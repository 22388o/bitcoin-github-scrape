[
  {
    "sha": "b229ad9a5a183867921440b4b3a86b84b10c96d3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMjI5YWQ5YTVhMTgzODY3OTIxNDQwYjRiM2E4NmI4NGIxMGM5NmQz",
    "commit": {
      "author": {
        "name": "globaltoken",
        "email": "globaltoken@users.noreply.github.com",
        "date": "2017-06-09T10:36:27Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2017-06-09T10:36:27Z"
      },
      "message": "Merge pull request #2 from bitcoin/master\n\nMerging 0.14 Bitcoin",
      "tree": {
        "sha": "932fa2f0813c0ba10963efa140ee65451043a005",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/932fa2f0813c0ba10963efa140ee65451043a005"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b229ad9a5a183867921440b4b3a86b84b10c96d3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b229ad9a5a183867921440b4b3a86b84b10c96d3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b229ad9a5a183867921440b4b3a86b84b10c96d3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b229ad9a5a183867921440b4b3a86b84b10c96d3/comments",
    "author": {
      "login": "globaltoken",
      "id": 24831016,
      "node_id": "MDQ6VXNlcjI0ODMxMDE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/24831016?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/globaltoken",
      "html_url": "https://github.com/globaltoken",
      "followers_url": "https://api.github.com/users/globaltoken/followers",
      "following_url": "https://api.github.com/users/globaltoken/following{/other_user}",
      "gists_url": "https://api.github.com/users/globaltoken/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/globaltoken/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/globaltoken/subscriptions",
      "organizations_url": "https://api.github.com/users/globaltoken/orgs",
      "repos_url": "https://api.github.com/users/globaltoken/repos",
      "events_url": "https://api.github.com/users/globaltoken/events{/privacy}",
      "received_events_url": "https://api.github.com/users/globaltoken/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3192e5278abca7c1f3b4a2a7f77a0ce941c73985",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3192e5278abca7c1f3b4a2a7f77a0ce941c73985",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3192e5278abca7c1f3b4a2a7f77a0ce941c73985"
      },
      {
        "sha": "29f80cd230c38d7e424810e986c160ddba9b53ac",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/29f80cd230c38d7e424810e986c160ddba9b53ac",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/29f80cd230c38d7e424810e986c160ddba9b53ac"
      }
    ],
    "stats": {
      "total": 19372,
      "additions": 12021,
      "deletions": 7351
    },
    "files": [
      {
        "sha": "60c26dae8b89349b88d704dd7be7320ef8684b16",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -80,7 +80,6 @@ Bitcoin-Qt.app\n # Unit-tests\n Makefile.test\n bitcoin-qt_test\n-src/test/buildenv.py\n \n # Resources cpp\n qrc_*.cpp\n@@ -101,8 +100,7 @@ coverage_percent.txt\n linux-coverage-build\n linux-build\n win32-build\n-test/functional/config.ini\n-test/util/buildenv.py\n+test/config.ini\n test/cache/*\n \n !src/leveldb*/Makefile"
      },
      {
        "sha": "fcf4b082f1b57d0eda6a52108f61da7f39a42dc4",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -32,26 +32,24 @@ env:\n # bitcoind\n     - HOST=x86_64-unknown-linux-gnu PACKAGES=\"bc python3-zmq\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports CPPFLAGS=-DDEBUG_LOCKORDER\"\n # No wallet\n-    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3 xvfb\" DEP_OPTS=\"NO_WALLET=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n+    - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3\" DEP_OPTS=\"NO_WALLET=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\"\n # Cross-Mac\n     - HOST=x86_64-apple-darwin11 PACKAGES=\"cmake imagemagick libcap-dev librsvg2-bin libz-dev libbz2-dev libtiff-tools python-dev\" BITCOIN_CONFIG=\"--enable-gui --enable-reduce-exports\" OSX_SDK=10.11 GOAL=\"deploy\"\n \n before_install:\n     - export PATH=$(echo $PATH | tr ':' \"\\n\" | sed '/\\/opt\\/python/d' | tr \"\\n\" \":\" | sed \"s|::|:|g\")\n install:\n-    - if [ -n \"$PPA\" ]; then travis_retry sudo add-apt-repository \"$PPA\" -y; fi\n     - if [ -n \"$DPKG_ADD_ARCH\" ]; then sudo dpkg --add-architecture \"$DPKG_ADD_ARCH\" ; fi\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get update; fi\n     - if [ -n \"$PACKAGES\" ]; then travis_retry sudo apt-get install --no-install-recommends --no-upgrade -qq $PACKAGES; fi\n before_script:\n+    - if [ \"$TRAVIS_EVENT_TYPE\" = \"pull_request\" ]; then contrib/devtools/commit-script-check.sh $TRAVIS_COMMIT_RANGE; fi\n     - unset CC; unset CXX\n     - if [ \"$CHECK_DOC\" = 1 ]; then contrib/devtools/check-doc.py; fi\n     - mkdir -p depends/SDKs depends/sdk-sources\n     - if [ -n \"$OSX_SDK\" -a ! -f depends/sdk-sources/MacOSX${OSX_SDK}.sdk.tar.gz ]; then curl --location --fail $SDK_URL/MacOSX${OSX_SDK}.sdk.tar.gz -o depends/sdk-sources/MacOSX${OSX_SDK}.sdk.tar.gz; fi\n     - if [ -n \"$OSX_SDK\" -a -f depends/sdk-sources/MacOSX${OSX_SDK}.sdk.tar.gz ]; then tar -C depends/SDKs -xf depends/sdk-sources/MacOSX${OSX_SDK}.sdk.tar.gz; fi\n     - make $MAKEJOBS -C depends HOST=$HOST $DEP_OPTS\n-    # Start xvfb if needed, as documented at https://docs.travis-ci.com/user/gui-and-headless-browsers/#Using-xvfb-to-Run-Tests-That-Require-a-GUI\n-    - if [ \"$RUN_TESTS\" = \"true\" -a \"${DEP_OPTS#*NO_QT=1}\" = \"$DEP_OPTS\" ]; then export DISPLAY=:99.0; /sbin/start-stop-daemon --start --pidfile /tmp/custom_xvfb_99.pid --make-pidfile --background --exec /usr/bin/Xvfb -- :99 -ac; fi\n script:\n     - if [ \"$CHECK_DOC\" = 1 -a \"$TRAVIS_REPO_SLUG\" = \"bitcoin/bitcoin\" -a \"$TRAVIS_PULL_REQUEST\" = \"false\" ]; then while read LINE; do travis_retry gpg --keyserver hkp://subset.pool.sks-keyservers.net --recv-keys $LINE; done < contrib/verify-commits/trusted-keys; fi\n     - if [ \"$CHECK_DOC\" = 1 -a \"$TRAVIS_REPO_SLUG\" = \"bitcoin/bitcoin\" -a \"$TRAVIS_PULL_REQUEST\" = \"false\" ]; then git fetch --unshallow; fi\n@@ -69,8 +67,9 @@ script:\n     - ./configure --cache-file=../config.cache $BITCOIN_CONFIG_ALL $BITCOIN_CONFIG || ( cat config.log && false)\n     - make $MAKEJOBS $GOAL || ( echo \"Build failure. Verbose build follows.\" && make $GOAL V=1 ; false )\n     - export LD_LIBRARY_PATH=$TRAVIS_BUILD_DIR/depends/$HOST/lib\n-    - if [ \"$RUN_TESTS\" = \"true\" ]; then make $MAKEJOBS check VERBOSE=1; fi\n-    - if [ \"$RUN_TESTS\" = \"true\" ]; then test/functional/test_runner.py --coverage; fi\n+    - if [ \"$RUN_TESTS\" = \"true\" ]; then travis_wait 30 make $MAKEJOBS check VERBOSE=1; fi\n+    - if [ \"$TRAVIS_EVENT_TYPE\" = \"cron\" ]; then extended=\"--extended --exclude pruning\"; fi\n+    - if [ \"$RUN_TESTS\" = \"true\" ]; then test/functional/test_runner.py --coverage --quiet ${extended}; fi\n after_script:\n     - echo $TRAVIS_COMMIT_RANGE\n     - echo $TRAVIS_COMMIT_LOG"
      },
      {
        "sha": "f5d63517b134d0bc206957fb8b4b7a714851c01d",
        "filename": "CONTRIBUTING.md",
        "status": "modified",
        "additions": 36,
        "deletions": 5,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/CONTRIBUTING.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/CONTRIBUTING.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/CONTRIBUTING.md?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -37,8 +37,8 @@ fixes or code moves with actual code changes.\n \n Commit messages should be verbose by default consisting of a short subject line\n (50 chars max), a blank line and detailed explanatory text as separate\n-paragraph(s); unless the title alone is self-explanatory (like \"Corrected typo\n-in init.cpp\") then a single title line is sufficient. Commit messages should be\n+paragraph(s), unless the title alone is self-explanatory (like \"Corrected typo\n+in init.cpp\") in which case a single title line is sufficient. Commit messages should be\n helpful to people reading your code in the future, so explain the reasoning for\n your decisions. Further explanation [here](http://chris.beams.io/posts/git-commit/).\n \n@@ -130,7 +130,7 @@ pull requests which attempt to do too much, are overly large, or overly complex\n as this makes review difficult.\n \n \n-###Features\n+### Features\n \n When adding a new feature, thought must be given to the long term technical debt\n and maintenance that feature may require after inclusion. Before proposing a new\n@@ -139,7 +139,7 @@ maintain it (including bug fixing). If features get orphaned with no maintainer\n in the future, they may be removed by the Repository Maintainer.\n \n \n-###Refactoring\n+### Refactoring\n \n Refactoring is a necessary part of any software project's evolution. The\n following guidelines cover refactoring pull requests for the project.\n@@ -187,7 +187,7 @@ other kinds of patches because of increased peer review and consensus building\n requirements.\n \n \n-###Peer Review\n+### Peer Review\n \n Anyone may participate in peer review which is expressed by comments in the pull\n request. Typically reviewers will review the code for obvious errors, as well as\n@@ -225,6 +225,37 @@ discussed extensively on the mailing list and IRC, be accompanied by a widely\n discussed BIP and have a generally widely perceived technical consensus of being\n a worthwhile change based on the judgement of the maintainers.\n \n+### Finding Reviewers\n+\n+As most reviewers are themselves developers with their own projects, the review\n+process can be quite lengthy, and some amount of patience is required. If you find\n+that you've been waiting for a pull request to be given attention for several\n+months, there may be a number of reasons for this, some of which you can do something\n+about:\n+\n+  - It may be because of a feature freeze due to an upcoming release. During this time,\n+    only bug fixes are taken into consideration. If your pull request is a new feature,\n+    it will not be prioritized until the release is over. Wait for release.\n+  - It may be because the changes you are suggesting do not appeal to people. Rather than\n+    nits and critique, which require effort and means they care enough to spend time on your\n+    contribution, thundering silence is a good sign of widespread (mild) dislike of a given change\n+    (because people don't assume *others* won't actually like the proposal). Don't take\n+    that personally, though! Instead, take another critical look at what you are suggesting\n+    and see if it: changes too much, is too broad, doesn't adhere to the\n+    [developer notes](doc/developer-notes.md), is dangerous or insecure, is messily written, etc.\n+    Identify and address any of the issues you find. Then ask e.g. on IRC if someone could give\n+    their opinion on the concept itself.\n+  - It may be because your code is too complex for all but a few people. And those people\n+    may not have realized your pull request even exists. A great way to find people who\n+    are qualified and care about the code you are touching is the\n+    [Git Blame feature](https://help.github.com/articles/tracing-changes-in-a-file/). Simply\n+    find the person touching the code you are touching before you and see if you can find\n+    them and give them a nudge. Don't be incessant about the nudging though.\n+  - Finally, if all else fails, ask on IRC or elsewhere for someone to give your pull request\n+    a look. If you think you've been waiting an unreasonably long amount of time (month+) for\n+    no particular reason (few lines changed, etc), this is totally fine. Try to return the favor\n+    when someone else is asking for feedback on their code, and universe balances out.\n+\n \n Release Policy\n --------------"
      },
      {
        "sha": "40114a551fb87bfb64122c8b3f3bf3e6b95afc61",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -76,9 +76,6 @@ $(BITCOIN_WIN_INSTALLER): all-recursive\n \t  echo error: could not build $@\n \t@echo built $@\n \n-$(if $(findstring src/,$(MAKECMDGOALS)),$(MAKECMDGOALS), none): FORCE\n-\t$(MAKE) -C src $(patsubst src/%,%,$@)\n-\n $(OSX_APP)/Contents/PkgInfo:\n \t$(MKDIR_P) $(@D)\n \t@echo \"APPL????\" > $@\n@@ -226,7 +223,6 @@ dist_noinst_SCRIPTS = autogen.sh\n EXTRA_DIST = $(top_srcdir)/share/genbuild.sh test/functional/test_runner.py test/functional $(DIST_CONTRIB) $(DIST_DOCS) $(WINDOWS_PACKAGING) $(OSX_PACKAGING) $(BIN_CHECKS)\n \n EXTRA_DIST += \\\n-    test/util/bctest.py \\\n     test/util/bitcoin-util-test.py \\\n     test/util/data/bitcoin-util-test.json \\\n     test/util/data/blanktxv1.hex \\\n@@ -280,9 +276,6 @@ EXTRA_DIST += \\\n \n CLEANFILES = $(OSX_DMG) $(BITCOIN_WIN_INSTALLER)\n \n-# This file is problematic for out-of-tree builds if it exists.\n-DISTCLEANFILES = test/util/buildenv.pyc\n-\n .INTERMEDIATE: $(COVERAGE_INFO)\n \n DISTCHECK_CONFIGURE_FLAGS = --enable-man"
      },
      {
        "sha": "1b339559fc1a46ace208c24245ab95aad46d5347",
        "filename": "build-aux/m4/bitcoin_qt.m4",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/build-aux/m4/bitcoin_qt.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/build-aux/m4/bitcoin_qt.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_qt.m4?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -130,6 +130,8 @@ AC_DEFUN([BITCOIN_QT_CONFIGURE],[\n       if test \"x$bitcoin_cv_need_acc_widget\" = \"xyes\"; then\n         _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(AccessibleFactory)], [-lqtaccessiblewidgets])\n       fi\n+      _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QMinimalIntegrationPlugin)],[-lqminimal])\n+      AC_DEFINE(QT_QPA_PLATFORM_MINIMAL, 1, [Define this symbol if the minimal qt platform exists])\n       if test x$TARGET_OS = xwindows; then\n         _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin)],[-lqwindows])\n         AC_DEFINE(QT_QPA_PLATFORM_WINDOWS, 1, [Define this symbol if the qt platform is windows])"
      },
      {
        "sha": "160be397ba5fab0b435baffc4df678c08cfb785c",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 19,
        "deletions": 6,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -227,7 +227,6 @@ if test \"x$CXXFLAGS_overridden\" = \"xno\"; then\n   AX_CHECK_COMPILE_FLAG([-Wformat],[CXXFLAGS=\"$CXXFLAGS -Wformat\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wvla],[CXXFLAGS=\"$CXXFLAGS -Wvla\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wformat-security],[CXXFLAGS=\"$CXXFLAGS -Wformat-security\"],,[[$CXXFLAG_WERROR]])\n-  AX_CHECK_COMPILE_FLAG([-Wshadow],[CXXFLAGS=\"$CXXFLAGS -Wshadow\"],,[[$CXXFLAG_WERROR]])\n \n   ## Some compilers (gcc) ignore unknown -Wno-* options, but warn about all\n   ## unknown options if any other warning is produced. Test the -Wfoo case, and\n@@ -236,6 +235,7 @@ if test \"x$CXXFLAGS_overridden\" = \"xno\"; then\n   AX_CHECK_COMPILE_FLAG([-Wself-assign],[CXXFLAGS=\"$CXXFLAGS -Wno-self-assign\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wunused-local-typedef],[CXXFLAGS=\"$CXXFLAGS -Wno-unused-local-typedef\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wdeprecated-register],[CXXFLAGS=\"$CXXFLAGS -Wno-deprecated-register\"],,[[$CXXFLAG_WERROR]])\n+  AX_CHECK_COMPILE_FLAG([-Wimplicit-fallthrough],[CXXFLAGS=\"$CXXFLAGS -Wno-implicit-fallthrough\"],,[[$CXXFLAG_WERROR]])\n fi\n CPPFLAGS=\"$CPPFLAGS -DHAVE_BUILD_INFO -D__STDC_FORMAT_MACROS\"\n \n@@ -550,6 +550,8 @@ AC_CHECK_DECLS([bswap_16, bswap_32, bswap_64],,,\n                  #include <byteswap.h>\n                  #endif])\n \n+AC_CHECK_DECLS([__builtin_clz, __builtin_clzl, __builtin_clzll])\n+\n dnl Check for MSG_NOSIGNAL\n AC_MSG_CHECKING(for MSG_NOSIGNAL)\n AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <sys/socket.h>]],\n@@ -574,6 +576,14 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <malloc.h>]],\n  [ AC_MSG_RESULT(no)]\n )\n \n+dnl Check for mallopt(M_ARENA_MAX) (to set glibc arenas)\n+AC_MSG_CHECKING(for mallopt M_ARENA_MAX)\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[#include <malloc.h>]],\n+ [[ mallopt(M_ARENA_MAX, 1); ]])],\n+ [ AC_MSG_RESULT(yes); AC_DEFINE(HAVE_MALLOPT_ARENA_MAX, 1,[Define this symbol if you have mallopt with M_ARENA_MAX]) ],\n+ [ AC_MSG_RESULT(no)]\n+)\n+\n AC_MSG_CHECKING([for visibility attribute])\n AC_LINK_IFELSE([AC_LANG_SOURCE([\n   int foo_def( void ) __attribute__((visibility(\"default\")));\n@@ -669,6 +679,10 @@ AX_BOOST_PROGRAM_OPTIONS\n AX_BOOST_THREAD\n AX_BOOST_CHRONO\n \n+dnl Boost 1.56 through 1.62 allow using std::atomic instead of its own atomic\n+dnl counter implementations. In 1.63 and later the std::atomic approach is default.\n+m4_pattern_allow(DBOOST_AC_USE_STD_ATOMIC) dnl otherwise it's treated like a macro\n+BOOST_CPPFLAGS=\"-DBOOST_SP_USE_STD_ATOMIC -DBOOST_AC_USE_STD_ATOMIC $BOOST_CPPFLAGS\"\n \n if test x$use_reduce_exports = xyes; then\n   AC_MSG_CHECKING([for working boost reduced exports])\n@@ -1147,12 +1161,11 @@ AC_SUBST(EVENT_PTHREADS_LIBS)\n AC_SUBST(ZMQ_LIBS)\n AC_SUBST(PROTOBUF_LIBS)\n AC_SUBST(QR_LIBS)\n-AC_CONFIG_FILES([Makefile src/Makefile doc/man/Makefile share/setup.nsi share/qt/Info.plist test/functional/config.ini])\n-AC_CONFIG_FILES([test/util/buildenv.py],[chmod +x test/util/buildenv.py])\n+AC_CONFIG_FILES([Makefile src/Makefile doc/man/Makefile share/setup.nsi share/qt/Info.plist test/config.ini])\n AC_CONFIG_FILES([contrib/devtools/split-debug.sh],[chmod +x contrib/devtools/split-debug.sh])\n+AC_CONFIG_FILES([doc/Doxyfile])\n AC_CONFIG_LINKS([test/functional/test_runner.py:test/functional/test_runner.py])\n AC_CONFIG_LINKS([test/util/bitcoin-util-test.py:test/util/bitcoin-util-test.py])\n-AC_CONFIG_LINKS([test/util/bctest.py:test/util/bctest.py])\n \n dnl boost's m4 checks do something really nasty: they export these vars. As a\n dnl result, they leak into secp256k1's configure and crazy things happen.\n@@ -1200,8 +1213,8 @@ esac\n dnl Replace the BUILDDIR path with the correct Windows path if compiling on Native Windows\n case ${OS} in\n    *Windows*)\n-     sed  's/BUILDDIR=\"\\/\\([[a-z]]\\)/BUILDDIR=\"\\1:/'  test/functional/config.ini > test/functional/config-2.ini\n-     mv test/functional/config-2.ini test/functional/config.ini\n+     sed  's/BUILDDIR=\"\\/\\([[a-z]]\\)/BUILDDIR=\"\\1:/'  test/config.ini > test/config-2.ini\n+     mv test/config-2.ini test/config.ini\n    ;;\n esac\n "
      },
      {
        "sha": "33dab9b6388890a5ba10e47fcd3b833bb0875dc4",
        "filename": "contrib/debian/changelog",
        "status": "modified",
        "additions": 122,
        "deletions": 3,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/debian/changelog",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/debian/changelog",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/changelog?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,3 +1,122 @@\n+bitcoin (0.14.1-trusty4) trusty; urgency=medium\n+\n+  * Re-enable UPnP support.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Fri, 05 May 2017 13:28:00 -0400\n+\n+bitcoin (0.14.1-trusty3) trusty; urgency=medium\n+\n+  * Build with qt5 if we are on a non-Ubuntu (ie non-Unity) distro.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Thu, 04 May 2017 17:13:00 -0400\n+\n+bitcoin (0.14.1-trusty2) trusty; urgency=medium\n+\n+  * Bump minimum boost version in deps.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Thu, 04 May 2017 17:12:00 -0400\n+\n+bitcoin (0.14.1-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Sat, 22 Apr 2017 17:10:00 -0400\n+\n+bitcoin (0.14.0-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Wed, 08 Mar 2017 10:30:00 -0500\n+\n+bitcoin (0.13.2-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Thu, 05 Jan 2017 09:59:00 -0500\n+\n+bitcoin (0.13.1-trusty2) trusty; urgency=medium\n+\n+  * Revert to Qt4, due to https://github.com/bitcoin/bitcoin/issues/9038\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Mon, 31 Oct 2016 11:16:00 -0400\n+\n+bitcoin (0.13.1-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+  * Backport updated bitcoin-qt.desktop from upstream master\n+  * Add zmq dependency\n+  * Switch to Qt5 (breaks precise, but that was already broken by C++11)\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Thu, 27 Oct 2016 17:32:00 -0400\n+\n+bitcoin (0.13.0-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Sun, 04 Sep 2016 22:09:00 -0400\n+\n+bitcoin (0.12.1-trusty1) trusty; urgency=medium\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Mon, 18 Apr 2016 14:26:00 -0700\n+\n+bitcoin (0.12.0-trusty6) trusty; urgency=medium\n+\n+  * Fix program-options dep.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Fri, 25 Mar 2016 21:41:00 -0700\n+\n+bitcoin (0.12.0-trusty5) trusty; urgency=medium\n+\n+  * Test explicit --with-gui\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Tue, 23 Feb 2015 23:25:00 -0800\n+\n+bitcoin (0.12.0-trusty4) trusty; urgency=medium\n+\n+  * Fix libevent-dev dep.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Tue, 23 Feb 2015 23:25:00 -0800\n+\n+bitcoin (0.12.0-trusty3) trusty; urgency=medium\n+\n+  * Fix precise boost dep.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Tue, 23 Feb 2015 19:55:00 -0800\n+\n+bitcoin (0.12.0-trusty2) trusty; urgency=medium\n+\n+  * Fix libevent dep.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Tue, 23 Feb 2015 19:53:00 -0800\n+\n+bitcoin (0.12.0-trusty1) trusty; urgency=medium\n+\n+  * New upstream release\n+  * Various updates to contrib/debian were merged, a few were not\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Tue, 23 Feb 2015 19:29:00 -0800\n+\n+bitcoin (0.11.2-trusty1) trusty; urgency=low\n+\n+  * New upstream release.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Fri, 13 Nov 2015 18:39:00 -0800\n+\n+bitcoin (0.11.1-trusty2) trusty; urgency=low\n+\n+  * Remove minupnpc builddep.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Wed, 14 Oct 2015 23:06:00 -1000\n+\n+bitcoin (0.11.1-trusty1) trusty; urgency=high\n+\n+  * New upstream release.\n+  * Disable all UPnP support.\n+\n+ -- Matt Corallo (BlueMatt) <matt@mattcorallo.com>  Wed, 14 Oct 2015 13:57:00 -1000\n+\n bitcoin (0.11.0-precise1) precise; urgency=medium\n \n   * New upstream release.\n@@ -179,7 +298,7 @@ bitcoin (0.5.3-natty0) natty; urgency=low\n bitcoin (0.5.2-natty1) natty; urgency=low\n \n   * Remove mentions on anonymity in package descriptions and manpage.\n-    These should never have been there, bitcoin isn't anonymous without\n+    These should never have been there, bitcoin isnt anonymous without\n     a ton of work that virtually no users will ever be willing and\n     capable of doing\n \n@@ -220,7 +339,7 @@ bitcoin (0.5.0~rc1-natty1) natty; urgency=low\n \n   * Add test_bitcoin to build test\n   * Fix clean\n-  * Remove unnecessary build-dependancies\n+  * Remove uneccessary build-dependancies\n \n  -- Matt Corallo <matt@bluematt.me>  Wed, 26 Oct 2011 14:37:18 -0400\n \n@@ -380,7 +499,7 @@ bitcoin (0.3.20.01~dfsg-1) unstable; urgency=low\n \n bitcoin (0.3.19~dfsg-6) unstable; urgency=low\n \n-  * Fix override aggressive optimizations.\n+  * Fix override agressive optimizations.\n   * Fix tighten build-dependencies to really fit backporting to Lenny:\n     + Add fallback build-dependency on libdb4.6++-dev.\n     + Tighten unversioned Boost build-dependencies to recent versions,"
      },
      {
        "sha": "0d6ad25e249fe9b7b89a738aba89c2ca1d495587",
        "filename": "contrib/debian/control",
        "status": "modified",
        "additions": 29,
        "deletions": 26,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/debian/control",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/debian/control",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/control?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,27 +1,30 @@\n Source: bitcoin\n Section: utils\n Priority: optional\n-Maintainer: Jonas Smedegaard <dr@jones.dk>\n-Uploaders: Micah Anderson <micah@debian.org>\n+Maintainer: Matt Corallo <matt@mattcorallo.com>\n+Uploaders: Matt Corallo <matt@mattcorallo.com>\n Build-Depends: debhelper,\n  devscripts,\n  automake,\n  libtool,\n  bash-completion,\n- libboost-system-dev (>> 1.35) | libboost-system1.35-dev,\n  libdb4.8++-dev,\n  libssl-dev,\n  pkg-config,\n- libminiupnpc8-dev | libminiupnpc-dev (>> 1.6),\n- libboost-filesystem-dev (>> 1.35) | libboost-filesystem1.35-dev,\n- libboost-program-options-dev (>> 1.35) | libboost-program-options1.35-dev,\n- libboost-thread-dev (>> 1.35) | libboost-thread1.35-dev,\n- libboost-test-dev (>> 1.35) | libboost-test1.35-dev,\n- qt4-qmake,\n- libqt4-dev,\n+ libevent-dev,\n+ libboost-system1.48-dev | libboost-system-dev (>> 1.47),\n+ libboost-filesystem1.48-dev | libboost-filesystem-dev (>> 1.47),\n+ libboost-program-options1.48-dev | libboost-program-options-dev (>> 1.47),\n+ libboost-thread1.48-dev | libboost-thread-dev (>> 1.47),\n+ libboost-test1.48-dev | libboost-test-dev (>> 1.47),\n+ libboost-chrono1.48-dev | libboost-chrono-dev (>> 1.47),\n+ libminiupnpc8-dev | libminiupnpc-dev,\n+ qt4-qmake, libqt4-dev,\n+ qttools5-dev-tools, qttools5-dev,\n  libqrencode-dev,\n  libprotobuf-dev, protobuf-compiler,\n- python\n+ python,\n+ libzmq3-dev\n Standards-Version: 3.9.2\n Homepage: https://bitcoincore.org/\n Vcs-Git: git://github.com/bitcoin/bitcoin.git\n@@ -31,11 +34,11 @@ Package: bitcoind\n Architecture: any\n Depends: ${shlibs:Depends}, ${misc:Depends}\n Description: peer-to-peer network based digital currency - daemon\n- Bitcoin is an experimental new digital currency that enables instant\n- payments to anyone, anywhere in the world. Bitcoin uses peer-to-peer\n- technology to operate with no central authority: managing transactions\n- and issuing money are carried out collectively by the network. Bitcoin Core\n- is the name of the open source software which enables the use of this currency.\n+ Bitcoin is a free open source peer-to-peer electronic cash system that\n+ is completely decentralized, without the need for a central server or\n+ trusted parties.  Users hold the crypto keys to their own money and\n+ transact directly with each other, with the help of a P2P network to\n+ check for double-spending.\n  .\n  This package provides the daemon, bitcoind, and the CLI tool\n  bitcoin-cli to interact with the daemon.\n@@ -44,23 +47,23 @@ Package: bitcoin-qt\n Architecture: any\n Depends: ${shlibs:Depends}, ${misc:Depends}\n Description: peer-to-peer network based digital currency - Qt GUI\n- Bitcoin is an experimental new digital currency that enables instant\n- payments to anyone, anywhere in the world. Bitcoin uses peer-to-peer\n- technology to operate with no central authority: managing transactions\n- and issuing money are carried out collectively by the network. Bitcoin Core\n- is the name of the open source software which enables the use of this currency.\n+ Bitcoin is a free open source peer-to-peer electronic cash system that\n+ is completely decentralized, without the need for a central server or\n+ trusted parties.  Users hold the crypto keys to their own money and\n+ transact directly with each other, with the help of a P2P network to\n+ check for double-spending.\n  .\n  This package provides Bitcoin-Qt, a GUI for Bitcoin based on Qt.\n \n Package: bitcoin-tx\n Architecture: any\n Depends: ${shlibs:Depends}, ${misc:Depends}\n Description: peer-to-peer digital currency - standalone transaction tool\n- Bitcoin is an experimental new digital currency that enables instant\n- payments to anyone, anywhere in the world. Bitcoin uses peer-to-peer\n- technology to operate with no central authority: managing transactions\n- and issuing money are carried out collectively by the network. Bitcoin Core\n- is the name of the open source software which enables the use of this currency.\n+ Bitcoin is a free open source peer-to-peer electronic cash system that\n+ is completely decentralized, without the need for a central server or\n+ trusted parties.  Users hold the crypto keys to their own money and\n+ transact directly with each other, with the help of a P2P network to\n+ check for double-spending.\n  .\n  This package provides bitcoin-tx, a command-line transaction creation\n  tool which can be used without a bitcoin daemon.  Some means of"
      },
      {
        "sha": "1029a51073e88b44b76b8a3246bc74ad9795781d",
        "filename": "contrib/debian/examples/bitcoin.conf",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/debian/examples/bitcoin.conf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/debian/examples/bitcoin.conf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/examples/bitcoin.conf?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -131,6 +131,13 @@\n # be validated sooner.\n #paytxfee=0.00\n \n+# Enable pruning to reduce storage requirements by deleting old blocks. \n+# This mode is incompatible with -txindex and -rescan.\n+# 0 = default (no pruning).\n+# 1 = allows manual pruning via RPC.\n+# >=550 = target to stay under in MiB. \n+#prune=550\n+\n # User interface options\n \n # Start Bitcoin minimized"
      },
      {
        "sha": "6885e3852126f17e910cbe4236b4f773a1fd8de6",
        "filename": "contrib/debian/rules",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/debian/rules",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/debian/rules",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/rules?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -12,10 +12,12 @@ override_dh_auto_clean:\n \tif [ -f Makefile ]; then $(MAKE) distclean; fi\n \trm -rf Makefile.in aclocal.m4 configure src/Makefile.in src/bitcoin-config.h.in src/build-aux src/qt/Makefile.in src/qt/test/Makefile.in src/test/Makefile.in\n \n+QT=$(shell dpkg-vendor --derives-from Ubuntu && echo qt4 || echo qt5)\n+\n # Yea, autogen should be run on the source archive, but I like doing git archive\n override_dh_auto_configure:\n \t./autogen.sh\n-\t./configure\n+\t./configure --with-gui=$(QT)\n \n override_dh_auto_test:\n \tmake check"
      },
      {
        "sha": "add4bb4883d41b495109672df6d44ebe9691e1d1",
        "filename": "contrib/devtools/commit-script-check.sh",
        "status": "added",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/devtools/commit-script-check.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/devtools/commit-script-check.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/commit-script-check.sh?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -0,0 +1,39 @@\n+#!/bin/sh\n+# Copyright (c) 2017 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+# This simple script checks for commits beginning with: scripted-diff:\n+# If found, looks for a script between the lines -BEGIN VERIFY SCRIPT- and\n+# -END VERIFY SCRIPT-. If no ending is found, it reads until the end of the\n+# commit message.\n+\n+# The resulting script should exactly transform the previous commit into the current\n+# one. Any remaining diff signals an error.\n+\n+if test \"x$1\" = \"x\"; then\n+    echo \"Usage: $0 <commit>...\"\n+    exit 1\n+fi\n+\n+RET=0\n+PREV_BRANCH=`git name-rev --name-only HEAD`\n+PREV_HEAD=`git rev-parse HEAD`\n+for i in `git rev-list --reverse $1`; do\n+    git rev-list -n 1 --pretty=\"%s\" $i | grep -q \"^scripted-diff:\" || continue\n+    git checkout --quiet $i^ || exit\n+    SCRIPT=\"`git rev-list --format=%b -n1 $i | sed '/^-BEGIN VERIFY SCRIPT-$/,/^-END VERIFY SCRIPT-$/{//!b};d'`\"\n+    if test \"x$SCRIPT\" = \"x\"; then\n+        echo \"Error: missing script for: $i\"\n+        echo \"Failed\"\n+        RET=1\n+    else\n+        echo \"Running script for: $i\"\n+        echo \"$SCRIPT\"\n+        eval \"$SCRIPT\"\n+        git --no-pager diff --exit-code $i && echo \"OK\" || (echo \"Failed\"; false) || RET=1\n+    fi\n+    git reset --quiet --hard HEAD\n+done\n+git checkout --quiet $PREV_BRANCH 2>/dev/null || git checkout --quiet $PREV_HEAD\n+exit $RET"
      },
      {
        "sha": "e9816f7d1916dd047e134eebba225d06f71e4432",
        "filename": "contrib/devtools/github-merge.py",
        "status": "modified",
        "additions": 24,
        "deletions": 28,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/devtools/github-merge.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/devtools/github-merge.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/github-merge.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python3\n-# Copyright (c) 2016 The Bitcoin Core developers\n+# Copyright (c) 2016-2017 Bitcoin Core Developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -127,6 +127,9 @@ def tree_sha512sum(commit='HEAD'):\n         raise IOError('Non-zero return value executing git cat-file')\n     return overall.hexdigest()\n \n+def print_merge_details(pull, title, branch, base_branch, head_branch):\n+    print('%s#%s%s %s %sinto %s%s' % (ATTR_RESET+ATTR_PR,pull,ATTR_RESET,title,ATTR_RESET+ATTR_PR,branch,ATTR_RESET))\n+    subprocess.check_call([GIT,'log','--graph','--topo-order','--pretty=format:'+COMMIT_FORMAT,base_branch+'..'+head_branch])\n \n def parse_arguments():\n     epilog = '''\n@@ -171,7 +174,7 @@ def main():\n     info = retrieve_pr_info(repo,pull)\n     if info is None:\n         exit(1)\n-    title = info['title']\n+    title = info['title'].strip()\n     # precedence order for destination branch argument:\n     #   - command line argument\n     #   - githubmerge.branch setting\n@@ -256,8 +259,7 @@ def main():\n             printf(\"ERROR: Cannot update message.\",file=stderr)\n             exit(4)\n \n-        print('%s#%s%s %s %sinto %s%s' % (ATTR_RESET+ATTR_PR,pull,ATTR_RESET,title,ATTR_RESET+ATTR_PR,branch,ATTR_RESET))\n-        subprocess.check_call([GIT,'log','--graph','--topo-order','--pretty=format:'+COMMIT_FORMAT,base_branch+'..'+head_branch])\n+        print_merge_details(pull, title, branch, base_branch, head_branch)\n         print()\n \n         # Run test command if configured.\n@@ -276,12 +278,6 @@ def main():\n                     print(\"Difference with github ignored.\",file=stderr)\n                 else:\n                     exit(6)\n-            reply = ask_prompt(\"Press 'd' to accept the diff.\")\n-            if reply.lower() == 'd':\n-                print(\"Diff accepted.\",file=stderr)\n-            else:\n-                print(\"ERROR: Diff rejected.\",file=stderr)\n-                exit(6)\n         else:\n             # Verify the result manually.\n             print(\"Dropping you on a shell so you can try building/testing the merged source.\",file=stderr)\n@@ -290,29 +286,25 @@ def main():\n             if os.path.isfile('/etc/debian_version'): # Show pull number on Debian default prompt\n                 os.putenv('debian_chroot',pull)\n             subprocess.call([BASH,'-i'])\n-            reply = ask_prompt(\"Type 'm' to accept the merge.\")\n-            if reply.lower() == 'm':\n-                print(\"Merge accepted.\",file=stderr)\n-            else:\n-                print(\"ERROR: Merge rejected.\",file=stderr)\n-                exit(7)\n \n         second_sha512 = tree_sha512sum()\n         if first_sha512 != second_sha512:\n             print(\"ERROR: Tree hash changed unexpectedly\",file=stderr)\n             exit(8)\n \n         # Sign the merge commit.\n-        reply = ask_prompt(\"Type 's' to sign off on the merge.\")\n-        if reply == 's':\n-            try:\n-                subprocess.check_call([GIT,'commit','-q','--gpg-sign','--amend','--no-edit'])\n-            except subprocess.CalledProcessError as e:\n-                print(\"Error signing, exiting.\",file=stderr)\n+        print_merge_details(pull, title, branch, base_branch, head_branch)\n+        while True:\n+            reply = ask_prompt(\"Type 's' to sign off on the above merge, or 'x' to reject and exit.\").lower()\n+            if reply == 's':\n+                try:\n+                    subprocess.check_call([GIT,'commit','-q','--gpg-sign','--amend','--no-edit'])\n+                    break\n+                except subprocess.CalledProcessError as e:\n+                    print(\"Error while signing, asking again.\",file=stderr)\n+            elif reply == 'x':\n+                print(\"Not signing off on merge, exiting.\",file=stderr)\n                 exit(1)\n-        else:\n-            print(\"Not signing off on merge, exiting.\",file=stderr)\n-            exit(1)\n \n         # Put the result in branch.\n         subprocess.check_call([GIT,'checkout','-q',branch])\n@@ -326,9 +318,13 @@ def main():\n         subprocess.call([GIT,'branch','-q','-D',local_merge_branch],stderr=devnull)\n \n     # Push the result.\n-    reply = ask_prompt(\"Type 'push' to push the result to %s, branch %s.\" % (host_repo,branch))\n-    if reply.lower() == 'push':\n-        subprocess.check_call([GIT,'push',host_repo,'refs/heads/'+branch])\n+    while True:\n+        reply = ask_prompt(\"Type 'push' to push the result to %s, branch %s, or 'x' to exit without pushing.\" % (host_repo,branch)).lower()\n+        if reply == 'push':\n+            subprocess.check_call([GIT,'push',host_repo,'refs/heads/'+branch])\n+            break\n+        elif reply == 'x':\n+            exit(1)\n \n if __name__ == '__main__':\n     main()"
      },
      {
        "sha": "3da8510cfbd70132954e678ee80f07f9c9e16234",
        "filename": "contrib/gitian-descriptors/gitian-linux.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/gitian-descriptors/gitian-linux.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/gitian-descriptors/gitian-linux.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-linux.yml?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -132,6 +132,7 @@ script: |\n   export PATH=${WRAP_DIR}:${PATH}\n \n   # Create the release tarball using (arbitrarily) the first host\n+  export GIT_DIR=\"$PWD/.git\"\n   ./autogen.sh\n   CONFIG_SITE=${BASEPREFIX}/`echo \"${HOSTS}\" | awk '{print $1;}'`/share/config.site ./configure --prefix=/\n   make dist"
      },
      {
        "sha": "206db7c19e751d414d51d4aaeb2e7bf6bff6288b",
        "filename": "contrib/gitian-descriptors/gitian-osx.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/gitian-descriptors/gitian-osx.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/gitian-descriptors/gitian-osx.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx.yml?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -101,6 +101,7 @@ script: |\n   export PATH=${WRAP_DIR}:${PATH}\n \n   # Create the release tarball using (arbitrarily) the first host\n+  export GIT_DIR=\"$PWD/.git\"\n   ./autogen.sh\n   CONFIG_SITE=${BASEPREFIX}/`echo \"${HOSTS}\" | awk '{print $1;}'`/share/config.site ./configure --prefix=/\n   make dist"
      },
      {
        "sha": "1d4d70494b0cc403649235133c72cbbbc8b2fba0",
        "filename": "contrib/gitian-descriptors/gitian-win.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/gitian-descriptors/gitian-win.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/gitian-descriptors/gitian-win.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-win.yml?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -116,6 +116,7 @@ script: |\n   export PATH=${WRAP_DIR}:${PATH}\n \n   # Create the release tarball using (arbitrarily) the first host\n+  export GIT_DIR=\"$PWD/.git\"\n   ./autogen.sh\n   CONFIG_SITE=${BASEPREFIX}/`echo \"${HOSTS}\" | awk '{print $1;}'`/share/config.site ./configure --prefix=/\n   make dist"
      },
      {
        "sha": "1a949f3c078bec11afeb991ccc28dac640481082",
        "filename": "contrib/init/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/init/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/init/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/README.md?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,12 +1,12 @@\n Sample configuration files for:\n-\n+```\n SystemD: bitcoind.service\n Upstart: bitcoind.conf\n OpenRC:  bitcoind.openrc\n          bitcoind.openrcconf\n CentOS:  bitcoind.init\n OS X:    org.bitcoin.bitcoind.plist\n-\n+```\n have been made available to assist packagers in creating node packages here.\n \n See doc/init.md for more information."
      },
      {
        "sha": "f70e25cb5fdd29e49de2c89b81bd92633e5b93df",
        "filename": "contrib/init/bitcoind.openrcconf",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/init/bitcoind.openrcconf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/init/bitcoind.openrcconf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/bitcoind.openrcconf?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -23,7 +23,7 @@\n #BITCOIND_NICE=0\n \n # Additional options (avoid -conf and -datadir, use flags above)\n-BITCOIND_OPTS=\"-disablewallet\"\n+#BITCOIND_OPTS=\"\"\n \n # The timeout in seconds OpenRC will wait for bitcoind to terminate\n # after a SIGTERM has been raised."
      },
      {
        "sha": "f2a2ab2768af4af6fe9f83d175864b327b093be7",
        "filename": "contrib/linearize/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/linearize/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/linearize/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/README.md?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -7,7 +7,8 @@ run using Python 3 but are compatible with Python 2.\n     $ ./linearize-hashes.py linearize.cfg > hashlist.txt\n \n Required configuration file settings for linearize-hashes:\n-* RPC: `rpcuser`, `rpcpassword`\n+* RPC: `datadir` (Required if `rpcuser` and `rpcpassword` are not specified)\n+* RPC: `rpcuser`, `rpcpassword` (Required if `datadir` is not specified)\n \n Optional config file setting for linearize-hashes:\n * RPC: `host`  (Default: `127.0.0.1`)"
      },
      {
        "sha": "d019b06b6c0afd7de90e078fa96cabea055b4ddc",
        "filename": "contrib/linearize/example-linearize.cfg",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/linearize/example-linearize.cfg",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/linearize/example-linearize.cfg",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/example-linearize.cfg?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,6 +1,7 @@\n # bitcoind RPC settings (linearize-hashes)\n rpcuser=someuser\n rpcpassword=somepassword\n+#datadir=~/.bitcoin\n host=127.0.0.1\n port=8332\n #port=18332"
      },
      {
        "sha": "db8eb7021e160259d798fd6a76a7d970b0a74bf1",
        "filename": "contrib/linearize/linearize-hashes.py",
        "status": "modified",
        "additions": 22,
        "deletions": 1,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/linearize/linearize-hashes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/linearize/linearize-hashes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/linearize-hashes.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -16,6 +16,8 @@\n import re\n import base64\n import sys\n+import os\n+import os.path\n \n settings = {}\n \n@@ -93,6 +95,14 @@ def get_block_hashes(settings, max_blocks_per_call=10000):\n \n \t\theight += num_blocks\n \n+def get_rpc_cookie():\n+\t# Open the cookie file\n+\twith open(os.path.join(os.path.expanduser(settings['datadir']), '.cookie'), 'r') as f:\n+\t\tcombined = f.readline()\n+\t\tcombined_split = combined.split(\":\")\n+\t\tsettings['rpcuser'] = combined_split[0]\n+\t\tsettings['rpcpassword'] = combined_split[1]\n+\n if __name__ == '__main__':\n \tif len(sys.argv) != 2:\n \t\tprint(\"Usage: linearize-hashes.py CONFIG-FILE\")\n@@ -122,8 +132,15 @@ def get_block_hashes(settings, max_blocks_per_call=10000):\n \t\tsettings['max_height'] = 313000\n \tif 'rev_hash_bytes' not in settings:\n \t\tsettings['rev_hash_bytes'] = 'false'\n+\n+\tuse_userpass = True\n+\tuse_datadir = False\n \tif 'rpcuser' not in settings or 'rpcpassword' not in settings:\n-\t\tprint(\"Missing username and/or password in cfg file\", file=stderr)\n+\t\tuse_userpass = False\n+\tif 'datadir' in settings and not use_userpass:\n+\t\tuse_datadir = True\n+\tif not use_userpass and not use_datadir:\n+\t\tprint(\"Missing datadir or username and/or password in cfg file\", file=stderr)\n \t\tsys.exit(1)\n \n \tsettings['port'] = int(settings['port'])\n@@ -133,4 +150,8 @@ def get_block_hashes(settings, max_blocks_per_call=10000):\n \t# Force hash byte format setting to be lowercase to make comparisons easier.\n \tsettings['rev_hash_bytes'] = settings['rev_hash_bytes'].lower()\n \n+\t# Get the rpc user and pass from the cookie if the datadir is set\n+\tif use_datadir:\n+\t\tget_rpc_cookie()\n+\n \tget_block_hashes(settings)"
      },
      {
        "sha": "23a568ad13aeb91d79e51de4283b0959c4baf027",
        "filename": "contrib/macdeploy/macdeployqtplus",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/macdeploy/macdeployqtplus",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/macdeploy/macdeployqtplus",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/macdeployqtplus?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -302,7 +302,6 @@ def copyFramework(framework, path, verbose):\n         if os.path.exists(fromContentsDir):\n             toContentsDir = os.path.join(path, framework.destinationVersionContentsDirectory)\n             shutil.copytree(fromContentsDir, toContentsDir, symlinks=True)\n-            contentslinkfrom = os.path.join(path, framework.destinationContentsDirectory)\n             if verbose >= 3:\n                 print(\"Copied Contents:\", fromContentsDir)\n                 print(\" to:\", toContentsDir)\n@@ -675,9 +674,8 @@ else:\n if verbose >= 2:\n     print(\"+ Installing qt.conf +\")\n \n-f = open(os.path.join(applicationBundle.resourcesPath, \"qt.conf\"), \"wb\")\n-f.write(qt_conf.encode())\n-f.close()\n+with open(os.path.join(applicationBundle.resourcesPath, \"qt.conf\"), \"wb\") as f:\n+    f.write(qt_conf.encode())\n \n # ------------------------------------------------\n "
      },
      {
        "sha": "139c03181fc806a9854a3ad307146883df0e47cf",
        "filename": "contrib/seeds/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/seeds/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/seeds/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/seeds/README.md?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -8,7 +8,7 @@ and remove old versions as necessary.\n \n The seeds compiled into the release are created from sipa's DNS seed data, like this:\n \n-    curl -s http://bitcoin.sipa.be/seeds.txt > seeds_main.txt\n+    curl -s http://bitcoin.sipa.be/seeds.txt.gz | gzip -dc > seeds_main.txt\n     python3 makeseeds.py < seeds_main.txt > nodes_main.txt\n     python3 generate-seeds.py . > ../../src/chainparamsseeds.h\n "
      },
      {
        "sha": "86366eb8e352278e7cfd46c028fe4cdff8d8da84",
        "filename": "contrib/testgen/gen_base58_test_vectors.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/testgen/gen_base58_test_vectors.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/testgen/gen_base58_test_vectors.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/testgen/gen_base58_test_vectors.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -13,7 +13,7 @@\n # Released under MIT License\n import os\n from itertools import islice\n-from base58 import b58encode, b58decode, b58encode_chk, b58decode_chk, b58chars\n+from base58 import b58encode_chk, b58decode_chk, b58chars\n import random\n from binascii import b2a_hex\n "
      },
      {
        "sha": "1cb7eec0c08660d1c2fa7deac45393292f549ea5",
        "filename": "contrib/zmq/zmq_sub3.4.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/zmq/zmq_sub3.4.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/contrib/zmq/zmq_sub3.4.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/zmq/zmq_sub3.4.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -57,7 +57,7 @@ def handle(self) :\n         msg = yield from self.zmqSubSocket.recv_multipart()\n         topic = msg[0]\n         body = msg[1]\n-        sequence = \"Unknown\";\n+        sequence = \"Unknown\"\n         if len(msg[-1]) == 4:\n           msgSequence = struct.unpack('<I', msg[-1])[-1]\n           sequence = str(msgSequence)"
      },
      {
        "sha": "69ed3e573bb3fa14476b0b539805850159eb23e0",
        "filename": "depends/config.guess",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/depends/config.guess",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/depends/config.guess",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/config.guess?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -2,7 +2,7 @@\n # Attempt to guess a canonical system name.\n #   Copyright 1992-2017 Free Software Foundation, Inc.\n \n-timestamp='2017-01-01'\n+timestamp='2017-03-05'\n \n # This file is free software; you can redistribute it and/or modify it\n # under the terms of the GNU General Public License as published by\n@@ -837,10 +837,11 @@ EOF\n \tUNAME_PROCESSOR=`/usr/bin/uname -p`\n \tcase ${UNAME_PROCESSOR} in\n \t    amd64)\n-\t\techo x86_64-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;\n-\t    *)\n-\t\techo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'` ;;\n+\t\tUNAME_PROCESSOR=x86_64 ;;\n+\t    i386)\n+\t\tUNAME_PROCESSOR=i586 ;;\n \tesac\n+\techo ${UNAME_PROCESSOR}-unknown-freebsd`echo ${UNAME_RELEASE}|sed -e 's/[-(].*//'`\n \texit ;;\n     i*:CYGWIN*:*)\n \techo ${UNAME_MACHINE}-pc-cygwin\n@@ -1343,6 +1344,9 @@ EOF\n     NSR-?:NONSTOP_KERNEL:*:*)\n \techo nsr-tandem-nsk${UNAME_RELEASE}\n \texit ;;\n+    NSX-?:NONSTOP_KERNEL:*:*)\n+\techo nsx-tandem-nsk${UNAME_RELEASE}\n+\texit ;;\n     *:NonStop-UX:*:*)\n \techo mips-compaq-nonstopux\n \texit ;;"
      },
      {
        "sha": "40ea5dfe1152f0fc5160879bb71bfe1fae2595f6",
        "filename": "depends/config.sub",
        "status": "modified",
        "additions": 11,
        "deletions": 3,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/depends/config.sub",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/depends/config.sub",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/config.sub?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -2,7 +2,7 @@\n # Configuration validation subroutine script.\n #   Copyright 1992-2017 Free Software Foundation, Inc.\n \n-timestamp='2017-01-01'\n+timestamp='2017-04-02'\n \n # This file is free software; you can redistribute it and/or modify it\n # under the terms of the GNU General Public License as published by\n@@ -263,7 +263,7 @@ case $basic_machine in\n \t| fido | fr30 | frv | ft32 \\\n \t| h8300 | h8500 | hppa | hppa1.[01] | hppa2.0 | hppa2.0[nw] | hppa64 \\\n \t| hexagon \\\n-\t| i370 | i860 | i960 | ia64 \\\n+\t| i370 | i860 | i960 | ia16 | ia64 \\\n \t| ip2k | iq2000 \\\n \t| k1om \\\n \t| le32 | le64 \\\n@@ -315,6 +315,7 @@ case $basic_machine in\n \t| ubicom32 \\\n \t| v850 | v850e | v850e1 | v850e2 | v850es | v850e2v3 \\\n \t| visium \\\n+\t| wasm32 \\\n \t| we32k \\\n \t| x86 | xc16x | xstormy16 | xtensa \\\n \t| z8k | z80)\n@@ -388,7 +389,7 @@ case $basic_machine in\n \t| h8300-* | h8500-* \\\n \t| hppa-* | hppa1.[01]-* | hppa2.0-* | hppa2.0[nw]-* | hppa64-* \\\n \t| hexagon-* \\\n-\t| i*86-* | i860-* | i960-* | ia64-* \\\n+\t| i*86-* | i860-* | i960-* | ia16-* | ia64-* \\\n \t| ip2k-* | iq2000-* \\\n \t| k1om-* \\\n \t| le32-* | le64-* \\\n@@ -446,6 +447,7 @@ case $basic_machine in\n \t| v850-* | v850e-* | v850e1-* | v850es-* | v850e2-* | v850e2v3-* \\\n \t| vax-* \\\n \t| visium-* \\\n+\t| wasm32-* \\\n \t| we32k-* \\\n \t| x86-* | x86_64-* | xc16x-* | xps100-* \\\n \t| xstormy16-* | xtensa*-* \\\n@@ -948,6 +950,9 @@ case $basic_machine in\n \tnsr-tandem)\n \t\tbasic_machine=nsr-tandem\n \t\t;;\n+\tnsx-tandem)\n+\t\tbasic_machine=nsx-tandem\n+\t\t;;\n \top50n-* | op60c-*)\n \t\tbasic_machine=hppa1.1-oki\n \t\tos=-proelf\n@@ -1243,6 +1248,9 @@ case $basic_machine in\n \t\tbasic_machine=a29k-wrs\n \t\tos=-vxworks\n \t\t;;\n+\twasm32)\n+\t\tbasic_machine=wasm32-unknown\n+\t\t;;\n \tw65*)\n \t\tbasic_machine=w65-wdc\n \t\tos=-none"
      },
      {
        "sha": "bf773ccd147d43228815200029dbddd9920fa09d",
        "filename": "depends/packages/boost.mk",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/depends/packages/boost.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/depends/packages/boost.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/boost.mk?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,8 +1,8 @@\n package=boost\n-$(package)_version=1_63_0\n-$(package)_download_path=https://sourceforge.net/projects/boost/files/boost/1.63.0\n+$(package)_version=1_64_0\n+$(package)_download_path=https://dl.bintray.com/boostorg/release/1.64.0/source/\n $(package)_file_name=$(package)_$($(package)_version).tar.bz2\n-$(package)_sha256_hash=beae2529f759f6b3bf3f4969a19c2e9d6f0c503edcb2de4a61d1428519fcb3b0\n+$(package)_sha256_hash=7bcc5caace97baa948931d712ea5f37038dbb1c5d89b43ad4def4ed7cb683332\n \n define $(package)_set_vars\n $(package)_config_opts_release=variant=release"
      },
      {
        "sha": "bbe03754099f53b6fe404876af8cbc68722fc216",
        "filename": "depends/packages/dbus.mk",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/depends/packages/dbus.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/depends/packages/dbus.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/dbus.mk?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,8 +1,8 @@\n package=dbus\n-$(package)_version=1.10.14\n-$(package)_download_path=http://dbus.freedesktop.org/releases/dbus\n+$(package)_version=1.10.18\n+$(package)_download_path=https://dbus.freedesktop.org/releases/dbus\n $(package)_file_name=$(package)-$($(package)_version).tar.gz\n-$(package)_sha256_hash=23238f70353e38ce5ca183ebc9525c0d97ac00ef640ad29cf794782af6e6a083\n+$(package)_sha256_hash=6049ddd5f3f3e2618f615f1faeda0a115104423a7996b7aa73e2f36e38cc514a\n $(package)_dependencies=expat\n \n define $(package)_set_vars"
      },
      {
        "sha": "00231d75d5f2f297b798b652c2e85ca865fc2e02",
        "filename": "depends/packages/libevent.mk",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/depends/packages/libevent.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/depends/packages/libevent.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/libevent.mk?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,8 +1,8 @@\n package=libevent\n-$(package)_version=2.1.7\n+$(package)_version=2.1.8-stable\n $(package)_download_path=https://github.com/libevent/libevent/archive/\n-$(package)_file_name=release-$($(package)_version)-rc.tar.gz\n-$(package)_sha256_hash=548362d202e22fe24d4c3fad38287b4f6d683e6c21503341373b89785fa6f991\n+$(package)_file_name=release-$($(package)_version).tar.gz\n+$(package)_sha256_hash=316ddb401745ac5d222d7c529ef1eada12f58f6376a66c1118eee803cb70f83d\n \n define $(package)_preprocess_cmds\n   ./autogen.sh"
      },
      {
        "sha": "1bb8cb5d2664746b943756a9efa0db8d8a9d385d",
        "filename": "depends/packages/miniupnpc.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/depends/packages/miniupnpc.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/depends/packages/miniupnpc.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/miniupnpc.mk?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,8 +1,8 @@\n package=miniupnpc\n-$(package)_version=2.0\n+$(package)_version=2.0.20170509\n $(package)_download_path=http://miniupnp.free.fr/files\n $(package)_file_name=$(package)-$($(package)_version).tar.gz\n-$(package)_sha256_hash=d434ceb8986efbe199c5ca53f90ed53eab290b1e6d0530b717eb6fa49d61f93b\n+$(package)_sha256_hash=d3c368627f5cdfb66d3ebd64ca39ba54d6ff14a61966dbecb8dd296b7039f16a\n \n define $(package)_set_vars\n $(package)_build_opts=CC=\"$($(package)_cc)\""
      },
      {
        "sha": "966804ce8bbf677fae5446219420532b86fdb800",
        "filename": "depends/packages/native_ccache.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/depends/packages/native_ccache.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/depends/packages/native_ccache.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/native_ccache.mk?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,8 +1,8 @@\n package=native_ccache\n-$(package)_version=3.3.3\n+$(package)_version=3.3.4\n $(package)_download_path=https://samba.org/ftp/ccache\n $(package)_file_name=ccache-$($(package)_version).tar.bz2\n-$(package)_sha256_hash=2985bc5e32ebe38d2958d508eb54ddcad39eed909489c0c2988035214597ca54\n+$(package)_sha256_hash=fa9d7f38367431bc86b19ad107d709ca7ecf1574fdacca01698bdf0a47cd8567\n \n define $(package)_set_vars\n $(package)_config_opts="
      },
      {
        "sha": "38498103bb1704a3f13979c1359649a786d50aef",
        "filename": "doc/.gitignore",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/.gitignore?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -0,0 +1 @@\n+Doxyfile"
      },
      {
        "sha": "58c65fb7e25514043bef4caad82a668aabca4914",
        "filename": "doc/Doxyfile.in",
        "status": "renamed",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/Doxyfile.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/Doxyfile.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/Doxyfile.in?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -38,7 +38,7 @@ PROJECT_NAME           = \"Bitcoin Core\"\n # could be handy for archiving the generated documentation or if some version\n # control system is used.\n \n-PROJECT_NUMBER         = 0.14.99\n+PROJECT_NUMBER         = @PACKAGE_VERSION@\n \n # Using the PROJECT_BRIEF tag one can provide an optional one line description\n # for a project that appears at the top of each page and should give viewer a",
        "previous_filename": "doc/Doxyfile"
      },
      {
        "sha": "275ae67e54daaa03c451dffbcdedf04e89388698",
        "filename": "doc/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README.md?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,5 +1,5 @@\n-Bitcoin Core 0.14.99\n-=====================\n+Bitcoin Core\n+=============\n \n Setup\n ---------------------"
      },
      {
        "sha": "07d61b3bda13acb5ac4775db4d23a97586aed646",
        "filename": "doc/README_windows.txt",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/README_windows.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/README_windows.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README_windows.txt?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,5 +1,5 @@\n-Bitcoin Core 0.14.99\r\n-=====================\r\n+Bitcoin Core\r\n+=============\r\n \r\n Intro\r\n -----\r"
      },
      {
        "sha": "32d7dbd69e7d694f4b27c151343c815c1708eed9",
        "filename": "doc/build-osx.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/build-osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/build-osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-osx.md?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -11,14 +11,14 @@ Install the OS X command line tools:\n \n When the popup appears, click `Install`.\n \n-Then install [Homebrew](http://brew.sh).\n+Then install [Homebrew](https://brew.sh).\n \n Dependencies\n ----------------------\n \n-    brew install automake berkeley-db4 libtool boost --c++11 miniupnpc openssl pkg-config protobuf --c++11 qt5 libevent\n+    brew install automake berkeley-db4 libtool boost --c++11 miniupnpc openssl pkg-config protobuf qt libevent\n \n-In case you want to build the disk image with `make deploy` (.dmg / optional), you need RSVG\n+If you want to build the disk image with `make deploy` (.dmg / optional), you need RSVG\n \n     brew install librsvg\n "
      },
      {
        "sha": "b7eae2a630ad1acca937121b4def7e382256f283",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -321,8 +321,10 @@ Clang is installed by default as `cc` compiler, this makes it easier to get\n started than on [OpenBSD](build-openbsd.md). Installing dependencies:\n \n     pkg install autoconf automake libtool pkgconf\n-    pkg install boost-libs openssl libevent2\n+    pkg install boost-libs openssl libevent\n+    pkg install gmake\n \n+You need to use GNU make (`gmake`) instead of `make`.\n (`libressl` instead of `openssl` will also work)\n \n For the wallet (optional):\n@@ -338,7 +340,7 @@ Then build using:\n \n     ./autogen.sh\n     ./configure --with-incompatible-bdb BDB_CFLAGS=\"-I/usr/local/include/db5\" BDB_LIBS=\"-L/usr/local/lib -ldb_cxx-5\"\n-    make\n+    gmake\n \n *Note on debugging*: The version of `gdb` installed by default is [ancient and considered harmful](https://wiki.freebsd.org/GdbRetirement).\n It is not suitable for debugging a multi-threaded C++ program, not even for getting backtraces. Please install the package `gdb` and"
      },
      {
        "sha": "ec6abda91e7b96ef138a131a037d728dedcf0bde",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 110,
        "deletions": 15,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -3,41 +3,64 @@ Developer Notes\n \n Various coding styles have been used during the history of the codebase,\n and the result is not very consistent. However, we're now trying to converge to\n-a single style, so please use it in new code. Old code will be converted\n-gradually and you are encouraged to use the provided\n-[clang-format-diff script](/contrib/devtools/README.md#clang-format-diffpy)\n-to clean up the patch automatically before submitting a pull request.\n+a single style, which is specified below. When writing patches, favor the new\n+style over attempting to mimick the surrounding style, except for move-only\n+commits.\n+\n+Do not submit patches solely to modify the style of existing code.\n \n-- Basic rules specified in [src/.clang-format](/src/.clang-format).\n+- **Indentation and whitespace rules** as specified in\n+[src/.clang-format](/src/.clang-format). You can use the provided\n+[clang-format-diff script](/contrib/devtools/README.md#clang-format-diffpy)\n+tool to clean up patches automatically before submission.\n   - Braces on new lines for namespaces, classes, functions, methods.\n   - Braces on the same line for everything else.\n   - 4 space indentation (no tabs) for every block except namespaces.\n   - No indentation for `public`/`protected`/`private` or for `namespace`.\n   - No extra spaces inside parenthesis; don't do ( this )\n   - No space after function names; one space after `if`, `for` and `while`.\n-  - If an `if` only has a single-statement then-clause, it can appear\n-    on the same line as the if, without braces. In every other case,\n-    braces are required, and the then and else clauses must appear\n+  - If an `if` only has a single-statement `then`-clause, it can appear\n+    on the same line as the `if`, without braces. In every other case,\n+    braces are required, and the `then` and `else` clauses must appear\n     correctly indented on a new line.\n+\n+- **Symbol naming conventions**. These are preferred in new code, but are not\n+required when doing so would need changes to significant pieces of existing\n+code.\n+  - Variable and namespace names are all lowercase, and may use `_` to\n+    separate words.\n+    - Class member variables have a `m_` prefix.\n+    - Global variables have a `g_` prefix.\n+  - Constant names are all uppercase, and use `_` to separate words.\n+  - Class names, function names and method names are CamelCase. Do not prefix\n+    class names with `C`.\n+\n+- **Miscellaneous**\n   - `++i` is preferred over `i++`.\n \n Block style example:\n ```c++\n+int g_count = 0;\n+\n namespace foo\n {\n class Class\n {\n+    std::string m_name;\n+\n+public:\n     bool Function(const std::string& s, int n)\n     {\n         // Comment summarising what this section of code does\n         for (int i = 0; i < n; ++i) {\n+            int total_sum = 0;\n             // When something fails, return early\n             if (!Something()) return false;\n             ...\n-            if (SomethingElse()) {\n-                DoMore();\n+            if (SomethingElse(i)) {\n+                total_sum += ComputeSomething(g_count);\n             } else {\n-                DoLess();\n+                DoSomething(m_name, total_sum);\n             }\n         }\n \n@@ -343,10 +366,9 @@ Strings and formatting\n Variable names\n --------------\n \n-The shadowing warning (`-Wshadow`) is enabled by default. It prevents issues rising\n-from using a different variable with the same name.\n-\n-Please name variables so that their names do not shadow variables defined in the source code.\n+Although the shadowing warning (`-Wshadow`) is not enabled by default (it prevents issues rising\n+from using a different variable with the same name),\n+please name variables so that their names do not shadow variables defined in the source code.\n \n E.g. in member initializers, prepend `_` to the argument name shadowing the\n member name:\n@@ -495,3 +517,76 @@ Git and GitHub tips\n   This will add an `upstream-pull` remote to your git repository, which can be fetched using `git fetch --all`\n   or `git fetch upstream-pull`. Afterwards, you can use `upstream-pull/NUMBER/head` in arguments to `git show`,\n   `git checkout` and anywhere a commit id would be acceptable to see the changes from pull request NUMBER.\n+\n+RPC interface guidelines\n+--------------------------\n+\n+A few guidelines for introducing and reviewing new RPC interfaces:\n+\n+- Method naming: use consecutive lower-case names such as `getrawtransaction` and `submitblock`\n+\n+  - *Rationale*: Consistency with existing interface.\n+\n+- Argument naming: use snake case `fee_delta` (and not, e.g. camel case `feeDelta`)\n+\n+  - *Rationale*: Consistency with existing interface.\n+\n+- Use the JSON parser for parsing, don't manually parse integers or strings from\n+  arguments unless absolutely necessary.\n+\n+  - *Rationale*: Introduces hand-rolled string manipulation code at both the caller and callee sites,\n+    which is error prone, and it is easy to get things such as escaping wrong.\n+    JSON already supports nested data structures, no need to re-invent the wheel.\n+\n+  - *Exception*: AmountToValue can parse amounts as string. This was introduced because many JSON\n+    parsers and formatters hard-code handling decimal numbers as floating point\n+    values, resulting in potential loss of precision. This is unacceptable for\n+    monetary values. **Always** use `AmountToValue` and `ValueToAmount` when\n+    inputting or outputting monetary values. The only exceptions to this are\n+    `prioritisetransaction` and `getblocktemplate` because their interface\n+    is specified as-is in BIP22.\n+\n+- Missing arguments and 'null' should be treated the same: as default values. If there is no\n+  default value, both cases should fail in the same way.\n+\n+  - *Rationale*: Avoids surprises when switching to name-based arguments. Missing name-based arguments\n+  are passed as 'null'.\n+\n+  - *Exception*: Many legacy exceptions to this exist, one of the worst ones is\n+    `getbalance` which follows a completely different code path based on the\n+    number of arguments. We are still in the process of cleaning these up. Do not introduce\n+    new ones.\n+\n+- Try not to overload methods on argument type. E.g. don't make `getblock(true)` and `getblock(\"hash\")`\n+  do different things.\n+\n+  - *Rationale*: This is impossible to use with `bitcoin-cli`, and can be surprising to users.\n+\n+  - *Exception*: Some RPC calls can take both an `int` and `bool`, most notably when a bool was switched\n+    to a multi-value, or due to other historical reasons. **Always** have false map to 0 and\n+    true to 1 in this case.\n+\n+- Don't forget to fill in the argument names correctly in the RPC command table.\n+\n+  - *Rationale*: If not, the call can not be used with name-based arguments.\n+\n+- Set okSafeMode in the RPC command table to a sensible value: safe mode is when the\n+  blockchain is regarded to be in a confused state, and the client deems it unsafe to\n+  do anything irreversible such as send. Anything that just queries should be permitted.\n+\n+  - *Rationale*: Troubleshooting a node in safe mode is difficult if half the\n+    RPCs don't work.\n+\n+- Add every non-string RPC argument `(method, idx, name)` to the table `vRPCConvertParams` in `rpc/client.cpp`.\n+\n+  - *Rationale*: `bitcoin-cli` and the GUI debug console use this table to determine how to\n+    convert a plaintext command line to JSON. If the types don't match, the method can be unusable\n+    from there.\n+\n+- A RPC method must either be a wallet method or a non-wallet method. Do not\n+  introduce new methods such as `getinfo` and `signrawtransaction` that differ\n+  in behavior based on presence of a wallet.\n+\n+  - *Rationale*: as well as complicating the implementation and interfering\n+    with the introduction of multi-wallet, wallet and non-wallet code should be\n+    separated to avoid introducing circular dependencies between code units."
      },
      {
        "sha": "5dedcb51c895e612c6953b99ca3bb532899cb4aa",
        "filename": "doc/fuzzing.md",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/fuzzing.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/fuzzing.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/fuzzing.md?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -32,6 +32,13 @@ We disable ccache because we don't want to pollute the ccache with instrumented\n objects, and similarly don't want to use non-instrumented cached objects linked\n in.\n \n+The fuzzing can be sped up significantly (~200x) by using `afl-clang-fast` and\n+`afl-clang-fast++` in place of `afl-gcc` and `afl-g++` when compiling. When\n+compiling using `afl-clang-fast`/`afl-clang-fast++` the resulting\n+`test_bitcoin_fuzzy` binary will be instrumented in such a way that the AFL\n+features \"persistent mode\" and \"deferred forkserver\" can be used. See\n+https://github.com/mcarpenter/afl/tree/master/llvm_mode for details.\n+\n Preparing fuzzing\n ------------------\n \n@@ -63,4 +70,3 @@ $AFLPATH/afl-fuzz -i ${AFLIN} -o ${AFLOUT} -m52 -- test/test_bitcoin_fuzzy\n \n You may have to change a few kernel parameters to test optimally - `afl-fuzz`\n will print an error and suggestion if so.\n-"
      },
      {
        "sha": "a13ede2dd584c7950287b50186844db9a269d6ab",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -36,6 +36,21 @@ Notable changes\n Low-level RPC changes\n ---------------------\n \n+- The new database model no longer stores information about transaction\n+  versions of unspent outputs. This means that:\n+  - The `gettxout` RPC no longer has a `version` field in the response.\n+  - The `gettxoutsetinfo` RPC reports `hash_serialized_2` instead of `hash_serialized`,\n+    which does not commit to the transaction versions of unspent outputs, but does\n+    commit to the height and coinbase information.\n+  - The `gettxoutsetinfo` response now contains `disk_size` and `bogosize` instead of\n+    `bytes_serialized`. The first is a more accurate estimate of actual disk usage, but\n+    is not deterministic. The second is unrelated to disk usage, but is a\n+    database-independent metric of UTXO set size: it counts every UTXO entry as 50 + the\n+    length of its scriptPubKey.\n+  - The `getutxos` REST path no longer reports the `txvers` field in JSON format,\n+    and always reports 0 for transaction versions in the binary format\n+\n+\n - Error codes have been updated to be more accurate for the following error cases:\n   - `getblock` now returns RPC_MISC_ERROR if the block can't be found on disk (for\n   example if the block has been pruned). Previously returned RPC_INTERNAL_ERROR."
      },
      {
        "sha": "ef072afd4d7fb94d29007038e587eacb40358a98",
        "filename": "doc/release-notes/release-notes-0.14.1.md",
        "status": "added",
        "additions": 143,
        "deletions": 0,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/release-notes/release-notes-0.14.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/release-notes/release-notes-0.14.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.14.1.md?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -0,0 +1,143 @@\n+Bitcoin Core version 0.14.1 is now available from:\n+\n+  <https://bitcoin.org/bin/bitcoin-core-0.14.1/>\n+\n+This is a new minor version release, including various bugfixes and\n+performance improvements, as well as updated translations.\n+\n+Please report bugs using the issue tracker at github:\n+\n+  <https://github.com/bitcoin/bitcoin/issues>\n+\n+To receive security and update notifications, please subscribe to:\n+\n+  <https://bitcoincore.org/en/list/announcements/join/>\n+\n+Compatibility\n+==============\n+\n+Bitcoin Core is extensively tested on multiple operating systems using\n+the Linux kernel, macOS 10.8+, and Windows Vista and later.\n+\n+Microsoft ended support for Windows XP on [April 8th, 2014](https://www.microsoft.com/en-us/WindowsForBusiness/end-of-xp-support),\n+No attempt is made to prevent installing or running the software on Windows XP, you\n+can still do so at your own risk but be aware that there are known instabilities and issues.\n+Please do not report issues about Windows XP to the issue tracker.\n+\n+Bitcoin Core should also work on most other Unix-like systems but is not\n+frequently tested on them.\n+\n+Notable changes\n+===============\n+\n+RPC changes\n+-----------\n+\n+- The first positional argument of `createrawtransaction` was renamed from\n+  `transactions` to `inputs`.\n+\n+- The argument of `disconnectnode` was renamed from `node` to `address`.\n+\n+These interface changes break compatibility with 0.14.0, when the named\n+arguments functionality, introduced in 0.14.0, is used. Client software\n+using these calls with named arguments needs to be updated.\n+\n+Mining\n+------\n+\n+In previous versions, getblocktemplate required segwit support from downstream\n+clients/miners once the feature activated on the network. In this version, it\n+now supports non-segwit clients even after activation, by removing all segwit\n+transactions from the returned block template. This allows non-segwit miners to\n+continue functioning correctly even after segwit has activated.\n+\n+Due to the limitations in previous versions, getblocktemplate also recommended\n+non-segwit clients to not signal for the segwit version-bit. Since this is no\n+longer an issue, getblocktemplate now always recommends signalling segwit for\n+all miners. This is safe because ability to enforce the rule is the only\n+required criteria for safe activation, not actually producing segwit-enabled\n+blocks.\n+\n+UTXO memory accounting\n+----------------------\n+\n+Memory usage for the UTXO cache is being calculated more accurately, so that\n+the configured limit (`-dbcache`) will be respected when memory usage peaks\n+during cache flushes.  The memory accounting in prior releases is estimated to\n+only account for half the actual peak utilization.\n+\n+The default `-dbcache` has also been changed in this release to 450MiB.  Users\n+who currently set `-dbcache` to a high value (e.g. to keep the UTXO more fully\n+cached in memory) should consider increasing this setting in order to achieve\n+the same cache performance as prior releases.  Users on low-memory systems\n+(such as systems with 1GB or less) should consider specifying a lower value for\n+this parameter.\n+\n+Additional information relating to running on low-memory systems can be found\n+here:\n+[reducing-bitcoind-memory-usage.md](https://gist.github.com/laanwj/efe29c7661ce9b6620a7).\n+\n+0.14.1 Change log\n+=================\n+\n+Detailed release notes follow. This overview includes changes that affect\n+behavior, not code moves, refactors and string updates. For convenience in locating\n+the code changes and accompanying discussion, both the pull request and\n+git merge commit are mentioned.\n+\n+### RPC and other APIs\n+- #10084 `142fbb2` Rename first named arg of createrawtransaction (MarcoFalke)\n+- #10139 `f15268d` Remove auth cookie on shutdown (practicalswift)\n+- #10146 `2fea10a` Better error handling for submitblock (rawodb, gmaxwell)\n+- #10144 `d947afc` Prioritisetransaction wasn't always updating ancestor fee (sdaftuar)\n+- #10204 `3c79602` Rename disconnectnode argument (jnewbery)\n+\n+### Block and transaction handling\n+- #10126 `0b5e162` Compensate for memory peak at flush time (sipa)\n+- #9912 `fc3d7db` Optimize GetWitnessHash() for non-segwit transactions (sdaftuar)\n+- #10133 `ab864d3` Clean up calculations of pcoinsTip memory usage (morcos)\n+\n+### P2P protocol and network code\n+- #9953/#10013 `d2548a4` Fix shutdown hang with >= 8 -addnodes set (TheBlueMatt)\n+- #10176 `30fa231` net: gracefully handle NodeId wrapping (theuni)\n+\n+### Build system\n+- #9973 `e9611d1` depends: fix zlib build on osx (theuni)\n+\n+### GUI\n+- #10060 `ddc2dd1` Ensure an item exists on the rpcconsole stack before adding (achow101)\n+\n+### Mining\n+- #9955/#10006 `569596c` Don't require segwit in getblocktemplate for segwit signalling or mining (sdaftuar)\n+- #9959/#10127 `b5c3440` Prevent slowdown in CreateNewBlock on large mempools (sdaftuar)\n+\n+### Tests and QA\n+- #10157 `55f641c` Fix the `mempool_packages.py` test (sdaftuar)\n+\n+### Miscellaneous\n+- #10037 `4d8e660` Trivial: Fix typo in help getrawtransaction RPC (keystrike)\n+- #10120 `e4c9a90` util: Work around (virtual) memory exhaustion on 32-bit w/ glibc (laanwj)\n+- #10130 `ecc5232` bitcoin-tx input verification (awemany, jnewbery)\n+\n+Credits\n+=======\n+\n+Thanks to everyone who directly contributed to this release:\n+\n+- Alex Morcos\n+- Andrew Chow\n+- Awemany\n+- Cory Fields\n+- Gregory Maxwell\n+- James Evans\n+- John Newbery\n+- MarcoFalke\n+- Matt Corallo\n+- Pieter Wuille\n+- practicalswift\n+- rawodb\n+- Suhas Daftuar\n+- Wladimir J. van der Laan\n+\n+As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n+"
      },
      {
        "sha": "5a99b726f1281424b1f1fda842137de2e36856b8",
        "filename": "doc/release-process.md",
        "status": "modified",
        "additions": 3,
        "deletions": 18,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/release-process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/doc/release-process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-process.md?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -10,7 +10,7 @@ Before every release candidate:\n Before every minor and major release:\n \n * Update [bips.md](bips.md) to account for changes since the last release.\n-* Update version in sources (see below)\n+* Update version in `configure.ac` (don't forget to set `CLIENT_VERSION_IS_RELEASE` to `true`)\n * Write release notes (see below)\n * Update `src/chainparams.cpp` nMinimumChainWork with information from the getblockchaininfo rpc.\n * Update `src/chainparams.cpp` defaultAssumeValid  with information from the getblockhash rpc.\n@@ -24,6 +24,7 @@ Before every major release:\n * Update hardcoded [seeds](/contrib/seeds/README.md), see [this pull request](https://github.com/bitcoin/bitcoin/pull/7415) for an example.\n * Update [`BLOCK_CHAIN_SIZE`](/src/qt/intro.cpp) to the current size plus some overhead.\n * Update `src/chainparams.cpp` chainTxData with statistics about the transaction count and rate.\n+* Update version of `contrib/gitian-descriptors/*.yml`: usually one'd want to do this on master after branching off the release - but be sure to at least do it before a new major release\n \n ### First time / New builders\n \n@@ -37,23 +38,7 @@ Check out the source code in the following directory hierarchy.\n     git clone https://github.com/devrandom/gitian-builder.git\n     git clone https://github.com/bitcoin/bitcoin.git\n \n-### Bitcoin maintainers/release engineers, update version in sources\n-\n-Update the following:\n-\n-- `configure.ac`:\n-    - `_CLIENT_VERSION_MAJOR`\n-    - `_CLIENT_VERSION_MINOR`\n-    - `_CLIENT_VERSION_REVISION`\n-    - Don't forget to set `_CLIENT_VERSION_IS_RELEASE` to `true`\n-- `src/clientversion.h`: (this mirrors `configure.ac` - see issue #3539)\n-    - `CLIENT_VERSION_MAJOR`\n-    - `CLIENT_VERSION_MINOR`\n-    - `CLIENT_VERSION_REVISION`\n-    - Don't forget to set `CLIENT_VERSION_IS_RELEASE` to `true`\n-- `doc/README.md` and `doc/README_windows.txt`\n-- `doc/Doxyfile`: `PROJECT_NUMBER` contains the full version\n-- `contrib/gitian-descriptors/*.yml`: usually one'd want to do this on master after branching off the release - but be sure to at least do it before a new major release\n+### Bitcoin maintainers/release engineers, suggestion for writing release notes\n \n Write release notes. git shortlog helps a lot, for example:\n "
      },
      {
        "sha": "32ef2a5755aa4e93d3da541f78f576a846b53db0",
        "filename": "share/genbuild.sh",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/share/genbuild.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/share/genbuild.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/genbuild.sh?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -17,9 +17,13 @@ else\n     exit 1\n fi\n \n+git_check_in_repo() {\n+    ! { git status --porcelain -uall --ignored \"$@\" 2>/dev/null || echo '??'; } | grep -q '?'\n+}\n+\n DESC=\"\"\n SUFFIX=\"\"\n-if [ -e \"$(which git 2>/dev/null)\" -a \"$(git rev-parse --is-inside-work-tree 2>/dev/null)\" = \"true\" ]; then\n+if [ \"${BITCOIN_GENBUILD_NO_GIT}\" != \"1\" -a -e \"$(which git 2>/dev/null)\" -a \"$(git rev-parse --is-inside-work-tree 2>/dev/null)\" = \"true\" ] && git_check_in_repo share/genbuild.sh; then\n     # clean 'dirty' status of touched files that haven't been modified\n     git diff >/dev/null 2>/dev/null \n "
      },
      {
        "sha": "199d60b725f47142eed4b1f4937b31d75af5a3fe",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 23,
        "deletions": 5,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -95,9 +95,11 @@ BITCOIN_CORE_H = \\\n   compat/sanity.h \\\n   compressor.h \\\n   consensus/consensus.h \\\n+  consensus/tx_verify.h \\\n   core_io.h \\\n   core_memusage.h \\\n   cuckoocache.h \\\n+  fs.h \\\n   httprpc.h \\\n   httpserver.h \\\n   indirectmap.h \\\n@@ -115,13 +117,15 @@ BITCOIN_CORE_H = \\\n   netbase.h \\\n   netmessagemaker.h \\\n   noui.h \\\n+  policy/feerate.h \\\n   policy/fees.h \\\n   policy/policy.h \\\n   policy/rbf.h \\\n   pow.h \\\n   protocol.h \\\n   random.h \\\n   reverselock.h \\\n+  rpc/blockchain.h \\\n   rpc/client.h \\\n   rpc/protocol.h \\\n   rpc/server.h \\\n@@ -155,6 +159,7 @@ BITCOIN_CORE_H = \\\n   wallet/coincontrol.h \\\n   wallet/crypter.h \\\n   wallet/db.h \\\n+  wallet/feebumper.h \\\n   wallet/rpcwallet.h \\\n   wallet/wallet.h \\\n   wallet/walletdb.h \\\n@@ -167,20 +172,21 @@ BITCOIN_CORE_H = \\\n \n obj/build.h: FORCE\n \t@$(MKDIR_P) $(builddir)/obj\n-\t@$(top_srcdir)/share/genbuild.sh $(abs_top_builddir)/src/obj/build.h \\\n-\t  $(abs_top_srcdir)\n+\t@$(top_srcdir)/share/genbuild.sh \"$(abs_top_builddir)/src/obj/build.h\" \\\n+\t  \"$(abs_top_srcdir)\"\n libbitcoin_util_a-clientversion.$(OBJEXT): obj/build.h\n \n # server: shared between bitcoind and bitcoin-qt\n libbitcoin_server_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(MINIUPNPC_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n libbitcoin_server_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_server_a_SOURCES = \\\n-  addrman.cpp \\\n   addrdb.cpp \\\n+  addrman.cpp \\\n   bloom.cpp \\\n   blockencodings.cpp \\\n   chain.cpp \\\n   checkpoints.cpp \\\n+  consensus/tx_verify.cpp \\\n   httprpc.cpp \\\n   httpserver.cpp \\\n   init.cpp \\\n@@ -192,6 +198,7 @@ libbitcoin_server_a_SOURCES = \\\n   noui.cpp \\\n   policy/fees.cpp \\\n   policy/policy.cpp \\\n+  policy/rbf.cpp \\\n   pow.cpp \\\n   rest.cpp \\\n   rpc/blockchain.cpp \\\n@@ -229,11 +236,11 @@ libbitcoin_wallet_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_wallet_a_SOURCES = \\\n   wallet/crypter.cpp \\\n   wallet/db.cpp \\\n+  wallet/feebumper.cpp \\\n   wallet/rpcdump.cpp \\\n   wallet/rpcwallet.cpp \\\n   wallet/wallet.cpp \\\n   wallet/walletdb.cpp \\\n-  policy/rbf.cpp \\\n   $(BITCOIN_CORE_H)\n \n # crypto primitives library\n@@ -242,6 +249,8 @@ crypto_libbitcoin_crypto_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n crypto_libbitcoin_crypto_a_SOURCES = \\\n   crypto/aes.cpp \\\n   crypto/aes.h \\\n+  crypto/chacha20.h \\\n+  crypto/chacha20.cpp \\\n   crypto/common.h \\\n   crypto/hmac_sha256.cpp \\\n   crypto/hmac_sha256.h \\\n@@ -295,7 +304,6 @@ libbitcoin_consensus_a_SOURCES = \\\n libbitcoin_common_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_common_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_common_a_SOURCES = \\\n-  amount.cpp \\\n   base58.cpp \\\n   chainparams.cpp \\\n   coins.cpp \\\n@@ -306,6 +314,7 @@ libbitcoin_common_a_SOURCES = \\\n   keystore.cpp \\\n   netaddress.cpp \\\n   netbase.cpp \\\n+  policy/feerate.cpp \\\n   protocol.cpp \\\n   scheduler.cpp \\\n   script/sign.cpp \\\n@@ -325,6 +334,7 @@ libbitcoin_util_a_SOURCES = \\\n   compat/glibc_sanity.cpp \\\n   compat/glibcxx_sanity.cpp \\\n   compat/strnlen.cpp \\\n+  fs.cpp \\\n   random.cpp \\\n   rpc/protocol.cpp \\\n   support/cleanse.cpp \\\n@@ -457,6 +467,14 @@ DISTCLEANFILES = obj/build.h\n \n EXTRA_DIST = $(CTAES_DIST)\n \n+\n+config/bitcoin-config.h: config/stamp-h1\n+\t@$(MAKE) -C $(top_builddir) $(subdir)/$(@)\n+config/stamp-h1: $(top_srcdir)/$(subdir)/config/bitcoin-config.h.in $(top_builddir)/config.status\n+\t$(AM_V_at)$(MAKE) -C $(top_builddir) $(subdir)/$(@)\n+$(top_srcdir)/$(subdir)/config/bitcoin-config.h.in:  $(am__configure_deps)\n+\t$(AM_V_at)$(MAKE) -C $(top_srcdir) $(subdir)/config/bitcoin-config.h.in\n+\n clean-local:\n \t-$(MAKE) -C secp256k1 clean\n \t-$(MAKE) -C univalue clean"
      },
      {
        "sha": "48411f29ecb9b10071a62b447f67227e7be8fcde",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -122,6 +122,7 @@ QT_MOC_CPP = \\\n   qt/moc_bitcoinamountfield.cpp \\\n   qt/moc_bitcoingui.cpp \\\n   qt/moc_bitcoinunits.cpp \\\n+  qt/moc_callback.cpp \\\n   qt/moc_clientmodel.cpp \\\n   qt/moc_coincontroldialog.cpp \\\n   qt/moc_coincontroltreewidget.cpp \\\n@@ -167,6 +168,7 @@ BITCOIN_MM = \\\n QT_MOC = \\\n   qt/bitcoin.moc \\\n   qt/bitcoinamountfield.moc \\\n+  qt/callback.moc \\\n   qt/intro.moc \\\n   qt/overviewpage.moc \\\n   qt/rpcconsole.moc\n@@ -189,6 +191,7 @@ BITCOIN_QT_H = \\\n   qt/bitcoinamountfield.h \\\n   qt/bitcoingui.h \\\n   qt/bitcoinunits.h \\\n+  qt/callback.h \\\n   qt/clientmodel.h \\\n   qt/coincontroldialog.h \\\n   qt/coincontroltreewidget.h \\"
      },
      {
        "sha": "391b9ebdf6947f272f342ad7a83a3e8c99883121",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -46,7 +46,8 @@ qt_test_test_bitcoin_qt_SOURCES = \\\n if ENABLE_WALLET\n qt_test_test_bitcoin_qt_SOURCES += \\\n   qt/test/paymentservertests.cpp \\\n-  qt/test/wallettests.cpp\n+  qt/test/wallettests.cpp \\\n+  wallet/test/wallet_test_fixture.cpp\n endif\n \n nodist_qt_test_test_bitcoin_qt_SOURCES = $(TEST_QT_MOC_CPP)"
      },
      {
        "sha": "13e0a03c762741ca64e41bc52101107c1a4d6744",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -57,8 +57,8 @@ BITCOIN_TESTS =\\\n   test/policyestimator_tests.cpp \\\n   test/pow_tests.cpp \\\n   test/prevector_tests.cpp \\\n-  test/random_tests.cpp \\\n   test/raii_event_tests.cpp \\\n+  test/random_tests.cpp \\\n   test/reverselock_tests.cpp \\\n   test/rpc_tests.cpp \\\n   test/sanity_tests.cpp \\\n@@ -74,10 +74,10 @@ BITCOIN_TESTS =\\\n   test/test_bitcoin.cpp \\\n   test/test_bitcoin.h \\\n   test/test_bitcoin_main.cpp \\\n-  test/test_random.h \\\n   test/testutil.cpp \\\n   test/testutil.h \\\n   test/timedata_tests.cpp \\\n+  test/torcontrol_tests.cpp \\\n   test/transaction_tests.cpp \\\n   test/txvalidationcache_tests.cpp \\\n   test/versionbits_tests.cpp \\\n@@ -97,7 +97,7 @@ endif\n test_test_bitcoin_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)\n test_test_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -I$(builddir)/test/ $(TESTDEFS) $(EVENT_CFLAGS)\n test_test_bitcoin_LDADD = $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n-  $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS)\n+  $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n test_test_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n if ENABLE_WALLET\n test_test_bitcoin_LDADD += $(LIBBITCOIN_WALLET)\n@@ -147,7 +147,7 @@ bitcoin_test_clean : FORCE\n \n check-local:\n \t@echo \"Running test/util/bitcoin-util-test.py...\"\n-\t$(PYTHON) $(top_builddir)/test/util/bitcoin-util-test.py\n+\t$(top_builddir)/test/util/bitcoin-util-test.py\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C secp256k1 check\n if EMBEDDED_UNIVALUE\n \t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C univalue check"
      },
      {
        "sha": "a3743cd0d4dee3fb069e952bd847e2d59c46d607",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -8,13 +8,13 @@\n #include \"addrman.h\"\n #include \"chainparams.h\"\n #include \"clientversion.h\"\n+#include \"fs.h\"\n #include \"hash.h\"\n #include \"random.h\"\n #include \"streams.h\"\n #include \"tinyformat.h\"\n #include \"util.h\"\n \n-#include <boost/filesystem.hpp>\n \n CBanDB::CBanDB()\n {\n@@ -36,8 +36,8 @@ bool CBanDB::Write(const banmap_t& banSet)\n     ssBanlist << hash;\n \n     // open temp output file, and associate with CAutoFile\n-    boost::filesystem::path pathTmp = GetDataDir() / tmpfn;\n-    FILE *file = fopen(pathTmp.string().c_str(), \"wb\");\n+    fs::path pathTmp = GetDataDir() / tmpfn;\n+    FILE *file = fsbridge::fopen(pathTmp, \"wb\");\n     CAutoFile fileout(file, SER_DISK, CLIENT_VERSION);\n     if (fileout.IsNull())\n         return error(\"%s: Failed to open file %s\", __func__, pathTmp.string());\n@@ -62,13 +62,13 @@ bool CBanDB::Write(const banmap_t& banSet)\n bool CBanDB::Read(banmap_t& banSet)\n {\n     // open input file, and associate with CAutoFile\n-    FILE *file = fopen(pathBanlist.string().c_str(), \"rb\");\n+    FILE *file = fsbridge::fopen(pathBanlist, \"rb\");\n     CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n     if (filein.IsNull())\n         return error(\"%s: Failed to open file %s\", __func__, pathBanlist.string());\n \n     // use file size to size memory buffer\n-    uint64_t fileSize = boost::filesystem::file_size(pathBanlist);\n+    uint64_t fileSize = fs::file_size(pathBanlist);\n     uint64_t dataSize = 0;\n     // Don't try to resize to a negative number if file is small\n     if (fileSize >= sizeof(uint256))\n@@ -133,8 +133,8 @@ bool CAddrDB::Write(const CAddrMan& addr)\n     ssPeers << hash;\n \n     // open temp output file, and associate with CAutoFile\n-    boost::filesystem::path pathTmp = GetDataDir() / tmpfn;\n-    FILE *file = fopen(pathTmp.string().c_str(), \"wb\");\n+    fs::path pathTmp = GetDataDir() / tmpfn;\n+    FILE *file = fsbridge::fopen(pathTmp, \"wb\");\n     CAutoFile fileout(file, SER_DISK, CLIENT_VERSION);\n     if (fileout.IsNull())\n         return error(\"%s: Failed to open file %s\", __func__, pathTmp.string());\n@@ -159,13 +159,13 @@ bool CAddrDB::Write(const CAddrMan& addr)\n bool CAddrDB::Read(CAddrMan& addr)\n {\n     // open input file, and associate with CAutoFile\n-    FILE *file = fopen(pathAddr.string().c_str(), \"rb\");\n+    FILE *file = fsbridge::fopen(pathAddr, \"rb\");\n     CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n     if (filein.IsNull())\n         return error(\"%s: Failed to open file %s\", __func__, pathAddr.string());\n \n     // use file size to size memory buffer\n-    uint64_t fileSize = boost::filesystem::file_size(pathAddr);\n+    uint64_t fileSize = fs::file_size(pathAddr);\n     uint64_t dataSize = 0;\n     // Don't try to resize to a negative number if file is small\n     if (fileSize >= sizeof(uint256))"
      },
      {
        "sha": "c3d509bd3a7a653353d00b0c9c7a5eb776fbd9dc",
        "filename": "src/addrdb.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/addrdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/addrdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -6,11 +6,11 @@\n #ifndef BITCOIN_ADDRDB_H\n #define BITCOIN_ADDRDB_H\n \n+#include \"fs.h\"\n #include \"serialize.h\"\n \n #include <string>\n #include <map>\n-#include <boost/filesystem/path.hpp>\n \n class CSubNet;\n class CAddrMan;\n@@ -80,7 +80,7 @@ typedef std::map<CSubNet, CBanEntry> banmap_t;\n class CAddrDB\n {\n private:\n-    boost::filesystem::path pathAddr;\n+    fs::path pathAddr;\n public:\n     CAddrDB();\n     bool Write(const CAddrMan& addr);\n@@ -92,7 +92,7 @@ class CAddrDB\n class CBanDB\n {\n private:\n-    boost::filesystem::path pathBanlist;\n+    fs::path pathBanlist;\n public:\n     CBanDB();\n     bool Write(const banmap_t& banSet);"
      },
      {
        "sha": "4a408b9beb1913e06cc9fc570319431838e86533",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -233,7 +233,7 @@ void CAddrMan::Good_(const CService& addr, int64_t nTime)\n     if (nUBucket == -1)\n         return;\n \n-    LogPrint(\"addrman\", \"Moving %s to tried\\n\", addr.ToString());\n+    LogPrint(BCLog::ADDRMAN, \"Moving %s to tried\\n\", addr.ToString());\n \n     // move nId to the tried tables\n     MakeTried(info, nId);\n@@ -351,8 +351,8 @@ CAddrInfo CAddrMan::Select_(bool newOnly)\n             int nKBucket = RandomInt(ADDRMAN_TRIED_BUCKET_COUNT);\n             int nKBucketPos = RandomInt(ADDRMAN_BUCKET_SIZE);\n             while (vvTried[nKBucket][nKBucketPos] == -1) {\n-                nKBucket = (nKBucket + insecure_rand.rand32()) % ADDRMAN_TRIED_BUCKET_COUNT;\n-                nKBucketPos = (nKBucketPos + insecure_rand.rand32()) % ADDRMAN_BUCKET_SIZE;\n+                nKBucket = (nKBucket + insecure_rand.randbits(ADDRMAN_TRIED_BUCKET_COUNT_LOG2)) % ADDRMAN_TRIED_BUCKET_COUNT;\n+                nKBucketPos = (nKBucketPos + insecure_rand.randbits(ADDRMAN_BUCKET_SIZE_LOG2)) % ADDRMAN_BUCKET_SIZE;\n             }\n             int nId = vvTried[nKBucket][nKBucketPos];\n             assert(mapInfo.count(nId) == 1);\n@@ -368,8 +368,8 @@ CAddrInfo CAddrMan::Select_(bool newOnly)\n             int nUBucket = RandomInt(ADDRMAN_NEW_BUCKET_COUNT);\n             int nUBucketPos = RandomInt(ADDRMAN_BUCKET_SIZE);\n             while (vvNew[nUBucket][nUBucketPos] == -1) {\n-                nUBucket = (nUBucket + insecure_rand.rand32()) % ADDRMAN_NEW_BUCKET_COUNT;\n-                nUBucketPos = (nUBucketPos + insecure_rand.rand32()) % ADDRMAN_BUCKET_SIZE;\n+                nUBucket = (nUBucket + insecure_rand.randbits(ADDRMAN_NEW_BUCKET_COUNT_LOG2)) % ADDRMAN_NEW_BUCKET_COUNT;\n+                nUBucketPos = (nUBucketPos + insecure_rand.randbits(ADDRMAN_BUCKET_SIZE_LOG2)) % ADDRMAN_BUCKET_SIZE;\n             }\n             int nId = vvNew[nUBucket][nUBucketPos];\n             assert(mapInfo.count(nId) == 1);"
      },
      {
        "sha": "70d907488f3d92bdf432d5091aa68e7714887193",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 15,
        "deletions": 8,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -136,13 +136,13 @@ class CAddrInfo : public CAddress\n  */\n \n //! total number of buckets for tried addresses\n-#define ADDRMAN_TRIED_BUCKET_COUNT 256\n+#define ADDRMAN_TRIED_BUCKET_COUNT_LOG2 8\n \n //! total number of buckets for new addresses\n-#define ADDRMAN_NEW_BUCKET_COUNT 1024\n+#define ADDRMAN_NEW_BUCKET_COUNT_LOG2 10\n \n //! maximum allowed number of entries in buckets for new and tried addresses\n-#define ADDRMAN_BUCKET_SIZE 64\n+#define ADDRMAN_BUCKET_SIZE_LOG2 6\n \n //! over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread\n #define ADDRMAN_TRIED_BUCKETS_PER_GROUP 8\n@@ -171,6 +171,11 @@ class CAddrInfo : public CAddress\n //! the maximum number of nodes to return in a getaddr call\n #define ADDRMAN_GETADDR_MAX 2500\n \n+//! Convenience\n+#define ADDRMAN_TRIED_BUCKET_COUNT (1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2)\n+#define ADDRMAN_NEW_BUCKET_COUNT (1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2)\n+#define ADDRMAN_BUCKET_SIZE (1 << ADDRMAN_BUCKET_SIZE_LOG2)\n+\n /** \n  * Stochastical (IP) address manager \n  */\n@@ -442,7 +447,7 @@ class CAddrMan\n             }\n         }\n         if (nLost + nLostUnk > 0) {\n-            LogPrint(\"addrman\", \"addrman lost %i new and %i tried addresses due to collisions\\n\", nLostUnk, nLost);\n+            LogPrint(BCLog::ADDRMAN, \"addrman lost %i new and %i tried addresses due to collisions\\n\", nLostUnk, nLost);\n         }\n \n         Check();\n@@ -507,8 +512,9 @@ class CAddrMan\n         Check();\n         fRet |= Add_(addr, source, nTimePenalty);\n         Check();\n-        if (fRet)\n-            LogPrint(\"addrman\", \"Added %s from %s: %i tried, %i new\\n\", addr.ToStringIPPort(), source.ToString(), nTried, nNew);\n+        if (fRet) {\n+            LogPrint(BCLog::ADDRMAN, \"Added %s from %s: %i tried, %i new\\n\", addr.ToStringIPPort(), source.ToString(), nTried, nNew);\n+        }\n         return fRet;\n     }\n \n@@ -521,8 +527,9 @@ class CAddrMan\n         for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n             nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n         Check();\n-        if (nAdd)\n-            LogPrint(\"addrman\", \"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString(), nTried, nNew);\n+        if (nAdd) {\n+            LogPrint(BCLog::ADDRMAN, \"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString(), nTried, nNew);\n+        }\n         return nAdd > 0;\n     }\n "
      },
      {
        "sha": "2bd367cba29fa5e802635786607272b8c718a553",
        "filename": "src/amount.h",
        "status": "modified",
        "additions": 1,
        "deletions": 44,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/amount.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/amount.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/amount.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -6,19 +6,14 @@\n #ifndef BITCOIN_AMOUNT_H\n #define BITCOIN_AMOUNT_H\n \n-#include \"serialize.h\"\n-\n-#include <stdlib.h>\n-#include <string>\n+#include <stdint.h>\n \n /** Amount in satoshis (Can be negative) */\n typedef int64_t CAmount;\n \n static const CAmount COIN = 100000000;\n static const CAmount CENT = 1000000;\n \n-extern const std::string CURRENCY_UNIT;\n-\n /** No amount larger than this (in satoshi) is valid.\n  *\n  * Note that this constant is *not* the total money supply, which in Bitcoin\n@@ -31,42 +26,4 @@ extern const std::string CURRENCY_UNIT;\n static const CAmount MAX_MONEY = 21000000 * COIN;\n inline bool MoneyRange(const CAmount& nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }\n \n-/**\n- * Fee rate in satoshis per kilobyte: CAmount / kB\n- */\n-class CFeeRate\n-{\n-private:\n-    CAmount nSatoshisPerK; // unit is satoshis-per-1,000-bytes\n-public:\n-    /** Fee rate of 0 satoshis per kB */\n-    CFeeRate() : nSatoshisPerK(0) { }\n-    explicit CFeeRate(const CAmount& _nSatoshisPerK): nSatoshisPerK(_nSatoshisPerK) { }\n-    /** Constructor for a fee rate in satoshis per kB. The size in bytes must not exceed (2^63 - 1)*/\n-    CFeeRate(const CAmount& nFeePaid, size_t nBytes);\n-    CFeeRate(const CFeeRate& other) { nSatoshisPerK = other.nSatoshisPerK; }\n-    /**\n-     * Return the fee in satoshis for the given size in bytes.\n-     */\n-    CAmount GetFee(size_t nBytes) const;\n-    /**\n-     * Return the fee in satoshis for a size of 1000 bytes\n-     */\n-    CAmount GetFeePerK() const { return GetFee(1000); }\n-    friend bool operator<(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK < b.nSatoshisPerK; }\n-    friend bool operator>(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK > b.nSatoshisPerK; }\n-    friend bool operator==(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK == b.nSatoshisPerK; }\n-    friend bool operator<=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK <= b.nSatoshisPerK; }\n-    friend bool operator>=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK >= b.nSatoshisPerK; }\n-    CFeeRate& operator+=(const CFeeRate& a) { nSatoshisPerK += a.nSatoshisPerK; return *this; }\n-    std::string ToString() const;\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITE(nSatoshisPerK);\n-    }\n-};\n-\n #endif //  BITCOIN_AMOUNT_H"
      },
      {
        "sha": "36b3523692bfc124981b4d0d525628544f7afe56",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -134,7 +134,7 @@ bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet)\n         vchRet.clear();\n         return false;\n     }\n-    // re-calculate the checksum, insure it matches the included 4-byte checksum\n+    // re-calculate the checksum, ensure it matches the included 4-byte checksum\n     uint256 hash = Hash(vchRet.begin(), vchRet.end() - 4);\n     if (memcmp(&hash, &vchRet.end()[-4], 4) != 0) {\n         vchRet.clear();"
      },
      {
        "sha": "33631d2d150545196a1a559e5b40a140b8f00c9e",
        "filename": "src/bench/bench.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bench/bench.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bench/bench.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -5,6 +5,7 @@\n #include \"bench.h\"\n #include \"perf.h\"\n \n+#include <assert.h>\n #include <iostream>\n #include <iomanip>\n #include <sys/time.h>"
      },
      {
        "sha": "1f36f2a4bca1b07e2577aebb8392463aabe0a2b4",
        "filename": "src/bench/bench.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bench/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bench/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -5,16 +5,17 @@\n #ifndef BITCOIN_BENCH_BENCH_H\n #define BITCOIN_BENCH_BENCH_H\n \n+#include <functional>\n+#include <limits>\n #include <map>\n #include <string>\n \n-#include <boost/function.hpp>\n #include <boost/preprocessor/cat.hpp>\n #include <boost/preprocessor/stringize.hpp>\n \n // Simple micro-benchmarking framework; API mostly matches a subset of the Google Benchmark\n // framework (see https://github.com/google/benchmark)\n-// Wny not use the Google Benchmark framework? Because adding Yet Another Dependency\n+// Why not use the Google Benchmark framework? Because adding Yet Another Dependency\n // (that uses cmake as its build system and has lots of features we don't need) isn't\n // worth it.\n \n@@ -59,7 +60,7 @@ namespace benchmark {\n         bool KeepRunning();\n     };\n \n-    typedef boost::function<void(State&)> BenchFunction;\n+    typedef std::function<void(State&)> BenchFunction;\n \n     class BenchRunner\n     {"
      },
      {
        "sha": "5aab3381fd21dd64684306b01b1dfce9861212fd",
        "filename": "src/bench/ccoins_caching.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bench/ccoins_caching.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bench/ccoins_caching.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/ccoins_caching.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -35,14 +35,14 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n     dummyTransactions[0].vout[0].scriptPubKey << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n     dummyTransactions[0].vout[1].nValue = 50 * CENT;\n     dummyTransactions[0].vout[1].scriptPubKey << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\n-    coinsRet.ModifyCoins(dummyTransactions[0].GetHash())->FromTx(dummyTransactions[0], 0);\n+    AddCoins(coinsRet, dummyTransactions[0], 0);\n \n     dummyTransactions[1].vout.resize(2);\n     dummyTransactions[1].vout[0].nValue = 21 * CENT;\n     dummyTransactions[1].vout[0].scriptPubKey = GetScriptForDestination(key[2].GetPubKey().GetID());\n     dummyTransactions[1].vout[1].nValue = 22 * CENT;\n     dummyTransactions[1].vout[1].scriptPubKey = GetScriptForDestination(key[3].GetPubKey().GetID());\n-    coinsRet.ModifyCoins(dummyTransactions[1].GetHash())->FromTx(dummyTransactions[1], 0);\n+    AddCoins(coinsRet, dummyTransactions[1], 0);\n \n     return dummyTransactions;\n }"
      },
      {
        "sha": "195388839eaacb5dc1bf91b77eebb0e6d9f19e33",
        "filename": "src/bench/checkblock.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bench/checkblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bench/checkblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkblock.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -22,7 +22,7 @@ static void DeserializeBlockTest(benchmark::State& state)\n     CDataStream stream((const char*)block_bench::block413567,\n             (const char*)&block_bench::block413567[sizeof(block_bench::block413567)],\n             SER_NETWORK, PROTOCOL_VERSION);\n-    char a;\n+    char a = '\\0';\n     stream.write(&a, 1); // Prevent compaction\n \n     while (state.KeepRunning()) {\n@@ -37,18 +37,18 @@ static void DeserializeAndCheckBlockTest(benchmark::State& state)\n     CDataStream stream((const char*)block_bench::block413567,\n             (const char*)&block_bench::block413567[sizeof(block_bench::block413567)],\n             SER_NETWORK, PROTOCOL_VERSION);\n-    char a;\n+    char a = '\\0';\n     stream.write(&a, 1); // Prevent compaction\n \n-    Consensus::Params params = Params(CBaseChainParams::MAIN).GetConsensus();\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n \n     while (state.KeepRunning()) {\n         CBlock block; // Note that CBlock caches its checked state, so we need to recreate it here\n         stream >> block;\n         assert(stream.Rewind(sizeof(block_bench::block413567)));\n \n         CValidationState validationState;\n-        assert(CheckBlock(block, validationState, params));\n+        assert(CheckBlock(block, validationState, chainParams->GetConsensus()));\n     }\n }\n "
      },
      {
        "sha": "88a2a570f93d2a83aae94700ea7b854426f54c9e",
        "filename": "src/bench/checkqueue.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bench/checkqueue.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bench/checkqueue.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkqueue.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -68,7 +68,7 @@ static void CCheckQueueSpeedPrevectorJob(benchmark::State& state)\n         PrevectorJob(){\n         }\n         PrevectorJob(FastRandomContext& insecure_rand){\n-            p.resize(insecure_rand.rand32() % (PREVECTOR_SIZE*2));\n+            p.resize(insecure_rand.randrange(PREVECTOR_SIZE*2));\n         }\n         bool operator()()\n         {"
      },
      {
        "sha": "42891f345b7c8e7cb57800427891b51e1844c81e",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -48,7 +48,7 @@ static void CoinSelection(benchmark::State& state)\n             addCoin(1000 * COIN, wallet, vCoins);\n         addCoin(3 * COIN, wallet, vCoins);\n \n-        std::set<std::pair<const CWalletTx*, unsigned int> > setCoinsRet;\n+        std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n         bool success = wallet.SelectCoinsMinConf(1003 * COIN, 1, 6, 0, vCoins, setCoinsRet, nValueRet);\n         assert(success);"
      },
      {
        "sha": "2914a36c7b92ade59e0fa9c2208647155c762cb5",
        "filename": "src/bench/crypto_hash.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bench/crypto_hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bench/crypto_hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/crypto_hash.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -7,6 +7,7 @@\n #include \"bench.h\"\n #include \"bloom.h\"\n #include \"hash.h\"\n+#include \"random.h\"\n #include \"uint256.h\"\n #include \"utiltime.h\"\n #include \"crypto/ripemd160.h\"\n@@ -69,10 +70,34 @@ static void SipHash_32b(benchmark::State& state)\n     }\n }\n \n+static void FastRandom_32bit(benchmark::State& state)\n+{\n+    FastRandomContext rng(true);\n+    uint32_t x = 0;\n+    while (state.KeepRunning()) {\n+        for (int i = 0; i < 1000000; i++) {\n+            x += rng.rand32();\n+        }\n+    }\n+}\n+\n+static void FastRandom_1bit(benchmark::State& state)\n+{\n+    FastRandomContext rng(true);\n+    uint32_t x = 0;\n+    while (state.KeepRunning()) {\n+        for (int i = 0; i < 1000000; i++) {\n+            x += rng.randbool();\n+        }\n+    }\n+}\n+\n BENCHMARK(RIPEMD160);\n BENCHMARK(SHA1);\n BENCHMARK(SHA256);\n BENCHMARK(SHA512);\n \n BENCHMARK(SHA256_32b);\n BENCHMARK(SipHash_32b);\n+BENCHMARK(FastRandom_32bit);\n+BENCHMARK(FastRandom_1bit);"
      },
      {
        "sha": "885b787b4da09815fd6ba79038608f0b9e8c0281",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -9,12 +9,12 @@\n \n #include \"chainparamsbase.h\"\n #include \"clientversion.h\"\n+#include \"fs.h\"\n #include \"rpc/client.h\"\n #include \"rpc/protocol.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n \n-#include <boost/filesystem/operations.hpp>\n #include <stdio.h>\n \n #include <event2/buffer.h>\n@@ -30,6 +30,8 @@ static const int CONTINUE_EXECUTION=-1;\n \n std::string HelpMessageCli()\n {\n+    const auto defaultBaseParams = CreateBaseChainParams(CBaseChainParams::MAIN);\n+    const auto testnetBaseParams = CreateBaseChainParams(CBaseChainParams::TESTNET);\n     std::string strUsage;\n     strUsage += HelpMessageGroup(_(\"Options:\"));\n     strUsage += HelpMessageOpt(\"-?\", _(\"This help message\"));\n@@ -38,7 +40,7 @@ std::string HelpMessageCli()\n     AppendParamsHelpMessages(strUsage);\n     strUsage += HelpMessageOpt(\"-named\", strprintf(_(\"Pass named instead of positional arguments (default: %s)\"), DEFAULT_NAMED));\n     strUsage += HelpMessageOpt(\"-rpcconnect=<ip>\", strprintf(_(\"Send commands to node running on <ip> (default: %s)\"), DEFAULT_RPCCONNECT));\n-    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\"), BaseParams(CBaseChainParams::MAIN).RPCPort(), BaseParams(CBaseChainParams::TESTNET).RPCPort()));\n+    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Connect to JSON-RPC on <port> (default: %u or testnet: %u)\"), defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()));\n     strUsage += HelpMessageOpt(\"-rpcwait\", _(\"Wait for RPC server to start\"));\n     strUsage += HelpMessageOpt(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));\n@@ -96,7 +98,7 @@ static int AppInitRPC(int argc, char* argv[])\n         }\n         return EXIT_SUCCESS;\n     }\n-    if (!boost::filesystem::is_directory(GetDataDir(false))) {\n+    if (!fs::is_directory(GetDataDir(false))) {\n         fprintf(stderr, \"Error: Specified data directory \\\"%s\\\" does not exist.\\n\", GetArg(\"-datadir\", \"\").c_str());\n         return EXIT_FAILURE;\n     }"
      },
      {
        "sha": "499e7ea9265f082058e72b5fad34a6736a3a70cd",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 17,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -13,6 +13,7 @@\n #include \"core_io.h\"\n #include \"keystore.h\"\n #include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n #include \"primitives/transaction.h\"\n #include \"script/script.h\"\n #include \"script/sign.h\"\n@@ -24,7 +25,6 @@\n #include <stdio.h>\n \n #include <boost/algorithm/string.hpp>\n-#include <boost/assign/list_of.hpp>\n \n static bool fCreateBlank;\n static std::map<std::string,UniValue> registers;\n@@ -77,6 +77,7 @@ static int AppInitRawTx(int argc, char* argv[])\n         strUsage += HelpMessageOpt(\"in=TXID:VOUT(:SEQUENCE_NUMBER)\", _(\"Add input to TX\"));\n         strUsage += HelpMessageOpt(\"locktime=N\", _(\"Set TX lock time to N\"));\n         strUsage += HelpMessageOpt(\"nversion=N\", _(\"Set TX version to N\"));\n+        strUsage += HelpMessageOpt(\"rbfoptin(=N)\", _(\"Set RBF opt-in sequence number for input N (if not provided, opt-in all available inputs)\"));\n         strUsage += HelpMessageOpt(\"outaddr=VALUE:ADDRESS\", _(\"Add address-based output to TX\"));\n         strUsage += HelpMessageOpt(\"outpubkey=VALUE:PUBKEY[:FLAGS]\", _(\"Add pay-to-pubkey output to TX\") + \". \" +\n             _(\"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-pubkey-hash output\") + \". \" +\n@@ -202,6 +203,26 @@ static void MutateTxLocktime(CMutableTransaction& tx, const std::string& cmdVal)\n     tx.nLockTime = (unsigned int) newLocktime;\n }\n \n+static void MutateTxRBFOptIn(CMutableTransaction& tx, const std::string& strInIdx)\n+{\n+    // parse requested index\n+    int inIdx = atoi(strInIdx);\n+    if (inIdx < 0 || inIdx >= (int)tx.vin.size()) {\n+        throw std::runtime_error(\"Invalid TX input index '\" + strInIdx + \"'\");\n+    }\n+\n+    // set the nSequence to MAX_INT - 2 (= RBF opt in flag)\n+    int cnt = 0;\n+    for (CTxIn& txin : tx.vin) {\n+        if (strInIdx == \"\" || cnt == inIdx) {\n+            if (txin.nSequence > MAX_BIP125_RBF_SEQUENCE) {\n+                txin.nSequence = MAX_BIP125_RBF_SEQUENCE;\n+            }\n+        }\n+        ++cnt;\n+    }\n+}\n+\n static void MutateTxAddInput(CMutableTransaction& tx, const std::string& strInput)\n {\n     std::vector<std::string> vStrInputParts;\n@@ -242,6 +263,9 @@ static void MutateTxAddOutAddr(CMutableTransaction& tx, const std::string& strIn\n     std::vector<std::string> vStrInputParts;\n     boost::split(vStrInputParts, strInput, boost::is_any_of(\":\"));\n \n+    if (vStrInputParts.size() != 2)\n+        throw std::runtime_error(\"TX output missing or too many separators\");\n+\n     // Extract and validate VALUE\n     CAmount value = ExtractAndValidateValue(vStrInputParts[0]);\n \n@@ -264,6 +288,9 @@ static void MutateTxAddOutPubKey(CMutableTransaction& tx, const std::string& str\n     std::vector<std::string> vStrInputParts;\n     boost::split(vStrInputParts, strInput, boost::is_any_of(\":\"));\n \n+    if (vStrInputParts.size() < 2 || vStrInputParts.size() > 3)\n+        throw std::runtime_error(\"TX output missing or too many separators\");\n+\n     // Extract and validate VALUE\n     CAmount value = ExtractAndValidateValue(vStrInputParts[0]);\n \n@@ -540,7 +567,11 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n             if (!prevOut.isObject())\n                 throw std::runtime_error(\"expected prevtxs internal object\");\n \n-            std::map<std::string,UniValue::VType> types = boost::assign::map_list_of(\"txid\", UniValue::VSTR)(\"vout\",UniValue::VNUM)(\"scriptPubKey\",UniValue::VSTR);\n+            std::map<std::string, UniValue::VType> types = {\n+                {\"txid\", UniValue::VSTR},\n+                {\"vout\", UniValue::VNUM},\n+                {\"scriptPubKey\", UniValue::VSTR},\n+            };\n             if (!prevOut.checkObject(types))\n                 throw std::runtime_error(\"prevtxs internal object typecheck fail\");\n \n@@ -550,24 +581,26 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n             if (nOut < 0)\n                 throw std::runtime_error(\"vout must be positive\");\n \n+            COutPoint out(txid, nOut);\n             std::vector<unsigned char> pkData(ParseHexUV(prevOut[\"scriptPubKey\"], \"scriptPubKey\"));\n             CScript scriptPubKey(pkData.begin(), pkData.end());\n \n             {\n-                CCoinsModifier coins = view.ModifyCoins(txid);\n-                if (coins->IsAvailable(nOut) && coins->vout[nOut].scriptPubKey != scriptPubKey) {\n+                const Coin& coin = view.AccessCoin(out);\n+                if (!coin.IsSpent() && coin.out.scriptPubKey != scriptPubKey) {\n                     std::string err(\"Previous output scriptPubKey mismatch:\\n\");\n-                    err = err + ScriptToAsmStr(coins->vout[nOut].scriptPubKey) + \"\\nvs:\\n\"+\n+                    err = err + ScriptToAsmStr(coin.out.scriptPubKey) + \"\\nvs:\\n\"+\n                         ScriptToAsmStr(scriptPubKey);\n                     throw std::runtime_error(err);\n                 }\n-                if ((unsigned int)nOut >= coins->vout.size())\n-                    coins->vout.resize(nOut+1);\n-                coins->vout[nOut].scriptPubKey = scriptPubKey;\n-                coins->vout[nOut].nValue = 0;\n+                Coin newcoin;\n+                newcoin.out.scriptPubKey = scriptPubKey;\n+                newcoin.out.nValue = 0;\n                 if (prevOut.exists(\"amount\")) {\n-                    coins->vout[nOut].nValue = AmountFromValue(prevOut[\"amount\"]);\n+                    newcoin.out.nValue = AmountFromValue(prevOut[\"amount\"]);\n                 }\n+                newcoin.nHeight = 1;\n+                view.AddCoin(out, std::move(newcoin), true);\n             }\n \n             // if redeemScript given and private keys given,\n@@ -589,13 +622,13 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n     // Sign what we can:\n     for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n         CTxIn& txin = mergedTx.vin[i];\n-        const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n-        if (!coins || !coins->IsAvailable(txin.prevout.n)) {\n+        const Coin& coin = view.AccessCoin(txin.prevout);\n+        if (coin.IsSpent()) {\n             fComplete = false;\n             continue;\n         }\n-        const CScript& prevPubKey = coins->vout[txin.prevout.n].scriptPubKey;\n-        const CAmount& amount = coins->vout[txin.prevout.n].nValue;\n+        const CScript& prevPubKey = coin.out.scriptPubKey;\n+        const CAmount& amount = coin.out.nValue;\n \n         SignatureData sigdata;\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n@@ -641,6 +674,9 @@ static void MutateTx(CMutableTransaction& tx, const std::string& command,\n         MutateTxVersion(tx, commandVal);\n     else if (command == \"locktime\")\n         MutateTxLocktime(tx, commandVal);\n+    else if (command == \"rbfoptin\") {\n+        MutateTxRBFOptIn(tx, commandVal);\n+    }\n \n     else if (command == \"delin\")\n         MutateTxDelInput(tx, commandVal);\n@@ -651,11 +687,13 @@ static void MutateTx(CMutableTransaction& tx, const std::string& command,\n         MutateTxDelOutput(tx, commandVal);\n     else if (command == \"outaddr\")\n         MutateTxAddOutAddr(tx, commandVal);\n-    else if (command == \"outpubkey\")\n+    else if (command == \"outpubkey\") {\n+        if (!ecc) { ecc.reset(new Secp256k1Init()); }\n         MutateTxAddOutPubKey(tx, commandVal);\n-    else if (command == \"outmultisig\")\n+    } else if (command == \"outmultisig\") {\n+        if (!ecc) { ecc.reset(new Secp256k1Init()); }\n         MutateTxAddOutMultiSig(tx, commandVal);\n-    else if (command == \"outscript\")\n+    } else if (command == \"outscript\")\n         MutateTxAddOutScript(tx, commandVal);\n     else if (command == \"outdata\")\n         MutateTxAddOutData(tx, commandVal);"
      },
      {
        "sha": "5922e45801898460f8600245a61d86f60065a9d8",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 12,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -10,6 +10,7 @@\n #include \"chainparams.h\"\n #include \"clientversion.h\"\n #include \"compat.h\"\n+#include \"fs.h\"\n #include \"rpc/server.h\"\n #include \"init.h\"\n #include \"noui.h\"\n@@ -20,7 +21,6 @@\n #include \"utilstrencodings.h\"\n \n #include <boost/algorithm/string/predicate.hpp>\n-#include <boost/filesystem.hpp>\n #include <boost/thread.hpp>\n \n #include <stdio.h>\n@@ -97,7 +97,7 @@ bool AppInit(int argc, char* argv[])\n \n     try\n     {\n-        if (!boost::filesystem::is_directory(GetDataDir(false)))\n+        if (!fs::is_directory(GetDataDir(false)))\n         {\n             fprintf(stderr, \"Error: Specified data directory \\\"%s\\\" does not exist.\\n\", GetArg(\"-datadir\", \"\").c_str());\n             return false;\n@@ -117,17 +117,14 @@ bool AppInit(int argc, char* argv[])\n             return false;\n         }\n \n-        // Command-line RPC\n-        bool fCommandLine = false;\n-        for (int i = 1; i < argc; i++)\n-            if (!IsSwitchChar(argv[i][0]) && !boost::algorithm::istarts_with(argv[i], \"bitcoin:\"))\n-                fCommandLine = true;\n-\n-        if (fCommandLine)\n-        {\n-            fprintf(stderr, \"Error: There is no RPC client functionality in bitcoind anymore. Use the bitcoin-cli utility instead.\\n\");\n-            exit(EXIT_FAILURE);\n+        // Error out when loose non-argument tokens are encountered on command line\n+        for (int i = 1; i < argc; i++) {\n+            if (!IsSwitchChar(argv[i][0])) {\n+                fprintf(stderr, \"Error: Command line contains unexpected token '%s', see bitcoind -h for a list of options.\\n\", argv[i]);\n+                exit(EXIT_FAILURE);\n+            }\n         }\n+\n         // -server defaults to true for bitcoind but not for the GUI so do this here\n         SoftSetBoolArg(\"-server\", true);\n         // Set this early so that parameter interactions go to console"
      },
      {
        "sha": "ee2c65498070ced771dcbe454eeb68fd10fe5aaa",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -147,7 +147,7 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n                 // request it.\n                 // This should be rare enough that the extra bandwidth doesn't matter,\n                 // but eating a round-trip due to FillBlock failure would be annoying\n-                // Note that we dont want duplication between extra_txn and mempool to\n+                // Note that we don't want duplication between extra_txn and mempool to\n                 // trigger this case, so we compare witness hashes first\n                 if (txn_available[idit->second] &&\n                         txn_available[idit->second]->GetWitnessHash() != extra_txn[i].second->GetWitnessHash()) {\n@@ -164,7 +164,7 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n             break;\n     }\n \n-    LogPrint(\"cmpctblock\", \"Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\\n\", cmpctblock.header.GetHash().ToString(), GetSerializeSize(cmpctblock, SER_NETWORK, PROTOCOL_VERSION));\n+    LogPrint(BCLog::CMPCTBLOCK, \"Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\\n\", cmpctblock.header.GetHash().ToString(), GetSerializeSize(cmpctblock, SER_NETWORK, PROTOCOL_VERSION));\n \n     return READ_STATUS_OK;\n }\n@@ -209,10 +209,11 @@ ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<\n         return READ_STATUS_CHECKBLOCK_FAILED;\n     }\n \n-    LogPrint(\"cmpctblock\", \"Successfully reconstructed block %s with %lu txn prefilled, %lu txn from mempool (incl at least %lu from extra pool) and %lu txn requested\\n\", hash.ToString(), prefilled_count, mempool_count, extra_count, vtx_missing.size());\n+    LogPrint(BCLog::CMPCTBLOCK, \"Successfully reconstructed block %s with %lu txn prefilled, %lu txn from mempool (incl at least %lu from extra pool) and %lu txn requested\\n\", hash.ToString(), prefilled_count, mempool_count, extra_count, vtx_missing.size());\n     if (vtx_missing.size() < 5) {\n-        for (const auto& tx : vtx_missing)\n-            LogPrint(\"cmpctblock\", \"Reconstructed block %s required tx %s\\n\", hash.ToString(), tx->GetHash().ToString());\n+        for (const auto& tx : vtx_missing) {\n+            LogPrint(BCLog::CMPCTBLOCK, \"Reconstructed block %s required tx %s\\n\", hash.ToString(), tx->GetHash().ToString());\n+        }\n     }\n \n     return READ_STATUS_OK;"
      },
      {
        "sha": "7ed982c984ce906f53cda4ac39855265dc838080",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -19,7 +19,7 @@\n #define LN2SQUARED 0.4804530139182014246671025263266649717305529515945455\n #define LN2 0.6931471805599453094172321214581765680755001343602552\n \n-CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn, unsigned char nFlagsIn) :\n+CBloomFilter::CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweakIn, unsigned char nFlagsIn) :\n     /**\n      * The ideal size for a bloom filter with a given number of elements and false positive rate is:\n      * - nElements * log(fp rate) / ln(2)^2\n@@ -40,7 +40,7 @@ CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int\n }\n \n // Private constructor used by CRollingBloomFilter\n-CBloomFilter::CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweakIn) :\n+CBloomFilter::CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweakIn) :\n     vData((unsigned int)(-1  / LN2SQUARED * nElements * log(nFPRate)) / 8),\n     isFull(false),\n     isEmpty(true),\n@@ -120,7 +120,7 @@ void CBloomFilter::clear()\n     isEmpty = true;\n }\n \n-void CBloomFilter::reset(unsigned int nNewTweak)\n+void CBloomFilter::reset(const unsigned int nNewTweak)\n {\n     clear();\n     nTweak = nNewTweak;\n@@ -214,7 +214,7 @@ void CBloomFilter::UpdateEmptyFull()\n     isEmpty = empty;\n }\n \n-CRollingBloomFilter::CRollingBloomFilter(unsigned int nElements, double fpRate)\n+CRollingBloomFilter::CRollingBloomFilter(const unsigned int nElements, const double fpRate)\n {\n     double logFpRate = log(fpRate);\n     /* The optimal number of hash functions is log(fpRate) / log(0.5), but"
      },
      {
        "sha": "7ca96822396b909ec076e7f2f562b7d0f1766133",
        "filename": "src/bloom.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bloom.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/bloom.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -54,7 +54,7 @@ class CBloomFilter\n     unsigned int Hash(unsigned int nHashNum, const std::vector<unsigned char>& vDataToHash) const;\n \n     // Private constructor for CRollingBloomFilter, no restrictions on size\n-    CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweak);\n+    CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweak);\n     friend class CRollingBloomFilter;\n \n public:\n@@ -67,7 +67,7 @@ class CBloomFilter\n      * It should generally always be a random value (and is largely only exposed for unit testing)\n      * nFlags should be one of the BLOOM_UPDATE_* enums (not _MASK)\n      */\n-    CBloomFilter(unsigned int nElements, double nFPRate, unsigned int nTweak, unsigned char nFlagsIn);\n+    CBloomFilter(const unsigned int nElements, const double nFPRate, const unsigned int nTweak, unsigned char nFlagsIn);\n     CBloomFilter() : isFull(true), isEmpty(false), nHashFuncs(0), nTweak(0), nFlags(0) {}\n \n     ADD_SERIALIZE_METHODS;\n@@ -89,7 +89,7 @@ class CBloomFilter\n     bool contains(const uint256& hash) const;\n \n     void clear();\n-    void reset(unsigned int nNewTweak);\n+    void reset(const unsigned int nNewTweak);\n \n     //! True if the size is <= MAX_BLOOM_FILTER_SIZE and the number of hash functions is <= MAX_HASH_FUNCS\n     //! (catch a filter which was just deserialized which was too big)\n@@ -122,7 +122,7 @@ class CRollingBloomFilter\n     // A random bloom filter calls GetRand() at creation time.\n     // Don't create global CRollingBloomFilter objects, as they may be\n     // constructed before the randomizer is properly initialized.\n-    CRollingBloomFilter(unsigned int nElements, double nFPRate);\n+    CRollingBloomFilter(const unsigned int nElements, const double nFPRate);\n \n     void insert(const std::vector<unsigned char>& vKey);\n     void insert(const uint256& hash);"
      },
      {
        "sha": "3b42c5fb23e22c41574710190e5fa28b83fbd92f",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 49,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -12,8 +12,6 @@\n \n #include <assert.h>\n \n-#include <boost/assign/list_of.hpp>\n-\n #include \"chainparamsseeds.h\"\n \n static CBlock CreateGenesisBlock(const char* pszTimestamp, const CScript& genesisOutputScript, uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)\n@@ -55,6 +53,12 @@ static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits\n     return CreateGenesisBlock(pszTimestamp, genesisOutputScript, nTime, nNonce, nBits, nVersion, genesisReward);\n }\n \n+void CChainParams::UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n+{\n+    consensus.vDeployments[d].nStartTime = nStartTime;\n+    consensus.vDeployments[d].nTimeout = nTimeout;\n+}\n+\n /**\n  * Main network\n  */\n@@ -130,8 +134,8 @@ class CMainParams : public CChainParams {\n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);\n         base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,128);\n-        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x88)(0xB2)(0x1E).convert_to_container<std::vector<unsigned char> >();\n-        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x88)(0xAD)(0xE4).convert_to_container<std::vector<unsigned char> >();\n+        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x88, 0xB2, 0x1E};\n+        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x88, 0xAD, 0xE4};\n \n         vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_main, pnSeed6_main + ARRAYLEN(pnSeed6_main));\n \n@@ -140,20 +144,21 @@ class CMainParams : public CChainParams {\n         fMineBlocksOnDemand = false;\n \n         checkpointData = (CCheckpointData) {\n-            boost::assign::map_list_of\n-            ( 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\"))\n-            ( 33333, uint256S(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\"))\n-            ( 74000, uint256S(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\"))\n-            (105000, uint256S(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\"))\n-            (134444, uint256S(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\"))\n-            (168000, uint256S(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\"))\n-            (193000, uint256S(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\"))\n-            (210000, uint256S(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\"))\n-            (216116, uint256S(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\"))\n-            (225430, uint256S(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\"))\n-            (250000, uint256S(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\"))\n-            (279000, uint256S(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\"))\n-            (295000, uint256S(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\"))\n+            {\n+                { 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\")},\n+                { 33333, uint256S(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\")},\n+                { 74000, uint256S(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\")},\n+                {105000, uint256S(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\")},\n+                {134444, uint256S(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\")},\n+                {168000, uint256S(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\")},\n+                {193000, uint256S(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\")},\n+                {210000, uint256S(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\")},\n+                {216116, uint256S(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\")},\n+                {225430, uint256S(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\")},\n+                {250000, uint256S(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\")},\n+                {279000, uint256S(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\")},\n+                {295000, uint256S(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\")},\n+            }\n         };\n \n         chainTxData = ChainTxData{\n@@ -165,7 +170,6 @@ class CMainParams : public CChainParams {\n         };\n     }\n };\n-static CMainParams mainParams;\n \n /**\n  * Testnet (v3)\n@@ -229,8 +233,8 @@ class CTestNetParams : public CChainParams {\n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);\n         base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);\n-        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF).convert_to_container<std::vector<unsigned char> >();\n-        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94).convert_to_container<std::vector<unsigned char> >();\n+        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x35, 0x87, 0xCF};\n+        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x35, 0x83, 0x94};\n \n         vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_test, pnSeed6_test + ARRAYLEN(pnSeed6_test));\n \n@@ -240,8 +244,9 @@ class CTestNetParams : public CChainParams {\n \n \n         checkpointData = (CCheckpointData) {\n-            boost::assign::map_list_of\n-            ( 546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\")),\n+            {\n+                {546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\")},\n+            }\n         };\n \n         chainTxData = ChainTxData{\n@@ -253,7 +258,6 @@ class CTestNetParams : public CChainParams {\n \n     }\n };\n-static CTestNetParams testNetParams;\n \n /**\n  * Regression test\n@@ -309,9 +313,10 @@ class CRegTestParams : public CChainParams {\n         fRequireStandard = false;\n         fMineBlocksOnDemand = true;\n \n-        checkpointData = (CCheckpointData){\n-            boost::assign::map_list_of\n-            ( 0, uint256S(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"))\n+        checkpointData = (CCheckpointData) {\n+            {\n+                {0, uint256S(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\")},\n+            }\n         };\n \n         chainTxData = ChainTxData{\n@@ -323,45 +328,36 @@ class CRegTestParams : public CChainParams {\n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);\n         base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);\n-        base58Prefixes[EXT_PUBLIC_KEY] = boost::assign::list_of(0x04)(0x35)(0x87)(0xCF).convert_to_container<std::vector<unsigned char> >();\n-        base58Prefixes[EXT_SECRET_KEY] = boost::assign::list_of(0x04)(0x35)(0x83)(0x94).convert_to_container<std::vector<unsigned char> >();\n-    }\n-\n-    void UpdateBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n-    {\n-        consensus.vDeployments[d].nStartTime = nStartTime;\n-        consensus.vDeployments[d].nTimeout = nTimeout;\n+        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x35, 0x87, 0xCF};\n+        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x35, 0x83, 0x94};\n     }\n };\n-static CRegTestParams regTestParams;\n \n-static CChainParams *pCurrentParams = 0;\n+static std::unique_ptr<CChainParams> globalChainParams;\n \n const CChainParams &Params() {\n-    assert(pCurrentParams);\n-    return *pCurrentParams;\n+    assert(globalChainParams);\n+    return *globalChainParams;\n }\n \n-CChainParams& Params(const std::string& chain)\n+std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain)\n {\n     if (chain == CBaseChainParams::MAIN)\n-            return mainParams;\n+        return std::unique_ptr<CChainParams>(new CMainParams());\n     else if (chain == CBaseChainParams::TESTNET)\n-            return testNetParams;\n+        return std::unique_ptr<CChainParams>(new CTestNetParams());\n     else if (chain == CBaseChainParams::REGTEST)\n-            return regTestParams;\n-    else\n-        throw std::runtime_error(strprintf(\"%s: Unknown chain %s.\", __func__, chain));\n+        return std::unique_ptr<CChainParams>(new CRegTestParams());\n+    throw std::runtime_error(strprintf(\"%s: Unknown chain %s.\", __func__, chain));\n }\n \n void SelectParams(const std::string& network)\n {\n     SelectBaseParams(network);\n-    pCurrentParams = &Params(network);\n+    globalChainParams = CreateChainParams(network);\n }\n \n-void UpdateRegtestBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n+void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n {\n-    regTestParams.UpdateBIP9Parameters(d, nStartTime, nTimeout);\n+    globalChainParams->UpdateVersionBitsParameters(d, nStartTime, nTimeout);\n }\n- "
      },
      {
        "sha": "a2f136171bd33384f11ef65d3805d2976ebc084f",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 11,
        "deletions": 7,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -11,6 +11,7 @@\n #include \"primitives/block.h\"\n #include \"protocol.h\"\n \n+#include <memory>\n #include <vector>\n \n struct CDNSSeedData {\n@@ -75,6 +76,7 @@ class CChainParams\n     const std::vector<SeedSpec6>& FixedSeeds() const { return vFixedSeeds; }\n     const CCheckpointData& Checkpoints() const { return checkpointData; }\n     const ChainTxData& TxData() const { return chainTxData; }\n+    void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);\n protected:\n     CChainParams() {}\n \n@@ -95,15 +97,17 @@ class CChainParams\n };\n \n /**\n- * Return the currently selected parameters. This won't change after app\n- * startup, except for unit tests.\n+ * Creates and returns a std::unique_ptr<CChainParams> of the chosen chain.\n+ * @returns a CChainParams* of the chosen chain.\n+ * @throws a std::runtime_error if the chain is not supported.\n  */\n-const CChainParams &Params();\n+std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain);\n \n /**\n- * @returns CChainParams for the given BIP70 chain name.\n+ * Return the currently selected parameters. This won't change after app\n+ * startup, except for unit tests.\n  */\n-CChainParams& Params(const std::string& chain);\n+const CChainParams &Params();\n \n /**\n  * Sets the params returned by Params() to those for the given BIP70 chain name.\n@@ -112,8 +116,8 @@ CChainParams& Params(const std::string& chain);\n void SelectParams(const std::string& chain);\n \n /**\n- * Allows modifying the BIP9 regtest parameters.\n+ * Allows modifying the Version Bits regtest parameters.\n  */\n-void UpdateRegtestBIP9Parameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);\n+void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout);\n \n #endif // BITCOIN_CHAINPARAMS_H"
      },
      {
        "sha": "43c9a13c5468b8e01e1f25f5d9b91d6aa8d8a392",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 16,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -35,7 +35,6 @@ class CBaseMainParams : public CBaseChainParams\n         nRPCPort = 8332;\n     }\n };\n-static CBaseMainParams mainParams;\n \n /**\n  * Testnet (v3)\n@@ -49,7 +48,6 @@ class CBaseTestNetParams : public CBaseChainParams\n         strDataDir = \"testnet3\";\n     }\n };\n-static CBaseTestNetParams testNetParams;\n \n /*\n  * Regression test\n@@ -63,31 +61,30 @@ class CBaseRegTestParams : public CBaseChainParams\n         strDataDir = \"regtest\";\n     }\n };\n-static CBaseRegTestParams regTestParams;\n \n-static CBaseChainParams* pCurrentBaseParams = 0;\n+static std::unique_ptr<CBaseChainParams> globalChainBaseParams;\n \n const CBaseChainParams& BaseParams()\n {\n-    assert(pCurrentBaseParams);\n-    return *pCurrentBaseParams;\n+    assert(globalChainBaseParams);\n+    return *globalChainBaseParams;\n }\n \n-CBaseChainParams& BaseParams(const std::string& chain)\n+std::unique_ptr<CBaseChainParams> CreateBaseChainParams(const std::string& chain)\n {\n     if (chain == CBaseChainParams::MAIN)\n-        return mainParams;\n+        return std::unique_ptr<CBaseChainParams>(new CBaseMainParams());\n     else if (chain == CBaseChainParams::TESTNET)\n-        return testNetParams;\n+        return std::unique_ptr<CBaseChainParams>(new CBaseTestNetParams());\n     else if (chain == CBaseChainParams::REGTEST)\n-        return regTestParams;\n+        return std::unique_ptr<CBaseChainParams>(new CBaseRegTestParams());\n     else\n         throw std::runtime_error(strprintf(\"%s: Unknown chain %s.\", __func__, chain));\n }\n \n void SelectBaseParams(const std::string& chain)\n {\n-    pCurrentBaseParams = &BaseParams(chain);\n+    globalChainBaseParams = CreateBaseChainParams(chain);\n }\n \n std::string ChainNameFromCommandLine()\n@@ -103,8 +100,3 @@ std::string ChainNameFromCommandLine()\n         return CBaseChainParams::TESTNET;\n     return CBaseChainParams::MAIN;\n }\n-\n-bool AreBaseParamsConfigured()\n-{\n-    return pCurrentBaseParams != NULL;\n-}"
      },
      {
        "sha": "fc101f5b774c23a483c26dab115ac2675514ec11",
        "filename": "src/chainparamsbase.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/chainparamsbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/chainparamsbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -5,6 +5,7 @@\n #ifndef BITCOIN_CHAINPARAMSBASE_H\n #define BITCOIN_CHAINPARAMSBASE_H\n \n+#include <memory>\n #include <string>\n #include <vector>\n \n@@ -30,6 +31,13 @@ class CBaseChainParams\n     std::string strDataDir;\n };\n \n+/**\n+ * Creates and returns a std::unique_ptr<CBaseChainParams> of the chosen chain.\n+ * @returns a CBaseChainParams* of the chosen chain.\n+ * @throws a std::runtime_error if the chain is not supported.\n+ */\n+std::unique_ptr<CBaseChainParams> CreateBaseChainParams(const std::string& chain);\n+\n /**\n  * Append the help messages for the chainparams options to the\n  * parameter string.\n@@ -42,8 +50,6 @@ void AppendParamsHelpMessages(std::string& strUsage, bool debugHelp=true);\n  */\n const CBaseChainParams& BaseParams();\n \n-CBaseChainParams& BaseParams(const std::string& chain);\n-\n /** Sets the params returned by Params() to those for the given network. */\n void SelectBaseParams(const std::string& chain);\n \n@@ -53,10 +59,4 @@ void SelectBaseParams(const std::string& chain);\n  */\n std::string ChainNameFromCommandLine();\n \n-/**\n- * Return true if SelectBaseParamsFromCommandLine() has been called to select\n- * a network.\n- */\n-bool AreBaseParamsConfigured();\n-\n #endif // BITCOIN_CHAINPARAMSBASE_H"
      },
      {
        "sha": "63c104c02a114a4fa350de9ce6a58675a8b224db",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -5,6 +5,8 @@\n #ifndef BITCOIN_CHECKQUEUE_H\n #define BITCOIN_CHECKQUEUE_H\n \n+#include \"sync.h\"\n+\n #include <algorithm>\n #include <vector>\n "
      },
      {
        "sha": "3d5392619b1beebb4c4ff812127f5306e2e1d153",
        "filename": "src/clientversion.h",
        "status": "modified",
        "additions": 5,
        "deletions": 21,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/clientversion.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/clientversion.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -7,29 +7,13 @@\n \n #if defined(HAVE_CONFIG_H)\n #include \"config/bitcoin-config.h\"\n-#else\n-\n-/**\n- * client versioning and copyright year\n- */\n-\n-//! These need to be macros, as clientversion.cpp's and bitcoin*-res.rc's voodoo requires it\n-#define CLIENT_VERSION_MAJOR 0\n-#define CLIENT_VERSION_MINOR 14\n-#define CLIENT_VERSION_REVISION 99\n-#define CLIENT_VERSION_BUILD 0\n-\n-//! Set to true for release, false for prerelease or test build\n-#define CLIENT_VERSION_IS_RELEASE false\n-\n-/**\n- * Copyright year (2009-this)\n- * Todo: update this when changing our copyright comments in the source\n- */\n-#define COPYRIGHT_YEAR 2017\n-\n #endif //HAVE_CONFIG_H\n \n+// Check that required client information is defined\n+#if !defined(CLIENT_VERSION_MAJOR) || !defined(CLIENT_VERSION_MINOR) || !defined(CLIENT_VERSION_REVISION) || !defined(CLIENT_VERSION_BUILD) || !defined(CLIENT_VERSION_IS_RELEASE) || !defined(COPYRIGHT_YEAR)\n+#error Client version information missing: version is not defined by bitcoin-config.h or in any other way\n+#endif\n+\n /**\n  * Converts the parameter X to a string after macro replacement on X has been performed.\n  * Don't merge these into one macro!"
      },
      {
        "sha": "b45fc76338183d027d525861a7bb51bd25237899",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 90,
        "deletions": 158,
        "changes": 248,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -4,174 +4,126 @@\n \n #include \"coins.h\"\n \n+#include \"consensus/consensus.h\"\n #include \"memusage.h\"\n #include \"random.h\"\n \n #include <assert.h>\n \n-/**\n- * calculate number of bytes for the bitmask, and its number of non-zero bytes\n- * each bit in the bitmask represents the availability of one output, but the\n- * availabilities of the first two outputs are encoded separately\n- */\n-void CCoins::CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const {\n-    unsigned int nLastUsedByte = 0;\n-    for (unsigned int b = 0; 2+b*8 < vout.size(); b++) {\n-        bool fZero = true;\n-        for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++) {\n-            if (!vout[2+b*8+i].IsNull()) {\n-                fZero = false;\n-                continue;\n-            }\n-        }\n-        if (!fZero) {\n-            nLastUsedByte = b + 1;\n-            nNonzeroBytes++;\n-        }\n-    }\n-    nBytes += nLastUsedByte;\n-}\n-\n-bool CCoins::Spend(uint32_t nPos) \n-{\n-    if (nPos >= vout.size() || vout[nPos].IsNull())\n-        return false;\n-    vout[nPos].SetNull();\n-    Cleanup();\n-    return true;\n-}\n-\n-bool CCoinsView::GetCoins(const uint256 &txid, CCoins &coins) const { return false; }\n-bool CCoinsView::HaveCoins(const uint256 &txid) const { return false; }\n+bool CCoinsView::GetCoin(const COutPoint &outpoint, Coin &coin) const { return false; }\n+bool CCoinsView::HaveCoin(const COutPoint &outpoint) const { return false; }\n uint256 CCoinsView::GetBestBlock() const { return uint256(); }\n bool CCoinsView::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return false; }\n CCoinsViewCursor *CCoinsView::Cursor() const { return 0; }\n \n \n CCoinsViewBacked::CCoinsViewBacked(CCoinsView *viewIn) : base(viewIn) { }\n-bool CCoinsViewBacked::GetCoins(const uint256 &txid, CCoins &coins) const { return base->GetCoins(txid, coins); }\n-bool CCoinsViewBacked::HaveCoins(const uint256 &txid) const { return base->HaveCoins(txid); }\n+bool CCoinsViewBacked::GetCoin(const COutPoint &outpoint, Coin &coin) const { return base->GetCoin(outpoint, coin); }\n+bool CCoinsViewBacked::HaveCoin(const COutPoint &outpoint) const { return base->HaveCoin(outpoint); }\n uint256 CCoinsViewBacked::GetBestBlock() const { return base->GetBestBlock(); }\n void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n CCoinsViewCursor *CCoinsViewBacked::Cursor() const { return base->Cursor(); }\n+size_t CCoinsViewBacked::EstimateSize() const { return base->EstimateSize(); }\n \n-SaltedTxidHasher::SaltedTxidHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}\n+SaltedOutpointHasher::SaltedOutpointHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}\n \n-CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), hasModifier(false), cachedCoinsUsage(0) { }\n-\n-CCoinsViewCache::~CCoinsViewCache()\n-{\n-    assert(!hasModifier);\n-}\n+CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), cachedCoinsUsage(0) {}\n \n size_t CCoinsViewCache::DynamicMemoryUsage() const {\n     return memusage::DynamicUsage(cacheCoins) + cachedCoinsUsage;\n }\n \n-CCoinsMap::const_iterator CCoinsViewCache::FetchCoins(const uint256 &txid) const {\n-    CCoinsMap::iterator it = cacheCoins.find(txid);\n+CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const {\n+    CCoinsMap::iterator it = cacheCoins.find(outpoint);\n     if (it != cacheCoins.end())\n         return it;\n-    CCoins tmp;\n-    if (!base->GetCoins(txid, tmp))\n+    Coin tmp;\n+    if (!base->GetCoin(outpoint, tmp))\n         return cacheCoins.end();\n-    CCoinsMap::iterator ret = cacheCoins.insert(std::make_pair(txid, CCoinsCacheEntry())).first;\n-    tmp.swap(ret->second.coins);\n-    if (ret->second.coins.IsPruned()) {\n-        // The parent only has an empty entry for this txid; we can consider our\n+    CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first;\n+    if (ret->second.coin.IsSpent()) {\n+        // The parent only has an empty entry for this outpoint; we can consider our\n         // version as fresh.\n         ret->second.flags = CCoinsCacheEntry::FRESH;\n     }\n-    cachedCoinsUsage += ret->second.coins.DynamicMemoryUsage();\n+    cachedCoinsUsage += ret->second.coin.DynamicMemoryUsage();\n     return ret;\n }\n \n-bool CCoinsViewCache::GetCoins(const uint256 &txid, CCoins &coins) const {\n-    CCoinsMap::const_iterator it = FetchCoins(txid);\n+bool CCoinsViewCache::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n+    CCoinsMap::const_iterator it = FetchCoin(outpoint);\n     if (it != cacheCoins.end()) {\n-        coins = it->second.coins;\n+        coin = it->second.coin;\n         return true;\n     }\n     return false;\n }\n \n-CCoinsModifier CCoinsViewCache::ModifyCoins(const uint256 &txid) {\n-    assert(!hasModifier);\n-    std::pair<CCoinsMap::iterator, bool> ret = cacheCoins.insert(std::make_pair(txid, CCoinsCacheEntry()));\n-    size_t cachedCoinUsage = 0;\n-    if (ret.second) {\n-        if (!base->GetCoins(txid, ret.first->second.coins)) {\n-            // The parent view does not have this entry; mark it as fresh.\n-            ret.first->second.coins.Clear();\n-            ret.first->second.flags = CCoinsCacheEntry::FRESH;\n-        } else if (ret.first->second.coins.IsPruned()) {\n-            // The parent view only has a pruned entry for this; mark it as fresh.\n-            ret.first->second.flags = CCoinsCacheEntry::FRESH;\n+void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possible_overwrite) {\n+    assert(!coin.IsSpent());\n+    if (coin.out.scriptPubKey.IsUnspendable()) return;\n+    CCoinsMap::iterator it;\n+    bool inserted;\n+    std::tie(it, inserted) = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::tuple<>());\n+    bool fresh = false;\n+    if (!inserted) {\n+        cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n+    }\n+    if (!possible_overwrite) {\n+        if (!it->second.coin.IsSpent()) {\n+            throw std::logic_error(\"Adding new coin that replaces non-pruned entry\");\n         }\n-    } else {\n-        cachedCoinUsage = ret.first->second.coins.DynamicMemoryUsage();\n+        fresh = !(it->second.flags & CCoinsCacheEntry::DIRTY);\n+    }\n+    it->second.coin = std::move(coin);\n+    it->second.flags |= CCoinsCacheEntry::DIRTY | (fresh ? CCoinsCacheEntry::FRESH : 0);\n+    cachedCoinsUsage += it->second.coin.DynamicMemoryUsage();\n+}\n+\n+void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight) {\n+    bool fCoinbase = tx.IsCoinBase();\n+    const uint256& txid = tx.GetHash();\n+    for (size_t i = 0; i < tx.vout.size(); ++i) {\n+        // Pass fCoinbase as the possible_overwrite flag to AddCoin, in order to correctly\n+        // deal with the pre-BIP30 occurrences of duplicate coinbase transactions.\n+        cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), fCoinbase);\n     }\n-    // Assume that whenever ModifyCoins is called, the entry will be modified.\n-    ret.first->second.flags |= CCoinsCacheEntry::DIRTY;\n-    return CCoinsModifier(*this, ret.first, cachedCoinUsage);\n }\n \n-/* ModifyNewCoins allows for faster coin modification when creating the new\n- * outputs from a transaction.  It assumes that BIP 30 (no duplicate txids)\n- * applies and has already been tested for (or the test is not required due to\n- * BIP 34, height in coinbase).  If we can assume BIP 30 then we know that any\n- * non-coinbase transaction we are adding to the UTXO must not already exist in\n- * the utxo unless it is fully spent.  Thus we can check only if it exists DIRTY\n- * at the current level of the cache, in which case it is not safe to mark it\n- * FRESH (b/c then its spentness still needs to flushed).  If it's not dirty and\n- * doesn't exist or is pruned in the current cache, we know it either doesn't\n- * exist or is pruned in parent caches, which is the definition of FRESH.  The\n- * exception to this is the two historical violations of BIP 30 in the chain,\n- * both of which were coinbases.  We do not mark these fresh so we we can ensure\n- * that they will still be properly overwritten when spent.\n- */\n-CCoinsModifier CCoinsViewCache::ModifyNewCoins(const uint256 &txid, bool coinbase) {\n-    assert(!hasModifier);\n-    std::pair<CCoinsMap::iterator, bool> ret = cacheCoins.insert(std::make_pair(txid, CCoinsCacheEntry()));\n-    if (!coinbase) {\n-        // New coins must not already exist.\n-        if (!ret.first->second.coins.IsPruned())\n-            throw std::logic_error(\"ModifyNewCoins should not find pre-existing coins on a non-coinbase unless they are pruned!\");\n-\n-        if (!(ret.first->second.flags & CCoinsCacheEntry::DIRTY)) {\n-            // If the coin is known to be pruned (have no unspent outputs) in\n-            // the current view and the cache entry is not dirty, we know the\n-            // coin also must be pruned in the parent view as well, so it is safe\n-            // to mark this fresh.\n-            ret.first->second.flags |= CCoinsCacheEntry::FRESH;\n-        }\n+void CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n+    CCoinsMap::iterator it = FetchCoin(outpoint);\n+    if (it == cacheCoins.end()) return;\n+    cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n+    if (moveout) {\n+        *moveout = std::move(it->second.coin);\n+    }\n+    if (it->second.flags & CCoinsCacheEntry::FRESH) {\n+        cacheCoins.erase(it);\n+    } else {\n+        it->second.flags |= CCoinsCacheEntry::DIRTY;\n+        it->second.coin.Clear();\n     }\n-    ret.first->second.coins.Clear();\n-    ret.first->second.flags |= CCoinsCacheEntry::DIRTY;\n-    return CCoinsModifier(*this, ret.first, 0);\n }\n \n-const CCoins* CCoinsViewCache::AccessCoins(const uint256 &txid) const {\n-    CCoinsMap::const_iterator it = FetchCoins(txid);\n+static const Coin coinEmpty;\n+\n+const Coin& CCoinsViewCache::AccessCoin(const COutPoint &outpoint) const {\n+    CCoinsMap::const_iterator it = FetchCoin(outpoint);\n     if (it == cacheCoins.end()) {\n-        return NULL;\n+        return coinEmpty;\n     } else {\n-        return &it->second.coins;\n+        return it->second.coin;\n     }\n }\n \n-bool CCoinsViewCache::HaveCoins(const uint256 &txid) const {\n-    CCoinsMap::const_iterator it = FetchCoins(txid);\n-    // We're using vtx.empty() instead of IsPruned here for performance reasons,\n-    // as we only care about the case where a transaction was replaced entirely\n-    // in a reorganization (which wipes vout entirely, as opposed to spending\n-    // which just cleans individual outputs).\n-    return (it != cacheCoins.end() && !it->second.coins.vout.empty());\n+bool CCoinsViewCache::HaveCoin(const COutPoint &outpoint) const {\n+    CCoinsMap::const_iterator it = FetchCoin(outpoint);\n+    return (it != cacheCoins.end() && !it->second.coin.IsSpent());\n }\n \n-bool CCoinsViewCache::HaveCoinsInCache(const uint256 &txid) const {\n-    CCoinsMap::const_iterator it = cacheCoins.find(txid);\n+bool CCoinsViewCache::HaveCoinInCache(const COutPoint &outpoint) const {\n+    CCoinsMap::const_iterator it = cacheCoins.find(outpoint);\n     return it != cacheCoins.end();\n }\n \n@@ -186,19 +138,18 @@ void CCoinsViewCache::SetBestBlock(const uint256 &hashBlockIn) {\n }\n \n bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn) {\n-    assert(!hasModifier);\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) { // Ignore non-dirty entries (optimization).\n             CCoinsMap::iterator itUs = cacheCoins.find(it->first);\n             if (itUs == cacheCoins.end()) {\n                 // The parent cache does not have an entry, while the child does\n                 // We can ignore it if it's both FRESH and pruned in the child\n-                if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coins.IsPruned())) {\n+                if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coin.IsSpent())) {\n                     // Otherwise we will need to create it in the parent\n                     // and move the data up and mark it as dirty\n                     CCoinsCacheEntry& entry = cacheCoins[it->first];\n-                    entry.coins.swap(it->second.coins);\n-                    cachedCoinsUsage += entry.coins.DynamicMemoryUsage();\n+                    entry.coin = std::move(it->second.coin);\n+                    cachedCoinsUsage += entry.coin.DynamicMemoryUsage();\n                     entry.flags = CCoinsCacheEntry::DIRTY;\n                     // We can mark it FRESH in the parent if it was FRESH in the child\n                     // Otherwise it might have just been flushed from the parent's cache\n@@ -211,21 +162,21 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n                 // parent cache entry has unspent outputs. If this ever happens,\n                 // it means the FRESH flag was misapplied and there is a logic\n                 // error in the calling code.\n-                if ((it->second.flags & CCoinsCacheEntry::FRESH) && !itUs->second.coins.IsPruned())\n+                if ((it->second.flags & CCoinsCacheEntry::FRESH) && !itUs->second.coin.IsSpent())\n                     throw std::logic_error(\"FRESH flag misapplied to cache entry for base transaction with spendable outputs\");\n \n                 // Found the entry in the parent cache\n-                if ((itUs->second.flags & CCoinsCacheEntry::FRESH) && it->second.coins.IsPruned()) {\n+                if ((itUs->second.flags & CCoinsCacheEntry::FRESH) && it->second.coin.IsSpent()) {\n                     // The grandparent does not have an entry, and the child is\n                     // modified and being pruned. This means we can just delete\n                     // it from the parent.\n-                    cachedCoinsUsage -= itUs->second.coins.DynamicMemoryUsage();\n+                    cachedCoinsUsage -= itUs->second.coin.DynamicMemoryUsage();\n                     cacheCoins.erase(itUs);\n                 } else {\n                     // A normal modification.\n-                    cachedCoinsUsage -= itUs->second.coins.DynamicMemoryUsage();\n-                    itUs->second.coins.swap(it->second.coins);\n-                    cachedCoinsUsage += itUs->second.coins.DynamicMemoryUsage();\n+                    cachedCoinsUsage -= itUs->second.coin.DynamicMemoryUsage();\n+                    itUs->second.coin = std::move(it->second.coin);\n+                    cachedCoinsUsage += itUs->second.coin.DynamicMemoryUsage();\n                     itUs->second.flags |= CCoinsCacheEntry::DIRTY;\n                     // NOTE: It is possible the child has a FRESH flag here in\n                     // the event the entry we found in the parent is pruned. But\n@@ -249,11 +200,11 @@ bool CCoinsViewCache::Flush() {\n     return fOk;\n }\n \n-void CCoinsViewCache::Uncache(const uint256& hash)\n+void CCoinsViewCache::Uncache(const COutPoint& hash)\n {\n     CCoinsMap::iterator it = cacheCoins.find(hash);\n     if (it != cacheCoins.end() && it->second.flags == 0) {\n-        cachedCoinsUsage -= it->second.coins.DynamicMemoryUsage();\n+        cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n         cacheCoins.erase(it);\n     }\n }\n@@ -262,21 +213,14 @@ unsigned int CCoinsViewCache::GetCacheSize() const {\n     return cacheCoins.size();\n }\n \n-const CTxOut &CCoinsViewCache::GetOutputFor(const CTxIn& input) const\n-{\n-    const CCoins* coins = AccessCoins(input.prevout.hash);\n-    assert(coins && coins->IsAvailable(input.prevout.n));\n-    return coins->vout[input.prevout.n];\n-}\n-\n CAmount CCoinsViewCache::GetValueIn(const CTransaction& tx) const\n {\n     if (tx.IsCoinBase())\n         return 0;\n \n     CAmount nResult = 0;\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n-        nResult += GetOutputFor(tx.vin[i]).nValue;\n+        nResult += AccessCoin(tx.vin[i].prevout).out.nValue;\n \n     return nResult;\n }\n@@ -285,35 +229,23 @@ bool CCoinsViewCache::HaveInputs(const CTransaction& tx) const\n {\n     if (!tx.IsCoinBase()) {\n         for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-            const COutPoint &prevout = tx.vin[i].prevout;\n-            const CCoins* coins = AccessCoins(prevout.hash);\n-            if (!coins || !coins->IsAvailable(prevout.n)) {\n+            if (!HaveCoin(tx.vin[i].prevout)) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n \n-CCoinsModifier::CCoinsModifier(CCoinsViewCache& cache_, CCoinsMap::iterator it_, size_t usage) : cache(cache_), it(it_), cachedCoinUsage(usage) {\n-    assert(!cache.hasModifier);\n-    cache.hasModifier = true;\n-}\n+static const size_t MAX_OUTPUTS_PER_BLOCK = MAX_BLOCK_BASE_SIZE /  ::GetSerializeSize(CTxOut(), SER_NETWORK, PROTOCOL_VERSION); // TODO: merge with similar definition in undo.h.\n \n-CCoinsModifier::~CCoinsModifier()\n+const Coin& AccessByTxid(const CCoinsViewCache& view, const uint256& txid)\n {\n-    assert(cache.hasModifier);\n-    cache.hasModifier = false;\n-    it->second.coins.Cleanup();\n-    cache.cachedCoinsUsage -= cachedCoinUsage; // Subtract the old usage\n-    if ((it->second.flags & CCoinsCacheEntry::FRESH) && it->second.coins.IsPruned()) {\n-        cache.cacheCoins.erase(it);\n-    } else {\n-        // If the coin still exists after the modification, add the new usage\n-        cache.cachedCoinsUsage += it->second.coins.DynamicMemoryUsage();\n+    COutPoint iter(txid, 0);\n+    while (iter.n < MAX_OUTPUTS_PER_BLOCK) {\n+        const Coin& alternate = view.AccessCoin(iter);\n+        if (!alternate.IsSpent()) return alternate;\n+        ++iter.n;\n     }\n-}\n-\n-CCoinsViewCursor::~CCoinsViewCursor()\n-{\n+    return coinEmpty;\n }"
      },
      {
        "sha": "476db8f37c73b14cbb42adb58488a726e332093a",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 85,
        "deletions": 267,
        "changes": 352,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -6,6 +6,7 @@\n #ifndef BITCOIN_COINS_H\n #define BITCOIN_COINS_H\n \n+#include \"primitives/transaction.h\"\n #include \"compressor.h\"\n #include \"core_memusage.h\"\n #include \"hash.h\"\n@@ -17,253 +18,92 @@\n #include <stdint.h>\n \n #include <boost/foreach.hpp>\n-#include <boost/unordered_map.hpp>\n+#include <unordered_map>\n \n-/** \n- * Pruned version of CTransaction: only retains metadata and unspent transaction outputs\n+/**\n+ * A UTXO entry.\n  *\n  * Serialized format:\n- * - VARINT(nVersion)\n- * - VARINT(nCode)\n- * - unspentness bitvector, for vout[2] and further; least significant byte first\n- * - the non-spent CTxOuts (via CTxOutCompressor)\n- * - VARINT(nHeight)\n- *\n- * The nCode value consists of:\n- * - bit 0: IsCoinBase()\n- * - bit 1: vout[0] is not spent\n- * - bit 2: vout[1] is not spent\n- * - The higher bits encode N, the number of non-zero bytes in the following bitvector.\n- *   - In case both bit 1 and bit 2 are unset, they encode N-1, as there must be at\n- *     least one non-spent output).\n- *\n- * Example: 0104835800816115944e077fe7c803cfa57f29b36bf87c1d358bb85e\n- *          <><><--------------------------------------------><---->\n- *          |  \\                  |                             /\n- *    version   code             vout[1]                  height\n- *\n- *    - version = 1\n- *    - code = 4 (vout[1] is not spent, and 0 non-zero bytes of bitvector follow)\n- *    - unspentness bitvector: as 0 non-zero bytes follow, it has length 0\n- *    - vout[1]: 835800816115944e077fe7c803cfa57f29b36bf87c1d35\n- *               * 8358: compact amount representation for 60000000000 (600 BTC)\n- *               * 00: special txout type pay-to-pubkey-hash\n- *               * 816115944e077fe7c803cfa57f29b36bf87c1d35: address uint160\n- *    - height = 203998\n- *\n- *\n- * Example: 0109044086ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4eebbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa486af3b\n- *          <><><--><--------------------------------------------------><----------------------------------------------><---->\n- *         /  \\   \\                     |                                                           |                     /\n- *  version  code  unspentness       vout[4]                                                     vout[16]           height\n- *\n- *  - version = 1\n- *  - code = 9 (coinbase, neither vout[0] or vout[1] are unspent,\n- *                2 (1, +1 because both bit 1 and bit 2 are unset) non-zero bitvector bytes follow)\n- *  - unspentness bitvector: bits 2 (0x04) and 14 (0x4000) are set, so vout[2+2] and vout[14+2] are unspent\n- *  - vout[4]: 86ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4ee\n- *             * 86ef97d579: compact amount representation for 234925952 (2.35 BTC)\n- *             * 00: special txout type pay-to-pubkey-hash\n- *             * 61b01caab50f1b8e9c50a5057eb43c2d9563a4ee: address uint160\n- *  - vout[16]: bbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa4\n- *              * bbd123: compact amount representation for 110397 (0.001 BTC)\n- *              * 00: special txout type pay-to-pubkey-hash\n- *              * 8c988f1a4a4de2161e0f50aac7f17e7f9555caa4: address uint160\n- *  - height = 120891\n+ * - VARINT((coinbase ? 1 : 0) | (height << 1))\n+ * - the non-spent CTxOut (via CTxOutCompressor)\n  */\n-class CCoins\n+class Coin\n {\n public:\n-    //! whether transaction is a coinbase\n-    bool fCoinBase;\n-\n-    //! unspent transaction outputs; spent outputs are .IsNull(); spent outputs at the end of the array are dropped\n-    std::vector<CTxOut> vout;\n+    //! unspent transaction output\n+    CTxOut out;\n \n-    //! at which height this transaction was included in the active block chain\n-    int nHeight;\n+    //! whether containing transaction was a coinbase\n+    unsigned int fCoinBase : 1;\n \n-    //! version of the CTransaction; accesses to this value should probably check for nHeight as well,\n-    //! as new tx version will probably only be introduced at certain heights\n-    int nVersion;\n+    //! at which height this containing transaction was included in the active block chain\n+    uint32_t nHeight : 31;\n \n-    void FromTx(const CTransaction &tx, int nHeightIn) {\n-        fCoinBase = tx.IsCoinBase();\n-        vout = tx.vout;\n-        nHeight = nHeightIn;\n-        nVersion = tx.nVersion;\n-        ClearUnspendable();\n-    }\n-\n-    //! construct a CCoins from a CTransaction, at a given height\n-    CCoins(const CTransaction &tx, int nHeightIn) {\n-        FromTx(tx, nHeightIn);\n-    }\n+    //! construct a Coin from a CTxOut and height/coinbase information.\n+    Coin(CTxOut&& outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {}\n+    Coin(const CTxOut& outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {}\n \n     void Clear() {\n+        out.SetNull();\n         fCoinBase = false;\n-        std::vector<CTxOut>().swap(vout);\n         nHeight = 0;\n-        nVersion = 0;\n     }\n \n     //! empty constructor\n-    CCoins() : fCoinBase(false), vout(0), nHeight(0), nVersion(0) { }\n-\n-    //!remove spent outputs at the end of vout\n-    void Cleanup() {\n-        while (vout.size() > 0 && vout.back().IsNull())\n-            vout.pop_back();\n-        if (vout.empty())\n-            std::vector<CTxOut>().swap(vout);\n-    }\n-\n-    void ClearUnspendable() {\n-        BOOST_FOREACH(CTxOut &txout, vout) {\n-            if (txout.scriptPubKey.IsUnspendable())\n-                txout.SetNull();\n-        }\n-        Cleanup();\n-    }\n-\n-    void swap(CCoins &to) {\n-        std::swap(to.fCoinBase, fCoinBase);\n-        to.vout.swap(vout);\n-        std::swap(to.nHeight, nHeight);\n-        std::swap(to.nVersion, nVersion);\n-    }\n-\n-    //! equality test\n-    friend bool operator==(const CCoins &a, const CCoins &b) {\n-         // Empty CCoins objects are always equal.\n-         if (a.IsPruned() && b.IsPruned())\n-             return true;\n-         return a.fCoinBase == b.fCoinBase &&\n-                a.nHeight == b.nHeight &&\n-                a.nVersion == b.nVersion &&\n-                a.vout == b.vout;\n-    }\n-    friend bool operator!=(const CCoins &a, const CCoins &b) {\n-        return !(a == b);\n-    }\n-\n-    void CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const;\n+    Coin() : fCoinBase(false), nHeight(0) { }\n \n     bool IsCoinBase() const {\n         return fCoinBase;\n     }\n \n     template<typename Stream>\n     void Serialize(Stream &s) const {\n-        unsigned int nMaskSize = 0, nMaskCode = 0;\n-        CalcMaskSize(nMaskSize, nMaskCode);\n-        bool fFirst = vout.size() > 0 && !vout[0].IsNull();\n-        bool fSecond = vout.size() > 1 && !vout[1].IsNull();\n-        assert(fFirst || fSecond || nMaskCode);\n-        unsigned int nCode = 8*(nMaskCode - (fFirst || fSecond ? 0 : 1)) + (fCoinBase ? 1 : 0) + (fFirst ? 2 : 0) + (fSecond ? 4 : 0);\n-        // version\n-        ::Serialize(s, VARINT(this->nVersion));\n-        // header code\n-        ::Serialize(s, VARINT(nCode));\n-        // spentness bitmask\n-        for (unsigned int b = 0; b<nMaskSize; b++) {\n-            unsigned char chAvail = 0;\n-            for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++)\n-                if (!vout[2+b*8+i].IsNull())\n-                    chAvail |= (1 << i);\n-            ::Serialize(s, chAvail);\n-        }\n-        // txouts themself\n-        for (unsigned int i = 0; i < vout.size(); i++) {\n-            if (!vout[i].IsNull())\n-                ::Serialize(s, CTxOutCompressor(REF(vout[i])));\n-        }\n-        // coinbase height\n-        ::Serialize(s, VARINT(nHeight));\n+        assert(!IsSpent());\n+        uint32_t code = nHeight * 2 + fCoinBase;\n+        ::Serialize(s, VARINT(code));\n+        ::Serialize(s, CTxOutCompressor(REF(out)));\n     }\n \n     template<typename Stream>\n     void Unserialize(Stream &s) {\n-        unsigned int nCode = 0;\n-        // version\n-        ::Unserialize(s, VARINT(this->nVersion));\n-        // header code\n-        ::Unserialize(s, VARINT(nCode));\n-        fCoinBase = nCode & 1;\n-        std::vector<bool> vAvail(2, false);\n-        vAvail[0] = (nCode & 2) != 0;\n-        vAvail[1] = (nCode & 4) != 0;\n-        unsigned int nMaskCode = (nCode / 8) + ((nCode & 6) != 0 ? 0 : 1);\n-        // spentness bitmask\n-        while (nMaskCode > 0) {\n-            unsigned char chAvail = 0;\n-            ::Unserialize(s, chAvail);\n-            for (unsigned int p = 0; p < 8; p++) {\n-                bool f = (chAvail & (1 << p)) != 0;\n-                vAvail.push_back(f);\n-            }\n-            if (chAvail != 0)\n-                nMaskCode--;\n-        }\n-        // txouts themself\n-        vout.assign(vAvail.size(), CTxOut());\n-        for (unsigned int i = 0; i < vAvail.size(); i++) {\n-            if (vAvail[i])\n-                ::Unserialize(s, REF(CTxOutCompressor(vout[i])));\n-        }\n-        // coinbase height\n-        ::Unserialize(s, VARINT(nHeight));\n-        Cleanup();\n+        uint32_t code = 0;\n+        ::Unserialize(s, VARINT(code));\n+        nHeight = code >> 1;\n+        fCoinBase = code & 1;\n+        ::Unserialize(s, REF(CTxOutCompressor(out)));\n     }\n \n-    //! mark a vout spent\n-    bool Spend(uint32_t nPos);\n-\n-    //! check whether a particular output is still available\n-    bool IsAvailable(unsigned int nPos) const {\n-        return (nPos < vout.size() && !vout[nPos].IsNull());\n-    }\n-\n-    //! check whether the entire CCoins is spent\n-    //! note that only !IsPruned() CCoins can be serialized\n-    bool IsPruned() const {\n-        BOOST_FOREACH(const CTxOut &out, vout)\n-            if (!out.IsNull())\n-                return false;\n-        return true;\n+    bool IsSpent() const {\n+        return out.IsNull();\n     }\n \n     size_t DynamicMemoryUsage() const {\n-        size_t ret = memusage::DynamicUsage(vout);\n-        BOOST_FOREACH(const CTxOut &out, vout) {\n-            ret += RecursiveDynamicUsage(out.scriptPubKey);\n-        }\n-        return ret;\n+        return memusage::DynamicUsage(out.scriptPubKey);\n     }\n };\n \n-class SaltedTxidHasher\n+class SaltedOutpointHasher\n {\n private:\n     /** Salt */\n     const uint64_t k0, k1;\n \n public:\n-    SaltedTxidHasher();\n+    SaltedOutpointHasher();\n \n     /**\n      * This *must* return size_t. With Boost 1.46 on 32-bit systems the\n      * unordered_map will behave unpredictably if the custom hasher returns a\n      * uint64_t, resulting in failures when syncing the chain (#4634).\n      */\n-    size_t operator()(const uint256& txid) const {\n-        return SipHashUint256(k0, k1, txid);\n+    size_t operator()(const COutPoint& id) const {\n+        return SipHashUint256Extra(k0, k1, id.hash, id.n);\n     }\n };\n \n struct CCoinsCacheEntry\n {\n-    CCoins coins; // The actual cached data.\n+    Coin coin; // The actual cached data.\n     unsigned char flags;\n \n     enum Flags {\n@@ -276,20 +116,21 @@ struct CCoinsCacheEntry\n          */\n     };\n \n-    CCoinsCacheEntry() : coins(), flags(0) {}\n+    CCoinsCacheEntry() : flags(0) {}\n+    explicit CCoinsCacheEntry(Coin&& coin_) : coin(std::move(coin_)), flags(0) {}\n };\n \n-typedef boost::unordered_map<uint256, CCoinsCacheEntry, SaltedTxidHasher> CCoinsMap;\n+typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n \n /** Cursor for iterating over CoinsView state */\n class CCoinsViewCursor\n {\n public:\n     CCoinsViewCursor(const uint256 &hashBlockIn): hashBlock(hashBlockIn) {}\n-    virtual ~CCoinsViewCursor();\n+    virtual ~CCoinsViewCursor() {}\n \n-    virtual bool GetKey(uint256 &key) const = 0;\n-    virtual bool GetValue(CCoins &coins) const = 0;\n+    virtual bool GetKey(COutPoint &key) const = 0;\n+    virtual bool GetValue(Coin &coin) const = 0;\n     virtual unsigned int GetValueSize() const = 0;\n \n     virtual bool Valid() const = 0;\n@@ -305,17 +146,17 @@ class CCoinsViewCursor\n class CCoinsView\n {\n public:\n-    //! Retrieve the CCoins (unspent transaction outputs) for a given txid\n-    virtual bool GetCoins(const uint256 &txid, CCoins &coins) const;\n+    //! Retrieve the Coin (unspent transaction output) for a given outpoint.\n+    virtual bool GetCoin(const COutPoint &outpoint, Coin &coin) const;\n \n-    //! Just check whether we have data for a given txid.\n-    //! This may (but cannot always) return true for fully spent transactions\n-    virtual bool HaveCoins(const uint256 &txid) const;\n+    //! Just check whether we have data for a given outpoint.\n+    //! This may (but cannot always) return true for spent outputs.\n+    virtual bool HaveCoin(const COutPoint &outpoint) const;\n \n     //! Retrieve the block hash whose state this CCoinsView currently represents\n     virtual uint256 GetBestBlock() const;\n \n-    //! Do a bulk modification (multiple CCoins changes + BestBlock change).\n+    //! Do a bulk modification (multiple Coin changes + BestBlock change).\n     //! The passed mapCoins can be modified.\n     virtual bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n \n@@ -324,6 +165,9 @@ class CCoinsView\n \n     //! As we use CCoinsViews polymorphically, have a virtual destructor\n     virtual ~CCoinsView() {}\n+\n+    //! Estimate database size (0 if not implemented)\n+    virtual size_t EstimateSize() const { return 0; }\n };\n \n \n@@ -335,97 +179,66 @@ class CCoinsViewBacked : public CCoinsView\n \n public:\n     CCoinsViewBacked(CCoinsView *viewIn);\n-    bool GetCoins(const uint256 &txid, CCoins &coins) const;\n-    bool HaveCoins(const uint256 &txid) const;\n-    uint256 GetBestBlock() const;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n+    bool HaveCoin(const COutPoint &outpoint) const override;\n+    uint256 GetBestBlock() const override;\n     void SetBackend(CCoinsView &viewIn);\n-    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n-    CCoinsViewCursor *Cursor() const;\n+    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n+    CCoinsViewCursor *Cursor() const override;\n+    size_t EstimateSize() const override;\n };\n \n \n-class CCoinsViewCache;\n-\n-/** \n- * A reference to a mutable cache entry. Encapsulating it allows us to run\n- *  cleanup code after the modification is finished, and keeping track of\n- *  concurrent modifications. \n- */\n-class CCoinsModifier\n-{\n-private:\n-    CCoinsViewCache& cache;\n-    CCoinsMap::iterator it;\n-    size_t cachedCoinUsage; // Cached memory usage of the CCoins object before modification\n-    CCoinsModifier(CCoinsViewCache& cache_, CCoinsMap::iterator it_, size_t usage);\n-\n-public:\n-    CCoins* operator->() { return &it->second.coins; }\n-    CCoins& operator*() { return it->second.coins; }\n-    ~CCoinsModifier();\n-    friend class CCoinsViewCache;\n-};\n-\n /** CCoinsView that adds a memory cache for transactions to another CCoinsView */\n class CCoinsViewCache : public CCoinsViewBacked\n {\n protected:\n-    /* Whether this cache has an active modifier. */\n-    bool hasModifier;\n-\n-\n     /**\n      * Make mutable so that we can \"fill the cache\" even from Get-methods\n      * declared as \"const\".  \n      */\n     mutable uint256 hashBlock;\n     mutable CCoinsMap cacheCoins;\n \n-    /* Cached dynamic memory usage for the inner CCoins objects. */\n+    /* Cached dynamic memory usage for the inner Coin objects. */\n     mutable size_t cachedCoinsUsage;\n \n public:\n     CCoinsViewCache(CCoinsView *baseIn);\n-    ~CCoinsViewCache();\n \n     // Standard CCoinsView methods\n-    bool GetCoins(const uint256 &txid, CCoins &coins) const;\n-    bool HaveCoins(const uint256 &txid) const;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const;\n+    bool HaveCoin(const COutPoint &outpoint) const;\n     uint256 GetBestBlock() const;\n     void SetBestBlock(const uint256 &hashBlock);\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n \n     /**\n-     * Check if we have the given tx already loaded in this cache.\n-     * The semantics are the same as HaveCoins(), but no calls to\n+     * Check if we have the given utxo already loaded in this cache.\n+     * The semantics are the same as HaveCoin(), but no calls to\n      * the backing CCoinsView are made.\n      */\n-    bool HaveCoinsInCache(const uint256 &txid) const;\n+    bool HaveCoinInCache(const COutPoint &outpoint) const;\n \n     /**\n-     * Return a pointer to CCoins in the cache, or NULL if not found. This is\n-     * more efficient than GetCoins. Modifications to other cache entries are\n+     * Return a reference to Coin in the cache, or a pruned one if not found. This is\n+     * more efficient than GetCoin. Modifications to other cache entries are\n      * allowed while accessing the returned pointer.\n      */\n-    const CCoins* AccessCoins(const uint256 &txid) const;\n+    const Coin& AccessCoin(const COutPoint &output) const;\n \n     /**\n-     * Return a modifiable reference to a CCoins. If no entry with the given\n-     * txid exists, a new one is created. Simultaneous modifications are not\n-     * allowed.\n+     * Add a coin. Set potential_overwrite to true if a non-pruned version may\n+     * already exist.\n      */\n-    CCoinsModifier ModifyCoins(const uint256 &txid);\n+    void AddCoin(const COutPoint& outpoint, Coin&& coin, bool potential_overwrite);\n \n     /**\n-     * Return a modifiable reference to a CCoins. Assumes that no entry with the given\n-     * txid exists and creates a new one. This saves a database access in the case where\n-     * the coins were to be wiped out by FromTx anyway.  This should not be called with\n-     * the 2 historical coinbase duplicate pairs because the new coins are marked fresh, and\n-     * in the event the duplicate coinbase was spent before a flush, the now pruned coins\n-     * would not properly overwrite the first coinbase of the pair. Simultaneous modifications\n-     * are not allowed.\n+     * Spend a coin. Pass moveto in order to get the deleted data.\n+     * If no unspent output exists for the passed outpoint, this call\n+     * has no effect.\n      */\n-    CCoinsModifier ModifyNewCoins(const uint256 &txid, bool coinbase);\n+    void SpendCoin(const COutPoint &outpoint, Coin* moveto = nullptr);\n \n     /**\n      * Push the modifications applied to this cache to its base.\n@@ -435,12 +248,12 @@ class CCoinsViewCache : public CCoinsViewBacked\n     bool Flush();\n \n     /**\n-     * Removes the transaction with the given hash from the cache, if it is\n+     * Removes the UTXO with the given outpoint from the cache, if it is\n      * not modified.\n      */\n-    void Uncache(const uint256 &txid);\n+    void Uncache(const COutPoint &outpoint);\n \n-    //! Calculate the size of the cache (in number of transactions)\n+    //! Calculate the size of the cache (in number of transaction outputs)\n     unsigned int GetCacheSize() const;\n \n     //! Calculate the size of the cache (in bytes)\n@@ -459,17 +272,22 @@ class CCoinsViewCache : public CCoinsViewBacked\n     //! Check whether all prevouts of the transaction are present in the UTXO set represented by this view\n     bool HaveInputs(const CTransaction& tx) const;\n \n-    const CTxOut &GetOutputFor(const CTxIn& input) const;\n-\n-    friend class CCoinsModifier;\n-\n private:\n-    CCoinsMap::const_iterator FetchCoins(const uint256 &txid) const;\n+    CCoinsMap::iterator FetchCoin(const COutPoint &outpoint) const;\n \n     /**\n      * By making the copy constructor private, we prevent accidentally using it when one intends to create a cache on top of a base cache.\n      */\n     CCoinsViewCache(const CCoinsViewCache &);\n };\n \n+//! Utility function to add all of a transaction's outputs to a cache.\n+// It assumes that overwrites are only possible for coinbase transactions,\n+// TODO: pass in a boolean to limit these possible overwrites to known\n+// (pre-BIP34) cases.\n+void AddCoins(CCoinsViewCache& cache, const CTransaction& tx, int nHeight);\n+\n+//! Utility function to find any unspent output with a given txid.\n+const Coin& AccessByTxid(const CCoinsViewCache& cache, const uint256& txid);\n+\n #endif // BITCOIN_COINS_H"
      },
      {
        "sha": "bf68f8754b71739ba3aa4cc11e6180acec62fabf",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "added",
        "additions": 246,
        "deletions": 0,
        "changes": 246,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -0,0 +1,246 @@\n+// Copyright (c) 2017-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"tx_verify.h\"\n+\n+#include \"consensus.h\"\n+#include \"primitives/transaction.h\"\n+#include \"script/interpreter.h\"\n+#include \"validation.h\"\n+\n+// TODO remove the following dependencies\n+#include \"chain.h\"\n+#include \"coins.h\"\n+#include \"utilmoneystr.h\"\n+ \n+bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n+{\n+    if (tx.nLockTime == 0)\n+        return true;\n+    if ((int64_t)tx.nLockTime < ((int64_t)tx.nLockTime < LOCKTIME_THRESHOLD ? (int64_t)nBlockHeight : nBlockTime))\n+        return true;\n+    for (const auto& txin : tx.vin) {\n+        if (!(txin.nSequence == CTxIn::SEQUENCE_FINAL))\n+            return false;\n+    }\n+    return true;\n+}\n+\n+std::pair<int, int64_t> CalculateSequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n+{\n+    assert(prevHeights->size() == tx.vin.size());\n+\n+    // Will be set to the equivalent height- and time-based nLockTime\n+    // values that would be necessary to satisfy all relative lock-\n+    // time constraints given our view of block chain history.\n+    // The semantics of nLockTime are the last invalid height/time, so\n+    // use -1 to have the effect of any height or time being valid.\n+    int nMinHeight = -1;\n+    int64_t nMinTime = -1;\n+\n+    // tx.nVersion is signed integer so requires cast to unsigned otherwise\n+    // we would be doing a signed comparison and half the range of nVersion\n+    // wouldn't support BIP 68.\n+    bool fEnforceBIP68 = static_cast<uint32_t>(tx.nVersion) >= 2\n+                      && flags & LOCKTIME_VERIFY_SEQUENCE;\n+\n+    // Do not enforce sequence numbers as a relative lock time\n+    // unless we have been instructed to\n+    if (!fEnforceBIP68) {\n+        return std::make_pair(nMinHeight, nMinTime);\n+    }\n+\n+    for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n+        const CTxIn& txin = tx.vin[txinIndex];\n+\n+        // Sequence numbers with the most significant bit set are not\n+        // treated as relative lock-times, nor are they given any\n+        // consensus-enforced meaning at this point.\n+        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_DISABLE_FLAG) {\n+            // The height of this input is not relevant for sequence locks\n+            (*prevHeights)[txinIndex] = 0;\n+            continue;\n+        }\n+\n+        int nCoinHeight = (*prevHeights)[txinIndex];\n+\n+        if (txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_TYPE_FLAG) {\n+            int64_t nCoinTime = block.GetAncestor(std::max(nCoinHeight-1, 0))->GetMedianTimePast();\n+            // NOTE: Subtract 1 to maintain nLockTime semantics\n+            // BIP 68 relative lock times have the semantics of calculating\n+            // the first block or time at which the transaction would be\n+            // valid. When calculating the effective block time or height\n+            // for the entire transaction, we switch to using the\n+            // semantics of nLockTime which is the last invalid block\n+            // time or height.  Thus we subtract 1 from the calculated\n+            // time or height.\n+\n+            // Time-based relative lock-times are measured from the\n+            // smallest allowed timestamp of the block containing the\n+            // txout being spent, which is the median time past of the\n+            // block prior.\n+            nMinTime = std::max(nMinTime, nCoinTime + (int64_t)((txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) << CTxIn::SEQUENCE_LOCKTIME_GRANULARITY) - 1);\n+        } else {\n+            nMinHeight = std::max(nMinHeight, nCoinHeight + (int)(txin.nSequence & CTxIn::SEQUENCE_LOCKTIME_MASK) - 1);\n+        }\n+    }\n+\n+    return std::make_pair(nMinHeight, nMinTime);\n+}\n+\n+bool EvaluateSequenceLocks(const CBlockIndex& block, std::pair<int, int64_t> lockPair)\n+{\n+    assert(block.pprev);\n+    int64_t nBlockTime = block.pprev->GetMedianTimePast();\n+    if (lockPair.first >= block.nHeight || lockPair.second >= nBlockTime)\n+        return false;\n+\n+    return true;\n+}\n+\n+bool SequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block)\n+{\n+    return EvaluateSequenceLocks(block, CalculateSequenceLocks(tx, flags, prevHeights, block));\n+}\n+\n+unsigned int GetLegacySigOpCount(const CTransaction& tx)\n+{\n+    unsigned int nSigOps = 0;\n+    for (const auto& txin : tx.vin)\n+    {\n+        nSigOps += txin.scriptSig.GetSigOpCount(false);\n+    }\n+    for (const auto& txout : tx.vout)\n+    {\n+        nSigOps += txout.scriptPubKey.GetSigOpCount(false);\n+    }\n+    return nSigOps;\n+}\n+\n+unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& inputs)\n+{\n+    if (tx.IsCoinBase())\n+        return 0;\n+\n+    unsigned int nSigOps = 0;\n+    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+    {\n+        const CTxOut &prevout = inputs.AccessCoin(tx.vin[i].prevout).out;\n+        if (prevout.scriptPubKey.IsPayToScriptHash())\n+            nSigOps += prevout.scriptPubKey.GetSigOpCount(tx.vin[i].scriptSig);\n+    }\n+    return nSigOps;\n+}\n+\n+int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags)\n+{\n+    int64_t nSigOps = GetLegacySigOpCount(tx) * WITNESS_SCALE_FACTOR;\n+\n+    if (tx.IsCoinBase())\n+        return nSigOps;\n+\n+    if (flags & SCRIPT_VERIFY_P2SH) {\n+        nSigOps += GetP2SHSigOpCount(tx, inputs) * WITNESS_SCALE_FACTOR;\n+    }\n+\n+    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+    {\n+        const CTxOut &prevout = inputs.AccessCoin(tx.vin[i].prevout).out;\n+        nSigOps += CountWitnessSigOps(tx.vin[i].scriptSig, prevout.scriptPubKey, &tx.vin[i].scriptWitness, flags);\n+    }\n+    return nSigOps;\n+}\n+\n+bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fCheckDuplicateInputs)\n+{\n+    // Basic checks that don't depend on any context\n+    if (tx.vin.empty())\n+        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vin-empty\");\n+    if (tx.vout.empty())\n+        return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n+    // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n+    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) > MAX_BLOCK_BASE_SIZE)\n+        return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\");\n+\n+    // Check for negative or overflow output values\n+    CAmount nValueOut = 0;\n+    for (const auto& txout : tx.vout)\n+    {\n+        if (txout.nValue < 0)\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-negative\");\n+        if (txout.nValue > MAX_MONEY)\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-vout-toolarge\");\n+        nValueOut += txout.nValue;\n+        if (!MoneyRange(nValueOut))\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-txouttotal-toolarge\");\n+    }\n+\n+    // Check for duplicate inputs - note that this check is slow so we skip it in CheckBlock\n+    if (fCheckDuplicateInputs) {\n+        std::set<COutPoint> vInOutPoints;\n+        for (const auto& txin : tx.vin)\n+        {\n+            if (!vInOutPoints.insert(txin.prevout).second)\n+                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputs-duplicate\");\n+        }\n+    }\n+\n+    if (tx.IsCoinBase())\n+    {\n+        if (tx.vin[0].scriptSig.size() < 2 || tx.vin[0].scriptSig.size() > 100)\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-cb-length\");\n+    }\n+    else\n+    {\n+        for (const auto& txin : tx.vin)\n+            if (txin.prevout.IsNull())\n+                return state.DoS(10, false, REJECT_INVALID, \"bad-txns-prevout-null\");\n+    }\n+\n+    return true;\n+}\n+\n+bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& inputs, int nSpendHeight)\n+{\n+        // This doesn't trigger the DoS code on purpose; if it did, it would make it easier\n+        // for an attacker to attempt to split the network.\n+        if (!inputs.HaveInputs(tx))\n+            return state.Invalid(false, 0, \"\", \"Inputs unavailable\");\n+\n+        CAmount nValueIn = 0;\n+        CAmount nFees = 0;\n+        for (unsigned int i = 0; i < tx.vin.size(); i++)\n+        {\n+            const COutPoint &prevout = tx.vin[i].prevout;\n+            const Coin& coin = inputs.AccessCoin(prevout);\n+            assert(!coin.IsSpent());\n+\n+            // If prev is coinbase, check that it's matured\n+            if (coin.IsCoinBase()) {\n+                if (nSpendHeight - coin.nHeight < COINBASE_MATURITY)\n+                    return state.Invalid(false,\n+                        REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n+                        strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n+            }\n+\n+            // Check for negative or overflow input values\n+            nValueIn += coin.out.nValue;\n+            if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn))\n+                return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n+\n+        }\n+\n+        if (nValueIn < tx.GetValueOut())\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-in-belowout\", false,\n+                strprintf(\"value in (%s) < value out (%s)\", FormatMoney(nValueIn), FormatMoney(tx.GetValueOut())));\n+\n+        // Tally transaction fees\n+        CAmount nTxFee = nValueIn - tx.GetValueOut();\n+        if (nTxFee < 0)\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-fee-negative\");\n+        nFees += nTxFee;\n+        if (!MoneyRange(nFees))\n+            return state.DoS(100, false, REJECT_INVALID, \"bad-txns-fee-outofrange\");\n+    return true;\n+}"
      },
      {
        "sha": "d46d3294ca25039e8ebdaf1d0cd4d73abebb3597",
        "filename": "src/consensus/tx_verify.h",
        "status": "added",
        "additions": 78,
        "deletions": 0,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/consensus/tx_verify.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/consensus/tx_verify.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -0,0 +1,78 @@\n+// Copyright (c) 2017-2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CONSENSUS_TX_VERIFY_H\n+#define BITCOIN_CONSENSUS_TX_VERIFY_H\n+\n+#include <stdint.h>\n+#include <vector>\n+\n+class CBlockIndex;\n+class CCoinsViewCache;\n+class CTransaction;\n+class CValidationState;\n+\n+/** Transaction validation functions */\n+\n+/** Context-independent validity checks */\n+bool CheckTransaction(const CTransaction& tx, CValidationState& state, bool fCheckDuplicateInputs=true);\n+\n+namespace Consensus {\n+/**\n+ * Check whether all inputs of this transaction are valid (no double spends and amounts)\n+ * This does not modify the UTXO set. This does not check scripts and sigs.\n+ * Preconditions: tx.IsCoinBase() is false.\n+ */\n+bool CheckTxInputs(const CTransaction& tx, CValidationState& state, const CCoinsViewCache& inputs, int nSpendHeight);\n+} // namespace Consensus\n+\n+/** Auxiliary functions for transaction validation (ideally should not be exposed) */\n+\n+/**\n+ * Count ECDSA signature operations the old-fashioned (pre-0.6) way\n+ * @return number of sigops this transaction's outputs will produce when spent\n+ * @see CTransaction::FetchInputs\n+ */\n+unsigned int GetLegacySigOpCount(const CTransaction& tx);\n+\n+/**\n+ * Count ECDSA signature operations in pay-to-script-hash inputs.\n+ * \n+ * @param[in] mapInputs Map of previous transactions that have outputs we're spending\n+ * @return maximum number of sigops required to validate this transaction's inputs\n+ * @see CTransaction::FetchInputs\n+ */\n+unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n+\n+/**\n+ * Compute total signature operation cost of a transaction.\n+ * @param[in] tx     Transaction for which we are computing the cost\n+ * @param[in] inputs Map of previous transactions that have outputs we're spending\n+ * @param[out] flags Script verification flags\n+ * @return Total signature operation cost of tx\n+ */\n+int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& inputs, int flags);\n+\n+/**\n+ * Check if transaction is final and can be included in a block with the\n+ * specified height and time. Consensus critical.\n+ */\n+bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime);\n+\n+/**\n+ * Calculates the block height and previous block's median time past at\n+ * which the transaction will be considered final in the context of BIP 68.\n+ * Also removes from the vector of input heights any entries which did not\n+ * correspond to sequence locked inputs as they do not affect the calculation.\n+ */\n+std::pair<int, int64_t> CalculateSequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block);\n+\n+bool EvaluateSequenceLocks(const CBlockIndex& block, std::pair<int, int64_t> lockPair);\n+/**\n+ * Check if transaction is final per BIP 68 sequence numbers and can be included in a block.\n+ * Consensus critical. Takes as input a list of heights at which tx's inputs (in order) confirmed.\n+ */\n+bool SequenceLocks(const CTransaction &tx, int flags, std::vector<int>* prevHeights, const CBlockIndex& block);\n+\n+#endif // BITCOIN_CONSENSUS_TX_VERIFY_H"
      },
      {
        "sha": "e4ccd54c4238b899752a7924da0ebc384e44206c",
        "filename": "src/core_memusage.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/core_memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/core_memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_memusage.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -63,4 +63,9 @@ static inline size_t RecursiveDynamicUsage(const CBlockLocator& locator) {\n     return memusage::DynamicUsage(locator.vHave);\n }\n \n+template<typename X>\n+static inline size_t RecursiveDynamicUsage(const std::shared_ptr<X>& p) {\n+    return p ? memusage::DynamicUsage(p) + RecursiveDynamicUsage(*p) : 0;\n+}\n+\n #endif // BITCOIN_CORE_MEMUSAGE_H"
      },
      {
        "sha": "dd9b5726a312c0f311598cadb503a16fc5bdd257",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 4,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -18,7 +18,6 @@\n #include <boost/algorithm/string/predicate.hpp>\n #include <boost/algorithm/string/replace.hpp>\n #include <boost/algorithm/string/split.hpp>\n-#include <boost/assign/list_of.hpp>\n \n CScript ParseScript(const std::string& s)\n {\n@@ -88,18 +87,40 @@ CScript ParseScript(const std::string& s)\n     return result;\n }\n \n+// Check that all of the input and output scripts of a transaction contains valid opcodes\n+bool CheckTxScriptsSanity(const CMutableTransaction& tx)\n+{\n+    // Check input scripts for non-coinbase txs\n+    if (!CTransaction(tx).IsCoinBase()) {\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            if (!tx.vin[i].scriptSig.HasValidOps() || tx.vin[i].scriptSig.size() > MAX_SCRIPT_SIZE) {\n+                return false;\n+            }\n+        }\n+    }\n+    // Check output scripts\n+    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n+        if (!tx.vout[i].scriptPubKey.HasValidOps() || tx.vout[i].scriptPubKey.size() > MAX_SCRIPT_SIZE) {\n+            return false;\n+        }\n+    }\n+    \n+    return true;\n+}\n+\n bool DecodeHexTx(CMutableTransaction& tx, const std::string& strHexTx, bool fTryNoWitness)\n {\n-    if (!IsHex(strHexTx))\n+    if (!IsHex(strHexTx)) {\n         return false;\n+    }\n \n     std::vector<unsigned char> txData(ParseHex(strHexTx));\n \n     if (fTryNoWitness) {\n         CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\n         try {\n             ssData >> tx;\n-            if (ssData.eof()) {\n+            if (ssData.eof() && CheckTxScriptsSanity(tx)) {\n                 return true;\n             }\n         }\n@@ -111,8 +132,9 @@ bool DecodeHexTx(CMutableTransaction& tx, const std::string& strHexTx, bool fTry\n     CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n     try {\n         ssData >> tx;\n-        if (!ssData.empty())\n+        if (!ssData.empty()) {\n             return false;\n+        }\n     }\n     catch (const std::exception&) {\n         return false;"
      },
      {
        "sha": "178519daf11faec4b3b69704422cecb05f4bfdba",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -15,7 +15,6 @@\n #include \"utilmoneystr.h\"\n #include \"utilstrencodings.h\"\n \n-#include <boost/assign/list_of.hpp>\n #include <boost/foreach.hpp>\n \n std::string FormatScript(const CScript& script)\n@@ -53,15 +52,14 @@ std::string FormatScript(const CScript& script)\n     return ret.substr(0, ret.size() - 1);\n }\n \n-const std::map<unsigned char, std::string> mapSigHashTypes =\n-    boost::assign::map_list_of\n-    (static_cast<unsigned char>(SIGHASH_ALL), std::string(\"ALL\"))\n-    (static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_ANYONECANPAY), std::string(\"ALL|ANYONECANPAY\"))\n-    (static_cast<unsigned char>(SIGHASH_NONE), std::string(\"NONE\"))\n-    (static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_ANYONECANPAY), std::string(\"NONE|ANYONECANPAY\"))\n-    (static_cast<unsigned char>(SIGHASH_SINGLE), std::string(\"SINGLE\"))\n-    (static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\"))\n-    ;\n+const std::map<unsigned char, std::string> mapSigHashTypes = {\n+    {static_cast<unsigned char>(SIGHASH_ALL), std::string(\"ALL\")},\n+    {static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_ANYONECANPAY), std::string(\"ALL|ANYONECANPAY\")},\n+    {static_cast<unsigned char>(SIGHASH_NONE), std::string(\"NONE\")},\n+    {static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_ANYONECANPAY), std::string(\"NONE|ANYONECANPAY\")},\n+    {static_cast<unsigned char>(SIGHASH_SINGLE), std::string(\"SINGLE\")},\n+    {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n+};\n \n /**\n  * Create the assembly string representation of a CScript object.\n@@ -114,9 +112,9 @@ std::string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDeco\n     return str;\n }\n \n-std::string EncodeHexTx(const CTransaction& tx, const int serialFlags)\n+std::string EncodeHexTx(const CTransaction& tx, const int serializeFlags)\n {\n-    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | serialFlags);\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | serializeFlags);\n     ssTx << tx;\n     return HexStr(ssTx.begin(), ssTx.end());\n }\n@@ -151,6 +149,8 @@ void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry)\n     entry.pushKV(\"txid\", tx.GetHash().GetHex());\n     entry.pushKV(\"hash\", tx.GetWitnessHash().GetHex());\n     entry.pushKV(\"version\", tx.nVersion);\n+    entry.pushKV(\"size\", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+    entry.pushKV(\"vsize\", (GetTransactionWeight(tx) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR);\n     entry.pushKV(\"locktime\", (int64_t)tx.nLockTime);\n \n     UniValue vin(UniValue::VARR);"
      },
      {
        "sha": "816ae870e138aa54621b2cebd62052b36bf55c2f",
        "filename": "src/crypto/chacha20.cpp",
        "status": "added",
        "additions": 180,
        "deletions": 0,
        "changes": 180,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/crypto/chacha20.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/crypto/chacha20.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha20.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -0,0 +1,180 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+// Based on the public domain implementation 'merged' by D. J. Bernstein\n+// See https://cr.yp.to/chacha.html.\n+\n+#include \"crypto/common.h\"\n+#include \"crypto/chacha20.h\"\n+\n+#include <string.h>\n+\n+constexpr static inline uint32_t rotl32(uint32_t v, int c) { return (v << c) | (v >> (32 - c)); }\n+\n+#define QUARTERROUND(a,b,c,d) \\\n+  a += b; d = rotl32(d ^ a, 16); \\\n+  c += d; b = rotl32(b ^ c, 12); \\\n+  a += b; d = rotl32(d ^ a, 8); \\\n+  c += d; b = rotl32(b ^ c, 7);\n+\n+static const unsigned char sigma[] = \"expand 32-byte k\";\n+static const unsigned char tau[] = \"expand 16-byte k\";\n+\n+void ChaCha20::SetKey(const unsigned char* k, size_t keylen)\n+{\n+    const unsigned char *constants;\n+\n+    input[4] = ReadLE32(k + 0);\n+    input[5] = ReadLE32(k + 4);\n+    input[6] = ReadLE32(k + 8);\n+    input[7] = ReadLE32(k + 12);\n+    if (keylen == 32) { /* recommended */\n+        k += 16;\n+        constants = sigma;\n+    } else { /* keylen == 16 */\n+        constants = tau;\n+    }\n+    input[8] = ReadLE32(k + 0);\n+    input[9] = ReadLE32(k + 4);\n+    input[10] = ReadLE32(k + 8);\n+    input[11] = ReadLE32(k + 12);\n+    input[0] = ReadLE32(constants + 0);\n+    input[1] = ReadLE32(constants + 4);\n+    input[2] = ReadLE32(constants + 8);\n+    input[3] = ReadLE32(constants + 12);\n+    input[12] = 0;\n+    input[13] = 0;\n+    input[14] = 0;\n+    input[15] = 0;\n+}\n+\n+ChaCha20::ChaCha20()\n+{\n+    memset(input, 0, sizeof(input));\n+}\n+\n+ChaCha20::ChaCha20(const unsigned char* k, size_t keylen)\n+{\n+    SetKey(k, keylen);\n+}\n+\n+void ChaCha20::SetIV(uint64_t iv)\n+{\n+    input[14] = iv;\n+    input[15] = iv >> 32;\n+}\n+\n+void ChaCha20::Seek(uint64_t pos)\n+{\n+    input[12] = pos;\n+    input[13] = pos >> 32;\n+}\n+\n+void ChaCha20::Output(unsigned char* c, size_t bytes)\n+{\n+    uint32_t x0, x1, x2, x3, x4, x5, x6, x7, x8, x9, x10, x11, x12, x13, x14, x15;\n+    uint32_t j0, j1, j2, j3, j4, j5, j6, j7, j8, j9, j10, j11, j12, j13, j14, j15;\n+    unsigned char *ctarget = NULL;\n+    unsigned char tmp[64];\n+    unsigned int i;\n+\n+    if (!bytes) return;\n+\n+    j0 = input[0];\n+    j1 = input[1];\n+    j2 = input[2];\n+    j3 = input[3];\n+    j4 = input[4];\n+    j5 = input[5];\n+    j6 = input[6];\n+    j7 = input[7];\n+    j8 = input[8];\n+    j9 = input[9];\n+    j10 = input[10];\n+    j11 = input[11];\n+    j12 = input[12];\n+    j13 = input[13];\n+    j14 = input[14];\n+    j15 = input[15];\n+\n+    for (;;) {\n+        if (bytes < 64) {\n+            ctarget = c;\n+            c = tmp;\n+        }\n+        x0 = j0;\n+        x1 = j1;\n+        x2 = j2;\n+        x3 = j3;\n+        x4 = j4;\n+        x5 = j5;\n+        x6 = j6;\n+        x7 = j7;\n+        x8 = j8;\n+        x9 = j9;\n+        x10 = j10;\n+        x11 = j11;\n+        x12 = j12;\n+        x13 = j13;\n+        x14 = j14;\n+        x15 = j15;\n+        for (i = 20;i > 0;i -= 2) {\n+            QUARTERROUND( x0, x4, x8,x12)\n+            QUARTERROUND( x1, x5, x9,x13)\n+            QUARTERROUND( x2, x6,x10,x14)\n+            QUARTERROUND( x3, x7,x11,x15)\n+            QUARTERROUND( x0, x5,x10,x15)\n+            QUARTERROUND( x1, x6,x11,x12)\n+            QUARTERROUND( x2, x7, x8,x13)\n+            QUARTERROUND( x3, x4, x9,x14)\n+        }\n+        x0 += j0;\n+        x1 += j1;\n+        x2 += j2;\n+        x3 += j3;\n+        x4 += j4;\n+        x5 += j5;\n+        x6 += j6;\n+        x7 += j7;\n+        x8 += j8;\n+        x9 += j9;\n+        x10 += j10;\n+        x11 += j11;\n+        x12 += j12;\n+        x13 += j13;\n+        x14 += j14;\n+        x15 += j15;\n+\n+        ++j12;\n+        if (!j12) ++j13;\n+\n+        WriteLE32(c + 0, x0);\n+        WriteLE32(c + 4, x1);\n+        WriteLE32(c + 8, x2);\n+        WriteLE32(c + 12, x3);\n+        WriteLE32(c + 16, x4);\n+        WriteLE32(c + 20, x5);\n+        WriteLE32(c + 24, x6);\n+        WriteLE32(c + 28, x7);\n+        WriteLE32(c + 32, x8);\n+        WriteLE32(c + 36, x9);\n+        WriteLE32(c + 40, x10);\n+        WriteLE32(c + 44, x11);\n+        WriteLE32(c + 48, x12);\n+        WriteLE32(c + 52, x13);\n+        WriteLE32(c + 56, x14);\n+        WriteLE32(c + 60, x15);\n+\n+        if (bytes <= 64) {\n+            if (bytes < 64) {\n+                for (i = 0;i < bytes;++i) ctarget[i] = c[i];\n+            }\n+            input[12] = j12;\n+            input[13] = j13;\n+            return;\n+        }\n+        bytes -= 64;\n+        c += 64;\n+    }\n+}"
      },
      {
        "sha": "a305977bcd5f4027cbb83b27a16622bab6f0c4c3",
        "filename": "src/crypto/chacha20.h",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/crypto/chacha20.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/crypto/chacha20.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha20.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -0,0 +1,26 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CRYPTO_CHACHA20_H\n+#define BITCOIN_CRYPTO_CHACHA20_H\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+/** A PRNG class for ChaCha20. */\n+class ChaCha20\n+{\n+private:\n+    uint32_t input[16];\n+\n+public:\n+    ChaCha20();\n+    ChaCha20(const unsigned char* key, size_t keylen);\n+    void SetKey(const unsigned char* key, size_t keylen);\n+    void SetIV(uint64_t iv);\n+    void Seek(uint64_t pos);\n+    void Output(unsigned char* output, size_t bytes);\n+};\n+\n+#endif // BITCOIN_CRYPTO_CHACHA20_H"
      },
      {
        "sha": "bcca3d30ea7d686b4244049a3d63f28f50ca8d7c",
        "filename": "src/crypto/common.h",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/crypto/common.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/crypto/common.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/common.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -79,4 +79,25 @@ void static inline WriteBE64(unsigned char* ptr, uint64_t x)\n     memcpy(ptr, (char*)&v, 8);\n }\n \n+/** Return the smallest number n such that (x >> n) == 0 (or 64 if the highest bit in x is set. */\n+uint64_t static inline CountBits(uint64_t x)\n+{\n+#ifdef HAVE_DECL___BUILTIN_CLZL\n+    if (sizeof(unsigned long) >= sizeof(uint64_t)) {\n+        return x ? 8 * sizeof(unsigned long) - __builtin_clzl(x) : 0;\n+    }\n+#endif\n+#ifdef HAVE_DECL___BUILTIN_CLZLL\n+    if (sizeof(unsigned long long) >= sizeof(uint64_t)) {\n+        return x ? 8 * sizeof(unsigned long long) - __builtin_clzll(x) : 0;\n+    }\n+#endif\n+    int ret = 0;\n+    while (x) {\n+        x >>= 1;\n+        ++ret;\n+    }\n+    return ret;\n+}\n+\n #endif // BITCOIN_CRYPTO_COMMON_H"
      },
      {
        "sha": "58375494555ec88d737f3aeea91bef3d151eba24",
        "filename": "src/cuckoocache.h",
        "status": "modified",
        "additions": 11,
        "deletions": 18,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/cuckoocache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/cuckoocache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cuckoocache.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -154,7 +154,7 @@ class bit_packed_atomic_flags\n  * @tparam Element should be a movable and copyable type\n  * @tparam Hash should be a function/callable which takes a template parameter\n  * hash_select and an Element and extracts a hash from it. Should return\n- * high-entropy hashes for `Hash h; h<0>(e) ... h<7>(e)`.\n+ * high-entropy uint32_t hashes for `Hash h; h<0>(e) ... h<7>(e)`.\n  */\n template <typename Element, typename Hash>\n class cache\n@@ -193,12 +193,6 @@ class cache\n      */\n     uint32_t epoch_size;\n \n-    /** hash_mask should be set to appropriately mask out a hash such that every\n-     * masked hash is [0,size), eg, if floor(log2(size)) == 20, then hash_mask\n-     * should be (1<<20)-1\n-     */\n-    uint32_t hash_mask;\n-\n     /** depth_limit determines how many elements insert should try to replace.\n      * Should be set to log2(n)*/\n     uint8_t depth_limit;\n@@ -217,14 +211,14 @@ class cache\n      */\n     inline std::array<uint32_t, 8> compute_hashes(const Element& e) const\n     {\n-        return {{hash_function.template operator()<0>(e) & hash_mask,\n-                 hash_function.template operator()<1>(e) & hash_mask,\n-                 hash_function.template operator()<2>(e) & hash_mask,\n-                 hash_function.template operator()<3>(e) & hash_mask,\n-                 hash_function.template operator()<4>(e) & hash_mask,\n-                 hash_function.template operator()<5>(e) & hash_mask,\n-                 hash_function.template operator()<6>(e) & hash_mask,\n-                 hash_function.template operator()<7>(e) & hash_mask}};\n+        return {{(uint32_t)((hash_function.template operator()<0>(e) * (uint64_t)size) >> 32),\n+                 (uint32_t)((hash_function.template operator()<1>(e) * (uint64_t)size) >> 32),\n+                 (uint32_t)((hash_function.template operator()<2>(e) * (uint64_t)size) >> 32),\n+                 (uint32_t)((hash_function.template operator()<3>(e) * (uint64_t)size) >> 32),\n+                 (uint32_t)((hash_function.template operator()<4>(e) * (uint64_t)size) >> 32),\n+                 (uint32_t)((hash_function.template operator()<5>(e) * (uint64_t)size) >> 32),\n+                 (uint32_t)((hash_function.template operator()<6>(e) * (uint64_t)size) >> 32),\n+                 (uint32_t)((hash_function.template operator()<7>(e) * (uint64_t)size) >> 32)}};\n     }\n \n     /* end\n@@ -305,7 +299,7 @@ class cache\n     }\n \n     /** setup initializes the container to store no more than new_size\n-     * elements. setup rounds down to a power of two size.\n+     * elements.\n      *\n      * setup should only be called once.\n      *\n@@ -316,8 +310,7 @@ class cache\n     {\n         // depth_limit must be at least one otherwise errors can occur.\n         depth_limit = static_cast<uint8_t>(std::log2(static_cast<float>(std::max((uint32_t)2, new_size))));\n-        size = 1 << depth_limit;\n-        hash_mask = size-1;\n+        size = std::max<uint32_t>(2, new_size);\n         table.resize(size);\n         collection_flags.setup(size);\n         epoch_flags.resize(size);"
      },
      {
        "sha": "3d2098c05927cceb8c41184536f77ab87cbe1230",
        "filename": "src/dbwrapper.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/dbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/dbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -4,11 +4,10 @@\n \n #include \"dbwrapper.h\"\n \n+#include \"fs.h\"\n #include \"util.h\"\n #include \"random.h\"\n \n-#include <boost/filesystem.hpp>\n-\n #include <leveldb/cache.h>\n #include <leveldb/env.h>\n #include <leveldb/filter_policy.h>\n@@ -21,8 +20,9 @@ class CBitcoinLevelDBLogger : public leveldb::Logger {\n     // This code is adapted from posix_logger.h, which is why it is using vsprintf.\n     // Please do not do this in normal code\n     virtual void Logv(const char * format, va_list ap) override {\n-            if (!LogAcceptCategory(\"leveldb\"))\n+            if (!LogAcceptCategory(BCLog::LEVELDB)) {\n                 return;\n+            }\n             char buffer[500];\n             for (int iter = 0; iter < 2; iter++) {\n                 char* base;\n@@ -90,7 +90,7 @@ static leveldb::Options GetOptions(size_t nCacheSize)\n     return options;\n }\n \n-CDBWrapper::CDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory, bool fWipe, bool obfuscate)\n+CDBWrapper::CDBWrapper(const fs::path& path, size_t nCacheSize, bool fMemory, bool fWipe, bool obfuscate)\n {\n     penv = NULL;\n     readoptions.verify_checksums = true;"
      },
      {
        "sha": "24ef71bfbffa9461eadcc94e0db83bb3dd3c5a70",
        "filename": "src/dbwrapper.h",
        "status": "modified",
        "additions": 43,
        "deletions": 5,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/dbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/dbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -6,14 +6,13 @@\n #define BITCOIN_DBWRAPPER_H\n \n #include \"clientversion.h\"\n+#include \"fs.h\"\n #include \"serialize.h\"\n #include \"streams.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n #include \"version.h\"\n \n-#include <boost/filesystem/path.hpp>\n-\n #include <leveldb/db.h>\n #include <leveldb/write_batch.h>\n \n@@ -56,11 +55,19 @@ class CDBBatch\n     CDataStream ssKey;\n     CDataStream ssValue;\n \n+    size_t size_estimate;\n+\n public:\n     /**\n      * @param[in] _parent   CDBWrapper that this batch is to be submitted to\n      */\n-    CDBBatch(const CDBWrapper &_parent) : parent(_parent), ssKey(SER_DISK, CLIENT_VERSION), ssValue(SER_DISK, CLIENT_VERSION) { };\n+    CDBBatch(const CDBWrapper &_parent) : parent(_parent), ssKey(SER_DISK, CLIENT_VERSION), ssValue(SER_DISK, CLIENT_VERSION), size_estimate(0) { };\n+\n+    void Clear()\n+    {\n+        batch.Clear();\n+        size_estimate = 0;\n+    }\n \n     template <typename K, typename V>\n     void Write(const K& key, const V& value)\n@@ -75,6 +82,14 @@ class CDBBatch\n         leveldb::Slice slValue(ssValue.data(), ssValue.size());\n \n         batch.Put(slKey, slValue);\n+        // LevelDB serializes writes as:\n+        // - byte: header\n+        // - varint: key length (1 byte up to 127B, 2 bytes up to 16383B, ...)\n+        // - byte[]: key\n+        // - varint: value length\n+        // - byte[]: value\n+        // The formula below assumes the key and value are both less than 16k.\n+        size_estimate += 3 + (slKey.size() > 127) + slKey.size() + (slValue.size() > 127) + slValue.size();\n         ssKey.clear();\n         ssValue.clear();\n     }\n@@ -87,8 +102,16 @@ class CDBBatch\n         leveldb::Slice slKey(ssKey.data(), ssKey.size());\n \n         batch.Delete(slKey);\n+        // LevelDB serializes erases as:\n+        // - byte: header\n+        // - varint: key length\n+        // - byte[]: key\n+        // The formula below assumes the key is less than 16kB.\n+        size_estimate += 2 + (slKey.size() > 127) + slKey.size();\n         ssKey.clear();\n     }\n+\n+    size_t SizeEstimate() const { return size_estimate; }\n };\n \n class CDBIterator\n@@ -195,7 +218,7 @@ class CDBWrapper\n      * @param[in] obfuscate   If true, store data obfuscated via simple XOR. If false, XOR\n      *                        with a zero'd byte array.\n      */\n-    CDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory = false, bool fWipe = false, bool obfuscate = false);\n+    CDBWrapper(const fs::path& path, size_t nCacheSize, bool fMemory = false, bool fWipe = false, bool obfuscate = false);\n     ~CDBWrapper();\n \n     template <typename K, typename V>\n@@ -282,7 +305,22 @@ class CDBWrapper\n      * Return true if the database managed by this class contains no entries.\n      */\n     bool IsEmpty();\n+\n+    template<typename K>\n+    size_t EstimateSize(const K& key_begin, const K& key_end) const\n+    {\n+        CDataStream ssKey1(SER_DISK, CLIENT_VERSION), ssKey2(SER_DISK, CLIENT_VERSION);\n+        ssKey1.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n+        ssKey2.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n+        ssKey1 << key_begin;\n+        ssKey2 << key_end;\n+        leveldb::Slice slKey1(ssKey1.data(), ssKey1.size());\n+        leveldb::Slice slKey2(ssKey2.data(), ssKey2.size());\n+        uint64_t size = 0;\n+        leveldb::Range range(slKey1, slKey2);\n+        pdb->GetApproximateSizes(&range, 1, &size);\n+        return size;\n+    }\n };\n \n #endif // BITCOIN_DBWRAPPER_H\n-"
      },
      {
        "sha": "6f2b768de322f4c1de51ae8ada66955fcec5faad",
        "filename": "src/fs.cpp",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/fs.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/fs.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fs.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -0,0 +1,17 @@\n+#include \"fs.h\"\n+\n+#include <boost/filesystem.hpp>\n+\n+namespace fsbridge {\n+\n+FILE *fopen(const fs::path& p, const char *mode)\n+{\n+    return ::fopen(p.string().c_str(), mode);\n+}\n+\n+FILE *freopen(const fs::path& p, const char *mode, FILE *stream)\n+{\n+    return ::freopen(p.string().c_str(), mode, stream);\n+}\n+\n+} // fsbridge"
      },
      {
        "sha": "abb4be254b8fa00f76a43fcaf99b54f310cc3254",
        "filename": "src/fs.h",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/fs.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/fs.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fs.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -0,0 +1,24 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_FS_H\n+#define BITCOIN_FS_H\n+\n+#include <stdio.h>\n+#include <string>\n+\n+#include <boost/filesystem.hpp>\n+#include <boost/filesystem/fstream.hpp>\n+#include <boost/filesystem/detail/utf8_codecvt_facet.hpp>\n+\n+/** Filesystem operations and types */\n+namespace fs = boost::filesystem;\n+\n+/** Bridge operations to C stdio */\n+namespace fsbridge {\n+    FILE *fopen(const fs::path& p, const char *mode);\n+    FILE *freopen(const fs::path& p, const char *mode, FILE *stream);\n+};\n+\n+#endif // BITCOIN_FS_H"
      },
      {
        "sha": "b361c90d1626ae5cb5fc720d54ffb09546549da5",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -208,3 +208,44 @@ uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val)\n     SIPROUND;\n     return v0 ^ v1 ^ v2 ^ v3;\n }\n+\n+uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra)\n+{\n+    /* Specialized implementation for efficiency */\n+    uint64_t d = val.GetUint64(0);\n+\n+    uint64_t v0 = 0x736f6d6570736575ULL ^ k0;\n+    uint64_t v1 = 0x646f72616e646f6dULL ^ k1;\n+    uint64_t v2 = 0x6c7967656e657261ULL ^ k0;\n+    uint64_t v3 = 0x7465646279746573ULL ^ k1 ^ d;\n+\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(1);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(2);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(3);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = (((uint64_t)36) << 56) | extra;\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    v2 ^= 0xFF;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    return v0 ^ v1 ^ v2 ^ v3;\n+}"
      },
      {
        "sha": "b9952d39fc97dc1472a1c11b6e9e312f1b7a5e01",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -160,6 +160,41 @@ class CHashWriter\n     }\n };\n \n+/** Reads data from an underlying stream, while hashing the read data. */\n+template<typename Source>\n+class CHashVerifier : public CHashWriter\n+{\n+private:\n+    Source* source;\n+\n+public:\n+    CHashVerifier(Source* source_) : CHashWriter(source_->GetType(), source_->GetVersion()), source(source_) {}\n+\n+    void read(char* pch, size_t nSize)\n+    {\n+        source->read(pch, nSize);\n+        this->write(pch, nSize);\n+    }\n+\n+    void ignore(size_t nSize)\n+    {\n+        char data[1024];\n+        while (nSize > 0) {\n+            size_t now = std::min<size_t>(nSize, 1024);\n+            read(data, now);\n+            nSize -= now;\n+        }\n+    }\n+\n+    template<typename T>\n+    CHashVerifier<Source>& operator>>(T& obj)\n+    {\n+        // Unserialize from this stream\n+        ::Unserialize(*this, obj);\n+        return (*this);\n+    }\n+};\n+\n /** Compute the 256-bit hash of an object's serialization. */\n template<typename T>\n uint256 SerializeHash(const T& obj, int nType=SER_GETHASH, int nVersion=PROTOCOL_VERSION)\n@@ -206,5 +241,6 @@ class CSipHasher\n  *      .Finalize()\n  */\n uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val);\n+uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra);\n \n #endif // BITCOIN_HASH_H"
      },
      {
        "sha": "5ab6d8d73268bf79ae2bca44df99e5cffce613e0",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -30,7 +30,7 @@ static const char* WWW_AUTH_HEADER_DATA = \"Basic realm=\\\"jsonrpc\\\"\";\n class HTTPRPCTimer : public RPCTimerBase\n {\n public:\n-    HTTPRPCTimer(struct event_base* eventBase, boost::function<void(void)>& func, int64_t millis) :\n+    HTTPRPCTimer(struct event_base* eventBase, std::function<void(void)>& func, int64_t millis) :\n         ev(eventBase, false, func)\n     {\n         struct timeval tv;\n@@ -52,7 +52,7 @@ class HTTPRPCTimerInterface : public RPCTimerInterface\n     {\n         return \"HTTP\";\n     }\n-    RPCTimerBase* NewTimer(boost::function<void(void)>& func, int64_t millis)\n+    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis)\n     {\n         return new HTTPRPCTimer(base, func, millis);\n     }\n@@ -93,9 +93,9 @@ static bool multiUserAuthorized(std::string strUserPass)\n     std::string strUser = strUserPass.substr(0, strUserPass.find(\":\"));\n     std::string strPass = strUserPass.substr(strUserPass.find(\":\") + 1);\n \n-    if (mapMultiArgs.count(\"-rpcauth\") > 0) {\n+    if (gArgs.IsArgSet(\"-rpcauth\")) {\n         //Search for multi-user login/pass \"rpcauth\" from config\n-        BOOST_FOREACH(std::string strRPCAuth, mapMultiArgs.at(\"-rpcauth\"))\n+        BOOST_FOREACH(std::string strRPCAuth, gArgs.GetArgs(\"-rpcauth\"))\n         {\n             std::vector<std::string> vFields;\n             boost::split(vFields, strRPCAuth, boost::is_any_of(\":$\"));\n@@ -233,7 +233,7 @@ static bool InitRPCAuthentication()\n \n bool StartHTTPRPC()\n {\n-    LogPrint(\"rpc\", \"Starting HTTP RPC server\\n\");\n+    LogPrint(BCLog::RPC, \"Starting HTTP RPC server\\n\");\n     if (!InitRPCAuthentication())\n         return false;\n \n@@ -247,12 +247,12 @@ bool StartHTTPRPC()\n \n void InterruptHTTPRPC()\n {\n-    LogPrint(\"rpc\", \"Interrupting HTTP RPC server\\n\");\n+    LogPrint(BCLog::RPC, \"Interrupting HTTP RPC server\\n\");\n }\n \n void StopHTTPRPC()\n {\n-    LogPrint(\"rpc\", \"Stopping HTTP RPC server\\n\");\n+    LogPrint(BCLog::RPC, \"Stopping HTTP RPC server\\n\");\n     UnregisterHTTPHandler(\"/\", true);\n     if (httpRPCTimerInterface) {\n         RPCUnsetTimerInterface(httpRPCTimerInterface);"
      },
      {
        "sha": "0d1cba3fd2bddb728475cfedc873c09b7a8655f2",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 31,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -196,9 +196,8 @@ static bool InitHTTPAllowList()\n     LookupHost(\"::1\", localv6, false);\n     rpc_allow_subnets.push_back(CSubNet(localv4, 8));      // always allow IPv4 local subnet\n     rpc_allow_subnets.push_back(CSubNet(localv6));         // always allow IPv6 localhost\n-    if (mapMultiArgs.count(\"-rpcallowip\")) {\n-        const std::vector<std::string>& vAllow = mapMultiArgs.at(\"-rpcallowip\");\n-        for (std::string strAllow : vAllow) {\n+    if (gArgs.IsArgSet(\"-rpcallowip\")) {\n+        for (const std::string& strAllow : gArgs.GetArgs(\"-rpcallowip\")) {\n             CSubNet subnet;\n             LookupSubNet(strAllow.c_str(), subnet);\n             if (!subnet.IsValid()) {\n@@ -213,7 +212,7 @@ static bool InitHTTPAllowList()\n     std::string strAllowed;\n     for (const CSubNet& subnet : rpc_allow_subnets)\n         strAllowed += subnet.ToString() + \" \";\n-    LogPrint(\"http\", \"Allowing HTTP connections from: %s\\n\", strAllowed);\n+    LogPrint(BCLog::HTTP, \"Allowing HTTP connections from: %s\\n\", strAllowed);\n     return true;\n }\n \n@@ -243,7 +242,7 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\n {\n     std::unique_ptr<HTTPRequest> hreq(new HTTPRequest(req));\n \n-    LogPrint(\"http\", \"Received a %s request for %s from %s\\n\",\n+    LogPrint(BCLog::HTTP, \"Received a %s request for %s from %s\\n\",\n              RequestMethodString(hreq->GetRequestMethod()), hreq->GetURI(), hreq->GetPeer().ToString());\n \n     // Early address-based allow check\n@@ -293,18 +292,18 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\n /** Callback to reject HTTP requests after shutdown. */\n static void http_reject_request_cb(struct evhttp_request* req, void*)\n {\n-    LogPrint(\"http\", \"Rejecting request while shutting down\\n\");\n+    LogPrint(BCLog::HTTP, \"Rejecting request while shutting down\\n\");\n     evhttp_send_error(req, HTTP_SERVUNAVAIL, NULL);\n }\n \n /** Event dispatcher thread */\n static bool ThreadHTTP(struct event_base* base, struct evhttp* http)\n {\n     RenameThread(\"bitcoin-http\");\n-    LogPrint(\"http\", \"Entering http event loop\\n\");\n+    LogPrint(BCLog::HTTP, \"Entering http event loop\\n\");\n     event_base_dispatch(base);\n     // Event loop will be interrupted by InterruptHTTPServer()\n-    LogPrint(\"http\", \"Exited http event loop\\n\");\n+    LogPrint(BCLog::HTTP, \"Exited http event loop\\n\");\n     return event_base_got_break(base) == 0;\n }\n \n@@ -321,12 +320,11 @@ static bool HTTPBindAddresses(struct evhttp* http)\n         if (IsArgSet(\"-rpcbind\")) {\n             LogPrintf(\"WARNING: option -rpcbind was ignored because -rpcallowip was not specified, refusing to allow everyone to connect\\n\");\n         }\n-    } else if (mapMultiArgs.count(\"-rpcbind\")) { // Specific bind address\n-        const std::vector<std::string>& vbind = mapMultiArgs.at(\"-rpcbind\");\n-        for (std::vector<std::string>::const_iterator i = vbind.begin(); i != vbind.end(); ++i) {\n+    } else if (gArgs.IsArgSet(\"-rpcbind\")) { // Specific bind address\n+        for (const std::string& strRPCBind : gArgs.GetArgs(\"-rpcbind\")) {\n             int port = defaultPort;\n             std::string host;\n-            SplitHostPort(*i, port, host);\n+            SplitHostPort(strRPCBind, port, host);\n             endpoints.push_back(std::make_pair(host, port));\n         }\n     } else { // No specific bind address specified, bind to any\n@@ -336,7 +334,7 @@ static bool HTTPBindAddresses(struct evhttp* http)\n \n     // Bind addresses\n     for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\n-        LogPrint(\"http\", \"Binding RPC on address %s port %i\\n\", i->first, i->second);\n+        LogPrint(BCLog::HTTP, \"Binding RPC on address %s port %i\\n\", i->first, i->second);\n         evhttp_bound_socket *bind_handle = evhttp_bind_socket_with_handle(http, i->first.empty() ? NULL : i->first.c_str(), i->second);\n         if (bind_handle) {\n             boundSockets.push_back(bind_handle);\n@@ -364,7 +362,7 @@ static void libevent_log_cb(int severity, const char *msg)\n     if (severity >= EVENT_LOG_WARN) // Log warn messages and higher without debug category\n         LogPrintf(\"libevent: %s\\n\", msg);\n     else\n-        LogPrint(\"libevent\", \"libevent: %s\\n\", msg);\n+        LogPrint(BCLog::LIBEVENT, \"libevent: %s\\n\", msg);\n }\n \n bool InitHTTPServer()\n@@ -384,14 +382,13 @@ bool InitHTTPServer()\n \n     // Redirect libevent's logging to our own log\n     event_set_log_callback(&libevent_log_cb);\n-#if LIBEVENT_VERSION_NUMBER >= 0x02010100\n-    // If -debug=libevent, set full libevent debugging.\n-    // Otherwise, disable all libevent debugging.\n-    if (LogAcceptCategory(\"libevent\"))\n-        event_enable_debug_logging(EVENT_DBG_ALL);\n-    else\n-        event_enable_debug_logging(EVENT_DBG_NONE);\n-#endif\n+    // Update libevent's log handling. Returns false if our version of\n+    // libevent doesn't support debug logging, in which case we should\n+    // clear the BCLog::LIBEVENT flag.\n+    if (!UpdateHTTPServerLogging(logCategories & BCLog::LIBEVENT)) {\n+        logCategories &= ~BCLog::LIBEVENT;\n+    }\n+\n #ifdef WIN32\n     evthread_use_windows_threads();\n #else\n@@ -424,7 +421,7 @@ bool InitHTTPServer()\n         return false;\n     }\n \n-    LogPrint(\"http\", \"Initialized HTTP server\\n\");\n+    LogPrint(BCLog::HTTP, \"Initialized HTTP server\\n\");\n     int workQueueDepth = std::max((long)GetArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n     LogPrintf(\"HTTP: creating work queue of depth %d\\n\", workQueueDepth);\n \n@@ -434,12 +431,26 @@ bool InitHTTPServer()\n     return true;\n }\n \n+bool UpdateHTTPServerLogging(bool enable) {\n+#if LIBEVENT_VERSION_NUMBER >= 0x02010100\n+    if (enable) {\n+        event_enable_debug_logging(EVENT_DBG_ALL);\n+    } else {\n+        event_enable_debug_logging(EVENT_DBG_NONE);\n+    }\n+    return true;\n+#else\n+    // Can't update libevent logging if version < 02010100\n+    return false;\n+#endif\n+}\n+\n std::thread threadHTTP;\n std::future<bool> threadResult;\n \n bool StartHTTPServer()\n {\n-    LogPrint(\"http\", \"Starting HTTP server\\n\");\n+    LogPrint(BCLog::HTTP, \"Starting HTTP server\\n\");\n     int rpcThreads = std::max((long)GetArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n     LogPrintf(\"HTTP: starting %d worker threads\\n\", rpcThreads);\n     std::packaged_task<bool(event_base*, evhttp*)> task(ThreadHTTP);\n@@ -455,7 +466,7 @@ bool StartHTTPServer()\n \n void InterruptHTTPServer()\n {\n-    LogPrint(\"http\", \"Interrupting HTTP server\\n\");\n+    LogPrint(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n     if (eventHTTP) {\n         // Unlisten sockets\n         for (evhttp_bound_socket *socket : boundSockets) {\n@@ -470,15 +481,15 @@ void InterruptHTTPServer()\n \n void StopHTTPServer()\n {\n-    LogPrint(\"http\", \"Stopping HTTP server\\n\");\n+    LogPrint(BCLog::HTTP, \"Stopping HTTP server\\n\");\n     if (workQueue) {\n-        LogPrint(\"http\", \"Waiting for HTTP worker threads to exit\\n\");\n+        LogPrint(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n         workQueue->WaitExit();\n         delete workQueue;\n         workQueue = nullptr;\n     }\n     if (eventBase) {\n-        LogPrint(\"http\", \"Waiting for HTTP event thread to exit\\n\");\n+        LogPrint(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n         // Give event loop a few seconds to exit (to send back last RPC responses), then break it\n         // Before this was solved with event_base_loopexit, but that didn't work as expected in\n         // at least libevent 2.0.21 and always introduced a delay. In libevent\n@@ -499,7 +510,7 @@ void StopHTTPServer()\n         event_base_free(eventBase);\n         eventBase = 0;\n     }\n-    LogPrint(\"http\", \"Stopped HTTP server\\n\");\n+    LogPrint(BCLog::HTTP, \"Stopped HTTP server\\n\");\n }\n \n struct event_base* EventBase()\n@@ -646,7 +657,7 @@ HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod()\n \n void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    LogPrint(\"http\", \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LogPrint(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n     pathHandlers.push_back(HTTPPathHandler(prefix, exactMatch, handler));\n }\n \n@@ -659,7 +670,7 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n             break;\n     if (i != iend)\n     {\n-        LogPrint(\"http\", \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        LogPrint(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n         pathHandlers.erase(i);\n     }\n }"
      },
      {
        "sha": "6be9950682034d6a4b7fb37be7c3163c1864dedb",
        "filename": "src/httpserver.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/httpserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/httpserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -32,6 +32,10 @@ void InterruptHTTPServer();\n /** Stop HTTP server */\n void StopHTTPServer();\n \n+/** Change logging level for libevent. Removes BCLog::LIBEVENT from logCategories if\n+ * libevent doesn't support debug logging.*/\n+bool UpdateHTTPServerLogging(bool enable);\n+\n /** Handler for requests to a certain HTTP path */\n typedef std::function<bool(HTTPRequest* req, const std::string &)> HTTPRequestHandler;\n /** Register handler for prefix."
      },
      {
        "sha": "04d1280c92be9a1c66372fe28cc1a487835a131f",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 144,
        "deletions": 107,
        "changes": 251,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -16,6 +16,7 @@\n #include \"checkpoints.h\"\n #include \"compat/sanity.h\"\n #include \"consensus/validation.h\"\n+#include \"fs.h\"\n #include \"httpserver.h\"\n #include \"httprpc.h\"\n #include \"key.h\"\n@@ -24,9 +25,12 @@\n #include \"netbase.h\"\n #include \"net.h\"\n #include \"net_processing.h\"\n+#include \"policy/feerate.h\"\n+#include \"policy/fees.h\"\n #include \"policy/policy.h\"\n #include \"rpc/server.h\"\n #include \"rpc/register.h\"\n+#include \"rpc/blockchain.h\"\n #include \"script/standard.h\"\n #include \"script/sigcache.h\"\n #include \"scheduler.h\"\n@@ -55,8 +59,6 @@\n #include <boost/algorithm/string/replace.hpp>\n #include <boost/algorithm/string/split.hpp>\n #include <boost/bind.hpp>\n-#include <boost/filesystem.hpp>\n-#include <boost/function.hpp>\n #include <boost/interprocess/sync/file_lock.hpp>\n #include <boost/thread.hpp>\n #include <openssl/crypto.h>\n@@ -144,9 +146,9 @@ class CCoinsViewErrorCatcher : public CCoinsViewBacked\n {\n public:\n     CCoinsViewErrorCatcher(CCoinsView* view) : CCoinsViewBacked(view) {}\n-    bool GetCoins(const uint256 &txid, CCoins &coins) const {\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override {\n         try {\n-            return CCoinsViewBacked::GetCoins(txid, coins);\n+            return CCoinsViewBacked::GetCoin(outpoint, coin);\n         } catch(const std::runtime_error& e) {\n             uiInterface.ThreadSafeMessageBox(_(\"Error reading from database, shutting down.\"), \"\", CClientUIInterface::MSG_ERROR);\n             LogPrintf(\"Error reading from database: %s\\n\", e.what());\n@@ -206,15 +208,17 @@ void Shutdown()\n \n     StopTorControl();\n     UnregisterNodeSignals(GetNodeSignals());\n-    if (fDumpMempoolLater)\n+    if (fDumpMempoolLater && GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n         DumpMempool();\n+    }\n \n     if (fFeeEstimatesInitialized)\n     {\n-        boost::filesystem::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n-        CAutoFile est_fileout(fopen(est_path.string().c_str(), \"wb\"), SER_DISK, CLIENT_VERSION);\n+        ::feeEstimator.FlushUnconfirmed(::mempool);\n+        fs::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n+        CAutoFile est_fileout(fsbridge::fopen(est_path, \"wb\"), SER_DISK, CLIENT_VERSION);\n         if (!est_fileout.IsNull())\n-            mempool.WriteFeeEstimates(est_fileout);\n+            ::feeEstimator.Write(est_fileout);\n         else\n             LogPrintf(\"%s: Failed to write fee estimates to %s\\n\", __func__, est_path.string());\n         fFeeEstimatesInitialized = false;\n@@ -249,8 +253,8 @@ void Shutdown()\n \n #ifndef WIN32\n     try {\n-        boost::filesystem::remove(GetPidFile());\n-    } catch (const boost::filesystem::filesystem_error& e) {\n+        fs::remove(GetPidFile());\n+    } catch (const fs::filesystem_error& e) {\n         LogPrintf(\"%s: Unable to remove pidfile: %s\\n\", __func__, e.what());\n     }\n #endif\n@@ -265,18 +269,31 @@ void Shutdown()\n }\n \n /**\n- * Signal handlers are very limited in what they are allowed to do, so:\n+ * Signal handlers are very limited in what they are allowed to do.\n+ * The execution context the handler is invoked in is not guaranteed,\n+ * so we restrict handler operations to just touching variables:\n  */\n-void HandleSIGTERM(int)\n+static void HandleSIGTERM(int)\n {\n     fRequestShutdown = true;\n }\n \n-void HandleSIGHUP(int)\n+static void HandleSIGHUP(int)\n {\n     fReopenDebugLog = true;\n }\n \n+#ifndef WIN32\n+static void registerSignalHandler(int signal, void(*handler)(int))\n+{\n+    struct sigaction sa;\n+    sa.sa_handler = handler;\n+    sigemptyset(&sa.sa_mask);\n+    sa.sa_flags = 0;\n+    sigaction(signal, &sa, NULL);\n+}\n+#endif\n+\n bool static Bind(CConnman& connman, const CService &addr, unsigned int flags) {\n     if (!(flags & BF_EXPLICIT) && IsLimited(addr))\n         return false;\n@@ -298,7 +315,7 @@ void OnRPCStopped()\n     uiInterface.NotifyBlockTip.disconnect(&RPCNotifyBlockChange);\n     RPCNotifyBlockChange(false, nullptr);\n     cvBlockChange.notify_all();\n-    LogPrint(\"rpc\", \"RPC stopped.\\n\");\n+    LogPrint(BCLog::RPC, \"RPC stopped.\\n\");\n }\n \n void OnRPCPreCommand(const CRPCCommand& cmd)\n@@ -312,6 +329,10 @@ void OnRPCPreCommand(const CRPCCommand& cmd)\n \n std::string HelpMessage(HelpMessageMode mode)\n {\n+    const auto defaultBaseParams = CreateBaseChainParams(CBaseChainParams::MAIN);\n+    const auto testnetBaseParams = CreateBaseChainParams(CBaseChainParams::TESTNET);\n+    const auto defaultChainParams = CreateChainParams(CBaseChainParams::MAIN);\n+    const auto testnetChainParams = CreateChainParams(CBaseChainParams::TESTNET);\n     const bool showDebug = GetBoolArg(\"-help-debug\", false);\n \n     // When adding new options to the categories, please keep and ensure alphabetical ordering.\n@@ -323,7 +344,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-blocknotify=<cmd>\", _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\"));\n     if (showDebug)\n         strUsage += HelpMessageOpt(\"-blocksonly\", strprintf(_(\"Whether to operate in a blocks only mode (default: %u)\"), DEFAULT_BLOCKSONLY));\n-    strUsage +=HelpMessageOpt(\"-assumevalid=<hex>\", strprintf(_(\"If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\"), Params(CBaseChainParams::MAIN).GetConsensus().defaultAssumeValid.GetHex(), Params(CBaseChainParams::TESTNET).GetConsensus().defaultAssumeValid.GetHex()));\n+    strUsage +=HelpMessageOpt(\"-assumevalid=<hex>\", strprintf(_(\"If this block is in the chain assume that it and its ancestors are valid and potentially skip their script verification (0 to verify all, default: %s, testnet: %s)\"), defaultChainParams->GetConsensus().defaultAssumeValid.GetHex(), testnetChainParams->GetConsensus().defaultAssumeValid.GetHex()));\n     strUsage += HelpMessageOpt(\"-conf=<file>\", strprintf(_(\"Specify configuration file (default: %s)\"), BITCOIN_CONF_FILENAME));\n     if (mode == HMM_BITCOIND)\n     {\n@@ -339,6 +360,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-maxorphantx=<n>\", strprintf(_(\"Keep at most <n> unconnectable transactions in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n     strUsage += HelpMessageOpt(\"-maxmempool=<n>\", strprintf(_(\"Keep the transaction memory pool below <n> megabytes (default: %u)\"), DEFAULT_MAX_MEMPOOL_SIZE));\n     strUsage += HelpMessageOpt(\"-mempoolexpiry=<n>\", strprintf(_(\"Do not keep transactions in the mempool longer than <n> hours (default: %u)\"), DEFAULT_MEMPOOL_EXPIRY));\n+    strUsage += HelpMessageOpt(\"-persistmempool\", strprintf(_(\"Whether to save the mempool on shutdown and load on restart (default: %u)\"), DEFAULT_PERSIST_MEMPOOL));\n     strUsage += HelpMessageOpt(\"-blockreconstructionextratxn=<n>\", strprintf(_(\"Extra transactions to keep in memory for compact block reconstructions (default: %u)\"), DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN));\n     strUsage += HelpMessageOpt(\"-par=<n>\", strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"),\n         -GetNumCores(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS));\n@@ -360,13 +382,13 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-banscore=<n>\", strprintf(_(\"Threshold for disconnecting misbehaving peers (default: %u)\"), DEFAULT_BANSCORE_THRESHOLD));\n     strUsage += HelpMessageOpt(\"-bantime=<n>\", strprintf(_(\"Number of seconds to keep misbehaving peers from reconnecting (default: %u)\"), DEFAULT_MISBEHAVING_BANTIME));\n     strUsage += HelpMessageOpt(\"-bind=<addr>\", _(\"Bind to given address and always listen on it. Use [host]:port notation for IPv6\"));\n-    strUsage += HelpMessageOpt(\"-connect=<ip>\", _(\"Connect only to the specified node(s); -noconnect or -connect=0 alone to disable automatic connections\"));\n+    strUsage += HelpMessageOpt(\"-connect=<ip>\", _(\"Connect only to the specified node(s); -connect=0 disables automatic connections\"));\n     strUsage += HelpMessageOpt(\"-discover\", _(\"Discover own IP addresses (default: 1 when listening and no -externalip or -proxy)\"));\n     strUsage += HelpMessageOpt(\"-dns\", _(\"Allow DNS lookups for -addnode, -seednode and -connect\") + \" \" + strprintf(_(\"(default: %u)\"), DEFAULT_NAME_LOOKUP));\n-    strUsage += HelpMessageOpt(\"-dnsseed\", _(\"Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect/-noconnect)\"));\n+    strUsage += HelpMessageOpt(\"-dnsseed\", _(\"Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect used)\"));\n     strUsage += HelpMessageOpt(\"-externalip=<ip>\", _(\"Specify your own public address\"));\n     strUsage += HelpMessageOpt(\"-forcednsseed\", strprintf(_(\"Always query for peer addresses via DNS lookup (default: %u)\"), DEFAULT_FORCEDNSSEED));\n-    strUsage += HelpMessageOpt(\"-listen\", _(\"Accept connections from outside (default: 1 if no -proxy or -connect/-noconnect)\"));\n+    strUsage += HelpMessageOpt(\"-listen\", _(\"Accept connections from outside (default: 1 if no -proxy or -connect)\"));\n     strUsage += HelpMessageOpt(\"-listenonion\", strprintf(_(\"Automatically create Tor hidden service (default: %d)\"), DEFAULT_LISTEN_ONION));\n     strUsage += HelpMessageOpt(\"-maxconnections=<n>\", strprintf(_(\"Maintain at most <n> connections to peers (default: %u)\"), DEFAULT_MAX_PEER_CONNECTIONS));\n     strUsage += HelpMessageOpt(\"-maxreceivebuffer=<n>\", strprintf(_(\"Maximum per-connection receive buffer, <n>*1000 bytes (default: %u)\"), DEFAULT_MAXRECEIVEBUFFER));\n@@ -376,10 +398,9 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-onlynet=<net>\", _(\"Only connect to nodes in network <net> (ipv4, ipv6 or onion)\"));\n     strUsage += HelpMessageOpt(\"-permitbaremultisig\", strprintf(_(\"Relay non-P2SH multisig (default: %u)\"), DEFAULT_PERMIT_BAREMULTISIG));\n     strUsage += HelpMessageOpt(\"-peerbloomfilters\", strprintf(_(\"Support filtering of blocks and transaction with bloom filters (default: %u)\"), DEFAULT_PEERBLOOMFILTERS));\n-    strUsage += HelpMessageOpt(\"-port=<port>\", strprintf(_(\"Listen for connections on <port> (default: %u or testnet: %u)\"), Params(CBaseChainParams::MAIN).GetDefaultPort(), Params(CBaseChainParams::TESTNET).GetDefaultPort()));\n+    strUsage += HelpMessageOpt(\"-port=<port>\", strprintf(_(\"Listen for connections on <port> (default: %u or testnet: %u)\"), defaultChainParams->GetDefaultPort(), testnetChainParams->GetDefaultPort()));\n     strUsage += HelpMessageOpt(\"-proxy=<ip:port>\", _(\"Connect through SOCKS5 proxy\"));\n     strUsage += HelpMessageOpt(\"-proxyrandomize\", strprintf(_(\"Randomize credentials for every proxy connection. This enables Tor stream isolation (default: %u)\"), DEFAULT_PROXYRANDOMIZE));\n-    strUsage += HelpMessageOpt(\"-rpcserialversion\", strprintf(_(\"Sets the serialization of raw transaction or block hex returned in non-verbose mode, non-segwit(0) or segwit(1) (default: %d)\"), DEFAULT_RPC_SERIALIZE_VERSION));\n     strUsage += HelpMessageOpt(\"-seednode=<ip>\", _(\"Connect to a node to retrieve peer addresses, and disconnect\"));\n     strUsage += HelpMessageOpt(\"-timeout=<n>\", strprintf(_(\"Specify connection timeout in milliseconds (minimum: 1, default: %d)\"), DEFAULT_CONNECT_TIMEOUT));\n     strUsage += HelpMessageOpt(\"-torcontrol=<ip>:<port>\", strprintf(_(\"Tor control port to use if onion listening enabled (default: %s)\"), DEFAULT_TOR_CONTROL));\n@@ -394,8 +415,6 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-whitebind=<addr>\", _(\"Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\"));\n     strUsage += HelpMessageOpt(\"-whitelist=<IP address or network>\", _(\"Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or CIDR notated network (e.g. 1.2.3.0/24). Can be specified multiple times.\") +\n         \" \" + _(\"Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway\"));\n-    strUsage += HelpMessageOpt(\"-whitelistrelay\", strprintf(_(\"Accept relayed transactions received from whitelisted peers even when not relaying transactions (default: %d)\"), DEFAULT_WHITELISTRELAY));\n-    strUsage += HelpMessageOpt(\"-whitelistforcerelay\", strprintf(_(\"Force relay of transactions from whitelisted peers even if they violate local relay policy (default: %d)\"), DEFAULT_WHITELISTFORCERELAY));\n     strUsage += HelpMessageOpt(\"-maxuploadtarget=<n>\", strprintf(_(\"Tries to keep outbound traffic under the given target (in MiB per 24h), 0 = no limit (default: %d)\"), DEFAULT_MAX_UPLOAD_TARGET));\n \n #ifdef ENABLE_WALLET\n@@ -416,27 +435,25 @@ std::string HelpMessage(HelpMessageMode mode)\n     {\n         strUsage += HelpMessageOpt(\"-checkblocks=<n>\", strprintf(_(\"How many blocks to check at startup (default: %u, 0 = all)\"), DEFAULT_CHECKBLOCKS));\n         strUsage += HelpMessageOpt(\"-checklevel=<n>\", strprintf(_(\"How thorough the block verification of -checkblocks is (0-4, default: %u)\"), DEFAULT_CHECKLEVEL));\n-        strUsage += HelpMessageOpt(\"-checkblockindex\", strprintf(\"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. Also sets -checkmempool (default: %u)\", Params(CBaseChainParams::MAIN).DefaultConsistencyChecks()));\n-        strUsage += HelpMessageOpt(\"-checkmempool=<n>\", strprintf(\"Run checks every <n> transactions (default: %u)\", Params(CBaseChainParams::MAIN).DefaultConsistencyChecks()));\n+        strUsage += HelpMessageOpt(\"-checkblockindex\", strprintf(\"Do a full consistency check for mapBlockIndex, setBlockIndexCandidates, chainActive and mapBlocksUnlinked occasionally. Also sets -checkmempool (default: %u)\", defaultChainParams->DefaultConsistencyChecks()));\n+        strUsage += HelpMessageOpt(\"-checkmempool=<n>\", strprintf(\"Run checks every <n> transactions (default: %u)\", defaultChainParams->DefaultConsistencyChecks()));\n         strUsage += HelpMessageOpt(\"-checkpoints\", strprintf(\"Disable expensive verification for known chain history (default: %u)\", DEFAULT_CHECKPOINTS_ENABLED));\n         strUsage += HelpMessageOpt(\"-disablesafemode\", strprintf(\"Disable safemode, override a real safe mode event (default: %u)\", DEFAULT_DISABLE_SAFEMODE));\n         strUsage += HelpMessageOpt(\"-testsafemode\", strprintf(\"Force safe mode (default: %u)\", DEFAULT_TESTSAFEMODE));\n         strUsage += HelpMessageOpt(\"-dropmessagestest=<n>\", \"Randomly drop 1 of every <n> network messages\");\n         strUsage += HelpMessageOpt(\"-fuzzmessagestest=<n>\", \"Randomly fuzz 1 of every <n> network messages\");\n         strUsage += HelpMessageOpt(\"-stopafterblockimport\", strprintf(\"Stop running after importing blocks from disk (default: %u)\", DEFAULT_STOPAFTERBLOCKIMPORT));\n+        strUsage += HelpMessageOpt(\"-stopatheight\", strprintf(\"Stop running after reaching the given height in the main chain (default: %u)\", DEFAULT_STOPATHEIGHT));\n+\n         strUsage += HelpMessageOpt(\"-limitancestorcount=<n>\", strprintf(\"Do not accept transactions if number of in-mempool ancestors is <n> or more (default: %u)\", DEFAULT_ANCESTOR_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitancestorsize=<n>\", strprintf(\"Do not accept transactions whose size with all in-mempool ancestors exceeds <n> kilobytes (default: %u)\", DEFAULT_ANCESTOR_SIZE_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitdescendantcount=<n>\", strprintf(\"Do not accept transactions if any ancestor would have <n> or more in-mempool descendants (default: %u)\", DEFAULT_DESCENDANT_LIMIT));\n         strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n-        strUsage += HelpMessageOpt(\"-bip9params=deployment:start:end\", \"Use given start/end times for specified BIP9 deployment (regtest-only)\");\n+        strUsage += HelpMessageOpt(\"-vbparams=deployment:start:end\", \"Use given start/end times for specified version bits deployment (regtest-only)\");\n     }\n-    std::string debugCategories = \"addrman, alert, bench, cmpctblock, coindb, db, http, leveldb, libevent, lock, mempool, mempoolrej, net, proxy, prune, rand, reindex, rpc, selectcoins, tor, zmq\"; // Don't translate these and qt below\n-    if (mode == HMM_BITCOIN_QT)\n-        debugCategories += \", qt\";\n     strUsage += HelpMessageOpt(\"-debug=<category>\", strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \". \" +\n-        _(\"If <category> is not supplied or if <category> = 1, output all debugging information.\") + _(\"<category> can be:\") + \" \" + debugCategories + \".\");\n-    if (showDebug)\n-        strUsage += HelpMessageOpt(\"-nodebug\", \"Turn off debugging messages, same as -debug=0\");\n+        _(\"If <category> is not supplied or if <category> = 1, output all debugging information.\") + \" \" + _(\"<category> can be:\") + \" \" + ListLogCategories() + \".\");\n+    strUsage += HelpMessageOpt(\"-debugexclude=<category>\", strprintf(_(\"Exclude debugging information for a category. Can be used in conjunction with -debug=1 to output debug logs for all categories except one or more specified categories.\")));\n     strUsage += HelpMessageOpt(\"-help-debug\", _(\"Show all debugging options (usage: --help -help-debug)\"));\n     strUsage += HelpMessageOpt(\"-logips\", strprintf(_(\"Include IP addresses in debug output (default: %u)\"), DEFAULT_LOGIPS));\n     strUsage += HelpMessageOpt(\"-logtimestamps\", strprintf(_(\"Prepend debug output with timestamp (default: %u)\"), DEFAULT_LOGTIMESTAMPS));\n@@ -447,8 +464,6 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-maxsigcachesize=<n>\", strprintf(\"Limit size of signature cache to <n> MiB (default: %u)\", DEFAULT_MAX_SIG_CACHE_SIZE));\n         strUsage += HelpMessageOpt(\"-maxtipage=<n>\", strprintf(\"Maximum tip age in seconds to consider node in initial block download (default: %u)\", DEFAULT_MAX_TIP_AGE));\n     }\n-    strUsage += HelpMessageOpt(\"-minrelaytxfee=<amt>\", strprintf(_(\"Fees (in %s/kB) smaller than this are considered zero fee for relaying, mining and transaction creation (default: %s)\"),\n-        CURRENCY_UNIT, FormatMoney(DEFAULT_MIN_RELAY_TX_FEE)));\n     strUsage += HelpMessageOpt(\"-maxtxfee=<amt>\", strprintf(_(\"Maximum total fees (in %s) to use in a single wallet transaction or raw transaction; setting this too low may abort large transactions (default: %s)\"),\n         CURRENCY_UNIT, FormatMoney(DEFAULT_TRANSACTION_MAXFEE)));\n     strUsage += HelpMessageOpt(\"-printtoconsole\", _(\"Send trace/debug info to console instead of debug.log file\"));\n@@ -462,14 +477,18 @@ std::string HelpMessage(HelpMessageMode mode)\n \n     strUsage += HelpMessageGroup(_(\"Node relay options:\"));\n     if (showDebug) {\n-        strUsage += HelpMessageOpt(\"-acceptnonstdtxn\", strprintf(\"Relay and mine \\\"non-standard\\\" transactions (%sdefault: %u)\", \"testnet/regtest only; \", !Params(CBaseChainParams::TESTNET).RequireStandard()));\n+        strUsage += HelpMessageOpt(\"-acceptnonstdtxn\", strprintf(\"Relay and mine \\\"non-standard\\\" transactions (%sdefault: %u)\", \"testnet/regtest only; \", defaultChainParams->RequireStandard()));\n         strUsage += HelpMessageOpt(\"-incrementalrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to define cost of relay, used for mempool limiting and BIP 125 replacement. (default: %s)\", CURRENCY_UNIT, FormatMoney(DEFAULT_INCREMENTAL_RELAY_FEE)));\n         strUsage += HelpMessageOpt(\"-dustrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to defined dust, the value of an output such that it will cost about 1/3 of its value in fees at this fee rate to spend it. (default: %s)\", CURRENCY_UNIT, FormatMoney(DUST_RELAY_TX_FEE)));\n     }\n     strUsage += HelpMessageOpt(\"-bytespersigop\", strprintf(_(\"Equivalent bytes per sigop in transactions for relay and mining (default: %u)\"), DEFAULT_BYTES_PER_SIGOP));\n     strUsage += HelpMessageOpt(\"-datacarrier\", strprintf(_(\"Relay and mine data carrier transactions (default: %u)\"), DEFAULT_ACCEPT_DATACARRIER));\n     strUsage += HelpMessageOpt(\"-datacarriersize\", strprintf(_(\"Maximum size of data in data carrier transactions we relay and mine (default: %u)\"), MAX_OP_RETURN_RELAY));\n     strUsage += HelpMessageOpt(\"-mempoolreplacement\", strprintf(_(\"Enable transaction replacement in the memory pool (default: %u)\"), DEFAULT_ENABLE_REPLACEMENT));\n+    strUsage += HelpMessageOpt(\"-minrelaytxfee=<amt>\", strprintf(_(\"Fees (in %s/kB) smaller than this are considered zero fee for relaying, mining and transaction creation (default: %s)\"),\n+        CURRENCY_UNIT, FormatMoney(DEFAULT_MIN_RELAY_TX_FEE)));\n+    strUsage += HelpMessageOpt(\"-whitelistrelay\", strprintf(_(\"Accept relayed transactions received from whitelisted peers even when not relaying transactions (default: %d)\"), DEFAULT_WHITELISTRELAY));\n+    strUsage += HelpMessageOpt(\"-whitelistforcerelay\", strprintf(_(\"Force relay of transactions from whitelisted peers even if they violate local relay policy (default: %d)\"), DEFAULT_WHITELISTFORCERELAY));\n \n     strUsage += HelpMessageGroup(_(\"Block creation options:\"));\n     strUsage += HelpMessageOpt(\"-blockmaxweight=<n>\", strprintf(_(\"Set maximum BIP141 block weight (default: %d)\"), DEFAULT_BLOCK_MAX_WEIGHT));\n@@ -486,8 +505,9 @@ std::string HelpMessage(HelpMessageMode mode)\n     strUsage += HelpMessageOpt(\"-rpcuser=<user>\", _(\"Username for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcauth=<userpw>\", _(\"Username and hashed password for JSON-RPC connections. The field <userpw> comes in the format: <USERNAME>:<SALT>$<HASH>. A canonical python script is included in share/rpcuser. The client then connects normally using the rpcuser=<USERNAME>/rpcpassword=<PASSWORD> pair of arguments. This option can be specified multiple times\"));\n-    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"), BaseParams(CBaseChainParams::MAIN).RPCPort(), BaseParams(CBaseChainParams::TESTNET).RPCPort()));\n+    strUsage += HelpMessageOpt(\"-rpcport=<port>\", strprintf(_(\"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"), defaultBaseParams->RPCPort(), testnetBaseParams->RPCPort()));\n     strUsage += HelpMessageOpt(\"-rpcallowip=<ip>\", _(\"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\"));\n+    strUsage += HelpMessageOpt(\"-rpcserialversion\", strprintf(_(\"Sets the serialization of raw transaction or block hex returned in non-verbose mode, non-segwit(0) or segwit(1) (default: %d)\"), DEFAULT_RPC_SERIALIZE_VERSION));\n     strUsage += HelpMessageOpt(\"-rpcthreads=<n>\", strprintf(_(\"Set the number of threads to service RPC calls (default: %d)\"), DEFAULT_HTTP_THREADS));\n     if (showDebug) {\n         strUsage += HelpMessageOpt(\"-rpcworkqueue=<n>\", strprintf(\"Set the depth of the work queue to service RPC calls (default: %d)\", DEFAULT_HTTP_WORKQUEUE));\n@@ -567,14 +587,14 @@ struct CImportingNow\n // works correctly.\n void CleanupBlockRevFiles()\n {\n-    std::map<std::string, boost::filesystem::path> mapBlockFiles;\n+    std::map<std::string, fs::path> mapBlockFiles;\n \n     // Glob all blk?????.dat and rev?????.dat files from the blocks directory.\n     // Remove the rev files immediately and insert the blk file paths into an\n     // ordered map keyed by block file index.\n     LogPrintf(\"Removing unusable blk?????.dat and rev?????.dat files for -reindex with -prune\\n\");\n-    boost::filesystem::path blocksdir = GetDataDir() / \"blocks\";\n-    for (boost::filesystem::directory_iterator it(blocksdir); it != boost::filesystem::directory_iterator(); it++) {\n+    fs::path blocksdir = GetDataDir() / \"blocks\";\n+    for (fs::directory_iterator it(blocksdir); it != fs::directory_iterator(); it++) {\n         if (is_regular_file(*it) &&\n             it->path().filename().string().length() == 12 &&\n             it->path().filename().string().substr(8,4) == \".dat\")\n@@ -591,7 +611,7 @@ void CleanupBlockRevFiles()\n     // keeping a separate counter.  Once we hit a gap (or if 0 doesn't exist)\n     // start removing block files.\n     int nContigCounter = 0;\n-    BOOST_FOREACH(const PAIRTYPE(std::string, boost::filesystem::path)& item, mapBlockFiles) {\n+    BOOST_FOREACH(const PAIRTYPE(std::string, fs::path)& item, mapBlockFiles) {\n         if (atoi(item.first) == nContigCounter) {\n             nContigCounter++;\n             continue;\n@@ -600,7 +620,7 @@ void CleanupBlockRevFiles()\n     }\n }\n \n-void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n+void ThreadImport(std::vector<fs::path> vImportFiles)\n {\n     const CChainParams& chainparams = Params();\n     RenameThread(\"bitcoin-loadblk\");\n@@ -613,7 +633,7 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n         int nFile = 0;\n         while (true) {\n             CDiskBlockPos pos(nFile, 0);\n-            if (!boost::filesystem::exists(GetBlockPosFilename(pos, \"blk\")))\n+            if (!fs::exists(GetBlockPosFilename(pos, \"blk\")))\n                 break; // No block files left to reindex\n             FILE *file = OpenBlockFile(pos, true);\n             if (!file)\n@@ -630,11 +650,11 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n     }\n \n     // hardcoded $DATADIR/bootstrap.dat\n-    boost::filesystem::path pathBootstrap = GetDataDir() / \"bootstrap.dat\";\n-    if (boost::filesystem::exists(pathBootstrap)) {\n-        FILE *file = fopen(pathBootstrap.string().c_str(), \"rb\");\n+    fs::path pathBootstrap = GetDataDir() / \"bootstrap.dat\";\n+    if (fs::exists(pathBootstrap)) {\n+        FILE *file = fsbridge::fopen(pathBootstrap, \"rb\");\n         if (file) {\n-            boost::filesystem::path pathBootstrapOld = GetDataDir() / \"bootstrap.dat.old\";\n+            fs::path pathBootstrapOld = GetDataDir() / \"bootstrap.dat.old\";\n             LogPrintf(\"Importing bootstrap.dat...\\n\");\n             LoadExternalBlockFile(chainparams, file);\n             RenameOver(pathBootstrap, pathBootstrapOld);\n@@ -644,8 +664,8 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n     }\n \n     // -loadblock=\n-    BOOST_FOREACH(const boost::filesystem::path& path, vImportFiles) {\n-        FILE *file = fopen(path.string().c_str(), \"rb\");\n+    BOOST_FOREACH(const fs::path& path, vImportFiles) {\n+        FILE *file = fsbridge::fopen(path, \"rb\");\n         if (file) {\n             LogPrintf(\"Importing blocks file %s...\\n\", path.string());\n             LoadExternalBlockFile(chainparams, file);\n@@ -666,8 +686,10 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n         StartShutdown();\n     }\n     } // End scope of CImportingNow\n-    LoadMempool();\n-    fDumpMempoolLater = !fRequestShutdown;\n+    if (GetArg(\"-persistmempool\", DEFAULT_PERSIST_MEMPOOL)) {\n+        LoadMempool();\n+        fDumpMempoolLater = !fRequestShutdown;\n+    }\n }\n \n /** Sanity checks\n@@ -724,7 +746,7 @@ void InitParameterInteraction()\n             LogPrintf(\"%s: parameter interaction: -whitebind set -> setting -listen=1\\n\", __func__);\n     }\n \n-    if (mapMultiArgs.count(\"-connect\") && mapMultiArgs.at(\"-connect\").size() > 0) {\n+    if (gArgs.IsArgSet(\"-connect\")) {\n         // when only connecting to trusted nodes, do not seed via DNS, or listen by default\n         if (SoftSetBoolArg(\"-dnsseed\", false))\n             LogPrintf(\"%s: parameter interaction: -connect set -> setting -dnsseed=0\\n\", __func__);\n@@ -848,19 +870,11 @@ bool AppInitBasicSetup()\n     }\n \n     // Clean shutdown on SIGTERM\n-    struct sigaction sa;\n-    sa.sa_handler = HandleSIGTERM;\n-    sigemptyset(&sa.sa_mask);\n-    sa.sa_flags = 0;\n-    sigaction(SIGTERM, &sa, NULL);\n-    sigaction(SIGINT, &sa, NULL);\n+    registerSignalHandler(SIGTERM, HandleSIGTERM);\n+    registerSignalHandler(SIGINT, HandleSIGTERM);\n \n     // Reopen debug.log on SIGHUP\n-    struct sigaction sa_hup;\n-    sa_hup.sa_handler = HandleSIGHUP;\n-    sigemptyset(&sa_hup.sa_mask);\n-    sa_hup.sa_flags = 0;\n-    sigaction(SIGHUP, &sa_hup, NULL);\n+    registerSignalHandler(SIGHUP, HandleSIGHUP);\n \n     // Ignore SIGPIPE, otherwise it will bring the daemon down if the client closes unexpectedly\n     signal(SIGPIPE, SIG_IGN);\n@@ -886,8 +900,8 @@ bool AppInitParameterInteraction()\n \n     // Make sure enough file descriptors are available\n     int nBind = std::max(\n-                (mapMultiArgs.count(\"-bind\") ? mapMultiArgs.at(\"-bind\").size() : 0) +\n-                (mapMultiArgs.count(\"-whitebind\") ? mapMultiArgs.at(\"-whitebind\").size() : 0), size_t(1));\n+                (gArgs.IsArgSet(\"-bind\") ? gArgs.GetArgs(\"-bind\").size() : 0) +\n+                (gArgs.IsArgSet(\"-whitebind\") ? gArgs.GetArgs(\"-whitebind\").size() : 0), size_t(1));\n     nUserMaxConnections = GetArg(\"-maxconnections\", DEFAULT_MAX_PEER_CONNECTIONS);\n     nMaxConnections = std::max(nUserMaxConnections, 0);\n \n@@ -902,13 +916,32 @@ bool AppInitParameterInteraction()\n         InitWarning(strprintf(_(\"Reducing -maxconnections from %d to %d, because of system limitations.\"), nUserMaxConnections, nMaxConnections));\n \n     // ********************************************************* Step 3: parameter-to-internal-flags\n+    if (gArgs.IsArgSet(\"-debug\")) {\n+        // Special-case: if -debug=0/-nodebug is set, turn off debugging messages\n+        const std::vector<std::string> categories = gArgs.GetArgs(\"-debug\");\n+\n+        if (find(categories.begin(), categories.end(), std::string(\"0\")) == categories.end()) {\n+            for (const auto& cat : categories) {\n+                uint32_t flag = 0;\n+                if (!GetLogCategory(&flag, &cat)) {\n+                    InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debug\", cat));\n+                    continue;\n+                }\n+                logCategories |= flag;\n+            }\n+        }\n+    }\n \n-    fDebug = mapMultiArgs.count(\"-debug\");\n-    // Special-case: if -debug=0/-nodebug is set, turn off debugging messages\n-    if (fDebug) {\n-        const std::vector<std::string>& categories = mapMultiArgs.at(\"-debug\");\n-        if (GetBoolArg(\"-nodebug\", false) || find(categories.begin(), categories.end(), std::string(\"0\")) != categories.end())\n-            fDebug = false;\n+    // Now remove the logging categories which were explicitly excluded\n+    if (gArgs.IsArgSet(\"-debugexclude\")) {\n+        for (const std::string& cat : gArgs.GetArgs(\"-debugexclude\")) {\n+            uint32_t flag = 0;\n+            if (!GetLogCategory(&flag, &cat)) {\n+                InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debugexclude\", cat));\n+                continue;\n+            }\n+            logCategories &= ~flag;\n+        }\n     }\n \n     // Check for -debugnet\n@@ -1071,17 +1104,16 @@ bool AppInitParameterInteraction()\n         fEnableReplacement = (std::find(vstrReplacementModes.begin(), vstrReplacementModes.end(), \"fee\") != vstrReplacementModes.end());\n     }\n \n-    if (mapMultiArgs.count(\"-bip9params\")) {\n-        // Allow overriding BIP9 parameters for testing\n+    if (gArgs.IsArgSet(\"-vbparams\")) {\n+        // Allow overriding version bits parameters for testing\n         if (!chainparams.MineBlocksOnDemand()) {\n-            return InitError(\"BIP9 parameters may only be overridden on regtest.\");\n+            return InitError(\"Version bits parameters may only be overridden on regtest.\");\n         }\n-        const std::vector<std::string>& deployments = mapMultiArgs.at(\"-bip9params\");\n-        for (auto i : deployments) {\n+        for (const std::string& strDeployment : gArgs.GetArgs(\"-vbparams\")) {\n             std::vector<std::string> vDeploymentParams;\n-            boost::split(vDeploymentParams, i, boost::is_any_of(\":\"));\n+            boost::split(vDeploymentParams, strDeployment, boost::is_any_of(\":\"));\n             if (vDeploymentParams.size() != 3) {\n-                return InitError(\"BIP9 parameters malformed, expecting deployment:start:end\");\n+                return InitError(\"Version bits parameters malformed, expecting deployment:start:end\");\n             }\n             int64_t nStartTime, nTimeout;\n             if (!ParseInt64(vDeploymentParams[1], &nStartTime)) {\n@@ -1094,9 +1126,9 @@ bool AppInitParameterInteraction()\n             for (int j=0; j<(int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j)\n             {\n                 if (vDeploymentParams[0].compare(VersionBitsDeploymentInfo[j].name) == 0) {\n-                    UpdateRegtestBIP9Parameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);\n+                    UpdateVersionBitsParameters(Consensus::DeploymentPos(j), nStartTime, nTimeout);\n                     found = true;\n-                    LogPrintf(\"Setting BIP9 activation parameters for %s to start=%ld, timeout=%ld\\n\", vDeploymentParams[0], nStartTime, nTimeout);\n+                    LogPrintf(\"Setting version bits activation parameters for %s to start=%ld, timeout=%ld\\n\", vDeploymentParams[0], nStartTime, nTimeout);\n                     break;\n                 }\n             }\n@@ -1113,8 +1145,8 @@ static bool LockDataDirectory(bool probeOnly)\n     std::string strDataDir = GetDataDir().string();\n \n     // Make sure only a single Bitcoin process is using the data directory.\n-    boost::filesystem::path pathLockFile = GetDataDir() / \".lock\";\n-    FILE* file = fopen(pathLockFile.string().c_str(), \"a\"); // empty lock file; created if it doesn't exist.\n+    fs::path pathLockFile = GetDataDir() / \".lock\";\n+    FILE* file = fsbridge::fopen(pathLockFile, \"a\"); // empty lock file; created if it doesn't exist.\n     if (file) fclose(file);\n \n     try {\n@@ -1162,7 +1194,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n #ifndef WIN32\n     CreatePidFile(GetPidFile(), getpid());\n #endif\n-    if (GetBoolArg(\"-shrinkdebugfile\", !fDebug)) {\n+    if (GetBoolArg(\"-shrinkdebugfile\", logCategories == BCLog::NONE)) {\n         // Do this first since it both loads a bunch of debug.log into memory,\n         // and because this needs to happen before any other debug.log printing\n         ShrinkDebugFile();\n@@ -1225,8 +1257,8 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     // sanitize comments per BIP-0014, format user agent and check total size\n     std::vector<std::string> uacomments;\n-    if (mapMultiArgs.count(\"-uacomment\")) {\n-        BOOST_FOREACH(std::string cmt, mapMultiArgs.at(\"-uacomment\"))\n+    if (gArgs.IsArgSet(\"-uacomment\")) {\n+        BOOST_FOREACH(std::string cmt, gArgs.GetArgs(\"-uacomment\"))\n         {\n             if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))\n                 return InitError(strprintf(_(\"User Agent comment (%s) contains unsafe characters.\"), cmt));\n@@ -1239,9 +1271,9 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n             strSubVersion.size(), MAX_SUBVERSION_LENGTH));\n     }\n \n-    if (mapMultiArgs.count(\"-onlynet\")) {\n+    if (gArgs.IsArgSet(\"-onlynet\")) {\n         std::set<enum Network> nets;\n-        BOOST_FOREACH(const std::string& snet, mapMultiArgs.at(\"-onlynet\")) {\n+        BOOST_FOREACH(const std::string& snet, gArgs.GetArgs(\"-onlynet\")) {\n             enum Network net = ParseNetwork(snet);\n             if (net == NET_UNROUTABLE)\n                 return InitError(strprintf(_(\"Unknown network specified in -onlynet: '%s'\"), snet));\n@@ -1254,8 +1286,8 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n         }\n     }\n \n-    if (mapMultiArgs.count(\"-whitelist\")) {\n-        BOOST_FOREACH(const std::string& net, mapMultiArgs.at(\"-whitelist\")) {\n+    if (gArgs.IsArgSet(\"-whitelist\")) {\n+        BOOST_FOREACH(const std::string& net, gArgs.GetArgs(\"-whitelist\")) {\n             CSubNet subnet;\n             LookupSubNet(net.c_str(), subnet);\n             if (!subnet.IsValid())\n@@ -1316,16 +1348,16 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     if (fListen) {\n         bool fBound = false;\n-        if (mapMultiArgs.count(\"-bind\")) {\n-            BOOST_FOREACH(const std::string& strBind, mapMultiArgs.at(\"-bind\")) {\n+        if (gArgs.IsArgSet(\"-bind\")) {\n+            BOOST_FOREACH(const std::string& strBind, gArgs.GetArgs(\"-bind\")) {\n                 CService addrBind;\n                 if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false))\n                     return InitError(ResolveErrMsg(\"bind\", strBind));\n                 fBound |= Bind(connman, addrBind, (BF_EXPLICIT | BF_REPORT_ERROR));\n             }\n         }\n-        if (mapMultiArgs.count(\"-whitebind\")) {\n-            BOOST_FOREACH(const std::string& strBind, mapMultiArgs.at(\"-whitebind\")) {\n+        if (gArgs.IsArgSet(\"-whitebind\")) {\n+            BOOST_FOREACH(const std::string& strBind, gArgs.GetArgs(\"-whitebind\")) {\n                 CService addrBind;\n                 if (!Lookup(strBind.c_str(), addrBind, 0, false))\n                     return InitError(ResolveErrMsg(\"whitebind\", strBind));\n@@ -1334,7 +1366,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                 fBound |= Bind(connman, addrBind, (BF_EXPLICIT | BF_REPORT_ERROR | BF_WHITELIST));\n             }\n         }\n-        if (!mapMultiArgs.count(\"-bind\") && !mapMultiArgs.count(\"-whitebind\")) {\n+        if (!gArgs.IsArgSet(\"-bind\") && !gArgs.IsArgSet(\"-whitebind\")) {\n             struct in_addr inaddr_any;\n             inaddr_any.s_addr = INADDR_ANY;\n             fBound |= Bind(connman, CService(in6addr_any, GetListenPort()), BF_NONE);\n@@ -1344,8 +1376,8 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n             return InitError(_(\"Failed to listen on any port. Use -listen=0 if you want this.\"));\n     }\n \n-    if (mapMultiArgs.count(\"-externalip\")) {\n-        BOOST_FOREACH(const std::string& strAddr, mapMultiArgs.at(\"-externalip\")) {\n+    if (gArgs.IsArgSet(\"-externalip\")) {\n+        BOOST_FOREACH(const std::string& strAddr, gArgs.GetArgs(\"-externalip\")) {\n             CService addrLocal;\n             if (Lookup(strAddr.c_str(), addrLocal, GetListenPort(), fNameLookup) && addrLocal.IsValid())\n                 AddLocal(addrLocal, LOCAL_MANUAL);\n@@ -1354,11 +1386,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n         }\n     }\n \n-    if (mapMultiArgs.count(\"-seednode\")) {\n-        BOOST_FOREACH(const std::string& strDest, mapMultiArgs.at(\"-seednode\"))\n-            connman.AddOneShot(strDest);\n-    }\n-\n #if ENABLE_ZMQ\n     pzmqNotificationInterface = CZMQNotificationInterface::Create();\n \n@@ -1378,7 +1405,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     fReindex = GetBoolArg(\"-reindex\", false);\n     bool fReindexChainState = GetBoolArg(\"-reindex-chainstate\", false);\n \n-    boost::filesystem::create_directories(GetDataDir() / \"blocks\");\n+    fs::create_directories(GetDataDir() / \"blocks\");\n \n     // cache size calculations\n     int64_t nTotalCache = (GetArg(\"-dbcache\", nDefaultDbCache) << 20);\n@@ -1423,6 +1450,12 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     //If we're reindexing in prune mode, wipe away unusable block files and all undo data files\n                     if (fPruneMode)\n                         CleanupBlockRevFiles();\n+                } else {\n+                    // If necessary, upgrade from older database format.\n+                    if (!pcoinsdbview->Upgrade()) {\n+                        strLoadError = _(\"Error upgrading chainstate database\");\n+                        break;\n+                    }\n                 }\n \n                 if (!LoadBlockIndex(chainparams)) {\n@@ -1486,7 +1519,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     break;\n                 }\n             } catch (const std::exception& e) {\n-                if (fDebug) LogPrintf(\"%s\\n\", e.what());\n+                LogPrintf(\"%s\\n\", e.what());\n                 strLoadError = _(\"Error opening block database\");\n                 break;\n             }\n@@ -1524,11 +1557,11 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     }\n     LogPrintf(\" block index %15dms\\n\", GetTimeMillis() - nStart);\n \n-    boost::filesystem::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n-    CAutoFile est_filein(fopen(est_path.string().c_str(), \"rb\"), SER_DISK, CLIENT_VERSION);\n+    fs::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n+    CAutoFile est_filein(fsbridge::fopen(est_path, \"rb\"), SER_DISK, CLIENT_VERSION);\n     // Allowed to fail as this file IS missing on first startup.\n     if (!est_filein.IsNull())\n-        mempool.ReadFeeEstimates(est_filein);\n+        ::feeEstimator.Read(est_filein);\n     fFeeEstimatesInitialized = true;\n \n     // ********************************************************* Step 8: load wallet\n@@ -1580,10 +1613,10 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     if (IsArgSet(\"-blocknotify\"))\n         uiInterface.NotifyBlockTip.connect(BlockNotifyCallback);\n \n-    std::vector<boost::filesystem::path> vImportFiles;\n-    if (mapMultiArgs.count(\"-loadblock\"))\n+    std::vector<fs::path> vImportFiles;\n+    if (gArgs.IsArgSet(\"-loadblock\"))\n     {\n-        BOOST_FOREACH(const std::string& strFile, mapMultiArgs.at(\"-loadblock\"))\n+        BOOST_FOREACH(const std::string& strFile, gArgs.GetArgs(\"-loadblock\"))\n             vImportFiles.push_back(strFile);\n     }\n \n@@ -1627,6 +1660,10 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     connOptions.nMaxOutboundTimeframe = nMaxOutboundTimeframe;\n     connOptions.nMaxOutboundLimit = nMaxOutboundLimit;\n \n+    if (gArgs.IsArgSet(\"-seednode\")) {\n+        connOptions.vSeedNodes = gArgs.GetArgs(\"-seednode\");\n+    }\n+\n     if (!connman.Start(scheduler, strNodeError, connOptions))\n         return InitError(strNodeError);\n "
      },
      {
        "sha": "5a75647f1a44163fce0660cad0b444dbbc5e4a64",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 8,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -131,14 +131,6 @@ void CKey::MakeNewKey(bool fCompressedIn) {\n     fCompressed = fCompressedIn;\n }\n \n-bool CKey::SetPrivKey(const CPrivKey &privkey, bool fCompressedIn) {\n-    if (!ec_privkey_import_der(secp256k1_context_sign, (unsigned char*)begin(), &privkey[0], privkey.size()))\n-        return false;\n-    fCompressed = fCompressedIn;\n-    fValid = true;\n-    return true;\n-}\n-\n CPrivKey CKey::GetPrivKey() const {\n     assert(fValid);\n     CPrivKey privkey;"
      },
      {
        "sha": "2c6f151727b6447fc1ac7c2816310d434195ab7f",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -94,9 +94,6 @@ class CKey\n     //! Check whether the public key corresponding to this private key is (to be) compressed.\n     bool IsCompressed() const { return fCompressed; }\n \n-    //! Initialize from a CPrivKey (serialized OpenSSL private key data).\n-    bool SetPrivKey(const CPrivKey& vchPrivKey, bool fCompressed);\n-\n     //! Generate a new private key using a cryptographic PRNG.\n     void MakeNewKey(bool fCompressed);\n "
      },
      {
        "sha": "710120d285ea6e1afc3da85ae00dcf25c3ce8ce9",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 7,
        "deletions": 9,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -12,10 +12,10 @@\n #include <map>\n #include <set>\n #include <vector>\n+#include <unordered_map>\n+#include <unordered_set>\n \n #include <boost/foreach.hpp>\n-#include <boost/unordered_set.hpp>\n-#include <boost/unordered_map.hpp>\n \n namespace memusage\n {\n@@ -146,25 +146,23 @@ static inline size_t DynamicUsage(const std::shared_ptr<X>& p)\n     return p ? MallocUsage(sizeof(X)) + MallocUsage(sizeof(stl_shared_counter)) : 0;\n }\n \n-// Boost data structures\n-\n template<typename X>\n-struct boost_unordered_node : private X\n+struct unordered_node : private X\n {\n private:\n     void* ptr;\n };\n \n template<typename X, typename Y>\n-static inline size_t DynamicUsage(const boost::unordered_set<X, Y>& s)\n+static inline size_t DynamicUsage(const std::unordered_set<X, Y>& s)\n {\n-    return MallocUsage(sizeof(boost_unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n+    return MallocUsage(sizeof(unordered_node<X>)) * s.size() + MallocUsage(sizeof(void*) * s.bucket_count());\n }\n \n template<typename X, typename Y, typename Z>\n-static inline size_t DynamicUsage(const boost::unordered_map<X, Y, Z>& m)\n+static inline size_t DynamicUsage(const std::unordered_map<X, Y, Z>& m)\n {\n-    return MallocUsage(sizeof(boost_unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n+    return MallocUsage(sizeof(unordered_node<std::pair<const X, Y> >)) * m.size() + MallocUsage(sizeof(void*) * m.bucket_count());\n }\n \n }"
      },
      {
        "sha": "78d7cd60010529afa6b3310eba69f5bccb0df7ee",
        "filename": "src/merkleblock.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/merkleblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/merkleblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -65,7 +65,7 @@ uint256 CPartialMerkleTree::CalcHash(int height, unsigned int pos, const std::ve\n     } else {\n         // calculate left hash\n         uint256 left = CalcHash(height-1, pos*2, vTxid), right;\n-        // calculate right hash if not beyond the end of the array - copy left hash otherwise1\n+        // calculate right hash if not beyond the end of the array - copy left hash otherwise\n         if (pos*2+1 < CalcTreeWidth(height-1))\n             right = CalcHash(height-1, pos*2+1, vTxid);\n         else"
      },
      {
        "sha": "de4c5c8d29e7329b36c64b07f0ee5a768c8c7544",
        "filename": "src/merkleblock.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/merkleblock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/merkleblock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -23,7 +23,7 @@\n  * storing a bit for each traversed node, signifying whether the node is the\n  * parent of at least one matched leaf txid (or a matched txid itself). In\n  * case we are at the leaf level, or this bit is 0, its merkle node hash is\n- * stored, and its children are not explorer further. Otherwise, no hash is\n+ * stored, and its children are not explored further. Otherwise, no hash is\n  * stored, but we recurse into both (or the only) child branch. During\n  * decoding, the same depth-first traversal is performed, consuming bits and\n  * hashes as they written during encoding."
      },
      {
        "sha": "28b6f23d569665b48e81c627a684487c603e800f",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 39,
        "deletions": 20,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -10,11 +10,13 @@\n #include \"chainparams.h\"\n #include \"coins.h\"\n #include \"consensus/consensus.h\"\n+#include \"consensus/tx_verify.h\"\n #include \"consensus/merkle.h\"\n #include \"consensus/validation.h\"\n #include \"hash.h\"\n #include \"validation.h\"\n #include \"net.h\"\n+#include \"policy/feerate.h\"\n #include \"policy/policy.h\"\n #include \"pow.h\"\n #include \"primitives/transaction.h\"\n@@ -26,8 +28,6 @@\n #include \"validationinterface.h\"\n \n #include <algorithm>\n-#include <boost/thread.hpp>\n-#include <boost/tuple/tuple.hpp>\n #include <queue>\n #include <utility>\n \n@@ -46,17 +46,6 @@ uint64_t nLastBlockTx = 0;\n uint64_t nLastBlockSize = 0;\n uint64_t nLastBlockWeight = 0;\n \n-class ScoreCompare\n-{\n-public:\n-    ScoreCompare() {}\n-\n-    bool operator()(const CTxMemPool::txiter a, const CTxMemPool::txiter b)\n-    {\n-        return CompareTxMemPoolEntryByScore()(*b,*a); // Convert to less than\n-    }\n-};\n-\n int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev)\n {\n     int64_t nOldTime = pblock->nTime;\n@@ -139,6 +128,8 @@ void BlockAssembler::resetBlock()\n \n std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn, bool fMineWitnessTx)\n {\n+    int64_t nTimeStart = GetTimeMicros();\n+\n     resetBlock();\n \n     pblocktemplate.reset(new CBlockTemplate());\n@@ -177,7 +168,11 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     // transaction (which in most cases can be a no-op).\n     fIncludeWitness = IsWitnessEnabled(pindexPrev, chainparams.GetConsensus()) && fMineWitnessTx;\n \n-    addPackageTxs();\n+    int nPackagesSelected = 0;\n+    int nDescendantsUpdated = 0;\n+    addPackageTxs(nPackagesSelected, nDescendantsUpdated);\n+\n+    int64_t nTime1 = GetTimeMicros();\n \n     nLastBlockTx = nBlockTx;\n     nLastBlockSize = nBlockSize;\n@@ -209,6 +204,9 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) {\n         throw std::runtime_error(strprintf(\"%s: TestBlockValidity failed: %s\", __func__, FormatStateMessage(state)));\n     }\n+    int64_t nTime2 = GetTimeMicros();\n+\n+    LogPrint(BCLog::BENCH, \"CreateNewBlock() packages: %.2fms (%d packages, %d updated descendants), validity: %.2fms (total %.2fms)\\n\", 0.001 * (nTime1 - nTimeStart), nPackagesSelected, nDescendantsUpdated, 0.001 * (nTime2 - nTime1), 0.001 * (nTime2 - nTimeStart));\n \n     return std::move(pblocktemplate);\n }\n@@ -282,16 +280,18 @@ void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n     }\n }\n \n-void BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& alreadyAdded,\n+int BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& alreadyAdded,\n         indexed_modified_transaction_set &mapModifiedTx)\n {\n+    int nDescendantsUpdated = 0;\n     BOOST_FOREACH(const CTxMemPool::txiter it, alreadyAdded) {\n         CTxMemPool::setEntries descendants;\n         mempool.CalculateDescendants(it, descendants);\n         // Insert all descendants (not yet in block) into the modified set\n         BOOST_FOREACH(CTxMemPool::txiter desc, descendants) {\n             if (alreadyAdded.count(desc))\n                 continue;\n+            ++nDescendantsUpdated;\n             modtxiter mit = mapModifiedTx.find(desc);\n             if (mit == mapModifiedTx.end()) {\n                 CTxMemPoolModifiedEntry modEntry(desc);\n@@ -304,6 +304,7 @@ void BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& alread\n             }\n         }\n     }\n+    return nDescendantsUpdated;\n }\n \n // Skip entries in mapTx that are already in a block or are present\n@@ -318,9 +319,7 @@ void BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& alread\n bool BlockAssembler::SkipMapTxEntry(CTxMemPool::txiter it, indexed_modified_transaction_set &mapModifiedTx, CTxMemPool::setEntries &failedTx)\n {\n     assert (it != mempool.mapTx.end());\n-    if (mapModifiedTx.count(it) || inBlock.count(it) || failedTx.count(it))\n-        return true;\n-    return false;\n+    return mapModifiedTx.count(it) || inBlock.count(it) || failedTx.count(it);\n }\n \n void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, CTxMemPool::txiter entry, std::vector<CTxMemPool::txiter>& sortedEntries)\n@@ -344,7 +343,7 @@ void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, CTxMemP\n // Each time through the loop, we compare the best transaction in\n // mapModifiedTxs with the next transaction in the mempool to decide what\n // transaction package to work on next.\n-void BlockAssembler::addPackageTxs()\n+void BlockAssembler::addPackageTxs(int &nPackagesSelected, int &nDescendantsUpdated)\n {\n     // mapModifiedTx will store sorted packages after they are modified\n     // because some of their txs are already in the block\n@@ -358,6 +357,13 @@ void BlockAssembler::addPackageTxs()\n \n     CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n     CTxMemPool::txiter iter;\n+\n+    // Limit the number of attempts to add transactions to the block when it is\n+    // close to full; this is just a simple heuristic to finish quickly if the\n+    // mempool has a lot of entries.\n+    const int64_t MAX_CONSECUTIVE_FAILURES = 1000;\n+    int64_t nConsecutiveFailed = 0;\n+\n     while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty())\n     {\n         // First try to find a new transaction in mapTx to evaluate.\n@@ -419,6 +425,14 @@ void BlockAssembler::addPackageTxs()\n                 mapModifiedTx.get<ancestor_score>().erase(modit);\n                 failedTx.insert(iter);\n             }\n+\n+            ++nConsecutiveFailed;\n+\n+            if (nConsecutiveFailed > MAX_CONSECUTIVE_FAILURES && nBlockWeight >\n+                    nBlockMaxWeight - 4000) {\n+                // Give up if we're close to full and haven't succeeded in a while\n+                break;\n+            }\n             continue;\n         }\n \n@@ -439,6 +453,9 @@ void BlockAssembler::addPackageTxs()\n             continue;\n         }\n \n+        // This transaction will make it in; reset the failed counter.\n+        nConsecutiveFailed = 0;\n+\n         // Package can be added. Sort the entries in a valid order.\n         std::vector<CTxMemPool::txiter> sortedEntries;\n         SortForBlock(ancestors, iter, sortedEntries);\n@@ -449,8 +466,10 @@ void BlockAssembler::addPackageTxs()\n             mapModifiedTx.erase(sortedEntries[i]);\n         }\n \n+        ++nPackagesSelected;\n+\n         // Update transactions that depend on each of these\n-        UpdatePackagesForAdded(ancestors, mapModifiedTx);\n+        nDescendantsUpdated += UpdatePackagesForAdded(ancestors, mapModifiedTx);\n     }\n }\n "
      },
      {
        "sha": "1f3c9d652f175a4e3a7109438b530499871e40ba",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 7,
        "deletions": 4,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -180,8 +180,10 @@ class BlockAssembler\n     void AddToBlock(CTxMemPool::txiter iter);\n \n     // Methods for how to add transactions to a block.\n-    /** Add transactions based on feerate including unconfirmed ancestors */\n-    void addPackageTxs();\n+    /** Add transactions based on feerate including unconfirmed ancestors\n+      * Increments nPackagesSelected / nDescendantsUpdated with corresponding\n+      * statistics from the package selection (for logging statistics). */\n+    void addPackageTxs(int &nPackagesSelected, int &nDescendantsUpdated);\n \n     // helper functions for addPackageTxs()\n     /** Remove confirmed (inBlock) entries from given set */\n@@ -199,8 +201,9 @@ class BlockAssembler\n     /** Sort the package in an order that is valid to appear in a block */\n     void SortForBlock(const CTxMemPool::setEntries& package, CTxMemPool::txiter entry, std::vector<CTxMemPool::txiter>& sortedEntries);\n     /** Add descendants of given transactions to mapModifiedTx with ancestor\n-      * state updated assuming given transactions are inBlock. */\n-    void UpdatePackagesForAdded(const CTxMemPool::setEntries& alreadyAdded, indexed_modified_transaction_set &mapModifiedTx);\n+      * state updated assuming given transactions are inBlock. Returns number\n+      * of updated descendants. */\n+    int UpdatePackagesForAdded(const CTxMemPool::setEntries& alreadyAdded, indexed_modified_transaction_set &mapModifiedTx);\n };\n \n /** Modify the extranonce in a block */"
      },
      {
        "sha": "14ac5618eb87d4d7a70919323cb83ca0c2811e24",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 143,
        "deletions": 99,
        "changes": 242,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -148,7 +148,7 @@ static std::vector<CAddress> convertSeed6(const std::vector<SeedSpec6> &vSeedsIn\n // one by discovery.\n CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices)\n {\n-    CAddress ret(CService(CNetAddr(),GetListenPort()), NODE_NONE);\n+    CAddress ret(CService(CNetAddr(),GetListenPort()), nLocalServices);\n     CService addr;\n     if (GetLocal(addr, paddrPeer))\n     {\n@@ -190,7 +190,7 @@ void AdvertiseLocal(CNode *pnode)\n         }\n         if (addrLocal.IsRoutable())\n         {\n-            LogPrint(\"net\", \"AdvertiseLocal: advertising address %s\\n\", addrLocal.ToString());\n+            LogPrint(BCLog::NET, \"AdvertiseLocal: advertising address %s\\n\", addrLocal.ToString());\n             FastRandomContext insecure_rand;\n             pnode->PushAddress(addrLocal, insecure_rand);\n         }\n@@ -340,6 +340,22 @@ bool CConnman::CheckIncomingNonce(uint64_t nonce)\n     return true;\n }\n \n+/** Get the bind address for a socket as CAddress */\n+static CAddress GetBindAddress(SOCKET sock)\n+{\n+    CAddress addr_bind;\n+    struct sockaddr_storage sockaddr_bind;\n+    socklen_t sockaddr_bind_len = sizeof(sockaddr_bind);\n+    if (sock != INVALID_SOCKET) {\n+        if (!getsockname(sock, (struct sockaddr*)&sockaddr_bind, &sockaddr_bind_len)) {\n+            addr_bind.SetSockAddr((const struct sockaddr*)&sockaddr_bind);\n+        } else {\n+            LogPrint(BCLog::NET, \"Warning: getsockname failed\\n\");\n+        }\n+    }\n+    return addr_bind;\n+}\n+\n CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCountFailure)\n {\n     if (pszDest == NULL) {\n@@ -356,7 +372,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n     }\n \n     /// debug print\n-    LogPrint(\"net\", \"trying connection %s lastseen=%.1fhrs\\n\",\n+    LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n@@ -393,7 +409,8 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n         // Add node\n         NodeId id = GetNewNodeId();\n         uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n-        CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, pszDest ? pszDest : \"\", false);\n+        CAddress addr_bind = GetBindAddress(hSocket);\n+        CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addrConnect, CalculateKeyedNetGroup(addrConnect), nonce, addr_bind, pszDest ? pszDest : \"\", false);\n         pnode->nServicesExpected = ServiceFlags(addrConnect.nServices & nRelevantServices);\n         pnode->AddRef();\n \n@@ -418,12 +435,12 @@ void CConnman::DumpBanlist()\n \n     CBanDB bandb;\n     banmap_t banmap;\n-    SetBannedSetDirty(false);\n     GetBanned(banmap);\n-    if (!bandb.Write(banmap))\n-        SetBannedSetDirty(true);\n+    if (bandb.Write(banmap)) {\n+        SetBannedSetDirty(false);\n+    }\n \n-    LogPrint(\"net\", \"Flushed %d banned node ips/subnets to banlist.dat  %dms\\n\",\n+    LogPrint(BCLog::NET, \"Flushed %d banned node ips/subnets to banlist.dat  %dms\\n\",\n         banmap.size(), GetTimeMillis() - nStart);\n }\n \n@@ -433,7 +450,7 @@ void CNode::CloseSocketDisconnect()\n     LOCK(cs_hSocket);\n     if (hSocket != INVALID_SOCKET)\n     {\n-        LogPrint(\"net\", \"disconnecting peer=%d\\n\", id);\n+        LogPrint(BCLog::NET, \"disconnecting peer=%d\\n\", id);\n         CloseSocket(hSocket);\n     }\n }\n@@ -541,6 +558,8 @@ bool CConnman::Unban(const CSubNet &subNet) {\n void CConnman::GetBanned(banmap_t &banMap)\n {\n     LOCK(cs_setBanned);\n+    // Sweep the banlist so expired bans are not returned\n+    SweepBanned();\n     banMap = setBanned; //create a thread safe copy\n }\n \n@@ -565,7 +584,7 @@ void CConnman::SweepBanned()\n         {\n             setBanned.erase(it++);\n             setBannedIsDirty = true;\n-            LogPrint(\"net\", \"%s: Removed banned node ip/subnet from banlist.dat: %s\\n\", __func__, subNet.ToString());\n+            LogPrint(BCLog::NET, \"%s: Removed banned node ip/subnet from banlist.dat: %s\\n\", __func__, subNet.ToString());\n         }\n         else\n             ++it;\n@@ -633,6 +652,7 @@ void CNode::copyStats(CNodeStats &stats)\n     stats.nodeid = this->GetId();\n     X(nServices);\n     X(addr);\n+    X(addrBind);\n     {\n         LOCK(cs_filter);\n         X(fRelayTxes);\n@@ -708,10 +728,10 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete\n             handled = msg.readData(pch, nBytes);\n \n         if (handled < 0)\n-                return false;\n+            return false;\n \n         if (msg.in_data && msg.hdr.nMessageSize > MAX_PROTOCOL_MESSAGE_LENGTH) {\n-            LogPrint(\"net\", \"Oversized message from peer=%i, disconnecting\\n\", GetId());\n+            LogPrint(BCLog::NET, \"Oversized message from peer=%i, disconnecting\\n\", GetId());\n             return false;\n         }\n \n@@ -786,7 +806,7 @@ int CNetMessage::readHeader(const char *pch, unsigned int nBytes)\n \n     // reject messages larger than MAX_SIZE\n     if (hdr.nMessageSize > MAX_SIZE)\n-            return -1;\n+        return -1;\n \n     // switch state to reading message data\n     in_data = true;\n@@ -946,7 +966,7 @@ bool CConnman::AttemptToEvictConnection()\n                 continue;\n             if (node->fDisconnect)\n                 continue;\n-            NodeEvictionCandidate candidate = {node->id, node->nTimeConnected, node->nMinPingUsecTime,\n+            NodeEvictionCandidate candidate = {node->GetId(), node->nTimeConnected, node->nMinPingUsecTime,\n                                                node->nLastBlockTime, node->nLastTXTime,\n                                                (node->nServices & nRelevantServices) == nRelevantServices,\n                                                node->fRelayTxes, node->pfilter != NULL, node->addr, node->nKeyedNetGroup};\n@@ -1034,9 +1054,11 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     int nInbound = 0;\n     int nMaxInbound = nMaxConnections - (nMaxOutbound + nMaxFeeler);\n \n-    if (hSocket != INVALID_SOCKET)\n-        if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr))\n+    if (hSocket != INVALID_SOCKET) {\n+        if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr)) {\n             LogPrintf(\"Warning: Unknown socket family\\n\");\n+        }\n+    }\n \n     bool whitelisted = hListenSocket.whitelisted || IsWhitelistedRange(addr);\n     {\n@@ -1069,12 +1091,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n \n     // According to the internet TCP_NODELAY is not carried into accepted sockets\n     // on all platforms.  Set it again here just to be sure.\n-    int set = 1;\n-#ifdef WIN32\n-    setsockopt(hSocket, IPPROTO_TCP, TCP_NODELAY, (const char*)&set, sizeof(int));\n-#else\n-    setsockopt(hSocket, IPPROTO_TCP, TCP_NODELAY, (void*)&set, sizeof(int));\n-#endif\n+    SetSocketNoDelay(hSocket);\n \n     if (IsBanned(addr) && !whitelisted)\n     {\n@@ -1087,21 +1104,22 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     {\n         if (!AttemptToEvictConnection()) {\n             // No connection to evict, disconnect the new connection\n-            LogPrint(\"net\", \"failed to find an eviction candidate - connection dropped (full)\\n\");\n+            LogPrint(BCLog::NET, \"failed to find an eviction candidate - connection dropped (full)\\n\");\n             CloseSocket(hSocket);\n             return;\n         }\n     }\n \n     NodeId id = GetNewNodeId();\n     uint64_t nonce = GetDeterministicRandomizer(RANDOMIZER_ID_LOCALHOSTNONCE).Write(id).Finalize();\n+    CAddress addr_bind = GetBindAddress(hSocket);\n \n-    CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addr, CalculateKeyedNetGroup(addr), nonce, \"\", true);\n+    CNode* pnode = new CNode(id, nLocalServices, GetBestHeight(), hSocket, addr, CalculateKeyedNetGroup(addr), nonce, addr_bind, \"\", true);\n     pnode->AddRef();\n     pnode->fWhitelisted = whitelisted;\n     GetNodeSignals().InitializeNode(pnode, *this);\n \n-    LogPrint(\"net\", \"connection from %s accepted\\n\", addr.ToString());\n+    LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToString());\n \n     {\n         LOCK(cs_vNodes);\n@@ -1299,58 +1317,55 @@ void CConnman::ThreadSocketHandler()\n             }\n             if (recvSet || errorSet)\n             {\n+                // typical socket buffer is 8K-64K\n+                char pchBuf[0x10000];\n+                int nBytes = 0;\n                 {\n-                    {\n-                        // typical socket buffer is 8K-64K\n-                        char pchBuf[0x10000];\n-                        int nBytes = 0;\n-                        {\n-                            LOCK(pnode->cs_hSocket);\n-                            if (pnode->hSocket == INVALID_SOCKET)\n-                                continue;\n-                            nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n-                        }\n-                        if (nBytes > 0)\n-                        {\n-                            bool notify = false;\n-                            if (!pnode->ReceiveMsgBytes(pchBuf, nBytes, notify))\n-                                pnode->CloseSocketDisconnect();\n-                            RecordBytesRecv(nBytes);\n-                            if (notify) {\n-                                size_t nSizeAdded = 0;\n-                                auto it(pnode->vRecvMsg.begin());\n-                                for (; it != pnode->vRecvMsg.end(); ++it) {\n-                                    if (!it->complete())\n-                                        break;\n-                                    nSizeAdded += it->vRecv.size() + CMessageHeader::HEADER_SIZE;\n-                                }\n-                                {\n-                                    LOCK(pnode->cs_vProcessMsg);\n-                                    pnode->vProcessMsg.splice(pnode->vProcessMsg.end(), pnode->vRecvMsg, pnode->vRecvMsg.begin(), it);\n-                                    pnode->nProcessQueueSize += nSizeAdded;\n-                                    pnode->fPauseRecv = pnode->nProcessQueueSize > nReceiveFloodSize;\n-                                }\n-                                WakeMessageHandler();\n-                            }\n-                        }\n-                        else if (nBytes == 0)\n-                        {\n-                            // socket closed gracefully\n-                            if (!pnode->fDisconnect)\n-                                LogPrint(\"net\", \"socket closed\\n\");\n-                            pnode->CloseSocketDisconnect();\n+                    LOCK(pnode->cs_hSocket);\n+                    if (pnode->hSocket == INVALID_SOCKET)\n+                        continue;\n+                    nBytes = recv(pnode->hSocket, pchBuf, sizeof(pchBuf), MSG_DONTWAIT);\n+                }\n+                if (nBytes > 0)\n+                {\n+                    bool notify = false;\n+                    if (!pnode->ReceiveMsgBytes(pchBuf, nBytes, notify))\n+                        pnode->CloseSocketDisconnect();\n+                    RecordBytesRecv(nBytes);\n+                    if (notify) {\n+                        size_t nSizeAdded = 0;\n+                        auto it(pnode->vRecvMsg.begin());\n+                        for (; it != pnode->vRecvMsg.end(); ++it) {\n+                            if (!it->complete())\n+                                break;\n+                            nSizeAdded += it->vRecv.size() + CMessageHeader::HEADER_SIZE;\n                         }\n-                        else if (nBytes < 0)\n                         {\n-                            // error\n-                            int nErr = WSAGetLastError();\n-                            if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n-                            {\n-                                if (!pnode->fDisconnect)\n-                                    LogPrintf(\"socket recv error %s\\n\", NetworkErrorString(nErr));\n-                                pnode->CloseSocketDisconnect();\n-                            }\n+                            LOCK(pnode->cs_vProcessMsg);\n+                            pnode->vProcessMsg.splice(pnode->vProcessMsg.end(), pnode->vRecvMsg, pnode->vRecvMsg.begin(), it);\n+                            pnode->nProcessQueueSize += nSizeAdded;\n+                            pnode->fPauseRecv = pnode->nProcessQueueSize > nReceiveFloodSize;\n                         }\n+                        WakeMessageHandler();\n+                    }\n+                }\n+                else if (nBytes == 0)\n+                {\n+                    // socket closed gracefully\n+                    if (!pnode->fDisconnect) {\n+                        LogPrint(BCLog::NET, \"socket closed\\n\");\n+                    }\n+                    pnode->CloseSocketDisconnect();\n+                }\n+                else if (nBytes < 0)\n+                {\n+                    // error\n+                    int nErr = WSAGetLastError();\n+                    if (nErr != WSAEWOULDBLOCK && nErr != WSAEMSGSIZE && nErr != WSAEINTR && nErr != WSAEINPROGRESS)\n+                    {\n+                        if (!pnode->fDisconnect)\n+                            LogPrintf(\"socket recv error %s\\n\", NetworkErrorString(nErr));\n+                        pnode->CloseSocketDisconnect();\n                     }\n                 }\n             }\n@@ -1375,7 +1390,7 @@ void CConnman::ThreadSocketHandler()\n             {\n                 if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n                 {\n-                    LogPrint(\"net\", \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->id);\n+                    LogPrint(BCLog::NET, \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->GetId());\n                     pnode->fDisconnect = true;\n                 }\n                 else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL)\n@@ -1395,7 +1410,7 @@ void CConnman::ThreadSocketHandler()\n                 }\n                 else if (!pnode->fSuccessfullyConnected)\n                 {\n-                    LogPrintf(\"version handshake timeout from %d\\n\", pnode->id);\n+                    LogPrintf(\"version handshake timeout from %d\\n\", pnode->GetId());\n                     pnode->fDisconnect = true;\n                 }\n             }\n@@ -1584,6 +1599,9 @@ void CConnman::ThreadDNSAddressSeed()\n     LogPrintf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n \n     BOOST_FOREACH(const CDNSSeedData &seed, vSeeds) {\n+        if (interruptNet) {\n+            return;\n+        }\n         if (HaveNameProxy()) {\n             AddOneShot(seed.host);\n         } else {\n@@ -1601,6 +1619,9 @@ void CConnman::ThreadDNSAddressSeed()\n                     found++;\n                 }\n             }\n+            if (interruptNet) {\n+                return;\n+            }\n             // TODO: The seed name resolve may fail, yielding an IP of [::], which results in\n             // addrman assigning the same source to results from different seeds.\n             // This should switch to a hard-coded stable dummy IP for each seed name, so that the\n@@ -1634,7 +1655,7 @@ void CConnman::DumpAddresses()\n     CAddrDB adb;\n     adb.Write(addrman);\n \n-    LogPrint(\"net\", \"Flushed %d addresses to peers.dat  %dms\\n\",\n+    LogPrint(BCLog::NET, \"Flushed %d addresses to peers.dat  %dms\\n\",\n            addrman.size(), GetTimeMillis() - nStart);\n }\n \n@@ -1665,12 +1686,12 @@ void CConnman::ProcessOneShot()\n void CConnman::ThreadOpenConnections()\n {\n     // Connect to specific addresses\n-    if (mapMultiArgs.count(\"-connect\") && mapMultiArgs.at(\"-connect\").size() > 0)\n+    if (gArgs.IsArgSet(\"-connect\") && gArgs.GetArgs(\"-connect\").size() > 0)\n     {\n         for (int64_t nLoop = 0;; nLoop++)\n         {\n             ProcessOneShot();\n-            BOOST_FOREACH(const std::string& strAddr, mapMultiArgs.at(\"-connect\"))\n+            BOOST_FOREACH(const std::string& strAddr, gArgs.GetArgs(\"-connect\"))\n             {\n                 CAddress addr(CService(), NODE_NONE);\n                 OpenNetworkConnection(addr, false, NULL, strAddr.c_str());\n@@ -1721,11 +1742,17 @@ void CConnman::ThreadOpenConnections()\n         // Only connect out to one peer per network group (/16 for IPv4).\n         // Do this here so we don't have to critsect vNodes inside mapAddresses critsect.\n         int nOutbound = 0;\n+        int nOutboundRelevant = 0;\n         std::set<std::vector<unsigned char> > setConnected;\n         {\n             LOCK(cs_vNodes);\n             BOOST_FOREACH(CNode* pnode, vNodes) {\n                 if (!pnode->fInbound && !pnode->fAddnode) {\n+\n+                    // Count the peers that have all relevant services\n+                    if (pnode->fSuccessfullyConnected && !pnode->fFeeler && ((pnode->nServices & nRelevantServices) == nRelevantServices)) {\n+                        nOutboundRelevant++;\n+                    }\n                     // Netgroups for inbound and addnode peers are not excluded because our goal here\n                     // is to not use multiple of our limited outbound slots on a single netgroup\n                     // but inbound and addnode peers do not use our outbound slots.  Inbound peers\n@@ -1743,9 +1770,9 @@ void CConnman::ThreadOpenConnections()\n         //  * Increase the number of connectable addresses in the tried table.\n         //\n         // Method:\n-        //  * Choose a random address from new and attempt to connect to it if we can connect \n+        //  * Choose a random address from new and attempt to connect to it if we can connect\n         //    successfully it is added to tried.\n-        //  * Start attempting feeler connections only after node finishes making outbound \n+        //  * Start attempting feeler connections only after node finishes making outbound\n         //    connections.\n         //  * Only make a feeler connection once every few minutes.\n         //\n@@ -1789,14 +1816,27 @@ void CConnman::ThreadOpenConnections()\n                 continue;\n \n             // only consider nodes missing relevant services after 40 failed attempts and only if less than half the outbound are up.\n-            if ((addr.nServices & nRelevantServices) != nRelevantServices && (nTries < 40 || nOutbound >= (nMaxOutbound >> 1)))\n+            ServiceFlags nRequiredServices = nRelevantServices;\n+            if (nTries >= 40 && nOutbound < (nMaxOutbound >> 1)) {\n+                nRequiredServices = REQUIRED_SERVICES;\n+            }\n+\n+            if ((addr.nServices & nRequiredServices) != nRequiredServices) {\n                 continue;\n+            }\n \n             // do not allow non-default ports, unless after 50 invalid addresses selected already\n             if (addr.GetPort() != Params().GetDefaultPort() && nTries < 50)\n                 continue;\n \n             addrConnect = addr;\n+\n+            // regardless of the services assumed to be available, only require the minimum if half or more outbound have relevant services\n+            if (nOutboundRelevant >= (nMaxOutbound >> 1)) {\n+                addrConnect.nServices = REQUIRED_SERVICES;\n+            } else {\n+                addrConnect.nServices = nRequiredServices;\n+            }\n             break;\n         }\n \n@@ -1807,7 +1847,7 @@ void CConnman::ThreadOpenConnections()\n                 int randsleep = GetRandInt(FEELER_SLEEP_WINDOW * 1000);\n                 if (!interruptNet.sleep_for(std::chrono::milliseconds(randsleep)))\n                     return;\n-                LogPrint(\"net\", \"Making feeler connection to %s\\n\", addrConnect.ToString());\n+                LogPrint(BCLog::NET, \"Making feeler connection to %s\\n\", addrConnect.ToString());\n             }\n \n             OpenNetworkConnection(addrConnect, (int)setConnected.size() >= std::min(nMaxConnections - 1, 2), &grant, NULL, false, fFeeler);\n@@ -1872,8 +1912,8 @@ void CConnman::ThreadOpenAddedConnections()\n {\n     {\n         LOCK(cs_vAddedNodes);\n-        if (mapMultiArgs.count(\"-addnode\"))\n-            vAddedNodes = mapMultiArgs.at(\"-addnode\");\n+        if (gArgs.IsArgSet(\"-addnode\"))\n+            vAddedNodes = gArgs.GetArgs(\"-addnode\");\n     }\n \n     while (true)\n@@ -2150,9 +2190,7 @@ void Discover(boost::thread_group& threadGroup)\n \n void CConnman::SetNetworkActive(bool active)\n {\n-    if (fDebug) {\n-        LogPrint(\"net\", \"SetNetworkActive: %s\\n\", active);\n-    }\n+    LogPrint(BCLog::NET, \"SetNetworkActive: %s\\n\", active);\n \n     if (!active) {\n         fNetworkActive = false;\n@@ -2214,6 +2252,10 @@ bool CConnman::Start(CScheduler& scheduler, std::string& strNodeError, Options c\n \n     SetBestHeight(connOptions.nBestHeight);\n \n+    for (const auto& strDest : connOptions.vSeedNodes) {\n+        AddOneShot(strDest);\n+    }\n+\n     clientInterface = connOptions.uiInterface;\n     if (clientInterface) {\n         clientInterface->InitMessage(_(\"Loading P2P addresses...\"));\n@@ -2241,7 +2283,7 @@ bool CConnman::Start(CScheduler& scheduler, std::string& strNodeError, Options c\n         SetBannedSetDirty(false); // no need to write down, just read data\n         SweepBanned(); // sweep out unused entries\n \n-        LogPrint(\"net\", \"Loaded %d banned node ips/subnets from banlist.dat  %dms\\n\",\n+        LogPrint(BCLog::NET, \"Loaded %d banned node ips/subnets from banlist.dat  %dms\\n\",\n             banmap.size(), GetTimeMillis() - nStart);\n     } else {\n         LogPrintf(\"Invalid or missing banlist.dat; recreating\\n\");\n@@ -2286,7 +2328,7 @@ bool CConnman::Start(CScheduler& scheduler, std::string& strNodeError, Options c\n     threadOpenAddedConnections = std::thread(&TraceThread<std::function<void()> >, \"addcon\", std::function<void()>(std::bind(&CConnman::ThreadOpenAddedConnections, this)));\n \n     // Initiate outbound connections unless connect=0\n-    if (!mapMultiArgs.count(\"-connect\") || mapMultiArgs.at(\"-connect\").size() != 1 || mapMultiArgs.at(\"-connect\")[0] != \"0\")\n+    if (!gArgs.IsArgSet(\"-connect\") || gArgs.GetArgs(\"-connect\").size() != 1 || gArgs.GetArgs(\"-connect\")[0] != \"0\")\n         threadOpenConnections = std::thread(&TraceThread<std::function<void()> >, \"opencon\", std::function<void()>(std::bind(&CConnman::ThreadOpenConnections, this)));\n \n     // Process messages\n@@ -2484,7 +2526,7 @@ bool CConnman::DisconnectNode(NodeId id)\n {\n     LOCK(cs_vNodes);\n     for(CNode* pnode : vNodes) {\n-        if (id == pnode->id) {\n+        if (id == pnode->GetId()) {\n             pnode->fDisconnect = true;\n             return true;\n         }\n@@ -2618,14 +2660,15 @@ int CConnman::GetBestHeight() const\n unsigned int CConnman::GetReceiveFloodSize() const { return nReceiveFloodSize; }\n unsigned int CConnman::GetSendBufferSize() const{ return nSendBufferMaxSize; }\n \n-CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const std::string& addrNameIn, bool fInboundIn) :\n+CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress& addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress &addrBindIn, const std::string& addrNameIn, bool fInboundIn) :\n     nTimeConnected(GetSystemTimeInSeconds()),\n     addr(addrIn),\n+    addrBind(addrBindIn),\n     fInbound(fInboundIn),\n-    id(idIn),\n     nKeyedNetGroup(nKeyedNetGroupIn),\n     addrKnown(5000, 0.001),\n     filterInventoryKnown(50000, 0.000001),\n+    id(idIn),\n     nLocalHostNonce(nLocalHostNonceIn),\n     nLocalServices(nLocalServicesIn),\n     nMyStartingHeight(nMyStartingHeightIn),\n@@ -2683,10 +2726,11 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n         mapRecvBytesPerMsgCmd[msg] = 0;\n     mapRecvBytesPerMsgCmd[NET_MESSAGE_COMMAND_OTHER] = 0;\n \n-    if (fLogIPs)\n-        LogPrint(\"net\", \"Added connection to %s peer=%d\\n\", addrName, id);\n-    else\n-        LogPrint(\"net\", \"Added connection peer=%d\\n\", id);\n+    if (fLogIPs) {\n+        LogPrint(BCLog::NET, \"Added connection to %s peer=%d\\n\", addrName, id);\n+    } else {\n+        LogPrint(BCLog::NET, \"Added connection peer=%d\\n\", id);\n+    }\n }\n \n CNode::~CNode()\n@@ -2713,7 +2757,7 @@ void CNode::AskFor(const CInv& inv)\n         nRequestTime = it->second;\n     else\n         nRequestTime = 0;\n-    LogPrint(\"net\", \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000), id);\n+    LogPrint(BCLog::NET, \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000), id);\n \n     // Make sure not to reuse time indexes to keep things in the same order\n     int64_t nNow = GetTimeMicros() - 1000000;\n@@ -2740,7 +2784,7 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n     size_t nTotalSize = nMessageSize + CMessageHeader::HEADER_SIZE;\n-    LogPrint(\"net\", \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->id);\n+    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->GetId());\n \n     std::vector<unsigned char> serializedHeader;\n     serializedHeader.reserve(CMessageHeader::HEADER_SIZE);\n@@ -2778,7 +2822,7 @@ bool CConnman::ForNode(NodeId id, std::function<bool(CNode* pnode)> func)\n     CNode* found = nullptr;\n     LOCK(cs_vNodes);\n     for (auto&& pnode : vNodes) {\n-        if(pnode->id == id) {\n+        if(pnode->GetId() == id) {\n             found = pnode;\n             break;\n         }"
      },
      {
        "sha": "b89c13a90d09cc700e9aa1ff13482097a5b9624b",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 20,
        "deletions": 13,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -14,6 +14,7 @@\n #include \"hash.h\"\n #include \"limitedmap.h\"\n #include \"netaddress.h\"\n+#include \"policy/feerate.h\"\n #include \"protocol.h\"\n #include \"random.h\"\n #include \"streams.h\"\n@@ -32,11 +33,9 @@\n #include <arpa/inet.h>\n #endif\n \n-#include <boost/filesystem/path.hpp>\n #include <boost/foreach.hpp>\n #include <boost/signals2/signal.hpp>\n \n-class CAddrMan;\n class CScheduler;\n class CNode;\n \n@@ -92,7 +91,7 @@ static const ServiceFlags REQUIRED_SERVICES = NODE_NETWORK;\n // NOTE: When adjusting this, update rpcnet:setban's help (\"24h\")\n static const unsigned int DEFAULT_MISBEHAVING_BANTIME = 60 * 60 * 24;  // Default 24-hour ban\n \n-typedef int NodeId;\n+typedef int64_t NodeId;\n \n struct AddedNodeInfo\n {\n@@ -145,6 +144,7 @@ class CConnman\n         unsigned int nReceiveFloodSize = 0;\n         uint64_t nMaxOutboundTimeframe = 0;\n         uint64_t nMaxOutboundLimit = 0;\n+        std::vector<std::string> vSeedNodes;\n     };\n     CConnman(uint64_t seed0, uint64_t seed1);\n     ~CConnman();\n@@ -234,8 +234,6 @@ class CConnman\n     void GetBanned(banmap_t &banmap);\n     void SetBanned(const banmap_t &banmap);\n \n-    void AddOneShot(const std::string& strDest);\n-\n     bool AddNode(const std::string& node);\n     bool RemoveAddedNode(const std::string& node);\n     std::vector<AddedNodeInfo> GetAddedNodeInfo();\n@@ -293,6 +291,7 @@ class CConnman\n     };\n \n     void ThreadOpenAddedConnections();\n+    void AddOneShot(const std::string& strDest);\n     void ProcessOneShot();\n     void ThreadOpenConnections();\n     void ThreadMessageHandler();\n@@ -505,8 +504,12 @@ class CNodeStats\n     double dPingTime;\n     double dPingWait;\n     double dMinPing;\n+    // Our address, as reported by the peer\n     std::string addrLocal;\n+    // Address of this peer\n     CAddress addr;\n+    // Bind address of our side of the connection\n+    CAddress addrBind;\n };\n \n \n@@ -587,7 +590,10 @@ class CNode\n     std::atomic<int64_t> nLastRecv;\n     const int64_t nTimeConnected;\n     std::atomic<int64_t> nTimeOffset;\n+    // Address of this peer\n     const CAddress addr;\n+    // Bind address of our side of the connection\n+    const CAddress addrBind;\n     std::atomic<int> nVersion;\n     // strSubVer is whatever byte array we read from the wire. However, this field is intended\n     // to be printed out, displayed to humans in various forms and so on. So we sanitize it and\n@@ -613,7 +619,6 @@ class CNode\n     CCriticalSection cs_filter;\n     CBloomFilter* pfilter;\n     std::atomic<int> nRefCount;\n-    const NodeId id;\n \n     const uint64_t nKeyedNetGroup;\n     std::atomic_bool fPauseRecv;\n@@ -678,12 +683,13 @@ class CNode\n     CAmount lastSentFeeFilter;\n     int64_t nextSendTimeFeeFilter;\n \n-    CNode(NodeId id, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress &addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const std::string &addrNameIn = \"\", bool fInboundIn = false);\n+    CNode(NodeId id, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn, SOCKET hSocketIn, const CAddress &addrIn, uint64_t nKeyedNetGroupIn, uint64_t nLocalHostNonceIn, const CAddress &addrBindIn, const std::string &addrNameIn = \"\", bool fInboundIn = false);\n     ~CNode();\n \n private:\n     CNode(const CNode&);\n     void operator=(const CNode&);\n+    const NodeId id;\n \n \n     const uint64_t nLocalHostNonce;\n@@ -696,23 +702,24 @@ class CNode\n     mutable CCriticalSection cs_addrName;\n     std::string addrName;\n \n+    // Our address, as reported by the peer\n     CService addrLocal;\n     mutable CCriticalSection cs_addrLocal;\n public:\n \n     NodeId GetId() const {\n-      return id;\n+        return id;\n     }\n \n     uint64_t GetLocalNonce() const {\n-      return nLocalHostNonce;\n+        return nLocalHostNonce;\n     }\n \n     int GetMyStartingHeight() const {\n-      return nMyStartingHeight;\n+        return nMyStartingHeight;\n     }\n \n-    int GetRefCount()\n+    int GetRefCount() const\n     {\n         assert(nRefCount >= 0);\n         return nRefCount;\n@@ -724,7 +731,7 @@ class CNode\n     {\n         nRecvVersion = nVersionIn;\n     }\n-    int GetRecvVersion()\n+    int GetRecvVersion() const\n     {\n         return nRecvVersion;\n     }\n@@ -760,7 +767,7 @@ class CNode\n         // after addresses were pushed.\n         if (_addr.IsValid() && !addrKnown.contains(_addr.GetKey())) {\n             if (vAddrToSend.size() >= MAX_ADDR_TO_SEND) {\n-                vAddrToSend[insecure_rand.rand32() % vAddrToSend.size()] = _addr;\n+                vAddrToSend[insecure_rand.randrange(vAddrToSend.size())] = _addr;\n             } else {\n                 vAddrToSend.push_back(_addr);\n             }"
      },
      {
        "sha": "4ca02c281d6dd20c192657cac618d9c40f4fe4c2",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 282,
        "deletions": 230,
        "changes": 512,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -168,6 +168,8 @@ struct CNodeState {\n     int nUnconnectingHeaders;\n     //! Whether we've started headers synchronization with this peer.\n     bool fSyncStarted;\n+    //! When to potentially disconnect peer for stalling headers download\n+    int64_t nHeadersSyncTimeout;\n     //! Since when we're stalling block download progress (in microseconds), or 0.\n     int64_t nStallingSince;\n     std::list<QueuedBlock> vBlocksInFlight;\n@@ -207,6 +209,7 @@ struct CNodeState {\n         pindexBestHeaderSent = NULL;\n         nUnconnectingHeaders = 0;\n         fSyncStarted = false;\n+        nHeadersSyncTimeout = 0;\n         nStallingSince = 0;\n         nDownloadingSince = 0;\n         nBlocksInFlight = 0;\n@@ -256,10 +259,11 @@ void PushNodeVersion(CNode *pnode, CConnman& connman, int64_t nTime)\n     connman.PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n             nonce, strSubVersion, nNodeStartingHeight, ::fRelayTxes));\n \n-    if (fLogIPs)\n-        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), addrYou.ToString(), nodeid);\n-    else\n-        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), nodeid);\n+    if (fLogIPs) {\n+        LogPrint(BCLog::NET, \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), addrYou.ToString(), nodeid);\n+    } else {\n+        LogPrint(BCLog::NET, \"send version message: version %d, blocks=%d, us=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), nodeid);\n+    }\n }\n \n void InitializeNode(CNode *pnode, CConnman& connman) {\n@@ -302,6 +306,7 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n         assert(nPreferredDownload == 0);\n         assert(nPeersWithValidatedDownloads == 0);\n     }\n+    LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n }\n \n // Requires cs_main.\n@@ -332,7 +337,7 @@ bool MarkBlockAsReceived(const uint256& hash) {\n // Requires cs_main.\n // returns false, still setting pit, if the block was already in flight from the same peer\n // pit will only be valid as long as the same cs_main lock is being held\n-bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const Consensus::Params& consensusParams, const CBlockIndex* pindex = NULL, std::list<QueuedBlock>::iterator** pit = NULL) {\n+bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex* pindex = NULL, std::list<QueuedBlock>::iterator** pit = NULL) {\n     CNodeState *state = State(nodeid);\n     assert(state != NULL);\n \n@@ -479,7 +484,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n     // Make sure pindexBestKnownBlock is up to date, we'll need it.\n     ProcessBlockAvailability(nodeid);\n \n-    if (state->pindexBestKnownBlock == NULL || state->pindexBestKnownBlock->nChainWork < chainActive.Tip()->nChainWork) {\n+    if (state->pindexBestKnownBlock == NULL || state->pindexBestKnownBlock->nChainWork < chainActive.Tip()->nChainWork || state->pindexBestKnownBlock->nChainWork < UintToArith256(consensusParams.nMinimumChainWork)) {\n         // This peer has nothing interesting.\n         return;\n     }\n@@ -619,7 +624,7 @@ bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRE\n     unsigned int sz = GetTransactionWeight(*tx);\n     if (sz >= MAX_STANDARD_TX_WEIGHT)\n     {\n-        LogPrint(\"mempool\", \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString());\n+        LogPrint(BCLog::MEMPOOL, \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString());\n         return false;\n     }\n \n@@ -631,7 +636,7 @@ bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRE\n \n     AddToCompactExtraTransactions(tx);\n \n-    LogPrint(\"mempool\", \"stored orphan tx %s (mapsz %u outsz %u)\\n\", hash.ToString(),\n+    LogPrint(BCLog::MEMPOOL, \"stored orphan tx %s (mapsz %u outsz %u)\\n\", hash.ToString(),\n              mapOrphanTransactions.size(), mapOrphanTransactionsByPrev.size());\n     return true;\n }\n@@ -666,7 +671,7 @@ void EraseOrphansFor(NodeId peer)\n             nErased += EraseOrphanTx(maybeErase->second.tx->GetHash());\n         }\n     }\n-    if (nErased > 0) LogPrint(\"mempool\", \"Erased %d orphan tx from peer=%d\\n\", nErased, peer);\n+    if (nErased > 0) LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx from peer=%d\\n\", nErased, peer);\n }\n \n \n@@ -691,7 +696,7 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRE\n         }\n         // Sweep again 5 minutes after the next entry that expires in order to batch the linear scan.\n         nNextSweep = nMinExpTime + ORPHAN_TX_EXPIRE_INTERVAL;\n-        if (nErased > 0) LogPrint(\"mempool\", \"Erased %d orphan tx due to expiration\\n\", nErased);\n+        if (nErased > 0) LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx due to expiration\\n\", nErased);\n     }\n     while (mapOrphanTransactions.size() > nMaxOrphans)\n     {\n@@ -743,21 +748,23 @@ PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn) : connman(connmanI\n     recentRejects.reset(new CRollingBloomFilter(120000, 0.000001));\n }\n \n-void PeerLogicValidation::SyncTransaction(const CTransaction& tx, const CBlockIndex* pindex, int nPosInBlock) {\n-    if (nPosInBlock == CMainSignals::SYNC_TRANSACTION_NOT_IN_BLOCK)\n-        return;\n-\n+void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindex, const std::vector<CTransactionRef>& vtxConflicted) {\n     LOCK(cs_main);\n \n     std::vector<uint256> vOrphanErase;\n-    // Which orphan pool entries must we evict?\n-    for (size_t j = 0; j < tx.vin.size(); j++) {\n-        auto itByPrev = mapOrphanTransactionsByPrev.find(tx.vin[j].prevout);\n-        if (itByPrev == mapOrphanTransactionsByPrev.end()) continue;\n-        for (auto mi = itByPrev->second.begin(); mi != itByPrev->second.end(); ++mi) {\n-            const CTransaction& orphanTx = *(*mi)->second.tx;\n-            const uint256& orphanHash = orphanTx.GetHash();\n-            vOrphanErase.push_back(orphanHash);\n+\n+    for (const CTransactionRef& ptx : pblock->vtx) {\n+        const CTransaction& tx = *ptx;\n+\n+        // Which orphan pool entries must we evict?\n+        for (const auto& txin : tx.vin) {\n+            auto itByPrev = mapOrphanTransactionsByPrev.find(txin.prevout);\n+            if (itByPrev == mapOrphanTransactionsByPrev.end()) continue;\n+            for (auto mi = itByPrev->second.begin(); mi != itByPrev->second.end(); ++mi) {\n+                const CTransaction& orphanTx = *(*mi)->second.tx;\n+                const uint256& orphanHash = orphanTx.GetHash();\n+                vOrphanErase.push_back(orphanHash);\n+            }\n         }\n     }\n \n@@ -767,14 +774,16 @@ void PeerLogicValidation::SyncTransaction(const CTransaction& tx, const CBlockIn\n         BOOST_FOREACH(uint256 &orphanHash, vOrphanErase) {\n             nErased += EraseOrphanTx(orphanHash);\n         }\n-        LogPrint(\"mempool\", \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n+        LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n \n+// All of the following cache a recent block, and are protected by cs_most_recent_block\n static CCriticalSection cs_most_recent_block;\n static std::shared_ptr<const CBlock> most_recent_block;\n static std::shared_ptr<const CBlockHeaderAndShortTxIDs> most_recent_compact_block;\n static uint256 most_recent_block_hash;\n+static bool fWitnessesPresentInMostRecentCompactBlock;\n \n void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) {\n     std::shared_ptr<const CBlockHeaderAndShortTxIDs> pcmpctblock = std::make_shared<const CBlockHeaderAndShortTxIDs> (*pblock, true);\n@@ -795,6 +804,7 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n         most_recent_block_hash = hashBlock;\n         most_recent_block = pblock;\n         most_recent_compact_block = pcmpctblock;\n+        fWitnessesPresentInMostRecentCompactBlock = fWitnessEnabled;\n     }\n \n     connman->ForEachNode([this, &pcmpctblock, pindex, &msgMaker, fWitnessEnabled, &hashBlock](CNode* pnode) {\n@@ -808,8 +818,8 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n         if (state.fPreferHeaderAndIDs && (!fWitnessEnabled || state.fWantsCmpctWitness) &&\n                 !PeerHasHeader(&state, pindex) && PeerHasHeader(&state, pindex->pprev)) {\n \n-            LogPrint(\"net\", \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerLogicValidation::NewPoWValidBlock\",\n-                    hashBlock.ToString(), pnode->id);\n+            LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerLogicValidation::NewPoWValidBlock\",\n+                    hashBlock.ToString(), pnode->GetId());\n             connman->PushMessage(pnode, msgMaker.Make(NetMsgType::CMPCTBLOCK, *pcmpctblock));\n             state.pindexBestHeaderSent = pindex;\n         }\n@@ -855,8 +865,8 @@ void PeerLogicValidation::BlockChecked(const CBlock& block, const CValidationSta\n \n     int nDoS = 0;\n     if (state.IsInvalid(nDoS)) {\n-        if (it != mapBlockSource.end() && State(it->second.first)) {\n-            assert (state.GetRejectCode() < REJECT_INTERNAL); // Blocks are never rejected with internal reject codes\n+        // Don't send reject message with code 0 or an internal reject code.\n+        if (it != mapBlockSource.end() && State(it->second.first) && state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) {\n             CBlockReject reject = {(unsigned char)state.GetRejectCode(), state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), hash};\n             State(it->second.first)->rejects.push_back(reject);\n             if (nDoS > 0 && it->second.second)\n@@ -904,12 +914,11 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n                 recentRejects->reset();\n             }\n \n-            // Use pcoinsTip->HaveCoinsInCache as a quick approximation to exclude\n-            // requesting or processing some txs which have already been included in a block\n             return recentRejects->contains(inv.hash) ||\n                    mempool.exists(inv.hash) ||\n                    mapOrphanTransactions.count(inv.hash) ||\n-                   pcoinsTip->HaveCoinsInCache(inv.hash);\n+                   pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 0)) || // Best effort: only try output 0 and 1\n+                   pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 1));\n         }\n     case MSG_BLOCK:\n     case MSG_WITNESS_BLOCK:\n@@ -944,7 +953,7 @@ static void RelayAddress(const CAddress& addr, bool fReachable, CConnman& connma\n \n     auto sortfunc = [&best, &hasher, nRelayNodes](CNode* pnode) {\n         if (pnode->nVersion >= CADDR_TIME_VERSION) {\n-            uint64_t hashKey = CSipHasher(hasher).Write(pnode->id).Finalize();\n+            uint64_t hashKey = CSipHasher(hasher).Write(pnode->GetId()).Finalize();\n             for (unsigned int i = 0; i < nRelayNodes; i++) {\n                  if (hashKey > best[i].first) {\n                      std::copy(best.begin() + i, best.begin() + nRelayNodes - 1, best.begin() + i + 1);\n@@ -987,6 +996,15 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n             {\n                 bool send = false;\n                 BlockMap::iterator mi = mapBlockIndex.find(inv.hash);\n+                std::shared_ptr<const CBlock> a_recent_block;\n+                std::shared_ptr<const CBlockHeaderAndShortTxIDs> a_recent_compact_block;\n+                bool fWitnessesPresentInARecentCompactBlock;\n+                {\n+                    LOCK(cs_most_recent_block);\n+                    a_recent_block = most_recent_block;\n+                    a_recent_compact_block = most_recent_compact_block;\n+                    fWitnessesPresentInARecentCompactBlock = fWitnessesPresentInMostRecentCompactBlock;\n+                }\n                 if (mi != mapBlockIndex.end())\n                 {\n                     if (mi->second->nChainTx && !mi->second->IsValid(BLOCK_VALID_SCRIPTS) &&\n@@ -996,11 +1014,6 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         // before ActivateBestChain but after AcceptBlock).\n                         // In this case, we need to run ActivateBestChain prior to checking the relay\n                         // conditions below.\n-                        std::shared_ptr<const CBlock> a_recent_block;\n-                        {\n-                            LOCK(cs_most_recent_block);\n-                            a_recent_block = most_recent_block;\n-                        }\n                         CValidationState dummy;\n                         ActivateBestChain(dummy, Params(), a_recent_block);\n                     }\n@@ -1024,7 +1037,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                 static const int nOneWeek = 7 * 24 * 60 * 60; // assume > 1 week = historical\n                 if (send && connman.OutboundTargetReached(true) && ( ((pindexBestHeader != NULL) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > nOneWeek)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n                 {\n-                    LogPrint(\"net\", \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n+                    LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n \n                     //disconnect node\n                     pfrom->fDisconnect = true;\n@@ -1034,14 +1047,20 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                 // it's available before trying to send.\n                 if (send && (mi->second->nStatus & BLOCK_HAVE_DATA))\n                 {\n-                    // Send block from disk\n-                    CBlock block;\n-                    if (!ReadBlockFromDisk(block, (*mi).second, consensusParams))\n-                        assert(!\"cannot load block from disk\");\n+                    std::shared_ptr<const CBlock> pblock;\n+                    if (a_recent_block && a_recent_block->GetHash() == (*mi).second->GetBlockHash()) {\n+                        pblock = a_recent_block;\n+                    } else {\n+                        // Send block from disk\n+                        std::shared_ptr<CBlock> pblockRead = std::make_shared<CBlock>();\n+                        if (!ReadBlockFromDisk(*pblockRead, (*mi).second, consensusParams))\n+                            assert(!\"cannot load block from disk\");\n+                        pblock = pblockRead;\n+                    }\n                     if (inv.type == MSG_BLOCK)\n-                        connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, block));\n+                        connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::BLOCK, *pblock));\n                     else if (inv.type == MSG_WITNESS_BLOCK)\n-                        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, block));\n+                        connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::BLOCK, *pblock));\n                     else if (inv.type == MSG_FILTERED_BLOCK)\n                     {\n                         bool sendMerkleBlock = false;\n@@ -1050,7 +1069,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             LOCK(pfrom->cs_filter);\n                             if (pfrom->pfilter) {\n                                 sendMerkleBlock = true;\n-                                merkleBlock = CMerkleBlock(block, *pfrom->pfilter);\n+                                merkleBlock = CMerkleBlock(*pblock, *pfrom->pfilter);\n                             }\n                         }\n                         if (sendMerkleBlock) {\n@@ -1063,7 +1082,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             // however we MUST always provide at least what the remote peer needs\n                             typedef std::pair<unsigned int, uint256> PairType;\n                             BOOST_FOREACH(PairType& pair, merkleBlock.vMatchedTxn)\n-                                connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *block.vtx[pair.first]));\n+                                connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n                         }\n                         // else\n                             // no response\n@@ -1077,10 +1096,15 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                         bool fPeerWantsWitness = State(pfrom->GetId())->fWantsCmpctWitness;\n                         int nSendFlags = fPeerWantsWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n                         if (CanDirectFetch(consensusParams) && mi->second->nHeight >= chainActive.Height() - MAX_CMPCTBLOCK_DEPTH) {\n-                            CBlockHeaderAndShortTxIDs cmpctblock(block, fPeerWantsWitness);\n-                            connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n-                        } else\n-                            connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, block));\n+                            if ((fPeerWantsWitness || !fWitnessesPresentInARecentCompactBlock) && a_recent_compact_block && a_recent_compact_block->header.GetHash() == mi->second->GetBlockHash()) {\n+                                connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *a_recent_compact_block));\n+                            } else {\n+                                CBlockHeaderAndShortTxIDs cmpctblock(*pblock, fPeerWantsWitness);\n+                                connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, cmpctblock));\n+                            }\n+                        } else {\n+                            connman.PushMessage(pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCK, *pblock));\n+                        }\n                     }\n \n                     // Trigger the peer node to send a getblocks request for the next batch of inventory\n@@ -1141,7 +1165,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n     }\n }\n \n-uint32_t GetFetchFlags(CNode* pfrom, const CBlockIndex* pprev, const Consensus::Params& chainparams) {\n+uint32_t GetFetchFlags(CNode* pfrom) {\n     uint32_t nFetchFlags = 0;\n     if ((pfrom->GetLocalServices() & NODE_WITNESS) && State(pfrom->GetId())->fHaveWitness) {\n         nFetchFlags |= MSG_WITNESS_FLAG;\n@@ -1155,7 +1179,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n         if (req.indexes[i] >= block.vtx.size()) {\n             LOCK(cs_main);\n             Misbehaving(pfrom->GetId(), 100);\n-            LogPrintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->id);\n+            LogPrintf(\"Peer %d sent us a getblocktxn with out-of-bounds tx indices\", pfrom->GetId());\n             return;\n         }\n         resp.txn[i] = block.vtx[req.indexes[i]];\n@@ -1168,7 +1192,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n \n bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n {\n-    LogPrint(\"net\", \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->id);\n+    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->GetId());\n     if (IsArgSet(\"-dropmessagestest\") && GetRand(GetArg(\"-dropmessagestest\", 0)) == 0)\n     {\n         LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n@@ -1192,7 +1216,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n     if (strCommand == NetMsgType::REJECT)\n     {\n-        if (fDebug) {\n+        if (LogAcceptCategory(BCLog::NET)) {\n             try {\n                 std::string strMsg; unsigned char ccode; std::string strReason;\n                 vRecv >> LIMITED_STRING(strMsg, CMessageHeader::COMMAND_SIZE) >> ccode >> LIMITED_STRING(strReason, MAX_REJECT_MESSAGE_LENGTH);\n@@ -1206,10 +1230,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     vRecv >> hash;\n                     ss << \": hash \" << hash.ToString();\n                 }\n-                LogPrint(\"net\", \"Reject %s\\n\", SanitizeString(ss.str()));\n+                LogPrint(BCLog::NET, \"Reject %s\\n\", SanitizeString(ss.str()));\n             } catch (const std::ios_base::failure&) {\n                 // Avoid feedback loops by preventing reject messages from triggering a new reject message.\n-                LogPrint(\"net\", \"Unparseable reject message received\\n\");\n+                LogPrint(BCLog::NET, \"Unparseable reject message received\\n\");\n             }\n         }\n     }\n@@ -1247,7 +1271,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n         if (pfrom->nServicesExpected & ~nServices)\n         {\n-            LogPrint(\"net\", \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->id, nServices, pfrom->nServicesExpected);\n+            LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->GetId(), nServices, pfrom->nServicesExpected);\n             connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n                                strprintf(\"Expected to offer services %08x\", pfrom->nServicesExpected)));\n             pfrom->fDisconnect = true;\n@@ -1257,7 +1281,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (nVersion < MIN_PEER_PROTO_VERSION)\n         {\n             // disconnect from peers older than this proto version\n-            LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->id, nVersion);\n+            LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->GetId(), nVersion);\n             connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_OBSOLETE,\n                                strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION)));\n             pfrom->fDisconnect = true;\n@@ -1335,11 +1359,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 FastRandomContext insecure_rand;\n                 if (addr.IsRoutable())\n                 {\n-                    LogPrint(\"net\", \"ProcessMessages: advertising address %s\\n\", addr.ToString());\n+                    LogPrint(BCLog::NET, \"ProcessMessages: advertising address %s\\n\", addr.ToString());\n                     pfrom->PushAddress(addr, insecure_rand);\n                 } else if (IsPeerAddrLocalGood(pfrom)) {\n                     addr.SetIP(addrMe);\n-                    LogPrint(\"net\", \"ProcessMessages: advertising address %s\\n\", addr.ToString());\n+                    LogPrint(BCLog::NET, \"ProcessMessages: advertising address %s\\n\", addr.ToString());\n                     pfrom->PushAddress(addr, insecure_rand);\n                 }\n             }\n@@ -1359,7 +1383,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LogPrintf(\"receive version message: %s: version %d, blocks=%d, us=%s, peer=%d%s\\n\",\n                   cleanSubVer, pfrom->nVersion,\n-                  pfrom->nStartingHeight, addrMe.ToString(), pfrom->id,\n+                  pfrom->nStartingHeight, addrMe.ToString(), pfrom->GetId(),\n                   remoteAddr);\n \n         int64_t nTimeOffset = nTime - GetTime();\n@@ -1529,19 +1553,15 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LOCK(cs_main);\n \n-        uint32_t nFetchFlags = GetFetchFlags(pfrom, chainActive.Tip(), chainparams.GetConsensus());\n+        uint32_t nFetchFlags = GetFetchFlags(pfrom);\n \n-        std::vector<CInv> vToFetch;\n-\n-        for (unsigned int nInv = 0; nInv < vInv.size(); nInv++)\n+        for (CInv &inv : vInv)\n         {\n-            CInv &inv = vInv[nInv];\n-\n             if (interruptMsgProc)\n                 return true;\n \n             bool fAlreadyHave = AlreadyHave(inv);\n-            LogPrint(\"net\", \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->id);\n+            LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->GetId());\n \n             if (inv.type == MSG_TX) {\n                 inv.type |= nFetchFlags;\n@@ -1556,24 +1576,22 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     // we now only provide a getheaders response here. When we receive the headers, we will\n                     // then ask for the blocks we need.\n                     connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash));\n-                    LogPrint(\"net\", \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->id);\n+                    LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->GetId());\n                 }\n             }\n             else\n             {\n                 pfrom->AddInventoryKnown(inv);\n-                if (fBlocksOnly)\n-                    LogPrint(\"net\", \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->id);\n-                else if (!fAlreadyHave && !fImporting && !fReindex && !IsInitialBlockDownload())\n+                if (fBlocksOnly) {\n+                    LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->GetId());\n+                } else if (!fAlreadyHave && !fImporting && !fReindex && !IsInitialBlockDownload()) {\n                     pfrom->AskFor(inv);\n+                }\n             }\n \n             // Track requests for our stuff\n             GetMainSignals().Inventory(inv.hash);\n         }\n-\n-        if (!vToFetch.empty())\n-            connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vToFetch));\n     }\n \n \n@@ -1588,11 +1606,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return error(\"message getdata size() = %u\", vInv.size());\n         }\n \n-        if (fDebug || (vInv.size() != 1))\n-            LogPrint(\"net\", \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom->id);\n+        LogPrint(BCLog::NET, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom->GetId());\n \n-        if ((fDebug && vInv.size() > 0) || (vInv.size() == 1))\n-            LogPrint(\"net\", \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->id);\n+        if (vInv.size() > 0) {\n+            LogPrint(BCLog::NET, \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->GetId());\n+        }\n \n         pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());\n         ProcessGetData(pfrom, chainparams.GetConsensus(), connman, interruptMsgProc);\n@@ -1631,28 +1649,28 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (pindex)\n             pindex = chainActive.Next(pindex);\n         int nLimit = 500;\n-        LogPrint(\"net\", \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom->id);\n+        LogPrint(BCLog::NET, \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom->GetId());\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             if (pindex->GetBlockHash() == hashStop)\n             {\n-                LogPrint(\"net\", \"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+                LogPrint(BCLog::NET, \"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n                 break;\n             }\n             // If pruning, don't inv blocks unless we have on disk and are likely to still have\n             // for some reasonable time window (1 hour) that block relay might require.\n             const int nPrunedBlocksLikelyToHave = MIN_BLOCKS_TO_KEEP - 3600 / chainparams.GetConsensus().nPowTargetSpacing;\n             if (fPruneMode && (!(pindex->nStatus & BLOCK_HAVE_DATA) || pindex->nHeight <= chainActive.Tip()->nHeight - nPrunedBlocksLikelyToHave))\n             {\n-                LogPrint(\"net\", \" getblocks stopping, pruned or too old block at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+                LogPrint(BCLog::NET, \" getblocks stopping, pruned or too old block at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n                 break;\n             }\n             pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n             if (--nLimit <= 0)\n             {\n                 // When this block is requested, we'll send an inv that'll\n                 // trigger the peer to getblocks the next batch of inventory.\n-                LogPrint(\"net\", \"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+                LogPrint(BCLog::NET, \"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n                 pfrom->hashContinue = pindex->GetBlockHash();\n                 break;\n             }\n@@ -1681,7 +1699,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         BlockMap::iterator it = mapBlockIndex.find(req.blockhash);\n         if (it == mapBlockIndex.end() || !(it->second->nStatus & BLOCK_HAVE_DATA)) {\n-            LogPrintf(\"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->id);\n+            LogPrintf(\"Peer %d sent us a getblocktxn for a block we don't have\", pfrom->GetId());\n             return true;\n         }\n \n@@ -1693,7 +1711,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // might maliciously send lots of getblocktxn requests to trigger\n             // expensive disk reads, because it will require the peer to\n             // actually receive all the data read from disk over the network.\n-            LogPrint(\"net\", \"Peer %d sent us a getblocktxn for a block > %i deep\", pfrom->id, MAX_BLOCKTXN_DEPTH);\n+            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\", pfrom->GetId(), MAX_BLOCKTXN_DEPTH);\n             CInv inv;\n             inv.type = State(pfrom->GetId())->fWantsCmpctWitness ? MSG_WITNESS_BLOCK : MSG_BLOCK;\n             inv.hash = req.blockhash;\n@@ -1718,7 +1736,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LOCK(cs_main);\n         if (IsInitialBlockDownload() && !pfrom->fWhitelisted) {\n-            LogPrint(\"net\", \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->GetId());\n             return true;\n         }\n \n@@ -1743,7 +1761,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         std::vector<CBlock> vHeaders;\n         int nLimit = MAX_HEADERS_RESULTS;\n-        LogPrint(\"net\", \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->id);\n+        LogPrint(BCLog::NET, \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->GetId());\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             vHeaders.push_back(pindex->GetBlockHeader());\n@@ -1773,7 +1791,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // We are in blocks only mode and peer is either not whitelisted or whitelistrelay is off\n         if (!fRelayTxes && (!pfrom->fWhitelisted || !GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)))\n         {\n-            LogPrint(\"net\", \"transaction sent in violation of protocol peer=%d\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom->GetId());\n             return true;\n         }\n \n@@ -1805,8 +1823,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n             pfrom->nLastTXTime = GetTime();\n \n-            LogPrint(\"mempool\", \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n-                pfrom->id,\n+            LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n+                pfrom->GetId(),\n                 tx.GetHash().ToString(),\n                 mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n \n@@ -1835,7 +1853,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     if (setMisbehaving.count(fromPeer))\n                         continue;\n                     if (AcceptToMemoryPool(mempool, stateDummy, porphanTx, true, &fMissingInputs2, &lRemovedTxn)) {\n-                        LogPrint(\"mempool\", \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n+                        LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n                         RelayTransaction(orphanTx, connman);\n                         for (unsigned int i = 0; i < orphanTx.vout.size(); i++) {\n                             vWorkQueue.emplace_back(orphanHash, i);\n@@ -1850,11 +1868,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                             // Punish peer that gave us an invalid orphan tx\n                             Misbehaving(fromPeer, nDos);\n                             setMisbehaving.insert(fromPeer);\n-                            LogPrint(\"mempool\", \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n+                            LogPrint(BCLog::MEMPOOL, \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n                         }\n                         // Has inputs but not accepted to mempool\n                         // Probably non-standard or insufficient fee\n-                        LogPrint(\"mempool\", \"   removed orphan tx %s\\n\", orphanHash.ToString());\n+                        LogPrint(BCLog::MEMPOOL, \"   removed orphan tx %s\\n\", orphanHash.ToString());\n                         vEraseQueue.push_back(orphanHash);\n                         if (!orphanTx.HasWitness() && !stateDummy.CorruptionPossible()) {\n                             // Do not use rejection cache for witness transactions or\n@@ -1881,7 +1899,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 }\n             }\n             if (!fRejectedParents) {\n-                uint32_t nFetchFlags = GetFetchFlags(pfrom, chainActive.Tip(), chainparams.GetConsensus());\n+                uint32_t nFetchFlags = GetFetchFlags(pfrom);\n                 BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n                     CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);\n                     pfrom->AddInventoryKnown(_inv);\n@@ -1892,10 +1910,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n                 unsigned int nMaxOrphanTx = (unsigned int)std::max((int64_t)0, GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n                 unsigned int nEvicted = LimitOrphanTxSize(nMaxOrphanTx);\n-                if (nEvicted > 0)\n-                    LogPrint(\"mempool\", \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n+                if (nEvicted > 0) {\n+                    LogPrint(BCLog::MEMPOOL, \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n+                }\n             } else {\n-                LogPrint(\"mempool\", \"not keeping orphan with rejected parents %s\\n\",tx.GetHash().ToString());\n+                LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s\\n\",tx.GetHash().ToString());\n                 // We will continue to reject this tx since it has rejected\n                 // parents so avoid re-requesting it from other peers.\n                 recentRejects->insert(tx.GetHash());\n@@ -1925,10 +1944,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // case.\n                 int nDoS = 0;\n                 if (!state.IsInvalid(nDoS) || nDoS == 0) {\n-                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->id);\n+                    LogPrintf(\"Force relaying tx %s from whitelisted peer=%d\\n\", tx.GetHash().ToString(), pfrom->GetId());\n                     RelayTransaction(tx, connman);\n                 } else {\n-                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->id, FormatStateMessage(state));\n+                    LogPrintf(\"Not relaying invalid transaction %s from whitelisted peer=%d (%s)\\n\", tx.GetHash().ToString(), pfrom->GetId(), FormatStateMessage(state));\n                 }\n             }\n         }\n@@ -1939,10 +1958,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         int nDoS = 0;\n         if (state.IsInvalid(nDoS))\n         {\n-            LogPrint(\"mempoolrej\", \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n-                pfrom->id,\n+            LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n+                pfrom->GetId(),\n                 FormatStateMessage(state));\n-            if (state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n+            if (state.GetRejectCode() > 0 && state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n                 connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::REJECT, strCommand, (unsigned char)state.GetRejectCode(),\n                                    state.GetRejectReason().substr(0, MAX_REJECT_MESSAGE_LENGTH), inv.hash));\n             if (nDoS > 0) {\n@@ -1977,7 +1996,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     LOCK(cs_main);\n                     Misbehaving(pfrom->GetId(), nDoS);\n                 }\n-                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->id);\n+                LogPrintf(\"Peer %d sent us invalid header via cmpctblock\\n\", pfrom->GetId());\n                 return true;\n             }\n         }\n@@ -2017,7 +2036,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // We requested this block for some reason, but our mempool will probably be useless\n                 // so we just grab the block via normal getdata\n                 std::vector<CInv> vInv(1);\n-                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n+                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n                 connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n             }\n             return true;\n@@ -2041,12 +2060,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             if ((!fAlreadyInFlight && nodestate->nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) ||\n                  (fAlreadyInFlight && blockInFlightIt->second.first == pfrom->GetId())) {\n                 std::list<QueuedBlock>::iterator* queuedBlockIt = NULL;\n-                if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex, &queuedBlockIt)) {\n+                if (!MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex, &queuedBlockIt)) {\n                     if (!(*queuedBlockIt)->partialBlock)\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n                     else {\n                         // The block was already in flight using compact blocks from the same peer\n-                        LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\\n\");\n+                        LogPrint(BCLog::NET, \"Peer sent us compact block we were already syncing!\\n\");\n                         return true;\n                     }\n                 }\n@@ -2056,12 +2075,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 if (status == READ_STATUS_INVALID) {\n                     MarkBlockAsReceived(pindex->GetBlockHash()); // Reset in-flight state in case of whitelist\n                     Misbehaving(pfrom->GetId(), 100);\n-                    LogPrintf(\"Peer %d sent us invalid compact block\\n\", pfrom->id);\n+                    LogPrintf(\"Peer %d sent us invalid compact block\\n\", pfrom->GetId());\n                     return true;\n                 } else if (status == READ_STATUS_FAILED) {\n                     // Duplicate txindexes, the block is now in-flight, so just request it\n                     std::vector<CInv> vInv(1);\n-                    vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n+                    vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n                     connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                     return true;\n                 }\n@@ -2104,7 +2123,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // We requested this block, but its far into the future, so our\n                 // mempool will probably be useless - request the block normally\n                 std::vector<CInv> vInv(1);\n-                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus()), cmpctblock.header.GetHash());\n+                vInv[0] = CInv(MSG_BLOCK | GetFetchFlags(pfrom), cmpctblock.header.GetHash());\n                 connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, vInv));\n                 return true;\n             } else {\n@@ -2161,7 +2180,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n             if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n                     it->second.first != pfrom->GetId()) {\n-                LogPrint(\"net\", \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->id);\n+                LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->GetId());\n                 return true;\n             }\n \n@@ -2170,12 +2189,12 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             if (status == READ_STATUS_INVALID) {\n                 MarkBlockAsReceived(resp.blockhash); // Reset in-flight state in case of whitelist\n                 Misbehaving(pfrom->GetId(), 100);\n-                LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->id);\n+                LogPrintf(\"Peer %d sent us invalid compact block/non-matching block transactions\\n\", pfrom->GetId());\n                 return true;\n             } else if (status == READ_STATUS_FAILED) {\n                 // Might have collided, fall back to getdata now :(\n                 std::vector<CInv> invs;\n-                invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom, chainActive.Tip(), chainparams.GetConsensus()), resp.blockhash));\n+                invs.push_back(CInv(MSG_BLOCK | GetFetchFlags(pfrom), resp.blockhash));\n                 connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETDATA, invs));\n             } else {\n                 // Block is either okay, or possibly we received\n@@ -2254,11 +2273,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n             nodestate->nUnconnectingHeaders++;\n             connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n-            LogPrint(\"net\", \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n+            LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n                     pindexBestHeader->nHeight,\n-                    pfrom->id, nodestate->nUnconnectingHeaders);\n+                    pfrom->GetId(), nodestate->nUnconnectingHeaders);\n             // Set hashLastUnknownBlock for this peer, so that if we\n             // eventually get the headers - even from a different peer -\n             // we can use this peer to download.\n@@ -2296,7 +2315,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         LOCK(cs_main);\n         CNodeState *nodestate = State(pfrom->GetId());\n         if (nodestate->nUnconnectingHeaders > 0) {\n-            LogPrint(\"net\", \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->id, nodestate->nUnconnectingHeaders);\n+            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->GetId(), nodestate->nUnconnectingHeaders);\n         }\n         nodestate->nUnconnectingHeaders = 0;\n \n@@ -2307,7 +2326,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // Headers message had its maximum size; the peer may have more headers.\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n             // from there instead.\n-            LogPrint(\"net\", \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->id, pfrom->nStartingHeight);\n+            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->GetId(), pfrom->nStartingHeight);\n             connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));\n         }\n \n@@ -2332,7 +2351,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // the main chain -- this shouldn't really happen.  Bail out on the\n             // direct fetch and rely on parallel download instead.\n             if (!chainActive.Contains(pindexWalk)) {\n-                LogPrint(\"net\", \"Large reorg, won't direct fetch to %s (%d)\\n\",\n+                LogPrint(BCLog::NET, \"Large reorg, won't direct fetch to %s (%d)\\n\",\n                         pindexLast->GetBlockHash().ToString(),\n                         pindexLast->nHeight);\n             } else {\n@@ -2343,14 +2362,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                         // Can't download any more from this peer\n                         break;\n                     }\n-                    uint32_t nFetchFlags = GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus());\n+                    uint32_t nFetchFlags = GetFetchFlags(pfrom);\n                     vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                    MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex);\n-                    LogPrint(\"net\", \"Requesting block %s from  peer=%d\\n\",\n-                            pindex->GetBlockHash().ToString(), pfrom->id);\n+                    MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), pindex);\n+                    LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n+                            pindex->GetBlockHash().ToString(), pfrom->GetId());\n                 }\n                 if (vGetData.size() > 1) {\n-                    LogPrint(\"net\", \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\n+                    LogPrint(BCLog::NET, \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\n                             pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n                 }\n                 if (vGetData.size() > 0) {\n@@ -2370,7 +2389,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n         vRecv >> *pblock;\n \n-        LogPrint(\"net\", \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->id);\n+        LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->GetId());\n \n         // Process all blocks from whitelisted peers, even if not requested,\n         // unless we're still syncing with the network.\n@@ -2402,14 +2421,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // Making nodes which are behind NAT and can only make outgoing connections ignore\n         // the getaddr message mitigates the attack.\n         if (!pfrom->fInbound) {\n-            LogPrint(\"net\", \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom->GetId());\n             return true;\n         }\n \n         // Only send one GetAddr response per connection to reduce resource waste\n         //  and discourage addr stamping of INV announcements.\n         if (pfrom->fSentAddr) {\n-            LogPrint(\"net\", \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom->GetId());\n             return true;\n         }\n         pfrom->fSentAddr = true;\n@@ -2426,14 +2445,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     {\n         if (!(pfrom->GetLocalServices() & NODE_BLOOM) && !pfrom->fWhitelisted)\n         {\n-            LogPrint(\"net\", \"mempool request with bloom filters disabled, disconnect peer=%d\\n\", pfrom->GetId());\n+            LogPrint(BCLog::NET, \"mempool request with bloom filters disabled, disconnect peer=%d\\n\", pfrom->GetId());\n             pfrom->fDisconnect = true;\n             return true;\n         }\n \n         if (connman.OutboundTargetReached(false) && !pfrom->fWhitelisted)\n         {\n-            LogPrint(\"net\", \"mempool request with bandwidth limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n+            LogPrint(BCLog::NET, \"mempool request with bandwidth limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n             pfrom->fDisconnect = true;\n             return true;\n         }\n@@ -2509,8 +2528,8 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n \n         if (!(sProblem.empty())) {\n-            LogPrint(\"net\", \"pong peer=%d: %s, %x expected, %x received, %u bytes\\n\",\n-                pfrom->id,\n+            LogPrint(BCLog::NET, \"pong peer=%d: %s, %x expected, %x received, %u bytes\\n\",\n+                pfrom->GetId(),\n                 sProblem,\n                 pfrom->nPingNonceSent,\n                 nonce,\n@@ -2587,7 +2606,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LOCK(pfrom->cs_feeFilter);\n                 pfrom->minFeeFilter = newFeeFilter;\n             }\n-            LogPrint(\"net\", \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->id);\n+            LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->GetId());\n         }\n     }\n \n@@ -2598,7 +2617,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n     else {\n         // Ignore unknown commands for extensibility\n-        LogPrint(\"net\", \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->id);\n+        LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->GetId());\n     }\n \n \n@@ -2658,100 +2677,100 @@ bool ProcessMessages(CNode* pfrom, CConnman& connman, const std::atomic<bool>& i\n     // this maintains the order of responses\n     if (!pfrom->vRecvGetData.empty()) return true;\n \n-        // Don't bother if send buffer is too full to respond anyway\n-        if (pfrom->fPauseSend)\n-            return false;\n+    // Don't bother if send buffer is too full to respond anyway\n+    if (pfrom->fPauseSend)\n+        return false;\n \n-        std::list<CNetMessage> msgs;\n-        {\n-            LOCK(pfrom->cs_vProcessMsg);\n-            if (pfrom->vProcessMsg.empty())\n-                return false;\n-            // Just take one message\n-            msgs.splice(msgs.begin(), pfrom->vProcessMsg, pfrom->vProcessMsg.begin());\n-            pfrom->nProcessQueueSize -= msgs.front().vRecv.size() + CMessageHeader::HEADER_SIZE;\n-            pfrom->fPauseRecv = pfrom->nProcessQueueSize > connman.GetReceiveFloodSize();\n-            fMoreWork = !pfrom->vProcessMsg.empty();\n-        }\n-        CNetMessage& msg(msgs.front());\n-\n-        msg.SetVersion(pfrom->GetRecvVersion());\n-        // Scan for message start\n-        if (memcmp(msg.hdr.pchMessageStart, chainparams.MessageStart(), CMessageHeader::MESSAGE_START_SIZE) != 0) {\n-            LogPrintf(\"PROCESSMESSAGE: INVALID MESSAGESTART %s peer=%d\\n\", SanitizeString(msg.hdr.GetCommand()), pfrom->id);\n-            pfrom->fDisconnect = true;\n+    std::list<CNetMessage> msgs;\n+    {\n+        LOCK(pfrom->cs_vProcessMsg);\n+        if (pfrom->vProcessMsg.empty())\n             return false;\n-        }\n+        // Just take one message\n+        msgs.splice(msgs.begin(), pfrom->vProcessMsg, pfrom->vProcessMsg.begin());\n+        pfrom->nProcessQueueSize -= msgs.front().vRecv.size() + CMessageHeader::HEADER_SIZE;\n+        pfrom->fPauseRecv = pfrom->nProcessQueueSize > connman.GetReceiveFloodSize();\n+        fMoreWork = !pfrom->vProcessMsg.empty();\n+    }\n+    CNetMessage& msg(msgs.front());\n+\n+    msg.SetVersion(pfrom->GetRecvVersion());\n+    // Scan for message start\n+    if (memcmp(msg.hdr.pchMessageStart, chainparams.MessageStart(), CMessageHeader::MESSAGE_START_SIZE) != 0) {\n+        LogPrintf(\"PROCESSMESSAGE: INVALID MESSAGESTART %s peer=%d\\n\", SanitizeString(msg.hdr.GetCommand()), pfrom->GetId());\n+        pfrom->fDisconnect = true;\n+        return false;\n+    }\n \n-        // Read header\n-        CMessageHeader& hdr = msg.hdr;\n-        if (!hdr.IsValid(chainparams.MessageStart()))\n-        {\n-            LogPrintf(\"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\\n\", SanitizeString(hdr.GetCommand()), pfrom->id);\n-            return fMoreWork;\n-        }\n-        std::string strCommand = hdr.GetCommand();\n+    // Read header\n+    CMessageHeader& hdr = msg.hdr;\n+    if (!hdr.IsValid(chainparams.MessageStart()))\n+    {\n+        LogPrintf(\"PROCESSMESSAGE: ERRORS IN HEADER %s peer=%d\\n\", SanitizeString(hdr.GetCommand()), pfrom->GetId());\n+        return fMoreWork;\n+    }\n+    std::string strCommand = hdr.GetCommand();\n \n-        // Message size\n-        unsigned int nMessageSize = hdr.nMessageSize;\n+    // Message size\n+    unsigned int nMessageSize = hdr.nMessageSize;\n \n-        // Checksum\n-        CDataStream& vRecv = msg.vRecv;\n-        const uint256& hash = msg.GetMessageHash();\n-        if (memcmp(hash.begin(), hdr.pchChecksum, CMessageHeader::CHECKSUM_SIZE) != 0)\n+    // Checksum\n+    CDataStream& vRecv = msg.vRecv;\n+    const uint256& hash = msg.GetMessageHash();\n+    if (memcmp(hash.begin(), hdr.pchChecksum, CMessageHeader::CHECKSUM_SIZE) != 0)\n+    {\n+        LogPrintf(\"%s(%s, %u bytes): CHECKSUM ERROR expected %s was %s\\n\", __func__,\n+           SanitizeString(strCommand), nMessageSize,\n+           HexStr(hash.begin(), hash.begin()+CMessageHeader::CHECKSUM_SIZE),\n+           HexStr(hdr.pchChecksum, hdr.pchChecksum+CMessageHeader::CHECKSUM_SIZE));\n+        return fMoreWork;\n+    }\n+\n+    // Process message\n+    bool fRet = false;\n+    try\n+    {\n+        fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc);\n+        if (interruptMsgProc)\n+            return false;\n+        if (!pfrom->vRecvGetData.empty())\n+            fMoreWork = true;\n+    }\n+    catch (const std::ios_base::failure& e)\n+    {\n+        connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));\n+        if (strstr(e.what(), \"end of data\"))\n         {\n-            LogPrintf(\"%s(%s, %u bytes): CHECKSUM ERROR expected %s was %s\\n\", __func__,\n-               SanitizeString(strCommand), nMessageSize,\n-               HexStr(hash.begin(), hash.begin()+CMessageHeader::CHECKSUM_SIZE),\n-               HexStr(hdr.pchChecksum, hdr.pchChecksum+CMessageHeader::CHECKSUM_SIZE));\n-            return fMoreWork;\n+            // Allow exceptions from under-length message on vRecv\n+            LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n         }\n-\n-        // Process message\n-        bool fRet = false;\n-        try\n+        else if (strstr(e.what(), \"size too large\"))\n         {\n-            fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime, chainparams, connman, interruptMsgProc);\n-            if (interruptMsgProc)\n-                return false;\n-            if (!pfrom->vRecvGetData.empty())\n-                fMoreWork = true;\n+            // Allow exceptions from over-long size\n+            LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n         }\n-        catch (const std::ios_base::failure& e)\n+        else if (strstr(e.what(), \"non-canonical ReadCompactSize()\"))\n         {\n-            connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_MALFORMED, std::string(\"error parsing message\")));\n-            if (strstr(e.what(), \"end of data\"))\n-            {\n-                // Allow exceptions from under-length message on vRecv\n-                LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught, normally caused by a message being shorter than its stated length\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n-            }\n-            else if (strstr(e.what(), \"size too large\"))\n-            {\n-                // Allow exceptions from over-long size\n-                LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n-            }\n-            else if (strstr(e.what(), \"non-canonical ReadCompactSize()\"))\n-            {\n-                // Allow exceptions from non-canonical encoding\n-                LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n-            }\n-            else\n-            {\n-                PrintExceptionContinue(&e, \"ProcessMessages()\");\n-            }\n+            // Allow exceptions from non-canonical encoding\n+            LogPrintf(\"%s(%s, %u bytes): Exception '%s' caught\\n\", __func__, SanitizeString(strCommand), nMessageSize, e.what());\n         }\n-        catch (const std::exception& e) {\n+        else\n+        {\n             PrintExceptionContinue(&e, \"ProcessMessages()\");\n-        } catch (...) {\n-            PrintExceptionContinue(NULL, \"ProcessMessages()\");\n         }\n+    }\n+    catch (const std::exception& e) {\n+        PrintExceptionContinue(&e, \"ProcessMessages()\");\n+    } catch (...) {\n+        PrintExceptionContinue(NULL, \"ProcessMessages()\");\n+    }\n \n-        if (!fRet) {\n-            LogPrintf(\"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->id);\n-        }\n+    if (!fRet) {\n+        LogPrintf(\"%s(%s, %u bytes) FAILED peer=%d\\n\", __func__, SanitizeString(strCommand), nMessageSize, pfrom->GetId());\n+    }\n \n-        LOCK(cs_main);\n-        SendRejectsAndCheckIfBanned(pfrom, connman);\n+    LOCK(cs_main);\n+    SendRejectsAndCheckIfBanned(pfrom, connman);\n \n     return fMoreWork;\n }\n@@ -2865,6 +2884,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             // Only actively request headers from a single peer, unless we're close to today.\n             if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n                 state.fSyncStarted = true;\n+                state.nHeadersSyncTimeout = GetTimeMicros() + HEADERS_DOWNLOAD_TIMEOUT_BASE + HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER * (GetAdjustedTime() - pindexBestHeader->GetBlockTime())/(consensusParams.nPowTargetSpacing);\n                 nSyncStarted++;\n                 const CBlockIndex *pindexStart = pindexBestHeader;\n                 /* If possible, start at the block preceding the currently\n@@ -2876,7 +2896,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                    got back an empty response.  */\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n-                LogPrint(\"net\", \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->id, pto->nStartingHeight);\n+                LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->GetId(), pto->nStartingHeight);\n                 connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256()));\n             }\n         }\n@@ -2906,7 +2926,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                                  (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n                                 pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n             const CBlockIndex *pBestIndex = NULL; // last header queued for delivery\n-            ProcessBlockAvailability(pto->id); // ensure pindexBestKnownBlock is up-to-date\n+            ProcessBlockAvailability(pto->GetId()); // ensure pindexBestKnownBlock is up-to-date\n \n             if (!fRevertToInv) {\n                 bool fFoundStartingHeader = false;\n@@ -2960,16 +2980,16 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                 if (vHeaders.size() == 1 && state.fPreferHeaderAndIDs) {\n                     // We only send up to 1 block as header-and-ids, as otherwise\n                     // probably means we're doing an initial-ish-sync or they're slow\n-                    LogPrint(\"net\", \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n-                            vHeaders.front().GetHash().ToString(), pto->id);\n+                    LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n+                            vHeaders.front().GetHash().ToString(), pto->GetId());\n \n                     int nSendFlags = state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n \n                     bool fGotBlockFromCache = false;\n                     {\n                         LOCK(cs_most_recent_block);\n                         if (most_recent_block_hash == pBestIndex->GetBlockHash()) {\n-                            if (state.fWantsCmpctWitness)\n+                            if (state.fWantsCmpctWitness || !fWitnessesPresentInMostRecentCompactBlock)\n                                 connman.PushMessage(pto, msgMaker.Make(nSendFlags, NetMsgType::CMPCTBLOCK, *most_recent_compact_block));\n                             else {\n                                 CBlockHeaderAndShortTxIDs cmpctblock(*most_recent_block, state.fWantsCmpctWitness);\n@@ -2988,13 +3008,13 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else if (state.fPreferHeaders) {\n                     if (vHeaders.size() > 1) {\n-                        LogPrint(\"net\", \"%s: %u headers, range (%s, %s), to peer=%d\\n\", __func__,\n+                        LogPrint(BCLog::NET, \"%s: %u headers, range (%s, %s), to peer=%d\\n\", __func__,\n                                 vHeaders.size(),\n                                 vHeaders.front().GetHash().ToString(),\n-                                vHeaders.back().GetHash().ToString(), pto->id);\n+                                vHeaders.back().GetHash().ToString(), pto->GetId());\n                     } else {\n-                        LogPrint(\"net\", \"%s: sending header %s to peer=%d\\n\", __func__,\n-                                vHeaders.front().GetHash().ToString(), pto->id);\n+                        LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,\n+                                vHeaders.front().GetHash().ToString(), pto->GetId());\n                     }\n                     connman.PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n                     state.pindexBestHeaderSent = pBestIndex;\n@@ -3015,15 +3035,15 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     // This should be very rare and could be optimized out.\n                     // Just log for now.\n                     if (chainActive[pindex->nHeight] != pindex) {\n-                        LogPrint(\"net\", \"Announcing block %s not on main chain (tip=%s)\\n\",\n+                        LogPrint(BCLog::NET, \"Announcing block %s not on main chain (tip=%s)\\n\",\n                             hashToAnnounce.ToString(), chainActive.Tip()->GetBlockHash().ToString());\n                     }\n \n                     // If the peer's chain has this block, don't inv it back.\n                     if (!PeerHasHeader(&state, pindex)) {\n                         pto->PushInventory(CInv(MSG_BLOCK, hashToAnnounce));\n-                        LogPrint(\"net\", \"%s: sending inv peer=%d hash=%s\\n\", __func__,\n-                            pto->id, hashToAnnounce.ToString());\n+                        LogPrint(BCLog::NET, \"%s: sending inv peer=%d hash=%s\\n\", __func__,\n+                            pto->GetId(), hashToAnnounce.ToString());\n                     }\n                 }\n             }\n@@ -3170,7 +3190,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             // Stalling only triggers when the block download window cannot move. During normal steady state,\n             // the download window should be much larger than the to-be-downloaded set of blocks, so disconnection\n             // should only happen during initial block download.\n-            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->id);\n+            LogPrintf(\"Peer=%d is stalling block download, disconnecting\\n\", pto->GetId());\n             pto->fDisconnect = true;\n             return true;\n         }\n@@ -3183,11 +3203,44 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             QueuedBlock &queuedBlock = state.vBlocksInFlight.front();\n             int nOtherPeersWithValidatedDownloads = nPeersWithValidatedDownloads - (state.nBlocksInFlightValidHeaders > 0);\n             if (nNow > state.nDownloadingSince + consensusParams.nPowTargetSpacing * (BLOCK_DOWNLOAD_TIMEOUT_BASE + BLOCK_DOWNLOAD_TIMEOUT_PER_PEER * nOtherPeersWithValidatedDownloads)) {\n-                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->id);\n+                LogPrintf(\"Timeout downloading block %s from peer=%d, disconnecting\\n\", queuedBlock.hash.ToString(), pto->GetId());\n                 pto->fDisconnect = true;\n                 return true;\n             }\n         }\n+        // Check for headers sync timeouts\n+        if (state.fSyncStarted && state.nHeadersSyncTimeout < std::numeric_limits<int64_t>::max()) {\n+            // Detect whether this is a stalling initial-headers-sync peer\n+            if (pindexBestHeader->GetBlockTime() <= GetAdjustedTime() - 24*60*60) {\n+                if (nNow > state.nHeadersSyncTimeout && nSyncStarted == 1 && (nPreferredDownload - state.fPreferredDownload >= 1)) {\n+                    // Disconnect a (non-whitelisted) peer if it is our only sync peer,\n+                    // and we have others we could be using instead.\n+                    // Note: If all our peers are inbound, then we won't\n+                    // disconnect our sync peer for stalling; we have bigger\n+                    // problems if we can't get any outbound peers.\n+                    if (!pto->fWhitelisted) {\n+                        LogPrintf(\"Timeout downloading headers from peer=%d, disconnecting\\n\", pto->GetId());\n+                        pto->fDisconnect = true;\n+                        return true;\n+                    } else {\n+                        LogPrintf(\"Timeout downloading headers from whitelisted peer=%d, not disconnecting\\n\", pto->GetId());\n+                        // Reset the headers sync state so that we have a\n+                        // chance to try downloading from a different peer.\n+                        // Note: this will also result in at least one more\n+                        // getheaders message to be sent to\n+                        // this peer (eventually).\n+                        state.fSyncStarted = false;\n+                        nSyncStarted--;\n+                        state.nHeadersSyncTimeout = 0;\n+                    }\n+                }\n+            } else {\n+                // After we've caught up once, reset the timeout so we can't trigger\n+                // disconnect later.\n+                state.nHeadersSyncTimeout = std::numeric_limits<int64_t>::max();\n+            }\n+        }\n+\n \n         //\n         // Message: getdata (blocks)\n@@ -3198,16 +3251,16 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             NodeId staller = -1;\n             FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n             BOOST_FOREACH(const CBlockIndex *pindex, vToDownload) {\n-                uint32_t nFetchFlags = GetFetchFlags(pto, pindex->pprev, consensusParams);\n+                uint32_t nFetchFlags = GetFetchFlags(pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n-                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), consensusParams, pindex);\n-                LogPrint(\"net\", \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n-                    pindex->nHeight, pto->id);\n+                MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n+                LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n+                    pindex->nHeight, pto->GetId());\n             }\n             if (state.nBlocksInFlight == 0 && staller != -1) {\n                 if (State(staller)->nStallingSince == 0) {\n                     State(staller)->nStallingSince = nNow;\n-                    LogPrint(\"net\", \"Stall started peer=%d\\n\", staller);\n+                    LogPrint(BCLog::NET, \"Stall started peer=%d\\n\", staller);\n                 }\n             }\n         }\n@@ -3220,8 +3273,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             const CInv& inv = (*pto->mapAskFor.begin()).second;\n             if (!AlreadyHave(inv))\n             {\n-                if (fDebug)\n-                    LogPrint(\"net\", \"Requesting %s peer=%d\\n\", inv.ToString(), pto->id);\n+                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->GetId());\n                 vGetData.push_back(inv);\n                 if (vGetData.size() >= 1000)\n                 {"
      },
      {
        "sha": "db6d81e6b67f47a56e45a17815fea164c33e263a",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -17,6 +17,10 @@ static const int64_t ORPHAN_TX_EXPIRE_TIME = 20 * 60;\n static const int64_t ORPHAN_TX_EXPIRE_INTERVAL = 5 * 60;\n /** Default number of orphan+recently-replaced txn to keep around for block reconstruction */\n static const unsigned int DEFAULT_BLOCK_RECONSTRUCTION_EXTRA_TXN = 100;\n+/** Headers download timeout expressed in microseconds\n+ *  Timeout = base + per_header * (expected number of headers) */\n+static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_BASE = 15 * 60 * 1000000; // 15 minutes\n+static constexpr int64_t HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER = 1000; // 1ms/header\n \n /** Register with a network node to receive its signals */\n void RegisterNodeSignals(CNodeSignals& nodeSignals);\n@@ -30,10 +34,10 @@ class PeerLogicValidation : public CValidationInterface {\n public:\n     PeerLogicValidation(CConnman* connmanIn);\n \n-    virtual void SyncTransaction(const CTransaction& tx, const CBlockIndex* pindex, int nPosInBlock);\n-    virtual void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload);\n-    virtual void BlockChecked(const CBlock& block, const CValidationState& state);\n-    virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock);\n+    void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected, const std::vector<CTransactionRef>& vtxConflicted) override;\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n+    void BlockChecked(const CBlock& block, const CValidationState& state) override;\n+    void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n };\n \n struct CNodeStateStats {"
      },
      {
        "sha": "34a7029862e4d16517bc07a9ff62d29e865887ac",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -179,12 +179,6 @@ bool CNetAddr::IsLocal() const\n    return false;\n }\n \n-bool CNetAddr::IsMulticast() const\n-{\n-    return    (IsIPv4() && (GetByte(3) & 0xF0) == 0xE0)\n-           || (GetByte(15) == 0xFF);\n-}\n-\n bool CNetAddr::IsValid() const\n {\n     // Cleanup 3-byte shifted addresses caused by garbage in size field"
      },
      {
        "sha": "fbc4d1a65f9e7f54eaa2b72e6a22ba13abfe2db4",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -65,7 +65,6 @@ class CNetAddr\n         bool IsLocal() const;\n         bool IsRoutable() const;\n         bool IsValid() const;\n-        bool IsMulticast() const;\n         enum Network GetNetwork() const;\n         std::string ToString() const;\n         std::string ToStringIP() const;"
      },
      {
        "sha": "32557dd179996b9d1f58d780662e3f7cf5ce6635",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 11,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -281,7 +281,7 @@ std::string Socks5ErrorString(int err)\n static bool Socks5(const std::string& strDest, int port, const ProxyCredentials *auth, SOCKET& hSocket)\n {\n     IntrRecvError recvr;\n-    LogPrint(\"net\", \"SOCKS5 connecting %s\\n\", strDest);\n+    LogPrint(BCLog::NET, \"SOCKS5 connecting %s\\n\", strDest);\n     if (strDest.size() > 255) {\n         CloseSocket(hSocket);\n         return error(\"Hostname too long\");\n@@ -327,7 +327,7 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n             CloseSocket(hSocket);\n             return error(\"Error sending authentication to proxy\");\n         }\n-        LogPrint(\"proxy\", \"SOCKS5 sending proxy authentication %s:%s\\n\", auth->username, auth->password);\n+        LogPrint(BCLog::PROXY, \"SOCKS5 sending proxy authentication %s:%s\\n\", auth->username, auth->password);\n         char pchRetA[2];\n         if ((recvr = InterruptibleRecv(pchRetA, 2, SOCKS5_RECV_TIMEOUT, hSocket)) != IntrRecvError::OK) {\n             CloseSocket(hSocket);\n@@ -409,7 +409,7 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n         CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }\n-    LogPrint(\"net\", \"SOCKS5 connected %s\\n\", strDest);\n+    LogPrint(BCLog::NET, \"SOCKS5 connected %s\\n\", strDest);\n     return true;\n }\n \n@@ -428,18 +428,14 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     if (hSocket == INVALID_SOCKET)\n         return false;\n \n-    int set = 1;\n #ifdef SO_NOSIGPIPE\n+    int set = 1;\n     // Different way of disabling SIGPIPE on BSD\n     setsockopt(hSocket, SOL_SOCKET, SO_NOSIGPIPE, (void*)&set, sizeof(int));\n #endif\n \n     //Disable Nagle's algorithm\n-#ifdef WIN32\n-    setsockopt(hSocket, IPPROTO_TCP, TCP_NODELAY, (const char*)&set, sizeof(int));\n-#else\n-    setsockopt(hSocket, IPPROTO_TCP, TCP_NODELAY, (void*)&set, sizeof(int));\n-#endif\n+    SetSocketNoDelay(hSocket);\n \n     // Set to non-blocking\n     if (!SetSocketNonBlocking(hSocket, true))\n@@ -458,7 +454,7 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n             int nRet = select(hSocket + 1, NULL, &fdset, NULL, &timeout);\n             if (nRet == 0)\n             {\n-                LogPrint(\"net\", \"connection to %s timeout\\n\", addrConnect.ToString());\n+                LogPrint(BCLog::NET, \"connection to %s timeout\\n\", addrConnect.ToString());\n                 CloseSocket(hSocket);\n                 return false;\n             }\n@@ -672,13 +668,14 @@ std::string NetworkErrorString(int err)\n std::string NetworkErrorString(int err)\n {\n     char buf[256];\n-    const char *s = buf;\n     buf[0] = 0;\n     /* Too bad there are two incompatible implementations of the\n      * thread-safe strerror. */\n+    const char *s;\n #ifdef STRERROR_R_CHAR_P /* GNU variant can return a pointer outside the passed buffer */\n     s = strerror_r(err, buf, sizeof(buf));\n #else /* POSIX variant always returns message in buffer */\n+    s = buf;\n     if (strerror_r(err, buf, sizeof(buf)))\n         buf[0] = 0;\n #endif\n@@ -728,6 +725,13 @@ bool SetSocketNonBlocking(SOCKET& hSocket, bool fNonBlocking)\n     return true;\n }\n \n+bool SetSocketNoDelay(SOCKET& hSocket)\n+{\n+    int set = 1;\n+    int rc = setsockopt(hSocket, IPPROTO_TCP, TCP_NODELAY, (const char*)&set, sizeof(int));\n+    return rc == 0;\n+}\n+\n void InterruptSocks5(bool interrupt)\n {\n     interruptSocks5Recv = interrupt;"
      },
      {
        "sha": "c9d108aadd1410da675ba0182132d84ce56f96dc",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -59,6 +59,8 @@ std::string NetworkErrorString(int err);\n bool CloseSocket(SOCKET& hSocket);\n /** Disable or enable blocking-mode for a socket */\n bool SetSocketNonBlocking(SOCKET& hSocket, bool fNonBlocking);\n+/** Set the TCP_NODELAY flag on a socket */\n+bool SetSocketNoDelay(SOCKET& hSocket);\n /**\n  * Convert milliseconds to a struct timeval for e.g. select.\n  */"
      },
      {
        "sha": "a089c02284f047ed68c791cddeedb8d978c91736",
        "filename": "src/policy/feerate.cpp",
        "status": "renamed",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/policy/feerate.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/policy/feerate.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/feerate.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -3,7 +3,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"amount.h\"\n+#include \"feerate.h\"\n \n #include \"tinyformat.h\"\n ",
        "previous_filename": "src/amount.cpp"
      },
      {
        "sha": "e82268b095a3196b16007ac58cf3967a40196ed2",
        "filename": "src/policy/feerate.h",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/policy/feerate.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/policy/feerate.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/feerate.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -0,0 +1,54 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_POLICY_FEERATE_H\n+#define BITCOIN_POLICY_FEERATE_H\n+\n+#include \"amount.h\"\n+#include \"serialize.h\"\n+\n+#include <string>\n+\n+extern const std::string CURRENCY_UNIT;\n+\n+/**\n+ * Fee rate in satoshis per kilobyte: CAmount / kB\n+ */\n+class CFeeRate\n+{\n+private:\n+    CAmount nSatoshisPerK; // unit is satoshis-per-1,000-bytes\n+public:\n+    /** Fee rate of 0 satoshis per kB */\n+    CFeeRate() : nSatoshisPerK(0) { }\n+    explicit CFeeRate(const CAmount& _nSatoshisPerK): nSatoshisPerK(_nSatoshisPerK) { }\n+    /** Constructor for a fee rate in satoshis per kB. The size in bytes must not exceed (2^63 - 1)*/\n+    CFeeRate(const CAmount& nFeePaid, size_t nBytes);\n+    CFeeRate(const CFeeRate& other) { nSatoshisPerK = other.nSatoshisPerK; }\n+    /**\n+     * Return the fee in satoshis for the given size in bytes.\n+     */\n+    CAmount GetFee(size_t nBytes) const;\n+    /**\n+     * Return the fee in satoshis for a size of 1000 bytes\n+     */\n+    CAmount GetFeePerK() const { return GetFee(1000); }\n+    friend bool operator<(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK < b.nSatoshisPerK; }\n+    friend bool operator>(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK > b.nSatoshisPerK; }\n+    friend bool operator==(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK == b.nSatoshisPerK; }\n+    friend bool operator<=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK <= b.nSatoshisPerK; }\n+    friend bool operator>=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK >= b.nSatoshisPerK; }\n+    CFeeRate& operator+=(const CFeeRate& a) { nSatoshisPerK += a.nSatoshisPerK; return *this; }\n+    std::string ToString() const;\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITE(nSatoshisPerK);\n+    }\n+};\n+\n+#endif //  BITCOIN_POLICY_FEERATE_H"
      },
      {
        "sha": "7a9af5edc2456c5515c81b1b9fa4f71d215ce20d",
        "filename": "src/policy/fees.cpp",
        "status": "modified",
        "additions": 631,
        "deletions": 151,
        "changes": 782,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -7,46 +7,163 @@\n #include \"policy/policy.h\"\n \n #include \"amount.h\"\n+#include \"clientversion.h\"\n #include \"primitives/transaction.h\"\n #include \"random.h\"\n #include \"streams.h\"\n #include \"txmempool.h\"\n #include \"util.h\"\n \n-void TxConfirmStats::Initialize(std::vector<double>& defaultBuckets,\n-                                unsigned int maxConfirms, double _decay)\n+static constexpr double INF_FEERATE = 1e99;\n+\n+/**\n+ * We will instantiate an instance of this class to track transactions that were\n+ * included in a block. We will lump transactions into a bucket according to their\n+ * approximate feerate and then track how long it took for those txs to be included in a block\n+ *\n+ * The tracking of unconfirmed (mempool) transactions is completely independent of the\n+ * historical tracking of transactions that have been confirmed in a block.\n+ */\n+class TxConfirmStats\n+{\n+private:\n+    //Define the buckets we will group transactions into\n+    const std::vector<double>& buckets;              // The upper-bound of the range for the bucket (inclusive)\n+    const std::map<double, unsigned int>& bucketMap; // Map of bucket upper-bound to index into all vectors by bucket\n+\n+    // For each bucket X:\n+    // Count the total # of txs in each bucket\n+    // Track the historical moving average of this total over blocks\n+    std::vector<double> txCtAvg;\n+\n+    // Count the total # of txs confirmed within Y blocks in each bucket\n+    // Track the historical moving average of theses totals over blocks\n+    std::vector<std::vector<double>> confAvg; // confAvg[Y][X]\n+\n+    // Track moving avg of txs which have been evicted from the mempool\n+    // after failing to be confirmed within Y blocks\n+    std::vector<std::vector<double>> failAvg; // failAvg[Y][X]\n+\n+    // Sum the total feerate of all tx's in each bucket\n+    // Track the historical moving average of this total over blocks\n+    std::vector<double> avg;\n+\n+    // Combine the conf counts with tx counts to calculate the confirmation % for each Y,X\n+    // Combine the total value with the tx counts to calculate the avg feerate per bucket\n+\n+    double decay;\n+\n+    // Resolution (# of blocks) with which confirmations are tracked\n+    unsigned int scale;\n+\n+    // Mempool counts of outstanding transactions\n+    // For each bucket X, track the number of transactions in the mempool\n+    // that are unconfirmed for each possible confirmation value Y\n+    std::vector<std::vector<int> > unconfTxs;  //unconfTxs[Y][X]\n+    // transactions still unconfirmed after GetMaxConfirms for each bucket\n+    std::vector<int> oldUnconfTxs;\n+\n+    void resizeInMemoryCounters(size_t newbuckets);\n+\n+public:\n+    /**\n+     * Create new TxConfirmStats. This is called by BlockPolicyEstimator's\n+     * constructor with default values.\n+     * @param defaultBuckets contains the upper limits for the bucket boundaries\n+     * @param maxConfirms max number of confirms to track\n+     * @param decay how much to decay the historical moving average per block\n+     */\n+    TxConfirmStats(const std::vector<double>& defaultBuckets, const std::map<double, unsigned int>& defaultBucketMap,\n+                   unsigned int maxPeriods, double decay, unsigned int scale);\n+\n+    /** Roll the circular buffer for unconfirmed txs*/\n+    void ClearCurrent(unsigned int nBlockHeight);\n+\n+    /**\n+     * Record a new transaction data point in the current block stats\n+     * @param blocksToConfirm the number of blocks it took this transaction to confirm\n+     * @param val the feerate of the transaction\n+     * @warning blocksToConfirm is 1-based and has to be >= 1\n+     */\n+    void Record(int blocksToConfirm, double val);\n+\n+    /** Record a new transaction entering the mempool*/\n+    unsigned int NewTx(unsigned int nBlockHeight, double val);\n+\n+    /** Remove a transaction from mempool tracking stats*/\n+    void removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight,\n+                  unsigned int bucketIndex, bool inBlock);\n+\n+    /** Update our estimates by decaying our historical moving average and updating\n+        with the data gathered from the current block */\n+    void UpdateMovingAverages();\n+\n+    /**\n+     * Calculate a feerate estimate.  Find the lowest value bucket (or range of buckets\n+     * to make sure we have enough data points) whose transactions still have sufficient likelihood\n+     * of being confirmed within the target number of confirmations\n+     * @param confTarget target number of confirmations\n+     * @param sufficientTxVal required average number of transactions per block in a bucket range\n+     * @param minSuccess the success probability we require\n+     * @param requireGreater return the lowest feerate such that all higher values pass minSuccess OR\n+     *        return the highest feerate such that all lower values fail minSuccess\n+     * @param nBlockHeight the current block height\n+     */\n+    double EstimateMedianVal(int confTarget, double sufficientTxVal,\n+                             double minSuccess, bool requireGreater, unsigned int nBlockHeight,\n+                             EstimationResult *result = nullptr) const;\n+\n+    /** Return the max number of confirms we're tracking */\n+    unsigned int GetMaxConfirms() const { return scale * confAvg.size(); }\n+\n+    /** Write state of estimation data to a file*/\n+    void Write(CAutoFile& fileout) const;\n+\n+    /**\n+     * Read saved state of estimation data from a file and replace all internal data structures and\n+     * variables with this state.\n+     */\n+    void Read(CAutoFile& filein, int nFileVersion, size_t numBuckets);\n+};\n+\n+\n+TxConfirmStats::TxConfirmStats(const std::vector<double>& defaultBuckets,\n+                                const std::map<double, unsigned int>& defaultBucketMap,\n+                               unsigned int maxPeriods, double _decay, unsigned int _scale)\n+    : buckets(defaultBuckets), bucketMap(defaultBucketMap)\n {\n     decay = _decay;\n-    for (unsigned int i = 0; i < defaultBuckets.size(); i++) {\n-        buckets.push_back(defaultBuckets[i]);\n-        bucketMap[defaultBuckets[i]] = i;\n-    }\n-    confAvg.resize(maxConfirms);\n-    curBlockConf.resize(maxConfirms);\n-    unconfTxs.resize(maxConfirms);\n-    for (unsigned int i = 0; i < maxConfirms; i++) {\n+    scale = _scale;\n+    confAvg.resize(maxPeriods);\n+    for (unsigned int i = 0; i < maxPeriods; i++) {\n         confAvg[i].resize(buckets.size());\n-        curBlockConf[i].resize(buckets.size());\n-        unconfTxs[i].resize(buckets.size());\n+    }\n+    failAvg.resize(maxPeriods);\n+    for (unsigned int i = 0; i < maxPeriods; i++) {\n+        failAvg[i].resize(buckets.size());\n     }\n \n-    oldUnconfTxs.resize(buckets.size());\n-    curBlockTxCt.resize(buckets.size());\n     txCtAvg.resize(buckets.size());\n-    curBlockVal.resize(buckets.size());\n     avg.resize(buckets.size());\n+\n+    resizeInMemoryCounters(buckets.size());\n+}\n+\n+void TxConfirmStats::resizeInMemoryCounters(size_t newbuckets) {\n+    // newbuckets must be passed in because the buckets referred to during Read have not been updated yet.\n+    unconfTxs.resize(GetMaxConfirms());\n+    for (unsigned int i = 0; i < unconfTxs.size(); i++) {\n+        unconfTxs[i].resize(newbuckets);\n+    }\n+    oldUnconfTxs.resize(newbuckets);\n }\n \n-// Zero out the data for the current block\n+// Roll the unconfirmed txs circular buffer\n void TxConfirmStats::ClearCurrent(unsigned int nBlockHeight)\n {\n     for (unsigned int j = 0; j < buckets.size(); j++) {\n         oldUnconfTxs[j] += unconfTxs[nBlockHeight%unconfTxs.size()][j];\n         unconfTxs[nBlockHeight%unconfTxs.size()][j] = 0;\n-        for (unsigned int i = 0; i < curBlockConf.size(); i++)\n-            curBlockConf[i][j] = 0;\n-        curBlockTxCt[j] = 0;\n-        curBlockVal[j] = 0;\n     }\n }\n \n@@ -56,33 +173,38 @@ void TxConfirmStats::Record(int blocksToConfirm, double val)\n     // blocksToConfirm is 1-based\n     if (blocksToConfirm < 1)\n         return;\n+    int periodsToConfirm = (blocksToConfirm + scale - 1)/scale;\n     unsigned int bucketindex = bucketMap.lower_bound(val)->second;\n-    for (size_t i = blocksToConfirm; i <= curBlockConf.size(); i++) {\n-        curBlockConf[i - 1][bucketindex]++;\n+    for (size_t i = periodsToConfirm; i <= confAvg.size(); i++) {\n+        confAvg[i - 1][bucketindex]++;\n     }\n-    curBlockTxCt[bucketindex]++;\n-    curBlockVal[bucketindex] += val;\n+    txCtAvg[bucketindex]++;\n+    avg[bucketindex] += val;\n }\n \n void TxConfirmStats::UpdateMovingAverages()\n {\n     for (unsigned int j = 0; j < buckets.size(); j++) {\n         for (unsigned int i = 0; i < confAvg.size(); i++)\n-            confAvg[i][j] = confAvg[i][j] * decay + curBlockConf[i][j];\n-        avg[j] = avg[j] * decay + curBlockVal[j];\n-        txCtAvg[j] = txCtAvg[j] * decay + curBlockTxCt[j];\n+            confAvg[i][j] = confAvg[i][j] * decay;\n+        for (unsigned int i = 0; i < failAvg.size(); i++)\n+            failAvg[i][j] = failAvg[i][j] * decay;\n+        avg[j] = avg[j] * decay;\n+        txCtAvg[j] = txCtAvg[j] * decay;\n     }\n }\n \n // returns -1 on error conditions\n double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n                                          double successBreakPoint, bool requireGreater,\n-                                         unsigned int nBlockHeight)\n+                                         unsigned int nBlockHeight, EstimationResult *result) const\n {\n     // Counters for a bucket (or range of buckets)\n     double nConf = 0; // Number of tx's confirmed within the confTarget\n     double totalNum = 0; // Total number of tx's that were ever confirmed\n     int extraNum = 0;  // Number of tx's still in mempool for confTarget or longer\n+    double failNum = 0; // Number of tx's that were never confirmed but removed from the mempool after confTarget\n+    int periodTarget = (confTarget + scale - 1)/scale;\n \n     int maxbucketindex = buckets.size() - 1;\n \n@@ -105,12 +227,21 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n \n     bool foundAnswer = false;\n     unsigned int bins = unconfTxs.size();\n+    bool newBucketRange = true;\n+    bool passing = true;\n+    EstimatorBucket passBucket;\n+    EstimatorBucket failBucket;\n \n     // Start counting from highest(default) or lowest feerate transactions\n     for (int bucket = startbucket; bucket >= 0 && bucket <= maxbucketindex; bucket += step) {\n+        if (newBucketRange) {\n+            curNearBucket = bucket;\n+            newBucketRange = false;\n+        }\n         curFarBucket = bucket;\n-        nConf += confAvg[confTarget - 1][bucket];\n+        nConf += confAvg[periodTarget - 1][bucket];\n         totalNum += txCtAvg[bucket];\n+        failNum += failAvg[periodTarget - 1][bucket];\n         for (unsigned int confct = confTarget; confct < GetMaxConfirms(); confct++)\n             extraNum += unconfTxs[(nBlockHeight - confct)%bins][bucket];\n         extraNum += oldUnconfTxs[bucket];\n@@ -119,24 +250,41 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n         // (Only count the confirmed data points, so that each confirmation count\n         // will be looking at the same amount of data and same bucket breaks)\n         if (totalNum >= sufficientTxVal / (1 - decay)) {\n-            double curPct = nConf / (totalNum + extraNum);\n+            double curPct = nConf / (totalNum + failNum + extraNum);\n \n             // Check to see if we are no longer getting confirmed at the success rate\n-            if (requireGreater && curPct < successBreakPoint)\n-                break;\n-            if (!requireGreater && curPct > successBreakPoint)\n-                break;\n-\n+            if ((requireGreater && curPct < successBreakPoint) || (!requireGreater && curPct > successBreakPoint)) {\n+                if (passing == true) {\n+                    // First time we hit a failure record the failed bucket\n+                    unsigned int failMinBucket = std::min(curNearBucket, curFarBucket);\n+                    unsigned int failMaxBucket = std::max(curNearBucket, curFarBucket);\n+                    failBucket.start = failMinBucket ? buckets[failMinBucket - 1] : 0;\n+                    failBucket.end = buckets[failMaxBucket];\n+                    failBucket.withinTarget = nConf;\n+                    failBucket.totalConfirmed = totalNum;\n+                    failBucket.inMempool = extraNum;\n+                    failBucket.leftMempool = failNum;\n+                    passing = false;\n+                }\n+                continue;\n+            }\n             // Otherwise update the cumulative stats, and the bucket variables\n             // and reset the counters\n             else {\n+                failBucket = EstimatorBucket(); // Reset any failed bucket, currently passing\n                 foundAnswer = true;\n+                passing = true;\n+                passBucket.withinTarget = nConf;\n                 nConf = 0;\n+                passBucket.totalConfirmed = totalNum;\n                 totalNum = 0;\n+                passBucket.inMempool = extraNum;\n+                passBucket.leftMempool = failNum;\n+                failNum = 0;\n                 extraNum = 0;\n                 bestNearBucket = curNearBucket;\n                 bestFarBucket = curFarBucket;\n-                curNearBucket = bucket + step;\n+                newBucketRange = true;\n             }\n         }\n     }\n@@ -148,8 +296,8 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n     // Find the bucket with the median transaction and then report the average feerate from that bucket\n     // This is a compromise between finding the median which we can't since we don't save all tx's\n     // and reporting the average which is less accurate\n-    unsigned int minBucket = bestNearBucket < bestFarBucket ? bestNearBucket : bestFarBucket;\n-    unsigned int maxBucket = bestNearBucket > bestFarBucket ? bestNearBucket : bestFarBucket;\n+    unsigned int minBucket = std::min(bestNearBucket, bestFarBucket);\n+    unsigned int maxBucket = std::max(bestNearBucket, bestFarBucket);\n     for (unsigned int j = minBucket; j <= maxBucket; j++) {\n         txSum += txCtAvg[j];\n     }\n@@ -163,85 +311,111 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n                 break;\n             }\n         }\n+\n+        passBucket.start = minBucket ? buckets[minBucket-1] : 0;\n+        passBucket.end = buckets[maxBucket];\n     }\n \n-    LogPrint(\"estimatefee\", \"%3d: For conf success %s %4.2f need feerate %s: %12.5g from buckets %8g - %8g  Cur Bucket stats %6.2f%%  %8.1f/(%.1f+%d mempool)\\n\",\n-             confTarget, requireGreater ? \">\" : \"<\", successBreakPoint,\n-             requireGreater ? \">\" : \"<\", median, buckets[minBucket], buckets[maxBucket],\n-             100 * nConf / (totalNum + extraNum), nConf, totalNum, extraNum);\n+    // If we were passing until we reached last few buckets with insufficient data, then report those as failed\n+    if (passing && !newBucketRange) {\n+        unsigned int failMinBucket = std::min(curNearBucket, curFarBucket);\n+        unsigned int failMaxBucket = std::max(curNearBucket, curFarBucket);\n+        failBucket.start = failMinBucket ? buckets[failMinBucket - 1] : 0;\n+        failBucket.end = buckets[failMaxBucket];\n+        failBucket.withinTarget = nConf;\n+        failBucket.totalConfirmed = totalNum;\n+        failBucket.inMempool = extraNum;\n+        failBucket.leftMempool = failNum;\n+    }\n \n+    LogPrint(BCLog::ESTIMATEFEE, \"FeeEst: %d %s%.0f%% decay %.5f: feerate: %g from (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n+             confTarget, requireGreater ? \">\" : \"<\", 100.0 * successBreakPoint, decay,\n+             median, passBucket.start, passBucket.end,\n+             100 * passBucket.withinTarget / (passBucket.totalConfirmed + passBucket.inMempool + passBucket.leftMempool),\n+             passBucket.withinTarget, passBucket.totalConfirmed, passBucket.inMempool, passBucket.leftMempool,\n+             failBucket.start, failBucket.end,\n+             100 * failBucket.withinTarget / (failBucket.totalConfirmed + failBucket.inMempool + failBucket.leftMempool),\n+             failBucket.withinTarget, failBucket.totalConfirmed, failBucket.inMempool, failBucket.leftMempool);\n+\n+\n+    if (result) {\n+        result->pass = passBucket;\n+        result->fail = failBucket;\n+        result->decay = decay;\n+        result->scale = scale;\n+    }\n     return median;\n }\n \n-void TxConfirmStats::Write(CAutoFile& fileout)\n+void TxConfirmStats::Write(CAutoFile& fileout) const\n {\n     fileout << decay;\n-    fileout << buckets;\n+    fileout << scale;\n     fileout << avg;\n     fileout << txCtAvg;\n     fileout << confAvg;\n+    fileout << failAvg;\n }\n \n-void TxConfirmStats::Read(CAutoFile& filein)\n+void TxConfirmStats::Read(CAutoFile& filein, int nFileVersion, size_t numBuckets)\n {\n-    // Read data file into temporary variables and do some very basic sanity checking\n-    std::vector<double> fileBuckets;\n-    std::vector<double> fileAvg;\n-    std::vector<std::vector<double> > fileConfAvg;\n-    std::vector<double> fileTxCtAvg;\n-    double fileDecay;\n-    size_t maxConfirms;\n-    size_t numBuckets;\n-\n-    filein >> fileDecay;\n-    if (fileDecay <= 0 || fileDecay >= 1)\n-        throw std::runtime_error(\"Corrupt estimates file. Decay must be between 0 and 1 (non-inclusive)\");\n-    filein >> fileBuckets;\n-    numBuckets = fileBuckets.size();\n-    if (numBuckets <= 1 || numBuckets > 1000)\n-        throw std::runtime_error(\"Corrupt estimates file. Must have between 2 and 1000 feerate buckets\");\n-    filein >> fileAvg;\n-    if (fileAvg.size() != numBuckets)\n+    // Read data file and do some very basic sanity checking\n+    // buckets and bucketMap are not updated yet, so don't access them\n+    // If there is a read failure, we'll just discard this entire object anyway\n+    size_t maxConfirms, maxPeriods;\n+\n+    // The current version will store the decay with each individual TxConfirmStats and also keep a scale factor\n+    if (nFileVersion >= 149900) {\n+        filein >> decay;\n+        if (decay <= 0 || decay >= 1) {\n+            throw std::runtime_error(\"Corrupt estimates file. Decay must be between 0 and 1 (non-inclusive)\");\n+        }\n+        filein >> scale;\n+    }\n+\n+    filein >> avg;\n+    if (avg.size() != numBuckets) {\n         throw std::runtime_error(\"Corrupt estimates file. Mismatch in feerate average bucket count\");\n-    filein >> fileTxCtAvg;\n-    if (fileTxCtAvg.size() != numBuckets)\n+    }\n+    filein >> txCtAvg;\n+    if (txCtAvg.size() != numBuckets) {\n         throw std::runtime_error(\"Corrupt estimates file. Mismatch in tx count bucket count\");\n-    filein >> fileConfAvg;\n-    maxConfirms = fileConfAvg.size();\n-    if (maxConfirms <= 0 || maxConfirms > 6 * 24 * 7) // one week\n-        throw std::runtime_error(\"Corrupt estimates file.  Must maintain estimates for between 1 and 1008 (one week) confirms\");\n-    for (unsigned int i = 0; i < maxConfirms; i++) {\n-        if (fileConfAvg[i].size() != numBuckets)\n-            throw std::runtime_error(\"Corrupt estimates file. Mismatch in feerate conf average bucket count\");\n     }\n-    // Now that we've processed the entire feerate estimate data file and not\n-    // thrown any errors, we can copy it to our data structures\n-    decay = fileDecay;\n-    buckets = fileBuckets;\n-    avg = fileAvg;\n-    confAvg = fileConfAvg;\n-    txCtAvg = fileTxCtAvg;\n-    bucketMap.clear();\n+    filein >> confAvg;\n+    maxPeriods = confAvg.size();\n+    maxConfirms = scale * maxPeriods;\n \n-    // Resize the current block variables which aren't stored in the data file\n-    // to match the number of confirms and buckets\n-    curBlockConf.resize(maxConfirms);\n-    for (unsigned int i = 0; i < maxConfirms; i++) {\n-        curBlockConf[i].resize(buckets.size());\n+    if (maxConfirms <= 0 || maxConfirms > 6 * 24 * 7) { // one week\n+        throw std::runtime_error(\"Corrupt estimates file.  Must maintain estimates for between 1 and 1008 (one week) confirms\");\n+    }\n+    for (unsigned int i = 0; i < maxPeriods; i++) {\n+        if (confAvg[i].size() != numBuckets) {\n+            throw std::runtime_error(\"Corrupt estimates file. Mismatch in feerate conf average bucket count\");\n+        }\n     }\n-    curBlockTxCt.resize(buckets.size());\n-    curBlockVal.resize(buckets.size());\n \n-    unconfTxs.resize(maxConfirms);\n-    for (unsigned int i = 0; i < maxConfirms; i++) {\n-        unconfTxs[i].resize(buckets.size());\n+    if (nFileVersion >= 149900) {\n+        filein >> failAvg;\n+        if (maxPeriods != failAvg.size()) {\n+            throw std::runtime_error(\"Corrupt estimates file. Mismatch in confirms tracked for failures\");\n+        }\n+        for (unsigned int i = 0; i < maxPeriods; i++) {\n+            if (failAvg[i].size() != numBuckets) {\n+                throw std::runtime_error(\"Corrupt estimates file. Mismatch in one of failure average bucket counts\");\n+            }\n+        }\n+    } else {\n+        failAvg.resize(confAvg.size());\n+        for (unsigned int i = 0; i < failAvg.size(); i++) {\n+            failAvg[i].resize(numBuckets);\n+        }\n     }\n-    oldUnconfTxs.resize(buckets.size());\n \n-    for (unsigned int i = 0; i < buckets.size(); i++)\n-        bucketMap[buckets[i]] = i;\n+    // Resize the current block variables which aren't stored in the data file\n+    // to match the number of confirms and buckets\n+    resizeInMemoryCounters(numBuckets);\n \n-    LogPrint(\"estimatefee\", \"Reading estimates: %u buckets counting confirms up to %u blocks\\n\",\n+    LogPrint(BCLog::ESTIMATEFEE, \"Reading estimates: %u buckets counting confirms up to %u blocks\\n\",\n              numBuckets, maxConfirms);\n }\n \n@@ -253,31 +427,39 @@ unsigned int TxConfirmStats::NewTx(unsigned int nBlockHeight, double val)\n     return bucketindex;\n }\n \n-void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight, unsigned int bucketindex)\n+void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight, unsigned int bucketindex, bool inBlock)\n {\n     //nBestSeenHeight is not updated yet for the new block\n     int blocksAgo = nBestSeenHeight - entryHeight;\n     if (nBestSeenHeight == 0)  // the BlockPolicyEstimator hasn't seen any blocks yet\n         blocksAgo = 0;\n     if (blocksAgo < 0) {\n-        LogPrint(\"estimatefee\", \"Blockpolicy error, blocks ago is negative for mempool tx\\n\");\n+        LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy error, blocks ago is negative for mempool tx\\n\");\n         return;  //This can't happen because we call this with our best seen height, no entries can have higher\n     }\n \n     if (blocksAgo >= (int)unconfTxs.size()) {\n-        if (oldUnconfTxs[bucketindex] > 0)\n+        if (oldUnconfTxs[bucketindex] > 0) {\n             oldUnconfTxs[bucketindex]--;\n-        else\n-            LogPrint(\"estimatefee\", \"Blockpolicy error, mempool tx removed from >25 blocks,bucketIndex=%u already\\n\",\n+        } else {\n+            LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy error, mempool tx removed from >25 blocks,bucketIndex=%u already\\n\",\n                      bucketindex);\n+        }\n     }\n     else {\n         unsigned int blockIndex = entryHeight % unconfTxs.size();\n-        if (unconfTxs[blockIndex][bucketindex] > 0)\n+        if (unconfTxs[blockIndex][bucketindex] > 0) {\n             unconfTxs[blockIndex][bucketindex]--;\n-        else\n-            LogPrint(\"estimatefee\", \"Blockpolicy error, mempool tx removed from blockIndex=%u,bucketIndex=%u already\\n\",\n+        } else {\n+            LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy error, mempool tx removed from blockIndex=%u,bucketIndex=%u already\\n\",\n                      blockIndex, bucketindex);\n+        }\n+    }\n+    if (!inBlock && (unsigned int)blocksAgo >= scale) { // Only counts as a failure if not confirmed for entire period\n+        unsigned int periodsAgo = blocksAgo / scale;\n+        for (size_t i = 0; i < periodsAgo && i < failAvg.size(); i++) {\n+            failAvg[i][bucketindex]++;\n+        }\n     }\n }\n \n@@ -286,11 +468,14 @@ void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHe\n // tracked. Txs that were part of a block have already been removed in\n // processBlockTx to ensure they are never double tracked, but it is\n // of no harm to try to remove them again.\n-bool CBlockPolicyEstimator::removeTx(uint256 hash)\n+bool CBlockPolicyEstimator::removeTx(uint256 hash, bool inBlock)\n {\n+    LOCK(cs_feeEstimator);\n     std::map<uint256, TxStatsInfo>::iterator pos = mapMemPoolTxs.find(hash);\n     if (pos != mapMemPoolTxs.end()) {\n-        feeStats.removeTx(pos->second.blockHeight, nBestSeenHeight, pos->second.bucketIndex);\n+        feeStats->removeTx(pos->second.blockHeight, nBestSeenHeight, pos->second.bucketIndex, inBlock);\n+        shortStats->removeTx(pos->second.blockHeight, nBestSeenHeight, pos->second.bucketIndex, inBlock);\n+        longStats->removeTx(pos->second.blockHeight, nBestSeenHeight, pos->second.bucketIndex, inBlock);\n         mapMemPoolTxs.erase(hash);\n         return true;\n     } else {\n@@ -299,24 +484,37 @@ bool CBlockPolicyEstimator::removeTx(uint256 hash)\n }\n \n CBlockPolicyEstimator::CBlockPolicyEstimator()\n-    : nBestSeenHeight(0), trackedTxs(0), untrackedTxs(0)\n+    : nBestSeenHeight(0), firstRecordedHeight(0), historicalFirst(0), historicalBest(0), trackedTxs(0), untrackedTxs(0)\n {\n     static_assert(MIN_BUCKET_FEERATE > 0, \"Min feerate must be nonzero\");\n-    minTrackedFee = CFeeRate(MIN_BUCKET_FEERATE);\n-    std::vector<double> vfeelist;\n-    for (double bucketBoundary = minTrackedFee.GetFeePerK(); bucketBoundary <= MAX_BUCKET_FEERATE; bucketBoundary *= FEE_SPACING) {\n-        vfeelist.push_back(bucketBoundary);\n+    size_t bucketIndex = 0;\n+    for (double bucketBoundary = MIN_BUCKET_FEERATE; bucketBoundary <= MAX_BUCKET_FEERATE; bucketBoundary *= FEE_SPACING, bucketIndex++) {\n+        buckets.push_back(bucketBoundary);\n+        bucketMap[bucketBoundary] = bucketIndex;\n     }\n-    vfeelist.push_back(INF_FEERATE);\n-    feeStats.Initialize(vfeelist, MAX_BLOCK_CONFIRMS, DEFAULT_DECAY);\n+    buckets.push_back(INF_FEERATE);\n+    bucketMap[INF_FEERATE] = bucketIndex;\n+    assert(bucketMap.size() == buckets.size());\n+\n+    feeStats = new TxConfirmStats(buckets, bucketMap, MED_BLOCK_PERIODS, MED_DECAY, MED_SCALE);\n+    shortStats = new TxConfirmStats(buckets, bucketMap, SHORT_BLOCK_PERIODS, SHORT_DECAY, SHORT_SCALE);\n+    longStats = new TxConfirmStats(buckets, bucketMap, LONG_BLOCK_PERIODS, LONG_DECAY, LONG_SCALE);\n+}\n+\n+CBlockPolicyEstimator::~CBlockPolicyEstimator()\n+{\n+    delete feeStats;\n+    delete shortStats;\n+    delete longStats;\n }\n \n void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, bool validFeeEstimate)\n {\n+    LOCK(cs_feeEstimator);\n     unsigned int txHeight = entry.GetHeight();\n     uint256 hash = entry.GetTx().GetHash();\n     if (mapMemPoolTxs.count(hash)) {\n-        LogPrint(\"estimatefee\", \"Blockpolicy error mempool tx %s already being tracked\\n\",\n+        LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy error mempool tx %s already being tracked\\n\",\n                  hash.ToString().c_str());\n \treturn;\n     }\n@@ -341,12 +539,17 @@ void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, boo\n     CFeeRate feeRate(entry.GetFee(), entry.GetTxSize());\n \n     mapMemPoolTxs[hash].blockHeight = txHeight;\n-    mapMemPoolTxs[hash].bucketIndex = feeStats.NewTx(txHeight, (double)feeRate.GetFeePerK());\n+    unsigned int bucketIndex = feeStats->NewTx(txHeight, (double)feeRate.GetFeePerK());\n+    mapMemPoolTxs[hash].bucketIndex = bucketIndex;\n+    unsigned int bucketIndex2 = shortStats->NewTx(txHeight, (double)feeRate.GetFeePerK());\n+    assert(bucketIndex == bucketIndex2);\n+    unsigned int bucketIndex3 = longStats->NewTx(txHeight, (double)feeRate.GetFeePerK());\n+    assert(bucketIndex == bucketIndex3);\n }\n \n bool CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry* entry)\n {\n-    if (!removeTx(entry->GetTx().GetHash())) {\n+    if (!removeTx(entry->GetTx().GetHash(), true)) {\n         // This transaction wasn't being tracked for fee estimation\n         return false;\n     }\n@@ -358,20 +561,23 @@ bool CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight, const CTxM\n     if (blocksToConfirm <= 0) {\n         // This can't happen because we don't process transactions from a block with a height\n         // lower than our greatest seen height\n-        LogPrint(\"estimatefee\", \"Blockpolicy error Transaction had negative blocksToConfirm\\n\");\n+        LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy error Transaction had negative blocksToConfirm\\n\");\n         return false;\n     }\n \n     // Feerates are stored and reported as BTC-per-kb:\n     CFeeRate feeRate(entry->GetFee(), entry->GetTxSize());\n \n-    feeStats.Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n+    feeStats->Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n+    shortStats->Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n+    longStats->Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n     return true;\n }\n \n void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n                                          std::vector<const CTxMemPoolEntry*>& entries)\n {\n+    LOCK(cs_feeEstimator);\n     if (nBlockHeight <= nBestSeenHeight) {\n         // Ignore side chains and re-orgs; assuming they are random\n         // they don't affect the estimate.\n@@ -386,60 +592,226 @@ void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n     // of unconfirmed txs to remove from tracking.\n     nBestSeenHeight = nBlockHeight;\n \n-    // Clear the current block state and update unconfirmed circular buffer\n-    feeStats.ClearCurrent(nBlockHeight);\n+    // Update unconfirmed circular buffer\n+    feeStats->ClearCurrent(nBlockHeight);\n+    shortStats->ClearCurrent(nBlockHeight);\n+    longStats->ClearCurrent(nBlockHeight);\n+\n+    // Decay all exponential averages\n+    feeStats->UpdateMovingAverages();\n+    shortStats->UpdateMovingAverages();\n+    longStats->UpdateMovingAverages();\n \n     unsigned int countedTxs = 0;\n-    // Repopulate the current block states\n-    for (unsigned int i = 0; i < entries.size(); i++) {\n-        if (processBlockTx(nBlockHeight, entries[i]))\n+    // Update averages with data points from current block\n+    for (const auto& entry : entries) {\n+        if (processBlockTx(nBlockHeight, entry))\n             countedTxs++;\n     }\n \n-    // Update all exponential averages with the current block state\n-    feeStats.UpdateMovingAverages();\n+    if (firstRecordedHeight == 0 && countedTxs > 0) {\n+        firstRecordedHeight = nBestSeenHeight;\n+        LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy first recorded height %u\\n\", firstRecordedHeight);\n+    }\n+\n \n-    LogPrint(\"estimatefee\", \"Blockpolicy after updating estimates for %u of %u txs in block, since last block %u of %u tracked, new mempool map size %u\\n\",\n-             countedTxs, entries.size(), trackedTxs, trackedTxs + untrackedTxs, mapMemPoolTxs.size());\n+    LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy estimates updated by %u of %u block txs, since last block %u of %u tracked, mempool map size %u, max target %u from %s\\n\",\n+             countedTxs, entries.size(), trackedTxs, trackedTxs + untrackedTxs, mapMemPoolTxs.size(),\n+             MaxUsableEstimate(), HistoricalBlockSpan() > BlockSpan() ? \"historical\" : \"current\");\n \n     trackedTxs = 0;\n     untrackedTxs = 0;\n }\n \n-CFeeRate CBlockPolicyEstimator::estimateFee(int confTarget)\n+CFeeRate CBlockPolicyEstimator::estimateFee(int confTarget) const\n {\n-    // Return failure if trying to analyze a target we're not tracking\n     // It's not possible to get reasonable estimates for confTarget of 1\n-    if (confTarget <= 1 || (unsigned int)confTarget > feeStats.GetMaxConfirms())\n+    if (confTarget <= 1)\n         return CFeeRate(0);\n \n-    double median = feeStats.EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);\n+    return estimateRawFee(confTarget, DOUBLE_SUCCESS_PCT, FeeEstimateHorizon::MED_HALFLIFE);\n+}\n+\n+CFeeRate CBlockPolicyEstimator::estimateRawFee(int confTarget, double successThreshold, FeeEstimateHorizon horizon, EstimationResult* result) const\n+{\n+    TxConfirmStats* stats;\n+    double sufficientTxs = SUFFICIENT_FEETXS;\n+    switch (horizon) {\n+    case FeeEstimateHorizon::SHORT_HALFLIFE: {\n+        stats = shortStats;\n+        sufficientTxs = SUFFICIENT_TXS_SHORT;\n+        break;\n+    }\n+    case FeeEstimateHorizon::MED_HALFLIFE: {\n+        stats = feeStats;\n+        break;\n+    }\n+    case FeeEstimateHorizon::LONG_HALFLIFE: {\n+        stats = longStats;\n+        break;\n+    }\n+    default: {\n+        return CFeeRate(0);\n+    }\n+    }\n+\n+    LOCK(cs_feeEstimator);\n+    // Return failure if trying to analyze a target we're not tracking\n+    if (confTarget <= 0 || (unsigned int)confTarget > stats->GetMaxConfirms())\n+        return CFeeRate(0);\n+    if (successThreshold > 1)\n+        return CFeeRate(0);\n+\n+    double median = stats->EstimateMedianVal(confTarget, sufficientTxs, successThreshold, true, nBestSeenHeight, result);\n \n     if (median < 0)\n         return CFeeRate(0);\n \n     return CFeeRate(median);\n }\n \n-CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool)\n+unsigned int CBlockPolicyEstimator::BlockSpan() const\n+{\n+    if (firstRecordedHeight == 0) return 0;\n+    assert(nBestSeenHeight >= firstRecordedHeight);\n+\n+    return nBestSeenHeight - firstRecordedHeight;\n+}\n+\n+unsigned int CBlockPolicyEstimator::HistoricalBlockSpan() const\n+{\n+    if (historicalFirst == 0) return 0;\n+    assert(historicalBest >= historicalFirst);\n+\n+    if (nBestSeenHeight - historicalBest > OLDEST_ESTIMATE_HISTORY) return 0;\n+\n+    return historicalBest - historicalFirst;\n+}\n+\n+unsigned int CBlockPolicyEstimator::MaxUsableEstimate() const\n+{\n+    // Block spans are divided by 2 to make sure there are enough potential failing data points for the estimate\n+    return std::min(longStats->GetMaxConfirms(), std::max(BlockSpan(), HistoricalBlockSpan()) / 2);\n+}\n+\n+/** Return a fee estimate at the required successThreshold from the shortest\n+ * time horizon which tracks confirmations up to the desired target.  If\n+ * checkShorterHorizon is requested, also allow short time horizon estimates\n+ * for a lower target to reduce the given answer */\n+double CBlockPolicyEstimator::estimateCombinedFee(unsigned int confTarget, double successThreshold, bool checkShorterHorizon) const\n+{\n+    double estimate = -1;\n+    if (confTarget >= 1 && confTarget <= longStats->GetMaxConfirms()) {\n+        // Find estimate from shortest time horizon possible\n+        if (confTarget <= shortStats->GetMaxConfirms()) { // short horizon\n+            estimate = shortStats->EstimateMedianVal(confTarget, SUFFICIENT_TXS_SHORT, successThreshold, true, nBestSeenHeight);\n+        }\n+        else if (confTarget <= feeStats->GetMaxConfirms()) { // medium horizon\n+            estimate = feeStats->EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, successThreshold, true, nBestSeenHeight);\n+        }\n+        else { // long horizon\n+            estimate = longStats->EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, successThreshold, true, nBestSeenHeight);\n+        }\n+        if (checkShorterHorizon) {\n+            // If a lower confTarget from a more recent horizon returns a lower answer use it.\n+            if (confTarget > feeStats->GetMaxConfirms()) {\n+                double medMax = feeStats->EstimateMedianVal(feeStats->GetMaxConfirms(), SUFFICIENT_FEETXS, successThreshold, true, nBestSeenHeight);\n+                if (medMax > 0 && (estimate == -1 || medMax < estimate))\n+                    estimate = medMax;\n+            }\n+            if (confTarget > shortStats->GetMaxConfirms()) {\n+                double shortMax = shortStats->EstimateMedianVal(shortStats->GetMaxConfirms(), SUFFICIENT_TXS_SHORT, successThreshold, true, nBestSeenHeight);\n+                if (shortMax > 0 && (estimate == -1 || shortMax < estimate))\n+                    estimate = shortMax;\n+            }\n+        }\n+    }\n+    return estimate;\n+}\n+\n+/** Ensure that for a conservative estimate, the DOUBLE_SUCCESS_PCT is also met\n+ * at 2 * target for any longer time horizons.\n+ */\n+double CBlockPolicyEstimator::estimateConservativeFee(unsigned int doubleTarget) const\n+{\n+    double estimate = -1;\n+    if (doubleTarget <= shortStats->GetMaxConfirms()) {\n+        estimate = feeStats->EstimateMedianVal(doubleTarget, SUFFICIENT_FEETXS, DOUBLE_SUCCESS_PCT, true, nBestSeenHeight);\n+    }\n+    if (doubleTarget <= feeStats->GetMaxConfirms()) {\n+        double longEstimate = longStats->EstimateMedianVal(doubleTarget, SUFFICIENT_FEETXS, DOUBLE_SUCCESS_PCT, true, nBestSeenHeight);\n+        if (longEstimate > estimate) {\n+            estimate = longEstimate;\n+        }\n+    }\n+    return estimate;\n+}\n+\n+/** estimateSmartFee returns the max of the feerates calculated with a 60%\n+ * threshold required at target / 2, an 85% threshold required at target and a\n+ * 95% threshold required at 2 * target.  Each calculation is performed at the\n+ * shortest time horizon which tracks the required target.  Conservative\n+ * estimates, however, required the 95% threshold at 2 * target be met for any\n+ * longer time horizons also.\n+ */\n+CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool, bool conservative) const\n {\n     if (answerFoundAtTarget)\n         *answerFoundAtTarget = confTarget;\n-    // Return failure if trying to analyze a target we're not tracking\n-    if (confTarget <= 0 || (unsigned int)confTarget > feeStats.GetMaxConfirms())\n-        return CFeeRate(0);\n-\n-    // It's not possible to get reasonable estimates for confTarget of 1\n-    if (confTarget == 1)\n-        confTarget = 2;\n \n     double median = -1;\n-    while (median < 0 && (unsigned int)confTarget <= feeStats.GetMaxConfirms()) {\n-        median = feeStats.EstimateMedianVal(confTarget++, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);\n-    }\n+    {\n+        LOCK(cs_feeEstimator);\n+\n+        // Return failure if trying to analyze a target we're not tracking\n+        if (confTarget <= 0 || (unsigned int)confTarget > longStats->GetMaxConfirms())\n+            return CFeeRate(0);\n+\n+        // It's not possible to get reasonable estimates for confTarget of 1\n+        if (confTarget == 1)\n+            confTarget = 2;\n+\n+        unsigned int maxUsableEstimate = MaxUsableEstimate();\n+        if (maxUsableEstimate <= 1)\n+            return CFeeRate(0);\n+\n+        if ((unsigned int)confTarget > maxUsableEstimate) {\n+            confTarget = maxUsableEstimate;\n+        }\n+\n+        assert(confTarget > 0); //estimateCombinedFee and estimateConservativeFee take unsigned ints\n+\n+        /** true is passed to estimateCombined fee for target/2 and target so\n+         * that we check the max confirms for shorter time horizons as well.\n+         * This is necessary to preserve monotonically increasing estimates.\n+         * For non-conservative estimates we do the same thing for 2*target, but\n+         * for conservative estimates we want to skip these shorter horizons\n+         * checks for 2*target because we are taking the max over all time\n+         * horizons so we already have monotonically increasing estimates and\n+         * the purpose of conservative estimates is not to let short term\n+         * fluctuations lower our estimates by too much.\n+         */\n+        double halfEst = estimateCombinedFee(confTarget/2, HALF_SUCCESS_PCT, true);\n+        double actualEst = estimateCombinedFee(confTarget, SUCCESS_PCT, true);\n+        double doubleEst = estimateCombinedFee(2 * confTarget, DOUBLE_SUCCESS_PCT, !conservative);\n+        median = halfEst;\n+        if (actualEst > median) {\n+            median = actualEst;\n+        }\n+        if (doubleEst > median) {\n+            median = doubleEst;\n+        }\n+\n+        if (conservative || median == -1) {\n+            double consEst =  estimateConservativeFee(2 * confTarget);\n+            if (consEst > median) {\n+                median = consEst;\n+            }\n+        }\n+    } // Must unlock cs_feeEstimator before taking mempool locks\n \n     if (answerFoundAtTarget)\n-        *answerFoundAtTarget = confTarget - 1;\n+        *answerFoundAtTarget = confTarget;\n \n     // If mempool is limiting txs , return at least the min feerate from the mempool\n     CAmount minPoolFee = pool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n@@ -452,26 +824,134 @@ CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, int *answerFoun\n     return CFeeRate(median);\n }\n \n-void CBlockPolicyEstimator::Write(CAutoFile& fileout)\n+\n+bool CBlockPolicyEstimator::Write(CAutoFile& fileout) const\n {\n-    fileout << nBestSeenHeight;\n-    feeStats.Write(fileout);\n+    try {\n+        LOCK(cs_feeEstimator);\n+        fileout << 149900; // version required to read: 0.14.99 or later\n+        fileout << CLIENT_VERSION; // version that wrote the file\n+        fileout << nBestSeenHeight;\n+        if (BlockSpan() > HistoricalBlockSpan()/2) {\n+            fileout << firstRecordedHeight << nBestSeenHeight;\n+        }\n+        else {\n+            fileout << historicalFirst << historicalBest;\n+        }\n+        fileout << buckets;\n+        feeStats->Write(fileout);\n+        shortStats->Write(fileout);\n+        longStats->Write(fileout);\n+    }\n+    catch (const std::exception&) {\n+        LogPrintf(\"CBlockPolicyEstimator::Write(): unable to write policy estimator data (non-fatal)\\n\");\n+        return false;\n+    }\n+    return true;\n }\n \n-void CBlockPolicyEstimator::Read(CAutoFile& filein, int nFileVersion)\n+bool CBlockPolicyEstimator::Read(CAutoFile& filein)\n {\n-    int nFileBestSeenHeight;\n-    filein >> nFileBestSeenHeight;\n-    feeStats.Read(filein);\n-    nBestSeenHeight = nFileBestSeenHeight;\n-    // if nVersionThatWrote < 139900 then another TxConfirmStats (for priority) follows but can be ignored.\n+    try {\n+        LOCK(cs_feeEstimator);\n+        int nVersionRequired, nVersionThatWrote;\n+        unsigned int nFileBestSeenHeight, nFileHistoricalFirst, nFileHistoricalBest;\n+        filein >> nVersionRequired >> nVersionThatWrote;\n+        if (nVersionRequired > CLIENT_VERSION)\n+            return error(\"CBlockPolicyEstimator::Read(): up-version (%d) fee estimate file\", nVersionRequired);\n+\n+        // Read fee estimates file into temporary variables so existing data\n+        // structures aren't corrupted if there is an exception.\n+        filein >> nFileBestSeenHeight;\n+\n+        if (nVersionThatWrote < 149900) {\n+            // Read the old fee estimates file for temporary use, but then discard.  Will start collecting data from scratch.\n+            // decay is stored before buckets in old versions, so pre-read decay and pass into TxConfirmStats constructor\n+            double tempDecay;\n+            filein >> tempDecay;\n+            if (tempDecay <= 0 || tempDecay >= 1)\n+                throw std::runtime_error(\"Corrupt estimates file. Decay must be between 0 and 1 (non-inclusive)\");\n+\n+            std::vector<double> tempBuckets;\n+            filein >> tempBuckets;\n+            size_t tempNum = tempBuckets.size();\n+            if (tempNum <= 1 || tempNum > 1000)\n+                throw std::runtime_error(\"Corrupt estimates file. Must have between 2 and 1000 feerate buckets\");\n+\n+            std::map<double, unsigned int> tempMap;\n+\n+            std::unique_ptr<TxConfirmStats> tempFeeStats(new TxConfirmStats(tempBuckets, tempMap, MED_BLOCK_PERIODS, tempDecay, 1));\n+            tempFeeStats->Read(filein, nVersionThatWrote, tempNum);\n+            // if nVersionThatWrote < 139900 then another TxConfirmStats (for priority) follows but can be ignored.\n+\n+            tempMap.clear();\n+            for (unsigned int i = 0; i < tempBuckets.size(); i++) {\n+                tempMap[tempBuckets[i]] = i;\n+            }\n+        }\n+        else { // nVersionThatWrote >= 149900\n+            filein >> nFileHistoricalFirst >> nFileHistoricalBest;\n+            if (nFileHistoricalFirst > nFileHistoricalBest || nFileHistoricalBest > nFileBestSeenHeight) {\n+                throw std::runtime_error(\"Corrupt estimates file. Historical block range for estimates is invalid\");\n+            }\n+            std::vector<double> fileBuckets;\n+            filein >> fileBuckets;\n+            size_t numBuckets = fileBuckets.size();\n+            if (numBuckets <= 1 || numBuckets > 1000)\n+                throw std::runtime_error(\"Corrupt estimates file. Must have between 2 and 1000 feerate buckets\");\n+\n+            std::unique_ptr<TxConfirmStats> fileFeeStats(new TxConfirmStats(buckets, bucketMap, MED_BLOCK_PERIODS, MED_DECAY, MED_SCALE));\n+            std::unique_ptr<TxConfirmStats> fileShortStats(new TxConfirmStats(buckets, bucketMap, SHORT_BLOCK_PERIODS, SHORT_DECAY, SHORT_SCALE));\n+            std::unique_ptr<TxConfirmStats> fileLongStats(new TxConfirmStats(buckets, bucketMap, LONG_BLOCK_PERIODS, LONG_DECAY, LONG_SCALE));\n+            fileFeeStats->Read(filein, nVersionThatWrote, numBuckets);\n+            fileShortStats->Read(filein, nVersionThatWrote, numBuckets);\n+            fileLongStats->Read(filein, nVersionThatWrote, numBuckets);\n+\n+            // Fee estimates file parsed correctly\n+            // Copy buckets from file and refresh our bucketmap\n+            buckets = fileBuckets;\n+            bucketMap.clear();\n+            for (unsigned int i = 0; i < buckets.size(); i++) {\n+                bucketMap[buckets[i]] = i;\n+            }\n+\n+            // Destroy old TxConfirmStats and point to new ones that already reference buckets and bucketMap\n+            delete feeStats;\n+            delete shortStats;\n+            delete longStats;\n+            feeStats = fileFeeStats.release();\n+            shortStats = fileShortStats.release();\n+            longStats = fileLongStats.release();\n+\n+            nBestSeenHeight = nFileBestSeenHeight;\n+            historicalFirst = nFileHistoricalFirst;\n+            historicalBest = nFileHistoricalBest;\n+        }\n+    }\n+    catch (const std::exception& e) {\n+        LogPrintf(\"CBlockPolicyEstimator::Read(): unable to read policy estimator data (non-fatal): %s\\n\",e.what());\n+        return false;\n+    }\n+    return true;\n+}\n+\n+void CBlockPolicyEstimator::FlushUnconfirmed(CTxMemPool& pool) {\n+    int64_t startclear = GetTimeMicros();\n+    std::vector<uint256> txids;\n+    pool.queryHashes(txids);\n+    LOCK(cs_feeEstimator);\n+    for (auto& txid : txids) {\n+        removeTx(txid, false);\n+    }\n+    int64_t endclear = GetTimeMicros();\n+    LogPrint(BCLog::ESTIMATEFEE, \"Recorded %u unconfirmed txs from mempool in %gs\\n\",txids.size(), (endclear - startclear)*0.000001);\n }\n \n FeeFilterRounder::FeeFilterRounder(const CFeeRate& minIncrementalFee)\n {\n     CAmount minFeeLimit = std::max(CAmount(1), minIncrementalFee.GetFeePerK() / 2);\n     feeset.insert(0);\n-    for (double bucketBoundary = minFeeLimit; bucketBoundary <= MAX_BUCKET_FEERATE; bucketBoundary *= FEE_SPACING) {\n+    for (double bucketBoundary = minFeeLimit; bucketBoundary <= MAX_FILTER_FEERATE; bucketBoundary *= FEE_FILTER_SPACING) {\n         feeset.insert(bucketBoundary);\n     }\n }"
      },
      {
        "sha": "e99fec2c39398d81b01024e6dd0a10665908e57e",
        "filename": "src/policy/fees.h",
        "status": "modified",
        "additions": 152,
        "deletions": 162,
        "changes": 314,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -6,8 +6,10 @@\n #define BITCOIN_POLICYESTIMATOR_H\n \n #include \"amount.h\"\n+#include \"feerate.h\"\n #include \"uint256.h\"\n #include \"random.h\"\n+#include \"sync.h\"\n \n #include <map>\n #include <string>\n@@ -17,6 +19,7 @@ class CAutoFile;\n class CFeeRate;\n class CTxMemPoolEntry;\n class CTxMemPool;\n+class TxConfirmStats;\n \n /** \\class CBlockPolicyEstimator\n  * The BlockPolicyEstimator is used for estimating the feerate needed\n@@ -39,203 +42,160 @@ class CTxMemPool;\n  * within your desired 5 blocks.\n  *\n  * Here is a brief description of the implementation:\n- * When a transaction enters the mempool, we\n- * track the height of the block chain at entry.  Whenever a block comes in,\n- * we count the number of transactions in each bucket and the total amount of feerate\n- * paid in each bucket. Then we calculate how many blocks Y it took each\n- * transaction to be mined and we track an array of counters in each bucket\n- * for how long it to took transactions to get confirmed from 1 to a max of 25\n- * and we increment all the counters from Y up to 25. This is because for any\n- * number Z>=Y the transaction was successfully mined within Z blocks.  We\n- * want to save a history of this information, so at any time we have a\n- * counter of the total number of transactions that happened in a given feerate\n- * bucket and the total number that were confirmed in each number 1-25 blocks\n- * or less for any bucket.   We save this history by keeping an exponentially\n- * decaying moving average of each one of these stats.  Furthermore we also\n- * keep track of the number unmined (in mempool) transactions in each bucket\n- * and for how many blocks they have been outstanding and use that to increase\n- * the number of transactions we've seen in that feerate bucket when calculating\n- * an estimate for any number of confirmations below the number of blocks\n- * they've been outstanding.\n+ * When a transaction enters the mempool, we track the height of the block chain\n+ * at entry.  All further calculations are conducted only on this set of \"seen\"\n+ * transactions. Whenever a block comes in, we count the number of transactions\n+ * in each bucket and the total amount of feerate paid in each bucket. Then we\n+ * calculate how many blocks Y it took each transaction to be mined.  We convert\n+ * from a number of blocks to a number of periods Y' each encompassing \"scale\"\n+ * blocks.  This is is tracked in 3 different data sets each up to a maximum\n+ * number of periods. Within each data set we have an array of counters in each\n+ * feerate bucket and we increment all the counters from Y' up to max periods\n+ * representing that a tx was successfully confirmed in less than or equal to\n+ * that many periods. We want to save a history of this information, so at any\n+ * time we have a counter of the total number of transactions that happened in a\n+ * given feerate bucket and the total number that were confirmed in each of the\n+ * periods or less for any bucket.  We save this history by keeping an\n+ * exponentially decaying moving average of each one of these stats.  This is\n+ * done for a different decay in each of the 3 data sets to keep relevant data\n+ * from different time horizons.  Furthermore we also keep track of the number\n+ * unmined (in mempool or left mempool without being included in a block)\n+ * transactions in each bucket and for how many blocks they have been\n+ * outstanding and use both of these numbers to increase the number of transactions\n+ * we've seen in that feerate bucket when calculating an estimate for any number\n+ * of confirmations below the number of blocks they've been outstanding.\n  */\n \n-/**\n- * We will instantiate an instance of this class to track transactions that were\n- * included in a block. We will lump transactions into a bucket according to their\n- * approximate feerate and then track how long it took for those txs to be included in a block\n- *\n- * The tracking of unconfirmed (mempool) transactions is completely independent of the\n- * historical tracking of transactions that have been confirmed in a block.\n- */\n-class TxConfirmStats\n-{\n-private:\n-    //Define the buckets we will group transactions into\n-    std::vector<double> buckets;              // The upper-bound of the range for the bucket (inclusive)\n-    std::map<double, unsigned int> bucketMap; // Map of bucket upper-bound to index into all vectors by bucket\n-\n-    // For each bucket X:\n-    // Count the total # of txs in each bucket\n-    // Track the historical moving average of this total over blocks\n-    std::vector<double> txCtAvg;\n-    // and calculate the total for the current block to update the moving average\n-    std::vector<int> curBlockTxCt;\n-\n-    // Count the total # of txs confirmed within Y blocks in each bucket\n-    // Track the historical moving average of theses totals over blocks\n-    std::vector<std::vector<double> > confAvg; // confAvg[Y][X]\n-    // and calculate the totals for the current block to update the moving averages\n-    std::vector<std::vector<int> > curBlockConf; // curBlockConf[Y][X]\n-\n-    // Sum the total feerate of all tx's in each bucket\n-    // Track the historical moving average of this total over blocks\n-    std::vector<double> avg;\n-    // and calculate the total for the current block to update the moving average\n-    std::vector<double> curBlockVal;\n+/* Identifier for each of the 3 different TxConfirmStats which will track\n+ * history over different time horizons. */\n+enum FeeEstimateHorizon {\n+    SHORT_HALFLIFE = 0,\n+    MED_HALFLIFE = 1,\n+    LONG_HALFLIFE = 2\n+};\n \n-    // Combine the conf counts with tx counts to calculate the confirmation % for each Y,X\n-    // Combine the total value with the tx counts to calculate the avg feerate per bucket\n+/* Used to return detailed information about a feerate bucket */\n+struct EstimatorBucket\n+{\n+    double start = -1;\n+    double end = -1;\n+    double withinTarget = 0;\n+    double totalConfirmed = 0;\n+    double inMempool = 0;\n+    double leftMempool = 0;\n+};\n \n+/* Used to return detailed information about a fee estimate calculation */\n+struct EstimationResult\n+{\n+    EstimatorBucket pass;\n+    EstimatorBucket fail;\n     double decay;\n-\n-    // Mempool counts of outstanding transactions\n-    // For each bucket X, track the number of transactions in the mempool\n-    // that are unconfirmed for each possible confirmation value Y\n-    std::vector<std::vector<int> > unconfTxs;  //unconfTxs[Y][X]\n-    // transactions still unconfirmed after MAX_CONFIRMS for each bucket\n-    std::vector<int> oldUnconfTxs;\n-\n-public:\n-    /**\n-     * Initialize the data structures.  This is called by BlockPolicyEstimator's\n-     * constructor with default values.\n-     * @param defaultBuckets contains the upper limits for the bucket boundaries\n-     * @param maxConfirms max number of confirms to track\n-     * @param decay how much to decay the historical moving average per block\n-     */\n-    void Initialize(std::vector<double>& defaultBuckets, unsigned int maxConfirms, double decay);\n-\n-    /** Clear the state of the curBlock variables to start counting for the new block */\n-    void ClearCurrent(unsigned int nBlockHeight);\n-\n-    /**\n-     * Record a new transaction data point in the current block stats\n-     * @param blocksToConfirm the number of blocks it took this transaction to confirm\n-     * @param val the feerate of the transaction\n-     * @warning blocksToConfirm is 1-based and has to be >= 1\n-     */\n-    void Record(int blocksToConfirm, double val);\n-\n-    /** Record a new transaction entering the mempool*/\n-    unsigned int NewTx(unsigned int nBlockHeight, double val);\n-\n-    /** Remove a transaction from mempool tracking stats*/\n-    void removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight,\n-                  unsigned int bucketIndex);\n-\n-    /** Update our estimates by decaying our historical moving average and updating\n-        with the data gathered from the current block */\n-    void UpdateMovingAverages();\n-\n-    /**\n-     * Calculate a feerate estimate.  Find the lowest value bucket (or range of buckets\n-     * to make sure we have enough data points) whose transactions still have sufficient likelihood\n-     * of being confirmed within the target number of confirmations\n-     * @param confTarget target number of confirmations\n-     * @param sufficientTxVal required average number of transactions per block in a bucket range\n-     * @param minSuccess the success probability we require\n-     * @param requireGreater return the lowest feerate such that all higher values pass minSuccess OR\n-     *        return the highest feerate such that all lower values fail minSuccess\n-     * @param nBlockHeight the current block height\n-     */\n-    double EstimateMedianVal(int confTarget, double sufficientTxVal,\n-                             double minSuccess, bool requireGreater, unsigned int nBlockHeight);\n-\n-    /** Return the max number of confirms we're tracking */\n-    unsigned int GetMaxConfirms() { return confAvg.size(); }\n-\n-    /** Write state of estimation data to a file*/\n-    void Write(CAutoFile& fileout);\n-\n-    /**\n-     * Read saved state of estimation data from a file and replace all internal data structures and\n-     * variables with this state.\n-     */\n-    void Read(CAutoFile& filein);\n+    unsigned int scale;\n };\n \n-\n-\n-/** Track confirm delays up to 25 blocks, can't estimate beyond that */\n-static const unsigned int MAX_BLOCK_CONFIRMS = 25;\n-\n-/** Decay of .998 is a half-life of 346 blocks or about 2.4 days */\n-static const double DEFAULT_DECAY = .998;\n-\n-/** Require greater than 95% of X feerate transactions to be confirmed within Y blocks for X to be big enough */\n-static const double MIN_SUCCESS_PCT = .95;\n-\n-/** Require an avg of 1 tx in the combined feerate bucket per block to have stat significance */\n-static const double SUFFICIENT_FEETXS = 1;\n-\n-// Minimum and Maximum values for tracking feerates\n-// The MIN_BUCKET_FEERATE should just be set to the lowest reasonable feerate we\n-// might ever want to track.  Historically this has been 1000 since it was\n-// inheriting DEFAULT_MIN_RELAY_TX_FEE and changing it is disruptive as it\n-// invalidates old estimates files. So leave it at 1000 unless it becomes\n-// necessary to lower it, and then lower it substantially.\n-static constexpr double MIN_BUCKET_FEERATE = 1000;\n-static const double MAX_BUCKET_FEERATE = 1e7;\n-static const double INF_FEERATE = MAX_MONEY;\n-\n-// We have to lump transactions into buckets based on feerate, but we want to be able\n-// to give accurate estimates over a large range of potential feerates\n-// Therefore it makes sense to exponentially space the buckets\n-/** Spacing of FeeRate buckets */\n-static const double FEE_SPACING = 1.1;\n-\n /**\n  *  We want to be able to estimate feerates that are needed on tx's to be included in\n  * a certain number of blocks.  Every time a block is added to the best chain, this class records\n  * stats on the transactions included in that block\n  */\n class CBlockPolicyEstimator\n {\n+private:\n+    /** Track confirm delays up to 12 blocks for short horizon */\n+    static constexpr unsigned int SHORT_BLOCK_PERIODS = 12;\n+    static constexpr unsigned int SHORT_SCALE = 1;\n+    /** Track confirm delays up to 48 blocks for medium horizon */\n+    static constexpr unsigned int MED_BLOCK_PERIODS = 24;\n+    static constexpr unsigned int MED_SCALE = 2;\n+    /** Track confirm delays up to 1008 blocks for long horizon */\n+    static constexpr unsigned int LONG_BLOCK_PERIODS = 42;\n+    static constexpr unsigned int LONG_SCALE = 24;\n+    /** Historical estimates that are older than this aren't valid */\n+    static const unsigned int OLDEST_ESTIMATE_HISTORY = 6 * 1008;\n+\n+    /** Decay of .962 is a half-life of 18 blocks or about 3 hours */\n+    static constexpr double SHORT_DECAY = .962;\n+    /** Decay of .998 is a half-life of 144 blocks or about 1 day */\n+    static constexpr double MED_DECAY = .9952;\n+    /** Decay of .9995 is a half-life of 1008 blocks or about 1 week */\n+    static constexpr double LONG_DECAY = .99931;\n+\n+    /** Require greater than 60% of X feerate transactions to be confirmed within Y/2 blocks*/\n+    static constexpr double HALF_SUCCESS_PCT = .6;\n+    /** Require greater than 85% of X feerate transactions to be confirmed within Y blocks*/\n+    static constexpr double SUCCESS_PCT = .85;\n+    /** Require greater than 95% of X feerate transactions to be confirmed within 2 * Y blocks*/\n+    static constexpr double DOUBLE_SUCCESS_PCT = .95;\n+\n+    /** Require an avg of 0.1 tx in the combined feerate bucket per block to have stat significance */\n+    static constexpr double SUFFICIENT_FEETXS = 0.1;\n+    /** Require an avg of 0.5 tx when using short decay since there are fewer blocks considered*/\n+    static constexpr double SUFFICIENT_TXS_SHORT = 0.5;\n+\n+    /** Minimum and Maximum values for tracking feerates\n+     * The MIN_BUCKET_FEERATE should just be set to the lowest reasonable feerate we\n+     * might ever want to track.  Historically this has been 1000 since it was\n+     * inheriting DEFAULT_MIN_RELAY_TX_FEE and changing it is disruptive as it\n+     * invalidates old estimates files. So leave it at 1000 unless it becomes\n+     * necessary to lower it, and then lower it substantially.\n+     */\n+    static constexpr double MIN_BUCKET_FEERATE = 1000;\n+    static constexpr double MAX_BUCKET_FEERATE = 1e7;\n+\n+    /** Spacing of FeeRate buckets\n+     * We have to lump transactions into buckets based on feerate, but we want to be able\n+     * to give accurate estimates over a large range of potential feerates\n+     * Therefore it makes sense to exponentially space the buckets\n+     */\n+    static constexpr double FEE_SPACING = 1.05;\n+\n public:\n     /** Create new BlockPolicyEstimator and initialize stats tracking classes with default values */\n     CBlockPolicyEstimator();\n+    ~CBlockPolicyEstimator();\n \n     /** Process all the transactions that have been included in a block */\n     void processBlock(unsigned int nBlockHeight,\n                       std::vector<const CTxMemPoolEntry*>& entries);\n \n-    /** Process a transaction confirmed in a block*/\n-    bool processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry* entry);\n-\n     /** Process a transaction accepted to the mempool*/\n     void processTransaction(const CTxMemPoolEntry& entry, bool validFeeEstimate);\n \n     /** Remove a transaction from the mempool tracking stats*/\n-    bool removeTx(uint256 hash);\n+    bool removeTx(uint256 hash, bool inBlock);\n+\n+    /** DEPRECATED. Return a feerate estimate */\n+    CFeeRate estimateFee(int confTarget) const;\n \n-    /** Return a feerate estimate */\n-    CFeeRate estimateFee(int confTarget);\n+    /** Estimate feerate needed to get be included in a block within confTarget\n+     *  blocks. If no answer can be given at confTarget, return an estimate at\n+     *  the closest target where one can be given.  'conservative' estimates are\n+     *  valid over longer time horizons also.\n+     */\n+    CFeeRate estimateSmartFee(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool, bool conservative = true) const;\n \n-    /** Estimate feerate needed to get be included in a block within\n-     *  confTarget blocks. If no answer can be given at confTarget, return an\n-     *  estimate at the lowest target where one can be given.\n+    /** Return a specific fee estimate calculation with a given success\n+     * threshold and time horizon, and optionally return detailed data about\n+     * calculation\n      */\n-    CFeeRate estimateSmartFee(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool);\n+    CFeeRate estimateRawFee(int confTarget, double successThreshold, FeeEstimateHorizon horizon, EstimationResult *result = nullptr) const;\n \n     /** Write estimation data to a file */\n-    void Write(CAutoFile& fileout);\n+    bool Write(CAutoFile& fileout) const;\n \n     /** Read estimation data from a file */\n-    void Read(CAutoFile& filein, int nFileVersion);\n+    bool Read(CAutoFile& filein);\n+\n+    /** Empty mempool transactions on shutdown to record failure to confirm for txs still in mempool */\n+    void FlushUnconfirmed(CTxMemPool& pool);\n \n private:\n-    CFeeRate minTrackedFee;    //!< Passed to constructor to avoid dependency on main\n     unsigned int nBestSeenHeight;\n+    unsigned int firstRecordedHeight;\n+    unsigned int historicalFirst;\n+    unsigned int historicalBest;\n+\n     struct TxStatsInfo\n     {\n         unsigned int blockHeight;\n@@ -247,14 +207,43 @@ class CBlockPolicyEstimator\n     std::map<uint256, TxStatsInfo> mapMemPoolTxs;\n \n     /** Classes to track historical data on transaction confirmations */\n-    TxConfirmStats feeStats;\n+    TxConfirmStats* feeStats;\n+    TxConfirmStats* shortStats;\n+    TxConfirmStats* longStats;\n \n     unsigned int trackedTxs;\n     unsigned int untrackedTxs;\n+\n+    std::vector<double> buckets;              // The upper-bound of the range for the bucket (inclusive)\n+    std::map<double, unsigned int> bucketMap; // Map of bucket upper-bound to index into all vectors by bucket\n+\n+    mutable CCriticalSection cs_feeEstimator;\n+\n+    /** Process a transaction confirmed in a block*/\n+    bool processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry* entry);\n+\n+    /** Helper for estimateSmartFee */\n+    double estimateCombinedFee(unsigned int confTarget, double successThreshold, bool checkShorterHorizon) const;\n+    /** Helper for estimateSmartFee */\n+    double estimateConservativeFee(unsigned int doubleTarget) const;\n+    /** Number of blocks of data recorded while fee estimates have been running */\n+    unsigned int BlockSpan() const;\n+    /** Number of blocks of recorded fee estimate data represented in saved data file */\n+    unsigned int HistoricalBlockSpan() const;\n+    /** Calculation of highest target that reasonable estimate can be provided for */\n+    unsigned int MaxUsableEstimate() const;\n };\n \n class FeeFilterRounder\n {\n+private:\n+    static constexpr double MAX_FILTER_FEERATE = 1e7;\n+    /** FEE_FILTER_SPACING is just used to provide some quantization of fee\n+     * filter results.  Historically it reused FEE_SPACING, but it is completely\n+     * unrelated, and was made a separate constant so the two concepts are not\n+     * tied together */\n+    static constexpr double FEE_FILTER_SPACING = 1.1;\n+\n public:\n     /** Create new FeeFilterRounder */\n     FeeFilterRounder(const CFeeRate& minIncrementalFee);\n@@ -266,4 +255,5 @@ class FeeFilterRounder\n     std::set<double> feeset;\n     FastRandomContext insecure_rand;\n };\n+\n #endif /*BITCOIN_POLICYESTIMATOR_H */"
      },
      {
        "sha": "14d58e7442db0b52277dcbdacdc62d8e9bc8234d",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 3,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -8,12 +8,50 @@\n #include \"policy/policy.h\"\n \n #include \"validation.h\"\n+#include \"coins.h\"\n #include \"tinyformat.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n \n #include <boost/foreach.hpp>\n \n+CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)\n+{\n+    // \"Dust\" is defined in terms of dustRelayFee,\n+    // which has units satoshis-per-kilobyte.\n+    // If you'd pay more than 1/3 in fees\n+    // to spend something, then we consider it dust.\n+    // A typical spendable non-segwit txout is 34 bytes big, and will\n+    // need a CTxIn of at least 148 bytes to spend:\n+    // so dust is a spendable txout less than\n+    // 546*dustRelayFee/1000 (in satoshis).\n+    // A typical spendable segwit txout is 31 bytes big, and will\n+    // need a CTxIn of at least 67 bytes to spend:\n+    // so dust is a spendable txout less than\n+    // 294*dustRelayFee/1000 (in satoshis).\n+    if (txout.scriptPubKey.IsUnspendable())\n+        return 0;\n+\n+    size_t nSize = GetSerializeSize(txout, SER_DISK, 0);\n+    int witnessversion = 0;\n+    std::vector<unsigned char> witnessprogram;\n+\n+    if (txout.scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n+        // sum the sizes of the parts of a transaction input\n+        // with 75% segwit discount applied to the script size.\n+        nSize += (32 + 4 + 1 + (107 / WITNESS_SCALE_FACTOR) + 4);\n+    } else {\n+        nSize += (32 + 4 + 1 + 107 + 4); // the 148 mentioned above\n+    }\n+\n+    return 3 * dustRelayFeeIn.GetFee(nSize);\n+}\n+\n+bool IsDust(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)\n+{\n+    return (txout.nValue < GetDustThreshold(txout, dustRelayFeeIn));\n+}\n+\n     /**\n      * Check transaction inputs to mitigate two\n      * potential denial-of-service attacks:\n@@ -105,7 +143,7 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnes\n         else if ((whichType == TX_MULTISIG) && (!fIsBareMultisigStd)) {\n             reason = \"bare-multisig\";\n             return false;\n-        } else if (txout.IsDust(dustRelayFee)) {\n+        } else if (IsDust(txout, ::dustRelayFee)) {\n             reason = \"dust\";\n             return false;\n         }\n@@ -127,7 +165,7 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n \n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n     {\n-        const CTxOut& prev = mapInputs.GetOutputFor(tx.vin[i]);\n+        const CTxOut& prev = mapInputs.AccessCoin(tx.vin[i].prevout).out;\n \n         std::vector<std::vector<unsigned char> > vSolutions;\n         txnouttype whichType;\n@@ -166,7 +204,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         if (tx.vin[i].scriptWitness.IsNull())\n             continue;\n \n-        const CTxOut &prev = mapInputs.GetOutputFor(tx.vin[i]);\n+        const CTxOut &prev = mapInputs.AccessCoin(tx.vin[i].prevout).out;\n \n         // get the scriptPubKey corresponding to this input:\n         CScript prevScript = prev.scriptPubKey;"
      },
      {
        "sha": "2c2ea9d5b85a6011523ca2d9275806834cc93b37",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -7,12 +7,14 @@\n #define BITCOIN_POLICY_POLICY_H\n \n #include \"consensus/consensus.h\"\n+#include \"feerate.h\"\n #include \"script/interpreter.h\"\n #include \"script/standard.h\"\n \n #include <string>\n \n class CCoinsViewCache;\n+class CTxOut;\n \n /** Default for -blockmaxsize, which controls the maximum size of block the mining code will create **/\n static const unsigned int DEFAULT_BLOCK_MAX_SIZE = 750000;\n@@ -72,6 +74,10 @@ static const unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_\n static const unsigned int STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_VERIFY_SEQUENCE |\n                                                            LOCKTIME_MEDIAN_TIME_PAST;\n \n+CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFee);\n+\n+bool IsDust(const CTxOut& txout, const CFeeRate& dustRelayFee);\n+\n bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType, const bool witnessEnabled = false);\n     /**\n      * Check for standard transaction types"
      },
      {
        "sha": "22c73f3319340453f5f5f254e38761d66f2e70c9",
        "filename": "src/policy/rbf.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/policy/rbf.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/policy/rbf.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -7,6 +7,8 @@\n \n #include \"txmempool.h\"\n \n+static const uint32_t MAX_BIP125_RBF_SEQUENCE = 0xfffffffd;\n+\n enum RBFTransactionState {\n     RBF_TRANSACTIONSTATE_UNKNOWN,\n     RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125,"
      },
      {
        "sha": "f03cf48504a48de36f13428dd8abf06c1e31c5d4",
        "filename": "src/primitives/block.h",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/primitives/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/primitives/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -129,10 +129,7 @@ struct CBlockLocator\n \n     CBlockLocator() {}\n \n-    CBlockLocator(const std::vector<uint256>& vHaveIn)\n-    {\n-        vHave = vHaveIn;\n-    }\n+    CBlockLocator(const std::vector<uint256>& vHaveIn) : vHave(vHaveIn) {}\n \n     ADD_SERIALIZE_METHODS;\n "
      },
      {
        "sha": "00ac0b92b54da5e9ff41b3e37945f4f00a0a6c2f",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 2,
        "deletions": 39,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -22,8 +22,8 @@ class COutPoint\n     uint256 hash;\n     uint32_t n;\n \n-    COutPoint() { SetNull(); }\n-    COutPoint(uint256 hashIn, uint32_t nIn) { hash = hashIn; n = nIn; }\n+    COutPoint(): n((uint32_t) -1) { }\n+    COutPoint(const uint256& hashIn, uint32_t nIn): hash(hashIn), n(nIn) { }\n \n     ADD_SERIALIZE_METHODS;\n \n@@ -161,43 +161,6 @@ class CTxOut\n         return (nValue == -1);\n     }\n \n-    CAmount GetDustThreshold(const CFeeRate &minRelayTxFee) const\n-    {\n-        // \"Dust\" is defined in terms of CTransaction::minRelayTxFee,\n-        // which has units satoshis-per-kilobyte.\n-        // If you'd pay more than 1/3 in fees\n-        // to spend something, then we consider it dust.\n-        // A typical spendable non-segwit txout is 34 bytes big, and will\n-        // need a CTxIn of at least 148 bytes to spend:\n-        // so dust is a spendable txout less than\n-        // 546*minRelayTxFee/1000 (in satoshis).\n-        // A typical spendable segwit txout is 31 bytes big, and will\n-        // need a CTxIn of at least 67 bytes to spend:\n-        // so dust is a spendable txout less than\n-        // 294*minRelayTxFee/1000 (in satoshis).\n-        if (scriptPubKey.IsUnspendable())\n-            return 0;\n-\n-        size_t nSize = GetSerializeSize(*this, SER_DISK, 0);\n-        int witnessversion = 0;\n-        std::vector<unsigned char> witnessprogram;\n-\n-        if (scriptPubKey.IsWitnessProgram(witnessversion, witnessprogram)) {\n-            // sum the sizes of the parts of a transaction input\n-            // with 75% segwit discount applied to the script size.\n-            nSize += (32 + 4 + 1 + (107 / WITNESS_SCALE_FACTOR) + 4);\n-        } else {\n-            nSize += (32 + 4 + 1 + 107 + 4); // the 148 mentioned above\n-        }\n-\n-        return 3 * minRelayTxFee.GetFee(nSize);\n-    }\n-\n-    bool IsDust(const CFeeRate &minRelayTxFee) const\n-    {\n-        return (nValue < GetDustThreshold(minRelayTxFee));\n-    }\n-\n     friend bool operator==(const CTxOut& a, const CTxOut& b)\n     {\n         return (a.nValue       == b.nValue &&"
      },
      {
        "sha": "6cd246ed53edb219c6f6ff3cfddda346cb0859f2",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -151,11 +151,7 @@ CInv::CInv()\n     hash.SetNull();\n }\n \n-CInv::CInv(int typeIn, const uint256& hashIn)\n-{\n-    type = typeIn;\n-    hash = hashIn;\n-}\n+CInv::CInv(int typeIn, const uint256& hashIn) : type(typeIn), hash(hashIn) {}\n \n bool operator<(const CInv& a, const CInv& b)\n {"
      },
      {
        "sha": "f8a99506c131ea35169a73cf7240d4b818599282",
        "filename": "src/qt/bantablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/bantablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/bantablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bantablemodel.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -181,7 +181,5 @@ void BanTableModel::sort(int column, Qt::SortOrder order)\n \n bool BanTableModel::shouldShow()\n {\n-    if (priv->size() > 0)\n-        return true;\n-    return false;\n+    return priv->size() > 0;\n }"
      },
      {
        "sha": "23ec3ab434fa5b4ca221b809680b0c6cd92f86f2",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 6,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -10,6 +10,7 @@\n \n #include \"chainparams.h\"\n #include \"clientmodel.h\"\n+#include \"fs.h\"\n #include \"guiconstants.h\"\n #include \"guiutil.h\"\n #include \"intro.h\"\n@@ -38,7 +39,6 @@\n \n #include <stdint.h>\n \n-#include <boost/filesystem/operations.hpp>\n #include <boost/thread.hpp>\n \n #include <QApplication>\n@@ -152,15 +152,21 @@ static void initTranslations(QTranslator &qtTranslatorBase, QTranslator &qtTrans\n #if QT_VERSION < 0x050000\n void DebugMessageHandler(QtMsgType type, const char *msg)\n {\n-    const char *category = (type == QtDebugMsg) ? \"qt\" : NULL;\n-    LogPrint(category, \"GUI: %s\\n\", msg);\n+    if (type == QtDebugMsg) {\n+        LogPrint(BCLog::QT, \"GUI: %s\\n\", msg);\n+    } else {\n+        LogPrintf(\"GUI: %s\\n\", msg);\n+    }\n }\n #else\n void DebugMessageHandler(QtMsgType type, const QMessageLogContext& context, const QString &msg)\n {\n     Q_UNUSED(context);\n-    const char *category = (type == QtDebugMsg) ? \"qt\" : NULL;\n-    LogPrint(category, \"GUI: %s\\n\", msg.toStdString());\n+    if (type == QtDebugMsg) {\n+        LogPrint(BCLog::QT, \"GUI: %s\\n\", msg.toStdString());\n+    } else {\n+        LogPrintf(\"GUI: %s\\n\", msg.toStdString());\n+    }\n }\n #endif\n \n@@ -602,7 +608,7 @@ int main(int argc, char *argv[])\n \n     /// 6. Determine availability of data directory and parse bitcoin.conf\n     /// - Do not call GetDataDir(true) before this step finishes\n-    if (!boost::filesystem::is_directory(GetDataDir(false)))\n+    if (!fs::is_directory(GetDataDir(false)))\n     {\n         QMessageBox::critical(0, QObject::tr(PACKAGE_NAME),\n                               QObject::tr(\"Error: Specified data directory \\\"%1\\\" does not exist.\").arg(QString::fromStdString(GetArg(\"-datadir\", \"\"))));"
      },
      {
        "sha": "5c26baef9e8ae89758bb109dfb4637d4dd38a75c",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -478,6 +478,7 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel)\n         connect(_clientModel, SIGNAL(numConnectionsChanged(int)), this, SLOT(setNumConnections(int)));\n         connect(_clientModel, SIGNAL(networkActiveChanged(bool)), this, SLOT(setNetworkActive(bool)));\n \n+        modalOverlay->setKnownBestHeight(_clientModel->getHeaderTipHeight(), QDateTime::fromTime_t(_clientModel->getHeaderTipTime()));\n         setNumBlocks(_clientModel->getNumBlocks(), _clientModel->getLastBlockDate(), _clientModel->getVerificationProgress(NULL), false);\n         connect(_clientModel, SIGNAL(numBlocksChanged(int,QDateTime,double,bool)), this, SLOT(setNumBlocks(int,QDateTime,double,bool)));\n \n@@ -505,8 +506,6 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel)\n             // initialize the disable state of the tray icon with the current value in the model.\n             setTrayIconVisible(optionsModel->getHideTrayIcon());\n         }\n-\n-        modalOverlay->setKnownBestHeight(clientModel->getHeaderTipHeight(), QDateTime::fromTime_t(clientModel->getHeaderTipTime()));\n     } else {\n         // Disable possibility to show main window via action\n         toggleHideAction->setEnabled(false);"
      },
      {
        "sha": "a8b593a6525582184b34f2845b575bb99a59e08a",
        "filename": "src/qt/callback.h",
        "status": "added",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/callback.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/callback.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/callback.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -0,0 +1,30 @@\n+#ifndef BITCOIN_QT_CALLBACK_H\n+#define BITCOIN_QT_CALLBACK_H\n+\n+#include <QObject>\n+\n+class Callback : public QObject\n+{\n+    Q_OBJECT\n+public Q_SLOTS:\n+    virtual void call() = 0;\n+};\n+\n+template <typename F>\n+class FunctionCallback : public Callback\n+{\n+    F f;\n+\n+public:\n+    FunctionCallback(F f_) : f(std::move(f_)) {}\n+    ~FunctionCallback() override {}\n+    void call() override { f(this); }\n+};\n+\n+template <typename F>\n+FunctionCallback<F>* makeCallback(F f)\n+{\n+    return new FunctionCallback<F>(std::move(f));\n+}\n+\n+#endif // BITCOIN_QT_CALLBACK_H"
      },
      {
        "sha": "de00eacdb98f81917b41889ad8f2c791c8058460",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 8,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -9,6 +9,7 @@\n #include \"guiutil.h\"\n #include \"peertablemodel.h\"\n \n+#include \"chain.h\"\n #include \"chainparams.h\"\n #include \"checkpoints.h\"\n #include \"clientversion.h\"\n@@ -36,6 +37,8 @@ ClientModel::ClientModel(OptionsModel *_optionsModel, QObject *parent) :\n     banTableModel(0),\n     pollTimer(0)\n {\n+    cachedBestHeaderHeight = -1;\n+    cachedBestHeaderTime = -1;\n     peerTableModel = new PeerTableModel(this);\n     banTableModel = new BanTableModel(this);\n     pollTimer = new QTimer(this);\n@@ -74,18 +77,28 @@ int ClientModel::getNumBlocks() const\n \n int ClientModel::getHeaderTipHeight() const\n {\n-    LOCK(cs_main);\n-    if (!pindexBestHeader)\n-        return 0;\n-    return pindexBestHeader->nHeight;\n+    if (cachedBestHeaderHeight == -1) {\n+        // make sure we initially populate the cache via a cs_main lock\n+        // otherwise we need to wait for a tip update\n+        LOCK(cs_main);\n+        if (pindexBestHeader) {\n+            cachedBestHeaderHeight = pindexBestHeader->nHeight;\n+            cachedBestHeaderTime = pindexBestHeader->GetBlockTime();\n+        }\n+    }\n+    return cachedBestHeaderHeight;\n }\n \n int64_t ClientModel::getHeaderTipTime() const\n {\n-    LOCK(cs_main);\n-    if (!pindexBestHeader)\n-        return 0;\n-    return pindexBestHeader->GetBlockTime();\n+    if (cachedBestHeaderTime == -1) {\n+        LOCK(cs_main);\n+        if (pindexBestHeader) {\n+            cachedBestHeaderHeight = pindexBestHeader->nHeight;\n+            cachedBestHeaderTime = pindexBestHeader->GetBlockTime();\n+        }\n+    }\n+    return cachedBestHeaderTime;\n }\n \n quint64 ClientModel::getTotalBytesRecv() const\n@@ -283,6 +296,11 @@ static void BlockTipChanged(ClientModel *clientmodel, bool initialSync, const CB\n \n     int64_t& nLastUpdateNotification = fHeader ? nLastHeaderTipUpdateNotification : nLastBlockTipUpdateNotification;\n \n+    if (fHeader) {\n+        // cache best headers time and height to reduce future cs_main locks\n+        clientmodel->cachedBestHeaderHeight = pIndex->nHeight;\n+        clientmodel->cachedBestHeaderTime = pIndex->GetBlockTime();\n+    }\n     // if we are in-sync, update the UI regardless of last update time\n     if (!initialSync || now - nLastUpdateNotification > MODEL_UPDATE_DELAY) {\n         //pass a async signal to the UI thread"
      },
      {
        "sha": "4c92e2144e32154b7683a4f3e9a29eeedd425a39",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -8,6 +8,8 @@\n #include <QObject>\n #include <QDateTime>\n \n+#include <atomic>\n+\n class AddressTableModel;\n class BanTableModel;\n class OptionsModel;\n@@ -81,6 +83,10 @@ class ClientModel : public QObject\n     QString formatClientStartupTime() const;\n     QString dataDir() const;\n \n+    // caches for the best header\n+    mutable std::atomic<int> cachedBestHeaderHeight;\n+    mutable std::atomic<int64_t> cachedBestHeaderTime;\n+\n private:\n     OptionsModel *optionsModel;\n     PeerTableModel *peerTableModel;"
      },
      {
        "sha": "1f14abf2c99ac5cfac1837ca6297ab71dcd57894",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 11,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -15,12 +15,11 @@\n \n #include \"wallet/coincontrol.h\"\n #include \"init.h\"\n+#include \"policy/fees.h\"\n #include \"policy/policy.h\"\n #include \"validation.h\" // For mempool\n #include \"wallet/wallet.h\"\n \n-#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n-\n #include <QApplication>\n #include <QCheckBox>\n #include <QCursor>\n@@ -433,8 +432,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n         {\n             CTxOut txout(amount, (CScript)std::vector<unsigned char>(24, 0));\n             txDummy.vout.push_back(txout);\n-            if (txout.IsDust(dustRelayFee))\n-               fDust = true;\n+            fDust |= IsDust(txout, ::dustRelayFee);\n         }\n     }\n \n@@ -512,9 +510,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n                 nBytes -= 34;\n \n         // Fee\n-        nPayFee = CWallet::GetMinimumFee(nBytes, nTxConfirmTarget, mempool);\n-        if (nPayFee > 0 && coinControl->nMinimumTotalFee > nPayFee)\n-            nPayFee = coinControl->nMinimumTotalFee;\n+        nPayFee = CWallet::GetMinimumFee(nBytes, nTxConfirmTarget, ::mempool, ::feeEstimator);\n \n         if (nPayAmount > 0)\n         {\n@@ -526,10 +522,10 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n             if (nChange > 0 && nChange < MIN_CHANGE)\n             {\n                 CTxOut txout(nChange, (CScript)std::vector<unsigned char>(24, 0));\n-                if (txout.IsDust(dustRelayFee))\n+                if (IsDust(txout, ::dustRelayFee))\n                 {\n                     if (CoinControlDialog::fSubtractFeeFromAmount) // dust-change will be raised until no dust\n-                        nChange = txout.GetDustThreshold(dustRelayFee);\n+                        nChange = GetDustThreshold(txout, ::dustRelayFee);\n                     else\n                     {\n                         nPayFee += nChange;\n@@ -573,7 +569,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n     l5->setText(((nBytes > 0) ? ASYMP_UTF8 : \"\") + QString::number(nBytes));        // Bytes\n     l7->setText(fDust ? tr(\"yes\") : tr(\"no\"));                               // Dust\n     l8->setText(BitcoinUnits::formatWithUnit(nDisplayUnit, nChange));        // Change\n-    if (nPayFee > 0 && (coinControl->nMinimumTotalFee < nPayFee))\n+    if (nPayFee > 0)\n     {\n         l3->setText(ASYMP_UTF8 + l3->text());\n         l4->setText(ASYMP_UTF8 + l4->text());\n@@ -592,7 +588,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n     if (payTxFee.GetFeePerK() > 0)\n         dFeeVary = (double)std::max(CWallet::GetRequiredFee(1000), payTxFee.GetFeePerK()) / 1000;\n     else {\n-        dFeeVary = (double)std::max(CWallet::GetRequiredFee(1000), mempool.estimateSmartFee(nTxConfirmTarget).GetFeePerK()) / 1000;\n+        dFeeVary = (double)std::max(CWallet::GetRequiredFee(1000), ::feeEstimator.estimateSmartFee(nTxConfirmTarget, NULL, ::mempool).GetFeePerK()) / 1000;\n     }\n     QString toolTip4 = tr(\"Can vary +/- %1 satoshi(s) per input.\").arg(dFeeVary);\n "
      },
      {
        "sha": "0f1b3f4a732578e7ef7a6c6b22a5d3199603327b",
        "filename": "src/qt/forms/optionsdialog.ui",
        "status": "modified",
        "additions": 70,
        "deletions": 32,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/forms/optionsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/forms/optionsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/optionsdialog.ui?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -692,17 +692,34 @@\n    <item>\n     <layout class=\"QHBoxLayout\" name=\"horizontalLayout_Buttons\">\n      <item>\n-      <widget class=\"QPushButton\" name=\"resetButton\">\n-       <property name=\"toolTip\">\n-        <string>Reset all client options to default.</string>\n-       </property>\n-       <property name=\"text\">\n-        <string>&amp;Reset Options</string>\n-       </property>\n-       <property name=\"autoDefault\">\n-        <bool>false</bool>\n-       </property>\n-      </widget>\n+      <layout class=\"QVBoxLayout\" name=\"verticalLayout_Buttons\">\n+       <item>\n+        <widget class=\"QPushButton\" name=\"openBitcoinConfButton\">\n+         <property name=\"toolTip\">\n+          <string>Open the %1 configuration file from the working directory.</string>\n+         </property>\n+         <property name=\"text\">\n+          <string>Open Configuration File</string>\n+         </property>\n+         <property name=\"autoDefault\">\n+          <bool>false</bool>\n+         </property>\n+        </widget>\n+       </item>\n+       <item>\n+        <widget class=\"QPushButton\" name=\"resetButton\">\n+         <property name=\"toolTip\">\n+          <string>Reset all client options to default.</string>\n+         </property>\n+         <property name=\"text\">\n+          <string>&amp;Reset Options</string>\n+         </property>\n+         <property name=\"autoDefault\">\n+          <bool>false</bool>\n+         </property>\n+        </widget>\n+       </item>\n+      </layout>\n      </item>\n      <item>\n       <spacer name=\"horizontalSpacer_1\">\n@@ -756,27 +773,48 @@\n       </spacer>\n      </item>\n      <item>\n-      <widget class=\"QPushButton\" name=\"okButton\">\n-       <property name=\"text\">\n-        <string>&amp;OK</string>\n-       </property>\n-       <property name=\"autoDefault\">\n-        <bool>false</bool>\n-       </property>\n-       <property name=\"default\">\n-        <bool>true</bool>\n-       </property>\n-      </widget>\n-     </item>\n-     <item>\n-      <widget class=\"QPushButton\" name=\"cancelButton\">\n-       <property name=\"text\">\n-        <string>&amp;Cancel</string>\n-       </property>\n-       <property name=\"autoDefault\">\n-        <bool>false</bool>\n-       </property>\n-      </widget>\n+      <layout class=\"QVBoxLayout\" name=\"verticalLayout_4\">\n+       <item>\n+        <spacer name=\"verticalSpacer\">\n+         <property name=\"orientation\">\n+          <enum>Qt::Vertical</enum>\n+         </property>\n+         <property name=\"sizeHint\" stdset=\"0\">\n+          <size>\n+           <width>20</width>\n+           <height>40</height>\n+          </size>\n+         </property>\n+        </spacer>\n+       </item>\n+       <item>\n+        <layout class=\"QHBoxLayout\" name=\"horizontalLayout\">\n+         <item>\n+          <widget class=\"QPushButton\" name=\"okButton\">\n+           <property name=\"text\">\n+            <string>&amp;OK</string>\n+           </property>\n+           <property name=\"autoDefault\">\n+            <bool>false</bool>\n+           </property>\n+           <property name=\"default\">\n+            <bool>true</bool>\n+           </property>\n+          </widget>\n+         </item>\n+         <item>\n+          <widget class=\"QPushButton\" name=\"cancelButton\">\n+           <property name=\"text\">\n+            <string>&amp;Cancel</string>\n+           </property>\n+           <property name=\"autoDefault\">\n+            <bool>false</bool>\n+           </property>\n+          </widget>\n+         </item>\n+        </layout>\n+       </item>\n+      </layout>\n      </item>\n     </layout>\n    </item>"
      },
      {
        "sha": "89f9c25d143697f8a61317d0307d38eafd745acb",
        "filename": "src/qt/forms/sendcoinsdialog.ui",
        "status": "modified",
        "additions": 1,
        "deletions": 14,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/forms/sendcoinsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/forms/sendcoinsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/sendcoinsdialog.ui?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -861,19 +861,6 @@\n                    </attribute>\n                   </widget>\n                  </item>\n-                 <item>\n-                  <widget class=\"QRadioButton\" name=\"radioCustomAtLeast\">\n-                   <property name=\"toolTip\">\n-                    <string>If the custom fee is set to 1000 satoshis and the transaction is only 250 bytes, then &quot;per kilobyte&quot; only pays 250 satoshis in fee, while &quot;total at least&quot; pays 1000 satoshis. For transactions bigger than a kilobyte both pay by kilobyte.</string>\n-                   </property>\n-                   <property name=\"text\">\n-                    <string>total at least</string>\n-                   </property>\n-                   <attribute name=\"buttonGroup\">\n-                    <string notr=\"true\">groupCustomFee</string>\n-                   </attribute>\n-                  </widget>\n-                 </item>\n                  <item>\n                   <widget class=\"BitcoinAmountField\" name=\"customFee\"/>\n                  </item>\n@@ -1235,7 +1222,7 @@\n         <bool>false</bool>\n        </property>\n        <property name=\"default\">\n-        <bool>true</bool>\n+        <bool>false</bool>\n        </property>\n       </widget>\n      </item>"
      },
      {
        "sha": "bffa81137b230c5e2fb5292b53d41b776e1494c1",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 43,
        "deletions": 28,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -9,6 +9,7 @@\n #include \"qvalidatedlineedit.h\"\n #include \"walletmodel.h\"\n \n+#include \"fs.h\"\n #include \"primitives/transaction.h\"\n #include \"init.h\"\n #include \"policy/policy.h\"\n@@ -35,9 +36,6 @@\n #include \"shlwapi.h\"\n #endif\n \n-#include <boost/filesystem.hpp>\n-#include <boost/filesystem/fstream.hpp>\n-#include <boost/filesystem/detail/utf8_codecvt_facet.hpp>\n #include <boost/scoped_array.hpp>\n \n #include <QAbstractItemView>\n@@ -65,7 +63,7 @@\n #include <QFontDatabase>\n #endif\n \n-static boost::filesystem::detail::utf8_codecvt_facet utf8;\n+static fs::detail::utf8_codecvt_facet utf8;\n \n #if defined(Q_OS_MAC)\n extern double NSAppKitVersionNumber;\n@@ -253,7 +251,7 @@ bool isDust(const QString& address, const CAmount& amount)\n     CTxDestination dest = CBitcoinAddress(address.toStdString()).Get();\n     CScript script = GetScriptForDestination(dest);\n     CTxOut txOut(amount, script);\n-    return txOut.IsDust(dustRelayFee);\n+    return IsDust(txOut, ::dustRelayFee);\n }\n \n QString HtmlEscape(const QString& str, bool fMultiLine)\n@@ -410,13 +408,29 @@ bool isObscured(QWidget *w)\n \n void openDebugLogfile()\n {\n-    boost::filesystem::path pathDebug = GetDataDir() / \"debug.log\";\n+    fs::path pathDebug = GetDataDir() / \"debug.log\";\n \n     /* Open debug.log with the associated application */\n-    if (boost::filesystem::exists(pathDebug))\n+    if (fs::exists(pathDebug))\n         QDesktopServices::openUrl(QUrl::fromLocalFile(boostPathToQString(pathDebug)));\n }\n \n+bool openBitcoinConf()\n+{\n+    boost::filesystem::path pathConfig = GetConfigFile(BITCOIN_CONF_FILENAME);\n+\n+    /* Create the file */\n+    boost::filesystem::ofstream configFile(pathConfig, std::ios_base::app);\n+    \n+    if (!configFile.good())\n+        return false;\n+    \n+    configFile.close();\n+    \n+    /* Open bitcoin.conf with the associated application */\n+    return QDesktopServices::openUrl(QUrl::fromLocalFile(boostPathToQString(pathConfig)));\n+}\n+\n void SubstituteFonts(const QString& language)\n {\n #if defined(Q_OS_MAC)\n@@ -443,7 +457,7 @@ void SubstituteFonts(const QString& language)\n             /* 10.10 or later system */\n             if (language == \"zh_CN\" || language == \"zh_TW\" || language == \"zh_HK\") // traditional or simplified Chinese\n               QFont::insertSubstitution(\".Helvetica Neue DeskInterface\", \"Heiti SC\");\n-            else if (language == \"ja\") // Japanesee\n+            else if (language == \"ja\") // Japanese\n               QFont::insertSubstitution(\".Helvetica Neue DeskInterface\", \"Songti SC\");\n             else\n               QFont::insertSubstitution(\".Helvetica Neue DeskInterface\", \"Lucida Grande\");\n@@ -597,7 +611,7 @@ TableViewLastColumnResizingFixer::TableViewLastColumnResizingFixer(QTableView* t\n }\n \n #ifdef WIN32\n-boost::filesystem::path static StartupShortcutPath()\n+fs::path static StartupShortcutPath()\n {\n     std::string chain = ChainNameFromCommandLine();\n     if (chain == CBaseChainParams::MAIN)\n@@ -610,13 +624,13 @@ boost::filesystem::path static StartupShortcutPath()\n bool GetStartOnSystemStartup()\n {\n     // check for Bitcoin*.lnk\n-    return boost::filesystem::exists(StartupShortcutPath());\n+    return fs::exists(StartupShortcutPath());\n }\n \n bool SetStartOnSystemStartup(bool fAutoStart)\n {\n     // If the shortcut exists already, remove it for updating\n-    boost::filesystem::remove(StartupShortcutPath());\n+    fs::remove(StartupShortcutPath());\n \n     if (fAutoStart)\n     {\n@@ -686,18 +700,16 @@ bool SetStartOnSystemStartup(bool fAutoStart)\n // Follow the Desktop Application Autostart Spec:\n // http://standards.freedesktop.org/autostart-spec/autostart-spec-latest.html\n \n-boost::filesystem::path static GetAutostartDir()\n+fs::path static GetAutostartDir()\n {\n-    namespace fs = boost::filesystem;\n-\n     char* pszConfigHome = getenv(\"XDG_CONFIG_HOME\");\n     if (pszConfigHome) return fs::path(pszConfigHome) / \"autostart\";\n     char* pszHome = getenv(\"HOME\");\n     if (pszHome) return fs::path(pszHome) / \".config\" / \"autostart\";\n     return fs::path();\n }\n \n-boost::filesystem::path static GetAutostartFilePath()\n+fs::path static GetAutostartFilePath()\n {\n     std::string chain = ChainNameFromCommandLine();\n     if (chain == CBaseChainParams::MAIN)\n@@ -707,7 +719,7 @@ boost::filesystem::path static GetAutostartFilePath()\n \n bool GetStartOnSystemStartup()\n {\n-    boost::filesystem::ifstream optionFile(GetAutostartFilePath());\n+    fs::ifstream optionFile(GetAutostartFilePath());\n     if (!optionFile.good())\n         return false;\n     // Scan through file for \"Hidden=true\":\n@@ -727,17 +739,17 @@ bool GetStartOnSystemStartup()\n bool SetStartOnSystemStartup(bool fAutoStart)\n {\n     if (!fAutoStart)\n-        boost::filesystem::remove(GetAutostartFilePath());\n+        fs::remove(GetAutostartFilePath());\n     else\n     {\n         char pszExePath[MAX_PATH+1];\n         memset(pszExePath, 0, sizeof(pszExePath));\n         if (readlink(\"/proc/self/exe\", pszExePath, sizeof(pszExePath)-1) == -1)\n             return false;\n \n-        boost::filesystem::create_directories(GetAutostartDir());\n+        fs::create_directories(GetAutostartDir());\n \n-        boost::filesystem::ofstream optionFile(GetAutostartFilePath(), std::ios_base::out|std::ios_base::trunc);\n+        fs::ofstream optionFile(GetAutostartFilePath(), std::ios_base::out|std::ios_base::trunc);\n         if (!optionFile.good())\n             return false;\n         std::string chain = ChainNameFromCommandLine();\n@@ -843,14 +855,17 @@ void restoreWindowGeometry(const QString& strSetting, const QSize& defaultSize,\n     QPoint pos = settings.value(strSetting + \"Pos\").toPoint();\n     QSize size = settings.value(strSetting + \"Size\", defaultSize).toSize();\n \n-    if (!pos.x() && !pos.y()) {\n-        QRect screen = QApplication::desktop()->screenGeometry();\n-        pos.setX((screen.width() - size.width()) / 2);\n-        pos.setY((screen.height() - size.height()) / 2);\n-    }\n-\n     parent->resize(size);\n     parent->move(pos);\n+\n+    if ((!pos.x() && !pos.y()) || (QApplication::desktop()->screenNumber(parent) == -1))\n+    {\n+        QRect screen = QApplication::desktop()->screenGeometry();\n+        QPoint defaultPos((screen.width() - defaultSize.width()) / 2,\n+                          (screen.height() - defaultSize.height()) / 2);\n+        parent->resize(defaultSize);\n+        parent->move(defaultPos);\n+    }\n }\n \n void setClipboard(const QString& str)\n@@ -859,12 +874,12 @@ void setClipboard(const QString& str)\n     QApplication::clipboard()->setText(str, QClipboard::Selection);\n }\n \n-boost::filesystem::path qstringToBoostPath(const QString &path)\n+fs::path qstringToBoostPath(const QString &path)\n {\n-    return boost::filesystem::path(path.toStdString(), utf8);\n+    return fs::path(path.toStdString(), utf8);\n }\n \n-QString boostPathToQString(const boost::filesystem::path &path)\n+QString boostPathToQString(const fs::path &path)\n {\n     return QString::fromStdString(path.string(utf8));\n }"
      },
      {
        "sha": "d6aa8c4ea656c49b0810288035d762b12b432530",
        "filename": "src/qt/guiutil.h",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/guiutil.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/guiutil.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -6,6 +6,7 @@\n #define BITCOIN_QT_GUIUTIL_H\n \n #include \"amount.h\"\n+#include \"fs.h\"\n \n #include <QEvent>\n #include <QHeaderView>\n@@ -16,8 +17,6 @@\n #include <QTableView>\n #include <QLabel>\n \n-#include <boost/filesystem.hpp>\n-\n class QValidatedLineEdit;\n class SendCoinsRecipient;\n \n@@ -114,6 +113,9 @@ namespace GUIUtil\n     // Open debug.log\n     void openDebugLogfile();\n \n+    // Open the config file\n+    bool openBitcoinConf();\n+\n     // Replace invalid default fonts with known good ones\n     void SubstituteFonts(const QString& language);\n \n@@ -183,10 +185,10 @@ namespace GUIUtil\n     void restoreWindowGeometry(const QString& strSetting, const QSize &defaultSizeIn, QWidget *parent);\n \n     /* Convert QString to OS specific boost path through UTF-8 */\n-    boost::filesystem::path qstringToBoostPath(const QString &path);\n+    fs::path qstringToBoostPath(const QString &path);\n \n     /* Convert OS specific boost path to QString through UTF-8 */\n-    QString boostPathToQString(const boost::filesystem::path &path);\n+    QString boostPathToQString(const fs::path &path);\n \n     /* Convert seconds into a QString with days, hours, mins, secs */\n     QString formatDurationStr(int secs);"
      },
      {
        "sha": "2460a59109c505e5ab9dd187a9ee9cb0b5233c92",
        "filename": "src/qt/intro.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/intro.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/intro.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/intro.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -6,15 +6,14 @@\n #include \"config/bitcoin-config.h\"\n #endif\n \n+#include \"fs.h\"\n #include \"intro.h\"\n #include \"ui_intro.h\"\n \n #include \"guiutil.h\"\n \n #include \"util.h\"\n \n-#include <boost/filesystem.hpp>\n-\n #include <QFileDialog>\n #include <QSettings>\n #include <QMessageBox>\n@@ -70,7 +69,6 @@ FreespaceChecker::FreespaceChecker(Intro *_intro)\n \n void FreespaceChecker::check()\n {\n-    namespace fs = boost::filesystem;\n     QString dataDirStr = intro->getPathToCheck();\n     fs::path dataDir = GUIUtil::qstringToBoostPath(dataDirStr);\n     uint64_t freeBytesAvailable = 0;\n@@ -190,7 +188,6 @@ QString Intro::getDefaultDataDirectory()\n \n bool Intro::pickDataDirectory()\n {\n-    namespace fs = boost::filesystem;\n     QSettings settings;\n     /* If data directory provided on command line, no need to look at settings\n        or show a picking dialog */"
      },
      {
        "sha": "efb25aaf18d48d868bad7eaec52afad84bf1c5a7",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -232,6 +232,18 @@ void OptionsDialog::on_resetButton_clicked()\n     }\n }\n \n+void OptionsDialog::on_openBitcoinConfButton_clicked()\n+{\n+    /* explain the purpose of the config file */\n+    QMessageBox::information(this, tr(\"Configuration options\"),\n+        tr(\"The configuration file is used to specify advanced user options which override GUI settings. \"\n+           \"Additionally, any command-line options will override this configuration file.\"));\n+\n+    /* show an error if there was some problem opening the file */\n+    if (!GUIUtil::openBitcoinConf())\n+        QMessageBox::critical(this, tr(\"Error\"), tr(\"The configuration file could not be opened.\"));\n+}\n+\n void OptionsDialog::on_okButton_clicked()\n {\n     mapper->submit();"
      },
      {
        "sha": "f9f5823c051560c6a843949225cd5a54e766ba21",
        "filename": "src/qt/optionsdialog.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/optionsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/optionsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -47,6 +47,7 @@ private Q_SLOTS:\n     /* set OK button state (enabled / disabled) */\n     void setOkButtonState(bool fState);\n     void on_resetButton_clicked();\n+    void on_openBitcoinConfButton_clicked();\n     void on_okButton_clicked();\n     void on_cancelButton_clicked();\n     "
      },
      {
        "sha": "c31a7a478d6538810df6c33ed5983b88e7c26802",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -219,14 +219,16 @@ void PaymentServer::ipcParseCommandLine(int argc, char* argv[])\n             if (GUIUtil::parseBitcoinURI(arg, &r) && !r.address.isEmpty())\n             {\n                 CBitcoinAddress address(r.address.toStdString());\n+                auto tempChainParams = CreateChainParams(CBaseChainParams::MAIN);\n \n-                if (address.IsValid(Params(CBaseChainParams::MAIN)))\n+                if (address.IsValid(*tempChainParams))\n                 {\n                     SelectParams(CBaseChainParams::MAIN);\n                 }\n-                else if (address.IsValid(Params(CBaseChainParams::TESTNET)))\n-                {\n-                    SelectParams(CBaseChainParams::TESTNET);\n+                else {\n+                    tempChainParams = CreateChainParams(CBaseChainParams::TESTNET);\n+                    if (address.IsValid(*tempChainParams))\n+                        SelectParams(CBaseChainParams::TESTNET);\n                 }\n             }\n         }\n@@ -580,7 +582,7 @@ bool PaymentServer::processPaymentRequest(const PaymentRequestPlus& request, Sen\n \n         // Extract and check amounts\n         CTxOut txOut(sendingTo.second, sendingTo.first);\n-        if (txOut.IsDust(dustRelayFee)) {\n+        if (IsDust(txOut, ::dustRelayFee)) {\n             Q_EMIT message(tr(\"Payment request error\"), tr(\"Requested payment amount of %1 is too small (considered dust).\")\n                 .arg(BitcoinUnits::formatWithUnit(optionsModel->getDisplayUnit(), sendingTo.second)),\n                 CClientUIInterface::MSG_ERROR);"
      },
      {
        "sha": "fff072fd4c8cff26b9024cd28d6244d98f0ad719",
        "filename": "src/qt/peertablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/peertablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/peertablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablemodel.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -166,7 +166,7 @@ QVariant PeerTableModel::data(const QModelIndex &index, int role) const\n         switch(index.column())\n         {\n         case NetNodeId:\n-            return rec->nodeStats.nodeid;\n+            return (qint64)rec->nodeStats.nodeid;\n         case Address:\n             return QString::fromStdString(rec->nodeStats.addrName);\n         case Subversion:"
      },
      {
        "sha": "b200cb112717b73a6f8610192412bdffa09f7550",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 7,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -98,7 +98,7 @@ class QtRPCTimerBase: public QObject, public RPCTimerBase\n {\n     Q_OBJECT\n public:\n-    QtRPCTimerBase(boost::function<void(void)>& _func, int64_t millis):\n+    QtRPCTimerBase(std::function<void(void)>& _func, int64_t millis):\n         func(_func)\n     {\n         timer.setSingleShot(true);\n@@ -110,15 +110,15 @@ private Q_SLOTS:\n     void timeout() { func(); }\n private:\n     QTimer timer;\n-    boost::function<void(void)> func;\n+    std::function<void(void)> func;\n };\n \n class QtRPCTimerInterface: public RPCTimerInterface\n {\n public:\n     ~QtRPCTimerInterface() {}\n     const char *Name() { return \"Qt\"; }\n-    RPCTimerBase* NewTimer(boost::function<void(void)>& func, int64_t millis)\n+    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis)\n     {\n         return new QtRPCTimerBase(func, millis);\n     }\n@@ -175,6 +175,10 @@ bool RPCConsole::RPCParseCommandLine(std::string &strResult, const std::string &\n             nDepthInsideSensitive = 1;\n             filter_begin_pos = chpos;\n         }\n+        // Make sure stack is not empty before adding something\n+        if (stack.empty()) {\n+            stack.push_back(std::vector<std::string>());\n+        }\n         stack.back().push_back(strArg);\n     };\n \n@@ -626,9 +630,12 @@ void RPCConsole::setClientModel(ClientModel *model)\n         for (size_t i = 0; i < commandList.size(); ++i)\n         {\n             wordList << commandList[i].c_str();\n+            wordList << (\"help \" + commandList[i]).c_str();\n         }\n \n+        wordList.sort();\n         autoCompleter = new QCompleter(wordList, this);\n+        autoCompleter->setModelSorting(QCompleter::CaseSensitivelySortedModel);\n         ui->lineEdit->setCompleter(autoCompleter);\n         autoCompleter->popup()->installEventFilter(this);\n         // Start thread to execute RPC commands.\n@@ -723,8 +730,14 @@ void RPCConsole::clear(bool clearHistory)\n             ).arg(fixedFontInfo.family(), QString(\"%1pt\").arg(consoleFontSize))\n         );\n \n+#ifdef Q_OS_MAC\n+    QString clsKey = \"(\u2318)-L\";\n+#else\n+    QString clsKey = \"Ctrl-L\";\n+#endif\n+\t \n     message(CMD_REPLY, (tr(\"Welcome to the %1 RPC console.\").arg(tr(PACKAGE_NAME)) + \"<br>\" +\n-                        tr(\"Use up and down arrows to navigate history, and <b>Ctrl-L</b> to clear screen.\") + \"<br>\" +\n+                        tr(\"Use up and down arrows to navigate history, and %1 to clear screen.\").arg(\"<b>\"+clsKey+\"</b>\") + \"<br>\" +\n                         tr(\"Type <b>help</b> for an overview of available commands.\")) +\n                         \"<br><span class=\\\"secwarning\\\">\" +\n                         tr(\"WARNING: Scammers have been active, telling users to type commands here, stealing their wallet contents. Do not use this console without fully understanding the ramification of a command.\") +\n@@ -822,7 +835,7 @@ void RPCConsole::on_lineEdit_returnPressed()\n \n         cmdBeforeBrowsing = QString();\n \n-        message(CMD_REQUEST, cmd);\n+        message(CMD_REQUEST, QString::fromStdString(strFilteredCmd));\n         Q_EMIT cmdRequest(cmd);\n \n         cmd = QString::fromStdString(strFilteredCmd);\n@@ -1111,7 +1124,7 @@ void RPCConsole::disconnectSelectedNode()\n     for(int i = 0; i < nodes.count(); i++)\n     {\n         // Get currently selected peer address\n-        NodeId id = nodes.at(i).data().toInt();\n+        NodeId id = nodes.at(i).data().toLongLong();\n         // Find the node, disconnect it and clear the selected node\n         if(g_connman->DisconnectNode(id))\n             clearSelectedNode();\n@@ -1128,7 +1141,7 @@ void RPCConsole::banSelectedNode(int bantime)\n     for(int i = 0; i < nodes.count(); i++)\n     {\n         // Get currently selected peer address\n-        NodeId id = nodes.at(i).data().toInt();\n+        NodeId id = nodes.at(i).data().toLongLong();\n \n \t// Get currently selected peer address\n \tint detailNodeRow = clientModel->getPeerTableModel()->getRowByNodeId(id);"
      },
      {
        "sha": "272ab9486acef2b22c8e92b4d99589459910024e",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 28,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -21,6 +21,7 @@\n #include \"validation.h\" // mempool and minRelayTxFee\n #include \"ui_interface.h\"\n #include \"txmempool.h\"\n+#include \"policy/fees.h\"\n #include \"wallet/wallet.h\"\n \n #include <QFontMetrics>\n@@ -30,8 +31,6 @@\n #include <QTextDocument>\n #include <QTimer>\n \n-#define SEND_CONFIRM_DELAY   3\n-\n SendCoinsDialog::SendCoinsDialog(const PlatformStyle *_platformStyle, QWidget *parent) :\n     QDialog(parent),\n     ui(new Ui::SendCoinsDialog),\n@@ -110,11 +109,9 @@ SendCoinsDialog::SendCoinsDialog(const PlatformStyle *_platformStyle, QWidget *p\n     ui->groupFee->setId(ui->radioCustomFee, 1);\n     ui->groupFee->button((int)std::max(0, std::min(1, settings.value(\"nFeeRadio\").toInt())))->setChecked(true);\n     ui->groupCustomFee->setId(ui->radioCustomPerKilobyte, 0);\n-    ui->groupCustomFee->setId(ui->radioCustomAtLeast, 1);\n     ui->groupCustomFee->button((int)std::max(0, std::min(1, settings.value(\"nCustomFeeRadio\").toInt())))->setChecked(true);\n     ui->customFee->setValue(settings.value(\"nTransactionFee\").toLongLong());\n     ui->checkBoxMinimumFee->setChecked(settings.value(\"fPayOnlyMinFee\").toBool());\n-    ui->optInRBF->setCheckState(model->getDefaultWalletRbf() ? Qt::Checked : Qt::Unchecked);\n     minimizeFeeSection(settings.value(\"fFeeSectionMinimized\").toBool());\n }\n \n@@ -175,6 +172,9 @@ void SendCoinsDialog::setModel(WalletModel *_model)\n         updateSmartFeeLabel();\n         updateGlobalFeeVariables();\n \n+        // set default rbf checkbox state\n+        ui->optInRBF->setCheckState(model->getDefaultWalletRbf() ? Qt::Checked : Qt::Unchecked);\n+\n         // set the smartfee-sliders default value (wallets default conf.target or last stored value)\n         QSettings settings;\n         if (settings.value(\"nSmartFeeSliderPosition\").toInt() == 0)\n@@ -605,7 +605,6 @@ void SendCoinsDialog::updateFeeSectionControls()\n     ui->checkBoxMinimumFee      ->setEnabled(ui->radioCustomFee->isChecked());\n     ui->labelMinFeeWarning      ->setEnabled(ui->radioCustomFee->isChecked());\n     ui->radioCustomPerKilobyte  ->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked());\n-    ui->radioCustomAtLeast      ->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked() && CoinControlDialog::coinControl->HasSelected());\n     ui->customFee               ->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked());\n }\n \n@@ -616,19 +615,12 @@ void SendCoinsDialog::updateGlobalFeeVariables()\n         int nConfirmTarget = ui->sliderSmartFee->maximum() - ui->sliderSmartFee->value() + 2;\n         payTxFee = CFeeRate(0);\n \n-        // set nMinimumTotalFee to 0 to not accidentally pay a custom fee\n-        CoinControlDialog::coinControl->nMinimumTotalFee = 0;\n-\n         // show the estimated required time for confirmation\n         ui->confirmationTargetLabel->setText(GUIUtil::formatDurationStr(nConfirmTarget * Params().GetConsensus().nPowTargetSpacing) + \" / \" + tr(\"%n block(s)\", \"\", nConfirmTarget));\n     }\n     else\n     {\n         payTxFee = CFeeRate(ui->customFee->value());\n-\n-        // if user has selected to set a minimum absolute fee, pass the value to coincontrol\n-        // set nMinimumTotalFee to 0 in case of user has selected that the fee is per KB\n-        CoinControlDialog::coinControl->nMinimumTotalFee = ui->radioCustomAtLeast->isChecked() ? ui->customFee->value() : 0;\n     }\n }\n \n@@ -660,7 +652,7 @@ void SendCoinsDialog::updateSmartFeeLabel()\n \n     int nBlocksToConfirm = ui->sliderSmartFee->maximum() - ui->sliderSmartFee->value() + 2;\n     int estimateFoundAtBlocks = nBlocksToConfirm;\n-    CFeeRate feeRate = mempool.estimateSmartFee(nBlocksToConfirm, &estimateFoundAtBlocks);\n+    CFeeRate feeRate = ::feeEstimator.estimateSmartFee(nBlocksToConfirm, &estimateFoundAtBlocks, ::mempool);\n     if (feeRate <= CFeeRate(0)) // not enough data => minfee\n     {\n         ui->labelSmartFee->setText(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(),\n@@ -827,21 +819,6 @@ void SendCoinsDialog::coinControlUpdateLabels()\n     if (!model || !model->getOptionsModel())\n         return;\n \n-    if (model->getOptionsModel()->getCoinControlFeatures())\n-    {\n-        // enable minimum absolute fee UI controls\n-        ui->radioCustomAtLeast->setVisible(true);\n-\n-        // only enable the feature if inputs are selected\n-        ui->radioCustomAtLeast->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked() &&CoinControlDialog::coinControl->HasSelected());\n-    }\n-    else\n-    {\n-        // in case coin control is disabled (=default), hide minimum absolute fee UI controls\n-        ui->radioCustomAtLeast->setVisible(false);\n-        return;\n-    }\n-\n     // set pay amounts\n     CoinControlDialog::payAmounts.clear();\n     CoinControlDialog::fSubtractFeeFromAmount = false;"
      },
      {
        "sha": "a932f129bed7a78d4ba7d405df89ee752f4d1353",
        "filename": "src/qt/sendcoinsdialog.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/sendcoinsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/sendcoinsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -100,13 +100,14 @@ private Q_SLOTS:\n };\n \n \n+#define SEND_CONFIRM_DELAY   3\n \n class SendConfirmationDialog : public QMessageBox\n {\n     Q_OBJECT\n \n public:\n-    SendConfirmationDialog(const QString &title, const QString &text, int secDelay = 0, QWidget *parent = 0);\n+    SendConfirmationDialog(const QString &title, const QString &text, int secDelay = SEND_CONFIRM_DELAY, QWidget *parent = 0);\n     int exec();\n \n private Q_SLOTS:"
      },
      {
        "sha": "08a76c7d49632b2da1eac7254eabffc398935a2b",
        "filename": "src/qt/test/paymentservertests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/test/paymentservertests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/test/paymentservertests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/paymentservertests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -142,7 +142,7 @@ void PaymentServerTests::paymentServerTests()\n     byteArray = QByteArray((const char*)&data[0], data.size());\n     r.paymentRequest.parse(byteArray);\n     // Ensure the request is initialized, because network \"main\" is default, even for\n-    // uninizialized payment requests and that will fail our test here.\n+    // uninitialized payment requests and that will fail our test here.\n     QVERIFY(r.paymentRequest.IsInitialized());\n     QCOMPARE(PaymentServer::verifyNetwork(r.paymentRequest.getDetails()), false);\n "
      },
      {
        "sha": "dada689731094611f23f562a289138bf3842364b",
        "filename": "src/qt/test/rpcnestedtests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/test/rpcnestedtests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/test/rpcnestedtests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/rpcnestedtests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -6,6 +6,7 @@\n \n #include \"chainparams.h\"\n #include \"consensus/validation.h\"\n+#include \"fs.h\"\n #include \"validation.h\"\n #include \"rpc/register.h\"\n #include \"rpc/server.h\"\n@@ -17,8 +18,6 @@\n #include <QDir>\n #include <QtGlobal>\n \n-#include <boost/filesystem.hpp>\n-\n static UniValue rpcNestedTest_rpc(const JSONRPCRequest& request)\n {\n     if (request.fHelp) {\n@@ -156,5 +155,5 @@ void RPCNestedTests::rpcNestedTests()\n     delete pblocktree;\n     pblocktree = nullptr;\n \n-    boost::filesystem::remove_all(boost::filesystem::path(path));\n+    fs::remove_all(fs::path(path));\n }"
      },
      {
        "sha": "cae18f41a5c50bc67ad988ed0a33744a360d8cbe",
        "filename": "src/qt/test/test_main.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/test/test_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/test/test_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/test_main.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -31,6 +31,9 @@ Q_IMPORT_PLUGIN(qjpcodecs)\n Q_IMPORT_PLUGIN(qtwcodecs)\n Q_IMPORT_PLUGIN(qkrcodecs)\n #else\n+#if defined(QT_QPA_PLATFORM_MINIMAL)\n+Q_IMPORT_PLUGIN(QMinimalIntegrationPlugin);\n+#endif\n #if defined(QT_QPA_PLATFORM_XCB)\n Q_IMPORT_PLUGIN(QXcbIntegrationPlugin);\n #elif defined(QT_QPA_PLATFORM_WINDOWS)\n@@ -53,6 +56,11 @@ int main(int argc, char *argv[])\n \n     bool fInvalid = false;\n \n+    // Prefer the \"minimal\" platform for the test instead of the normal default\n+    // platform (\"xcb\", \"windows\", or \"cocoa\") so tests can't unintentially\n+    // interfere with any background GUIs and don't require extra resources.\n+    setenv(\"QT_QPA_PLATFORM\", \"minimal\", 0);\n+\n     // Don't remove this, it's needed to access\n     // QApplication:: and QCoreApplication:: in the tests\n     QApplication app(argc, argv);"
      },
      {
        "sha": "ff1eb59f16b7cb18b8dc9f4a407891de3de176a9",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 108,
        "deletions": 16,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,50 +1,76 @@\n #include \"wallettests.h\"\n \n #include \"qt/bitcoinamountfield.h\"\n+#include \"qt/callback.h\"\n #include \"qt/optionsmodel.h\"\n #include \"qt/platformstyle.h\"\n #include \"qt/qvalidatedlineedit.h\"\n #include \"qt/sendcoinsdialog.h\"\n #include \"qt/sendcoinsentry.h\"\n #include \"qt/transactiontablemodel.h\"\n+#include \"qt/transactionview.h\"\n #include \"qt/walletmodel.h\"\n #include \"test/test_bitcoin.h\"\n #include \"validation.h\"\n #include \"wallet/wallet.h\"\n \n #include <QAbstractButton>\n+#include <QAction>\n #include <QApplication>\n+#include <QCheckBox>\n+#include <QPushButton>\n #include <QTimer>\n #include <QVBoxLayout>\n \n namespace\n {\n-//! Press \"Yes\" button in modal send confirmation dialog.\n-void ConfirmSend()\n+//! Press \"Ok\" button in message box dialog.\n+void ConfirmMessage(QString* text = nullptr)\n {\n-    QTimer::singleShot(0, Qt::PreciseTimer, []() {\n+    QTimer::singleShot(0, makeCallback([text](Callback* callback) {\n+        for (QWidget* widget : QApplication::topLevelWidgets()) {\n+            if (widget->inherits(\"QMessageBox\")) {\n+                QMessageBox* messageBox = qobject_cast<QMessageBox*>(widget);\n+                if (text) *text = messageBox->text();\n+                messageBox->defaultButton()->click();\n+            }\n+        }\n+        delete callback;\n+    }), SLOT(call()));\n+}\n+\n+//! Press \"Yes\" or \"Cancel\" buttons in modal send confirmation dialog.\n+void ConfirmSend(QString* text = nullptr, bool cancel = false)\n+{\n+    QTimer::singleShot(0, makeCallback([text, cancel](Callback* callback) {\n         for (QWidget* widget : QApplication::topLevelWidgets()) {\n             if (widget->inherits(\"SendConfirmationDialog\")) {\n                 SendConfirmationDialog* dialog = qobject_cast<SendConfirmationDialog*>(widget);\n-                QAbstractButton* button = dialog->button(QMessageBox::Yes);\n+                if (text) *text = dialog->text();\n+                QAbstractButton* button = dialog->button(cancel ? QMessageBox::Cancel : QMessageBox::Yes);\n                 button->setEnabled(true);\n                 button->click();\n             }\n         }\n-    });\n+        delete callback;\n+    }), SLOT(call()));\n }\n \n //! Send coins to address and return txid.\n-uint256 SendCoins(CWallet& wallet, SendCoinsDialog& sendCoinsDialog, const CBitcoinAddress& address, CAmount amount)\n+uint256 SendCoins(CWallet& wallet, SendCoinsDialog& sendCoinsDialog, const CBitcoinAddress& address, CAmount amount, bool rbf)\n {\n     QVBoxLayout* entries = sendCoinsDialog.findChild<QVBoxLayout*>(\"entries\");\n     SendCoinsEntry* entry = qobject_cast<SendCoinsEntry*>(entries->itemAt(0)->widget());\n     entry->findChild<QValidatedLineEdit*>(\"payTo\")->setText(QString::fromStdString(address.ToString()));\n     entry->findChild<BitcoinAmountField*>(\"payAmount\")->setValue(amount);\n+    sendCoinsDialog.findChild<QFrame*>(\"frameFee\")\n+        ->findChild<QFrame*>(\"frameFeeSelection\")\n+        ->findChild<QCheckBox*>(\"optInRBF\")\n+        ->setCheckState(rbf ? Qt::Checked : Qt::Unchecked);\n     uint256 txid;\n-    boost::signals2::scoped_connection c = wallet.NotifyTransactionChanged.connect([&txid](CWallet*, const uint256& hash, ChangeType status) {\n+    boost::signals2::scoped_connection c(wallet.NotifyTransactionChanged.connect([&txid](CWallet*, const uint256& hash, ChangeType status) {\n         if (status == CT_NEW) txid = hash;\n-    });\n+    }));\n     ConfirmSend();\n     QMetaObject::invokeMethod(&sendCoinsDialog, \"on_sendButton_clicked\");\n     return txid;\n@@ -63,16 +89,67 @@ QModelIndex FindTx(const QAbstractItemModel& model, const uint256& txid)\n     }\n     return {};\n }\n+\n+//! Request context menu (call method that is public in qt5, but protected in qt4).\n+void RequestContextMenu(QWidget* widget)\n+{\n+    class Qt4Hack : public QWidget\n+    {\n+    public:\n+        using QWidget::customContextMenuRequested;\n+    };\n+    static_cast<Qt4Hack*>(widget)->customContextMenuRequested({});\n+}\n+\n+//! Invoke bumpfee on txid and check results.\n+void BumpFee(TransactionView& view, const uint256& txid, bool expectDisabled, std::string expectError, bool cancel)\n+{\n+    QTableView* table = view.findChild<QTableView*>(\"transactionView\");\n+    QModelIndex index = FindTx(*table->selectionModel()->model(), txid);\n+    QVERIFY2(index.isValid(), \"Could not find BumpFee txid\");\n+\n+    // Select row in table, invoke context menu, and make sure bumpfee action is\n+    // enabled or disabled as expected.\n+    QAction* action = view.findChild<QAction*>(\"bumpFeeAction\");\n+    table->selectionModel()->select(index, QItemSelectionModel::ClearAndSelect | QItemSelectionModel::Rows);\n+    action->setEnabled(expectDisabled);\n+    RequestContextMenu(table);\n+    QCOMPARE(action->isEnabled(), !expectDisabled);\n+\n+    action->setEnabled(true);\n+    QString text;\n+    if (expectError.empty()) {\n+        ConfirmSend(&text, cancel);\n+    } else {\n+        ConfirmMessage(&text);\n+    }\n+    action->trigger();\n+    QVERIFY(text.indexOf(QString::fromStdString(expectError)) != -1);\n }\n \n //! Simple qt wallet tests.\n-void WalletTests::walletTests()\n+//\n+// Test widgets can be debugged interactively calling show() on them and\n+// manually running the event loop, e.g.:\n+//\n+//     sendCoinsDialog.show();\n+//     QEventLoop().exec();\n+//\n+// This also requires overriding the default minimal Qt platform:\n+//\n+//     src/qt/test/test_bitcoin-qt -platform xcb      # Linux\n+//     src/qt/test/test_bitcoin-qt -platform windows  # Windows\n+//     src/qt/test/test_bitcoin-qt -platform cocoa    # macOS\n+void TestSendCoins()\n {\n-    // Set up wallet and chain with 101 blocks (1 mature block for spending).\n+    // Set up wallet and chain with 105 blocks (5 mature blocks for spending).\n     TestChain100Setup test;\n-    test.CreateAndProcessBlock({}, GetScriptForRawPubKey(test.coinbaseKey.GetPubKey()));\n+    for (int i = 0; i < 5; ++i) {\n+        test.CreateAndProcessBlock({}, GetScriptForRawPubKey(test.coinbaseKey.GetPubKey()));\n+    }\n     bitdb.MakeMock();\n-    CWallet wallet(\"wallet_test.dat\");\n+    std::unique_ptr<CWalletDBWrapper> dbw(new CWalletDBWrapper(&bitdb, \"wallet_test.dat\"));\n+    CWallet wallet(std::move(dbw));\n     bool firstRun;\n     wallet.LoadWallet(firstRun);\n     {\n@@ -86,19 +163,34 @@ void WalletTests::walletTests()\n     // Create widgets for sending coins and listing transactions.\n     std::unique_ptr<const PlatformStyle> platformStyle(PlatformStyle::instantiate(\"other\"));\n     SendCoinsDialog sendCoinsDialog(platformStyle.get());\n+    TransactionView transactionView(platformStyle.get());\n     OptionsModel optionsModel;\n     WalletModel walletModel(platformStyle.get(), &wallet, &optionsModel);\n     sendCoinsDialog.setModel(&walletModel);\n+    transactionView.setModel(&walletModel);\n \n     // Send two transactions, and verify they are added to transaction list.\n     TransactionTableModel* transactionTableModel = walletModel.getTransactionTableModel();\n-    QCOMPARE(transactionTableModel->rowCount({}), 101);\n-    uint256 txid1 = SendCoins(wallet, sendCoinsDialog, CBitcoinAddress(CKeyID()), 5 * COIN);\n-    uint256 txid2 = SendCoins(wallet, sendCoinsDialog, CBitcoinAddress(CKeyID()), 10 * COIN);\n-    QCOMPARE(transactionTableModel->rowCount({}), 103);\n+    QCOMPARE(transactionTableModel->rowCount({}), 105);\n+    uint256 txid1 = SendCoins(wallet, sendCoinsDialog, CBitcoinAddress(CKeyID()), 5 * COIN, false /* rbf */);\n+    uint256 txid2 = SendCoins(wallet, sendCoinsDialog, CBitcoinAddress(CKeyID()), 10 * COIN, true /* rbf */);\n+    QCOMPARE(transactionTableModel->rowCount({}), 107);\n     QVERIFY(FindTx(*transactionTableModel, txid1).isValid());\n     QVERIFY(FindTx(*transactionTableModel, txid2).isValid());\n \n+    // Call bumpfee. Test disabled, canceled, enabled, then failing cases.\n+    BumpFee(transactionView, txid1, true /* expect disabled */, \"not BIP 125 replaceable\" /* expected error */, false /* cancel */);\n+    BumpFee(transactionView, txid2, false /* expect disabled */, {} /* expected error */, true /* cancel */);\n+    BumpFee(transactionView, txid2, false /* expect disabled */, {} /* expected error */, false /* cancel */);\n+    BumpFee(transactionView, txid2, true /* expect disabled */, \"already bumped\" /* expected error */, false /* cancel */);\n+\n     bitdb.Flush(true);\n     bitdb.Reset();\n }\n+\n+}\n+\n+void WalletTests::walletTests()\n+{\n+    TestSendCoins();\n+}"
      },
      {
        "sha": "233fc08772170929ccb05c950bafde9edd3a17eb",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -273,7 +273,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n     //\n     // Debug view\n     //\n-    if (fDebug)\n+    if (logCategories != BCLog::NONE)\n     {\n         strHTML += \"<hr><br>\" + tr(\"Debug information\") + \"<br><br>\";\n         BOOST_FOREACH(const CTxIn& txin, wtx.tx->vin)\n@@ -293,13 +293,12 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n         {\n             COutPoint prevout = txin.prevout;\n \n-            CCoins prev;\n-            if(pcoinsTip->GetCoins(prevout.hash, prev))\n+            Coin prev;\n+            if(pcoinsTip->GetCoin(prevout, prev))\n             {\n-                if (prevout.n < prev.vout.size())\n                 {\n                     strHTML += \"<li>\";\n-                    const CTxOut &vout = prev.vout[prevout.n];\n+                    const CTxOut &vout = prev.out;\n                     CTxDestination address;\n                     if (ExtractDestination(vout.scriptPubKey, address))\n                     {"
      },
      {
        "sha": "0090b0c74bf5924267b222b7d5708cc122e8e195",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 10,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -18,14 +18,8 @@\n  */\n bool TransactionRecord::showTransaction(const CWalletTx &wtx)\n {\n-    if (wtx.IsCoinBase())\n-    {\n-        // Ensures we show generated coins / mined transactions at depth 1\n-        if (!wtx.IsInMainChain())\n-        {\n-            return false;\n-        }\n-    }\n+    // There are currently no cases where we hide transactions, but\n+    // we may want to use this in the future for things like RBF.\n     return true;\n }\n \n@@ -252,13 +246,13 @@ void TransactionRecord::updateStatus(const CWalletTx &wtx)\n             status.status = TransactionStatus::Confirmed;\n         }\n     }\n-\n+    status.needsUpdate = false;\n }\n \n bool TransactionRecord::statusUpdateNeeded()\n {\n     AssertLockHeld(cs_main);\n-    return status.cur_num_blocks != chainActive.Height();\n+    return status.cur_num_blocks != chainActive.Height() || status.needsUpdate;\n }\n \n QString TransactionRecord::getTxID() const"
      },
      {
        "sha": "59f681224fc995b8e5a610d3e107e672a5bc58b5",
        "filename": "src/qt/transactionrecord.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/transactionrecord.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/transactionrecord.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -61,6 +61,8 @@ class TransactionStatus\n \n     /** Current number of blocks (to know whether cached status is still valid) */\n     int cur_num_blocks;\n+\n+    bool needsUpdate;\n };\n \n /** UI model for a transaction. A core transaction can be represented by multiple UI transactions if it has"
      },
      {
        "sha": "f27abc2104cbfb566ca92c5007d9ac9e8d4959f8",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -168,6 +168,10 @@ class TransactionTablePriv\n         case CT_UPDATED:\n             // Miscellaneous updates -- nothing to do, status update will take care of this, and is only computed for\n             // visible transactions.\n+            for (int i = lowerIndex; i < upperIndex; i++) {\n+                TransactionRecord *rec = &cachedWallet[i];\n+                rec->status.needsUpdate = true;\n+            }\n             break;\n         }\n     }"
      },
      {
        "sha": "e3e070b27f3545d96498d27167854516b4709890",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 2,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -11,6 +11,7 @@\n #include \"guiutil.h\"\n #include \"optionsmodel.h\"\n #include \"platformstyle.h\"\n+#include \"sendcoinsdialog.h\"\n #include \"transactiondescdialog.h\"\n #include \"transactionfilterproxy.h\"\n #include \"transactionrecord.h\"\n@@ -37,7 +38,7 @@\n \n TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *parent) :\n     QWidget(parent), model(0), transactionProxyModel(0),\n-    transactionView(0), abandonAction(0), columnResizingFixer(0)\n+    transactionView(0), abandonAction(0), bumpFeeAction(0), columnResizingFixer(0)\n {\n     // Build filter row\n     setContentsMargins(0,0,0,0);\n@@ -135,9 +136,12 @@ TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *pa\n     view->installEventFilter(this);\n \n     transactionView = view;\n+    transactionView->setObjectName(\"transactionView\");\n \n     // Actions\n     abandonAction = new QAction(tr(\"Abandon transaction\"), this);\n+    bumpFeeAction = new QAction(tr(\"Increase transaction fee\"), this);\n+    bumpFeeAction->setObjectName(\"bumpFeeAction\");\n     QAction *copyAddressAction = new QAction(tr(\"Copy address\"), this);\n     QAction *copyLabelAction = new QAction(tr(\"Copy label\"), this);\n     QAction *copyAmountAction = new QAction(tr(\"Copy amount\"), this);\n@@ -148,6 +152,7 @@ TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *pa\n     QAction *showDetailsAction = new QAction(tr(\"Show transaction details\"), this);\n \n     contextMenu = new QMenu(this);\n+    contextMenu->setObjectName(\"contextMenu\");\n     contextMenu->addAction(copyAddressAction);\n     contextMenu->addAction(copyLabelAction);\n     contextMenu->addAction(copyAmountAction);\n@@ -156,6 +161,7 @@ TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *pa\n     contextMenu->addAction(copyTxPlainText);\n     contextMenu->addAction(showDetailsAction);\n     contextMenu->addSeparator();\n+    contextMenu->addAction(bumpFeeAction);\n     contextMenu->addAction(abandonAction);\n     contextMenu->addAction(editLabelAction);\n \n@@ -173,6 +179,7 @@ TransactionView::TransactionView(const PlatformStyle *platformStyle, QWidget *pa\n     connect(view, SIGNAL(doubleClicked(QModelIndex)), this, SIGNAL(doubleClicked(QModelIndex)));\n     connect(view, SIGNAL(customContextMenuRequested(QPoint)), this, SLOT(contextualMenu(QPoint)));\n \n+    connect(bumpFeeAction, SIGNAL(triggered()), this, SLOT(bumpFee()));\n     connect(abandonAction, SIGNAL(triggered()), this, SLOT(abandonTx()));\n     connect(copyAddressAction, SIGNAL(triggered()), this, SLOT(copyAddress()));\n     connect(copyLabelAction, SIGNAL(triggered()), this, SLOT(copyLabel()));\n@@ -372,10 +379,11 @@ void TransactionView::contextualMenu(const QPoint &point)\n     uint256 hash;\n     hash.SetHex(selection.at(0).data(TransactionTableModel::TxHashRole).toString().toStdString());\n     abandonAction->setEnabled(model->transactionCanBeAbandoned(hash));\n+    bumpFeeAction->setEnabled(model->transactionCanBeBumped(hash));\n \n     if(index.isValid())\n     {\n-        contextMenu->exec(QCursor::pos());\n+        contextMenu->popup(transactionView->viewport()->mapToGlobal(point));\n     }\n }\n \n@@ -397,6 +405,24 @@ void TransactionView::abandonTx()\n     model->getTransactionTableModel()->updateTransaction(hashQStr, CT_UPDATED, false);\n }\n \n+void TransactionView::bumpFee()\n+{\n+    if(!transactionView || !transactionView->selectionModel())\n+        return;\n+    QModelIndexList selection = transactionView->selectionModel()->selectedRows(0);\n+\n+    // get the hash from the TxHashRole (QVariant / QString)\n+    uint256 hash;\n+    QString hashQStr = selection.at(0).data(TransactionTableModel::TxHashRole).toString();\n+    hash.SetHex(hashQStr.toStdString());\n+\n+    // Bump tx fee over the walletModel\n+    if (model->bumpFee(hash)) {\n+        // Update the table\n+        model->getTransactionTableModel()->updateTransaction(hashQStr, CT_UPDATED, true);\n+    }\n+}\n+\n void TransactionView::copyAddress()\n {\n     GUIUtil::copyEntryData(transactionView, 0, TransactionTableModel::AddressRole);"
      },
      {
        "sha": "52e57cae4cf9486d98b7e55278d5ab44b4d32098",
        "filename": "src/qt/transactionview.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/transactionview.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/transactionview.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -76,6 +76,7 @@ class TransactionView : public QWidget\n     QDateTimeEdit *dateFrom;\n     QDateTimeEdit *dateTo;\n     QAction *abandonAction;\n+    QAction *bumpFeeAction;\n \n     QWidget *createDateRangeWidget();\n \n@@ -99,6 +100,7 @@ private Q_SLOTS:\n     void openThirdPartyTxUrl(QString url);\n     void updateWatchOnlyColumn(bool fHaveWatchOnly);\n     void abandonTx();\n+    void bumpFee();\n \n Q_SIGNALS:\n     void doubleClicked(const QModelIndex&);"
      },
      {
        "sha": "8df0e481bdb47d2a8d0a328b172e904f3ad1697a",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 91,
        "deletions": 49,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -8,23 +8,29 @@\n #include \"consensus/validation.h\"\n #include \"guiconstants.h\"\n #include \"guiutil.h\"\n+#include \"optionsmodel.h\"\n #include \"paymentserver.h\"\n #include \"recentrequeststablemodel.h\"\n+#include \"sendcoinsdialog.h\"\n #include \"transactiontablemodel.h\"\n \n #include \"base58.h\"\n+#include \"chain.h\"\n #include \"keystore.h\"\n #include \"validation.h\"\n #include \"net.h\" // for g_connman\n+#include \"policy/rbf.h\"\n #include \"sync.h\"\n #include \"ui_interface.h\"\n #include \"util.h\" // for GetBoolArg\n+#include \"wallet/feebumper.h\"\n #include \"wallet/wallet.h\"\n #include \"wallet/walletdb.h\" // for BackupWallet\n \n #include <stdint.h>\n \n #include <QDebug>\n+#include <QMessageBox>\n #include <QSet>\n #include <QTimer>\n \n@@ -62,14 +68,7 @@ CAmount WalletModel::getBalance(const CCoinControl *coinControl) const\n {\n     if (coinControl)\n     {\n-        CAmount nBalance = 0;\n-        std::vector<COutput> vCoins;\n-        wallet->AvailableCoins(vCoins, true, coinControl);\n-        BOOST_FOREACH(const COutput& out, vCoins)\n-            if(out.fSpendable)\n-                nBalance += out.tx->tx->vout[out.i].nValue;\n-\n-        return nBalance;\n+        return wallet->GetAvailableBalance(coinControl);\n     }\n \n     return wallet->GetBalance();\n@@ -594,38 +593,11 @@ bool WalletModel::isSpent(const COutPoint& outpoint) const\n // AvailableCoins + LockedCoins grouped by wallet address (put change in one group with wallet address)\n void WalletModel::listCoins(std::map<QString, std::vector<COutput> >& mapCoins) const\n {\n-    std::vector<COutput> vCoins;\n-    wallet->AvailableCoins(vCoins);\n-\n-    LOCK2(cs_main, wallet->cs_wallet); // ListLockedCoins, mapWallet\n-    std::vector<COutPoint> vLockedCoins;\n-    wallet->ListLockedCoins(vLockedCoins);\n-\n-    // add locked coins\n-    BOOST_FOREACH(const COutPoint& outpoint, vLockedCoins)\n-    {\n-        if (!wallet->mapWallet.count(outpoint.hash)) continue;\n-        int nDepth = wallet->mapWallet[outpoint.hash].GetDepthInMainChain();\n-        if (nDepth < 0) continue;\n-        COutput out(&wallet->mapWallet[outpoint.hash], outpoint.n, nDepth, true /* spendable */, true /* solvable */, true /* safe */);\n-        if (outpoint.n < out.tx->tx->vout.size() && wallet->IsMine(out.tx->tx->vout[outpoint.n]) == ISMINE_SPENDABLE)\n-            vCoins.push_back(out);\n-    }\n-\n-    BOOST_FOREACH(const COutput& out, vCoins)\n-    {\n-        COutput cout = out;\n-\n-        while (wallet->IsChange(cout.tx->tx->vout[cout.i]) && cout.tx->tx->vin.size() > 0 && wallet->IsMine(cout.tx->tx->vin[0]))\n-        {\n-            if (!wallet->mapWallet.count(cout.tx->tx->vin[0].prevout.hash)) break;\n-            cout = COutput(&wallet->mapWallet[cout.tx->tx->vin[0].prevout.hash], cout.tx->tx->vin[0].prevout.n, 0 /* depth */, true /* spendable */, true /* solvable */, true /* safe */);\n+    for (auto& group : wallet->ListCoins()) {\n+        auto& resultGroup = mapCoins[QString::fromStdString(CBitcoinAddress(group.first).ToString())];\n+        for (auto& coin : group.second) {\n+            resultGroup.emplace_back(std::move(coin));\n         }\n-\n-        CTxDestination address;\n-        if(!out.fSpendable || !ExtractDestination(cout.tx->tx->vout[cout.i].scriptPubKey, address))\n-            continue;\n-        mapCoins[QString::fromStdString(CBitcoinAddress(address).ToString())].push_back(out);\n     }\n }\n \n@@ -655,11 +627,7 @@ void WalletModel::listLockedCoins(std::vector<COutPoint>& vOutpts)\n \n void WalletModel::loadReceiveRequests(std::vector<std::string>& vReceiveRequests)\n {\n-    LOCK(wallet->cs_wallet);\n-    BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& item, wallet->mapAddressBook)\n-        BOOST_FOREACH(const PAIRTYPE(std::string, std::string)& item2, item.second.destdata)\n-            if (item2.first.size() > 2 && item2.first.substr(0,2) == \"rr\") // receive request\n-                vReceiveRequests.push_back(item2.second);\n+    vReceiveRequests = wallet->GetDestValues(\"rr\"); // receive request\n }\n \n bool WalletModel::saveReceiveRequest(const std::string &sAddress, const int64_t nId, const std::string &sRequest)\n@@ -679,11 +647,7 @@ bool WalletModel::saveReceiveRequest(const std::string &sAddress, const int64_t\n \n bool WalletModel::transactionCanBeAbandoned(uint256 hash) const\n {\n-    LOCK2(cs_main, wallet->cs_wallet);\n-    const CWalletTx *wtx = wallet->GetWalletTx(hash);\n-    if (!wtx || wtx->isAbandoned() || wtx->GetDepthInMainChain() > 0 || wtx->InMempool())\n-        return false;\n-    return true;\n+    return wallet->TransactionCanBeAbandoned(hash);\n }\n \n bool WalletModel::abandonTransaction(uint256 hash) const\n@@ -692,6 +656,84 @@ bool WalletModel::abandonTransaction(uint256 hash) const\n     return wallet->AbandonTransaction(hash);\n }\n \n+bool WalletModel::transactionCanBeBumped(uint256 hash) const\n+{\n+    LOCK2(cs_main, wallet->cs_wallet);\n+    const CWalletTx *wtx = wallet->GetWalletTx(hash);\n+    return wtx && SignalsOptInRBF(*wtx) && !wtx->mapValue.count(\"replaced_by_txid\");\n+}\n+\n+bool WalletModel::bumpFee(uint256 hash)\n+{\n+    std::unique_ptr<CFeeBumper> feeBump;\n+    {\n+        LOCK2(cs_main, wallet->cs_wallet);\n+        feeBump.reset(new CFeeBumper(wallet, hash, nTxConfirmTarget, false, 0, true));\n+    }\n+    if (feeBump->getResult() != BumpFeeResult::OK)\n+    {\n+        QMessageBox::critical(0, tr(\"Fee bump error\"), tr(\"Increasing transaction fee failed\") + \"<br />(\" +\n+            (feeBump->getErrors().size() ? QString::fromStdString(feeBump->getErrors()[0]) : \"\") +\")\");\n+         return false;\n+    }\n+\n+    // allow a user based fee verification\n+    QString questionString = tr(\"Do you want to increase the fee?\");\n+    questionString.append(\"<br />\");\n+    CAmount oldFee = feeBump->getOldFee();\n+    CAmount newFee = feeBump->getNewFee();\n+    questionString.append(\"<table style=\\\"text-align: left;\\\">\");\n+    questionString.append(\"<tr><td>\");\n+    questionString.append(tr(\"Current fee:\"));\n+    questionString.append(\"</td><td>\");\n+    questionString.append(BitcoinUnits::formatHtmlWithUnit(getOptionsModel()->getDisplayUnit(), oldFee));\n+    questionString.append(\"</td></tr><tr><td>\");\n+    questionString.append(tr(\"Increase:\"));\n+    questionString.append(\"</td><td>\");\n+    questionString.append(BitcoinUnits::formatHtmlWithUnit(getOptionsModel()->getDisplayUnit(), newFee - oldFee));\n+    questionString.append(\"</td></tr><tr><td>\");\n+    questionString.append(tr(\"New fee:\"));\n+    questionString.append(\"</td><td>\");\n+    questionString.append(BitcoinUnits::formatHtmlWithUnit(getOptionsModel()->getDisplayUnit(), newFee));\n+    questionString.append(\"</td></tr></table>\");\n+    SendConfirmationDialog confirmationDialog(tr(\"Confirm fee bump\"), questionString);\n+    confirmationDialog.exec();\n+    QMessageBox::StandardButton retval = (QMessageBox::StandardButton)confirmationDialog.result();\n+\n+    // cancel sign&broadcast if users doesn't want to bump the fee\n+    if (retval != QMessageBox::Yes) {\n+        return false;\n+    }\n+\n+    WalletModel::UnlockContext ctx(requestUnlock());\n+    if(!ctx.isValid())\n+    {\n+        return false;\n+    }\n+\n+    // sign bumped transaction\n+    bool res = false;\n+    {\n+        LOCK2(cs_main, wallet->cs_wallet);\n+        res = feeBump->signTransaction(wallet);\n+    }\n+    if (!res) {\n+        QMessageBox::critical(0, tr(\"Fee bump error\"), tr(\"Can't sign transaction.\"));\n+        return false;\n+    }\n+    // commit the bumped transaction\n+    {\n+        LOCK2(cs_main, wallet->cs_wallet);\n+        res = feeBump->commit(wallet);\n+    }\n+    if(!res) {\n+        QMessageBox::critical(0, tr(\"Fee bump error\"), tr(\"Could not commit transaction\") + \"<br />(\" +\n+            QString::fromStdString(feeBump->getErrors()[0])+\")\");\n+         return false;\n+    }\n+    return true;\n+}\n+\n bool WalletModel::isWalletEnabled()\n {\n    return !GetBoolArg(\"-disablewallet\", DEFAULT_DISABLE_WALLET);"
      },
      {
        "sha": "16b0caed4efa99f7f98fdc5cb31bde65c2d1f96b",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -207,6 +207,9 @@ class WalletModel : public QObject\n     bool transactionCanBeAbandoned(uint256 hash) const;\n     bool abandonTransaction(uint256 hash) const;\n \n+    bool transactionCanBeBumped(uint256 hash) const;\n+    bool bumpFee(uint256 hash);\n+\n     static bool isWalletEnabled();\n \n     bool hdEnabled() const;"
      },
      {
        "sha": "e1ccfa5f2404a961f6bedde6a594ed30969d2015",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 117,
        "deletions": 24,
        "changes": 141,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -16,6 +16,8 @@\n \n #include <stdlib.h>\n #include <limits>\n+#include <chrono>\n+#include <thread>\n \n #ifndef WIN32\n #include <sys/time.h>\n@@ -32,6 +34,8 @@\n #include <sys/sysctl.h>\n #endif\n \n+#include <mutex>\n+\n #include <openssl/err.h>\n #include <openssl/rand.h>\n \n@@ -43,15 +47,22 @@ static void RandFailure()\n \n static inline int64_t GetPerformanceCounter()\n {\n-    int64_t nCounter = 0;\n-#ifdef WIN32\n-    QueryPerformanceCounter((LARGE_INTEGER*)&nCounter);\n+    // Read the hardware time stamp counter when available.\n+    // See https://en.wikipedia.org/wiki/Time_Stamp_Counter for more information.\n+#if defined(_MSC_VER) && (defined(_M_IX86) || defined(_M_X64))\n+    return __rdtsc();\n+#elif !defined(_MSC_VER) && defined(__i386__)\n+    uint64_t r = 0;\n+    __asm__ volatile (\"rdtsc\" : \"=A\"(r)); // Constrain the r variable to the eax:edx pair.\n+    return r;\n+#elif !defined(_MSC_VER) && (defined(__x86_64__) || defined(__amd64__))\n+    uint64_t r1 = 0, r2 = 0;\n+    __asm__ volatile (\"rdtsc\" : \"=a\"(r1), \"=d\"(r2)); // Constrain r1 to rax and r2 to rdx.\n+    return (r2 << 32) | r1;\n #else\n-    timeval t;\n-    gettimeofday(&t, NULL);\n-    nCounter = (int64_t)(t.tv_sec * 1000000 + t.tv_usec);\n+    // Fall back to using C++11 clock (usually microsecond or nanosecond precision)\n+    return std::chrono::high_resolution_clock::now().time_since_epoch().count();\n #endif\n-    return nCounter;\n }\n \n void RandAddSeed()\n@@ -91,7 +102,7 @@ static void RandAddSeedPerfmon()\n     if (ret == ERROR_SUCCESS) {\n         RAND_add(vData.data(), nSize, nSize / 100.0);\n         memory_cleanse(vData.data(), nSize);\n-        LogPrint(\"rand\", \"%s: %lu bytes\\n\", __func__, nSize);\n+        LogPrint(BCLog::RAND, \"%s: %lu bytes\\n\", __func__, nSize);\n     } else {\n         static bool warned = false; // Warn only once\n         if (!warned) {\n@@ -192,6 +203,43 @@ void GetRandBytes(unsigned char* buf, int num)\n     }\n }\n \n+static void AddDataToRng(void* data, size_t len);\n+\n+void RandAddSeedSleep()\n+{\n+    int64_t nPerfCounter1 = GetPerformanceCounter();\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+    int64_t nPerfCounter2 = GetPerformanceCounter();\n+\n+    // Combine with and update state\n+    AddDataToRng(&nPerfCounter1, sizeof(nPerfCounter1));\n+    AddDataToRng(&nPerfCounter2, sizeof(nPerfCounter2));\n+\n+    memory_cleanse(&nPerfCounter1, sizeof(nPerfCounter1));\n+    memory_cleanse(&nPerfCounter2, sizeof(nPerfCounter2));\n+}\n+\n+\n+static std::mutex cs_rng_state;\n+static unsigned char rng_state[32] = {0};\n+static uint64_t rng_counter = 0;\n+\n+static void AddDataToRng(void* data, size_t len) {\n+    CSHA512 hasher;\n+    hasher.Write((const unsigned char*)&len, sizeof(len));\n+    hasher.Write((const unsigned char*)data, len);\n+    unsigned char buf[64];\n+    {\n+        std::unique_lock<std::mutex> lock(cs_rng_state);\n+        hasher.Write(rng_state, sizeof(rng_state));\n+        hasher.Write((const unsigned char*)&rng_counter, sizeof(rng_counter));\n+        ++rng_counter;\n+        hasher.Finalize(buf);\n+        memcpy(rng_state, buf + 32, 32);\n+    }\n+    memory_cleanse(buf, 64);\n+}\n+\n void GetStrongRandBytes(unsigned char* out, int num)\n {\n     assert(num <= 32);\n@@ -207,8 +255,17 @@ void GetStrongRandBytes(unsigned char* out, int num)\n     GetOSRand(buf);\n     hasher.Write(buf, 32);\n \n+    // Combine with and update state\n+    {\n+        std::unique_lock<std::mutex> lock(cs_rng_state);\n+        hasher.Write(rng_state, sizeof(rng_state));\n+        hasher.Write((const unsigned char*)&rng_counter, sizeof(rng_counter));\n+        ++rng_counter;\n+        hasher.Finalize(buf);\n+        memcpy(rng_state, buf + 32, 32);\n+    }\n+\n     // Produce output\n-    hasher.Finalize(buf);\n     memcpy(out, buf, num);\n     memory_cleanse(buf, 64);\n }\n@@ -240,26 +297,42 @@ uint256 GetRandHash()\n     return hash;\n }\n \n-FastRandomContext::FastRandomContext(bool fDeterministic)\n+void FastRandomContext::RandomSeed()\n {\n-    // The seed values have some unlikely fixed points which we avoid.\n-    if (fDeterministic) {\n-        Rz = Rw = 11;\n-    } else {\n-        uint32_t tmp;\n-        do {\n-            GetRandBytes((unsigned char*)&tmp, 4);\n-        } while (tmp == 0 || tmp == 0x9068ffffU);\n-        Rz = tmp;\n-        do {\n-            GetRandBytes((unsigned char*)&tmp, 4);\n-        } while (tmp == 0 || tmp == 0x464fffffU);\n-        Rw = tmp;\n+    uint256 seed = GetRandHash();\n+    rng.SetKey(seed.begin(), 32);\n+    requires_seed = false;\n+}\n+\n+uint256 FastRandomContext::rand256()\n+{\n+    if (bytebuf_size < 32) {\n+        FillByteBuffer();\n+    }\n+    uint256 ret;\n+    memcpy(ret.begin(), bytebuf + 64 - bytebuf_size, 32);\n+    bytebuf_size -= 32;\n+    return ret;\n+}\n+\n+std::vector<unsigned char> FastRandomContext::randbytes(size_t len)\n+{\n+    std::vector<unsigned char> ret(len);\n+    if (len > 0) {\n+        rng.Output(&ret[0], len);\n     }\n+    return ret;\n+}\n+\n+FastRandomContext::FastRandomContext(const uint256& seed) : requires_seed(false), bytebuf_size(0), bitbuf_size(0)\n+{\n+    rng.SetKey(seed.begin(), 32);\n }\n \n bool Random_SanityCheck()\n {\n+    uint64_t start = GetPerformanceCounter();\n+\n     /* This does not measure the quality of randomness, but it does test that\n      * OSRandom() overwrites all 32 bytes of the output given a maximum\n      * number of tries.\n@@ -286,5 +359,25 @@ bool Random_SanityCheck()\n \n         tries += 1;\n     } while (num_overwritten < NUM_OS_RANDOM_BYTES && tries < MAX_TRIES);\n-    return (num_overwritten == NUM_OS_RANDOM_BYTES); /* If this failed, bailed out after too many tries */\n+    if (num_overwritten != NUM_OS_RANDOM_BYTES) return false; /* If this failed, bailed out after too many tries */\n+\n+    // Check that GetPerformanceCounter increases at least during a GetOSRand() call + 1ms sleep.\n+    std::this_thread::sleep_for(std::chrono::milliseconds(1));\n+    uint64_t stop = GetPerformanceCounter();\n+    if (stop == start) return false;\n+\n+    // We called GetPerformanceCounter. Use it as entropy.\n+    RAND_add((const unsigned char*)&start, sizeof(start), 1);\n+    RAND_add((const unsigned char*)&stop, sizeof(stop), 1);\n+\n+    return true;\n+}\n+\n+FastRandomContext::FastRandomContext(bool fDeterministic) : requires_seed(!fDeterministic), bytebuf_size(0), bitbuf_size(0)\n+{\n+    if (!fDeterministic) {\n+        return;\n+    }\n+    uint256 seed;\n+    rng.SetKey(seed.begin(), 32);\n }"
      },
      {
        "sha": "dcb74eadb5b79f5c176aec9efd068c21c2222dc8",
        "filename": "src/random.h",
        "status": "modified",
        "additions": 84,
        "deletions": 7,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -6,6 +6,8 @@\n #ifndef BITCOIN_RANDOM_H\n #define BITCOIN_RANDOM_H\n \n+#include \"crypto/chacha20.h\"\n+#include \"crypto/common.h\"\n #include \"uint256.h\"\n \n #include <stdint.h>\n@@ -21,6 +23,13 @@ uint64_t GetRand(uint64_t nMax);\n int GetRandInt(int nMax);\n uint256 GetRandHash();\n \n+/**\n+ * Add a little bit of randomness to the output of GetStrongRangBytes.\n+ * This sleeps for a millisecond, so should only be called when there is\n+ * no other work to be done.\n+ */\n+void RandAddSeedSleep();\n+\n /**\n  * Function to gather random data from multiple sources, failing whenever any\n  * of those source fail to provide a result.\n@@ -33,17 +42,85 @@ void GetStrongRandBytes(unsigned char* buf, int num);\n  * This class is not thread-safe.\n  */\n class FastRandomContext {\n+private:\n+    bool requires_seed;\n+    ChaCha20 rng;\n+\n+    unsigned char bytebuf[64];\n+    int bytebuf_size;\n+\n+    uint64_t bitbuf;\n+    int bitbuf_size;\n+\n+    void RandomSeed();\n+\n+    void FillByteBuffer()\n+    {\n+        if (requires_seed) {\n+            RandomSeed();\n+        }\n+        rng.Output(bytebuf, sizeof(bytebuf));\n+        bytebuf_size = sizeof(bytebuf);\n+    }\n+\n+    void FillBitBuffer()\n+    {\n+        bitbuf = rand64();\n+        bitbuf_size = 64;\n+    }\n+\n public:\n-    explicit FastRandomContext(bool fDeterministic=false);\n+    explicit FastRandomContext(bool fDeterministic = false);\n+\n+    /** Initialize with explicit seed (only for testing) */\n+    explicit FastRandomContext(const uint256& seed);\n \n-    uint32_t rand32() {\n-        Rz = 36969 * (Rz & 65535) + (Rz >> 16);\n-        Rw = 18000 * (Rw & 65535) + (Rw >> 16);\n-        return (Rw << 16) + Rz;\n+    /** Generate a random 64-bit integer. */\n+    uint64_t rand64()\n+    {\n+        if (bytebuf_size < 8) FillByteBuffer();\n+        uint64_t ret = ReadLE64(bytebuf + 64 - bytebuf_size);\n+        bytebuf_size -= 8;\n+        return ret;\n     }\n \n-    uint32_t Rz;\n-    uint32_t Rw;\n+    /** Generate a random (bits)-bit integer. */\n+    uint64_t randbits(int bits) {\n+        if (bits == 0) {\n+            return 0;\n+        } else if (bits > 32) {\n+            return rand64() >> (64 - bits);\n+        } else {\n+            if (bitbuf_size < bits) FillBitBuffer();\n+            uint64_t ret = bitbuf & (~(uint64_t)0 >> (64 - bits));\n+            bitbuf >>= bits;\n+            bitbuf_size -= bits;\n+            return ret;\n+        }\n+    }\n+\n+    /** Generate a random integer in the range [0..range). */\n+    uint64_t randrange(uint64_t range)\n+    {\n+        --range;\n+        int bits = CountBits(range);\n+        while (true) {\n+            uint64_t ret = randbits(bits);\n+            if (ret <= range) return ret;\n+        }\n+    }\n+\n+    /** Generate random bytes. */\n+    std::vector<unsigned char> randbytes(size_t len);\n+\n+    /** Generate a random 32-bit integer. */\n+    uint32_t rand32() { return randbits(32); }\n+\n+    /** generate a random uint256. */\n+    uint256 rand256();\n+\n+    /** Generate a random boolean. */\n+    bool randbool() { return randbits(1); }\n };\n \n /* Number of random bytes returned by GetOSRand."
      },
      {
        "sha": "b08d7153b1d0a91d1e1e3e003abff475dc36739c",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 27,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -5,10 +5,12 @@\n \n #include \"chain.h\"\n #include \"chainparams.h\"\n+#include \"core_io.h\"\n #include \"primitives/block.h\"\n #include \"primitives/transaction.h\"\n #include \"validation.h\"\n #include \"httpserver.h\"\n+#include \"rpc/blockchain.h\"\n #include \"rpc/server.h\"\n #include \"streams.h\"\n #include \"sync.h\"\n@@ -40,28 +42,24 @@ static const struct {\n };\n \n struct CCoin {\n-    uint32_t nTxVer; // Don't call this nVersion, that name has a special meaning inside IMPLEMENT_SERIALIZE\n     uint32_t nHeight;\n     CTxOut out;\n \n     ADD_SERIALIZE_METHODS;\n \n+    CCoin() : nHeight(0) {}\n+    CCoin(Coin&& in) : nHeight(in.nHeight), out(std::move(in.out)) {}\n+\n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action)\n     {\n-        READWRITE(nTxVer);\n+        uint32_t nTxVerDummy = 0;\n+        READWRITE(nTxVerDummy);\n         READWRITE(nHeight);\n         READWRITE(out);\n     }\n };\n \n-extern void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry);\n-extern UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool txDetails = false);\n-extern UniValue mempoolInfoToJSON();\n-extern UniValue mempoolToJSON(bool fVerbose = false);\n-extern void ScriptPubKeyToJSON(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex);\n-extern UniValue blockheaderToJSON(const CBlockIndex* blockindex);\n-\n static bool RESTERR(HTTPRequest* req, enum HTTPStatusCode status, std::string message)\n {\n     req->WriteHeader(\"Content-Type\", \"text/plain\");\n@@ -385,7 +383,7 @@ static bool rest_tx(HTTPRequest* req, const std::string& strURIPart)\n \n     case RF_JSON: {\n         UniValue objTx(UniValue::VOBJ);\n-        TxToJSON(*tx, hashBlock, objTx);\n+        TxToUniv(*tx, hashBlock, objTx);\n         std::string strJSON = objTx.write() + \"\\n\";\n         req->WriteHeader(\"Content-Type\", \"application/json\");\n         req->WriteReply(HTTP_OK, strJSON);\n@@ -514,22 +512,11 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n             view.SetBackend(viewMempool); // switch cache backend to db+mempool in case user likes to query mempool\n \n         for (size_t i = 0; i < vOutPoints.size(); i++) {\n-            CCoins coins;\n-            uint256 hash = vOutPoints[i].hash;\n             bool hit = false;\n-            if (view.GetCoins(hash, coins)) {\n-                mempool.pruneSpent(hash, coins);\n-                if (coins.IsAvailable(vOutPoints[i].n)) {\n-                    hit = true;\n-                    // Safe to index into vout here because IsAvailable checked if it's off the end of the array, or if\n-                    // n is valid but points to an already spent output (IsNull).\n-                    CCoin coin;\n-                    coin.nTxVer = coins.nVersion;\n-                    coin.nHeight = coins.nHeight;\n-                    coin.out = coins.vout.at(vOutPoints[i].n);\n-                    assert(!coin.out.IsNull());\n-                    outs.push_back(coin);\n-                }\n+            Coin coin;\n+            if (view.GetCoin(vOutPoints[i], coin) && !mempool.isSpent(vOutPoints[i])) {\n+                hit = true;\n+                outs.emplace_back(std::move(coin));\n             }\n \n             hits.push_back(hit);\n@@ -573,13 +560,12 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         UniValue utxos(UniValue::VARR);\n         BOOST_FOREACH (const CCoin& coin, outs) {\n             UniValue utxo(UniValue::VOBJ);\n-            utxo.push_back(Pair(\"txvers\", (int32_t)coin.nTxVer));\n             utxo.push_back(Pair(\"height\", (int32_t)coin.nHeight));\n             utxo.push_back(Pair(\"value\", ValueFromAmount(coin.out.nValue)));\n \n             // include the script in a json output\n             UniValue o(UniValue::VOBJ);\n-            ScriptPubKeyToJSON(coin.out.scriptPubKey, o, true);\n+            ScriptPubKeyToUniv(coin.out.scriptPubKey, o, true);\n             utxo.push_back(Pair(\"scriptPubKey\", o));\n             utxos.push_back(utxo);\n         }"
      },
      {
        "sha": "b66c1c2b64c79893cac1cbe506590dff1eb822cf",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 177,
        "deletions": 65,
        "changes": 242,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -3,13 +3,17 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"rpc/blockchain.h\"\n+\n #include \"amount.h\"\n #include \"chain.h\"\n #include \"chainparams.h\"\n #include \"checkpoints.h\"\n #include \"coins.h\"\n #include \"consensus/validation.h\"\n #include \"validation.h\"\n+#include \"core_io.h\"\n+#include \"policy/feerate.h\"\n #include \"policy/policy.h\"\n #include \"primitives/transaction.h\"\n #include \"rpc/server.h\"\n@@ -40,15 +44,7 @@ static std::condition_variable cond_blockchange;\n static CUpdatedBlock latestblock;\n \n extern void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry);\n-void ScriptPubKeyToJSON(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex);\n-\n-/**\n- * Get the difficulty of the net wrt to the given block index, or the chain tip if\n- * not provided.\n- *\n- * @return A floating point number that is a multiple of the main net minimum\n- * difficulty (4295032833 hashes).\n- */\n+\n double GetDifficulty(const CBlockIndex* blockindex)\n {\n     if (blockindex == NULL)\n@@ -106,7 +102,7 @@ UniValue blockheaderToJSON(const CBlockIndex* blockindex)\n     return result;\n }\n \n-UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool txDetails = false)\n+UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool txDetails)\n {\n     UniValue result(UniValue::VOBJ);\n     result.push_back(Pair(\"hash\", blockindex->GetBlockHash().GetHex()));\n@@ -128,7 +124,7 @@ UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool tx\n         if(txDetails)\n         {\n             UniValue objTx(UniValue::VOBJ);\n-            TxToJSON(*tx, uint256(), objTx);\n+            TxToUniv(*tx, uint256(), objTx);\n             txs.push_back(objTx);\n         }\n         else\n@@ -191,7 +187,7 @@ void RPCNotifyBlockChange(bool ibd, const CBlockIndex * pindex)\n         latestblock.hash = pindex->GetBlockHash();\n         latestblock.height = pindex->nHeight;\n     }\n-\tcond_blockchange.notify_all();\n+    cond_blockchange.notify_all();\n }\n \n UniValue waitfornewblock(const JSONRPCRequest& request)\n@@ -383,7 +379,7 @@ void entryToJSON(UniValue &info, const CTxMemPoolEntry &e)\n     info.push_back(Pair(\"depends\", depends));\n }\n \n-UniValue mempoolToJSON(bool fVerbose = false)\n+UniValue mempoolToJSON(bool fVerbose)\n {\n     if (fVerbose)\n     {\n@@ -417,6 +413,7 @@ UniValue getrawmempool(const JSONRPCRequest& request)\n         throw std::runtime_error(\n             \"getrawmempool ( verbose )\\n\"\n             \"\\nReturns all transaction ids in memory pool as a json array of string transaction ids.\\n\"\n+            \"\\nHint: use getmempoolentry to fetch a specific transaction from the mempool.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. verbose (boolean, optional, default=false) True for a json object, false for array of transaction ids\\n\"\n             \"\\nResult: (for verbose = false):\\n\"\n@@ -691,13 +688,16 @@ UniValue getblock(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"getblock \\\"blockhash\\\" ( verbose )\\n\"\n-            \"\\nIf verbose is false, returns a string that is serialized, hex-encoded data for block 'hash'.\\n\"\n-            \"If verbose is true, returns an Object with information about block <hash>.\\n\"\n+            \"getblock \\\"blockhash\\\" ( verbosity ) \\n\"\n+            \"\\nIf verbosity is 0, returns a string that is serialized, hex-encoded data for block 'hash'.\\n\"\n+            \"If verbosity is 1, returns an Object with information about block <hash>.\\n\"\n+            \"If verbosity is 2, returns an Object with information about block <hash> and information about each transaction. \\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"blockhash\\\"          (string, required) The block hash\\n\"\n-            \"2. verbose                (boolean, optional, default=true) true for a json object, false for the hex encoded data\\n\"\n-            \"\\nResult (for verbose = true):\\n\"\n+            \"2. verbosity              (numeric, optional, default=1) 0 for hex encoded data, 1 for a json object, and 2 for json object with transaction data\\n\"\n+            \"\\nResult (for verbosity = 0):\\n\"\n+            \"\\\"data\\\"             (string) A string that is serialized, hex-encoded data for block 'hash'.\\n\"\n+            \"\\nResult (for verbosity = 1):\\n\"\n             \"{\\n\"\n             \"  \\\"hash\\\" : \\\"hash\\\",     (string) the block hash (same as provided)\\n\"\n             \"  \\\"confirmations\\\" : n,   (numeric) The number of confirmations, or -1 if the block is not on the main chain\\n\"\n@@ -721,8 +721,14 @@ UniValue getblock(const JSONRPCRequest& request)\n             \"  \\\"previousblockhash\\\" : \\\"hash\\\",  (string) The hash of the previous block\\n\"\n             \"  \\\"nextblockhash\\\" : \\\"hash\\\"       (string) The hash of the next block\\n\"\n             \"}\\n\"\n-            \"\\nResult (for verbose=false):\\n\"\n-            \"\\\"data\\\"             (string) A string that is serialized, hex-encoded data for block 'hash'.\\n\"\n+            \"\\nResult (for verbosity = 2):\\n\"\n+            \"{\\n\"\n+            \"  ...,                     Same output as verbosity = 1.\\n\"\n+            \"  \\\"tx\\\" : [               (array of Objects) The transactions in the format of the getrawtransaction RPC. Different from verbosity = 1 \\\"tx\\\" result.\\n\"\n+            \"         ,...\\n\"\n+            \"  ],\\n\"\n+            \"  ,...                     Same output as verbosity = 1.\\n\"\n+            \"}\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"getblock\", \"\\\"00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09\\\"\")\n             + HelpExampleRpc(\"getblock\", \"\\\"00000000c937983704a73af28acdec37b049d214adbda81d7e2a3dd146f6ed09\\\"\")\n@@ -733,9 +739,13 @@ UniValue getblock(const JSONRPCRequest& request)\n     std::string strHash = request.params[0].get_str();\n     uint256 hash(uint256S(strHash));\n \n-    bool fVerbose = true;\n-    if (request.params.size() > 1)\n-        fVerbose = request.params[1].get_bool();\n+    int verbosity = 1;\n+    if (request.params.size() > 1) {\n+        if(request.params[1].isNum())\n+            verbosity = request.params[1].get_int();\n+        else\n+            verbosity = request.params[1].get_bool() ? 1 : 0;\n+    }\n \n     if (mapBlockIndex.count(hash) == 0)\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n@@ -754,15 +764,15 @@ UniValue getblock(const JSONRPCRequest& request)\n         // block).\n         throw JSONRPCError(RPC_MISC_ERROR, \"Block not found on disk\");\n \n-    if (!fVerbose)\n+    if (verbosity <= 0)\n     {\n         CDataStream ssBlock(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());\n         ssBlock << block;\n         std::string strHex = HexStr(ssBlock.begin(), ssBlock.end());\n         return strHex;\n     }\n \n-    return blockToJSON(block, pblockindex);\n+    return blockToJSON(block, pblockindex, verbosity >= 2);\n }\n \n struct CCoinsStats\n@@ -771,13 +781,32 @@ struct CCoinsStats\n     uint256 hashBlock;\n     uint64_t nTransactions;\n     uint64_t nTransactionOutputs;\n-    uint64_t nSerializedSize;\n+    uint64_t nBogoSize;\n     uint256 hashSerialized;\n+    uint64_t nDiskSize;\n     CAmount nTotalAmount;\n \n-    CCoinsStats() : nHeight(0), nTransactions(0), nTransactionOutputs(0), nSerializedSize(0), nTotalAmount(0) {}\n+    CCoinsStats() : nHeight(0), nTransactions(0), nTransactionOutputs(0), nBogoSize(0), nDiskSize(0), nTotalAmount(0) {}\n };\n \n+static void ApplyStats(CCoinsStats &stats, CHashWriter& ss, const uint256& hash, const std::map<uint32_t, Coin>& outputs)\n+{\n+    assert(!outputs.empty());\n+    ss << hash;\n+    ss << VARINT(outputs.begin()->second.nHeight * 2 + outputs.begin()->second.fCoinBase);\n+    stats.nTransactions++;\n+    for (const auto output : outputs) {\n+        ss << VARINT(output.first + 1);\n+        ss << *(const CScriptBase*)(&output.second.out.scriptPubKey);\n+        ss << VARINT(output.second.out.nValue);\n+        stats.nTransactionOutputs++;\n+        stats.nTotalAmount += output.second.out.nValue;\n+        stats.nBogoSize += 32 /* txid */ + 4 /* vout index */ + 4 /* height + coinbase */ + 8 /* amount */ +\n+                           2 /* scriptPubKey len */ + output.second.out.scriptPubKey.size() /* scriptPubKey */;\n+    }\n+    ss << VARINT(0);\n+}\n+\n //! Calculate statistics about the unspent transaction output set\n static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n {\n@@ -790,32 +819,29 @@ static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n         stats.nHeight = mapBlockIndex.find(stats.hashBlock)->second->nHeight;\n     }\n     ss << stats.hashBlock;\n-    CAmount nTotalAmount = 0;\n+    uint256 prevkey;\n+    std::map<uint32_t, Coin> outputs;\n     while (pcursor->Valid()) {\n         boost::this_thread::interruption_point();\n-        uint256 key;\n-        CCoins coins;\n-        if (pcursor->GetKey(key) && pcursor->GetValue(coins)) {\n-            stats.nTransactions++;\n-            ss << key;\n-            for (unsigned int i=0; i<coins.vout.size(); i++) {\n-                const CTxOut &out = coins.vout[i];\n-                if (!out.IsNull()) {\n-                    stats.nTransactionOutputs++;\n-                    ss << VARINT(i+1);\n-                    ss << out;\n-                    nTotalAmount += out.nValue;\n-                }\n+        COutPoint key;\n+        Coin coin;\n+        if (pcursor->GetKey(key) && pcursor->GetValue(coin)) {\n+            if (!outputs.empty() && key.hash != prevkey) {\n+                ApplyStats(stats, ss, prevkey, outputs);\n+                outputs.clear();\n             }\n-            stats.nSerializedSize += 32 + pcursor->GetValueSize();\n-            ss << VARINT(0);\n+            prevkey = key.hash;\n+            outputs[key.n] = std::move(coin);\n         } else {\n             return error(\"%s: unable to read value\", __func__);\n         }\n         pcursor->Next();\n     }\n+    if (!outputs.empty()) {\n+        ApplyStats(stats, ss, prevkey, outputs);\n+    }\n     stats.hashSerialized = ss.GetHash();\n-    stats.nTotalAmount = nTotalAmount;\n+    stats.nDiskSize = view->EstimateSize();\n     return true;\n }\n \n@@ -860,7 +886,7 @@ UniValue pruneblockchain(const JSONRPCRequest& request)\n     else if (height > chainHeight)\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Blockchain is shorter than the attempted prune height.\");\n     else if (height > chainHeight - MIN_BLOCKS_TO_KEEP) {\n-        LogPrint(\"rpc\", \"Attempt to prune blocks close to the tip.  Retaining the minimum number of blocks.\");\n+        LogPrint(BCLog::RPC, \"Attempt to prune blocks close to the tip.  Retaining the minimum number of blocks.\");\n         height = chainHeight - MIN_BLOCKS_TO_KEEP;\n     }\n \n@@ -881,8 +907,9 @@ UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n             \"  \\\"bestblock\\\": \\\"hex\\\",   (string) the best block hash hex\\n\"\n             \"  \\\"transactions\\\": n,      (numeric) The number of transactions\\n\"\n             \"  \\\"txouts\\\": n,            (numeric) The number of output transactions\\n\"\n-            \"  \\\"bytes_serialized\\\": n,  (numeric) The serialized size\\n\"\n-            \"  \\\"hash_serialized\\\": \\\"hash\\\",   (string) The serialized hash\\n\"\n+            \"  \\\"bogosize\\\": n,          (numeric) A meaningless metric for UTXO set size\\n\"\n+            \"  \\\"hash_serialized_2\\\": \\\"hash\\\", (string) The serialized hash\\n\"\n+            \"  \\\"disk_size\\\": n,         (numeric) The estimated size of the chainstate on disk\\n\"\n             \"  \\\"total_amount\\\": x.xxx          (numeric) The total amount\\n\"\n             \"}\\n\"\n             \"\\nExamples:\\n\"\n@@ -899,8 +926,9 @@ UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n         ret.push_back(Pair(\"bestblock\", stats.hashBlock.GetHex()));\n         ret.push_back(Pair(\"transactions\", (int64_t)stats.nTransactions));\n         ret.push_back(Pair(\"txouts\", (int64_t)stats.nTransactionOutputs));\n-        ret.push_back(Pair(\"bytes_serialized\", (int64_t)stats.nSerializedSize));\n-        ret.push_back(Pair(\"hash_serialized\", stats.hashSerialized.GetHex()));\n+        ret.push_back(Pair(\"bogosize\", (int64_t)stats.nBogoSize));\n+        ret.push_back(Pair(\"hash_serialized_2\", stats.hashSerialized.GetHex()));\n+        ret.push_back(Pair(\"disk_size\", stats.nDiskSize));\n         ret.push_back(Pair(\"total_amount\", ValueFromAmount(stats.nTotalAmount)));\n     } else {\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Unable to read UTXO set\");\n@@ -953,37 +981,37 @@ UniValue gettxout(const JSONRPCRequest& request)\n     std::string strHash = request.params[0].get_str();\n     uint256 hash(uint256S(strHash));\n     int n = request.params[1].get_int();\n+    COutPoint out(hash, n);\n     bool fMempool = true;\n     if (request.params.size() > 2)\n         fMempool = request.params[2].get_bool();\n \n-    CCoins coins;\n+    Coin coin;\n     if (fMempool) {\n         LOCK(mempool.cs);\n         CCoinsViewMemPool view(pcoinsTip, mempool);\n-        if (!view.GetCoins(hash, coins))\n+        if (!view.GetCoin(out, coin) || mempool.isSpent(out)) { // TODO: filtering spent coins should be done by the CCoinsViewMemPool\n             return NullUniValue;\n-        mempool.pruneSpent(hash, coins); // TODO: this should be done by the CCoinsViewMemPool\n+        }\n     } else {\n-        if (!pcoinsTip->GetCoins(hash, coins))\n+        if (!pcoinsTip->GetCoin(out, coin)) {\n             return NullUniValue;\n+        }\n     }\n-    if (n<0 || (unsigned int)n>=coins.vout.size() || coins.vout[n].IsNull())\n-        return NullUniValue;\n \n     BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n     CBlockIndex *pindex = it->second;\n     ret.push_back(Pair(\"bestblock\", pindex->GetBlockHash().GetHex()));\n-    if ((unsigned int)coins.nHeight == MEMPOOL_HEIGHT)\n+    if (coin.nHeight == MEMPOOL_HEIGHT) {\n         ret.push_back(Pair(\"confirmations\", 0));\n-    else\n-        ret.push_back(Pair(\"confirmations\", pindex->nHeight - coins.nHeight + 1));\n-    ret.push_back(Pair(\"value\", ValueFromAmount(coins.vout[n].nValue)));\n+    } else {\n+        ret.push_back(Pair(\"confirmations\", (int64_t)(pindex->nHeight - coin.nHeight + 1)));\n+    }\n+    ret.push_back(Pair(\"value\", ValueFromAmount(coin.out.nValue)));\n     UniValue o(UniValue::VOBJ);\n-    ScriptPubKeyToJSON(coins.vout[n].scriptPubKey, o, true);\n+    ScriptPubKeyToUniv(coin.out.scriptPubKey, o, true);\n     ret.push_back(Pair(\"scriptPubKey\", o));\n-    ret.push_back(Pair(\"version\", coins.nVersion));\n-    ret.push_back(Pair(\"coinbase\", coins.fCoinBase));\n+    ret.push_back(Pair(\"coinbase\", (bool)coin.fCoinBase));\n \n     return ret;\n }\n@@ -1064,6 +1092,17 @@ static UniValue BIP9SoftForkDesc(const Consensus::Params& consensusParams, Conse\n     rv.push_back(Pair(\"startTime\", consensusParams.vDeployments[id].nStartTime));\n     rv.push_back(Pair(\"timeout\", consensusParams.vDeployments[id].nTimeout));\n     rv.push_back(Pair(\"since\", VersionBitsTipStateSinceHeight(consensusParams, id)));\n+    if (THRESHOLD_STARTED == thresholdState)\n+    {\n+        UniValue statsUV(UniValue::VOBJ);\n+        BIP9Stats statsStruct = VersionBitsTipStatistics(consensusParams, id);\n+        statsUV.push_back(Pair(\"period\", statsStruct.period));\n+        statsUV.push_back(Pair(\"threshold\", statsStruct.threshold));\n+        statsUV.push_back(Pair(\"elapsed\", statsStruct.elapsed));\n+        statsUV.push_back(Pair(\"count\", statsStruct.count));\n+        statsUV.push_back(Pair(\"possible\", statsStruct.possible));\n+        rv.push_back(Pair(\"statistics\", statsUV));\n+    }\n     return rv;\n }\n \n@@ -1109,7 +1148,14 @@ UniValue getblockchaininfo(const JSONRPCRequest& request)\n             \"        \\\"bit\\\": xx,             (numeric) the bit (0-28) in the block version field used to signal this softfork (only for \\\"started\\\" status)\\n\"\n             \"        \\\"startTime\\\": xx,       (numeric) the minimum median time past of a block at which the bit gains its meaning\\n\"\n             \"        \\\"timeout\\\": xx,         (numeric) the median time past of a block at which the deployment is considered failed if not yet locked in\\n\"\n-            \"        \\\"since\\\": xx            (numeric) height of the first block to which the status applies\\n\"\n+            \"        \\\"since\\\": xx,           (numeric) height of the first block to which the status applies\\n\"\n+            \"        \\\"statistics\\\": {        (object) numeric statistics about BIP9 signalling for a softfork (only for \\\"started\\\" status)\\n\"\n+            \"           \\\"period\\\": xx,       (numeric) the length in blocks of the BIP9 signalling period \\n\"\n+            \"           \\\"threshold\\\": xx,    (numeric) the number of blocks with the version bit set required to activate the feature \\n\"\n+            \"           \\\"elapsed\\\": xx,      (numeric) the number of blocks elapsed since the beginning of the current period \\n\"\n+            \"           \\\"count\\\": xx,        (numeric) the number of blocks with the version bit set in the current period \\n\"\n+            \"           \\\"possible\\\": xx      (boolean) returns false if there are not enough blocks left in this period to pass activation threshold \\n\"\n+            \"        }\\n\"\n             \"     }\\n\"\n             \"  }\\n\"\n             \"}\\n\"\n@@ -1297,7 +1343,7 @@ UniValue getmempoolinfo(const JSONRPCRequest& request)\n             \"  \\\"bytes\\\": xxxxx,              (numeric) Sum of all virtual transaction sizes as defined in BIP 141. Differs from actual serialized size because witness data is discounted\\n\"\n             \"  \\\"usage\\\": xxxxx,              (numeric) Total memory usage for the mempool\\n\"\n             \"  \\\"maxmempool\\\": xxxxx,         (numeric) Maximum memory usage for the mempool\\n\"\n-            \"  \\\"mempoolminfee\\\": xxxxx       (numeric) Minimum fee for tx to be accepted\\n\"\n+            \"  \\\"mempoolminfee\\\": xxxxx       (numeric) Minimum feerate (\" + CURRENCY_UNIT + \" per KB) for tx to be accepted\\n\"\n             \"}\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"getmempoolinfo\", \"\")\n@@ -1420,13 +1466,79 @@ UniValue reconsiderblock(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n+UniValue getchaintxstats(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() > 2)\n+        throw std::runtime_error(\n+            \"getchaintxstats ( nblocks blockhash )\\n\"\n+            \"\\nCompute statistics about the total number and rate of transactions in the chain.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. nblocks      (numeric, optional) Size of the window in number of blocks (default: one month).\\n\"\n+            \"2. \\\"blockhash\\\"  (string, optional) The hash of the block that ends the window.\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"time\\\": xxxxx,        (numeric) The timestamp for the statistics in UNIX format.\\n\"\n+            \"  \\\"txcount\\\": xxxxx,     (numeric) The total number of transactions in the chain up to that point.\\n\"\n+            \"  \\\"txrate\\\": x.xx,       (numeric) The average rate of transactions per second in the window.\\n\"\n+            \"}\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"getchaintxstats\", \"\")\n+            + HelpExampleRpc(\"getchaintxstats\", \"2016\")\n+        );\n+\n+    const CBlockIndex* pindex;\n+    int blockcount = 30 * 24 * 60 * 60 / Params().GetConsensus().nPowTargetSpacing; // By default: 1 month\n+\n+    if (request.params.size() > 0 && !request.params[0].isNull()) {\n+        blockcount = request.params[0].get_int();\n+    }\n+\n+    bool havehash = request.params.size() > 1 && !request.params[1].isNull();\n+    uint256 hash;\n+    if (havehash) {\n+        hash = uint256S(request.params[1].get_str());\n+    }\n+\n+    {\n+        LOCK(cs_main);\n+        if (havehash) {\n+            auto it = mapBlockIndex.find(hash);\n+            if (it == mapBlockIndex.end()) {\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n+            }\n+            pindex = it->second;\n+            if (!chainActive.Contains(pindex)) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Block is not in main chain\");\n+            }\n+        } else {\n+            pindex = chainActive.Tip();\n+        }\n+    }\n+\n+    if (blockcount < 1 || blockcount >= pindex->nHeight) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid block count: should be between 1 and the block's height\");\n+    }\n+\n+    const CBlockIndex* pindexPast = pindex->GetAncestor(pindex->nHeight - blockcount);\n+    int nTimeDiff = pindex->GetMedianTimePast() - pindexPast->GetMedianTimePast();\n+    int nTxDiff = pindex->nChainTx - pindexPast->nChainTx;\n+\n+    UniValue ret(UniValue::VOBJ);\n+    ret.push_back(Pair(\"time\", (int64_t)pindex->nTime));\n+    ret.push_back(Pair(\"txcount\", (int64_t)pindex->nChainTx));\n+    ret.push_back(Pair(\"txrate\", ((double)nTxDiff) / nTimeDiff));\n+\n+    return ret;\n+}\n+\n static const CRPCCommand commands[] =\n { //  category              name                      actor (function)         okSafe argNames\n   //  --------------------- ------------------------  -----------------------  ------ ----------\n     { \"blockchain\",         \"getblockchaininfo\",      &getblockchaininfo,      true,  {} },\n+    { \"blockchain\",         \"getchaintxstats\",        &getchaintxstats,        true,  {\"nblocks\", \"blockhash\"} },\n     { \"blockchain\",         \"getbestblockhash\",       &getbestblockhash,       true,  {} },\n     { \"blockchain\",         \"getblockcount\",          &getblockcount,          true,  {} },\n-    { \"blockchain\",         \"getblock\",               &getblock,               true,  {\"blockhash\",\"verbose\"} },\n+    { \"blockchain\",         \"getblock\",               &getblock,               true,  {\"blockhash\",\"verbosity|verbose\"} },\n     { \"blockchain\",         \"getblockhash\",           &getblockhash,           true,  {\"height\"} },\n     { \"blockchain\",         \"getblockheader\",         &getblockheader,         true,  {\"blockhash\",\"verbose\"} },\n     { \"blockchain\",         \"getchaintips\",           &getchaintips,           true,  {} },"
      },
      {
        "sha": "c021441b0a731076f2d8014e1c4c82f9c103fa74",
        "filename": "src/rpc/blockchain.h",
        "status": "added",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/blockchain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/blockchain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -0,0 +1,40 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RPC_BLOCKCHAIN_H\n+#define BITCOIN_RPC_BLOCKCHAIN_H\n+\n+class CBlock;\n+class CBlockIndex;\n+class CScript;\n+class CTransaction;\n+class uint256;\n+class UniValue;\n+\n+/**\n+ * Get the difficulty of the net wrt to the given block index, or the chain tip if\n+ * not provided.\n+ *\n+ * @return A floating point number that is a multiple of the main net minimum\n+ * difficulty (4295032833 hashes).\n+ */\n+double GetDifficulty(const CBlockIndex* blockindex = nullptr);\n+\n+/** Callback for when block tip changed. */\n+void RPCNotifyBlockChange(bool ibd, const CBlockIndex *);\n+\n+/** Block description to JSON */\n+UniValue blockToJSON(const CBlock& block, const CBlockIndex* blockindex, bool txDetails = false);\n+\n+/** Mempool information to JSON */\n+UniValue mempoolInfoToJSON();\n+\n+/** Mempool to JSON */\n+UniValue mempoolToJSON(bool fVerbose = false);\n+\n+/** Block header to JSON */\n+UniValue blockheaderToJSON(const CBlockIndex* blockindex);\n+\n+#endif\n+"
      },
      {
        "sha": "8dd84e20c915a2b514e290c0dfa7039c9fc87100",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 3,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -77,13 +77,16 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"listunspent\", 0, \"minconf\" },\n     { \"listunspent\", 1, \"maxconf\" },\n     { \"listunspent\", 2, \"addresses\" },\n-    { \"getblock\", 1, \"verbose\" },\n+    { \"listunspent\", 4, \"query_options\" },\n+    { \"getblock\", 1, \"verbosity\" },\n     { \"getblockheader\", 1, \"verbose\" },\n+    { \"getchaintxstats\", 0, \"nblocks\" },\n     { \"gettransaction\", 1, \"include_watchonly\" },\n     { \"getrawtransaction\", 1, \"verbose\" },\n-    { \"createrawtransaction\", 0, \"transactions\" },\n+    { \"createrawtransaction\", 0, \"inputs\" },\n     { \"createrawtransaction\", 1, \"outputs\" },\n     { \"createrawtransaction\", 2, \"locktime\" },\n+    { \"createrawtransaction\", 3, \"optintorbf\" },\n     { \"signrawtransaction\", 1, \"prevtxs\" },\n     { \"signrawtransaction\", 2, \"privkeys\" },\n     { \"sendrawtransaction\", 1, \"allowhighfees\" },\n@@ -106,13 +109,21 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"getrawmempool\", 0, \"verbose\" },\n     { \"estimatefee\", 0, \"nblocks\" },\n     { \"estimatesmartfee\", 0, \"nblocks\" },\n-    { \"prioritisetransaction\", 1, \"fee_delta\" },\n+    { \"estimatesmartfee\", 1, \"conservative\" },\n+    { \"estimaterawfee\", 0, \"nblocks\" },\n+    { \"estimaterawfee\", 1, \"threshold\" },\n+    { \"estimaterawfee\", 2, \"horizon\" },\n+    { \"prioritisetransaction\", 1, \"priority_delta\" },\n+    { \"prioritisetransaction\", 2, \"fee_delta\" },\n     { \"setban\", 2, \"bantime\" },\n     { \"setban\", 3, \"absolute\" },\n     { \"setnetworkactive\", 0, \"state\" },\n     { \"getmempoolancestors\", 1, \"verbose\" },\n     { \"getmempooldescendants\", 1, \"verbose\" },\n     { \"bumpfee\", 1, \"options\" },\n+    { \"logging\", 0, \"include\" },\n+    { \"logging\", 1, \"exclude\" },\n+    { \"disconnectnode\", 1, \"nodeid\" },\n     // Echo with conversion (For testing only)\n     { \"echojson\", 0, \"arg0\" },\n     { \"echojson\", 1, \"arg1\" },"
      },
      {
        "sha": "d8c47023460d7ce6f48d890ed1aaba27f1d80e99",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 141,
        "deletions": 35,
        "changes": 176,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -15,7 +15,9 @@\n #include \"validation.h\"\n #include \"miner.h\"\n #include \"net.h\"\n+#include \"policy/fees.h\"\n #include \"pow.h\"\n+#include \"rpc/blockchain.h\"\n #include \"rpc/server.h\"\n #include \"txmempool.h\"\n #include \"util.h\"\n@@ -25,9 +27,6 @@\n #include <memory>\n #include <stdint.h>\n \n-#include <boost/assign/list_of.hpp>\n-#include <boost/shared_ptr.hpp>\n-\n #include <univalue.h>\n \n /**\n@@ -94,7 +93,7 @@ UniValue getnetworkhashps(const JSONRPCRequest& request)\n     return GetNetworkHashPS(request.params.size() > 0 ? request.params[0].get_int() : 120, request.params.size() > 1 ? request.params[1].get_int() : -1);\n }\n \n-UniValue generateBlocks(boost::shared_ptr<CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)\n+UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)\n {\n     static const int nInnerLoopCount = 0x10000;\n     int nHeightStart = 0;\n@@ -166,7 +165,7 @@ UniValue generate(const JSONRPCRequest& request)\n         nMaxTries = request.params[1].get_int();\n     }\n \n-    boost::shared_ptr<CReserveScript> coinbaseScript;\n+    std::shared_ptr<CReserveScript> coinbaseScript;\n     GetMainSignals().ScriptForMining(coinbaseScript);\n \n     // If the keypool is exhausted, no script is returned at all.  Catch this.\n@@ -207,7 +206,7 @@ UniValue generatetoaddress(const JSONRPCRequest& request)\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Error: Invalid address\");\n \n-    boost::shared_ptr<CReserveScript> coinbaseScript(new CReserveScript());\n+    std::shared_ptr<CReserveScript> coinbaseScript = std::make_shared<CReserveScript>();\n     coinbaseScript->reserveScript = GetScriptForDestination(address.Get());\n \n     return generateBlocks(coinbaseScript, nGenerate, nMaxTries, false);\n@@ -256,26 +255,31 @@ UniValue getmininginfo(const JSONRPCRequest& request)\n // NOTE: Unlike wallet RPC (which use BTC values), mining RPCs follow GBT (BIP 22) in using satoshi amounts\n UniValue prioritisetransaction(const JSONRPCRequest& request)\n {\n-    if (request.fHelp || request.params.size() != 2)\n+    if (request.fHelp || request.params.size() != 3)\n         throw std::runtime_error(\n-            \"prioritisetransaction <txid> <fee delta>\\n\"\n+            \"prioritisetransaction <txid> <priority delta> <fee delta>\\n\"\n             \"Accepts the transaction into mined blocks at a higher (or lower) priority\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"txid\\\"       (string, required) The transaction id.\\n\"\n-            \"2. fee_delta      (numeric, required) The fee value (in satoshis) to add (or subtract, if negative).\\n\"\n+            \"2. priority_delta (numeric, optional) Fee-independent priority adjustment. Not supported, so must be zero or null.\\n\"\n+            \"3. fee_delta      (numeric, required) The fee value (in satoshis) to add (or subtract, if negative).\\n\"\n             \"                  The fee is not actually paid, only the algorithm for selecting transactions into a block\\n\"\n             \"                  considers the transaction as it would have paid a higher (or lower) fee.\\n\"\n             \"\\nResult:\\n\"\n             \"true              (boolean) Returns true\\n\"\n             \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"prioritisetransaction\", \"\\\"txid\\\" 10000\")\n-            + HelpExampleRpc(\"prioritisetransaction\", \"\\\"txid\\\", 10000\")\n+            + HelpExampleCli(\"prioritisetransaction\", \"\\\"txid\\\" 0.0 10000\")\n+            + HelpExampleRpc(\"prioritisetransaction\", \"\\\"txid\\\", 0.0, 10000\")\n         );\n \n     LOCK(cs_main);\n \n     uint256 hash = ParseHashStr(request.params[0].get_str(), \"txid\");\n-    CAmount nAmount = request.params[1].get_int64();\n+    CAmount nAmount = request.params[2].get_int64();\n+\n+    if (!(request.params[1].isNull() || request.params[1].get_real() == 0)) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Priority is not supported, and adjustment thereof must be zero.\");\n+    }\n \n     mempool.PrioritiseTransaction(hash, nAmount);\n     return true;\n@@ -302,7 +306,7 @@ static UniValue BIP22ValidationResult(const CValidationState& state)\n }\n \n std::string gbt_vb_name(const Consensus::DeploymentPos pos) {\n-    const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n+    const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n     std::string s = vbinfo.name;\n     if (!vbinfo.gbt_force) {\n         s.insert(s.begin(), '!');\n@@ -514,7 +518,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n         // TODO: Maybe recheck connections/IBD and (if something wrong) send an expires-immediately template to stop miners?\n     }\n \n-    const struct BIP9DeploymentInfo& segwit_info = VersionBitsDeploymentInfo[Consensus::DEPLOYMENT_SEGWIT];\n+    const struct VBDeploymentInfo& segwit_info = VersionBitsDeploymentInfo[Consensus::DEPLOYMENT_SEGWIT];\n     // If the caller is indicating segwit support, then allow CreateNewBlock()\n     // to select witness transactions, after segwit activates (otherwise\n     // don't).\n@@ -628,7 +632,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n                 // FALL THROUGH to get vbavailable set...\n             case THRESHOLD_STARTED:\n             {\n-                const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n+                const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n                 vbavailable.push_back(Pair(gbt_vb_name(pos), consensusParams.vDeployments[pos].bit));\n                 if (setClientRules.find(vbinfo.name) == setClientRules.end()) {\n                     if (!vbinfo.gbt_force) {\n@@ -641,7 +645,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n             case THRESHOLD_ACTIVE:\n             {\n                 // Add to rules only\n-                const struct BIP9DeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n+                const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n                 aRules.push_back(gbt_vb_name(pos));\n                 if (setClientRules.find(vbinfo.name) == setClientRules.end()) {\n                     // Not supported by the client; make sure it's safe to proceed\n@@ -709,7 +713,7 @@ class submitblock_StateCatcher : public CValidationInterface\n     submitblock_StateCatcher(const uint256 &hashIn) : hash(hashIn), found(false), state() {}\n \n protected:\n-    virtual void BlockChecked(const CBlock& block, const CValidationState& stateIn) {\n+    void BlockChecked(const CBlock& block, const CValidationState& stateIn) override {\n         if (block.GetHash() != hash)\n             return;\n         found = true;\n@@ -719,7 +723,7 @@ class submitblock_StateCatcher : public CValidationInterface\n \n UniValue submitblock(const JSONRPCRequest& request)\n {\n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n         throw std::runtime_error(\n             \"submitblock \\\"hexdata\\\" ( \\\"jsonparametersobject\\\" )\\n\"\n             \"\\nAttempts to submit new block to network.\\n\"\n@@ -737,11 +741,17 @@ UniValue submitblock(const JSONRPCRequest& request)\n             + HelpExampleCli(\"submitblock\", \"\\\"mydata\\\"\")\n             + HelpExampleRpc(\"submitblock\", \"\\\"mydata\\\"\")\n         );\n+    }\n \n     std::shared_ptr<CBlock> blockptr = std::make_shared<CBlock>();\n     CBlock& block = *blockptr;\n-    if (!DecodeHexBlk(block, request.params[0].get_str()))\n+    if (!DecodeHexBlk(block, request.params[0].get_str())) {\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block decode failed\");\n+    }\n+\n+    if (block.vtx.empty() || !block.vtx[0]->IsCoinBase()) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block does not start with a coinbase\");\n+    }\n \n     uint256 hash = block.GetHash();\n     bool fBlockPresent = false;\n@@ -750,10 +760,12 @@ UniValue submitblock(const JSONRPCRequest& request)\n         BlockMap::iterator mi = mapBlockIndex.find(hash);\n         if (mi != mapBlockIndex.end()) {\n             CBlockIndex *pindex = mi->second;\n-            if (pindex->IsValid(BLOCK_VALID_SCRIPTS))\n+            if (pindex->IsValid(BLOCK_VALID_SCRIPTS)) {\n                 return \"duplicate\";\n-            if (pindex->nStatus & BLOCK_FAILED_MASK)\n+            }\n+            if (pindex->nStatus & BLOCK_FAILED_MASK) {\n                 return \"duplicate-invalid\";\n+            }\n             // Otherwise, we might only have the header - process the block before returning\n             fBlockPresent = true;\n         }\n@@ -771,14 +783,15 @@ UniValue submitblock(const JSONRPCRequest& request)\n     RegisterValidationInterface(&sc);\n     bool fAccepted = ProcessNewBlock(Params(), blockptr, true, NULL);\n     UnregisterValidationInterface(&sc);\n-    if (fBlockPresent)\n-    {\n-        if (fAccepted && !sc.found)\n+    if (fBlockPresent) {\n+        if (fAccepted && !sc.found) {\n             return \"duplicate-inconclusive\";\n+        }\n         return \"duplicate\";\n     }\n-    if (!sc.found)\n+    if (!sc.found) {\n         return \"inconclusive\";\n+    }\n     return BIP22ValidationResult(sc.state);\n }\n \n@@ -787,6 +800,7 @@ UniValue estimatefee(const JSONRPCRequest& request)\n     if (request.fHelp || request.params.size() != 1)\n         throw std::runtime_error(\n             \"estimatefee nblocks\\n\"\n+            \"\\nDEPRECATED. Please use estimatesmartfee for more intelligent estimates.\"\n             \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\n             \"confirmation within nblocks blocks. Uses virtual transaction size of transaction\\n\"\n             \"as defined in BIP 141 (witness data is discounted).\\n\"\n@@ -803,13 +817,13 @@ UniValue estimatefee(const JSONRPCRequest& request)\n             + HelpExampleCli(\"estimatefee\", \"6\")\n             );\n \n-    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VNUM));\n+    RPCTypeCheck(request.params, {UniValue::VNUM});\n \n     int nBlocks = request.params[0].get_int();\n     if (nBlocks < 1)\n         nBlocks = 1;\n \n-    CFeeRate feeRate = mempool.estimateFee(nBlocks);\n+    CFeeRate feeRate = ::feeEstimator.estimateFee(nBlocks);\n     if (feeRate == CFeeRate(0))\n         return -1.0;\n \n@@ -818,16 +832,19 @@ UniValue estimatefee(const JSONRPCRequest& request)\n \n UniValue estimatesmartfee(const JSONRPCRequest& request)\n {\n-    if (request.fHelp || request.params.size() != 1)\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"estimatesmartfee nblocks\\n\"\n-            \"\\nWARNING: This interface is unstable and may disappear or change!\\n\"\n+            \"estimatesmartfee nblocks (conservative)\\n\"\n             \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\n             \"confirmation within nblocks blocks if possible and return the number of blocks\\n\"\n             \"for which the estimate is valid. Uses virtual transaction size as defined\\n\"\n             \"in BIP 141 (witness data is discounted).\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. nblocks     (numeric)\\n\"\n+            \"1. nblocks       (numeric)\\n\"\n+            \"2. conservative  (bool, optional, default=true) Whether to return a more conservative estimate which\\n\"\n+            \"                 also satisfies a longer history. A conservative estimate potentially returns a higher\\n\"\n+            \"                 feerate and is more likely to be sufficient for the desired target, but is not as\\n\"\n+            \"                 responsive to short term drops in the prevailing fee market\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"feerate\\\" : x.x,     (numeric) estimate fee-per-kilobyte (in BTC)\\n\"\n@@ -841,32 +858,121 @@ UniValue estimatesmartfee(const JSONRPCRequest& request)\n             + HelpExampleCli(\"estimatesmartfee\", \"6\")\n             );\n \n-    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VNUM));\n+    RPCTypeCheck(request.params, {UniValue::VNUM});\n \n     int nBlocks = request.params[0].get_int();\n+    bool conservative = true;\n+    if (request.params.size() > 1 && !request.params[1].isNull()) {\n+        RPCTypeCheckArgument(request.params[1], UniValue::VBOOL);\n+        conservative = request.params[1].get_bool();\n+    }\n \n     UniValue result(UniValue::VOBJ);\n     int answerFound;\n-    CFeeRate feeRate = mempool.estimateSmartFee(nBlocks, &answerFound);\n+    CFeeRate feeRate = ::feeEstimator.estimateSmartFee(nBlocks, &answerFound, ::mempool, conservative);\n     result.push_back(Pair(\"feerate\", feeRate == CFeeRate(0) ? -1.0 : ValueFromAmount(feeRate.GetFeePerK())));\n     result.push_back(Pair(\"blocks\", answerFound));\n     return result;\n }\n \n+UniValue estimaterawfee(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() < 1|| request.params.size() > 3)\n+        throw std::runtime_error(\n+            \"estimaterawfee nblocks (threshold horizon)\\n\"\n+            \"\\nWARNING: This interface is unstable and may disappear or change!\\n\"\n+            \"\\nWARNING: This is an advanced API call that is tightly coupled to the specific\\n\"\n+            \"         implementation of fee estimation. The parameters it can be called with\\n\"\n+            \"         and the results it returns will change if the internal implementation changes.\\n\"\n+            \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\n+            \"confirmation within nblocks blocks if possible. Uses virtual transaction size as defined\\n\"\n+            \"in BIP 141 (witness data is discounted).\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. nblocks     (numeric)\\n\"\n+            \"2. threshold   (numeric, optional) The proportion of transactions in a given feerate range that must have been\\n\"\n+            \"               confirmed within nblocks in order to consider those feerates as high enough and proceed to check\\n\"\n+            \"               lower buckets.  Default: 0.95\\n\"\n+            \"3. horizon     (numeric, optional) How long a history of estimates to consider. 0=short, 1=medium, 2=long.\\n\"\n+            \"               Default: 1\\n\"\n+            \"\\nResult:\\n\"\n+            \"{\\n\"\n+            \"  \\\"feerate\\\" : x.x,        (numeric) estimate fee-per-kilobyte (in BTC)\\n\"\n+            \"  \\\"decay\\\" : x.x,          (numeric) exponential decay (per block) for historical moving average of confirmation data\\n\"\n+            \"  \\\"scale\\\" : x,            (numeric) The resolution of confirmation targets at this time horizon\\n\"\n+            \"  \\\"pass\\\" : {              (json object) information about the lowest range of feerates to succeed in meeting the threshold\\n\"\n+            \"      \\\"startrange\\\" : x.x,     (numeric) start of feerate range\\n\"\n+            \"      \\\"endrange\\\" : x.x,       (numeric) end of feerate range\\n\"\n+            \"      \\\"withintarget\\\" : x.x,   (numeric) number of txs over history horizon in the feerate range that were confirmed within target\\n\"\n+            \"      \\\"totalconfirmed\\\" : x.x, (numeric) number of txs over history horizon in the feerate range that were confirmed at any point\\n\"\n+            \"      \\\"inmempool\\\" : x.x,      (numeric) current number of txs in mempool in the feerate range unconfirmed for at least target blocks\\n\"\n+            \"      \\\"leftmempool\\\" : x.x,    (numeric) number of txs over history horizon in the feerate range that left mempool unconfirmed after target\\n\"\n+            \"  }\\n\"\n+            \"  \\\"fail\\\" : { ... }        (json object) information about the highest range of feerates to fail to meet the threshold\\n\"\n+            \"}\\n\"\n+            \"\\n\"\n+            \"A negative feerate is returned if no answer can be given.\\n\"\n+            \"\\nExample:\\n\"\n+            + HelpExampleCli(\"estimaterawfee\", \"6 0.9 1\")\n+            );\n+\n+    RPCTypeCheck(request.params, {UniValue::VNUM, UniValue::VNUM, UniValue::VNUM}, true);\n+    RPCTypeCheckArgument(request.params[0], UniValue::VNUM);\n+    int nBlocks = request.params[0].get_int();\n+    double threshold = 0.95;\n+    if (!request.params[1].isNull())\n+        threshold = request.params[1].get_real();\n+    FeeEstimateHorizon horizon = FeeEstimateHorizon::MED_HALFLIFE;\n+    if (!request.params[2].isNull()) {\n+        int horizonInt = request.params[2].get_int();\n+        if (horizonInt < 0 || horizonInt > 2) {\n+            throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid horizon for fee estimates\");\n+        } else {\n+            horizon = (FeeEstimateHorizon)horizonInt;\n+        }\n+    }\n+    UniValue result(UniValue::VOBJ);\n+    CFeeRate feeRate;\n+    EstimationResult buckets;\n+    feeRate = ::feeEstimator.estimateRawFee(nBlocks, threshold, horizon, &buckets);\n+\n+    result.push_back(Pair(\"feerate\", feeRate == CFeeRate(0) ? -1.0 : ValueFromAmount(feeRate.GetFeePerK())));\n+    result.push_back(Pair(\"decay\", buckets.decay));\n+    result.push_back(Pair(\"scale\", (int)buckets.scale));\n+    UniValue passbucket(UniValue::VOBJ);\n+    passbucket.push_back(Pair(\"startrange\", round(buckets.pass.start)));\n+    passbucket.push_back(Pair(\"endrange\", round(buckets.pass.end)));\n+    passbucket.push_back(Pair(\"withintarget\", round(buckets.pass.withinTarget * 100.0) / 100.0));\n+    passbucket.push_back(Pair(\"totalconfirmed\", round(buckets.pass.totalConfirmed * 100.0) / 100.0));\n+    passbucket.push_back(Pair(\"inmempool\", round(buckets.pass.inMempool * 100.0) / 100.0));\n+    passbucket.push_back(Pair(\"leftmempool\", round(buckets.pass.leftMempool * 100.0) / 100.0));\n+    result.push_back(Pair(\"pass\", passbucket));\n+    UniValue failbucket(UniValue::VOBJ);\n+    failbucket.push_back(Pair(\"startrange\", round(buckets.fail.start)));\n+    failbucket.push_back(Pair(\"endrange\", round(buckets.fail.end)));\n+    failbucket.push_back(Pair(\"withintarget\", round(buckets.fail.withinTarget * 100.0) / 100.0));\n+    failbucket.push_back(Pair(\"totalconfirmed\", round(buckets.fail.totalConfirmed * 100.0) / 100.0));\n+    failbucket.push_back(Pair(\"inmempool\", round(buckets.fail.inMempool * 100.0) / 100.0));\n+    failbucket.push_back(Pair(\"leftmempool\", round(buckets.fail.leftMempool * 100.0) / 100.0));\n+    result.push_back(Pair(\"fail\", failbucket));\n+    return result;\n+}\n+\n static const CRPCCommand commands[] =\n { //  category              name                      actor (function)         okSafeMode\n   //  --------------------- ------------------------  -----------------------  ----------\n     { \"mining\",             \"getnetworkhashps\",       &getnetworkhashps,       true,  {\"nblocks\",\"height\"} },\n     { \"mining\",             \"getmininginfo\",          &getmininginfo,          true,  {} },\n-    { \"mining\",             \"prioritisetransaction\",  &prioritisetransaction,  true,  {\"txid\",\"fee_delta\"} },\n+    { \"mining\",             \"prioritisetransaction\",  &prioritisetransaction,  true,  {\"txid\",\"priority_delta\",\"fee_delta\"} },\n     { \"mining\",             \"getblocktemplate\",       &getblocktemplate,       true,  {\"template_request\"} },\n     { \"mining\",             \"submitblock\",            &submitblock,            true,  {\"hexdata\",\"parameters\"} },\n \n     { \"generating\",         \"generate\",               &generate,               true,  {\"nblocks\",\"maxtries\"} },\n     { \"generating\",         \"generatetoaddress\",      &generatetoaddress,      true,  {\"nblocks\",\"address\",\"maxtries\"} },\n \n     { \"util\",               \"estimatefee\",            &estimatefee,            true,  {\"nblocks\"} },\n-    { \"util\",               \"estimatesmartfee\",       &estimatesmartfee,       true,  {\"nblocks\"} },\n+    { \"util\",               \"estimatesmartfee\",       &estimatesmartfee,       true,  {\"nblocks\", \"conservative\"} },\n+\n+    { \"hidden\",             \"estimaterawfee\",         &estimaterawfee,         true,  {\"nblocks\", \"threshold\", \"horizon\"} },\n };\n \n void RegisterMiningRPCCommands(CRPCTable &t)"
      },
      {
        "sha": "f6f01eef4b609db2f10e0c2a41cede6cdde5d8a1",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 73,
        "deletions": 4,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -4,11 +4,14 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"base58.h\"\n+#include \"chain.h\"\n #include \"clientversion.h\"\n #include \"init.h\"\n #include \"validation.h\"\n+#include \"httpserver.h\"\n #include \"net.h\"\n #include \"netbase.h\"\n+#include \"rpc/blockchain.h\"\n #include \"rpc/server.h\"\n #include \"timedata.h\"\n #include \"util.h\"\n@@ -24,8 +27,6 @@\n #include <malloc.h>\n #endif\n \n-#include <boost/assign/list_of.hpp>\n-\n #include <univalue.h>\n \n /**\n@@ -469,7 +470,7 @@ UniValue setmocktime(const JSONRPCRequest& request)\n     // ensure all call sites of GetTime() are accessing this safely.\n     LOCK(cs_main);\n \n-    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VNUM));\n+    RPCTypeCheck(request.params, {UniValue::VNUM});\n     SetMockTime(request.params[0].get_int64());\n \n     return NullUniValue;\n@@ -554,6 +555,73 @@ UniValue getmemoryinfo(const JSONRPCRequest& request)\n     }\n }\n \n+uint32_t getCategoryMask(UniValue cats) {\n+    cats = cats.get_array();\n+    uint32_t mask = 0;\n+    for (unsigned int i = 0; i < cats.size(); ++i) {\n+        uint32_t flag = 0;\n+        std::string cat = cats[i].get_str();\n+        if (!GetLogCategory(&flag, &cat)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"unknown logging category \" + cat);\n+        }\n+        mask |= flag;\n+    }\n+    return mask;\n+}\n+\n+UniValue logging(const JSONRPCRequest& request)\n+{\n+    if (request.fHelp || request.params.size() > 2) {\n+        throw std::runtime_error(\n+            \"logging [include,...] <exclude>\\n\"\n+            \"Gets and sets the logging configuration.\\n\"\n+            \"When called without an argument, returns the list of categories that are currently being debug logged.\\n\"\n+            \"When called with arguments, adds or removes categories from debug logging.\\n\"\n+            \"The valid logging categories are: \" + ListLogCategories() + \"\\n\"\n+            \"libevent logging is configured on startup and cannot be modified by this RPC during runtime.\"\n+            \"Arguments:\\n\"\n+            \"1. \\\"include\\\" (array of strings) add debug logging for these categories.\\n\"\n+            \"2. \\\"exclude\\\" (array of strings) remove debug logging for these categories.\\n\"\n+            \"\\nResult: <categories>  (string): a list of the logging categories that are active.\\n\"\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"logging\", \"\\\"[\\\\\\\"all\\\\\\\"]\\\" \\\"[\\\\\\\"http\\\\\\\"]\\\"\")\n+            + HelpExampleRpc(\"logging\", \"[\\\"all\\\"], \\\"[libevent]\\\"\")\n+        );\n+    }\n+\n+    uint32_t originalLogCategories = logCategories;\n+    if (request.params.size() > 0 && request.params[0].isArray()) {\n+        logCategories |= getCategoryMask(request.params[0]);\n+    }\n+\n+    if (request.params.size() > 1 && request.params[1].isArray()) {\n+        logCategories &= ~getCategoryMask(request.params[1]);\n+    }\n+\n+    // Update libevent logging if BCLog::LIBEVENT has changed.\n+    // If the library version doesn't allow it, UpdateHTTPServerLogging() returns false,\n+    // in which case we should clear the BCLog::LIBEVENT flag.\n+    // Throw an error if the user has explicitly asked to change only the libevent\n+    // flag and it failed.\n+    uint32_t changedLogCategories = originalLogCategories ^ logCategories;\n+    if (changedLogCategories & BCLog::LIBEVENT) {\n+        if (!UpdateHTTPServerLogging(logCategories & BCLog::LIBEVENT)) {\n+            logCategories &= ~BCLog::LIBEVENT;\n+            if (changedLogCategories == BCLog::LIBEVENT) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"libevent logging cannot be updated when using libevent before v2.1.1.\");\n+            }\n+        }\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+    std::vector<CLogCategoryActive> vLogCatActive = ListActiveLogCategories();\n+    for (const auto& logCatActive : vLogCatActive) {\n+        result.pushKV(logCatActive.category, logCatActive.active);\n+    }\n+\n+    return result;\n+}\n+\n UniValue echo(const JSONRPCRequest& request)\n {\n     if (request.fHelp)\n@@ -580,7 +648,8 @@ static const CRPCCommand commands[] =\n     /* Not shown in help */\n     { \"hidden\",             \"setmocktime\",            &setmocktime,            true,  {\"timestamp\"}},\n     { \"hidden\",             \"echo\",                   &echo,                   true,  {\"arg0\",\"arg1\",\"arg2\",\"arg3\",\"arg4\",\"arg5\",\"arg6\",\"arg7\",\"arg8\",\"arg9\"}},\n-    { \"hidden\",             \"echojson\",               &echo,                  true,  {\"arg0\",\"arg1\",\"arg2\",\"arg3\",\"arg4\",\"arg5\",\"arg6\",\"arg7\",\"arg8\",\"arg9\"}},\n+    { \"hidden\",             \"echojson\",               &echo,                   true,  {\"arg0\",\"arg1\",\"arg2\",\"arg3\",\"arg4\",\"arg5\",\"arg6\",\"arg7\",\"arg8\",\"arg9\"}},\n+    { \"hidden\",             \"logging\",                &logging,                true,  {\"include\", \"exclude\"}},\n };\n \n void RegisterMiscRPCCommands(CRPCTable &t)"
      },
      {
        "sha": "10bf99eb386d92ff50ca0fb4f0b6f92e54259062",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 8,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -76,7 +76,8 @@ UniValue getpeerinfo(const JSONRPCRequest& request)\n             \"  {\\n\"\n             \"    \\\"id\\\": n,                   (numeric) Peer index\\n\"\n             \"    \\\"addr\\\":\\\"host:port\\\",      (string) The ip address and port of the peer\\n\"\n-            \"    \\\"addrlocal\\\":\\\"ip:port\\\",   (string) local address\\n\"\n+            \"    \\\"addrbind\\\":\\\"ip:port\\\",    (string) Bind address of the connection to the peer\\n\"\n+            \"    \\\"addrlocal\\\":\\\"ip:port\\\",   (string) Local address as reported by the peer\\n\"\n             \"    \\\"services\\\":\\\"xxxxxxxxxxxxxxxx\\\",   (string) The services offered\\n\"\n             \"    \\\"relaytxes\\\":true|false,    (boolean) Whether peer has asked us to relay transactions to it\\n\"\n             \"    \\\"lastsend\\\": ttt,           (numeric) The time in seconds since epoch (Jan 1 1970 GMT) of the last send\\n\"\n@@ -133,6 +134,8 @@ UniValue getpeerinfo(const JSONRPCRequest& request)\n         obj.push_back(Pair(\"addr\", stats.addrName));\n         if (!(stats.addrLocal.empty()))\n             obj.push_back(Pair(\"addrlocal\", stats.addrLocal));\n+        if (stats.addrBind.IsValid())\n+            obj.push_back(Pair(\"addrbind\", stats.addrBind.ToString()));\n         obj.push_back(Pair(\"services\", strprintf(\"%016x\", stats.nServices)));\n         obj.push_back(Pair(\"relaytxes\", stats.fRelayTxes));\n         obj.push_back(Pair(\"lastsend\", stats.nLastSend));\n@@ -234,23 +237,43 @@ UniValue addnode(const JSONRPCRequest& request)\n \n UniValue disconnectnode(const JSONRPCRequest& request)\n {\n-    if (request.fHelp || request.params.size() != 1)\n+    if (request.fHelp || request.params.size() == 0 || request.params.size() >= 3)\n         throw std::runtime_error(\n-            \"disconnectnode \\\"node\\\" \\n\"\n-            \"\\nImmediately disconnects from the specified node.\\n\"\n+            \"disconnectnode \\\"[address]\\\" [nodeid]\\n\"\n+            \"\\nImmediately disconnects from the specified peer node.\\n\"\n+            \"\\nStrictly one out of 'address' and 'nodeid' can be provided to identify the node.\\n\"\n+            \"\\nTo disconnect by nodeid, either set 'address' to the empty string, or call using the named 'nodeid' argument only.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"node\\\"     (string, required) The node (see getpeerinfo for nodes)\\n\"\n+            \"1. \\\"address\\\"     (string, optional) The IP address/port of the node\\n\"\n+            \"2. \\\"nodeid\\\"      (number, optional) The node ID (see getpeerinfo for node IDs)\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"disconnectnode\", \"\\\"192.168.0.6:8333\\\"\")\n+            + HelpExampleCli(\"disconnectnode\", \"\\\"\\\" 1\")\n             + HelpExampleRpc(\"disconnectnode\", \"\\\"192.168.0.6:8333\\\"\")\n+            + HelpExampleRpc(\"disconnectnode\", \"\\\"\\\", 1\")\n         );\n \n     if(!g_connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n-    bool ret = g_connman->DisconnectNode(request.params[0].get_str());\n-    if (!ret)\n+    bool success;\n+    const UniValue &address_arg = request.params[0];\n+    const UniValue &id_arg = request.params.size() < 2 ? NullUniValue : request.params[1];\n+\n+    if (!address_arg.isNull() && id_arg.isNull()) {\n+        /* handle disconnect-by-address */\n+        success = g_connman->DisconnectNode(address_arg.get_str());\n+    } else if (!id_arg.isNull() && (address_arg.isNull() || (address_arg.isStr() && address_arg.get_str().empty()))) {\n+        /* handle disconnect-by-id */\n+        NodeId nodeid = (NodeId) id_arg.get_int64();\n+        success = g_connman->DisconnectNode(nodeid);\n+    } else {\n+        throw JSONRPCError(RPC_INVALID_PARAMS, \"Only one of address and nodeid should be provided.\");\n+    }\n+\n+    if (!success) {\n         throw JSONRPCError(RPC_CLIENT_NODE_NOT_CONNECTED, \"Node not found in connected nodes\");\n+    }\n \n     return NullUniValue;\n }\n@@ -607,7 +630,7 @@ static const CRPCCommand commands[] =\n     { \"network\",            \"ping\",                   &ping,                   true,  {} },\n     { \"network\",            \"getpeerinfo\",            &getpeerinfo,            true,  {} },\n     { \"network\",            \"addnode\",                &addnode,                true,  {\"node\",\"command\"} },\n-    { \"network\",            \"disconnectnode\",         &disconnectnode,         true,  {\"node\"} },\n+    { \"network\",            \"disconnectnode\",         &disconnectnode,         true,  {\"address\", \"nodeid\"} },\n     { \"network\",            \"getaddednodeinfo\",       &getaddednodeinfo,       true,  {\"node\"} },\n     { \"network\",            \"getnettotals\",           &getnettotals,           true,  {} },\n     { \"network\",            \"getnetworkinfo\",         &getnetworkinfo,         true,  {} },"
      },
      {
        "sha": "823a5775f6dc3b2b4680e5df981cc09d9be18269",
        "filename": "src/rpc/protocol.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/protocol.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -66,9 +66,9 @@ static const std::string COOKIEAUTH_USER = \"__cookie__\";\n /** Default name for auth cookie file */\n static const std::string COOKIEAUTH_FILE = \".cookie\";\n \n-boost::filesystem::path GetAuthCookieFile()\n+fs::path GetAuthCookieFile()\n {\n-    boost::filesystem::path path(GetArg(\"-rpccookiefile\", COOKIEAUTH_FILE));\n+    fs::path path(GetArg(\"-rpccookiefile\", COOKIEAUTH_FILE));\n     if (!path.is_complete()) path = GetDataDir() / path;\n     return path;\n }\n@@ -84,7 +84,7 @@ bool GenerateAuthCookie(std::string *cookie_out)\n      * these are set to 077 in init.cpp unless overridden with -sysperms.\n      */\n     std::ofstream file;\n-    boost::filesystem::path filepath = GetAuthCookieFile();\n+    fs::path filepath = GetAuthCookieFile();\n     file.open(filepath.string().c_str());\n     if (!file.is_open()) {\n         LogPrintf(\"Unable to open cookie authentication file %s for writing\\n\", filepath.string());\n@@ -103,7 +103,7 @@ bool GetAuthCookie(std::string *cookie_out)\n {\n     std::ifstream file;\n     std::string cookie;\n-    boost::filesystem::path filepath = GetAuthCookieFile();\n+    fs::path filepath = GetAuthCookieFile();\n     file.open(filepath.string().c_str());\n     if (!file.is_open())\n         return false;\n@@ -118,8 +118,8 @@ bool GetAuthCookie(std::string *cookie_out)\n void DeleteAuthCookie()\n {\n     try {\n-        boost::filesystem::remove(GetAuthCookieFile());\n-    } catch (const boost::filesystem::filesystem_error& e) {\n+        fs::remove(GetAuthCookieFile());\n+    } catch (const fs::filesystem_error& e) {\n         LogPrintf(\"%s: Unable to remove random auth cookie file: %s\\n\", __func__, e.what());\n     }\n }"
      },
      {
        "sha": "70f7092cfeb659d8c870d02d4142c308c9768402",
        "filename": "src/rpc/protocol.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/protocol.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -6,11 +6,12 @@\n #ifndef BITCOIN_RPCPROTOCOL_H\n #define BITCOIN_RPCPROTOCOL_H\n \n+#include \"fs.h\"\n+\n #include <list>\n #include <map>\n #include <stdint.h>\n #include <string>\n-#include <boost/filesystem.hpp>\n \n #include <univalue.h>\n \n@@ -89,7 +90,7 @@ std::string JSONRPCReply(const UniValue& result, const UniValue& error, const Un\n UniValue JSONRPCError(int code, const std::string& message);\n \n /** Get name of RPC authentication cookie file */\n-boost::filesystem::path GetAuthCookieFile();\n+fs::path GetAuthCookieFile();\n /** Generate a new RPC authentication cookie and write it to disk */\n bool GenerateAuthCookie(std::string *cookie_out);\n /** Read the RPC authentication cookie from disk */"
      },
      {
        "sha": "0d624c2631f8a1346c404ab567c7ac46ffd5f24e",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 114,
        "changes": 188,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -14,6 +14,7 @@\n #include \"merkleblock.h\"\n #include \"net.h\"\n #include \"policy/policy.h\"\n+#include \"policy/rbf.h\"\n #include \"primitives/transaction.h\"\n #include \"rpc/server.h\"\n #include \"script/script.h\"\n@@ -30,81 +31,17 @@\n \n #include <stdint.h>\n \n-#include <boost/assign/list_of.hpp>\n-\n #include <univalue.h>\n \n-void ScriptPubKeyToJSON(const CScript& scriptPubKey, UniValue& out, bool fIncludeHex)\n-{\n-    txnouttype type;\n-    std::vector<CTxDestination> addresses;\n-    int nRequired;\n-\n-    out.push_back(Pair(\"asm\", ScriptToAsmStr(scriptPubKey)));\n-    if (fIncludeHex)\n-        out.push_back(Pair(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end())));\n-\n-    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired)) {\n-        out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n-        return;\n-    }\n-\n-    out.push_back(Pair(\"reqSigs\", nRequired));\n-    out.push_back(Pair(\"type\", GetTxnOutputType(type)));\n-\n-    UniValue a(UniValue::VARR);\n-    BOOST_FOREACH(const CTxDestination& addr, addresses)\n-        a.push_back(CBitcoinAddress(addr).ToString());\n-    out.push_back(Pair(\"addresses\", a));\n-}\n \n void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n {\n-    entry.push_back(Pair(\"txid\", tx.GetHash().GetHex()));\n-    entry.push_back(Pair(\"hash\", tx.GetWitnessHash().GetHex()));\n-    entry.push_back(Pair(\"size\", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION)));\n-    entry.push_back(Pair(\"vsize\", (int)::GetVirtualTransactionSize(tx)));\n-    entry.push_back(Pair(\"version\", tx.nVersion));\n-    entry.push_back(Pair(\"locktime\", (int64_t)tx.nLockTime));\n-\n-    UniValue vin(UniValue::VARR);\n-    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-        const CTxIn& txin = tx.vin[i];\n-        UniValue in(UniValue::VOBJ);\n-        if (tx.IsCoinBase())\n-            in.push_back(Pair(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n-        else {\n-            in.push_back(Pair(\"txid\", txin.prevout.hash.GetHex()));\n-            in.push_back(Pair(\"vout\", (int64_t)txin.prevout.n));\n-            UniValue o(UniValue::VOBJ);\n-            o.push_back(Pair(\"asm\", ScriptToAsmStr(txin.scriptSig, true)));\n-            o.push_back(Pair(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n-            in.push_back(Pair(\"scriptSig\", o));\n-        }\n-        if (tx.HasWitness()) {\n-                UniValue txinwitness(UniValue::VARR);\n-                for (unsigned int j = 0; j < tx.vin[i].scriptWitness.stack.size(); j++) {\n-                    std::vector<unsigned char> item = tx.vin[i].scriptWitness.stack[j];\n-                    txinwitness.push_back(HexStr(item.begin(), item.end()));\n-                }\n-                in.push_back(Pair(\"txinwitness\", txinwitness));\n-        }\n-        in.push_back(Pair(\"sequence\", (int64_t)txin.nSequence));\n-        vin.push_back(in);\n-    }\n-    entry.push_back(Pair(\"vin\", vin));\n-    UniValue vout(UniValue::VARR);\n-    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n-        const CTxOut& txout = tx.vout[i];\n-        UniValue out(UniValue::VOBJ);\n-        out.push_back(Pair(\"value\", ValueFromAmount(txout.nValue)));\n-        out.push_back(Pair(\"n\", (int64_t)i));\n-        UniValue o(UniValue::VOBJ);\n-        ScriptPubKeyToJSON(txout.scriptPubKey, o, true);\n-        out.push_back(Pair(\"scriptPubKey\", o));\n-        vout.push_back(out);\n-    }\n-    entry.push_back(Pair(\"vout\", vout));\n+    // Call into TxToUniv() in bitcoin-common to decode the transaction hex.\n+    //\n+    // Blockchain contextual information (confirmations and blocktime) is not\n+    // available to code in bitcoin-common, so we query them here and push the\n+    // data into the returned UniValue.\n+    TxToUniv(tx, uint256(), entry);\n \n     if (!hashBlock.IsNull()) {\n         entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n@@ -281,9 +218,10 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         pblockindex = mapBlockIndex[hashBlock];\n     } else {\n-        CCoins coins;\n-        if (pcoinsTip->GetCoins(oneTxid, coins) && coins.nHeight > 0 && coins.nHeight <= chainActive.Height())\n-            pblockindex = chainActive[coins.nHeight];\n+        const Coin& coin = AccessByTxid(*pcoinsTip, oneTxid);\n+        if (!coin.IsSpent() && coin.nHeight > 0 && coin.nHeight <= chainActive.Height()) {\n+            pblockindex = chainActive[coin.nHeight];\n+        }\n     }\n \n     if (pblockindex == NULL)\n@@ -350,17 +288,17 @@ UniValue verifytxoutproof(const JSONRPCRequest& request)\n \n UniValue createrawtransaction(const JSONRPCRequest& request)\n {\n-    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n         throw std::runtime_error(\n-            \"createrawtransaction [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] {\\\"address\\\":amount,\\\"data\\\":\\\"hex\\\",...} ( locktime )\\n\"\n+            \"createrawtransaction [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] {\\\"address\\\":amount,\\\"data\\\":\\\"hex\\\",...} ( locktime ) ( optintorbf )\\n\"\n             \"\\nCreate a transaction spending the given inputs and creating new outputs.\\n\"\n             \"Outputs can be addresses or data.\\n\"\n             \"Returns hex-encoded raw transaction.\\n\"\n             \"Note that the transaction's inputs are not signed, and\\n\"\n             \"it is not stored in the wallet or transmitted to the network.\\n\"\n \n             \"\\nArguments:\\n\"\n-            \"1. \\\"inputs\\\"                (string, required) A json array of json objects\\n\"\n+            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n             \"     [\\n\"\n             \"       {\\n\"\n             \"         \\\"txid\\\":\\\"id\\\",    (string, required) The transaction id\\n\"\n@@ -369,13 +307,14 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n             \"       } \\n\"\n             \"       ,...\\n\"\n             \"     ]\\n\"\n-            \"2. \\\"outputs\\\"               (string, required) a json object with outputs\\n\"\n+            \"2. \\\"outputs\\\"               (object, required) a json object with outputs\\n\"\n             \"    {\\n\"\n             \"      \\\"address\\\": x.xxx,    (numeric or string, required) The key is the bitcoin address, the numeric value (can be string) is the \" + CURRENCY_UNIT + \" amount\\n\"\n             \"      \\\"data\\\": \\\"hex\\\"      (string, required) The key is \\\"data\\\", the value is hex encoded data\\n\"\n             \"      ,...\\n\"\n             \"    }\\n\"\n             \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n+            \"4. optintorbf                (boolean, optional, default=false) Allow this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"transaction\\\"              (string) hex string of the transaction\\n\"\n \n@@ -386,7 +325,7 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}\\\"\")\n         );\n \n-    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VARR)(UniValue::VOBJ)(UniValue::VNUM), true);\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VOBJ, UniValue::VNUM}, true);\n     if (request.params[0].isNull() || request.params[1].isNull())\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, arguments 1 and 2 must be non-null\");\n \n@@ -402,6 +341,8 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n         rawTx.nLockTime = nLockTime;\n     }\n \n+    bool rbfOptIn = request.params.size() > 3 ? request.params[3].isTrue() : false;\n+\n     for (unsigned int idx = 0; idx < inputs.size(); idx++) {\n         const UniValue& input = inputs[idx];\n         const UniValue& o = input.get_obj();\n@@ -415,16 +356,24 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n         if (nOutput < 0)\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, vout must be positive\");\n \n-        uint32_t nSequence = (rawTx.nLockTime ? std::numeric_limits<uint32_t>::max() - 1 : std::numeric_limits<uint32_t>::max());\n+        uint32_t nSequence;\n+        if (rbfOptIn) {\n+            nSequence = MAX_BIP125_RBF_SEQUENCE;\n+        } else if (rawTx.nLockTime) {\n+            nSequence = std::numeric_limits<uint32_t>::max() - 1;\n+        } else {\n+            nSequence = std::numeric_limits<uint32_t>::max();\n+        }\n \n         // set the sequence number if passed in the parameters object\n         const UniValue& sequenceObj = find_value(o, \"sequence\");\n         if (sequenceObj.isNum()) {\n             int64_t seqNr64 = sequenceObj.get_int64();\n-            if (seqNr64 < 0 || seqNr64 > std::numeric_limits<uint32_t>::max())\n+            if (seqNr64 < 0 || seqNr64 > std::numeric_limits<uint32_t>::max()) {\n                 throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, sequence number is out of range\");\n-            else\n+            } else {\n                 nSequence = (uint32_t)seqNr64;\n+            }\n         }\n \n         CTxIn in(COutPoint(txid, nOutput), CScript(), nSequence);\n@@ -458,6 +407,10 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n         }\n     }\n \n+    if (request.params.size() > 3 && rbfOptIn != SignalsOptInRBF(rawTx)) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter combination: Sequence number(s) contradict optintorbf option\");\n+    }\n+\n     return EncodeHexTx(rawTx);\n }\n \n@@ -517,15 +470,15 @@ UniValue decoderawtransaction(const JSONRPCRequest& request)\n         );\n \n     LOCK(cs_main);\n-    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n \n     CMutableTransaction mtx;\n \n     if (!DecodeHexTx(mtx, request.params[0].get_str(), true))\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n \n     UniValue result(UniValue::VOBJ);\n-    TxToJSON(CTransaction(std::move(mtx)), uint256(), result);\n+    TxToUniv(CTransaction(std::move(mtx)), uint256(), result);\n \n     return result;\n }\n@@ -555,7 +508,7 @@ UniValue decodescript(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"decodescript\", \"\\\"hexstring\\\"\")\n         );\n \n-    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR));\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\n \n     UniValue r(UniValue::VOBJ);\n     CScript script;\n@@ -565,7 +518,7 @@ UniValue decodescript(const JSONRPCRequest& request)\n     } else {\n         // Empty scripts are valid\n     }\n-    ScriptPubKeyToJSON(script, r, false);\n+    ScriptPubKeyToUniv(script, r, false);\n \n     UniValue type;\n     type = find_value(r, \"type\");\n@@ -585,6 +538,11 @@ static void TxInErrorToJSON(const CTxIn& txin, UniValue& vErrorsRet, const std::\n     UniValue entry(UniValue::VOBJ);\n     entry.push_back(Pair(\"txid\", txin.prevout.hash.ToString()));\n     entry.push_back(Pair(\"vout\", (uint64_t)txin.prevout.n));\n+    UniValue witness(UniValue::VARR);\n+    for (unsigned int i = 0; i < txin.scriptWitness.stack.size(); i++) {\n+        witness.push_back(HexStr(txin.scriptWitness.stack[i].begin(), txin.scriptWitness.stack[i].end()));\n+    }\n+    entry.push_back(Pair(\"witness\", witness));\n     entry.push_back(Pair(\"scriptSig\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n     entry.push_back(Pair(\"sequence\", (uint64_t)txin.nSequence));\n     entry.push_back(Pair(\"error\", strMessage));\n@@ -661,7 +619,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n #else\n     LOCK(cs_main);\n #endif\n-    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VARR)(UniValue::VARR)(UniValue::VSTR), true);\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR, UniValue::VARR, UniValue::VSTR}, true);\n \n     std::vector<unsigned char> txData(ParseHexV(request.params[0], \"argument 1\"));\n     CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n@@ -694,9 +652,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n \n         BOOST_FOREACH(const CTxIn& txin, mergedTx.vin) {\n-            const uint256& prevHash = txin.prevout.hash;\n-            CCoins coins;\n-            view.AccessCoins(prevHash); // this is certainly allowed to fail\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n         }\n \n         view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n@@ -748,24 +704,26 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n             if (nOut < 0)\n                 throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"vout must be positive\");\n \n+            COutPoint out(txid, nOut);\n             std::vector<unsigned char> pkData(ParseHexO(prevOut, \"scriptPubKey\"));\n             CScript scriptPubKey(pkData.begin(), pkData.end());\n \n             {\n-                CCoinsModifier coins = view.ModifyCoins(txid);\n-                if (coins->IsAvailable(nOut) && coins->vout[nOut].scriptPubKey != scriptPubKey) {\n+                const Coin& coin = view.AccessCoin(out);\n+                if (!coin.IsSpent() && coin.out.scriptPubKey != scriptPubKey) {\n                     std::string err(\"Previous output scriptPubKey mismatch:\\n\");\n-                    err = err + ScriptToAsmStr(coins->vout[nOut].scriptPubKey) + \"\\nvs:\\n\"+\n+                    err = err + ScriptToAsmStr(coin.out.scriptPubKey) + \"\\nvs:\\n\"+\n                         ScriptToAsmStr(scriptPubKey);\n                     throw JSONRPCError(RPC_DESERIALIZATION_ERROR, err);\n                 }\n-                if ((unsigned int)nOut >= coins->vout.size())\n-                    coins->vout.resize(nOut+1);\n-                coins->vout[nOut].scriptPubKey = scriptPubKey;\n-                coins->vout[nOut].nValue = 0;\n+                Coin newcoin;\n+                newcoin.out.scriptPubKey = scriptPubKey;\n+                newcoin.out.nValue = 0;\n                 if (prevOut.exists(\"amount\")) {\n-                    coins->vout[nOut].nValue = AmountFromValue(find_value(prevOut, \"amount\"));\n+                    newcoin.out.nValue = AmountFromValue(find_value(prevOut, \"amount\"));\n                 }\n+                newcoin.nHeight = 1;\n+                view.AddCoin(out, std::move(newcoin), true);\n             }\n \n             // if redeemScript given and not using the local wallet (private keys\n@@ -796,15 +754,14 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n \n     int nHashType = SIGHASH_ALL;\n     if (request.params.size() > 3 && !request.params[3].isNull()) {\n-        static std::map<std::string, int> mapSigHashValues =\n-            boost::assign::map_list_of\n-            (std::string(\"ALL\"), int(SIGHASH_ALL))\n-            (std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY))\n-            (std::string(\"NONE\"), int(SIGHASH_NONE))\n-            (std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY))\n-            (std::string(\"SINGLE\"), int(SIGHASH_SINGLE))\n-            (std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY))\n-            ;\n+        static std::map<std::string, int> mapSigHashValues = {\n+            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n+            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n+            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n+            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n+            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n+        };\n         std::string strHashType = request.params[3].get_str();\n         if (mapSigHashValues.count(strHashType))\n             nHashType = mapSigHashValues[strHashType];\n@@ -823,13 +780,13 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n     // Sign what we can:\n     for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n         CTxIn& txin = mergedTx.vin[i];\n-        const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n-        if (coins == NULL || !coins->IsAvailable(txin.prevout.n)) {\n+        const Coin& coin = view.AccessCoin(txin.prevout);\n+        if (coin.IsSpent()) {\n             TxInErrorToJSON(txin, vErrors, \"Input not found or already spent\");\n             continue;\n         }\n-        const CScript& prevPubKey = coins->vout[txin.prevout.n].scriptPubKey;\n-        const CAmount& amount = coins->vout[txin.prevout.n].nValue;\n+        const CScript& prevPubKey = coin.out.scriptPubKey;\n+        const CAmount& amount = coin.out.nValue;\n \n         SignatureData sigdata;\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n@@ -886,7 +843,7 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n         );\n \n     LOCK(cs_main);\n-    RPCTypeCheck(request.params, boost::assign::list_of(UniValue::VSTR)(UniValue::VBOOL));\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL});\n \n     // parse hex string from parameter\n     CMutableTransaction mtx;\n@@ -901,9 +858,12 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n         nMaxRawTxFee = 0;\n \n     CCoinsViewCache &view = *pcoinsTip;\n-    const CCoins* existingCoins = view.AccessCoins(hashTx);\n+    bool fHaveChain = false;\n+    for (size_t o = 0; !fHaveChain && o < tx->vout.size(); o++) {\n+        const Coin& existingCoin = view.AccessCoin(COutPoint(hashTx, o));\n+        fHaveChain = !existingCoin.IsSpent();\n+    }\n     bool fHaveMempool = mempool.exists(hashTx);\n-    bool fHaveChain = existingCoins && existingCoins->nHeight < 1000000000;\n     if (!fHaveMempool && !fHaveChain) {\n         // push to local node and sync with wallets\n         CValidationState state;\n@@ -936,7 +896,7 @@ static const CRPCCommand commands[] =\n { //  category              name                      actor (function)         okSafeMode\n   //  --------------------- ------------------------  -----------------------  ----------\n     { \"rawtransactions\",    \"getrawtransaction\",      &getrawtransaction,      true,  {\"txid\",\"verbose\"} },\n-    { \"rawtransactions\",    \"createrawtransaction\",   &createrawtransaction,   true,  {\"transactions\",\"outputs\",\"locktime\"} },\n+    { \"rawtransactions\",    \"createrawtransaction\",   &createrawtransaction,   true,  {\"inputs\",\"outputs\",\"locktime\"} },\n     { \"rawtransactions\",    \"decoderawtransaction\",   &decoderawtransaction,   true,  {\"hexstring\"} },\n     { \"rawtransactions\",    \"decodescript\",           &decodescript,           true,  {\"hexstring\"} },\n     { \"rawtransactions\",    \"sendrawtransaction\",     &sendrawtransaction,     false, {\"hexstring\",\"allowhighfees\"} },"
      },
      {
        "sha": "c5fbff00775cdd546e301d702bf776d08f44579c",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 13,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -6,6 +6,7 @@\n #include \"rpc/server.h\"\n \n #include \"base58.h\"\n+#include \"fs.h\"\n #include \"init.h\"\n #include \"random.h\"\n #include \"sync.h\"\n@@ -16,12 +17,13 @@\n #include <univalue.h>\n \n #include <boost/bind.hpp>\n-#include <boost/filesystem.hpp>\n #include <boost/foreach.hpp>\n #include <boost/shared_ptr.hpp>\n #include <boost/signals2/signal.hpp>\n #include <boost/thread.hpp>\n #include <boost/algorithm/string/case_conv.hpp> // for to_upper()\n+#include <boost/algorithm/string/classification.hpp>\n+#include <boost/algorithm/string/split.hpp>\n \n #include <memory> // for unique_ptr\n #include <unordered_map>\n@@ -42,17 +44,17 @@ static struct CRPCSignals\n     boost::signals2::signal<void (const CRPCCommand&)> PreCommand;\n } g_rpcSignals;\n \n-void RPCServer::OnStarted(boost::function<void ()> slot)\n+void RPCServer::OnStarted(std::function<void ()> slot)\n {\n     g_rpcSignals.Started.connect(slot);\n }\n \n-void RPCServer::OnStopped(boost::function<void ()> slot)\n+void RPCServer::OnStopped(std::function<void ()> slot)\n {\n     g_rpcSignals.Stopped.connect(slot);\n }\n \n-void RPCServer::OnPreCommand(boost::function<void (const CRPCCommand&)> slot)\n+void RPCServer::OnPreCommand(std::function<void (const CRPCCommand&)> slot)\n {\n     g_rpcSignals.PreCommand.connect(boost::bind(slot, _1));\n }\n@@ -305,23 +307,24 @@ bool CRPCTable::appendCommand(const std::string& name, const CRPCCommand* pcmd)\n \n bool StartRPC()\n {\n-    LogPrint(\"rpc\", \"Starting RPC\\n\");\n+    LogPrint(BCLog::RPC, \"Starting RPC\\n\");\n     fRPCRunning = true;\n     g_rpcSignals.Started();\n     return true;\n }\n \n void InterruptRPC()\n {\n-    LogPrint(\"rpc\", \"Interrupting RPC\\n\");\n+    LogPrint(BCLog::RPC, \"Interrupting RPC\\n\");\n     // Interrupt e.g. running longpolls\n     fRPCRunning = false;\n }\n \n void StopRPC()\n {\n-    LogPrint(\"rpc\", \"Stopping RPC\\n\");\n+    LogPrint(BCLog::RPC, \"Stopping RPC\\n\");\n     deadlineTimers.clear();\n+    DeleteAuthCookie();\n     g_rpcSignals.Stopped();\n }\n \n@@ -368,8 +371,7 @@ void JSONRPCRequest::parse(const UniValue& valRequest)\n     if (!valMethod.isStr())\n         throw JSONRPCError(RPC_INVALID_REQUEST, \"Method must be a string\");\n     strMethod = valMethod.get_str();\n-    if (strMethod != \"getblocktemplate\")\n-        LogPrint(\"rpc\", \"ThreadRPCServer method=%s\\n\", SanitizeString(strMethod));\n+    LogPrint(BCLog::RPC, \"ThreadRPCServer method=%s\\n\", SanitizeString(strMethod));\n \n     // Parse params\n     UniValue valParams = find_value(request, \"params\");\n@@ -432,8 +434,16 @@ static inline JSONRPCRequest transformNamedArguments(const JSONRPCRequest& in, c\n     }\n     // Process expected parameters.\n     int hole = 0;\n-    for (const std::string &argName: argNames) {\n-        auto fr = argsIn.find(argName);\n+    for (const std::string &argNamePattern: argNames) {\n+        std::vector<std::string> vargNames;\n+        boost::algorithm::split(vargNames, argNamePattern, boost::algorithm::is_any_of(\"|\"));\n+        auto fr = argsIn.end();\n+        for (const std::string & argName : vargNames) {\n+            fr = argsIn.find(argName);\n+            if (fr != argsIn.end()) {\n+                break;\n+            }\n+        }\n         if (fr != argsIn.end()) {\n             for (int i = 0; i < hole; ++i) {\n                 // Fill hole between specified parameters with JSON nulls,\n@@ -526,12 +536,12 @@ void RPCUnsetTimerInterface(RPCTimerInterface *iface)\n         timerInterface = NULL;\n }\n \n-void RPCRunLater(const std::string& name, boost::function<void(void)> func, int64_t nSeconds)\n+void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds)\n {\n     if (!timerInterface)\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"No timer handler registered for RPC\");\n     deadlineTimers.erase(name);\n-    LogPrint(\"rpc\", \"queue run of timer %s in %i seconds (using %s)\\n\", name, nSeconds, timerInterface->Name());\n+    LogPrint(BCLog::RPC, \"queue run of timer %s in %i seconds (using %s)\\n\", name, nSeconds, timerInterface->Name());\n     deadlineTimers.emplace(name, std::unique_ptr<RPCTimerBase>(timerInterface->NewTimer(func, nSeconds*1000)));\n }\n "
      },
      {
        "sha": "a893f49033d67496355b5363c4076d868a0c6293",
        "filename": "src/rpc/server.h",
        "status": "modified",
        "additions": 7,
        "deletions": 11,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/server.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/rpc/server.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -15,8 +15,6 @@\n #include <stdint.h>\n #include <string>\n \n-#include <boost/function.hpp>\n-\n #include <univalue.h>\n \n static const unsigned int DEFAULT_RPC_SERIALIZE_VERSION = 1;\n@@ -25,9 +23,9 @@ class CRPCCommand;\n \n namespace RPCServer\n {\n-    void OnStarted(boost::function<void ()> slot);\n-    void OnStopped(boost::function<void ()> slot);\n-    void OnPreCommand(boost::function<void (const CRPCCommand&)> slot);\n+    void OnStarted(std::function<void ()> slot);\n+    void OnStopped(std::function<void ()> slot);\n+    void OnPreCommand(std::function<void (const CRPCCommand&)> slot);\n }\n \n class CBlockIndex;\n@@ -52,7 +50,7 @@ class JSONRPCRequest\n     std::string URI;\n     std::string authUser;\n \n-    JSONRPCRequest() { id = NullUniValue; params = NullUniValue; fHelp = false; }\n+    JSONRPCRequest() : id(NullUniValue), params(NullUniValue), fHelp(false) {}\n     void parse(const UniValue& valRequest);\n };\n \n@@ -68,7 +66,7 @@ void SetRPCWarmupStatus(const std::string& newStatus);\n void SetRPCWarmupFinished();\n \n /* returns the current warmup state.  */\n-bool RPCIsInWarmup(std::string *statusOut);\n+bool RPCIsInWarmup(std::string *outStatus);\n \n /**\n  * Type-check arguments; throws JSONRPCError if wrong type given. Does not check that\n@@ -115,7 +113,7 @@ class RPCTimerInterface\n      * This is needed to cope with the case in which there is no HTTP server, but\n      * only GUI RPC console, and to break the dependency of pcserver on httprpc.\n      */\n-    virtual RPCTimerBase* NewTimer(boost::function<void(void)>& func, int64_t millis) = 0;\n+    virtual RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) = 0;\n };\n \n /** Set the factory function for timers */\n@@ -129,7 +127,7 @@ void RPCUnsetTimerInterface(RPCTimerInterface *iface);\n  * Run func nSeconds from now.\n  * Overrides previous timer <name> (if any).\n  */\n-void RPCRunLater(const std::string& name, boost::function<void(void)> func, int64_t nSeconds);\n+void RPCRunLater(const std::string& name, std::function<void(void)> func, int64_t nSeconds);\n \n typedef UniValue(*rpcfn_type)(const JSONRPCRequest& jsonRequest);\n \n@@ -191,15 +189,13 @@ extern std::vector<unsigned char> ParseHexO(const UniValue& o, std::string strKe\n \n extern CAmount AmountFromValue(const UniValue& value);\n extern UniValue ValueFromAmount(const CAmount& amount);\n-extern double GetDifficulty(const CBlockIndex* blockindex = NULL);\n extern std::string HelpExampleCli(const std::string& methodname, const std::string& args);\n extern std::string HelpExampleRpc(const std::string& methodname, const std::string& args);\n \n bool StartRPC();\n void InterruptRPC();\n void StopRPC();\n std::string JSONRPCExecBatch(const UniValue& vReq);\n-void RPCNotifyBlockChange(bool ibd, const CBlockIndex *);\n \n // Retrieves any serialization flags requested in command line argument\n int RPCSerializationFlags();"
      },
      {
        "sha": "923ba2c231ede81b503d4923de93571033ab0862",
        "filename": "src/scheduler.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/scheduler.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/scheduler.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scheduler.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -4,6 +4,7 @@\n \n #include \"scheduler.h\"\n \n+#include \"random.h\"\n #include \"reverselock.h\"\n \n #include <assert.h>\n@@ -23,7 +24,9 @@ CScheduler::~CScheduler()\n #if BOOST_VERSION < 105000\n static boost::system_time toPosixTime(const boost::chrono::system_clock::time_point& t)\n {\n-    return boost::posix_time::from_time_t(boost::chrono::system_clock::to_time_t(t));\n+    // Creating the posix_time using from_time_t loses sub-second precision. So rather than exporting the time_point to time_t,\n+    // start with a posix_time at the epoch (0) and add the milliseconds that have passed since then.\n+    return boost::posix_time::from_time_t(0) + boost::posix_time::milliseconds(boost::chrono::duration_cast<boost::chrono::milliseconds>(t.time_since_epoch()).count());\n }\n #endif\n \n@@ -37,6 +40,11 @@ void CScheduler::serviceQueue()\n     // is called.\n     while (!shouldStop()) {\n         try {\n+            if (!shouldStop() && taskQueue.empty()) {\n+                reverse_lock<boost::unique_lock<boost::mutex> > rlock(lock);\n+                // Use this chance to get a tiny bit more entropy\n+                RandAddSeedSleep();\n+            }\n             while (!shouldStop() && taskQueue.empty()) {\n                 // Wait until there is something to do.\n                 newTaskScheduled.wait(lock);"
      },
      {
        "sha": "27412a15b465b1a98cbc46613fc17b11c45b40cd",
        "filename": "src/scheduler.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/scheduler.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/scheduler.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scheduler.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -7,8 +7,8 @@\n \n //\n // NOTE:\n-// boost::thread / boost::function / boost::chrono should be ported to\n-// std::thread / std::function / std::chrono when we support C++11.\n+// boost::thread / boost::chrono should be ported to std::thread / std::chrono\n+// when we support C++11.\n //\n #include <boost/chrono/chrono.hpp>\n #include <boost/thread.hpp>"
      },
      {
        "sha": "222cff59eab2581fb879dd5c6e1c43fba099f2e5",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -247,10 +247,10 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n {\n     static const CScriptNum bnZero(0);\n     static const CScriptNum bnOne(1);\n-    static const CScriptNum bnFalse(0);\n-    static const CScriptNum bnTrue(1);\n+    // static const CScriptNum bnFalse(0);\n+    // static const CScriptNum bnTrue(1);\n     static const valtype vchFalse(0);\n-    static const valtype vchZero(0);\n+    // static const valtype vchZero(0);\n     static const valtype vchTrue(1, 1);\n \n     CScript::const_iterator pc = script.begin();\n@@ -1028,7 +1028,7 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n             }\n \n             // Size limits\n-            if (stack.size() + altstack.size() > 1000)\n+            if (stack.size() + altstack.size() > MAX_STACK_SIZE)\n                 return set_error(serror, SCRIPT_ERR_STACK_SIZE);\n         }\n     }\n@@ -1142,24 +1142,24 @@ class CTransactionSignatureSerializer {\n \n uint256 GetPrevoutHash(const CTransaction& txTo) {\n     CHashWriter ss(SER_GETHASH, 0);\n-    for (unsigned int n = 0; n < txTo.vin.size(); n++) {\n-        ss << txTo.vin[n].prevout;\n+    for (const auto& txin : txTo.vin) {\n+        ss << txin.prevout;\n     }\n     return ss.GetHash();\n }\n \n uint256 GetSequenceHash(const CTransaction& txTo) {\n     CHashWriter ss(SER_GETHASH, 0);\n-    for (unsigned int n = 0; n < txTo.vin.size(); n++) {\n-        ss << txTo.vin[n].nSequence;\n+    for (const auto& txin : txTo.vin) {\n+        ss << txin.nSequence;\n     }\n     return ss.GetHash();\n }\n \n uint256 GetOutputsHash(const CTransaction& txTo) {\n     CHashWriter ss(SER_GETHASH, 0);\n-    for (unsigned int n = 0; n < txTo.vout.size(); n++) {\n-        ss << txTo.vout[n];\n+    for (const auto& txout : txTo.vout) {\n+        ss << txout;\n     }\n     return ss.GetHash();\n }"
      },
      {
        "sha": "a10b619f7d439facc87c512ed820ddf3442e07b8",
        "filename": "src/script/script.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/script/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/script/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -267,3 +267,16 @@ std::string CScriptWitness::ToString() const\n     }\n     return ret + \")\";\n }\n+\n+bool CScript::HasValidOps() const\n+{\n+    CScript::const_iterator it = begin();\n+    while (it < end()) {\n+        opcodetype opcode;\n+        std::vector<unsigned char> item;\n+        if (!GetOp(it, opcode, item) || opcode > MAX_OPCODE || item.size() > MAX_SCRIPT_ELEMENT_SIZE) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}"
      },
      {
        "sha": "23706b9826dd34de61e02988552def888c7953f7",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -30,6 +30,9 @@ static const int MAX_PUBKEYS_PER_MULTISIG = 20;\n // Maximum script length in bytes\n static const int MAX_SCRIPT_SIZE = 10000;\n \n+// Maximum number of values on script interpreter stack\n+static const int MAX_STACK_SIZE = 1000;\n+\n // Threshold for nLockTime: below this value it is interpreted as block number,\n // otherwise as UNIX timestamp.\n static const unsigned int LOCKTIME_THRESHOLD = 500000000; // Tue Nov  5 00:53:20 1985 UTC\n@@ -187,6 +190,9 @@ enum opcodetype\n     OP_INVALIDOPCODE = 0xff,\n };\n \n+// Maximum value that an opcode can be\n+static const unsigned int MAX_OPCODE = OP_NOP10;\n+\n const char* GetOpName(opcodetype opcode);\n \n class scriptnum_error : public std::runtime_error\n@@ -627,6 +633,9 @@ class CScript : public CScriptBase\n     bool IsPushOnly(const_iterator pc) const;\n     bool IsPushOnly() const;\n \n+    /** Check if the script contains valid OP_CODES */\n+    bool HasValidOps() const;\n+\n     /**\n      * Returns whether the script is guaranteed to fail at execution,\n      * regardless of the initial stack. This allows outputs to be pruned"
      },
      {
        "sha": "7bb8d9941b56dbdba54a57861250639bc1cc7fe3",
        "filename": "src/script/sigcache.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 22,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/script/sigcache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/script/sigcache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -15,28 +15,6 @@\n #include <boost/thread.hpp>\n \n namespace {\n-\n-/**\n- * We're hashing a nonce into the entries themselves, so we don't need extra\n- * blinding in the set hash computation.\n- *\n- * This may exhibit platform endian dependent behavior but because these are\n- * nonced hashes (random) and this state is only ever used locally it is safe.\n- * All that matters is local consistency.\n- */\n-class SignatureCacheHasher\n-{\n-public:\n-    template <uint8_t hash_select>\n-    uint32_t operator()(const uint256& key) const\n-    {\n-        static_assert(hash_select <8, \"SignatureCacheHasher only has 8 hashes available.\");\n-        uint32_t u;\n-        std::memcpy(&u, key.begin()+4*hash_select, 4);\n-        return u;\n-    }\n-};\n-\n /**\n  * Valid signature cache, to avoid doing expensive ECDSA signature checking\n  * twice for every transaction (once when accepted into memory pool, and"
      },
      {
        "sha": "55cec4cc8d730edaf87b9a3557e186c78f561cb1",
        "filename": "src/script/sigcache.h",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/script/sigcache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/script/sigcache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -19,6 +19,27 @@ static const int64_t MAX_MAX_SIG_CACHE_SIZE = 16384;\n \n class CPubKey;\n \n+/**\n+ * We're hashing a nonce into the entries themselves, so we don't need extra\n+ * blinding in the set hash computation.\n+ *\n+ * This may exhibit platform endian dependent behavior but because these are\n+ * nonced hashes (random) and this state is only ever used locally it is safe.\n+ * All that matters is local consistency.\n+ */\n+class SignatureCacheHasher\n+{\n+public:\n+    template <uint8_t hash_select>\n+    uint32_t operator()(const uint256& key) const\n+    {\n+        static_assert(hash_select <8, \"SignatureCacheHasher only has 8 hashes available.\");\n+        uint32_t u;\n+        std::memcpy(&u, key.begin()+4*hash_select, 4);\n+        return u;\n+    }\n+};\n+\n class CachingTransactionSignatureChecker : public TransactionSignatureChecker\n {\n private:"
      },
      {
        "sha": "c071fbe2753c9bda4c8d7b74143dc15878572c4b",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -93,7 +93,10 @@ TESTS =\n if USE_TESTS\n noinst_PROGRAMS += tests\n tests_SOURCES = src/tests.c\n-tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src -I$(top_srcdir)/include $(SECP_INCLUDES) $(SECP_TEST_INCLUDES)\n+if !ENABLE_COVERAGE\n+tests_CPPFLAGS += -DVERIFY\n+endif\n tests_LDADD = $(SECP_LIBS) $(SECP_TEST_LIBS) $(COMMON_LIB)\n tests_LDFLAGS = -static\n TESTS += tests\n@@ -102,7 +105,10 @@ endif\n if USE_EXHAUSTIVE_TESTS\n noinst_PROGRAMS += exhaustive_tests\n exhaustive_tests_SOURCES = src/tests_exhaustive.c\n-exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -DVERIFY -I$(top_srcdir)/src $(SECP_INCLUDES)\n+exhaustive_tests_CPPFLAGS = -DSECP256K1_BUILD -I$(top_srcdir)/src $(SECP_INCLUDES)\n+if !ENABLE_COVERAGE\n+exhaustive_tests_CPPFLAGS += -DVERIFY\n+endif\n exhaustive_tests_LDADD = $(SECP_LIBS)\n exhaustive_tests_LDFLAGS = -static\n TESTS += exhaustive_tests"
      },
      {
        "sha": "e5fcbcb4edf2ace1c2b8740fc118b1e784f12d5e",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 16,
        "deletions": 1,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -20,7 +20,7 @@ AC_PATH_TOOL(STRIP, strip)\n AX_PROG_CC_FOR_BUILD\n \n if test \"x$CFLAGS\" = \"x\"; then\n-  CFLAGS=\"-O3 -g\"\n+  CFLAGS=\"-g\"\n fi\n \n AM_PROG_CC_C_O\n@@ -89,6 +89,11 @@ AC_ARG_ENABLE(benchmark,\n     [use_benchmark=$enableval],\n     [use_benchmark=no])\n \n+AC_ARG_ENABLE(coverage,\n+    AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis]),\n+    [enable_coverage=$enableval],\n+    [enable_coverage=no])\n+\n AC_ARG_ENABLE(tests,\n     AS_HELP_STRING([--enable-tests],[compile tests (default is yes)]),\n     [use_tests=$enableval],\n@@ -154,6 +159,14 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[void myfunc() {__builtin_expect(0,0);}]])],\n     [ AC_MSG_RESULT([no])\n     ])\n \n+if test x\"$enable_coverage\" = x\"yes\"; then\n+    AC_DEFINE(COVERAGE, 1, [Define this symbol to compile out all VERIFY code])\n+    CFLAGS=\"$CFLAGS -O0 --coverage\"\n+    LDFLAGS=\"--coverage\"\n+else\n+    CFLAGS=\"$CFLAGS -O3\"\n+fi\n+\n if test x\"$use_ecmult_static_precomputation\" != x\"no\"; then\n   save_cross_compiling=$cross_compiling\n   cross_compiling=no\n@@ -434,6 +447,7 @@ AC_MSG_NOTICE([Using field implementation: $set_field])\n AC_MSG_NOTICE([Using bignum implementation: $set_bignum])\n AC_MSG_NOTICE([Using scalar implementation: $set_scalar])\n AC_MSG_NOTICE([Using endomorphism optimizations: $use_endomorphism])\n+AC_MSG_NOTICE([Building for coverage analysis: $enable_coverage])\n AC_MSG_NOTICE([Building ECDH module: $enable_module_ecdh])\n AC_MSG_NOTICE([Building ECDSA pubkey recovery module: $enable_module_recovery])\n AC_MSG_NOTICE([Using jni: $use_jni])\n@@ -460,6 +474,7 @@ AC_SUBST(SECP_INCLUDES)\n AC_SUBST(SECP_LIBS)\n AC_SUBST(SECP_TEST_LIBS)\n AC_SUBST(SECP_TEST_INCLUDES)\n+AM_CONDITIONAL([ENABLE_COVERAGE], [test x\"$enable_coverage\" = x\"yes\"])\n AM_CONDITIONAL([USE_TESTS], [test x\"$use_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_EXHAUSTIVE_TESTS], [test x\"$use_exhaustive_tests\" != x\"no\"])\n AM_CONDITIONAL([USE_BENCHMARK], [test x\"$use_benchmark\" = x\"yes\"])"
      },
      {
        "sha": "fc4c5cefbb3b654855908761b9a68be88303b813",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 38,
        "deletions": 1,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -163,6 +163,8 @@ typedef int (*secp256k1_nonce_function)(\n  *\n  *  Returns: a newly created context object.\n  *  In:      flags: which parts of the context to initialize.\n+ *\n+ *  See also secp256k1_context_randomize.\n  */\n SECP256K1_API secp256k1_context* secp256k1_context_create(\n     unsigned int flags\n@@ -485,6 +487,28 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_create(\n     const unsigned char *seckey\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n+/** Negates a private key in place.\n+ *\n+ *  Returns: 1 always\n+ *  Args:   ctx:        pointer to a context object\n+ *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_negate(\n+    const secp256k1_context* ctx,\n+    unsigned char *seckey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+\n+/** Negates a public key in place.\n+ *\n+ *  Returns: 1 always\n+ *  Args:   ctx:        pointer to a context object\n+ *  In/Out: pubkey:     pointer to the public key to be negated (cannot be NULL)\n+ */\n+SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_negate(\n+    const secp256k1_context* ctx,\n+    secp256k1_pubkey *pubkey\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2);\n+\n /** Tweak a private key by adding tweak to it.\n  * Returns: 0 if the tweak was out of range (chance of around 1 in 2^128 for\n  *          uniformly random 32-byte arrays, or if the resulting private key\n@@ -543,11 +567,24 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n     const unsigned char *tweak\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_ARG_NONNULL(3);\n \n-/** Updates the context randomization.\n+/** Updates the context randomization to protect against side-channel leakage.\n  *  Returns: 1: randomization successfully updated\n  *           0: error\n  *  Args:    ctx:       pointer to a context object (cannot be NULL)\n  *  In:      seed32:    pointer to a 32-byte random seed (NULL resets to initial state)\n+ *\n+ * While secp256k1 code is written to be constant-time no matter what secret\n+ * values are, it's possible that a future compiler may output code which isn't,\n+ * and also that the CPU may not emit the same radio frequencies or draw the same\n+ * amount power for all values.\n+ *\n+ * This function provides a seed which is combined into the blinding value: that\n+ * blinding value is added before each multiplication (and removed afterwards) so\n+ * that it does not affect function results, but shields against attacks which\n+ * rely on any input-dependent behaviour.\n+ *\n+ * You should call this after secp256k1_context_create or\n+ * secp256k1_context_clone, and may call this repeatedly afterwards.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(\n     secp256k1_context* ctx,"
      },
      {
        "sha": "d67f08a4267bcb2e03e8ffbedb8c01de2691863b",
        "filename": "src/secp256k1/src/bench.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/bench.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/bench.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -23,7 +23,7 @@ void print_number(double x) {\n     if (y < 0.0) {\n         y = -y;\n     }\n-    while (y < 100.0) {\n+    while (y > 0 && y < 100.0) {\n         y *= 10.0;\n         c++;\n     }"
      },
      {
        "sha": "5f137dda23ef3a62326a6aee21cd152fa09860da",
        "filename": "src/secp256k1/src/bench_schnorr_verify.c",
        "status": "removed",
        "additions": 0,
        "deletions": 73,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3192e5278abca7c1f3b4a2a7f77a0ce941c73985/src/secp256k1/src/bench_schnorr_verify.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3192e5278abca7c1f3b4a2a7f77a0ce941c73985/src/secp256k1/src/bench_schnorr_verify.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_schnorr_verify.c?ref=3192e5278abca7c1f3b4a2a7f77a0ce941c73985",
        "patch": "@@ -1,73 +0,0 @@\n-/**********************************************************************\n- * Copyright (c) 2014 Pieter Wuille                                   *\n- * Distributed under the MIT software license, see the accompanying   *\n- * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n- **********************************************************************/\n-\n-#include <stdio.h>\n-#include <string.h>\n-\n-#include \"include/secp256k1.h\"\n-#include \"include/secp256k1_schnorr.h\"\n-#include \"util.h\"\n-#include \"bench.h\"\n-\n-typedef struct {\n-    unsigned char key[32];\n-    unsigned char sig[64];\n-    unsigned char pubkey[33];\n-    size_t pubkeylen;\n-} benchmark_schnorr_sig_t;\n-\n-typedef struct {\n-    secp256k1_context *ctx;\n-    unsigned char msg[32];\n-    benchmark_schnorr_sig_t sigs[64];\n-    int numsigs;\n-} benchmark_schnorr_verify_t;\n-\n-static void benchmark_schnorr_init(void* arg) {\n-    int i, k;\n-    benchmark_schnorr_verify_t* data = (benchmark_schnorr_verify_t*)arg;\n-\n-    for (i = 0; i < 32; i++) {\n-        data->msg[i] = 1 + i;\n-    }\n-    for (k = 0; k < data->numsigs; k++) {\n-        secp256k1_pubkey pubkey;\n-        for (i = 0; i < 32; i++) {\n-            data->sigs[k].key[i] = 33 + i + k;\n-        }\n-        secp256k1_schnorr_sign(data->ctx, data->sigs[k].sig, data->msg, data->sigs[k].key, NULL, NULL);\n-        data->sigs[k].pubkeylen = 33;\n-        CHECK(secp256k1_ec_pubkey_create(data->ctx, &pubkey, data->sigs[k].key));\n-        CHECK(secp256k1_ec_pubkey_serialize(data->ctx, data->sigs[k].pubkey, &data->sigs[k].pubkeylen, &pubkey, SECP256K1_EC_COMPRESSED));\n-    }\n-}\n-\n-static void benchmark_schnorr_verify(void* arg) {\n-    int i;\n-    benchmark_schnorr_verify_t* data = (benchmark_schnorr_verify_t*)arg;\n-\n-    for (i = 0; i < 20000 / data->numsigs; i++) {\n-        secp256k1_pubkey pubkey;\n-        data->sigs[0].sig[(i >> 8) % 64] ^= (i & 0xFF);\n-        CHECK(secp256k1_ec_pubkey_parse(data->ctx, &pubkey, data->sigs[0].pubkey, data->sigs[0].pubkeylen));\n-        CHECK(secp256k1_schnorr_verify(data->ctx, data->sigs[0].sig, data->msg, &pubkey) == ((i & 0xFF) == 0));\n-        data->sigs[0].sig[(i >> 8) % 64] ^= (i & 0xFF);\n-    }\n-}\n-\n-\n-\n-int main(void) {\n-    benchmark_schnorr_verify_t data;\n-\n-    data.ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n-\n-    data.numsigs = 1;\n-    run_benchmark(\"schnorr_verify\", benchmark_schnorr_verify, benchmark_schnorr_init, NULL, &data, 10, 20000);\n-\n-    secp256k1_context_destroy(data.ctx);\n-    return 0;\n-}"
      },
      {
        "sha": "453bb1188066f90f7b4648ac19c8e78212973e11",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "modified",
        "additions": 5,
        "deletions": 11,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -225,14 +225,12 @@ static int secp256k1_ecdsa_sig_verify(const secp256k1_ecmult_context *ctx, const\n #if defined(EXHAUSTIVE_TEST_ORDER)\n {\n     secp256k1_scalar computed_r;\n-    int overflow = 0;\n     secp256k1_ge pr_ge;\n     secp256k1_ge_set_gej(&pr_ge, &pr);\n     secp256k1_fe_normalize(&pr_ge.x);\n \n     secp256k1_fe_get_b32(c, &pr_ge.x);\n-    secp256k1_scalar_set_b32(&computed_r, c, &overflow);\n-    /* we fully expect overflow */\n+    secp256k1_scalar_set_b32(&computed_r, c, NULL);\n     return secp256k1_scalar_eq(sigr, &computed_r);\n }\n #else\n@@ -285,14 +283,10 @@ static int secp256k1_ecdsa_sig_sign(const secp256k1_ecmult_gen_context *ctx, sec\n     secp256k1_fe_normalize(&r.y);\n     secp256k1_fe_get_b32(b, &r.x);\n     secp256k1_scalar_set_b32(sigr, b, &overflow);\n-    if (secp256k1_scalar_is_zero(sigr)) {\n-        /* P.x = order is on the curve, so technically sig->r could end up zero, which would be an invalid signature.\n-         * This branch is cryptographically unreachable as hitting it requires finding the discrete log of P.x = N.\n-         */\n-        secp256k1_gej_clear(&rp);\n-        secp256k1_ge_clear(&r);\n-        return 0;\n-    }\n+    /* These two conditions should be checked before calling */\n+    VERIFY_CHECK(!secp256k1_scalar_is_zero(sigr));\n+    VERIFY_CHECK(overflow == 0);\n+\n     if (recid) {\n         /* The overflow condition is cryptographically unreachable as hitting it requires finding the discrete log\n          * of some P where P.x >= order, and only 1 in about 2^127 points meet this criteria."
      },
      {
        "sha": "234c13a644233b15d84aa45183c5674ad37457ce",
        "filename": "src/secp256k1/src/field_10x26_impl.h",
        "status": "modified",
        "additions": 43,
        "deletions": 26,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/field_10x26_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/field_10x26_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_10x26_impl.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -38,10 +38,6 @@ static void secp256k1_fe_verify(const secp256k1_fe *a) {\n     }\n     VERIFY_CHECK(r == 1);\n }\n-#else\n-static void secp256k1_fe_verify(const secp256k1_fe *a) {\n-    (void)a;\n-}\n #endif\n \n static void secp256k1_fe_normalize(secp256k1_fe *r) {\n@@ -325,17 +321,17 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n }\n \n static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n-    int i;\n-    r->n[0] = r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n-    r->n[5] = r->n[6] = r->n[7] = r->n[8] = r->n[9] = 0;\n-    for (i=0; i<32; i++) {\n-        int j;\n-        for (j=0; j<4; j++) {\n-            int limb = (8*i+2*j)/26;\n-            int shift = (8*i+2*j)%26;\n-            r->n[limb] |= (uint32_t)((a[31-i] >> (2*j)) & 0x3) << shift;\n-        }\n-    }\n+    r->n[0] = (uint32_t)a[31] | ((uint32_t)a[30] << 8) | ((uint32_t)a[29] << 16) | ((uint32_t)(a[28] & 0x3) << 24);\n+    r->n[1] = (uint32_t)((a[28] >> 2) & 0x3f) | ((uint32_t)a[27] << 6) | ((uint32_t)a[26] << 14) | ((uint32_t)(a[25] & 0xf) << 22);\n+    r->n[2] = (uint32_t)((a[25] >> 4) & 0xf) | ((uint32_t)a[24] << 4) | ((uint32_t)a[23] << 12) | ((uint32_t)(a[22] & 0x3f) << 20);\n+    r->n[3] = (uint32_t)((a[22] >> 6) & 0x3) | ((uint32_t)a[21] << 2) | ((uint32_t)a[20] << 10) | ((uint32_t)a[19] << 18);\n+    r->n[4] = (uint32_t)a[18] | ((uint32_t)a[17] << 8) | ((uint32_t)a[16] << 16) | ((uint32_t)(a[15] & 0x3) << 24);\n+    r->n[5] = (uint32_t)((a[15] >> 2) & 0x3f) | ((uint32_t)a[14] << 6) | ((uint32_t)a[13] << 14) | ((uint32_t)(a[12] & 0xf) << 22);\n+    r->n[6] = (uint32_t)((a[12] >> 4) & 0xf) | ((uint32_t)a[11] << 4) | ((uint32_t)a[10] << 12) | ((uint32_t)(a[9] & 0x3f) << 20);\n+    r->n[7] = (uint32_t)((a[9] >> 6) & 0x3) | ((uint32_t)a[8] << 2) | ((uint32_t)a[7] << 10) | ((uint32_t)a[6] << 18);\n+    r->n[8] = (uint32_t)a[5] | ((uint32_t)a[4] << 8) | ((uint32_t)a[3] << 16) | ((uint32_t)(a[2] & 0x3) << 24);\n+    r->n[9] = (uint32_t)((a[2] >> 2) & 0x3f) | ((uint32_t)a[1] << 6) | ((uint32_t)a[0] << 14);\n+\n     if (r->n[9] == 0x3FFFFFUL && (r->n[8] & r->n[7] & r->n[6] & r->n[5] & r->n[4] & r->n[3] & r->n[2]) == 0x3FFFFFFUL && (r->n[1] + 0x40UL + ((r->n[0] + 0x3D1UL) >> 26)) > 0x3FFFFFFUL) {\n         return 0;\n     }\n@@ -349,21 +345,42 @@ static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n \n /** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n static void secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe *a) {\n-    int i;\n #ifdef VERIFY\n     VERIFY_CHECK(a->normalized);\n     secp256k1_fe_verify(a);\n #endif\n-    for (i=0; i<32; i++) {\n-        int j;\n-        int c = 0;\n-        for (j=0; j<4; j++) {\n-            int limb = (8*i+2*j)/26;\n-            int shift = (8*i+2*j)%26;\n-            c |= ((a->n[limb] >> shift) & 0x3) << (2 * j);\n-        }\n-        r[31-i] = c;\n-    }\n+    r[0] = (a->n[9] >> 14) & 0xff;\n+    r[1] = (a->n[9] >> 6) & 0xff;\n+    r[2] = ((a->n[9] & 0x3F) << 2) | ((a->n[8] >> 24) & 0x3);\n+    r[3] = (a->n[8] >> 16) & 0xff;\n+    r[4] = (a->n[8] >> 8) & 0xff;\n+    r[5] = a->n[8] & 0xff;\n+    r[6] = (a->n[7] >> 18) & 0xff;\n+    r[7] = (a->n[7] >> 10) & 0xff;\n+    r[8] = (a->n[7] >> 2) & 0xff;\n+    r[9] = ((a->n[7] & 0x3) << 6) | ((a->n[6] >> 20) & 0x3f);\n+    r[10] = (a->n[6] >> 12) & 0xff;\n+    r[11] = (a->n[6] >> 4) & 0xff;\n+    r[12] = ((a->n[6] & 0xf) << 4) | ((a->n[5] >> 22) & 0xf);\n+    r[13] = (a->n[5] >> 14) & 0xff;\n+    r[14] = (a->n[5] >> 6) & 0xff;\n+    r[15] = ((a->n[5] & 0x3f) << 2) | ((a->n[4] >> 24) & 0x3);\n+    r[16] = (a->n[4] >> 16) & 0xff;\n+    r[17] = (a->n[4] >> 8) & 0xff;\n+    r[18] = a->n[4] & 0xff;\n+    r[19] = (a->n[3] >> 18) & 0xff;\n+    r[20] = (a->n[3] >> 10) & 0xff;\n+    r[21] = (a->n[3] >> 2) & 0xff;\n+    r[22] = ((a->n[3] & 0x3) << 6) | ((a->n[2] >> 20) & 0x3f);\n+    r[23] = (a->n[2] >> 12) & 0xff;\n+    r[24] = (a->n[2] >> 4) & 0xff;\n+    r[25] = ((a->n[2] & 0xf) << 4) | ((a->n[1] >> 22) & 0xf);\n+    r[26] = (a->n[1] >> 14) & 0xff;\n+    r[27] = (a->n[1] >> 6) & 0xff;\n+    r[28] = ((a->n[1] & 0x3f) << 2) | ((a->n[0] >> 24) & 0x3);\n+    r[29] = (a->n[0] >> 16) & 0xff;\n+    r[30] = (a->n[0] >> 8) & 0xff;\n+    r[31] = a->n[0] & 0xff;\n }\n \n SECP256K1_INLINE static void secp256k1_fe_negate(secp256k1_fe *r, const secp256k1_fe *a, int m) {"
      },
      {
        "sha": "8e8b286baff86a7e7796380e977194c2255483c2",
        "filename": "src/secp256k1/src/field_5x52_impl.h",
        "status": "modified",
        "additions": 66,
        "deletions": 25,
        "changes": 91,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/field_5x52_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/field_5x52_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/field_5x52_impl.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -49,10 +49,6 @@ static void secp256k1_fe_verify(const secp256k1_fe *a) {\n     }\n     VERIFY_CHECK(r == 1);\n }\n-#else\n-static void secp256k1_fe_verify(const secp256k1_fe *a) {\n-    (void)a;\n-}\n #endif\n \n static void secp256k1_fe_normalize(secp256k1_fe *r) {\n@@ -288,16 +284,40 @@ static int secp256k1_fe_cmp_var(const secp256k1_fe *a, const secp256k1_fe *b) {\n }\n \n static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n-    int i;\n-    r->n[0] = r->n[1] = r->n[2] = r->n[3] = r->n[4] = 0;\n-    for (i=0; i<32; i++) {\n-        int j;\n-        for (j=0; j<2; j++) {\n-            int limb = (8*i+4*j)/52;\n-            int shift = (8*i+4*j)%52;\n-            r->n[limb] |= (uint64_t)((a[31-i] >> (4*j)) & 0xF) << shift;\n-        }\n-    }\n+    r->n[0] = (uint64_t)a[31]\n+            | ((uint64_t)a[30] << 8)\n+            | ((uint64_t)a[29] << 16)\n+            | ((uint64_t)a[28] << 24)\n+            | ((uint64_t)a[27] << 32)\n+            | ((uint64_t)a[26] << 40)\n+            | ((uint64_t)(a[25] & 0xF)  << 48);\n+    r->n[1] = (uint64_t)((a[25] >> 4) & 0xF)\n+            | ((uint64_t)a[24] << 4)\n+            | ((uint64_t)a[23] << 12)\n+            | ((uint64_t)a[22] << 20)\n+            | ((uint64_t)a[21] << 28)\n+            | ((uint64_t)a[20] << 36)\n+            | ((uint64_t)a[19] << 44);\n+    r->n[2] = (uint64_t)a[18]\n+            | ((uint64_t)a[17] << 8)\n+            | ((uint64_t)a[16] << 16)\n+            | ((uint64_t)a[15] << 24)\n+            | ((uint64_t)a[14] << 32)\n+            | ((uint64_t)a[13] << 40)\n+            | ((uint64_t)(a[12] & 0xF) << 48);\n+    r->n[3] = (uint64_t)((a[12] >> 4) & 0xF)\n+            | ((uint64_t)a[11] << 4)\n+            | ((uint64_t)a[10] << 12)\n+            | ((uint64_t)a[9]  << 20)\n+            | ((uint64_t)a[8]  << 28)\n+            | ((uint64_t)a[7]  << 36)\n+            | ((uint64_t)a[6]  << 44);\n+    r->n[4] = (uint64_t)a[5]\n+            | ((uint64_t)a[4] << 8)\n+            | ((uint64_t)a[3] << 16)\n+            | ((uint64_t)a[2] << 24)\n+            | ((uint64_t)a[1] << 32)\n+            | ((uint64_t)a[0] << 40);\n     if (r->n[4] == 0x0FFFFFFFFFFFFULL && (r->n[3] & r->n[2] & r->n[1]) == 0xFFFFFFFFFFFFFULL && r->n[0] >= 0xFFFFEFFFFFC2FULL) {\n         return 0;\n     }\n@@ -311,21 +331,42 @@ static int secp256k1_fe_set_b32(secp256k1_fe *r, const unsigned char *a) {\n \n /** Convert a field element to a 32-byte big endian value. Requires the input to be normalized */\n static void secp256k1_fe_get_b32(unsigned char *r, const secp256k1_fe *a) {\n-    int i;\n #ifdef VERIFY\n     VERIFY_CHECK(a->normalized);\n     secp256k1_fe_verify(a);\n #endif\n-    for (i=0; i<32; i++) {\n-        int j;\n-        int c = 0;\n-        for (j=0; j<2; j++) {\n-            int limb = (8*i+4*j)/52;\n-            int shift = (8*i+4*j)%52;\n-            c |= ((a->n[limb] >> shift) & 0xF) << (4 * j);\n-        }\n-        r[31-i] = c;\n-    }\n+    r[0] = (a->n[4] >> 40) & 0xFF;\n+    r[1] = (a->n[4] >> 32) & 0xFF;\n+    r[2] = (a->n[4] >> 24) & 0xFF;\n+    r[3] = (a->n[4] >> 16) & 0xFF;\n+    r[4] = (a->n[4] >> 8) & 0xFF;\n+    r[5] = a->n[4] & 0xFF;\n+    r[6] = (a->n[3] >> 44) & 0xFF;\n+    r[7] = (a->n[3] >> 36) & 0xFF;\n+    r[8] = (a->n[3] >> 28) & 0xFF;\n+    r[9] = (a->n[3] >> 20) & 0xFF;\n+    r[10] = (a->n[3] >> 12) & 0xFF;\n+    r[11] = (a->n[3] >> 4) & 0xFF;\n+    r[12] = ((a->n[2] >> 48) & 0xF) | ((a->n[3] & 0xF) << 4);\n+    r[13] = (a->n[2] >> 40) & 0xFF;\n+    r[14] = (a->n[2] >> 32) & 0xFF;\n+    r[15] = (a->n[2] >> 24) & 0xFF;\n+    r[16] = (a->n[2] >> 16) & 0xFF;\n+    r[17] = (a->n[2] >> 8) & 0xFF;\n+    r[18] = a->n[2] & 0xFF;\n+    r[19] = (a->n[1] >> 44) & 0xFF;\n+    r[20] = (a->n[1] >> 36) & 0xFF;\n+    r[21] = (a->n[1] >> 28) & 0xFF;\n+    r[22] = (a->n[1] >> 20) & 0xFF;\n+    r[23] = (a->n[1] >> 12) & 0xFF;\n+    r[24] = (a->n[1] >> 4) & 0xFF;\n+    r[25] = ((a->n[0] >> 48) & 0xF) | ((a->n[1] & 0xF) << 4);\n+    r[26] = (a->n[0] >> 40) & 0xFF;\n+    r[27] = (a->n[0] >> 32) & 0xFF;\n+    r[28] = (a->n[0] >> 24) & 0xFF;\n+    r[29] = (a->n[0] >> 16) & 0xFF;\n+    r[30] = (a->n[0] >> 8) & 0xFF;\n+    r[31] = a->n[0] & 0xFF;\n }\n \n SECP256K1_INLINE static void secp256k1_fe_negate(secp256k1_fe *r, const secp256k1_fe *a, int m) {"
      },
      {
        "sha": "7d723532ff3e12c1767540d019e35ede17a7c6c4",
        "filename": "src/secp256k1/src/group_impl.h",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/group_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/group_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/group_impl.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -200,12 +200,6 @@ static void secp256k1_gej_set_infinity(secp256k1_gej *r) {\n     secp256k1_fe_clear(&r->z);\n }\n \n-static void secp256k1_ge_set_infinity(secp256k1_ge *r) {\n-    r->infinity = 1;\n-    secp256k1_fe_clear(&r->x);\n-    secp256k1_fe_clear(&r->y);\n-}\n-\n static void secp256k1_gej_clear(secp256k1_gej *r) {\n     r->infinity = 0;\n     secp256k1_fe_clear(&r->x);"
      },
      {
        "sha": "9e30fb73dd7fb98b6e860cfb9054f1d66fb4089a",
        "filename": "src/secp256k1/src/modules/ecdh/main_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/modules/ecdh/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/modules/ecdh/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/main_impl.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -16,10 +16,10 @@ int secp256k1_ecdh(const secp256k1_context* ctx, unsigned char *result, const se\n     secp256k1_gej res;\n     secp256k1_ge pt;\n     secp256k1_scalar s;\n+    VERIFY_CHECK(ctx != NULL);\n     ARG_CHECK(result != NULL);\n     ARG_CHECK(point != NULL);\n     ARG_CHECK(scalar != NULL);\n-    (void)ctx;\n \n     secp256k1_pubkey_load(ctx, &pt, point);\n     secp256k1_scalar_set_b32(&s, scalar, &overflow);"
      },
      {
        "sha": "85a5d0a9a69e10d585c2bc2ad4df03f14cf0def6",
        "filename": "src/secp256k1/src/modules/ecdh/tests_impl.h",
        "status": "modified",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/modules/ecdh/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/modules/ecdh/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/ecdh/tests_impl.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -7,6 +7,35 @@\n #ifndef _SECP256K1_MODULE_ECDH_TESTS_\n #define _SECP256K1_MODULE_ECDH_TESTS_\n \n+void test_ecdh_api(void) {\n+    /* Setup context that just counts errors */\n+    secp256k1_context *tctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_pubkey point;\n+    unsigned char res[32];\n+    unsigned char s_one[32] = { 0 };\n+    int32_t ecount = 0;\n+    s_one[31] = 1;\n+\n+    secp256k1_context_set_error_callback(tctx, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(tctx, counting_illegal_callback_fn, &ecount);\n+    CHECK(secp256k1_ec_pubkey_create(tctx, &point, s_one) == 1);\n+\n+    /* Check all NULLs are detected */\n+    CHECK(secp256k1_ecdh(tctx, res, &point, s_one) == 1);\n+    CHECK(ecount == 0);\n+    CHECK(secp256k1_ecdh(tctx, NULL, &point, s_one) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdh(tctx, res, NULL, s_one) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdh(tctx, res, &point, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdh(tctx, res, &point, s_one) == 1);\n+    CHECK(ecount == 3);\n+\n+    /* Cleanup */\n+    secp256k1_context_destroy(tctx);\n+}\n+\n void test_ecdh_generator_basepoint(void) {\n     unsigned char s_one[32] = { 0 };\n     secp256k1_pubkey point[2];\n@@ -68,6 +97,7 @@ void test_bad_scalar(void) {\n }\n \n void run_ecdh_tests(void) {\n+    test_ecdh_api();\n     test_ecdh_generator_basepoint();\n     test_bad_scalar();\n }"
      },
      {
        "sha": "c6fbe239813a3e45559bd36098d3d2ca2dac145a",
        "filename": "src/secp256k1/src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/main_impl.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -179,7 +179,7 @@ int secp256k1_ecdsa_recover(const secp256k1_context* ctx, secp256k1_pubkey *pubk\n     ARG_CHECK(pubkey != NULL);\n \n     secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, signature);\n-    ARG_CHECK(recid >= 0 && recid < 4);\n+    VERIFY_CHECK(recid >= 0 && recid < 4);  /* should have been caught in parse_compact */\n     secp256k1_scalar_set_b32(&m, msg32, NULL);\n     if (secp256k1_ecdsa_sig_recover(&ctx->ecmult_ctx, &r, &s, &q, &m, recid)) {\n         secp256k1_pubkey_save(pubkey, &q);"
      },
      {
        "sha": "765c7dd81e958c9ca37ee50117b286e90b6c7f7f",
        "filename": "src/secp256k1/src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 143,
        "deletions": 0,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/tests_impl.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -7,6 +7,146 @@\n #ifndef _SECP256K1_MODULE_RECOVERY_TESTS_\n #define _SECP256K1_MODULE_RECOVERY_TESTS_\n \n+static int recovery_test_nonce_function(unsigned char *nonce32, const unsigned char *msg32, const unsigned char *key32, const unsigned char *algo16, void *data, unsigned int counter) {\n+    (void) msg32;\n+    (void) key32;\n+    (void) algo16;\n+    (void) data;\n+\n+    /* On the first run, return 0 to force a second run */\n+    if (counter == 0) {\n+        memset(nonce32, 0, 32);\n+        return 1;\n+    }\n+    /* On the second run, return an overflow to force a third run */\n+    if (counter == 1) {\n+        memset(nonce32, 0xff, 32);\n+        return 1;\n+    }\n+    /* On the next run, return a valid nonce, but flip a coin as to whether or not to fail signing. */\n+    memset(nonce32, 1, 32);\n+    return secp256k1_rand_bits(1);\n+}\n+\n+void test_ecdsa_recovery_api(void) {\n+    /* Setup contexts that just count errors */\n+    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_pubkey pubkey;\n+    secp256k1_pubkey recpubkey;\n+    secp256k1_ecdsa_signature normal_sig;\n+    secp256k1_ecdsa_recoverable_signature recsig;\n+    unsigned char privkey[32] = { 1 };\n+    unsigned char message[32] = { 2 };\n+    int32_t ecount = 0;\n+    int recid = 0;\n+    unsigned char sig[74];\n+    unsigned char zero_privkey[32] = { 0 };\n+    unsigned char over_privkey[32] = { 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+                                       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+                                       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff,\n+                                       0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff, 0xff };\n+\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(both, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(sign, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_illegal_callback(both, counting_illegal_callback_fn, &ecount);\n+\n+    /* Construct and verify corresponding public key. */\n+    CHECK(secp256k1_ec_seckey_verify(ctx, privkey) == 1);\n+    CHECK(secp256k1_ec_pubkey_create(ctx, &pubkey, privkey) == 1);\n+\n+    /* Check bad contexts and NULLs for signing */\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_sign_recoverable(none, &recsig, message, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(sign, &recsig, message, privkey, NULL, NULL) == 1);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(vrfy, &recsig, message, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, NULL, NULL) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, NULL, message, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, NULL, privkey, NULL, NULL) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, NULL, NULL, NULL) == 0);\n+    CHECK(ecount == 5);\n+    /* This will fail or succeed randomly, and in either case will not ARG_CHECK failure */\n+    secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, recovery_test_nonce_function, NULL);\n+    CHECK(ecount == 5);\n+    /* These will all fail, but not in ARG_CHECK way */\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, zero_privkey, NULL, NULL) == 0);\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, over_privkey, NULL, NULL) == 0);\n+    /* This one will succeed. */\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, NULL, NULL) == 1);\n+    CHECK(ecount == 5);\n+\n+    /* Check signing with a goofy nonce function */\n+\n+    /* Check bad contexts and NULLs for recovery */\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_recover(none, &recpubkey, &recsig, message) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_recover(sign, &recpubkey, &recsig, message) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(vrfy, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, message) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recover(both, NULL, &recsig, message) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdsa_recover(both, &recpubkey, NULL, message) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_ecdsa_recover(both, &recpubkey, &recsig, NULL) == 0);\n+    CHECK(ecount == 5);\n+\n+    /* Check NULLs for conversion */\n+    CHECK(secp256k1_ecdsa_sign(both, &normal_sig, message, privkey, NULL, NULL) == 1);\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_recoverable_signature_convert(both, NULL, &recsig) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_convert(both, &normal_sig, NULL) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_convert(both, &normal_sig, &recsig) == 1);\n+\n+    /* Check NULLs for de/serialization */\n+    CHECK(secp256k1_ecdsa_sign_recoverable(both, &recsig, message, privkey, NULL, NULL) == 1);\n+    ecount = 0;\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, NULL, &recid, &recsig) == 0);\n+    CHECK(ecount == 1);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, sig, NULL, &recsig) == 0);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, sig, &recid, NULL) == 0);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_serialize_compact(both, sig, &recid, &recsig) == 1);\n+\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, NULL, sig, recid) == 0);\n+    CHECK(ecount == 4);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, NULL, recid) == 0);\n+    CHECK(ecount == 5);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, sig, -1) == 0);\n+    CHECK(ecount == 6);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, sig, 5) == 0);\n+    CHECK(ecount == 7);\n+    /* overflow in signature will fail but not affect ecount */\n+    memcpy(sig, over_privkey, 32);\n+    CHECK(secp256k1_ecdsa_recoverable_signature_parse_compact(both, &recsig, sig, recid) == 0);\n+    CHECK(ecount == 7);\n+\n+    /* cleanup */\n+    secp256k1_context_destroy(none);\n+    secp256k1_context_destroy(sign);\n+    secp256k1_context_destroy(vrfy);\n+    secp256k1_context_destroy(both);\n+}\n+\n void test_ecdsa_recovery_end_to_end(void) {\n     unsigned char extra[32] = {0x00};\n     unsigned char privkey[32];\n@@ -241,6 +381,9 @@ void test_ecdsa_recovery_edge_cases(void) {\n \n void run_recovery_tests(void) {\n     int i;\n+    for (i = 0; i < count; i++) {\n+        test_ecdsa_recovery_api();\n+    }\n     for (i = 0; i < 64*count; i++) {\n         test_ecdsa_recovery_end_to_end();\n     }"
      },
      {
        "sha": "2690d86558a9a1973ee5f4cc9c339c527718c54c",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 67,
        "deletions": 104,
        "changes": 171,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -66,88 +66,79 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n #else\n     secp256k1_scalar *t;\n     int i;\n-    /* First compute x ^ (2^N - 1) for some values of N. */\n-    secp256k1_scalar x2, x3, x4, x6, x7, x8, x15, x30, x60, x120, x127;\n+    /* First compute xN as x ^ (2^N - 1) for some values of N,\n+     * and uM as x ^ M for some values of M. */\n+    secp256k1_scalar x2, x3, x6, x8, x14, x28, x56, x112, x126;\n+    secp256k1_scalar u2, u5, u9, u11, u13;\n \n-    secp256k1_scalar_sqr(&x2,  x);\n-    secp256k1_scalar_mul(&x2, &x2,  x);\n+    secp256k1_scalar_sqr(&u2, x);\n+    secp256k1_scalar_mul(&x2, &u2,  x);\n+    secp256k1_scalar_mul(&u5, &u2, &x2);\n+    secp256k1_scalar_mul(&x3, &u5,  &u2);\n+    secp256k1_scalar_mul(&u9, &x3, &u2);\n+    secp256k1_scalar_mul(&u11, &u9, &u2);\n+    secp256k1_scalar_mul(&u13, &u11, &u2);\n \n-    secp256k1_scalar_sqr(&x3, &x2);\n-    secp256k1_scalar_mul(&x3, &x3,  x);\n-\n-    secp256k1_scalar_sqr(&x4, &x3);\n-    secp256k1_scalar_mul(&x4, &x4,  x);\n-\n-    secp256k1_scalar_sqr(&x6, &x4);\n+    secp256k1_scalar_sqr(&x6, &u13);\n     secp256k1_scalar_sqr(&x6, &x6);\n-    secp256k1_scalar_mul(&x6, &x6, &x2);\n-\n-    secp256k1_scalar_sqr(&x7, &x6);\n-    secp256k1_scalar_mul(&x7, &x7,  x);\n+    secp256k1_scalar_mul(&x6, &x6, &u11);\n \n-    secp256k1_scalar_sqr(&x8, &x7);\n-    secp256k1_scalar_mul(&x8, &x8,  x);\n+    secp256k1_scalar_sqr(&x8, &x6);\n+    secp256k1_scalar_sqr(&x8, &x8);\n+    secp256k1_scalar_mul(&x8, &x8,  &x2);\n \n-    secp256k1_scalar_sqr(&x15, &x8);\n-    for (i = 0; i < 6; i++) {\n-        secp256k1_scalar_sqr(&x15, &x15);\n+    secp256k1_scalar_sqr(&x14, &x8);\n+    for (i = 0; i < 5; i++) {\n+        secp256k1_scalar_sqr(&x14, &x14);\n     }\n-    secp256k1_scalar_mul(&x15, &x15, &x7);\n+    secp256k1_scalar_mul(&x14, &x14, &x6);\n \n-    secp256k1_scalar_sqr(&x30, &x15);\n-    for (i = 0; i < 14; i++) {\n-        secp256k1_scalar_sqr(&x30, &x30);\n+    secp256k1_scalar_sqr(&x28, &x14);\n+    for (i = 0; i < 13; i++) {\n+        secp256k1_scalar_sqr(&x28, &x28);\n     }\n-    secp256k1_scalar_mul(&x30, &x30, &x15);\n+    secp256k1_scalar_mul(&x28, &x28, &x14);\n \n-    secp256k1_scalar_sqr(&x60, &x30);\n-    for (i = 0; i < 29; i++) {\n-        secp256k1_scalar_sqr(&x60, &x60);\n+    secp256k1_scalar_sqr(&x56, &x28);\n+    for (i = 0; i < 27; i++) {\n+        secp256k1_scalar_sqr(&x56, &x56);\n     }\n-    secp256k1_scalar_mul(&x60, &x60, &x30);\n+    secp256k1_scalar_mul(&x56, &x56, &x28);\n \n-    secp256k1_scalar_sqr(&x120, &x60);\n-    for (i = 0; i < 59; i++) {\n-        secp256k1_scalar_sqr(&x120, &x120);\n+    secp256k1_scalar_sqr(&x112, &x56);\n+    for (i = 0; i < 55; i++) {\n+        secp256k1_scalar_sqr(&x112, &x112);\n     }\n-    secp256k1_scalar_mul(&x120, &x120, &x60);\n+    secp256k1_scalar_mul(&x112, &x112, &x56);\n \n-    secp256k1_scalar_sqr(&x127, &x120);\n-    for (i = 0; i < 6; i++) {\n-        secp256k1_scalar_sqr(&x127, &x127);\n+    secp256k1_scalar_sqr(&x126, &x112);\n+    for (i = 0; i < 13; i++) {\n+        secp256k1_scalar_sqr(&x126, &x126);\n     }\n-    secp256k1_scalar_mul(&x127, &x127, &x7);\n+    secp256k1_scalar_mul(&x126, &x126, &x14);\n \n-    /* Then accumulate the final result (t starts at x127). */\n-    t = &x127;\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    /* Then accumulate the final result (t starts at x126). */\n+    t = &x126;\n+    for (i = 0; i < 3; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n     for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 4; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n+    for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 3; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n+    for (i = 0; i < 4; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n+    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n     for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n@@ -156,38 +147,26 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x3); /* 111 */\n-    for (i = 0; i < 4; i++) { /* 00 */\n+    for (i = 0; i < 6; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 4; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n+    for (i = 0; i < 3; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &x3); /* 111 */\n     for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x4); /* 1111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 4; i++) { /* 000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n+    for (i = 0; i < 6; i++) { /* 000 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &u5); /* 101 */\n     for (i = 0; i < 10; i++) { /* 0000000 */\n         secp256k1_scalar_sqr(t, t);\n     }\n@@ -200,50 +179,34 @@ static void secp256k1_scalar_inverse(secp256k1_scalar *r, const secp256k1_scalar\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x8); /* 11111111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n     for (i = 0; i < 5; i++) { /* 0 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x4); /* 1111 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n+    for (i = 0; i < 6; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 5; i++) { /* 000 */\n+    secp256k1_scalar_mul(t, t, &u11); /* 1011 */\n+    for (i = 0; i < 4; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 4; i++) { /* 00 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 5; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n     secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 2; i++) { /* 0 */\n+    for (i = 0; i < 6; i++) { /* 00 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n-    for (i = 0; i < 8; i++) { /* 000000 */\n-        secp256k1_scalar_sqr(t, t);\n-    }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 3; i++) { /* 0 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 10; i++) { /* 000000 */\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, &x2); /* 11 */\n-    for (i = 0; i < 3; i++) { /* 00 */\n+    secp256k1_scalar_mul(t, t, &u13); /* 1101 */\n+    for (i = 0; i < 4; i++) {\n         secp256k1_scalar_sqr(t, t);\n     }\n-    secp256k1_scalar_mul(t, t, x); /* 1 */\n+    secp256k1_scalar_mul(t, t, &u9); /* 1001 */\n     for (i = 0; i < 6; i++) { /* 00000 */\n         secp256k1_scalar_sqr(t, t);\n     }"
      },
      {
        "sha": "4f8c01655bd00eed0565b698f7029421b5fd1562",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 27,
        "deletions": 4,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -424,6 +424,33 @@ int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *p\n     return ret;\n }\n \n+int secp256k1_ec_privkey_negate(const secp256k1_context* ctx, unsigned char *seckey) {\n+    secp256k1_scalar sec;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(seckey != NULL);\n+\n+    secp256k1_scalar_set_b32(&sec, seckey, NULL);\n+    secp256k1_scalar_negate(&sec, &sec);\n+    secp256k1_scalar_get_b32(seckey, &sec);\n+\n+    return 1;\n+}\n+\n+int secp256k1_ec_pubkey_negate(const secp256k1_context* ctx, secp256k1_pubkey *pubkey) {\n+    int ret = 0;\n+    secp256k1_ge p;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(pubkey != NULL);\n+\n+    ret = secp256k1_pubkey_load(ctx, &p, pubkey);\n+    memset(pubkey, 0, sizeof(*pubkey));\n+    if (ret) {\n+        secp256k1_ge_neg(&p, &p);\n+        secp256k1_pubkey_save(pubkey, &p);\n+    }\n+    return ret;\n+}\n+\n int secp256k1_ec_privkey_tweak_add(const secp256k1_context* ctx, unsigned char *seckey, const unsigned char *tweak) {\n     secp256k1_scalar term;\n     secp256k1_scalar sec;\n@@ -552,10 +579,6 @@ int secp256k1_ec_pubkey_combine(const secp256k1_context* ctx, secp256k1_pubkey *\n # include \"modules/ecdh/main_impl.h\"\n #endif\n \n-#ifdef ENABLE_MODULE_SCHNORR\n-# include \"modules/schnorr/main_impl.h\"\n-#endif\n-\n #ifdef ENABLE_MODULE_RECOVERY\n # include \"modules/recovery/main_impl.h\"\n #endif"
      },
      {
        "sha": "3d9bd5ebb48d46dff2d677976f850ad8809592e7",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 31,
        "deletions": 20,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -10,6 +10,7 @@\n \n #include <stdio.h>\n #include <stdlib.h>\n+#include <string.h>\n \n #include <time.h>\n \n@@ -135,6 +136,7 @@ void random_scalar_order(secp256k1_scalar *num) {\n \n void run_context_tests(void) {\n     secp256k1_pubkey pubkey;\n+    secp256k1_pubkey zero_pubkey;\n     secp256k1_ecdsa_signature sig;\n     unsigned char ctmp[32];\n     int32_t ecount;\n@@ -149,6 +151,8 @@ void run_context_tests(void) {\n     secp256k1_scalar msg, key, nonce;\n     secp256k1_scalar sigr, sigs;\n \n+    memset(&zero_pubkey, 0, sizeof(zero_pubkey));\n+\n     ecount = 0;\n     ecount2 = 10;\n     secp256k1_context_set_illegal_callback(vrfy, counting_illegal_callback_fn, &ecount);\n@@ -201,12 +205,20 @@ void run_context_tests(void) {\n     CHECK(ecount == 2);\n     CHECK(secp256k1_ec_pubkey_tweak_mul(sign, &pubkey, ctmp) == 0);\n     CHECK(ecount2 == 13);\n-    CHECK(secp256k1_ec_pubkey_tweak_mul(vrfy, &pubkey, ctmp) == 1);\n+    CHECK(secp256k1_ec_pubkey_negate(vrfy, &pubkey) == 1);\n     CHECK(ecount == 2);\n-    CHECK(secp256k1_context_randomize(vrfy, ctmp) == 0);\n+    CHECK(secp256k1_ec_pubkey_negate(sign, &pubkey) == 1);\n+    CHECK(ecount == 2);\n+    CHECK(secp256k1_ec_pubkey_negate(sign, NULL) == 0);\n+    CHECK(ecount2 == 14);\n+    CHECK(secp256k1_ec_pubkey_negate(vrfy, &zero_pubkey) == 0);\n     CHECK(ecount == 3);\n+    CHECK(secp256k1_ec_pubkey_tweak_mul(vrfy, &pubkey, ctmp) == 1);\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_context_randomize(vrfy, ctmp) == 0);\n+    CHECK(ecount == 4);\n     CHECK(secp256k1_context_randomize(sign, NULL) == 1);\n-    CHECK(ecount2 == 13);\n+    CHECK(ecount2 == 14);\n     secp256k1_context_set_illegal_callback(vrfy, NULL, NULL);\n     secp256k1_context_set_illegal_callback(sign, NULL, NULL);\n \n@@ -1879,9 +1891,9 @@ void test_ge(void) {\n      *\n      * When the endomorphism code is compiled in, p5 = lambda*p1 and p6 = lambda^2*p1 are added as well.\n      */\n-    secp256k1_ge *ge = (secp256k1_ge *)malloc(sizeof(secp256k1_ge) * (1 + 4 * runs));\n-    secp256k1_gej *gej = (secp256k1_gej *)malloc(sizeof(secp256k1_gej) * (1 + 4 * runs));\n-    secp256k1_fe *zinv = (secp256k1_fe *)malloc(sizeof(secp256k1_fe) * (1 + 4 * runs));\n+    secp256k1_ge *ge = (secp256k1_ge *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_ge) * (1 + 4 * runs));\n+    secp256k1_gej *gej = (secp256k1_gej *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_gej) * (1 + 4 * runs));\n+    secp256k1_fe *zinv = (secp256k1_fe *)checked_malloc(&ctx->error_callback, sizeof(secp256k1_fe) * (1 + 4 * runs));\n     secp256k1_fe zf;\n     secp256k1_fe zfi2, zfi3;\n \n@@ -1919,7 +1931,7 @@ void test_ge(void) {\n \n     /* Compute z inverses. */\n     {\n-        secp256k1_fe *zs = malloc(sizeof(secp256k1_fe) * (1 + 4 * runs));\n+        secp256k1_fe *zs = checked_malloc(&ctx->error_callback, sizeof(secp256k1_fe) * (1 + 4 * runs));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             if (i == 0) {\n                 /* The point at infinity does not have a meaningful z inverse. Any should do. */\n@@ -2020,7 +2032,7 @@ void test_ge(void) {\n     /* Test adding all points together in random order equals infinity. */\n     {\n         secp256k1_gej sum = SECP256K1_GEJ_CONST_INFINITY;\n-        secp256k1_gej *gej_shuffled = (secp256k1_gej *)malloc((4 * runs + 1) * sizeof(secp256k1_gej));\n+        secp256k1_gej *gej_shuffled = (secp256k1_gej *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_gej));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             gej_shuffled[i] = gej[i];\n         }\n@@ -2041,9 +2053,9 @@ void test_ge(void) {\n \n     /* Test batch gej -> ge conversion with and without known z ratios. */\n     {\n-        secp256k1_fe *zr = (secp256k1_fe *)malloc((4 * runs + 1) * sizeof(secp256k1_fe));\n-        secp256k1_ge *ge_set_table = (secp256k1_ge *)malloc((4 * runs + 1) * sizeof(secp256k1_ge));\n-        secp256k1_ge *ge_set_all = (secp256k1_ge *)malloc((4 * runs + 1) * sizeof(secp256k1_ge));\n+        secp256k1_fe *zr = (secp256k1_fe *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_fe));\n+        secp256k1_ge *ge_set_table = (secp256k1_ge *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_ge));\n+        secp256k1_ge *ge_set_all = (secp256k1_ge *)checked_malloc(&ctx->error_callback, (4 * runs + 1) * sizeof(secp256k1_ge));\n         for (i = 0; i < 4 * runs + 1; i++) {\n             /* Compute gej[i + 1].z / gez[i].z (with gej[n].z taken to be 1). */\n             if (i < 4 * runs) {\n@@ -3436,6 +3448,7 @@ void test_ecdsa_end_to_end(void) {\n     unsigned char pubkeyc[65];\n     size_t pubkeyclen = 65;\n     secp256k1_pubkey pubkey;\n+    secp256k1_pubkey pubkey_tmp;\n     unsigned char seckey[300];\n     size_t seckeylen = 300;\n \n@@ -3457,6 +3470,13 @@ void test_ecdsa_end_to_end(void) {\n     memset(&pubkey, 0, sizeof(pubkey));\n     CHECK(secp256k1_ec_pubkey_parse(ctx, &pubkey, pubkeyc, pubkeyclen) == 1);\n \n+    /* Verify negation changes the key and changes it back */\n+    memcpy(&pubkey_tmp, &pubkey, sizeof(pubkey));\n+    CHECK(secp256k1_ec_pubkey_negate(ctx, &pubkey_tmp) == 1);\n+    CHECK(memcmp(&pubkey_tmp, &pubkey, sizeof(pubkey)) != 0);\n+    CHECK(secp256k1_ec_pubkey_negate(ctx, &pubkey_tmp) == 1);\n+    CHECK(memcmp(&pubkey_tmp, &pubkey, sizeof(pubkey)) == 0);\n+\n     /* Verify private key import and export. */\n     CHECK(ec_privkey_export_der(ctx, seckey, &seckeylen, privkey, secp256k1_rand_bits(1) == 1));\n     CHECK(ec_privkey_import_der(ctx, privkey2, seckey, seckeylen) == 1);\n@@ -4383,10 +4403,6 @@ void run_ecdsa_openssl(void) {\n # include \"modules/ecdh/tests_impl.h\"\n #endif\n \n-#ifdef ENABLE_MODULE_SCHNORR\n-# include \"modules/schnorr/tests_impl.h\"\n-#endif\n-\n #ifdef ENABLE_MODULE_RECOVERY\n # include \"modules/recovery/tests_impl.h\"\n #endif\n@@ -4504,11 +4520,6 @@ int main(int argc, char **argv) {\n     run_ecdsa_openssl();\n #endif\n \n-#ifdef ENABLE_MODULE_SCHNORR\n-    /* Schnorr tests */\n-    run_schnorr_tests();\n-#endif\n-\n #ifdef ENABLE_MODULE_RECOVERY\n     /* ECDSA pubkey recovery tests */\n     run_recovery_tests();"
      },
      {
        "sha": "b040bb0733ddf1abef0b715b807d3133db37d2f8",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "modified",
        "additions": 142,
        "deletions": 1,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -26,6 +26,11 @@\n #include \"secp256k1.c\"\n #include \"testrand_impl.h\"\n \n+#ifdef ENABLE_MODULE_RECOVERY\n+#include \"src/modules/recovery/main_impl.h\"\n+#include \"include/secp256k1_recovery.h\"\n+#endif\n+\n /** stolen from tests.c */\n void ge_equals_ge(const secp256k1_ge *a, const secp256k1_ge *b) {\n     CHECK(a->infinity == b->infinity);\n@@ -77,7 +82,7 @@ int secp256k1_nonce_function_smallint(unsigned char *nonce32, const unsigned cha\n      * function with an increased `attempt`. So if attempt > 0 this means we\n      * need to change the nonce to avoid an infinite loop. */\n     if (attempt > 0) {\n-        (*idata)++;\n+        *idata = (*idata + 1) % EXHAUSTIVE_TEST_ORDER;\n     }\n     secp256k1_scalar_set_int(&s, *idata);\n     secp256k1_scalar_get_b32(nonce32, &s);\n@@ -244,6 +249,7 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n     for (i = 1; i < order; i++) {  /* message */\n         for (j = 1; j < order; j++) {  /* key */\n             for (k = 1; k < order; k++) {  /* nonce */\n+                const int starting_k = k;\n                 secp256k1_ecdsa_signature sig;\n                 secp256k1_scalar sk, msg, r, s, expected_r;\n                 unsigned char sk32[32], msg32[32];\n@@ -262,6 +268,11 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n                 CHECK(r == expected_r);\n                 CHECK((k * s) % order == (i + r * j) % order ||\n                       (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+\n+                /* Overflow means we've tried every possible nonce */\n+                if (k < starting_k) {\n+                    break;\n+                }\n             }\n         }\n     }\n@@ -276,6 +287,130 @@ void test_exhaustive_sign(const secp256k1_context *ctx, const secp256k1_ge *grou\n      */\n }\n \n+#ifdef ENABLE_MODULE_RECOVERY\n+void test_exhaustive_recovery_sign(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    int i, j, k;\n+\n+    /* Loop */\n+    for (i = 1; i < order; i++) {  /* message */\n+        for (j = 1; j < order; j++) {  /* key */\n+            for (k = 1; k < order; k++) {  /* nonce */\n+                const int starting_k = k;\n+                secp256k1_fe r_dot_y_normalized;\n+                secp256k1_ecdsa_recoverable_signature rsig;\n+                secp256k1_ecdsa_signature sig;\n+                secp256k1_scalar sk, msg, r, s, expected_r;\n+                unsigned char sk32[32], msg32[32];\n+                int expected_recid;\n+                int recid;\n+                secp256k1_scalar_set_int(&msg, i);\n+                secp256k1_scalar_set_int(&sk, j);\n+                secp256k1_scalar_get_b32(sk32, &sk);\n+                secp256k1_scalar_get_b32(msg32, &msg);\n+\n+                secp256k1_ecdsa_sign_recoverable(ctx, &rsig, msg32, sk32, secp256k1_nonce_function_smallint, &k);\n+\n+                /* Check directly */\n+                secp256k1_ecdsa_recoverable_signature_load(ctx, &r, &s, &recid, &rsig);\n+                r_from_k(&expected_r, group, k);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % order == (i + r * j) % order ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+                /* In computing the recid, there is an overflow condition that is disabled in\n+                 * scalar_low_impl.h `secp256k1_scalar_set_b32` because almost every r.y value\n+                 * will exceed the group order, and our signing code always holds out for r\n+                 * values that don't overflow, so with a proper overflow check the tests would\n+                 * loop indefinitely. */\n+                r_dot_y_normalized = group[k].y;\n+                secp256k1_fe_normalize(&r_dot_y_normalized);\n+                /* Also the recovery id is flipped depending if we hit the low-s branch */\n+                if ((k * s) % order == (i + r * j) % order) {\n+                    expected_recid = secp256k1_fe_is_odd(&r_dot_y_normalized) ? 1 : 0;\n+                } else {\n+                    expected_recid = secp256k1_fe_is_odd(&r_dot_y_normalized) ? 0 : 1;\n+                }\n+                CHECK(recid == expected_recid);\n+\n+                /* Convert to a standard sig then check */\n+                secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n+                secp256k1_ecdsa_signature_load(ctx, &r, &s, &sig);\n+                /* Note that we compute expected_r *after* signing -- this is important\n+                 * because our nonce-computing function function might change k during\n+                 * signing. */\n+                r_from_k(&expected_r, group, k);\n+                CHECK(r == expected_r);\n+                CHECK((k * s) % order == (i + r * j) % order ||\n+                      (k * (EXHAUSTIVE_TEST_ORDER - s)) % order == (i + r * j) % order);\n+\n+                /* Overflow means we've tried every possible nonce */\n+                if (k < starting_k) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+void test_exhaustive_recovery_verify(const secp256k1_context *ctx, const secp256k1_ge *group, int order) {\n+    /* This is essentially a copy of test_exhaustive_verify, with recovery added */\n+    int s, r, msg, key;\n+    for (s = 1; s < order; s++) {\n+        for (r = 1; r < order; r++) {\n+            for (msg = 1; msg < order; msg++) {\n+                for (key = 1; key < order; key++) {\n+                    secp256k1_ge nonconst_ge;\n+                    secp256k1_ecdsa_recoverable_signature rsig;\n+                    secp256k1_ecdsa_signature sig;\n+                    secp256k1_pubkey pk;\n+                    secp256k1_scalar sk_s, msg_s, r_s, s_s;\n+                    secp256k1_scalar s_times_k_s, msg_plus_r_times_sk_s;\n+                    int recid = 0;\n+                    int k, should_verify;\n+                    unsigned char msg32[32];\n+\n+                    secp256k1_scalar_set_int(&s_s, s);\n+                    secp256k1_scalar_set_int(&r_s, r);\n+                    secp256k1_scalar_set_int(&msg_s, msg);\n+                    secp256k1_scalar_set_int(&sk_s, key);\n+                    secp256k1_scalar_get_b32(msg32, &msg_s);\n+\n+                    /* Verify by hand */\n+                    /* Run through every k value that gives us this r and check that *one* works.\n+                     * Note there could be none, there could be multiple, ECDSA is weird. */\n+                    should_verify = 0;\n+                    for (k = 0; k < order; k++) {\n+                        secp256k1_scalar check_x_s;\n+                        r_from_k(&check_x_s, group, k);\n+                        if (r_s == check_x_s) {\n+                            secp256k1_scalar_set_int(&s_times_k_s, k);\n+                            secp256k1_scalar_mul(&s_times_k_s, &s_times_k_s, &s_s);\n+                            secp256k1_scalar_mul(&msg_plus_r_times_sk_s, &r_s, &sk_s);\n+                            secp256k1_scalar_add(&msg_plus_r_times_sk_s, &msg_plus_r_times_sk_s, &msg_s);\n+                            should_verify |= secp256k1_scalar_eq(&s_times_k_s, &msg_plus_r_times_sk_s);\n+                        }\n+                    }\n+                    /* nb we have a \"high s\" rule */\n+                    should_verify &= !secp256k1_scalar_is_high(&s_s);\n+\n+                    /* We would like to try recovering the pubkey and checking that it matches,\n+                     * but pubkey recovery is impossible in the exhaustive tests (the reason\n+                     * being that there are 12 nonzero r values, 12 nonzero points, and no\n+                     * overlap between the sets, so there are no valid signatures). */\n+\n+                    /* Verify by converting to a standard signature and calling verify */\n+                    secp256k1_ecdsa_recoverable_signature_save(&rsig, &r_s, &s_s, recid);\n+                    secp256k1_ecdsa_recoverable_signature_convert(ctx, &sig, &rsig);\n+                    memcpy(&nonconst_ge, &group[sk_s], sizeof(nonconst_ge));\n+                    secp256k1_pubkey_save(&pk, &nonconst_ge);\n+                    CHECK(should_verify ==\n+                          secp256k1_ecdsa_verify(ctx, &sig, msg32, &pk));\n+                }\n+            }\n+        }\n+    }\n+}\n+#endif\n+\n int main(void) {\n     int i;\n     secp256k1_gej groupj[EXHAUSTIVE_TEST_ORDER];\n@@ -324,6 +459,12 @@ int main(void) {\n     test_exhaustive_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n     test_exhaustive_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n \n+#ifdef ENABLE_MODULE_RECOVERY\n+    test_exhaustive_recovery_sign(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+    test_exhaustive_recovery_verify(ctx, group, EXHAUSTIVE_TEST_ORDER);\n+#endif\n+\n+    secp256k1_context_destroy(ctx);\n     return 0;\n }\n "
      },
      {
        "sha": "4092a86c9175cb7815cd4ebe5cf791940f72fb47",
        "filename": "src/secp256k1/src/util.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/secp256k1/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/util.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -57,7 +57,10 @@ static SECP256K1_INLINE void secp256k1_callback_call(const secp256k1_callback *\n #endif\n \n /* Like assert(), but when VERIFY is defined, and side-effect safe. */\n-#ifdef VERIFY\n+#if defined(COVERAGE)\n+#define VERIFY_CHECK(check)\n+#define VERIFY_SETUP(stmt)\n+#elif defined(VERIFY)\n #define VERIFY_CHECK CHECK\n #define VERIFY_SETUP(stmt) do { stmt; } while(0)\n #else"
      },
      {
        "sha": "e82ddf2c5a7bbacf018ba8b13b907b58fdff93be",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -336,11 +336,18 @@ I ReadVarInt(Stream& is)\n     I n = 0;\n     while(true) {\n         unsigned char chData = ser_readdata8(is);\n+        if (n > (std::numeric_limits<I>::max() >> 7)) {\n+           throw std::ios_base::failure(\"ReadVarInt(): size too large\");\n+        }\n         n = (n << 7) | (chData & 0x7F);\n-        if (chData & 0x80)\n+        if (chData & 0x80) {\n+            if (n == std::numeric_limits<I>::max()) {\n+                throw std::ios_base::failure(\"ReadVarInt(): size too large\");\n+            }\n             n++;\n-        else\n+        } else {\n             return n;\n+        }\n     }\n }\n "
      },
      {
        "sha": "8dc5a19ead4b5531566e0210dcdaa6ff2837cd00",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -248,7 +248,8 @@ class CDataStream\n \n     void insert(iterator it, std::vector<char>::const_iterator first, std::vector<char>::const_iterator last)\n     {\n-        assert(last - first >= 0);\n+        if (last == first) return;\n+        assert(last - first > 0);\n         if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n         {\n             // special case for inserting at the front when there's room\n@@ -261,7 +262,8 @@ class CDataStream\n \n     void insert(iterator it, const char* first, const char* last)\n     {\n-        assert(last - first >= 0);\n+        if (last == first) return;\n+        assert(last - first > 0);\n         if (it == vch.begin() + nReadPos && (unsigned int)(last - first) <= nReadPos)\n         {\n             // special case for inserting at the front when there's room\n@@ -339,6 +341,8 @@ class CDataStream\n \n     void read(char* pch, size_t nSize)\n     {\n+        if (nSize == 0) return;\n+\n         // Read from the beginning of the buffer\n         unsigned int nReadPosNext = nReadPos + nSize;\n         if (nReadPosNext >= vch.size())"
      },
      {
        "sha": "f020216c7300a6a7894da8157cc2ffe87b3f62a3",
        "filename": "src/support/cleanse.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/support/cleanse.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/support/cleanse.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/cleanse.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -8,6 +8,7 @@\n \n #include <stdlib.h>\n \n+// Attempt to overwrite data in the specified memory span.\n void memory_cleanse(void *ptr, size_t len);\n \n #endif // BITCOIN_SUPPORT_CLEANSE_H"
      },
      {
        "sha": "5bfe6e10ba3db5e881954f1795358d6e28ddc23d",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -18,7 +18,6 @@\n \n #include <stdint.h>\n \n-#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n #include <boost/date_time/posix_time/posix_time_types.hpp>\n #include <boost/foreach.hpp>\n #include <boost/test/unit_test.hpp>\n@@ -51,7 +50,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n \n     connman->ClearBanned();\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n-    CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 0, 0, \"\", true);\n+    CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 0, 0, CAddress(), \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n     GetNodeSignals().InitializeNode(&dummyNode1, *connman);\n     dummyNode1.nVersion = 1;\n@@ -62,7 +61,7 @@ BOOST_AUTO_TEST_CASE(DoS_banning)\n     BOOST_CHECK(!connman->IsBanned(ip(0xa0b0c001|0x0000ff00))); // Different IP, not banned\n \n     CAddress addr2(ip(0xa0b0c002), NODE_NONE);\n-    CNode dummyNode2(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr2, 1, 1, \"\", true);\n+    CNode dummyNode2(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr2, 1, 1, CAddress(), \"\", true);\n     dummyNode2.SetSendVersion(PROTOCOL_VERSION);\n     GetNodeSignals().InitializeNode(&dummyNode2, *connman);\n     dummyNode2.nVersion = 1;\n@@ -83,7 +82,7 @@ BOOST_AUTO_TEST_CASE(DoS_banscore)\n     connman->ClearBanned();\n     ForceSetArg(\"-banscore\", \"111\"); // because 11 is my favorite number\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n-    CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 3, 1, \"\", true);\n+    CNode dummyNode1(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr1, 3, 1, CAddress(), \"\", true);\n     dummyNode1.SetSendVersion(PROTOCOL_VERSION);\n     GetNodeSignals().InitializeNode(&dummyNode1, *connman);\n     dummyNode1.nVersion = 1;\n@@ -109,7 +108,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     SetMockTime(nStartTime); // Overrides future calls to GetTime()\n \n     CAddress addr(ip(0xa0b0c001), NODE_NONE);\n-    CNode dummyNode(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr, 4, 4, \"\", true);\n+    CNode dummyNode(id++, NODE_NETWORK, 0, INVALID_SOCKET, addr, 4, 4, CAddress(), \"\", true);\n     dummyNode.SetSendVersion(PROTOCOL_VERSION);\n     GetNodeSignals().InitializeNode(&dummyNode, *connman);\n     dummyNode.nVersion = 1;\n@@ -129,7 +128,7 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n CTransactionRef RandomOrphan()\n {\n     std::map<uint256, COrphanTx>::iterator it;\n-    it = mapOrphanTransactions.lower_bound(GetRandHash());\n+    it = mapOrphanTransactions.lower_bound(InsecureRand256());\n     if (it == mapOrphanTransactions.end())\n         it = mapOrphanTransactions.begin();\n     return it->second.tx;\n@@ -148,7 +147,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n         CMutableTransaction tx;\n         tx.vin.resize(1);\n         tx.vin[0].prevout.n = 0;\n-        tx.vin[0].prevout.hash = GetRandHash();\n+        tx.vin[0].prevout.hash = InsecureRand256();\n         tx.vin[0].scriptSig << OP_1;\n         tx.vout.resize(1);\n         tx.vout[0].nValue = 1*CENT;"
      },
      {
        "sha": "dc5372a07043988aeb3b4b611bf7c99fc1551587",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 111,
        "deletions": 101,
        "changes": 212,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -84,36 +84,47 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    // Test 1: Does Addrman respond correctly when empty.\n-    BOOST_CHECK(addrman.size() == 0);\n+    // Test: Does Addrman respond correctly when empty.\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n     CAddrInfo addr_null = addrman.Select();\n-    BOOST_CHECK(addr_null.ToString() == \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addr_null.ToString(), \"[::]:0\");\n \n-    // Test 2: Does Addrman::Add work as expected.\n+    // Test: Does Addrman::Add work as expected.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n-    addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK(addrman.Add(CAddress(addr1, NODE_NONE), source));\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n     CAddrInfo addr_ret1 = addrman.Select();\n-    BOOST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n-    // Test 3: Does IP address deduplication work correctly.\n+    // Test: Does IP address deduplication work correctly.\n     //  Expected dup IP should not be added.\n     CService addr1_dup = ResolveService(\"250.1.1.1\", 8333);\n-    addrman.Add(CAddress(addr1_dup, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK(!addrman.Add(CAddress(addr1_dup, NODE_NONE), source));\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n+\n \n+    // Test: New table has one addr and we add a diff addr we should\n+    //  have at least one addr.\n+    // Note that addrman's size cannot be tested reliably after insertion, as\n+    // hash collisions may occur. But we can always be sure of at least one\n+    // success.\n \n-    // Test 5: New table has one addr and we add a diff addr we should\n-    //  have two addrs.\n     CService addr2 = ResolveService(\"250.1.1.2\", 8333);\n-    addrman.Add(CAddress(addr2, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 2);\n+    BOOST_CHECK(addrman.Add(CAddress(addr2, NODE_NONE), source));\n+    BOOST_CHECK(addrman.size() >= 1);\n \n-    // Test 6: AddrMan::Clear() should empty the new table.\n+    // Test: AddrMan::Clear() should empty the new table.\n     addrman.Clear();\n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n     CAddrInfo addr_null2 = addrman.Select();\n-    BOOST_CHECK(addr_null2.ToString() == \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addr_null2.ToString(), \"[::]:0\");\n+\n+    // Test: AddrMan::Add multiple addresses works as expected\n+    std::vector<CAddress> vAddr;\n+    vAddr.push_back(CAddress(ResolveService(\"250.1.1.3\", 8333), NODE_NONE));\n+    vAddr.push_back(CAddress(ResolveService(\"250.1.1.4\", 8333), NODE_NONE));\n+    BOOST_CHECK(addrman.Add(vAddr, source));\n+    BOOST_CHECK(addrman.size() >= 1);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_ports)\n@@ -125,26 +136,26 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     // Test 7; Addr with same IP but diff port does not replace existing addr.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n \n     CService addr1_port = ResolveService(\"250.1.1.1\", 8334);\n     addrman.Add(CAddress(addr1_port, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n     CAddrInfo addr_ret2 = addrman.Select();\n-    BOOST_CHECK(addr_ret2.ToString() == \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"250.1.1.1:8333\");\n \n-    // Test 8: Add same IP but diff port to tried table, it doesn't get added.\n+    // Test: Add same IP but diff port to tried table, it doesn't get added.\n     //  Perhaps this is not ideal behavior but it is the current behavior.\n     addrman.Good(CAddress(addr1_port, NODE_NONE));\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n     bool newOnly = true;\n     CAddrInfo addr_ret3 = addrman.Select(newOnly);\n-    BOOST_CHECK(addr_ret3.ToString() == \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n }\n \n \n@@ -157,25 +168,25 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    // Test 9: Select from new with 1 addr in new.\n+    // Test: Select from new with 1 addr in new.\n     CService addr1 = ResolveService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n \n     bool newOnly = true;\n     CAddrInfo addr_ret1 = addrman.Select(newOnly);\n-    BOOST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addr_ret1.ToString(), \"250.1.1.1:8333\");\n \n-    // Test 10: move addr to tried, select from new expected nothing returned.\n+    // Test: move addr to tried, select from new expected nothing returned.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n     CAddrInfo addr_ret2 = addrman.Select(newOnly);\n-    BOOST_CHECK(addr_ret2.ToString() == \"[::]:0\");\n+    BOOST_CHECK_EQUAL(addr_ret2.ToString(), \"[::]:0\");\n \n     CAddrInfo addr_ret3 = addrman.Select();\n-    BOOST_CHECK(addr_ret3.ToString() == \"250.1.1.1:8333\");\n+    BOOST_CHECK_EQUAL(addr_ret3.ToString(), \"250.1.1.1:8333\");\n \n-    BOOST_CHECK(addrman.size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n \n \n     // Add three addresses to new table.\n@@ -199,14 +210,15 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     addrman.Add(CAddress(addr7, NODE_NONE), ResolveService(\"250.1.1.3\", 8333));\n     addrman.Good(CAddress(addr7, NODE_NONE));\n \n-    // Test 11: 6 addrs + 1 addr from last test = 7.\n-    BOOST_CHECK(addrman.size() == 7);\n+    // Test: 6 addrs + 1 addr from last test = 7.\n+    BOOST_CHECK_EQUAL(addrman.size(), 7);\n \n-    // Test 12: Select pulls from new and tried regardless of port number.\n-    BOOST_CHECK(addrman.Select().ToString() == \"250.4.6.6:8333\");\n-    BOOST_CHECK(addrman.Select().ToString() == \"250.3.2.2:9999\");\n-    BOOST_CHECK(addrman.Select().ToString() == \"250.3.3.3:9999\");\n-    BOOST_CHECK(addrman.Select().ToString() == \"250.4.4.4:8333\");\n+    // Test: Select pulls from new and tried regardless of port number.\n+    std::set<uint16_t> ports;\n+    for (int i = 0; i < 20; ++i) {\n+        ports.insert(addrman.Select().GetPort());\n+    }\n+    BOOST_CHECK_EQUAL(ports.size(), 3);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n@@ -218,24 +230,24 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     for (unsigned int i = 1; i < 18; i++) {\n         CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n \n-        //Test 13: No collision in new table yet.\n-        BOOST_CHECK(addrman.size() == i);\n+        //Test: No collision in new table yet.\n+        BOOST_CHECK_EQUAL(addrman.size(), i);\n     }\n \n-    //Test 14: new table collision!\n+    //Test: new table collision!\n     CService addr1 = ResolveService(\"250.1.1.18\");\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 17);\n+    BOOST_CHECK_EQUAL(addrman.size(), 17);\n \n     CService addr2 = ResolveService(\"250.1.1.19\");\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 18);\n+    BOOST_CHECK_EQUAL(addrman.size(), 18);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n@@ -247,25 +259,25 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n \n     CNetAddr source = ResolveIP(\"252.2.2.2\");\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     for (unsigned int i = 1; i < 80; i++) {\n         CService addr = ResolveService(\"250.1.1.\" + boost::to_string(i));\n         addrman.Add(CAddress(addr, NODE_NONE), source);\n         addrman.Good(CAddress(addr, NODE_NONE));\n \n-        //Test 15: No collision in tried table yet.\n+        //Test: No collision in tried table yet.\n         BOOST_CHECK_EQUAL(addrman.size(), i);\n     }\n \n-    //Test 16: tried table collision!\n+    //Test: tried table collision!\n     CService addr1 = ResolveService(\"250.1.1.80\");\n     addrman.Add(CAddress(addr1, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 79);\n+    BOOST_CHECK_EQUAL(addrman.size(), 79);\n \n     CService addr2 = ResolveService(\"250.1.1.81\");\n     addrman.Add(CAddress(addr2, NODE_NONE), source);\n-    BOOST_CHECK(addrman.size() == 80);\n+    BOOST_CHECK_EQUAL(addrman.size(), 80);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_find)\n@@ -275,7 +287,7 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CAddress addr2 = CAddress(ResolveService(\"250.1.2.1\", 9999), NODE_NONE);\n@@ -288,23 +300,20 @@ BOOST_AUTO_TEST_CASE(addrman_find)\n     addrman.Add(addr2, source2);\n     addrman.Add(addr3, source1);\n \n-    // Test 17: ensure Find returns an IP matching what we searched on.\n+    // Test: ensure Find returns an IP matching what we searched on.\n     CAddrInfo* info1 = addrman.Find(addr1);\n-    BOOST_CHECK(info1);\n-    if (info1)\n-        BOOST_CHECK(info1->ToString() == \"250.1.2.1:8333\");\n+    BOOST_REQUIRE(info1);\n+    BOOST_CHECK_EQUAL(info1->ToString(), \"250.1.2.1:8333\");\n \n     // Test 18; Find does not discriminate by port number.\n     CAddrInfo* info2 = addrman.Find(addr2);\n-    BOOST_CHECK(info2);\n-    if (info2 && info1)\n-        BOOST_CHECK(info2->ToString() == info1->ToString());\n+    BOOST_REQUIRE(info2);\n+    BOOST_CHECK_EQUAL(info2->ToString(), info1->ToString());\n \n-    // Test 19: Find returns another IP matching what we searched on.\n+    // Test: Find returns another IP matching what we searched on.\n     CAddrInfo* info3 = addrman.Find(addr3);\n-    BOOST_CHECK(info3);\n-    if (info3)\n-        BOOST_CHECK(info3->ToString() == \"251.255.2.1:8333\");\n+    BOOST_REQUIRE(info3);\n+    BOOST_CHECK_EQUAL(info3->ToString(), \"251.255.2.1:8333\");\n }\n \n BOOST_AUTO_TEST_CASE(addrman_create)\n@@ -314,19 +323,19 @@ BOOST_AUTO_TEST_CASE(addrman_create)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n     CAddrInfo* pinfo = addrman.Create(addr1, source1, &nId);\n \n-    // Test 20: The result should be the same as the input addr.\n-    BOOST_CHECK(pinfo->ToString() == \"250.1.2.1:8333\");\n+    // Test: The result should be the same as the input addr.\n+    BOOST_CHECK_EQUAL(pinfo->ToString(), \"250.1.2.1:8333\");\n \n     CAddrInfo* info2 = addrman.Find(addr1);\n-    BOOST_CHECK(info2->ToString() == \"250.1.2.1:8333\");\n+    BOOST_CHECK_EQUAL(info2->ToString(), \"250.1.2.1:8333\");\n }\n \n \n@@ -337,18 +346,18 @@ BOOST_AUTO_TEST_CASE(addrman_delete)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.1.2.1\", 8333), NODE_NONE);\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n \n     int nId;\n     addrman.Create(addr1, source1, &nId);\n \n-    // Test 21: Delete should actually delete the addr.\n-    BOOST_CHECK(addrman.size() == 1);\n+    // Test: Delete should actually delete the addr.\n+    BOOST_CHECK_EQUAL(addrman.size(), 1);\n     addrman.Delete(nId);\n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n     CAddrInfo* info2 = addrman.Find(addr1);\n     BOOST_CHECK(info2 == NULL);\n }\n@@ -360,11 +369,11 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    // Test 22: Sanity check, GetAddr should never return anything if addrman\n+    // Test: Sanity check, GetAddr should never return anything if addrman\n     //  is empty.\n-    BOOST_CHECK(addrman.size() == 0);\n+    BOOST_CHECK_EQUAL(addrman.size(), 0);\n     std::vector<CAddress> vAddr1 = addrman.GetAddr();\n-    BOOST_CHECK(vAddr1.size() == 0);\n+    BOOST_CHECK_EQUAL(vAddr1.size(), 0);\n \n     CAddress addr1 = CAddress(ResolveService(\"250.250.2.1\", 8333), NODE_NONE);\n     addr1.nTime = GetAdjustedTime(); // Set time so isTerrible = false\n@@ -379,29 +388,28 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     CNetAddr source1 = ResolveIP(\"250.1.2.1\");\n     CNetAddr source2 = ResolveIP(\"250.2.3.3\");\n \n-    // Test 23: Ensure GetAddr works with new addresses.\n+    // Test: Ensure GetAddr works with new addresses.\n     addrman.Add(addr1, source1);\n     addrman.Add(addr2, source2);\n     addrman.Add(addr3, source1);\n     addrman.Add(addr4, source2);\n     addrman.Add(addr5, source1);\n \n     // GetAddr returns 23% of addresses, 23% of 5 is 1 rounded down.\n-    BOOST_CHECK(addrman.GetAddr().size() == 1); \n+    BOOST_CHECK_EQUAL(addrman.GetAddr().size(), 1);\n \n-    // Test 24: Ensure GetAddr works with new and tried addresses.\n+    // Test: Ensure GetAddr works with new and tried addresses.\n     addrman.Good(CAddress(addr1, NODE_NONE));\n     addrman.Good(CAddress(addr2, NODE_NONE));\n-    BOOST_CHECK(addrman.GetAddr().size() == 1);\n+    BOOST_CHECK_EQUAL(addrman.GetAddr().size(), 1);\n \n-    // Test 25: Ensure GetAddr still returns 23% when addrman has many addrs.\n+    // Test: Ensure GetAddr still returns 23% when addrman has many addrs.\n     for (unsigned int i = 1; i < (8 * 256); i++) {\n         int octet1 = i % 256;\n-        int octet2 = (i / 256) % 256;\n-        int octet3 = (i / (256 * 2)) % 256;\n-        std::string strAddr = boost::to_string(octet1) + \".\" + boost::to_string(octet2) + \".\" + boost::to_string(octet3) + \".23\";\n+        int octet2 = i >> 8 % 256;\n+        std::string strAddr = boost::to_string(octet1) + \".\" + boost::to_string(octet2) + \".1.23\";\n         CAddress addr = CAddress(ResolveService(strAddr), NODE_NONE);\n-        \n+\n         // Ensure that for all addrs in addrman, isTerrible == false.\n         addr.nTime = GetAdjustedTime();\n         addrman.Add(addr, ResolveIP(strAddr));\n@@ -411,10 +419,10 @@ BOOST_AUTO_TEST_CASE(addrman_getaddr)\n     std::vector<CAddress> vAddr = addrman.GetAddr();\n \n     size_t percent23 = (addrman.size() * 23) / 100;\n-    BOOST_CHECK(vAddr.size() == percent23);\n-    BOOST_CHECK(vAddr.size() == 461);\n-    // (Addrman.size() < number of addresses added) due to address collisons.\n-    BOOST_CHECK(addrman.size() == 2007);\n+    BOOST_CHECK_EQUAL(vAddr.size(), percent23);\n+    BOOST_CHECK_EQUAL(vAddr.size(), 461);\n+    // (Addrman.size() < number of addresses added) due to address collisions.\n+    BOOST_CHECK_EQUAL(addrman.size(), 2006);\n }\n \n \n@@ -437,13 +445,13 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n \n \n-    BOOST_CHECK(info1.GetTriedBucket(nKey1) == 40);\n+    BOOST_CHECK_EQUAL(info1.GetTriedBucket(nKey1), 40);\n \n-    // Test 26: Make sure key actually randomizes bucket placement. A fail on\n+    // Test: Make sure key actually randomizes bucket placement. A fail on\n     //  this test could be a security issue.\n     BOOST_CHECK(info1.GetTriedBucket(nKey1) != info1.GetTriedBucket(nKey2));\n \n-    // Test 27: Two addresses with same IP but different ports can map to\n+    // Test: Two addresses with same IP but different ports can map to\n     //  different buckets because they have different keys.\n     CAddrInfo info2 = CAddrInfo(addr2, source1);\n \n@@ -458,9 +466,9 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n         int bucket = infoi.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n-    // Test 28: IP addresses in the same group (\\16 prefix for IPv4) should\n+    // Test: IP addresses in the same group (\\16 prefix for IPv4) should\n     //  never get more than 8 buckets\n-    BOOST_CHECK(buckets.size() == 8);\n+    BOOST_CHECK_EQUAL(buckets.size(), 8);\n \n     buckets.clear();\n     for (int j = 0; j < 255; j++) {\n@@ -470,9 +478,9 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n         int bucket = infoj.GetTriedBucket(nKey1);\n         buckets.insert(bucket);\n     }\n-    // Test 29: IP addresses in the different groups should map to more than\n+    // Test: IP addresses in the different groups should map to more than\n     //  8 buckets.\n-    BOOST_CHECK(buckets.size() == 160);\n+    BOOST_CHECK_EQUAL(buckets.size(), 160);\n }\n \n BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n@@ -492,16 +500,18 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n     uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n     uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n \n-    BOOST_CHECK(info1.GetNewBucket(nKey1) == 786);\n+    // Test: Make sure the buckets are what we expect\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1), 786);\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1, source1), 786);\n \n-    // Test 30: Make sure key actually randomizes bucket placement. A fail on\n+    // Test: Make sure key actually randomizes bucket placement. A fail on\n     //  this test could be a security issue.\n     BOOST_CHECK(info1.GetNewBucket(nKey1) != info1.GetNewBucket(nKey2));\n \n-    // Test 31: Ports should not effect bucket placement in the addr\n+    // Test: Ports should not effect bucket placement in the addr\n     CAddrInfo info2 = CAddrInfo(addr2, source1);\n     BOOST_CHECK(info1.GetKey() != info2.GetKey());\n-    BOOST_CHECK(info1.GetNewBucket(nKey1) == info2.GetNewBucket(nKey1));\n+    BOOST_CHECK_EQUAL(info1.GetNewBucket(nKey1), info2.GetNewBucket(nKey1));\n \n     std::set<int> buckets;\n     for (int i = 0; i < 255; i++) {\n@@ -511,9 +521,9 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n         int bucket = infoi.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n-    // Test 32: IP addresses in the same group (\\16 prefix for IPv4) should\n+    // Test: IP addresses in the same group (\\16 prefix for IPv4) should\n     //  always map to the same bucket.\n-    BOOST_CHECK(buckets.size() == 1);\n+    BOOST_CHECK_EQUAL(buckets.size(), 1);\n \n     buckets.clear();\n     for (int j = 0; j < 4 * 255; j++) {\n@@ -524,7 +534,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n-    // Test 33: IP addresses in the same source groups should map to no more\n+    // Test: IP addresses in the same source groups should map to no more\n     //  than 64 buckets.\n     BOOST_CHECK(buckets.size() <= 64);\n \n@@ -536,7 +546,7 @@ BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n         int bucket = infoj.GetNewBucket(nKey1);\n         buckets.insert(bucket);\n     }\n-    // Test 34: IP addresses in the different source groups should map to more\n+    // Test: IP addresses in the different source groups should map to more\n     //  than 64 buckets.\n     BOOST_CHECK(buckets.size() > 64);\n }"
      },
      {
        "sha": "952cf901f02bd3f5c3dfc9e7cf7f9acc7d25f9ba",
        "filename": "src/test/amount_tests.cpp",
        "status": "modified",
        "additions": 38,
        "deletions": 1,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/amount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/amount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/amount_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -3,15 +3,23 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"amount.h\"\n+#include \"policy/feerate.h\"\n #include \"test/test_bitcoin.h\"\n \n #include <boost/test/unit_test.hpp>\n \n BOOST_FIXTURE_TEST_SUITE(amount_tests, BasicTestingSetup)\n \n+BOOST_AUTO_TEST_CASE(MoneyRangeTest)\n+{\n+    BOOST_CHECK_EQUAL(MoneyRange(CAmount(-1)), false);\n+    BOOST_CHECK_EQUAL(MoneyRange(MAX_MONEY + CAmount(1)), false);\n+    BOOST_CHECK_EQUAL(MoneyRange(CAmount(1)), true);\n+}\n+\n BOOST_AUTO_TEST_CASE(GetFeeTest)\n {\n-    CFeeRate feeRate;\n+    CFeeRate feeRate, altFeeRate;\n \n     feeRate = CFeeRate(0);\n     // Must always return 0\n@@ -53,6 +61,11 @@ BOOST_AUTO_TEST_CASE(GetFeeTest)\n     BOOST_CHECK_EQUAL(feeRate.GetFee(8), -1); // Special case: returns -1 instead of 0\n     BOOST_CHECK_EQUAL(feeRate.GetFee(9), -1);\n \n+    // check alternate constructor\n+    feeRate = CFeeRate(1000);\n+    altFeeRate = CFeeRate(feeRate);\n+    BOOST_CHECK_EQUAL(feeRate.GetFee(100), altFeeRate.GetFee(100));\n+\n     // Check full constructor\n     // default value\n     BOOST_CHECK(CFeeRate(CAmount(-1), 1000) == CFeeRate(-1));\n@@ -68,4 +81,28 @@ BOOST_AUTO_TEST_CASE(GetFeeTest)\n     CFeeRate(MAX_MONEY, std::numeric_limits<size_t>::max() >> 1).GetFeePerK();\n }\n \n+BOOST_AUTO_TEST_CASE(BinaryOperatorTest)\n+{\n+    CFeeRate a, b;\n+    a = CFeeRate(1);\n+    b = CFeeRate(2);\n+    BOOST_CHECK(a < b);\n+    BOOST_CHECK(b > a);\n+    BOOST_CHECK(a == a);\n+    BOOST_CHECK(a <= b);\n+    BOOST_CHECK(a <= a);\n+    BOOST_CHECK(b >= a);\n+    BOOST_CHECK(b >= b);\n+    // a should be 0.00000002 BTC/kB now\n+    a += a;\n+    BOOST_CHECK(a == b);\n+}\n+\n+BOOST_AUTO_TEST_CASE(ToStringTest)\n+{\n+    CFeeRate feeRate;\n+    feeRate = CFeeRate(1);\n+    BOOST_CHECK_EQUAL(feeRate.ToString(), \"0.00000001 BTC/kB\");\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "10a40fea3cb179eb1a41455c5fbbdc7b238e5fc1",
        "filename": "src/test/blockencodings_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/blockencodings_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/blockencodings_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockencodings_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -30,16 +30,16 @@ static CBlock BuildBlockTestCase() {\n     block.vtx.resize(3);\n     block.vtx[0] = MakeTransactionRef(tx);\n     block.nVersion = 42;\n-    block.hashPrevBlock = GetRandHash();\n+    block.hashPrevBlock = InsecureRand256();\n     block.nBits = 0x207fffff;\n \n-    tx.vin[0].prevout.hash = GetRandHash();\n+    tx.vin[0].prevout.hash = InsecureRand256();\n     tx.vin[0].prevout.n = 0;\n     block.vtx[1] = MakeTransactionRef(tx);\n \n     tx.vin.resize(10);\n     for (size_t i = 0; i < tx.vin.size(); i++) {\n-        tx.vin[i].prevout.hash = GetRandHash();\n+        tx.vin[i].prevout.hash = InsecureRand256();\n         tx.vin[i].prevout.n = 0;\n     }\n     block.vtx[2] = MakeTransactionRef(tx);\n@@ -283,7 +283,7 @@ BOOST_AUTO_TEST_CASE(EmptyBlockRoundTripTest)\n     block.vtx.resize(1);\n     block.vtx[0] = MakeTransactionRef(std::move(coinbase));\n     block.nVersion = 42;\n-    block.hashPrevBlock = GetRandHash();\n+    block.hashPrevBlock = InsecureRand256();\n     block.nBits = 0x207fffff;\n \n     bool mutated;\n@@ -316,7 +316,7 @@ BOOST_AUTO_TEST_CASE(EmptyBlockRoundTripTest)\n \n BOOST_AUTO_TEST_CASE(TransactionsRequestSerializationTest) {\n     BlockTransactionsRequest req1;\n-    req1.blockhash = GetRandHash();\n+    req1.blockhash = InsecureRand256();\n     req1.indexes.resize(4);\n     req1.indexes[0] = 0;\n     req1.indexes[1] = 1;"
      },
      {
        "sha": "1788ee13269cfd3ef92417c55abacf80aa044215",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -463,7 +463,7 @@ BOOST_AUTO_TEST_CASE(merkle_block_4_test_update_none)\n \n static std::vector<unsigned char> RandomData()\n {\n-    uint256 r = GetRandHash();\n+    uint256 r = InsecureRand256();\n     return std::vector<unsigned char>(r.begin(), r.end());\n }\n "
      },
      {
        "sha": "bf999eb5248668aa487b07a26598de0edd886a51",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -160,7 +160,7 @@ void Correct_Queue_range(std::vector<size_t> range)\n         FakeCheckCheckCompletion::n_calls = 0;\n         CCheckQueueControl<FakeCheckCheckCompletion> control(small_queue.get());\n         while (total) {\n-            vChecks.resize(std::min(total, (size_t) GetRand(10)));\n+            vChecks.resize(std::min(total, (size_t) InsecureRandRange(10)));\n             total -= vChecks.size();\n             control.Add(vChecks);\n         }\n@@ -204,7 +204,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Correct_Random)\n {\n     std::vector<size_t> range;\n     range.reserve(100000/1000);\n-    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)GetRand(std::min((size_t)1000, ((size_t)100000) - i))))\n+    for (size_t i = 2; i < 100000; i += std::max((size_t)1, (size_t)InsecureRandRange(std::min((size_t)1000, ((size_t)100000) - i))))\n         range.push_back(i);\n     Correct_Queue_range(range);\n }\n@@ -224,7 +224,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Catches_Failure)\n         CCheckQueueControl<FailingCheck> control(fail_queue.get());\n         size_t remaining = i;\n         while (remaining) {\n-            size_t r = GetRand(10);\n+            size_t r = InsecureRandRange(10);\n \n             std::vector<FailingCheck> vChecks;\n             vChecks.reserve(r);\n@@ -286,7 +286,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n     {\n         CCheckQueueControl<UniqueCheck> control(queue.get());\n         while (total) {\n-            size_t r = GetRand(10);\n+            size_t r = InsecureRandRange(10);\n             std::vector<UniqueCheck> vChecks;\n             for (size_t k = 0; k < r && total; k++)\n                 vChecks.emplace_back(--total);\n@@ -303,7 +303,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_UniqueCheck)\n }\n \n \n-// Test that blocks which might allocate lots of memory free their memory agressively.\n+// Test that blocks which might allocate lots of memory free their memory aggressively.\n //\n // This test attempts to catch a pathological case where by lazily freeing\n // checks might mean leaving a check un-swapped out, and decreasing by 1 each\n@@ -320,7 +320,7 @@ BOOST_AUTO_TEST_CASE(test_CheckQueue_Memory)\n         {\n             CCheckQueueControl<MemoryCheck> control(queue.get());\n             while (total) {\n-                size_t r = GetRand(10);\n+                size_t r = InsecureRandRange(10);\n                 std::vector<MemoryCheck> vChecks;\n                 for (size_t k = 0; k < r && total; k++) {\n                     total--;"
      },
      {
        "sha": "a72975d6e435120e6eb4ec17eed173c090f68b6c",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 286,
        "deletions": 312,
        "changes": 598,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -8,7 +8,6 @@\n #include \"undo.h\"\n #include \"utilstrencodings.h\"\n #include \"test/test_bitcoin.h\"\n-#include \"test/test_random.h\"\n #include \"validation.h\"\n #include \"consensus/validation.h\"\n \n@@ -17,35 +16,44 @@\n \n #include <boost/test/unit_test.hpp>\n \n-bool ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint& out);\n+int ApplyTxInUndo(Coin&& undo, CCoinsViewCache& view, const COutPoint& out);\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txundo, int nHeight);\n \n namespace\n {\n+//! equality test\n+bool operator==(const Coin &a, const Coin &b) {\n+    // Empty Coin objects are always equal.\n+    if (a.IsSpent() && b.IsSpent()) return true;\n+    return a.fCoinBase == b.fCoinBase &&\n+           a.nHeight == b.nHeight &&\n+           a.out == b.out;\n+}\n+\n class CCoinsViewTest : public CCoinsView\n {\n     uint256 hashBestBlock_;\n-    std::map<uint256, CCoins> map_;\n+    std::map<COutPoint, Coin> map_;\n \n public:\n-    bool GetCoins(const uint256& txid, CCoins& coins) const\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const\n     {\n-        std::map<uint256, CCoins>::const_iterator it = map_.find(txid);\n+        std::map<COutPoint, Coin>::const_iterator it = map_.find(outpoint);\n         if (it == map_.end()) {\n             return false;\n         }\n-        coins = it->second;\n-        if (coins.IsPruned() && insecure_rand() % 2 == 0) {\n+        coin = it->second;\n+        if (coin.IsSpent() && InsecureRandBool() == 0) {\n             // Randomly return false in case of an empty entry.\n             return false;\n         }\n         return true;\n     }\n \n-    bool HaveCoins(const uint256& txid) const\n+    bool HaveCoin(const COutPoint& outpoint) const\n     {\n-        CCoins coins;\n-        return GetCoins(txid, coins);\n+        Coin coin;\n+        return GetCoin(outpoint, coin);\n     }\n \n     uint256 GetBestBlock() const { return hashBestBlock_; }\n@@ -55,8 +63,8 @@ class CCoinsViewTest : public CCoinsView\n         for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end(); ) {\n             if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n                 // Same optimization used in CCoinsViewDB is to only write dirty entries.\n-                map_[it->first] = it->second.coins;\n-                if (it->second.coins.IsPruned() && insecure_rand() % 3 == 0) {\n+                map_[it->first] = it->second.coin;\n+                if (it->second.coin.IsSpent() && InsecureRandRange(3) == 0) {\n                     // Randomly delete empty entries on write.\n                     map_.erase(it->first);\n                 }\n@@ -78,9 +86,12 @@ class CCoinsViewCacheTest : public CCoinsViewCache\n     {\n         // Manually recompute the dynamic usage of the whole data, and compare it.\n         size_t ret = memusage::DynamicUsage(cacheCoins);\n+        size_t count = 0;\n         for (CCoinsMap::iterator it = cacheCoins.begin(); it != cacheCoins.end(); it++) {\n-            ret += it->second.coins.DynamicMemoryUsage();\n+            ret += it->second.coin.DynamicMemoryUsage();\n+            ++count;\n         }\n+        BOOST_CHECK_EQUAL(GetCacheSize(), count);\n         BOOST_CHECK_EQUAL(DynamicMemoryUsage(), ret);\n     }\n \n@@ -97,7 +108,7 @@ static const unsigned int NUM_SIMULATION_ITERATIONS = 40000;\n // This is a large randomized insert/remove simulation test on a variable-size\n // stack of caches on top of CCoinsViewTest.\n //\n-// It will randomly create/update/delete CCoins entries to a tip of caches, with\n+// It will randomly create/update/delete Coin entries to a tip of caches, with\n // txids picked from a limited list of random 256-bit hashes. Occasionally, a\n // new tip is added to the stack of caches, or the tip is flushed and removed.\n //\n@@ -109,13 +120,15 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     bool removed_all_caches = false;\n     bool reached_4_caches = false;\n     bool added_an_entry = false;\n+    bool added_an_unspendable_entry = false;\n     bool removed_an_entry = false;\n     bool updated_an_entry = false;\n     bool found_an_entry = false;\n     bool missed_an_entry = false;\n+    bool uncached_an_entry = false;\n \n     // A simple map to track what we expect the cache stack to represent.\n-    std::map<uint256, CCoins> result;\n+    std::map<COutPoint, Coin> result;\n \n     // The cache stack.\n     CCoinsViewTest base; // A CCoinsViewTest at the bottom.\n@@ -126,66 +139,81 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     std::vector<uint256> txids;\n     txids.resize(NUM_SIMULATION_ITERATIONS / 8);\n     for (unsigned int i = 0; i < txids.size(); i++) {\n-        txids[i] = GetRandHash();\n+        txids[i] = InsecureRand256();\n     }\n \n     for (unsigned int i = 0; i < NUM_SIMULATION_ITERATIONS; i++) {\n         // Do a random modification.\n         {\n-            uint256 txid = txids[insecure_rand() % txids.size()]; // txid we're going to modify in this iteration.\n-            CCoins& coins = result[txid];\n-            CCoinsModifier entry = stack.back()->ModifyCoins(txid);\n-            BOOST_CHECK(coins == *entry);\n-            if (insecure_rand() % 5 == 0 || coins.IsPruned()) {\n-                if (coins.IsPruned()) {\n-                    added_an_entry = true;\n+            uint256 txid = txids[InsecureRandRange(txids.size())]; // txid we're going to modify in this iteration.\n+            Coin& coin = result[COutPoint(txid, 0)];\n+            const Coin& entry = (InsecureRandRange(500) == 0) ? AccessByTxid(*stack.back(), txid) : stack.back()->AccessCoin(COutPoint(txid, 0));\n+            BOOST_CHECK(coin == entry);\n+\n+            if (InsecureRandRange(5) == 0 || coin.IsSpent()) {\n+                Coin newcoin;\n+                newcoin.out.nValue = InsecureRand32();\n+                newcoin.nHeight = 1;\n+                if (InsecureRandRange(16) == 0 && coin.IsSpent()) {\n+                    newcoin.out.scriptPubKey.assign(1 + InsecureRandBits(6), OP_RETURN);\n+                    BOOST_CHECK(newcoin.out.scriptPubKey.IsUnspendable());\n+                    added_an_unspendable_entry = true;\n                 } else {\n-                    updated_an_entry = true;\n+                    newcoin.out.scriptPubKey.assign(InsecureRandBits(6), 0); // Random sizes so we can test memory usage accounting\n+                    (coin.IsSpent() ? added_an_entry : updated_an_entry) = true;\n+                    coin = newcoin;\n                 }\n-                coins.nVersion = insecure_rand();\n-                coins.vout.resize(1);\n-                coins.vout[0].nValue = insecure_rand();\n-                *entry = coins;\n+                stack.back()->AddCoin(COutPoint(txid, 0), std::move(newcoin), !coin.IsSpent() || InsecureRand32() & 1);\n             } else {\n-                coins.Clear();\n-                entry->Clear();\n                 removed_an_entry = true;\n+                coin.Clear();\n+                stack.back()->SpendCoin(COutPoint(txid, 0));\n             }\n         }\n \n+        // One every 10 iterations, remove a random entry from the cache\n+        if (InsecureRandRange(10) == 0) {\n+            COutPoint out(txids[InsecureRand32() % txids.size()], 0);\n+            int cacheid = InsecureRand32() % stack.size();\n+            stack[cacheid]->Uncache(out);\n+            uncached_an_entry |= !stack[cacheid]->HaveCoinInCache(out);\n+        }\n+\n         // Once every 1000 iterations and at the end, verify the full cache.\n-        if (insecure_rand() % 1000 == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n-            for (std::map<uint256, CCoins>::iterator it = result.begin(); it != result.end(); it++) {\n-                const CCoins* coins = stack.back()->AccessCoins(it->first);\n-                if (coins) {\n-                    BOOST_CHECK(*coins == it->second);\n-                    found_an_entry = true;\n-                } else {\n-                    BOOST_CHECK(it->second.IsPruned());\n+        if (InsecureRandRange(1000) == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n+            for (auto it = result.begin(); it != result.end(); it++) {\n+                bool have = stack.back()->HaveCoin(it->first);\n+                const Coin& coin = stack.back()->AccessCoin(it->first);\n+                BOOST_CHECK(have == !coin.IsSpent());\n+                BOOST_CHECK(coin == it->second);\n+                if (coin.IsSpent()) {\n                     missed_an_entry = true;\n+                } else {\n+                    BOOST_CHECK(stack.back()->HaveCoinInCache(it->first));\n+                    found_an_entry = true;\n                 }\n             }\n             BOOST_FOREACH(const CCoinsViewCacheTest *test, stack) {\n                 test->SelfTest();\n             }\n         }\n \n-        if (insecure_rand() % 100 == 0) {\n+        if (InsecureRandRange(100) == 0) {\n             // Every 100 iterations, flush an intermediate cache\n-            if (stack.size() > 1 && insecure_rand() % 2 == 0) {\n-                unsigned int flushIndex = insecure_rand() % (stack.size() - 1);\n+            if (stack.size() > 1 && InsecureRandBool() == 0) {\n+                unsigned int flushIndex = InsecureRandRange(stack.size() - 1);\n                 stack[flushIndex]->Flush();\n             }\n         }\n-        if (insecure_rand() % 100 == 0) {\n+        if (InsecureRandRange(100) == 0) {\n             // Every 100 iterations, change the cache stack.\n-            if (stack.size() > 0 && insecure_rand() % 2 == 0) {\n+            if (stack.size() > 0 && InsecureRandBool() == 0) {\n                 //Remove the top cache\n                 stack.back()->Flush();\n                 delete stack.back();\n                 stack.pop_back();\n             }\n-            if (stack.size() == 0 || (stack.size() < 4 && insecure_rand() % 2)) {\n+            if (stack.size() == 0 || (stack.size() < 4 && InsecureRandBool())) {\n                 //Add a new cache\n                 CCoinsView* tip = &base;\n                 if (stack.size() > 0) {\n@@ -211,25 +239,27 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     BOOST_CHECK(removed_all_caches);\n     BOOST_CHECK(reached_4_caches);\n     BOOST_CHECK(added_an_entry);\n+    BOOST_CHECK(added_an_unspendable_entry);\n     BOOST_CHECK(removed_an_entry);\n     BOOST_CHECK(updated_an_entry);\n     BOOST_CHECK(found_an_entry);\n     BOOST_CHECK(missed_an_entry);\n+    BOOST_CHECK(uncached_an_entry);\n }\n \n-typedef std::tuple<CTransaction,CTxUndo,CCoins> TxData;\n // Store of all necessary tx and undo data for next test\n-std::map<uint256, TxData> alltxs;\n-\n-TxData &FindRandomFrom(const std::set<uint256> &txidset) {\n-    assert(txidset.size());\n-    std::set<uint256>::iterator txIt = txidset.lower_bound(GetRandHash());\n-    if (txIt == txidset.end()) {\n-        txIt = txidset.begin();\n+typedef std::map<COutPoint, std::tuple<CTransaction,CTxUndo,Coin>> UtxoData;\n+UtxoData utxoData;\n+\n+UtxoData::iterator FindRandomFrom(const std::set<COutPoint> &utxoSet) {\n+    assert(utxoSet.size());\n+    auto utxoSetIt = utxoSet.lower_bound(COutPoint(InsecureRand256(), 0));\n+    if (utxoSetIt == utxoSet.end()) {\n+        utxoSetIt = utxoSet.begin();\n     }\n-    std::map<uint256, TxData>::iterator txdit = alltxs.find(*txIt);\n-    assert(txdit != alltxs.end());\n-    return txdit->second;\n+    auto utxoDataIt = utxoData.find(*utxoSetIt);\n+    assert(utxoDataIt != utxoData.end());\n+    return utxoDataIt;\n }\n \n \n@@ -242,175 +272,180 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n {\n     bool spent_a_duplicate_coinbase = false;\n     // A simple map to track what we expect the cache stack to represent.\n-    std::map<uint256, CCoins> result;\n+    std::map<COutPoint, Coin> result;\n \n     // The cache stack.\n     CCoinsViewTest base; // A CCoinsViewTest at the bottom.\n     std::vector<CCoinsViewCacheTest*> stack; // A stack of CCoinsViewCaches on top.\n     stack.push_back(new CCoinsViewCacheTest(&base)); // Start with one cache.\n \n     // Track the txids we've used in various sets\n-    std::set<uint256> coinbaseids;\n-    std::set<uint256> disconnectedids;\n-    std::set<uint256> duplicateids;\n-    std::set<uint256> utxoset;\n+    std::set<COutPoint> coinbase_coins;\n+    std::set<COutPoint> disconnected_coins;\n+    std::set<COutPoint> duplicate_coins;\n+    std::set<COutPoint> utxoset;\n \n     for (unsigned int i = 0; i < NUM_SIMULATION_ITERATIONS; i++) {\n-        uint32_t randiter = insecure_rand();\n+        uint32_t randiter = InsecureRand32();\n \n         // 19/20 txs add a new transaction\n         if (randiter % 20 < 19) {\n             CMutableTransaction tx;\n             tx.vin.resize(1);\n             tx.vout.resize(1);\n             tx.vout[0].nValue = i; //Keep txs unique unless intended to duplicate\n-            unsigned int height = insecure_rand();\n-            CCoins oldcoins;\n+            tx.vout[0].scriptPubKey.assign(InsecureRand32() & 0x3F, 0); // Random sizes so we can test memory usage accounting\n+            unsigned int height = InsecureRand32();\n+            Coin old_coin;\n \n             // 2/20 times create a new coinbase\n-            if (randiter % 20 < 2 || coinbaseids.size() < 10) {\n+            if (randiter % 20 < 2 || coinbase_coins.size() < 10) {\n                 // 1/10 of those times create a duplicate coinbase\n-                if (insecure_rand() % 10 == 0 && coinbaseids.size()) {\n-                    TxData &txd = FindRandomFrom(coinbaseids);\n+                if (InsecureRandRange(10) == 0 && coinbase_coins.size()) {\n+                    auto utxod = FindRandomFrom(coinbase_coins);\n                     // Reuse the exact same coinbase\n-                    tx = std::get<0>(txd);\n+                    tx = std::get<0>(utxod->second);\n                     // shouldn't be available for reconnection if its been duplicated\n-                    disconnectedids.erase(tx.GetHash());\n+                    disconnected_coins.erase(utxod->first);\n \n-                    duplicateids.insert(tx.GetHash());\n+                    duplicate_coins.insert(utxod->first);\n                 }\n                 else {\n-                    coinbaseids.insert(tx.GetHash());\n+                    coinbase_coins.insert(COutPoint(tx.GetHash(), 0));\n                 }\n                 assert(CTransaction(tx).IsCoinBase());\n             }\n \n             // 17/20 times reconnect previous or add a regular tx\n             else {\n \n-                uint256 prevouthash;\n+                COutPoint prevout;\n                 // 1/20 times reconnect a previously disconnected tx\n-                if (randiter % 20 == 2 && disconnectedids.size()) {\n-                    TxData &txd = FindRandomFrom(disconnectedids);\n-                    tx = std::get<0>(txd);\n-                    prevouthash = tx.vin[0].prevout.hash;\n-                    if (!CTransaction(tx).IsCoinBase() && !utxoset.count(prevouthash)) {\n-                        disconnectedids.erase(tx.GetHash());\n+                if (randiter % 20 == 2 && disconnected_coins.size()) {\n+                    auto utxod = FindRandomFrom(disconnected_coins);\n+                    tx = std::get<0>(utxod->second);\n+                    prevout = tx.vin[0].prevout;\n+                    if (!CTransaction(tx).IsCoinBase() && !utxoset.count(prevout)) {\n+                        disconnected_coins.erase(utxod->first);\n                         continue;\n                     }\n \n                     // If this tx is already IN the UTXO, then it must be a coinbase, and it must be a duplicate\n-                    if (utxoset.count(tx.GetHash())) {\n+                    if (utxoset.count(utxod->first)) {\n                         assert(CTransaction(tx).IsCoinBase());\n-                        assert(duplicateids.count(tx.GetHash()));\n+                        assert(duplicate_coins.count(utxod->first));\n                     }\n-                    disconnectedids.erase(tx.GetHash());\n+                    disconnected_coins.erase(utxod->first);\n                 }\n \n                 // 16/20 times create a regular tx\n                 else {\n-                    TxData &txd = FindRandomFrom(utxoset);\n-                    prevouthash = std::get<0>(txd).GetHash();\n+                    auto utxod = FindRandomFrom(utxoset);\n+                    prevout = utxod->first;\n \n                     // Construct the tx to spend the coins of prevouthash\n-                    tx.vin[0].prevout.hash = prevouthash;\n-                    tx.vin[0].prevout.n = 0;\n+                    tx.vin[0].prevout = prevout;\n                     assert(!CTransaction(tx).IsCoinBase());\n                 }\n                 // In this simple test coins only have two states, spent or unspent, save the unspent state to restore\n-                oldcoins = result[prevouthash];\n+                old_coin = result[prevout];\n                 // Update the expected result of prevouthash to know these coins are spent\n-                result[prevouthash].Clear();\n+                result[prevout].Clear();\n \n-                utxoset.erase(prevouthash);\n+                utxoset.erase(prevout);\n \n                 // The test is designed to ensure spending a duplicate coinbase will work properly\n                 // if that ever happens and not resurrect the previously overwritten coinbase\n-                if (duplicateids.count(prevouthash))\n+                if (duplicate_coins.count(prevout)) {\n                     spent_a_duplicate_coinbase = true;\n+                }\n \n             }\n             // Update the expected result to know about the new output coins\n-            result[tx.GetHash()].FromTx(tx, height);\n+            assert(tx.vout.size() == 1);\n+            const COutPoint outpoint(tx.GetHash(), 0);\n+            result[outpoint] = Coin(tx.vout[0], height, CTransaction(tx).IsCoinBase());\n \n             // Call UpdateCoins on the top cache\n             CTxUndo undo;\n             UpdateCoins(tx, *(stack.back()), undo, height);\n \n             // Update the utxo set for future spends\n-            utxoset.insert(tx.GetHash());\n+            utxoset.insert(outpoint);\n \n             // Track this tx and undo info to use later\n-            alltxs.insert(std::make_pair(tx.GetHash(),std::make_tuple(tx,undo,oldcoins)));\n-        }\n-\n-        //1/20 times undo a previous transaction\n-        else if (utxoset.size()) {\n-            TxData &txd = FindRandomFrom(utxoset);\n+            utxoData.emplace(outpoint, std::make_tuple(tx,undo,old_coin));\n+        } else if (utxoset.size()) {\n+            //1/20 times undo a previous transaction\n+            auto utxod = FindRandomFrom(utxoset);\n \n-            CTransaction &tx = std::get<0>(txd);\n-            CTxUndo &undo = std::get<1>(txd);\n-            CCoins &origcoins = std::get<2>(txd);\n-\n-            uint256 undohash = tx.GetHash();\n+            CTransaction &tx = std::get<0>(utxod->second);\n+            CTxUndo &undo = std::get<1>(utxod->second);\n+            Coin &orig_coin = std::get<2>(utxod->second);\n \n             // Update the expected result\n             // Remove new outputs\n-            result[undohash].Clear();\n+            result[utxod->first].Clear();\n             // If not coinbase restore prevout\n             if (!tx.IsCoinBase()) {\n-                result[tx.vin[0].prevout.hash] = origcoins;\n+                result[tx.vin[0].prevout] = orig_coin;\n             }\n \n             // Disconnect the tx from the current UTXO\n             // See code in DisconnectBlock\n             // remove outputs\n-            {\n-                CCoinsModifier outs = stack.back()->ModifyCoins(undohash);\n-                outs->Clear();\n-            }\n+            stack.back()->SpendCoin(utxod->first);\n             // restore inputs\n             if (!tx.IsCoinBase()) {\n                 const COutPoint &out = tx.vin[0].prevout;\n-                const CTxInUndo &undoin = undo.vprevout[0];\n-                ApplyTxInUndo(undoin, *(stack.back()), out);\n+                Coin coin = undo.vprevout[0];\n+                ApplyTxInUndo(std::move(coin), *(stack.back()), out);\n             }\n             // Store as a candidate for reconnection\n-            disconnectedids.insert(undohash);\n+            disconnected_coins.insert(utxod->first);\n \n             // Update the utxoset\n-            utxoset.erase(undohash);\n+            utxoset.erase(utxod->first);\n             if (!tx.IsCoinBase())\n-                utxoset.insert(tx.vin[0].prevout.hash);\n+                utxoset.insert(tx.vin[0].prevout);\n         }\n \n         // Once every 1000 iterations and at the end, verify the full cache.\n-        if (insecure_rand() % 1000 == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n-            for (std::map<uint256, CCoins>::iterator it = result.begin(); it != result.end(); it++) {\n-                const CCoins* coins = stack.back()->AccessCoins(it->first);\n-                if (coins) {\n-                    BOOST_CHECK(*coins == it->second);\n-                } else {\n-                    BOOST_CHECK(it->second.IsPruned());\n-                }\n+        if (InsecureRandRange(1000) == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n+            for (auto it = result.begin(); it != result.end(); it++) {\n+                bool have = stack.back()->HaveCoin(it->first);\n+                const Coin& coin = stack.back()->AccessCoin(it->first);\n+                BOOST_CHECK(have == !coin.IsSpent());\n+                BOOST_CHECK(coin == it->second);\n             }\n         }\n \n-        if (insecure_rand() % 100 == 0) {\n+        // One every 10 iterations, remove a random entry from the cache\n+        if (utxoset.size() > 1 && InsecureRandRange(30) == 0) {\n+            stack[InsecureRand32() % stack.size()]->Uncache(FindRandomFrom(utxoset)->first);\n+        }\n+        if (disconnected_coins.size() > 1 && InsecureRandRange(30) == 0) {\n+            stack[InsecureRand32() % stack.size()]->Uncache(FindRandomFrom(disconnected_coins)->first);\n+        }\n+        if (duplicate_coins.size() > 1 && InsecureRandRange(30) == 0) {\n+            stack[InsecureRand32() % stack.size()]->Uncache(FindRandomFrom(duplicate_coins)->first);\n+        }\n+\n+        if (InsecureRandRange(100) == 0) {\n             // Every 100 iterations, flush an intermediate cache\n-            if (stack.size() > 1 && insecure_rand() % 2 == 0) {\n-                unsigned int flushIndex = insecure_rand() % (stack.size() - 1);\n+            if (stack.size() > 1 && InsecureRandBool() == 0) {\n+                unsigned int flushIndex = InsecureRandRange(stack.size() - 1);\n                 stack[flushIndex]->Flush();\n             }\n         }\n-        if (insecure_rand() % 100 == 0) {\n+        if (InsecureRandRange(100) == 0) {\n             // Every 100 iterations, change the cache stack.\n-            if (stack.size() > 0 && insecure_rand() % 2 == 0) {\n+            if (stack.size() > 0 && InsecureRandBool() == 0) {\n                 stack.back()->Flush();\n                 delete stack.back();\n                 stack.pop_back();\n             }\n-            if (stack.size() == 0 || (stack.size() < 4 && insecure_rand() % 2)) {\n+            if (stack.size() == 0 || (stack.size() < 4 && InsecureRandBool())) {\n                 CCoinsView* tip = &base;\n                 if (stack.size() > 0) {\n                     tip = stack.back();\n@@ -433,53 +468,36 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n BOOST_AUTO_TEST_CASE(ccoins_serialization)\n {\n     // Good example\n-    CDataStream ss1(ParseHex(\"0104835800816115944e077fe7c803cfa57f29b36bf87c1d358bb85e\"), SER_DISK, CLIENT_VERSION);\n-    CCoins cc1;\n+    CDataStream ss1(ParseHex(\"97f23c835800816115944e077fe7c803cfa57f29b36bf87c1d35\"), SER_DISK, CLIENT_VERSION);\n+    Coin cc1;\n     ss1 >> cc1;\n-    BOOST_CHECK_EQUAL(cc1.nVersion, 1);\n     BOOST_CHECK_EQUAL(cc1.fCoinBase, false);\n     BOOST_CHECK_EQUAL(cc1.nHeight, 203998);\n-    BOOST_CHECK_EQUAL(cc1.vout.size(), 2);\n-    BOOST_CHECK_EQUAL(cc1.IsAvailable(0), false);\n-    BOOST_CHECK_EQUAL(cc1.IsAvailable(1), true);\n-    BOOST_CHECK_EQUAL(cc1.vout[1].nValue, 60000000000ULL);\n-    BOOST_CHECK_EQUAL(HexStr(cc1.vout[1].scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"816115944e077fe7c803cfa57f29b36bf87c1d35\"))))));\n+    BOOST_CHECK_EQUAL(cc1.out.nValue, 60000000000ULL);\n+    BOOST_CHECK_EQUAL(HexStr(cc1.out.scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"816115944e077fe7c803cfa57f29b36bf87c1d35\"))))));\n \n     // Good example\n-    CDataStream ss2(ParseHex(\"0109044086ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4eebbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa486af3b\"), SER_DISK, CLIENT_VERSION);\n-    CCoins cc2;\n+    CDataStream ss2(ParseHex(\"8ddf77bbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa4\"), SER_DISK, CLIENT_VERSION);\n+    Coin cc2;\n     ss2 >> cc2;\n-    BOOST_CHECK_EQUAL(cc2.nVersion, 1);\n     BOOST_CHECK_EQUAL(cc2.fCoinBase, true);\n     BOOST_CHECK_EQUAL(cc2.nHeight, 120891);\n-    BOOST_CHECK_EQUAL(cc2.vout.size(), 17);\n-    for (int i = 0; i < 17; i++) {\n-        BOOST_CHECK_EQUAL(cc2.IsAvailable(i), i == 4 || i == 16);\n-    }\n-    BOOST_CHECK_EQUAL(cc2.vout[4].nValue, 234925952);\n-    BOOST_CHECK_EQUAL(HexStr(cc2.vout[4].scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"61b01caab50f1b8e9c50a5057eb43c2d9563a4ee\"))))));\n-    BOOST_CHECK_EQUAL(cc2.vout[16].nValue, 110397);\n-    BOOST_CHECK_EQUAL(HexStr(cc2.vout[16].scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"8c988f1a4a4de2161e0f50aac7f17e7f9555caa4\"))))));\n+    BOOST_CHECK_EQUAL(cc2.out.nValue, 110397);\n+    BOOST_CHECK_EQUAL(HexStr(cc2.out.scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"8c988f1a4a4de2161e0f50aac7f17e7f9555caa4\"))))));\n \n     // Smallest possible example\n-    CDataStream ssx(SER_DISK, CLIENT_VERSION);\n-    BOOST_CHECK_EQUAL(HexStr(ssx.begin(), ssx.end()), \"\");\n-\n-    CDataStream ss3(ParseHex(\"0002000600\"), SER_DISK, CLIENT_VERSION);\n-    CCoins cc3;\n+    CDataStream ss3(ParseHex(\"000006\"), SER_DISK, CLIENT_VERSION);\n+    Coin cc3;\n     ss3 >> cc3;\n-    BOOST_CHECK_EQUAL(cc3.nVersion, 0);\n     BOOST_CHECK_EQUAL(cc3.fCoinBase, false);\n     BOOST_CHECK_EQUAL(cc3.nHeight, 0);\n-    BOOST_CHECK_EQUAL(cc3.vout.size(), 1);\n-    BOOST_CHECK_EQUAL(cc3.IsAvailable(0), true);\n-    BOOST_CHECK_EQUAL(cc3.vout[0].nValue, 0);\n-    BOOST_CHECK_EQUAL(cc3.vout[0].scriptPubKey.size(), 0);\n+    BOOST_CHECK_EQUAL(cc3.out.nValue, 0);\n+    BOOST_CHECK_EQUAL(cc3.out.scriptPubKey.size(), 0);\n \n     // scriptPubKey that ends beyond the end of the stream\n-    CDataStream ss4(ParseHex(\"0002000800\"), SER_DISK, CLIENT_VERSION);\n+    CDataStream ss4(ParseHex(\"000007\"), SER_DISK, CLIENT_VERSION);\n     try {\n-        CCoins cc4;\n+        Coin cc4;\n         ss4 >> cc4;\n         BOOST_CHECK_MESSAGE(false, \"We should have thrown\");\n     } catch (const std::ios_base::failure& e) {\n@@ -490,16 +508,16 @@ BOOST_AUTO_TEST_CASE(ccoins_serialization)\n     uint64_t x = 3000000000ULL;\n     tmp << VARINT(x);\n     BOOST_CHECK_EQUAL(HexStr(tmp.begin(), tmp.end()), \"8a95c0bb00\");\n-    CDataStream ss5(ParseHex(\"0002008a95c0bb0000\"), SER_DISK, CLIENT_VERSION);\n+    CDataStream ss5(ParseHex(\"00008a95c0bb00\"), SER_DISK, CLIENT_VERSION);\n     try {\n-        CCoins cc5;\n+        Coin cc5;\n         ss5 >> cc5;\n         BOOST_CHECK_MESSAGE(false, \"We should have thrown\");\n     } catch (const std::ios_base::failure& e) {\n     }\n }\n \n-const static uint256 TXID;\n+const static COutPoint OUTPOINT;\n const static CAmount PRUNED = -1;\n const static CAmount ABSENT = -2;\n const static CAmount FAIL = -3;\n@@ -514,15 +532,15 @@ const static auto FLAGS = {char(0), FRESH, DIRTY, char(DIRTY | FRESH)};\n const static auto CLEAN_FLAGS = {char(0), FRESH};\n const static auto ABSENT_FLAGS = {NO_ENTRY};\n \n-void SetCoinsValue(CAmount value, CCoins& coins)\n+void SetCoinsValue(CAmount value, Coin& coin)\n {\n     assert(value != ABSENT);\n-    coins.Clear();\n-    assert(coins.IsPruned());\n+    coin.Clear();\n+    assert(coin.IsSpent());\n     if (value != PRUNED) {\n-        coins.vout.emplace_back();\n-        coins.vout.back().nValue = value;\n-        assert(!coins.IsPruned());\n+        coin.out.nValue = value;\n+        coin.nHeight = 1;\n+        assert(!coin.IsSpent());\n     }\n }\n \n@@ -535,25 +553,23 @@ size_t InsertCoinsMapEntry(CCoinsMap& map, CAmount value, char flags)\n     assert(flags != NO_ENTRY);\n     CCoinsCacheEntry entry;\n     entry.flags = flags;\n-    SetCoinsValue(value, entry.coins);\n-    auto inserted = map.emplace(TXID, std::move(entry));\n+    SetCoinsValue(value, entry.coin);\n+    auto inserted = map.emplace(OUTPOINT, std::move(entry));\n     assert(inserted.second);\n-    return inserted.first->second.coins.DynamicMemoryUsage();\n+    return inserted.first->second.coin.DynamicMemoryUsage();\n }\n \n void GetCoinsMapEntry(const CCoinsMap& map, CAmount& value, char& flags)\n {\n-    auto it = map.find(TXID);\n+    auto it = map.find(OUTPOINT);\n     if (it == map.end()) {\n         value = ABSENT;\n         flags = NO_ENTRY;\n     } else {\n-        if (it->second.coins.IsPruned()) {\n-            assert(it->second.coins.vout.size() == 0);\n+        if (it->second.coin.IsSpent()) {\n             value = PRUNED;\n         } else {\n-            assert(it->second.coins.vout.size() == 1);\n-            value = it->second.coins.vout[0].nValue;\n+            value = it->second.coin.out.nValue;\n         }\n         flags = it->second.flags;\n         assert(flags != NO_ENTRY);\n@@ -581,10 +597,10 @@ class SingleEntryCacheTest\n     CCoinsViewCacheTest cache{&base};\n };\n \n-void CheckAccessCoins(CAmount base_value, CAmount cache_value, CAmount expected_value, char cache_flags, char expected_flags)\n+void CheckAccessCoin(CAmount base_value, CAmount cache_value, CAmount expected_value, char cache_flags, char expected_flags)\n {\n     SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n-    test.cache.AccessCoins(TXID);\n+    test.cache.AccessCoin(OUTPOINT);\n     test.cache.SelfTest();\n \n     CAmount result_value;\n@@ -603,39 +619,39 @@ BOOST_AUTO_TEST_CASE(ccoins_access)\n      *               Base    Cache   Result  Cache        Result\n      *               Value   Value   Value   Flags        Flags\n      */\n-    CheckAccessCoins(ABSENT, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   );\n-    CheckAccessCoins(ABSENT, PRUNED, PRUNED, 0          , 0          );\n-    CheckAccessCoins(ABSENT, PRUNED, PRUNED, FRESH      , FRESH      );\n-    CheckAccessCoins(ABSENT, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckAccessCoins(ABSENT, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoins(ABSENT, VALUE2, VALUE2, 0          , 0          );\n-    CheckAccessCoins(ABSENT, VALUE2, VALUE2, FRESH      , FRESH      );\n-    CheckAccessCoins(ABSENT, VALUE2, VALUE2, DIRTY      , DIRTY      );\n-    CheckAccessCoins(ABSENT, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoins(PRUNED, ABSENT, PRUNED, NO_ENTRY   , FRESH      );\n-    CheckAccessCoins(PRUNED, PRUNED, PRUNED, 0          , 0          );\n-    CheckAccessCoins(PRUNED, PRUNED, PRUNED, FRESH      , FRESH      );\n-    CheckAccessCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckAccessCoins(PRUNED, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoins(PRUNED, VALUE2, VALUE2, 0          , 0          );\n-    CheckAccessCoins(PRUNED, VALUE2, VALUE2, FRESH      , FRESH      );\n-    CheckAccessCoins(PRUNED, VALUE2, VALUE2, DIRTY      , DIRTY      );\n-    CheckAccessCoins(PRUNED, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoins(VALUE1, ABSENT, VALUE1, NO_ENTRY   , 0          );\n-    CheckAccessCoins(VALUE1, PRUNED, PRUNED, 0          , 0          );\n-    CheckAccessCoins(VALUE1, PRUNED, PRUNED, FRESH      , FRESH      );\n-    CheckAccessCoins(VALUE1, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckAccessCoins(VALUE1, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoins(VALUE1, VALUE2, VALUE2, 0          , 0          );\n-    CheckAccessCoins(VALUE1, VALUE2, VALUE2, FRESH      , FRESH      );\n-    CheckAccessCoins(VALUE1, VALUE2, VALUE2, DIRTY      , DIRTY      );\n-    CheckAccessCoins(VALUE1, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(ABSENT, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   );\n+    CheckAccessCoin(ABSENT, PRUNED, PRUNED, 0          , 0          );\n+    CheckAccessCoin(ABSENT, PRUNED, PRUNED, FRESH      , FRESH      );\n+    CheckAccessCoin(ABSENT, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckAccessCoin(ABSENT, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(ABSENT, VALUE2, VALUE2, 0          , 0          );\n+    CheckAccessCoin(ABSENT, VALUE2, VALUE2, FRESH      , FRESH      );\n+    CheckAccessCoin(ABSENT, VALUE2, VALUE2, DIRTY      , DIRTY      );\n+    CheckAccessCoin(ABSENT, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(PRUNED, ABSENT, PRUNED, NO_ENTRY   , FRESH      );\n+    CheckAccessCoin(PRUNED, PRUNED, PRUNED, 0          , 0          );\n+    CheckAccessCoin(PRUNED, PRUNED, PRUNED, FRESH      , FRESH      );\n+    CheckAccessCoin(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckAccessCoin(PRUNED, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(PRUNED, VALUE2, VALUE2, 0          , 0          );\n+    CheckAccessCoin(PRUNED, VALUE2, VALUE2, FRESH      , FRESH      );\n+    CheckAccessCoin(PRUNED, VALUE2, VALUE2, DIRTY      , DIRTY      );\n+    CheckAccessCoin(PRUNED, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(VALUE1, ABSENT, VALUE1, NO_ENTRY   , 0          );\n+    CheckAccessCoin(VALUE1, PRUNED, PRUNED, 0          , 0          );\n+    CheckAccessCoin(VALUE1, PRUNED, PRUNED, FRESH      , FRESH      );\n+    CheckAccessCoin(VALUE1, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckAccessCoin(VALUE1, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(VALUE1, VALUE2, VALUE2, 0          , 0          );\n+    CheckAccessCoin(VALUE1, VALUE2, VALUE2, FRESH      , FRESH      );\n+    CheckAccessCoin(VALUE1, VALUE2, VALUE2, DIRTY      , DIRTY      );\n+    CheckAccessCoin(VALUE1, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n }\n \n-void CheckModifyCoins(CAmount base_value, CAmount cache_value, CAmount modify_value, CAmount expected_value, char cache_flags, char expected_flags)\n+void CheckSpendCoins(CAmount base_value, CAmount cache_value, CAmount expected_value, char cache_flags, char expected_flags)\n {\n     SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n-    SetCoinsValue(modify_value, *test.cache.ModifyCoins(TXID));\n+    test.cache.SpendCoin(OUTPOINT);\n     test.cache.SelfTest();\n \n     CAmount result_value;\n@@ -645,79 +661,55 @@ void CheckModifyCoins(CAmount base_value, CAmount cache_value, CAmount modify_va\n     BOOST_CHECK_EQUAL(result_flags, expected_flags);\n };\n \n-BOOST_AUTO_TEST_CASE(ccoins_modify)\n+BOOST_AUTO_TEST_CASE(ccoins_spend)\n {\n-    /* Check ModifyCoin behavior, requesting a coin from a cache view layered on\n-     * top of a base view, writing a modification to the coin, and then checking\n+    /* Check SpendCoin behavior, requesting a coin from a cache view layered on\n+     * top of a base view, spending, and then checking\n      * the resulting entry in the cache after the modification.\n      *\n-     *               Base    Cache   Write   Result  Cache        Result\n-     *               Value   Value   Value   Value   Flags        Flags\n+     *              Base    Cache   Result  Cache        Result\n+     *              Value   Value   Value   Flags        Flags\n      */\n-    CheckModifyCoins(ABSENT, ABSENT, PRUNED, ABSENT, NO_ENTRY   , NO_ENTRY   );\n-    CheckModifyCoins(ABSENT, ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY|FRESH);\n-    CheckModifyCoins(ABSENT, PRUNED, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(ABSENT, PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(ABSENT, PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(ABSENT, PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckModifyCoins(ABSENT, VALUE2, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(ABSENT, VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(ABSENT, VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(ABSENT, VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckModifyCoins(PRUNED, ABSENT, PRUNED, ABSENT, NO_ENTRY   , NO_ENTRY   );\n-    CheckModifyCoins(PRUNED, ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY|FRESH);\n-    CheckModifyCoins(PRUNED, PRUNED, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(PRUNED, PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(PRUNED, PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(PRUNED, PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckModifyCoins(PRUNED, VALUE2, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(PRUNED, VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(PRUNED, VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(PRUNED, VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckModifyCoins(VALUE1, ABSENT, PRUNED, PRUNED, NO_ENTRY   , DIRTY      );\n-    CheckModifyCoins(VALUE1, ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY      );\n-    CheckModifyCoins(VALUE1, PRUNED, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(VALUE1, PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(VALUE1, PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(VALUE1, PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckModifyCoins(VALUE1, VALUE2, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(VALUE1, VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(VALUE1, VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(VALUE1, VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckSpendCoins(ABSENT, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   );\n+    CheckSpendCoins(ABSENT, PRUNED, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(ABSENT, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(ABSENT, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(ABSENT, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckSpendCoins(ABSENT, VALUE2, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(ABSENT, VALUE2, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(ABSENT, VALUE2, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(ABSENT, VALUE2, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckSpendCoins(PRUNED, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   );\n+    CheckSpendCoins(PRUNED, PRUNED, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckSpendCoins(PRUNED, VALUE2, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(PRUNED, VALUE2, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(PRUNED, VALUE2, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(PRUNED, VALUE2, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckSpendCoins(VALUE1, ABSENT, PRUNED, NO_ENTRY   , DIRTY      );\n+    CheckSpendCoins(VALUE1, PRUNED, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(VALUE1, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(VALUE1, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(VALUE1, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckSpendCoins(VALUE1, VALUE2, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(VALUE1, VALUE2, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(VALUE1, VALUE2, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(VALUE1, VALUE2, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n }\n \n-void CheckModifyNewCoinsBase(CAmount base_value, CAmount cache_value, CAmount modify_value, CAmount expected_value, char cache_flags, char expected_flags, bool coinbase)\n+void CheckAddCoinBase(CAmount base_value, CAmount cache_value, CAmount modify_value, CAmount expected_value, char cache_flags, char expected_flags, bool coinbase)\n {\n     SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n \n     CAmount result_value;\n     char result_flags;\n     try {\n-        SetCoinsValue(modify_value, *test.cache.ModifyNewCoins(TXID, coinbase));\n+        CTxOut output;\n+        output.nValue = modify_value;\n+        test.cache.AddCoin(OUTPOINT, Coin(std::move(output), 1, coinbase), coinbase);\n+        test.cache.SelfTest();\n         GetCoinsMapEntry(test.cache.map(), result_value, result_flags);\n     } catch (std::logic_error& e) {\n         result_value = FAIL;\n@@ -728,64 +720,46 @@ void CheckModifyNewCoinsBase(CAmount base_value, CAmount cache_value, CAmount mo\n     BOOST_CHECK_EQUAL(result_flags, expected_flags);\n }\n \n-// Simple wrapper for CheckModifyNewCoinsBase function above that loops through\n+// Simple wrapper for CheckAddCoinBase function above that loops through\n // different possible base_values, making sure each one gives the same results.\n-// This wrapper lets the modify_new test below be shorter and less repetitive,\n-// while still verifying that the CoinsViewCache::ModifyNewCoins implementation\n+// This wrapper lets the coins_add test below be shorter and less repetitive,\n+// while still verifying that the CoinsViewCache::AddCoin implementation\n // ignores base values.\n template <typename... Args>\n-void CheckModifyNewCoins(Args&&... args)\n+void CheckAddCoin(Args&&... args)\n {\n     for (CAmount base_value : {ABSENT, PRUNED, VALUE1})\n-        CheckModifyNewCoinsBase(base_value, std::forward<Args>(args)...);\n+        CheckAddCoinBase(base_value, std::forward<Args>(args)...);\n }\n \n-BOOST_AUTO_TEST_CASE(ccoins_modify_new)\n+BOOST_AUTO_TEST_CASE(ccoins_add)\n {\n-    /* Check ModifyNewCoin behavior, requesting a new coin from a cache view,\n+    /* Check AddCoin behavior, requesting a new coin from a cache view,\n      * writing a modification to the coin, and then checking the resulting\n      * entry in the cache after the modification. Verify behavior with the\n-     * with the ModifyNewCoin coinbase argument set to false, and to true.\n+     * with the AddCoin potential_overwrite argument set to false, and to true.\n      *\n-     *                  Cache   Write   Result  Cache        Result     Coinbase\n-     *                  Value   Value   Value   Flags        Flags\n+     *           Cache   Write   Result  Cache        Result       potential_overwrite\n+     *           Value   Value   Value   Flags        Flags\n      */\n-    CheckModifyNewCoins(ABSENT, PRUNED, ABSENT, NO_ENTRY   , NO_ENTRY   , false);\n-    CheckModifyNewCoins(ABSENT, PRUNED, PRUNED, NO_ENTRY   , DIRTY      , true );\n-    CheckModifyNewCoins(ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY|FRESH, false);\n-    CheckModifyNewCoins(ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY      , true );\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, 0          , NO_ENTRY   , false);\n-    CheckModifyNewCoins(PRUNED, PRUNED, PRUNED, 0          , DIRTY      , true );\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   , false);\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   , true );\n-    CheckModifyNewCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      , false);\n-    CheckModifyNewCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      , true );\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , false);\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , true );\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, 0          , DIRTY|FRESH, false);\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, 0          , DIRTY      , true );\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, false);\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      , false);\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, false);\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , 0          , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, PRUNED, PRUNED, 0          , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , FRESH      , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   , true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , DIRTY      , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , DIRTY|FRESH, NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , 0          , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, 0          , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , FRESH      , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , DIRTY      , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , DIRTY|FRESH, NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n+    CheckAddCoin(ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY|FRESH, false);\n+    CheckAddCoin(ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY      , true );\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, 0          , DIRTY|FRESH, false);\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, 0          , DIRTY      , true );\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, false);\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      , false);\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, false);\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n+    CheckAddCoin(VALUE2, VALUE3, FAIL  , 0          , NO_ENTRY   , false);\n+    CheckAddCoin(VALUE2, VALUE3, VALUE3, 0          , DIRTY      , true );\n+    CheckAddCoin(VALUE2, VALUE3, FAIL  , FRESH      , NO_ENTRY   , false);\n+    CheckAddCoin(VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n+    CheckAddCoin(VALUE2, VALUE3, FAIL  , DIRTY      , NO_ENTRY   , false);\n+    CheckAddCoin(VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n+    CheckAddCoin(VALUE2, VALUE3, FAIL  , DIRTY|FRESH, NO_ENTRY   , false);\n+    CheckAddCoin(VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n }\n \n void CheckWriteCoins(CAmount parent_value, CAmount child_value, CAmount expected_value, char parent_flags, char child_flags, char expected_flags)"
      },
      {
        "sha": "391ad14ffa1e88b843bd5aed44801b0f29bc7609",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 69,
        "deletions": 3,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -3,19 +3,19 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"crypto/aes.h\"\n+#include \"crypto/chacha20.h\"\n #include \"crypto/ripemd160.h\"\n #include \"crypto/sha1.h\"\n #include \"crypto/sha256.h\"\n #include \"crypto/sha512.h\"\n #include \"crypto/hmac_sha256.h\"\n #include \"crypto/hmac_sha512.h\"\n+#include \"random.h\"\n #include \"utilstrencodings.h\"\n #include \"test/test_bitcoin.h\"\n-#include \"test/test_random.h\"\n \n #include <vector>\n \n-#include <boost/assign/list_of.hpp>\n #include <boost/test/unit_test.hpp>\n #include <openssl/aes.h>\n #include <openssl/evp.h>\n@@ -37,7 +37,7 @@ void TestVector(const Hasher &h, const In &in, const Out &out) {\n         Hasher hasher(h);\n         size_t pos = 0;\n         while (pos < in.size()) {\n-            size_t len = insecure_rand() % ((in.size() - pos + 1) / 2 + 1);\n+            size_t len = InsecureRandRange((in.size() - pos + 1) / 2 + 1);\n             hasher.Write((unsigned char*)&in[pos], len);\n             pos += len;\n             if (pos > 0 && pos + 2 * out.size() > in.size() && pos < in.size()) {\n@@ -187,6 +187,19 @@ void TestAES256CBC(const std::string &hexkey, const std::string &hexiv, bool pad\n     }\n }\n \n+void TestChaCha20(const std::string &hexkey, uint64_t nonce, uint64_t seek, const std::string& hexout)\n+{\n+    std::vector<unsigned char> key = ParseHex(hexkey);\n+    ChaCha20 rng(key.data(), key.size());\n+    rng.SetIV(nonce);\n+    rng.Seek(seek);\n+    std::vector<unsigned char> out = ParseHex(hexout);\n+    std::vector<unsigned char> outres;\n+    outres.resize(out.size());\n+    rng.Output(outres.data(), outres.size());\n+    BOOST_CHECK(out == outres);\n+}\n+\n std::string LongTestString(void) {\n     std::string ret;\n     for (int i=0; i<200000; i++) {\n@@ -439,4 +452,57 @@ BOOST_AUTO_TEST_CASE(aes_cbc_testvectors) {\n                   \"b2eb05e2c39be9fcda6c19078c6a9d1b3f461796d6b0d6b2e0c2a72b4d80e644\");\n }\n \n+\n+BOOST_AUTO_TEST_CASE(chacha20_testvector)\n+{\n+    // Test vector from RFC 7539\n+    TestChaCha20(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\", 0x4a000000UL, 1,\n+                 \"224f51f3401bd9e12fde276fb8631ded8c131f823d2c06e27e4fcaec9ef3cf788a3b0aa372600a92b57974cded2b9334794cb\"\n+                 \"a40c63e34cdea212c4cf07d41b769a6749f3f630f4122cafe28ec4dc47e26d4346d70b98c73f3e9c53ac40c5945398b6eda1a\"\n+                 \"832c89c167eacd901d7e2bf363\");\n+\n+    // Test vectors from https://tools.ietf.org/html/draft-agl-tls-chacha20poly1305-04#section-7\n+    TestChaCha20(\"0000000000000000000000000000000000000000000000000000000000000000\", 0, 0,\n+                 \"76b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8b770dc7da41597c5157488d7724e03fb8d84a376a43b\"\n+                 \"8f41518a11cc387b669b2ee6586\");\n+    TestChaCha20(\"0000000000000000000000000000000000000000000000000000000000000001\", 0, 0,\n+                 \"4540f05a9f1fb296d7736e7b208e3c96eb4fe1834688d2604f450952ed432d41bbe2a0b6ea7566d2a5d1e7e20d42af2c53d79\"\n+                 \"2b1c43fea817e9ad275ae546963\");\n+    TestChaCha20(\"0000000000000000000000000000000000000000000000000000000000000000\", 0x0100000000000000ULL, 0,\n+                 \"de9cba7bf3d69ef5e786dc63973f653a0b49e015adbff7134fcb7df137821031e85a050278a7084527214f73efc7fa5b52770\"\n+                 \"62eb7a0433e445f41e3\");\n+    TestChaCha20(\"0000000000000000000000000000000000000000000000000000000000000000\", 1, 0,\n+                 \"ef3fdfd6c61578fbf5cf35bd3dd33b8009631634d21e42ac33960bd138e50d32111e4caf237ee53ca8ad6426194a88545ddc4\"\n+                 \"97a0b466e7d6bbdb0041b2f586b\");\n+    TestChaCha20(\"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\", 0x0706050403020100ULL, 0,\n+                 \"f798a189f195e66982105ffb640bb7757f579da31602fc93ec01ac56f85ac3c134a4547b733b46413042c9440049176905d3b\"\n+                 \"e59ea1c53f15916155c2be8241a38008b9a26bc35941e2444177c8ade6689de95264986d95889fb60e84629c9bd9a5acb1cc1\"\n+                 \"18be563eb9b3a4a472f82e09a7e778492b562ef7130e88dfe031c79db9d4f7c7a899151b9a475032b63fc385245fe054e3dd5\"\n+                 \"a97a5f576fe064025d3ce042c566ab2c507b138db853e3d6959660996546cc9c4a6eafdc777c040d70eaf46f76dad3979e5c5\"\n+                 \"360c3317166a1c894c94a371876a94df7628fe4eaaf2ccb27d5aaae0ad7ad0f9d4b6ad3b54098746d4524d38407a6deb3ab78\"\n+                 \"fab78c9\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(countbits_tests)\n+{\n+    FastRandomContext ctx;\n+    for (int i = 0; i <= 64; ++i) {\n+        if (i == 0) {\n+            // Check handling of zero.\n+            BOOST_CHECK_EQUAL(CountBits(0), 0);\n+        } else if (i < 10) {\n+            for (uint64_t j = 1 << (i - 1); (j >> i) == 0; ++j) {\n+                // Exhaustively test up to 10 bits\n+                BOOST_CHECK_EQUAL(CountBits(j), i);\n+            }\n+        } else {\n+            for (int k = 0; k < 1000; k++) {\n+                // Randomly test 1000 samples of each length above 10 bits.\n+                uint64_t j = ((uint64_t)1) << (i - 1) | ctx.randbits(i - 1);\n+                BOOST_CHECK_EQUAL(CountBits(j), i);\n+            }\n+        }\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "ed391e184cf5dd653f5bfcb3e18c93ccaf789456",
        "filename": "src/test/cuckoocache_tests.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 38,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/cuckoocache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/cuckoocache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/cuckoocache_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #include <boost/test/unit_test.hpp>\n #include \"cuckoocache.h\"\n+#include \"script/sigcache.h\"\n #include \"test/test_bitcoin.h\"\n #include \"random.h\"\n #include <thread>\n@@ -22,34 +23,20 @@\n  *  using BOOST_CHECK_CLOSE to fail.\n  *\n  */\n-FastRandomContext insecure_rand(true);\n+FastRandomContext local_rand_ctx(true);\n \n BOOST_AUTO_TEST_SUITE(cuckoocache_tests);\n \n \n-/** insecure_GetRandHash fills in a uint256 from insecure_rand\n+/** insecure_GetRandHash fills in a uint256 from local_rand_ctx\n  */\n void insecure_GetRandHash(uint256& t)\n {\n     uint32_t* ptr = (uint32_t*)t.begin();\n     for (uint8_t j = 0; j < 8; ++j)\n-        *(ptr++) = insecure_rand.rand32();\n+        *(ptr++) = local_rand_ctx.rand32();\n }\n \n-/** Definition copied from /src/script/sigcache.cpp\n- */\n-class uint256Hasher\n-{\n-public:\n-    template <uint8_t hash_select>\n-    uint32_t operator()(const uint256& key) const\n-    {\n-        static_assert(hash_select <8, \"SignatureCacheHasher only has 8 hashes available.\");\n-        uint32_t u;\n-        std::memcpy(&u, key.begin() + 4 * hash_select, 4);\n-        return u;\n-    }\n-};\n \n \n /* Test that no values not inserted into the cache are read out of it.\n@@ -58,9 +45,10 @@ class uint256Hasher\n  */\n BOOST_AUTO_TEST_CASE(test_cuckoocache_no_fakes)\n {\n-    insecure_rand = FastRandomContext(true);\n-    CuckooCache::cache<uint256, uint256Hasher> cc{};\n-    cc.setup_bytes(32 << 20);\n+    local_rand_ctx = FastRandomContext(true);\n+    CuckooCache::cache<uint256, SignatureCacheHasher> cc{};\n+    size_t megabytes = 4;\n+    cc.setup_bytes(megabytes << 20);\n     uint256 v;\n     for (int x = 0; x < 100000; ++x) {\n         insecure_GetRandHash(v);\n@@ -78,7 +66,7 @@ BOOST_AUTO_TEST_CASE(test_cuckoocache_no_fakes)\n template <typename Cache>\n double test_cache(size_t megabytes, double load)\n {\n-    insecure_rand = FastRandomContext(true);\n+    local_rand_ctx = FastRandomContext(true);\n     std::vector<uint256> hashes;\n     Cache set{};\n     size_t bytes = megabytes * (1 << 20);\n@@ -88,7 +76,7 @@ double test_cache(size_t megabytes, double load)\n     for (uint32_t i = 0; i < n_insert; ++i) {\n         uint32_t* ptr = (uint32_t*)hashes[i].begin();\n         for (uint8_t j = 0; j < 8; ++j)\n-            *(ptr++) = insecure_rand.rand32();\n+            *(ptr++) = local_rand_ctx.rand32();\n     }\n     /** We make a copy of the hashes because future optimizations of the\n      * cuckoocache may overwrite the inserted element, so the test is\n@@ -135,9 +123,9 @@ BOOST_AUTO_TEST_CASE(cuckoocache_hit_rate_ok)\n      * as a lower bound on performance.\n      */\n     double HitRateThresh = 0.98;\n-    size_t megabytes = 32;\n+    size_t megabytes = 4;\n     for (double load = 0.1; load < 2; load *= 2) {\n-        double hits = test_cache<CuckooCache::cache<uint256, uint256Hasher>>(megabytes, load);\n+        double hits = test_cache<CuckooCache::cache<uint256, SignatureCacheHasher>>(megabytes, load);\n         BOOST_CHECK(normalize_hit_rate(hits, load) > HitRateThresh);\n     }\n }\n@@ -149,7 +137,7 @@ template <typename Cache>\n void test_cache_erase(size_t megabytes)\n {\n     double load = 1;\n-    insecure_rand = FastRandomContext(true);\n+    local_rand_ctx = FastRandomContext(true);\n     std::vector<uint256> hashes;\n     Cache set{};\n     size_t bytes = megabytes * (1 << 20);\n@@ -159,7 +147,7 @@ void test_cache_erase(size_t megabytes)\n     for (uint32_t i = 0; i < n_insert; ++i) {\n         uint32_t* ptr = (uint32_t*)hashes[i].begin();\n         for (uint8_t j = 0; j < 8; ++j)\n-            *(ptr++) = insecure_rand.rand32();\n+            *(ptr++) = local_rand_ctx.rand32();\n     }\n     /** We make a copy of the hashes because future optimizations of the\n      * cuckoocache may overwrite the inserted element, so the test is\n@@ -204,15 +192,15 @@ void test_cache_erase(size_t megabytes)\n \n BOOST_AUTO_TEST_CASE(cuckoocache_erase_ok)\n {\n-    size_t megabytes = 32;\n-    test_cache_erase<CuckooCache::cache<uint256, uint256Hasher>>(megabytes);\n+    size_t megabytes = 4;\n+    test_cache_erase<CuckooCache::cache<uint256, SignatureCacheHasher>>(megabytes);\n }\n \n template <typename Cache>\n void test_cache_erase_parallel(size_t megabytes)\n {\n     double load = 1;\n-    insecure_rand = FastRandomContext(true);\n+    local_rand_ctx = FastRandomContext(true);\n     std::vector<uint256> hashes;\n     Cache set{};\n     size_t bytes = megabytes * (1 << 20);\n@@ -222,7 +210,7 @@ void test_cache_erase_parallel(size_t megabytes)\n     for (uint32_t i = 0; i < n_insert; ++i) {\n         uint32_t* ptr = (uint32_t*)hashes[i].begin();\n         for (uint8_t j = 0; j < 8; ++j)\n-            *(ptr++) = insecure_rand.rand32();\n+            *(ptr++) = local_rand_ctx.rand32();\n     }\n     /** We make a copy of the hashes because future optimizations of the\n      * cuckoocache may overwrite the inserted element, so the test is\n@@ -291,8 +279,8 @@ void test_cache_erase_parallel(size_t megabytes)\n }\n BOOST_AUTO_TEST_CASE(cuckoocache_erase_parallel_ok)\n {\n-    size_t megabytes = 32;\n-    test_cache_erase_parallel<CuckooCache::cache<uint256, uint256Hasher>>(megabytes);\n+    size_t megabytes = 4;\n+    test_cache_erase_parallel<CuckooCache::cache<uint256, SignatureCacheHasher>>(megabytes);\n }\n \n \n@@ -314,7 +302,7 @@ void test_cache_generations()\n     // iterations with non-deterministic values, so it isn't \"overfit\" to the\n     // specific entropy in FastRandomContext(true) and implementation of the\n     // cache.\n-    insecure_rand = FastRandomContext(true);\n+    local_rand_ctx = FastRandomContext(true);\n \n     // block_activity models a chunk of network activity. n_insert elements are\n     // adde to the cache. The first and last n/4 are stored for removal later\n@@ -331,7 +319,7 @@ void test_cache_generations()\n             for (uint32_t i = 0; i < n_insert; ++i) {\n                 uint32_t* ptr = (uint32_t*)inserts[i].begin();\n                 for (uint8_t j = 0; j < 8; ++j)\n-                    *(ptr++) = insecure_rand.rand32();\n+                    *(ptr++) = local_rand_ctx.rand32();\n             }\n             for (uint32_t i = 0; i < n_insert / 4; ++i)\n                 reads.push_back(inserts[i]);\n@@ -342,13 +330,13 @@ void test_cache_generations()\n         }\n     };\n \n-    const uint32_t BLOCK_SIZE = 10000;\n+    const uint32_t BLOCK_SIZE = 1000;\n     // We expect window size 60 to perform reasonably given that each epoch\n     // stores 45% of the cache size (~472k).\n     const uint32_t WINDOW_SIZE = 60;\n     const uint32_t POP_AMOUNT = (BLOCK_SIZE / WINDOW_SIZE) / 2;\n     const double load = 10;\n-    const size_t megabytes = 32;\n+    const size_t megabytes = 4;\n     const size_t bytes = megabytes * (1 << 20);\n     const uint32_t n_insert = static_cast<uint32_t>(load * (bytes / sizeof(uint256)));\n \n@@ -379,7 +367,7 @@ void test_cache_generations()\n         // Loose Check that hit rate is above min_hit_rate\n         BOOST_CHECK(hit > min_hit_rate);\n         // Tighter check, count number of times we are less than tight_hit_rate\n-        // (and implicityly, greater than min_hit_rate)\n+        // (and implicitly, greater than min_hit_rate)\n         out_of_tight_tolerance += hit < tight_hit_rate;\n     }\n     // Check that being out of tolerance happens less than\n@@ -388,7 +376,7 @@ void test_cache_generations()\n }\n BOOST_AUTO_TEST_CASE(cuckoocache_generations)\n {\n-    test_cache_generations<CuckooCache::cache<uint256, uint256Hasher>>();\n+    test_cache_generations<CuckooCache::cache<uint256, SignatureCacheHasher>>();\n }\n \n BOOST_AUTO_TEST_SUITE_END();"
      },
      {
        "sha": "e35a7ce569c0e2abd18fd9e653d94562c2471ce2",
        "filename": "src/test/data/script_tests.json",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/data/script_tests.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/data/script_tests.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/script_tests.json?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -349,7 +349,7 @@\n [\"2147483647\", \"0x04 0xFFFFFF7F EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n [\"2147483648\", \"0x05 0x0000008000 EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n [\"549755813887\", \"0x05 0xFFFFFFFF7F EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n-[\"549755813888\", \"0x06 0xFFFFFFFF7F EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n+[\"549755813888\", \"0x06 0x000000008000 EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n [\"9223372036854775807\", \"0x08 0xFFFFFFFFFFFFFF7F EQUAL\", \"P2SH,STRICTENC\", \"OK\"],\n [\"-1\", \"0x01 0x81 EQUAL\", \"P2SH,STRICTENC\", \"OK\", \"Numbers are little-endian with the MSB being a sign bit\"],\n [\"-127\", \"0x01 0xFF EQUAL\", \"P2SH,STRICTENC\", \"OK\"],"
      },
      {
        "sha": "2d8a419bdb0f95b6650bc4b224535ab89fa17901",
        "filename": "src/test/dbwrapper_tests.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/dbwrapper_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/dbwrapper_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/dbwrapper_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -28,10 +28,10 @@ BOOST_AUTO_TEST_CASE(dbwrapper)\n     // Perform tests both obfuscated and non-obfuscated.\n     for (int i = 0; i < 2; i++) {\n         bool obfuscate = (bool)i;\n-        boost::filesystem::path ph = boost::filesystem::temp_directory_path() / boost::filesystem::unique_path();\n+        fs::path ph = fs::temp_directory_path() / fs::unique_path();\n         CDBWrapper dbw(ph, (1 << 20), true, false, obfuscate);\n         char key = 'k';\n-        uint256 in = GetRandHash();\n+        uint256 in = InsecureRand256();\n         uint256 res;\n \n         // Ensure that we're doing real obfuscation when obfuscate=true\n@@ -49,15 +49,15 @@ BOOST_AUTO_TEST_CASE(dbwrapper_batch)\n     // Perform tests both obfuscated and non-obfuscated.\n     for (int i = 0; i < 2; i++) {\n         bool obfuscate = (bool)i;\n-        boost::filesystem::path ph = boost::filesystem::temp_directory_path() / boost::filesystem::unique_path();\n+        fs::path ph = fs::temp_directory_path() / fs::unique_path();\n         CDBWrapper dbw(ph, (1 << 20), true, false, obfuscate);\n \n         char key = 'i';\n-        uint256 in = GetRandHash();\n+        uint256 in = InsecureRand256();\n         char key2 = 'j';\n-        uint256 in2 = GetRandHash();\n+        uint256 in2 = InsecureRand256();\n         char key3 = 'k';\n-        uint256 in3 = GetRandHash();\n+        uint256 in3 = InsecureRand256();\n \n         uint256 res;\n         CDBBatch batch(dbw);\n@@ -86,15 +86,15 @@ BOOST_AUTO_TEST_CASE(dbwrapper_iterator)\n     // Perform tests both obfuscated and non-obfuscated.\n     for (int i = 0; i < 2; i++) {\n         bool obfuscate = (bool)i;\n-        boost::filesystem::path ph = boost::filesystem::temp_directory_path() / boost::filesystem::unique_path();\n+        fs::path ph = fs::temp_directory_path() / fs::unique_path();\n         CDBWrapper dbw(ph, (1 << 20), true, false, obfuscate);\n \n         // The two keys are intentionally chosen for ordering\n         char key = 'j';\n-        uint256 in = GetRandHash();\n+        uint256 in = InsecureRand256();\n         BOOST_CHECK(dbw.Write(key, in));\n         char key2 = 'k';\n-        uint256 in2 = GetRandHash();\n+        uint256 in2 = InsecureRand256();\n         BOOST_CHECK(dbw.Write(key2, in2));\n \n         std::unique_ptr<CDBIterator> it(const_cast<CDBWrapper*>(&dbw)->NewIterator());\n@@ -125,14 +125,14 @@ BOOST_AUTO_TEST_CASE(dbwrapper_iterator)\n // Test that we do not obfuscation if there is existing data.\n BOOST_AUTO_TEST_CASE(existing_data_no_obfuscate)\n {\n-    // We're going to share this boost::filesystem::path between two wrappers\n-    boost::filesystem::path ph = boost::filesystem::temp_directory_path() / boost::filesystem::unique_path();\n+    // We're going to share this fs::path between two wrappers\n+    fs::path ph = fs::temp_directory_path() / fs::unique_path();\n     create_directories(ph);\n \n     // Set up a non-obfuscated wrapper to write some initial data.\n     CDBWrapper* dbw = new CDBWrapper(ph, (1 << 10), false, false, false);\n     char key = 'k';\n-    uint256 in = GetRandHash();\n+    uint256 in = InsecureRand256();\n     uint256 res;\n \n     BOOST_CHECK(dbw->Write(key, in));\n@@ -155,7 +155,7 @@ BOOST_AUTO_TEST_CASE(existing_data_no_obfuscate)\n     BOOST_CHECK(!odbw.IsEmpty()); // There should be existing data\n     BOOST_CHECK(is_null_key(dbwrapper_private::GetObfuscateKey(odbw))); // The key should be an empty string\n \n-    uint256 in2 = GetRandHash();\n+    uint256 in2 = InsecureRand256();\n     uint256 res3;\n  \n     // Check that we can write successfully\n@@ -167,14 +167,14 @@ BOOST_AUTO_TEST_CASE(existing_data_no_obfuscate)\n // Ensure that we start obfuscating during a reindex.\n BOOST_AUTO_TEST_CASE(existing_data_reindex)\n {\n-    // We're going to share this boost::filesystem::path between two wrappers\n-    boost::filesystem::path ph = boost::filesystem::temp_directory_path() / boost::filesystem::unique_path();\n+    // We're going to share this fs::path between two wrappers\n+    fs::path ph = fs::temp_directory_path() / fs::unique_path();\n     create_directories(ph);\n \n     // Set up a non-obfuscated wrapper to write some initial data.\n     CDBWrapper* dbw = new CDBWrapper(ph, (1 << 10), false, false, false);\n     char key = 'k';\n-    uint256 in = GetRandHash();\n+    uint256 in = InsecureRand256();\n     uint256 res;\n \n     BOOST_CHECK(dbw->Write(key, in));\n@@ -193,7 +193,7 @@ BOOST_AUTO_TEST_CASE(existing_data_reindex)\n     BOOST_CHECK(!odbw.Read(key, res2));\n     BOOST_CHECK(!is_null_key(dbwrapper_private::GetObfuscateKey(odbw)));\n \n-    uint256 in2 = GetRandHash();\n+    uint256 in2 = InsecureRand256();\n     uint256 res3;\n  \n     // Check that we can write successfully\n@@ -204,7 +204,7 @@ BOOST_AUTO_TEST_CASE(existing_data_reindex)\n \n BOOST_AUTO_TEST_CASE(iterator_ordering)\n {\n-    boost::filesystem::path ph = boost::filesystem::temp_directory_path() / boost::filesystem::unique_path();\n+    fs::path ph = fs::temp_directory_path() / fs::unique_path();\n     CDBWrapper dbw(ph, (1 << 20), true, false, false);\n     for (int x=0x00; x<256; ++x) {\n         uint8_t key = x;\n@@ -275,7 +275,7 @@ BOOST_AUTO_TEST_CASE(iterator_string_ordering)\n {\n     char buf[10];\n \n-    boost::filesystem::path ph = boost::filesystem::temp_directory_path() / boost::filesystem::unique_path();\n+    fs::path ph = fs::temp_directory_path() / fs::unique_path();\n     CDBWrapper dbw(ph, (1 << 20), true, false, false);\n     for (int x=0x00; x<10; ++x) {\n         for (int y = 0; y < 10; y++) {"
      },
      {
        "sha": "05b6b3b1e6a11f2d55fea0072d95be2bb0cbd957",
        "filename": "src/test/hash_tests.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/hash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/hash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/hash_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -128,6 +128,23 @@ BOOST_AUTO_TEST_CASE(siphash)\n     tx.nVersion = 1;\n     ss << tx;\n     BOOST_CHECK_EQUAL(SipHashUint256(1, 2, ss.GetHash()), 0x79751e980c2a0a35ULL);\n+\n+    // Check consistency between CSipHasher and SipHashUint256[Extra].\n+    FastRandomContext ctx;\n+    for (int i = 0; i < 16; ++i) {\n+        uint64_t k1 = ctx.rand64();\n+        uint64_t k2 = ctx.rand64();\n+        uint256 x = InsecureRand256();\n+        uint32_t n = ctx.rand32();\n+        uint8_t nb[4];\n+        WriteLE32(nb, n);\n+        CSipHasher sip256(k1, k2);\n+        sip256.Write(x.begin(), 32);\n+        CSipHasher sip288 = sip256;\n+        sip288.Write(nb, 4);\n+        BOOST_CHECK_EQUAL(SipHashUint256(k1, k2, x), sip256.Finalize());\n+        BOOST_CHECK_EQUAL(SipHashUint256Extra(k1, k2, x, n), sip288.Finalize());\n+    }\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "656aec606b6c2cc30a9211418960a3d1f186da85",
        "filename": "src/test/main_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/main_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/main_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/main_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -39,17 +39,18 @@ static void TestBlockSubsidyHalvings(int nSubsidyHalvingInterval)\n \n BOOST_AUTO_TEST_CASE(block_subsidy_test)\n {\n-    TestBlockSubsidyHalvings(Params(CBaseChainParams::MAIN).GetConsensus()); // As in main\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n+    TestBlockSubsidyHalvings(chainParams->GetConsensus()); // As in main\n     TestBlockSubsidyHalvings(150); // As in regtest\n     TestBlockSubsidyHalvings(1000); // Just another interval\n }\n \n BOOST_AUTO_TEST_CASE(subsidy_limit_test)\n {\n-    const Consensus::Params& consensusParams = Params(CBaseChainParams::MAIN).GetConsensus();\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n     CAmount nSum = 0;\n     for (int nHeight = 0; nHeight < 14000000; nHeight += 1000) {\n-        CAmount nSubsidy = GetBlockSubsidy(nHeight, consensusParams);\n+        CAmount nSubsidy = GetBlockSubsidy(nHeight, chainParams->GetConsensus());\n         BOOST_CHECK(nSubsidy <= 50 * COIN);\n         nSum += nSubsidy * 1000;\n         BOOST_CHECK(MoneyRange(nSum));"
      },
      {
        "sha": "1a1cf4399c2d58876846ff07a57b39087cf0f13f",
        "filename": "src/test/merkle_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/merkle_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/merkle_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/merkle_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -4,7 +4,6 @@\n \n #include \"consensus/merkle.h\"\n #include \"test/test_bitcoin.h\"\n-#include \"test/test_random.h\"\n \n #include <boost/test/unit_test.hpp>\n \n@@ -68,7 +67,7 @@ BOOST_AUTO_TEST_CASE(merkle_test)\n {\n     for (int i = 0; i < 32; i++) {\n         // Try 32 block sizes: all sizes from 0 to 16 inclusive, and then 15 random sizes.\n-        int ntx = (i <= 16) ? i : 17 + (insecure_rand() % 4000);\n+        int ntx = (i <= 16) ? i : 17 + (InsecureRandRange(4000));\n         // Try up to 3 mutations.\n         for (int mutate = 0; mutate <= 3; mutate++) {\n             int duplicate1 = mutate >= 1 ? 1 << ctz(ntx) : 0; // The last how many transactions to duplicate first.\n@@ -118,10 +117,10 @@ BOOST_AUTO_TEST_CASE(merkle_test)\n             // If no mutation was done (once for every ntx value), try up to 16 branches.\n             if (mutate == 0) {\n                 for (int loop = 0; loop < std::min(ntx, 16); loop++) {\n-                    // If ntx <= 16, try all branches. Otherise, try 16 random ones.\n+                    // If ntx <= 16, try all branches. Otherwise, try 16 random ones.\n                     int mtx = loop;\n                     if (ntx > 16) {\n-                        mtx = insecure_rand() % ntx;\n+                        mtx = InsecureRandRange(ntx);\n                     }\n                     std::vector<uint256> newBranch = BlockMerkleBranch(block, mtx);\n                     std::vector<uint256> oldBranch = BlockGetMerkleBranch(block, merkleTree, mtx);"
      },
      {
        "sha": "c95800a728c22b2f5635f48147172a44b9e2fa8a",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -6,6 +6,7 @@\n #include \"coins.h\"\n #include \"consensus/consensus.h\"\n #include \"consensus/merkle.h\"\n+#include \"consensus/tx_verify.h\"\n #include \"consensus/validation.h\"\n #include \"validation.h\"\n #include \"miner.h\"\n@@ -194,7 +195,8 @@ void TestPackageSelection(const CChainParams& chainparams, CScript scriptPubKey,\n BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n {\n     // Note that by default, these tests run with size accounting enabled.\n-    const CChainParams& chainparams = Params(CBaseChainParams::MAIN);\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n+    const CChainParams& chainparams = *chainParams;\n     CScript scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n     std::unique_ptr<CBlockTemplate> pblocktemplate;\n     CMutableTransaction tx,tx2;\n@@ -370,7 +372,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     while (chainActive.Tip()->nHeight < 209999) {\n         CBlockIndex* prev = chainActive.Tip();\n         CBlockIndex* next = new CBlockIndex();\n-        next->phashBlock = new uint256(GetRandHash());\n+        next->phashBlock = new uint256(InsecureRand256());\n         pcoinsTip->SetBestBlock(next->GetBlockHash());\n         next->pprev = prev;\n         next->nHeight = prev->nHeight + 1;\n@@ -382,7 +384,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     while (chainActive.Tip()->nHeight < 210000) {\n         CBlockIndex* prev = chainActive.Tip();\n         CBlockIndex* next = new CBlockIndex();\n-        next->phashBlock = new uint256(GetRandHash());\n+        next->phashBlock = new uint256(InsecureRand256());\n         pcoinsTip->SetBestBlock(next->GetBlockHash());\n         next->pprev = prev;\n         next->nHeight = prev->nHeight + 1;"
      },
      {
        "sha": "66354699b2ce2854dbad1a56fac12a8fc09cd509",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 2,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -11,6 +11,7 @@\n #include \"net.h\"\n #include \"netbase.h\"\n #include \"chainparams.h\"\n+#include \"util.h\"\n \n class CAddrManSerializationMock : public CAddrMan\n {\n@@ -72,6 +73,18 @@ CDataStream AddrmanToStream(CAddrManSerializationMock& _addrman)\n \n BOOST_FIXTURE_TEST_SUITE(net_tests, BasicTestingSetup)\n \n+BOOST_AUTO_TEST_CASE(cnode_listen_port)\n+{\n+    // test default\n+    unsigned short port = GetListenPort();\n+    BOOST_CHECK(port == Params().GetDefaultPort());\n+    // test set port\n+    unsigned short altPort = 12345;\n+    SoftSetArg(\"-port\", std::to_string(altPort));\n+    port = GetListenPort();\n+    BOOST_CHECK(port == altPort);\n+}\n+\n BOOST_AUTO_TEST_CASE(caddrdb_read)\n {\n     CAddrManUncorrupted addrmanUncorrupted;\n@@ -162,12 +175,12 @@ BOOST_AUTO_TEST_CASE(cnode_simple_test)\n     bool fInboundIn = false;\n \n     // Test that fFeeler is false by default.\n-    std::unique_ptr<CNode> pnode1(new CNode(id++, NODE_NETWORK, height, hSocket, addr, 0, 0, pszDest, fInboundIn));\n+    std::unique_ptr<CNode> pnode1(new CNode(id++, NODE_NETWORK, height, hSocket, addr, 0, 0, CAddress(), pszDest, fInboundIn));\n     BOOST_CHECK(pnode1->fInbound == false);\n     BOOST_CHECK(pnode1->fFeeler == false);\n \n     fInboundIn = true;\n-    std::unique_ptr<CNode> pnode2(new CNode(id++, NODE_NETWORK, height, hSocket, addr, 1, 1, pszDest, fInboundIn));\n+    std::unique_ptr<CNode> pnode2(new CNode(id++, NODE_NETWORK, height, hSocket, addr, 1, 1, CAddress(), pszDest, fInboundIn));\n     BOOST_CHECK(pnode2->fInbound == true);\n     BOOST_CHECK(pnode2->fFeeler == false);\n }"
      },
      {
        "sha": "e4b4b857208640855cddb3c78bb8d34f3946720d",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 13,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -7,7 +7,6 @@\n \n #include <string>\n \n-#include <boost/assign/list_of.hpp>\n #include <boost/test/unit_test.hpp>\n \n BOOST_FIXTURE_TEST_SUITE(netbase_tests, BasicTestingSetup)\n@@ -269,18 +268,18 @@ BOOST_AUTO_TEST_CASE(subnet_test)\n BOOST_AUTO_TEST_CASE(netbase_getgroup)\n {\n \n-    BOOST_CHECK(ResolveIP(\"127.0.0.1\").GetGroup() == boost::assign::list_of(0)); // Local -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"257.0.0.1\").GetGroup() == boost::assign::list_of(0)); // !Valid -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"10.0.0.1\").GetGroup() == boost::assign::list_of(0)); // RFC1918 -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"169.254.1.1\").GetGroup() == boost::assign::list_of(0)); // RFC3927 -> !Routable()\n-    BOOST_CHECK(ResolveIP(\"1.2.3.4\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // IPv4\n-    BOOST_CHECK(ResolveIP(\"::FFFF:0:102:304\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC6145\n-    BOOST_CHECK(ResolveIP(\"64:FF9B::102:304\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC6052\n-    BOOST_CHECK(ResolveIP(\"2002:102:304:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC3964\n-    BOOST_CHECK(ResolveIP(\"2001:0:9999:9999:9999:9999:FEFD:FCFB\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV4)(1)(2)); // RFC4380\n-    BOOST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetGroup() == boost::assign::list_of((unsigned char)NET_TOR)(239)); // Tor\n-    BOOST_CHECK(ResolveIP(\"2001:470:abcd:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV6)(32)(1)(4)(112)(175)); //he.net\n-    BOOST_CHECK(ResolveIP(\"2001:2001:9999:9999:9999:9999:9999:9999\").GetGroup() == boost::assign::list_of((unsigned char)NET_IPV6)(32)(1)(32)(1)); //IPv6\n+    BOOST_CHECK(ResolveIP(\"127.0.0.1\").GetGroup() == std::vector<unsigned char>({0})); // Local -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"257.0.0.1\").GetGroup() == std::vector<unsigned char>({0})); // !Valid -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"10.0.0.1\").GetGroup() == std::vector<unsigned char>({0})); // RFC1918 -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"169.254.1.1\").GetGroup() == std::vector<unsigned char>({0})); // RFC3927 -> !Routable()\n+    BOOST_CHECK(ResolveIP(\"1.2.3.4\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // IPv4\n+    BOOST_CHECK(ResolveIP(\"::FFFF:0:102:304\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC6145\n+    BOOST_CHECK(ResolveIP(\"64:FF9B::102:304\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC6052\n+    BOOST_CHECK(ResolveIP(\"2002:102:304:9999:9999:9999:9999:9999\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC3964\n+    BOOST_CHECK(ResolveIP(\"2001:0:9999:9999:9999:9999:FEFD:FCFB\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV4, 1, 2})); // RFC4380\n+    BOOST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_TOR, 239})); // Tor\n+    BOOST_CHECK(ResolveIP(\"2001:470:abcd:9999:9999:9999:9999:9999\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV6, 32, 1, 4, 112, 175})); //he.net\n+    BOOST_CHECK(ResolveIP(\"2001:2001:9999:9999:9999:9999:9999:9999\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV6, 32, 1, 32, 1})); //IPv6\n \n }\n "
      },
      {
        "sha": "c1d216d09445b64d56bf6d6991e45daa5d678b17",
        "filename": "src/test/pmt_tests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 14,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/pmt_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/pmt_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pmt_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -10,20 +10,18 @@\n #include \"arith_uint256.h\"\n #include \"version.h\"\n #include \"test/test_bitcoin.h\"\n-#include \"test/test_random.h\"\n \n #include <vector>\n \n-#include <boost/assign/list_of.hpp>\n #include <boost/test/unit_test.hpp>\n \n class CPartialMerkleTreeTester : public CPartialMerkleTree\n {\n public:\n     // flip one bit in one of the hashes - this should break the authentication\n     void Damage() {\n-        unsigned int n = insecure_rand() % vHash.size();\n-        int bit = insecure_rand() % 256;\n+        unsigned int n = InsecureRandRange(vHash.size());\n+        int bit = InsecureRandBits(8);\n         *(vHash[n].begin() + (bit>>3)) ^= 1<<(bit&7);\n     }\n };\n@@ -32,7 +30,7 @@ BOOST_FIXTURE_TEST_SUITE(pmt_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(pmt_test1)\n {\n-    seed_insecure_rand(false);\n+    SeedInsecureRand(false);\n     static const unsigned int nTxCounts[] = {1, 4, 7, 17, 56, 100, 127, 256, 312, 513, 1000, 4095};\n \n     for (int i = 0; i < 12; i++) {\n@@ -63,7 +61,7 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n             std::vector<bool> vMatch(nTx, false);\n             std::vector<uint256> vMatchTxid1;\n             for (unsigned int j=0; j<nTx; j++) {\n-                bool fInclude = (insecure_rand() & ((1 << (att/2)) - 1)) == 0;\n+                bool fInclude = InsecureRandBits(att / 2) == 0;\n                 vMatch[j] = fInclude;\n                 if (fInclude)\n                     vMatchTxid1.push_back(vTxid[j]);\n@@ -110,14 +108,15 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n \n BOOST_AUTO_TEST_CASE(pmt_malleability)\n {\n-    std::vector<uint256> vTxid = boost::assign::list_of\n-        (ArithToUint256(1))(ArithToUint256(2))\n-        (ArithToUint256(3))(ArithToUint256(4))\n-        (ArithToUint256(5))(ArithToUint256(6))\n-        (ArithToUint256(7))(ArithToUint256(8))\n-        (ArithToUint256(9))(ArithToUint256(10))\n-        (ArithToUint256(9))(ArithToUint256(10));\n-    std::vector<bool> vMatch = boost::assign::list_of(false)(false)(false)(false)(false)(false)(false)(false)(false)(true)(true)(false);\n+    std::vector<uint256> vTxid = {\n+        ArithToUint256(1), ArithToUint256(2),\n+        ArithToUint256(3), ArithToUint256(4),\n+        ArithToUint256(5), ArithToUint256(6),\n+        ArithToUint256(7), ArithToUint256(8),\n+        ArithToUint256(9), ArithToUint256(10),\n+        ArithToUint256(9), ArithToUint256(10),\n+    };\n+    std::vector<bool> vMatch = {false, false, false, false, false, false, false, false, false, true, true, false};\n \n     CPartialMerkleTree tree(vTxid, vMatch);\n     std::vector<unsigned int> vIndex;"
      },
      {
        "sha": "6bfd31564730233d800b244a2b93bd56bbdb6123",
        "filename": "src/test/policyestimator_tests.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 38,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/policyestimator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/policyestimator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/policyestimator_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -16,7 +16,8 @@ BOOST_FIXTURE_TEST_SUITE(policyestimator_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n {\n-    CTxMemPool mpool;\n+    CBlockPolicyEstimator feeEst;\n+    CTxMemPool mpool(&feeEst);\n     TestMemPoolEntryHelper entry;\n     CAmount basefee(2000);\n     CAmount deltaFee(100);\n@@ -49,8 +50,8 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     int blocknum = 0;\n \n     // Loop through 200 blocks\n-    // At a decay .998 and 4 fee transactions per block\n-    // This makes the tx count about 1.33 per bucket, above the 1 threshold\n+    // At a decay .9952 and 4 fee transactions per block\n+    // This makes the tx count about 2.5 per bucket, well above the 0.1 threshold\n     while (blocknum < 200) {\n         for (int j = 0; j < 10; j++) { // For each fee\n             for (int k = 0; k < 4; k++) { // add 4 fee txs\n@@ -74,20 +75,14 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n         }\n         mpool.removeForBlock(block, ++blocknum);\n         block.clear();\n-        if (blocknum == 30) {\n-            // At this point we should need to combine 5 buckets to get enough data points\n-            // So estimateFee(1,2,3) should fail and estimateFee(4) should return somewhere around\n-            // 8*baserate.  estimateFee(4) %'s are 100,100,100,100,90 = average 98%\n-            BOOST_CHECK(mpool.estimateFee(1) == CFeeRate(0));\n-            BOOST_CHECK(mpool.estimateFee(2) == CFeeRate(0));\n-            BOOST_CHECK(mpool.estimateFee(3) == CFeeRate(0));\n-            BOOST_CHECK(mpool.estimateFee(4).GetFeePerK() < 8*baseRate.GetFeePerK() + deltaFee);\n-            BOOST_CHECK(mpool.estimateFee(4).GetFeePerK() > 8*baseRate.GetFeePerK() - deltaFee);\n-            int answerFound;\n-            BOOST_CHECK(mpool.estimateSmartFee(1, &answerFound) == mpool.estimateFee(4) && answerFound == 4);\n-            BOOST_CHECK(mpool.estimateSmartFee(3, &answerFound) == mpool.estimateFee(4) && answerFound == 4);\n-            BOOST_CHECK(mpool.estimateSmartFee(4, &answerFound) == mpool.estimateFee(4) && answerFound == 4);\n-            BOOST_CHECK(mpool.estimateSmartFee(8, &answerFound) == mpool.estimateFee(8) && answerFound == 8);\n+        // Check after just a few txs that combining buckets works as expected\n+        if (blocknum == 3) {\n+            // At this point we should need to combine 3 buckets to get enough data points\n+            // So estimateFee(1) should fail and estimateFee(2) should return somewhere around\n+            // 9*baserate.  estimateFee(2) %'s are 100,100,90 = average 97%\n+            BOOST_CHECK(feeEst.estimateFee(1) == CFeeRate(0));\n+            BOOST_CHECK(feeEst.estimateFee(2).GetFeePerK() < 9*baseRate.GetFeePerK() + deltaFee);\n+            BOOST_CHECK(feeEst.estimateFee(2).GetFeePerK() > 9*baseRate.GetFeePerK() - deltaFee);\n         }\n     }\n \n@@ -99,29 +94,30 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     // Second highest feerate has 100% chance of being included by 2 blocks,\n     // so estimateFee(2) should return 9*baseRate etc...\n     for (int i = 1; i < 10;i++) {\n-        origFeeEst.push_back(mpool.estimateFee(i).GetFeePerK());\n+        origFeeEst.push_back(feeEst.estimateFee(i).GetFeePerK());\n         if (i > 2) { // Fee estimates should be monotonically decreasing\n             BOOST_CHECK(origFeeEst[i-1] <= origFeeEst[i-2]);\n         }\n         int mult = 11-i;\n-        if (i > 1) {\n+        if (i % 2 == 0) { //At scale 2, test logic is only correct for even targets\n             BOOST_CHECK(origFeeEst[i-1] < mult*baseRate.GetFeePerK() + deltaFee);\n             BOOST_CHECK(origFeeEst[i-1] > mult*baseRate.GetFeePerK() - deltaFee);\n         }\n-        else {\n-            BOOST_CHECK(origFeeEst[i-1] == CFeeRate(0).GetFeePerK());\n-        }\n+    }\n+    // Fill out rest of the original estimates\n+    for (int i = 10; i <= 48; i++) {\n+        origFeeEst.push_back(feeEst.estimateFee(i).GetFeePerK());\n     }\n \n     // Mine 50 more blocks with no transactions happening, estimates shouldn't change\n     // We haven't decayed the moving average enough so we still have enough data points in every bucket\n     while (blocknum < 250)\n         mpool.removeForBlock(block, ++blocknum);\n \n-    BOOST_CHECK(mpool.estimateFee(1) == CFeeRate(0));\n+    BOOST_CHECK(feeEst.estimateFee(1) == CFeeRate(0));\n     for (int i = 2; i < 10;i++) {\n-        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() < origFeeEst[i-1] + deltaFee);\n-        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n+        BOOST_CHECK(feeEst.estimateFee(i).GetFeePerK() < origFeeEst[i-1] + deltaFee);\n+        BOOST_CHECK(feeEst.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n     }\n \n \n@@ -139,10 +135,8 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n         mpool.removeForBlock(block, ++blocknum);\n     }\n \n-    int answerFound;\n     for (int i = 1; i < 10;i++) {\n-        BOOST_CHECK(mpool.estimateFee(i) == CFeeRate(0) || mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n-        BOOST_CHECK(mpool.estimateSmartFee(i, &answerFound).GetFeePerK() > origFeeEst[answerFound-1] - deltaFee);\n+        BOOST_CHECK(feeEst.estimateFee(i) == CFeeRate(0) || feeEst.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n     }\n \n     // Mine all those transactions\n@@ -155,16 +149,16 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n             txHashes[j].pop_back();\n         }\n     }\n-    mpool.removeForBlock(block, 265);\n+    mpool.removeForBlock(block, 266);\n     block.clear();\n-    BOOST_CHECK(mpool.estimateFee(1) == CFeeRate(0));\n+    BOOST_CHECK(feeEst.estimateFee(1) == CFeeRate(0));\n     for (int i = 2; i < 10;i++) {\n-        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n+        BOOST_CHECK(feeEst.estimateFee(i) == CFeeRate(0) || feeEst.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n     }\n \n-    // Mine 200 more blocks where everything is mined every block\n+    // Mine 400 more blocks where everything is mined every block\n     // Estimates should be below original estimates\n-    while (blocknum < 465) {\n+    while (blocknum < 665) {\n         for (int j = 0; j < 10; j++) { // For each fee multiple\n             for (int k = 0; k < 4; k++) { // add 4 fee txs\n                 tx.vin[0].prevout.n = 10000*blocknum+100*j+k;\n@@ -179,9 +173,9 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n         mpool.removeForBlock(block, ++blocknum);\n         block.clear();\n     }\n-    BOOST_CHECK(mpool.estimateFee(1) == CFeeRate(0));\n-    for (int i = 2; i < 10; i++) {\n-        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() < origFeeEst[i-1] - deltaFee);\n+    BOOST_CHECK(feeEst.estimateFee(1) == CFeeRate(0));\n+    for (int i = 2; i < 9; i++) { // At 9, the original estimate was already at the bottom (b/c scale = 2)\n+        BOOST_CHECK(feeEst.estimateFee(i).GetFeePerK() < origFeeEst[i-1] - deltaFee);\n     }\n \n     // Test that if the mempool is limited, estimateSmartFee won't return a value below the mempool min fee\n@@ -190,8 +184,8 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     mpool.TrimToSize(1);\n     BOOST_CHECK(mpool.GetMinFee(1).GetFeePerK() > feeV[5]);\n     for (int i = 1; i < 10; i++) {\n-        BOOST_CHECK(mpool.estimateSmartFee(i).GetFeePerK() >= mpool.estimateFee(i).GetFeePerK());\n-        BOOST_CHECK(mpool.estimateSmartFee(i).GetFeePerK() >= mpool.GetMinFee(1).GetFeePerK());\n+        BOOST_CHECK(feeEst.estimateSmartFee(i, NULL, mpool).GetFeePerK() >= feeEst.estimateRawFee(i, 0.85, FeeEstimateHorizon::MED_HALFLIFE).GetFeePerK());\n+        BOOST_CHECK(feeEst.estimateSmartFee(i, NULL, mpool).GetFeePerK() >= mpool.GetMinFee(1).GetFeePerK());\n     }\n }\n "
      },
      {
        "sha": "b9fabd02e4df57dac6435a6a234a4515c7d3267b",
        "filename": "src/test/pow_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 24,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/pow_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/pow_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pow_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -16,79 +16,69 @@ BOOST_FIXTURE_TEST_SUITE(pow_tests, BasicTestingSetup)\n /* Test calculation of next difficulty target with no constraints applying */\n BOOST_AUTO_TEST_CASE(get_next_work)\n {\n-    SelectParams(CBaseChainParams::MAIN);\n-    const Consensus::Params& params = Params().GetConsensus();\n-\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n     int64_t nLastRetargetTime = 1261130161; // Block #30240\n     CBlockIndex pindexLast;\n     pindexLast.nHeight = 32255;\n     pindexLast.nTime = 1262152739;  // Block #32255\n     pindexLast.nBits = 0x1d00ffff;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1d00d86a);\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00d86a);\n }\n \n /* Test the constraint on the upper bound for next work */\n BOOST_AUTO_TEST_CASE(get_next_work_pow_limit)\n {\n-    SelectParams(CBaseChainParams::MAIN);\n-    const Consensus::Params& params = Params().GetConsensus();\n-\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n     int64_t nLastRetargetTime = 1231006505; // Block #0\n     CBlockIndex pindexLast;\n     pindexLast.nHeight = 2015;\n     pindexLast.nTime = 1233061996;  // Block #2015\n     pindexLast.nBits = 0x1d00ffff;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1d00ffff);\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00ffff);\n }\n \n /* Test the constraint on the lower bound for actual time taken */\n BOOST_AUTO_TEST_CASE(get_next_work_lower_limit_actual)\n {\n-    SelectParams(CBaseChainParams::MAIN);\n-    const Consensus::Params& params = Params().GetConsensus();\n-\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n     int64_t nLastRetargetTime = 1279008237; // Block #66528\n     CBlockIndex pindexLast;\n     pindexLast.nHeight = 68543;\n     pindexLast.nTime = 1279297671;  // Block #68543\n     pindexLast.nBits = 0x1c05a3f4;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1c0168fd);\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1c0168fd);\n }\n \n /* Test the constraint on the upper bound for actual time taken */\n BOOST_AUTO_TEST_CASE(get_next_work_upper_limit_actual)\n {\n-    SelectParams(CBaseChainParams::MAIN);\n-    const Consensus::Params& params = Params().GetConsensus();\n-\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n     int64_t nLastRetargetTime = 1263163443; // NOTE: Not an actual block time\n     CBlockIndex pindexLast;\n     pindexLast.nHeight = 46367;\n     pindexLast.nTime = 1269211443;  // Block #46367\n     pindexLast.nBits = 0x1c387f6f;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, params), 0x1d00e1fd);\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00e1fd);\n }\n \n BOOST_AUTO_TEST_CASE(GetBlockProofEquivalentTime_test)\n {\n-    SelectParams(CBaseChainParams::MAIN);\n-    const Consensus::Params& params = Params().GetConsensus();\n-\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n     std::vector<CBlockIndex> blocks(10000);\n     for (int i = 0; i < 10000; i++) {\n         blocks[i].pprev = i ? &blocks[i - 1] : NULL;\n         blocks[i].nHeight = i;\n-        blocks[i].nTime = 1269211443 + i * params.nPowTargetSpacing;\n+        blocks[i].nTime = 1269211443 + i * chainParams->GetConsensus().nPowTargetSpacing;\n         blocks[i].nBits = 0x207fffff; /* target 0x7fffff000... */\n         blocks[i].nChainWork = i ? blocks[i - 1].nChainWork + GetBlockProof(blocks[i - 1]) : arith_uint256(0);\n     }\n \n     for (int j = 0; j < 1000; j++) {\n-        CBlockIndex *p1 = &blocks[GetRand(10000)];\n-        CBlockIndex *p2 = &blocks[GetRand(10000)];\n-        CBlockIndex *p3 = &blocks[GetRand(10000)];\n+        CBlockIndex *p1 = &blocks[InsecureRandRange(10000)];\n+        CBlockIndex *p2 = &blocks[InsecureRandRange(10000)];\n+        CBlockIndex *p3 = &blocks[InsecureRandRange(10000)];\n \n-        int64_t tdiff = GetBlockProofEquivalentTime(*p1, *p2, *p3, params);\n+        int64_t tdiff = GetBlockProofEquivalentTime(*p1, *p2, *p3, chainParams->GetConsensus());\n         BOOST_CHECK_EQUAL(tdiff, p1->GetBlockTime() - p2->GetBlockTime());\n     }\n }"
      },
      {
        "sha": "354fed1c1dad3fdc405cc2d412b8a079d5ba0a58",
        "filename": "src/test/prevector_tests.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 39,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/prevector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/prevector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/prevector_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -9,7 +9,6 @@\n #include \"streams.h\"\n \n #include \"test/test_bitcoin.h\"\n-#include \"test/test_random.h\"\n \n #include <boost/test/unit_test.hpp>\n \n@@ -28,6 +27,7 @@ class prevector_tester {\n     typedef typename pretype::size_type Size;\n     bool passed = true;\n     FastRandomContext rand_cache;\n+    uint256 rand_seed;\n \n \n     template <typename A, typename B>\n@@ -183,13 +183,12 @@ class prevector_tester {\n     }\n \n     ~prevector_tester() {\n-        BOOST_CHECK_MESSAGE(passed, \"insecure_rand_Rz: \"\n-                << rand_cache.Rz\n-                << \", insecure_rand_Rw: \"\n-                << rand_cache.Rw);\n+        BOOST_CHECK_MESSAGE(passed, \"insecure_rand: \" + rand_seed.ToString());\n     }\n+\n     prevector_tester() {\n-        seed_insecure_rand();\n+        SeedInsecureRand();\n+        rand_seed = insecure_rand_seed;\n         rand_cache = insecure_rand_ctx;\n     }\n };\n@@ -199,67 +198,65 @@ BOOST_AUTO_TEST_CASE(PrevectorTestInt)\n     for (int j = 0; j < 64; j++) {\n         prevector_tester<8, int> test;\n         for (int i = 0; i < 2048; i++) {\n-            int r = insecure_rand();\n-            if ((r % 4) == 0) {\n-                test.insert(insecure_rand() % (test.size() + 1), insecure_rand());\n+            if (InsecureRandBits(2) == 0) {\n+                test.insert(InsecureRandRange(test.size() + 1), InsecureRand32());\n             }\n-            if (test.size() > 0 && ((r >> 2) % 4) == 1) {\n-                test.erase(insecure_rand() % test.size());\n+            if (test.size() > 0 && InsecureRandBits(2) == 1) {\n+                test.erase(InsecureRandRange(test.size()));\n             }\n-            if (((r >> 4) % 8) == 2) {\n-                int new_size = std::max<int>(0, std::min<int>(30, test.size() + (insecure_rand() % 5) - 2));\n+            if (InsecureRandBits(3) == 2) {\n+                int new_size = std::max<int>(0, std::min<int>(30, test.size() + (InsecureRandRange(5)) - 2));\n                 test.resize(new_size);\n             }\n-            if (((r >> 7) % 8) == 3) {\n-                test.insert(insecure_rand() % (test.size() + 1), 1 + (insecure_rand() % 2), insecure_rand());\n+            if (InsecureRandBits(3) == 3) {\n+                test.insert(InsecureRandRange(test.size() + 1), 1 + InsecureRandBool(), InsecureRand32());\n             }\n-            if (((r >> 10) % 8) == 4) {\n-                int del = std::min<int>(test.size(), 1 + (insecure_rand() % 2));\n-                int beg = insecure_rand() % (test.size() + 1 - del);\n+            if (InsecureRandBits(3) == 4) {\n+                int del = std::min<int>(test.size(), 1 + (InsecureRandBool()));\n+                int beg = InsecureRandRange(test.size() + 1 - del);\n                 test.erase(beg, beg + del);\n             }\n-            if (((r >> 13) % 16) == 5) {\n-                test.push_back(insecure_rand());\n+            if (InsecureRandBits(4) == 5) {\n+                test.push_back(InsecureRand32());\n             }\n-            if (test.size() > 0 && ((r >> 17) % 16) == 6) {\n+            if (test.size() > 0 && InsecureRandBits(4) == 6) {\n                 test.pop_back();\n             }\n-            if (((r >> 21) % 32) == 7) {\n+            if (InsecureRandBits(5) == 7) {\n                 int values[4];\n-                int num = 1 + (insecure_rand() % 4);\n+                int num = 1 + (InsecureRandBits(2));\n                 for (int k = 0; k < num; k++) {\n-                    values[k] = insecure_rand();\n+                    values[k] = InsecureRand32();\n                 }\n-                test.insert_range(insecure_rand() % (test.size() + 1), values, values + num);\n+                test.insert_range(InsecureRandRange(test.size() + 1), values, values + num);\n             }\n-            if (((r >> 26) % 32) == 8) {\n-                int del = std::min<int>(test.size(), 1 + (insecure_rand() % 4));\n-                int beg = insecure_rand() % (test.size() + 1 - del);\n+            if (InsecureRandBits(5) == 8) {\n+                int del = std::min<int>(test.size(), 1 + (InsecureRandBits(2)));\n+                int beg = InsecureRandRange(test.size() + 1 - del);\n                 test.erase(beg, beg + del);\n             }\n-            r = insecure_rand();\n-            if (r % 32 == 9) {\n-                test.reserve(insecure_rand() % 32);\n+            if (InsecureRandBits(5) == 9) {\n+                test.reserve(InsecureRandBits(5));\n             }\n-            if ((r >> 5) % 64 == 10) {\n+            if (InsecureRandBits(6) == 10) {\n                 test.shrink_to_fit();\n             }\n             if (test.size() > 0) {\n-                test.update(insecure_rand() % test.size(), insecure_rand());\n+                test.update(InsecureRandRange(test.size()), InsecureRand32());\n             }\n-            if (((r >> 11) % 1024) == 11) {\n+            if (InsecureRandBits(10) == 11) {\n                 test.clear();\n             }\n-            if (((r >> 21) % 512) == 12) {\n-                test.assign(insecure_rand() % 32, insecure_rand());\n+            if (InsecureRandBits(9) == 12) {\n+                test.assign(InsecureRandBits(5), InsecureRand32());\n             }\n-            if (((r >> 15) % 8) == 3) {\n+            if (InsecureRandBits(3) == 3) {\n                 test.swap();\n             }\n-            if (((r >> 15) % 16) == 8) {\n+            if (InsecureRandBits(4) == 8) {\n                 test.copy();\n             }\n-            if (((r >> 15) % 32) == 18) {\n+            if (InsecureRandBits(5) == 18) {\n                 test.move();\n             }\n         }"
      },
      {
        "sha": "132e190051ea30c8a97f16853f2eefa7ac4dfb0d",
        "filename": "src/test/random_tests.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 1,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/random_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/random_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/random_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -15,5 +15,46 @@ BOOST_AUTO_TEST_CASE(osrandom_tests)\n     BOOST_CHECK(Random_SanityCheck());\n }\n \n-BOOST_AUTO_TEST_SUITE_END()\n+BOOST_AUTO_TEST_CASE(fastrandom_tests)\n+{\n+    // Check that deterministic FastRandomContexts are deterministic\n+    FastRandomContext ctx1(true);\n+    FastRandomContext ctx2(true);\n+\n+    BOOST_CHECK_EQUAL(ctx1.rand32(), ctx2.rand32());\n+    BOOST_CHECK_EQUAL(ctx1.rand32(), ctx2.rand32());\n+    BOOST_CHECK_EQUAL(ctx1.rand64(), ctx2.rand64());\n+    BOOST_CHECK_EQUAL(ctx1.randbits(3), ctx2.randbits(3));\n+    BOOST_CHECK(ctx1.randbytes(17) == ctx2.randbytes(17));\n+    BOOST_CHECK(ctx1.rand256() == ctx2.rand256());\n+    BOOST_CHECK_EQUAL(ctx1.randbits(7), ctx2.randbits(7));\n+    BOOST_CHECK(ctx1.randbytes(128) == ctx2.randbytes(128));\n+    BOOST_CHECK_EQUAL(ctx1.rand32(), ctx2.rand32());\n+    BOOST_CHECK_EQUAL(ctx1.randbits(3), ctx2.randbits(3));\n+    BOOST_CHECK(ctx1.rand256() == ctx2.rand256());\n+    BOOST_CHECK(ctx1.randbytes(50) == ctx2.randbytes(50));\n+\n+    // Check that a nondeterministic ones are not\n+    FastRandomContext ctx3;\n+    FastRandomContext ctx4;\n+    BOOST_CHECK(ctx3.rand64() != ctx4.rand64()); // extremely unlikely to be equal\n+    BOOST_CHECK(ctx3.rand256() != ctx4.rand256());\n+    BOOST_CHECK(ctx3.randbytes(7) != ctx4.randbytes(7));\n+}\n \n+BOOST_AUTO_TEST_CASE(fastrandom_randbits)\n+{\n+    FastRandomContext ctx1;\n+    FastRandomContext ctx2;\n+    for (int bits = 0; bits < 63; ++bits) {\n+        for (int j = 0; j < 1000; ++j) {\n+            uint64_t rangebits = ctx1.randbits(bits);\n+            BOOST_CHECK_EQUAL(rangebits >> bits, 0);\n+            uint64_t range = ((uint64_t)1) << bits | rangebits;\n+            uint64_t rand = ctx2.randrange(range);\n+            BOOST_CHECK(rand < range);\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "134bd7c6094f15cfccb39692ef80ab5dd028b1d7",
        "filename": "src/test/rpc_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/rpc_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/rpc_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/rpc_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -11,7 +11,6 @@\n #include \"test/test_bitcoin.h\"\n \n #include <boost/algorithm/string.hpp>\n-#include <boost/assign/list_of.hpp>\n #include <boost/test/unit_test.hpp>\n \n #include <univalue.h>\n@@ -276,7 +275,7 @@ BOOST_AUTO_TEST_CASE(rpc_ban)\n     BOOST_CHECK(banned_until.get_int64() > now);\n     BOOST_CHECK(banned_until.get_int64()-now <= 200);\n \n-    // must throw an exception because 127.0.0.1 is in already banned suubnet range\n+    // must throw an exception because 127.0.0.1 is in already banned subnet range\n     BOOST_CHECK_THROW(r = CallRPC(std::string(\"setban 127.0.0.1 add\")), std::runtime_error);\n \n     BOOST_CHECK_NO_THROW(CallRPC(std::string(\"setban 127.0.0.0/24 remove\")));\n@@ -324,20 +323,20 @@ BOOST_AUTO_TEST_CASE(rpc_convert_values_generatetoaddress)\n {\n     UniValue result;\n \n-    BOOST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", boost::assign::list_of(\"101\")(\"mkESjLZW66TmHhiFX8MCaBjrhZ543PPh9a\")));\n+    BOOST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", {\"101\", \"mkESjLZW66TmHhiFX8MCaBjrhZ543PPh9a\"}));\n     BOOST_CHECK_EQUAL(result[0].get_int(), 101);\n     BOOST_CHECK_EQUAL(result[1].get_str(), \"mkESjLZW66TmHhiFX8MCaBjrhZ543PPh9a\");\n \n-    BOOST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", boost::assign::list_of(\"101\")(\"mhMbmE2tE9xzJYCV9aNC8jKWN31vtGrguU\")));\n+    BOOST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", {\"101\", \"mhMbmE2tE9xzJYCV9aNC8jKWN31vtGrguU\"}));\n     BOOST_CHECK_EQUAL(result[0].get_int(), 101);\n     BOOST_CHECK_EQUAL(result[1].get_str(), \"mhMbmE2tE9xzJYCV9aNC8jKWN31vtGrguU\");\n \n-    BOOST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", boost::assign::list_of(\"1\")(\"mkESjLZW66TmHhiFX8MCaBjrhZ543PPh9a\")(\"9\")));\n+    BOOST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", {\"1\", \"mkESjLZW66TmHhiFX8MCaBjrhZ543PPh9a\", \"9\"}));\n     BOOST_CHECK_EQUAL(result[0].get_int(), 1);\n     BOOST_CHECK_EQUAL(result[1].get_str(), \"mkESjLZW66TmHhiFX8MCaBjrhZ543PPh9a\");\n     BOOST_CHECK_EQUAL(result[2].get_int(), 9);\n \n-    BOOST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", boost::assign::list_of(\"1\")(\"mhMbmE2tE9xzJYCV9aNC8jKWN31vtGrguU\")(\"9\")));\n+    BOOST_CHECK_NO_THROW(result = RPCConvertValues(\"generatetoaddress\", {\"1\", \"mhMbmE2tE9xzJYCV9aNC8jKWN31vtGrguU\", \"9\"}));\n     BOOST_CHECK_EQUAL(result[0].get_int(), 1);\n     BOOST_CHECK_EQUAL(result[1].get_str(), \"mhMbmE2tE9xzJYCV9aNC8jKWN31vtGrguU\");\n     BOOST_CHECK_EQUAL(result[2].get_int(), 9);"
      },
      {
        "sha": "1de865776e78e4b3e3fc6af7757792ec816f564e",
        "filename": "src/test/scheduler_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 6,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/scheduler_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/scheduler_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/scheduler_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -8,8 +8,6 @@\n #include \"test/test_bitcoin.h\"\n \n #include <boost/bind.hpp>\n-#include <boost/random/mersenne_twister.hpp>\n-#include <boost/random/uniform_int_distribution.hpp>\n #include <boost/thread.hpp>\n #include <boost/test/unit_test.hpp>\n \n@@ -56,10 +54,10 @@ BOOST_AUTO_TEST_CASE(manythreads)\n \n     boost::mutex counterMutex[10];\n     int counter[10] = { 0 };\n-    boost::random::mt19937 rng(42);\n-    boost::random::uniform_int_distribution<> zeroToNine(0, 9);\n-    boost::random::uniform_int_distribution<> randomMsec(-11, 1000);\n-    boost::random::uniform_int_distribution<> randomDelta(-1000, 1000);\n+    FastRandomContext rng(42);\n+    auto zeroToNine = [](FastRandomContext& rc) -> int { return rc.randrange(10); }; // [0, 9]\n+    auto randomMsec = [](FastRandomContext& rc) -> int { return -11 + rc.randrange(1012); }; // [-11, 1000]\n+    auto randomDelta = [](FastRandomContext& rc) -> int { return -1000 + rc.randrange(2001); }; // [-1000, 1000]\n \n     boost::chrono::system_clock::time_point start = boost::chrono::system_clock::now();\n     boost::chrono::system_clock::time_point now = start;"
      },
      {
        "sha": "0789b2e80cacdf2c044c5b3c133500273ccda6dc",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"consensus/tx_verify.h\"\n #include \"core_io.h\"\n #include \"key.h\"\n #include \"keystore.h\"\n@@ -111,7 +112,8 @@ BOOST_AUTO_TEST_CASE(sign)\n         {\n             CScript sigSave = txTo[i].vin[0].scriptSig;\n             txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n-            bool sigOK = CScriptCheck(CCoins(txFrom, 0), txTo[i], 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC, false, &txdata)();\n+            const CTxOut& output = txFrom.vout[txTo[i].vin[0].prevout.n];\n+            bool sigOK = CScriptCheck(output.scriptPubKey, output.nValue, txTo[i], 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC, false, &txdata)();\n             if (i == j)\n                 BOOST_CHECK_MESSAGE(sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n             else\n@@ -315,7 +317,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txFrom.vout[6].scriptPubKey = GetScriptForDestination(CScriptID(twentySigops));\n     txFrom.vout[6].nValue = 6000;\n \n-    coins.ModifyCoins(txFrom.GetHash())->FromTx(txFrom, 0);\n+    AddCoins(coins, txFrom, 0);\n \n     CMutableTransaction txTo;\n     txTo.vout.resize(1);"
      },
      {
        "sha": "70544cacd6a8e58a1ff509c6311ea09eaf59fe5b",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1438,4 +1438,18 @@ BOOST_AUTO_TEST_CASE(script_FindAndDelete)\n     BOOST_CHECK(s == expect);\n }\n \n+BOOST_AUTO_TEST_CASE(script_HasValidOps)\n+{\n+    // Exercise the HasValidOps functionality\n+    CScript script;\n+    script = ScriptFromHex(\"76a9141234567890abcdefa1a2a3a4a5a6a7a8a9a0aaab88ac\"); // Normal script\n+    BOOST_CHECK(script.HasValidOps());\n+    script = ScriptFromHex(\"76a914ff34567890abcdefa1a2a3a4a5a6a7a8a9a0aaab88ac\");\n+    BOOST_CHECK(script.HasValidOps());\n+    script = ScriptFromHex(\"ff88ac\"); // Script with OP_INVALIDOPCODE explicit\n+    BOOST_CHECK(!script.HasValidOps());\n+    script = ScriptFromHex(\"88acc0\"); // Script with undefined opcode\n+    BOOST_CHECK(!script.HasValidOps());\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "1ca83a7cf8726450856ab533ca279d2e9430cdfa",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 17,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -2,16 +2,15 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include \"consensus/tx_verify.h\"\n #include \"consensus/validation.h\"\n #include \"data/sighash.json.h\"\n #include \"hash.h\"\n-#include \"validation.h\" // For CheckTransaction\n #include \"script/interpreter.h\"\n #include \"script/script.h\"\n #include \"serialize.h\"\n #include \"streams.h\"\n #include \"test/test_bitcoin.h\"\n-#include \"test/test_random.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n #include \"version.h\"\n@@ -30,7 +29,6 @@ uint256 static SignatureHashOld(CScript scriptCode, const CTransaction& txTo, un\n     static const uint256 one(uint256S(\"0000000000000000000000000000000000000000000000000000000000000001\"));\n     if (nIn >= txTo.vin.size())\n     {\n-        printf(\"ERROR: SignatureHash(): nIn=%d out of range\\n\", nIn);\n         return one;\n     }\n     CMutableTransaction txTmp(txTo);\n@@ -61,7 +59,6 @@ uint256 static SignatureHashOld(CScript scriptCode, const CTransaction& txTo, un\n         unsigned int nOut = nIn;\n         if (nOut >= txTmp.vout.size())\n         {\n-            printf(\"ERROR: SignatureHash(): nOut=%d out of range\\n\", nOut);\n             return one;\n         }\n         txTmp.vout.resize(nOut+1);\n@@ -90,30 +87,30 @@ uint256 static SignatureHashOld(CScript scriptCode, const CTransaction& txTo, un\n void static RandomScript(CScript &script) {\n     static const opcodetype oplist[] = {OP_FALSE, OP_1, OP_2, OP_3, OP_CHECKSIG, OP_IF, OP_VERIF, OP_RETURN, OP_CODESEPARATOR};\n     script = CScript();\n-    int ops = (insecure_rand() % 10);\n+    int ops = (InsecureRandRange(10));\n     for (int i=0; i<ops; i++)\n-        script << oplist[insecure_rand() % (sizeof(oplist)/sizeof(oplist[0]))];\n+        script << oplist[InsecureRandRange(sizeof(oplist)/sizeof(oplist[0]))];\n }\n \n void static RandomTransaction(CMutableTransaction &tx, bool fSingle) {\n-    tx.nVersion = insecure_rand();\n+    tx.nVersion = InsecureRand32();\n     tx.vin.clear();\n     tx.vout.clear();\n-    tx.nLockTime = (insecure_rand() % 2) ? insecure_rand() : 0;\n-    int ins = (insecure_rand() % 4) + 1;\n-    int outs = fSingle ? ins : (insecure_rand() % 4) + 1;\n+    tx.nLockTime = (InsecureRandBool()) ? InsecureRand32() : 0;\n+    int ins = (InsecureRandBits(2)) + 1;\n+    int outs = fSingle ? ins : (InsecureRandBits(2)) + 1;\n     for (int in = 0; in < ins; in++) {\n         tx.vin.push_back(CTxIn());\n         CTxIn &txin = tx.vin.back();\n-        txin.prevout.hash = GetRandHash();\n-        txin.prevout.n = insecure_rand() % 4;\n+        txin.prevout.hash = InsecureRand256();\n+        txin.prevout.n = InsecureRandBits(2);\n         RandomScript(txin.scriptSig);\n-        txin.nSequence = (insecure_rand() % 2) ? insecure_rand() : (unsigned int)-1;\n+        txin.nSequence = (InsecureRandBool()) ? InsecureRand32() : (unsigned int)-1;\n     }\n     for (int out = 0; out < outs; out++) {\n         tx.vout.push_back(CTxOut());\n         CTxOut &txout = tx.vout.back();\n-        txout.nValue = insecure_rand() % 100000000;\n+        txout.nValue = InsecureRandRange(100000000);\n         RandomScript(txout.scriptPubKey);\n     }\n }\n@@ -122,7 +119,7 @@ BOOST_FIXTURE_TEST_SUITE(sighash_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(sighash_test)\n {\n-    seed_insecure_rand(false);\n+    SeedInsecureRand(false);\n \n     #if defined(PRINT_SIGHASH_JSON)\n     std::cout << \"[\\n\";\n@@ -134,12 +131,12 @@ BOOST_AUTO_TEST_CASE(sighash_test)\n     nRandomTests = 500;\n     #endif\n     for (int i=0; i<nRandomTests; i++) {\n-        int nHashType = insecure_rand();\n+        int nHashType = InsecureRand32();\n         CMutableTransaction txTo;\n         RandomTransaction(txTo, (nHashType & 0x1f) == SIGHASH_SINGLE);\n         CScript scriptCode;\n         RandomScript(scriptCode);\n-        int nIn = insecure_rand() % txTo.vin.size();\n+        int nIn = InsecureRandRange(txTo.vin.size());\n \n         uint256 sh, sho;\n         sho = SignatureHashOld(scriptCode, txTo, nIn, nHashType);"
      },
      {
        "sha": "4e117448fe2acd9e5abe3ebb0818213d40cadb86",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -2,7 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include \"validation.h\"\n+#include \"consensus/tx_verify.h\"\n #include \"pubkey.h\"\n #include \"key.h\"\n #include \"script/script.h\"\n@@ -102,7 +102,7 @@ void BuildTxs(CMutableTransaction& spendingTx, CCoinsViewCache& coins, CMutableT\n     spendingTx.vout[0].nValue = 1;\n     spendingTx.vout[0].scriptPubKey = CScript();\n \n-    coins.ModifyCoins(creationTx.GetHash())->FromTx(creationTx, 0);\n+    AddCoins(coins, creationTx, 0);\n }\n \n BOOST_AUTO_TEST_CASE(GetTxSigOpCost)"
      },
      {
        "sha": "77c321cdf65ca63a7e25adf884da238d4078e1c5",
        "filename": "src/test/skiplist_tests.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 6,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/skiplist_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/skiplist_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/skiplist_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -5,7 +5,6 @@\n #include \"chain.h\"\n #include \"util.h\"\n #include \"test/test_bitcoin.h\"\n-#include \"test/test_random.h\"\n \n #include <vector>\n \n@@ -35,8 +34,8 @@ BOOST_AUTO_TEST_CASE(skiplist_test)\n     }\n \n     for (int i=0; i < 1000; i++) {\n-        int from = insecure_rand() % (SKIPLIST_LENGTH - 1);\n-        int to = insecure_rand() % (from + 1);\n+        int from = InsecureRandRange(SKIPLIST_LENGTH - 1);\n+        int to = InsecureRandRange(from + 1);\n \n         BOOST_CHECK(vIndex[SKIPLIST_LENGTH - 1].GetAncestor(from) == &vIndex[from]);\n         BOOST_CHECK(vIndex[from].GetAncestor(to) == &vIndex[to]);\n@@ -78,7 +77,7 @@ BOOST_AUTO_TEST_CASE(getlocator_test)\n \n     // Test 100 random starting points for locators.\n     for (int n=0; n<100; n++) {\n-        int r = insecure_rand() % 150000;\n+        int r = InsecureRandRange(150000);\n         CBlockIndex* tip = (r < 100000) ? &vBlocksMain[r] : &vBlocksSide[r - 100000];\n         CBlockLocator locator = chain.GetLocator(tip);\n \n@@ -116,7 +115,7 @@ BOOST_AUTO_TEST_CASE(findearliestatleast_test)\n         } else {\n             // randomly choose something in the range [MTP, MTP*2]\n             int64_t medianTimePast = vBlocksMain[i].GetMedianTimePast();\n-            int r = insecure_rand() % medianTimePast;\n+            int r = InsecureRandRange(medianTimePast);\n             vBlocksMain[i].nTime = r + medianTimePast;\n             vBlocksMain[i].nTimeMax = std::max(vBlocksMain[i].nTime, vBlocksMain[i-1].nTimeMax);\n         }\n@@ -135,12 +134,47 @@ BOOST_AUTO_TEST_CASE(findearliestatleast_test)\n     // Verify that FindEarliestAtLeast is correct.\n     for (unsigned int i=0; i<10000; ++i) {\n         // Pick a random element in vBlocksMain.\n-        int r = insecure_rand() % vBlocksMain.size();\n+        int r = InsecureRandRange(vBlocksMain.size());\n         int64_t test_time = vBlocksMain[r].nTime;\n         CBlockIndex *ret = chain.FindEarliestAtLeast(test_time);\n         BOOST_CHECK(ret->nTimeMax >= test_time);\n         BOOST_CHECK((ret->pprev==NULL) || ret->pprev->nTimeMax < test_time);\n         BOOST_CHECK(vBlocksMain[r].GetAncestor(ret->nHeight) == ret);\n     }\n }\n+\n+BOOST_AUTO_TEST_CASE(findearliestatleast_edge_test)\n+{\n+    std::list<CBlockIndex> blocks;\n+    for (unsigned int timeMax : {100, 100, 100, 200, 200, 200, 300, 300, 300}) {\n+        CBlockIndex* prev = blocks.empty() ? nullptr : &blocks.back();\n+        blocks.emplace_back();\n+        blocks.back().nHeight = prev ? prev->nHeight + 1 : 0;\n+        blocks.back().pprev = prev;\n+        blocks.back().BuildSkip();\n+        blocks.back().nTimeMax = timeMax;\n+    }\n+\n+    CChain chain;\n+    chain.SetTip(&blocks.back());\n+\n+    BOOST_CHECK_EQUAL(chain.FindEarliestAtLeast(50)->nHeight, 0);\n+    BOOST_CHECK_EQUAL(chain.FindEarliestAtLeast(100)->nHeight, 0);\n+    BOOST_CHECK_EQUAL(chain.FindEarliestAtLeast(150)->nHeight, 3);\n+    BOOST_CHECK_EQUAL(chain.FindEarliestAtLeast(200)->nHeight, 3);\n+    BOOST_CHECK_EQUAL(chain.FindEarliestAtLeast(250)->nHeight, 6);\n+    BOOST_CHECK_EQUAL(chain.FindEarliestAtLeast(300)->nHeight, 6);\n+    BOOST_CHECK(!chain.FindEarliestAtLeast(350));\n+\n+    BOOST_CHECK_EQUAL(chain.FindEarliestAtLeast(0)->nHeight, 0);\n+    BOOST_CHECK_EQUAL(chain.FindEarliestAtLeast(-1)->nHeight, 0);\n+\n+    BOOST_CHECK_EQUAL(chain.FindEarliestAtLeast(std::numeric_limits<int64_t>::min())->nHeight, 0);\n+    BOOST_CHECK_EQUAL(chain.FindEarliestAtLeast(std::numeric_limits<unsigned int>::min())->nHeight, 0);\n+    BOOST_CHECK_EQUAL(chain.FindEarliestAtLeast(-int64_t(std::numeric_limits<unsigned int>::max()) - 1)->nHeight, 0);\n+    BOOST_CHECK(!chain.FindEarliestAtLeast(std::numeric_limits<int64_t>::max()));\n+    BOOST_CHECK(!chain.FindEarliestAtLeast(std::numeric_limits<unsigned int>::max()));\n+    BOOST_CHECK(!chain.FindEarliestAtLeast(int64_t(std::numeric_limits<unsigned int>::max()) + 1));\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "c1aea1680add3391411fd4669713a7d00857df07",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -7,6 +7,7 @@\n #include \"chainparams.h\"\n #include \"consensus/consensus.h\"\n #include \"consensus/validation.h\"\n+#include \"fs.h\"\n #include \"key.h\"\n #include \"validation.h\"\n #include \"miner.h\"\n@@ -24,10 +25,10 @@\n \n #include <memory>\n \n-#include <boost/filesystem.hpp>\n #include <boost/thread.hpp>\n \n-FastRandomContext insecure_rand_ctx(true);\n+uint256 insecure_rand_seed = GetRandHash();\n+FastRandomContext insecure_rand_ctx(insecure_rand_seed);\n \n extern bool fPrintToConsole;\n extern void noui_connect();\n@@ -58,8 +59,8 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n \n         RegisterAllCoreRPCCommands(tableRPC);\n         ClearDatadirCache();\n-        pathTemp = GetTempPath() / strprintf(\"test_bitcoin_%lu_%i\", (unsigned long)GetTime(), (int)(GetRand(100000)));\n-        boost::filesystem::create_directories(pathTemp);\n+        pathTemp = GetTempPath() / strprintf(\"test_bitcoin_%lu_%i\", (unsigned long)GetTime(), (int)(InsecureRandRange(100000)));\n+        fs::create_directories(pathTemp);\n         ForceSetArg(\"-datadir\", pathTemp.string());\n         mempool.setSanityCheck(1.0);\n         pblocktree = new CBlockTreeDB(1 << 20, true);\n@@ -91,7 +92,7 @@ TestingSetup::~TestingSetup()\n         delete pcoinsTip;\n         delete pcoinsdbview;\n         delete pblocktree;\n-        boost::filesystem::remove_all(pathTemp);\n+        fs::remove_all(pathTemp);\n }\n \n TestChain100Setup::TestChain100Setup() : TestingSetup(CBaseChainParams::REGTEST)"
      },
      {
        "sha": "0087eeb2d7bd1b6527748eb11e452e2c2b41e75e",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 23,
        "deletions": 2,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -6,14 +6,35 @@\n #define BITCOIN_TEST_TEST_BITCOIN_H\n \n #include \"chainparamsbase.h\"\n+#include \"fs.h\"\n #include \"key.h\"\n #include \"pubkey.h\"\n+#include \"random.h\"\n #include \"txdb.h\"\n #include \"txmempool.h\"\n \n-#include <boost/filesystem.hpp>\n #include <boost/thread.hpp>\n \n+extern uint256 insecure_rand_seed;\n+extern FastRandomContext insecure_rand_ctx;\n+\n+static inline void SeedInsecureRand(bool fDeterministic = false)\n+{\n+    if (fDeterministic) {\n+        insecure_rand_seed = uint256();\n+    } else {\n+        insecure_rand_seed = GetRandHash();\n+    }\n+    insecure_rand_ctx = FastRandomContext(insecure_rand_seed);\n+}\n+\n+static inline uint32_t InsecureRand32() { return insecure_rand_ctx.rand32(); }\n+static inline uint256 InsecureRand256() { return insecure_rand_ctx.rand256(); }\n+static inline uint64_t InsecureRandBits(int bits) { return insecure_rand_ctx.randbits(bits); }\n+static inline uint64_t InsecureRandRange(uint64_t range) { return insecure_rand_ctx.randrange(range); }\n+static inline bool InsecureRandBool() { return insecure_rand_ctx.randbool(); }\n+static inline std::vector<unsigned char> InsecureRandBytes(size_t len) { return insecure_rand_ctx.randbytes(len); }\n+\n /** Basic testing setup.\n  * This just configures logging and chain parameters.\n  */\n@@ -30,7 +51,7 @@ struct BasicTestingSetup {\n class CConnman;\n struct TestingSetup: public BasicTestingSetup {\n     CCoinsViewDB *pcoinsdbview;\n-    boost::filesystem::path pathTemp;\n+    fs::path pathTemp;\n     boost::thread_group threadGroup;\n     CConnman* connman;\n "
      },
      {
        "sha": "de14251601377956cb368634d22f48f54a5a1832",
        "filename": "src/test/test_bitcoin_fuzzy.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 4,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/test_bitcoin_fuzzy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/test_bitcoin_fuzzy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin_fuzzy.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -59,9 +59,8 @@ bool read_stdin(std::vector<char> &data) {\n     return length==0;\n }\n \n-int main(int argc, char **argv)\n+int do_fuzz()\n {\n-    ECCVerifyHandle globalVerifyHandle;\n     std::vector<char> buffer;\n     if (!read_stdin(buffer)) return 0;\n \n@@ -169,8 +168,8 @@ int main(int argc, char **argv)\n         {\n             try\n             {\n-                CCoins block;\n-                ds >> block;\n+                Coin coin;\n+                ds >> coin;\n             } catch (const std::ios_base::failure& e) {return 0;}\n             break;\n         }\n@@ -256,3 +255,23 @@ int main(int argc, char **argv)\n     return 0;\n }\n \n+int main(int argc, char **argv)\n+{\n+    ECCVerifyHandle globalVerifyHandle;\n+#ifdef __AFL_INIT\n+    // Enable AFL deferred forkserver mode. Requires compilation using\n+    // afl-clang-fast++. See fuzzing.md for details.\n+    __AFL_INIT();\n+#endif\n+\n+#ifdef __AFL_LOOP\n+    // Enable AFL persistent mode. Requires compilation using afl-clang-fast++.\n+    // See fuzzing.md for details.\n+    while (__AFL_LOOP(1000)) {\n+        do_fuzz();\n+    }\n+    return 0;\n+#else\n+    return do_fuzz();\n+#endif\n+}"
      },
      {
        "sha": "4a1637ac7249171a429c3a890540269fdbbccaf3",
        "filename": "src/test/test_random.h",
        "status": "removed",
        "additions": 0,
        "deletions": 23,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3192e5278abca7c1f3b4a2a7f77a0ce941c73985/src/test/test_random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3192e5278abca7c1f3b4a2a7f77a0ce941c73985/src/test/test_random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_random.h?ref=3192e5278abca7c1f3b4a2a7f77a0ce941c73985",
        "patch": "@@ -1,23 +0,0 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_TEST_RANDOM_H\n-#define BITCOIN_TEST_RANDOM_H\n-\n-#include \"random.h\"\n-\n-extern FastRandomContext insecure_rand_ctx;\n-\n-static inline void seed_insecure_rand(bool fDeterministic = false)\n-{\n-    insecure_rand_ctx = FastRandomContext(fDeterministic);\n-}\n-\n-static inline uint32_t insecure_rand(void)\n-{\n-    return insecure_rand_ctx.rand32();\n-}\n-\n-#endif"
      },
      {
        "sha": "591d0bf30271240f9184ed472d04ab6c6096c851",
        "filename": "src/test/testutil.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/testutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/testutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/testutil.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -8,8 +8,8 @@\n #include <shlobj.h>\n #endif\n \n-#include <boost/filesystem.hpp>\n+#include \"fs.h\"\n \n-boost::filesystem::path GetTempPath() {\n-    return boost::filesystem::temp_directory_path();\n+fs::path GetTempPath() {\n+    return fs::temp_directory_path();\n }"
      },
      {
        "sha": "cbe784d6400b9dd4cc4339ae6803f9c1d2bb13fd",
        "filename": "src/test/testutil.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/testutil.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/testutil.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/testutil.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -8,8 +8,8 @@\n #ifndef BITCOIN_TEST_TESTUTIL_H\n #define BITCOIN_TEST_TESTUTIL_H\n \n-#include <boost/filesystem/path.hpp>\n+#include \"fs.h\"\n \n-boost::filesystem::path GetTempPath();\n+fs::path GetTempPath();\n \n #endif // BITCOIN_TEST_TESTUTIL_H"
      },
      {
        "sha": "b7affaacde585dae3c395359ecc30364ea88a40f",
        "filename": "src/test/torcontrol_tests.cpp",
        "status": "added",
        "additions": 199,
        "deletions": 0,
        "changes": 199,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/torcontrol_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/torcontrol_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/torcontrol_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2017 The Zcash developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+//\n+#include \"test/test_bitcoin.h\"\n+#include \"torcontrol.cpp\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+\n+BOOST_FIXTURE_TEST_SUITE(torcontrol_tests, BasicTestingSetup)\n+\n+void CheckSplitTorReplyLine(std::string input, std::string command, std::string args)\n+{\n+    BOOST_TEST_MESSAGE(std::string(\"CheckSplitTorReplyLine(\") + input + \")\");\n+    auto ret = SplitTorReplyLine(input);\n+    BOOST_CHECK_EQUAL(ret.first, command);\n+    BOOST_CHECK_EQUAL(ret.second, args);\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_SplitTorReplyLine)\n+{\n+    // Data we should receive during normal usage\n+    CheckSplitTorReplyLine(\n+        \"PROTOCOLINFO PIVERSION\",\n+        \"PROTOCOLINFO\", \"PIVERSION\");\n+    CheckSplitTorReplyLine(\n+        \"AUTH METHODS=COOKIE,SAFECOOKIE COOKIEFILE=\\\"/home/x/.tor/control_auth_cookie\\\"\",\n+        \"AUTH\", \"METHODS=COOKIE,SAFECOOKIE COOKIEFILE=\\\"/home/x/.tor/control_auth_cookie\\\"\");\n+    CheckSplitTorReplyLine(\n+        \"AUTH METHODS=NULL\",\n+        \"AUTH\", \"METHODS=NULL\");\n+    CheckSplitTorReplyLine(\n+        \"AUTH METHODS=HASHEDPASSWORD\",\n+        \"AUTH\", \"METHODS=HASHEDPASSWORD\");\n+    CheckSplitTorReplyLine(\n+        \"VERSION Tor=\\\"0.2.9.8 (git-a0df013ea241b026)\\\"\",\n+        \"VERSION\", \"Tor=\\\"0.2.9.8 (git-a0df013ea241b026)\\\"\");\n+    CheckSplitTorReplyLine(\n+        \"AUTHCHALLENGE SERVERHASH=aaaa SERVERNONCE=bbbb\",\n+        \"AUTHCHALLENGE\", \"SERVERHASH=aaaa SERVERNONCE=bbbb\");\n+\n+    // Other valid inputs\n+    CheckSplitTorReplyLine(\"COMMAND\", \"COMMAND\", \"\");\n+    CheckSplitTorReplyLine(\"COMMAND SOME  ARGS\", \"COMMAND\", \"SOME  ARGS\");\n+\n+    // These inputs are valid because PROTOCOLINFO accepts an OtherLine that is\n+    // just an OptArguments, which enables multiple spaces to be present\n+    // between the command and arguments.\n+    CheckSplitTorReplyLine(\"COMMAND  ARGS\", \"COMMAND\", \" ARGS\");\n+    CheckSplitTorReplyLine(\"COMMAND   EVEN+more  ARGS\", \"COMMAND\", \"  EVEN+more  ARGS\");\n+}\n+\n+void CheckParseTorReplyMapping(std::string input, std::map<std::string,std::string> expected)\n+{\n+    BOOST_TEST_MESSAGE(std::string(\"CheckParseTorReplyMapping(\") + input + \")\");\n+    auto ret = ParseTorReplyMapping(input);\n+    BOOST_CHECK_EQUAL(ret.size(), expected.size());\n+    auto r_it = ret.begin();\n+    auto e_it = expected.begin();\n+    while (r_it != ret.end() && e_it != expected.end()) {\n+        BOOST_CHECK_EQUAL(r_it->first, e_it->first);\n+        BOOST_CHECK_EQUAL(r_it->second, e_it->second);\n+        r_it++;\n+        e_it++;\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(util_ParseTorReplyMapping)\n+{\n+    // Data we should receive during normal usage\n+    CheckParseTorReplyMapping(\n+        \"METHODS=COOKIE,SAFECOOKIE COOKIEFILE=\\\"/home/x/.tor/control_auth_cookie\\\"\", {\n+            {\"METHODS\", \"COOKIE,SAFECOOKIE\"},\n+            {\"COOKIEFILE\", \"/home/x/.tor/control_auth_cookie\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"METHODS=NULL\", {\n+            {\"METHODS\", \"NULL\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"METHODS=HASHEDPASSWORD\", {\n+            {\"METHODS\", \"HASHEDPASSWORD\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Tor=\\\"0.2.9.8 (git-a0df013ea241b026)\\\"\", {\n+            {\"Tor\", \"0.2.9.8 (git-a0df013ea241b026)\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"SERVERHASH=aaaa SERVERNONCE=bbbb\", {\n+            {\"SERVERHASH\", \"aaaa\"},\n+            {\"SERVERNONCE\", \"bbbb\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"ServiceID=exampleonion1234\", {\n+            {\"ServiceID\", \"exampleonion1234\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"PrivateKey=RSA1024:BLOB\", {\n+            {\"PrivateKey\", \"RSA1024:BLOB\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"ClientAuth=bob:BLOB\", {\n+            {\"ClientAuth\", \"bob:BLOB\"},\n+        });\n+\n+    // Other valid inputs\n+    CheckParseTorReplyMapping(\n+        \"Foo=Bar=Baz Spam=Eggs\", {\n+            {\"Foo\", \"Bar=Baz\"},\n+            {\"Spam\", \"Eggs\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar=Baz\\\"\", {\n+            {\"Foo\", \"Bar=Baz\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar Baz\\\"\", {\n+            {\"Foo\", \"Bar Baz\"},\n+        });\n+\n+    // Escapes\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar\\\\ Baz\\\"\", {\n+            {\"Foo\", \"Bar Baz\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar\\\\Baz\\\"\", {\n+            {\"Foo\", \"BarBaz\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar\\\\@Baz\\\"\", {\n+            {\"Foo\", \"Bar@Baz\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar\\\\\\\"Baz\\\" Spam=\\\"\\\\\\\"Eggs\\\\\\\"\\\"\", {\n+            {\"Foo\", \"Bar\\\"Baz\"},\n+            {\"Spam\", \"\\\"Eggs\\\"\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar\\\\\\\\Baz\\\"\", {\n+            {\"Foo\", \"Bar\\\\Baz\"},\n+        });\n+\n+    // C escapes\n+    CheckParseTorReplyMapping(\n+        \"Foo=\\\"Bar\\\\nBaz\\\\t\\\" Spam=\\\"\\\\rEggs\\\" Octals=\\\"\\\\1a\\\\11\\\\17\\\\18\\\\81\\\\377\\\\378\\\\400\\\\2222\\\" Final=Check\", {\n+            {\"Foo\", \"Bar\\nBaz\\t\"},\n+            {\"Spam\", \"\\rEggs\"},\n+            {\"Octals\", \"\\1a\\11\\17\\1\" \"881\\377\\37\" \"8\\40\" \"0\\222\" \"2\"},\n+            {\"Final\", \"Check\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Valid=Mapping Escaped=\\\"Escape\\\\\\\\\\\"\", {\n+            {\"Valid\", \"Mapping\"},\n+            {\"Escaped\", \"Escape\\\\\"},\n+        });\n+    CheckParseTorReplyMapping(\n+        \"Valid=Mapping Bare=\\\"Escape\\\\\\\"\", {});\n+    CheckParseTorReplyMapping(\n+        \"OneOctal=\\\"OneEnd\\\\1\\\" TwoOctal=\\\"TwoEnd\\\\11\\\"\", {\n+            {\"OneOctal\", \"OneEnd\\1\"},\n+            {\"TwoOctal\", \"TwoEnd\\11\"},\n+        });\n+\n+    // Special handling for null case\n+    // (needed because string comparison reads the null as end-of-string)\n+    BOOST_TEST_MESSAGE(std::string(\"CheckParseTorReplyMapping(Null=\\\"\\\\0\\\")\"));\n+    auto ret = ParseTorReplyMapping(\"Null=\\\"\\\\0\\\"\");\n+    BOOST_CHECK_EQUAL(ret.size(), 1);\n+    auto r_it = ret.begin();\n+    BOOST_CHECK_EQUAL(r_it->first, \"Null\");\n+    BOOST_CHECK_EQUAL(r_it->second.size(), 1);\n+    BOOST_CHECK_EQUAL(r_it->second[0], '\\0');\n+\n+    // A more complex valid grammar. PROTOCOLINFO accepts a VersionLine that\n+    // takes a key=value pair followed by an OptArguments, making this valid.\n+    // Because an OptArguments contains no semantic data, there is no point in\n+    // parsing it.\n+    CheckParseTorReplyMapping(\n+        \"SOME=args,here MORE optional=arguments  here\", {\n+            {\"SOME\", \"args,here\"},\n+        });\n+\n+    // Inputs that are effectively invalid under the target grammar.\n+    // PROTOCOLINFO accepts an OtherLine that is just an OptArguments, which\n+    // would make these inputs valid. However,\n+    // - This parser is never used in that situation, because the\n+    //   SplitTorReplyLine parser enables OtherLine to be skipped.\n+    // - Even if these were valid, an OptArguments contains no semantic data,\n+    //   so there is no point in parsing it.\n+    CheckParseTorReplyMapping(\"ARGS\", {});\n+    CheckParseTorReplyMapping(\"MORE ARGS\", {});\n+    CheckParseTorReplyMapping(\"MORE  ARGS\", {});\n+    CheckParseTorReplyMapping(\"EVEN more=ARGS\", {});\n+    CheckParseTorReplyMapping(\"EVEN+more ARGS\", {});\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "e146bb238c4253598ea59de287a5aaeec06a5aac",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 31,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -8,11 +8,12 @@\n \n #include \"clientversion.h\"\n #include \"checkqueue.h\"\n+#include \"consensus/tx_verify.h\"\n #include \"consensus/validation.h\"\n #include \"core_io.h\"\n #include \"key.h\"\n #include \"keystore.h\"\n-#include \"validation.h\" // For CheckTransaction\n+#include \"validation.h\"\n #include \"policy/policy.h\"\n #include \"script/script.h\"\n #include \"script/sign.h\"\n@@ -25,9 +26,7 @@\n \n #include <boost/algorithm/string/classification.hpp>\n #include <boost/algorithm/string/split.hpp>\n-#include <boost/assign/list_of.hpp>\n #include <boost/test/unit_test.hpp>\n-#include <boost/assign/list_of.hpp>\n #include <boost/foreach.hpp>\n \n #include <univalue.h>\n@@ -37,24 +36,25 @@ typedef std::vector<unsigned char> valtype;\n // In script_tests.cpp\n extern UniValue read_json(const std::string& jsondata);\n \n-static std::map<std::string, unsigned int> mapFlagNames = boost::assign::map_list_of\n-    (std::string(\"NONE\"), (unsigned int)SCRIPT_VERIFY_NONE)\n-    (std::string(\"P2SH\"), (unsigned int)SCRIPT_VERIFY_P2SH)\n-    (std::string(\"STRICTENC\"), (unsigned int)SCRIPT_VERIFY_STRICTENC)\n-    (std::string(\"DERSIG\"), (unsigned int)SCRIPT_VERIFY_DERSIG)\n-    (std::string(\"LOW_S\"), (unsigned int)SCRIPT_VERIFY_LOW_S)\n-    (std::string(\"SIGPUSHONLY\"), (unsigned int)SCRIPT_VERIFY_SIGPUSHONLY)\n-    (std::string(\"MINIMALDATA\"), (unsigned int)SCRIPT_VERIFY_MINIMALDATA)\n-    (std::string(\"NULLDUMMY\"), (unsigned int)SCRIPT_VERIFY_NULLDUMMY)\n-    (std::string(\"DISCOURAGE_UPGRADABLE_NOPS\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS)\n-    (std::string(\"CLEANSTACK\"), (unsigned int)SCRIPT_VERIFY_CLEANSTACK)\n-    (std::string(\"MINIMALIF\"), (unsigned int)SCRIPT_VERIFY_MINIMALIF)\n-    (std::string(\"NULLFAIL\"), (unsigned int)SCRIPT_VERIFY_NULLFAIL)\n-    (std::string(\"CHECKLOCKTIMEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY)\n-    (std::string(\"CHECKSEQUENCEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY)\n-    (std::string(\"WITNESS\"), (unsigned int)SCRIPT_VERIFY_WITNESS)\n-    (std::string(\"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM)\n-    (std::string(\"WITNESS_PUBKEYTYPE\"), (unsigned int)SCRIPT_VERIFY_WITNESS_PUBKEYTYPE);\n+static std::map<std::string, unsigned int> mapFlagNames = {\n+    {std::string(\"NONE\"), (unsigned int)SCRIPT_VERIFY_NONE},\n+    {std::string(\"P2SH\"), (unsigned int)SCRIPT_VERIFY_P2SH},\n+    {std::string(\"STRICTENC\"), (unsigned int)SCRIPT_VERIFY_STRICTENC},\n+    {std::string(\"DERSIG\"), (unsigned int)SCRIPT_VERIFY_DERSIG},\n+    {std::string(\"LOW_S\"), (unsigned int)SCRIPT_VERIFY_LOW_S},\n+    {std::string(\"SIGPUSHONLY\"), (unsigned int)SCRIPT_VERIFY_SIGPUSHONLY},\n+    {std::string(\"MINIMALDATA\"), (unsigned int)SCRIPT_VERIFY_MINIMALDATA},\n+    {std::string(\"NULLDUMMY\"), (unsigned int)SCRIPT_VERIFY_NULLDUMMY},\n+    {std::string(\"DISCOURAGE_UPGRADABLE_NOPS\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS},\n+    {std::string(\"CLEANSTACK\"), (unsigned int)SCRIPT_VERIFY_CLEANSTACK},\n+    {std::string(\"MINIMALIF\"), (unsigned int)SCRIPT_VERIFY_MINIMALIF},\n+    {std::string(\"NULLFAIL\"), (unsigned int)SCRIPT_VERIFY_NULLFAIL},\n+    {std::string(\"CHECKLOCKTIMEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY},\n+    {std::string(\"CHECKSEQUENCEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY},\n+    {std::string(\"WITNESS\"), (unsigned int)SCRIPT_VERIFY_WITNESS},\n+    {std::string(\"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM},\n+    {std::string(\"WITNESS_PUBKEYTYPE\"), (unsigned int)SCRIPT_VERIFY_WITNESS_PUBKEYTYPE},\n+};\n \n unsigned int ParseScriptFlags(std::string strFlags)\n {\n@@ -306,14 +306,14 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n     dummyTransactions[0].vout[0].scriptPubKey << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n     dummyTransactions[0].vout[1].nValue = 50*CENT;\n     dummyTransactions[0].vout[1].scriptPubKey << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\n-    coinsRet.ModifyCoins(dummyTransactions[0].GetHash())->FromTx(dummyTransactions[0], 0);\n+    AddCoins(coinsRet, dummyTransactions[0], 0);\n \n     dummyTransactions[1].vout.resize(2);\n     dummyTransactions[1].vout[0].nValue = 21*CENT;\n     dummyTransactions[1].vout[0].scriptPubKey = GetScriptForDestination(key[2].GetPubKey().GetID());\n     dummyTransactions[1].vout[1].nValue = 22*CENT;\n     dummyTransactions[1].vout[1].scriptPubKey = GetScriptForDestination(key[3].GetPubKey().GetID());\n-    coinsRet.ModifyCoins(dummyTransactions[1].GetHash())->FromTx(dummyTransactions[1], 0);\n+    AddCoins(coinsRet, dummyTransactions[1], 0);\n \n     return dummyTransactions;\n }\n@@ -469,19 +469,20 @@ BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n     for (int i=0; i<20; i++)\n         threadGroup.create_thread(boost::bind(&CCheckQueue<CScriptCheck>::Thread, boost::ref(scriptcheckqueue)));\n \n-    CCoins coins;\n-    coins.nVersion = 1;\n-    coins.fCoinBase = false;\n+    std::vector<Coin> coins;\n     for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n-        CTxOut txout;\n-        txout.nValue = 1000;\n-        txout.scriptPubKey = scriptPubKey;\n-        coins.vout.push_back(txout);\n+        Coin coin;\n+        coin.nHeight = 1;\n+        coin.fCoinBase = false;\n+        coin.out.nValue = 1000;\n+        coin.out.scriptPubKey = scriptPubKey;\n+        coins.emplace_back(std::move(coin));\n     }\n \n     for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n         std::vector<CScriptCheck> vChecks;\n-        CScriptCheck check(coins, tx, i, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false, &txdata);\n+        const CTxOut& output = coins[tx.vin[i].prevout.n].out;\n+        CScriptCheck check(output.scriptPubKey, output.nValue, tx, i, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false, &txdata);\n         vChecks.push_back(CScriptCheck());\n         check.swap(vChecks.back());\n         control.Add(vChecks);"
      },
      {
        "sha": "5e9dfb730bbb94e51b2623b7f06afe2d3b3326bb",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 36,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -10,15 +10,12 @@\n #include \"utilstrencodings.h\"\n #include \"utilmoneystr.h\"\n #include \"test/test_bitcoin.h\"\n-#include \"test/test_random.h\"\n \n #include <stdint.h>\n #include <vector>\n \n #include <boost/test/unit_test.hpp>\n \n-extern std::map<std::string, std::string> mapArgs;\n-\n BOOST_FIXTURE_TEST_SUITE(util_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(util_criticalsection)\n@@ -100,52 +97,67 @@ BOOST_AUTO_TEST_CASE(util_DateTimeStrFormat)\n     BOOST_CHECK_EQUAL(DateTimeStrFormat(\"%a, %d %b %Y %H:%M:%S +0000\", 1317425777), \"Fri, 30 Sep 2011 23:36:17 +0000\");\n }\n \n+class TestArgsManager : public ArgsManager\n+{\n+public:\n+    std::map<std::string, std::string>& GetMapArgs()\n+    {\n+        return mapArgs;\n+    };\n+    const std::map<std::string, std::vector<std::string> >& GetMapMultiArgs()\n+    {\n+        return mapMultiArgs;\n+    };\n+};\n+\n BOOST_AUTO_TEST_CASE(util_ParseParameters)\n {\n+    TestArgsManager testArgs;\n     const char *argv_test[] = {\"-ignored\", \"-a\", \"-b\", \"-ccc=argument\", \"-ccc=multiple\", \"f\", \"-d=e\"};\n \n-    ParseParameters(0, (char**)argv_test);\n-    BOOST_CHECK(mapArgs.empty() && mapMultiArgs.empty());\n+    testArgs.ParseParameters(0, (char**)argv_test);\n+    BOOST_CHECK(testArgs.GetMapArgs().empty() && testArgs.GetMapMultiArgs().empty());\n \n-    ParseParameters(1, (char**)argv_test);\n-    BOOST_CHECK(mapArgs.empty() && mapMultiArgs.empty());\n+    testArgs.ParseParameters(1, (char**)argv_test);\n+    BOOST_CHECK(testArgs.GetMapArgs().empty() && testArgs.GetMapMultiArgs().empty());\n \n-    ParseParameters(5, (char**)argv_test);\n+    testArgs.ParseParameters(5, (char**)argv_test);\n     // expectation: -ignored is ignored (program name argument),\n     // -a, -b and -ccc end up in map, -d ignored because it is after\n     // a non-option argument (non-GNU option parsing)\n-    BOOST_CHECK(mapArgs.size() == 3 && mapMultiArgs.size() == 3);\n-    BOOST_CHECK(IsArgSet(\"-a\") && IsArgSet(\"-b\") && IsArgSet(\"-ccc\")\n-                && !IsArgSet(\"f\") && !IsArgSet(\"-d\"));\n-    BOOST_CHECK(mapMultiArgs.count(\"-a\") && mapMultiArgs.count(\"-b\") && mapMultiArgs.count(\"-ccc\")\n-                && !mapMultiArgs.count(\"f\") && !mapMultiArgs.count(\"-d\"));\n-\n-    BOOST_CHECK(mapArgs[\"-a\"] == \"\" && mapArgs[\"-ccc\"] == \"multiple\");\n-    BOOST_CHECK(mapMultiArgs.at(\"-ccc\").size() == 2);\n+    BOOST_CHECK(testArgs.GetMapArgs().size() == 3 && testArgs.GetMapMultiArgs().size() == 3);\n+    BOOST_CHECK(testArgs.IsArgSet(\"-a\") && testArgs.IsArgSet(\"-b\") && testArgs.IsArgSet(\"-ccc\")\n+                && !testArgs.IsArgSet(\"f\") && !testArgs.IsArgSet(\"-d\"));\n+    BOOST_CHECK(testArgs.GetMapMultiArgs().count(\"-a\") && testArgs.GetMapMultiArgs().count(\"-b\") && testArgs.GetMapMultiArgs().count(\"-ccc\")\n+                && !testArgs.GetMapMultiArgs().count(\"f\") && !testArgs.GetMapMultiArgs().count(\"-d\"));\n+\n+    BOOST_CHECK(testArgs.GetMapArgs()[\"-a\"] == \"\" && testArgs.GetMapArgs()[\"-ccc\"] == \"multiple\");\n+    BOOST_CHECK(testArgs.GetArgs(\"-ccc\").size() == 2);\n }\n \n BOOST_AUTO_TEST_CASE(util_GetArg)\n {\n-    mapArgs.clear();\n-    mapArgs[\"strtest1\"] = \"string...\";\n+    TestArgsManager testArgs;\n+    testArgs.GetMapArgs().clear();\n+    testArgs.GetMapArgs()[\"strtest1\"] = \"string...\";\n     // strtest2 undefined on purpose\n-    mapArgs[\"inttest1\"] = \"12345\";\n-    mapArgs[\"inttest2\"] = \"81985529216486895\";\n+    testArgs.GetMapArgs()[\"inttest1\"] = \"12345\";\n+    testArgs.GetMapArgs()[\"inttest2\"] = \"81985529216486895\";\n     // inttest3 undefined on purpose\n-    mapArgs[\"booltest1\"] = \"\";\n+    testArgs.GetMapArgs()[\"booltest1\"] = \"\";\n     // booltest2 undefined on purpose\n-    mapArgs[\"booltest3\"] = \"0\";\n-    mapArgs[\"booltest4\"] = \"1\";\n-\n-    BOOST_CHECK_EQUAL(GetArg(\"strtest1\", \"default\"), \"string...\");\n-    BOOST_CHECK_EQUAL(GetArg(\"strtest2\", \"default\"), \"default\");\n-    BOOST_CHECK_EQUAL(GetArg(\"inttest1\", -1), 12345);\n-    BOOST_CHECK_EQUAL(GetArg(\"inttest2\", -1), 81985529216486895LL);\n-    BOOST_CHECK_EQUAL(GetArg(\"inttest3\", -1), -1);\n-    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest1\", false), true);\n-    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest2\", false), false);\n-    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest3\", false), false);\n-    BOOST_CHECK_EQUAL(GetBoolArg(\"booltest4\", false), true);\n+    testArgs.GetMapArgs()[\"booltest3\"] = \"0\";\n+    testArgs.GetMapArgs()[\"booltest4\"] = \"1\";\n+\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"strtest1\", \"default\"), \"string...\");\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"strtest2\", \"default\"), \"default\");\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"inttest1\", -1), 12345);\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"inttest2\", -1), 81985529216486895LL);\n+    BOOST_CHECK_EQUAL(testArgs.GetArg(\"inttest3\", -1), -1);\n+    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest1\", false), true);\n+    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest2\", false), false);\n+    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest3\", false), false);\n+    BOOST_CHECK_EQUAL(testArgs.GetBoolArg(\"booltest4\", false), true);\n }\n \n BOOST_AUTO_TEST_CASE(util_FormatMoney)\n@@ -243,11 +255,11 @@ BOOST_AUTO_TEST_CASE(util_IsHex)\n \n BOOST_AUTO_TEST_CASE(util_seed_insecure_rand)\n {\n-    seed_insecure_rand(true);\n+    SeedInsecureRand(true);\n     for (int mod=2;mod<11;mod++)\n     {\n         int mask = 1;\n-        // Really rough binomal confidence approximation.\n+        // Really rough binomial confidence approximation.\n         int err = 30*10000./mod*sqrt((1./mod*(1-1./mod))/10000.);\n         //mask is 2^ceil(log2(mod))-1\n         while(mask<mod-1)mask=(mask<<1)+1;\n@@ -257,7 +269,7 @@ BOOST_AUTO_TEST_CASE(util_seed_insecure_rand)\n         for (int i = 0; i < 10000; i++) {\n             uint32_t rval;\n             do{\n-                rval=insecure_rand()&mask;\n+                rval=InsecureRand32()&mask;\n             }while(rval>=(uint32_t)mod);\n             count += rval==0;\n         }"
      },
      {
        "sha": "faa2383d148750234883216cac67d2dbb6506a80",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -5,7 +5,6 @@\n #include \"chain.h\"\n #include \"versionbits.h\"\n #include \"test/test_bitcoin.h\"\n-#include \"test/test_random.h\"\n #include \"chainparams.h\"\n #include \"validation.h\"\n #include \"consensus/params.h\"\n@@ -81,7 +80,7 @@ class VersionBitsTester\n \n     VersionBitsTester& TestStateSinceHeight(int height) {\n         for (int i = 0; i < CHECKERS; i++) {\n-            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+            if (InsecureRandBits(i) == 0) {\n                 BOOST_CHECK_MESSAGE(checker[i].GetStateSinceHeightFor(vpblock.empty() ? NULL : vpblock.back()) == height, strprintf(\"Test %i for StateSinceHeight\", num));\n             }\n         }\n@@ -91,7 +90,7 @@ class VersionBitsTester\n \n     VersionBitsTester& TestDefined() {\n         for (int i = 0; i < CHECKERS; i++) {\n-            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+            if (InsecureRandBits(i) == 0) {\n                 BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_DEFINED, strprintf(\"Test %i for DEFINED\", num));\n             }\n         }\n@@ -101,7 +100,7 @@ class VersionBitsTester\n \n     VersionBitsTester& TestStarted() {\n         for (int i = 0; i < CHECKERS; i++) {\n-            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+            if (InsecureRandBits(i) == 0) {\n                 BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_STARTED, strprintf(\"Test %i for STARTED\", num));\n             }\n         }\n@@ -111,7 +110,7 @@ class VersionBitsTester\n \n     VersionBitsTester& TestLockedIn() {\n         for (int i = 0; i < CHECKERS; i++) {\n-            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+            if (InsecureRandBits(i) == 0) {\n                 BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_LOCKED_IN, strprintf(\"Test %i for LOCKED_IN\", num));\n             }\n         }\n@@ -121,7 +120,7 @@ class VersionBitsTester\n \n     VersionBitsTester& TestActive() {\n         for (int i = 0; i < CHECKERS; i++) {\n-            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+            if (InsecureRandBits(i) == 0) {\n                 BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_ACTIVE, strprintf(\"Test %i for ACTIVE\", num));\n             }\n         }\n@@ -131,7 +130,7 @@ class VersionBitsTester\n \n     VersionBitsTester& TestFailed() {\n         for (int i = 0; i < CHECKERS; i++) {\n-            if ((insecure_rand() & ((1 << i) - 1)) == 0) {\n+            if (InsecureRandBits(i) == 0) {\n                 BOOST_CHECK_MESSAGE(checker[i].GetStateFor(vpblock.empty() ? NULL : vpblock.back()) == THRESHOLD_FAILED, strprintf(\"Test %i for FAILED\", num));\n             }\n         }\n@@ -209,7 +208,8 @@ BOOST_AUTO_TEST_CASE(versionbits_test)\n     }\n \n     // Sanity checks of version bit deployments\n-    const Consensus::Params &mainnetParams = Params(CBaseChainParams::MAIN).GetConsensus();\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n+    const Consensus::Params &mainnetParams = chainParams->GetConsensus();\n     for (int i=0; i<(int) Consensus::MAX_VERSION_BITS_DEPLOYMENTS; i++) {\n         uint32_t bitmask = VersionBitsMask(mainnetParams, (Consensus::DeploymentPos)i);\n         // Make sure that no deployment tries to set an invalid bit.\n@@ -235,7 +235,8 @@ BOOST_AUTO_TEST_CASE(versionbits_computeblockversion)\n {\n     // Check that ComputeBlockVersion will set the appropriate bit correctly\n     // on mainnet.\n-    const Consensus::Params &mainnetParams = Params(CBaseChainParams::MAIN).GetConsensus();\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n+    const Consensus::Params &mainnetParams = chainParams->GetConsensus();\n \n     // Use the TESTDUMMY deployment for testing purposes.\n     int64_t bit = mainnetParams.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit;"
      },
      {
        "sha": "ec749127032b643053fa88625f9a2e8fad2abe51",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -58,7 +58,7 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n     // Add data\n     static CMedianFilter<int64_t> vTimeOffsets(BITCOIN_TIMEDATA_MAX_SAMPLES, 0);\n     vTimeOffsets.input(nOffsetSample);\n-    LogPrint(\"net\",\"added time data, samples %d, offset %+d (%+d minutes)\\n\", vTimeOffsets.size(), nOffsetSample, nOffsetSample/60);\n+    LogPrint(BCLog::NET,\"added time data, samples %d, offset %+d (%+d minutes)\\n\", vTimeOffsets.size(), nOffsetSample, nOffsetSample/60);\n \n     // There is a known issue here (see issue #4521):\n     //\n@@ -108,11 +108,14 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n                 }\n             }\n         }\n-        \n-        BOOST_FOREACH(int64_t n, vSorted)\n-            LogPrint(\"net\", \"%+d  \", n);\n-        LogPrint(\"net\", \"|  \");\n-        \n-        LogPrint(\"net\", \"nTimeOffset = %+d  (%+d minutes)\\n\", nTimeOffset, nTimeOffset/60);\n+\n+        if (LogAcceptCategory(BCLog::NET)) {\n+            BOOST_FOREACH(int64_t n, vSorted) {\n+                LogPrint(BCLog::NET, \"%+d  \", n);\n+            }\n+            LogPrint(BCLog::NET, \"|  \");\n+\n+            LogPrint(BCLog::NET, \"nTimeOffset = %+d  (%+d minutes)\\n\", nTimeOffset, nTimeOffset/60);\n+        }\n     }\n }"
      },
      {
        "sha": "8a37139f1d1ae98b00fb26d711069705f2c63672",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 106,
        "deletions": 38,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,4 +1,5 @@\n // Copyright (c) 2015-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Zcash developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -14,7 +15,6 @@\n #include <set>\n #include <stdlib.h>\n \n-#include <boost/function.hpp>\n #include <boost/bind.hpp>\n #include <boost/signals2/signal.hpp>\n #include <boost/foreach.hpp>\n@@ -73,8 +73,8 @@ class TorControlReply\n class TorControlConnection\n {\n public:\n-    typedef boost::function<void(TorControlConnection&)> ConnectionCB;\n-    typedef boost::function<void(TorControlConnection &,const TorControlReply &)> ReplyHandlerCB;\n+    typedef std::function<void(TorControlConnection&)> ConnectionCB;\n+    typedef std::function<void(TorControlConnection &,const TorControlReply &)> ReplyHandlerCB;\n \n     /** Create a new TorControlConnection.\n      */\n@@ -105,9 +105,9 @@ class TorControlConnection\n     boost::signals2::signal<void(TorControlConnection &,const TorControlReply &)> async_handler;\n private:\n     /** Callback when ready for use */\n-    boost::function<void(TorControlConnection&)> connected;\n+    std::function<void(TorControlConnection&)> connected;\n     /** Callback when connection lost */\n-    boost::function<void(TorControlConnection&)> disconnected;\n+    std::function<void(TorControlConnection&)> disconnected;\n     /** Libevent event base */\n     struct event_base *base;\n     /** Connection to control socket */\n@@ -163,7 +163,7 @@ void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)\n                     self->reply_handlers.front()(*self, self->message);\n                     self->reply_handlers.pop_front();\n                 } else {\n-                    LogPrint(\"tor\", \"tor: Received unexpected sync reply %i\\n\", self->message.code);\n+                    LogPrint(BCLog::TOR, \"tor: Received unexpected sync reply %i\\n\", self->message.code);\n                 }\n             }\n             self->message.Clear();\n@@ -182,13 +182,14 @@ void TorControlConnection::eventcb(struct bufferevent *bev, short what, void *ct\n {\n     TorControlConnection *self = (TorControlConnection*)ctx;\n     if (what & BEV_EVENT_CONNECTED) {\n-        LogPrint(\"tor\", \"tor: Successfully connected!\\n\");\n+        LogPrint(BCLog::TOR, \"tor: Successfully connected!\\n\");\n         self->connected(*self);\n     } else if (what & (BEV_EVENT_EOF|BEV_EVENT_ERROR)) {\n-        if (what & BEV_EVENT_ERROR)\n-            LogPrint(\"tor\", \"tor: Error connecting to Tor control socket\\n\");\n-        else\n-            LogPrint(\"tor\", \"tor: End of stream\\n\");\n+        if (what & BEV_EVENT_ERROR) {\n+            LogPrint(BCLog::TOR, \"tor: Error connecting to Tor control socket\\n\");\n+        } else {\n+            LogPrint(BCLog::TOR, \"tor: End of stream\\n\");\n+        }\n         self->Disconnect();\n         self->disconnected(*self);\n     }\n@@ -249,6 +250,8 @@ bool TorControlConnection::Command(const std::string &cmd, const ReplyHandlerCB&\n \n /* Split reply line in the form 'AUTH METHODS=...' into a type\n  * 'AUTH' and arguments 'METHODS=...'.\n+ * Grammar is implicitly defined in https://spec.torproject.org/control-spec by\n+ * the server reply formats for PROTOCOLINFO (S3.21) and AUTHCHALLENGE (S3.24).\n  */\n static std::pair<std::string,std::string> SplitTorReplyLine(const std::string &s)\n {\n@@ -264,35 +267,85 @@ static std::pair<std::string,std::string> SplitTorReplyLine(const std::string &s\n }\n \n /** Parse reply arguments in the form 'METHODS=COOKIE,SAFECOOKIE COOKIEFILE=\".../control_auth_cookie\"'.\n+ * Returns a map of keys to values, or an empty map if there was an error.\n+ * Grammar is implicitly defined in https://spec.torproject.org/control-spec by\n+ * the server reply formats for PROTOCOLINFO (S3.21), AUTHCHALLENGE (S3.24),\n+ * and ADD_ONION (S3.27). See also sections 2.1 and 2.3.\n  */\n static std::map<std::string,std::string> ParseTorReplyMapping(const std::string &s)\n {\n     std::map<std::string,std::string> mapping;\n     size_t ptr=0;\n     while (ptr < s.size()) {\n         std::string key, value;\n-        while (ptr < s.size() && s[ptr] != '=') {\n+        while (ptr < s.size() && s[ptr] != '=' && s[ptr] != ' ') {\n             key.push_back(s[ptr]);\n             ++ptr;\n         }\n         if (ptr == s.size()) // unexpected end of line\n             return std::map<std::string,std::string>();\n+        if (s[ptr] == ' ') // The remaining string is an OptArguments\n+            break;\n         ++ptr; // skip '='\n         if (ptr < s.size() && s[ptr] == '\"') { // Quoted string\n-            ++ptr; // skip '='\n+            ++ptr; // skip opening '\"'\n             bool escape_next = false;\n-            while (ptr < s.size() && (!escape_next && s[ptr] != '\"')) {\n-                escape_next = (s[ptr] == '\\\\');\n+            while (ptr < s.size() && (escape_next || s[ptr] != '\"')) {\n+                // Repeated backslashes must be interpreted as pairs\n+                escape_next = (s[ptr] == '\\\\' && !escape_next);\n                 value.push_back(s[ptr]);\n                 ++ptr;\n             }\n             if (ptr == s.size()) // unexpected end of line\n                 return std::map<std::string,std::string>();\n             ++ptr; // skip closing '\"'\n-            /* TODO: unescape value - according to the spec this depends on the\n-             * context, some strings use C-LogPrintf style escape codes, some\n-             * don't. So may be better handled at the call site.\n+            /**\n+             * Unescape value. Per https://spec.torproject.org/control-spec section 2.1.1:\n+             *\n+             *   For future-proofing, controller implementors MAY use the following\n+             *   rules to be compatible with buggy Tor implementations and with\n+             *   future ones that implement the spec as intended:\n+             *\n+             *     Read \\n \\t \\r and \\0 ... \\377 as C escapes.\n+             *     Treat a backslash followed by any other character as that character.\n              */\n+            std::string escaped_value;\n+            for (size_t i = 0; i < value.size(); ++i) {\n+                if (value[i] == '\\\\') {\n+                    // This will always be valid, because if the QuotedString\n+                    // ended in an odd number of backslashes, then the parser\n+                    // would already have returned above, due to a missing\n+                    // terminating double-quote.\n+                    ++i;\n+                    if (value[i] == 'n') {\n+                        escaped_value.push_back('\\n');\n+                    } else if (value[i] == 't') {\n+                        escaped_value.push_back('\\t');\n+                    } else if (value[i] == 'r') {\n+                        escaped_value.push_back('\\r');\n+                    } else if ('0' <= value[i] && value[i] <= '7') {\n+                        size_t j;\n+                        // Octal escape sequences have a limit of three octal digits,\n+                        // but terminate at the first character that is not a valid\n+                        // octal digit if encountered sooner.\n+                        for (j = 1; j < 3 && (i+j) < value.size() && '0' <= value[i+j] && value[i+j] <= '7'; ++j) {}\n+                        // Tor restricts first digit to 0-3 for three-digit octals.\n+                        // A leading digit of 4-7 would therefore be interpreted as\n+                        // a two-digit octal.\n+                        if (j == 3 && value[i] > '3') {\n+                            j--;\n+                        }\n+                        escaped_value.push_back(strtol(value.substr(i, j).c_str(), NULL, 8));\n+                        // Account for automatic incrementing at loop end\n+                        i += j - 1;\n+                    } else {\n+                        escaped_value.push_back(value[i]);\n+                    }\n+                } else {\n+                    escaped_value.push_back(value[i]);\n+                }\n+            }\n+            value = escaped_value;\n         } else { // Unquoted value. Note that values can contain '=' at will, just no spaces\n             while (ptr < s.size() && s[ptr] != ' ') {\n                 value.push_back(s[ptr]);\n@@ -313,15 +366,19 @@ static std::map<std::string,std::string> ParseTorReplyMapping(const std::string\n  * @param maxsize Puts a maximum size limit on the file that is read. If the file is larger than this, truncated data\n  *         (with len > maxsize) will be returned.\n  */\n-static std::pair<bool,std::string> ReadBinaryFile(const std::string &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n+static std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size_t maxsize=std::numeric_limits<size_t>::max())\n {\n-    FILE *f = fopen(filename.c_str(), \"rb\");\n+    FILE *f = fsbridge::fopen(filename, \"rb\");\n     if (f == NULL)\n         return std::make_pair(false,\"\");\n     std::string retval;\n     char buffer[128];\n     size_t n;\n     while ((n=fread(buffer, 1, sizeof(buffer), f)) > 0) {\n+        // Check for reading errors so we don't return any data if we couldn't\n+        // read the entire file (or up to maxsize)\n+        if (ferror(f))\n+            return std::make_pair(false,\"\");\n         retval.append(buffer, buffer+n);\n         if (retval.size() > maxsize)\n             break;\n@@ -333,9 +390,9 @@ static std::pair<bool,std::string> ReadBinaryFile(const std::string &filename, s\n /** Write contents of std::string to a file.\n  * @return true on success.\n  */\n-static bool WriteBinaryFile(const std::string &filename, const std::string &data)\n+static bool WriteBinaryFile(const fs::path &filename, const std::string &data)\n {\n-    FILE *f = fopen(filename.c_str(), \"wb\");\n+    FILE *f = fsbridge::fopen(filename, \"wb\");\n     if (f == NULL)\n         return false;\n     if (fwrite(data.data(), 1, data.size(), f) != data.size()) {\n@@ -358,7 +415,7 @@ class TorController\n     ~TorController();\n \n     /** Get name fo file to store private key in */\n-    std::string GetPrivateKeyFile();\n+    fs::path GetPrivateKeyFile();\n \n     /** Reconnect, after getting disconnected */\n     void Reconnect();\n@@ -410,7 +467,7 @@ TorController::TorController(struct event_base* _base, const std::string& _targe\n     // Read service private key if cached\n     std::pair<bool,std::string> pkf = ReadBinaryFile(GetPrivateKeyFile());\n     if (pkf.first) {\n-        LogPrint(\"tor\", \"tor: Reading cached private key from %s\\n\", GetPrivateKeyFile());\n+        LogPrint(BCLog::TOR, \"tor: Reading cached private key from %s\\n\", GetPrivateKeyFile().string());\n         private_key = pkf.second;\n     }\n }\n@@ -429,7 +486,7 @@ TorController::~TorController()\n void TorController::add_onion_cb(TorControlConnection& _conn, const TorControlReply& reply)\n {\n     if (reply.code == 250) {\n-        LogPrint(\"tor\", \"tor: ADD_ONION successful\\n\");\n+        LogPrint(BCLog::TOR, \"tor: ADD_ONION successful\\n\");\n         BOOST_FOREACH(const std::string &s, reply.lines) {\n             std::map<std::string,std::string> m = ParseTorReplyMapping(s);\n             std::map<std::string,std::string>::iterator i;\n@@ -438,12 +495,19 @@ void TorController::add_onion_cb(TorControlConnection& _conn, const TorControlRe\n             if ((i = m.find(\"PrivateKey\")) != m.end())\n                 private_key = i->second;\n         }\n+        if (service_id.empty()) {\n+            LogPrintf(\"tor: Error parsing ADD_ONION parameters:\\n\");\n+            for (const std::string &s : reply.lines) {\n+                LogPrintf(\"    %s\\n\", SanitizeString(s));\n+            }\n+            return;\n+        }\n         service = LookupNumeric(std::string(service_id+\".onion\").c_str(), GetListenPort());\n         LogPrintf(\"tor: Got service ID %s, advertising service %s\\n\", service_id, service.ToString());\n         if (WriteBinaryFile(GetPrivateKeyFile(), private_key)) {\n-            LogPrint(\"tor\", \"tor: Cached service private key to %s\\n\", GetPrivateKeyFile());\n+            LogPrint(BCLog::TOR, \"tor: Cached service private key to %s\\n\", GetPrivateKeyFile().string());\n         } else {\n-            LogPrintf(\"tor: Error writing service private key to %s\\n\", GetPrivateKeyFile());\n+            LogPrintf(\"tor: Error writing service private key to %s\\n\", GetPrivateKeyFile().string());\n         }\n         AddLocal(service, LOCAL_MANUAL);\n         // ... onion requested - keep connection open\n@@ -457,7 +521,7 @@ void TorController::add_onion_cb(TorControlConnection& _conn, const TorControlRe\n void TorController::auth_cb(TorControlConnection& _conn, const TorControlReply& reply)\n {\n     if (reply.code == 250) {\n-        LogPrint(\"tor\", \"tor: Authentication successful\\n\");\n+        LogPrint(BCLog::TOR, \"tor: Authentication successful\\n\");\n \n         // Now that we know Tor is running setup the proxy for onion addresses\n         // if -onion isn't set to something else.\n@@ -511,13 +575,17 @@ static std::vector<uint8_t> ComputeResponse(const std::string &key, const std::v\n void TorController::authchallenge_cb(TorControlConnection& _conn, const TorControlReply& reply)\n {\n     if (reply.code == 250) {\n-        LogPrint(\"tor\", \"tor: SAFECOOKIE authentication challenge successful\\n\");\n+        LogPrint(BCLog::TOR, \"tor: SAFECOOKIE authentication challenge successful\\n\");\n         std::pair<std::string,std::string> l = SplitTorReplyLine(reply.lines[0]);\n         if (l.first == \"AUTHCHALLENGE\") {\n             std::map<std::string,std::string> m = ParseTorReplyMapping(l.second);\n+            if (m.empty()) {\n+                LogPrintf(\"tor: Error parsing AUTHCHALLENGE parameters: %s\\n\", SanitizeString(l.second));\n+                return;\n+            }\n             std::vector<uint8_t> serverHash = ParseHex(m[\"SERVERHASH\"]);\n             std::vector<uint8_t> serverNonce = ParseHex(m[\"SERVERNONCE\"]);\n-            LogPrint(\"tor\", \"tor: AUTHCHALLENGE ServerHash %s ServerNonce %s\\n\", HexStr(serverHash), HexStr(serverNonce));\n+            LogPrint(BCLog::TOR, \"tor: AUTHCHALLENGE ServerHash %s ServerNonce %s\\n\", HexStr(serverHash), HexStr(serverNonce));\n             if (serverNonce.size() != 32) {\n                 LogPrintf(\"tor: ServerNonce is not 32 bytes, as required by spec\\n\");\n                 return;\n@@ -562,12 +630,12 @@ void TorController::protocolinfo_cb(TorControlConnection& _conn, const TorContro\n                 std::map<std::string,std::string> m = ParseTorReplyMapping(l.second);\n                 std::map<std::string,std::string>::iterator i;\n                 if ((i = m.find(\"Tor\")) != m.end()) {\n-                    LogPrint(\"tor\", \"tor: Connected to Tor version %s\\n\", i->second);\n+                    LogPrint(BCLog::TOR, \"tor: Connected to Tor version %s\\n\", i->second);\n                 }\n             }\n         }\n         BOOST_FOREACH(const std::string &s, methods) {\n-            LogPrint(\"tor\", \"tor: Supported authentication method: %s\\n\", s);\n+            LogPrint(BCLog::TOR, \"tor: Supported authentication method: %s\\n\", s);\n         }\n         // Prefer NULL, otherwise SAFECOOKIE. If a password is provided, use HASHEDPASSWORD\n         /* Authentication:\n@@ -577,18 +645,18 @@ void TorController::protocolinfo_cb(TorControlConnection& _conn, const TorContro\n         std::string torpassword = GetArg(\"-torpassword\", \"\");\n         if (!torpassword.empty()) {\n             if (methods.count(\"HASHEDPASSWORD\")) {\n-                LogPrint(\"tor\", \"tor: Using HASHEDPASSWORD authentication\\n\");\n+                LogPrint(BCLog::TOR, \"tor: Using HASHEDPASSWORD authentication\\n\");\n                 boost::replace_all(torpassword, \"\\\"\", \"\\\\\\\"\");\n                 _conn.Command(\"AUTHENTICATE \\\"\" + torpassword + \"\\\"\", boost::bind(&TorController::auth_cb, this, _1, _2));\n             } else {\n                 LogPrintf(\"tor: Password provided with -torpassword, but HASHEDPASSWORD authentication is not available\\n\");\n             }\n         } else if (methods.count(\"NULL\")) {\n-            LogPrint(\"tor\", \"tor: Using NULL authentication\\n\");\n+            LogPrint(BCLog::TOR, \"tor: Using NULL authentication\\n\");\n             _conn.Command(\"AUTHENTICATE\", boost::bind(&TorController::auth_cb, this, _1, _2));\n         } else if (methods.count(\"SAFECOOKIE\")) {\n             // Cookie: hexdump -e '32/1 \"%02x\"\"\\n\"'  ~/.tor/control_auth_cookie\n-            LogPrint(\"tor\", \"tor: Using SAFECOOKIE authentication, reading cookie authentication from %s\\n\", cookiefile);\n+            LogPrint(BCLog::TOR, \"tor: Using SAFECOOKIE authentication, reading cookie authentication from %s\\n\", cookiefile);\n             std::pair<bool,std::string> status_cookie = ReadBinaryFile(cookiefile, TOR_COOKIE_SIZE);\n             if (status_cookie.first && status_cookie.second.size() == TOR_COOKIE_SIZE) {\n                 // _conn.Command(\"AUTHENTICATE \" + HexStr(status_cookie.second), boost::bind(&TorController::auth_cb, this, _1, _2));\n@@ -630,7 +698,7 @@ void TorController::disconnected_cb(TorControlConnection& _conn)\n     if (!reconnect)\n         return;\n \n-    LogPrint(\"tor\", \"tor: Not connected to Tor control port %s, trying to reconnect\\n\", target);\n+    LogPrint(BCLog::TOR, \"tor: Not connected to Tor control port %s, trying to reconnect\\n\", target);\n \n     // Single-shot timer for reconnect. Use exponential backoff.\n     struct timeval time = MillisToTimeval(int64_t(reconnect_timeout * 1000.0));\n@@ -650,9 +718,9 @@ void TorController::Reconnect()\n     }\n }\n \n-std::string TorController::GetPrivateKeyFile()\n+fs::path TorController::GetPrivateKeyFile()\n {\n-    return (GetDataDir() / \"onion_private_key\").string();\n+    return GetDataDir() / \"onion_private_key\";\n }\n \n void TorController::reconnect_cb(evutil_socket_t fd, short what, void *arg)"
      },
      {
        "sha": "c8f509029324e7da3fd3d4a572401414908956a9",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 159,
        "deletions": 18,
        "changes": 177,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -14,6 +14,7 @@\n \n #include <boost/thread.hpp>\n \n+static const char DB_COIN = 'C';\n static const char DB_COINS = 'c';\n static const char DB_BLOCK_FILES = 'f';\n static const char DB_TXINDEX = 't';\n@@ -24,17 +25,40 @@ static const char DB_FLAG = 'F';\n static const char DB_REINDEX_FLAG = 'R';\n static const char DB_LAST_BLOCK = 'l';\n \n+namespace {\n+\n+struct CoinEntry {\n+    COutPoint* outpoint;\n+    char key;\n+    CoinEntry(const COutPoint* ptr) : outpoint(const_cast<COutPoint*>(ptr)), key(DB_COIN)  {}\n+\n+    template<typename Stream>\n+    void Serialize(Stream &s) const {\n+        s << key;\n+        s << outpoint->hash;\n+        s << VARINT(outpoint->n);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s) {\n+        s >> key;\n+        s >> outpoint->hash;\n+        s >> VARINT(outpoint->n);\n+    }\n+};\n+\n+}\n \n CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe, true) \n {\n }\n \n-bool CCoinsViewDB::GetCoins(const uint256 &txid, CCoins &coins) const {\n-    return db.Read(std::make_pair(DB_COINS, txid), coins);\n+bool CCoinsViewDB::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n+    return db.Read(CoinEntry(&outpoint), coin);\n }\n \n-bool CCoinsViewDB::HaveCoins(const uint256 &txid) const {\n-    return db.Exists(std::make_pair(DB_COINS, txid));\n+bool CCoinsViewDB::HaveCoin(const COutPoint &outpoint) const {\n+    return db.Exists(CoinEntry(&outpoint));\n }\n \n uint256 CCoinsViewDB::GetBestBlock() const {\n@@ -50,10 +74,11 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     size_t changed = 0;\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n-            if (it->second.coins.IsPruned())\n-                batch.Erase(std::make_pair(DB_COINS, it->first));\n+            CoinEntry entry(&it->first);\n+            if (it->second.coin.IsSpent())\n+                batch.Erase(entry);\n             else\n-                batch.Write(std::make_pair(DB_COINS, it->first), it->second.coins);\n+                batch.Write(entry, it->second.coin);\n             changed++;\n         }\n         count++;\n@@ -63,8 +88,14 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     if (!hashBlock.IsNull())\n         batch.Write(DB_BEST_BLOCK, hashBlock);\n \n-    LogPrint(\"coindb\", \"Committing %u changed transactions (out of %u) to coin database...\\n\", (unsigned int)changed, (unsigned int)count);\n-    return db.WriteBatch(batch);\n+    bool ret = db.WriteBatch(batch);\n+    LogPrint(BCLog::COINDB, \"Committed %u changed transaction outputs (out of %u) to coin database...\\n\", (unsigned int)changed, (unsigned int)count);\n+    return ret;\n+}\n+\n+size_t CCoinsViewDB::EstimateSize() const\n+{\n+    return db.EstimateSize(DB_COIN, (char)(DB_COIN+1));\n }\n \n CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CDBWrapper(GetDataDir() / \"blocks\" / \"index\", nCacheSize, fMemory, fWipe) {\n@@ -96,25 +127,31 @@ CCoinsViewCursor *CCoinsViewDB::Cursor() const\n     /* It seems that there are no \"const iterators\" for LevelDB.  Since we\n        only need read operations on it, use a const-cast to get around\n        that restriction.  */\n-    i->pcursor->Seek(DB_COINS);\n+    i->pcursor->Seek(DB_COIN);\n     // Cache key of first record\n-    i->pcursor->GetKey(i->keyTmp);\n+    if (i->pcursor->Valid()) {\n+        CoinEntry entry(&i->keyTmp.second);\n+        i->pcursor->GetKey(entry);\n+        i->keyTmp.first = entry.key;\n+    } else {\n+        i->keyTmp.first = 0; // Make sure Valid() and GetKey() return false\n+    }\n     return i;\n }\n \n-bool CCoinsViewDBCursor::GetKey(uint256 &key) const\n+bool CCoinsViewDBCursor::GetKey(COutPoint &key) const\n {\n     // Return cached key\n-    if (keyTmp.first == DB_COINS) {\n+    if (keyTmp.first == DB_COIN) {\n         key = keyTmp.second;\n         return true;\n     }\n     return false;\n }\n \n-bool CCoinsViewDBCursor::GetValue(CCoins &coins) const\n+bool CCoinsViewDBCursor::GetValue(Coin &coin) const\n {\n-    return pcursor->GetValue(coins);\n+    return pcursor->GetValue(coin);\n }\n \n unsigned int CCoinsViewDBCursor::GetValueSize() const\n@@ -124,14 +161,18 @@ unsigned int CCoinsViewDBCursor::GetValueSize() const\n \n bool CCoinsViewDBCursor::Valid() const\n {\n-    return keyTmp.first == DB_COINS;\n+    return keyTmp.first == DB_COIN;\n }\n \n void CCoinsViewDBCursor::Next()\n {\n     pcursor->Next();\n-    if (!pcursor->Valid() || !pcursor->GetKey(keyTmp))\n+    CoinEntry entry(&keyTmp.second);\n+    if (!pcursor->Valid() || !pcursor->GetKey(entry)) {\n         keyTmp.first = 0; // Invalidate cached key after last record so that Valid() and GetKey() return false\n+    } else {\n+        keyTmp.first = entry.key;\n+    }\n }\n \n bool CBlockTreeDB::WriteBatchSync(const std::vector<std::pair<int, const CBlockFileInfo*> >& fileInfo, int nLastFile, const std::vector<const CBlockIndex*>& blockinfo) {\n@@ -169,7 +210,7 @@ bool CBlockTreeDB::ReadFlag(const std::string &name, bool &fValue) {\n     return true;\n }\n \n-bool CBlockTreeDB::LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256&)> insertBlockIndex)\n+bool CBlockTreeDB::LoadBlockIndexGuts(std::function<CBlockIndex*(const uint256&)> insertBlockIndex)\n {\n     std::unique_ptr<CDBIterator> pcursor(NewIterator());\n \n@@ -211,3 +252,103 @@ bool CBlockTreeDB::LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256\n \n     return true;\n }\n+\n+namespace {\n+\n+//! Legacy class to deserialize pre-pertxout database entries without reindex.\n+class CCoins\n+{\n+public:\n+    //! whether transaction is a coinbase\n+    bool fCoinBase;\n+\n+    //! unspent transaction outputs; spent outputs are .IsNull(); spent outputs at the end of the array are dropped\n+    std::vector<CTxOut> vout;\n+\n+    //! at which height this transaction was included in the active block chain\n+    int nHeight;\n+\n+    //! empty constructor\n+    CCoins() : fCoinBase(false), vout(0), nHeight(0) { }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream &s) {\n+        unsigned int nCode = 0;\n+        // version\n+        int nVersionDummy;\n+        ::Unserialize(s, VARINT(nVersionDummy));\n+        // header code\n+        ::Unserialize(s, VARINT(nCode));\n+        fCoinBase = nCode & 1;\n+        std::vector<bool> vAvail(2, false);\n+        vAvail[0] = (nCode & 2) != 0;\n+        vAvail[1] = (nCode & 4) != 0;\n+        unsigned int nMaskCode = (nCode / 8) + ((nCode & 6) != 0 ? 0 : 1);\n+        // spentness bitmask\n+        while (nMaskCode > 0) {\n+            unsigned char chAvail = 0;\n+            ::Unserialize(s, chAvail);\n+            for (unsigned int p = 0; p < 8; p++) {\n+                bool f = (chAvail & (1 << p)) != 0;\n+                vAvail.push_back(f);\n+            }\n+            if (chAvail != 0)\n+                nMaskCode--;\n+        }\n+        // txouts themself\n+        vout.assign(vAvail.size(), CTxOut());\n+        for (unsigned int i = 0; i < vAvail.size(); i++) {\n+            if (vAvail[i])\n+                ::Unserialize(s, REF(CTxOutCompressor(vout[i])));\n+        }\n+        // coinbase height\n+        ::Unserialize(s, VARINT(nHeight));\n+    }\n+};\n+\n+}\n+\n+/** Upgrade the database from older formats.\n+ *\n+ * Currently implemented: from the per-tx utxo model (0.8..0.14.x) to per-txout.\n+ */\n+bool CCoinsViewDB::Upgrade() {\n+    std::unique_ptr<CDBIterator> pcursor(db.NewIterator());\n+    pcursor->Seek(std::make_pair(DB_COINS, uint256()));\n+    if (!pcursor->Valid()) {\n+        return true;\n+    }\n+\n+    LogPrintf(\"Upgrading database...\\n\");\n+    size_t batch_size = 1 << 24;\n+    CDBBatch batch(db);\n+    while (pcursor->Valid()) {\n+        boost::this_thread::interruption_point();\n+        std::pair<unsigned char, uint256> key;\n+        if (pcursor->GetKey(key) && key.first == DB_COINS) {\n+            CCoins old_coins;\n+            if (!pcursor->GetValue(old_coins)) {\n+                return error(\"%s: cannot parse CCoins record\", __func__);\n+            }\n+            COutPoint outpoint(key.second, 0);\n+            for (size_t i = 0; i < old_coins.vout.size(); ++i) {\n+                if (!old_coins.vout[i].IsNull() && !old_coins.vout[i].scriptPubKey.IsUnspendable()) {\n+                    Coin newcoin(std::move(old_coins.vout[i]), old_coins.nHeight, old_coins.fCoinBase);\n+                    outpoint.n = i;\n+                    CoinEntry entry(&outpoint);\n+                    batch.Write(entry, newcoin);\n+                }\n+            }\n+            batch.Erase(key);\n+            if (batch.SizeEstimate() > batch_size) {\n+                db.WriteBatch(batch);\n+                batch.Clear();\n+            }\n+            pcursor->Next();\n+        } else {\n+            break;\n+        }\n+    }\n+    db.WriteBatch(batch);\n+    return true;\n+}"
      },
      {
        "sha": "974dd4ebe351c42995288ab08ecf644e9dcbc2ab",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 18,
        "deletions": 12,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -15,14 +15,16 @@\n #include <utility>\n #include <vector>\n \n-#include <boost/function.hpp>\n-\n class CBlockIndex;\n class CCoinsViewDBCursor;\n class uint256;\n \n+//! Compensate for extra memory peak (x1.5-x1.9) at flush time.\n+static constexpr int DB_PEAK_USAGE_FACTOR = 2;\n+//! No need to periodic flush if at least this much space still available.\n+static constexpr int MAX_BLOCK_COINSDB_USAGE = 10 * DB_PEAK_USAGE_FACTOR;\n //! -dbcache default (MiB)\n-static const int64_t nDefaultDbCache = 300;\n+static const int64_t nDefaultDbCache = 450;\n //! max. -dbcache (MiB)\n static const int64_t nMaxDbCache = sizeof(void*) > 4 ? 16384 : 1024;\n //! min. -dbcache (MiB)\n@@ -69,11 +71,15 @@ class CCoinsViewDB : public CCoinsView\n public:\n     CCoinsViewDB(size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n \n-    bool GetCoins(const uint256 &txid, CCoins &coins) const;\n-    bool HaveCoins(const uint256 &txid) const;\n-    uint256 GetBestBlock() const;\n-    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n-    CCoinsViewCursor *Cursor() const;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n+    bool HaveCoin(const COutPoint &outpoint) const override;\n+    uint256 GetBestBlock() const override;\n+    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n+    CCoinsViewCursor *Cursor() const override;\n+\n+    //! Attempt to update from an older database format. Returns whether an error occurred.\n+    bool Upgrade();\n+    size_t EstimateSize() const override;\n };\n \n /** Specialization of CCoinsViewCursor to iterate over a CCoinsViewDB */\n@@ -82,8 +88,8 @@ class CCoinsViewDBCursor: public CCoinsViewCursor\n public:\n     ~CCoinsViewDBCursor() {}\n \n-    bool GetKey(uint256 &key) const;\n-    bool GetValue(CCoins &coins) const;\n+    bool GetKey(COutPoint &key) const;\n+    bool GetValue(Coin &coin) const;\n     unsigned int GetValueSize() const;\n \n     bool Valid() const;\n@@ -93,7 +99,7 @@ class CCoinsViewDBCursor: public CCoinsViewCursor\n     CCoinsViewDBCursor(CDBIterator* pcursorIn, const uint256 &hashBlockIn):\n         CCoinsViewCursor(hashBlockIn), pcursor(pcursorIn) {}\n     std::unique_ptr<CDBIterator> pcursor;\n-    std::pair<char, uint256> keyTmp;\n+    std::pair<char, COutPoint> keyTmp;\n \n     friend class CCoinsViewDB;\n };\n@@ -116,7 +122,7 @@ class CBlockTreeDB : public CDBWrapper\n     bool WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> > &list);\n     bool WriteFlag(const std::string &name, bool fValue);\n     bool ReadFlag(const std::string &name, bool &fValue);\n-    bool LoadBlockIndexGuts(boost::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n+    bool LoadBlockIndexGuts(std::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n };\n \n #endif // BITCOIN_TXDB_H"
      },
      {
        "sha": "17389db9f089827d7c120f729b012e45f65e2aeb",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 91,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -5,8 +5,8 @@\n \n #include \"txmempool.h\"\n \n-#include \"clientversion.h\"\n #include \"consensus/consensus.h\"\n+#include \"consensus/tx_verify.h\"\n #include \"consensus/validation.h\"\n #include \"validation.h\"\n #include \"policy/policy.h\"\n@@ -16,7 +16,6 @@\n #include \"util.h\"\n #include \"utilmoneystr.h\"\n #include \"utiltime.h\"\n-#include \"version.h\"\n \n CTxMemPoolEntry::CTxMemPoolEntry(const CTransactionRef& _tx, const CAmount& _nFee,\n                                  int64_t _nTime, unsigned int _entryHeight,\n@@ -25,7 +24,7 @@ CTxMemPoolEntry::CTxMemPoolEntry(const CTransactionRef& _tx, const CAmount& _nFe\n     spendsCoinbase(_spendsCoinbase), sigOpCost(_sigOpsCost), lockPoints(lp)\n {\n     nTxWeight = GetTransactionWeight(*tx);\n-    nUsageSize = RecursiveDynamicUsage(*tx) + memusage::DynamicUsage(tx);\n+    nUsageSize = RecursiveDynamicUsage(tx);\n \n     nCountWithDescendants = 1;\n     nSizeWithDescendants = GetTxSize();\n@@ -108,7 +107,7 @@ void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendan\n \n // vHashesToUpdate is the set of transaction hashes from a disconnected block\n // which has been re-added to the mempool.\n-// for each entry, look for descendants that are outside hashesToUpdate, and\n+// for each entry, look for descendants that are outside vHashesToUpdate, and\n // add fee/size information for such descendants to the parent.\n // for each such descendant, also update the ancestor state to include the parent.\n void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashesToUpdate)\n@@ -333,35 +332,21 @@ void CTxMemPoolEntry::UpdateAncestorState(int64_t modifySize, CAmount modifyFee,\n     assert(int(nSigOpCostWithAncestors) >= 0);\n }\n \n-CTxMemPool::CTxMemPool() :\n-    nTransactionsUpdated(0)\n+CTxMemPool::CTxMemPool(CBlockPolicyEstimator* estimator) :\n+    nTransactionsUpdated(0), minerPolicyEstimator(estimator)\n {\n     _clear(); //lock free clear\n \n     // Sanity checks off by default for performance, because otherwise\n     // accepting transactions becomes O(N^2) where N is the number\n     // of transactions in the pool\n     nCheckFrequency = 0;\n-\n-    minerPolicyEstimator = new CBlockPolicyEstimator();\n }\n \n-CTxMemPool::~CTxMemPool()\n-{\n-    delete minerPolicyEstimator;\n-}\n-\n-void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)\n+bool CTxMemPool::isSpent(const COutPoint& outpoint)\n {\n     LOCK(cs);\n-\n-    auto it = mapNextTx.lower_bound(COutPoint(hashTx, 0));\n-\n-    // iterate over all COutPoints in mapNextTx whose hash equals the provided hashTx\n-    while (it != mapNextTx.end() && it->first->hash == hashTx) {\n-        coins.Spend(it->first->n); // and remove those outputs from coins\n-        it++;\n-    }\n+    return mapNextTx.count(outpoint);\n }\n \n unsigned int CTxMemPool::GetTransactionsUpdated() const\n@@ -427,7 +412,7 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n \n     nTransactionsUpdated++;\n     totalTxSize += entry.GetTxSize();\n-    minerPolicyEstimator->processTransaction(entry, validFeeEstimate);\n+    if (minerPolicyEstimator) {minerPolicyEstimator->processTransaction(entry, validFeeEstimate);}\n \n     vTxHashes.emplace_back(tx.GetWitnessHash(), newit);\n     newit->vTxHashesIdx = vTxHashes.size() - 1;\n@@ -457,7 +442,7 @@ void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)\n     mapLinks.erase(it);\n     mapTx.erase(it);\n     nTransactionsUpdated++;\n-    minerPolicyEstimator->removeTx(hash);\n+    if (minerPolicyEstimator) {minerPolicyEstimator->removeTx(hash, false);}\n }\n \n // Calculates descendants of entry that are not already in setDescendants, and adds to\n@@ -539,9 +524,9 @@ void CTxMemPool::removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMem\n                 indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n                 if (it2 != mapTx.end())\n                     continue;\n-                const CCoins *coins = pcoins->AccessCoins(txin.prevout.hash);\n-                if (nCheckFrequency != 0) assert(coins);\n-                if (!coins || (coins->IsCoinBase() && ((signed long)nMemPoolHeight) - coins->nHeight < COINBASE_MATURITY)) {\n+                const Coin &coin = pcoins->AccessCoin(txin.prevout);\n+                if (nCheckFrequency != 0) assert(!coin.IsSpent());\n+                if (coin.IsSpent() || (coin.IsCoinBase() && ((signed long)nMemPoolHeight) - coin.nHeight < COINBASE_MATURITY)) {\n                     txToRemove.insert(it);\n                     break;\n                 }\n@@ -591,7 +576,7 @@ void CTxMemPool::removeForBlock(const std::vector<CTransactionRef>& vtx, unsigne\n             entries.push_back(&*i);\n     }\n     // Before the txs in the new block have been removed from the mempool, update policy estimates\n-    minerPolicyEstimator->processBlock(nBlockHeight, entries);\n+    if (minerPolicyEstimator) {minerPolicyEstimator->processBlock(nBlockHeight, entries);}\n     for (const auto& tx : vtx)\n     {\n         txiter it = mapTx.find(tx->GetHash());\n@@ -634,7 +619,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n     if (GetRand(std::numeric_limits<uint32_t>::max()) >= nCheckFrequency)\n         return;\n \n-    LogPrint(\"mempool\", \"Checking mempool with %u transactions and %u inputs\\n\", (unsigned int)mapTx.size(), (unsigned int)mapNextTx.size());\n+    LogPrint(BCLog::MEMPOOL, \"Checking mempool with %u transactions and %u inputs\\n\", (unsigned int)mapTx.size(), (unsigned int)mapNextTx.size());\n \n     uint64_t checkTotal = 0;\n     uint64_t innerUsage = 0;\n@@ -669,8 +654,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n                     parentSigOpCost += it2->GetSigOpCost();\n                 }\n             } else {\n-                const CCoins* coins = pcoins->AccessCoins(txin.prevout.hash);\n-                assert(coins && coins->IsAvailable(txin.prevout.n));\n+                assert(pcoins->HaveCoin(txin.prevout));\n             }\n             // Check whether its inputs are marked in mapNextTx.\n             auto it3 = mapNextTx.find(txin.prevout);\n@@ -850,51 +834,6 @@ TxMempoolInfo CTxMemPool::info(const uint256& hash) const\n     return GetInfo(i);\n }\n \n-CFeeRate CTxMemPool::estimateFee(int nBlocks) const\n-{\n-    LOCK(cs);\n-    return minerPolicyEstimator->estimateFee(nBlocks);\n-}\n-CFeeRate CTxMemPool::estimateSmartFee(int nBlocks, int *answerFoundAtBlocks) const\n-{\n-    LOCK(cs);\n-    return minerPolicyEstimator->estimateSmartFee(nBlocks, answerFoundAtBlocks, *this);\n-}\n-\n-bool\n-CTxMemPool::WriteFeeEstimates(CAutoFile& fileout) const\n-{\n-    try {\n-        LOCK(cs);\n-        fileout << 139900; // version required to read: 0.13.99 or later\n-        fileout << CLIENT_VERSION; // version that wrote the file\n-        minerPolicyEstimator->Write(fileout);\n-    }\n-    catch (const std::exception&) {\n-        LogPrintf(\"CTxMemPool::WriteFeeEstimates(): unable to write policy estimator data (non-fatal)\\n\");\n-        return false;\n-    }\n-    return true;\n-}\n-\n-bool\n-CTxMemPool::ReadFeeEstimates(CAutoFile& filein)\n-{\n-    try {\n-        int nVersionRequired, nVersionThatWrote;\n-        filein >> nVersionRequired >> nVersionThatWrote;\n-        if (nVersionRequired > CLIENT_VERSION)\n-            return error(\"CTxMemPool::ReadFeeEstimates(): up-version (%d) fee estimate file\", nVersionRequired);\n-        LOCK(cs);\n-        minerPolicyEstimator->Read(filein, nVersionThatWrote);\n-    }\n-    catch (const std::exception&) {\n-        LogPrintf(\"CTxMemPool::ReadFeeEstimates(): unable to read policy estimator data (non-fatal)\\n\");\n-        return false;\n-    }\n-    return true;\n-}\n-\n void CTxMemPool::PrioritiseTransaction(const uint256& hash, const CAmount& nFeeDelta)\n {\n     {\n@@ -912,6 +851,14 @@ void CTxMemPool::PrioritiseTransaction(const uint256& hash, const CAmount& nFeeD\n             BOOST_FOREACH(txiter ancestorIt, setAncestors) {\n                 mapTx.modify(ancestorIt, update_descendant_state(0, nFeeDelta, 0));\n             }\n+            // Now update all descendants' modified fees with ancestors\n+            setEntries setDescendants;\n+            CalculateDescendants(it, setDescendants);\n+            setDescendants.erase(it);\n+            BOOST_FOREACH(txiter descendantIt, setDescendants) {\n+                mapTx.modify(descendantIt, update_ancestor_state(0, nFeeDelta, 0, 0));\n+            }\n+            ++nTransactionsUpdated;\n         }\n     }\n     LogPrintf(\"PrioritiseTransaction: %s feerate += %s\\n\", hash.ToString(), FormatMoney(nFeeDelta));\n@@ -943,20 +890,24 @@ bool CTxMemPool::HasNoInputsOf(const CTransaction &tx) const\n \n CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool& mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) { }\n \n-bool CCoinsViewMemPool::GetCoins(const uint256 &txid, CCoins &coins) const {\n+bool CCoinsViewMemPool::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n     // If an entry in the mempool exists, always return that one, as it's guaranteed to never\n     // conflict with the underlying cache, and it cannot have pruned entries (as it contains full)\n     // transactions. First checking the underlying cache risks returning a pruned entry instead.\n-    CTransactionRef ptx = mempool.get(txid);\n+    CTransactionRef ptx = mempool.get(outpoint.hash);\n     if (ptx) {\n-        coins = CCoins(*ptx, MEMPOOL_HEIGHT);\n-        return true;\n+        if (outpoint.n < ptx->vout.size()) {\n+            coin = Coin(ptx->vout[outpoint.n], MEMPOOL_HEIGHT, false);\n+            return true;\n+        } else {\n+            return false;\n+        }\n     }\n-    return (base->GetCoins(txid, coins) && !coins.IsPruned());\n+    return (base->GetCoin(outpoint, coin) && !coin.IsSpent());\n }\n \n-bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n-    return mempool.exists(txid) || base->HaveCoins(txid);\n+bool CCoinsViewMemPool::HaveCoin(const COutPoint &outpoint) const {\n+    return mempool.exists(outpoint) || base->HaveCoin(outpoint);\n }\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n@@ -1067,7 +1018,7 @@ void CTxMemPool::trackPackageRemoved(const CFeeRate& rate) {\n     }\n }\n \n-void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<uint256>* pvNoSpendsRemaining) {\n+void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpendsRemaining) {\n     LOCK(cs);\n \n     unsigned nTxnRemoved = 0;\n@@ -1098,18 +1049,18 @@ void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<uint256>* pvNoSpendsRe\n         if (pvNoSpendsRemaining) {\n             BOOST_FOREACH(const CTransaction& tx, txn) {\n                 BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n-                    if (exists(txin.prevout.hash))\n-                        continue;\n-                    auto iter = mapNextTx.lower_bound(COutPoint(txin.prevout.hash, 0));\n-                    if (iter == mapNextTx.end() || iter->first->hash != txin.prevout.hash)\n-                        pvNoSpendsRemaining->push_back(txin.prevout.hash);\n+                    if (exists(txin.prevout.hash)) continue;\n+                    if (!mapNextTx.count(txin.prevout)) {\n+                        pvNoSpendsRemaining->push_back(txin.prevout);\n+                    }\n                 }\n             }\n         }\n     }\n \n-    if (maxFeeRateRemoved > CFeeRate(0))\n-        LogPrint(\"mempool\", \"Removed %u txn, rolling minimum fee bumped to %s\\n\", nTxnRemoved, maxFeeRateRemoved.ToString());\n+    if (maxFeeRateRemoved > CFeeRate(0)) {\n+        LogPrint(BCLog::MEMPOOL, \"Removed %u txn, rolling minimum fee bumped to %s\\n\", nTxnRemoved, maxFeeRateRemoved.ToString());\n+    }\n }\n \n bool CTxMemPool::TransactionWithinChainLimit(const uint256& txid, size_t chainLimit) const {\n@@ -1118,3 +1069,5 @@ bool CTxMemPool::TransactionWithinChainLimit(const uint256& txid, size_t chainLi\n     return it == mapTx.end() || (it->GetCountWithAncestors() < chainLimit &&\n        it->GetCountWithDescendants() < chainLimit);\n }\n+\n+SaltedTxidHasher::SaltedTxidHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}"
      },
      {
        "sha": "0316b42ba29527cd8bea15fd4fad3bea4fece15e",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "3749d5d7a8df79c1f8e04626b438a48d66a4e979",
        "filename": "src/undo.h",
        "status": "modified",
        "additions": 58,
        "deletions": 26,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/undo.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/undo.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/undo.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "653a4f072ad60c151e91b62761d8ff17cfa3fcac",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 156,
        "deletions": 105,
        "changes": 261,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "4386ddd550e63e9ddf373f5a6593acaacf6bd373",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 120,
        "deletions": 15,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "e07069125d20a37e8eddf2e1f06a8be9df6955ad",
        "filename": "src/utiltime.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/utiltime.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/utiltime.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "8ae8540b89c7090ccae8b3db516e67530cc765e8",
        "filename": "src/utiltime.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/utiltime.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/utiltime.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "eaefa954113286d6863ebea8883c4d9c10103397",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 453,
        "deletions": 588,
        "changes": 1041,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "0f410530fb63a2b871a134ae7a4aecbfdb39b91f",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 20,
        "deletions": 113,
        "changes": 133,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "46d7c9b3295026331a2c595ea3994a8bbf41706b",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "460aecf243fa25fa7e3f6f6b7d191d6286ff4b2c",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 22,
        "deletions": 23,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "4bb352f23c9300bd92af253cab4f9ada08a1d5c4",
        "filename": "src/versionbits.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 2,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "f4dfb71515adf4df7f7390c4580435813af8c7d6",
        "filename": "src/versionbits.h",
        "status": "modified",
        "additions": 12,
        "deletions": 2,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/versionbits.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/versionbits.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "cb4719ae90c01710f27ee77488680a365d081b84",
        "filename": "src/wallet/coincontrol.h",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/coincontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/coincontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coincontrol.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "89f204bc31592b0c6374f99d79b2f2f58f633589",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 117,
        "deletions": 65,
        "changes": 182,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "3c6870d169d6d3016e3083344053094b840e900c",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 80,
        "deletions": 34,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "46ef87b7b1e4ade88d0eec08c34bbe5029b6912f",
        "filename": "src/wallet/feebumper.cpp",
        "status": "added",
        "additions": 288,
        "deletions": 0,
        "changes": 288,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "fc323167048cce07f4cb6397fbddf7fbb951d06e",
        "filename": "src/wallet/feebumper.h",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/feebumper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/feebumper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "e771ce9bb3fe316781f8dad148fd2b6374937f54",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 61,
        "deletions": 17,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "07d1e10cddcebea0f23ee3e93d68ac054d3e210b",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 139,
        "deletions": 304,
        "changes": 443,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "524a72c303fba2c0c9f3fd02b031f97c94d56b7d",
        "filename": "src/wallet/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/crypto_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "1989bf8d9b96e85e17d3d3759f4da0ab6556f0b0",
        "filename": "src/wallet/test/wallet_test_fixture.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/test/wallet_test_fixture.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/test/wallet_test_fixture.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_test_fixture.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "b30748d66b48d18d3cc3392302e0fe6966358c0f",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 177,
        "deletions": 5,
        "changes": 182,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "b2706d09f66fb318d7f434426f090e4b5fa685f6",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 559,
        "deletions": 394,
        "changes": 953,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "a9c50aee4de49fe0919bd75e334541d1b29af69d",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 132,
        "deletions": 51,
        "changes": 183,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "342c797dd3ad118f34980da7c5afb2d483d1b9b8",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 49,
        "changes": 123,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "cd9fe279c537ec0037156915f3b41706b9174d7a",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 45,
        "deletions": 6,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "c06389805680314a4c076a0e0ea7e68de3163ef0",
        "filename": "src/zmq/zmqnotificationinterface.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 7,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/zmq/zmqnotificationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/zmq/zmqnotificationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqnotificationinterface.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "eec6f7bc64500454ef3612e405f1c06990b6874a",
        "filename": "src/zmq/zmqnotificationinterface.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/zmq/zmqnotificationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/zmq/zmqnotificationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqnotificationinterface.h?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "700c39f66ea822f60070e3109243ff9fb13860f8",
        "filename": "src/zmq/zmqpublishnotifier.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 6,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/zmq/zmqpublishnotifier.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/zmq/zmqpublishnotifier.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqpublishnotifier.cpp?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "4dd512638d973393292e2448cbe097e9dfb875b4",
        "filename": "test/README.md",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/README.md?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "35ee092be4fc134b0892e7d72fb35b6004aee8f6",
        "filename": "test/config.ini.in",
        "status": "renamed",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/config.ini.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/config.ini.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/config.ini.in?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "previous_filename": "test/functional/config.ini.in"
      },
      {
        "sha": "e6c4849702c7fe14796d54f1ea53ab8ce9c51ebe",
        "filename": "test/functional/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/README.md?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "c87c02492d7cc488196706311d65bff7f284ff81",
        "filename": "test/functional/abandonconflict.py",
        "status": "modified",
        "additions": 11,
        "deletions": 17,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/abandonconflict.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/abandonconflict.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/abandonconflict.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "9d17faac51ba2a5da6e62636f35140d83a1516a3",
        "filename": "test/functional/assumevalid.py",
        "status": "modified",
        "additions": 61,
        "deletions": 49,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/assumevalid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/assumevalid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/assumevalid.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "bb83042f35002ea1167caaad11e60a2abe385aa9",
        "filename": "test/functional/bip65-cltv-p2p.py",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bip65-cltv-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bip65-cltv-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip65-cltv-p2p.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "ddf932c74606b4cb1c1f2942d1b41863cd416b58",
        "filename": "test/functional/bip65-cltv.py",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bip65-cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bip65-cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip65-cltv.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "5a322e8c0e43d387cc2f062620846ae8f10c6680",
        "filename": "test/functional/bip68-112-113-p2p.py",
        "status": "modified",
        "additions": 1,
        "deletions": 6,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bip68-112-113-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bip68-112-113-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip68-112-113-p2p.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "87a50692f6c828dfd79cb91da310e25b31687e98",
        "filename": "test/functional/bip68-sequence.py",
        "status": "modified",
        "additions": 6,
        "deletions": 11,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bip68-sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bip68-sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip68-sequence.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "b90b0ca62842eb28d04a25f5ff96ce19df2d56d1",
        "filename": "test/functional/bip9-softforks.py",
        "status": "modified",
        "additions": 53,
        "deletions": 17,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bip9-softforks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bip9-softforks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip9-softforks.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "31c7ebba90c820b6dd910c9bac9b1a986774d40a",
        "filename": "test/functional/bipdersig-p2p.py",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bipdersig-p2p.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bipdersig-p2p.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bipdersig-p2p.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "41f88fb664b2318f447be09c4063a7e694f8c6a5",
        "filename": "test/functional/bipdersig.py",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bipdersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bipdersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bipdersig.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "6aef6d44892cef640d9afa8a849a62730a0da067",
        "filename": "test/functional/blockchain.py",
        "status": "modified",
        "additions": 62,
        "deletions": 12,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/blockchain.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "d42bab6cbfae98db8d5930ef4b0103be22cbbf19",
        "filename": "test/functional/bumpfee.py",
        "status": "modified",
        "additions": 49,
        "deletions": 68,
        "changes": 117,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bumpfee.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "3ca74ea35eaccb4f7feafc39f475e6541cd6a9e5",
        "filename": "test/functional/combine_logs.py",
        "status": "added",
        "additions": 114,
        "deletions": 0,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/combine_logs.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/combine_logs.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/combine_logs.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "c0b854b0805603e4c7dbd51c77195f953d99e8e7",
        "filename": "test/functional/combined_log_template.html",
        "status": "added",
        "additions": 40,
        "deletions": 0,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/combined_log_template.html",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/combined_log_template.html",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/combined_log_template.html?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "21a9f1223fd37abee2209c698b4eaa50ec1637b1",
        "filename": "test/functional/decodescript.py",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/decodescript.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/decodescript.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/decodescript.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "d3445134142622825ef0dae53a4c48c9399c77cb",
        "filename": "test/functional/disablewallet.py",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/disablewallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/disablewallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/disablewallet.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "89b68aeb25e6a0bf8120af1f7bac0126e1b7e647",
        "filename": "test/functional/disconnect_ban.py",
        "status": "added",
        "additions": 108,
        "deletions": 0,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/disconnect_ban.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/disconnect_ban.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/disconnect_ban.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "3bcf0a679511f68a4e03b16e36a5788eb60c88af",
        "filename": "test/functional/forknotify.py",
        "status": "modified",
        "additions": 14,
        "deletions": 8,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/forknotify.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/forknotify.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/forknotify.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "0a3166b89bb7a2d5d0f6211e297d718ed9eaa8f8",
        "filename": "test/functional/fundrawtransaction.py",
        "status": "modified",
        "additions": 36,
        "deletions": 34,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/fundrawtransaction.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "fca99c7df5715a767e30a31e7946d8ba993b79f5",
        "filename": "test/functional/getblocktemplate_proposals.py",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/getblocktemplate_proposals.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/getblocktemplate_proposals.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/getblocktemplate_proposals.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "15f96c565fe60353c4a20ff105953f5b21e8a922",
        "filename": "test/functional/getchaintips.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/getchaintips.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/getchaintips.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/getchaintips.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "4b32e8d9ca338373d3fbf7e332fa06c082afcb5d",
        "filename": "test/functional/httpbasics.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/httpbasics.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/httpbasics.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/httpbasics.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "4fc507821760e8492e32fe1ccd8a622a573de719",
        "filename": "test/functional/import-rescan.py",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/import-rescan.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/import-rescan.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/import-rescan.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "e83e85de138ef421ef01783ee1ef024ae609cfda",
        "filename": "test/functional/importmulti.py",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/importmulti.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/importmulti.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/importmulti.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "94753fe43114c31eb75092249b17c8a05d20b233",
        "filename": "test/functional/importprunedfunds.py",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/importprunedfunds.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/importprunedfunds.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/importprunedfunds.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "c499d57b90379746f66ee1def2cc3544de0b9d87",
        "filename": "test/functional/invalidateblock.py",
        "status": "modified",
        "additions": 3,
        "deletions": 8,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/invalidateblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/invalidateblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/invalidateblock.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "f23a427d1fff72c3a6f79edd91dfe196186d50c9",
        "filename": "test/functional/keypool.py",
        "status": "modified",
        "additions": 31,
        "deletions": 15,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/keypool.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "f3d41e573eda75ebc24b5fe9b815b1a06c404fbb",
        "filename": "test/functional/listsinceblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/listsinceblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/listsinceblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/listsinceblock.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "f69f1c5724ef35694fdb7534018904da673da787",
        "filename": "test/functional/listtransactions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/listtransactions.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "2c3766125ac44241e5c58b0ab46dea6492044b6f",
        "filename": "test/functional/maxblocksinflight.py",
        "status": "removed",
        "additions": 0,
        "deletions": 97,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3192e5278abca7c1f3b4a2a7f77a0ce941c73985/test/functional/maxblocksinflight.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3192e5278abca7c1f3b4a2a7f77a0ce941c73985/test/functional/maxblocksinflight.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/maxblocksinflight.py?ref=3192e5278abca7c1f3b4a2a7f77a0ce941c73985"
      },
      {
        "sha": "66e5bd29e6d244b9e50e108e95b2d517d9f2363e",
        "filename": "test/functional/maxuploadtarget.py",
        "status": "modified",
        "additions": 19,
        "deletions": 78,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/maxuploadtarget.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "2777291dd0effec0044c37e642c62ee2bb8a7913",
        "filename": "test/functional/mempool_limit.py",
        "status": "modified",
        "additions": 7,
        "deletions": 12,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/mempool_limit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/mempool_limit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_limit.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "e225493816e05de84503495308aacc31d4d08010",
        "filename": "test/functional/mempool_packages.py",
        "status": "modified",
        "additions": 15,
        "deletions": 10,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_packages.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "e0889fd5e9d89eb0bb89cb9ccc8be9fdb5801786",
        "filename": "test/functional/mempool_persist.py",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/mempool_persist.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/mempool_persist.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_persist.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      }
    ]
  },
  {
    "sha": "d6e2da631a3f67c653902afb71de30817e36ada3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkNmUyZGE2MzFhM2Y2N2M2NTM5MDJhZmI3MWRlMzA4MTdlMzZhZGEz",
    "commit": {
      "author": {
        "name": "globaltoken",
        "email": "globaltoken@users.noreply.github.com",
        "date": "2017-07-20T17:19:50Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2017-07-20T17:19:50Z"
      },
      "message": "Merge pull request #3 from bitcoin/master\n\nMerging to Master",
      "tree": {
        "sha": "c3ba3d83cda07628d21720436a295be08fcfe446",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c3ba3d83cda07628d21720436a295be08fcfe446"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d6e2da631a3f67c653902afb71de30817e36ada3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6e2da631a3f67c653902afb71de30817e36ada3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d6e2da631a3f67c653902afb71de30817e36ada3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6e2da631a3f67c653902afb71de30817e36ada3/comments",
    "author": {
      "login": "globaltoken",
      "id": 24831016,
      "node_id": "MDQ6VXNlcjI0ODMxMDE2",
      "avatar_url": "https://avatars.githubusercontent.com/u/24831016?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/globaltoken",
      "html_url": "https://github.com/globaltoken",
      "followers_url": "https://api.github.com/users/globaltoken/followers",
      "following_url": "https://api.github.com/users/globaltoken/following{/other_user}",
      "gists_url": "https://api.github.com/users/globaltoken/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/globaltoken/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/globaltoken/subscriptions",
      "organizations_url": "https://api.github.com/users/globaltoken/orgs",
      "repos_url": "https://api.github.com/users/globaltoken/repos",
      "events_url": "https://api.github.com/users/globaltoken/events{/privacy}",
      "received_events_url": "https://api.github.com/users/globaltoken/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "7c2400cb8ab7ebd5fe374b1f69657e0b0718ab73",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7c2400cb8ab7ebd5fe374b1f69657e0b0718ab73",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7c2400cb8ab7ebd5fe374b1f69657e0b0718ab73"
      }
    ],
    "stats": {
      "total": 12558,
      "additions": 7817,
      "deletions": 4741
    },
    "files": [
      {
        "sha": "a79428fc17a1f6bd85e7e014b9976eb53f1415b2",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -68,7 +68,7 @@ script:\n     - make $MAKEJOBS $GOAL || ( echo \"Build failure. Verbose build follows.\" && make $GOAL V=1 ; false )\n     - export LD_LIBRARY_PATH=$TRAVIS_BUILD_DIR/depends/$HOST/lib\n     - if [ \"$RUN_TESTS\" = \"true\" ]; then travis_wait 30 make $MAKEJOBS check VERBOSE=1; fi\n-    - if [ \"$TRAVIS_EVENT_TYPE\" = \"cron\" ]; then extended=\"--extended --exclude pruning\"; fi\n+    - if [ \"$TRAVIS_EVENT_TYPE\" = \"cron\" ]; then extended=\"--extended --exclude pruning,dbcrash\"; fi\n     - if [ \"$RUN_TESTS\" = \"true\" ]; then test/functional/test_runner.py --coverage --quiet ${extended}; fi\n after_script:\n     - echo $TRAVIS_COMMIT_RANGE"
      },
      {
        "sha": "8216b7d60811bc01573622eaa5f12a856d6e53e8",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 22,
        "deletions": 29,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -59,10 +59,10 @@ OSX_PACKAGING = $(OSX_DEPLOY_SCRIPT) $(OSX_FANCY_PLIST) $(OSX_INSTALLER_ICONS) \\\n   $(top_srcdir)/contrib/macdeploy/detached-sig-apply.sh \\\n   $(top_srcdir)/contrib/macdeploy/detached-sig-create.sh\n \n-COVERAGE_INFO = baseline_filtered_combined.info baseline.info \\\n-  leveldb_baseline.info test_bitcoin_filtered.info total_coverage.info \\\n+COVERAGE_INFO = baseline.info \\\n+  test_bitcoin_filtered.info total_coverage.info \\\n   baseline_filtered.info functional_test.info functional_test_filtered.info \\\n-  leveldb_baseline_filtered.info test_bitcoin_coverage.info test_bitcoin.info\n+  test_bitcoin_coverage.info test_bitcoin.info\n \n dist-hook:\n \t-$(GIT) archive --format=tar HEAD -- src/clientversion.cpp | $(AMTAR) -C $(top_distdir) -xf -\n@@ -166,52 +166,45 @@ $(BITCOIN_CLI_BIN): FORCE\n \t$(MAKE) -C src $(@F)\n \n if USE_LCOV\n+LCOV_FILTER_PATTERN=-p \"/usr/include/\" -p \"src/leveldb/\" -p \"src/bench/\" -p \"src/univalue\" -p \"src/crypto/ctaes\" -p \"src/secp256k1\"\n \n baseline.info:\n \t$(LCOV) -c -i -d $(abs_builddir)/src -o $@\n \n baseline_filtered.info: baseline.info\n-\t$(LCOV) -r $< \"/usr/include/*\" -o $@\n+\t$(abs_builddir)/contrib/filter-lcov.py $(LCOV_FILTER_PATTERN) $< $@\n+\t$(LCOV) -a $@ $(LCOV_OPTS) -o $@\n \n-leveldb_baseline.info: baseline_filtered.info\n-\t$(LCOV) -c -i -d $(abs_builddir)/src/leveldb -b $(abs_builddir)/src/leveldb -o $@\n-\n-leveldb_baseline_filtered.info: leveldb_baseline.info\n-\t$(LCOV) -r $< \"/usr/include/*\" -o $@\n-\n-baseline_filtered_combined.info: leveldb_baseline_filtered.info baseline_filtered.info\n-\t$(LCOV) -a leveldb_baseline_filtered.info -a baseline_filtered.info -o $@\n-\n-test_bitcoin.info: baseline_filtered_combined.info\n+test_bitcoin.info: baseline_filtered.info\n \t$(MAKE) -C src/ check\n-\t$(LCOV) -c -d $(abs_builddir)/src -t test_bitcoin -o $@\n-\t$(LCOV) -z -d $(abs_builddir)/src\n-\t$(LCOV) -z -d $(abs_builddir)/src/leveldb\n+\t$(LCOV) -c $(LCOV_OPTS) -d $(abs_builddir)/src -t test_bitcoin -o $@\n+\t$(LCOV) -z $(LCOV_OPTS) -d $(abs_builddir)/src\n \n test_bitcoin_filtered.info: test_bitcoin.info\n-\t$(LCOV) -r $< \"/usr/include/*\" -o $@\n+\t$(abs_builddir)/contrib/filter-lcov.py $(LCOV_FILTER_PATTERN) $< $@\n+\t$(LCOV) -a $@ $(LCOV_OPTS) -o $@\n \n functional_test.info: test_bitcoin_filtered.info\n-\t-@TIMEOUT=15 python test/functional/test_runner.py $(EXTENDED_FUNCTIONAL_TESTS)\n-\t$(LCOV) -c -d $(abs_builddir)/src --t functional-tests -o $@\n-\t$(LCOV) -z -d $(abs_builddir)/src\n-\t$(LCOV) -z -d $(abs_builddir)/src/leveldb\n+\t-@TIMEOUT=15 test/functional/test_runner.py $(EXTENDED_FUNCTIONAL_TESTS)\n+\t$(LCOV) -c $(LCOV_OPTS) -d $(abs_builddir)/src --t functional-tests -o $@\n+\t$(LCOV) -z $(LCOV_OPTS) -d $(abs_builddir)/src\n \n functional_test_filtered.info: functional_test.info\n-\t$(LCOV) -r $< \"/usr/include/*\" -o $@\n+\t$(abs_builddir)/contrib/filter-lcov.py $(LCOV_FILTER_PATTERN) $< $@\n+\t$(LCOV) -a $@ $(LCOV_OPTS) -o $@\n \n-test_bitcoin_coverage.info: baseline_filtered_combined.info test_bitcoin_filtered.info\n-\t$(LCOV) -a baseline_filtered.info -a leveldb_baseline_filtered.info -a test_bitcoin_filtered.info -o $@\n+test_bitcoin_coverage.info: baseline_filtered.info test_bitcoin_filtered.info\n+\t$(LCOV) -a $(LCOV_OPTS) baseline_filtered.info -a test_bitcoin_filtered.info -o $@\n \n-total_coverage.info: baseline_filtered_combined.info test_bitcoin_filtered.info functional_test_filtered.info\n-\t$(LCOV) -a baseline_filtered.info -a leveldb_baseline_filtered.info -a test_bitcoin_filtered.info -a functional_test_filtered.info -o $@ | $(GREP) \"\\%\" | $(AWK) '{ print substr($$3,2,50) \"/\" $$5 }' > coverage_percent.txt\n+total_coverage.info: test_bitcoin_filtered.info functional_test_filtered.info\n+\t$(LCOV) -a $(LCOV_OPTS) baseline_filtered.info -a test_bitcoin_filtered.info -a functional_test_filtered.info -o $@ | $(GREP) \"\\%\" | $(AWK) '{ print substr($$3,2,50) \"/\" $$5 }' > coverage_percent.txt\n \n test_bitcoin.coverage/.dirstamp:  test_bitcoin_coverage.info\n-\t$(GENHTML) -s $< -o $(@D)\n+\t$(GENHTML) -s $(LCOV_OPTS) $< -o $(@D)\n \t@touch $@\n \n total.coverage/.dirstamp: total_coverage.info\n-\t$(GENHTML) -s $< -o $(@D)\n+\t$(GENHTML) -s $(LCOV_OPTS) $< -o $(@D)\n \t@touch $@\n \n cov: test_bitcoin.coverage/.dirstamp total.coverage/.dirstamp"
      },
      {
        "sha": "b9bf7bf46e54971d3f0f3b9353a707fce3ddb4a3",
        "filename": "build-aux/m4/bitcoin_find_bdb48.m4",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/build-aux/m4/bitcoin_find_bdb48.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/build-aux/m4/bitcoin_find_bdb48.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_find_bdb48.m4?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -12,7 +12,7 @@ AC_DEFUN([BITCOIN_FIND_BDB48],[\n     bdbpath=X\n     bdb48path=X\n     bdbdirlist=\n-    for _vn in 4.8 48 4 5 ''; do\n+    for _vn in 4.8 48 4 5 5.3 ''; do\n       for _pfx in b lib ''; do\n         bdbdirlist=\"$bdbdirlist ${_pfx}db${_vn}\"\n       done"
      },
      {
        "sha": "f83dba076fd132df578edfb1ec9f94715cb42317",
        "filename": "build-aux/m4/bitcoin_qt.m4",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/build-aux/m4/bitcoin_qt.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/build-aux/m4/bitcoin_qt.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_qt.m4?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -399,17 +399,17 @@ AC_DEFUN([_BITCOIN_QT_FIND_LIBS_WITH_PKGCONFIG],[\n     qt4_modules=\"QtCore QtGui QtNetwork\"\n     BITCOIN_QT_CHECK([\n       if test x$bitcoin_qt_want_version = xqt5 || ( test x$bitcoin_qt_want_version = xauto && test x$auto_priority_version = xqt5 ); then\n-        PKG_CHECK_MODULES([QT], [$qt5_modules], [QT_INCLUDES=\"$QT_CFLAGS\"; have_qt=yes],[have_qt=no])\n+        PKG_CHECK_MODULES([QT5], [$qt5_modules], [QT_INCLUDES=\"$QT5_CFLAGS\"; QT_LIBS=\"$QT5_LIBS\" have_qt=yes],[have_qt=no])\n       elif test x$bitcoin_qt_want_version = xqt4 || ( test x$bitcoin_qt_want_version = xauto && test x$auto_priority_version = xqt4 ); then\n-        PKG_CHECK_MODULES([QT], [$qt4_modules], [QT_INCLUDES=\"$QT_CFLAGS\"; have_qt=yes], [have_qt=no])\n+        PKG_CHECK_MODULES([QT4], [$qt4_modules], [QT_INCLUDES=\"$QT4_CFLAGS\"; QT_LIBS=\"$QT4_LIBS\" ; have_qt=yes], [have_qt=no])\n       fi\n \n       dnl qt version is set to 'auto' and the preferred version wasn't found. Now try the other.\n       if test x$have_qt = xno && test x$bitcoin_qt_want_version = xauto; then\n         if test x$auto_priority_version = xqt5; then\n-          PKG_CHECK_MODULES([QT], [$qt4_modules], [QT_INCLUDES=\"$QT_CFLAGS\"; have_qt=yes; QT_LIB_PREFIX=Qt; bitcoin_qt_got_major_vers=4], [have_qt=no])\n+          PKG_CHECK_MODULES([QT4], [$qt4_modules], [QT_INCLUDES=\"$QT4_CFLAGS\"; QT_LIBS=\"$QT4_LIBS\" ; have_qt=yes; QT_LIB_PREFIX=Qt; bitcoin_qt_got_major_vers=4], [have_qt=no])\n         else\n-          PKG_CHECK_MODULES([QT], [$qt5_modules], [QT_INCLUDES=\"$QT_CFLAGS\"; have_qt=yes; QT_LIB_PREFIX=Qt5; bitcoin_qt_got_major_vers=5], [have_qt=no])\n+          PKG_CHECK_MODULES([QT5], [$qt5_modules], [QT_INCLUDES=\"$QT5_CFLAGS\"; QT_LIBS=\"$QT5_LIBS\" ; have_qt=yes; QT_LIB_PREFIX=Qt5; bitcoin_qt_got_major_vers=5], [have_qt=no])\n         fi\n       fi\n       if test x$have_qt != xyes; then"
      },
      {
        "sha": "835dcdbf570c8d82ad5d99802276f3a6d8e70412",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 50,
        "deletions": 0,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -19,6 +19,12 @@ BITCOIN_GUI_NAME=bitcoin-qt\n BITCOIN_CLI_NAME=bitcoin-cli\n BITCOIN_TX_NAME=bitcoin-tx\n \n+dnl Unless the user specified ARFLAGS, force it to be cr\n+AC_ARG_VAR(ARFLAGS, [Flags for the archiver, defaults to <cr> if not set])\n+if test \"x${ARFLAGS+set}\" != \"xset\"; then\n+  ARFLAGS=\"cr\"\n+fi\n+\n AC_CANONICAL_HOST\n \n AH_TOP([#ifndef BITCOIN_CONFIG_H])\n@@ -158,6 +164,12 @@ AC_ARG_ENABLE([lcov],\n   [enable lcov testing (default is no)])],\n   [use_lcov=yes],\n   [use_lcov=no])\n+  \n+AC_ARG_ENABLE([lcov-branch-coverage],\n+  [AS_HELP_STRING([--enable-lcov-branch-coverage],\n+  [enable lcov testing branch coverage (default is no)])],\n+  [use_lcov_branch=yes],\n+  [use_lcov_branch=no])\n \n AC_ARG_ENABLE([glibc-back-compat],\n   [AS_HELP_STRING([--enable-glibc-back-compat],\n@@ -236,7 +248,36 @@ if test \"x$CXXFLAGS_overridden\" = \"xno\"; then\n   AX_CHECK_COMPILE_FLAG([-Wunused-local-typedef],[CXXFLAGS=\"$CXXFLAGS -Wno-unused-local-typedef\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wdeprecated-register],[CXXFLAGS=\"$CXXFLAGS -Wno-deprecated-register\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Wimplicit-fallthrough],[CXXFLAGS=\"$CXXFLAGS -Wno-implicit-fallthrough\"],,[[$CXXFLAG_WERROR]])\n+\n+  # Check for optional instruction set support. Enabling these does _not_ imply that all code will\n+  # be compiled with them, rather that specific objects/libs may use them after checking for runtime\n+  # compatibility.\n+  AX_CHECK_COMPILE_FLAG([-msse4.2],[[SSE42_CXXFLAGS=\"-msse4.2\"]],,[[$CXXFLAG_WERROR]])\n+\n fi\n+\n+TEMP_CXXFLAGS=\"$CXXFLAGS\"\n+CXXFLAGS=\"$CXXFLAGS $SSE42_CXXFLAGS\"\n+AC_MSG_CHECKING(for assembler crc32 support)\n+AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n+    #include <stdint.h>\n+    #if defined(_MSC_VER)\n+    #include <intrin.h>\n+    #elif defined(__GNUC__) && defined(__SSE4_2__)\n+    #include <nmmintrin.h>\n+    #endif\n+  ]],[[\n+    uint64_t l = 0;\n+    l = _mm_crc32_u8(l, 0);\n+    l = _mm_crc32_u32(l, 0);\n+    l = _mm_crc32_u64(l, 0);\n+    return l;\n+  ]])],\n+ [ AC_MSG_RESULT(yes); enable_hwcrc32=yes],\n+ [ AC_MSG_RESULT(no)]\n+)\n+CXXFLAGS=\"$TEMP_CXXFLAGS\"\n+\n CPPFLAGS=\"$CPPFLAGS -DHAVE_BUILD_INFO -D__STDC_FORMAT_MACROS\"\n \n AC_ARG_WITH([utils],\n@@ -436,6 +477,12 @@ if test x$use_lcov = xyes; then\n     [AC_MSG_ERROR(\"lcov testing requested but --coverage linker flag does not work\")])\n   AX_CHECK_COMPILE_FLAG([--coverage],[CXXFLAGS=\"$CXXFLAGS --coverage\"],\n     [AC_MSG_ERROR(\"lcov testing requested but --coverage flag does not work\")])\n+  AC_DEFINE(USE_COVERAGE, 1, [Define this symbol if coverage is enabled])\n+  CXXFLAGS=\"$CXXFLAGS -Og\"\n+fi\n+\n+if test x$use_lcov_branch != xno; then\n+  AC_SUBST(LCOV_OPTS, \"$LCOV_OPTS --rc lcov_branch_coverage=1\")\n fi\n \n dnl Check for endianness\n@@ -1114,6 +1161,7 @@ AM_CONDITIONAL([USE_QRCODE], [test x$use_qr = xyes])\n AM_CONDITIONAL([USE_LCOV],[test x$use_lcov = xyes])\n AM_CONDITIONAL([GLIBC_BACK_COMPAT],[test x$use_glibc_compat = xyes])\n AM_CONDITIONAL([HARDEN],[test x$use_hardening = xyes])\n+AM_CONDITIONAL([ENABLE_HWCRC32],[test x$enable_hwcrc32 = xyes])\n \n AC_DEFINE(CLIENT_VERSION_MAJOR, _CLIENT_VERSION_MAJOR, [Major version])\n AC_DEFINE(CLIENT_VERSION_MINOR, _CLIENT_VERSION_MINOR, [Minor version])\n@@ -1146,6 +1194,7 @@ AC_SUBST(HARDENED_CPPFLAGS)\n AC_SUBST(HARDENED_LDFLAGS)\n AC_SUBST(PIC_FLAGS)\n AC_SUBST(PIE_FLAGS)\n+AC_SUBST(SSE42_CXXFLAGS)\n AC_SUBST(LIBTOOL_APP_LDFLAGS)\n AC_SUBST(USE_UPNP)\n AC_SUBST(USE_QRCODE)\n@@ -1242,4 +1291,5 @@ echo \"  CPPFLAGS      = $CPPFLAGS\"\n echo \"  CXX           = $CXX\"\n echo \"  CXXFLAGS      = $CXXFLAGS\"\n echo \"  LDFLAGS       = $LDFLAGS\"\n+echo \"  ARFLAGS       = $ARFLAGS\"\n echo "
      },
      {
        "sha": "150f368513296525112f09d9732bc7c7a428b32f",
        "filename": "contrib/devtools/check-doc.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/devtools/check-doc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/devtools/check-doc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/check-doc.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -21,7 +21,7 @@\n REGEX_ARG = re.compile(r'(?:map(?:Multi)?Args(?:\\.count\\(|\\[)|Get(?:Bool)?Arg\\()\\\"(\\-[^\\\"]+?)\\\"')\n REGEX_DOC = re.compile(r'HelpMessageOpt\\(\\\"(\\-[^\\\"=]+?)(?:=|\\\")')\n # list unsupported, deprecated and duplicate args as they need no documentation\n-SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize', '-sendfreetransactions'])\n+SET_DOC_OPTIONAL = set(['-rpcssl', '-benchmark', '-h', '-help', '-socks', '-tor', '-debugnet', '-whitelistalwaysrelay', '-prematurewitness', '-walletprematurewitness', '-promiscuousmempoolflags', '-blockminsize', '-dbcrashratio'])\n \n def main():\n   used = check_output(CMD_GREP_ARGS, shell=True)"
      },
      {
        "sha": "1c9dbc7f68ff5355fa02848dd6c85d659cf8d409",
        "filename": "contrib/devtools/commit-script-check.sh",
        "status": "modified",
        "additions": 20,
        "deletions": 13,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/devtools/commit-script-check.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/devtools/commit-script-check.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/commit-script-check.sh?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -20,20 +20,27 @@ RET=0\n PREV_BRANCH=`git name-rev --name-only HEAD`\n PREV_HEAD=`git rev-parse HEAD`\n for i in `git rev-list --reverse $1`; do\n-    git rev-list -n 1 --pretty=\"%s\" $i | grep -q \"^scripted-diff:\" || continue\n-    git checkout --quiet $i^ || exit\n-    SCRIPT=\"`git rev-list --format=%b -n1 $i | sed '/^-BEGIN VERIFY SCRIPT-$/,/^-END VERIFY SCRIPT-$/{//!b};d'`\"\n-    if test \"x$SCRIPT\" = \"x\"; then\n-        echo \"Error: missing script for: $i\"\n-        echo \"Failed\"\n-        RET=1\n-    else\n-        echo \"Running script for: $i\"\n-        echo \"$SCRIPT\"\n-        eval \"$SCRIPT\"\n-        git --no-pager diff --exit-code $i && echo \"OK\" || (echo \"Failed\"; false) || RET=1\n+    if git rev-list -n 1 --pretty=\"%s\" $i | grep -q \"^scripted-diff:\"; then\n+        git checkout --quiet $i^ || exit\n+        SCRIPT=\"`git rev-list --format=%b -n1 $i | sed '/^-BEGIN VERIFY SCRIPT-$/,/^-END VERIFY SCRIPT-$/{//!b};d'`\"\n+        if test \"x$SCRIPT\" = \"x\"; then\n+            echo \"Error: missing script for: $i\"\n+            echo \"Failed\"\n+            RET=1\n+        else\n+            echo \"Running script for: $i\"\n+            echo \"$SCRIPT\"\n+            eval \"$SCRIPT\"\n+            git --no-pager diff --exit-code $i && echo \"OK\" || (echo \"Failed\"; false) || RET=1\n+        fi\n+        git reset --quiet --hard HEAD\n+     else\n+        if git rev-list \"--format=%b\" -n1 $i | grep -q '^-\\(BEGIN\\|END\\)[ a-zA-Z]*-$'; then\n+            echo \"Error: script block marker but no scripted-diff in title\"\n+            echo \"Failed\"\n+            RET=1\n+        fi\n     fi\n-    git reset --quiet --hard HEAD\n done\n git checkout --quiet $PREV_BRANCH 2>/dev/null || git checkout --quiet $PREV_HEAD\n exit $RET"
      },
      {
        "sha": "c664cf81fa9f63ac3fb4a32a19840442927b7450",
        "filename": "contrib/devtools/github-merge.py",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/devtools/github-merge.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/devtools/github-merge.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/github-merge.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -175,6 +175,7 @@ def main():\n     if info is None:\n         exit(1)\n     title = info['title'].strip()\n+    body = info['body'].strip()\n     # precedence order for destination branch argument:\n     #   - command line argument\n     #   - githubmerge.branch setting\n@@ -229,6 +230,7 @@ def main():\n             firstline = 'Merge #%s' % (pull,)\n         message = firstline + '\\n\\n'\n         message += subprocess.check_output([GIT,'log','--no-merges','--topo-order','--pretty=format:%h %s (%an)',base_branch+'..'+head_branch]).decode('utf-8')\n+        message += '\\n\\nPull request description:\\n\\n  ' + body.replace('\\n', '\\n  ') + '\\n'\n         try:\n             subprocess.check_call([GIT,'merge','-q','--commit','--no-edit','--no-ff','-m',message.encode('utf-8'),head_branch])\n         except subprocess.CalledProcessError as e:"
      },
      {
        "sha": "299377d691155308875fb95fe5b7f49f9e8d50dc",
        "filename": "contrib/filter-lcov.py",
        "status": "added",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/filter-lcov.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/filter-lcov.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/filter-lcov.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -0,0 +1,25 @@\n+#!/usr/bin/env python3\n+\n+import argparse\n+\n+parser = argparse.ArgumentParser(description='Remove the coverage data from a tracefile for all files matching the pattern.')\n+parser.add_argument('--pattern', '-p', action='append', help='the pattern of files to remove', required=True)\n+parser.add_argument('tracefile', help='the tracefile to remove the coverage data from')\n+parser.add_argument('outfile', help='filename for the output to be written to')\n+\n+args = parser.parse_args()\n+tracefile = args.tracefile\n+pattern = args.pattern\n+outfile = args.outfile\n+\n+in_remove = False\n+with open(tracefile, 'r') as f:\n+    with open(outfile, 'w') as wf:\n+        for line in f:\n+            for p in pattern:\n+                if line.startswith(\"SF:\") and p in line:\n+                    in_remove = True\n+            if not in_remove:\n+                wf.write(line)\n+            if line == 'end_of_record\\n':\n+                in_remove = False"
      },
      {
        "sha": "eed232a8722de569dc75dc97fc926e18b060898a",
        "filename": "contrib/gitian-keys/laanwj-key.pgp",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/gitian-keys/laanwj-key.pgp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/gitian-keys/laanwj-key.pgp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-keys/laanwj-key.pgp?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "4ab2f356803a8933edd1fe7b573533281ef7c1f2",
        "filename": "contrib/rpm/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/rpm/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/rpm/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/rpm/README.md?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -181,5 +181,5 @@ knows what they are getting when installing the GUI package.\n \n As far as minor differences, I generally prefer to assign the file permissions\n in the `%files` portion of an RPM spec file rather than specifying the\n-permissions of a file during `%install` and other minor things like that that\n+permissions of a file during `%install` and other minor things like that\n are largely just cosmetic."
      },
      {
        "sha": "b206866cc5eb4abc3075f8692637a7096d7f0b0e",
        "filename": "contrib/rpm/bitcoin.if",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/rpm/bitcoin.if",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/rpm/bitcoin.if",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/rpm/bitcoin.if?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -121,7 +121,7 @@ interface(`bitcoin_manage_lib_dirs',`\n ########################################\n ## <summary>\n ##\tAll of the rules required to administrate\n-##\tan bitcoin environment\n+##\ta bitcoin environment\n ## </summary>\n ## <param name=\"domain\">\n ##\t<summary>"
      },
      {
        "sha": "3ffe0a2f289556d40fab4f5ed82ddefaab645ea9",
        "filename": "contrib/verifybinaries/README.md",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/verifybinaries/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/verifybinaries/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verifybinaries/README.md?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -26,6 +26,14 @@ The script returns 0 if everything passes the checks. It returns 1 if either the\n ./verify.sh bitcoin-core-0.13.0-rc3\n ```\n \n+If you only want to download the binaries of certain platform, add the corresponding suffix, e.g.:\n+\n+```sh\n+./verify.sh bitcoin-core-0.11.2-osx\n+./verify.sh 0.12.0-linux\n+./verify.sh bitcoin-core-0.13.0-rc3-win64\n+```\n+\n If you do not want to keep the downloaded binaries, specify anything as the second parameter.\n \n ```sh"
      },
      {
        "sha": "409f517c9fb2691549a8ff280461d14d1b2e9dd7",
        "filename": "contrib/verifybinaries/verify.sh",
        "status": "modified",
        "additions": 63,
        "deletions": 11,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/verifybinaries/verify.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/contrib/verifybinaries/verify.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verifybinaries/verify.sh?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -3,7 +3,8 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-###   This script attempts to download the signature file SHA256SUMS.asc from bitcoin.org\n+###   This script attempts to download the signature file SHA256SUMS.asc from\n+###   bitcoincore.org and bitcoin.org and compares them.\n ###   It first checks if the signature passes, and then downloads the files specified in\n ###   the file, and checks if the hashes of these files match those that are specified\n ###   in the signature file.\n@@ -22,7 +23,9 @@ TMPFILE=\"hashes.tmp\"\n \n SIGNATUREFILENAME=\"SHA256SUMS.asc\"\n RCSUBDIR=\"test\"\n-BASEDIR=\"https://bitcoin.org/bin/\"\n+HOST1=\"https://bitcoincore.org\"\n+HOST2=\"https://bitcoin.org\"\n+BASEDIR=\"/bin/\"\n VERSIONPREFIX=\"bitcoin-core-\"\n RCVERSIONSTRING=\"rc\"\n \n@@ -42,13 +45,36 @@ if [ -n \"$1\" ]; then\n       VERSION=\"$VERSIONPREFIX$1\"\n    fi\n \n-   #now let's see if the version string contains \"rc\", and strip it off if it does\n-   #  and simultaneously add RCSUBDIR to BASEDIR, where we will look for SIGNATUREFILENAME\n-   if [[ $VERSION == *\"$RCVERSIONSTRING\"* ]]; then\n-      BASEDIR=\"$BASEDIR${VERSION/%-$RCVERSIONSTRING*}/\"\n-      BASEDIR=\"$BASEDIR$RCSUBDIR.$RCVERSIONSTRING${VERSION: -1}/\"\n+   STRIPPEDLAST=\"${VERSION%-*}\"\n+\n+   #now let's see if the version string contains \"rc\" or a platform name (e.g. \"osx\")\n+   if [[ \"$STRIPPEDLAST-\" == \"$VERSIONPREFIX\" ]]; then\n+      BASEDIR=\"$BASEDIR$VERSION/\"\n    else\n+      # let's examine the last part to see if it's rc and/or platform name\n+      STRIPPEDNEXTTOLAST=\"${STRIPPEDLAST%-*}\"\n+      if [[ \"$STRIPPEDNEXTTOLAST-\" == \"$VERSIONPREFIX\" ]]; then\n+\n+         LASTSUFFIX=\"${VERSION##*-}\"\n+         VERSION=\"$STRIPPEDLAST\"\n+\n+         if [[ $LASTSUFFIX == *\"$RCVERSIONSTRING\"* ]]; then\n+            RCVERSION=\"$LASTSUFFIX\"\n+         else\n+            PLATFORM=\"$LASTSUFFIX\"\n+         fi\n+\n+      else\n+         RCVERSION=\"${STRIPPEDLAST##*-}\"\n+         PLATFORM=\"${VERSION##*-}\"\n+\n+         VERSION=\"$STRIPPEDNEXTTOLAST\"\n+      fi\n+\n       BASEDIR=\"$BASEDIR$VERSION/\"\n+      if [[ $RCVERSION == *\"$RCVERSIONSTRING\"* ]]; then\n+         BASEDIR=\"$BASEDIR$RCSUBDIR.$RCVERSION/\"\n+      fi\n    fi\n \n    SIGNATUREFILE=\"$BASEDIR$SIGNATUREFILENAME\"\n@@ -58,7 +84,7 @@ else\n fi\n \n #first we fetch the file containing the signature\n-WGETOUT=$(wget -N \"$BASEDIR$SIGNATUREFILENAME\" 2>&1)\n+WGETOUT=$(wget -N \"$HOST1$BASEDIR$SIGNATUREFILENAME\" 2>&1)\n \n #and then see if wget completed successfully\n if [ $? -ne 0 ]; then\n@@ -69,6 +95,22 @@ if [ $? -ne 0 ]; then\n    exit 2\n fi\n \n+WGETOUT=$(wget -N -O \"$SIGNATUREFILENAME.2\" \"$HOST2$BASEDIR$SIGNATUREFILENAME\" 2>&1)\n+if [ $? -ne 0 ]; then\n+   echo \"bitcoin.org failed to provide signature file, but bitcoincore.org did?\"\n+   echo \"wget output:\"\n+   echo \"$WGETOUT\"|sed 's/^/\\t/g'\n+   clean_up $SIGNATUREFILENAME\n+   exit 3\n+fi\n+\n+SIGFILEDIFFS=\"$(diff $SIGNATUREFILENAME $SIGNATUREFILENAME.2)\"\n+if [ \"$SIGFILEDIFFS\" != \"\" ]; then\n+   echo \"bitcoin.org and bitcoincore.org signature files were not equal?\"\n+   clean_up $SIGNATUREFILENAME $SIGNATUREFILENAME.2\n+   exit 4\n+fi\n+\n #then we check it\n GPGOUT=$(gpg --yes --decrypt --output \"$TMPFILE\" \"$SIGNATUREFILENAME\" 2>&1)\n \n@@ -88,17 +130,27 @@ if [ $RET -ne 0 ]; then\n \n    echo \"gpg output:\"\n    echo \"$GPGOUT\"|sed 's/^/\\t/g'\n-   clean_up $SIGNATUREFILENAME $TMPFILE\n+   clean_up $SIGNATUREFILENAME $SIGNATUREFILENAME.2 $TMPFILE\n    exit \"$RET\"\n fi\n \n+if [ -n \"$PLATFORM\" ]; then\n+   grep $PLATFORM $TMPFILE > \"$TMPFILE-plat\"\n+   TMPFILESIZE=$(stat -c%s \"$TMPFILE-plat\")\n+   if [ $TMPFILESIZE -eq 0 ]; then\n+      echo \"error: no files matched the platform specified\" && exit 3\n+   fi\n+   mv \"$TMPFILE-plat\" $TMPFILE\n+fi\n+\n #here we extract the filenames from the signature file\n FILES=$(awk '{print $2}' \"$TMPFILE\")\n \n #and download these one by one\n for file in $FILES\n do\n-   wget --quiet -N \"$BASEDIR$file\"\n+   echo \"Downloading $file\"\n+   wget --quiet -N \"$HOST1$BASEDIR$file\"\n done\n \n #check hashes\n@@ -116,7 +168,7 @@ fi\n \n if [ -n \"$2\" ]; then\n    echo \"Clean up the binaries\"\n-   clean_up $FILES $SIGNATUREFILENAME $TMPFILE\n+   clean_up $FILES $SIGNATUREFILENAME $SIGNATUREFILENAME.2 $TMPFILE\n else\n    echo \"Keep the binaries in $WORKINGDIR\"\n    clean_up $TMPFILE"
      },
      {
        "sha": "7f484724a49097b4ed403f16141ad1f2f2ec7b92",
        "filename": "depends/packages/expat.mk",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/depends/packages/expat.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/depends/packages/expat.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/expat.mk?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -1,8 +1,8 @@\n package=expat\n-$(package)_version=2.2.0\n+$(package)_version=2.2.1\n $(package)_download_path=https://downloads.sourceforge.net/project/expat/expat/$($(package)_version)\n $(package)_file_name=$(package)-$($(package)_version).tar.bz2\n-$(package)_sha256_hash=d9e50ff2d19b3538bd2127902a89987474e1a4db8e43a66a4d1a712ab9a504ff\n+$(package)_sha256_hash=1868cadae4c82a018e361e2b2091de103cd820aaacb0d6cfa49bd2cd83978885\n \n define $(package)_set_vars\n $(package)_config_opts=--disable-static"
      },
      {
        "sha": "caf6782886520aa050869489f237a8323b250475",
        "filename": "doc/REST-interface.md",
        "status": "modified",
        "additions": 16,
        "deletions": 12,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/doc/REST-interface.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/doc/REST-interface.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/REST-interface.md?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -40,11 +40,13 @@ Only supports JSON as output format.\n * headers : (numeric) the current number of headers we have validated\n * bestblockhash : (string) the hash of the currently best block\n * difficulty : (numeric) the current difficulty\n+* mediantime : (numeric) the median time of the 11 blocks before the most recent block on the blockchain\n * verificationprogress : (numeric) estimate of verification progress [0..1]\n * chainwork : (string) total amount of work in active chain, in hexadecimal\n * pruned : (boolean) if the blocks are subject to pruning\n * pruneheight : (numeric) heighest block available\n * softforks : (array) status of softforks in progress\n+* bip9_softforks : (object) status of BIP9 softforks in progress\n \n ####Query UTXO set\n `GET /rest/getutxos/<checkmempool>/<txid>-<n>/<txid>-<n>/.../<txid>-<n>.<bin|hex|json>`\n@@ -57,25 +59,25 @@ Example:\n ```\n $ curl localhost:18332/rest/getutxos/checkmempool/b2cdfd7b89def827ff8af7cd9bff7627ff72e5e8b0f71210f92ea7a4000c5d75-0.json 2>/dev/null | json_pp\n {\n-   \"chaintipHash\" : \"00000000fb01a7f3745a717f8caebee056c484e6e0bfe4a9591c235bb70506fb\",\n    \"chainHeight\" : 325347,\n+   \"chaintipHash\" : \"00000000fb01a7f3745a717f8caebee056c484e6e0bfe4a9591c235bb70506fb\",\n+   \"bitmap\": \"1\",\n    \"utxos\" : [\n       {\n+         \"txvers\" : 1\n+         \"height\" : 2147483647,\n+         \"value\" : 8.8687,\t\t \n          \"scriptPubKey\" : {\n-            \"addresses\" : [\n-               \"mi7as51dvLJsizWnTMurtRmrP8hG2m1XvD\"\n-            ],\n-            \"type\" : \"pubkeyhash\",\n+            \"asm\" : \"OP_DUP OP_HASH160 1c7cebb529b86a04c683dfa87be49de35bcf589e OP_EQUALVERIFY OP_CHECKSIG\",\n             \"hex\" : \"76a9141c7cebb529b86a04c683dfa87be49de35bcf589e88ac\",\n             \"reqSigs\" : 1,\n-            \"asm\" : \"OP_DUP OP_HASH160 1c7cebb529b86a04c683dfa87be49de35bcf589e OP_EQUALVERIFY OP_CHECKSIG\"\n-         },\n-         \"value\" : 8.8687,\n-         \"height\" : 2147483647,\n-         \"txvers\" : 1\n+            \"type\" : \"pubkeyhash\",\n+            \"addresses\" : [\n+               \"mi7as51dvLJsizWnTMurtRmrP8hG2m1XvD\"\n+            ]\n+         }\n       }\n-   ],\n-   \"bitmap\" : \"1\"\n+   ]\n }\n ```\n \n@@ -87,6 +89,8 @@ Only supports JSON as output format.\n * size : (numeric) the number of transactions in the TX mempool\n * bytes : (numeric) size of the TX mempool in bytes\n * usage : (numeric) total TX mempool memory usage\n+* maxmempool : (numeric) maximum memory usage for the mempool in bytes\n+* mempoolminfee : (numeric) minimum feerate (BTC per KB) for tx to be accepted\n \n `GET /rest/mempool/contents.json`\n "
      },
      {
        "sha": "81bdcc9fdb936f656be7ac38b28a52762b7f2f1a",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 25,
        "deletions": 2,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -68,7 +68,7 @@ public:\n         return true;\n     }\n }\n-}\n+} // namespace foo\n ```\n \n Doxygen comments\n@@ -287,7 +287,7 @@ General C++\n \n - Assertions should not have side-effects\n \n-  - *Rationale*: Even though the source code is set to to refuse to compile\n+  - *Rationale*: Even though the source code is set to refuse to compile\n     with assertions disabled, having side-effects in assertions is unexpected and\n     makes the code harder to understand\n \n@@ -425,11 +425,34 @@ Source code organization\n \n   - *Rationale*: Shorter and simpler header files are easier to read, and reduce compile time\n \n+- Every `.cpp` and `.h` file should `#include` every header file it directly uses classes, functions or other\n+  definitions from, even if those headers are already included indirectly through other headers. One exception\n+  is that a `.cpp` file does not need to re-include the includes already included in its corresponding `.h` file.\n+\n+  - *Rationale*: Excluding headers because they are already indirectly included results in compilation\n+    failures when those indirect dependencies change. Furthermore, it obscures what the real code\n+    dependencies are.\n+\n - Don't import anything into the global namespace (`using namespace ...`). Use\n   fully specified types such as `std::string`.\n \n   - *Rationale*: Avoids symbol conflicts\n \n+- Terminate namespaces with a comment (`// namespace mynamespace`). The comment\n+  should be placed on the same line as the brace closing the namespace, e.g.\n+\n+```c++\n+namespace mynamespace {\n+    ...\n+} // namespace mynamespace\n+\n+namespace {\n+    ...\n+} // namespace\n+```\n+\n+  - *Rationale*: Avoids confusion about the namespace context\n+\n GUI\n -----\n "
      },
      {
        "sha": "9f9afaf04f444dd1e7a31eec280b13e91fcae3b2",
        "filename": "doc/gitian-building.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/doc/gitian-building.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/doc/gitian-building.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/gitian-building.md?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -131,6 +131,7 @@ To select a different button, press `Tab`.\n   - Leave domain name empty.\n \n ![](gitian-building/debian_install_5_configure_the_network.png)\n+![](gitian-building/debian_install_6_domain_name.png)\n \n - Choose a root password and enter it twice (remember it for later)\n "
      },
      {
        "sha": "0ad554b7738c17a4017b57234fce1132f9a9ed45",
        "filename": "doc/release-notes/release-notes-0.14.2.md",
        "status": "added",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/doc/release-notes/release-notes-0.14.2.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/doc/release-notes/release-notes-0.14.2.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.14.2.md?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -0,0 +1,102 @@\n+Bitcoin Core version 0.14.2 is now available from:\n+\n+  <https://bitcoin.org/bin/bitcoin-core-0.14.2/>\n+\n+This is a new minor version release, including various bugfixes and\n+performance improvements, as well as updated translations.\n+\n+Please report bugs using the issue tracker at github:\n+\n+  <https://github.com/bitcoin/bitcoin/issues>\n+\n+To receive security and update notifications, please subscribe to:\n+\n+  <https://bitcoincore.org/en/list/announcements/join/>\n+\n+Compatibility\n+==============\n+\n+Bitcoin Core is extensively tested on multiple operating systems using\n+the Linux kernel, macOS 10.8+, and Windows Vista and later.\n+\n+Microsoft ended support for Windows XP on [April 8th, 2014](https://www.microsoft.com/en-us/WindowsForBusiness/end-of-xp-support),\n+No attempt is made to prevent installing or running the software on Windows XP, you\n+can still do so at your own risk but be aware that there are known instabilities and issues.\n+Please do not report issues about Windows XP to the issue tracker.\n+\n+Bitcoin Core should also work on most other Unix-like systems but is not\n+frequently tested on them.\n+\n+Notable changes\n+===============\n+\n+miniupnp CVE-2017-8798\n+----------------------------\n+\n+Bundled miniupnpc was updated to 2.0.20170509. This fixes an integer signedness error\n+(present in MiniUPnPc v1.4.20101221 through v2.0) that allows remote attackers\n+(within the LAN) to cause a denial of service or possibly have unspecified\n+other impact.\n+\n+This only affects users that have explicitly enabled UPnP through the GUI\n+setting or through the `-upnp` option, as since the last UPnP vulnerability\n+(in Bitcoin Core 0.10.3) it has been disabled by default.\n+\n+If you use this option, it is recommended to upgrade to this version as soon as\n+possible.\n+\n+Known Bugs\n+==========\n+\n+Since 0.14.0 the approximate transaction fee shown in Bitcoin-Qt when using coin\n+control and smart fee estimation does not reflect any change in target from the\n+smart fee slider. It will only present an approximate fee calculated using the\n+default target. The fee calculated using the correct target is still applied to\n+the transaction and shown in the final send confirmation dialog.\n+\n+0.14.2 Change log\n+=================\n+\n+Detailed release notes follow. This overview includes changes that affect\n+behavior, not code moves, refactors and string updates. For convenience in locating\n+the code changes and accompanying discussion, both the pull request and\n+git merge commit are mentioned.\n+\n+### RPC and other APIs\n+- #10410 `321419b` Fix importwallet edge case rescan bug (ryanofsky)\n+\n+### P2P protocol and network code\n+- #10424 `37a8fc5` Populate services in GetLocalAddress (morcos)\n+- #10441 `9e3ad50` Only enforce expected services for half of outgoing connections (theuni)\n+\n+### Build system\n+- #10414 `ffb0c4b` miniupnpc 2.0.20170509 (fanquake)\n+- #10228 `ae479bc` Regenerate bitcoin-config.h as necessary (theuni)\n+\n+### Miscellaneous\n+- #10245 `44a17f2` Minor fix in build documentation for FreeBSD 11 (shigeya)\n+- #10215 `0aee4a1` Check interruptNet during dnsseed lookups (TheBlueMatt)\n+\n+### GUI\n+- #10231 `1e936d7` Reduce a significant cs_main lock freeze (jonasschnelli)\n+\n+### Wallet\n+- #10294 `1847642` Unset change position when there is no change (instagibbs)\n+\n+Credits\n+=======\n+\n+Thanks to everyone who directly contributed to this release:\n+\n+- Alex Morcos\n+- Cory Fields\n+- fanquake\n+- Gregory Sanders\n+- Jonas Schnelli\n+- Matt Corallo\n+- Russell Yanofsky\n+- Shigeya Suzuki\n+- Wladimir J. van der Laan\n+\n+As well as everyone that helped translating on [Transifex](https://www.transifex.com/projects/p/bitcoin/).\n+"
      },
      {
        "sha": "f54e249a0c1e77003e93d9f9a0f1325caa859e42",
        "filename": "share/pixmaps/nsis-header.bmp",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/share/pixmaps/nsis-header.bmp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/share/pixmaps/nsis-header.bmp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/pixmaps/nsis-header.bmp?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "14349528853f1198bfdbf7f9f180a5618820ef76",
        "filename": "share/pixmaps/nsis-wizard.bmp",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/share/pixmaps/nsis-wizard.bmp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/share/pixmaps/nsis-wizard.bmp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/pixmaps/nsis-wizard.bmp?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "2d2ee67035991568ce34df826feadb88e0e10f74",
        "filename": "src/.clang-format",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/.clang-format",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/.clang-format",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/.clang-format?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -23,7 +23,6 @@ ContinuationIndentWidth: 4\n Cpp11BracedListStyle: true\n DerivePointerAlignment: false\n DisableFormat:   false\n-ForEachMacros:   [ foreach, Q_FOREACH, BOOST_FOREACH, BOOST_REVERSE_FOREACH ]\n IndentCaseLabels: false\n IndentFunctionDeclarationAfterType: false\n IndentWidth:     4\n@@ -47,6 +46,6 @@ SpacesInAngles:  false\n SpacesInContainerLiterals: true\n SpacesInCStyleCastParentheses: false\n SpacesInParentheses: false\n-Standard:        Cpp03\n+Standard:        Cpp11\n TabWidth:        8\n UseTab:          Never"
      },
      {
        "sha": "06b09404a767fe0bf591e6b07d26b657a881bae7",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -124,9 +124,11 @@ BITCOIN_CORE_H = \\\n   pow.h \\\n   protocol.h \\\n   random.h \\\n+  reverse_iterator.h \\\n   reverselock.h \\\n   rpc/blockchain.h \\\n   rpc/client.h \\\n+  rpc/mining.h \\\n   rpc/protocol.h \\\n   rpc/server.h \\\n   rpc/register.h \\\n@@ -380,6 +382,7 @@ bitcoind_LDADD = \\\n   $(LIBBITCOIN_CONSENSUS) \\\n   $(LIBBITCOIN_CRYPTO) \\\n   $(LIBLEVELDB) \\\n+  $(LIBLEVELDB_SSE42) \\\n   $(LIBMEMENV) \\\n   $(LIBSECP256K1)\n "
      },
      {
        "sha": "2b1f70b25bc4588d26470216dc9c07d0b4b5c676",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -39,6 +39,7 @@ bench_bench_bitcoin_LDADD = \\\n   $(LIBBITCOIN_CONSENSUS) \\\n   $(LIBBITCOIN_CRYPTO) \\\n   $(LIBLEVELDB) \\\n+  $(LIBLEVELDB_SSE42) \\\n   $(LIBMEMENV) \\\n   $(LIBSECP256K1) \\\n   $(LIBUNIVALUE)"
      },
      {
        "sha": "833f3d2a10cac9465c72045bc244e3efc76156c8",
        "filename": "src/Makefile.leveldb.include",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/Makefile.leveldb.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/Makefile.leveldb.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.leveldb.include?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -4,12 +4,15 @@\n \n LIBLEVELDB_INT = leveldb/libleveldb.a\n LIBMEMENV_INT  = leveldb/libmemenv.a\n+LIBLEVELDB_SSE42_INT  = leveldb/libleveldb_sse42.a\n \n EXTRA_LIBRARIES += $(LIBLEVELDB_INT)\n EXTRA_LIBRARIES += $(LIBMEMENV_INT)\n+EXTRA_LIBRARIES += $(LIBLEVELDB_SSE42_INT)\n \n LIBLEVELDB += $(LIBLEVELDB_INT)\n LIBMEMENV += $(LIBMEMENV_INT)\n+LIBLEVELDB_SSE42 = $(LIBLEVELDB_SSE42_INT)\n \n LEVELDB_CPPFLAGS += -I$(srcdir)/leveldb/include\n LEVELDB_CPPFLAGS += -I$(srcdir)/leveldb/helpers/memenv\n@@ -74,6 +77,7 @@ leveldb_libleveldb_a_SOURCES += leveldb/table/merger.h\n leveldb_libleveldb_a_SOURCES += leveldb/table/format.h\n leveldb_libleveldb_a_SOURCES += leveldb/table/iterator_wrapper.h\n leveldb_libleveldb_a_SOURCES += leveldb/util/crc32c.h\n+leveldb_libleveldb_a_SOURCES += leveldb/util/env_posix_test_helper.h\n leveldb_libleveldb_a_SOURCES += leveldb/util/arena.h\n leveldb_libleveldb_a_SOURCES += leveldb/util/random.h\n leveldb_libleveldb_a_SOURCES += leveldb/util/posix_logger.h\n@@ -135,3 +139,11 @@ leveldb_libmemenv_a_CPPFLAGS = $(leveldb_libleveldb_a_CPPFLAGS)\n leveldb_libmemenv_a_CXXFLAGS = $(leveldb_libleveldb_a_CXXFLAGS)\n leveldb_libmemenv_a_SOURCES =  leveldb/helpers/memenv/memenv.cc\n leveldb_libmemenv_a_SOURCES += leveldb/helpers/memenv/memenv.h\n+\n+leveldb_libleveldb_sse42_a_CPPFLAGS = $(leveldb_libleveldb_a_CPPFLAGS)\n+leveldb_libleveldb_sse42_a_CXXFLAGS = $(leveldb_libleveldb_a_CXXFLAGS)\n+if ENABLE_HWCRC32\n+leveldb_libleveldb_sse42_a_CPPFLAGS += -DLEVELDB_PLATFORM_POSIX_SSE\n+leveldb_libleveldb_sse42_a_CXXFLAGS += $(SSE42_CXXFLAGS)\n+endif\n+leveldb_libleveldb_sse42_a_SOURCES =  leveldb/port/port_posix_sse.cc"
      },
      {
        "sha": "e4b64c1ca79c3e6ab98e9c5d3662b9c3f9a315bb",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -407,7 +407,7 @@ endif\n if ENABLE_ZMQ\n qt_bitcoin_qt_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n-qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n+qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) \\\n   $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n   $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n qt_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)"
      },
      {
        "sha": "02f30bc9527b10ade4e91c36a1da2141539908a6",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -60,7 +60,7 @@ if ENABLE_ZMQ\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) \\\n-  $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n+  $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n   $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n   $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n qt_test_test_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)"
      },
      {
        "sha": "6415b3d2e3399fa9971e017e979bd9a84bf8f96c",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -96,12 +96,13 @@ endif\n \n test_test_bitcoin_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)\n test_test_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -I$(builddir)/test/ $(TESTDEFS) $(EVENT_CFLAGS)\n-test_test_bitcoin_LDADD = $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBMEMENV) \\\n-  $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n-test_test_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_test_bitcoin_LDADD =\n if ENABLE_WALLET\n test_test_bitcoin_LDADD += $(LIBBITCOIN_WALLET)\n endif\n+test_test_bitcoin_LDADD += $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) \\\n+  $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n+test_test_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n \n test_test_bitcoin_LDADD += $(LIBBITCOIN_CONSENSUS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS)\n test_test_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) -static"
      },
      {
        "sha": "7f85c16585aa28b471d16c15b689ba23da6391a8",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 71,
        "deletions": 143,
        "changes": 214,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -15,25 +15,31 @@\n #include \"tinyformat.h\"\n #include \"util.h\"\n \n+namespace {\n \n-CBanDB::CBanDB()\n+template <typename Stream, typename Data>\n+bool SerializeDB(Stream& stream, const Data& data)\n {\n-    pathBanlist = GetDataDir() / \"banlist.dat\";\n+    // Write and commit header, data\n+    try {\n+        CHashWriter hasher(SER_DISK, CLIENT_VERSION);\n+        stream << FLATDATA(Params().MessageStart()) << data;\n+        hasher << FLATDATA(Params().MessageStart()) << data;\n+        stream << hasher.GetHash();\n+    } catch (const std::exception& e) {\n+        return error(\"%s: Serialize or I/O error - %s\", __func__, e.what());\n+    }\n+\n+    return true;\n }\n \n-bool CBanDB::Write(const banmap_t& banSet)\n+template <typename Data>\n+bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data& data)\n {\n     // Generate random temporary filename\n     unsigned short randv = 0;\n     GetRandBytes((unsigned char*)&randv, sizeof(randv));\n-    std::string tmpfn = strprintf(\"banlist.dat.%04x\", randv);\n-\n-    // serialize banlist, checksum data up to that point, then append csum\n-    CDataStream ssBanlist(SER_DISK, CLIENT_VERSION);\n-    ssBanlist << FLATDATA(Params().MessageStart());\n-    ssBanlist << banSet;\n-    uint256 hash = Hash(ssBanlist.begin(), ssBanlist.end());\n-    ssBanlist << hash;\n+    std::string tmpfn = strprintf(\"%s.%04x\", prefix, randv);\n \n     // open temp output file, and associate with CAutoFile\n     fs::path pathTmp = GetDataDir() / tmpfn;\n@@ -42,69 +48,41 @@ bool CBanDB::Write(const banmap_t& banSet)\n     if (fileout.IsNull())\n         return error(\"%s: Failed to open file %s\", __func__, pathTmp.string());\n \n-    // Write and commit header, data\n-    try {\n-        fileout << ssBanlist;\n-    }\n-    catch (const std::exception& e) {\n-        return error(\"%s: Serialize or I/O error - %s\", __func__, e.what());\n-    }\n+    // Serialize\n+    if (!SerializeDB(fileout, data)) return false;\n     FileCommit(fileout.Get());\n     fileout.fclose();\n \n-    // replace existing banlist.dat, if any, with new banlist.dat.XXXX\n-    if (!RenameOver(pathTmp, pathBanlist))\n+    // replace existing file, if any, with new file\n+    if (!RenameOver(pathTmp, path))\n         return error(\"%s: Rename-into-place failed\", __func__);\n \n     return true;\n }\n \n-bool CBanDB::Read(banmap_t& banSet)\n+template <typename Stream, typename Data>\n+bool DeserializeDB(Stream& stream, Data& data, bool fCheckSum = true)\n {\n-    // open input file, and associate with CAutoFile\n-    FILE *file = fsbridge::fopen(pathBanlist, \"rb\");\n-    CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n-    if (filein.IsNull())\n-        return error(\"%s: Failed to open file %s\", __func__, pathBanlist.string());\n-\n-    // use file size to size memory buffer\n-    uint64_t fileSize = fs::file_size(pathBanlist);\n-    uint64_t dataSize = 0;\n-    // Don't try to resize to a negative number if file is small\n-    if (fileSize >= sizeof(uint256))\n-        dataSize = fileSize - sizeof(uint256);\n-    std::vector<unsigned char> vchData;\n-    vchData.resize(dataSize);\n-    uint256 hashIn;\n-\n-    // read data and checksum from file\n-    try {\n-        filein.read((char *)&vchData[0], dataSize);\n-        filein >> hashIn;\n-    }\n-    catch (const std::exception& e) {\n-        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n-    }\n-    filein.fclose();\n-\n-    CDataStream ssBanlist(vchData, SER_DISK, CLIENT_VERSION);\n-\n-    // verify stored checksum matches input data\n-    uint256 hashTmp = Hash(ssBanlist.begin(), ssBanlist.end());\n-    if (hashIn != hashTmp)\n-        return error(\"%s: Checksum mismatch, data corrupted\", __func__);\n-\n-    unsigned char pchMsgTmp[4];\n     try {\n+        CHashVerifier<Stream> verifier(&stream);\n         // de-serialize file header (network specific magic number) and ..\n-        ssBanlist >> FLATDATA(pchMsgTmp);\n-\n+        unsigned char pchMsgTmp[4];\n+        verifier >> FLATDATA(pchMsgTmp);\n         // ... verify the network matches ours\n         if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp)))\n             return error(\"%s: Invalid network magic number\", __func__);\n \n-        // de-serialize ban data\n-        ssBanlist >> banSet;\n+        // de-serialize data\n+        verifier >> data;\n+\n+        // verify checksum\n+        if (fCheckSum) {\n+            uint256 hashTmp;\n+            stream >> hashTmp;\n+            if (hashTmp != verifier.GetHash()) {\n+                return error(\"%s: Checksum mismatch, data corrupted\", __func__);\n+            }\n+        }\n     }\n     catch (const std::exception& e) {\n         return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n@@ -113,106 +91,56 @@ bool CBanDB::Read(banmap_t& banSet)\n     return true;\n }\n \n-CAddrDB::CAddrDB()\n+template <typename Data>\n+bool DeserializeFileDB(const fs::path& path, Data& data)\n {\n-    pathAddr = GetDataDir() / \"peers.dat\";\n+    // open input file, and associate with CAutoFile\n+    FILE *file = fsbridge::fopen(path, \"rb\");\n+    CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n+    if (filein.IsNull())\n+        return error(\"%s: Failed to open file %s\", __func__, path.string());\n+\n+    return DeserializeDB(filein, data);\n }\n \n-bool CAddrDB::Write(const CAddrMan& addr)\n-{\n-    // Generate random temporary filename\n-    unsigned short randv = 0;\n-    GetRandBytes((unsigned char*)&randv, sizeof(randv));\n-    std::string tmpfn = strprintf(\"peers.dat.%04x\", randv);\n+}\n \n-    // serialize addresses, checksum data up to that point, then append csum\n-    CDataStream ssPeers(SER_DISK, CLIENT_VERSION);\n-    ssPeers << FLATDATA(Params().MessageStart());\n-    ssPeers << addr;\n-    uint256 hash = Hash(ssPeers.begin(), ssPeers.end());\n-    ssPeers << hash;\n+CBanDB::CBanDB()\n+{\n+    pathBanlist = GetDataDir() / \"banlist.dat\";\n+}\n \n-    // open temp output file, and associate with CAutoFile\n-    fs::path pathTmp = GetDataDir() / tmpfn;\n-    FILE *file = fsbridge::fopen(pathTmp, \"wb\");\n-    CAutoFile fileout(file, SER_DISK, CLIENT_VERSION);\n-    if (fileout.IsNull())\n-        return error(\"%s: Failed to open file %s\", __func__, pathTmp.string());\n+bool CBanDB::Write(const banmap_t& banSet)\n+{\n+    return SerializeFileDB(\"banlist\", pathBanlist, banSet);\n+}\n \n-    // Write and commit header, data\n-    try {\n-        fileout << ssPeers;\n-    }\n-    catch (const std::exception& e) {\n-        return error(\"%s: Serialize or I/O error - %s\", __func__, e.what());\n-    }\n-    FileCommit(fileout.Get());\n-    fileout.fclose();\n+bool CBanDB::Read(banmap_t& banSet)\n+{\n+    return DeserializeFileDB(pathBanlist, banSet);\n+}\n \n-    // replace existing peers.dat, if any, with new peers.dat.XXXX\n-    if (!RenameOver(pathTmp, pathAddr))\n-        return error(\"%s: Rename-into-place failed\", __func__);\n+CAddrDB::CAddrDB()\n+{\n+    pathAddr = GetDataDir() / \"peers.dat\";\n+}\n \n-    return true;\n+bool CAddrDB::Write(const CAddrMan& addr)\n+{\n+    return SerializeFileDB(\"peers\", pathAddr, addr);\n }\n \n bool CAddrDB::Read(CAddrMan& addr)\n {\n-    // open input file, and associate with CAutoFile\n-    FILE *file = fsbridge::fopen(pathAddr, \"rb\");\n-    CAutoFile filein(file, SER_DISK, CLIENT_VERSION);\n-    if (filein.IsNull())\n-        return error(\"%s: Failed to open file %s\", __func__, pathAddr.string());\n-\n-    // use file size to size memory buffer\n-    uint64_t fileSize = fs::file_size(pathAddr);\n-    uint64_t dataSize = 0;\n-    // Don't try to resize to a negative number if file is small\n-    if (fileSize >= sizeof(uint256))\n-        dataSize = fileSize - sizeof(uint256);\n-    std::vector<unsigned char> vchData;\n-    vchData.resize(dataSize);\n-    uint256 hashIn;\n-\n-    // read data and checksum from file\n-    try {\n-        filein.read((char *)&vchData[0], dataSize);\n-        filein >> hashIn;\n-    }\n-    catch (const std::exception& e) {\n-        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n-    }\n-    filein.fclose();\n-\n-    CDataStream ssPeers(vchData, SER_DISK, CLIENT_VERSION);\n-\n-    // verify stored checksum matches input data\n-    uint256 hashTmp = Hash(ssPeers.begin(), ssPeers.end());\n-    if (hashIn != hashTmp)\n-        return error(\"%s: Checksum mismatch, data corrupted\", __func__);\n-\n-    return Read(addr, ssPeers);\n+    return DeserializeFileDB(pathAddr, addr);\n }\n \n bool CAddrDB::Read(CAddrMan& addr, CDataStream& ssPeers)\n {\n-    unsigned char pchMsgTmp[4];\n-    try {\n-        // de-serialize file header (network specific magic number) and ..\n-        ssPeers >> FLATDATA(pchMsgTmp);\n-\n-        // ... verify the network matches ours\n-        if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp)))\n-            return error(\"%s: Invalid network magic number\", __func__);\n-\n-        // de-serialize address data into one CAddrMan object\n-        ssPeers >> addr;\n-    }\n-    catch (const std::exception& e) {\n-        // de-serialization has failed, ensure addrman is left in a clean state\n+    bool ret = DeserializeDB(ssPeers, addr, false);\n+    if (!ret) {\n+        // Ensure addrman is left in a clean state\n         addr.Clear();\n-        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n     }\n-\n-    return true;\n+    return ret;\n }"
      },
      {
        "sha": "6cb36dfac4e60ee8512f8dfdac28101aa6ecc48c",
        "filename": "src/addrdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/addrdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/addrdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -85,7 +85,7 @@ class CAddrDB\n     CAddrDB();\n     bool Write(const CAddrMan& addr);\n     bool Read(CAddrMan& addr);\n-    bool Read(CAddrMan& addr, CDataStream& ssPeers);\n+    static bool Read(CAddrMan& addr, CDataStream& ssPeers);\n };\n \n /** Access to the banlist database (banlist.dat) */"
      },
      {
        "sha": "b4952af6f48906a29db02ce9a86766e01d7d92ca",
        "filename": "src/arith_uint256.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/arith_uint256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/arith_uint256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -15,6 +15,8 @@\n template <unsigned int BITS>\n base_uint<BITS>::base_uint(const std::string& str)\n {\n+    static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n+\n     SetHex(str);\n }\n "
      },
      {
        "sha": "c7734035df2e0bdf133598bd4581c0146ce18425",
        "filename": "src/arith_uint256.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/arith_uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/arith_uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/arith_uint256.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -31,12 +31,16 @@ class base_uint\n \n     base_uint()\n     {\n+        static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n+\n         for (int i = 0; i < WIDTH; i++)\n             pn[i] = 0;\n     }\n \n     base_uint(const base_uint& b)\n     {\n+        static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n+\n         for (int i = 0; i < WIDTH; i++)\n             pn[i] = b.pn[i];\n     }\n@@ -50,6 +54,8 @@ class base_uint\n \n     base_uint(uint64_t b)\n     {\n+        static_assert(BITS/32 > 0 && BITS%32 == 0, \"Template parameter BITS must be a positive multiple of 32.\");\n+\n         pn[0] = (unsigned int)b;\n         pn[1] = (unsigned int)(b >> 32);\n         for (int i = 2; i < WIDTH; i++)\n@@ -174,7 +180,7 @@ class base_uint\n     {\n         // prefix operator\n         int i = 0;\n-        while (++pn[i] == 0 && i < WIDTH-1)\n+        while (i < WIDTH && ++pn[i] == 0)\n             i++;\n         return *this;\n     }\n@@ -191,7 +197,7 @@ class base_uint\n     {\n         // prefix operator\n         int i = 0;\n-        while (--pn[i] == (uint32_t)-1 && i < WIDTH-1)\n+        while (i < WIDTH && --pn[i] == (uint32_t)-1)\n             i++;\n         return *this;\n     }"
      },
      {
        "sha": "17022a6bc161f084e4672882ce4f6e1060fe3d61",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -110,7 +110,7 @@ std::string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend)\n \n std::string EncodeBase58(const std::vector<unsigned char>& vch)\n {\n-    return EncodeBase58(&vch[0], &vch[0] + vch.size());\n+    return EncodeBase58(vch.data(), vch.data() + vch.size());\n }\n \n bool DecodeBase58(const std::string& str, std::vector<unsigned char>& vchRet)\n@@ -160,7 +160,7 @@ void CBase58Data::SetData(const std::vector<unsigned char>& vchVersionIn, const\n     vchVersion = vchVersionIn;\n     vchData.resize(nSize);\n     if (!vchData.empty())\n-        memcpy(&vchData[0], pdata, nSize);\n+        memcpy(vchData.data(), pdata, nSize);\n }\n \n void CBase58Data::SetData(const std::vector<unsigned char>& vchVersionIn, const unsigned char* pbegin, const unsigned char* pend)\n@@ -180,8 +180,8 @@ bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes)\n     vchVersion.assign(vchTemp.begin(), vchTemp.begin() + nVersionBytes);\n     vchData.resize(vchTemp.size() - nVersionBytes);\n     if (!vchData.empty())\n-        memcpy(&vchData[0], &vchTemp[nVersionBytes], vchData.size());\n-    memory_cleanse(&vchTemp[0], vchTemp.size());\n+        memcpy(vchData.data(), vchTemp.data() + nVersionBytes, vchData.size());\n+    memory_cleanse(vchTemp.data(), vchTemp.size());\n     return true;\n }\n \n@@ -225,7 +225,7 @@ class CBitcoinAddressVisitor : public boost::static_visitor<bool>\n     bool operator()(const CNoDestination& no) const { return false; }\n };\n \n-} // anon namespace\n+} // namespace\n \n bool CBitcoinAddress::Set(const CKeyID& id)\n {\n@@ -262,7 +262,7 @@ CTxDestination CBitcoinAddress::Get() const\n     if (!IsValid())\n         return CNoDestination();\n     uint160 id;\n-    memcpy(&id, &vchData[0], 20);\n+    memcpy(&id, vchData.data(), 20);\n     if (vchVersion == Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))\n         return CKeyID(id);\n     else if (vchVersion == Params().Base58Prefix(CChainParams::SCRIPT_ADDRESS))\n@@ -276,7 +276,7 @@ bool CBitcoinAddress::GetKeyID(CKeyID& keyID) const\n     if (!IsValid() || vchVersion != Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS))\n         return false;\n     uint160 id;\n-    memcpy(&id, &vchData[0], 20);\n+    memcpy(&id, vchData.data(), 20);\n     keyID = CKeyID(id);\n     return true;\n }"
      },
      {
        "sha": "4de5cc6ce5f9f3e4b8738bfa399743f5a8284b9d",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -148,7 +148,7 @@ template<typename K, int Size, CChainParams::Base58Type Type> class CBitcoinExtK\n         K ret;\n         if (vchData.size() == Size) {\n             // If base58 encoded data does not hold an ext key, return a !IsValid() key\n-            ret.Decode(&vchData[0]);\n+            ret.Decode(vchData.data());\n         }\n         return ret;\n     }"
      },
      {
        "sha": "65e27a615d9344c765068a95676691a19314504a",
        "filename": "src/bench/base58.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 12,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/bench/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/bench/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/base58.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -7,34 +7,37 @@\n #include \"validation.h\"\n #include \"base58.h\"\n \n+#include <array>\n #include <vector>\n #include <string>\n \n \n static void Base58Encode(benchmark::State& state)\n {\n-    unsigned char buff[32] = {\n-        17, 79, 8, 99, 150, 189, 208, 162, 22, 23, 203, 163, 36, 58, 147,\n-        227, 139, 2, 215, 100, 91, 38, 11, 141, 253, 40, 117, 21, 16, 90,\n-        200, 24\n+    static const std::array<unsigned char, 32> buff = {\n+        {\n+            17, 79, 8, 99, 150, 189, 208, 162, 22, 23, 203, 163, 36, 58, 147,\n+            227, 139, 2, 215, 100, 91, 38, 11, 141, 253, 40, 117, 21, 16, 90,\n+            200, 24\n+        }\n     };\n-    unsigned char* b = buff;\n     while (state.KeepRunning()) {\n-        EncodeBase58(b, b + 32);\n+        EncodeBase58(buff.begin(), buff.end());\n     }\n }\n \n \n static void Base58CheckEncode(benchmark::State& state)\n {\n-    unsigned char buff[32] = {\n-        17, 79, 8, 99, 150, 189, 208, 162, 22, 23, 203, 163, 36, 58, 147,\n-        227, 139, 2, 215, 100, 91, 38, 11, 141, 253, 40, 117, 21, 16, 90,\n-        200, 24\n+    static const std::array<unsigned char, 32> buff = {\n+        {\n+            17, 79, 8, 99, 150, 189, 208, 162, 22, 23, 203, 163, 36, 58, 147,\n+            227, 139, 2, 215, 100, 91, 38, 11, 141, 253, 40, 117, 21, 16, 90,\n+            200, 24\n+        }\n     };\n-    unsigned char* b = buff;\n     std::vector<unsigned char> vch;\n-    vch.assign(b, b + 32);\n+    vch.assign(buff.begin(), buff.end());\n     while (state.KeepRunning()) {\n         EncodeBase58Check(vch);\n     }"
      },
      {
        "sha": "226861aa7f745a5edb94155ef17dd86494537fd9",
        "filename": "src/bench/bench_bitcoin.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/bench/bench_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/bench/bench_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/bench_bitcoin.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -7,10 +7,12 @@\n #include \"key.h\"\n #include \"validation.h\"\n #include \"util.h\"\n+#include \"random.h\"\n \n int\n main(int argc, char** argv)\n {\n+    RandomInit();\n     ECC_Start();\n     SetupEnvironment();\n     fPrintToDebugLog = false; // don't want to write to debug.log file"
      },
      {
        "sha": "7bb1b93668cf7472dd8781cf750596d204d5314a",
        "filename": "src/bench/checkblock.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/bench/checkblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/bench/checkblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/checkblock.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -11,7 +11,7 @@\n \n namespace block_bench {\n #include \"bench/data/block413567.raw.h\"\n-}\n+} // namespace block_bench\n \n // These are the two major time-sinks which happen after we have fully received\n // a block off the wire, but before we can relay the block on to peers using"
      },
      {
        "sha": "f8956508f68216fba8b4534419ffafbac62002ff",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -5,7 +5,6 @@\n #include \"bench.h\"\n #include \"wallet/wallet.h\"\n \n-#include <boost/foreach.hpp>\n #include <set>\n \n static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<COutput>& vCoins)\n@@ -39,7 +38,7 @@ static void CoinSelection(benchmark::State& state)\n \n     while (state.KeepRunning()) {\n         // Empty wallet.\n-        BOOST_FOREACH (COutput output, vCoins)\n+        for (COutput output : vCoins)\n             delete output.tx;\n         vCoins.clear();\n "
      },
      {
        "sha": "ef7381c1201db0d37438c7de10ca1d17e221333b",
        "filename": "src/bench/verify_script.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/bench/verify_script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/bench/verify_script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/verify_script.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -11,6 +11,8 @@\n #include \"script/sign.h\"\n #include \"streams.h\"\n \n+#include <array>\n+\n // FIXME: Dedup with BuildCreditingTransaction in test/script_tests.cpp.\n static CMutableTransaction BuildCreditingTransaction(const CScript& scriptPubKey)\n {\n@@ -55,8 +57,12 @@ static void VerifyScriptBench(benchmark::State& state)\n \n     // Keypair.\n     CKey key;\n-    const unsigned char vchKey[32] = {0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1};\n-    key.Set(vchKey, vchKey + 32, false);\n+    static const std::array<unsigned char, 32> vchKey = {\n+        {\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1\n+        }\n+    };\n+    key.Set(vchKey.begin(), vchKey.end(), false);\n     CPubKey pubkey = key.GetPubKey();\n     uint160 pubkeyHash;\n     CHash160().Write(pubkey.begin(), pubkey.size()).Finalize(pubkeyHash.begin());"
      },
      {
        "sha": "445b9d8e89ad6e699a82e703f78cca4e5c94ec65",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 3,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -46,6 +46,7 @@ std::string HelpMessageCli()\n     strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcclienttimeout=<n>\", strprintf(_(\"Timeout in seconds during HTTP requests, or 0 for no timeout. (default: %d)\"), DEFAULT_HTTP_CLIENT_TIMEOUT));\n     strUsage += HelpMessageOpt(\"-stdin\", _(\"Read extra arguments from standard input, one per line until EOF/Ctrl-D (recommended for sensitive information such as passphrases)\"));\n+    strUsage += HelpMessageOpt(\"-rpcwallet=<walletname>\", _(\"Send RPC for non-default wallet on RPC server (argument is wallet filename in bitcoind directory, required if bitcoind/-Qt runs with multiple wallets)\"));\n \n     return strUsage;\n }\n@@ -191,8 +192,14 @@ static void http_error_cb(enum evhttp_request_error err, void *ctx)\n \n UniValue CallRPC(const std::string& strMethod, const UniValue& params)\n {\n-    std::string host = GetArg(\"-rpcconnect\", DEFAULT_RPCCONNECT);\n-    int port = GetArg(\"-rpcport\", BaseParams().RPCPort());\n+    std::string host;\n+    // In preference order, we choose the following for the port:\n+    //     1. -rpcport\n+    //     2. port in -rpcconnect (ie following : in ipv4 or ]: in ipv6)\n+    //     3. default port for chain\n+    int port = BaseParams().RPCPort();\n+    SplitHostPort(GetArg(\"-rpcconnect\", DEFAULT_RPCCONNECT), port, host);\n+    port = GetArg(\"-rpcport\", port);\n \n     // Obtain event base\n     raii_event_base base = obtain_event_base();\n@@ -235,7 +242,20 @@ UniValue CallRPC(const std::string& strMethod, const UniValue& params)\n     assert(output_buffer);\n     evbuffer_add(output_buffer, strRequest.data(), strRequest.size());\n \n-    int r = evhttp_make_request(evcon.get(), req.get(), EVHTTP_REQ_POST, \"/\");\n+    // check if we should use a special wallet endpoint\n+    std::string endpoint = \"/\";\n+    std::string walletName = GetArg(\"-rpcwallet\", \"\");\n+    if (!walletName.empty()) {\n+        char *encodedURI = evhttp_uriencode(walletName.c_str(), walletName.size(), false);\n+        if (encodedURI) {\n+            endpoint = \"/wallet/\"+ std::string(encodedURI);\n+            free(encodedURI);\n+        }\n+        else {\n+            throw CConnectionFailed(\"uri-encode failed\");\n+        }\n+    }\n+    int r = evhttp_make_request(evcon.get(), req.get(), EVHTTP_REQ_POST, endpoint.c_str());\n     req.release(); // ownership moved to evcon in above call\n     if (r != 0) {\n         throw CConnectionFailed(\"send http request failed\");"
      },
      {
        "sha": "9acb3fd30e9668e18f6cbbf2921646e7f2799d6f",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -77,7 +77,7 @@ static int AppInitRawTx(int argc, char* argv[])\n         strUsage += HelpMessageOpt(\"in=TXID:VOUT(:SEQUENCE_NUMBER)\", _(\"Add input to TX\"));\n         strUsage += HelpMessageOpt(\"locktime=N\", _(\"Set TX lock time to N\"));\n         strUsage += HelpMessageOpt(\"nversion=N\", _(\"Set TX version to N\"));\n-        strUsage += HelpMessageOpt(\"rbfoptin(=N)\", _(\"Set RBF opt-in sequence number for input N (if not provided, opt-in all available inputs)\"));\n+        strUsage += HelpMessageOpt(\"replaceable(=N)\", _(\"Set RBF opt-in sequence number for input N (if not provided, opt-in all available inputs)\"));\n         strUsage += HelpMessageOpt(\"outaddr=VALUE:ADDRESS\", _(\"Add address-based output to TX\"));\n         strUsage += HelpMessageOpt(\"outpubkey=VALUE:PUBKEY[:FLAGS]\", _(\"Add pay-to-pubkey output to TX\") + \". \" +\n             _(\"Optionally add the \\\"W\\\" flag to produce a pay-to-witness-pubkey-hash output\") + \". \" +\n@@ -239,7 +239,7 @@ static void MutateTxAddInput(CMutableTransaction& tx, const std::string& strInpu\n     uint256 txid(uint256S(strTxid));\n \n     static const unsigned int minTxOutSz = 9;\n-    static const unsigned int maxVout = MAX_BLOCK_BASE_SIZE / minTxOutSz;\n+    static const unsigned int maxVout = MAX_BLOCK_WEIGHT / (WITNESS_SCALE_FACTOR * minTxOutSz);\n \n     // extract and validate vout\n     std::string strVout = vStrInputParts[1];\n@@ -299,7 +299,6 @@ static void MutateTxAddOutPubKey(CMutableTransaction& tx, const std::string& str\n     if (!pubkey.IsFullyValid())\n         throw std::runtime_error(\"invalid TX output pubkey\");\n     CScript scriptPubKey = GetScriptForRawPubKey(pubkey);\n-    CBitcoinAddress addr(scriptPubKey);\n \n     // Extract and validate FLAGS\n     bool bSegWit = false;\n@@ -636,7 +635,7 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n             ProduceSignature(MutableTransactionSignatureCreator(&keystore, &mergedTx, i, amount, nHashType), prevPubKey, sigdata);\n \n         // ... and merge in other signatures:\n-        BOOST_FOREACH(const CTransaction& txv, txVariants)\n+        for (const CTransaction& txv : txVariants)\n             sigdata = CombineSignatures(prevPubKey, MutableTransactionSignatureChecker(&mergedTx, i, amount), sigdata, DataFromTransaction(txv, i));\n         UpdateTransaction(mergedTx, i, sigdata);\n \n@@ -674,7 +673,7 @@ static void MutateTx(CMutableTransaction& tx, const std::string& command,\n         MutateTxVersion(tx, commandVal);\n     else if (command == \"locktime\")\n         MutateTxLocktime(tx, commandVal);\n-    else if (command == \"rbfoptin\") {\n+    else if (command == \"replaceable\") {\n         MutateTxRBFOptIn(tx, commandVal);\n     }\n "
      },
      {
        "sha": "f3844e9d479a9ad093a842a0016a45e985995f38",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -20,7 +20,6 @@\n #include \"httprpc.h\"\n #include \"utilstrencodings.h\"\n \n-#include <boost/algorithm/string/predicate.hpp>\n #include <boost/thread.hpp>\n \n #include <stdio.h>\n@@ -160,7 +159,12 @@ bool AppInit(int argc, char* argv[])\n             return false;\n #endif // HAVE_DECL_DAEMON\n         }\n-\n+        // Lock data directory after daemonization\n+        if (!AppInitLockDataDirectory())\n+        {\n+            // If locking the data directory failed, exit immediately\n+            exit(EXIT_FAILURE);\n+        }\n         fRet = AppInitMain(threadGroup, scheduler);\n     }\n     catch (const std::exception& e) {"
      },
      {
        "sha": "6f27b7b9dc5dff082ab3c773a99786789ae315de",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -15,8 +15,6 @@\n \n #include <unordered_map>\n \n-#define MIN_TRANSACTION_BASE_SIZE (::GetSerializeSize(CTransaction(), SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS))\n-\n CBlockHeaderAndShortTxIDs::CBlockHeaderAndShortTxIDs(const CBlock& block, bool fUseWTXID) :\n         nonce(GetRand(std::numeric_limits<uint64_t>::max())),\n         shorttxids(block.vtx.size() - 1), prefilledtxn(1), header(block) {\n@@ -50,7 +48,7 @@ uint64_t CBlockHeaderAndShortTxIDs::GetShortID(const uint256& txhash) const {\n ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& cmpctblock, const std::vector<std::pair<uint256, CTransactionRef>>& extra_txn) {\n     if (cmpctblock.header.IsNull() || (cmpctblock.shorttxids.empty() && cmpctblock.prefilledtxn.empty()))\n         return READ_STATUS_INVALID;\n-    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_BASE_SIZE / MIN_TRANSACTION_BASE_SIZE)\n+    if (cmpctblock.shorttxids.size() + cmpctblock.prefilledtxn.size() > MAX_BLOCK_WEIGHT / MIN_SERIALIZABLE_TRANSACTION_WEIGHT)\n         return READ_STATUS_INVALID;\n \n     assert(header.IsNull() && txn_available.empty());\n@@ -172,7 +170,7 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n bool PartiallyDownloadedBlock::IsTxAvailable(size_t index) const {\n     assert(!header.IsNull());\n     assert(index < txn_available.size());\n-    return txn_available[index] ? true : false;\n+    return txn_available[index] != nullptr;\n }\n \n ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<CTransactionRef>& vtx_missing) {"
      },
      {
        "sha": "fa884f0bf32ef5d34a85f5712b6a44aa28d007aa",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -14,7 +14,6 @@\n #include <math.h>\n #include <stdlib.h>\n \n-#include <boost/foreach.hpp>\n \n #define LN2SQUARED 0.4804530139182014246671025263266649717305529515945455\n #define LN2 0.6931471805599453094172321214581765680755001343602552\n@@ -179,7 +178,7 @@ bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n     if (fFound)\n         return true;\n \n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    for (const CTxIn& txin : tx.vin)\n     {\n         // Match if the filter contains an outpoint tx spends\n         if (contains(txin.prevout))"
      },
      {
        "sha": "ffd58d471d34b5f9926194446137f4e703742a82",
        "filename": "src/chain.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 1,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/chain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/chain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -126,7 +126,7 @@ arith_uint256 GetBlockProof(const CBlockIndex& block)\n     if (fNegative || fOverflow || bnTarget == 0)\n         return 0;\n     // We need to compute 2**256 / (bnTarget+1), but we can't represent 2**256\n-    // as it's too large for a arith_uint256. However, as 2**256 is at least as large\n+    // as it's too large for an arith_uint256. However, as 2**256 is at least as large\n     // as bnTarget+1, it is equal to ((2**256 - bnTarget - 1) / (bnTarget+1)) + 1,\n     // or ~bnTarget / (nTarget+1) + 1.\n     return (~bnTarget / (bnTarget + 1)) + 1;\n@@ -148,3 +148,22 @@ int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& fr\n     }\n     return sign * r.GetLow64();\n }\n+\n+/** Find the last common ancestor two blocks have.\n+ *  Both pa and pb must be non-NULL. */\n+const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb) {\n+    if (pa->nHeight > pb->nHeight) {\n+        pa = pa->GetAncestor(pb->nHeight);\n+    } else if (pb->nHeight > pa->nHeight) {\n+        pb = pb->GetAncestor(pa->nHeight);\n+    }\n+\n+    while (pa != pb && pa && pb) {\n+        pa = pa->pprev;\n+        pb = pb->pprev;\n+    }\n+\n+    // Eventually all chain branches meet at the genesis block.\n+    assert(pa == pb);\n+    return pa;\n+}"
      },
      {
        "sha": "c5304b7d6f3e10bb32a1313d88d308ed14813d11",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -362,6 +362,9 @@ class CBlockIndex\n arith_uint256 GetBlockProof(const CBlockIndex& block);\n /** Return the time it would take to redo the work difference between from and to, assuming the current hashrate corresponds to the difficulty at tip, in seconds. */\n int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& from, const CBlockIndex& tip, const Consensus::Params&);\n+/** Find the forking point between two chain tips. */\n+const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb);\n+\n \n /** Used to marshal pointers into hashes for db storage. */\n class CDiskBlockIndex : public CBlockIndex"
      },
      {
        "sha": "dc4d2621ee0422dd01791031d0bd142439c69f23",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -124,12 +124,12 @@ class CMainParams : public CChainParams {\n         assert(genesis.hashMerkleRoot == uint256S(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\n \n         // Note that of those with the service bits flag, most only support a subset of possible options\n-        vSeeds.push_back(CDNSSeedData(\"bitcoin.sipa.be\", \"seed.bitcoin.sipa.be\", true)); // Pieter Wuille, only supports x1, x5, x9, and xd\n-        vSeeds.push_back(CDNSSeedData(\"bluematt.me\", \"dnsseed.bluematt.me\", true)); // Matt Corallo, only supports x9\n-        vSeeds.push_back(CDNSSeedData(\"dashjr.org\", \"dnsseed.bitcoin.dashjr.org\")); // Luke Dashjr\n-        vSeeds.push_back(CDNSSeedData(\"bitcoinstats.com\", \"seed.bitcoinstats.com\", true)); // Christian Decker, supports x1 - xf\n-        vSeeds.push_back(CDNSSeedData(\"bitcoin.jonasschnelli.ch\", \"seed.bitcoin.jonasschnelli.ch\", true)); // Jonas Schnelli, only supports x1, x5, x9, and xd\n-        vSeeds.push_back(CDNSSeedData(\"petertodd.org\", \"seed.btc.petertodd.org\", true)); // Peter Todd, only supports x1, x5, x9, and xd\n+        vSeeds.emplace_back(\"seed.bitcoin.sipa.be\", true); // Pieter Wuille, only supports x1, x5, x9, and xd\n+        vSeeds.emplace_back(\"dnsseed.bluematt.me\", true); // Matt Corallo, only supports x9\n+        vSeeds.emplace_back(\"dnsseed.bitcoin.dashjr.org\", false); // Luke Dashjr\n+        vSeeds.emplace_back(\"seed.bitcoinstats.com\", true); // Christian Decker, supports x1 - xf\n+        vSeeds.emplace_back(\"seed.bitcoin.jonasschnelli.ch\", true); // Jonas Schnelli, only supports x1, x5, x9, and xd\n+        vSeeds.emplace_back(\"seed.btc.petertodd.org\", true); // Peter Todd, only supports x1, x5, x9, and xd\n \n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);\n@@ -225,10 +225,10 @@ class CTestNetParams : public CChainParams {\n         vFixedSeeds.clear();\n         vSeeds.clear();\n         // nodes with support for servicebits filtering should be at the top\n-        vSeeds.push_back(CDNSSeedData(\"testnetbitcoin.jonasschnelli.ch\", \"testnet-seed.bitcoin.jonasschnelli.ch\", true));\n-        vSeeds.push_back(CDNSSeedData(\"petertodd.org\", \"seed.tbtc.petertodd.org\", true));\n-        vSeeds.push_back(CDNSSeedData(\"bluematt.me\", \"testnet-seed.bluematt.me\"));\n-        vSeeds.push_back(CDNSSeedData(\"bitcoin.schildbach.de\", \"testnet-seed.bitcoin.schildbach.de\"));\n+        vSeeds.emplace_back(\"testnet-seed.bitcoin.jonasschnelli.ch\", true);\n+        vSeeds.emplace_back(\"seed.tbtc.petertodd.org\", true);\n+        vSeeds.emplace_back(\"testnet-seed.bluematt.me\", false);\n+        vSeeds.emplace_back(\"testnet-seed.bitcoin.schildbach.de\", false);\n \n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);"
      },
      {
        "sha": "f55ae4cf7f068f8884f976c7a6c431bb7a778bcb",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -15,9 +15,9 @@\n #include <vector>\n \n struct CDNSSeedData {\n-    std::string name, host;\n+    std::string host;\n     bool supportsServiceBitsFiltering;\n-    CDNSSeedData(const std::string &strName, const std::string &strHost, bool supportsServiceBitsFilteringIn = false) : name(strName), host(strHost), supportsServiceBitsFiltering(supportsServiceBitsFilteringIn) {}\n+    CDNSSeedData(const std::string &strHost, bool supportsServiceBitsFilteringIn) : host(strHost), supportsServiceBitsFiltering(supportsServiceBitsFilteringIn) {}\n };\n \n struct SeedSpec6 {"
      },
      {
        "sha": "e6b5fb72a77ca3328ad9a41b1f8da887e3bcd8f4",
        "filename": "src/checkpoints.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/checkpoints.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/checkpoints.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -6,20 +6,20 @@\n \n #include \"chain.h\"\n #include \"chainparams.h\"\n+#include \"reverse_iterator.h\"\n #include \"validation.h\"\n #include \"uint256.h\"\n \n #include <stdint.h>\n \n-#include <boost/foreach.hpp>\n \n namespace Checkpoints {\n \n     CBlockIndex* GetLastCheckpoint(const CCheckpointData& data)\n     {\n         const MapCheckpoints& checkpoints = data.mapCheckpoints;\n \n-        BOOST_REVERSE_FOREACH(const MapCheckpoints::value_type& i, checkpoints)\n+        for (const MapCheckpoints::value_type& i : reverse_iterate(checkpoints))\n         {\n             const uint256& hash = i.second;\n             BlockMap::const_iterator t = mapBlockIndex.find(hash);"
      },
      {
        "sha": "408e278d216271daa09dc22ede258e53b45276ac",
        "filename": "src/checkqueue.h",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/checkqueue.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/checkqueue.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkqueue.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -10,9 +10,7 @@\n #include <algorithm>\n #include <vector>\n \n-#include <boost/foreach.hpp>\n #include <boost/thread/condition_variable.hpp>\n-#include <boost/thread/locks.hpp>\n #include <boost/thread/mutex.hpp>\n \n template <typename T>\n@@ -121,7 +119,7 @@ class CCheckQueue\n                 fOk = fAllOk;\n             }\n             // execute work\n-            BOOST_FOREACH (T& check, vChecks)\n+            for (T& check : vChecks)\n                 if (fOk)\n                     fOk = check();\n             vChecks.clear();\n@@ -151,7 +149,7 @@ class CCheckQueue\n     void Add(std::vector<T>& vChecks)\n     {\n         boost::unique_lock<boost::mutex> lock(mutex);\n-        BOOST_FOREACH (T& check, vChecks) {\n+        for (T& check : vChecks) {\n             queue.push_back(T());\n             check.swap(queue.back());\n         }"
      },
      {
        "sha": "e30bda930ae6c9e24ea2d121b36ac3157e341745",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 9,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -11,16 +11,22 @@\n #include <assert.h>\n \n bool CCoinsView::GetCoin(const COutPoint &outpoint, Coin &coin) const { return false; }\n-bool CCoinsView::HaveCoin(const COutPoint &outpoint) const { return false; }\n uint256 CCoinsView::GetBestBlock() const { return uint256(); }\n+std::vector<uint256> CCoinsView::GetHeadBlocks() const { return std::vector<uint256>(); }\n bool CCoinsView::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return false; }\n CCoinsViewCursor *CCoinsView::Cursor() const { return 0; }\n \n+bool CCoinsView::HaveCoin(const COutPoint &outpoint) const\n+{\n+    Coin coin;\n+    return GetCoin(outpoint, coin);\n+}\n \n CCoinsViewBacked::CCoinsViewBacked(CCoinsView *viewIn) : base(viewIn) { }\n bool CCoinsViewBacked::GetCoin(const COutPoint &outpoint, Coin &coin) const { return base->GetCoin(outpoint, coin); }\n bool CCoinsViewBacked::HaveCoin(const COutPoint &outpoint) const { return base->HaveCoin(outpoint); }\n uint256 CCoinsViewBacked::GetBestBlock() const { return base->GetBestBlock(); }\n+std::vector<uint256> CCoinsViewBacked::GetHeadBlocks() const { return base->GetHeadBlocks(); }\n void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n CCoinsViewCursor *CCoinsViewBacked::Cursor() const { return base->Cursor(); }\n@@ -55,7 +61,7 @@ bool CCoinsViewCache::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n     CCoinsMap::const_iterator it = FetchCoin(outpoint);\n     if (it != cacheCoins.end()) {\n         coin = it->second.coin;\n-        return true;\n+        return !coin.IsSpent();\n     }\n     return false;\n }\n@@ -81,19 +87,20 @@ void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possi\n     cachedCoinsUsage += it->second.coin.DynamicMemoryUsage();\n }\n \n-void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight) {\n+void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight, bool check) {\n     bool fCoinbase = tx.IsCoinBase();\n     const uint256& txid = tx.GetHash();\n     for (size_t i = 0; i < tx.vout.size(); ++i) {\n-        // Pass fCoinbase as the possible_overwrite flag to AddCoin, in order to correctly\n+        bool overwrite = check ? cache.HaveCoin(COutPoint(txid, i)) : fCoinbase;\n+        // Always set the possible_overwrite flag to AddCoin for coinbase txn, in order to correctly\n         // deal with the pre-BIP30 occurrences of duplicate coinbase transactions.\n-        cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), fCoinbase);\n+        cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), overwrite);\n     }\n }\n \n-void CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n+bool CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n     CCoinsMap::iterator it = FetchCoin(outpoint);\n-    if (it == cacheCoins.end()) return;\n+    if (it == cacheCoins.end()) return false;\n     cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n     if (moveout) {\n         *moveout = std::move(it->second.coin);\n@@ -104,6 +111,7 @@ void CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n         it->second.flags |= CCoinsCacheEntry::DIRTY;\n         it->second.coin.Clear();\n     }\n+    return true;\n }\n \n static const Coin coinEmpty;\n@@ -124,7 +132,7 @@ bool CCoinsViewCache::HaveCoin(const COutPoint &outpoint) const {\n \n bool CCoinsViewCache::HaveCoinInCache(const COutPoint &outpoint) const {\n     CCoinsMap::const_iterator it = cacheCoins.find(outpoint);\n-    return it != cacheCoins.end();\n+    return (it != cacheCoins.end() && !it->second.coin.IsSpent());\n }\n \n uint256 CCoinsViewCache::GetBestBlock() const {\n@@ -237,7 +245,8 @@ bool CCoinsViewCache::HaveInputs(const CTransaction& tx) const\n     return true;\n }\n \n-static const size_t MAX_OUTPUTS_PER_BLOCK = MAX_BLOCK_BASE_SIZE /  ::GetSerializeSize(CTxOut(), SER_NETWORK, PROTOCOL_VERSION); // TODO: merge with similar definition in undo.h.\n+static const size_t MIN_TRANSACTION_OUTPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxOut(), SER_NETWORK, PROTOCOL_VERSION);\n+static const size_t MAX_OUTPUTS_PER_BLOCK = MAX_BLOCK_WEIGHT / MIN_TRANSACTION_OUTPUT_WEIGHT;\n \n const Coin& AccessByTxid(const CCoinsViewCache& view, const uint256& txid)\n {"
      },
      {
        "sha": "efb5ce869c3fc13365cc07e436b75c2a7364d3dd",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 34,
        "deletions": 13,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -17,7 +17,6 @@\n #include <assert.h>\n #include <stdint.h>\n \n-#include <boost/foreach.hpp>\n #include <unordered_map>\n \n /**\n@@ -146,16 +145,24 @@ class CCoinsViewCursor\n class CCoinsView\n {\n public:\n-    //! Retrieve the Coin (unspent transaction output) for a given outpoint.\n+    /** Retrieve the Coin (unspent transaction output) for a given outpoint.\n+     *  Returns true only when an unspent coin was found, which is returned in coin.\n+     *  When false is returned, coin's value is unspecified.\n+     */\n     virtual bool GetCoin(const COutPoint &outpoint, Coin &coin) const;\n \n-    //! Just check whether we have data for a given outpoint.\n-    //! This may (but cannot always) return true for spent outputs.\n+    //! Just check whether a given outpoint is unspent.\n     virtual bool HaveCoin(const COutPoint &outpoint) const;\n \n     //! Retrieve the block hash whose state this CCoinsView currently represents\n     virtual uint256 GetBestBlock() const;\n \n+    //! Retrieve the range of blocks that may have been only partially written.\n+    //! If the database is in a consistent state, the result is the empty vector.\n+    //! Otherwise, a two-element vector is returned consisting of the new and\n+    //! the old block hash, in that order.\n+    virtual std::vector<uint256> GetHeadBlocks() const;\n+\n     //! Do a bulk modification (multiple Coin changes + BestBlock change).\n     //! The passed mapCoins can be modified.\n     virtual bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n@@ -182,6 +189,7 @@ class CCoinsViewBacked : public CCoinsView\n     bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n     bool HaveCoin(const COutPoint &outpoint) const override;\n     uint256 GetBestBlock() const override;\n+    std::vector<uint256> GetHeadBlocks() const override;\n     void SetBackend(CCoinsView &viewIn);\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n     CCoinsViewCursor *Cursor() const override;\n@@ -207,11 +215,14 @@ class CCoinsViewCache : public CCoinsViewBacked\n     CCoinsViewCache(CCoinsView *baseIn);\n \n     // Standard CCoinsView methods\n-    bool GetCoin(const COutPoint &outpoint, Coin &coin) const;\n-    bool HaveCoin(const COutPoint &outpoint) const;\n-    uint256 GetBestBlock() const;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n+    bool HaveCoin(const COutPoint &outpoint) const override;\n+    uint256 GetBestBlock() const override;\n     void SetBestBlock(const uint256 &hashBlock);\n-    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n+    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n+    CCoinsViewCursor* Cursor() const override {\n+        throw std::logic_error(\"CCoinsViewCache cursor iteration not supported.\");\n+    }\n \n     /**\n      * Check if we have the given utxo already loaded in this cache.\n@@ -222,8 +233,13 @@ class CCoinsViewCache : public CCoinsViewBacked\n \n     /**\n      * Return a reference to Coin in the cache, or a pruned one if not found. This is\n-     * more efficient than GetCoin. Modifications to other cache entries are\n-     * allowed while accessing the returned pointer.\n+     * more efficient than GetCoin.\n+     *\n+     * Generally, do not hold the reference returned for more than a short scope.\n+     * While the current implementation allows for modifications to the contents\n+     * of the cache while holding the reference, this behavior should not be relied\n+     * on! To be safe, best to not hold the returned reference through any other\n+     * calls to this cache.\n      */\n     const Coin& AccessCoin(const COutPoint &output) const;\n \n@@ -238,7 +254,7 @@ class CCoinsViewCache : public CCoinsViewBacked\n      * If no unspent output exists for the passed outpoint, this call\n      * has no effect.\n      */\n-    void SpendCoin(const COutPoint &outpoint, Coin* moveto = nullptr);\n+    bool SpendCoin(const COutPoint &outpoint, Coin* moveto = nullptr);\n \n     /**\n      * Push the modifications applied to this cache to its base.\n@@ -282,12 +298,17 @@ class CCoinsViewCache : public CCoinsViewBacked\n };\n \n //! Utility function to add all of a transaction's outputs to a cache.\n-// It assumes that overwrites are only possible for coinbase transactions,\n+// When check is false, this assumes that overwrites are only possible for coinbase transactions.\n+// When check is true, the underlying view may be queried to determine whether an addition is\n+// an overwrite.\n // TODO: pass in a boolean to limit these possible overwrites to known\n // (pre-BIP34) cases.\n-void AddCoins(CCoinsViewCache& cache, const CTransaction& tx, int nHeight);\n+void AddCoins(CCoinsViewCache& cache, const CTransaction& tx, int nHeight, bool check = false);\n \n //! Utility function to find any unspent output with a given txid.\n+// This function can be quite expensive because in the event of a transaction\n+// which is not found in the cache, it can cause up to MAX_OUTPUTS_PER_BLOCK\n+// lookups to database, so it should be used with care.\n const Coin& AccessByTxid(const CCoinsViewCache& cache, const uint256& txid);\n \n #endif // BITCOIN_COINS_H"
      },
      {
        "sha": "b4d1c90992b767f2f3676936f0478f2ef44a1b98",
        "filename": "src/compat/glibc_sanity.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/compat/glibc_sanity.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/compat/glibc_sanity.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibc_sanity.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -56,7 +56,7 @@ bool sanity_test_fdelt()\n }\n #endif\n \n-} // anon namespace\n+} // namespace\n \n bool glibc_sanity_test()\n {"
      },
      {
        "sha": "569fb1bbe886c5f561e5273a5f2fa3f086a32333",
        "filename": "src/compat/glibcxx_sanity.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/compat/glibcxx_sanity.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/compat/glibcxx_sanity.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibcxx_sanity.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -38,7 +38,7 @@ bool sanity_test_list(unsigned int size)\n     return true;\n }\n \n-} // anon namespace\n+} // namespace\n \n // trigger: string::at(x) on an empty string to trigger __throw_out_of_range_fmt.\n // test: force std::string to throw an out_of_range exception. Verify that"
      },
      {
        "sha": "f4c12f38d2d1fc7494669adbc3c3191978743db0",
        "filename": "src/compressor.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/compressor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/compressor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compressor.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -93,30 +93,30 @@ bool CScriptCompressor::Decompress(unsigned int nSize, const std::vector<unsigne\n         script[0] = OP_DUP;\n         script[1] = OP_HASH160;\n         script[2] = 20;\n-        memcpy(&script[3], &in[0], 20);\n+        memcpy(&script[3], in.data(), 20);\n         script[23] = OP_EQUALVERIFY;\n         script[24] = OP_CHECKSIG;\n         return true;\n     case 0x01:\n         script.resize(23);\n         script[0] = OP_HASH160;\n         script[1] = 20;\n-        memcpy(&script[2], &in[0], 20);\n+        memcpy(&script[2], in.data(), 20);\n         script[22] = OP_EQUAL;\n         return true;\n     case 0x02:\n     case 0x03:\n         script.resize(35);\n         script[0] = 33;\n         script[1] = nSize;\n-        memcpy(&script[2], &in[0], 32);\n+        memcpy(&script[2], in.data(), 32);\n         script[34] = OP_CHECKSIG;\n         return true;\n     case 0x04:\n     case 0x05:\n         unsigned char vch[33] = {};\n         vch[0] = nSize - 2;\n-        memcpy(&vch[1], &in[0], 32);\n+        memcpy(&vch[1], in.data(), 32);\n         CPubKey pubkey(&vch[0], &vch[33]);\n         if (!pubkey.Decompress())\n             return false;"
      },
      {
        "sha": "ddd4ee9fab489977a5d5f36a89f37ebdec767f9d",
        "filename": "src/consensus/consensus.h",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/consensus/consensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/consensus/consensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/consensus.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -6,19 +6,23 @@\n #ifndef BITCOIN_CONSENSUS_CONSENSUS_H\n #define BITCOIN_CONSENSUS_CONSENSUS_H\n \n+#include <stdlib.h>\n #include <stdint.h>\n \n /** The maximum allowed size for a serialized block, in bytes (only for buffer size limits) */\n static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 4000000;\n /** The maximum allowed weight for a block, see BIP 141 (network rule) */\n static const unsigned int MAX_BLOCK_WEIGHT = 4000000;\n-/** The maximum allowed size for a block excluding witness data, in bytes (network rule) */\n-static const unsigned int MAX_BLOCK_BASE_SIZE = 1000000;\n /** The maximum allowed number of signature check operations in a block (network rule) */\n static const int64_t MAX_BLOCK_SIGOPS_COST = 80000;\n /** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */\n static const int COINBASE_MATURITY = 100;\n \n+static const int WITNESS_SCALE_FACTOR = 4;\n+\n+static const size_t MIN_TRANSACTION_WEIGHT = WITNESS_SCALE_FACTOR * 60; // 60 is the lower bound for the size of a valid serialized CTransaction\n+static const size_t MIN_SERIALIZABLE_TRANSACTION_WEIGHT = WITNESS_SCALE_FACTOR * 10; // 10 is the lower bound for the size of a serialized CTransaction\n+\n /** Flags for nSequence and nLockTime locks */\n enum {\n     /* Interpret sequence numbers as relative lock-time constraints. */"
      },
      {
        "sha": "0a71915d1df129362300fdefe6e5b9b1b51e7ca9",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -126,7 +126,9 @@ unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& in\n     unsigned int nSigOps = 0;\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n     {\n-        const CTxOut &prevout = inputs.AccessCoin(tx.vin[i].prevout).out;\n+        const Coin& coin = inputs.AccessCoin(tx.vin[i].prevout);\n+        assert(!coin.IsSpent());\n+        const CTxOut &prevout = coin.out;\n         if (prevout.scriptPubKey.IsPayToScriptHash())\n             nSigOps += prevout.scriptPubKey.GetSigOpCount(tx.vin[i].scriptSig);\n     }\n@@ -146,7 +148,9 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n \n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n     {\n-        const CTxOut &prevout = inputs.AccessCoin(tx.vin[i].prevout).out;\n+        const Coin& coin = inputs.AccessCoin(tx.vin[i].prevout);\n+        assert(!coin.IsSpent());\n+        const CTxOut &prevout = coin.out;\n         nSigOps += CountWitnessSigOps(tx.vin[i].scriptSig, prevout.scriptPubKey, &tx.vin[i].scriptWitness, flags);\n     }\n     return nSigOps;\n@@ -160,7 +164,7 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n     if (tx.vout.empty())\n         return state.DoS(10, false, REJECT_INVALID, \"bad-txns-vout-empty\");\n     // Size limits (this doesn't take the witness into account, as that hasn't been checked for malleability)\n-    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) > MAX_BLOCK_BASE_SIZE)\n+    if (::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n         return state.DoS(100, false, REJECT_INVALID, \"bad-txns-oversize\");\n \n     // Check for negative or overflow output values"
      },
      {
        "sha": "5494ce40eac4204e06026d589958ff42e8f1fc0a",
        "filename": "src/consensus/validation.h",
        "status": "modified",
        "additions": 19,
        "deletions": 1,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/consensus/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/consensus/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/validation.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -7,14 +7,18 @@\n #define BITCOIN_CONSENSUS_VALIDATION_H\n \n #include <string>\n+#include \"version.h\"\n+#include \"consensus/consensus.h\"\n+#include \"primitives/transaction.h\"\n+#include \"primitives/block.h\"\n \n /** \"reject\" message codes */\n static const unsigned char REJECT_MALFORMED = 0x01;\n static const unsigned char REJECT_INVALID = 0x10;\n static const unsigned char REJECT_OBSOLETE = 0x11;\n static const unsigned char REJECT_DUPLICATE = 0x12;\n static const unsigned char REJECT_NONSTANDARD = 0x40;\n-static const unsigned char REJECT_DUST = 0x41;\n+// static const unsigned char REJECT_DUST = 0x41; // part of BIP 61\n static const unsigned char REJECT_INSUFFICIENTFEE = 0x42;\n static const unsigned char REJECT_CHECKPOINT = 0x43;\n \n@@ -85,4 +89,18 @@ class CValidationState {\n     std::string GetDebugMessage() const { return strDebugMessage; }\n };\n \n+static inline int64_t GetTransactionWeight(const CTransaction& tx)\n+{\n+    return ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR -1) + ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n+}\n+\n+static inline int64_t GetBlockWeight(const CBlock& block)\n+{\n+    // This implements the weight = (stripped_size * 4) + witness_size formula,\n+    // using only serialization with and without witness data. As witness_size\n+    // is equal to total_size - stripped_size, this formula is identical to:\n+    // weight = (stripped_size * 3) + total_size.\n+    return ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);\n+}\n+\n #endif // BITCOIN_CONSENSUS_VALIDATION_H"
      },
      {
        "sha": "f038e7b15487471566295dce78d24a6f903c83ab",
        "filename": "src/core_memusage.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/core_memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/core_memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_memusage.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -10,7 +10,7 @@\n #include \"memusage.h\"\n \n static inline size_t RecursiveDynamicUsage(const CScript& script) {\n-    return memusage::DynamicUsage(*static_cast<const CScriptBase*>(&script));\n+    return memusage::DynamicUsage(script);\n }\n \n static inline size_t RecursiveDynamicUsage(const COutPoint& out) {"
      },
      {
        "sha": "7018131a134ad08042c41ae1441594211448325c",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -27,7 +27,7 @@ CScript ParseScript(const std::string& s)\n \n     if (mapOpNames.empty())\n     {\n-        for (int op = 0; op <= OP_NOP10; op++)\n+        for (unsigned int op = 0; op <= MAX_OPCODE; op++)\n         {\n             // Allow OP_RESERVED to get into mapOpNames\n             if (op < OP_NOP && op != OP_RESERVED)"
      },
      {
        "sha": "a366ef933c344b9e0fca4cf55b2a54ca67a00021",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -5,7 +5,8 @@\n #include \"core_io.h\"\n \n #include \"base58.h\"\n-#include \"primitives/transaction.h\"\n+#include \"consensus/consensus.h\"\n+#include \"consensus/validation.h\"\n #include \"script/script.h\"\n #include \"script/standard.h\"\n #include \"serialize.h\"\n@@ -15,8 +16,6 @@\n #include \"utilmoneystr.h\"\n #include \"utilstrencodings.h\"\n \n-#include <boost/foreach.hpp>\n-\n std::string FormatScript(const CScript& script)\n {\n     std::string ret;\n@@ -139,7 +138,7 @@ void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n     out.pushKV(\"type\", GetTxnOutputType(type));\n \n     UniValue a(UniValue::VARR);\n-    BOOST_FOREACH(const CTxDestination& addr, addresses)\n+    for (const CTxDestination& addr : addresses)\n         a.push_back(CBitcoinAddress(addr).ToString());\n     out.pushKV(\"addresses\", a);\n }"
      },
      {
        "sha": "5e70d25eeeef4862bccaf2b64647411ba3f0673c",
        "filename": "src/crypto/aes.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/crypto/aes.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/crypto/aes.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/aes.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -112,7 +112,6 @@ static int CBCEncrypt(const T& enc, const unsigned char iv[AES_BLOCKSIZE], const\n template <typename T>\n static int CBCDecrypt(const T& dec, const unsigned char iv[AES_BLOCKSIZE], const unsigned char* data, int size, bool pad, unsigned char* out)\n {\n-    unsigned char padsize = 0;\n     int written = 0;\n     bool fail = false;\n     const unsigned char* prev = iv;\n@@ -136,7 +135,7 @@ static int CBCDecrypt(const T& dec, const unsigned char iv[AES_BLOCKSIZE], const\n     if (pad) {\n         // If used, padding size is the value of the last decrypted byte. For\n         // it to be valid, It must be between 1 and AES_BLOCKSIZE.\n-        padsize = *--out;\n+        unsigned char padsize = *--out;\n         fail = !padsize | (padsize > AES_BLOCKSIZE);\n \n         // If not well-formed, treat it as though there's no padding."
      },
      {
        "sha": "fd24d05ee7b998eab6bc7a4510e4d13fd1841f22",
        "filename": "src/cuckoocache.h",
        "status": "modified",
        "additions": 33,
        "deletions": 2,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/cuckoocache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/cuckoocache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/cuckoocache.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -176,15 +176,15 @@ class cache\n      */\n     mutable std::vector<bool> epoch_flags;\n \n-    /** epoch_heuristic_counter is used to determine when a epoch might be aged\n+    /** epoch_heuristic_counter is used to determine when an epoch might be aged\n      * & an expensive scan should be done.  epoch_heuristic_counter is\n      * decremented on insert and reset to the new number of inserts which would\n      * cause the epoch to reach epoch_size when it reaches zero.\n      */\n     uint32_t epoch_heuristic_counter;\n \n     /** epoch_size is set to be the number of elements supposed to be in a\n-     * epoch. When the number of non-erased elements in a epoch\n+     * epoch. When the number of non-erased elements in an epoch\n      * exceeds epoch_size, a new epoch should be started and all\n      * current entries demoted. epoch_size is set to be 45% of size because\n      * we want to keep load around 90%, and we support 3 epochs at once --\n@@ -206,6 +206,37 @@ class cache\n     /** compute_hashes is convenience for not having to write out this\n      * expression everywhere we use the hash values of an Element.\n      *\n+     * We need to map the 32-bit input hash onto a hash bucket in a range [0, size) in a\n+     *  manner which preserves as much of the hash's uniformity as possible.  Ideally\n+     *  this would be done by bitmasking but the size is usually not a power of two.\n+     *\n+     * The naive approach would be to use a mod -- which isn't perfectly uniform but so\n+     *  long as the hash is much larger than size it is not that bad.  Unfortunately,\n+     *  mod/division is fairly slow on ordinary microprocessors (e.g. 90-ish cycles on\n+     *  haswell, ARM doesn't even have an instruction for it.); when the divisor is a\n+     *  constant the compiler will do clever tricks to turn it into a multiply+add+shift,\n+     *  but size is a run-time value so the compiler can't do that here.\n+     *\n+     * One option would be to implement the same trick the compiler uses and compute the\n+     *  constants for exact division based on the size, as described in \"{N}-bit Unsigned\n+     *  Division via {N}-bit Multiply-Add\" by Arch D. Robison in 2005. But that code is\n+     *  somewhat complicated and the result is still slower than other options:\n+     *\n+     * Instead we treat the 32-bit random number as a Q32 fixed-point number in the range\n+     *  [0,1) and simply multiply it by the size.  Then we just shift the result down by\n+     *  32-bits to get our bucket number.  The results has non-uniformity the same as a\n+     *  mod, but it is much faster to compute. More about this technique can be found at\n+     *  http://lemire.me/blog/2016/06/27/a-fast-alternative-to-the-modulo-reduction/\n+     *\n+     * The resulting non-uniformity is also more equally distributed which would be\n+     *  advantageous for something like linear probing, though it shouldn't matter\n+     *  one way or the other for a cuckoo table.\n+     *\n+     * The primary disadvantage of this approach is increased intermediate precision is\n+     *  required but for a 32-bit random number we only need the high 32 bits of a\n+     *  32*32->64 multiply, which means the operation is reasonably fast even on a\n+     *  typical 32-bit processor.\n+     *\n      * @param e the element whose hashes will be returned\n      * @returns std::array<uint32_t, 8> of deterministic hashes derived from e\n      */"
      },
      {
        "sha": "ba9e21cc1fce8b36a5b199290147b1d2fdbd0ac7",
        "filename": "src/dbwrapper.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/dbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/dbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -108,7 +108,7 @@ CDBWrapper::CDBWrapper(const fs::path& path, size_t nCacheSize, bool fMemory, bo\n             leveldb::Status result = leveldb::DestroyDB(path.string(), options);\n             dbwrapper_private::HandleError(result);\n         }\n-        TryCreateDirectory(path);\n+        TryCreateDirectories(path);\n         LogPrintf(\"Opening LevelDB in %s\\n\", path.string());\n     }\n     leveldb::Status status = leveldb::DB::Open(options, path.string(), &pdb);\n@@ -209,4 +209,4 @@ const std::vector<unsigned char>& GetObfuscateKey(const CDBWrapper &w)\n     return w.obfuscate_key;\n }\n \n-};\n+} // namespace dbwrapper_private"
      },
      {
        "sha": "a5e12f1cfcb70e0c2fcc628d8f53bf6fa3adee1c",
        "filename": "src/fs.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/fs.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/fs.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fs.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -1,7 +1,5 @@\n #include \"fs.h\"\n \n-#include <boost/filesystem.hpp>\n-\n namespace fsbridge {\n \n FILE *fopen(const fs::path& p, const char *mode)"
      },
      {
        "sha": "5a15600be55e82dc595f3fee61e398431a4c219e",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 23,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -17,36 +17,34 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n {\n     // The following is MurmurHash3 (x86_32), see http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp\n     uint32_t h1 = nHashSeed;\n-    if (vDataToHash.size() > 0)\n-    {\n-        const uint32_t c1 = 0xcc9e2d51;\n-        const uint32_t c2 = 0x1b873593;\n+    const uint32_t c1 = 0xcc9e2d51;\n+    const uint32_t c2 = 0x1b873593;\n \n-        const int nblocks = vDataToHash.size() / 4;\n+    const int nblocks = vDataToHash.size() / 4;\n \n-        //----------\n-        // body\n-        const uint8_t* blocks = &vDataToHash[0] + nblocks * 4;\n+    //----------\n+    // body\n+    const uint8_t* blocks = vDataToHash.data();\n \n-        for (int i = -nblocks; i; i++) {\n-            uint32_t k1 = ReadLE32(blocks + i*4);\n+    for (int i = 0; i < nblocks; ++i) {\n+        uint32_t k1 = ReadLE32(blocks + i*4);\n \n-            k1 *= c1;\n-            k1 = ROTL32(k1, 15);\n-            k1 *= c2;\n+        k1 *= c1;\n+        k1 = ROTL32(k1, 15);\n+        k1 *= c2;\n \n-            h1 ^= k1;\n-            h1 = ROTL32(h1, 13);\n-            h1 = h1 * 5 + 0xe6546b64;\n-        }\n+        h1 ^= k1;\n+        h1 = ROTL32(h1, 13);\n+        h1 = h1 * 5 + 0xe6546b64;\n+    }\n \n-        //----------\n-        // tail\n-        const uint8_t* tail = (const uint8_t*)(&vDataToHash[0] + nblocks * 4);\n+    //----------\n+    // tail\n+    const uint8_t* tail = vDataToHash.data() + nblocks * 4;\n \n-        uint32_t k1 = 0;\n+    uint32_t k1 = 0;\n \n-        switch (vDataToHash.size() & 3) {\n+    switch (vDataToHash.size() & 3) {\n         case 3:\n             k1 ^= tail[2] << 16;\n         case 2:\n@@ -57,7 +55,6 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n             k1 = ROTL32(k1, 15);\n             k1 *= c2;\n             h1 ^= k1;\n-        }\n     }\n \n     //----------"
      },
      {
        "sha": "69c3e3f49f606ee808c11bd79f6e9d9e8072a8dc",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 33,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -16,10 +16,8 @@\n #include \"ui_interface.h\"\n #include \"crypto/hmac_sha256.h\"\n #include <stdio.h>\n-#include \"utilstrencodings.h\"\n \n #include <boost/algorithm/string.hpp> // boost::trim\n-#include <boost/foreach.hpp> //BOOST_FOREACH\n \n /** WWW-Authenticate to present with 401 Unauthorized response */\n static const char* WWW_AUTH_HEADER_DATA = \"Basic realm=\\\"jsonrpc\\\"\";\n@@ -48,11 +46,11 @@ class HTTPRPCTimerInterface : public RPCTimerInterface\n     HTTPRPCTimerInterface(struct event_base* _base) : base(_base)\n     {\n     }\n-    const char* Name()\n+    const char* Name() override\n     {\n         return \"HTTP\";\n     }\n-    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis)\n+    RPCTimerBase* NewTimer(std::function<void(void)>& func, int64_t millis) override\n     {\n         return new HTTPRPCTimer(base, func, millis);\n     }\n@@ -93,35 +91,32 @@ static bool multiUserAuthorized(std::string strUserPass)\n     std::string strUser = strUserPass.substr(0, strUserPass.find(\":\"));\n     std::string strPass = strUserPass.substr(strUserPass.find(\":\") + 1);\n \n-    if (gArgs.IsArgSet(\"-rpcauth\")) {\n+    for (const std::string& strRPCAuth : gArgs.GetArgs(\"-rpcauth\")) {\n         //Search for multi-user login/pass \"rpcauth\" from config\n-        BOOST_FOREACH(std::string strRPCAuth, gArgs.GetArgs(\"-rpcauth\"))\n-        {\n-            std::vector<std::string> vFields;\n-            boost::split(vFields, strRPCAuth, boost::is_any_of(\":$\"));\n-            if (vFields.size() != 3) {\n-                //Incorrect formatting in config file\n-                continue;\n-            }\n-\n-            std::string strName = vFields[0];\n-            if (!TimingResistantEqual(strName, strUser)) {\n-                continue;\n-            }\n-\n-            std::string strSalt = vFields[1];\n-            std::string strHash = vFields[2];\n-\n-            static const unsigned int KEY_SIZE = 32;\n-            unsigned char out[KEY_SIZE];\n-\n-            CHMAC_SHA256(reinterpret_cast<const unsigned char*>(strSalt.c_str()), strSalt.size()).Write(reinterpret_cast<const unsigned char*>(strPass.c_str()), strPass.size()).Finalize(out);\n-            std::vector<unsigned char> hexvec(out, out+KEY_SIZE);\n-            std::string strHashFromPass = HexStr(hexvec);\n-\n-            if (TimingResistantEqual(strHashFromPass, strHash)) {\n-                return true;\n-            }\n+        std::vector<std::string> vFields;\n+        boost::split(vFields, strRPCAuth, boost::is_any_of(\":$\"));\n+        if (vFields.size() != 3) {\n+            //Incorrect formatting in config file\n+            continue;\n+        }\n+\n+        std::string strName = vFields[0];\n+        if (!TimingResistantEqual(strName, strUser)) {\n+            continue;\n+        }\n+\n+        std::string strSalt = vFields[1];\n+        std::string strHash = vFields[2];\n+\n+        static const unsigned int KEY_SIZE = 32;\n+        unsigned char out[KEY_SIZE];\n+\n+        CHMAC_SHA256(reinterpret_cast<const unsigned char*>(strSalt.c_str()), strSalt.size()).Write(reinterpret_cast<const unsigned char*>(strPass.c_str()), strPass.size()).Finalize(out);\n+        std::vector<unsigned char> hexvec(out, out+KEY_SIZE);\n+        std::string strHashFromPass = HexStr(hexvec);\n+\n+        if (TimingResistantEqual(strHashFromPass, strHash)) {\n+            return true;\n         }\n     }\n     return false;\n@@ -238,7 +233,10 @@ bool StartHTTPRPC()\n         return false;\n \n     RegisterHTTPHandler(\"/\", true, HTTPReq_JSONRPC);\n-\n+#ifdef ENABLE_WALLET\n+    // ifdef can be removed once we switch to better endpoint support and API versioning\n+    RegisterHTTPHandler(\"/wallet/\", false, HTTPReq_JSONRPC);\n+#endif\n     assert(EventBase());\n     httpRPCTimerInterface = new HTTPRPCTimerInterface(EventBase());\n     RPCSetTimerInterface(httpRPCTimerInterface);"
      },
      {
        "sha": "a89a8f0fbfe0980bb935d33ceafb78b03270de00",
        "filename": "src/httprpc.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/httprpc.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/httprpc.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -8,8 +8,6 @@\n #include <string>\n #include <map>\n \n-class HTTPRequest;\n-\n /** Start HTTP RPC subsystem.\n  * Precondition; HTTP and RPC has been started.\n  */"
      },
      {
        "sha": "ba012554006a461dd75f450cf0dd0f013d759c29",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 28,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -7,6 +7,7 @@\n #include \"chainparamsbase.h\"\n #include \"compat.h\"\n #include \"util.h\"\n+#include \"utilstrencodings.h\"\n #include \"netbase.h\"\n #include \"rpc/protocol.h\" // For HTTP status codes\n #include \"sync.h\"\n@@ -21,13 +22,13 @@\n #include <signal.h>\n #include <future>\n \n-#include <event2/event.h>\n-#include <event2/http.h>\n #include <event2/thread.h>\n #include <event2/buffer.h>\n #include <event2/util.h>\n #include <event2/keyvalq_struct.h>\n \n+#include \"support/events.h\"\n+\n #ifdef EVENT__HAVE_NETINET_IN_H\n #include <netinet/in.h>\n #ifdef _XOPEN_SOURCE_EXTENDED\n@@ -46,7 +47,7 @@ class HTTPWorkItem : public HTTPClosure\n         req(std::move(_req)), path(_path), func(_func)\n     {\n     }\n-    void operator()()\n+    void operator()() override\n     {\n         func(req.get(), path);\n     }\n@@ -196,18 +197,16 @@ static bool InitHTTPAllowList()\n     LookupHost(\"::1\", localv6, false);\n     rpc_allow_subnets.push_back(CSubNet(localv4, 8));      // always allow IPv4 local subnet\n     rpc_allow_subnets.push_back(CSubNet(localv6));         // always allow IPv6 localhost\n-    if (gArgs.IsArgSet(\"-rpcallowip\")) {\n-        for (const std::string& strAllow : gArgs.GetArgs(\"-rpcallowip\")) {\n-            CSubNet subnet;\n-            LookupSubNet(strAllow.c_str(), subnet);\n-            if (!subnet.IsValid()) {\n-                uiInterface.ThreadSafeMessageBox(\n-                    strprintf(\"Invalid -rpcallowip subnet specification: %s. Valid are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24).\", strAllow),\n-                    \"\", CClientUIInterface::MSG_ERROR);\n-                return false;\n-            }\n-            rpc_allow_subnets.push_back(subnet);\n+    for (const std::string& strAllow : gArgs.GetArgs(\"-rpcallowip\")) {\n+        CSubNet subnet;\n+        LookupSubNet(strAllow.c_str(), subnet);\n+        if (!subnet.IsValid()) {\n+            uiInterface.ThreadSafeMessageBox(\n+                strprintf(\"Invalid -rpcallowip subnet specification: %s. Valid are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24).\", strAllow),\n+                \"\", CClientUIInterface::MSG_ERROR);\n+            return false;\n         }\n+        rpc_allow_subnets.push_back(subnet);\n     }\n     std::string strAllowed;\n     for (const CSubNet& subnet : rpc_allow_subnets)\n@@ -367,9 +366,6 @@ static void libevent_log_cb(int severity, const char *msg)\n \n bool InitHTTPServer()\n {\n-    struct evhttp* http = 0;\n-    struct event_base* base = 0;\n-\n     if (!InitHTTPAllowList())\n         return false;\n \n@@ -395,17 +391,13 @@ bool InitHTTPServer()\n     evthread_use_pthreads();\n #endif\n \n-    base = event_base_new(); // XXX RAII\n-    if (!base) {\n-        LogPrintf(\"Couldn't create an event_base: exiting\\n\");\n-        return false;\n-    }\n+    raii_event_base base_ctr = obtain_event_base();\n \n     /* Create a new evhttp object to handle requests. */\n-    http = evhttp_new(base); // XXX RAII\n+    raii_evhttp http_ctr = obtain_evhttp(base_ctr.get());\n+    struct evhttp* http = http_ctr.get();\n     if (!http) {\n         LogPrintf(\"couldn't create evhttp. Exiting.\\n\");\n-        event_base_free(base);\n         return false;\n     }\n \n@@ -416,8 +408,6 @@ bool InitHTTPServer()\n \n     if (!HTTPBindAddresses(http)) {\n         LogPrintf(\"Unable to bind any endpoint for RPC server\\n\");\n-        evhttp_free(http);\n-        event_base_free(base);\n         return false;\n     }\n \n@@ -426,8 +416,9 @@ bool InitHTTPServer()\n     LogPrintf(\"HTTP: creating work queue of depth %d\\n\", workQueueDepth);\n \n     workQueue = new WorkQueue<HTTPClosure>(workQueueDepth);\n-    eventBase = base;\n-    eventHTTP = http;\n+    // tranfer ownership to eventBase/HTTP via .release()\n+    eventBase = base_ctr.release();\n+    eventHTTP = http_ctr.release();\n     return true;\n }\n \n@@ -675,3 +666,14 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n     }\n }\n \n+std::string urlDecode(const std::string &urlEncoded) {\n+    std::string res;\n+    if (!urlEncoded.empty()) {\n+        char *decoded = evhttp_uridecode(urlEncoded.c_str(), false, NULL);\n+        if (decoded) {\n+            res = std::string(decoded);\n+            free(decoded);\n+        }\n+    }\n+    return res;\n+}"
      },
      {
        "sha": "3e434bf0a0b263ae1a26924710f29f2c5a33bf79",
        "filename": "src/httpserver.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/httpserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/httpserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -86,7 +86,7 @@ class HTTPRequest\n \n     /**\n      * Get the request header specified by hdr, or an empty string.\n-     * Return an pair (isPresent,string).\n+     * Return a pair (isPresent,string).\n      */\n     std::pair<bool, std::string> GetHeader(const std::string& hdr);\n \n@@ -125,7 +125,7 @@ class HTTPClosure\n     virtual ~HTTPClosure() {}\n };\n \n-/** Event class. This can be used either as an cross-thread trigger or as a timer.\n+/** Event class. This can be used either as a cross-thread trigger or as a timer.\n  */\n class HTTPEvent\n {\n@@ -148,4 +148,6 @@ class HTTPEvent\n     struct event* ev;\n };\n \n+std::string urlDecode(const std::string &urlEncoded);\n+\n #endif // BITCOIN_HTTPSERVER_H"
      },
      {
        "sha": "f0dbdb47c69365b1c5a950a61c28baace7f026c8",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 117,
        "deletions": 127,
        "changes": 244,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -55,7 +55,6 @@\n #endif\n \n #include <boost/algorithm/string/classification.hpp>\n-#include <boost/algorithm/string/predicate.hpp>\n #include <boost/algorithm/string/replace.hpp>\n #include <boost/algorithm/string/split.hpp>\n #include <boost/bind.hpp>\n@@ -89,14 +88,6 @@ static CZMQNotificationInterface* pzmqNotificationInterface = NULL;\n #define MIN_CORE_FILEDESCRIPTORS 150\n #endif\n \n-/** Used to pass flags to the Bind() function */\n-enum BindFlags {\n-    BF_NONE         = 0,\n-    BF_EXPLICIT     = (1U << 0),\n-    BF_REPORT_ERROR = (1U << 1),\n-    BF_WHITELIST    = (1U << 2),\n-};\n-\n static const char* FEE_ESTIMATES_FILENAME=\"fee_estimates.dat\";\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -162,7 +153,6 @@ class CCoinsViewErrorCatcher : public CCoinsViewBacked\n     // Writes do not need similar protection, as failure to write is handled by the caller.\n };\n \n-static CCoinsViewDB *pcoinsdbview = NULL;\n static CCoinsViewErrorCatcher *pcoinscatcher = NULL;\n static std::unique_ptr<ECCVerifyHandle> globalVerifyHandle;\n \n@@ -198,8 +188,9 @@ void Shutdown()\n     StopRPC();\n     StopHTTPServer();\n #ifdef ENABLE_WALLET\n-    if (pwalletMain)\n-        pwalletMain->Flush(false);\n+    for (CWalletRef pwallet : vpwallets) {\n+        pwallet->Flush(false);\n+    }\n #endif\n     MapPort(false);\n     UnregisterValidationInterface(peerLogic.get());\n@@ -224,6 +215,19 @@ void Shutdown()\n         fFeeEstimatesInitialized = false;\n     }\n \n+    // FlushStateToDisk generates a SetBestChain callback, which we should avoid missing\n+    FlushStateToDisk();\n+\n+    // After there are no more peers/RPC left to give us new data which may generate\n+    // CValidationInterface callbacks, flush them...\n+    GetMainSignals().FlushBackgroundCallbacks();\n+\n+    // Any future callbacks will be dropped. This should absolutely be safe - if\n+    // missing a callback results in an unrecoverable situation, unclean shutdown\n+    // would too. The only reason to do the above flushes is to let the wallet catch\n+    // up with our current chain to avoid any strange pruning edge cases and make\n+    // next startup faster by avoiding rescan.\n+\n     {\n         LOCK(cs_main);\n         if (pcoinsTip != NULL) {\n@@ -239,8 +243,9 @@ void Shutdown()\n         pblocktree = NULL;\n     }\n #ifdef ENABLE_WALLET\n-    if (pwalletMain)\n-        pwalletMain->Flush(true);\n+    for (CWalletRef pwallet : vpwallets) {\n+        pwallet->Flush(true);\n+    }\n #endif\n \n #if ENABLE_ZMQ\n@@ -259,9 +264,12 @@ void Shutdown()\n     }\n #endif\n     UnregisterAllValidationInterfaces();\n+    GetMainSignals().UnregisterBackgroundSignalScheduler();\n #ifdef ENABLE_WALLET\n-    delete pwalletMain;\n-    pwalletMain = NULL;\n+    for (CWalletRef pwallet : vpwallets) {\n+        delete pwallet;\n+    }\n+    vpwallets.clear();\n #endif\n     globalVerifyHandle.reset();\n     ECC_Stop();\n@@ -294,17 +302,6 @@ static void registerSignalHandler(int signal, void(*handler)(int))\n }\n #endif\n \n-bool static Bind(CConnman& connman, const CService &addr, unsigned int flags) {\n-    if (!(flags & BF_EXPLICIT) && IsLimited(addr))\n-        return false;\n-    std::string strError;\n-    if (!connman.BindListenPort(addr, strError, (flags & BF_WHITELIST) != 0)) {\n-        if (flags & BF_REPORT_ERROR)\n-            return InitError(strError);\n-        return false;\n-    }\n-    return true;\n-}\n void OnRPCStarted()\n {\n     uiInterface.NotifyBlockTip.connect(&RPCNotifyBlockChange);\n@@ -353,6 +350,9 @@ std::string HelpMessage(HelpMessageMode mode)\n #endif\n     }\n     strUsage += HelpMessageOpt(\"-datadir=<dir>\", _(\"Specify data directory\"));\n+    if (showDebug) {\n+        strUsage += HelpMessageOpt(\"-dbbatchsize\", strprintf(\"Maximum database write batch size in bytes (default: %u)\", nDefaultDbBatchSize));\n+    }\n     strUsage += HelpMessageOpt(\"-dbcache=<n>\", strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache));\n     if (showDebug)\n         strUsage += HelpMessageOpt(\"-feefilter\", strprintf(\"Tell other nodes to filter invs to us by our mempool min fee (default: %u)\", DEFAULT_FEEFILTER));\n@@ -461,7 +461,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     {\n         strUsage += HelpMessageOpt(\"-logtimemicros\", strprintf(\"Add microsecond precision to debug timestamps (default: %u)\", DEFAULT_LOGTIMEMICROS));\n         strUsage += HelpMessageOpt(\"-mocktime=<n>\", \"Replace actual time with <n> seconds since epoch (default: 0)\");\n-        strUsage += HelpMessageOpt(\"-maxsigcachesize=<n>\", strprintf(\"Limit size of signature cache to <n> MiB (default: %u)\", DEFAULT_MAX_SIG_CACHE_SIZE));\n+        strUsage += HelpMessageOpt(\"-maxsigcachesize=<n>\", strprintf(\"Limit sum of signature cache and script execution cache sizes to <n> MiB (default: %u)\", DEFAULT_MAX_SIG_CACHE_SIZE));\n         strUsage += HelpMessageOpt(\"-maxtipage=<n>\", strprintf(\"Maximum tip age in seconds to consider node in initial block download (default: %u)\", DEFAULT_MAX_TIP_AGE));\n     }\n     strUsage += HelpMessageOpt(\"-maxtxfee=<amt>\", strprintf(_(\"Maximum total fees (in %s) to use in a single wallet transaction or raw transaction; setting this too low may abort large transactions (default: %s)\"),\n@@ -479,7 +479,7 @@ std::string HelpMessage(HelpMessageMode mode)\n     if (showDebug) {\n         strUsage += HelpMessageOpt(\"-acceptnonstdtxn\", strprintf(\"Relay and mine \\\"non-standard\\\" transactions (%sdefault: %u)\", \"testnet/regtest only; \", defaultChainParams->RequireStandard()));\n         strUsage += HelpMessageOpt(\"-incrementalrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to define cost of relay, used for mempool limiting and BIP 125 replacement. (default: %s)\", CURRENCY_UNIT, FormatMoney(DEFAULT_INCREMENTAL_RELAY_FEE)));\n-        strUsage += HelpMessageOpt(\"-dustrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to defined dust, the value of an output such that it will cost about 1/3 of its value in fees at this fee rate to spend it. (default: %s)\", CURRENCY_UNIT, FormatMoney(DUST_RELAY_TX_FEE)));\n+        strUsage += HelpMessageOpt(\"-dustrelayfee=<amt>\", strprintf(\"Fee rate (in %s/kB) used to defined dust, the value of an output such that it will cost more than its value in fees at this fee rate to spend it. (default: %s)\", CURRENCY_UNIT, FormatMoney(DUST_RELAY_TX_FEE)));\n     }\n     strUsage += HelpMessageOpt(\"-bytespersigop\", strprintf(_(\"Equivalent bytes per sigop in transactions for relay and mining (default: %u)\"), DEFAULT_BYTES_PER_SIGOP));\n     strUsage += HelpMessageOpt(\"-datacarrier\", strprintf(_(\"Relay and mine data carrier transactions (default: %u)\"), DEFAULT_ACCEPT_DATACARRIER));\n@@ -611,7 +611,7 @@ void CleanupBlockRevFiles()\n     // keeping a separate counter.  Once we hit a gap (or if 0 doesn't exist)\n     // start removing block files.\n     int nContigCounter = 0;\n-    BOOST_FOREACH(const PAIRTYPE(std::string, fs::path)& item, mapBlockFiles) {\n+    for (const std::pair<std::string, fs::path>& item : mapBlockFiles) {\n         if (atoi(item.first) == nContigCounter) {\n             nContigCounter++;\n             continue;\n@@ -664,7 +664,7 @@ void ThreadImport(std::vector<fs::path> vImportFiles)\n     }\n \n     // -loadblock=\n-    BOOST_FOREACH(const fs::path& path, vImportFiles) {\n+    for (const fs::path& path : vImportFiles) {\n         FILE *file = fsbridge::fopen(path, \"rb\");\n         if (file) {\n             LogPrintf(\"Importing blocks file %s...\\n\", path.string());\n@@ -820,7 +820,7 @@ int nUserMaxConnections;\n int nFD;\n ServiceFlags nLocalServices = NODE_NETWORK;\n \n-}\n+} // namespace\n \n [[noreturn]] static void new_handler_terminate()\n {\n@@ -842,8 +842,6 @@ bool AppInitBasicSetup()\n     // Turn off Microsoft heap dump noise\n     _CrtSetReportMode(_CRT_WARN, _CRTDBG_MODE_FILE);\n     _CrtSetReportFile(_CRT_WARN, CreateFileA(\"NUL\", GENERIC_WRITE, 0, NULL, OPEN_EXISTING, 0, 0));\n-#endif\n-#if _MSC_VER >= 1400\n     // Disable confusing \"helpful\" text message on abort, Ctrl-C\n     _set_abort_behavior(0, _WRITE_ABORT_MSG | _CALL_REPORTFAULT);\n #endif\n@@ -898,10 +896,14 @@ bool AppInitParameterInteraction()\n             return InitError(_(\"Prune mode is incompatible with -txindex.\"));\n     }\n \n+    // -bind and -whitebind can't be set when not listening\n+    size_t nUserBind = gArgs.GetArgs(\"-bind\").size() + gArgs.GetArgs(\"-whitebind\").size();\n+    if (nUserBind != 0 && !gArgs.GetBoolArg(\"-listen\", DEFAULT_LISTEN)) {\n+        return InitError(\"Cannot set -bind or -whitebind together with -listen=0\");\n+    }\n+\n     // Make sure enough file descriptors are available\n-    int nBind = std::max(\n-                (gArgs.IsArgSet(\"-bind\") ? gArgs.GetArgs(\"-bind\").size() : 0) +\n-                (gArgs.IsArgSet(\"-whitebind\") ? gArgs.GetArgs(\"-whitebind\").size() : 0), size_t(1));\n+    int nBind = std::max(nUserBind, size_t(1));\n     nUserMaxConnections = GetArg(\"-maxconnections\", DEFAULT_MAX_PEER_CONNECTIONS);\n     nMaxConnections = std::max(nUserMaxConnections, 0);\n \n@@ -933,15 +935,13 @@ bool AppInitParameterInteraction()\n     }\n \n     // Now remove the logging categories which were explicitly excluded\n-    if (gArgs.IsArgSet(\"-debugexclude\")) {\n-        for (const std::string& cat : gArgs.GetArgs(\"-debugexclude\")) {\n-            uint32_t flag = 0;\n-            if (!GetLogCategory(&flag, &cat)) {\n-                InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debugexclude\", cat));\n-                continue;\n-            }\n-            logCategories &= ~flag;\n+    for (const std::string& cat : gArgs.GetArgs(\"-debugexclude\")) {\n+        uint32_t flag = 0;\n+        if (!GetLogCategory(&flag, &cat)) {\n+            InitWarning(strprintf(_(\"Unsupported logging category %s=%s.\"), \"-debugexclude\", cat));\n+            continue;\n         }\n+        logCategories &= ~flag;\n     }\n \n     // Check for -debugnet\n@@ -1028,14 +1028,7 @@ bool AppInitParameterInteraction()\n     if (nConnectTimeout <= 0)\n         nConnectTimeout = DEFAULT_CONNECT_TIMEOUT;\n \n-    // Fee-per-kilobyte amount required for mempool acceptance and relay\n-    // If you are mining, be careful setting this:\n-    // if you set it to zero then\n-    // a transaction spammer can cheaply fill blocks using\n-    // 0-fee transactions. It should be set above the real\n-    // cost to you of processing a transaction.\n-    if (IsArgSet(\"-minrelaytxfee\"))\n-    {\n+    if (IsArgSet(\"-minrelaytxfee\")) {\n         CAmount n = 0;\n         if (!ParseMoney(GetArg(\"-minrelaytxfee\", \"\"), n)) {\n             return InitError(AmountErrMsg(\"minrelaytxfee\", GetArg(\"-minrelaytxfee\", \"\")));\n@@ -1168,6 +1161,7 @@ bool AppInitSanityChecks()\n     // ********************************************************* Step 4: sanity checks\n \n     // Initialize elliptic curve code\n+    RandomInit();\n     ECC_Start();\n     globalVerifyHandle.reset(new ECCVerifyHandle());\n \n@@ -1176,21 +1170,27 @@ bool AppInitSanityChecks()\n         return InitError(strprintf(_(\"Initialization sanity check failed. %s is shutting down.\"), _(PACKAGE_NAME)));\n \n     // Probe the data directory lock to give an early error message, if possible\n+    // We cannot hold the data directory lock here, as the forking for daemon() hasn't yet happened,\n+    // and a fork will cause weird behavior to it.\n     return LockDataDirectory(true);\n }\n \n-bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n+bool AppInitLockDataDirectory()\n {\n-    const CChainParams& chainparams = Params();\n-    // ********************************************************* Step 4a: application initialization\n     // After daemonization get the data directory lock again and hold on to it until exit\n     // This creates a slight window for a race condition to happen, however this condition is harmless: it\n     // will at most make us exit without printing a message to console.\n     if (!LockDataDirectory(false)) {\n         // Detailed error printed inside LockDataDirectory\n         return false;\n     }\n+    return true;\n+}\n \n+bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n+{\n+    const CChainParams& chainparams = Params();\n+    // ********************************************************* Step 4a: application initialization\n #ifndef WIN32\n     CreatePidFile(GetPidFile(), getpid());\n #endif\n@@ -1211,6 +1211,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     LogPrintf(\"Using at most %i automatic connections (%i file descriptors available)\\n\", nMaxConnections, nFD);\n \n     InitSignatureCache();\n+    InitScriptExecutionCache();\n \n     LogPrintf(\"Using %u threads for script verification\\n\", nScriptCheckThreads);\n     if (nScriptCheckThreads) {\n@@ -1222,6 +1223,8 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     CScheduler::Function serviceLoop = boost::bind(&CScheduler::serviceQueue, &scheduler);\n     threadGroup.create_thread(boost::bind(&TraceThread<CScheduler::Function>, \"scheduler\", serviceLoop));\n \n+    GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n+\n     /* Start the RPC server already.  It will be started in \"warmup\" mode\n      * and not really process calls already (but it will signify connections\n      * that the server is there and will be ready later).  Warmup mode will\n@@ -1257,13 +1260,10 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     // sanitize comments per BIP-0014, format user agent and check total size\n     std::vector<std::string> uacomments;\n-    if (gArgs.IsArgSet(\"-uacomment\")) {\n-        BOOST_FOREACH(std::string cmt, gArgs.GetArgs(\"-uacomment\"))\n-        {\n-            if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))\n-                return InitError(strprintf(_(\"User Agent comment (%s) contains unsafe characters.\"), cmt));\n-            uacomments.push_back(cmt);\n-        }\n+    for (const std::string& cmt : gArgs.GetArgs(\"-uacomment\")) {\n+        if (cmt != SanitizeString(cmt, SAFE_CHARS_UA_COMMENT))\n+            return InitError(strprintf(_(\"User Agent comment (%s) contains unsafe characters.\"), cmt));\n+        uacomments.push_back(cmt);\n     }\n     strSubVersion = FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, uacomments);\n     if (strSubVersion.size() > MAX_SUBVERSION_LENGTH) {\n@@ -1273,7 +1273,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n \n     if (gArgs.IsArgSet(\"-onlynet\")) {\n         std::set<enum Network> nets;\n-        BOOST_FOREACH(const std::string& snet, gArgs.GetArgs(\"-onlynet\")) {\n+        for (const std::string& snet : gArgs.GetArgs(\"-onlynet\")) {\n             enum Network net = ParseNetwork(snet);\n             if (net == NET_UNROUTABLE)\n                 return InitError(strprintf(_(\"Unknown network specified in -onlynet: '%s'\"), snet));\n@@ -1286,16 +1286,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n         }\n     }\n \n-    if (gArgs.IsArgSet(\"-whitelist\")) {\n-        BOOST_FOREACH(const std::string& net, gArgs.GetArgs(\"-whitelist\")) {\n-            CSubNet subnet;\n-            LookupSubNet(net.c_str(), subnet);\n-            if (!subnet.IsValid())\n-                return InitError(strprintf(_(\"Invalid netmask specified in -whitelist: '%s'\"), net));\n-            connman.AddWhitelistedRange(subnet);\n-        }\n-    }\n-\n     // Check for host lookup allowed before parsing any network related parameters\n     fNameLookup = GetBoolArg(\"-dns\", DEFAULT_NAME_LOOKUP);\n \n@@ -1346,44 +1336,12 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     fDiscover = GetBoolArg(\"-discover\", true);\n     fRelayTxes = !GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY);\n \n-    if (fListen) {\n-        bool fBound = false;\n-        if (gArgs.IsArgSet(\"-bind\")) {\n-            BOOST_FOREACH(const std::string& strBind, gArgs.GetArgs(\"-bind\")) {\n-                CService addrBind;\n-                if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false))\n-                    return InitError(ResolveErrMsg(\"bind\", strBind));\n-                fBound |= Bind(connman, addrBind, (BF_EXPLICIT | BF_REPORT_ERROR));\n-            }\n-        }\n-        if (gArgs.IsArgSet(\"-whitebind\")) {\n-            BOOST_FOREACH(const std::string& strBind, gArgs.GetArgs(\"-whitebind\")) {\n-                CService addrBind;\n-                if (!Lookup(strBind.c_str(), addrBind, 0, false))\n-                    return InitError(ResolveErrMsg(\"whitebind\", strBind));\n-                if (addrBind.GetPort() == 0)\n-                    return InitError(strprintf(_(\"Need to specify a port with -whitebind: '%s'\"), strBind));\n-                fBound |= Bind(connman, addrBind, (BF_EXPLICIT | BF_REPORT_ERROR | BF_WHITELIST));\n-            }\n-        }\n-        if (!gArgs.IsArgSet(\"-bind\") && !gArgs.IsArgSet(\"-whitebind\")) {\n-            struct in_addr inaddr_any;\n-            inaddr_any.s_addr = INADDR_ANY;\n-            fBound |= Bind(connman, CService(in6addr_any, GetListenPort()), BF_NONE);\n-            fBound |= Bind(connman, CService(inaddr_any, GetListenPort()), !fBound ? BF_REPORT_ERROR : BF_NONE);\n-        }\n-        if (!fBound)\n-            return InitError(_(\"Failed to listen on any port. Use -listen=0 if you want this.\"));\n-    }\n-\n-    if (gArgs.IsArgSet(\"-externalip\")) {\n-        BOOST_FOREACH(const std::string& strAddr, gArgs.GetArgs(\"-externalip\")) {\n-            CService addrLocal;\n-            if (Lookup(strAddr.c_str(), addrLocal, GetListenPort(), fNameLookup) && addrLocal.IsValid())\n-                AddLocal(addrLocal, LOCAL_MANUAL);\n-            else\n-                return InitError(ResolveErrMsg(\"externalip\", strAddr));\n-        }\n+    for (const std::string& strAddr : gArgs.GetArgs(\"-externalip\")) {\n+        CService addrLocal;\n+        if (Lookup(strAddr.c_str(), addrLocal, GetListenPort(), fNameLookup) && addrLocal.IsValid())\n+            AddLocal(addrLocal, LOCAL_MANUAL);\n+        else\n+            return InitError(ResolveErrMsg(\"externalip\", strAddr));\n     }\n \n #if ENABLE_ZMQ\n@@ -1405,8 +1363,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     fReindex = GetBoolArg(\"-reindex\", false);\n     bool fReindexChainState = GetBoolArg(\"-reindex-chainstate\", false);\n \n-    fs::create_directories(GetDataDir() / \"blocks\");\n-\n     // cache size calculations\n     int64_t nTotalCache = (GetArg(\"-dbcache\", nDefaultDbCache) << 20);\n     nTotalCache = std::max(nTotalCache, nMinDbCache << 20); // total cache cannot be less than nMinDbCache\n@@ -1425,7 +1381,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     LogPrintf(\"* Using %.1fMiB for in-memory UTXO set (plus up to %.1fMiB of unused mempool space)\\n\", nCoinCacheUsage * (1.0 / 1024 / 1024), nMempoolSizeMax * (1.0 / 1024 / 1024));\n \n     bool fLoaded = false;\n-    while (!fLoaded) {\n+    while (!fLoaded && !fRequestShutdown) {\n         bool fReset = fReindex;\n         std::string strLoadError;\n \n@@ -1443,7 +1399,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                 pblocktree = new CBlockTreeDB(nBlockTreeDBCache, false, fReindex);\n                 pcoinsdbview = new CCoinsViewDB(nCoinDBCache, false, fReindex || fReindexChainState);\n                 pcoinscatcher = new CCoinsViewErrorCatcher(pcoinsdbview);\n-                pcoinsTip = new CCoinsViewCache(pcoinscatcher);\n \n                 if (fReindex) {\n                     pblocktree->WriteReindexing(true);\n@@ -1457,6 +1412,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                         break;\n                     }\n                 }\n+                if (fRequestShutdown) break;\n \n                 if (!LoadBlockIndex(chainparams)) {\n                     strLoadError = _(\"Error loading block database\");\n@@ -1487,6 +1443,13 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     break;\n                 }\n \n+                if (!ReplayBlocks(chainparams, pcoinsdbview)) {\n+                    strLoadError = _(\"Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.\");\n+                    break;\n+                }\n+                pcoinsTip = new CCoinsViewCache(pcoinscatcher);\n+                LoadChainTip(chainparams);\n+\n                 if (!fReindex && chainActive.Tip() != NULL) {\n                     uiInterface.InitMessage(_(\"Rewinding blocks...\"));\n                     if (!RewindBlockIndex(chainparams)) {\n@@ -1527,7 +1490,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n             fLoaded = true;\n         } while(false);\n \n-        if (!fLoaded) {\n+        if (!fLoaded && !fRequestShutdown) {\n             // first suggest a reindex\n             if (!fReset) {\n                 bool fRet = uiInterface.ThreadSafeQuestion(\n@@ -1555,7 +1518,9 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n         LogPrintf(\"Shutdown requested. Exiting.\\n\");\n         return false;\n     }\n-    LogPrintf(\" block index %15dms\\n\", GetTimeMillis() - nStart);\n+    if (fLoaded) {\n+        LogPrintf(\" block index %15dms\\n\", GetTimeMillis() - nStart);\n+    }\n \n     fs::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n     CAutoFile est_filein(fsbridge::fopen(est_path, \"rb\"), SER_DISK, CLIENT_VERSION);\n@@ -1614,10 +1579,8 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n         uiInterface.NotifyBlockTip.connect(BlockNotifyCallback);\n \n     std::vector<fs::path> vImportFiles;\n-    if (gArgs.IsArgSet(\"-loadblock\"))\n-    {\n-        BOOST_FOREACH(const std::string& strFile, gArgs.GetArgs(\"-loadblock\"))\n-            vImportFiles.push_back(strFile);\n+    for (const std::string& strFile : gArgs.GetArgs(\"-loadblock\")) {\n+        vImportFiles.push_back(strFile);\n     }\n \n     threadGroup.create_thread(boost::bind(&ThreadImport, vImportFiles));\n@@ -1644,7 +1607,6 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     // Map ports with UPnP\n     MapPort(GetBoolArg(\"-upnp\", DEFAULT_UPNP));\n \n-    std::string strNodeError;\n     CConnman::Options connOptions;\n     connOptions.nLocalServices = nLocalServices;\n     connOptions.nRelevantServices = nRelevantServices;\n@@ -1660,21 +1622,49 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n     connOptions.nMaxOutboundTimeframe = nMaxOutboundTimeframe;\n     connOptions.nMaxOutboundLimit = nMaxOutboundLimit;\n \n+    for (const std::string& strBind : gArgs.GetArgs(\"-bind\")) {\n+        CService addrBind;\n+        if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false)) {\n+            return InitError(ResolveErrMsg(\"bind\", strBind));\n+        }\n+        connOptions.vBinds.push_back(addrBind);\n+    }\n+    for (const std::string& strBind : gArgs.GetArgs(\"-whitebind\")) {\n+        CService addrBind;\n+        if (!Lookup(strBind.c_str(), addrBind, 0, false)) {\n+            return InitError(ResolveErrMsg(\"whitebind\", strBind));\n+        }\n+        if (addrBind.GetPort() == 0) {\n+            return InitError(strprintf(_(\"Need to specify a port with -whitebind: '%s'\"), strBind));\n+        }\n+        connOptions.vWhiteBinds.push_back(addrBind);\n+    }\n+\n+    for (const auto& net : gArgs.GetArgs(\"-whitelist\")) {\n+        CSubNet subnet;\n+        LookupSubNet(net.c_str(), subnet);\n+        if (!subnet.IsValid())\n+            return InitError(strprintf(_(\"Invalid netmask specified in -whitelist: '%s'\"), net));\n+        connOptions.vWhitelistedRange.push_back(subnet);\n+    }\n+\n     if (gArgs.IsArgSet(\"-seednode\")) {\n         connOptions.vSeedNodes = gArgs.GetArgs(\"-seednode\");\n     }\n \n-    if (!connman.Start(scheduler, strNodeError, connOptions))\n-        return InitError(strNodeError);\n+    if (!connman.Start(scheduler, connOptions)) {\n+        return false;\n+    }\n \n     // ********************************************************* Step 12: finished\n \n     SetRPCWarmupFinished();\n     uiInterface.InitMessage(_(\"Done loading\"));\n \n #ifdef ENABLE_WALLET\n-    if (pwalletMain)\n-        pwalletMain->postInitProcess(scheduler);\n+    for (CWalletRef pwallet : vpwallets) {\n+        pwallet->postInitProcess(scheduler);\n+    }\n #endif\n \n     return !fRequestShutdown;"
      },
      {
        "sha": "a0a824738cfe723ce68bbf0d1f01e3f508e1f85c",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 11,
        "deletions": 5,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -27,27 +27,33 @@ void InitLogging();\n void InitParameterInteraction();\n \n /** Initialize bitcoin core: Basic context setup.\n- *  @note This can be done before daemonization.\n+ *  @note This can be done before daemonization. Do not call Shutdown() if this function fails.\n  *  @pre Parameters should be parsed and config file should be read.\n  */\n bool AppInitBasicSetup();\n /**\n  * Initialization: parameter interaction.\n- * @note This can be done before daemonization.\n+ * @note This can be done before daemonization. Do not call Shutdown() if this function fails.\n  * @pre Parameters should be parsed and config file should be read, AppInitBasicSetup should have been called.\n  */\n bool AppInitParameterInteraction();\n /**\n  * Initialization sanity checks: ecc init, sanity checks, dir lock.\n- * @note This can be done before daemonization.\n+ * @note This can be done before daemonization. Do not call Shutdown() if this function fails.\n  * @pre Parameters should be parsed and config file should be read, AppInitParameterInteraction should have been called.\n  */\n bool AppInitSanityChecks();\n /**\n- * Bitcoin core main initialization.\n- * @note This should only be done after daemonization.\n+ * Lock bitcoin core data directory.\n+ * @note This should only be done after daemonization. Do not call Shutdown() if this function fails.\n  * @pre Parameters should be parsed and config file should be read, AppInitSanityChecks should have been called.\n  */\n+bool AppInitLockDataDirectory();\n+/**\n+ * Bitcoin core main initialization.\n+ * @note This should only be done after daemonization. Call Shutdown() if this function fails.\n+ * @pre Parameters should be parsed and config file should be read, AppInitLockDataDirectory should have been called.\n+ */\n bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler);\n \n /** The help message mode determines what help message to show */"
      },
      {
        "sha": "5a991fc1d2911cdf27309fe7ccb2aca65fdf1368",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -138,7 +138,7 @@ CPrivKey CKey::GetPrivKey() const {\n     size_t privkeylen;\n     privkey.resize(279);\n     privkeylen = 279;\n-    ret = ec_privkey_export_der(secp256k1_context_sign, (unsigned char*)&privkey[0], &privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);\n+    ret = ec_privkey_export_der(secp256k1_context_sign, (unsigned char*) privkey.data(), &privkeylen, begin(), fCompressed ? SECP256K1_EC_COMPRESSED : SECP256K1_EC_UNCOMPRESSED);\n     assert(ret);\n     privkey.resize(privkeylen);\n     return privkey;\n@@ -167,7 +167,7 @@ bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig, uint32_\n     secp256k1_ecdsa_signature sig;\n     int ret = secp256k1_ecdsa_sign(secp256k1_context_sign, &sig, hash.begin(), begin(), secp256k1_nonce_function_rfc6979, test_case ? extra_entropy : NULL);\n     assert(ret);\n-    secp256k1_ecdsa_signature_serialize_der(secp256k1_context_sign, (unsigned char*)&vchSig[0], &nSigLen, &sig);\n+    secp256k1_ecdsa_signature_serialize_der(secp256k1_context_sign, (unsigned char*)vchSig.data(), &nSigLen, &sig);\n     vchSig.resize(nSigLen);\n     return true;\n }\n@@ -202,7 +202,7 @@ bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig)\n }\n \n bool CKey::Load(CPrivKey &privkey, CPubKey &vchPubKey, bool fSkipCheck=false) {\n-    if (!ec_privkey_import_der(secp256k1_context_sign, (unsigned char*)begin(), &privkey[0], privkey.size()))\n+    if (!ec_privkey_import_der(secp256k1_context_sign, (unsigned char*)begin(), privkey.data(), privkey.size()))\n         return false;\n     fCompressed = vchPubKey.IsCompressed();\n     fValid = true;\n@@ -245,8 +245,8 @@ void CExtKey::SetMaster(const unsigned char *seed, unsigned int nSeedLen) {\n     static const unsigned char hashkey[] = {'B','i','t','c','o','i','n',' ','s','e','e','d'};\n     std::vector<unsigned char, secure_allocator<unsigned char>> vout(64);\n     CHMAC_SHA512(hashkey, sizeof(hashkey)).Write(seed, nSeedLen).Finalize(vout.data());\n-    key.Set(&vout[0], &vout[32], true);\n-    memcpy(chaincode.begin(), &vout[32], 32);\n+    key.Set(vout.data(), vout.data() + 32, true);\n+    memcpy(chaincode.begin(), vout.data() + 32, 32);\n     nDepth = 0;\n     nChild = 0;\n     memset(vchFingerprint, 0, sizeof(vchFingerprint));"
      },
      {
        "sha": "8454175ca81a0e5538a8b1ce054e46b65b3d67ea",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -9,8 +9,6 @@\n #include \"pubkey.h\"\n #include \"util.h\"\n \n-#include <boost/foreach.hpp>\n-\n bool CKeyStore::AddKey(const CKey &key) {\n     return AddKeyPubKey(key, key.GetPubKey());\n }"
      },
      {
        "sha": "965ae0c79ad865193afe0fb7041ca2c0ffe5f751",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 12,
        "deletions": 13,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -13,7 +13,6 @@\n #include \"sync.h\"\n \n #include <boost/signals2/signal.hpp>\n-#include <boost/variant.hpp>\n \n /** A virtual base class for key stores */\n class CKeyStore\n@@ -61,9 +60,9 @@ class CBasicKeyStore : public CKeyStore\n     WatchOnlySet setWatchOnly;\n \n public:\n-    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n-    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n-    bool HaveKey(const CKeyID &address) const\n+    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey) override;\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override;\n+    bool HaveKey(const CKeyID &address) const override\n     {\n         bool result;\n         {\n@@ -72,7 +71,7 @@ class CBasicKeyStore : public CKeyStore\n         }\n         return result;\n     }\n-    void GetKeys(std::set<CKeyID> &setAddress) const\n+    void GetKeys(std::set<CKeyID> &setAddress) const override\n     {\n         setAddress.clear();\n         {\n@@ -85,7 +84,7 @@ class CBasicKeyStore : public CKeyStore\n             }\n         }\n     }\n-    bool GetKey(const CKeyID &address, CKey &keyOut) const\n+    bool GetKey(const CKeyID &address, CKey &keyOut) const override\n     {\n         {\n             LOCK(cs_KeyStore);\n@@ -98,14 +97,14 @@ class CBasicKeyStore : public CKeyStore\n         }\n         return false;\n     }\n-    virtual bool AddCScript(const CScript& redeemScript);\n-    virtual bool HaveCScript(const CScriptID &hash) const;\n-    virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const;\n+    virtual bool AddCScript(const CScript& redeemScript) override;\n+    virtual bool HaveCScript(const CScriptID &hash) const override;\n+    virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const override;\n \n-    virtual bool AddWatchOnly(const CScript &dest);\n-    virtual bool RemoveWatchOnly(const CScript &dest);\n-    virtual bool HaveWatchOnly(const CScript &dest) const;\n-    virtual bool HaveWatchOnly() const;\n+    virtual bool AddWatchOnly(const CScript &dest) override;\n+    virtual bool RemoveWatchOnly(const CScript &dest) override;\n+    virtual bool HaveWatchOnly(const CScript &dest) const override;\n+    virtual bool HaveWatchOnly() const override;\n };\n \n typedef std::vector<unsigned char, secure_allocator<unsigned char> > CKeyingMaterial;"
      },
      {
        "sha": "f7cc7d736c4f20d6cab6e760d43b76e880b80e95",
        "filename": "src/leveldb/Makefile",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/Makefile?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -44,6 +44,7 @@ TESTS = \\\n \tutil/cache_test \\\n \tutil/coding_test \\\n \tutil/crc32c_test \\\n+\tutil/env_posix_test \\\n \tutil/env_test \\\n \tutil/hash_test\n \n@@ -121,7 +122,7 @@ SHARED_MEMENVLIB = $(SHARED_OUTDIR)/libmemenv.a\n else\n # Update db.h if you change these.\n SHARED_VERSION_MAJOR = 1\n-SHARED_VERSION_MINOR = 19\n+SHARED_VERSION_MINOR = 20\n SHARED_LIB1 = libleveldb.$(PLATFORM_SHARED_EXT)\n SHARED_LIB2 = $(SHARED_LIB1).$(SHARED_VERSION_MAJOR)\n SHARED_LIB3 = $(SHARED_LIB1).$(SHARED_VERSION_MAJOR).$(SHARED_VERSION_MINOR)\n@@ -337,6 +338,9 @@ $(STATIC_OUTDIR)/db_test:db/db_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n $(STATIC_OUTDIR)/dbformat_test:db/dbformat_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n \t$(CXX) $(LDFLAGS) $(CXXFLAGS) db/dbformat_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n+$(STATIC_OUTDIR)/env_posix_test:util/env_posix_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n+\t$(CXX) $(LDFLAGS) $(CXXFLAGS) util/env_posix_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n+\n $(STATIC_OUTDIR)/env_test:util/env_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS)\n \t$(CXX) $(LDFLAGS) $(CXXFLAGS) util/env_test.cc $(STATIC_LIBOBJECTS) $(TESTHARNESS) -o $@ $(LIBS)\n \n@@ -412,3 +416,9 @@ $(SHARED_OUTDIR)/%.o: %.cc\n \n $(SHARED_OUTDIR)/%.o: %.c\n \t$(CC) $(CFLAGS) $(PLATFORM_SHARED_CFLAGS) -c $< -o $@\n+\n+$(STATIC_OUTDIR)/port/port_posix_sse.o: port/port_posix_sse.cc\n+\t$(CXX) $(CXXFLAGS) $(PLATFORM_SSEFLAGS) -c $< -o $@\n+\n+$(SHARED_OUTDIR)/port/port_posix_sse.o: port/port_posix_sse.cc\n+\t$(CXX) $(CXXFLAGS) $(PLATFORM_SHARED_CFLAGS) $(PLATFORM_SSEFLAGS) -c $< -o $@"
      },
      {
        "sha": "a010c508585e89ad3aacf50dd3630feb05ac24db",
        "filename": "src/leveldb/README.md",
        "status": "modified",
        "additions": 13,
        "deletions": 12,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/README.md?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -16,7 +16,7 @@ Authors: Sanjay Ghemawat (sanjay@google.com) and Jeff Dean (jeff@google.com)\n   * External activity (file system operations etc.) is relayed through a virtual interface so users can customize the operating system interactions.\n \n # Documentation\n-  [LevelDB library documentation](https://rawgit.com/google/leveldb/master/doc/index.html) is online and bundled with the source code.\n+  [LevelDB library documentation](https://github.com/google/leveldb/blob/master/doc/index.md) is online and bundled with the source code.\n \n \n # Limitations\n@@ -113,29 +113,30 @@ by the one or two disk seeks needed to fetch the data from disk.\n Write performance will be mostly unaffected by whether or not the\n working set fits in memory.\n \n-    readrandom   :      16.677 micros/op;  (approximately 60,000 reads per second)\n-    readseq      :       0.476 micros/op;  232.3 MB/s\n-    readreverse  :       0.724 micros/op;  152.9 MB/s\n+    readrandom  : 16.677 micros/op;  (approximately 60,000 reads per second)\n+    readseq     :  0.476 micros/op;  232.3 MB/s\n+    readreverse :  0.724 micros/op;  152.9 MB/s\n \n LevelDB compacts its underlying storage data in the background to\n improve read performance.  The results listed above were done\n immediately after a lot of random writes.  The results after\n compactions (which are usually triggered automatically) are better.\n \n-    readrandom   :      11.602 micros/op;  (approximately 85,000 reads per second)\n-    readseq      :       0.423 micros/op;  261.8 MB/s\n-    readreverse  :       0.663 micros/op;  166.9 MB/s\n+    readrandom  : 11.602 micros/op;  (approximately 85,000 reads per second)\n+    readseq     :  0.423 micros/op;  261.8 MB/s\n+    readreverse :  0.663 micros/op;  166.9 MB/s\n \n Some of the high cost of reads comes from repeated decompression of blocks\n read from disk.  If we supply enough cache to the leveldb so it can hold the\n uncompressed blocks in memory, the read performance improves again:\n \n-    readrandom   :       9.775 micros/op;  (approximately 100,000 reads per second before compaction)\n-    readrandom   :       5.215 micros/op;  (approximately 190,000 reads per second after compaction)\n+    readrandom  : 9.775 micros/op;  (approximately 100,000 reads per second before compaction)\n+    readrandom  : 5.215 micros/op;  (approximately 190,000 reads per second after compaction)\n \n ## Repository contents\n \n-See doc/index.html for more explanation. See doc/impl.html for a brief overview of the implementation.\n+See [doc/index.md](doc/index.md) for more explanation. See\n+[doc/impl.md](doc/impl.md) for a brief overview of the implementation.\n \n The public interface is in include/*.h.  Callers should not include or\n rely on the details of any other header files in this package.  Those\n@@ -148,7 +149,7 @@ Guide to header files:\n * **include/options.h**: Control over the behavior of an entire database,\n and also control over the behavior of individual reads and writes.\n \n-* **include/comparator.h**: Abstraction for user-specified comparison function. \n+* **include/comparator.h**: Abstraction for user-specified comparison function.\n If you want just bytewise comparison of keys, you can use the default\n comparator, but clients can write their own comparator implementations if they\n want custom ordering (e.g. to handle different character encodings, etc.)\n@@ -165,7 +166,7 @@ length into some other byte array.\n * **include/status.h**: Status is returned from many of the public interfaces\n and is used to report success and various kinds of errors.\n \n-* **include/env.h**: \n+* **include/env.h**:\n Abstraction of the OS environment.  A posix implementation of this interface is\n in util/env_posix.cc\n "
      },
      {
        "sha": "4a94715900969161b9f29d41e27f0659c648df10",
        "filename": "src/leveldb/build_detect_platform",
        "status": "modified",
        "additions": 29,
        "deletions": 1,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/build_detect_platform",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/build_detect_platform",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/build_detect_platform?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -63,6 +63,7 @@ PLATFORM_SHARED_EXT=\"so\"\n PLATFORM_SHARED_LDFLAGS=\"-shared -Wl,-soname -Wl,\"\n PLATFORM_SHARED_CFLAGS=\"-fPIC\"\n PLATFORM_SHARED_VERSIONED=true\n+PLATFORM_SSEFLAGS=\n \n MEMCMP_FLAG=\n if [ \"$CXX\" = \"g++\" ]; then\n@@ -77,6 +78,7 @@ case \"$TARGET_OS\" in\n         COMMON_FLAGS=\"$MEMCMP_FLAG -lpthread -DOS_LINUX -DCYGWIN\"\n         PLATFORM_LDFLAGS=\"-lpthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     Darwin)\n         PLATFORM=OS_MACOSX\n@@ -85,24 +87,28 @@ case \"$TARGET_OS\" in\n         [ -z \"$INSTALL_PATH\" ] && INSTALL_PATH=`pwd`\n         PLATFORM_SHARED_LDFLAGS=\"-dynamiclib -install_name $INSTALL_PATH/\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     Linux)\n         PLATFORM=OS_LINUX\n         COMMON_FLAGS=\"$MEMCMP_FLAG -pthread -DOS_LINUX\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     SunOS)\n         PLATFORM=OS_SOLARIS\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_SOLARIS\"\n         PLATFORM_LIBS=\"-lpthread -lrt\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     FreeBSD)\n         PLATFORM=OS_FREEBSD\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_FREEBSD\"\n         PLATFORM_LIBS=\"-lpthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     GNU/kFreeBSD)\n         PLATFORM=OS_KFREEBSD\n@@ -115,31 +121,36 @@ case \"$TARGET_OS\" in\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_NETBSD\"\n         PLATFORM_LIBS=\"-lpthread -lgcc_s\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     OpenBSD)\n         PLATFORM=OS_OPENBSD\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_OPENBSD\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     DragonFly)\n         PLATFORM=OS_DRAGONFLYBSD\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_DRAGONFLYBSD\"\n         PLATFORM_LIBS=\"-lpthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         ;;\n     OS_ANDROID_CROSSCOMPILE)\n         PLATFORM=OS_ANDROID\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_ANDROID -DLEVELDB_PLATFORM_POSIX\"\n         PLATFORM_LDFLAGS=\"\"  # All pthread features are in the Android C library\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         CROSS_COMPILE=true\n         ;;\n     HP-UX)\n         PLATFORM=OS_HPUX\n         COMMON_FLAGS=\"$MEMCMP_FLAG -D_REENTRANT -DOS_HPUX\"\n         PLATFORM_LDFLAGS=\"-pthread\"\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         # man ld: +h internal_name\n         PLATFORM_SHARED_LDFLAGS=\"-shared -Wl,+h -Wl,\"\n         ;;\n@@ -148,6 +159,7 @@ case \"$TARGET_OS\" in\n         COMMON_FLAGS=\"$MEMCMP_FLAG -DOS_MACOSX\"\n         [ -z \"$INSTALL_PATH\" ] && INSTALL_PATH=`pwd`\n         PORT_FILE=port/port_posix.cc\n+        PORT_SSE_FILE=port/port_posix_sse.cc\n         PLATFORM_SHARED_EXT=\n         PLATFORM_SHARED_LDFLAGS=\n         PLATFORM_SHARED_CFLAGS=\n@@ -182,7 +194,7 @@ set +f # re-enable globbing\n \n # The sources consist of the portable files, plus the platform-specific port\n # file.\n-echo \"SOURCES=$PORTABLE_FILES $PORT_FILE\" >> $OUTPUT\n+echo \"SOURCES=$PORTABLE_FILES $PORT_FILE $PORT_SSE_FILE\" >> $OUTPUT\n echo \"MEMENV_SOURCES=helpers/memenv/memenv.cc\" >> $OUTPUT\n \n if [ \"$CROSS_COMPILE\" = \"true\" ]; then\n@@ -213,6 +225,21 @@ EOF\n     fi\n \n     rm -f $CXXOUTPUT 2>/dev/null\n+\n+    # Test if gcc SSE 4.2 is supported\n+    $CXX $CXXFLAGS -x c++ - -o $CXXOUTPUT -msse4.2 2>/dev/null  <<EOF\n+      int main() {}\n+EOF\n+    if [ \"$?\" = 0 ]; then\n+        PLATFORM_SSEFLAGS=\"-msse4.2\"\n+    fi\n+\n+    rm -f $CXXOUTPUT 2>/dev/null\n+fi\n+\n+# Use the SSE 4.2 CRC32C intrinsics iff runtime checks indicate compiler supports them.\n+if [ -n \"$PLATFORM_SSEFLAGS\" ]; then\n+    PLATFORM_SSEFLAGS=\"$PLATFORM_SSEFLAGS -DLEVELDB_PLATFORM_POSIX_SSE\"\n fi\n \n PLATFORM_CCFLAGS=\"$PLATFORM_CCFLAGS $COMMON_FLAGS\"\n@@ -225,6 +252,7 @@ echo \"PLATFORM_LDFLAGS=$PLATFORM_LDFLAGS\" >> $OUTPUT\n echo \"PLATFORM_LIBS=$PLATFORM_LIBS\" >> $OUTPUT\n echo \"PLATFORM_CCFLAGS=$PLATFORM_CCFLAGS\" >> $OUTPUT\n echo \"PLATFORM_CXXFLAGS=$PLATFORM_CXXFLAGS\" >> $OUTPUT\n+echo \"PLATFORM_SSEFLAGS=$PLATFORM_SSEFLAGS\" >> $OUTPUT\n echo \"PLATFORM_SHARED_CFLAGS=$PLATFORM_SHARED_CFLAGS\" >> $OUTPUT\n echo \"PLATFORM_SHARED_EXT=$PLATFORM_SHARED_EXT\" >> $OUTPUT\n echo \"PLATFORM_SHARED_LDFLAGS=$PLATFORM_SHARED_LDFLAGS\" >> $OUTPUT"
      },
      {
        "sha": "3ad19a512b56c92ba4d4ba26d1a8638d12611d57",
        "filename": "src/leveldb/db/db_bench.cc",
        "status": "modified",
        "additions": 29,
        "deletions": 9,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/db/db_bench.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/db/db_bench.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_bench.cc?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -84,6 +84,14 @@ static bool FLAGS_histogram = false;\n // (initialized to default value by \"main\")\n static int FLAGS_write_buffer_size = 0;\n \n+// Number of bytes written to each file.\n+// (initialized to default value by \"main\")\n+static int FLAGS_max_file_size = 0;\n+\n+// Approximate size of user data packed per block (before compression.\n+// (initialized to default value by \"main\")\n+static int FLAGS_block_size = 0;\n+\n // Number of bytes to use as a cache of uncompressed data.\n // Negative means use default settings.\n static int FLAGS_cache_size = -1;\n@@ -109,6 +117,7 @@ static const char* FLAGS_db = NULL;\n namespace leveldb {\n \n namespace {\n+leveldb::Env* g_env = NULL;\n \n // Helper for quickly generating random data.\n class RandomGenerator {\n@@ -186,7 +195,7 @@ class Stats {\n     done_ = 0;\n     bytes_ = 0;\n     seconds_ = 0;\n-    start_ = Env::Default()->NowMicros();\n+    start_ = g_env->NowMicros();\n     finish_ = start_;\n     message_.clear();\n   }\n@@ -204,7 +213,7 @@ class Stats {\n   }\n \n   void Stop() {\n-    finish_ = Env::Default()->NowMicros();\n+    finish_ = g_env->NowMicros();\n     seconds_ = (finish_ - start_) * 1e-6;\n   }\n \n@@ -214,7 +223,7 @@ class Stats {\n \n   void FinishedSingleOp() {\n     if (FLAGS_histogram) {\n-      double now = Env::Default()->NowMicros();\n+      double now = g_env->NowMicros();\n       double micros = now - last_op_finish_;\n       hist_.Add(micros);\n       if (micros > 20000) {\n@@ -404,10 +413,10 @@ class Benchmark {\n     reads_(FLAGS_reads < 0 ? FLAGS_num : FLAGS_reads),\n     heap_counter_(0) {\n     std::vector<std::string> files;\n-    Env::Default()->GetChildren(FLAGS_db, &files);\n+    g_env->GetChildren(FLAGS_db, &files);\n     for (size_t i = 0; i < files.size(); i++) {\n       if (Slice(files[i]).starts_with(\"heap-\")) {\n-        Env::Default()->DeleteFile(std::string(FLAGS_db) + \"/\" + files[i]);\n+        g_env->DeleteFile(std::string(FLAGS_db) + \"/\" + files[i]);\n       }\n     }\n     if (!FLAGS_use_existing_db) {\n@@ -589,7 +598,7 @@ class Benchmark {\n       arg[i].shared = &shared;\n       arg[i].thread = new ThreadState(i);\n       arg[i].thread->shared = &shared;\n-      Env::Default()->StartThread(ThreadBody, &arg[i]);\n+      g_env->StartThread(ThreadBody, &arg[i]);\n     }\n \n     shared.mu.Lock();\n@@ -700,9 +709,12 @@ class Benchmark {\n   void Open() {\n     assert(db_ == NULL);\n     Options options;\n+    options.env = g_env;\n     options.create_if_missing = !FLAGS_use_existing_db;\n     options.block_cache = cache_;\n     options.write_buffer_size = FLAGS_write_buffer_size;\n+    options.max_file_size = FLAGS_max_file_size;\n+    options.block_size = FLAGS_block_size;\n     options.max_open_files = FLAGS_open_files;\n     options.filter_policy = filter_policy_;\n     options.reuse_logs = FLAGS_reuse_logs;\n@@ -925,7 +937,7 @@ class Benchmark {\n     char fname[100];\n     snprintf(fname, sizeof(fname), \"%s/heap-%04d\", FLAGS_db, ++heap_counter_);\n     WritableFile* file;\n-    Status s = Env::Default()->NewWritableFile(fname, &file);\n+    Status s = g_env->NewWritableFile(fname, &file);\n     if (!s.ok()) {\n       fprintf(stderr, \"%s\\n\", s.ToString().c_str());\n       return;\n@@ -934,7 +946,7 @@ class Benchmark {\n     delete file;\n     if (!ok) {\n       fprintf(stderr, \"heap profiling not supported\\n\");\n-      Env::Default()->DeleteFile(fname);\n+      g_env->DeleteFile(fname);\n     }\n   }\n };\n@@ -943,6 +955,8 @@ class Benchmark {\n \n int main(int argc, char** argv) {\n   FLAGS_write_buffer_size = leveldb::Options().write_buffer_size;\n+  FLAGS_max_file_size = leveldb::Options().max_file_size;\n+  FLAGS_block_size = leveldb::Options().block_size;\n   FLAGS_open_files = leveldb::Options().max_open_files;\n   std::string default_db_path;\n \n@@ -973,6 +987,10 @@ int main(int argc, char** argv) {\n       FLAGS_value_size = n;\n     } else if (sscanf(argv[i], \"--write_buffer_size=%d%c\", &n, &junk) == 1) {\n       FLAGS_write_buffer_size = n;\n+    } else if (sscanf(argv[i], \"--max_file_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_max_file_size = n;\n+    } else if (sscanf(argv[i], \"--block_size=%d%c\", &n, &junk) == 1) {\n+      FLAGS_block_size = n;\n     } else if (sscanf(argv[i], \"--cache_size=%d%c\", &n, &junk) == 1) {\n       FLAGS_cache_size = n;\n     } else if (sscanf(argv[i], \"--bloom_bits=%d%c\", &n, &junk) == 1) {\n@@ -987,9 +1005,11 @@ int main(int argc, char** argv) {\n     }\n   }\n \n+  leveldb::g_env = leveldb::Env::Default();\n+\n   // Choose a location for the test database if none given with --db=<path>\n   if (FLAGS_db == NULL) {\n-      leveldb::Env::Default()->GetTestDirectory(&default_db_path);\n+      leveldb::g_env->GetTestDirectory(&default_db_path);\n       default_db_path += \"/dbbench\";\n       FLAGS_db = default_db_path.c_str();\n   }"
      },
      {
        "sha": "f43ad7679436b312959e5e0487c9313694d83ecc",
        "filename": "src/leveldb/db/db_impl.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/db/db_impl.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/db/db_impl.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/db_impl.cc?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -96,6 +96,7 @@ Options SanitizeOptions(const std::string& dbname,\n   result.filter_policy = (src.filter_policy != NULL) ? ipolicy : NULL;\n   ClipToRange(&result.max_open_files,    64 + kNumNonTableCacheFiles, 50000);\n   ClipToRange(&result.write_buffer_size, 64<<10,                      1<<30);\n+  ClipToRange(&result.max_file_size,     1<<20,                       1<<30);\n   ClipToRange(&result.block_size,        1<<10,                       4<<20);\n   if (result.info_log == NULL) {\n     // Open a log file in the same directory as the db"
      },
      {
        "sha": "356e69fca231def5f74b95eaff53f12f42169317",
        "filename": "src/leveldb/db/log_format.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/db/log_format.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/db/log_format.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/log_format.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -3,7 +3,7 @@\n // found in the LICENSE file. See the AUTHORS file for names of contributors.\n //\n // Log format information shared by reader and writer.\n-// See ../doc/log_format.txt for more detail.\n+// See ../doc/log_format.md for more detail.\n \n #ifndef STORAGE_LEVELDB_DB_LOG_FORMAT_H_\n #define STORAGE_LEVELDB_DB_LOG_FORMAT_H_"
      },
      {
        "sha": "b1256f90e1c2bc6f9f6f449029bed9266bbb55b9",
        "filename": "src/leveldb/db/version_set.cc",
        "status": "modified",
        "additions": 35,
        "deletions": 22,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/db/version_set.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/db/version_set.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set.cc?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -20,30 +20,39 @@\n \n namespace leveldb {\n \n-static const int kTargetFileSize = 2 * 1048576;\n+static int TargetFileSize(const Options* options) {\n+  return options->max_file_size;\n+}\n \n // Maximum bytes of overlaps in grandparent (i.e., level+2) before we\n // stop building a single file in a level->level+1 compaction.\n-static const int64_t kMaxGrandParentOverlapBytes = 10 * kTargetFileSize;\n+static int64_t MaxGrandParentOverlapBytes(const Options* options) {\n+  return 10 * TargetFileSize(options);\n+}\n \n // Maximum number of bytes in all compacted files.  We avoid expanding\n // the lower level file set of a compaction if it would make the\n // total compaction cover more than this many bytes.\n-static const int64_t kExpandedCompactionByteSizeLimit = 25 * kTargetFileSize;\n+static int64_t ExpandedCompactionByteSizeLimit(const Options* options) {\n+  return 25 * TargetFileSize(options);\n+}\n \n-static double MaxBytesForLevel(int level) {\n+static double MaxBytesForLevel(const Options* options, int level) {\n   // Note: the result for level zero is not really used since we set\n   // the level-0 compaction threshold based on number of files.\n-  double result = 10 * 1048576.0;  // Result for both level-0 and level-1\n+\n+  // Result for both level-0 and level-1\n+  double result = 10. * 1048576.0;\n   while (level > 1) {\n     result *= 10;\n     level--;\n   }\n   return result;\n }\n \n-static uint64_t MaxFileSizeForLevel(int level) {\n-  return kTargetFileSize;  // We could vary per level to reduce number of files?\n+static uint64_t MaxFileSizeForLevel(const Options* options, int level) {\n+  // We could vary per level to reduce number of files?\n+  return TargetFileSize(options);\n }\n \n static int64_t TotalFileSize(const std::vector<FileMetaData*>& files) {\n@@ -508,7 +517,7 @@ int Version::PickLevelForMemTableOutput(\n         // Check that file does not overlap too many grandparent bytes.\n         GetOverlappingInputs(level + 2, &start, &limit, &overlaps);\n         const int64_t sum = TotalFileSize(overlaps);\n-        if (sum > kMaxGrandParentOverlapBytes) {\n+        if (sum > MaxGrandParentOverlapBytes(vset_->options_)) {\n           break;\n         }\n       }\n@@ -1027,7 +1036,7 @@ bool VersionSet::ReuseManifest(const std::string& dscname,\n       manifest_type != kDescriptorFile ||\n       !env_->GetFileSize(dscname, &manifest_size).ok() ||\n       // Make new compacted MANIFEST if old one is too big\n-      manifest_size >= kTargetFileSize) {\n+      manifest_size >= TargetFileSize(options_)) {\n     return false;\n   }\n \n@@ -1076,7 +1085,8 @@ void VersionSet::Finalize(Version* v) {\n     } else {\n       // Compute the ratio of current size to size limit.\n       const uint64_t level_bytes = TotalFileSize(v->files_[level]);\n-      score = static_cast<double>(level_bytes) / MaxBytesForLevel(level);\n+      score =\n+          static_cast<double>(level_bytes) / MaxBytesForLevel(options_, level);\n     }\n \n     if (score > best_score) {\n@@ -1290,7 +1300,7 @@ Compaction* VersionSet::PickCompaction() {\n     level = current_->compaction_level_;\n     assert(level >= 0);\n     assert(level+1 < config::kNumLevels);\n-    c = new Compaction(level);\n+    c = new Compaction(options_, level);\n \n     // Pick the first file that comes after compact_pointer_[level]\n     for (size_t i = 0; i < current_->files_[level].size(); i++) {\n@@ -1307,7 +1317,7 @@ Compaction* VersionSet::PickCompaction() {\n     }\n   } else if (seek_compaction) {\n     level = current_->file_to_compact_level_;\n-    c = new Compaction(level);\n+    c = new Compaction(options_, level);\n     c->inputs_[0].push_back(current_->file_to_compact_);\n   } else {\n     return NULL;\n@@ -1352,7 +1362,8 @@ void VersionSet::SetupOtherInputs(Compaction* c) {\n     const int64_t inputs1_size = TotalFileSize(c->inputs_[1]);\n     const int64_t expanded0_size = TotalFileSize(expanded0);\n     if (expanded0.size() > c->inputs_[0].size() &&\n-        inputs1_size + expanded0_size < kExpandedCompactionByteSizeLimit) {\n+        inputs1_size + expanded0_size <\n+            ExpandedCompactionByteSizeLimit(options_)) {\n       InternalKey new_start, new_limit;\n       GetRange(expanded0, &new_start, &new_limit);\n       std::vector<FileMetaData*> expanded1;\n@@ -1414,7 +1425,7 @@ Compaction* VersionSet::CompactRange(\n   // and we must not pick one file and drop another older file if the\n   // two files overlap.\n   if (level > 0) {\n-    const uint64_t limit = MaxFileSizeForLevel(level);\n+    const uint64_t limit = MaxFileSizeForLevel(options_, level);\n     uint64_t total = 0;\n     for (size_t i = 0; i < inputs.size(); i++) {\n       uint64_t s = inputs[i]->file_size;\n@@ -1426,17 +1437,17 @@ Compaction* VersionSet::CompactRange(\n     }\n   }\n \n-  Compaction* c = new Compaction(level);\n+  Compaction* c = new Compaction(options_, level);\n   c->input_version_ = current_;\n   c->input_version_->Ref();\n   c->inputs_[0] = inputs;\n   SetupOtherInputs(c);\n   return c;\n }\n \n-Compaction::Compaction(int level)\n+Compaction::Compaction(const Options* options, int level)\n     : level_(level),\n-      max_output_file_size_(MaxFileSizeForLevel(level)),\n+      max_output_file_size_(MaxFileSizeForLevel(options, level)),\n       input_version_(NULL),\n       grandparent_index_(0),\n       seen_key_(false),\n@@ -1453,12 +1464,13 @@ Compaction::~Compaction() {\n }\n \n bool Compaction::IsTrivialMove() const {\n+  const VersionSet* vset = input_version_->vset_;\n   // Avoid a move if there is lots of overlapping grandparent data.\n   // Otherwise, the move could create a parent file that will require\n   // a very expensive merge later on.\n-  return (num_input_files(0) == 1 &&\n-          num_input_files(1) == 0 &&\n-          TotalFileSize(grandparents_) <= kMaxGrandParentOverlapBytes);\n+  return (num_input_files(0) == 1 && num_input_files(1) == 0 &&\n+          TotalFileSize(grandparents_) <=\n+              MaxGrandParentOverlapBytes(vset->options_));\n }\n \n void Compaction::AddInputDeletions(VersionEdit* edit) {\n@@ -1491,8 +1503,9 @@ bool Compaction::IsBaseLevelForKey(const Slice& user_key) {\n }\n \n bool Compaction::ShouldStopBefore(const Slice& internal_key) {\n+  const VersionSet* vset = input_version_->vset_;\n   // Scan to find earliest grandparent file that contains key.\n-  const InternalKeyComparator* icmp = &input_version_->vset_->icmp_;\n+  const InternalKeyComparator* icmp = &vset->icmp_;\n   while (grandparent_index_ < grandparents_.size() &&\n       icmp->Compare(internal_key,\n                     grandparents_[grandparent_index_]->largest.Encode()) > 0) {\n@@ -1503,7 +1516,7 @@ bool Compaction::ShouldStopBefore(const Slice& internal_key) {\n   }\n   seen_key_ = true;\n \n-  if (overlapped_bytes_ > kMaxGrandParentOverlapBytes) {\n+  if (overlapped_bytes_ > MaxGrandParentOverlapBytes(vset->options_)) {\n     // Too much overlap for current output; start new output\n     overlapped_bytes_ = 0;\n     return true;"
      },
      {
        "sha": "7935a965a7c9fdd62533a8c13c9b6033675066df",
        "filename": "src/leveldb/db/version_set.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/db/version_set.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/db/version_set.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/db/version_set.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -366,7 +366,7 @@ class Compaction {\n   friend class Version;\n   friend class VersionSet;\n \n-  explicit Compaction(int level);\n+  Compaction(const Options* options, int level);\n \n   int level_;\n   uint64_t max_output_file_size_;\n@@ -376,7 +376,7 @@ class Compaction {\n   // Each compaction reads inputs from \"level_\" and \"level_+1\"\n   std::vector<FileMetaData*> inputs_[2];      // The two sets of inputs\n \n-  // State used to check for number of of overlapping grandparent files\n+  // State used to check for number of overlapping grandparent files\n   // (parent == level_ + 1, grandparent == level_ + 2)\n   std::vector<FileMetaData*> grandparents_;\n   size_t grandparent_index_;  // Index in grandparent_starts_"
      },
      {
        "sha": "700c564e433827c311cd8a26896ceaa7c8260818",
        "filename": "src/leveldb/doc/doc.css",
        "status": "removed",
        "additions": 0,
        "deletions": 89,
        "changes": 89,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/leveldb/doc/doc.css",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/leveldb/doc/doc.css",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/doc.css?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,89 +0,0 @@\n-body {\n-  margin-left: 0.5in;\n-  margin-right: 0.5in;\n-  background: white;\n-  color: black;\n-}\n-\n-h1 {\n-  margin-left: -0.2in;\n-  font-size: 14pt;\n-}\n-h2 {\n-  margin-left: -0in;\n-  font-size: 12pt;\n-}\n-h3 {\n-  margin-left: -0in;\n-}\n-h4 {\n-  margin-left: -0in;\n-}\n-hr {\n-  margin-left: -0in;\n-}\n-\n-/* Definition lists: definition term bold */\n-dt {\n-  font-weight: bold;\n-}\n-\n-address {\n-  text-align: center;\n-}\n-code,samp,var {\n-  color: blue;\n-}\n-kbd {\n-  color: #600000;\n-}\n-div.note p {\n-  float: right;\n-  width: 3in;\n-  margin-right: 0%;\n-  padding: 1px;\n-  border: 2px solid #6060a0;\n-  background-color: #fffff0;\n-}\n-\n-ul {\n-  margin-top: -0em;\n-  margin-bottom: -0em;\n-}\n-\n-ol {\n-  margin-top: -0em;\n-  margin-bottom: -0em;\n-}\n-\n-UL.nobullets {\n-  list-style-type: none;\n-  list-style-image: none;\n-  margin-left: -1em;\n-}\n-\n-p {\n-  margin: 1em 0 1em 0;\n-  padding: 0 0 0 0;\n-}\n-\n-pre {\n-  line-height: 1.3em;\n-  padding: 0.4em 0 0.8em 0;\n-  margin:  0 0 0 0;\n-  border:  0 0 0 0;\n-  color: blue;\n-}\n-\n-.datatable {\n-  margin-left: auto;\n-  margin-right: auto;\n-  margin-top: 2em;\n-  margin-bottom: 2em;\n-  border: 1px solid;\n-}\n-\n-.datatable td,th {\n-  padding: 0 0.5em 0 0.5em;\n-  text-align: right;\n-}"
      },
      {
        "sha": "6a468be0955d921a3e7bad2d55a71989209d06ae",
        "filename": "src/leveldb/doc/impl.html",
        "status": "removed",
        "additions": 0,
        "deletions": 213,
        "changes": 213,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/leveldb/doc/impl.html",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/leveldb/doc/impl.html",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/impl.html?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,213 +0,0 @@\n-<!DOCTYPE html>\n-<html>\n-<head>\n-<link rel=\"stylesheet\" type=\"text/css\" href=\"doc.css\" />\n-<title>Leveldb file layout and compactions</title>\n-</head>\n-\n-<body>\n-\n-<h1>Files</h1>\n-\n-The implementation of leveldb is similar in spirit to the\n-representation of a single\n-<a href=\"http://research.google.com/archive/bigtable.html\">\n-Bigtable tablet (section 5.3)</a>.\n-However the organization of the files that make up the representation\n-is somewhat different and is explained below.\n-\n-<p>\n-Each database is represented by a set of files stored in a directory.\n-There are several different types of files as documented below:\n-<p>\n-<h2>Log files</h2>\n-<p>\n-A log file (*.log) stores a sequence of recent updates.  Each update\n-is appended to the current log file.  When the log file reaches a\n-pre-determined size (approximately 4MB by default), it is converted\n-to a sorted table (see below) and a new log file is created for future\n-updates.\n-<p>\n-A copy of the current log file is kept in an in-memory structure (the\n-<code>memtable</code>).  This copy is consulted on every read so that read\n-operations reflect all logged updates.\n-<p>\n-<h2>Sorted tables</h2>\n-<p>\n-A sorted table (*.sst) stores a sequence of entries sorted by key.\n-Each entry is either a value for the key, or a deletion marker for the\n-key.  (Deletion markers are kept around to hide obsolete values\n-present in older sorted tables).\n-<p>\n-The set of sorted tables are organized into a sequence of levels.  The\n-sorted table generated from a log file is placed in a special <code>young</code>\n-level (also called level-0).  When the number of young files exceeds a\n-certain threshold (currently four), all of the young files are merged\n-together with all of the overlapping level-1 files to produce a\n-sequence of new level-1 files (we create a new level-1 file for every\n-2MB of data.)\n-<p>\n-Files in the young level may contain overlapping keys.  However files\n-in other levels have distinct non-overlapping key ranges.  Consider\n-level number L where L >= 1.  When the combined size of files in\n-level-L exceeds (10^L) MB (i.e., 10MB for level-1, 100MB for level-2,\n-...), one file in level-L, and all of the overlapping files in\n-level-(L+1) are merged to form a set of new files for level-(L+1).\n-These merges have the effect of gradually migrating new updates from\n-the young level to the largest level using only bulk reads and writes\n-(i.e., minimizing expensive seeks).\n-\n-<h2>Manifest</h2>\n-<p>\n-A MANIFEST file lists the set of sorted tables that make up each\n-level, the corresponding key ranges, and other important metadata.\n-A new MANIFEST file (with a new number embedded in the file name)\n-is created whenever the database is reopened.  The MANIFEST file is\n-formatted as a log, and changes made to the serving state (as files\n-are added or removed) are appended to this log.\n-<p>\n-<h2>Current</h2>\n-<p>\n-CURRENT is a simple text file that contains the name of the latest\n-MANIFEST file.\n-<p>\n-<h2>Info logs</h2>\n-<p>\n-Informational messages are printed to files named LOG and LOG.old.\n-<p>\n-<h2>Others</h2>\n-<p>\n-Other files used for miscellaneous purposes may also be present\n-(LOCK, *.dbtmp).\n-\n-<h1>Level 0</h1>\n-When the log file grows above a certain size (1MB by default):\n-<ul>\n-<li>Create a brand new memtable and log file and direct future updates here\n-<li>In the background:\n-<ul>\n-<li>Write the contents of the previous memtable to an sstable\n-<li>Discard the memtable\n-<li>Delete the old log file and the old memtable\n-<li>Add the new sstable to the young (level-0) level.\n-</ul>\n-</ul>\n-\n-<h1>Compactions</h1>\n-\n-<p>\n-When the size of level L exceeds its limit, we compact it in a\n-background thread.  The compaction picks a file from level L and all\n-overlapping files from the next level L+1.  Note that if a level-L\n-file overlaps only part of a level-(L+1) file, the entire file at\n-level-(L+1) is used as an input to the compaction and will be\n-discarded after the compaction.  Aside: because level-0 is special\n-(files in it may overlap each other), we treat compactions from\n-level-0 to level-1 specially: a level-0 compaction may pick more than\n-one level-0 file in case some of these files overlap each other.\n-\n-<p>\n-A compaction merges the contents of the picked files to produce a\n-sequence of level-(L+1) files.  We switch to producing a new\n-level-(L+1) file after the current output file has reached the target\n-file size (2MB).  We also switch to a new output file when the key\n-range of the current output file has grown enough to overlap more than\n-ten level-(L+2) files.  This last rule ensures that a later compaction\n-of a level-(L+1) file will not pick up too much data from level-(L+2).\n-\n-<p>\n-The old files are discarded and the new files are added to the serving\n-state.\n-\n-<p>\n-Compactions for a particular level rotate through the key space.  In\n-more detail, for each level L, we remember the ending key of the last\n-compaction at level L.  The next compaction for level L will pick the\n-first file that starts after this key (wrapping around to the\n-beginning of the key space if there is no such file).\n-\n-<p>\n-Compactions drop overwritten values.  They also drop deletion markers\n-if there are no higher numbered levels that contain a file whose range\n-overlaps the current key.\n-\n-<h2>Timing</h2>\n-\n-Level-0 compactions will read up to four 1MB files from level-0, and\n-at worst all the level-1 files (10MB).  I.e., we will read 14MB and\n-write 14MB.\n-\n-<p>\n-Other than the special level-0 compactions, we will pick one 2MB file\n-from level L.  In the worst case, this will overlap ~ 12 files from\n-level L+1 (10 because level-(L+1) is ten times the size of level-L,\n-and another two at the boundaries since the file ranges at level-L\n-will usually not be aligned with the file ranges at level-L+1).  The\n-compaction will therefore read 26MB and write 26MB.  Assuming a disk\n-IO rate of 100MB/s (ballpark range for modern drives), the worst\n-compaction cost will be approximately 0.5 second.\n-\n-<p>\n-If we throttle the background writing to something small, say 10% of\n-the full 100MB/s speed, a compaction may take up to 5 seconds.  If the\n-user is writing at 10MB/s, we might build up lots of level-0 files\n-(~50 to hold the 5*10MB).  This may significantly increase the cost of\n-reads due to the overhead of merging more files together on every\n-read.\n-\n-<p>\n-Solution 1: To reduce this problem, we might want to increase the log\n-switching threshold when the number of level-0 files is large.  Though\n-the downside is that the larger this threshold, the more memory we will\n-need to hold the corresponding memtable.\n-\n-<p>\n-Solution 2: We might want to decrease write rate artificially when the\n-number of level-0 files goes up.\n-\n-<p>\n-Solution 3: We work on reducing the cost of very wide merges.\n-Perhaps most of the level-0 files will have their blocks sitting\n-uncompressed in the cache and we will only need to worry about the\n-O(N) complexity in the merging iterator.\n-\n-<h2>Number of files</h2>\n-\n-Instead of always making 2MB files, we could make larger files for\n-larger levels to reduce the total file count, though at the expense of\n-more bursty compactions.  Alternatively, we could shard the set of\n-files into multiple directories.\n-\n-<p>\n-An experiment on an <code>ext3</code> filesystem on Feb 04, 2011 shows\n-the following timings to do 100K file opens in directories with\n-varying number of files:\n-<table class=\"datatable\">\n-<tr><th>Files in directory</th><th>Microseconds to open a file</th></tr>\n-<tr><td>1000</td><td>9</td>\n-<tr><td>10000</td><td>10</td>\n-<tr><td>100000</td><td>16</td>\n-</table>\n-So maybe even the sharding is not necessary on modern filesystems?\n-\n-<h1>Recovery</h1>\n-\n-<ul>\n-<li> Read CURRENT to find name of the latest committed MANIFEST\n-<li> Read the named MANIFEST file\n-<li> Clean up stale files\n-<li> We could open all sstables here, but it is probably better to be lazy...\n-<li> Convert log chunk to a new level-0 sstable\n-<li> Start directing new writes to a new log file with recovered sequence#\n-</ul>\n-\n-<h1>Garbage collection of files</h1>\n-\n-<code>DeleteObsoleteFiles()</code> is called at the end of every\n-compaction and at the end of recovery.  It finds the names of all\n-files in the database.  It deletes all log files that are not the\n-current log file.  It deletes all table files that are not referenced\n-from some level and are not the output of an active compaction.\n-\n-</body>\n-</html>"
      },
      {
        "sha": "4b13f2a6ba73bd46667eec0e63e6af6e10bad6d4",
        "filename": "src/leveldb/doc/impl.md",
        "status": "added",
        "additions": 170,
        "deletions": 0,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/doc/impl.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/doc/impl.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/impl.md?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -0,0 +1,170 @@\n+## Files\n+\n+The implementation of leveldb is similar in spirit to the representation of a\n+single [Bigtable tablet (section 5.3)](http://research.google.com/archive/bigtable.html).\n+However the organization of the files that make up the representation is\n+somewhat different and is explained below.\n+\n+Each database is represented by a set of files stored in a directory. There are\n+several different types of files as documented below:\n+\n+### Log files\n+\n+A log file (*.log) stores a sequence of recent updates. Each update is appended\n+to the current log file. When the log file reaches a pre-determined size\n+(approximately 4MB by default), it is converted to a sorted table (see below)\n+and a new log file is created for future updates.\n+\n+A copy of the current log file is kept in an in-memory structure (the\n+`memtable`). This copy is consulted on every read so that read operations\n+reflect all logged updates.\n+\n+## Sorted tables\n+\n+A sorted table (*.ldb) stores a sequence of entries sorted by key. Each entry is\n+either a value for the key, or a deletion marker for the key. (Deletion markers\n+are kept around to hide obsolete values present in older sorted tables).\n+\n+The set of sorted tables are organized into a sequence of levels. The sorted\n+table generated from a log file is placed in a special **young** level (also\n+called level-0). When the number of young files exceeds a certain threshold\n+(currently four), all of the young files are merged together with all of the\n+overlapping level-1 files to produce a sequence of new level-1 files (we create\n+a new level-1 file for every 2MB of data.)\n+\n+Files in the young level may contain overlapping keys. However files in other\n+levels have distinct non-overlapping key ranges. Consider level number L where\n+L >= 1. When the combined size of files in level-L exceeds (10^L) MB (i.e., 10MB\n+for level-1, 100MB for level-2, ...), one file in level-L, and all of the\n+overlapping files in level-(L+1) are merged to form a set of new files for\n+level-(L+1). These merges have the effect of gradually migrating new updates\n+from the young level to the largest level using only bulk reads and writes\n+(i.e., minimizing expensive seeks).\n+\n+### Manifest\n+\n+A MANIFEST file lists the set of sorted tables that make up each level, the\n+corresponding key ranges, and other important metadata. A new MANIFEST file\n+(with a new number embedded in the file name) is created whenever the database\n+is reopened. The MANIFEST file is formatted as a log, and changes made to the\n+serving state (as files are added or removed) are appended to this log.\n+\n+### Current\n+\n+CURRENT is a simple text file that contains the name of the latest MANIFEST\n+file.\n+\n+### Info logs\n+\n+Informational messages are printed to files named LOG and LOG.old.\n+\n+### Others\n+\n+Other files used for miscellaneous purposes may also be present (LOCK, *.dbtmp).\n+\n+## Level 0\n+\n+When the log file grows above a certain size (1MB by default):\n+Create a brand new memtable and log file and direct future updates here\n+In the background:\n+Write the contents of the previous memtable to an sstable\n+Discard the memtable\n+Delete the old log file and the old memtable\n+Add the new sstable to the young (level-0) level.\n+\n+## Compactions\n+\n+When the size of level L exceeds its limit, we compact it in a background\n+thread. The compaction picks a file from level L and all overlapping files from\n+the next level L+1. Note that if a level-L file overlaps only part of a\n+level-(L+1) file, the entire file at level-(L+1) is used as an input to the\n+compaction and will be discarded after the compaction.  Aside: because level-0\n+is special (files in it may overlap each other), we treat compactions from\n+level-0 to level-1 specially: a level-0 compaction may pick more than one\n+level-0 file in case some of these files overlap each other.\n+\n+A compaction merges the contents of the picked files to produce a sequence of\n+level-(L+1) files. We switch to producing a new level-(L+1) file after the\n+current output file has reached the target file size (2MB). We also switch to a\n+new output file when the key range of the current output file has grown enough\n+to overlap more than ten level-(L+2) files.  This last rule ensures that a later\n+compaction of a level-(L+1) file will not pick up too much data from\n+level-(L+2).\n+\n+The old files are discarded and the new files are added to the serving state.\n+\n+Compactions for a particular level rotate through the key space. In more detail,\n+for each level L, we remember the ending key of the last compaction at level L.\n+The next compaction for level L will pick the first file that starts after this\n+key (wrapping around to the beginning of the key space if there is no such\n+file).\n+\n+Compactions drop overwritten values. They also drop deletion markers if there\n+are no higher numbered levels that contain a file whose range overlaps the\n+current key.\n+\n+### Timing\n+\n+Level-0 compactions will read up to four 1MB files from level-0, and at worst\n+all the level-1 files (10MB). I.e., we will read 14MB and write 14MB.\n+\n+Other than the special level-0 compactions, we will pick one 2MB file from level\n+L. In the worst case, this will overlap ~ 12 files from level L+1 (10 because\n+level-(L+1) is ten times the size of level-L, and another two at the boundaries\n+since the file ranges at level-L will usually not be aligned with the file\n+ranges at level-L+1). The compaction will therefore read 26MB and write 26MB.\n+Assuming a disk IO rate of 100MB/s (ballpark range for modern drives), the worst\n+compaction cost will be approximately 0.5 second.\n+\n+If we throttle the background writing to something small, say 10% of the full\n+100MB/s speed, a compaction may take up to 5 seconds. If the user is writing at\n+10MB/s, we might build up lots of level-0 files (~50 to hold the 5*10MB). This\n+may significantly increase the cost of reads due to the overhead of merging more\n+files together on every read.\n+\n+Solution 1: To reduce this problem, we might want to increase the log switching\n+threshold when the number of level-0 files is large. Though the downside is that\n+the larger this threshold, the more memory we will need to hold the\n+corresponding memtable.\n+\n+Solution 2: We might want to decrease write rate artificially when the number of\n+level-0 files goes up.\n+\n+Solution 3: We work on reducing the cost of very wide merges. Perhaps most of\n+the level-0 files will have their blocks sitting uncompressed in the cache and\n+we will only need to worry about the O(N) complexity in the merging iterator.\n+\n+### Number of files\n+\n+Instead of always making 2MB files, we could make larger files for larger levels\n+to reduce the total file count, though at the expense of more bursty\n+compactions.  Alternatively, we could shard the set of files into multiple\n+directories.\n+\n+An experiment on an ext3 filesystem on Feb 04, 2011 shows the following timings\n+to do 100K file opens in directories with varying number of files:\n+\n+\n+| Files in directory | Microseconds to open a file |\n+|-------------------:|----------------------------:|\n+|               1000 |                           9 |\n+|              10000 |                          10 |\n+|             100000 |                          16 |\n+\n+So maybe even the sharding is not necessary on modern filesystems?\n+\n+## Recovery\n+\n+* Read CURRENT to find name of the latest committed MANIFEST\n+* Read the named MANIFEST file\n+* Clean up stale files\n+* We could open all sstables here, but it is probably better to be lazy...\n+* Convert log chunk to a new level-0 sstable\n+* Start directing new writes to a new log file with recovered sequence#\n+\n+## Garbage collection of files\n+\n+`DeleteObsoleteFiles()` is called at the end of every compaction and at the end\n+of recovery. It finds the names of all files in the database. It deletes all log\n+files that are not the current log file. It deletes all table files that are not\n+referenced from some level and are not the output of an active compaction."
      },
      {
        "sha": "2155192581e7b79784564f190a47138ae29461f0",
        "filename": "src/leveldb/doc/index.html",
        "status": "removed",
        "additions": 0,
        "deletions": 549,
        "changes": 549,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/leveldb/doc/index.html",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/leveldb/doc/index.html",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/index.html?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,549 +0,0 @@\n-<!DOCTYPE html>\n-<html>\n-<head>\n-<link rel=\"stylesheet\" type=\"text/css\" href=\"doc.css\" />\n-<title>Leveldb</title>\n-</head>\n-\n-<body>\n-<h1>Leveldb</h1>\n-<address>Jeff Dean, Sanjay Ghemawat</address>\n-<p>\n-The <code>leveldb</code> library provides a persistent key value store.  Keys and\n-values are arbitrary byte arrays.  The keys are ordered within the key\n-value store according to a user-specified comparator function.\n-\n-<p>\n-<h1>Opening A Database</h1>\n-<p>\n-A <code>leveldb</code> database has a name which corresponds to a file system\n-directory.  All of the contents of database are stored in this\n-directory.  The following example shows how to open a database,\n-creating it if necessary:\n-<p>\n-<pre>\n-  #include &lt;cassert&gt;\n-  #include \"leveldb/db.h\"\n-\n-  leveldb::DB* db;\n-  leveldb::Options options;\n-  options.create_if_missing = true;\n-  leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n-  assert(status.ok());\n-  ...\n-</pre>\n-If you want to raise an error if the database already exists, add\n-the following line before the <code>leveldb::DB::Open</code> call:\n-<pre>\n-  options.error_if_exists = true;\n-</pre>\n-<h1>Status</h1>\n-<p>\n-You may have noticed the <code>leveldb::Status</code> type above.  Values of this\n-type are returned by most functions in <code>leveldb</code> that may encounter an\n-error.  You can check if such a result is ok, and also print an\n-associated error message:\n-<p>\n-<pre>\n-   leveldb::Status s = ...;\n-   if (!s.ok()) cerr &lt;&lt; s.ToString() &lt;&lt; endl;\n-</pre>\n-<h1>Closing A Database</h1>\n-<p>\n-When you are done with a database, just delete the database object.\n-Example:\n-<p>\n-<pre>\n-  ... open the db as described above ...\n-  ... do something with db ...\n-  delete db;\n-</pre>\n-<h1>Reads And Writes</h1>\n-<p>\n-The database provides <code>Put</code>, <code>Delete</code>, and <code>Get</code> methods to\n-modify/query the database.  For example, the following code\n-moves the value stored under key1 to key2.\n-<pre>\n-  std::string value;\n-  leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);\n-  if (s.ok()) s = db-&gt;Put(leveldb::WriteOptions(), key2, value);\n-  if (s.ok()) s = db-&gt;Delete(leveldb::WriteOptions(), key1);\n-</pre>\n-\n-<h1>Atomic Updates</h1>\n-<p>\n-Note that if the process dies after the Put of key2 but before the\n-delete of key1, the same value may be left stored under multiple keys.\n-Such problems can be avoided by using the <code>WriteBatch</code> class to\n-atomically apply a set of updates:\n-<p>\n-<pre>\n-  #include \"leveldb/write_batch.h\"\n-  ...\n-  std::string value;\n-  leveldb::Status s = db-&gt;Get(leveldb::ReadOptions(), key1, &amp;value);\n-  if (s.ok()) {\n-    leveldb::WriteBatch batch;\n-    batch.Delete(key1);\n-    batch.Put(key2, value);\n-    s = db-&gt;Write(leveldb::WriteOptions(), &amp;batch);\n-  }\n-</pre>\n-The <code>WriteBatch</code> holds a sequence of edits to be made to the database,\n-and these edits within the batch are applied in order.  Note that we\n-called <code>Delete</code> before <code>Put</code> so that if <code>key1</code> is identical to <code>key2</code>,\n-we do not end up erroneously dropping the value entirely.\n-<p>\n-Apart from its atomicity benefits, <code>WriteBatch</code> may also be used to\n-speed up bulk updates by placing lots of individual mutations into the\n-same batch.\n-\n-<h1>Synchronous Writes</h1>\n-By default, each write to <code>leveldb</code> is asynchronous: it\n-returns after pushing the write from the process into the operating\n-system.  The transfer from operating system memory to the underlying\n-persistent storage happens asynchronously.  The <code>sync</code> flag\n-can be turned on for a particular write to make the write operation\n-not return until the data being written has been pushed all the way to\n-persistent storage.  (On Posix systems, this is implemented by calling\n-either <code>fsync(...)</code> or <code>fdatasync(...)</code> or\n-<code>msync(..., MS_SYNC)</code> before the write operation returns.)\n-<pre>\n-  leveldb::WriteOptions write_options;\n-  write_options.sync = true;\n-  db-&gt;Put(write_options, ...);\n-</pre>\n-Asynchronous writes are often more than a thousand times as fast as\n-synchronous writes.  The downside of asynchronous writes is that a\n-crash of the machine may cause the last few updates to be lost.  Note\n-that a crash of just the writing process (i.e., not a reboot) will not\n-cause any loss since even when <code>sync</code> is false, an update\n-is pushed from the process memory into the operating system before it\n-is considered done.\n-\n-<p>\n-Asynchronous writes can often be used safely.  For example, when\n-loading a large amount of data into the database you can handle lost\n-updates by restarting the bulk load after a crash.  A hybrid scheme is\n-also possible where every Nth write is synchronous, and in the event\n-of a crash, the bulk load is restarted just after the last synchronous\n-write finished by the previous run.  (The synchronous write can update\n-a marker that describes where to restart on a crash.)\n-\n-<p>\n-<code>WriteBatch</code> provides an alternative to asynchronous writes.\n-Multiple updates may be placed in the same <code>WriteBatch</code> and\n-applied together using a synchronous write (i.e.,\n-<code>write_options.sync</code> is set to true).  The extra cost of\n-the synchronous write will be amortized across all of the writes in\n-the batch.\n-\n-<p>\n-<h1>Concurrency</h1>\n-<p>\n-A database may only be opened by one process at a time.\n-The <code>leveldb</code> implementation acquires a lock from the\n-operating system to prevent misuse.  Within a single process, the\n-same <code>leveldb::DB</code> object may be safely shared by multiple\n-concurrent threads.  I.e., different threads may write into or fetch\n-iterators or call <code>Get</code> on the same database without any\n-external synchronization (the leveldb implementation will\n-automatically do the required synchronization).  However other objects\n-(like Iterator and WriteBatch) may require external synchronization.\n-If two threads share such an object, they must protect access to it\n-using their own locking protocol.  More details are available in\n-the public header files.\n-<p>\n-<h1>Iteration</h1>\n-<p>\n-The following example demonstrates how to print all key,value pairs\n-in a database.\n-<p>\n-<pre>\n-  leveldb::Iterator* it = db-&gt;NewIterator(leveldb::ReadOptions());\n-  for (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) {\n-    cout &lt;&lt; it-&gt;key().ToString() &lt;&lt; \": \"  &lt;&lt; it-&gt;value().ToString() &lt;&lt; endl;\n-  }\n-  assert(it-&gt;status().ok());  // Check for any errors found during the scan\n-  delete it;\n-</pre>\n-The following variation shows how to process just the keys in the\n-range <code>[start,limit)</code>:\n-<p>\n-<pre>\n-  for (it-&gt;Seek(start);\n-       it-&gt;Valid() &amp;&amp; it-&gt;key().ToString() &lt; limit;\n-       it-&gt;Next()) {\n-    ...\n-  }\n-</pre>\n-You can also process entries in reverse order.  (Caveat: reverse\n-iteration may be somewhat slower than forward iteration.)\n-<p>\n-<pre>\n-  for (it-&gt;SeekToLast(); it-&gt;Valid(); it-&gt;Prev()) {\n-    ...\n-  }\n-</pre>\n-<h1>Snapshots</h1>\n-<p>\n-Snapshots provide consistent read-only views over the entire state of\n-the key-value store.  <code>ReadOptions::snapshot</code> may be non-NULL to indicate\n-that a read should operate on a particular version of the DB state.\n-If <code>ReadOptions::snapshot</code> is NULL, the read will operate on an\n-implicit snapshot of the current state.\n-<p>\n-Snapshots are created by the DB::GetSnapshot() method:\n-<p>\n-<pre>\n-  leveldb::ReadOptions options;\n-  options.snapshot = db-&gt;GetSnapshot();\n-  ... apply some updates to db ...\n-  leveldb::Iterator* iter = db-&gt;NewIterator(options);\n-  ... read using iter to view the state when the snapshot was created ...\n-  delete iter;\n-  db-&gt;ReleaseSnapshot(options.snapshot);\n-</pre>\n-Note that when a snapshot is no longer needed, it should be released\n-using the DB::ReleaseSnapshot interface.  This allows the\n-implementation to get rid of state that was being maintained just to\n-support reading as of that snapshot.\n-<h1>Slice</h1>\n-<p>\n-The return value of the <code>it->key()</code> and <code>it->value()</code> calls above\n-are instances of the <code>leveldb::Slice</code> type.  <code>Slice</code> is a simple\n-structure that contains a length and a pointer to an external byte\n-array.  Returning a <code>Slice</code> is a cheaper alternative to returning a\n-<code>std::string</code> since we do not need to copy potentially large keys and\n-values.  In addition, <code>leveldb</code> methods do not return null-terminated\n-C-style strings since <code>leveldb</code> keys and values are allowed to\n-contain '\\0' bytes.\n-<p>\n-C++ strings and null-terminated C-style strings can be easily converted\n-to a Slice:\n-<p>\n-<pre>\n-   leveldb::Slice s1 = \"hello\";\n-\n-   std::string str(\"world\");\n-   leveldb::Slice s2 = str;\n-</pre>\n-A Slice can be easily converted back to a C++ string:\n-<pre>\n-   std::string str = s1.ToString();\n-   assert(str == std::string(\"hello\"));\n-</pre>\n-Be careful when using Slices since it is up to the caller to ensure that\n-the external byte array into which the Slice points remains live while\n-the Slice is in use.  For example, the following is buggy:\n-<p>\n-<pre>\n-   leveldb::Slice slice;\n-   if (...) {\n-     std::string str = ...;\n-     slice = str;\n-   }\n-   Use(slice);\n-</pre>\n-When the <code>if</code> statement goes out of scope, <code>str</code> will be destroyed and the\n-backing storage for <code>slice</code> will disappear.\n-<p>\n-<h1>Comparators</h1>\n-<p>\n-The preceding examples used the default ordering function for key,\n-which orders bytes lexicographically.  You can however supply a custom\n-comparator when opening a database.  For example, suppose each\n-database key consists of two numbers and we should sort by the first\n-number, breaking ties by the second number.  First, define a proper\n-subclass of <code>leveldb::Comparator</code> that expresses these rules:\n-<p>\n-<pre>\n-  class TwoPartComparator : public leveldb::Comparator {\n-   public:\n-    // Three-way comparison function:\n-    //   if a &lt; b: negative result\n-    //   if a &gt; b: positive result\n-    //   else: zero result\n-    int Compare(const leveldb::Slice&amp; a, const leveldb::Slice&amp; b) const {\n-      int a1, a2, b1, b2;\n-      ParseKey(a, &amp;a1, &amp;a2);\n-      ParseKey(b, &amp;b1, &amp;b2);\n-      if (a1 &lt; b1) return -1;\n-      if (a1 &gt; b1) return +1;\n-      if (a2 &lt; b2) return -1;\n-      if (a2 &gt; b2) return +1;\n-      return 0;\n-    }\n-\n-    // Ignore the following methods for now:\n-    const char* Name() const { return \"TwoPartComparator\"; }\n-    void FindShortestSeparator(std::string*, const leveldb::Slice&amp;) const { }\n-    void FindShortSuccessor(std::string*) const { }\n-  };\n-</pre>\n-Now create a database using this custom comparator:\n-<p>\n-<pre>\n-  TwoPartComparator cmp;\n-  leveldb::DB* db;\n-  leveldb::Options options;\n-  options.create_if_missing = true;\n-  options.comparator = &amp;cmp;\n-  leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n-  ...\n-</pre>\n-<h2>Backwards compatibility</h2>\n-<p>\n-The result of the comparator's <code>Name</code> method is attached to the\n-database when it is created, and is checked on every subsequent\n-database open.  If the name changes, the <code>leveldb::DB::Open</code> call will\n-fail.  Therefore, change the name if and only if the new key format\n-and comparison function are incompatible with existing databases, and\n-it is ok to discard the contents of all existing databases.\n-<p>\n-You can however still gradually evolve your key format over time with\n-a little bit of pre-planning.  For example, you could store a version\n-number at the end of each key (one byte should suffice for most uses).\n-When you wish to switch to a new key format (e.g., adding an optional\n-third part to the keys processed by <code>TwoPartComparator</code>),\n-(a) keep the same comparator name (b) increment the version number\n-for new keys (c) change the comparator function so it uses the\n-version numbers found in the keys to decide how to interpret them.\n-<p>\n-<h1>Performance</h1>\n-<p>\n-Performance can be tuned by changing the default values of the\n-types defined in <code>include/leveldb/options.h</code>.\n-\n-<p>\n-<h2>Block size</h2>\n-<p>\n-<code>leveldb</code> groups adjacent keys together into the same block and such a\n-block is the unit of transfer to and from persistent storage.  The\n-default block size is approximately 4096 uncompressed bytes.\n-Applications that mostly do bulk scans over the contents of the\n-database may wish to increase this size.  Applications that do a lot\n-of point reads of small values may wish to switch to a smaller block\n-size if performance measurements indicate an improvement.  There isn't\n-much benefit in using blocks smaller than one kilobyte, or larger than\n-a few megabytes.  Also note that compression will be more effective\n-with larger block sizes.\n-<p>\n-<h2>Compression</h2>\n-<p>\n-Each block is individually compressed before being written to\n-persistent storage.  Compression is on by default since the default\n-compression method is very fast, and is automatically disabled for\n-uncompressible data.  In rare cases, applications may want to disable\n-compression entirely, but should only do so if benchmarks show a\n-performance improvement:\n-<p>\n-<pre>\n-  leveldb::Options options;\n-  options.compression = leveldb::kNoCompression;\n-  ... leveldb::DB::Open(options, name, ...) ....\n-</pre>\n-<h2>Cache</h2>\n-<p>\n-The contents of the database are stored in a set of files in the\n-filesystem and each file stores a sequence of compressed blocks.  If\n-<code>options.cache</code> is non-NULL, it is used to cache frequently used\n-uncompressed block contents.\n-<p>\n-<pre>\n-  #include \"leveldb/cache.h\"\n-\n-  leveldb::Options options;\n-  options.cache = leveldb::NewLRUCache(100 * 1048576);  // 100MB cache\n-  leveldb::DB* db;\n-  leveldb::DB::Open(options, name, &db);\n-  ... use the db ...\n-  delete db\n-  delete options.cache;\n-</pre>\n-Note that the cache holds uncompressed data, and therefore it should\n-be sized according to application level data sizes, without any\n-reduction from compression.  (Caching of compressed blocks is left to\n-the operating system buffer cache, or any custom <code>Env</code>\n-implementation provided by the client.)\n-<p>\n-When performing a bulk read, the application may wish to disable\n-caching so that the data processed by the bulk read does not end up\n-displacing most of the cached contents.  A per-iterator option can be\n-used to achieve this:\n-<p>\n-<pre>\n-  leveldb::ReadOptions options;\n-  options.fill_cache = false;\n-  leveldb::Iterator* it = db-&gt;NewIterator(options);\n-  for (it-&gt;SeekToFirst(); it-&gt;Valid(); it-&gt;Next()) {\n-    ...\n-  }\n-</pre>\n-<h2>Key Layout</h2>\n-<p>\n-Note that the unit of disk transfer and caching is a block.  Adjacent\n-keys (according to the database sort order) will usually be placed in\n-the same block.  Therefore the application can improve its performance\n-by placing keys that are accessed together near each other and placing\n-infrequently used keys in a separate region of the key space.\n-<p>\n-For example, suppose we are implementing a simple file system on top\n-of <code>leveldb</code>.  The types of entries we might wish to store are:\n-<p>\n-<pre>\n-   filename -&gt; permission-bits, length, list of file_block_ids\n-   file_block_id -&gt; data\n-</pre>\n-We might want to prefix <code>filename</code> keys with one letter (say '/') and the\n-<code>file_block_id</code> keys with a different letter (say '0') so that scans\n-over just the metadata do not force us to fetch and cache bulky file\n-contents.\n-<p>\n-<h2>Filters</h2>\n-<p>\n-Because of the way <code>leveldb</code> data is organized on disk,\n-a single <code>Get()</code> call may involve multiple reads from disk.\n-The optional <code>FilterPolicy</code> mechanism can be used to reduce\n-the number of disk reads substantially.\n-<pre>\n-   leveldb::Options options;\n-   options.filter_policy = NewBloomFilterPolicy(10);\n-   leveldb::DB* db;\n-   leveldb::DB::Open(options, \"/tmp/testdb\", &amp;db);\n-   ... use the database ...\n-   delete db;\n-   delete options.filter_policy;\n-</pre>\n-The preceding code associates a\n-<a href=\"http://en.wikipedia.org/wiki/Bloom_filter\">Bloom filter</a>\n-based filtering policy with the database.  Bloom filter based\n-filtering relies on keeping some number of bits of data in memory per\n-key (in this case 10 bits per key since that is the argument we passed\n-to NewBloomFilterPolicy).  This filter will reduce the number of unnecessary\n-disk reads needed for <code>Get()</code> calls by a factor of\n-approximately a 100.  Increasing the bits per key will lead to a\n-larger reduction at the cost of more memory usage.  We recommend that\n-applications whose working set does not fit in memory and that do a\n-lot of random reads set a filter policy.\n-<p>\n-If you are using a custom comparator, you should ensure that the filter\n-policy you are using is compatible with your comparator.  For example,\n-consider a comparator that ignores trailing spaces when comparing keys.\n-<code>NewBloomFilterPolicy</code> must not be used with such a comparator.\n-Instead, the application should provide a custom filter policy that\n-also ignores trailing spaces.  For example:\n-<pre>\n-  class CustomFilterPolicy : public leveldb::FilterPolicy {\n-   private:\n-    FilterPolicy* builtin_policy_;\n-   public:\n-    CustomFilterPolicy() : builtin_policy_(NewBloomFilterPolicy(10)) { }\n-    ~CustomFilterPolicy() { delete builtin_policy_; }\n-\n-    const char* Name() const { return \"IgnoreTrailingSpacesFilter\"; }\n-\n-    void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n-      // Use builtin bloom filter code after removing trailing spaces\n-      std::vector&lt;Slice&gt; trimmed(n);\n-      for (int i = 0; i &lt; n; i++) {\n-        trimmed[i] = RemoveTrailingSpaces(keys[i]);\n-      }\n-      return builtin_policy_-&gt;CreateFilter(&amp;trimmed[i], n, dst);\n-    }\n-\n-    bool KeyMayMatch(const Slice& key, const Slice& filter) const {\n-      // Use builtin bloom filter code after removing trailing spaces\n-      return builtin_policy_-&gt;KeyMayMatch(RemoveTrailingSpaces(key), filter);\n-    }\n-  };\n-</pre>\n-<p>\n-Advanced applications may provide a filter policy that does not use\n-a bloom filter but uses some other mechanism for summarizing a set\n-of keys.  See <code>leveldb/filter_policy.h</code> for detail.\n-<p>\n-<h1>Checksums</h1>\n-<p>\n-<code>leveldb</code> associates checksums with all data it stores in the file system.\n-There are two separate controls provided over how aggressively these\n-checksums are verified:\n-<p>\n-<ul>\n-<li> <code>ReadOptions::verify_checksums</code> may be set to true to force\n-  checksum verification of all data that is read from the file system on\n-  behalf of a particular read.  By default, no such verification is\n-  done.\n-<p>\n-<li> <code>Options::paranoid_checks</code> may be set to true before opening a\n-  database to make the database implementation raise an error as soon as\n-  it detects an internal corruption.  Depending on which portion of the\n-  database has been corrupted, the error may be raised when the database\n-  is opened, or later by another database operation.  By default,\n-  paranoid checking is off so that the database can be used even if\n-  parts of its persistent storage have been corrupted.\n-<p>\n-  If a database is corrupted (perhaps it cannot be opened when\n-  paranoid checking is turned on), the <code>leveldb::RepairDB</code> function\n-  may be used to recover as much of the data as possible\n-<p>\n-</ul>\n-<h1>Approximate Sizes</h1>\n-<p>\n-The <code>GetApproximateSizes</code> method can used to get the approximate\n-number of bytes of file system space used by one or more key ranges.\n-<p>\n-<pre>\n-   leveldb::Range ranges[2];\n-   ranges[0] = leveldb::Range(\"a\", \"c\");\n-   ranges[1] = leveldb::Range(\"x\", \"z\");\n-   uint64_t sizes[2];\n-   leveldb::Status s = db-&gt;GetApproximateSizes(ranges, 2, sizes);\n-</pre>\n-The preceding call will set <code>sizes[0]</code> to the approximate number of\n-bytes of file system space used by the key range <code>[a..c)</code> and\n-<code>sizes[1]</code> to the approximate number of bytes used by the key range\n-<code>[x..z)</code>.\n-<p>\n-<h1>Environment</h1>\n-<p>\n-All file operations (and other operating system calls) issued by the\n-<code>leveldb</code> implementation are routed through a <code>leveldb::Env</code> object.\n-Sophisticated clients may wish to provide their own <code>Env</code>\n-implementation to get better control.  For example, an application may\n-introduce artificial delays in the file IO paths to limit the impact\n-of <code>leveldb</code> on other activities in the system.\n-<p>\n-<pre>\n-  class SlowEnv : public leveldb::Env {\n-    .. implementation of the Env interface ...\n-  };\n-\n-  SlowEnv env;\n-  leveldb::Options options;\n-  options.env = &amp;env;\n-  Status s = leveldb::DB::Open(options, ...);\n-</pre>\n-<h1>Porting</h1>\n-<p>\n-<code>leveldb</code> may be ported to a new platform by providing platform\n-specific implementations of the types/methods/functions exported by\n-<code>leveldb/port/port.h</code>.  See <code>leveldb/port/port_example.h</code> for more\n-details.\n-<p>\n-In addition, the new platform may need a new default <code>leveldb::Env</code>\n-implementation.  See <code>leveldb/util/env_posix.h</code> for an example.\n-\n-<h1>Other Information</h1>\n-\n-<p>\n-Details about the <code>leveldb</code> implementation may be found in\n-the following documents:\n-<ul>\n-<li> <a href=\"impl.html\">Implementation notes</a>\n-<li> <a href=\"table_format.txt\">Format of an immutable Table file</a>\n-<li> <a href=\"log_format.txt\">Format of a log file</a>\n-</ul>\n-\n-</body>\n-</html>"
      },
      {
        "sha": "be8569692bb054676bf451e06a8dd4980c32edca",
        "filename": "src/leveldb/doc/index.md",
        "status": "added",
        "additions": 523,
        "deletions": 0,
        "changes": 523,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/doc/index.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/doc/index.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/index.md?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -0,0 +1,523 @@\n+leveldb\n+=======\n+\n+_Jeff Dean, Sanjay Ghemawat_\n+\n+The leveldb library provides a persistent key value store. Keys and values are\n+arbitrary byte arrays.  The keys are ordered within the key value store\n+according to a user-specified comparator function.\n+\n+## Opening A Database\n+\n+A leveldb database has a name which corresponds to a file system directory. All\n+of the contents of database are stored in this directory. The following example\n+shows how to open a database, creating it if necessary:\n+\n+```c++\n+#include <cassert>\n+#include \"leveldb/db.h\"\n+\n+leveldb::DB* db;\n+leveldb::Options options;\n+options.create_if_missing = true;\n+leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &db);\n+assert(status.ok());\n+...\n+```\n+\n+If you want to raise an error if the database already exists, add the following\n+line before the `leveldb::DB::Open` call:\n+\n+```c++\n+options.error_if_exists = true;\n+```\n+\n+## Status\n+\n+You may have noticed the `leveldb::Status` type above. Values of this type are\n+returned by most functions in leveldb that may encounter an error. You can check\n+if such a result is ok, and also print an associated error message:\n+\n+```c++\n+leveldb::Status s = ...;\n+if (!s.ok()) cerr << s.ToString() << endl;\n+```\n+\n+## Closing A Database\n+\n+When you are done with a database, just delete the database object. Example:\n+\n+```c++\n+... open the db as described above ...\n+... do something with db ...\n+delete db;\n+```\n+\n+## Reads And Writes\n+\n+The database provides Put, Delete, and Get methods to modify/query the database.\n+For example, the following code moves the value stored under key1 to key2.\n+\n+```c++\n+std::string value;\n+leveldb::Status s = db->Get(leveldb::ReadOptions(), key1, &value);\n+if (s.ok()) s = db->Put(leveldb::WriteOptions(), key2, value);\n+if (s.ok()) s = db->Delete(leveldb::WriteOptions(), key1);\n+```\n+\n+## Atomic Updates\n+\n+Note that if the process dies after the Put of key2 but before the delete of\n+key1, the same value may be left stored under multiple keys. Such problems can\n+be avoided by using the `WriteBatch` class to atomically apply a set of updates:\n+\n+```c++\n+#include \"leveldb/write_batch.h\"\n+...\n+std::string value;\n+leveldb::Status s = db->Get(leveldb::ReadOptions(), key1, &value);\n+if (s.ok()) {\n+  leveldb::WriteBatch batch;\n+  batch.Delete(key1);\n+  batch.Put(key2, value);\n+  s = db->Write(leveldb::WriteOptions(), &batch);\n+}\n+```\n+\n+The `WriteBatch` holds a sequence of edits to be made to the database, and these\n+edits within the batch are applied in order. Note that we called Delete before\n+Put so that if key1 is identical to key2, we do not end up erroneously dropping\n+the value entirely.\n+\n+Apart from its atomicity benefits, `WriteBatch` may also be used to speed up\n+bulk updates by placing lots of individual mutations into the same batch.\n+\n+## Synchronous Writes\n+\n+By default, each write to leveldb is asynchronous: it returns after pushing the\n+write from the process into the operating system. The transfer from operating\n+system memory to the underlying persistent storage happens asynchronously. The\n+sync flag can be turned on for a particular write to make the write operation\n+not return until the data being written has been pushed all the way to\n+persistent storage. (On Posix systems, this is implemented by calling either\n+`fsync(...)` or `fdatasync(...)` or `msync(..., MS_SYNC)` before the write\n+operation returns.)\n+\n+```c++\n+leveldb::WriteOptions write_options;\n+write_options.sync = true;\n+db->Put(write_options, ...);\n+```\n+\n+Asynchronous writes are often more than a thousand times as fast as synchronous\n+writes. The downside of asynchronous writes is that a crash of the machine may\n+cause the last few updates to be lost. Note that a crash of just the writing\n+process (i.e., not a reboot) will not cause any loss since even when sync is\n+false, an update is pushed from the process memory into the operating system\n+before it is considered done.\n+\n+Asynchronous writes can often be used safely. For example, when loading a large\n+amount of data into the database you can handle lost updates by restarting the\n+bulk load after a crash. A hybrid scheme is also possible where every Nth write\n+is synchronous, and in the event of a crash, the bulk load is restarted just\n+after the last synchronous write finished by the previous run. (The synchronous\n+write can update a marker that describes where to restart on a crash.)\n+\n+`WriteBatch` provides an alternative to asynchronous writes. Multiple updates\n+may be placed in the same WriteBatch and applied together using a synchronous\n+write (i.e., `write_options.sync` is set to true). The extra cost of the\n+synchronous write will be amortized across all of the writes in the batch.\n+\n+## Concurrency\n+\n+A database may only be opened by one process at a time. The leveldb\n+implementation acquires a lock from the operating system to prevent misuse.\n+Within a single process, the same `leveldb::DB` object may be safely shared by\n+multiple concurrent threads. I.e., different threads may write into or fetch\n+iterators or call Get on the same database without any external synchronization\n+(the leveldb implementation will automatically do the required synchronization).\n+However other objects (like Iterator and `WriteBatch`) may require external\n+synchronization. If two threads share such an object, they must protect access\n+to it using their own locking protocol. More details are available in the public\n+header files.\n+\n+## Iteration\n+\n+The following example demonstrates how to print all key,value pairs in a\n+database.\n+\n+```c++\n+leveldb::Iterator* it = db->NewIterator(leveldb::ReadOptions());\n+for (it->SeekToFirst(); it->Valid(); it->Next()) {\n+  cout << it->key().ToString() << \": \"  << it->value().ToString() << endl;\n+}\n+assert(it->status().ok());  // Check for any errors found during the scan\n+delete it;\n+```\n+\n+The following variation shows how to process just the keys in the range\n+[start,limit):\n+\n+```c++\n+for (it->Seek(start);\n+   it->Valid() && it->key().ToString() < limit;\n+   it->Next()) {\n+  ...\n+}\n+```\n+\n+You can also process entries in reverse order. (Caveat: reverse iteration may be\n+somewhat slower than forward iteration.)\n+\n+```c++\n+for (it->SeekToLast(); it->Valid(); it->Prev()) {\n+  ...\n+}\n+```\n+\n+## Snapshots\n+\n+Snapshots provide consistent read-only views over the entire state of the\n+key-value store.  `ReadOptions::snapshot` may be non-NULL to indicate that a\n+read should operate on a particular version of the DB state. If\n+`ReadOptions::snapshot` is NULL, the read will operate on an implicit snapshot\n+of the current state.\n+\n+Snapshots are created by the `DB::GetSnapshot()` method:\n+\n+```c++\n+leveldb::ReadOptions options;\n+options.snapshot = db->GetSnapshot();\n+... apply some updates to db ...\n+leveldb::Iterator* iter = db->NewIterator(options);\n+... read using iter to view the state when the snapshot was created ...\n+delete iter;\n+db->ReleaseSnapshot(options.snapshot);\n+```\n+\n+Note that when a snapshot is no longer needed, it should be released using the\n+`DB::ReleaseSnapshot` interface. This allows the implementation to get rid of\n+state that was being maintained just to support reading as of that snapshot.\n+\n+## Slice\n+\n+The return value of the `it->key()` and `it->value()` calls above are instances\n+of the `leveldb::Slice` type. Slice is a simple structure that contains a length\n+and a pointer to an external byte array. Returning a Slice is a cheaper\n+alternative to returning a `std::string` since we do not need to copy\n+potentially large keys and values. In addition, leveldb methods do not return\n+null-terminated C-style strings since leveldb keys and values are allowed to\n+contain `'\\0'` bytes.\n+\n+C++ strings and null-terminated C-style strings can be easily converted to a\n+Slice:\n+\n+```c++\n+leveldb::Slice s1 = \"hello\";\n+\n+std::string str(\"world\");\n+leveldb::Slice s2 = str;\n+```\n+\n+A Slice can be easily converted back to a C++ string:\n+\n+```c++\n+std::string str = s1.ToString();\n+assert(str == std::string(\"hello\"));\n+```\n+\n+Be careful when using Slices since it is up to the caller to ensure that the\n+external byte array into which the Slice points remains live while the Slice is\n+in use. For example, the following is buggy:\n+\n+```c++\n+leveldb::Slice slice;\n+if (...) {\n+  std::string str = ...;\n+  slice = str;\n+}\n+Use(slice);\n+```\n+\n+When the if statement goes out of scope, str will be destroyed and the backing\n+storage for slice will disappear.\n+\n+## Comparators\n+\n+The preceding examples used the default ordering function for key, which orders\n+bytes lexicographically. You can however supply a custom comparator when opening\n+a database.  For example, suppose each database key consists of two numbers and\n+we should sort by the first number, breaking ties by the second number. First,\n+define a proper subclass of `leveldb::Comparator` that expresses these rules:\n+\n+```c++\n+class TwoPartComparator : public leveldb::Comparator {\n+ public:\n+  // Three-way comparison function:\n+  //   if a < b: negative result\n+  //   if a > b: positive result\n+  //   else: zero result\n+  int Compare(const leveldb::Slice& a, const leveldb::Slice& b) const {\n+    int a1, a2, b1, b2;\n+    ParseKey(a, &a1, &a2);\n+    ParseKey(b, &b1, &b2);\n+    if (a1 < b1) return -1;\n+    if (a1 > b1) return +1;\n+    if (a2 < b2) return -1;\n+    if (a2 > b2) return +1;\n+    return 0;\n+  }\n+\n+  // Ignore the following methods for now:\n+  const char* Name() const { return \"TwoPartComparator\"; }\n+  void FindShortestSeparator(std::string*, const leveldb::Slice&) const {}\n+  void FindShortSuccessor(std::string*) const {}\n+};\n+```\n+\n+Now create a database using this custom comparator:\n+\n+```c++\n+TwoPartComparator cmp;\n+leveldb::DB* db;\n+leveldb::Options options;\n+options.create_if_missing = true;\n+options.comparator = &cmp;\n+leveldb::Status status = leveldb::DB::Open(options, \"/tmp/testdb\", &db);\n+...\n+```\n+\n+### Backwards compatibility\n+\n+The result of the comparator's Name method is attached to the database when it\n+is created, and is checked on every subsequent database open. If the name\n+changes, the `leveldb::DB::Open` call will fail. Therefore, change the name if\n+and only if the new key format and comparison function are incompatible with\n+existing databases, and it is ok to discard the contents of all existing\n+databases.\n+\n+You can however still gradually evolve your key format over time with a little\n+bit of pre-planning. For example, you could store a version number at the end of\n+each key (one byte should suffice for most uses). When you wish to switch to a\n+new key format (e.g., adding an optional third part to the keys processed by\n+`TwoPartComparator`), (a) keep the same comparator name (b) increment the\n+version number for new keys (c) change the comparator function so it uses the\n+version numbers found in the keys to decide how to interpret them.\n+\n+## Performance\n+\n+Performance can be tuned by changing the default values of the types defined in\n+`include/leveldb/options.h`.\n+\n+### Block size\n+\n+leveldb groups adjacent keys together into the same block and such a block is\n+the unit of transfer to and from persistent storage. The default block size is\n+approximately 4096 uncompressed bytes.  Applications that mostly do bulk scans\n+over the contents of the database may wish to increase this size. Applications\n+that do a lot of point reads of small values may wish to switch to a smaller\n+block size if performance measurements indicate an improvement. There isn't much\n+benefit in using blocks smaller than one kilobyte, or larger than a few\n+megabytes. Also note that compression will be more effective with larger block\n+sizes.\n+\n+### Compression\n+\n+Each block is individually compressed before being written to persistent\n+storage. Compression is on by default since the default compression method is\n+very fast, and is automatically disabled for uncompressible data. In rare cases,\n+applications may want to disable compression entirely, but should only do so if\n+benchmarks show a performance improvement:\n+\n+```c++\n+leveldb::Options options;\n+options.compression = leveldb::kNoCompression;\n+... leveldb::DB::Open(options, name, ...) ....\n+```\n+\n+### Cache\n+\n+The contents of the database are stored in a set of files in the filesystem and\n+each file stores a sequence of compressed blocks. If options.cache is non-NULL,\n+it is used to cache frequently used uncompressed block contents.\n+\n+```c++\n+#include \"leveldb/cache.h\"\n+\n+leveldb::Options options;\n+options.cache = leveldb::NewLRUCache(100 * 1048576);  // 100MB cache\n+leveldb::DB* db;\n+leveldb::DB::Open(options, name, &db);\n+... use the db ...\n+delete db\n+delete options.cache;\n+```\n+\n+Note that the cache holds uncompressed data, and therefore it should be sized\n+according to application level data sizes, without any reduction from\n+compression. (Caching of compressed blocks is left to the operating system\n+buffer cache, or any custom Env implementation provided by the client.)\n+\n+When performing a bulk read, the application may wish to disable caching so that\n+the data processed by the bulk read does not end up displacing most of the\n+cached contents. A per-iterator option can be used to achieve this:\n+\n+```c++\n+leveldb::ReadOptions options;\n+options.fill_cache = false;\n+leveldb::Iterator* it = db->NewIterator(options);\n+for (it->SeekToFirst(); it->Valid(); it->Next()) {\n+  ...\n+}\n+```\n+\n+### Key Layout\n+\n+Note that the unit of disk transfer and caching is a block. Adjacent keys\n+(according to the database sort order) will usually be placed in the same block.\n+Therefore the application can improve its performance by placing keys that are\n+accessed together near each other and placing infrequently used keys in a\n+separate region of the key space.\n+\n+For example, suppose we are implementing a simple file system on top of leveldb.\n+The types of entries we might wish to store are:\n+\n+    filename -> permission-bits, length, list of file_block_ids\n+    file_block_id -> data\n+\n+We might want to prefix filename keys with one letter (say '/') and the\n+`file_block_id` keys with a different letter (say '0') so that scans over just\n+the metadata do not force us to fetch and cache bulky file contents.\n+\n+### Filters\n+\n+Because of the way leveldb data is organized on disk, a single `Get()` call may\n+involve multiple reads from disk. The optional FilterPolicy mechanism can be\n+used to reduce the number of disk reads substantially.\n+\n+```c++\n+leveldb::Options options;\n+options.filter_policy = NewBloomFilterPolicy(10);\n+leveldb::DB* db;\n+leveldb::DB::Open(options, \"/tmp/testdb\", &db);\n+... use the database ...\n+delete db;\n+delete options.filter_policy;\n+```\n+\n+The preceding code associates a Bloom filter based filtering policy with the\n+database.  Bloom filter based filtering relies on keeping some number of bits of\n+data in memory per key (in this case 10 bits per key since that is the argument\n+we passed to `NewBloomFilterPolicy`). This filter will reduce the number of\n+unnecessary disk reads needed for Get() calls by a factor of approximately\n+a 100. Increasing the bits per key will lead to a larger reduction at the cost\n+of more memory usage. We recommend that applications whose working set does not\n+fit in memory and that do a lot of random reads set a filter policy.\n+\n+If you are using a custom comparator, you should ensure that the filter policy\n+you are using is compatible with your comparator. For example, consider a\n+comparator that ignores trailing spaces when comparing keys.\n+`NewBloomFilterPolicy` must not be used with such a comparator. Instead, the\n+application should provide a custom filter policy that also ignores trailing\n+spaces. For example:\n+\n+```c++\n+class CustomFilterPolicy : public leveldb::FilterPolicy {\n+ private:\n+  FilterPolicy* builtin_policy_;\n+\n+ public:\n+  CustomFilterPolicy() : builtin_policy_(NewBloomFilterPolicy(10)) {}\n+  ~CustomFilterPolicy() { delete builtin_policy_; }\n+\n+  const char* Name() const { return \"IgnoreTrailingSpacesFilter\"; }\n+\n+  void CreateFilter(const Slice* keys, int n, std::string* dst) const {\n+    // Use builtin bloom filter code after removing trailing spaces\n+    std::vector<Slice> trimmed(n);\n+    for (int i = 0; i < n; i++) {\n+      trimmed[i] = RemoveTrailingSpaces(keys[i]);\n+    }\n+    return builtin_policy_->CreateFilter(&trimmed[i], n, dst);\n+  }\n+};\n+```\n+\n+Advanced applications may provide a filter policy that does not use a bloom\n+filter but uses some other mechanism for summarizing a set of keys. See\n+`leveldb/filter_policy.h` for detail.\n+\n+## Checksums\n+\n+leveldb associates checksums with all data it stores in the file system. There\n+are two separate controls provided over how aggressively these checksums are\n+verified:\n+\n+`ReadOptions::verify_checksums` may be set to true to force checksum\n+verification of all data that is read from the file system on behalf of a\n+particular read.  By default, no such verification is done.\n+\n+`Options::paranoid_checks` may be set to true before opening a database to make\n+the database implementation raise an error as soon as it detects an internal\n+corruption. Depending on which portion of the database has been corrupted, the\n+error may be raised when the database is opened, or later by another database\n+operation. By default, paranoid checking is off so that the database can be used\n+even if parts of its persistent storage have been corrupted.\n+\n+If a database is corrupted (perhaps it cannot be opened when paranoid checking\n+is turned on), the `leveldb::RepairDB` function may be used to recover as much\n+of the data as possible\n+\n+## Approximate Sizes\n+\n+The `GetApproximateSizes` method can used to get the approximate number of bytes\n+of file system space used by one or more key ranges.\n+\n+```c++\n+leveldb::Range ranges[2];\n+ranges[0] = leveldb::Range(\"a\", \"c\");\n+ranges[1] = leveldb::Range(\"x\", \"z\");\n+uint64_t sizes[2];\n+leveldb::Status s = db->GetApproximateSizes(ranges, 2, sizes);\n+```\n+\n+The preceding call will set `sizes[0]` to the approximate number of bytes of\n+file system space used by the key range `[a..c)` and `sizes[1]` to the\n+approximate number of bytes used by the key range `[x..z)`.\n+\n+## Environment\n+\n+All file operations (and other operating system calls) issued by the leveldb\n+implementation are routed through a `leveldb::Env` object. Sophisticated clients\n+may wish to provide their own Env implementation to get better control.\n+For example, an application may introduce artificial delays in the file IO\n+paths to limit the impact of leveldb on other activities in the system.\n+\n+```c++\n+class SlowEnv : public leveldb::Env {\n+  ... implementation of the Env interface ...\n+};\n+\n+SlowEnv env;\n+leveldb::Options options;\n+options.env = &env;\n+Status s = leveldb::DB::Open(options, ...);\n+```\n+\n+## Porting\n+\n+leveldb may be ported to a new platform by providing platform specific\n+implementations of the types/methods/functions exported by\n+`leveldb/port/port.h`.  See `leveldb/port/port_example.h` for more details.\n+\n+In addition, the new platform may need a new default `leveldb::Env`\n+implementation.  See `leveldb/util/env_posix.h` for an example.\n+\n+## Other Information\n+\n+Details about the leveldb implementation may be found in the following\n+documents:\n+\n+1. [Implementation notes](impl.md)\n+2. [Format of an immutable Table file](table_format.md)\n+3. [Format of a log file](log_format.md)"
      },
      {
        "sha": "f32cb5d7dac482e71a103f85b1a2667b92e6120e",
        "filename": "src/leveldb/doc/log_format.md",
        "status": "added",
        "additions": 75,
        "deletions": 0,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/doc/log_format.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/doc/log_format.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/log_format.md?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -0,0 +1,75 @@\n+leveldb Log format\n+==================\n+The log file contents are a sequence of 32KB blocks.  The only exception is that\n+the tail of the file may contain a partial block.\n+\n+Each block consists of a sequence of records:\n+\n+    block := record* trailer?\n+    record :=\n+      checksum: uint32     // crc32c of type and data[] ; little-endian\n+      length: uint16       // little-endian\n+      type: uint8          // One of FULL, FIRST, MIDDLE, LAST\n+      data: uint8[length]\n+\n+A record never starts within the last six bytes of a block (since it won't fit).\n+Any leftover bytes here form the trailer, which must consist entirely of zero\n+bytes and must be skipped by readers.\n+\n+Aside: if exactly seven bytes are left in the current block, and a new non-zero\n+length record is added, the writer must emit a FIRST record (which contains zero\n+bytes of user data) to fill up the trailing seven bytes of the block and then\n+emit all of the user data in subsequent blocks.\n+\n+More types may be added in the future.  Some Readers may skip record types they\n+do not understand, others may report that some data was skipped.\n+\n+    FULL == 1\n+    FIRST == 2\n+    MIDDLE == 3\n+    LAST == 4\n+\n+The FULL record contains the contents of an entire user record.\n+\n+FIRST, MIDDLE, LAST are types used for user records that have been split into\n+multiple fragments (typically because of block boundaries).  FIRST is the type\n+of the first fragment of a user record, LAST is the type of the last fragment of\n+a user record, and MIDDLE is the type of all interior fragments of a user\n+record.\n+\n+Example: consider a sequence of user records:\n+\n+    A: length 1000\n+    B: length 97270\n+    C: length 8000\n+\n+**A** will be stored as a FULL record in the first block.\n+\n+**B** will be split into three fragments: first fragment occupies the rest of\n+the first block, second fragment occupies the entirety of the second block, and\n+the third fragment occupies a prefix of the third block.  This will leave six\n+bytes free in the third block, which will be left empty as the trailer.\n+\n+**C** will be stored as a FULL record in the fourth block.\n+\n+----\n+\n+## Some benefits over the recordio format:\n+\n+1. We do not need any heuristics for resyncing - just go to next block boundary\n+   and scan.  If there is a corruption, skip to the next block.  As a\n+   side-benefit, we do not get confused when part of the contents of one log\n+   file are embedded as a record inside another log file.\n+\n+2. Splitting at approximate boundaries (e.g., for mapreduce) is simple: find the\n+   next block boundary and skip records until we hit a FULL or FIRST record.\n+\n+3. We do not need extra buffering for large records.\n+\n+## Some downsides compared to recordio format:\n+\n+1. No packing of tiny records.  This could be fixed by adding a new record type,\n+   so it is a shortcoming of the current implementation, not necessarily the\n+   format.\n+\n+2. No compression.  Again, this could be fixed by adding new record types."
      },
      {
        "sha": "4cca5ef6ead327bc4c55d8941528f656fa68166c",
        "filename": "src/leveldb/doc/log_format.txt",
        "status": "removed",
        "additions": 0,
        "deletions": 75,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/leveldb/doc/log_format.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/leveldb/doc/log_format.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/log_format.txt?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,75 +0,0 @@\n-The log file contents are a sequence of 32KB blocks.  The only\n-exception is that the tail of the file may contain a partial block.\n-\n-Each block consists of a sequence of records:\n-   block := record* trailer?\n-   record :=\n-\tchecksum: uint32\t// crc32c of type and data[] ; little-endian\n-\tlength: uint16\t\t// little-endian\n-\ttype: uint8\t\t// One of FULL, FIRST, MIDDLE, LAST\n-\tdata: uint8[length]\n-\n-A record never starts within the last six bytes of a block (since it\n-won't fit).  Any leftover bytes here form the trailer, which must\n-consist entirely of zero bytes and must be skipped by readers.\n-\n-Aside: if exactly seven bytes are left in the current block, and a new\n-non-zero length record is added, the writer must emit a FIRST record\n-(which contains zero bytes of user data) to fill up the trailing seven\n-bytes of the block and then emit all of the user data in subsequent\n-blocks.\n-\n-More types may be added in the future.  Some Readers may skip record\n-types they do not understand, others may report that some data was\n-skipped.\n-\n-FULL == 1\n-FIRST == 2\n-MIDDLE == 3\n-LAST == 4\n-\n-The FULL record contains the contents of an entire user record.\n-\n-FIRST, MIDDLE, LAST are types used for user records that have been\n-split into multiple fragments (typically because of block boundaries).\n-FIRST is the type of the first fragment of a user record, LAST is the\n-type of the last fragment of a user record, and MIDDLE is the type of\n-all interior fragments of a user record.\n-\n-Example: consider a sequence of user records:\n-   A: length 1000\n-   B: length 97270\n-   C: length 8000\n-A will be stored as a FULL record in the first block.\n-\n-B will be split into three fragments: first fragment occupies the rest\n-of the first block, second fragment occupies the entirety of the\n-second block, and the third fragment occupies a prefix of the third\n-block.  This will leave six bytes free in the third block, which will\n-be left empty as the trailer.\n-\n-C will be stored as a FULL record in the fourth block.\n-\n-===================\n-\n-Some benefits over the recordio format:\n-\n-(1) We do not need any heuristics for resyncing - just go to next\n-block boundary and scan.  If there is a corruption, skip to the next\n-block.  As a side-benefit, we do not get confused when part of the\n-contents of one log file are embedded as a record inside another log\n-file.\n-\n-(2) Splitting at approximate boundaries (e.g., for mapreduce) is\n-simple: find the next block boundary and skip records until we\n-hit a FULL or FIRST record.\n-\n-(3) We do not need extra buffering for large records.\n-\n-Some downsides compared to recordio format:\n-\n-(1) No packing of tiny records.  This could be fixed by adding a new\n-record type, so it is a shortcoming of the current implementation,\n-not necessarily the format.\n-\n-(2) No compression.  Again, this could be fixed by adding new record types."
      },
      {
        "sha": "5fe7e72411b828ddc3453754d451fe357626382e",
        "filename": "src/leveldb/doc/table_format.md",
        "status": "added",
        "additions": 107,
        "deletions": 0,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/doc/table_format.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/doc/table_format.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/table_format.md?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -0,0 +1,107 @@\n+leveldb File format\n+===================\n+\n+    <beginning_of_file>\n+    [data block 1]\n+    [data block 2]\n+    ...\n+    [data block N]\n+    [meta block 1]\n+    ...\n+    [meta block K]\n+    [metaindex block]\n+    [index block]\n+    [Footer]        (fixed size; starts at file_size - sizeof(Footer))\n+    <end_of_file>\n+\n+The file contains internal pointers.  Each such pointer is called\n+a BlockHandle and contains the following information:\n+\n+    offset:   varint64\n+    size:     varint64\n+\n+See [varints](https://developers.google.com/protocol-buffers/docs/encoding#varints)\n+for an explanation of varint64 format.\n+\n+1.  The sequence of key/value pairs in the file are stored in sorted\n+order and partitioned into a sequence of data blocks.  These blocks\n+come one after another at the beginning of the file.  Each data block\n+is formatted according to the code in `block_builder.cc`, and then\n+optionally compressed.\n+\n+2. After the data blocks we store a bunch of meta blocks.  The\n+supported meta block types are described below.  More meta block types\n+may be added in the future.  Each meta block is again formatted using\n+`block_builder.cc` and then optionally compressed.\n+\n+3. A \"metaindex\" block.  It contains one entry for every other meta\n+block where the key is the name of the meta block and the value is a\n+BlockHandle pointing to that meta block.\n+\n+4. An \"index\" block.  This block contains one entry per data block,\n+where the key is a string >= last key in that data block and before\n+the first key in the successive data block.  The value is the\n+BlockHandle for the data block.\n+\n+5. At the very end of the file is a fixed length footer that contains\n+the BlockHandle of the metaindex and index blocks as well as a magic number.\n+\n+        metaindex_handle: char[p];     // Block handle for metaindex\n+        index_handle:     char[q];     // Block handle for index\n+        padding:          char[40-p-q];// zeroed bytes to make fixed length\n+                                       // (40==2*BlockHandle::kMaxEncodedLength)\n+        magic:            fixed64;     // == 0xdb4775248b80fb57 (little-endian)\n+\n+## \"filter\" Meta Block\n+\n+If a `FilterPolicy` was specified when the database was opened, a\n+filter block is stored in each table.  The \"metaindex\" block contains\n+an entry that maps from `filter.<N>` to the BlockHandle for the filter\n+block where `<N>` is the string returned by the filter policy's\n+`Name()` method.\n+\n+The filter block stores a sequence of filters, where filter i contains\n+the output of `FilterPolicy::CreateFilter()` on all keys that are stored\n+in a block whose file offset falls within the range\n+\n+    [ i*base ... (i+1)*base-1 ]\n+\n+Currently, \"base\" is 2KB.  So for example, if blocks X and Y start in\n+the range `[ 0KB .. 2KB-1 ]`, all of the keys in X and Y will be\n+converted to a filter by calling `FilterPolicy::CreateFilter()`, and the\n+resulting filter will be stored as the first filter in the filter\n+block.\n+\n+The filter block is formatted as follows:\n+\n+    [filter 0]\n+    [filter 1]\n+    [filter 2]\n+    ...\n+    [filter N-1]\n+\n+    [offset of filter 0]                  : 4 bytes\n+    [offset of filter 1]                  : 4 bytes\n+    [offset of filter 2]                  : 4 bytes\n+    ...\n+    [offset of filter N-1]                : 4 bytes\n+\n+    [offset of beginning of offset array] : 4 bytes\n+    lg(base)                              : 1 byte\n+\n+The offset array at the end of the filter block allows efficient\n+mapping from a data block offset to the corresponding filter.\n+\n+## \"stats\" Meta Block\n+\n+This meta block contains a bunch of stats.  The key is the name\n+of the statistic.  The value contains the statistic.\n+\n+TODO(postrelease): record following stats.\n+\n+    data size\n+    index size\n+    key size (uncompressed)\n+    value size (uncompressed)\n+    number of entries\n+    number of data blocks"
      },
      {
        "sha": "ca8f9b4460ad85d9e09f14a959ed47bd2812edb5",
        "filename": "src/leveldb/doc/table_format.txt",
        "status": "removed",
        "additions": 0,
        "deletions": 104,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/leveldb/doc/table_format.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/src/leveldb/doc/table_format.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/doc/table_format.txt?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3",
        "patch": "@@ -1,104 +0,0 @@\n-File format\n-===========\n-\n-  <beginning_of_file>\n-  [data block 1]\n-  [data block 2]\n-  ...\n-  [data block N]\n-  [meta block 1]\n-  ...\n-  [meta block K]\n-  [metaindex block]\n-  [index block]\n-  [Footer]        (fixed size; starts at file_size - sizeof(Footer))\n-  <end_of_file>\n-\n-The file contains internal pointers.  Each such pointer is called\n-a BlockHandle and contains the following information:\n-  offset:\t    varint64\n-  size:\t\t    varint64\n-See https://developers.google.com/protocol-buffers/docs/encoding#varints\n-for an explanation of varint64 format.\n-\n-(1) The sequence of key/value pairs in the file are stored in sorted\n-order and partitioned into a sequence of data blocks.  These blocks\n-come one after another at the beginning of the file.  Each data block\n-is formatted according to the code in block_builder.cc, and then\n-optionally compressed.\n-\n-(2) After the data blocks we store a bunch of meta blocks.  The\n-supported meta block types are described below.  More meta block types\n-may be added in the future.  Each meta block is again formatted using\n-block_builder.cc and then optionally compressed.\n-\n-(3) A \"metaindex\" block.  It contains one entry for every other meta\n-block where the key is the name of the meta block and the value is a\n-BlockHandle pointing to that meta block.\n-\n-(4) An \"index\" block.  This block contains one entry per data block,\n-where the key is a string >= last key in that data block and before\n-the first key in the successive data block.  The value is the\n-BlockHandle for the data block.\n-\n-(6) At the very end of the file is a fixed length footer that contains\n-the BlockHandle of the metaindex and index blocks as well as a magic number.\n-       metaindex_handle: char[p];    // Block handle for metaindex\n-       index_handle:     char[q];    // Block handle for index\n-       padding:          char[40-p-q]; // zeroed bytes to make fixed length\n-                                       // (40==2*BlockHandle::kMaxEncodedLength)\n-       magic:            fixed64;    // == 0xdb4775248b80fb57 (little-endian)\n-\n-\"filter\" Meta Block\n--------------------\n-\n-If a \"FilterPolicy\" was specified when the database was opened, a\n-filter block is stored in each table.  The \"metaindex\" block contains\n-an entry that maps from \"filter.<N>\" to the BlockHandle for the filter\n-block where \"<N>\" is the string returned by the filter policy's\n-\"Name()\" method.\n-\n-The filter block stores a sequence of filters, where filter i contains\n-the output of FilterPolicy::CreateFilter() on all keys that are stored\n-in a block whose file offset falls within the range\n-\n-    [ i*base ... (i+1)*base-1 ]\n-\n-Currently, \"base\" is 2KB.  So for example, if blocks X and Y start in\n-the range [ 0KB .. 2KB-1 ], all of the keys in X and Y will be\n-converted to a filter by calling FilterPolicy::CreateFilter(), and the\n-resulting filter will be stored as the first filter in the filter\n-block.\n-\n-The filter block is formatted as follows:\n-\n-     [filter 0]\n-     [filter 1]\n-     [filter 2]\n-     ...\n-     [filter N-1]\n-\n-     [offset of filter 0]                  : 4 bytes\n-     [offset of filter 1]                  : 4 bytes\n-     [offset of filter 2]                  : 4 bytes\n-     ...\n-     [offset of filter N-1]                : 4 bytes\n-\n-     [offset of beginning of offset array] : 4 bytes\n-     lg(base)                              : 1 byte\n-\n-The offset array at the end of the filter block allows efficient\n-mapping from a data block offset to the corresponding filter.\n-\n-\"stats\" Meta Block\n-------------------\n-\n-This meta block contains a bunch of stats.  The key is the name\n-of the statistic.  The value contains the statistic.\n-TODO(postrelease): record following stats.\n-  data size\n-  index size\n-  key size (uncompressed)\n-  value size (uncompressed)\n-  number of entries\n-  number of data blocks"
      },
      {
        "sha": "bfab10a0b725be9ed218783ee8fc98110fa77988",
        "filename": "src/leveldb/include/leveldb/db.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/include/leveldb/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/include/leveldb/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/db.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -14,7 +14,7 @@ namespace leveldb {\n \n // Update Makefile if you change these\n static const int kMajorVersion = 1;\n-static const int kMinorVersion = 19;\n+static const int kMinorVersion = 20;\n \n struct Options;\n struct ReadOptions;"
      },
      {
        "sha": "976e38122aafa88acba169b3fc3506c013a75b61",
        "filename": "src/leveldb/include/leveldb/options.h",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/include/leveldb/options.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/include/leveldb/options.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/include/leveldb/options.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -112,6 +112,18 @@ struct Options {\n   // Default: 16\n   int block_restart_interval;\n \n+  // Leveldb will write up to this amount of bytes to a file before\n+  // switching to a new one.\n+  // Most clients should leave this parameter alone.  However if your\n+  // filesystem is more efficient with larger files, you could\n+  // consider increasing the value.  The downside will be longer\n+  // compactions and hence longer latency/performance hiccups.\n+  // Another reason to increase this parameter might be when you are\n+  // initially populating a large database.\n+  //\n+  // Default: 2MB\n+  size_t max_file_size;\n+\n   // Compress blocks using the specified compression algorithm.  This\n   // parameter can be changed dynamically.\n   //"
      },
      {
        "sha": "97bd669a5ed6cd319c6b12bdd43bd43f8bab1548",
        "filename": "src/leveldb/port/port_example.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/port/port_example.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/port/port_example.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_example.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -129,6 +129,12 @@ extern bool Snappy_Uncompress(const char* input_data, size_t input_length,\n // The concatenation of all \"data[0,n-1]\" fragments is the heap profile.\n extern bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg);\n \n+// Extend the CRC to include the first n bytes of buf.\n+//\n+// Returns zero if the CRC cannot be extended using acceleration, else returns\n+// the newly extended CRC value (which may also be zero).\n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size);\n+\n }  // namespace port\n }  // namespace leveldb\n "
      },
      {
        "sha": "7e8213b22ecaf216067040a818d4cdb786d8ca98",
        "filename": "src/leveldb/port/port_posix.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/port/port_posix.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/port/port_posix.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_posix.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -152,6 +152,8 @@ inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {\n   return false;\n }\n \n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size);\n+\n } // namespace port\n } // namespace leveldb\n "
      },
      {
        "sha": "1e519ba0b64befe92b0a6ca70f290f699151baab",
        "filename": "src/leveldb/port/port_posix_sse.cc",
        "status": "added",
        "additions": 129,
        "deletions": 0,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/port/port_posix_sse.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/port/port_posix_sse.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_posix_sse.cc?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -0,0 +1,129 @@\n+// Copyright 2016 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+//\n+// A portable implementation of crc32c, optimized to handle\n+// four bytes at a time.\n+//\n+// In a separate source file to allow this accelerated CRC32C function to be\n+// compiled with the appropriate compiler flags to enable x86 SSE 4.2\n+// instructions.\n+\n+#include <stdint.h>\n+#include <string.h>\n+#include \"port/port.h\"\n+\n+#if defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+#if defined(_MSC_VER)\n+#include <intrin.h>\n+#elif defined(__GNUC__) && defined(__SSE4_2__)\n+#include <nmmintrin.h>\n+#include <cpuid.h>\n+#endif\n+\n+#endif  // defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+namespace leveldb {\n+namespace port {\n+\n+#if defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+// Used to fetch a naturally-aligned 32-bit word in little endian byte-order\n+static inline uint32_t LE_LOAD32(const uint8_t *p) {\n+  // SSE is x86 only, so ensured that |p| is always little-endian.\n+  uint32_t word;\n+  memcpy(&word, p, sizeof(word));\n+  return word;\n+}\n+\n+#if defined(_M_X64) || defined(__x86_64__)  // LE_LOAD64 is only used on x64.\n+\n+// Used to fetch a naturally-aligned 64-bit word in little endian byte-order\n+static inline uint64_t LE_LOAD64(const uint8_t *p) {\n+  uint64_t dword;\n+  memcpy(&dword, p, sizeof(dword));\n+  return dword;\n+}\n+\n+#endif  // defined(_M_X64) || defined(__x86_64__)\n+\n+static inline bool HaveSSE42() {\n+#if defined(_MSC_VER)\n+  int cpu_info[4];\n+  __cpuid(cpu_info, 1);\n+  return (cpu_info[2] & (1 << 20)) != 0;\n+#elif defined(__GNUC__)\n+  unsigned int eax, ebx, ecx, edx;\n+  __get_cpuid(1, &eax, &ebx, &ecx, &edx);\n+  return (ecx & (1 << 20)) != 0;\n+#else\n+  return false;\n+#endif\n+}\n+\n+#endif  // defined(LEVELDB_PLATFORM_POSIX_SSE)\n+\n+// For further improvements see Intel publication at:\n+// http://download.intel.com/design/intarch/papers/323405.pdf\n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size) {\n+#if !defined(LEVELDB_PLATFORM_POSIX_SSE)\n+  return 0;\n+#else\n+  static bool have = HaveSSE42();\n+  if (!have) {\n+    return 0;\n+  }\n+\n+  const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);\n+  const uint8_t *e = p + size;\n+  uint32_t l = crc ^ 0xffffffffu;\n+\n+#define STEP1 do {                              \\\n+    l = _mm_crc32_u8(l, *p++);                  \\\n+} while (0)\n+#define STEP4 do {                              \\\n+    l = _mm_crc32_u32(l, LE_LOAD32(p));         \\\n+    p += 4;                                     \\\n+} while (0)\n+#define STEP8 do {                              \\\n+    l = _mm_crc32_u64(l, LE_LOAD64(p));         \\\n+    p += 8;                                     \\\n+} while (0)\n+\n+  if (size > 16) {\n+    // Process unaligned bytes\n+    for (unsigned int i = reinterpret_cast<uintptr_t>(p) % 8; i; --i) {\n+      STEP1;\n+    }\n+\n+    // _mm_crc32_u64 is only available on x64.\n+#if defined(_M_X64) || defined(__x86_64__)\n+    // Process 8 bytes at a time\n+    while ((e-p) >= 8) {\n+      STEP8;\n+    }\n+    // Process 4 bytes at a time\n+    if ((e-p) >= 4) {\n+      STEP4;\n+    }\n+#else  // !(defined(_M_X64) || defined(__x86_64__))\n+    // Process 4 bytes at a time\n+    while ((e-p) >= 4) {\n+      STEP4;\n+    }\n+#endif  // defined(_M_X64) || defined(__x86_64__)\n+  }\n+  // Process the last few bytes\n+  while (p != e) {\n+    STEP1;\n+  }\n+#undef STEP8\n+#undef STEP4\n+#undef STEP1\n+  return l ^ 0xffffffffu;\n+#endif  // defined(LEVELDB_PLATFORM_POSIX_SSE)\n+}\n+\n+}  // namespace port\n+}  // namespace leveldb"
      },
      {
        "sha": "50090048228389c0595e44a2e0e2c274b3799245",
        "filename": "src/leveldb/port/port_win.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/port/port_win.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/port/port_win.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/port/port_win.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -168,6 +168,8 @@ inline bool GetHeapProfile(void (*func)(void*, const char*, int), void* arg) {\n   return false;\n }\n \n+uint32_t AcceleratedCRC32C(uint32_t crc, const char* buf, size_t size);\n+\n }\n }\n "
      },
      {
        "sha": "1ed5134170e54c430d8a0318e95ece23235ae1ba",
        "filename": "src/leveldb/table/filter_block.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/table/filter_block.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/table/filter_block.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/table/filter_block.cc?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -9,7 +9,7 @@\n \n namespace leveldb {\n \n-// See doc/table_format.txt for an explanation of the filter block format.\n+// See doc/table_format.md for an explanation of the filter block format.\n \n // Generate new filter every 2KB of data\n static const size_t kFilterBaseLg = 11;"
      },
      {
        "sha": "edd61cfd6fca832ff6e53f50700899fe1196c2ad",
        "filename": "src/leveldb/util/crc32c.cc",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/util/crc32c.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/util/crc32c.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/crc32c.cc?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -8,6 +8,8 @@\n #include \"util/crc32c.h\"\n \n #include <stdint.h>\n+\n+#include \"port/port.h\"\n #include \"util/coding.h\"\n \n namespace leveldb {\n@@ -283,7 +285,23 @@ static inline uint32_t LE_LOAD32(const uint8_t *p) {\n   return DecodeFixed32(reinterpret_cast<const char*>(p));\n }\n \n+// Determine if the CPU running this program can accelerate the CRC32C\n+// calculation.\n+static bool CanAccelerateCRC32C() {\n+  // port::AcceleretedCRC32C returns zero when unable to accelerate.\n+  static const char kTestCRCBuffer[] = \"TestCRCBuffer\";\n+  static const char kBufSize = sizeof(kTestCRCBuffer) - 1;\n+  static const uint32_t kTestCRCValue = 0xdcbc59fa;\n+\n+  return port::AcceleratedCRC32C(0, kTestCRCBuffer, kBufSize) == kTestCRCValue;\n+}\n+\n uint32_t Extend(uint32_t crc, const char* buf, size_t size) {\n+  static bool accelerate = CanAccelerateCRC32C();\n+  if (accelerate) {\n+    return port::AcceleratedCRC32C(crc, buf, size);\n+  }\n+\n   const uint8_t *p = reinterpret_cast<const uint8_t *>(buf);\n   const uint8_t *e = p + size;\n   uint32_t l = crc ^ 0xffffffffu;"
      },
      {
        "sha": "dd852af354c83d7d4839fa1e2a3b55824b4ae43c",
        "filename": "src/leveldb/util/env_posix.cc",
        "status": "modified",
        "additions": 136,
        "deletions": 59,
        "changes": 195,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/util/env_posix.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/util/env_posix.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_posix.cc?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -11,28 +11,85 @@\n #include <stdlib.h>\n #include <string.h>\n #include <sys/mman.h>\n+#include <sys/resource.h>\n #include <sys/stat.h>\n #include <sys/time.h>\n #include <sys/types.h>\n #include <time.h>\n #include <unistd.h>\n #include <deque>\n+#include <limits>\n #include <set>\n #include \"leveldb/env.h\"\n #include \"leveldb/slice.h\"\n #include \"port/port.h\"\n #include \"util/logging.h\"\n #include \"util/mutexlock.h\"\n #include \"util/posix_logger.h\"\n+#include \"util/env_posix_test_helper.h\"\n \n namespace leveldb {\n \n namespace {\n \n+static int open_read_only_file_limit = -1;\n+static int mmap_limit = -1;\n+\n static Status IOError(const std::string& context, int err_number) {\n   return Status::IOError(context, strerror(err_number));\n }\n \n+// Helper class to limit resource usage to avoid exhaustion.\n+// Currently used to limit read-only file descriptors and mmap file usage\n+// so that we do not end up running out of file descriptors, virtual memory,\n+// or running into kernel performance problems for very large databases.\n+class Limiter {\n+ public:\n+  // Limit maximum number of resources to |n|.\n+  Limiter(intptr_t n) {\n+    SetAllowed(n);\n+  }\n+\n+  // If another resource is available, acquire it and return true.\n+  // Else return false.\n+  bool Acquire() {\n+    if (GetAllowed() <= 0) {\n+      return false;\n+    }\n+    MutexLock l(&mu_);\n+    intptr_t x = GetAllowed();\n+    if (x <= 0) {\n+      return false;\n+    } else {\n+      SetAllowed(x - 1);\n+      return true;\n+    }\n+  }\n+\n+  // Release a resource acquired by a previous call to Acquire() that returned\n+  // true.\n+  void Release() {\n+    MutexLock l(&mu_);\n+    SetAllowed(GetAllowed() + 1);\n+  }\n+\n+ private:\n+  port::Mutex mu_;\n+  port::AtomicPointer allowed_;\n+\n+  intptr_t GetAllowed() const {\n+    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());\n+  }\n+\n+  // REQUIRES: mu_ must be held\n+  void SetAllowed(intptr_t v) {\n+    allowed_.Release_Store(reinterpret_cast<void*>(v));\n+  }\n+\n+  Limiter(const Limiter&);\n+  void operator=(const Limiter&);\n+};\n+\n class PosixSequentialFile: public SequentialFile {\n  private:\n   std::string filename_;\n@@ -70,73 +127,51 @@ class PosixSequentialFile: public SequentialFile {\n class PosixRandomAccessFile: public RandomAccessFile {\n  private:\n   std::string filename_;\n+  bool temporary_fd_;  // If true, fd_ is -1 and we open on every read.\n   int fd_;\n+  Limiter* limiter_;\n \n  public:\n-  PosixRandomAccessFile(const std::string& fname, int fd)\n-      : filename_(fname), fd_(fd) { }\n-  virtual ~PosixRandomAccessFile() { close(fd_); }\n+  PosixRandomAccessFile(const std::string& fname, int fd, Limiter* limiter)\n+      : filename_(fname), fd_(fd), limiter_(limiter) {\n+    temporary_fd_ = !limiter->Acquire();\n+    if (temporary_fd_) {\n+      // Open file on every access.\n+      close(fd_);\n+      fd_ = -1;\n+    }\n+  }\n+\n+  virtual ~PosixRandomAccessFile() {\n+    if (!temporary_fd_) {\n+      close(fd_);\n+      limiter_->Release();\n+    }\n+  }\n \n   virtual Status Read(uint64_t offset, size_t n, Slice* result,\n                       char* scratch) const {\n+    int fd = fd_;\n+    if (temporary_fd_) {\n+      fd = open(filename_.c_str(), O_RDONLY);\n+      if (fd < 0) {\n+        return IOError(filename_, errno);\n+      }\n+    }\n+\n     Status s;\n-    ssize_t r = pread(fd_, scratch, n, static_cast<off_t>(offset));\n+    ssize_t r = pread(fd, scratch, n, static_cast<off_t>(offset));\n     *result = Slice(scratch, (r < 0) ? 0 : r);\n     if (r < 0) {\n       // An error: return a non-ok status\n       s = IOError(filename_, errno);\n     }\n-    return s;\n-  }\n-};\n-\n-// Helper class to limit mmap file usage so that we do not end up\n-// running out virtual memory or running into kernel performance\n-// problems for very large databases.\n-class MmapLimiter {\n- public:\n-  // Up to 1000 mmaps for 64-bit binaries; none for smaller pointer sizes.\n-  MmapLimiter() {\n-    SetAllowed(sizeof(void*) >= 8 ? 1000 : 0);\n-  }\n-\n-  // If another mmap slot is available, acquire it and return true.\n-  // Else return false.\n-  bool Acquire() {\n-    if (GetAllowed() <= 0) {\n-      return false;\n-    }\n-    MutexLock l(&mu_);\n-    intptr_t x = GetAllowed();\n-    if (x <= 0) {\n-      return false;\n-    } else {\n-      SetAllowed(x - 1);\n-      return true;\n+    if (temporary_fd_) {\n+      // Close the temporary file descriptor opened earlier.\n+      close(fd);\n     }\n+    return s;\n   }\n-\n-  // Release a slot acquired by a previous call to Acquire() that returned true.\n-  void Release() {\n-    MutexLock l(&mu_);\n-    SetAllowed(GetAllowed() + 1);\n-  }\n-\n- private:\n-  port::Mutex mu_;\n-  port::AtomicPointer allowed_;\n-\n-  intptr_t GetAllowed() const {\n-    return reinterpret_cast<intptr_t>(allowed_.Acquire_Load());\n-  }\n-\n-  // REQUIRES: mu_ must be held\n-  void SetAllowed(intptr_t v) {\n-    allowed_.Release_Store(reinterpret_cast<void*>(v));\n-  }\n-\n-  MmapLimiter(const MmapLimiter&);\n-  void operator=(const MmapLimiter&);\n };\n \n // mmap() based random-access\n@@ -145,12 +180,12 @@ class PosixMmapReadableFile: public RandomAccessFile {\n   std::string filename_;\n   void* mmapped_region_;\n   size_t length_;\n-  MmapLimiter* limiter_;\n+  Limiter* limiter_;\n \n  public:\n   // base[0,length-1] contains the mmapped contents of the file.\n   PosixMmapReadableFile(const std::string& fname, void* base, size_t length,\n-                        MmapLimiter* limiter)\n+                        Limiter* limiter)\n       : filename_(fname), mmapped_region_(base), length_(length),\n         limiter_(limiter) {\n   }\n@@ -231,7 +266,7 @@ class PosixWritableFile : public WritableFile {\n       if (fd < 0) {\n         s = IOError(dir, errno);\n       } else {\n-        if (fsync(fd) < 0) {\n+        if (fsync(fd) < 0 && errno != EINVAL) {\n           s = IOError(dir, errno);\n         }\n         close(fd);\n@@ -333,7 +368,7 @@ class PosixEnv : public Env {\n         mmap_limit_.Release();\n       }\n     } else {\n-      *result = new PosixRandomAccessFile(fname, fd);\n+      *result = new PosixRandomAccessFile(fname, fd, &fd_limit_);\n     }\n     return s;\n   }\n@@ -533,10 +568,42 @@ class PosixEnv : public Env {\n   BGQueue queue_;\n \n   PosixLockTable locks_;\n-  MmapLimiter mmap_limit_;\n+  Limiter mmap_limit_;\n+  Limiter fd_limit_;\n };\n \n-PosixEnv::PosixEnv() : started_bgthread_(false) {\n+// Return the maximum number of concurrent mmaps.\n+static int MaxMmaps() {\n+  if (mmap_limit >= 0) {\n+    return mmap_limit;\n+  }\n+  // Up to 1000 mmaps for 64-bit binaries; none for smaller pointer sizes.\n+  mmap_limit = sizeof(void*) >= 8 ? 1000 : 0;\n+  return mmap_limit;\n+}\n+\n+// Return the maximum number of read-only files to keep open.\n+static intptr_t MaxOpenFiles() {\n+  if (open_read_only_file_limit >= 0) {\n+    return open_read_only_file_limit;\n+  }\n+  struct rlimit rlim;\n+  if (getrlimit(RLIMIT_NOFILE, &rlim)) {\n+    // getrlimit failed, fallback to hard-coded default.\n+    open_read_only_file_limit = 50;\n+  } else if (rlim.rlim_cur == RLIM_INFINITY) {\n+    open_read_only_file_limit = std::numeric_limits<int>::max();\n+  } else {\n+    // Allow use of 20% of available file descriptors for read-only files.\n+    open_read_only_file_limit = rlim.rlim_cur / 5;\n+  }\n+  return open_read_only_file_limit;\n+}\n+\n+PosixEnv::PosixEnv()\n+    : started_bgthread_(false),\n+      mmap_limit_(MaxMmaps()),\n+      fd_limit_(MaxOpenFiles()) {\n   PthreadCall(\"mutex_init\", pthread_mutex_init(&mu_, NULL));\n   PthreadCall(\"cvar_init\", pthread_cond_init(&bgsignal_, NULL));\n }\n@@ -611,6 +678,16 @@ static pthread_once_t once = PTHREAD_ONCE_INIT;\n static Env* default_env;\n static void InitDefaultEnv() { default_env = new PosixEnv; }\n \n+void EnvPosixTestHelper::SetReadOnlyFDLimit(int limit) {\n+  assert(default_env == NULL);\n+  open_read_only_file_limit = limit;\n+}\n+\n+void EnvPosixTestHelper::SetReadOnlyMMapLimit(int limit) {\n+  assert(default_env == NULL);\n+  mmap_limit = limit;\n+}\n+\n Env* Env::Default() {\n   pthread_once(&once, InitDefaultEnv);\n   return default_env;"
      },
      {
        "sha": "295f8ae4409f2a156c4e298cce4d6c8311e1e1b1",
        "filename": "src/leveldb/util/env_posix_test.cc",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/util/env_posix_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/util/env_posix_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_posix_test.cc?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -0,0 +1,66 @@\n+// Copyright (c) 2011 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#include \"leveldb/env.h\"\n+\n+#include \"port/port.h\"\n+#include \"util/testharness.h\"\n+#include \"util/env_posix_test_helper.h\"\n+\n+namespace leveldb {\n+\n+static const int kDelayMicros = 100000;\n+static const int kReadOnlyFileLimit = 4;\n+static const int kMMapLimit = 4;\n+\n+class EnvPosixTest {\n+ public:\n+  Env* env_;\n+  EnvPosixTest() : env_(Env::Default()) { }\n+\n+  static void SetFileLimits(int read_only_file_limit, int mmap_limit) {\n+    EnvPosixTestHelper::SetReadOnlyFDLimit(read_only_file_limit);\n+    EnvPosixTestHelper::SetReadOnlyMMapLimit(mmap_limit);\n+  }\n+};\n+\n+TEST(EnvPosixTest, TestOpenOnRead) {\n+  // Write some test data to a single file that will be opened |n| times.\n+  std::string test_dir;\n+  ASSERT_OK(env_->GetTestDirectory(&test_dir));\n+  std::string test_file = test_dir + \"/open_on_read.txt\";\n+\n+  FILE* f = fopen(test_file.c_str(), \"w\");\n+  ASSERT_TRUE(f != NULL);\n+  const char kFileData[] = \"abcdefghijklmnopqrstuvwxyz\";\n+  fputs(kFileData, f);\n+  fclose(f);\n+\n+  // Open test file some number above the sum of the two limits to force\n+  // open-on-read behavior of POSIX Env leveldb::RandomAccessFile.\n+  const int kNumFiles = kReadOnlyFileLimit + kMMapLimit + 5;\n+  leveldb::RandomAccessFile* files[kNumFiles] = {0};\n+  for (int i = 0; i < kNumFiles; i++) {\n+    ASSERT_OK(env_->NewRandomAccessFile(test_file, &files[i]));\n+  }\n+  char scratch;\n+  Slice read_result;\n+  for (int i = 0; i < kNumFiles; i++) {\n+    ASSERT_OK(files[i]->Read(i, 1, &read_result, &scratch));\n+    ASSERT_EQ(kFileData[i], read_result[0]);\n+  }\n+  for (int i = 0; i < kNumFiles; i++) {\n+    delete files[i];\n+  }\n+  ASSERT_OK(env_->DeleteFile(test_file));\n+}\n+\n+}  // namespace leveldb\n+\n+int main(int argc, char** argv) {\n+  // All tests currently run with the same read-only file limits.\n+  leveldb::EnvPosixTest::SetFileLimits(leveldb::kReadOnlyFileLimit,\n+                                       leveldb::kMMapLimit);\n+  return leveldb::test::RunAllTests();\n+}"
      },
      {
        "sha": "038696059826042f57808b58505c7f4339c54337",
        "filename": "src/leveldb/util/env_posix_test_helper.h",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/util/env_posix_test_helper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/util/env_posix_test_helper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_posix_test_helper.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -0,0 +1,28 @@\n+// Copyright 2017 The LevelDB Authors. All rights reserved.\n+// Use of this source code is governed by a BSD-style license that can be\n+// found in the LICENSE file. See the AUTHORS file for names of contributors.\n+\n+#ifndef STORAGE_LEVELDB_UTIL_ENV_POSIX_TEST_HELPER_H_\n+#define STORAGE_LEVELDB_UTIL_ENV_POSIX_TEST_HELPER_H_\n+\n+namespace leveldb {\n+\n+class EnvPosixTest;\n+\n+// A helper for the POSIX Env to facilitate testing.\n+class EnvPosixTestHelper {\n+ private:\n+  friend class EnvPosixTest;\n+\n+  // Set the maximum number of read-only files that will be opened.\n+  // Must be called before creating an Env.\n+  static void SetReadOnlyFDLimit(int limit);\n+\n+  // Set the maximum number of read-only files that will be mapped via mmap.\n+  // Must be called before creating an Env.\n+  static void SetReadOnlyMMapLimit(int limit);\n+};\n+\n+}  // namespace leveldb\n+\n+#endif  // STORAGE_LEVELDB_UTIL_ENV_POSIX_TEST_HELPER_H_"
      },
      {
        "sha": "839ae56a1a49c1b4d60562eca2707d2053ab1236",
        "filename": "src/leveldb/util/env_test.cc",
        "status": "modified",
        "additions": 10,
        "deletions": 8,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/util/env_test.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/util/env_test.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_test.cc?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -10,29 +10,31 @@\n namespace leveldb {\n \n static const int kDelayMicros = 100000;\n+static const int kReadOnlyFileLimit = 4;\n+static const int kMMapLimit = 4;\n \n-class EnvPosixTest {\n+class EnvTest {\n  private:\n   port::Mutex mu_;\n   std::string events_;\n \n  public:\n   Env* env_;\n-  EnvPosixTest() : env_(Env::Default()) { }\n+  EnvTest() : env_(Env::Default()) { }\n };\n \n static void SetBool(void* ptr) {\n   reinterpret_cast<port::AtomicPointer*>(ptr)->NoBarrier_Store(ptr);\n }\n \n-TEST(EnvPosixTest, RunImmediately) {\n+TEST(EnvTest, RunImmediately) {\n   port::AtomicPointer called (NULL);\n   env_->Schedule(&SetBool, &called);\n-  Env::Default()->SleepForMicroseconds(kDelayMicros);\n+  env_->SleepForMicroseconds(kDelayMicros);\n   ASSERT_TRUE(called.NoBarrier_Load() != NULL);\n }\n \n-TEST(EnvPosixTest, RunMany) {\n+TEST(EnvTest, RunMany) {\n   port::AtomicPointer last_id (NULL);\n \n   struct CB {\n@@ -59,7 +61,7 @@ TEST(EnvPosixTest, RunMany) {\n   env_->Schedule(&CB::Run, &cb3);\n   env_->Schedule(&CB::Run, &cb4);\n \n-  Env::Default()->SleepForMicroseconds(kDelayMicros);\n+  env_->SleepForMicroseconds(kDelayMicros);\n   void* cur = last_id.Acquire_Load();\n   ASSERT_EQ(4, reinterpret_cast<uintptr_t>(cur));\n }\n@@ -78,7 +80,7 @@ static void ThreadBody(void* arg) {\n   s->mu.Unlock();\n }\n \n-TEST(EnvPosixTest, StartThread) {\n+TEST(EnvTest, StartThread) {\n   State state;\n   state.val = 0;\n   state.num_running = 3;\n@@ -92,7 +94,7 @@ TEST(EnvPosixTest, StartThread) {\n     if (num == 0) {\n       break;\n     }\n-    Env::Default()->SleepForMicroseconds(kDelayMicros);\n+    env_->SleepForMicroseconds(kDelayMicros);\n   }\n   ASSERT_EQ(state.val, 3);\n }"
      },
      {
        "sha": "d32c4e676c3fcd6dd29394298f541832032ef1a7",
        "filename": "src/leveldb/util/env_win.cc",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/util/env_win.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/util/env_win.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/env_win.cc?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -1,7 +1,7 @@\n // This file contains source that originates from:\n // http://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/env_win32.h\n // http://code.google.com/p/leveldbwin/source/browse/trunk/win32_impl_src/port_win32.cc\n-// Those files dont' have any explict license headers but the \n+// Those files don't have any explicit license headers but the \n // project (http://code.google.com/p/leveldbwin/) lists the 'New BSD License'\n // as the license.\n #if defined(LEVELDB_PLATFORM_WINDOWS)\n@@ -355,11 +355,13 @@ BOOL Win32SequentialFile::_Init()\n \tToWidePath(_filename, path);\n \t_hFile = CreateFileW(path.c_str(),\n                          GENERIC_READ,\n-                         FILE_SHARE_READ,\n+                         FILE_SHARE_READ | FILE_SHARE_WRITE,\n                          NULL,\n                          OPEN_EXISTING,\n-                         FILE_ATTRIBUTE_NORMAL,\n+                         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_SEQUENTIAL_SCAN,\n                          NULL);\n+    if (_hFile == INVALID_HANDLE_VALUE)\n+        _hFile = NULL;\n     return _hFile ? TRUE : FALSE;\n }\n \n@@ -403,7 +405,7 @@ BOOL Win32RandomAccessFile::_Init( LPCWSTR path )\n {\n     BOOL bRet = FALSE;\n     if(!_hFile)\n-        _hFile = ::CreateFileW(path,GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,\n+        _hFile = ::CreateFileW(path,GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,\n         FILE_ATTRIBUTE_NORMAL | FILE_FLAG_RANDOM_ACCESS,NULL);\n     if(!_hFile || _hFile == INVALID_HANDLE_VALUE )\n         _hFile = NULL;\n@@ -669,7 +671,7 @@ Status Win32Env::GetFileSize( const std::string& fname, uint64_t* file_size )\n \tToWidePath(ModifyPath(path), wpath);\n \n     HANDLE file = ::CreateFileW(wpath.c_str(),\n-        GENERIC_READ,FILE_SHARE_READ,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n+        GENERIC_READ,FILE_SHARE_READ|FILE_SHARE_WRITE,NULL,OPEN_EXISTING,FILE_ATTRIBUTE_NORMAL,NULL);\n     LARGE_INTEGER li;\n     if(::GetFileSizeEx(file,&li)){\n         *file_size = (uint64_t)li.QuadPart;"
      },
      {
        "sha": "b5e622761357cfa3efb72d01facfd33339d4ce8e",
        "filename": "src/leveldb/util/options.cc",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/util/options.cc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/leveldb/util/options.cc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldb/util/options.cc?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -21,6 +21,7 @@ Options::Options()\n       block_cache(NULL),\n       block_size(4096),\n       block_restart_interval(16),\n+      max_file_size(2<<20),\n       compression(kSnappyCompression),\n       reuse_logs(false),\n       filter_policy(NULL) {"
      },
      {
        "sha": "93fd6a0eb5b30c1e73cccb2fe4e0644be2f455af",
        "filename": "src/memusage.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/memusage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/memusage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/memusage.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -15,7 +15,6 @@\n #include <unordered_map>\n #include <unordered_set>\n \n-#include <boost/foreach.hpp>\n \n namespace memusage\n {"
      },
      {
        "sha": "f0abea0611b9314c2e150bc8382bdd08172e786f",
        "filename": "src/merkleblock.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/merkleblock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/merkleblock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -59,6 +59,9 @@ CMerkleBlock::CMerkleBlock(const CBlock& block, const std::set<uint256>& txids)\n }\n \n uint256 CPartialMerkleTree::CalcHash(int height, unsigned int pos, const std::vector<uint256> &vTxid) {\n+    //we can never have zero txs in a merkle block, we always need the coinbase tx\n+    //if we do not have this assert, we can hit a memory access violation when indexing into vTxid\n+    assert(vTxid.size() != 0);\n     if (height == 0) {\n         // hash at height 0 is the txids themself\n         return vTxid[pos];\n@@ -153,7 +156,7 @@ uint256 CPartialMerkleTree::ExtractMatches(std::vector<uint256> &vMatch, std::ve\n     if (nTransactions == 0)\n         return uint256();\n     // check for excessively high numbers of transactions\n-    if (nTransactions > MAX_BLOCK_BASE_SIZE / 60) // 60 is the lower bound for the size of a serialized CTransaction\n+    if (nTransactions > MAX_BLOCK_WEIGHT / MIN_TRANSACTION_WEIGHT)\n         return uint256();\n     // there can never be more hashes provided than one for every txid\n     if (vHash.size() > nTransactions)"
      },
      {
        "sha": "f590c487dee0f70d668cf725ffa38560b80a6827",
        "filename": "src/merkleblock.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/merkleblock.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/merkleblock.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/merkleblock.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -121,6 +121,8 @@ class CPartialMerkleTree\n /**\n  * Used to relay blocks as header + vector<merkle branch>\n  * to filtered nodes.\n+ *\n+ * NOTE: The class assumes that the given CBlock has *at least* 1 transaction. If the CBlock has 0 txs, it will hit an assertion.\n  */\n class CMerkleBlock\n {"
      },
      {
        "sha": "79016bfd3eef4e13297f52749432c3955e5cbe52",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -242,7 +242,7 @@ bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost\n bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package)\n {\n     uint64_t nPotentialBlockSize = nBlockSize; // only used with fNeedSizeAccounting\n-    BOOST_FOREACH (const CTxMemPool::txiter it, package) {\n+    for (const CTxMemPool::txiter it : package) {\n         if (!IsFinalTx(it->GetTx(), nHeight, nLockTimeCutoff))\n             return false;\n         if (!fIncludeWitness && it->GetTx().HasWitness())\n@@ -284,11 +284,11 @@ int BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& already\n         indexed_modified_transaction_set &mapModifiedTx)\n {\n     int nDescendantsUpdated = 0;\n-    BOOST_FOREACH(const CTxMemPool::txiter it, alreadyAdded) {\n+    for (const CTxMemPool::txiter it : alreadyAdded) {\n         CTxMemPool::setEntries descendants;\n         mempool.CalculateDescendants(it, descendants);\n         // Insert all descendants (not yet in block) into the modified set\n-        BOOST_FOREACH(CTxMemPool::txiter desc, descendants) {\n+        for (CTxMemPool::txiter desc : descendants) {\n             if (alreadyAdded.count(desc))\n                 continue;\n             ++nDescendantsUpdated;"
      },
      {
        "sha": "5c9cfd78f0444a0a661a4ee7ef78a6910c39d3d5",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -16,9 +16,7 @@\n \n class CBlockIndex;\n class CChainParams;\n-class CReserveKey;\n class CScript;\n-class CWallet;\n \n namespace Consensus { struct Params; };\n "
      },
      {
        "sha": "5bf3af7ea3755cb423d7ad37cd13b3b0de3cc09d",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 113,
        "deletions": 80,
        "changes": 193,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -64,6 +64,14 @@\n #endif\n #endif\n \n+/** Used to pass flags to the Bind() function */\n+enum BindFlags {\n+    BF_NONE         = 0,\n+    BF_EXPLICIT     = (1U << 0),\n+    BF_REPORT_ERROR = (1U << 1),\n+    BF_WHITELIST    = (1U << 2),\n+};\n+\n const static std::string NET_MESSAGE_COMMAND_OTHER = \"*other*\";\n \n static const uint64_t RANDOMIZER_ID_NETGROUP = 0x6c0edd8036ef4036ULL; // SHA256(\"netgroup\")[0:8]\n@@ -240,7 +248,7 @@ bool RemoveLocal(const CService& addr)\n /** Make a particular network entirely off-limits (no automatic connects to it) */\n void SetLimited(enum Network net, bool fLimited)\n {\n-    if (net == NET_UNROUTABLE)\n+    if (net == NET_UNROUTABLE || net == NET_INTERNAL)\n         return;\n     LOCK(cs_mapLocalHost);\n     vfLimited[net] = fLimited;\n@@ -295,7 +303,7 @@ bool IsReachable(const CNetAddr& addr)\n CNode* CConnman::FindNode(const CNetAddr& ip)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+    for (CNode* pnode : vNodes)\n         if ((CNetAddr)pnode->addr == ip)\n             return (pnode);\n     return NULL;\n@@ -304,7 +312,7 @@ CNode* CConnman::FindNode(const CNetAddr& ip)\n CNode* CConnman::FindNode(const CSubNet& subNet)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+    for (CNode* pnode : vNodes)\n     if (subNet.Match((CNetAddr)pnode->addr))\n         return (pnode);\n     return NULL;\n@@ -313,7 +321,7 @@ CNode* CConnman::FindNode(const CSubNet& subNet)\n CNode* CConnman::FindNode(const std::string& addrName)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes) {\n+    for (CNode* pnode : vNodes) {\n         if (pnode->GetAddrName() == addrName) {\n             return (pnode);\n         }\n@@ -324,7 +332,7 @@ CNode* CConnman::FindNode(const std::string& addrName)\n CNode* CConnman::FindNode(const CService& addr)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+    for (CNode* pnode : vNodes)\n         if ((CService)pnode->addr == addr)\n             return (pnode);\n     return NULL;\n@@ -333,7 +341,7 @@ CNode* CConnman::FindNode(const CService& addr)\n bool CConnman::CheckIncomingNonce(uint64_t nonce)\n {\n     LOCK(cs_vNodes);\n-    BOOST_FOREACH(CNode* pnode, vNodes) {\n+    for (CNode* pnode : vNodes) {\n         if (!pnode->fSuccessfullyConnected && !pnode->fInbound && pnode->GetLocalNonce() == nonce)\n             return false;\n     }\n@@ -469,35 +477,31 @@ void CConnman::ClearBanned()\n \n bool CConnman::IsBanned(CNetAddr ip)\n {\n-    bool fResult = false;\n+    LOCK(cs_setBanned);\n+    for (banmap_t::iterator it = setBanned.begin(); it != setBanned.end(); it++)\n     {\n-        LOCK(cs_setBanned);\n-        for (banmap_t::iterator it = setBanned.begin(); it != setBanned.end(); it++)\n-        {\n-            CSubNet subNet = (*it).first;\n-            CBanEntry banEntry = (*it).second;\n+        CSubNet subNet = (*it).first;\n+        CBanEntry banEntry = (*it).second;\n \n-            if(subNet.Match(ip) && GetTime() < banEntry.nBanUntil)\n-                fResult = true;\n+        if (subNet.Match(ip) && GetTime() < banEntry.nBanUntil) {\n+            return true;\n         }\n     }\n-    return fResult;\n+    return false;\n }\n \n bool CConnman::IsBanned(CSubNet subnet)\n {\n-    bool fResult = false;\n+    LOCK(cs_setBanned);\n+    banmap_t::iterator i = setBanned.find(subnet);\n+    if (i != setBanned.end())\n     {\n-        LOCK(cs_setBanned);\n-        banmap_t::iterator i = setBanned.find(subnet);\n-        if (i != setBanned.end())\n-        {\n-            CBanEntry banEntry = (*i).second;\n-            if (GetTime() < banEntry.nBanUntil)\n-                fResult = true;\n+        CBanEntry banEntry = (*i).second;\n+        if (GetTime() < banEntry.nBanUntil) {\n+            return true;\n         }\n     }\n-    return fResult;\n+    return false;\n }\n \n void CConnman::Ban(const CNetAddr& addr, const BanReason &banReason, int64_t bantimeoffset, bool sinceUnixEpoch) {\n@@ -528,7 +532,7 @@ void CConnman::Ban(const CSubNet& subNet, const BanReason &banReason, int64_t ba\n         clientInterface->BannedListChanged();\n     {\n         LOCK(cs_vNodes);\n-        BOOST_FOREACH(CNode* pnode, vNodes) {\n+        for (CNode* pnode : vNodes) {\n             if (subNet.Match((CNetAddr)pnode->addr))\n                 pnode->fDisconnect = true;\n         }\n@@ -605,20 +609,13 @@ void CConnman::SetBannedSetDirty(bool dirty)\n \n \n bool CConnman::IsWhitelistedRange(const CNetAddr &addr) {\n-    LOCK(cs_vWhitelistedRange);\n-    BOOST_FOREACH(const CSubNet& subnet, vWhitelistedRange) {\n+    for (const CSubNet& subnet : vWhitelistedRange) {\n         if (subnet.Match(addr))\n             return true;\n     }\n     return false;\n }\n \n-void CConnman::AddWhitelistedRange(const CSubNet &subnet) {\n-    LOCK(cs_vWhitelistedRange);\n-    vWhitelistedRange.push_back(subnet);\n-}\n-\n-\n std::string CNode::GetAddrName() const {\n     LOCK(cs_addrName);\n     return addrName;\n@@ -959,7 +956,7 @@ bool CConnman::AttemptToEvictConnection()\n     {\n         LOCK(cs_vNodes);\n \n-        BOOST_FOREACH(CNode *node, vNodes) {\n+        for (CNode *node : vNodes) {\n             if (node->fWhitelisted)\n                 continue;\n             if (!node->fInbound)\n@@ -1019,7 +1016,7 @@ bool CConnman::AttemptToEvictConnection()\n     unsigned int nMostConnections = 0;\n     int64_t nMostConnectionsTime = 0;\n     std::map<uint64_t, std::vector<NodeEvictionCandidate> > mapNetGroupNodes;\n-    BOOST_FOREACH(const NodeEvictionCandidate &node, vEvictionCandidates) {\n+    for (const NodeEvictionCandidate &node : vEvictionCandidates) {\n         mapNetGroupNodes[node.nKeyedNetGroup].push_back(node);\n         int64_t grouptime = mapNetGroupNodes[node.nKeyedNetGroup][0].nTimeConnected;\n         size_t groupsize = mapNetGroupNodes[node.nKeyedNetGroup].size();\n@@ -1063,7 +1060,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     bool whitelisted = hListenSocket.whitelisted || IsWhitelistedRange(addr);\n     {\n         LOCK(cs_vNodes);\n-        BOOST_FOREACH(CNode* pnode, vNodes)\n+        for (CNode* pnode : vNodes)\n             if (pnode->fInbound)\n                 nInbound++;\n     }\n@@ -1139,7 +1136,7 @@ void CConnman::ThreadSocketHandler()\n             LOCK(cs_vNodes);\n             // Disconnect unused nodes\n             std::vector<CNode*> vNodesCopy = vNodes;\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+            for (CNode* pnode : vNodesCopy)\n             {\n                 if (pnode->fDisconnect)\n                 {\n@@ -1161,7 +1158,7 @@ void CConnman::ThreadSocketHandler()\n         {\n             // Delete disconnected nodes\n             std::list<CNode*> vNodesDisconnectedCopy = vNodesDisconnected;\n-            BOOST_FOREACH(CNode* pnode, vNodesDisconnectedCopy)\n+            for (CNode* pnode : vNodesDisconnectedCopy)\n             {\n                 // wait until threads are done using it\n                 if (pnode->GetRefCount() <= 0) {\n@@ -1209,15 +1206,15 @@ void CConnman::ThreadSocketHandler()\n         SOCKET hSocketMax = 0;\n         bool have_fds = false;\n \n-        BOOST_FOREACH(const ListenSocket& hListenSocket, vhListenSocket) {\n+        for (const ListenSocket& hListenSocket : vhListenSocket) {\n             FD_SET(hListenSocket.socket, &fdsetRecv);\n             hSocketMax = std::max(hSocketMax, hListenSocket.socket);\n             have_fds = true;\n         }\n \n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodes)\n+            for (CNode* pnode : vNodes)\n             {\n                 // Implement the following logic:\n                 // * If there is data to send, select() for sending data. As this only\n@@ -1278,7 +1275,7 @@ void CConnman::ThreadSocketHandler()\n         //\n         // Accept new connections\n         //\n-        BOOST_FOREACH(const ListenSocket& hListenSocket, vhListenSocket)\n+        for (const ListenSocket& hListenSocket : vhListenSocket)\n         {\n             if (hListenSocket.socket != INVALID_SOCKET && FD_ISSET(hListenSocket.socket, &fdsetRecv))\n             {\n@@ -1293,10 +1290,10 @@ void CConnman::ThreadSocketHandler()\n         {\n             LOCK(cs_vNodes);\n             vNodesCopy = vNodes;\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+            for (CNode* pnode : vNodesCopy)\n                 pnode->AddRef();\n         }\n-        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+        for (CNode* pnode : vNodesCopy)\n         {\n             if (interruptNet)\n                 return;\n@@ -1417,7 +1414,7 @@ void CConnman::ThreadSocketHandler()\n         }\n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+            for (CNode* pnode : vNodesCopy)\n                 pnode->Release();\n         }\n     }\n@@ -1598,7 +1595,7 @@ void CConnman::ThreadDNSAddressSeed()\n \n     LogPrintf(\"Loading addresses from DNS seeds (could take a while)\\n\");\n \n-    BOOST_FOREACH(const CDNSSeedData &seed, vSeeds) {\n+    for (const CDNSSeedData &seed : vSeeds) {\n         if (interruptNet) {\n             return;\n         }\n@@ -1608,28 +1605,22 @@ void CConnman::ThreadDNSAddressSeed()\n             std::vector<CNetAddr> vIPs;\n             std::vector<CAddress> vAdd;\n             ServiceFlags requiredServiceBits = nRelevantServices;\n-            if (LookupHost(GetDNSHost(seed, &requiredServiceBits).c_str(), vIPs, 0, true))\n+            std::string host = GetDNSHost(seed, &requiredServiceBits);\n+            CNetAddr resolveSource;\n+            if (!resolveSource.SetInternal(host)) {\n+                continue;\n+            }\n+            if (LookupHost(host.c_str(), vIPs, 0, true))\n             {\n-                BOOST_FOREACH(const CNetAddr& ip, vIPs)\n+                for (const CNetAddr& ip : vIPs)\n                 {\n                     int nOneDay = 24*3600;\n                     CAddress addr = CAddress(CService(ip, Params().GetDefaultPort()), requiredServiceBits);\n                     addr.nTime = GetTime() - 3*nOneDay - GetRand(4*nOneDay); // use a random age between 3 and 7 days old\n                     vAdd.push_back(addr);\n                     found++;\n                 }\n-            }\n-            if (interruptNet) {\n-                return;\n-            }\n-            // TODO: The seed name resolve may fail, yielding an IP of [::], which results in\n-            // addrman assigning the same source to results from different seeds.\n-            // This should switch to a hard-coded stable dummy IP for each seed name, so that the\n-            // resolve is not required at all.\n-            if (!vIPs.empty()) {\n-                CService seedSource;\n-                Lookup(seed.name.c_str(), seedSource, 0, true);\n-                addrman.Add(vAdd, seedSource);\n+                addrman.Add(vAdd, resolveSource);\n             }\n         }\n     }\n@@ -1686,12 +1677,12 @@ void CConnman::ProcessOneShot()\n void CConnman::ThreadOpenConnections()\n {\n     // Connect to specific addresses\n-    if (gArgs.IsArgSet(\"-connect\") && gArgs.GetArgs(\"-connect\").size() > 0)\n+    if (gArgs.IsArgSet(\"-connect\"))\n     {\n         for (int64_t nLoop = 0;; nLoop++)\n         {\n             ProcessOneShot();\n-            BOOST_FOREACH(const std::string& strAddr, gArgs.GetArgs(\"-connect\"))\n+            for (const std::string& strAddr : gArgs.GetArgs(\"-connect\"))\n             {\n                 CAddress addr(CService(), NODE_NONE);\n                 OpenNetworkConnection(addr, false, NULL, strAddr.c_str());\n@@ -1728,7 +1719,7 @@ void CConnman::ThreadOpenConnections()\n             if (!done) {\n                 LogPrintf(\"Adding fixed seed nodes as DNS doesn't seem to be available.\\n\");\n                 CNetAddr local;\n-                LookupHost(\"127.0.0.1\", local, false);\n+                local.SetInternal(\"fixedseeds\");\n                 addrman.Add(convertSeed6(Params().FixedSeeds()), local);\n                 done = true;\n             }\n@@ -1746,7 +1737,7 @@ void CConnman::ThreadOpenConnections()\n         std::set<std::vector<unsigned char> > setConnected;\n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodes) {\n+            for (CNode* pnode : vNodes) {\n                 if (!pnode->fInbound && !pnode->fAddnode) {\n \n                     // Count the peers that have all relevant services\n@@ -1863,7 +1854,7 @@ std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo()\n     {\n         LOCK(cs_vAddedNodes);\n         ret.reserve(vAddedNodes.size());\n-        BOOST_FOREACH(const std::string& strAddNode, vAddedNodes)\n+        for (const std::string& strAddNode : vAddedNodes)\n             lAddresses.push_back(strAddNode);\n     }\n \n@@ -1884,7 +1875,7 @@ std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo()\n         }\n     }\n \n-    BOOST_FOREACH(const std::string& strAddNode, lAddresses) {\n+    for (const std::string& strAddNode : lAddresses) {\n         CService service(LookupNumeric(strAddNode.c_str(), Params().GetDefaultPort()));\n         if (service.IsValid()) {\n             // strAddNode is an IP:port\n@@ -1912,8 +1903,7 @@ void CConnman::ThreadOpenAddedConnections()\n {\n     {\n         LOCK(cs_vAddedNodes);\n-        if (gArgs.IsArgSet(\"-addnode\"))\n-            vAddedNodes = gArgs.GetArgs(\"-addnode\");\n+        vAddedNodes = gArgs.GetArgs(\"-addnode\");\n     }\n \n     while (true)\n@@ -1993,14 +1983,14 @@ void CConnman::ThreadMessageHandler()\n         {\n             LOCK(cs_vNodes);\n             vNodesCopy = vNodes;\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy) {\n+            for (CNode* pnode : vNodesCopy) {\n                 pnode->AddRef();\n             }\n         }\n \n         bool fMoreWork = false;\n \n-        BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+        for (CNode* pnode : vNodesCopy)\n         {\n             if (pnode->fDisconnect)\n                 continue;\n@@ -2022,7 +2012,7 @@ void CConnman::ThreadMessageHandler()\n \n         {\n             LOCK(cs_vNodes);\n-            BOOST_FOREACH(CNode* pnode, vNodesCopy)\n+            for (CNode* pnode : vNodesCopy)\n                 pnode->Release();\n         }\n \n@@ -2150,7 +2140,7 @@ void Discover(boost::thread_group& threadGroup)\n         std::vector<CNetAddr> vaddr;\n         if (LookupHost(pszHostName, vaddr, 0, true))\n         {\n-            BOOST_FOREACH (const CNetAddr &addr, vaddr)\n+            for (const CNetAddr &addr : vaddr)\n             {\n                 if (AddLocal(addr, LOCAL_IF))\n                     LogPrintf(\"%s: %s - %s\\n\", __func__, pszHostName, addr.ToString());\n@@ -2197,7 +2187,7 @@ void CConnman::SetNetworkActive(bool active)\n \n         LOCK(cs_vNodes);\n         // Close sockets to all nodes\n-        BOOST_FOREACH(CNode* pnode, vNodes) {\n+        for (CNode* pnode : vNodes) {\n             pnode->CloseSocketDisconnect();\n         }\n     } else {\n@@ -2230,7 +2220,38 @@ NodeId CConnman::GetNewNodeId()\n     return nLastNodeId.fetch_add(1, std::memory_order_relaxed);\n }\n \n-bool CConnman::Start(CScheduler& scheduler, std::string& strNodeError, Options connOptions)\n+\n+bool CConnman::Bind(const CService &addr, unsigned int flags) {\n+    if (!(flags & BF_EXPLICIT) && IsLimited(addr))\n+        return false;\n+    std::string strError;\n+    if (!BindListenPort(addr, strError, (flags & BF_WHITELIST) != 0)) {\n+        if ((flags & BF_REPORT_ERROR) && clientInterface) {\n+            clientInterface->ThreadSafeMessageBox(strError, \"\", CClientUIInterface::MSG_ERROR);\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n+\n+bool CConnman::InitBinds(const std::vector<CService>& binds, const std::vector<CService>& whiteBinds) {\n+    bool fBound = false;\n+    for (const auto& addrBind : binds) {\n+        fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR));\n+    }\n+    for (const auto& addrBind : whiteBinds) {\n+        fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR | BF_WHITELIST));\n+    }\n+    if (binds.empty() && whiteBinds.empty()) {\n+        struct in_addr inaddr_any;\n+        inaddr_any.s_addr = INADDR_ANY;\n+        fBound |= Bind(CService(in6addr_any, GetListenPort()), BF_NONE);\n+        fBound |= Bind(CService(inaddr_any, GetListenPort()), !fBound ? BF_REPORT_ERROR : BF_NONE);\n+    }\n+    return fBound;\n+}\n+\n+bool CConnman::Start(CScheduler& scheduler, Options connOptions)\n {\n     nTotalBytesRecv = 0;\n     nTotalBytesSent = 0;\n@@ -2252,11 +2273,23 @@ bool CConnman::Start(CScheduler& scheduler, std::string& strNodeError, Options c\n \n     SetBestHeight(connOptions.nBestHeight);\n \n+    clientInterface = connOptions.uiInterface;\n+\n+    if (fListen && !InitBinds(connOptions.vBinds, connOptions.vWhiteBinds)) {\n+        if (clientInterface) {\n+            clientInterface->ThreadSafeMessageBox(\n+                _(\"Failed to listen on any port. Use -listen=0 if you want this.\"),\n+                \"\", CClientUIInterface::MSG_ERROR);\n+        }\n+        return false;\n+    }\n+\n+    vWhitelistedRange = connOptions.vWhitelistedRange;\n+\n     for (const auto& strDest : connOptions.vSeedNodes) {\n         AddOneShot(strDest);\n     }\n \n-    clientInterface = connOptions.uiInterface;\n     if (clientInterface) {\n         clientInterface->InitMessage(_(\"Loading P2P addresses...\"));\n     }\n@@ -2399,18 +2432,18 @@ void CConnman::Stop()\n     }\n \n     // Close sockets\n-    BOOST_FOREACH(CNode* pnode, vNodes)\n+    for (CNode* pnode : vNodes)\n         pnode->CloseSocketDisconnect();\n-    BOOST_FOREACH(ListenSocket& hListenSocket, vhListenSocket)\n+    for (ListenSocket& hListenSocket : vhListenSocket)\n         if (hListenSocket.socket != INVALID_SOCKET)\n             if (!CloseSocket(hListenSocket.socket))\n                 LogPrintf(\"CloseSocket(hListenSocket) failed with error %s\\n\", NetworkErrorString(WSAGetLastError()));\n \n     // clean up some globals (to help leak detection)\n-    BOOST_FOREACH(CNode *pnode, vNodes) {\n+    for (CNode *pnode : vNodes) {\n         DeleteNode(pnode);\n     }\n-    BOOST_FOREACH(CNode *pnode, vNodesDisconnected) {\n+    for (CNode *pnode : vNodesDisconnected) {\n         DeleteNode(pnode);\n     }\n     vNodes.clear();\n@@ -2722,7 +2755,7 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n     fPauseSend = false;\n     nProcessQueueSize = 0;\n \n-    BOOST_FOREACH(const std::string &msg, getAllNetMessageTypes())\n+    for (const std::string &msg : getAllNetMessageTypes())\n         mapRecvBytesPerMsgCmd[msg] = 0;\n     mapRecvBytesPerMsgCmd[NET_MESSAGE_COMMAND_OTHER] = 0;\n \n@@ -2843,5 +2876,5 @@ uint64_t CConnman::CalculateKeyedNetGroup(const CAddress& ad) const\n {\n     std::vector<unsigned char> vchNetGroup(ad.GetGroup());\n \n-    return GetDeterministicRandomizer(RANDOMIZER_ID_NETGROUP).Write(&vchNetGroup[0], vchNetGroup.size()).Finalize();\n+    return GetDeterministicRandomizer(RANDOMIZER_ID_NETGROUP).Write(vchNetGroup.data(), vchNetGroup.size()).Finalize();\n }"
      },
      {
        "sha": "b9a11c62f2123f63eaae4e03ed25e21cb113347d",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 6,
        "deletions": 7,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -33,7 +33,6 @@\n #include <arpa/inet.h>\n #endif\n \n-#include <boost/foreach.hpp>\n #include <boost/signals2/signal.hpp>\n \n class CScheduler;\n@@ -101,7 +100,6 @@ struct AddedNodeInfo\n     bool fInbound;\n };\n \n-class CTransaction;\n class CNodeStats;\n class CClientUIInterface;\n \n@@ -145,13 +143,14 @@ class CConnman\n         uint64_t nMaxOutboundTimeframe = 0;\n         uint64_t nMaxOutboundLimit = 0;\n         std::vector<std::string> vSeedNodes;\n+        std::vector<CSubNet> vWhitelistedRange;\n+        std::vector<CService> vBinds, vWhiteBinds;\n     };\n     CConnman(uint64_t seed0, uint64_t seed1);\n     ~CConnman();\n-    bool Start(CScheduler& scheduler, std::string& strNodeError, Options options);\n+    bool Start(CScheduler& scheduler, Options options);\n     void Stop();\n     void Interrupt();\n-    bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n     bool GetNetworkActive() const { return fNetworkActive; };\n     void SetNetworkActive(bool active);\n     bool OpenNetworkConnection(const CAddress& addrConnect, bool fCountFailure, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false, bool fFeeler = false, bool fAddnode = false);\n@@ -245,8 +244,6 @@ class CConnman\n \n     unsigned int GetSendBufferSize() const;\n \n-    void AddWhitelistedRange(const CSubNet &subnet);\n-\n     ServiceFlags GetLocalServices() const;\n \n     //!set the max outbound target in bytes\n@@ -290,6 +287,9 @@ class CConnman\n         ListenSocket(SOCKET socket_, bool whitelisted_) : socket(socket_), whitelisted(whitelisted_) {}\n     };\n \n+    bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n+    bool Bind(const CService &addr, unsigned int flags);\n+    bool InitBinds(const std::vector<CService>& binds, const std::vector<CService>& whiteBinds);\n     void ThreadOpenAddedConnections();\n     void AddOneShot(const std::string& strDest);\n     void ProcessOneShot();\n@@ -347,7 +347,6 @@ class CConnman\n     // Whitelisted ranges. Any node connecting from these is automatically\n     // whitelisted (as well as those connecting to whitelisted binds).\n     std::vector<CSubNet> vWhitelistedRange;\n-    CCriticalSection cs_vWhitelistedRange;\n \n     unsigned int nSendBufferMaxSize;\n     unsigned int nReceiveFloodSize;"
      },
      {
        "sha": "a743f04dd155f5ddc7eb7801d5ba2d01c8ac4cdc",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 43,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -22,6 +22,7 @@\n #include \"primitives/block.h\"\n #include \"primitives/transaction.h\"\n #include \"random.h\"\n+#include \"reverse_iterator.h\"\n #include \"tinyformat.h\"\n #include \"txmempool.h\"\n #include \"ui_interface.h\"\n@@ -30,8 +31,6 @@\n #include \"utilstrencodings.h\"\n #include \"validationinterface.h\"\n \n-#include <boost/thread.hpp>\n-\n #if defined(NDEBUG)\n # error \"Bitcoin cannot be compiled without assertions.\"\n #endif\n@@ -122,7 +121,7 @@ namespace {\n     MapRelay mapRelay;\n     /** Expiration-time ordered list of (expire time, relay map entry) pairs, protected by cs_main). */\n     std::deque<std::pair<int64_t, MapRelay::iterator>> vRelayExpiration;\n-} // anon namespace\n+} // namespace\n \n //////////////////////////////////////////////////////////////////////////////\n //\n@@ -290,7 +289,7 @@ void FinalizeNode(NodeId nodeid, bool& fUpdateConnectionTime) {\n         fUpdateConnectionTime = true;\n     }\n \n-    BOOST_FOREACH(const QueuedBlock& entry, state->vBlocksInFlight) {\n+    for (const QueuedBlock& entry : state->vBlocksInFlight) {\n         mapBlocksInFlight.erase(entry.hash);\n     }\n     EraseOrphansFor(nodeid);\n@@ -344,7 +343,9 @@ bool MarkBlockAsInFlight(NodeId nodeid, const uint256& hash, const CBlockIndex*\n     // Short-circuit most stuff in case its from the same node\n     std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator itInFlight = mapBlocksInFlight.find(hash);\n     if (itInFlight != mapBlocksInFlight.end() && itInFlight->second.first == nodeid) {\n-        *pit = &itInFlight->second.second;\n+        if (pit) {\n+            *pit = &itInFlight->second.second;\n+        }\n         return false;\n     }\n \n@@ -452,25 +453,6 @@ bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex)\n     return false;\n }\n \n-/** Find the last common ancestor two blocks have.\n- *  Both pa and pb must be non-NULL. */\n-const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb) {\n-    if (pa->nHeight > pb->nHeight) {\n-        pa = pa->GetAncestor(pb->nHeight);\n-    } else if (pb->nHeight > pa->nHeight) {\n-        pb = pb->GetAncestor(pa->nHeight);\n-    }\n-\n-    while (pa != pb && pa && pb) {\n-        pa = pa->pprev;\n-        pb = pb->pprev;\n-    }\n-\n-    // Eventually all chain branches meet at the genesis block.\n-    assert(pa == pb);\n-    return pa;\n-}\n-\n /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n  *  at most count entries. */\n void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) {\n@@ -525,7 +507,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n         // are not yet downloaded and not in flight to vBlocks. In the mean time, update\n         // pindexLastCommonBlock as long as all ancestors are already downloaded, or if it's\n         // already part of our chain (and therefore don't need it even if pruned).\n-        BOOST_FOREACH(const CBlockIndex* pindex, vToFetch) {\n+        for (const CBlockIndex* pindex : vToFetch) {\n             if (!pindex->IsValid(BLOCK_VALID_TREE)) {\n                 // We consider the chain that this peer is on invalid.\n                 return;\n@@ -559,7 +541,7 @@ void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<con\n     }\n }\n \n-} // anon namespace\n+} // namespace\n \n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     LOCK(cs_main);\n@@ -569,7 +551,7 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     stats.nMisbehavior = state->nMisbehavior;\n     stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n     stats.nCommonHeight = state->pindexLastCommonBlock ? state->pindexLastCommonBlock->nHeight : -1;\n-    BOOST_FOREACH(const QueuedBlock& queue, state->vBlocksInFlight) {\n+    for (const QueuedBlock& queue : state->vBlocksInFlight) {\n         if (queue.pindex)\n             stats.vHeightInFlight.push_back(queue.pindex->nHeight);\n     }\n@@ -630,7 +612,7 @@ bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRE\n \n     auto ret = mapOrphanTransactions.emplace(hash, COrphanTx{tx, peer, GetTime() + ORPHAN_TX_EXPIRE_TIME});\n     assert(ret.second);\n-    BOOST_FOREACH(const CTxIn& txin, tx->vin) {\n+    for (const CTxIn& txin : tx->vin) {\n         mapOrphanTransactionsByPrev[txin.prevout].insert(ret.first);\n     }\n \n@@ -646,7 +628,7 @@ int static EraseOrphanTx(uint256 hash) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n     std::map<uint256, COrphanTx>::iterator it = mapOrphanTransactions.find(hash);\n     if (it == mapOrphanTransactions.end())\n         return 0;\n-    BOOST_FOREACH(const CTxIn& txin, it->second.tx->vin)\n+    for (const CTxIn& txin : it->second.tx->vin)\n     {\n         auto itPrev = mapOrphanTransactionsByPrev.find(txin.prevout);\n         if (itPrev == mapOrphanTransactionsByPrev.end())\n@@ -771,7 +753,7 @@ void PeerLogicValidation::BlockConnected(const std::shared_ptr<const CBlock>& pb\n     // Erase orphan transactions include or precluded by this block\n     if (vOrphanErase.size()) {\n         int nErased = 0;\n-        BOOST_FOREACH(uint256 &orphanHash, vOrphanErase) {\n+        for (uint256 &orphanHash : vOrphanErase) {\n             nErased += EraseOrphanTx(orphanHash);\n         }\n         LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n@@ -846,7 +828,7 @@ void PeerLogicValidation::UpdatedBlockTip(const CBlockIndex *pindexNew, const CB\n         // Relay inventory, but don't relay old inventory during initial block download.\n         connman->ForEachNode([nNewHeight, &vHashes](CNode* pnode) {\n             if (nNewHeight > (pnode->nStartingHeight != -1 ? pnode->nStartingHeight - 2000 : 0)) {\n-                BOOST_REVERSE_FOREACH(const uint256& hash, vHashes) {\n+                for (const uint256& hash : reverse_iterate(vHashes)) {\n                     pnode->PushBlockHash(hash);\n                 }\n             }\n@@ -1081,7 +1063,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                             // Thus, the protocol spec specified allows for us to provide duplicate txn here,\n                             // however we MUST always provide at least what the remote peer needs\n                             typedef std::pair<unsigned int, uint256> PairType;\n-                            BOOST_FOREACH(PairType& pair, merkleBlock.vMatchedTxn)\n+                            for (PairType& pair : merkleBlock.vMatchedTxn)\n                                 connman.PushMessage(pfrom, msgMaker.Make(SERIALIZE_TRANSACTION_NO_WITNESS, NetMsgType::TX, *pblock->vtx[pair.first]));\n                         }\n                         // else\n@@ -1476,7 +1458,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         std::vector<CAddress> vAddrOk;\n         int64_t nNow = GetAdjustedTime();\n         int64_t nSince = nNow - 10 * 60;\n-        BOOST_FOREACH(CAddress& addr, vAddr)\n+        for (CAddress& addr : vAddr)\n         {\n             if (interruptMsgProc)\n                 return true;\n@@ -1886,21 +1868,21 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 }\n             }\n \n-            BOOST_FOREACH(uint256 hash, vEraseQueue)\n+            for (uint256 hash : vEraseQueue)\n                 EraseOrphanTx(hash);\n         }\n         else if (fMissingInputs)\n         {\n             bool fRejectedParents = false; // It may be the case that the orphans parents have all been rejected\n-            BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+            for (const CTxIn& txin : tx.vin) {\n                 if (recentRejects->contains(txin.prevout.hash)) {\n                     fRejectedParents = true;\n                     break;\n                 }\n             }\n             if (!fRejectedParents) {\n                 uint32_t nFetchFlags = GetFetchFlags(pfrom);\n-                BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+                for (const CTxIn& txin : tx.vin) {\n                     CInv _inv(MSG_TX | nFetchFlags, txin.prevout.hash);\n                     pfrom->AddInventoryKnown(_inv);\n                     if (!AlreadyHave(_inv)) pfrom->AskFor(_inv);\n@@ -2357,7 +2339,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             } else {\n                 std::vector<CInv> vGetData;\n                 // Download as much as possible, from earliest to latest.\n-                BOOST_REVERSE_FOREACH(const CBlockIndex *pindex, vToFetch) {\n+                for (const CBlockIndex *pindex : reverse_iterate(vToFetch)) {\n                     if (nodestate->nBlocksInFlight >= MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n                         // Can't download any more from this peer\n                         break;\n@@ -2436,7 +2418,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         pfrom->vAddrToSend.clear();\n         std::vector<CAddress> vAddr = connman.GetAddresses();\n         FastRandomContext insecure_rand;\n-        BOOST_FOREACH(const CAddress &addr, vAddr)\n+        for (const CAddress &addr : vAddr)\n             pfrom->PushAddress(addr, insecure_rand);\n     }\n \n@@ -2630,7 +2612,7 @@ static bool SendRejectsAndCheckIfBanned(CNode* pnode, CConnman& connman)\n     AssertLockHeld(cs_main);\n     CNodeState &state = *State(pnode->GetId());\n \n-    BOOST_FOREACH(const CBlockReject& reject, state.rejects) {\n+    for (const CBlockReject& reject : state.rejects) {\n         connman.PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, (std::string)NetMsgType::BLOCK, reject.chRejectCode, reject.strRejectReason, reject.hashBlock));\n     }\n     state.rejects.clear();\n@@ -2854,7 +2836,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             pto->nNextAddrSend = PoissonNextSend(nNow, AVG_ADDRESS_BROADCAST_INTERVAL);\n             std::vector<CAddress> vAddr;\n             vAddr.reserve(pto->vAddrToSend.size());\n-            BOOST_FOREACH(const CAddress& addr, pto->vAddrToSend)\n+            for (const CAddress& addr : pto->vAddrToSend)\n             {\n                 if (!pto->addrKnown.contains(addr.GetKey()))\n                 {\n@@ -2933,7 +2915,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                 // Try to find first header that our peer doesn't have, and\n                 // then send all headers past that one.  If we come across any\n                 // headers that aren't on chainActive, give up.\n-                BOOST_FOREACH(const uint256 &hash, pto->vBlockHashesToAnnounce) {\n+                for (const uint256 &hash : pto->vBlockHashesToAnnounce) {\n                     BlockMap::iterator mi = mapBlockIndex.find(hash);\n                     assert(mi != mapBlockIndex.end());\n                     const CBlockIndex *pindex = mi->second;\n@@ -3059,7 +3041,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             vInv.reserve(std::max<size_t>(pto->vInventoryBlockToSend.size(), INVENTORY_BROADCAST_MAX));\n \n             // Add blocks\n-            BOOST_FOREACH(const uint256& hash, pto->vInventoryBlockToSend) {\n+            for (const uint256& hash : pto->vInventoryBlockToSend) {\n                 vInv.push_back(CInv(MSG_BLOCK, hash));\n                 if (vInv.size() == MAX_INV_SZ) {\n                     connman.PushMessage(pto, msgMaker.Make(NetMsgType::INV, vInv));\n@@ -3250,7 +3232,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n             FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n-            BOOST_FOREACH(const CBlockIndex *pindex, vToDownload) {\n+            for (const CBlockIndex *pindex : vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n                 MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);"
      },
      {
        "sha": "110e778fbd81766dac4fb71cfb5a62d9c1c57a04",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 42,
        "deletions": 8,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -15,6 +15,9 @@\n static const unsigned char pchIPv4[12] = { 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0xff, 0xff };\n static const unsigned char pchOnionCat[] = {0xFD,0x87,0xD8,0x7E,0xEB,0x43};\n \n+// 0xFD + sha256(\"bitcoin\")[0:5]\n+static const unsigned char g_internal_prefix[] = { 0xFD, 0x6B, 0x88, 0xC0, 0x87, 0x24 };\n+\n void CNetAddr::Init()\n {\n     memset(ip, 0, sizeof(ip));\n@@ -42,6 +45,18 @@ void CNetAddr::SetRaw(Network network, const uint8_t *ip_in)\n     }\n }\n \n+bool CNetAddr::SetInternal(const std::string &name)\n+{\n+    if (name.empty()) {\n+        return false;\n+    }\n+    unsigned char hash[32] = {};\n+    CSHA256().Write((const unsigned char*)name.data(), name.size()).Finalize(hash);\n+    memcpy(ip, g_internal_prefix, sizeof(g_internal_prefix));\n+    memcpy(ip + sizeof(g_internal_prefix), hash, sizeof(ip) - sizeof(g_internal_prefix));\n+    return true;\n+}\n+\n bool CNetAddr::SetSpecial(const std::string &strName)\n {\n     if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n@@ -84,7 +99,7 @@ bool CNetAddr::IsIPv4() const\n \n bool CNetAddr::IsIPv6() const\n {\n-    return (!IsIPv4() && !IsTor());\n+    return (!IsIPv4() && !IsTor() && !IsInternal());\n }\n \n bool CNetAddr::IsRFC1918() const\n@@ -199,6 +214,9 @@ bool CNetAddr::IsValid() const\n     if (IsRFC3849())\n         return false;\n \n+    if (IsInternal())\n+        return false;\n+\n     if (IsIPv4())\n     {\n         // INADDR_NONE\n@@ -217,11 +235,19 @@ bool CNetAddr::IsValid() const\n \n bool CNetAddr::IsRoutable() const\n {\n-    return IsValid() && !(IsRFC1918() || IsRFC2544() || IsRFC3927() || IsRFC4862() || IsRFC6598() || IsRFC5737() || (IsRFC4193() && !IsTor()) || IsRFC4843() || IsLocal());\n+    return IsValid() && !(IsRFC1918() || IsRFC2544() || IsRFC3927() || IsRFC4862() || IsRFC6598() || IsRFC5737() || (IsRFC4193() && !IsTor()) || IsRFC4843() || IsLocal() || IsInternal());\n+}\n+\n+bool CNetAddr::IsInternal() const\n+{\n+   return memcmp(ip, g_internal_prefix, sizeof(g_internal_prefix)) == 0;\n }\n \n enum Network CNetAddr::GetNetwork() const\n {\n+    if (IsInternal())\n+        return NET_INTERNAL;\n+\n     if (!IsRoutable())\n         return NET_UNROUTABLE;\n \n@@ -238,6 +264,8 @@ std::string CNetAddr::ToStringIP() const\n {\n     if (IsTor())\n         return EncodeBase32(&ip[6], 10) + \".onion\";\n+    if (IsInternal())\n+        return EncodeBase32(ip + sizeof(g_internal_prefix), sizeof(ip) - sizeof(g_internal_prefix)) + \".internal\";\n     CService serv(*this, 0);\n     struct sockaddr_storage sockaddr;\n     socklen_t socklen = sizeof(sockaddr);\n@@ -305,9 +333,15 @@ std::vector<unsigned char> CNetAddr::GetGroup() const\n         nClass = 255;\n         nBits = 0;\n     }\n-\n-    // all unroutable addresses belong to the same group\n-    if (!IsRoutable())\n+    // all internal-usage addresses get their own group\n+    if (IsInternal())\n+    {\n+        nClass = NET_INTERNAL;\n+        nStartByte = sizeof(g_internal_prefix);\n+        nBits = (sizeof(ip) - sizeof(g_internal_prefix)) * 8;\n+    }\n+    // all other unroutable addresses belong to the same group\n+    else if (!IsRoutable())\n     {\n         nClass = NET_UNROUTABLE;\n         nBits = 0;\n@@ -393,7 +427,7 @@ int CNetAddr::GetReachabilityFrom(const CNetAddr *paddrPartner) const\n         REACH_PRIVATE\n     };\n \n-    if (!IsRoutable())\n+    if (!IsRoutable() || IsInternal())\n         return REACH_UNREACHABLE;\n \n     int ourNet = GetExtNetwork(this);\n@@ -539,7 +573,7 @@ std::vector<unsigned char> CService::GetKey() const\n {\n      std::vector<unsigned char> vKey;\n      vKey.resize(18);\n-     memcpy(&vKey[0], ip, 16);\n+     memcpy(vKey.data(), ip, 16);\n      vKey[16] = port / 0x100;\n      vKey[17] = port & 0x0FF;\n      return vKey;\n@@ -552,7 +586,7 @@ std::string CService::ToStringPort() const\n \n std::string CService::ToStringIPPort() const\n {\n-    if (IsIPv4() || IsTor()) {\n+    if (IsIPv4() || IsTor() || IsInternal()) {\n         return ToStringIP() + \":\" + ToStringPort();\n     } else {\n         return \"[\" + ToStringIP() + \"]:\" + ToStringPort();"
      },
      {
        "sha": "80716600d17f004e765561b142fa9aeada2f3971",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -22,6 +22,7 @@ enum Network\n     NET_IPV4,\n     NET_IPV6,\n     NET_TOR,\n+    NET_INTERNAL,\n \n     NET_MAX,\n };\n@@ -45,6 +46,12 @@ class CNetAddr\n          */\n         void SetRaw(Network network, const uint8_t *data);\n \n+        /**\n+          * Transform an arbitrary string into a non-routable ipv6 address.\n+          * Useful for mapping resolved addresses back to their source.\n+         */\n+        bool SetInternal(const std::string& name);\n+\n         bool SetSpecial(const std::string &strName); // for Tor addresses\n         bool IsIPv4() const;    // IPv4 mapped address (::FFFF:0:0/96, 0.0.0.0/0)\n         bool IsIPv6() const;    // IPv6 address (not mapped IPv4, not Tor)\n@@ -64,6 +71,7 @@ class CNetAddr\n         bool IsTor() const;\n         bool IsLocal() const;\n         bool IsRoutable() const;\n+        bool IsInternal() const;\n         bool IsValid() const;\n         enum Network GetNetwork() const;\n         std::string ToString() const;"
      },
      {
        "sha": "1f668a5d4c9ac28b82c79b35e8cec84491ce9923",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 22,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -58,25 +58,6 @@ std::string GetNetworkName(enum Network net) {\n     }\n }\n \n-void SplitHostPort(std::string in, int &portOut, std::string &hostOut) {\n-    size_t colon = in.find_last_of(':');\n-    // if a : is found, and it either follows a [...], or no other : is in the string, treat it as port separator\n-    bool fHaveColon = colon != in.npos;\n-    bool fBracketed = fHaveColon && (in[0]=='[' && in[colon-1]==']'); // if there is a colon, and in[0]=='[', colon is not 0, so in[colon-1] is safe\n-    bool fMultiColon = fHaveColon && (in.find_last_of(':',colon-1) != in.npos);\n-    if (fHaveColon && (colon==0 || fBracketed || !fMultiColon)) {\n-        int32_t n;\n-        if (ParseInt32(in.substr(colon + 1), &n) && n > 0 && n < 0x10000) {\n-            in = in.substr(0, colon);\n-            portOut = n;\n-        }\n-    }\n-    if (in.size()>0 && in[0] == '[' && in[in.size()-1] == ']')\n-        hostOut = in.substr(1, in.size()-2);\n-    else\n-        hostOut = in;\n-}\n-\n bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions, bool fAllowLookup)\n {\n     vIP.clear();\n@@ -108,17 +89,22 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n     struct addrinfo *aiTrav = aiRes;\n     while (aiTrav != NULL && (nMaxSolutions == 0 || vIP.size() < nMaxSolutions))\n     {\n+        CNetAddr resolved;\n         if (aiTrav->ai_family == AF_INET)\n         {\n             assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in));\n-            vIP.push_back(CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr));\n+            resolved = CNetAddr(((struct sockaddr_in*)(aiTrav->ai_addr))->sin_addr);\n         }\n \n         if (aiTrav->ai_family == AF_INET6)\n         {\n             assert(aiTrav->ai_addrlen >= sizeof(sockaddr_in6));\n             struct sockaddr_in6* s6 = (struct sockaddr_in6*) aiTrav->ai_addr;\n-            vIP.push_back(CNetAddr(s6->sin6_addr, s6->sin6_scope_id));\n+            resolved = CNetAddr(s6->sin6_addr, s6->sin6_scope_id);\n+        }\n+        /* Never allow resolving to an internal address. Consider any such result invalid */\n+        if (!resolved.IsInternal()) {\n+            vIP.push_back(resolved);\n         }\n \n         aiTrav = aiTrav->ai_next;\n@@ -558,7 +544,7 @@ static bool ConnectThroughProxy(const proxyType &proxy, const std::string& strDe\n     // do socks negotiation\n     if (proxy.randomize_credentials) {\n         ProxyCredentials random_auth;\n-        static std::atomic_int counter;\n+        static std::atomic_int counter(0);\n         random_auth.username = random_auth.password = strprintf(\"%i\", counter++);\n         if (!Socks5(strDest, (unsigned short)port, &random_auth, hSocket))\n             return false;"
      },
      {
        "sha": "fd4b34c8f1e6e987fdbec98850d8f11fe4729a91",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -39,7 +39,6 @@ class proxyType\n \n enum Network ParseNetwork(std::string net);\n std::string GetNetworkName(enum Network net);\n-void SplitHostPort(std::string in, int &portOut, std::string &hostOut);\n bool SetProxy(enum Network net, const proxyType &addrProxy);\n bool GetProxy(enum Network net, proxyType &proxyInfoOut);\n bool IsProxy(const CNetAddr &addr);"
      },
      {
        "sha": "565da6c1541e9d8edec25109f31dee25cc35ed0a",
        "filename": "src/policy/feerate.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/policy/feerate.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/policy/feerate.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/feerate.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -40,6 +40,7 @@ class CFeeRate\n     friend bool operator==(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK == b.nSatoshisPerK; }\n     friend bool operator<=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK <= b.nSatoshisPerK; }\n     friend bool operator>=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK >= b.nSatoshisPerK; }\n+    friend bool operator!=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK != b.nSatoshisPerK; }\n     CFeeRate& operator+=(const CFeeRate& a) { nSatoshisPerK += a.nSatoshisPerK; return *this; }\n     std::string ToString() const;\n "
      },
      {
        "sha": "b9476407cf163cc9d882930f02ed5a889a2a6870",
        "filename": "src/policy/fees.cpp",
        "status": "modified",
        "additions": 149,
        "deletions": 68,
        "changes": 217,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -16,6 +16,53 @@\n \n static constexpr double INF_FEERATE = 1e99;\n \n+std::string StringForFeeEstimateHorizon(FeeEstimateHorizon horizon) {\n+    static const std::map<FeeEstimateHorizon, std::string> horizon_strings = {\n+        {FeeEstimateHorizon::SHORT_HALFLIFE, \"short\"},\n+        {FeeEstimateHorizon::MED_HALFLIFE, \"medium\"},\n+        {FeeEstimateHorizon::LONG_HALFLIFE, \"long\"},\n+    };\n+    auto horizon_string = horizon_strings.find(horizon);\n+\n+    if (horizon_string == horizon_strings.end()) return \"unknown\";\n+\n+    return horizon_string->second;\n+}\n+\n+std::string StringForFeeReason(FeeReason reason) {\n+    static const std::map<FeeReason, std::string> fee_reason_strings = {\n+        {FeeReason::NONE, \"None\"},\n+        {FeeReason::HALF_ESTIMATE, \"Half Target 60% Threshold\"},\n+        {FeeReason::FULL_ESTIMATE, \"Target 85% Threshold\"},\n+        {FeeReason::DOUBLE_ESTIMATE, \"Double Target 95% Threshold\"},\n+        {FeeReason::CONSERVATIVE, \"Conservative Double Target longer horizon\"},\n+        {FeeReason::MEMPOOL_MIN, \"Mempool Min Fee\"},\n+        {FeeReason::PAYTXFEE, \"PayTxFee set\"},\n+        {FeeReason::FALLBACK, \"Fallback fee\"},\n+        {FeeReason::REQUIRED, \"Minimum Required Fee\"},\n+        {FeeReason::MAXTXFEE, \"MaxTxFee limit\"}\n+    };\n+    auto reason_string = fee_reason_strings.find(reason);\n+\n+    if (reason_string == fee_reason_strings.end()) return \"Unknown\";\n+\n+    return reason_string->second;\n+}\n+\n+bool FeeModeFromString(const std::string& mode_string, FeeEstimateMode& fee_estimate_mode) {\n+    static const std::map<std::string, FeeEstimateMode> fee_modes = {\n+        {\"UNSET\", FeeEstimateMode::UNSET},\n+        {\"ECONOMICAL\", FeeEstimateMode::ECONOMICAL},\n+        {\"CONSERVATIVE\", FeeEstimateMode::CONSERVATIVE},\n+    };\n+    auto mode = fee_modes.find(mode_string);\n+\n+    if (mode == fee_modes.end()) return false;\n+\n+    fee_estimate_mode = mode->second;\n+    return true;\n+}\n+\n /**\n  * We will instantiate an instance of this class to track transactions that were\n  * included in a block. We will lump transactions into a bucket according to their\n@@ -70,7 +117,7 @@ class TxConfirmStats\n      * Create new TxConfirmStats. This is called by BlockPolicyEstimator's\n      * constructor with default values.\n      * @param defaultBuckets contains the upper limits for the bucket boundaries\n-     * @param maxConfirms max number of confirms to track\n+     * @param maxPeriods max number of periods to track\n      * @param decay how much to decay the historical moving average per block\n      */\n     TxConfirmStats(const std::vector<double>& defaultBuckets, const std::map<double, unsigned int>& defaultBucketMap,\n@@ -651,7 +698,7 @@ CFeeRate CBlockPolicyEstimator::estimateRawFee(int confTarget, double successThr\n         break;\n     }\n     default: {\n-        return CFeeRate(0);\n+        throw std::out_of_range(\"CBlockPolicyEstimator::estimateRawFee unknown FeeEstimateHorizon\");\n     }\n     }\n \n@@ -670,6 +717,24 @@ CFeeRate CBlockPolicyEstimator::estimateRawFee(int confTarget, double successThr\n     return CFeeRate(median);\n }\n \n+unsigned int CBlockPolicyEstimator::HighestTargetTracked(FeeEstimateHorizon horizon) const\n+{\n+    switch (horizon) {\n+    case FeeEstimateHorizon::SHORT_HALFLIFE: {\n+        return shortStats->GetMaxConfirms();\n+    }\n+    case FeeEstimateHorizon::MED_HALFLIFE: {\n+        return feeStats->GetMaxConfirms();\n+    }\n+    case FeeEstimateHorizon::LONG_HALFLIFE: {\n+        return longStats->GetMaxConfirms();\n+    }\n+    default: {\n+        throw std::out_of_range(\"CBlockPolicyEstimator::HighestTargetTracked unknown FeeEstimateHorizon\");\n+    }\n+    }\n+}\n+\n unsigned int CBlockPolicyEstimator::BlockSpan() const\n {\n     if (firstRecordedHeight == 0) return 0;\n@@ -698,31 +763,36 @@ unsigned int CBlockPolicyEstimator::MaxUsableEstimate() const\n  * time horizon which tracks confirmations up to the desired target.  If\n  * checkShorterHorizon is requested, also allow short time horizon estimates\n  * for a lower target to reduce the given answer */\n-double CBlockPolicyEstimator::estimateCombinedFee(unsigned int confTarget, double successThreshold, bool checkShorterHorizon) const\n+double CBlockPolicyEstimator::estimateCombinedFee(unsigned int confTarget, double successThreshold, bool checkShorterHorizon, EstimationResult *result) const\n {\n     double estimate = -1;\n     if (confTarget >= 1 && confTarget <= longStats->GetMaxConfirms()) {\n         // Find estimate from shortest time horizon possible\n         if (confTarget <= shortStats->GetMaxConfirms()) { // short horizon\n-            estimate = shortStats->EstimateMedianVal(confTarget, SUFFICIENT_TXS_SHORT, successThreshold, true, nBestSeenHeight);\n+            estimate = shortStats->EstimateMedianVal(confTarget, SUFFICIENT_TXS_SHORT, successThreshold, true, nBestSeenHeight, result);\n         }\n         else if (confTarget <= feeStats->GetMaxConfirms()) { // medium horizon\n-            estimate = feeStats->EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, successThreshold, true, nBestSeenHeight);\n+            estimate = feeStats->EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, successThreshold, true, nBestSeenHeight, result);\n         }\n         else { // long horizon\n-            estimate = longStats->EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, successThreshold, true, nBestSeenHeight);\n+            estimate = longStats->EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, successThreshold, true, nBestSeenHeight, result);\n         }\n         if (checkShorterHorizon) {\n+            EstimationResult tempResult;\n             // If a lower confTarget from a more recent horizon returns a lower answer use it.\n             if (confTarget > feeStats->GetMaxConfirms()) {\n-                double medMax = feeStats->EstimateMedianVal(feeStats->GetMaxConfirms(), SUFFICIENT_FEETXS, successThreshold, true, nBestSeenHeight);\n-                if (medMax > 0 && (estimate == -1 || medMax < estimate))\n+                double medMax = feeStats->EstimateMedianVal(feeStats->GetMaxConfirms(), SUFFICIENT_FEETXS, successThreshold, true, nBestSeenHeight, &tempResult);\n+                if (medMax > 0 && (estimate == -1 || medMax < estimate)) {\n                     estimate = medMax;\n+                    if (result) *result = tempResult;\n+                }\n             }\n             if (confTarget > shortStats->GetMaxConfirms()) {\n-                double shortMax = shortStats->EstimateMedianVal(shortStats->GetMaxConfirms(), SUFFICIENT_TXS_SHORT, successThreshold, true, nBestSeenHeight);\n-                if (shortMax > 0 && (estimate == -1 || shortMax < estimate))\n+                double shortMax = shortStats->EstimateMedianVal(shortStats->GetMaxConfirms(), SUFFICIENT_TXS_SHORT, successThreshold, true, nBestSeenHeight, &tempResult);\n+                if (shortMax > 0 && (estimate == -1 || shortMax < estimate)) {\n                     estimate = shortMax;\n+                    if (result) *result = tempResult;\n+                }\n             }\n         }\n     }\n@@ -732,16 +802,18 @@ double CBlockPolicyEstimator::estimateCombinedFee(unsigned int confTarget, doubl\n /** Ensure that for a conservative estimate, the DOUBLE_SUCCESS_PCT is also met\n  * at 2 * target for any longer time horizons.\n  */\n-double CBlockPolicyEstimator::estimateConservativeFee(unsigned int doubleTarget) const\n+double CBlockPolicyEstimator::estimateConservativeFee(unsigned int doubleTarget, EstimationResult *result) const\n {\n     double estimate = -1;\n+    EstimationResult tempResult;\n     if (doubleTarget <= shortStats->GetMaxConfirms()) {\n-        estimate = feeStats->EstimateMedianVal(doubleTarget, SUFFICIENT_FEETXS, DOUBLE_SUCCESS_PCT, true, nBestSeenHeight);\n+        estimate = feeStats->EstimateMedianVal(doubleTarget, SUFFICIENT_FEETXS, DOUBLE_SUCCESS_PCT, true, nBestSeenHeight, result);\n     }\n     if (doubleTarget <= feeStats->GetMaxConfirms()) {\n-        double longEstimate = longStats->EstimateMedianVal(doubleTarget, SUFFICIENT_FEETXS, DOUBLE_SUCCESS_PCT, true, nBestSeenHeight);\n+        double longEstimate = longStats->EstimateMedianVal(doubleTarget, SUFFICIENT_FEETXS, DOUBLE_SUCCESS_PCT, true, nBestSeenHeight, &tempResult);\n         if (longEstimate > estimate) {\n             estimate = longEstimate;\n+            if (result) *result = tempResult;\n         }\n     }\n     return estimate;\n@@ -754,72 +826,80 @@ double CBlockPolicyEstimator::estimateConservativeFee(unsigned int doubleTarget)\n  * estimates, however, required the 95% threshold at 2 * target be met for any\n  * longer time horizons also.\n  */\n-CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool, bool conservative) const\n+CFeeRate CBlockPolicyEstimator::estimateSmartFee(int confTarget, FeeCalculation *feeCalc, bool conservative) const\n {\n-    if (answerFoundAtTarget)\n-        *answerFoundAtTarget = confTarget;\n-\n-    double median = -1;\n-    {\n-        LOCK(cs_feeEstimator);\n+    LOCK(cs_feeEstimator);\n \n-        // Return failure if trying to analyze a target we're not tracking\n-        if (confTarget <= 0 || (unsigned int)confTarget > longStats->GetMaxConfirms())\n-            return CFeeRate(0);\n+    if (feeCalc) {\n+        feeCalc->desiredTarget = confTarget;\n+        feeCalc->returnedTarget = confTarget;\n+    }\n \n-        // It's not possible to get reasonable estimates for confTarget of 1\n-        if (confTarget == 1)\n-            confTarget = 2;\n+    double median = -1;\n+    EstimationResult tempResult;\n \n-        unsigned int maxUsableEstimate = MaxUsableEstimate();\n-        if (maxUsableEstimate <= 1)\n-            return CFeeRate(0);\n+    // Return failure if trying to analyze a target we're not tracking\n+    if (confTarget <= 0 || (unsigned int)confTarget > longStats->GetMaxConfirms()) {\n+        return CFeeRate(0);  // error condition\n+    }\n \n-        if ((unsigned int)confTarget > maxUsableEstimate) {\n-            confTarget = maxUsableEstimate;\n-        }\n+    // It's not possible to get reasonable estimates for confTarget of 1\n+    if (confTarget == 1) confTarget = 2;\n \n-        assert(confTarget > 0); //estimateCombinedFee and estimateConservativeFee take unsigned ints\n-\n-        /** true is passed to estimateCombined fee for target/2 and target so\n-         * that we check the max confirms for shorter time horizons as well.\n-         * This is necessary to preserve monotonically increasing estimates.\n-         * For non-conservative estimates we do the same thing for 2*target, but\n-         * for conservative estimates we want to skip these shorter horizons\n-         * checks for 2*target because we are taking the max over all time\n-         * horizons so we already have monotonically increasing estimates and\n-         * the purpose of conservative estimates is not to let short term\n-         * fluctuations lower our estimates by too much.\n-         */\n-        double halfEst = estimateCombinedFee(confTarget/2, HALF_SUCCESS_PCT, true);\n-        double actualEst = estimateCombinedFee(confTarget, SUCCESS_PCT, true);\n-        double doubleEst = estimateCombinedFee(2 * confTarget, DOUBLE_SUCCESS_PCT, !conservative);\n-        median = halfEst;\n-        if (actualEst > median) {\n-            median = actualEst;\n+    unsigned int maxUsableEstimate = MaxUsableEstimate();\n+    if ((unsigned int)confTarget > maxUsableEstimate) {\n+        confTarget = maxUsableEstimate;\n+    }\n+    if (feeCalc) feeCalc->returnedTarget = confTarget;\n+\n+    if (confTarget <= 1) return CFeeRate(0); // error condition\n+\n+    assert(confTarget > 0); //estimateCombinedFee and estimateConservativeFee take unsigned ints\n+    /** true is passed to estimateCombined fee for target/2 and target so\n+     * that we check the max confirms for shorter time horizons as well.\n+     * This is necessary to preserve monotonically increasing estimates.\n+     * For non-conservative estimates we do the same thing for 2*target, but\n+     * for conservative estimates we want to skip these shorter horizons\n+     * checks for 2*target because we are taking the max over all time\n+     * horizons so we already have monotonically increasing estimates and\n+     * the purpose of conservative estimates is not to let short term\n+     * fluctuations lower our estimates by too much.\n+     */\n+    double halfEst = estimateCombinedFee(confTarget/2, HALF_SUCCESS_PCT, true, &tempResult);\n+    if (feeCalc) {\n+        feeCalc->est = tempResult;\n+        feeCalc->reason = FeeReason::HALF_ESTIMATE;\n+    }\n+    median = halfEst;\n+    double actualEst = estimateCombinedFee(confTarget, SUCCESS_PCT, true, &tempResult);\n+    if (actualEst > median) {\n+        median = actualEst;\n+        if (feeCalc) {\n+            feeCalc->est = tempResult;\n+            feeCalc->reason = FeeReason::FULL_ESTIMATE;\n         }\n-        if (doubleEst > median) {\n-            median = doubleEst;\n+    }\n+    double doubleEst = estimateCombinedFee(2 * confTarget, DOUBLE_SUCCESS_PCT, !conservative, &tempResult);\n+    if (doubleEst > median) {\n+        median = doubleEst;\n+        if (feeCalc) {\n+            feeCalc->est = tempResult;\n+            feeCalc->reason = FeeReason::DOUBLE_ESTIMATE;\n         }\n+    }\n \n-        if (conservative || median == -1) {\n-            double consEst =  estimateConservativeFee(2 * confTarget);\n-            if (consEst > median) {\n-                median = consEst;\n+    if (conservative || median == -1) {\n+        double consEst =  estimateConservativeFee(2 * confTarget, &tempResult);\n+        if (consEst > median) {\n+            median = consEst;\n+            if (feeCalc) {\n+                feeCalc->est = tempResult;\n+                feeCalc->reason = FeeReason::CONSERVATIVE;\n             }\n         }\n-    } // Must unlock cs_feeEstimator before taking mempool locks\n-\n-    if (answerFoundAtTarget)\n-        *answerFoundAtTarget = confTarget;\n-\n-    // If mempool is limiting txs , return at least the min feerate from the mempool\n-    CAmount minPoolFee = pool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFeePerK();\n-    if (minPoolFee > 0 && minPoolFee > median)\n-        return CFeeRate(minPoolFee);\n+    }\n \n-    if (median < 0)\n-        return CFeeRate(0);\n+    if (median < 0) return CFeeRate(0); // error condition\n \n     return CFeeRate(median);\n }\n@@ -855,13 +935,13 @@ bool CBlockPolicyEstimator::Read(CAutoFile& filein)\n     try {\n         LOCK(cs_feeEstimator);\n         int nVersionRequired, nVersionThatWrote;\n-        unsigned int nFileBestSeenHeight, nFileHistoricalFirst, nFileHistoricalBest;\n         filein >> nVersionRequired >> nVersionThatWrote;\n         if (nVersionRequired > CLIENT_VERSION)\n             return error(\"CBlockPolicyEstimator::Read(): up-version (%d) fee estimate file\", nVersionRequired);\n \n         // Read fee estimates file into temporary variables so existing data\n         // structures aren't corrupted if there is an exception.\n+        unsigned int nFileBestSeenHeight;\n         filein >> nFileBestSeenHeight;\n \n         if (nVersionThatWrote < 149900) {\n@@ -890,6 +970,7 @@ bool CBlockPolicyEstimator::Read(CAutoFile& filein)\n             }\n         }\n         else { // nVersionThatWrote >= 149900\n+            unsigned int nFileHistoricalFirst, nFileHistoricalBest;\n             filein >> nFileHistoricalFirst >> nFileHistoricalBest;\n             if (nFileHistoricalFirst > nFileHistoricalBest || nFileHistoricalBest > nFileBestSeenHeight) {\n                 throw std::runtime_error(\"Corrupt estimates file. Historical block range for estimates is invalid\");"
      },
      {
        "sha": "f4ef793643076ca22ac8fb726b1717f31304c094",
        "filename": "src/policy/fees.h",
        "status": "modified",
        "additions": 44,
        "deletions": 6,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -48,7 +48,7 @@ class TxConfirmStats;\n  * in each bucket and the total amount of feerate paid in each bucket. Then we\n  * calculate how many blocks Y it took each transaction to be mined.  We convert\n  * from a number of blocks to a number of periods Y' each encompassing \"scale\"\n- * blocks.  This is is tracked in 3 different data sets each up to a maximum\n+ * blocks.  This is tracked in 3 different data sets each up to a maximum\n  * number of periods. Within each data set we have an array of counters in each\n  * feerate bucket and we increment all the counters from Y' up to max periods\n  * representing that a tx was successfully confirmed in less than or equal to\n@@ -74,6 +74,33 @@ enum FeeEstimateHorizon {\n     LONG_HALFLIFE = 2\n };\n \n+std::string StringForFeeEstimateHorizon(FeeEstimateHorizon horizon);\n+\n+/* Enumeration of reason for returned fee estimate */\n+enum class FeeReason {\n+    NONE,\n+    HALF_ESTIMATE,\n+    FULL_ESTIMATE,\n+    DOUBLE_ESTIMATE,\n+    CONSERVATIVE,\n+    MEMPOOL_MIN,\n+    PAYTXFEE,\n+    FALLBACK,\n+    REQUIRED,\n+    MAXTXFEE,\n+};\n+\n+std::string StringForFeeReason(FeeReason reason);\n+\n+/* Used to determine type of fee estimation requested */\n+enum class FeeEstimateMode {\n+    UNSET,        //! Use default settings based on other criteria\n+    ECONOMICAL,   //! Force estimateSmartFee to use non-conservative estimates\n+    CONSERVATIVE, //! Force estimateSmartFee to use conservative estimates\n+};\n+\n+bool FeeModeFromString(const std::string& mode_string, FeeEstimateMode& fee_estimate_mode);\n+\n /* Used to return detailed information about a feerate bucket */\n struct EstimatorBucket\n {\n@@ -90,8 +117,16 @@ struct EstimationResult\n {\n     EstimatorBucket pass;\n     EstimatorBucket fail;\n-    double decay;\n-    unsigned int scale;\n+    double decay = 0;\n+    unsigned int scale = 0;\n+};\n+\n+struct FeeCalculation\n+{\n+    EstimationResult est;\n+    FeeReason reason = FeeReason::NONE;\n+    int desiredTarget = 0;\n+    int returnedTarget = 0;\n };\n \n /**\n@@ -173,7 +208,7 @@ class CBlockPolicyEstimator\n      *  the closest target where one can be given.  'conservative' estimates are\n      *  valid over longer time horizons also.\n      */\n-    CFeeRate estimateSmartFee(int confTarget, int *answerFoundAtTarget, const CTxMemPool& pool, bool conservative = true) const;\n+    CFeeRate estimateSmartFee(int confTarget, FeeCalculation *feeCalc, bool conservative) const;\n \n     /** Return a specific fee estimate calculation with a given success\n      * threshold and time horizon, and optionally return detailed data about\n@@ -190,6 +225,9 @@ class CBlockPolicyEstimator\n     /** Empty mempool transactions on shutdown to record failure to confirm for txs still in mempool */\n     void FlushUnconfirmed(CTxMemPool& pool);\n \n+    /** Calculation of highest target that estimates are tracked for */\n+    unsigned int HighestTargetTracked(FeeEstimateHorizon horizon) const;\n+\n private:\n     unsigned int nBestSeenHeight;\n     unsigned int firstRecordedHeight;\n@@ -223,9 +261,9 @@ class CBlockPolicyEstimator\n     bool processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry* entry);\n \n     /** Helper for estimateSmartFee */\n-    double estimateCombinedFee(unsigned int confTarget, double successThreshold, bool checkShorterHorizon) const;\n+    double estimateCombinedFee(unsigned int confTarget, double successThreshold, bool checkShorterHorizon, EstimationResult *result) const;\n     /** Helper for estimateSmartFee */\n-    double estimateConservativeFee(unsigned int doubleTarget) const;\n+    double estimateConservativeFee(unsigned int doubleTarget, EstimationResult *result) const;\n     /** Number of blocks of data recorded while fee estimates have been running */\n     unsigned int BlockSpan() const;\n     /** Number of blocks of recorded fee estimate data represented in saved data file */"
      },
      {
        "sha": "605e3e06968eb6741a795edbbc9928c44f7bfa2a",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -7,28 +7,30 @@\n \n #include \"policy/policy.h\"\n \n+#include \"consensus/validation.h\"\n #include \"validation.h\"\n #include \"coins.h\"\n #include \"tinyformat.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n \n-#include <boost/foreach.hpp>\n \n CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)\n {\n     // \"Dust\" is defined in terms of dustRelayFee,\n     // which has units satoshis-per-kilobyte.\n-    // If you'd pay more than 1/3 in fees\n+    // If you'd pay more in fees than the value of the output\n     // to spend something, then we consider it dust.\n     // A typical spendable non-segwit txout is 34 bytes big, and will\n     // need a CTxIn of at least 148 bytes to spend:\n     // so dust is a spendable txout less than\n-    // 546*dustRelayFee/1000 (in satoshis).\n+    // 182*dustRelayFee/1000 (in satoshis).\n+    // 546 satoshis at the default rate of 3000 sat/kB.\n     // A typical spendable segwit txout is 31 bytes big, and will\n     // need a CTxIn of at least 67 bytes to spend:\n     // so dust is a spendable txout less than\n-    // 294*dustRelayFee/1000 (in satoshis).\n+    // 98*dustRelayFee/1000 (in satoshis).\n+    // 294 satoshis at the default rate of 3000 sat/kB.\n     if (txout.scriptPubKey.IsUnspendable())\n         return 0;\n \n@@ -44,7 +46,7 @@ CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)\n         nSize += (32 + 4 + 1 + 107 + 4); // the 148 mentioned above\n     }\n \n-    return 3 * dustRelayFeeIn.GetFee(nSize);\n+    return dustRelayFeeIn.GetFee(nSize);\n }\n \n bool IsDust(const CTxOut& txout, const CFeeRate& dustRelayFeeIn)\n@@ -111,7 +113,7 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnes\n         return false;\n     }\n \n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    for (const CTxIn& txin : tx.vin)\n     {\n         // Biggest 'standard' txin is a 15-of-15 P2SH multisig with compressed\n         // keys (remember the 520 byte limit on redeemScript size). That works\n@@ -132,7 +134,7 @@ bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnes\n \n     unsigned int nDataOut = 0;\n     txnouttype whichType;\n-    BOOST_FOREACH(const CTxOut& txout, tx.vout) {\n+    for (const CTxOut& txout : tx.vout) {\n         if (!::IsStandard(txout.scriptPubKey, whichType, witnessEnabled)) {\n             reason = \"scriptpubkey\";\n             return false;"
      },
      {
        "sha": "c06820f84e6d067ecf5d6fd4a869dabf79b81b68",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -40,12 +40,12 @@ static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEMS = 100;\n static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80;\n /** The maximum size of a standard witnessScript */\n static const unsigned int MAX_STANDARD_P2WSH_SCRIPT_SIZE = 3600;\n-/** Min feerate for defining dust. Historically this has been the same as the\n+/** Min feerate for defining dust. Historically this has been based on the\n  * minRelayTxFee, however changing the dust limit changes which transactions are\n  * standard and should be done with care and ideally rarely. It makes sense to\n  * only increase the dust limit after prior releases were already not creating\n  * outputs below the new threshold */\n-static const unsigned int DUST_RELAY_TX_FEE = 1000;\n+static const unsigned int DUST_RELAY_TX_FEE = 3000;\n /**\n  * Standard script verification flags that standard transactions will comply\n  * with. However scripts violating these flags may still be present in valid"
      },
      {
        "sha": "755ef83c9af11a3d01efa95216b94eb8f897a167",
        "filename": "src/policy/rbf.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/policy/rbf.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/policy/rbf.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -6,7 +6,7 @@\n \n bool SignalsOptInRBF(const CTransaction &tx)\n {\n-    BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n+    for (const CTxIn &txin : tx.vin) {\n         if (txin.nSequence < std::numeric_limits<unsigned int>::max()-1) {\n             return true;\n         }\n@@ -38,7 +38,7 @@ RBFTransactionState IsRBFOptIn(const CTransaction &tx, CTxMemPool &pool)\n     CTxMemPoolEntry entry = *pool.mapTx.find(tx.GetHash());\n     pool.CalculateMemPoolAncestors(entry, setAncestors, noLimit, noLimit, noLimit, noLimit, dummy, false);\n \n-    BOOST_FOREACH(CTxMemPool::txiter it, setAncestors) {\n+    for (CTxMemPool::txiter it : setAncestors) {\n         if (SignalsOptInRBF(it->GetTx())) {\n             return RBF_TRANSACTIONSTATE_REPLACEABLE_BIP125;\n         }"
      },
      {
        "sha": "46640d6fff8434ea5d10e12ebe69917e4a32b984",
        "filename": "src/prevector.h",
        "status": "modified",
        "additions": 8,
        "deletions": 2,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/prevector.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/prevector.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/prevector.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -132,7 +132,7 @@ class prevector {\n         typedef const T* pointer;\n         typedef const T& reference;\n         typedef std::bidirectional_iterator_tag iterator_category;\n-        const_reverse_iterator(T* ptr_) : ptr(ptr_) {}\n+        const_reverse_iterator(const T* ptr_) : ptr(ptr_) {}\n         const_reverse_iterator(reverse_iterator x) : ptr(&(*x)) {}\n         const T& operator*() const { return *ptr; }\n         const T* operator->() const { return ptr; }\n@@ -220,7 +220,7 @@ class prevector {\n         }\n     }\n \n-    prevector() : _size(0) {}\n+    prevector() : _size(0), _union{{}} {}\n \n     explicit prevector(size_type n) : _size(0) {\n         resize(n);\n@@ -387,6 +387,12 @@ class prevector {\n     }\n \n     iterator erase(iterator first, iterator last) {\n+        // Erase is not allowed to the change the object's capacity. That means\n+        // that when starting with an indirectly allocated prevector with\n+        // size and capacity > N, the result may be a still indirectly allocated\n+        // prevector with size <= N and capacity > N. A shrink_to_fit() call is\n+        // necessary to switch to the (more efficient) directly allocated\n+        // representation (with capacity N and size <= N).\n         iterator p = first;\n         char* endp = (char*)&(*end());\n         if (!std::is_trivially_destructible<T>::value) {"
      },
      {
        "sha": "24be67c84fbb2dfc17d986b21b4f70202042242f",
        "filename": "src/primitives/block.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/primitives/block.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/primitives/block.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -31,12 +31,3 @@ std::string CBlock::ToString() const\n     }\n     return s.str();\n }\n-\n-int64_t GetBlockWeight(const CBlock& block)\n-{\n-    // This implements the weight = (stripped_size * 4) + witness_size formula,\n-    // using only serialization with and without witness data. As witness_size\n-    // is equal to total_size - stripped_size, this formula is identical to:\n-    // weight = (stripped_size * 3) + total_size.\n-    return ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR - 1) + ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION);\n-}"
      },
      {
        "sha": "c90a1dfa6448631db06e522d3d0876c79a2e4977",
        "filename": "src/primitives/block.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/primitives/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/primitives/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -152,7 +152,4 @@ struct CBlockLocator\n     }\n };\n \n-/** Compute the consensus-critical block weight (see BIP 141). */\n-int64_t GetBlockWeight(const CBlock& tx);\n-\n #endif // BITCOIN_PRIMITIVES_BLOCK_H"
      },
      {
        "sha": "f87934d586881b2e3d64dd88232b6a76aa1fd9cd",
        "filename": "src/primitives/transaction.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/primitives/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/primitives/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -114,8 +114,3 @@ std::string CTransaction::ToString() const\n         str += \"    \" + vout[i].ToString() + \"\\n\";\n     return str;\n }\n-\n-int64_t GetTransactionWeight(const CTransaction& tx)\n-{\n-    return ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * (WITNESS_SCALE_FACTOR -1) + ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n-}"
      },
      {
        "sha": "041034bb8b6f78ed03c995ff8e2877639ffad659",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 3,
        "deletions": 7,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -6,15 +6,14 @@\n #ifndef BITCOIN_PRIMITIVES_TRANSACTION_H\n #define BITCOIN_PRIMITIVES_TRANSACTION_H\n \n+#include <stdint.h>\n #include \"amount.h\"\n #include \"script/script.h\"\n #include \"serialize.h\"\n #include \"uint256.h\"\n \n static const int SERIALIZE_TRANSACTION_NO_WITNESS = 0x40000000;\n \n-static const int WITNESS_SCALE_FACTOR = 4;\n-\n /** An outpoint - a combination of a transaction hash and an index n into its vout */\n class COutPoint\n {\n@@ -107,7 +106,7 @@ class CTxIn\n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action) {\n         READWRITE(prevout);\n-        READWRITE(*(CScriptBase*)(&scriptSig));\n+        READWRITE(scriptSig);\n         READWRITE(nSequence);\n     }\n \n@@ -147,7 +146,7 @@ class CTxOut\n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action) {\n         READWRITE(nValue);\n-        READWRITE(*(CScriptBase*)(&scriptPubKey));\n+        READWRITE(scriptPubKey);\n     }\n \n     void SetNull()\n@@ -411,7 +410,4 @@ typedef std::shared_ptr<const CTransaction> CTransactionRef;\n static inline CTransactionRef MakeTransactionRef() { return std::make_shared<const CTransaction>(); }\n template <typename Tx> static inline CTransactionRef MakeTransactionRef(Tx&& txIn) { return std::make_shared<const CTransaction>(std::forward<Tx>(txIn)); }\n \n-/** Compute the weight of a transaction, as defined by BIP 141 */\n-int64_t GetTransactionWeight(const CTransaction &tx);\n-\n #endif // BITCOIN_PRIMITIVES_TRANSACTION_H"
      },
      {
        "sha": "da87e40091f65088ce6fff620cb27884bbbbae22",
        "filename": "src/protocol.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/protocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/protocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -39,7 +39,7 @@ const char *SENDCMPCT=\"sendcmpct\";\n const char *CMPCTBLOCK=\"cmpctblock\";\n const char *GETBLOCKTXN=\"getblocktxn\";\n const char *BLOCKTXN=\"blocktxn\";\n-};\n+} // namespace NetMsgType\n \n /** All known message types. Keep this in the same order as the list of\n  * messages above and in protocol.h."
      },
      {
        "sha": "7890bb627de36ccb4f8b48fc657c319f194c7273",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -163,7 +163,7 @@ extern const char *PONG;\n /**\n  * The notfound message is a reply to a getdata message which requested an\n  * object the receiving node does not have available for relay.\n- * @ince protocol version 70001.\n+ * @since protocol version 70001.\n  * @see https://bitcoin.org/en/developer-reference#notfound\n  */\n extern const char *NOTFOUND;"
      },
      {
        "sha": "91af4e56f2d63e22d971134e89947b420440e9d6",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 6,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -11,7 +11,7 @@ namespace\n {\n /* Global secp256k1_context object used for verification. */\n secp256k1_context* secp256k1_context_verify = NULL;\n-}\n+} // namespace\n \n /** This function is taken from the libsecp256k1 distribution and implements\n  *  DER parsing for ECDSA signatures, while supporting an arbitrary subset of\n@@ -172,10 +172,7 @@ bool CPubKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchS\n     if (!secp256k1_ec_pubkey_parse(secp256k1_context_verify, &pubkey, &(*this)[0], size())) {\n         return false;\n     }\n-    if (vchSig.size() == 0) {\n-        return false;\n-    }\n-    if (!ecdsa_signature_parse_der_lax(secp256k1_context_verify, &sig, &vchSig[0], vchSig.size())) {\n+    if (!ecdsa_signature_parse_der_lax(secp256k1_context_verify, &sig, vchSig.data(), vchSig.size())) {\n         return false;\n     }\n     /* libsecp256k1's ECDSA verification requires lower-S signatures, which have\n@@ -274,7 +271,7 @@ bool CExtPubKey::Derive(CExtPubKey &out, unsigned int _nChild) const {\n \n /* static */ bool CPubKey::CheckLowS(const std::vector<unsigned char>& vchSig) {\n     secp256k1_ecdsa_signature sig;\n-    if (!ecdsa_signature_parse_der_lax(secp256k1_context_verify, &sig, &vchSig[0], vchSig.size())) {\n+    if (!ecdsa_signature_parse_der_lax(secp256k1_context_verify, &sig, vchSig.data(), vchSig.size())) {\n         return false;\n     }\n     return (!secp256k1_ecdsa_signature_normalize(secp256k1_context_verify, NULL, &sig));"
      },
      {
        "sha": "cebac46b952387d714df71efa27a32eeb59e2e00",
        "filename": "src/qt/addressbookpage.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/addressbookpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/addressbookpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -254,7 +254,7 @@ void AddressBookPage::done(int retval)\n     // Figure out which address was selected, and return it\n     QModelIndexList indexes = table->selectionModel()->selectedRows(AddressTableModel::Address);\n \n-    Q_FOREACH (const QModelIndex& index, indexes) {\n+    for (const QModelIndex& index : indexes) {\n         QVariant address = table->model()->data(index);\n         returnValue = address.toString();\n     }"
      },
      {
        "sha": "3c00fd0809d33a5be8d001084c595b581e874fc6",
        "filename": "src/qt/addressbookpage.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/addressbookpage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/addressbookpage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -8,7 +8,6 @@\n #include <QDialog>\n \n class AddressTableModel;\n-class OptionsModel;\n class PlatformStyle;\n \n namespace Ui {\n@@ -20,7 +19,6 @@ class QItemSelection;\n class QMenu;\n class QModelIndex;\n class QSortFilterProxyModel;\n-class QTableView;\n QT_END_NAMESPACE\n \n /** Widget that shows a list of sending or receiving addresses."
      },
      {
        "sha": "2fa032abdc44a10a08f8444b8c7d81aa1fa438e8",
        "filename": "src/qt/addresstablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/addresstablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/addresstablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -10,7 +10,6 @@\n #include \"base58.h\"\n #include \"wallet/wallet.h\"\n \n-#include <boost/foreach.hpp>\n \n #include <QFont>\n #include <QDebug>\n@@ -81,7 +80,7 @@ class AddressTablePriv\n         cachedAddressTable.clear();\n         {\n             LOCK(wallet->cs_wallet);\n-            BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& item, wallet->mapAddressBook)\n+            for (const std::pair<CTxDestination, CAddressBookData>& item : wallet->mapAddressBook)\n             {\n                 const CBitcoinAddress& address = item.first;\n                 bool fMine = IsMine(*wallet, address.Get());"
      },
      {
        "sha": "4a4116c67024cc4bf2f927b708d9f06fcad9345b",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 23,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -178,6 +178,10 @@ class BitcoinCore: public QObject\n     Q_OBJECT\n public:\n     explicit BitcoinCore();\n+    /** Basic initialization, before starting initialization/shutdown thread.\n+     * Return true on success.\n+     */\n+    static bool baseInitialize();\n \n public Q_SLOTS:\n     void initialize();\n@@ -270,26 +274,32 @@ void BitcoinCore::handleRunawayException(const std::exception *e)\n     Q_EMIT runawayException(QString::fromStdString(GetWarnings(\"gui\")));\n }\n \n+bool BitcoinCore::baseInitialize()\n+{\n+    if (!AppInitBasicSetup())\n+    {\n+        return false;\n+    }\n+    if (!AppInitParameterInteraction())\n+    {\n+        return false;\n+    }\n+    if (!AppInitSanityChecks())\n+    {\n+        return false;\n+    }\n+    if (!AppInitLockDataDirectory())\n+    {\n+        return false;\n+    }\n+    return true;\n+}\n+\n void BitcoinCore::initialize()\n {\n     try\n     {\n         qDebug() << __func__ << \": Running initialization in thread\";\n-        if (!AppInitBasicSetup())\n-        {\n-            Q_EMIT initializeResult(false);\n-            return;\n-        }\n-        if (!AppInitParameterInteraction())\n-        {\n-            Q_EMIT initializeResult(false);\n-            return;\n-        }\n-        if (!AppInitSanityChecks())\n-        {\n-            Q_EMIT initializeResult(false);\n-            return;\n-        }\n         bool rv = AppInitMain(threadGroup, scheduler);\n         Q_EMIT initializeResult(rv);\n     } catch (const std::exception& e) {\n@@ -474,9 +484,10 @@ void BitcoinApplication::initializeResult(bool success)\n         window->setClientModel(clientModel);\n \n #ifdef ENABLE_WALLET\n-        if(pwalletMain)\n+        // TODO: Expose secondary wallets\n+        if (!vpwallets.empty())\n         {\n-            walletModel = new WalletModel(platformStyle, pwalletMain, optionsModel);\n+            walletModel = new WalletModel(platformStyle, vpwallets[0], optionsModel);\n \n             window->addWallet(BitcoinGUI::DEFAULT_WALLET, walletModel);\n             window->setCurrentWallet(BitcoinGUI::DEFAULT_WALLET);\n@@ -577,6 +588,7 @@ int main(int argc, char *argv[])\n     //   Need to pass name here as CAmount is a typedef (see http://qt-project.org/doc/qt-5/qmetatype.html#qRegisterMetaType)\n     //   IMPORTANT if it is no longer a typedef use the normal variant above\n     qRegisterMetaType< CAmount >(\"CAmount\");\n+    qRegisterMetaType< std::function<void(void)> >(\"std::function<void(void)>\");\n \n     /// 3. Application identification\n     // must be set before OptionsModel is initialized or translations are loaded,\n@@ -687,23 +699,33 @@ int main(int argc, char *argv[])\n     if (GetBoolArg(\"-splash\", DEFAULT_SPLASHSCREEN) && !GetBoolArg(\"-min\", false))\n         app.createSplashScreen(networkStyle.data());\n \n+    int rv = EXIT_SUCCESS;\n     try\n     {\n         app.createWindow(networkStyle.data());\n-        app.requestInitialize();\n+        // Perform base initialization before spinning up initialization/shutdown thread\n+        // This is acceptable because this function only contains steps that are quick to execute,\n+        // so the GUI thread won't be held up.\n+        if (BitcoinCore::baseInitialize()) {\n+            app.requestInitialize();\n #if defined(Q_OS_WIN) && QT_VERSION >= 0x050000\n-        WinShutdownMonitor::registerShutdownBlockReason(QObject::tr(\"%1 didn't yet exit safely...\").arg(QObject::tr(PACKAGE_NAME)), (HWND)app.getMainWinId());\n+            WinShutdownMonitor::registerShutdownBlockReason(QObject::tr(\"%1 didn't yet exit safely...\").arg(QObject::tr(PACKAGE_NAME)), (HWND)app.getMainWinId());\n #endif\n-        app.exec();\n-        app.requestShutdown();\n-        app.exec();\n+            app.exec();\n+            app.requestShutdown();\n+            app.exec();\n+            rv = app.getReturnValue();\n+        } else {\n+            // A dialog with detailed error will have been shown by InitError()\n+            rv = EXIT_FAILURE;\n+        }\n     } catch (const std::exception& e) {\n         PrintExceptionContinue(&e, \"Runaway exception\");\n         app.handleRunawayException(QString::fromStdString(GetWarnings(\"gui\")));\n     } catch (...) {\n         PrintExceptionContinue(NULL, \"Runaway exception\");\n         app.handleRunawayException(QString::fromStdString(GetWarnings(\"gui\")));\n     }\n-    return app.getReturnValue();\n+    return rv;\n }\n #endif // BITCOIN_QT_TEST"
      },
      {
        "sha": "429c18cba85c309fe2cfe8d9268e26741f81fa33",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -1006,7 +1006,7 @@ void BitcoinGUI::dropEvent(QDropEvent *event)\n {\n     if(event->mimeData()->hasUrls())\n     {\n-        Q_FOREACH(const QUrl &uri, event->mimeData()->urls())\n+        for (const QUrl &uri : event->mimeData()->urls())\n         {\n             Q_EMIT receivedURI(uri.toString());\n         }\n@@ -1202,7 +1202,7 @@ UnitDisplayStatusBarControl::UnitDisplayStatusBarControl(const PlatformStyle *pl\n     QList<BitcoinUnits::Unit> units = BitcoinUnits::availableUnits();\n     int max_width = 0;\n     const QFontMetrics fm(font());\n-    Q_FOREACH (const BitcoinUnits::Unit unit, units)\n+    for (const BitcoinUnits::Unit unit : units)\n     {\n         max_width = qMax(max_width, fm.width(BitcoinUnits::name(unit)));\n     }\n@@ -1221,7 +1221,7 @@ void UnitDisplayStatusBarControl::mousePressEvent(QMouseEvent *event)\n void UnitDisplayStatusBarControl::createContextMenu()\n {\n     menu = new QMenu(this);\n-    Q_FOREACH(BitcoinUnits::Unit u, BitcoinUnits::availableUnits())\n+    for (BitcoinUnits::Unit u : BitcoinUnits::availableUnits())\n     {\n         QAction *menuAction = new QAction(QString(BitcoinUnits::name(u)), this);\n         menuAction->setData(QVariant(u));"
      },
      {
        "sha": "8731caafc7757f3032cd413454d44d57e7606785",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -31,8 +31,6 @@ class WalletModel;\n class HelpMessageDialog;\n class ModalOverlay;\n \n-class CWallet;\n-\n QT_BEGIN_NAMESPACE\n class QAction;\n class QProgressBar;"
      },
      {
        "sha": "b3d2cf1d55c04c54a6d58c38d9bddccd66fe3538",
        "filename": "src/qt/bitcoinstrings.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 18,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/bitcoinstrings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/bitcoinstrings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinstrings.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -21,9 +21,6 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"A fee rate (in %s/kB) that will be used when fee estimation has insufficient \"\n \"data (default: %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Accept connections from outside (default: 1 if no -proxy or -connect/-\"\n-\"noconnect)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Accept relayed transactions received from whitelisted peers even when not \"\n \"relaying transactions (default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -37,14 +34,16 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Bind to given address and whitelist peers connecting to it. Use [host]:port \"\n \"notation for IPv6\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Bind to given address to listen for JSON-RPC connections. Use [host]:port \"\n-\"notation for IPv6. This option can be specified multiple times (default: \"\n-\"bind to all interfaces)\"),\n+\"Bind to given address to listen for JSON-RPC connections. This option is \"\n+\"ignored unless -rpcallowip is also passed. Port is optional and overrides -\"\n+\"rpcport. Use [host]:port notation for IPv6. This option can be specified \"\n+\"multiple times (default: 127.0.0.1 and ::1 i.e., localhost, or if -\"\n+\"rpcallowip has been specified, 0.0.0.0 and :: i.e., all addresses)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Cannot obtain a lock on data directory %s. %s is probably already running.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Connect only to the specified node(s); -noconnect or -connect=0 alone to \"\n-\"disable automatic connections\"),\n+\"Connect only to the specified node(s); -connect=0 disables automatic \"\n+\"connections\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Create new files with system default permissions, instead of umask 077 (only \"\n \"effective with disabled wallet functionality)\"),\n@@ -62,13 +61,17 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Equivalent bytes per sigop in transactions for relay and mining (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Error loading %s: You can't enable HD on a already existing non-HD wallet\"),\n+\"Error loading %s: You can't enable HD on an already existing non-HD wallet\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Error reading %s! All keys read correctly, but transaction data or address \"\n \"book entries might be missing or incorrect.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Error: Listening for incoming connections failed (listen returned error %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Exclude debugging information for a category. Can be used in conjunction \"\n+\"with -debug=1 to output debug logs for all categories except one or more \"\n+\"specified categories.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Execute command when a relevant alert is received or we see a really long \"\n \"fork (%s in cmd is replaced by message)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -134,7 +137,7 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"reindex (download the whole blockchain again in case of pruned node)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Query for peer addresses via DNS lookup, if low on addresses (default: 1 \"\n-\"unless -connect/-noconnect)\"),\n+\"unless -connect used)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Randomize credentials for every proxy connection. This enables Tor stream \"\n \"isolation (default: %u)\"),\n@@ -154,8 +157,6 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Set lowest fee rate (in %s/kB) for transactions to be included in block \"\n \"creation. (default: %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Set maximum size of high-priority/low-fee transactions in bytes (default: %d)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Set the number of script verification threads (%u to %d, 0 = auto, <0 = \"\n \"leave that many cores free, default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -186,6 +187,9 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Tries to keep outbound traffic under the given target (in MiB per 24h), 0 = \"\n \"no limit (default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Unable to replay blocks. You will need to rebuild the database using -\"\n+\"reindex-chainstate.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Unable to rewind the database to a pre-fork state. You will need to \"\n \"redownload the blockchain\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -225,6 +229,8 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Warning: We do not appear to fully agree with our peers! You may need to \"\n \"upgrade, or other nodes may need to upgrade.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Whether to save the mempool on shutdown and load on restart (default: %u)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or CIDR \"\n \"notated network (e.g. 1.2.3.0/24). Can be specified multiple times.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -235,13 +241,17 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"mode.  This will redownload the entire blockchain\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"You need to rebuild the database using -reindex-chainstate to change -txindex\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"%d of last 100 blocks have unexpected version\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"%s corrupt, salvage failed\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"%s is set very high!\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"(default: %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"(default: %u)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"(press q to shutdown and continue later)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"-maxmempool must be at least %d MB\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"-wallet parameter must only specify a filename (not a path)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"<category> can be:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Accept command line and JSON-RPC commands\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Accept connections from outside (default: 1 if no -proxy or -connect)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Accept public REST requests (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Add a node to connect to and attempt to keep the connection open\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Allow DNS lookups for -addnode, -seednode and -connect\"),\n@@ -274,10 +284,11 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error initializing wallet database environmen\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading %s\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading %s: Wallet corrupted\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading %s: Wallet requires newer version of %s\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading %s: You can't disable HD on a already existing HD wallet\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading %s: You can't disable HD on an already existing HD wallet\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading block database\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error opening block database\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error reading from database, shutting down.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error upgrading chainstate database\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: A fatal internal error occurred, see debug.log for details\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Disk space is low!\"),\n@@ -291,18 +302,19 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Incorrect or no genesis block found. Wrong da\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Information\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Initialization sanity check failed. %s is shutting down.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Insufficient funds\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid -onion address: '%s'\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid -proxy address: '%s'\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid -onion address or hostname: '%s'\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid -proxy address or hostname: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -%s=<amount>: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -fallbackfee=<amount>: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid characters in -wallet filename\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid netmask specified in -whitelist: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Keep at most <n> unconnectable transactions in memory (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Keep the transaction memory pool below <n> megabytes (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Keypool ran out, please call keypoolrefill first\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Listen for JSON-RPC connections on <port> (default: %u or testnet: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Listen for connections on <port> (default: %u or testnet: %u)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Loading addresses...\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Loading P2P addresses...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Loading banlist...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Loading block index...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Loading wallet...\"),\n@@ -329,12 +341,12 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rebuild chain state from the currently indexe\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Reducing -maxconnections from %d to %d, because of system limitations.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Relay and mine data carrier transactions (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Relay non-P2SH multisig (default: %u)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Replaying blocks...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rescan the block chain for missing wallet transactions on startup\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rescanning...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rewinding blocks...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Run in the background as a daemon and accept commands\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Send trace/debug info to console instead of debug.log file\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Send transactions as zero-fee transactions if possible (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Send transactions with full-RBF opt-in enabled (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set database cache size in megabytes (%d to %d, default: %d)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Set key pool size to <n> (default: %u)\"),\n@@ -374,13 +386,15 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unknown network specified in -onlynet: '%s'\")\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unsupported argument -benchmark ignored, use -debug=bench.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unsupported argument -debugnet ignored, use -debug=net.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unsupported argument -tor found, use -onion.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unsupported logging category %s=%s.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Upgrade wallet to latest format on startup\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Upgrading UTXO database\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Use UPnP to map the listening port (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Use the test chain\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"User Agent comment (%s) contains unsafe characters.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Username for JSON-RPC connections\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Verifying blocks...\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Verifying wallet...\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Verifying wallet(s)...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Wallet %s resides outside data directory %s\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Wallet debugging/testing options:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Wallet needed to be rewritten: restart %s to complete\"),"
      },
      {
        "sha": "52ce11cefd277df49601a617da143b108512d3a4",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -18,6 +18,7 @@\n #include \"txmempool.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n+#include \"warnings.h\"\n \n #include <stdint.h>\n \n@@ -26,7 +27,6 @@\n \n class CBlockIndex;\n \n-static const int64_t nClientStartupTime = GetTime();\n static int64_t nLastHeaderTipUpdateNotification = 0;\n static int64_t nLastBlockTipUpdateNotification = 0;\n \n@@ -238,7 +238,7 @@ bool ClientModel::isReleaseVersion() const\n \n QString ClientModel::formatClientStartupTime() const\n {\n-    return QDateTime::fromTime_t(nClientStartupTime).toString();\n+    return QDateTime::fromTime_t(GetStartupTime()).toString();\n }\n \n QString ClientModel::dataDir() const\n@@ -303,7 +303,7 @@ static void BlockTipChanged(ClientModel *clientmodel, bool initialSync, const CB\n     }\n     // if we are in-sync, update the UI regardless of last update time\n     if (!initialSync || now - nLastUpdateNotification > MODEL_UPDATE_DELAY) {\n-        //pass a async signal to the UI thread\n+        //pass an async signal to the UI thread\n         QMetaObject::invokeMethod(clientmodel, \"numBlocksChanged\", Qt::QueuedConnection,\n                                   Q_ARG(int, pIndex->nHeight),\n                                   Q_ARG(QDateTime, QDateTime::fromTime_t(pIndex->GetBlockTime())),"
      },
      {
        "sha": "6447cae1bb4e03bc4a211a55181b6321a69129f0",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -10,13 +10,10 @@\n \n #include <atomic>\n \n-class AddressTableModel;\n class BanTableModel;\n class OptionsModel;\n class PeerTableModel;\n-class TransactionTableModel;\n \n-class CWallet;\n class CBlockIndex;\n \n QT_BEGIN_NAMESPACE"
      },
      {
        "sha": "f3ee0fbe393aeace65b734393481a58623d164f7",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 19,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -424,7 +424,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n     CAmount nPayAmount = 0;\n     bool fDust = false;\n     CMutableTransaction txDummy;\n-    Q_FOREACH(const CAmount &amount, CoinControlDialog::payAmounts)\n+    for (const CAmount &amount : CoinControlDialog::payAmounts)\n     {\n         nPayAmount += amount;\n \n@@ -450,7 +450,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n     coinControl->ListSelected(vCoinControl);\n     model->getOutputs(vCoinControl, vOutputs);\n \n-    BOOST_FOREACH(const COutput& out, vOutputs) {\n+    for (const COutput& out : vOutputs) {\n         // unselect already spent, very unlikely scenario, this could happen\n         // when selected are spent elsewhere, like rpc or another computer\n         uint256 txhash = out.tx->GetHash();\n@@ -499,7 +499,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n         {\n             // there is some fudging in these numbers related to the actual virtual transaction size calculation that will keep this estimate from being exact.\n             // usually, the result will be an overestimate within a couple of satoshis so that the confirmation dialog ends up displaying a slightly smaller fee.\n-            // also, the witness stack size value value is a variable sized integer. usually, the number of stack items will be well under the single byte var int limit.\n+            // also, the witness stack size value is a variable sized integer. usually, the number of stack items will be well under the single byte var int limit.\n             nBytes += 2; // account for the serialized marker and flag bytes\n             nBytes += nQuantity; // account for the witness byte that holds the number of stack items for each input.\n         }\n@@ -510,7 +510,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n                 nBytes -= 34;\n \n         // Fee\n-        nPayFee = CWallet::GetMinimumFee(nBytes, nTxConfirmTarget, ::mempool, ::feeEstimator);\n+        nPayFee = CWallet::GetMinimumFee(nBytes, *coinControl, ::mempool, ::feeEstimator, nullptr /* FeeCalculation */);\n \n         if (nPayAmount > 0)\n         {\n@@ -524,13 +524,10 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n                 CTxOut txout(nChange, (CScript)std::vector<unsigned char>(24, 0));\n                 if (IsDust(txout, ::dustRelayFee))\n                 {\n-                    if (CoinControlDialog::fSubtractFeeFromAmount) // dust-change will be raised until no dust\n-                        nChange = GetDustThreshold(txout, ::dustRelayFee);\n-                    else\n-                    {\n-                        nPayFee += nChange;\n-                        nChange = 0;\n-                    }\n+                    nPayFee += nChange;\n+                    nChange = 0;\n+                    if (CoinControlDialog::fSubtractFeeFromAmount)\n+                        nBytes -= 34; // we didn't detect lack of change above\n                 }\n             }\n \n@@ -584,12 +581,8 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n     QString toolTipDust = tr(\"This label turns red if any recipient receives an amount smaller than the current dust threshold.\");\n \n     // how many satoshis the estimated fee can vary per byte we guess wrong\n-    double dFeeVary;\n-    if (payTxFee.GetFeePerK() > 0)\n-        dFeeVary = (double)std::max(CWallet::GetRequiredFee(1000), payTxFee.GetFeePerK()) / 1000;\n-    else {\n-        dFeeVary = (double)std::max(CWallet::GetRequiredFee(1000), ::feeEstimator.estimateSmartFee(nTxConfirmTarget, NULL, ::mempool).GetFeePerK()) / 1000;\n-    }\n+    double dFeeVary = (double)nPayFee / nBytes;\n+\n     QString toolTip4 = tr(\"Can vary +/- %1 satoshi(s) per input.\").arg(dFeeVary);\n \n     l3->setToolTip(toolTip4);\n@@ -626,7 +619,7 @@ void CoinControlDialog::updateView()\n     std::map<QString, std::vector<COutput> > mapCoins;\n     model->listCoins(mapCoins);\n \n-    BOOST_FOREACH(const PAIRTYPE(QString, std::vector<COutput>)& coins, mapCoins) {\n+    for (const std::pair<QString, std::vector<COutput>>& coins : mapCoins) {\n         CCoinControlWidgetItem *itemWalletAddress = new CCoinControlWidgetItem();\n         itemWalletAddress->setCheckState(COLUMN_CHECKBOX, Qt::Unchecked);\n         QString sWalletAddress = coins.first;\n@@ -651,7 +644,7 @@ void CoinControlDialog::updateView()\n \n         CAmount nSum = 0;\n         int nChildren = 0;\n-        BOOST_FOREACH(const COutput& out, coins.second) {\n+        for (const COutput& out : coins.second) {\n             nSum += out.tx->tx->vout[out.i].nValue;\n             nChildren++;\n "
      },
      {
        "sha": "99a9f893ffe3ae7092e51861f431683fea4feb08",
        "filename": "src/qt/coincontroldialog.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/coincontroldialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/coincontroldialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -20,7 +20,6 @@ class PlatformStyle;\n class WalletModel;\n \n class CCoinControl;\n-class CTxMemPool;\n \n namespace Ui {\n     class CoinControlDialog;"
      },
      {
        "sha": "88510b61681dcc06d75a42787faf3bb1e0d5c204",
        "filename": "src/qt/coincontroltreewidget.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/coincontroltreewidget.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/coincontroltreewidget.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroltreewidget.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -16,9 +16,10 @@ void CoinControlTreeWidget::keyPressEvent(QKeyEvent *event)\n     if (event->key() == Qt::Key_Space) // press spacebar -> select checkbox\n     {\n         event->ignore();\n-        int COLUMN_CHECKBOX = 0;\n-        if(this->currentItem())\n+        if (this->currentItem()) {\n+            int COLUMN_CHECKBOX = 0;\n             this->currentItem()->setCheckState(COLUMN_CHECKBOX, ((this->currentItem()->checkState(COLUMN_CHECKBOX) == Qt::Checked) ? Qt::Unchecked : Qt::Checked));\n+        }\n     }\n     else if (event->key() == Qt::Key_Escape) // press esc -> close dialog\n     {"
      },
      {
        "sha": "14078b9ee810503a326b2d212d001e1777c8316c",
        "filename": "src/qt/forms/optionsdialog.ui",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/forms/optionsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/forms/optionsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/optionsdialog.ui?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -315,7 +315,7 @@\n             <bool>false</bool>\n            </property>\n            <property name=\"toolTip\">\n-            <string>Shows, if the supplied default SOCKS5 proxy is used to reach peers via this network type.</string>\n+            <string>Shows if the supplied default SOCKS5 proxy is used to reach peers via this network type.</string>\n            </property>\n            <property name=\"text\">\n             <string/>\n@@ -338,7 +338,7 @@\n             <bool>false</bool>\n            </property>\n            <property name=\"toolTip\">\n-            <string>Shows, if the supplied default SOCKS5 proxy is used to reach peers via this network type.</string>\n+            <string>Shows if the supplied default SOCKS5 proxy is used to reach peers via this network type.</string>\n            </property>\n            <property name=\"text\">\n             <string/>\n@@ -361,7 +361,7 @@\n             <bool>false</bool>\n            </property>\n            <property name=\"toolTip\">\n-            <string>Shows, if the supplied default SOCKS5 proxy is used to reach peers via this network type.</string>\n+            <string>Shows if the supplied default SOCKS5 proxy is used to reach peers via this network type.</string>\n            </property>\n            <property name=\"text\">\n             <string/>"
      },
      {
        "sha": "e82a3c1533e3353546b0d21b669847d859484797",
        "filename": "src/qt/forms/sendcoinsdialog.ui",
        "status": "modified",
        "additions": 4,
        "deletions": 60,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/forms/sendcoinsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/forms/sendcoinsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/sendcoinsdialog.ui?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -1068,44 +1068,15 @@\n                     <number>30</number>\n                    </property>\n                    <item>\n-                    <widget class=\"QSlider\" name=\"sliderSmartFee\">\n-                     <property name=\"minimum\">\n+                    <layout class=\"QHBoxLayout\" name=\"horizontalLayoutConfTarget\">\n+                     <property name=\"bottomMargin\">\n                       <number>0</number>\n                      </property>\n-                     <property name=\"maximum\">\n-                      <number>23</number>\n-                     </property>\n-                     <property name=\"pageStep\">\n-                      <number>1</number>\n-                     </property>\n-                     <property name=\"value\">\n-                      <number>0</number>\n-                     </property>\n-                     <property name=\"orientation\">\n-                      <enum>Qt::Horizontal</enum>\n-                     </property>\n-                     <property name=\"invertedAppearance\">\n-                      <bool>false</bool>\n-                     </property>\n-                     <property name=\"invertedControls\">\n-                      <bool>false</bool>\n-                     </property>\n-                     <property name=\"tickPosition\">\n-                      <enum>QSlider::NoTicks</enum>\n-                     </property>\n-                    </widget>\n-                   </item>\n-                   <item>\n-                    <layout class=\"QHBoxLayout\" name=\"horizontalLayoutFee10\">\n                      <item>\n-                      <widget class=\"QLabel\" name=\"labelSmartFeeNormal\">\n-                       <property name=\"text\">\n-                        <string>normal</string>\n-                       </property>\n-                      </widget>\n+                      <widget class=\"QComboBox\" name=\"confTargetSelector\"/>\n                      </item>\n                      <item>\n-                      <spacer name=\"horizontalSpacer_7\">\n+                      <spacer name=\"horizontalSpacerConfTarget\">\n                        <property name=\"orientation\">\n                         <enum>Qt::Horizontal</enum>\n                        </property>\n@@ -1117,33 +1088,6 @@\n                        </property>\n                       </spacer>\n                      </item>\n-                     <item>\n-                      <widget class=\"QLabel\" name=\"confirmationTargetLabel\">\n-                       <property name=\"text\">\n-                        <string notr=\"true\">(count)</string>\n-                       </property>\n-                      </widget>\n-                     </item>\n-                     <item>\n-                      <spacer name=\"horizontalSpacer_3\">\n-                       <property name=\"orientation\">\n-                        <enum>Qt::Horizontal</enum>\n-                       </property>\n-                       <property name=\"sizeHint\" stdset=\"0\">\n-                        <size>\n-                         <width>40</width>\n-                         <height>20</height>\n-                        </size>\n-                       </property>\n-                      </spacer>\n-                     </item>\n-                     <item>\n-                      <widget class=\"QLabel\" name=\"labelSmartFeeFast\">\n-                       <property name=\"text\">\n-                        <string>fast</string>\n-                       </property>\n-                      </widget>\n-                     </item>\n                     </layout>\n                    </item>\n                   </layout>"
      },
      {
        "sha": "1e0d472b6a95c4aea1acda96427b415ce370479c",
        "filename": "src/qt/intro.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/intro.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/intro.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/intro.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -214,7 +214,7 @@ bool Intro::pickDataDirectory()\n             }\n             dataDir = intro.getDataDirectory();\n             try {\n-                TryCreateDirectory(GUIUtil::qstringToBoostPath(dataDir));\n+                TryCreateDirectories(GUIUtil::qstringToBoostPath(dataDir));\n                 break;\n             } catch (const fs::filesystem_error&) {\n                 QMessageBox::critical(0, tr(PACKAGE_NAME),"
      },
      {
        "sha": "91830750671d1556ac48e8afa8c3dcbba36b72eb",
        "filename": "src/qt/locale/bitcoin_en.ts",
        "status": "modified",
        "additions": 387,
        "deletions": 206,
        "changes": 593,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/locale/bitcoin_en.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/locale/bitcoin_en.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_en.ts?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -127,7 +127,7 @@\n <context>\n     <name>AddressTableModel</name>\n     <message>\n-        <location filename=\"../addresstablemodel.cpp\" line=\"+170\"/>\n+        <location filename=\"../addresstablemodel.cpp\" line=\"+169\"/>\n         <source>Label</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -304,12 +304,12 @@\n         <translation>Sign &amp;message...</translation>\n     </message>\n     <message>\n-        <location line=\"+427\"/>\n+        <location line=\"+429\"/>\n         <source>Synchronizing with network...</source>\n         <translation>Synchronizing with network...</translation>\n     </message>\n     <message>\n-        <location line=\"-505\"/>\n+        <location line=\"-507\"/>\n         <source>&amp;Overview</source>\n         <translation>&amp;Overview</translation>\n     </message>\n@@ -404,7 +404,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+357\"/>\n+        <location line=\"+359\"/>\n         <source>Click to disable network activity.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -429,7 +429,7 @@\n         <translation>Reindexing blocks on disk...</translation>\n     </message>\n     <message>\n-        <location line=\"-508\"/>\n+        <location line=\"-510\"/>\n         <source>Send coins to a Bitcoin address</source>\n         <translation>Send coins to a Bitcoin address</translation>\n     </message>\n@@ -459,12 +459,12 @@\n         <translation>&amp;Verify message...</translation>\n     </message>\n     <message>\n-        <location line=\"+514\"/>\n+        <location line=\"+516\"/>\n         <source>Bitcoin</source>\n         <translation>Bitcoin</translation>\n     </message>\n     <message>\n-        <location line=\"-739\"/>\n+        <location line=\"-741\"/>\n         <source>Wallet</source>\n         <translation>Wallet</translation>\n     </message>\n@@ -549,7 +549,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message numerus=\"yes\">\n-        <location line=\"+354\"/>\n+        <location line=\"+356\"/>\n         <source>%n active connection(s) to Bitcoin network</source>\n         <translation>\n             <numerusform>%n active connection to Bitcoin network</numerusform>\n@@ -610,12 +610,12 @@\n         <translation>Up to date</translation>\n     </message>\n     <message>\n-        <location line=\"-438\"/>\n+        <location line=\"-440\"/>\n         <source>Show the %1 help message to get a list with possible Bitcoin command-line options</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+197\"/>\n+        <location line=\"+199\"/>\n         <source>%1 client</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -690,7 +690,7 @@\n         <translation>Wallet is &lt;b&gt;encrypted&lt;/b&gt; and currently &lt;b&gt;locked&lt;/b&gt;</translation>\n     </message>\n     <message>\n-        <location filename=\"../bitcoin.cpp\" line=\"+518\"/>\n+        <location filename=\"../bitcoin.cpp\" line=\"+524\"/>\n         <source>A fatal error occurred. Bitcoin can no longer continue safely and will quit.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -783,7 +783,7 @@\n         <translation type=\"unfinished\">Confirmed</translation>\n     </message>\n     <message>\n-        <location filename=\"../coincontroldialog.cpp\" line=\"+55\"/>\n+        <location filename=\"../coincontroldialog.cpp\" line=\"+54\"/>\n         <source>Copy address</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -849,7 +849,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+183\"/>\n+        <location line=\"+155\"/>\n         <source>yes</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -956,7 +956,7 @@\n <context>\n     <name>FreespaceChecker</name>\n     <message>\n-        <location filename=\"../intro.cpp\" line=\"+78\"/>\n+        <location filename=\"../intro.cpp\" line=\"+76\"/>\n         <source>A new data directory will be created.</source>\n         <translation>A new data directory will be created.</translation>\n     </message>\n@@ -1067,13 +1067,23 @@\n         <source>As this is the first time the program is launched, you can choose where %1 will store its data.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n+    <message>\n+        <location line=\"+157\"/>\n+        <source>When you click OK, %1 will begin to download and process the full %4 block chain (%2GB) starting with the earliest transactions in %3 when %4 initially launched.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n     <message>\n         <location line=\"+10\"/>\n-        <source>%1 will download and store a copy of the Bitcoin block chain. At least %2GB of data will be stored in this directory, and it will grow over time. The wallet will also be stored in this directory.</source>\n+        <source>This initial synchronisation is very demanding, and may expose hardware problems with your computer that had previously gone unnoticed. Each time you run %1, it will continue downloading where it left off.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+10\"/>\n+        <source>If you have chosen to limit block chain storage (pruning), the historical data must still be downloaded and processed, but will be deleted afterward to keep your disk usage low.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"-160\"/>\n         <source>Use the default data directory</source>\n         <translation>Use the default data directory</translation>\n     </message>\n@@ -1083,7 +1093,32 @@\n         <translation>Use a custom data directory:</translation>\n     </message>\n     <message>\n-        <location filename=\"../intro.cpp\" line=\"+94\"/>\n+        <location filename=\"../intro.cpp\" line=\"+20\"/>\n+        <source>Bitcoin</source>\n+        <translation type=\"unfinished\">Bitcoin</translation>\n+    </message>\n+    <message>\n+        <location line=\"+6\"/>\n+        <source>At least %1 GB of data will be stored in this directory, and it will grow over time.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+5\"/>\n+        <source>Approximately %1 GB of data will be stored in this directory.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+8\"/>\n+        <source>%1 will download and store a copy of the Bitcoin block chain.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+2\"/>\n+        <source>The wallet will also be stored in this directory.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+70\"/>\n         <source>Error: Specified data directory &quot;%1&quot; cannot be created.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1257,7 +1292,14 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+94\"/>\n+        <location line=\"-118\"/>\n+        <location line=\"+23\"/>\n+        <location line=\"+23\"/>\n+        <source>Shows if the supplied default SOCKS5 proxy is used to reach peers via this network type.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+166\"/>\n         <source>Minimize instead of exit the application when the window is closed. When this option is enabled, the application will be closed only after selecting Exit in the menu.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1278,7 +1320,17 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+43\"/>\n+        <location line=\"+45\"/>\n+        <source>Open the %1 configuration file from the working directory.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n+        <source>Open Configuration File</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+10\"/>\n         <source>Reset all client options to default.</source>\n         <translation>Reset all client options to default.</translation>\n     </message>\n@@ -1288,7 +1340,7 @@\n         <translation>&amp;Reset Options</translation>\n     </message>\n     <message>\n-        <location line=\"-514\"/>\n+        <location line=\"-529\"/>\n         <source>&amp;Network</source>\n         <translation>&amp;Network</translation>\n     </message>\n@@ -1366,14 +1418,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+13\"/>\n         <location line=\"+23\"/>\n-        <location line=\"+23\"/>\n-        <source>Shows, if the supplied default SOCKS5 proxy is used to reach peers via this network type.</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"-36\"/>\n         <source>IPv4</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1458,7 +1503,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+612\"/>\n+        <location line=\"+646\"/>\n         <source>&amp;OK</source>\n         <translation>&amp;OK</translation>\n     </message>\n@@ -1468,7 +1513,7 @@\n         <translation>&amp;Cancel</translation>\n     </message>\n     <message>\n-        <location filename=\"../optionsdialog.cpp\" line=\"+86\"/>\n+        <location filename=\"../optionsdialog.cpp\" line=\"+84\"/>\n         <source>default</source>\n         <translation>default</translation>\n     </message>\n@@ -1484,22 +1529,42 @@\n     </message>\n     <message>\n         <location line=\"+1\"/>\n-        <location line=\"+43\"/>\n+        <location line=\"+55\"/>\n         <source>Client restart required to activate changes.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-43\"/>\n+        <location line=\"-55\"/>\n         <source>Client will be shut down. Do you want to proceed?</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+47\"/>\n+        <location line=\"+15\"/>\n+        <source>Configuration options</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>The configuration file is used to specify advanced user options which override GUI settings. Additionally, any command-line options will override this configuration file.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+5\"/>\n+        <source>Error</source>\n+        <translation type=\"unfinished\">Error</translation>\n+    </message>\n+    <message>\n+        <location line=\"+0\"/>\n+        <source>The configuration file could not be opened.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+38\"/>\n         <source>This change would require a client restart.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+25\"/>\n+        <location line=\"+28\"/>\n         <source>The supplied proxy address is invalid.</source>\n         <translation>The supplied proxy address is invalid.</translation>\n     </message>\n@@ -1755,12 +1820,12 @@\n         <translation type=\"unfinished\">Amount</translation>\n     </message>\n     <message>\n-        <location filename=\"../guiutil.cpp\" line=\"+136\"/>\n+        <location filename=\"../guiutil.cpp\" line=\"+130\"/>\n         <source>Enter a Bitcoin address (e.g. %1)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+759\"/>\n+        <location line=\"+766\"/>\n         <source>%1 d</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -1850,7 +1915,7 @@\n         </translation>\n     </message>\n     <message>\n-        <location filename=\"../bitcoin.cpp\" line=\"+172\"/>\n+        <location filename=\"../bitcoin.cpp\" line=\"+173\"/>\n         <source>%1 didn&apos;t yet exit safely...</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2007,7 +2072,12 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+404\"/>\n+        <location line=\"+324\"/>\n+        <source>&amp;Reset</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+80\"/>\n         <location line=\"+558\"/>\n         <source>Received</source>\n         <translation type=\"unfinished\"></translation>\n@@ -2030,8 +2100,8 @@\n     </message>\n     <message>\n         <location line=\"+60\"/>\n-        <location filename=\"../rpcconsole.cpp\" line=\"+456\"/>\n-        <location line=\"+719\"/>\n+        <location filename=\"../rpcconsole.cpp\" line=\"+458\"/>\n+        <location line=\"+728\"/>\n         <source>Select a peer to view detailed information.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2157,12 +2227,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+52\"/>\n-        <source>&amp;Clear</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+16\"/>\n+        <location line=\"+68\"/>\n         <source>Totals</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2187,7 +2252,7 @@\n         <translation>Clear console</translation>\n     </message>\n     <message>\n-        <location filename=\"../rpcconsole.cpp\" line=\"-214\"/>\n+        <location filename=\"../rpcconsole.cpp\" line=\"-223\"/>\n         <source>1 &amp;hour</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2225,23 +2290,23 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+126\"/>\n+        <location line=\"+135\"/>\n         <source>Welcome to the %1 RPC console.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+1\"/>\n-        <source>Use up and down arrows to navigate history, and &lt;b&gt;Ctrl-L&lt;/b&gt; to clear screen.</source>\n-        <translation>Use up and down arrows to navigate history, and &lt;b&gt;Ctrl-L&lt;/b&gt; to clear screen.</translation>\n-    </message>\n-    <message>\n-        <location line=\"+1\"/>\n+        <location line=\"+2\"/>\n         <source>Type &lt;b&gt;help&lt;/b&gt; for an overview of available commands.</source>\n         <translation>Type &lt;b&gt;help&lt;/b&gt; for an overview of available commands.</translation>\n     </message>\n     <message>\n-        <location line=\"+2\"/>\n-        <source>WARNING: Scammers have been active, telling users to type commands here, stealing their wallet contents. Do not use this console without fully understanding the ramification of a command.</source>\n+        <location line=\"-1\"/>\n+        <source>Use up and down arrows to navigate history, and %1 to clear screen.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n+        <source>WARNING: Scammers have been active, telling users to type commands here, stealing their wallet contents. Do not use this console without fully understanding the ramifications of a command.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n@@ -2494,7 +2559,7 @@\n <context>\n     <name>RecentRequestsTableModel</name>\n     <message>\n-        <location filename=\"../recentrequeststablemodel.cpp\" line=\"+29\"/>\n+        <location filename=\"../recentrequeststablemodel.cpp\" line=\"+28\"/>\n         <source>Date</source>\n         <translation type=\"unfinished\">Date</translation>\n     </message>\n@@ -2509,7 +2574,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+40\"/>\n+        <location line=\"+39\"/>\n         <source>(no label)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2533,7 +2598,7 @@\n     <name>SendCoinsDialog</name>\n     <message>\n         <location filename=\"../forms/sendcoinsdialog.ui\" line=\"+14\"/>\n-        <location filename=\"../sendcoinsdialog.cpp\" line=\"+554\"/>\n+        <location filename=\"../sendcoinsdialog.cpp\" line=\"+565\"/>\n         <source>Send Coins</source>\n         <translation>Send Coins</translation>\n     </message>\n@@ -2608,7 +2673,17 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+37\"/>\n+        <location line=\"+24\"/>\n+        <source>Using the fallbackfee can result in sending a transaction that will take several hours or days (or never) to confirm. Consider choosing your fee manually or wait until your have validated the complete chain.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+9\"/>\n+        <source>Warning: Fee estimation is currently not possible.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+26\"/>\n         <source>collapse fee-settings</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2619,22 +2694,16 @@\n     </message>\n     <message>\n         <location line=\"-3\"/>\n-        <location line=\"+16\"/>\n         <source>If the custom fee is set to 1000 satoshis and the transaction is only 250 bytes, then &quot;per kilobyte&quot; only pays 250 satoshis in fee, while &quot;total at least&quot; pays 1000 satoshis. For transactions bigger than a kilobyte both pay by kilobyte.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-64\"/>\n+        <location line=\"-48\"/>\n         <source>Hide</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+67\"/>\n-        <source>total at least</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+30\"/>\n+        <location line=\"+84\"/>\n         <location line=\"+13\"/>\n         <source>Paying only the minimum fee is just fine as long as there is less transaction volume than space in the blocks. But be aware that this can end up in a never confirming transaction once there is more demand for bitcoin transactions than the network can process.</source>\n         <translation type=\"unfinished\"></translation>\n@@ -2670,7 +2739,17 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+102\"/>\n+        <location line=\"+30\"/>\n+        <source>Request Replace-By-Fee</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n+        <source>Indicates that the sender may wish to replace this transaction with a new one paying higher fees (prior to being confirmed).</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+79\"/>\n         <source>Send to multiple recipients at once</source>\n         <translation>Send to multiple recipients at once</translation>\n     </message>\n@@ -2685,17 +2764,17 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-876\"/>\n+        <location line=\"-895\"/>\n         <source>Dust:</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+691\"/>\n+        <location line=\"+700\"/>\n         <source>Confirmation time target:</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+188\"/>\n+        <location line=\"+198\"/>\n         <source>Clear &amp;All</source>\n         <translation>Clear &amp;All</translation>\n     </message>\n@@ -2715,7 +2794,7 @@\n         <translation>S&amp;end</translation>\n     </message>\n     <message>\n-        <location filename=\"../sendcoinsdialog.cpp\" line=\"-486\"/>\n+        <location filename=\"../sendcoinsdialog.cpp\" line=\"-497\"/>\n         <source>Copy quantity</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2750,7 +2829,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+205\"/>\n+        <location line=\"+209\"/>\n         <location line=\"+5\"/>\n         <location line=\"+5\"/>\n         <location line=\"+4\"/>\n@@ -2778,7 +2857,12 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+2\"/>\n+        <location line=\"+5\"/>\n+        <source>This transaction signals replaceability (optin-RBF).</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+4\"/>\n         <source>Confirm send coins</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2828,28 +2912,28 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message numerus=\"yes\">\n-        <location line=\"+67\"/>\n+        <location line=\"+63\"/>\n         <source>%n block(s)</source>\n         <translation>\n             <numerusform>%n block</numerusform>\n             <numerusform>%n blocks</numerusform>\n         </translation>\n     </message>\n     <message>\n-        <location line=\"+28\"/>\n+        <location line=\"+24\"/>\n         <source>Pay only the required fee of %1</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message numerus=\"yes\">\n-        <location line=\"+25\"/>\n+        <location line=\"+30\"/>\n         <source>Estimated to begin confirmation within %n block(s).</source>\n         <translation>\n             <numerusform>Estimated to begin confirmation within %n block.</numerusform>\n             <numerusform>Estimated to begin confirmation within %n blocks.</numerusform>\n         </translation>\n     </message>\n     <message>\n-        <location line=\"+102\"/>\n+        <location line=\"+103\"/>\n         <source>Warning: Invalid Bitcoin address</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -2986,7 +3070,7 @@\n <context>\n     <name>SendConfirmationDialog</name>\n     <message>\n-        <location filename=\"../sendcoinsdialog.cpp\" line=\"+95\"/>\n+        <location filename=\"../sendcoinsdialog.cpp\" line=\"+86\"/>\n         <location line=\"+5\"/>\n         <source>Yes</source>\n         <translation type=\"unfinished\"></translation>\n@@ -3198,7 +3282,7 @@\n <context>\n     <name>TrafficGraphWidget</name>\n     <message>\n-        <location filename=\"../trafficgraphwidget.cpp\" line=\"+79\"/>\n+        <location filename=\"../trafficgraphwidget.cpp\" line=\"+80\"/>\n         <source>KB/s</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -3427,7 +3511,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+21\"/>\n+        <location line=\"+20\"/>\n         <source>Amount</source>\n         <translation type=\"unfinished\">Amount</translation>\n     </message>\n@@ -3460,7 +3544,7 @@\n <context>\n     <name>TransactionTableModel</name>\n     <message>\n-        <location filename=\"../transactiontablemodel.cpp\" line=\"+246\"/>\n+        <location filename=\"../transactiontablemodel.cpp\" line=\"+248\"/>\n         <source>Date</source>\n         <translation type=\"unfinished\">Date</translation>\n     </message>\n@@ -3606,7 +3690,7 @@\n <context>\n     <name>TransactionView</name>\n     <message>\n-        <location filename=\"../transactionview.cpp\" line=\"+69\"/>\n+        <location filename=\"../transactionview.cpp\" line=\"+70\"/>\n         <location line=\"+16\"/>\n         <source>All</source>\n         <translation type=\"unfinished\"></translation>\n@@ -3677,12 +3761,17 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+36\"/>\n+        <location line=\"+37\"/>\n         <source>Abandon transaction</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+1\"/>\n+        <source>Increase transaction fee</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+2\"/>\n         <source>Copy address</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -3722,7 +3811,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+186\"/>\n+        <location line=\"+193\"/>\n         <source>Export Transaction History</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -3787,7 +3876,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+147\"/>\n+        <location line=\"+166\"/>\n         <source>Range:</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -3816,10 +3905,57 @@\n <context>\n     <name>WalletModel</name>\n     <message>\n-        <location filename=\"../walletmodel.cpp\" line=\"+291\"/>\n+        <location filename=\"../walletmodel.cpp\" line=\"+289\"/>\n         <source>Send Coins</source>\n         <translation type=\"unfinished\">Send Coins</translation>\n     </message>\n+    <message>\n+        <location line=\"+385\"/>\n+        <location line=\"+46\"/>\n+        <location line=\"+9\"/>\n+        <source>Fee bump error</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"-55\"/>\n+        <source>Increasing transaction fee failed</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+6\"/>\n+        <source>Do you want to increase the fee?</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+6\"/>\n+        <source>Current fee:</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+4\"/>\n+        <source>Increase:</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+4\"/>\n+        <source>New fee:</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+4\"/>\n+        <source>Confirm fee bump</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+22\"/>\n+        <source>Can&apos;t sign transaction.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+9\"/>\n+        <source>Could not commit transaction</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n </context>\n <context>\n     <name>WalletView</name>\n@@ -3867,7 +4003,7 @@\n <context>\n     <name>bitcoin-core</name>\n     <message>\n-        <location filename=\"../bitcoinstrings.cpp\" line=\"+318\"/>\n+        <location filename=\"../bitcoinstrings.cpp\" line=\"+330\"/>\n         <source>Options:</source>\n         <translation>Options:</translation>\n     </message>\n@@ -3877,37 +4013,27 @@\n         <translation>Specify data directory</translation>\n     </message>\n     <message>\n-        <location line=\"-90\"/>\n+        <location line=\"-92\"/>\n         <source>Connect to a node to retrieve peer addresses, and disconnect</source>\n         <translation>Connect to a node to retrieve peer addresses, and disconnect</translation>\n     </message>\n     <message>\n-        <location line=\"+93\"/>\n+        <location line=\"+95\"/>\n         <source>Specify your own public address</source>\n         <translation>Specify your own public address</translation>\n     </message>\n     <message>\n-        <location line=\"-108\"/>\n+        <location line=\"-111\"/>\n         <source>Accept command line and JSON-RPC commands</source>\n         <translation>Accept command line and JSON-RPC commands</translation>\n     </message>\n     <message>\n-        <location line=\"-221\"/>\n-        <source>Accept connections from outside (default: 1 if no -proxy or -connect/-noconnect)</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+22\"/>\n-        <source>Connect only to the specified node(s); -noconnect or -connect=0 alone to disable automatic connections</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+12\"/>\n+        <location line=\"-197\"/>\n         <source>Distributed under the MIT software license, see the accompanying file %s or %s</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+37\"/>\n+        <location line=\"+41\"/>\n         <source>If &lt;category&gt; is not supplied or if &lt;category&gt; = 1, output all debugging information.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -3927,7 +4053,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+132\"/>\n+        <location line=\"+140\"/>\n         <source>Error: A fatal internal error occurred, see debug.log for details</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -3937,22 +4063,22 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+40\"/>\n+        <location line=\"+41\"/>\n         <source>Pruning blockstore...</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+10\"/>\n+        <location line=\"+11\"/>\n         <source>Run in the background as a daemon and accept commands</source>\n         <translation>Run in the background as a daemon and accept commands</translation>\n     </message>\n     <message>\n-        <location line=\"+37\"/>\n+        <location line=\"+36\"/>\n         <source>Unable to start HTTP server. See debug log for details.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-360\"/>\n+        <location line=\"-372\"/>\n         <source>Bitcoin Core</source>\n         <translation type=\"unfinished\">Bitcoin Core</translation>\n     </message>\n@@ -3967,7 +4093,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+6\"/>\n+        <location line=\"+3\"/>\n         <source>Accept relayed transactions received from whitelisted peers even when not relaying transactions (default: %d)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -3977,7 +4103,7 @@\n         <translation>Bind to given address and always listen on it. Use [host]:port notation for IPv6</translation>\n     </message>\n     <message>\n-        <location line=\"+10\"/>\n+        <location line=\"+12\"/>\n         <source>Cannot obtain a lock on data directory %s. %s is probably already running.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -3987,17 +4113,17 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+13\"/>\n-        <source>Error loading %s: You can&apos;t enable HD on a already existing non-HD wallet</source>\n+        <location line=\"+15\"/>\n+        <source>Error reading %s! All keys read correctly, but transaction data or address book entries might be missing or incorrect.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+2\"/>\n-        <source>Error reading %s! All keys read correctly, but transaction data or address book entries might be missing or incorrect.</source>\n+        <location line=\"+5\"/>\n+        <source>Exclude debugging information for a category. Can be used in conjunction with -debug=1 to output debug logs for all categories except one or more specified categories.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+8\"/>\n+        <location line=\"+7\"/>\n         <source>Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)</source>\n         <translation>Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)</translation>\n     </message>\n@@ -4032,7 +4158,12 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+14\"/>\n+        <location line=\"+8\"/>\n+        <source>Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect used)</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+6\"/>\n         <source>Reduce storage requirements by enabling pruning (deleting) of old blocks. This allows the pruneblockchain RPC to be called to delete specific blocks, and enables automatic pruning of old blocks if a target size in MiB is provided. This mode is incompatible with -txindex and -rescan. Warning: Reverting this setting requires re-downloading the entire blockchain. (default: 0 = disable pruning blocks, 1 = allow manual pruning via RPC, &gt;%u = automatically prune block files to stay under the specified target size in MiB)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4042,7 +4173,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+5\"/>\n+        <location line=\"+3\"/>\n         <source>Set the number of script verification threads (%u to %d, 0 = auto, &lt;0 = leave that many cores free, default: %d)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4058,6 +4189,11 @@\n     </message>\n     <message>\n         <location line=\"+15\"/>\n+        <source>Unable to replay blocks. You will need to rebuild the database using -reindex-chainstate.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n         <source>Unable to rewind the database to a pre-fork state. You will need to redownload the blockchain</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4087,27 +4223,52 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+12\"/>\n+        <location line=\"+3\"/>\n+        <source>Whether to save the mempool on shutdown and load on restart (default: %u)</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+11\"/>\n         <source>You need to rebuild the database using -reindex-chainstate to change -txindex</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+2\"/>\n+        <source>%d of last 100 blocks have unexpected version</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n         <source>%s corrupt, salvage failed</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+4\"/>\n+        <source>(press q to shutdown and continue later)</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n         <source>-maxmempool must be at least %d MB</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>-wallet parameter must only specify a filename (not a path)</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n     <message>\n         <location line=\"+1\"/>\n         <source>&lt;category&gt; can be:</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+6\"/>\n+        <location line=\"+2\"/>\n+        <source>Accept connections from outside (default: 1 if no -proxy or -connect)</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+5\"/>\n         <source>Append comment to the user agent string</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4217,12 +4378,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+1\"/>\n-        <source>Error loading %s: You can&apos;t disable HD on a already existing HD wallet</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+1\"/>\n+        <location line=\"+2\"/>\n         <source>Error loading block database</source>\n         <translation>Error loading block database</translation>\n     </message>\n@@ -4232,7 +4388,7 @@\n         <translation>Error opening block database</translation>\n     </message>\n     <message>\n-        <location line=\"+4\"/>\n+        <location line=\"+5\"/>\n         <source>Error: Disk space is low!</source>\n         <translation>Error: Disk space is low!</translation>\n     </message>\n@@ -4257,27 +4413,32 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+2\"/>\n-        <source>Invalid -onion address: &apos;%s&apos;</source>\n+        <location line=\"+4\"/>\n+        <source>Invalid amount for -%s=&lt;amount&gt;: &apos;%s&apos;</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>Invalid amount for -fallbackfee=&lt;amount&gt;: &apos;%s&apos;</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+2\"/>\n-        <source>Invalid amount for -%s=&lt;amount&gt;: &apos;%s&apos;</source>\n+        <source>Invalid characters in -wallet filename</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+1\"/>\n-        <source>Invalid amount for -fallbackfee=&lt;amount&gt;: &apos;%s&apos;</source>\n+        <location line=\"+3\"/>\n+        <source>Keep the transaction memory pool below &lt;n&gt; megabytes (default: %u)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+4\"/>\n-        <source>Keep the transaction memory pool below &lt;n&gt; megabytes (default: %u)</source>\n+        <source>Loading P2P addresses...</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+5\"/>\n+        <location line=\"+1\"/>\n         <source>Loading banlist...</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4327,12 +4488,17 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+6\"/>\n+        <location line=\"+4\"/>\n+        <source>Replaying blocks...</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n         <source>Rewinding blocks...</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+5\"/>\n+        <location line=\"+4\"/>\n         <source>Set database cache size in megabytes (%d to %d, default: %d)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4371,8 +4537,18 @@\n         <source>Unsupported argument -tor found, use -onion.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>Unsupported logging category %s=%s.</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n     <message>\n         <location line=\"+2\"/>\n+        <source>Upgrading UTXO database</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+1\"/>\n         <source>Use UPnP to map the listening port (default: %u)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4392,12 +4568,7 @@\n         <translation>Verifying blocks...</translation>\n     </message>\n     <message>\n-        <location line=\"+1\"/>\n-        <source>Verifying wallet...</source>\n-        <translation>Verifying wallet...</translation>\n-    </message>\n-    <message>\n-        <location line=\"+1\"/>\n+        <location line=\"+2\"/>\n         <source>Wallet %s resides outside data directory %s</source>\n         <translation>Wallet %s resides outside data directory %s</translation>\n     </message>\n@@ -4417,7 +4588,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-358\"/>\n+        <location line=\"-375\"/>\n         <source>Allow JSON-RPC connections from specified source. Valid for &lt;ip&gt; are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4427,12 +4598,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+3\"/>\n-        <source>Bind to given address to listen for JSON-RPC connections. Use [host]:port notation for IPv6. This option can be specified multiple times (default: bind to all interfaces)</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+9\"/>\n+        <location line=\"+14\"/>\n         <source>Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4447,7 +4613,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+2\"/>\n+        <location line=\"+6\"/>\n         <source>Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)</source>\n         <translation>Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)</translation>\n     </message>\n@@ -4477,22 +4643,17 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+18\"/>\n-        <source>Set maximum size of high-priority/low-fee transactions in bytes (default: %d)</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+15\"/>\n+        <location line=\"+31\"/>\n         <source>The transaction amount is too small to send after the fee has been deducted</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+28\"/>\n+        <location line=\"+31\"/>\n         <source>Use hierarchical deterministic key generation (HD) after BIP32. Only has effect during wallet creation/first start</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+31\"/>\n+        <location line=\"+33\"/>\n         <source>Whitelisted peers cannot be DoS banned and their transactions are always relayed, even if they are already in the mempool, useful e.g. for a gateway</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4502,12 +4663,12 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+8\"/>\n+        <location line=\"+9\"/>\n         <source>(default: %u)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+4\"/>\n+        <location line=\"+7\"/>\n         <source>Accept public REST requests (default: %u)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4522,10 +4683,20 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+22\"/>\n+        <location line=\"+19\"/>\n+        <source>Error loading %s: You can&apos;t disable HD on an already existing HD wallet</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n         <source>Error reading from database, shutting down.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n+    <message>\n+        <location line=\"+1\"/>\n+        <source>Error upgrading chainstate database</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n     <message>\n         <location line=\"+8\"/>\n         <source>Imports blocks from external blk000??.dat file on startup</source>\n@@ -4537,12 +4708,22 @@\n         <translation>Information</translation>\n     </message>\n     <message>\n-        <location line=\"+7\"/>\n-        <source>Invalid amount for -paytxfee=&lt;amount&gt;: &apos;%s&apos; (must be at least %s)</source>\n+        <location line=\"+3\"/>\n+        <source>Invalid -onion address or hostname: &apos;%s&apos;</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n         <location line=\"+1\"/>\n+        <source>Invalid -proxy address or hostname: &apos;%s&apos;</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+3\"/>\n+        <source>Invalid amount for -paytxfee=&lt;amount&gt;: &apos;%s&apos; (must be at least %s)</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+2\"/>\n         <source>Invalid netmask specified in -whitelist: &apos;%s&apos;</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4572,7 +4753,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+3\"/>\n+        <location line=\"+4\"/>\n         <source>Rescan the block chain for missing wallet transactions on startup</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4581,11 +4762,6 @@\n         <source>Send trace/debug info to console instead of debug.log file</source>\n         <translation>Send trace/debug info to console instead of debug.log file</translation>\n     </message>\n-    <message>\n-        <location line=\"+1\"/>\n-        <source>Send transactions as zero-fee transactions if possible (default: %u)</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n     <message>\n         <location line=\"+7\"/>\n         <source>Show all debugging options (usage: --help -help-debug)</source>\n@@ -4642,17 +4818,22 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+7\"/>\n+        <location line=\"+8\"/>\n         <source>Upgrade wallet to latest format on startup</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+4\"/>\n+        <location line=\"+5\"/>\n         <source>Username for JSON-RPC connections</source>\n         <translation>Username for JSON-RPC connections</translation>\n     </message>\n     <message>\n-        <location line=\"+7\"/>\n+        <location line=\"+2\"/>\n+        <source>Verifying wallet(s)...</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+5\"/>\n         <source>Warning</source>\n         <translation>Warning</translation>\n     </message>\n@@ -4677,27 +4858,22 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"-73\"/>\n+        <location line=\"-75\"/>\n         <source>Password for JSON-RPC connections</source>\n         <translation>Password for JSON-RPC connections</translation>\n     </message>\n     <message>\n-        <location line=\"-242\"/>\n+        <location line=\"-251\"/>\n         <source>Execute command when the best block changes (%s in cmd is replaced by block hash)</source>\n         <translation>Execute command when the best block changes (%s in cmd is replaced by block hash)</translation>\n     </message>\n     <message>\n-        <location line=\"+170\"/>\n+        <location line=\"+177\"/>\n         <source>Allow DNS lookups for -addnode, -seednode and -connect</source>\n         <translation>Allow DNS lookups for -addnode, -seednode and -connect</translation>\n     </message>\n     <message>\n-        <location line=\"+58\"/>\n-        <source>Loading addresses...</source>\n-        <translation>Loading addresses...</translation>\n-    </message>\n-    <message>\n-        <location line=\"-291\"/>\n+        <location line=\"-243\"/>\n         <source>(1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4707,7 +4883,17 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+43\"/>\n+        <location line=\"+19\"/>\n+        <source>Bind to given address to listen for JSON-RPC connections. This option is ignored unless -rpcallowip is also passed. Port is optional and overrides -rpcport. Use [host]:port notation for IPv6. This option can be specified multiple times (default: 127.0.0.1 and ::1 i.e., localhost, or if -rpcallowip has been specified, 0.0.0.0 and :: i.e., all addresses)</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+8\"/>\n+        <source>Connect only to the specified node(s); -connect=0 disables automatic connections</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+15\"/>\n         <source>Do not keep transactions in the mempool longer than &lt;n&gt; hours (default: %u)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4717,7 +4903,12 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+24\"/>\n+        <location line=\"+2\"/>\n+        <source>Error loading %s: You can&apos;t enable HD on an already existing non-HD wallet</source>\n+        <translation type=\"unfinished\"></translation>\n+    </message>\n+    <message>\n+        <location line=\"+26\"/>\n         <source>Fees (in %s/kB) smaller than this are considered zero fee for transaction creation (default: %s)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4747,12 +4938,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+13\"/>\n-        <source>Query for peer addresses via DNS lookup, if low on addresses (default: 1 unless -connect/-noconnect)</source>\n-        <translation type=\"unfinished\"></translation>\n-    </message>\n-    <message>\n-        <location line=\"+26\"/>\n+        <location line=\"+37\"/>\n         <source>Sets the serialization of raw transaction or block hex returned in non-verbose mode, non-segwit(0) or segwit(1) (default: %d)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4782,7 +4968,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+6\"/>\n+        <location line=\"+9\"/>\n         <source>Unsupported argument -socks found. Setting SOCKS version isn&apos;t possible anymore, only SOCKS5 proxies are supported.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4807,12 +4993,12 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+7\"/>\n+        <location line=\"+9\"/>\n         <source>Whitelist peers connecting from the given IP address (e.g. 1.2.3.4) or CIDR notated network (e.g. 1.2.3.0/24). Can be specified multiple times.</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+12\"/>\n+        <location line=\"+13\"/>\n         <source>%s is set very high!</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4822,12 +5008,12 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+8\"/>\n+        <location line=\"+11\"/>\n         <source>Always query for peer addresses via DNS lookup (default: %u)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+38\"/>\n+        <location line=\"+39\"/>\n         <source>How many blocks to check at startup (default: %u, 0 = all)</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4837,12 +5023,7 @@\n         <translation type=\"unfinished\"></translation>\n     </message>\n     <message>\n-        <location line=\"+6\"/>\n-        <source>Invalid -proxy address: &apos;%s&apos;</source>\n-        <translation>Invalid -proxy address: &apos;%s&apos;</translation>\n-    </message>\n-    <message>\n-        <location line=\"+7\"/>\n+        <location line=\"+14\"/>\n         <source>Keypool ran out, please call keypoolrefill first</source>\n         <translation type=\"unfinished\"></translation>\n     </message>\n@@ -4977,27 +5158,27 @@\n         <translation>Unknown network specified in -onlynet: &apos;%s&apos;</translation>\n     </message>\n     <message>\n-        <location line=\"-80\"/>\n+        <location line=\"-81\"/>\n         <source>Insufficient funds</source>\n         <translation>Insufficient funds</translation>\n     </message>\n     <message>\n-        <location line=\"+14\"/>\n+        <location line=\"+15\"/>\n         <source>Loading block index...</source>\n         <translation>Loading block index...</translation>\n     </message>\n     <message>\n-        <location line=\"-61\"/>\n+        <location line=\"-63\"/>\n         <source>Add a node to connect to and attempt to keep the connection open</source>\n         <translation>Add a node to connect to and attempt to keep the connection open</translation>\n     </message>\n     <message>\n-        <location line=\"+62\"/>\n+        <location line=\"+64\"/>\n         <source>Loading wallet...</source>\n         <translation>Loading wallet...</translation>\n     </message>\n     <message>\n-        <location line=\"-55\"/>\n+        <location line=\"-57\"/>\n         <source>Cannot downgrade wallet</source>\n         <translation>Cannot downgrade wallet</translation>\n     </message>\n@@ -5007,17 +5188,17 @@\n         <translation>Cannot write default address</translation>\n     </message>\n     <message>\n-        <location line=\"+78\"/>\n+        <location line=\"+81\"/>\n         <source>Rescanning...</source>\n         <translation>Rescanning...</translation>\n     </message>\n     <message>\n-        <location line=\"-67\"/>\n+        <location line=\"-70\"/>\n         <source>Done loading</source>\n         <translation>Done loading</translation>\n     </message>\n     <message>\n-        <location line=\"+15\"/>\n+        <location line=\"+16\"/>\n         <source>Error</source>\n         <translation>Error</translation>\n     </message>"
      },
      {
        "sha": "a83f285034fdb8b30330800c28e5913fc6b42fd4",
        "filename": "src/qt/modaloverlay.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/modaloverlay.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/modaloverlay.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/modaloverlay.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -126,7 +126,7 @@ void ModalOverlay::tipUpdate(int count, const QDateTime& blockDate, double nVeri\n         return;\n \n     // estimate the number of headers left based on nPowTargetSpacing\n-    // and check if the gui is not aware of the the best header (happens rarely)\n+    // and check if the gui is not aware of the best header (happens rarely)\n     int estimateNumHeadersLeft = bestHeaderDate.secsTo(currentDate) / Params().GetConsensus().nPowTargetSpacing;\n     bool hasBestHeader = bestHeaderHeight >= count;\n "
      },
      {
        "sha": "b80b6541dddd2ab3fdfd61f5e657cd18a3a8fd50",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -21,8 +21,6 @@\n #include \"wallet/wallet.h\" // for CWallet::GetRequiredFee()\n #endif\n \n-#include <boost/thread.hpp>\n-\n #include <QDataWidgetMapper>\n #include <QDir>\n #include <QIntValidator>\n@@ -84,7 +82,7 @@ OptionsDialog::OptionsDialog(QWidget *parent, bool enableWallet) :\n \n     ui->lang->setToolTip(ui->lang->toolTip().arg(tr(PACKAGE_NAME)));\n     ui->lang->addItem(QString(\"(\") + tr(\"default\") + QString(\")\"), QVariant(\"\"));\n-    Q_FOREACH(const QString &langStr, translations.entryList())\n+    for (const QString &langStr : translations.entryList())\n     {\n         QLocale locale(langStr);\n "
      },
      {
        "sha": "132ee32748c0bc37c58eca88598298a414900381",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -144,7 +144,7 @@ void PaymentServer::LoadRootCAs(X509_STORE* _store)\n     int nRootCerts = 0;\n     const QDateTime currentTime = QDateTime::currentDateTime();\n \n-    Q_FOREACH (const QSslCertificate& cert, certList) {\n+    for (const QSslCertificate& cert : certList) {\n         // Don't log NULL certificates\n         if (cert.isNull())\n             continue;\n@@ -267,7 +267,7 @@ void PaymentServer::ipcParseCommandLine(int argc, char* argv[])\n bool PaymentServer::ipcSendCommandLine()\n {\n     bool fResult = false;\n-    Q_FOREACH (const QString& r, savedPaymentRequests)\n+    for (const QString& r : savedPaymentRequests)\n     {\n         QLocalSocket* socket = new QLocalSocket();\n         socket->connectToServer(ipcServerName(), QIODevice::WriteOnly);\n@@ -392,7 +392,7 @@ void PaymentServer::uiReady()\n     initNetManager();\n \n     saveURIs = false;\n-    Q_FOREACH (const QString& s, savedPaymentRequests)\n+    for (const QString& s : savedPaymentRequests)\n     {\n         handleURIOrFile(s);\n     }\n@@ -555,7 +555,7 @@ bool PaymentServer::processPaymentRequest(const PaymentRequestPlus& request, Sen\n     QList<std::pair<CScript, CAmount> > sendingTos = request.getPayTo();\n     QStringList addresses;\n \n-    Q_FOREACH(const PAIRTYPE(CScript, CAmount)& sendingTo, sendingTos) {\n+    for (const std::pair<CScript, CAmount>& sendingTo : sendingTos) {\n         // Extract and check destination addresses\n         CTxDestination dest;\n         if (ExtractDestination(sendingTo.first, dest)) {\n@@ -742,7 +742,7 @@ void PaymentServer::reportSslErrors(QNetworkReply* reply, const QList<QSslError>\n     Q_UNUSED(reply);\n \n     QString errString;\n-    Q_FOREACH (const QSslError& err, errs) {\n+    for (const QSslError& err : errs) {\n         qWarning() << \"PaymentServer::reportSslErrors: \" << err;\n         errString += err.errorString() + \"\\n\";\n     }"
      },
      {
        "sha": "42934f8055d0107342d747bb9df09525b8fb66ec",
        "filename": "src/qt/peertablemodel.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/peertablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/peertablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablemodel.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -62,7 +62,7 @@ class PeerTablePriv\n #if QT_VERSION >= 0x040700\n             cachedNodeStats.reserve(vstats.size());\n #endif\n-            Q_FOREACH (const CNodeStats& nodestats, vstats)\n+            for (const CNodeStats& nodestats : vstats)\n             {\n                 CNodeCombinedStats stats;\n                 stats.nodeStateStats.nMisbehavior = 0;\n@@ -79,7 +79,7 @@ class PeerTablePriv\n             TRY_LOCK(cs_main, lockMain);\n             if (lockMain)\n             {\n-                BOOST_FOREACH(CNodeCombinedStats &stats, cachedNodeStats)\n+                for (CNodeCombinedStats &stats : cachedNodeStats)\n                     stats.fNodeStateStatsAvailable = GetNodeStateStats(stats.nodeStats.nodeid, stats.nodeStateStats);\n             }\n         }\n@@ -91,7 +91,7 @@ class PeerTablePriv\n         // build index map\n         mapNodeRows.clear();\n         int row = 0;\n-        Q_FOREACH (const CNodeCombinedStats& stats, cachedNodeStats)\n+        for (const CNodeCombinedStats& stats : cachedNodeStats)\n             mapNodeRows.insert(std::pair<NodeId, int>(stats.nodeStats.nodeid, row++));\n     }\n "
      },
      {
        "sha": "1f4e1a442f069ee873405b7adcc5ef02c0afdbf1",
        "filename": "src/qt/platformstyle.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/platformstyle.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/platformstyle.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/platformstyle.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -48,8 +48,7 @@ void MakeSingleColorImage(QImage& img, const QColor& colorbase)\n QIcon ColorizeIcon(const QIcon& ico, const QColor& colorbase)\n {\n     QIcon new_ico;\n-    QSize sz;\n-    Q_FOREACH(sz, ico.availableSizes())\n+    for (const QSize sz : ico.availableSizes())\n     {\n         QImage img(ico.pixmap(sz).toImage());\n         MakeSingleColorImage(img, colorbase);"
      },
      {
        "sha": "84f43266e125d9936d741acd14f37364ee3a7427",
        "filename": "src/qt/receivecoinsdialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/receivecoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/receivecoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receivecoinsdialog.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -191,7 +191,7 @@ void ReceiveCoinsDialog::on_showRequestButton_clicked()\n         return;\n     QModelIndexList selection = ui->recentRequestsView->selectionModel()->selectedRows();\n \n-    Q_FOREACH (const QModelIndex& index, selection) {\n+    for (const QModelIndex& index : selection) {\n         on_recentRequestsView_doubleClicked(index);\n     }\n }"
      },
      {
        "sha": "385f98565c71d996ec023e8841da20b237fbeef9",
        "filename": "src/qt/receivecoinsdialog.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/receivecoinsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/receivecoinsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receivecoinsdialog.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -15,7 +15,6 @@\n #include <QPoint>\n #include <QVariant>\n \n-class OptionsModel;\n class PlatformStyle;\n class WalletModel;\n "
      },
      {
        "sha": "4e88c8802c2b8a12caa2bcbd4b0ddb2963a0b738",
        "filename": "src/qt/recentrequeststablemodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/recentrequeststablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/recentrequeststablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/recentrequeststablemodel.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -11,7 +11,6 @@\n #include \"clientversion.h\"\n #include \"streams.h\"\n \n-#include <boost/foreach.hpp>\n \n RecentRequestsTableModel::RecentRequestsTableModel(CWallet *wallet, WalletModel *parent) :\n     QAbstractTableModel(parent), walletModel(parent)\n@@ -22,7 +21,7 @@ RecentRequestsTableModel::RecentRequestsTableModel(CWallet *wallet, WalletModel\n     // Load entries from wallet\n     std::vector<std::string> vReceiveRequests;\n     parent->loadReceiveRequests(vReceiveRequests);\n-    BOOST_FOREACH(const std::string& request, vReceiveRequests)\n+    for (const std::string& request : vReceiveRequests)\n         addNewRequest(request);\n \n     /* These columns must match the indices in the ColumnIndex enumeration */\n@@ -55,10 +54,9 @@ QVariant RecentRequestsTableModel::data(const QModelIndex &index, int role) cons\n     if(!index.isValid() || index.row() >= list.length())\n         return QVariant();\n \n-    const RecentRequestEntry *rec = &list[index.row()];\n-\n     if(role == Qt::DisplayRole || role == Qt::EditRole)\n     {\n+        const RecentRequestEntry *rec = &list[index.row()];\n         switch(index.column())\n         {\n         case Date:"
      },
      {
        "sha": "ec0580b81c24404cd4b664bde411573404f04f11",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -13,8 +13,6 @@\n #include \"clientmodel.h\"\n #include \"guiutil.h\"\n #include \"platformstyle.h\"\n-#include \"bantablemodel.h\"\n-\n #include \"chainparams.h\"\n #include \"netbase.h\"\n #include \"rpc/server.h\"\n@@ -674,7 +672,7 @@ void RPCConsole::setFontSize(int newSize)\n {\n     QSettings settings;\n \n-    //don't allow a insane font size\n+    //don't allow an insane font size\n     if (newSize < FONT_RANGE.width() || newSize > FONT_RANGE.height())\n         return;\n \n@@ -740,7 +738,7 @@ void RPCConsole::clear(bool clearHistory)\n                         tr(\"Use up and down arrows to navigate history, and %1 to clear screen.\").arg(\"<b>\"+clsKey+\"</b>\") + \"<br>\" +\n                         tr(\"Type <b>help</b> for an overview of available commands.\")) +\n                         \"<br><span class=\\\"secwarning\\\">\" +\n-                        tr(\"WARNING: Scammers have been active, telling users to type commands here, stealing their wallet contents. Do not use this console without fully understanding the ramification of a command.\") +\n+                        tr(\"WARNING: Scammers have been active, telling users to type commands here, stealing their wallet contents. Do not use this console without fully understanding the ramifications of a command.\") +\n                         \"</span>\",\n                         true);\n }"
      },
      {
        "sha": "a01886c3ea8aefbe9026e04e9c2d3d06e3781700",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 67,
        "deletions": 52,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -31,6 +31,25 @@\n #include <QTextDocument>\n #include <QTimer>\n \n+static const std::array<int, 9> confTargets = { {2, 4, 6, 12, 24, 48, 144, 504, 1008} };\n+int getConfTargetForIndex(int index) {\n+    if (index+1 > static_cast<int>(confTargets.size())) {\n+        return confTargets.back();\n+    }\n+    if (index < 0) {\n+        return confTargets[0];\n+    }\n+    return confTargets[index];\n+}\n+int getIndexForConfTarget(int target) {\n+    for (unsigned int i = 0; i < confTargets.size(); i++) {\n+        if (confTargets[i] >= target) {\n+            return i;\n+        }\n+    }\n+    return confTargets.size() - 1;\n+}\n+\n SendCoinsDialog::SendCoinsDialog(const PlatformStyle *_platformStyle, QWidget *parent) :\n     QDialog(parent),\n     ui(new Ui::SendCoinsDialog),\n@@ -152,35 +171,41 @@ void SendCoinsDialog::setModel(WalletModel *_model)\n         coinControlUpdateLabels();\n \n         // fee section\n-        connect(ui->sliderSmartFee, SIGNAL(valueChanged(int)), this, SLOT(updateSmartFeeLabel()));\n-        connect(ui->sliderSmartFee, SIGNAL(valueChanged(int)), this, SLOT(updateGlobalFeeVariables()));\n-        connect(ui->sliderSmartFee, SIGNAL(valueChanged(int)), this, SLOT(coinControlUpdateLabels()));\n+        for (const int &n : confTargets) {\n+            ui->confTargetSelector->addItem(tr(\"%1 (%2 blocks)\").arg(GUIUtil::formatNiceTimeOffset(n*Params().GetConsensus().nPowTargetSpacing)).arg(n));\n+        }\n+        connect(ui->confTargetSelector, SIGNAL(currentIndexChanged(int)), this, SLOT(updateSmartFeeLabel()));\n+        connect(ui->confTargetSelector, SIGNAL(currentIndexChanged(int)), this, SLOT(coinControlUpdateLabels()));\n         connect(ui->groupFee, SIGNAL(buttonClicked(int)), this, SLOT(updateFeeSectionControls()));\n-        connect(ui->groupFee, SIGNAL(buttonClicked(int)), this, SLOT(updateGlobalFeeVariables()));\n         connect(ui->groupFee, SIGNAL(buttonClicked(int)), this, SLOT(coinControlUpdateLabels()));\n-        connect(ui->groupCustomFee, SIGNAL(buttonClicked(int)), this, SLOT(updateGlobalFeeVariables()));\n         connect(ui->groupCustomFee, SIGNAL(buttonClicked(int)), this, SLOT(coinControlUpdateLabels()));\n-        connect(ui->customFee, SIGNAL(valueChanged()), this, SLOT(updateGlobalFeeVariables()));\n         connect(ui->customFee, SIGNAL(valueChanged()), this, SLOT(coinControlUpdateLabels()));\n         connect(ui->checkBoxMinimumFee, SIGNAL(stateChanged(int)), this, SLOT(setMinimumFee()));\n         connect(ui->checkBoxMinimumFee, SIGNAL(stateChanged(int)), this, SLOT(updateFeeSectionControls()));\n-        connect(ui->checkBoxMinimumFee, SIGNAL(stateChanged(int)), this, SLOT(updateGlobalFeeVariables()));\n         connect(ui->checkBoxMinimumFee, SIGNAL(stateChanged(int)), this, SLOT(coinControlUpdateLabels()));\n+        connect(ui->optInRBF, SIGNAL(stateChanged(int)), this, SLOT(updateSmartFeeLabel()));\n+        connect(ui->optInRBF, SIGNAL(stateChanged(int)), this, SLOT(coinControlUpdateLabels()));\n         ui->customFee->setSingleStep(CWallet::GetRequiredFee(1000));\n         updateFeeSectionControls();\n         updateMinFeeLabel();\n         updateSmartFeeLabel();\n-        updateGlobalFeeVariables();\n \n         // set default rbf checkbox state\n         ui->optInRBF->setCheckState(model->getDefaultWalletRbf() ? Qt::Checked : Qt::Unchecked);\n \n         // set the smartfee-sliders default value (wallets default conf.target or last stored value)\n         QSettings settings;\n-        if (settings.value(\"nSmartFeeSliderPosition\").toInt() == 0)\n-            ui->sliderSmartFee->setValue(ui->sliderSmartFee->maximum() - model->getDefaultConfirmTarget() + 2);\n+        if (settings.value(\"nSmartFeeSliderPosition\").toInt() != 0) {\n+            // migrate nSmartFeeSliderPosition to nConfTarget\n+            // nConfTarget is available since 0.15 (replaced nSmartFeeSliderPosition)\n+            int nConfirmTarget = 25 - settings.value(\"nSmartFeeSliderPosition\").toInt(); // 25 == old slider range\n+            settings.setValue(\"nConfTarget\", nConfirmTarget);\n+            settings.remove(\"nSmartFeeSliderPosition\");\n+        }\n+        if (settings.value(\"nConfTarget\").toInt() == 0)\n+            ui->confTargetSelector->setCurrentIndex(getIndexForConfTarget(model->getDefaultConfirmTarget()));\n         else\n-            ui->sliderSmartFee->setValue(settings.value(\"nSmartFeeSliderPosition\").toInt());\n+            ui->confTargetSelector->setCurrentIndex(getIndexForConfTarget(settings.value(\"nConfTarget\").toInt()));\n     }\n }\n \n@@ -190,7 +215,7 @@ SendCoinsDialog::~SendCoinsDialog()\n     settings.setValue(\"fFeeSectionMinimized\", fFeeMinimized);\n     settings.setValue(\"nFeeRadio\", ui->groupFee->checkedId());\n     settings.setValue(\"nCustomFeeRadio\", ui->groupCustomFee->checkedId());\n-    settings.setValue(\"nSmartFeeSliderPosition\", ui->sliderSmartFee->value());\n+    settings.setValue(\"nConfTarget\", getConfTargetForIndex(ui->confTargetSelector->currentIndex()));\n     settings.setValue(\"nTransactionFee\", (qint64)ui->customFee->value());\n     settings.setValue(\"fPayOnlyMinFee\", ui->checkBoxMinimumFee->isChecked());\n \n@@ -243,14 +268,10 @@ void SendCoinsDialog::on_sendButton_clicked()\n     CCoinControl ctrl;\n     if (model->getOptionsModel()->getCoinControlFeatures())\n         ctrl = *CoinControlDialog::coinControl;\n-    if (ui->radioSmartFee->isChecked())\n-        ctrl.nConfirmTarget = ui->sliderSmartFee->maximum() - ui->sliderSmartFee->value() + 2;\n-    else\n-        ctrl.nConfirmTarget = 0;\n \n-    ctrl.signalRbf = ui->optInRBF->isChecked();\n+    updateCoinControlState(ctrl);\n \n-    prepareStatus = model->prepareTransaction(currentTransaction, &ctrl);\n+    prepareStatus = model->prepareTransaction(currentTransaction, ctrl);\n \n     // process prepareStatus and on error generate message shown to user\n     processSendCoinsReturn(prepareStatus,\n@@ -265,7 +286,7 @@ void SendCoinsDialog::on_sendButton_clicked()\n \n     // Format confirmation message\n     QStringList formatted;\n-    Q_FOREACH(const SendCoinsRecipient &rcp, currentTransaction.getRecipients())\n+    for (const SendCoinsRecipient &rcp : currentTransaction.getRecipients())\n     {\n         // generate bold amount string\n         QString amount = \"<b>\" + BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), rcp.amount);\n@@ -319,7 +340,7 @@ void SendCoinsDialog::on_sendButton_clicked()\n     questionString.append(\"<hr />\");\n     CAmount totalAmount = currentTransaction.getTotalTransactionAmount() + txFee;\n     QStringList alternativeUnits;\n-    Q_FOREACH(BitcoinUnits::Unit u, BitcoinUnits::availableUnits())\n+    for (BitcoinUnits::Unit u : BitcoinUnits::availableUnits())\n     {\n         if(u != model->getOptionsModel()->getDisplayUnit())\n             alternativeUnits.append(BitcoinUnits::formatHtmlWithUnit(u, totalAmount));\n@@ -594,36 +615,17 @@ void SendCoinsDialog::setMinimumFee()\n \n void SendCoinsDialog::updateFeeSectionControls()\n {\n-    ui->sliderSmartFee          ->setEnabled(ui->radioSmartFee->isChecked());\n+    ui->confTargetSelector      ->setEnabled(ui->radioSmartFee->isChecked());\n     ui->labelSmartFee           ->setEnabled(ui->radioSmartFee->isChecked());\n     ui->labelSmartFee2          ->setEnabled(ui->radioSmartFee->isChecked());\n     ui->labelSmartFee3          ->setEnabled(ui->radioSmartFee->isChecked());\n     ui->labelFeeEstimation      ->setEnabled(ui->radioSmartFee->isChecked());\n-    ui->labelSmartFeeNormal     ->setEnabled(ui->radioSmartFee->isChecked());\n-    ui->labelSmartFeeFast       ->setEnabled(ui->radioSmartFee->isChecked());\n-    ui->confirmationTargetLabel ->setEnabled(ui->radioSmartFee->isChecked());\n     ui->checkBoxMinimumFee      ->setEnabled(ui->radioCustomFee->isChecked());\n     ui->labelMinFeeWarning      ->setEnabled(ui->radioCustomFee->isChecked());\n     ui->radioCustomPerKilobyte  ->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked());\n     ui->customFee               ->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked());\n }\n \n-void SendCoinsDialog::updateGlobalFeeVariables()\n-{\n-    if (ui->radioSmartFee->isChecked())\n-    {\n-        int nConfirmTarget = ui->sliderSmartFee->maximum() - ui->sliderSmartFee->value() + 2;\n-        payTxFee = CFeeRate(0);\n-\n-        // show the estimated required time for confirmation\n-        ui->confirmationTargetLabel->setText(GUIUtil::formatDurationStr(nConfirmTarget * Params().GetConsensus().nPowTargetSpacing) + \" / \" + tr(\"%n block(s)\", \"\", nConfirmTarget));\n-    }\n-    else\n-    {\n-        payTxFee = CFeeRate(ui->customFee->value());\n-    }\n-}\n-\n void SendCoinsDialog::updateFeeMinimizedLabel()\n {\n     if(!model || !model->getOptionsModel())\n@@ -645,18 +647,32 @@ void SendCoinsDialog::updateMinFeeLabel()\n         );\n }\n \n+void SendCoinsDialog::updateCoinControlState(CCoinControl& ctrl)\n+{\n+    if (ui->radioCustomFee->isChecked()) {\n+        ctrl.m_feerate = CFeeRate(ui->customFee->value());\n+    } else {\n+        ctrl.m_feerate.reset();\n+    }\n+    // Avoid using global defaults when sending money from the GUI\n+    // Either custom fee will be used or if not selected, the confirmation target from dropdown box\n+    ctrl.m_confirm_target = getConfTargetForIndex(ui->confTargetSelector->currentIndex());\n+    ctrl.signalRbf = ui->optInRBF->isChecked();\n+}\n+\n void SendCoinsDialog::updateSmartFeeLabel()\n {\n     if(!model || !model->getOptionsModel())\n         return;\n+    CCoinControl coin_control;\n+    updateCoinControlState(coin_control);\n+    coin_control.m_feerate.reset(); // Explicitly use only fee estimation rate for smart fee labels\n+    FeeCalculation feeCalc;\n+    CFeeRate feeRate = CFeeRate(CWallet::GetMinimumFee(1000, coin_control, ::mempool, ::feeEstimator, &feeCalc));\n \n-    int nBlocksToConfirm = ui->sliderSmartFee->maximum() - ui->sliderSmartFee->value() + 2;\n-    int estimateFoundAtBlocks = nBlocksToConfirm;\n-    CFeeRate feeRate = ::feeEstimator.estimateSmartFee(nBlocksToConfirm, &estimateFoundAtBlocks, ::mempool);\n-    if (feeRate <= CFeeRate(0)) // not enough data => minfee\n-    {\n-        ui->labelSmartFee->setText(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(),\n-                                                                std::max(CWallet::fallbackFee.GetFeePerK(), CWallet::GetRequiredFee(1000))) + \"/kB\");\n+    ui->labelSmartFee->setText(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), feeRate.GetFeePerK()) + \"/kB\");\n+\n+    if (feeCalc.reason == FeeReason::FALLBACK) {\n         ui->labelSmartFee2->show(); // (Smart fee not initialized yet. This usually takes a few blocks...)\n         ui->labelFeeEstimation->setText(\"\");\n         ui->fallbackFeeWarningLabel->setVisible(true);\n@@ -667,10 +683,8 @@ void SendCoinsDialog::updateSmartFeeLabel()\n     }\n     else\n     {\n-        ui->labelSmartFee->setText(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(),\n-                                                                std::max(feeRate.GetFeePerK(), CWallet::GetRequiredFee(1000))) + \"/kB\");\n         ui->labelSmartFee2->hide();\n-        ui->labelFeeEstimation->setText(tr(\"Estimated to begin confirmation within %n block(s).\", \"\", estimateFoundAtBlocks));\n+        ui->labelFeeEstimation->setText(tr(\"Estimated to begin confirmation within %n block(s).\", \"\", feeCalc.returnedTarget));\n         ui->fallbackFeeWarningLabel->setVisible(false);\n     }\n \n@@ -727,8 +741,6 @@ void SendCoinsDialog::coinControlFeatureChanged(bool checked)\n     if (!checked && model) // coin control features disabled\n         CoinControlDialog::coinControl->SetNull();\n \n-    // make sure we set back the confirmation target\n-    updateGlobalFeeVariables();\n     coinControlUpdateLabels();\n }\n \n@@ -819,9 +831,12 @@ void SendCoinsDialog::coinControlUpdateLabels()\n     if (!model || !model->getOptionsModel())\n         return;\n \n+    updateCoinControlState(*CoinControlDialog::coinControl);\n+\n     // set pay amounts\n     CoinControlDialog::payAmounts.clear();\n     CoinControlDialog::fSubtractFeeFromAmount = false;\n+\n     for(int i = 0; i < ui->entries->count(); ++i)\n     {\n         SendCoinsEntry *entry = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(i)->widget());"
      },
      {
        "sha": "70b4aa5a03ab3080bfd0924db680604971049db2",
        "filename": "src/qt/sendcoinsdialog.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/sendcoinsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/sendcoinsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -13,7 +13,6 @@\n #include <QTimer>\n \n class ClientModel;\n-class OptionsModel;\n class PlatformStyle;\n class SendCoinsEntry;\n class SendCoinsRecipient;\n@@ -69,6 +68,8 @@ public Q_SLOTS:\n     void processSendCoinsReturn(const WalletModel::SendCoinsReturn &sendCoinsReturn, const QString &msgArg = QString());\n     void minimizeFeeSection(bool fMinimize);\n     void updateFeeMinimizedLabel();\n+    // Update the passed in CCoinControl with state from the GUI\n+    void updateCoinControlState(CCoinControl& ctrl);\n \n private Q_SLOTS:\n     void on_sendButton_clicked();\n@@ -92,7 +93,6 @@ private Q_SLOTS:\n     void updateFeeSectionControls();\n     void updateMinFeeLabel();\n     void updateSmartFeeLabel();\n-    void updateGlobalFeeVariables();\n \n Q_SIGNALS:\n     // Fired when a message should be reported to the user"
      },
      {
        "sha": "1b7cc69231c14a648ddb045b84208aa297e4a9af",
        "filename": "src/qt/splashscreen.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 1,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/splashscreen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/splashscreen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -131,13 +131,24 @@ SplashScreen::SplashScreen(Qt::WindowFlags f, const NetworkStyle *networkStyle)\n     move(QApplication::desktop()->screenGeometry().center() - r.center());\n \n     subscribeToCoreSignals();\n+    installEventFilter(this);\n }\n \n SplashScreen::~SplashScreen()\n {\n     unsubscribeFromCoreSignals();\n }\n \n+bool SplashScreen::eventFilter(QObject * obj, QEvent * ev) {\n+    if (ev->type() == QEvent::KeyPress) {\n+        QKeyEvent *keyEvent = static_cast<QKeyEvent *>(ev);\n+        if(keyEvent->text()[0] == 'q' && breakAction != nullptr) {\n+            breakAction();\n+        }\n+    }\n+    return QObject::eventFilter(obj, ev);\n+}\n+\n void SplashScreen::slotFinish(QWidget *mainWin)\n {\n     Q_UNUSED(mainWin);\n@@ -164,6 +175,18 @@ static void ShowProgress(SplashScreen *splash, const std::string &title, int nPr\n     InitMessage(splash, title + strprintf(\"%d\", nProgress) + \"%\");\n }\n \n+void SplashScreen::setBreakAction(const std::function<void(void)> &action)\n+{\n+    breakAction = action;\n+}\n+\n+static void SetProgressBreakAction(SplashScreen *splash, const std::function<void(void)> &action)\n+{\n+    QMetaObject::invokeMethod(splash, \"setBreakAction\",\n+        Qt::QueuedConnection,\n+        Q_ARG(std::function<void(void)>, action));\n+}\n+\n #ifdef ENABLE_WALLET\n void SplashScreen::ConnectWallet(CWallet* wallet)\n {\n@@ -177,6 +200,7 @@ void SplashScreen::subscribeToCoreSignals()\n     // Connect signals to client\n     uiInterface.InitMessage.connect(boost::bind(InitMessage, this, _1));\n     uiInterface.ShowProgress.connect(boost::bind(ShowProgress, this, _1, _2));\n+    uiInterface.SetProgressBreakAction.connect(boost::bind(SetProgressBreakAction, this, _1));\n #ifdef ENABLE_WALLET\n     uiInterface.LoadWallet.connect(boost::bind(&SplashScreen::ConnectWallet, this, _1));\n #endif\n@@ -188,7 +212,7 @@ void SplashScreen::unsubscribeFromCoreSignals()\n     uiInterface.InitMessage.disconnect(boost::bind(InitMessage, this, _1));\n     uiInterface.ShowProgress.disconnect(boost::bind(ShowProgress, this, _1, _2));\n #ifdef ENABLE_WALLET\n-    Q_FOREACH(CWallet* const & pwallet, connectedWallets) {\n+    for (CWallet* const & pwallet : connectedWallets) {\n         pwallet->ShowProgress.disconnect(boost::bind(ShowProgress, this, _1, _2));\n     }\n #endif"
      },
      {
        "sha": "a88ebb98a87400c8d3f06c74b169158564859e95",
        "filename": "src/qt/splashscreen.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/splashscreen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/splashscreen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -5,6 +5,7 @@\n #ifndef BITCOIN_QT_SPLASHSCREEN_H\n #define BITCOIN_QT_SPLASHSCREEN_H\n \n+#include <functional>\n #include <QSplashScreen>\n \n class CWallet;\n@@ -35,6 +36,11 @@ public Q_SLOTS:\n     /** Show message and progress */\n     void showMessage(const QString &message, int alignment, const QColor &color);\n \n+    /** Sets the break action */\n+    void setBreakAction(const std::function<void(void)> &action);\n+protected:\n+    bool eventFilter(QObject * obj, QEvent * ev);\n+\n private:\n     /** Connect core signals to splash screen */\n     void subscribeToCoreSignals();\n@@ -49,6 +55,8 @@ public Q_SLOTS:\n     int curAlignment;\n \n     QList<CWallet*> connectedWallets;\n+\n+    std::function<void(void)> breakAction;\n };\n \n #endif // BITCOIN_QT_SPLASHSCREEN_H"
      },
      {
        "sha": "b9a8ad6e280dc42ddca609ab08806e27eac4ed1a",
        "filename": "src/qt/test/paymentservertests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/test/paymentservertests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/test/paymentservertests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/paymentservertests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -196,7 +196,7 @@ void PaymentServerTests::paymentServerTests()\n     QVERIFY(r.paymentRequest.IsInitialized());\n     // Extract address and amount from the request\n     QList<std::pair<CScript, CAmount> > sendingTos = r.paymentRequest.getPayTo();\n-    Q_FOREACH (const PAIRTYPE(CScript, CAmount)& sendingTo, sendingTos) {\n+    for (const std::pair<CScript, CAmount>& sendingTo : sendingTos) {\n         CTxDestination dest;\n         if (ExtractDestination(sendingTo.first, dest))\n             QCOMPARE(PaymentServer::verifyAmount(sendingTo.second), false);"
      },
      {
        "sha": "fbad9e544ae8f00acd2f17d48c54f130d226fcf8",
        "filename": "src/qt/test/rpcnestedtests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 21,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/test/rpcnestedtests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/test/rpcnestedtests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/rpcnestedtests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -12,6 +12,7 @@\n #include \"rpc/server.h\"\n #include \"rpcconsole.h\"\n #include \"test/testutil.h\"\n+#include \"test/test_bitcoin.h\"\n #include \"univalue.h\"\n #include \"util.h\"\n \n@@ -33,28 +34,17 @@ static const CRPCCommand vRPCCommands[] =\n \n void RPCNestedTests::rpcNestedTests()\n {\n-    UniValue jsonRPCError;\n-\n     // do some test setup\n     // could be moved to a more generic place when we add more tests on QT level\n-    const CChainParams& chainparams = Params();\n-    RegisterAllCoreRPCCommands(tableRPC);\n     tableRPC.appendCommand(\"rpcNestedTest\", &vRPCCommands[0]);\n     ClearDatadirCache();\n     std::string path = QDir::tempPath().toStdString() + \"/\" + strprintf(\"test_bitcoin_qt_%lu_%i\", (unsigned long)GetTime(), (int)(GetRand(100000)));\n     QDir dir(QString::fromStdString(path));\n     dir.mkpath(\".\");\n     ForceSetArg(\"-datadir\", path);\n     //mempool.setSanityCheck(1.0);\n-    pblocktree = new CBlockTreeDB(1 << 20, true);\n-    pcoinsdbview = new CCoinsViewDB(1 << 23, true);\n-    pcoinsTip = new CCoinsViewCache(pcoinsdbview);\n-    InitBlockIndex(chainparams);\n-    {\n-        CValidationState state;\n-        bool ok = ActivateBestChain(state, chainparams);\n-        QVERIFY(ok);\n-    }\n+\n+    TestingSetup test;\n \n     SetRPCWarmupFinished();\n \n@@ -147,13 +137,5 @@ void RPCNestedTests::rpcNestedTests()\n     QVERIFY_EXCEPTION_THROWN(RPCConsole::RPCExecuteCommandLine(result, \"rpcNestedTest(abc,,)\"), std::runtime_error); //don't tollerate empty arguments when using ,\n #endif\n \n-    UnloadBlockIndex();\n-    delete pcoinsTip;\n-    pcoinsTip = nullptr;\n-    delete pcoinsdbview;\n-    pcoinsdbview = nullptr;\n-    delete pblocktree;\n-    pblocktree = nullptr;\n-\n     fs::remove_all(fs::path(path));\n }"
      },
      {
        "sha": "5bb863451fd18814e90c229e8ae7d88a886deffb",
        "filename": "src/qt/trafficgraphwidget.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/trafficgraphwidget.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/trafficgraphwidget.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/trafficgraphwidget.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -47,13 +47,14 @@ int TrafficGraphWidget::getGraphRangeMins() const\n \n void TrafficGraphWidget::paintPath(QPainterPath &path, QQueue<float> &samples)\n {\n-    int h = height() - YMARGIN * 2, w = width() - XMARGIN * 2;\n-    int sampleCount = samples.size(), x = XMARGIN + w, y;\n+    int sampleCount = samples.size();\n     if(sampleCount > 0) {\n+        int h = height() - YMARGIN * 2, w = width() - XMARGIN * 2;\n+        int x = XMARGIN + w;\n         path.moveTo(x, YMARGIN + h);\n         for(int i = 0; i < sampleCount; ++i) {\n             x = XMARGIN + w - w * i / DESIRED_SAMPLES;\n-            y = YMARGIN + h - (int)(h * samples.at(i) / fMax);\n+            int y = YMARGIN + h - (int)(h * samples.at(i) / fMax);\n             path.lineTo(x, y);\n         }\n         path.lineTo(x, YMARGIN + h);\n@@ -139,10 +140,10 @@ void TrafficGraphWidget::updateRates()\n     }\n \n     float tmax = 0.0f;\n-    Q_FOREACH(float f, vSamplesIn) {\n+    for (float f : vSamplesIn) {\n         if(f > tmax) tmax = f;\n     }\n-    Q_FOREACH(float f, vSamplesOut) {\n+    for (float f : vSamplesOut) {\n         if(f > tmax) tmax = f;\n     }\n     fMax = tmax;"
      },
      {
        "sha": "bcacc47ef3e54d36809821ecf6598494ca898688",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -133,7 +133,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n         // Coinbase\n         //\n         CAmount nUnmatured = 0;\n-        BOOST_FOREACH(const CTxOut& txout, wtx.tx->vout)\n+        for (const CTxOut& txout : wtx.tx->vout)\n             nUnmatured += wallet->GetCredit(txout, ISMINE_ALL);\n         strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \";\n         if (wtx.IsInMainChain())\n@@ -152,14 +152,14 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n     else\n     {\n         isminetype fAllFromMe = ISMINE_SPENDABLE;\n-        BOOST_FOREACH(const CTxIn& txin, wtx.tx->vin)\n+        for (const CTxIn& txin : wtx.tx->vin)\n         {\n             isminetype mine = wallet->IsMine(txin);\n             if(fAllFromMe > mine) fAllFromMe = mine;\n         }\n \n         isminetype fAllToMe = ISMINE_SPENDABLE;\n-        BOOST_FOREACH(const CTxOut& txout, wtx.tx->vout)\n+        for (const CTxOut& txout : wtx.tx->vout)\n         {\n             isminetype mine = wallet->IsMine(txout);\n             if(fAllToMe > mine) fAllToMe = mine;\n@@ -173,7 +173,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n             //\n             // Debit\n             //\n-            BOOST_FOREACH(const CTxOut& txout, wtx.tx->vout)\n+            for (const CTxOut& txout : wtx.tx->vout)\n             {\n                 // Ignore change\n                 isminetype toSelf = wallet->IsMine(txout);\n@@ -221,10 +221,10 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n             //\n             // Mixed debit transaction\n             //\n-            BOOST_FOREACH(const CTxIn& txin, wtx.tx->vin)\n+            for (const CTxIn& txin : wtx.tx->vin)\n                 if (wallet->IsMine(txin))\n                     strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, -wallet->GetDebit(txin, ISMINE_ALL)) + \"<br>\";\n-            BOOST_FOREACH(const CTxOut& txout, wtx.tx->vout)\n+            for (const CTxOut& txout : wtx.tx->vout)\n                 if (wallet->IsMine(txout))\n                     strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, wallet->GetCredit(txout, ISMINE_ALL)) + \"<br>\";\n         }\n@@ -245,14 +245,14 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n     strHTML += \"<b>\" + tr(\"Output index\") + \":</b> \" + QString::number(rec->getOutputIndex()) + \"<br>\";\n \n     // Message from normal bitcoin:URI (bitcoin:123...?message=example)\n-    Q_FOREACH (const PAIRTYPE(std::string, std::string)& r, wtx.vOrderForm)\n+    for (const std::pair<std::string, std::string>& r : wtx.vOrderForm)\n         if (r.first == \"Message\")\n             strHTML += \"<br><b>\" + tr(\"Message\") + \":</b><br>\" + GUIUtil::HtmlEscape(r.second, true) + \"<br>\";\n \n     //\n     // PaymentRequest info:\n     //\n-    Q_FOREACH (const PAIRTYPE(std::string, std::string)& r, wtx.vOrderForm)\n+    for (const std::pair<std::string, std::string>& r : wtx.vOrderForm)\n     {\n         if (r.first == \"PaymentRequest\")\n         {\n@@ -276,10 +276,10 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n     if (logCategories != BCLog::NONE)\n     {\n         strHTML += \"<hr><br>\" + tr(\"Debug information\") + \"<br><br>\";\n-        BOOST_FOREACH(const CTxIn& txin, wtx.tx->vin)\n+        for (const CTxIn& txin : wtx.tx->vin)\n             if(wallet->IsMine(txin))\n                 strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, -wallet->GetDebit(txin, ISMINE_ALL)) + \"<br>\";\n-        BOOST_FOREACH(const CTxOut& txout, wtx.tx->vout)\n+        for (const CTxOut& txout : wtx.tx->vout)\n             if(wallet->IsMine(txout))\n                 strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, wallet->GetCredit(txout, ISMINE_ALL)) + \"<br>\";\n \n@@ -289,7 +289,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n         strHTML += \"<br><b>\" + tr(\"Inputs\") + \":</b>\";\n         strHTML += \"<ul>\";\n \n-        BOOST_FOREACH(const CTxIn& txin, wtx.tx->vin)\n+        for (const CTxIn& txin : wtx.tx->vin)\n         {\n             COutPoint prevout = txin.prevout;\n "
      },
      {
        "sha": "03fd734e9293402c7f885d6766e51b1a3ebb7bc3",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -12,7 +12,6 @@\n \n #include <stdint.h>\n \n-#include <boost/foreach.hpp>\n \n /* Return positive answer if transaction should be shown in list.\n  */\n@@ -78,15 +77,15 @@ QList<TransactionRecord> TransactionRecord::decomposeTransaction(const CWallet *\n     {\n         bool involvesWatchAddress = false;\n         isminetype fAllFromMe = ISMINE_SPENDABLE;\n-        BOOST_FOREACH(const CTxIn& txin, wtx.tx->vin)\n+        for (const CTxIn& txin : wtx.tx->vin)\n         {\n             isminetype mine = wallet->IsMine(txin);\n             if(mine & ISMINE_WATCH_ONLY) involvesWatchAddress = true;\n             if(fAllFromMe > mine) fAllFromMe = mine;\n         }\n \n         isminetype fAllToMe = ISMINE_SPENDABLE;\n-        BOOST_FOREACH(const CTxOut& txout, wtx.tx->vout)\n+        for (const CTxOut& txout : wtx.tx->vout)\n         {\n             isminetype mine = wallet->IsMine(txout);\n             if(mine & ISMINE_WATCH_ONLY) involvesWatchAddress = true;"
      },
      {
        "sha": "59cef555b1a6ac6801a9e1a92692ada6d665a958",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -26,8 +26,6 @@\n #include <QIcon>\n #include <QList>\n \n-#include <boost/foreach.hpp>\n-\n // Amount column is right-aligned it contains numbers\n static int column_alignments[] = {\n         Qt::AlignLeft|Qt::AlignVCenter, /* status */\n@@ -145,7 +143,7 @@ class TransactionTablePriv\n                 {\n                     parent->beginInsertRows(QModelIndex(), lowerIndex, lowerIndex+toInsert.size()-1);\n                     int insert_idx = lowerIndex;\n-                    Q_FOREACH(const TransactionRecord &rec, toInsert)\n+                    for (const TransactionRecord &rec : toInsert)\n                     {\n                         cachedWallet.insert(insert_idx, rec);\n                         insert_idx += 1;"
      },
      {
        "sha": "43d6e8826ba6fe1699c3899995ead50c48ec0982",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -336,6 +336,10 @@ void TransactionView::changedAmount(const QString &amount)\n \n void TransactionView::exportClicked()\n {\n+    if (!model || !model->getOptionsModel()) {\n+        return;\n+    }\n+\n     // CSV is currently the only supported format\n     QString filename = GUIUtil::getSaveFileName(this,\n         tr(\"Export Transaction History\"), QString(),"
      },
      {
        "sha": "c9b344fbd8ab288133ad7d3c2954915141dfd5a9",
        "filename": "src/qt/utilitydialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/utilitydialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/utilitydialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -106,7 +106,7 @@ HelpMessageDialog::HelpMessageDialog(QWidget *parent, bool about) :\n         QTextCharFormat bold;\n         bold.setFontWeight(QFont::Bold);\n \n-        Q_FOREACH (const QString &line, coreOptions.split(\"\\n\")) {\n+        for (const QString &line : coreOptions.split(\"\\n\")) {\n             if (line.startsWith(\"  -\"))\n             {\n                 cursor.currentTable()->appendRows(1);"
      },
      {
        "sha": "acaa864148c4cf94fcd301483cd9d5036a737312",
        "filename": "src/qt/utilitydialog.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/utilitydialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/utilitydialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -9,7 +9,6 @@\n #include <QObject>\n \n class BitcoinGUI;\n-class ClientModel;\n \n namespace Ui {\n     class HelpMessageDialog;"
      },
      {
        "sha": "ba0e1da0c787104f303f76050f095b01a490d4fb",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 9,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -19,10 +19,12 @@\n #include \"keystore.h\"\n #include \"validation.h\"\n #include \"net.h\" // for g_connman\n+#include \"policy/fees.h\"\n #include \"policy/rbf.h\"\n #include \"sync.h\"\n #include \"ui_interface.h\"\n #include \"util.h\" // for GetBoolArg\n+#include \"wallet/coincontrol.h\"\n #include \"wallet/feebumper.h\"\n #include \"wallet/wallet.h\"\n #include \"wallet/walletdb.h\" // for BackupWallet\n@@ -34,7 +36,6 @@\n #include <QSet>\n #include <QTimer>\n \n-#include <boost/foreach.hpp>\n \n WalletModel::WalletModel(const PlatformStyle *platformStyle, CWallet *_wallet, OptionsModel *_optionsModel, QObject *parent) :\n     QObject(parent), wallet(_wallet), optionsModel(_optionsModel), addressTableModel(0),\n@@ -191,7 +192,7 @@ bool WalletModel::validateAddress(const QString &address)\n     return addressParsed.IsValid();\n }\n \n-WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransaction &transaction, const CCoinControl *coinControl)\n+WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransaction &transaction, const CCoinControl& coinControl)\n {\n     CAmount total = 0;\n     bool fSubtractFeeFromAmount = false;\n@@ -207,7 +208,7 @@ WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransact\n     int nAddresses = 0;\n \n     // Pre-check input data for validity\n-    Q_FOREACH(const SendCoinsRecipient &rcp, recipients)\n+    for (const SendCoinsRecipient &rcp : recipients)\n     {\n         if (rcp.fSubtractFeeFromAmount)\n             fSubtractFeeFromAmount = true;\n@@ -258,7 +259,7 @@ WalletModel::SendCoinsReturn WalletModel::prepareTransaction(WalletModelTransact\n         return DuplicateAddress;\n     }\n \n-    CAmount nBalance = getBalance(coinControl);\n+    CAmount nBalance = getBalance(&coinControl);\n \n     if(total > nBalance)\n     {\n@@ -310,7 +311,7 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction &tran\n         LOCK2(cs_main, wallet->cs_wallet);\n         CWalletTx *newTx = transaction.getTransaction();\n \n-        Q_FOREACH(const SendCoinsRecipient &rcp, transaction.getRecipients())\n+        for (const SendCoinsRecipient &rcp : transaction.getRecipients())\n         {\n             if (rcp.paymentRequest.IsInitialized())\n             {\n@@ -339,9 +340,9 @@ WalletModel::SendCoinsReturn WalletModel::sendCoins(WalletModelTransaction &tran\n         transaction_array.append(&(ssTx[0]), ssTx.size());\n     }\n \n-    // Add addresses / update labels that we've sent to to the address book,\n+    // Add addresses / update labels that we've sent to the address book,\n     // and emit coinsSent signal for each recipient\n-    Q_FOREACH(const SendCoinsRecipient &rcp, transaction.getRecipients())\n+    for (const SendCoinsRecipient &rcp : transaction.getRecipients())\n     {\n         // Don't touch the address book when we have a payment request\n         if (!rcp.paymentRequest.IsInitialized())\n@@ -574,7 +575,7 @@ bool WalletModel::getPrivKey(const CKeyID &address, CKey& vchPrivKeyOut) const\n void WalletModel::getOutputs(const std::vector<COutPoint>& vOutpoints, std::vector<COutput>& vOutputs)\n {\n     LOCK2(cs_main, wallet->cs_wallet);\n-    BOOST_FOREACH(const COutPoint& outpoint, vOutpoints)\n+    for (const COutPoint& outpoint : vOutpoints)\n     {\n         if (!wallet->mapWallet.count(outpoint.hash)) continue;\n         int nDepth = wallet->mapWallet[outpoint.hash].GetDepthInMainChain();\n@@ -667,8 +668,10 @@ bool WalletModel::bumpFee(uint256 hash)\n {\n     std::unique_ptr<CFeeBumper> feeBump;\n     {\n+        CCoinControl coin_control;\n+        coin_control.signalRbf = true;\n         LOCK2(cs_main, wallet->cs_wallet);\n-        feeBump.reset(new CFeeBumper(wallet, hash, nTxConfirmTarget, false, 0, true));\n+        feeBump.reset(new CFeeBumper(wallet, hash, coin_control, 0));\n     }\n     if (feeBump->getResult() != BumpFeeResult::OK)\n     {"
      },
      {
        "sha": "5258dc669939a2b310e9822def01f17e74c7b920",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -154,7 +154,7 @@ class WalletModel : public QObject\n     };\n \n     // prepare transaction for getting txfee before sending coins\n-    SendCoinsReturn prepareTransaction(WalletModelTransaction &transaction, const CCoinControl *coinControl = NULL);\n+    SendCoinsReturn prepareTransaction(WalletModelTransaction &transaction, const CCoinControl& coinControl);\n \n     // Send coins to a list of recipients\n     SendCoinsReturn sendCoins(WalletModelTransaction &transaction);"
      },
      {
        "sha": "8bc9ef725e4d94e12025a451334f1e3efb6491f3",
        "filename": "src/qt/walletmodeltransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/walletmodeltransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/qt/walletmodeltransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodeltransaction.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -82,7 +82,7 @@ void WalletModelTransaction::reassignAmounts(int nChangePosRet)\n CAmount WalletModelTransaction::getTotalTransactionAmount()\n {\n     CAmount totalTransactionAmount = 0;\n-    Q_FOREACH(const SendCoinsRecipient &rcp, recipients)\n+    for (const SendCoinsRecipient &rcp : recipients)\n     {\n         totalTransactionAmount += rcp.amount;\n     }"
      },
      {
        "sha": "b308e8f4a1dec93d0e183dd51fe82174a32218bd",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 73,
        "deletions": 1,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -36,6 +36,10 @@\n \n #include <mutex>\n \n+#if defined(__x86_64__) || defined(__amd64__) || defined(__i386__)\n+#include <cpuid.h>\n+#endif\n+\n #include <openssl/err.h>\n #include <openssl/rand.h>\n \n@@ -65,6 +69,61 @@ static inline int64_t GetPerformanceCounter()\n #endif\n }\n \n+\n+#if defined(__x86_64__) || defined(__amd64__) || defined(__i386__)\n+static std::atomic<bool> hwrand_initialized{false};\n+static bool rdrand_supported = false;\n+static constexpr uint32_t CPUID_F1_ECX_RDRAND = 0x40000000;\n+static void RDRandInit()\n+{\n+    uint32_t eax, ebx, ecx, edx;\n+    if (__get_cpuid(1, &eax, &ebx, &ecx, &edx) && (ecx & CPUID_F1_ECX_RDRAND)) {\n+        LogPrintf(\"Using RdRand as an additional entropy source\\n\");\n+        rdrand_supported = true;\n+    }\n+    hwrand_initialized.store(true);\n+}\n+#else\n+static void RDRandInit() {}\n+#endif\n+\n+static bool GetHWRand(unsigned char* ent32) {\n+#if defined(__x86_64__) || defined(__amd64__) || defined(__i386__)\n+    assert(hwrand_initialized.load(std::memory_order_relaxed));\n+    if (rdrand_supported) {\n+        uint8_t ok;\n+        // Not all assemblers support the rdrand instruction, write it in hex.\n+#ifdef __i386__\n+        for (int iter = 0; iter < 4; ++iter) {\n+            uint32_t r1, r2;\n+            __asm__ volatile (\".byte 0x0f, 0xc7, 0xf0;\" // rdrand %eax\n+                              \".byte 0x0f, 0xc7, 0xf2;\" // rdrand %edx\n+                              \"setc %2\" :\n+                              \"=a\"(r1), \"=d\"(r2), \"=q\"(ok) :: \"cc\");\n+            if (!ok) return false;\n+            WriteLE32(ent32 + 8 * iter, r1);\n+            WriteLE32(ent32 + 8 * iter + 4, r2);\n+        }\n+#else\n+        uint64_t r1, r2, r3, r4;\n+        __asm__ volatile (\".byte 0x48, 0x0f, 0xc7, 0xf0, \" // rdrand %rax\n+                                \"0x48, 0x0f, 0xc7, 0xf3, \" // rdrand %rbx\n+                                \"0x48, 0x0f, 0xc7, 0xf1, \" // rdrand %rcx\n+                                \"0x48, 0x0f, 0xc7, 0xf2; \" // rdrand %rdx\n+                          \"setc %4\" :\n+                          \"=a\"(r1), \"=b\"(r2), \"=c\"(r3), \"=d\"(r4), \"=q\"(ok) :: \"cc\");\n+        if (!ok) return false;\n+        WriteLE64(ent32, r1);\n+        WriteLE64(ent32 + 8, r2);\n+        WriteLE64(ent32 + 16, r3);\n+        WriteLE64(ent32 + 24, r4);\n+#endif\n+        return true;\n+    }\n+#endif\n+    return false;\n+}\n+\n void RandAddSeed()\n {\n     // Seed with CPU performance counter\n@@ -127,6 +186,7 @@ void GetDevURandom(unsigned char *ent32)\n     do {\n         ssize_t n = read(f, ent32 + have, NUM_OS_RANDOM_BYTES - have);\n         if (n <= 0 || n + have > NUM_OS_RANDOM_BYTES) {\n+            close(f);\n             RandFailure();\n         }\n         have += n;\n@@ -167,10 +227,12 @@ void GetOSRand(unsigned char *ent32)\n             RandFailure();\n         }\n     }\n-#elif defined(HAVE_GETENTROPY)\n+#elif defined(HAVE_GETENTROPY) && defined(__OpenBSD__)\n     /* On OpenBSD this can return up to 256 bytes of entropy, will return an\n      * error if more are requested.\n      * The call cannot return less than the requested number of bytes.\n+       getentropy is explicitly limited to openbsd here, as a similar (but not\n+       the same) function may exist on other platforms via glibc.\n      */\n     if (getentropy(ent32, NUM_OS_RANDOM_BYTES) != 0) {\n         RandFailure();\n@@ -255,6 +317,11 @@ void GetStrongRandBytes(unsigned char* out, int num)\n     GetOSRand(buf);\n     hasher.Write(buf, 32);\n \n+    // Third source: HW RNG, if available.\n+    if (GetHWRand(buf)) {\n+        hasher.Write(buf, 32);\n+    }\n+\n     // Combine with and update state\n     {\n         std::unique_lock<std::mutex> lock(cs_rng_state);\n@@ -381,3 +448,8 @@ FastRandomContext::FastRandomContext(bool fDeterministic) : requires_seed(!fDete\n     uint256 seed;\n     rng.SetKey(seed.begin(), 32);\n }\n+\n+void RandomInit()\n+{\n+    RDRandInit();\n+}"
      },
      {
        "sha": "c60ab361795e6823f9c7c204fd292a6f19120b1a",
        "filename": "src/random.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -140,4 +140,7 @@ void GetOSRand(unsigned char *ent32);\n  */\n bool Random_SanityCheck();\n \n+/** Initialize the RNG. */\n+void RandomInit();\n+\n #endif // BITCOIN_RANDOM_H"
      },
      {
        "sha": "33e3fb4529833d3eb14e89e486e9019206c4c420",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -158,7 +158,7 @@ static bool rest_headers(HTTPRequest* req,\n     }\n \n     CDataStream ssHeader(SER_NETWORK, PROTOCOL_VERSION);\n-    BOOST_FOREACH(const CBlockIndex *pindex, headers) {\n+    for (const CBlockIndex *pindex : headers) {\n         ssHeader << pindex->GetBlockHeader();\n     }\n \n@@ -178,7 +178,7 @@ static bool rest_headers(HTTPRequest* req,\n     }\n     case RF_JSON: {\n         UniValue jsonHeaders(UniValue::VARR);\n-        BOOST_FOREACH(const CBlockIndex *pindex, headers) {\n+        for (const CBlockIndex *pindex : headers) {\n             jsonHeaders.push_back(blockheaderToJSON(pindex));\n         }\n         std::string strJSON = jsonHeaders.write() + \"\\n\";\n@@ -413,7 +413,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         boost::split(uriParts, strUriParams, boost::is_any_of(\"/\"));\n     }\n \n-    // throw exception in case of a empty request\n+    // throw exception in case of an empty request\n     std::string strRequestMutable = req->ReadBody();\n     if (strRequestMutable.length() == 0 && uriParts.size() == 0)\n         return RESTERR(req, HTTP_BAD_REQUEST, \"Error: empty request\");\n@@ -558,7 +558,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         objGetUTXOResponse.push_back(Pair(\"bitmap\", bitmapStringRepresentation));\n \n         UniValue utxos(UniValue::VARR);\n-        BOOST_FOREACH (const CCoin& coin, outs) {\n+        for (const CCoin& coin : outs) {\n             UniValue utxo(UniValue::VOBJ);\n             utxo.push_back(Pair(\"height\", (int32_t)coin.nHeight));\n             utxo.push_back(Pair(\"value\", ValueFromAmount(coin.out.nValue)));"
      },
      {
        "sha": "409f895ce062f0db78a991de833522e227d51e1c",
        "filename": "src/reverse_iterator.h",
        "status": "added",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/reverse_iterator.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/reverse_iterator.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/reverse_iterator.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -0,0 +1,39 @@\n+// Taken from https://gist.github.com/arvidsson/7231973\n+\n+#ifndef BITCOIN_REVERSE_ITERATOR_HPP\n+#define BITCOIN_REVERSE_ITERATOR_HPP\n+\n+/**\n+ * Template used for reverse iteration in C++11 range-based for loops.\n+ * \n+ *   std::vector<int> v = {1, 2, 3, 4, 5};\n+ *   for (auto x : reverse_iterate(v))\n+ *       std::cout << x << \" \";\n+ */\n+\n+template <typename T>\n+class reverse_range\n+{\n+    T &x;\n+    \n+public:\n+    reverse_range(T &x) : x(x) {}\n+    \n+    auto begin() const -> decltype(this->x.rbegin())\n+    {\n+        return x.rbegin();\n+    }\n+    \n+    auto end() const -> decltype(this->x.rend())\n+    {\n+        return x.rend();\n+    }\n+};\n+ \n+template <typename T>\n+reverse_range<T> reverse_iterate(T &x)\n+{\n+    return reverse_range<T>(x);\n+}\n+\n+#endif // BITCOIN_REVERSE_ITERATOR_HPP"
      },
      {
        "sha": "d65e107e3c4684c9a9232f4dd1bcd5032170034c",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 24,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -19,6 +19,7 @@\n #include \"rpc/server.h\"\n #include \"streams.h\"\n #include \"sync.h\"\n+#include \"txdb.h\"\n #include \"txmempool.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n@@ -209,7 +210,7 @@ UniValue waitfornewblock(const JSONRPCRequest& request)\n             + HelpExampleRpc(\"waitfornewblock\", \"1000\")\n         );\n     int timeout = 0;\n-    if (request.params.size() > 0)\n+    if (!request.params[0].isNull())\n         timeout = request.params[0].get_int();\n \n     CUpdatedBlock block;\n@@ -251,7 +252,7 @@ UniValue waitforblock(const JSONRPCRequest& request)\n \n     uint256 hash = uint256S(request.params[0].get_str());\n \n-    if (request.params.size() > 1)\n+    if (!request.params[1].isNull())\n         timeout = request.params[1].get_int();\n \n     CUpdatedBlock block;\n@@ -294,7 +295,7 @@ UniValue waitforblockheight(const JSONRPCRequest& request)\n \n     int height = request.params[0].get_int();\n \n-    if (request.params.size() > 1)\n+    if (!request.params[1].isNull())\n         timeout = request.params[1].get_int();\n \n     CUpdatedBlock block;\n@@ -364,14 +365,14 @@ void entryToJSON(UniValue &info, const CTxMemPoolEntry &e)\n     info.push_back(Pair(\"ancestorfees\", e.GetModFeesWithAncestors()));\n     const CTransaction& tx = e.GetTx();\n     std::set<std::string> setDepends;\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    for (const CTxIn& txin : tx.vin)\n     {\n         if (mempool.exists(txin.prevout.hash))\n             setDepends.insert(txin.prevout.hash.ToString());\n     }\n \n     UniValue depends(UniValue::VARR);\n-    BOOST_FOREACH(const std::string& dep, setDepends)\n+    for (const std::string& dep : setDepends)\n     {\n         depends.push_back(dep);\n     }\n@@ -385,7 +386,7 @@ UniValue mempoolToJSON(bool fVerbose)\n     {\n         LOCK(mempool.cs);\n         UniValue o(UniValue::VOBJ);\n-        BOOST_FOREACH(const CTxMemPoolEntry& e, mempool.mapTx)\n+        for (const CTxMemPoolEntry& e : mempool.mapTx)\n         {\n             const uint256& hash = e.GetTx().GetHash();\n             UniValue info(UniValue::VOBJ);\n@@ -400,7 +401,7 @@ UniValue mempoolToJSON(bool fVerbose)\n         mempool.queryHashes(vtxid);\n \n         UniValue a(UniValue::VARR);\n-        BOOST_FOREACH(const uint256& hash, vtxid)\n+        for (const uint256& hash : vtxid)\n             a.push_back(hash.ToString());\n \n         return a;\n@@ -433,7 +434,7 @@ UniValue getrawmempool(const JSONRPCRequest& request)\n         );\n \n     bool fVerbose = false;\n-    if (request.params.size() > 0)\n+    if (!request.params[0].isNull())\n         fVerbose = request.params[0].get_bool();\n \n     return mempoolToJSON(fVerbose);\n@@ -466,7 +467,7 @@ UniValue getmempoolancestors(const JSONRPCRequest& request)\n     }\n \n     bool fVerbose = false;\n-    if (request.params.size() > 1)\n+    if (!request.params[1].isNull())\n         fVerbose = request.params[1].get_bool();\n \n     uint256 hash = ParseHashV(request.params[0], \"parameter 1\");\n@@ -485,14 +486,14 @@ UniValue getmempoolancestors(const JSONRPCRequest& request)\n \n     if (!fVerbose) {\n         UniValue o(UniValue::VARR);\n-        BOOST_FOREACH(CTxMemPool::txiter ancestorIt, setAncestors) {\n+        for (CTxMemPool::txiter ancestorIt : setAncestors) {\n             o.push_back(ancestorIt->GetTx().GetHash().ToString());\n         }\n \n         return o;\n     } else {\n         UniValue o(UniValue::VOBJ);\n-        BOOST_FOREACH(CTxMemPool::txiter ancestorIt, setAncestors) {\n+        for (CTxMemPool::txiter ancestorIt : setAncestors) {\n             const CTxMemPoolEntry &e = *ancestorIt;\n             const uint256& _hash = e.GetTx().GetHash();\n             UniValue info(UniValue::VOBJ);\n@@ -530,7 +531,7 @@ UniValue getmempooldescendants(const JSONRPCRequest& request)\n     }\n \n     bool fVerbose = false;\n-    if (request.params.size() > 1)\n+    if (!request.params[1].isNull())\n         fVerbose = request.params[1].get_bool();\n \n     uint256 hash = ParseHashV(request.params[0], \"parameter 1\");\n@@ -549,14 +550,14 @@ UniValue getmempooldescendants(const JSONRPCRequest& request)\n \n     if (!fVerbose) {\n         UniValue o(UniValue::VARR);\n-        BOOST_FOREACH(CTxMemPool::txiter descendantIt, setDescendants) {\n+        for (CTxMemPool::txiter descendantIt : setDescendants) {\n             o.push_back(descendantIt->GetTx().GetHash().ToString());\n         }\n \n         return o;\n     } else {\n         UniValue o(UniValue::VOBJ);\n-        BOOST_FOREACH(CTxMemPool::txiter descendantIt, setDescendants) {\n+        for (CTxMemPool::txiter descendantIt : setDescendants) {\n             const CTxMemPoolEntry &e = *descendantIt;\n             const uint256& _hash = e.GetTx().GetHash();\n             UniValue info(UniValue::VOBJ);\n@@ -665,7 +666,7 @@ UniValue getblockheader(const JSONRPCRequest& request)\n     uint256 hash(uint256S(strHash));\n \n     bool fVerbose = true;\n-    if (request.params.size() > 1)\n+    if (!request.params[1].isNull())\n         fVerbose = request.params[1].get_bool();\n \n     if (mapBlockIndex.count(hash) == 0)\n@@ -740,7 +741,7 @@ UniValue getblock(const JSONRPCRequest& request)\n     uint256 hash(uint256S(strHash));\n \n     int verbosity = 1;\n-    if (request.params.size() > 1) {\n+    if (!request.params[1].isNull()) {\n         if(request.params[1].isNum())\n             verbosity = request.params[1].get_int();\n         else\n@@ -797,7 +798,7 @@ static void ApplyStats(CCoinsStats &stats, CHashWriter& ss, const uint256& hash,\n     stats.nTransactions++;\n     for (const auto output : outputs) {\n         ss << VARINT(output.first + 1);\n-        ss << *(const CScriptBase*)(&output.second.out.scriptPubKey);\n+        ss << output.second.out.scriptPubKey;\n         ss << VARINT(output.second.out.nValue);\n         stats.nTransactionOutputs++;\n         stats.nTotalAmount += output.second.out.nValue;\n@@ -921,7 +922,7 @@ UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n \n     CCoinsStats stats;\n     FlushStateToDisk();\n-    if (GetUTXOStats(pcoinsTip, stats)) {\n+    if (GetUTXOStats(pcoinsdbview, stats)) {\n         ret.push_back(Pair(\"height\", (int64_t)stats.nHeight));\n         ret.push_back(Pair(\"bestblock\", stats.hashBlock.GetHex()));\n         ret.push_back(Pair(\"transactions\", (int64_t)stats.nTransactions));\n@@ -983,14 +984,14 @@ UniValue gettxout(const JSONRPCRequest& request)\n     int n = request.params[1].get_int();\n     COutPoint out(hash, n);\n     bool fMempool = true;\n-    if (request.params.size() > 2)\n+    if (!request.params[2].isNull())\n         fMempool = request.params[2].get_bool();\n \n     Coin coin;\n     if (fMempool) {\n         LOCK(mempool.cs);\n         CCoinsViewMemPool view(pcoinsTip, mempool);\n-        if (!view.GetCoin(out, coin) || mempool.isSpent(out)) { // TODO: filtering spent coins should be done by the CCoinsViewMemPool\n+        if (!view.GetCoin(out, coin) || mempool.isSpent(out)) {\n             return NullUniValue;\n         }\n     } else {\n@@ -1036,9 +1037,9 @@ UniValue verifychain(const JSONRPCRequest& request)\n \n     LOCK(cs_main);\n \n-    if (request.params.size() > 0)\n+    if (!request.params[0].isNull())\n         nCheckLevel = request.params[0].get_int();\n-    if (request.params.size() > 1)\n+    if (!request.params[1].isNull())\n         nCheckDepth = request.params[1].get_int();\n \n     return CVerifyDB().VerifyDB(Params(), pcoinsTip, nCheckLevel, nCheckDepth);\n@@ -1261,7 +1262,7 @@ UniValue getchaintips(const JSONRPCRequest& request)\n     std::set<const CBlockIndex*> setOrphans;\n     std::set<const CBlockIndex*> setPrevs;\n \n-    BOOST_FOREACH(const PAIRTYPE(const uint256, CBlockIndex*)& item, mapBlockIndex)\n+    for (const std::pair<const uint256, CBlockIndex*>& item : mapBlockIndex)\n     {\n         if (!chainActive.Contains(item.second)) {\n             setOrphans.insert(item.second);\n@@ -1281,7 +1282,7 @@ UniValue getchaintips(const JSONRPCRequest& request)\n \n     /* Construct the output array.  */\n     UniValue res(UniValue::VARR);\n-    BOOST_FOREACH(const CBlockIndex* block, setTips)\n+    for (const CBlockIndex* block : setTips)\n     {\n         UniValue obj(UniValue::VOBJ);\n         obj.push_back(Pair(\"height\", block->nHeight));"
      },
      {
        "sha": "960edfd56f5b6bde590a5b33d018eed717b118a1",
        "filename": "src/rpc/blockchain.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/blockchain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/blockchain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -7,9 +7,6 @@\n \n class CBlock;\n class CBlockIndex;\n-class CScript;\n-class CTransaction;\n-class uint256;\n class UniValue;\n \n /**"
      },
      {
        "sha": "7c75586d03392b02a85e099d3816ac54fc5da3bb",
        "filename": "src/rpc/client.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 5,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/client.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/client.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/client.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -10,7 +10,6 @@\n #include <set>\n #include <stdint.h>\n \n-#include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n #include <univalue.h>\n \n class CRPCConvertParam\n@@ -38,6 +37,8 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"getnetworkhashps\", 1, \"height\" },\n     { \"sendtoaddress\", 1, \"amount\" },\n     { \"sendtoaddress\", 4, \"subtractfeefromamount\" },\n+    { \"sendtoaddress\", 5 , \"replaceable\" },\n+    { \"sendtoaddress\", 6 , \"conf_target\" },\n     { \"settxfee\", 0, \"amount\" },\n     { \"getreceivedbyaddress\", 1, \"minconf\" },\n     { \"getreceivedbyaccount\", 1, \"minconf\" },\n@@ -70,26 +71,31 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"sendmany\", 1, \"amounts\" },\n     { \"sendmany\", 2, \"minconf\" },\n     { \"sendmany\", 4, \"subtractfeefrom\" },\n+    { \"sendmany\", 5 , \"replaceable\" },\n+    { \"sendmany\", 6 , \"conf_target\" },\n     { \"addmultisigaddress\", 0, \"nrequired\" },\n     { \"addmultisigaddress\", 1, \"keys\" },\n     { \"createmultisig\", 0, \"nrequired\" },\n     { \"createmultisig\", 1, \"keys\" },\n     { \"listunspent\", 0, \"minconf\" },\n     { \"listunspent\", 1, \"maxconf\" },\n     { \"listunspent\", 2, \"addresses\" },\n+    { \"listunspent\", 3, \"include_unsafe\" },\n     { \"listunspent\", 4, \"query_options\" },\n     { \"getblock\", 1, \"verbosity\" },\n+    { \"getblock\", 1, \"verbose\" },\n     { \"getblockheader\", 1, \"verbose\" },\n     { \"getchaintxstats\", 0, \"nblocks\" },\n     { \"gettransaction\", 1, \"include_watchonly\" },\n     { \"getrawtransaction\", 1, \"verbose\" },\n     { \"createrawtransaction\", 0, \"inputs\" },\n     { \"createrawtransaction\", 1, \"outputs\" },\n     { \"createrawtransaction\", 2, \"locktime\" },\n-    { \"createrawtransaction\", 3, \"optintorbf\" },\n+    { \"createrawtransaction\", 3, \"replaceable\" },\n     { \"signrawtransaction\", 1, \"prevtxs\" },\n     { \"signrawtransaction\", 2, \"privkeys\" },\n     { \"sendrawtransaction\", 1, \"allowhighfees\" },\n+    { \"combinerawtransaction\", 0, \"txs\" },\n     { \"fundrawtransaction\", 1, \"options\" },\n     { \"gettxout\", 1, \"n\" },\n     { \"gettxout\", 2, \"include_mempool\" },\n@@ -109,11 +115,9 @@ static const CRPCConvertParam vRPCConvertParams[] =\n     { \"getrawmempool\", 0, \"verbose\" },\n     { \"estimatefee\", 0, \"nblocks\" },\n     { \"estimatesmartfee\", 0, \"nblocks\" },\n-    { \"estimatesmartfee\", 1, \"conservative\" },\n     { \"estimaterawfee\", 0, \"nblocks\" },\n     { \"estimaterawfee\", 1, \"threshold\" },\n-    { \"estimaterawfee\", 2, \"horizon\" },\n-    { \"prioritisetransaction\", 1, \"priority_delta\" },\n+    { \"prioritisetransaction\", 1, \"dummy\" },\n     { \"prioritisetransaction\", 2, \"fee_delta\" },\n     { \"setban\", 2, \"bantime\" },\n     { \"setban\", 3, \"absolute\" },"
      },
      {
        "sha": "7d292a4635015035056fba7390f4480ad0d54a91",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 144,
        "deletions": 136,
        "changes": 280,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -18,17 +18,29 @@\n #include \"policy/fees.h\"\n #include \"pow.h\"\n #include \"rpc/blockchain.h\"\n+#include \"rpc/mining.h\"\n #include \"rpc/server.h\"\n #include \"txmempool.h\"\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n #include \"validationinterface.h\"\n+#include \"warnings.h\"\n \n #include <memory>\n #include <stdint.h>\n \n #include <univalue.h>\n \n+unsigned int ParseConfirmTarget(const UniValue& value)\n+{\n+    int target = value.get_int();\n+    unsigned int max_target = ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n+    if (target < 1 || (unsigned int)target > max_target) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid conf_target, must be between %u - %u\", 1, max_target));\n+    }\n+    return (unsigned int)target;\n+}\n+\n /**\n  * Return average network hashes per second based on the last 'lookup' blocks,\n  * or from the last difficulty change if 'lookup' is nonpositive.\n@@ -90,21 +102,19 @@ UniValue getnetworkhashps(const JSONRPCRequest& request)\n        );\n \n     LOCK(cs_main);\n-    return GetNetworkHashPS(request.params.size() > 0 ? request.params[0].get_int() : 120, request.params.size() > 1 ? request.params[1].get_int() : -1);\n+    return GetNetworkHashPS(!request.params[0].isNull() ? request.params[0].get_int() : 120, !request.params[1].isNull() ? request.params[1].get_int() : -1);\n }\n \n UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)\n {\n     static const int nInnerLoopCount = 0x10000;\n-    int nHeightStart = 0;\n     int nHeightEnd = 0;\n     int nHeight = 0;\n \n     {   // Don't keep cs_main locked\n         LOCK(cs_main);\n-        nHeightStart = chainActive.Height();\n-        nHeight = nHeightStart;\n-        nHeightEnd = nHeightStart+nGenerate;\n+        nHeight = chainActive.Height();\n+        nHeightEnd = nHeight+nGenerate;\n     }\n     unsigned int nExtraNonce = 0;\n     UniValue blockHashes(UniValue::VARR);\n@@ -143,42 +153,6 @@ UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGen\n     return blockHashes;\n }\n \n-UniValue generate(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw std::runtime_error(\n-            \"generate nblocks ( maxtries )\\n\"\n-            \"\\nMine up to nblocks blocks immediately (before the RPC call returns)\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. nblocks      (numeric, required) How many blocks are generated immediately.\\n\"\n-            \"2. maxtries     (numeric, optional) How many iterations to try (default = 1000000).\\n\"\n-            \"\\nResult:\\n\"\n-            \"[ blockhashes ]     (array) hashes of blocks generated\\n\"\n-            \"\\nExamples:\\n\"\n-            \"\\nGenerate 11 blocks\\n\"\n-            + HelpExampleCli(\"generate\", \"11\")\n-        );\n-\n-    int nGenerate = request.params[0].get_int();\n-    uint64_t nMaxTries = 1000000;\n-    if (request.params.size() > 1) {\n-        nMaxTries = request.params[1].get_int();\n-    }\n-\n-    std::shared_ptr<CReserveScript> coinbaseScript;\n-    GetMainSignals().ScriptForMining(coinbaseScript);\n-\n-    // If the keypool is exhausted, no script is returned at all.  Catch this.\n-    if (!coinbaseScript)\n-        throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n-\n-    //throw an error if no script was provided\n-    if (coinbaseScript->reserveScript.empty())\n-        throw JSONRPCError(RPC_INTERNAL_ERROR, \"No coinbase script available (mining requires a wallet)\");\n-\n-    return generateBlocks(coinbaseScript, nGenerate, nMaxTries, true);\n-}\n-\n UniValue generatetoaddress(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n@@ -198,7 +172,7 @@ UniValue generatetoaddress(const JSONRPCRequest& request)\n \n     int nGenerate = request.params[0].get_int();\n     uint64_t nMaxTries = 1000000;\n-    if (request.params.size() > 2) {\n+    if (!request.params[2].isNull()) {\n         nMaxTries = request.params[2].get_int();\n     }\n \n@@ -257,11 +231,12 @@ UniValue prioritisetransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() != 3)\n         throw std::runtime_error(\n-            \"prioritisetransaction <txid> <priority delta> <fee delta>\\n\"\n+            \"prioritisetransaction <txid> <dummy value> <fee delta>\\n\"\n             \"Accepts the transaction into mined blocks at a higher (or lower) priority\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"txid\\\"       (string, required) The transaction id.\\n\"\n-            \"2. priority_delta (numeric, optional) Fee-independent priority adjustment. Not supported, so must be zero or null.\\n\"\n+            \"2. dummy          (numeric, optional) API-Compatibility for previous API. Must be zero or null.\\n\"\n+            \"                  DEPRECATED. For forward compatibility use named arguments and omit this parameter.\\n\"\n             \"3. fee_delta      (numeric, required) The fee value (in satoshis) to add (or subtract, if negative).\\n\"\n             \"                  The fee is not actually paid, only the algorithm for selecting transactions into a block\\n\"\n             \"                  considers the transaction as it would have paid a higher (or lower) fee.\\n\"\n@@ -278,7 +253,7 @@ UniValue prioritisetransaction(const JSONRPCRequest& request)\n     CAmount nAmount = request.params[2].get_int64();\n \n     if (!(request.params[1].isNull() || request.params[1].get_real() == 0)) {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Priority is not supported, and adjustment thereof must be zero.\");\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Priority is no longer supported, dummy argument to prioritisetransaction must be 0.\");\n     }\n \n     mempool.PrioritiseTransaction(hash, nAmount);\n@@ -399,7 +374,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n     UniValue lpval = NullUniValue;\n     std::set<std::string> setClientRules;\n     int64_t nMaxVersionPreVB = -1;\n-    if (request.params.size() > 0)\n+    if (!request.params[0].isNull())\n     {\n         const UniValue& oparam = request.params[0].get_obj();\n         const UniValue& modeval = find_value(oparam, \"mode\");\n@@ -583,7 +558,7 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n         entry.push_back(Pair(\"hash\", tx.GetWitnessHash().GetHex()));\n \n         UniValue deps(UniValue::VARR);\n-        BOOST_FOREACH (const CTxIn &in, tx.vin)\n+        for (const CTxIn &in : tx.vin)\n         {\n             if (setTxIndex.count(in.prevout.hash))\n                 deps.push_back(setTxIndex[in.prevout.hash]);\n@@ -681,15 +656,16 @@ UniValue getblocktemplate(const JSONRPCRequest& request)\n     result.push_back(Pair(\"mutable\", aMutable));\n     result.push_back(Pair(\"noncerange\", \"00000000ffffffff\"));\n     int64_t nSigOpLimit = MAX_BLOCK_SIGOPS_COST;\n+    int64_t nSizeLimit = MAX_BLOCK_SERIALIZED_SIZE;\n     if (fPreSegWit) {\n         assert(nSigOpLimit % WITNESS_SCALE_FACTOR == 0);\n         nSigOpLimit /= WITNESS_SCALE_FACTOR;\n+        assert(nSizeLimit % WITNESS_SCALE_FACTOR == 0);\n+        nSizeLimit /= WITNESS_SCALE_FACTOR;\n     }\n     result.push_back(Pair(\"sigoplimit\", nSigOpLimit));\n-    if (fPreSegWit) {\n-        result.push_back(Pair(\"sizelimit\", (int64_t)MAX_BLOCK_BASE_SIZE));\n-    } else {\n-        result.push_back(Pair(\"sizelimit\", (int64_t)MAX_BLOCK_SERIALIZED_SIZE));\n+    result.push_back(Pair(\"sizelimit\", nSizeLimit));\n+    if (!fPreSegWit) {\n         result.push_back(Pair(\"weightlimit\", (int64_t)MAX_BLOCK_WEIGHT));\n     }\n     result.push_back(Pair(\"curtime\", pblock->GetBlockTime()));\n@@ -723,19 +699,16 @@ class submitblock_StateCatcher : public CValidationInterface\n \n UniValue submitblock(const JSONRPCRequest& request)\n {\n+    // We allow 2 arguments for compliance with BIP22. Argument 2 is ignored.\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n         throw std::runtime_error(\n-            \"submitblock \\\"hexdata\\\" ( \\\"jsonparametersobject\\\" )\\n\"\n+            \"submitblock \\\"hexdata\\\"  ( \\\"dummy\\\" )\\n\"\n             \"\\nAttempts to submit new block to network.\\n\"\n-            \"The 'jsonparametersobject' parameter is currently ignored.\\n\"\n             \"See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\\n\"\n \n             \"\\nArguments\\n\"\n             \"1. \\\"hexdata\\\"        (string, required) the hex-encoded block data to submit\\n\"\n-            \"2. \\\"parameters\\\"     (string, optional) object of optional parameters\\n\"\n-            \"    {\\n\"\n-            \"      \\\"workid\\\" : \\\"id\\\"    (string, optional) if the server provided a workid, it MUST be included with submissions\\n\"\n-            \"    }\\n\"\n+            \"2. \\\"dummy\\\"          (optional) dummy value, for compatibility with BIP22. This value is ignored.\\n\"\n             \"\\nResult:\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"submitblock\", \"\\\"mydata\\\"\")\n@@ -834,126 +807,162 @@ UniValue estimatesmartfee(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"estimatesmartfee nblocks (conservative)\\n\"\n+            \"estimatesmartfee conf_target (\\\"estimate_mode\\\")\\n\"\n             \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\n-            \"confirmation within nblocks blocks if possible and return the number of blocks\\n\"\n+            \"confirmation within conf_target blocks if possible and return the number of blocks\\n\"\n             \"for which the estimate is valid. Uses virtual transaction size as defined\\n\"\n             \"in BIP 141 (witness data is discounted).\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. nblocks       (numeric)\\n\"\n-            \"2. conservative  (bool, optional, default=true) Whether to return a more conservative estimate which\\n\"\n-            \"                 also satisfies a longer history. A conservative estimate potentially returns a higher\\n\"\n-            \"                 feerate and is more likely to be sufficient for the desired target, but is not as\\n\"\n-            \"                 responsive to short term drops in the prevailing fee market\\n\"\n+            \"1. conf_target     (numeric) Confirmation target in blocks (1 - 1008)\\n\"\n+            \"2. \\\"estimate_mode\\\" (string, optional, default=CONSERVATIVE) The fee estimate mode.\\n\"\n+            \"                   Whether to return a more conservative estimate which also satisfies\\n\"\n+            \"                   a longer history. A conservative estimate potentially returns a\\n\"\n+            \"                   higher feerate and is more likely to be sufficient for the desired\\n\"\n+            \"                   target, but is not as responsive to short term drops in the\\n\"\n+            \"                   prevailing fee market.  Must be one of:\\n\"\n+            \"       \\\"UNSET\\\" (defaults to CONSERVATIVE)\\n\"\n+            \"       \\\"ECONOMICAL\\\"\\n\"\n+            \"       \\\"CONSERVATIVE\\\"\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n-            \"  \\\"feerate\\\" : x.x,     (numeric) estimate fee-per-kilobyte (in BTC)\\n\"\n+            \"  \\\"feerate\\\" : x.x,     (numeric, optional) estimate fee-per-kilobyte (in BTC)\\n\"\n+            \"  \\\"errors\\\": [ str... ] (json array of strings, optional) Errors encountered during processing\\n\"\n             \"  \\\"blocks\\\" : n         (numeric) block number where estimate was found\\n\"\n             \"}\\n\"\n             \"\\n\"\n-            \"A negative value is returned if not enough transactions and blocks\\n\"\n+            \"The request target will be clamped between 2 and the highest target\\n\"\n+            \"fee estimation is able to return based on how long it has been running.\\n\"\n+            \"An error is returned if not enough transactions and blocks\\n\"\n             \"have been observed to make an estimate for any number of blocks.\\n\"\n-            \"However it will not return a value below the mempool reject fee.\\n\"\n             \"\\nExample:\\n\"\n             + HelpExampleCli(\"estimatesmartfee\", \"6\")\n             );\n \n-    RPCTypeCheck(request.params, {UniValue::VNUM});\n-\n-    int nBlocks = request.params[0].get_int();\n+    RPCTypeCheck(request.params, {UniValue::VNUM, UniValue::VSTR});\n+    RPCTypeCheckArgument(request.params[0], UniValue::VNUM);\n+    unsigned int conf_target = ParseConfirmTarget(request.params[0]);\n     bool conservative = true;\n     if (request.params.size() > 1 && !request.params[1].isNull()) {\n-        RPCTypeCheckArgument(request.params[1], UniValue::VBOOL);\n-        conservative = request.params[1].get_bool();\n+        FeeEstimateMode fee_mode;\n+        if (!FeeModeFromString(request.params[1].get_str(), fee_mode)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid estimate_mode parameter\");\n+        }\n+        if (fee_mode == FeeEstimateMode::ECONOMICAL) conservative = false;\n     }\n \n     UniValue result(UniValue::VOBJ);\n-    int answerFound;\n-    CFeeRate feeRate = ::feeEstimator.estimateSmartFee(nBlocks, &answerFound, ::mempool, conservative);\n-    result.push_back(Pair(\"feerate\", feeRate == CFeeRate(0) ? -1.0 : ValueFromAmount(feeRate.GetFeePerK())));\n-    result.push_back(Pair(\"blocks\", answerFound));\n+    UniValue errors(UniValue::VARR);\n+    FeeCalculation feeCalc;\n+    CFeeRate feeRate = ::feeEstimator.estimateSmartFee(conf_target, &feeCalc, conservative);\n+    if (feeRate != CFeeRate(0)) {\n+        result.push_back(Pair(\"feerate\", ValueFromAmount(feeRate.GetFeePerK())));\n+    } else {\n+        errors.push_back(\"Insufficient data or no feerate found\");\n+        result.push_back(Pair(\"errors\", errors));\n+    }\n+    result.push_back(Pair(\"blocks\", feeCalc.returnedTarget));\n     return result;\n }\n \n UniValue estimaterawfee(const JSONRPCRequest& request)\n {\n-    if (request.fHelp || request.params.size() < 1|| request.params.size() > 3)\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n-            \"estimaterawfee nblocks (threshold horizon)\\n\"\n+            \"estimaterawfee conf_target (threshold)\\n\"\n             \"\\nWARNING: This interface is unstable and may disappear or change!\\n\"\n             \"\\nWARNING: This is an advanced API call that is tightly coupled to the specific\\n\"\n             \"         implementation of fee estimation. The parameters it can be called with\\n\"\n             \"         and the results it returns will change if the internal implementation changes.\\n\"\n             \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\n-            \"confirmation within nblocks blocks if possible. Uses virtual transaction size as defined\\n\"\n-            \"in BIP 141 (witness data is discounted).\\n\"\n+            \"confirmation within conf_target blocks if possible. Uses virtual transaction size as\\n\"\n+            \"defined in BIP 141 (witness data is discounted).\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. nblocks     (numeric)\\n\"\n+            \"1. conf_target (numeric) Confirmation target in blocks (1 - 1008)\\n\"\n             \"2. threshold   (numeric, optional) The proportion of transactions in a given feerate range that must have been\\n\"\n-            \"               confirmed within nblocks in order to consider those feerates as high enough and proceed to check\\n\"\n+            \"               confirmed within conf_target in order to consider those feerates as high enough and proceed to check\\n\"\n             \"               lower buckets.  Default: 0.95\\n\"\n-            \"3. horizon     (numeric, optional) How long a history of estimates to consider. 0=short, 1=medium, 2=long.\\n\"\n-            \"               Default: 1\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n-            \"  \\\"feerate\\\" : x.x,        (numeric) estimate fee-per-kilobyte (in BTC)\\n\"\n-            \"  \\\"decay\\\" : x.x,          (numeric) exponential decay (per block) for historical moving average of confirmation data\\n\"\n-            \"  \\\"scale\\\" : x,            (numeric) The resolution of confirmation targets at this time horizon\\n\"\n-            \"  \\\"pass\\\" : {              (json object) information about the lowest range of feerates to succeed in meeting the threshold\\n\"\n-            \"      \\\"startrange\\\" : x.x,     (numeric) start of feerate range\\n\"\n-            \"      \\\"endrange\\\" : x.x,       (numeric) end of feerate range\\n\"\n-            \"      \\\"withintarget\\\" : x.x,   (numeric) number of txs over history horizon in the feerate range that were confirmed within target\\n\"\n-            \"      \\\"totalconfirmed\\\" : x.x, (numeric) number of txs over history horizon in the feerate range that were confirmed at any point\\n\"\n-            \"      \\\"inmempool\\\" : x.x,      (numeric) current number of txs in mempool in the feerate range unconfirmed for at least target blocks\\n\"\n-            \"      \\\"leftmempool\\\" : x.x,    (numeric) number of txs over history horizon in the feerate range that left mempool unconfirmed after target\\n\"\n-            \"  }\\n\"\n-            \"  \\\"fail\\\" : { ... }        (json object) information about the highest range of feerates to fail to meet the threshold\\n\"\n+            \"  \\\"short\\\" : {            (json object, optional) estimate for short time horizon\\n\"\n+            \"      \\\"feerate\\\" : x.x,        (numeric, optional) estimate fee-per-kilobyte (in BTC)\\n\"\n+            \"      \\\"decay\\\" : x.x,          (numeric) exponential decay (per block) for historical moving average of confirmation data\\n\"\n+            \"      \\\"scale\\\" : x,            (numeric) The resolution of confirmation targets at this time horizon\\n\"\n+            \"      \\\"pass\\\" : {              (json object, optional) information about the lowest range of feerates to succeed in meeting the threshold\\n\"\n+            \"          \\\"startrange\\\" : x.x,     (numeric) start of feerate range\\n\"\n+            \"          \\\"endrange\\\" : x.x,       (numeric) end of feerate range\\n\"\n+            \"          \\\"withintarget\\\" : x.x,   (numeric) number of txs over history horizon in the feerate range that were confirmed within target\\n\"\n+            \"          \\\"totalconfirmed\\\" : x.x, (numeric) number of txs over history horizon in the feerate range that were confirmed at any point\\n\"\n+            \"          \\\"inmempool\\\" : x.x,      (numeric) current number of txs in mempool in the feerate range unconfirmed for at least target blocks\\n\"\n+            \"          \\\"leftmempool\\\" : x.x,    (numeric) number of txs over history horizon in the feerate range that left mempool unconfirmed after target\\n\"\n+            \"      },\\n\"\n+            \"      \\\"fail\\\" : { ... },       (json object, optional) information about the highest range of feerates to fail to meet the threshold\\n\"\n+            \"      \\\"errors\\\":  [ str... ]   (json array of strings, optional) Errors encountered during processing\\n\"\n+            \"  },\\n\"\n+            \"  \\\"medium\\\" : { ... },    (json object, optional) estimate for medium time horizon\\n\"\n+            \"  \\\"long\\\" : { ... }       (json object) estimate for long time horizon\\n\"\n             \"}\\n\"\n             \"\\n\"\n-            \"A negative feerate is returned if no answer can be given.\\n\"\n+            \"Results are returned for any horizon which tracks blocks up to the confirmation target.\\n\"\n             \"\\nExample:\\n\"\n-            + HelpExampleCli(\"estimaterawfee\", \"6 0.9 1\")\n+            + HelpExampleCli(\"estimaterawfee\", \"6 0.9\")\n             );\n \n-    RPCTypeCheck(request.params, {UniValue::VNUM, UniValue::VNUM, UniValue::VNUM}, true);\n+    RPCTypeCheck(request.params, {UniValue::VNUM, UniValue::VNUM}, true);\n     RPCTypeCheckArgument(request.params[0], UniValue::VNUM);\n-    int nBlocks = request.params[0].get_int();\n+    unsigned int conf_target = ParseConfirmTarget(request.params[0]);\n     double threshold = 0.95;\n-    if (!request.params[1].isNull())\n+    if (!request.params[1].isNull()) {\n         threshold = request.params[1].get_real();\n-    FeeEstimateHorizon horizon = FeeEstimateHorizon::MED_HALFLIFE;\n-    if (!request.params[2].isNull()) {\n-        int horizonInt = request.params[2].get_int();\n-        if (horizonInt < 0 || horizonInt > 2) {\n-            throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid horizon for fee estimates\");\n+    }\n+    if (threshold < 0 || threshold > 1) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid threshold\");\n+    }\n+\n+    UniValue result(UniValue::VOBJ);\n+\n+    for (FeeEstimateHorizon horizon : {FeeEstimateHorizon::SHORT_HALFLIFE, FeeEstimateHorizon::MED_HALFLIFE, FeeEstimateHorizon::LONG_HALFLIFE}) {\n+        CFeeRate feeRate;\n+        EstimationResult buckets;\n+\n+        // Only output results for horizons which track the target\n+        if (conf_target > ::feeEstimator.HighestTargetTracked(horizon)) continue;\n+\n+        feeRate = ::feeEstimator.estimateRawFee(conf_target, threshold, horizon, &buckets);\n+        UniValue horizon_result(UniValue::VOBJ);\n+        UniValue errors(UniValue::VARR);\n+        UniValue passbucket(UniValue::VOBJ);\n+        passbucket.push_back(Pair(\"startrange\", round(buckets.pass.start)));\n+        passbucket.push_back(Pair(\"endrange\", round(buckets.pass.end)));\n+        passbucket.push_back(Pair(\"withintarget\", round(buckets.pass.withinTarget * 100.0) / 100.0));\n+        passbucket.push_back(Pair(\"totalconfirmed\", round(buckets.pass.totalConfirmed * 100.0) / 100.0));\n+        passbucket.push_back(Pair(\"inmempool\", round(buckets.pass.inMempool * 100.0) / 100.0));\n+        passbucket.push_back(Pair(\"leftmempool\", round(buckets.pass.leftMempool * 100.0) / 100.0));\n+        UniValue failbucket(UniValue::VOBJ);\n+        failbucket.push_back(Pair(\"startrange\", round(buckets.fail.start)));\n+        failbucket.push_back(Pair(\"endrange\", round(buckets.fail.end)));\n+        failbucket.push_back(Pair(\"withintarget\", round(buckets.fail.withinTarget * 100.0) / 100.0));\n+        failbucket.push_back(Pair(\"totalconfirmed\", round(buckets.fail.totalConfirmed * 100.0) / 100.0));\n+        failbucket.push_back(Pair(\"inmempool\", round(buckets.fail.inMempool * 100.0) / 100.0));\n+        failbucket.push_back(Pair(\"leftmempool\", round(buckets.fail.leftMempool * 100.0) / 100.0));\n+\n+        // CFeeRate(0) is used to indicate error as a return value from estimateRawFee\n+        if (feeRate != CFeeRate(0)) {\n+            horizon_result.push_back(Pair(\"feerate\", ValueFromAmount(feeRate.GetFeePerK())));\n+            horizon_result.push_back(Pair(\"decay\", buckets.decay));\n+            horizon_result.push_back(Pair(\"scale\", (int)buckets.scale));\n+            horizon_result.push_back(Pair(\"pass\", passbucket));\n+            // buckets.fail.start == -1 indicates that all buckets passed, there is no fail bucket to output\n+            if (buckets.fail.start != -1) horizon_result.push_back(Pair(\"fail\", failbucket));\n         } else {\n-            horizon = (FeeEstimateHorizon)horizonInt;\n+            // Output only information that is still meaningful in the event of error\n+            horizon_result.push_back(Pair(\"decay\", buckets.decay));\n+            horizon_result.push_back(Pair(\"scale\", (int)buckets.scale));\n+            horizon_result.push_back(Pair(\"fail\", failbucket));\n+            errors.push_back(\"Insufficient data or no feerate found which meets threshold\");\n+            horizon_result.push_back(Pair(\"errors\",errors));\n         }\n+        result.push_back(Pair(StringForFeeEstimateHorizon(horizon), horizon_result));\n     }\n-    UniValue result(UniValue::VOBJ);\n-    CFeeRate feeRate;\n-    EstimationResult buckets;\n-    feeRate = ::feeEstimator.estimateRawFee(nBlocks, threshold, horizon, &buckets);\n-\n-    result.push_back(Pair(\"feerate\", feeRate == CFeeRate(0) ? -1.0 : ValueFromAmount(feeRate.GetFeePerK())));\n-    result.push_back(Pair(\"decay\", buckets.decay));\n-    result.push_back(Pair(\"scale\", (int)buckets.scale));\n-    UniValue passbucket(UniValue::VOBJ);\n-    passbucket.push_back(Pair(\"startrange\", round(buckets.pass.start)));\n-    passbucket.push_back(Pair(\"endrange\", round(buckets.pass.end)));\n-    passbucket.push_back(Pair(\"withintarget\", round(buckets.pass.withinTarget * 100.0) / 100.0));\n-    passbucket.push_back(Pair(\"totalconfirmed\", round(buckets.pass.totalConfirmed * 100.0) / 100.0));\n-    passbucket.push_back(Pair(\"inmempool\", round(buckets.pass.inMempool * 100.0) / 100.0));\n-    passbucket.push_back(Pair(\"leftmempool\", round(buckets.pass.leftMempool * 100.0) / 100.0));\n-    result.push_back(Pair(\"pass\", passbucket));\n-    UniValue failbucket(UniValue::VOBJ);\n-    failbucket.push_back(Pair(\"startrange\", round(buckets.fail.start)));\n-    failbucket.push_back(Pair(\"endrange\", round(buckets.fail.end)));\n-    failbucket.push_back(Pair(\"withintarget\", round(buckets.fail.withinTarget * 100.0) / 100.0));\n-    failbucket.push_back(Pair(\"totalconfirmed\", round(buckets.fail.totalConfirmed * 100.0) / 100.0));\n-    failbucket.push_back(Pair(\"inmempool\", round(buckets.fail.inMempool * 100.0) / 100.0));\n-    failbucket.push_back(Pair(\"leftmempool\", round(buckets.fail.leftMempool * 100.0) / 100.0));\n-    result.push_back(Pair(\"fail\", failbucket));\n     return result;\n }\n \n@@ -962,17 +971,16 @@ static const CRPCCommand commands[] =\n   //  --------------------- ------------------------  -----------------------  ----------\n     { \"mining\",             \"getnetworkhashps\",       &getnetworkhashps,       true,  {\"nblocks\",\"height\"} },\n     { \"mining\",             \"getmininginfo\",          &getmininginfo,          true,  {} },\n-    { \"mining\",             \"prioritisetransaction\",  &prioritisetransaction,  true,  {\"txid\",\"priority_delta\",\"fee_delta\"} },\n+    { \"mining\",             \"prioritisetransaction\",  &prioritisetransaction,  true,  {\"txid\",\"dummy\",\"fee_delta\"} },\n     { \"mining\",             \"getblocktemplate\",       &getblocktemplate,       true,  {\"template_request\"} },\n-    { \"mining\",             \"submitblock\",            &submitblock,            true,  {\"hexdata\",\"parameters\"} },\n+    { \"mining\",             \"submitblock\",            &submitblock,            true,  {\"hexdata\",\"dummy\"} },\n \n-    { \"generating\",         \"generate\",               &generate,               true,  {\"nblocks\",\"maxtries\"} },\n     { \"generating\",         \"generatetoaddress\",      &generatetoaddress,      true,  {\"nblocks\",\"address\",\"maxtries\"} },\n \n     { \"util\",               \"estimatefee\",            &estimatefee,            true,  {\"nblocks\"} },\n-    { \"util\",               \"estimatesmartfee\",       &estimatesmartfee,       true,  {\"nblocks\", \"conservative\"} },\n+    { \"util\",               \"estimatesmartfee\",       &estimatesmartfee,       true,  {\"conf_target\", \"estimate_mode\"} },\n \n-    { \"hidden\",             \"estimaterawfee\",         &estimaterawfee,         true,  {\"nblocks\", \"threshold\", \"horizon\"} },\n+    { \"hidden\",             \"estimaterawfee\",         &estimaterawfee,         true,  {\"conf_target\", \"threshold\"} },\n };\n \n void RegisterMiningRPCCommands(CRPCTable &t)"
      },
      {
        "sha": "868d7002b5ff465f1c317cc6a5b01e723c5cd28d",
        "filename": "src/rpc/mining.h",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/mining.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/mining.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -0,0 +1,18 @@\n+// Copyright (c) 2017 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RPC_MINING_H\n+#define BITCOIN_RPC_MINING_H\n+\n+#include \"script/script.h\"\n+\n+#include <univalue.h>\n+\n+/** Generate blocks (mine) */\n+UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript);\n+\n+/** Check bounds on a command line confirm target */\n+unsigned int ParseConfirmTarget(const UniValue& value);\n+\n+#endif"
      },
      {
        "sha": "f3c86038a3e4c92381ee2c5944d0a82c6f84a084",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 5,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -21,6 +21,7 @@\n #include \"wallet/wallet.h\"\n #include \"wallet/walletdb.h\"\n #endif\n+#include \"warnings.h\"\n \n #include <stdint.h>\n #ifdef HAVE_MALLOC_INFO\n@@ -50,22 +51,23 @@ UniValue getinfo(const JSONRPCRequest& request)\n             \"\\nDEPRECATED. Returns an object containing various state info.\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n+            \"  \\\"deprecation-warning\\\": \\\"...\\\" (string) warning that the getinfo command is deprecated and will be removed in 0.16\\n\"\n             \"  \\\"version\\\": xxxxx,           (numeric) the server version\\n\"\n             \"  \\\"protocolversion\\\": xxxxx,   (numeric) the protocol version\\n\"\n             \"  \\\"walletversion\\\": xxxxx,     (numeric) the wallet version\\n\"\n             \"  \\\"balance\\\": xxxxxxx,         (numeric) the total bitcoin balance of the wallet\\n\"\n             \"  \\\"blocks\\\": xxxxxx,           (numeric) the current number of blocks processed in the server\\n\"\n             \"  \\\"timeoffset\\\": xxxxx,        (numeric) the time offset\\n\"\n             \"  \\\"connections\\\": xxxxx,       (numeric) the number of connections\\n\"\n-            \"  \\\"proxy\\\": \\\"host:port\\\",     (string, optional) the proxy used by the server\\n\"\n+            \"  \\\"proxy\\\": \\\"host:port\\\",       (string, optional) the proxy used by the server\\n\"\n             \"  \\\"difficulty\\\": xxxxxx,       (numeric) the current difficulty\\n\"\n             \"  \\\"testnet\\\": true|false,      (boolean) if the server is using testnet or not\\n\"\n             \"  \\\"keypoololdest\\\": xxxxxx,    (numeric) the timestamp (seconds since Unix epoch) of the oldest pre-generated key in the key pool\\n\"\n             \"  \\\"keypoolsize\\\": xxxx,        (numeric) how many new keys are pre-generated\\n\"\n             \"  \\\"unlocked_until\\\": ttt,      (numeric) the timestamp in seconds since epoch (midnight Jan 1 1970 GMT) that the wallet is unlocked for transfers, or 0 if the wallet is locked\\n\"\n             \"  \\\"paytxfee\\\": x.xxxx,         (numeric) the transaction fee set in \" + CURRENCY_UNIT + \"/kB\\n\"\n             \"  \\\"relayfee\\\": x.xxxx,         (numeric) minimum relay fee for transactions in \" + CURRENCY_UNIT + \"/kB\\n\"\n-            \"  \\\"errors\\\": \\\"...\\\"           (string) any error messages\\n\"\n+            \"  \\\"errors\\\": \\\"...\\\"             (string) any error messages\\n\"\n             \"}\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"getinfo\", \"\")\n@@ -84,6 +86,8 @@ UniValue getinfo(const JSONRPCRequest& request)\n     GetProxy(NET_IPV4, proxy);\n \n     UniValue obj(UniValue::VOBJ);\n+    obj.push_back(Pair(\"deprecation-warning\", \"WARNING: getinfo is deprecated and will be fully removed in 0.16.\"\n+        \" Projects should transition to using getblockchaininfo, getnetworkinfo, and getwalletinfo before upgrading to 0.16\"));\n     obj.push_back(Pair(\"version\", CLIENT_VERSION));\n     obj.push_back(Pair(\"protocolversion\", PROTOCOL_VERSION));\n #ifdef ENABLE_WALLET\n@@ -147,7 +151,7 @@ class DescribeAddressVisitor : public boost::static_visitor<UniValue>\n             obj.push_back(Pair(\"script\", GetTxnOutputType(whichType)));\n             obj.push_back(Pair(\"hex\", HexStr(subscript.begin(), subscript.end())));\n             UniValue a(UniValue::VARR);\n-            BOOST_FOREACH(const CTxDestination& addr, addresses)\n+            for (const CTxDestination& addr : addresses)\n                 a.push_back(CBitcoinAddress(addr).ToString());\n             obj.push_back(Pair(\"addresses\", a));\n             if (whichType == TX_MULTISIG)\n@@ -174,6 +178,14 @@ UniValue validateaddress(const JSONRPCRequest& request)\n             \"  \\\"ismine\\\" : true|false,        (boolean) If the address is yours or not\\n\"\n             \"  \\\"iswatchonly\\\" : true|false,   (boolean) If the address is watchonly\\n\"\n             \"  \\\"isscript\\\" : true|false,      (boolean) If the key is a script\\n\"\n+            \"  \\\"script\\\" : \\\"type\\\"             (string, optional) The output script type. Possible types: nonstandard, pubkey, pubkeyhash, scripthash, multisig, nulldata, witness_v0_keyhash, witness_v0_scripthash\\n\"\n+            \"  \\\"hex\\\" : \\\"hex\\\",                (string, optional) The redeemscript for the p2sh address\\n\"\n+            \"  \\\"addresses\\\"                   (string, optional) Array of addresses associated with the known redeemscript\\n\"\n+            \"    [\\n\"\n+            \"      \\\"address\\\"\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+            \"  \\\"sigsrequired\\\" : xxxxx        (numeric, optional) Number of signatures required to spend multisig output\\n\"\n             \"  \\\"pubkey\\\" : \\\"publickeyhex\\\",    (string) The hex value of the raw public key\\n\"\n             \"  \\\"iscompressed\\\" : true|false,  (boolean) If the address is compressed\\n\"\n             \"  \\\"account\\\" : \\\"account\\\"         (string) DEPRECATED. The account associated with the address, \\\"\\\" is the default account\\n\"\n@@ -210,8 +222,8 @@ UniValue validateaddress(const JSONRPCRequest& request)\n \n #ifdef ENABLE_WALLET\n         isminetype mine = pwallet ? IsMine(*pwallet, dest) : ISMINE_NO;\n-        ret.push_back(Pair(\"ismine\", (mine & ISMINE_SPENDABLE) ? true : false));\n-        ret.push_back(Pair(\"iswatchonly\", (mine & ISMINE_WATCH_ONLY) ? true: false));\n+        ret.push_back(Pair(\"ismine\", bool(mine & ISMINE_SPENDABLE)));\n+        ret.push_back(Pair(\"iswatchonly\", bool(mine & ISMINE_WATCH_ONLY)));\n         UniValue detail = boost::apply_visitor(DescribeAddressVisitor(pwallet), dest);\n         ret.pushKVs(detail);\n         if (pwallet && pwallet->mapAddressBook.count(dest)) {"
      },
      {
        "sha": "b4d6795e6261a8fce14f8c7d91f64ff4aafa685b",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 20,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -18,8 +18,7 @@\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n #include \"version.h\"\n-\n-#include <boost/foreach.hpp>\n+#include \"warnings.h\"\n \n #include <univalue.h>\n \n@@ -75,7 +74,7 @@ UniValue getpeerinfo(const JSONRPCRequest& request)\n             \"[\\n\"\n             \"  {\\n\"\n             \"    \\\"id\\\": n,                   (numeric) Peer index\\n\"\n-            \"    \\\"addr\\\":\\\"host:port\\\",      (string) The ip address and port of the peer\\n\"\n+            \"    \\\"addr\\\":\\\"host:port\\\",      (string) The IP address and port of the peer\\n\"\n             \"    \\\"addrbind\\\":\\\"ip:port\\\",    (string) Bind address of the connection to the peer\\n\"\n             \"    \\\"addrlocal\\\":\\\"ip:port\\\",   (string) Local address as reported by the peer\\n\"\n             \"    \\\"services\\\":\\\"xxxxxxxxxxxxxxxx\\\",   (string) The services offered\\n\"\n@@ -126,7 +125,7 @@ UniValue getpeerinfo(const JSONRPCRequest& request)\n \n     UniValue ret(UniValue::VARR);\n \n-    BOOST_FOREACH(const CNodeStats& stats, vstats) {\n+    for (const CNodeStats& stats : vstats) {\n         UniValue obj(UniValue::VOBJ);\n         CNodeStateStats statestats;\n         bool fStateStats = GetNodeStateStats(stats.nodeid, statestats);\n@@ -163,22 +162,22 @@ UniValue getpeerinfo(const JSONRPCRequest& request)\n             obj.push_back(Pair(\"synced_headers\", statestats.nSyncHeight));\n             obj.push_back(Pair(\"synced_blocks\", statestats.nCommonHeight));\n             UniValue heights(UniValue::VARR);\n-            BOOST_FOREACH(int height, statestats.vHeightInFlight) {\n+            for (int height : statestats.vHeightInFlight) {\n                 heights.push_back(height);\n             }\n             obj.push_back(Pair(\"inflight\", heights));\n         }\n         obj.push_back(Pair(\"whitelisted\", stats.fWhitelisted));\n \n         UniValue sendPerMsgCmd(UniValue::VOBJ);\n-        BOOST_FOREACH(const mapMsgCmdSize::value_type &i, stats.mapSendBytesPerMsgCmd) {\n+        for (const mapMsgCmdSize::value_type &i : stats.mapSendBytesPerMsgCmd) {\n             if (i.second > 0)\n                 sendPerMsgCmd.push_back(Pair(i.first, i.second));\n         }\n         obj.push_back(Pair(\"bytessent_per_msg\", sendPerMsgCmd));\n \n         UniValue recvPerMsgCmd(UniValue::VOBJ);\n-        BOOST_FOREACH(const mapMsgCmdSize::value_type &i, stats.mapRecvBytesPerMsgCmd) {\n+        for (const mapMsgCmdSize::value_type &i : stats.mapRecvBytesPerMsgCmd) {\n             if (i.second > 0)\n                 recvPerMsgCmd.push_back(Pair(i.first, i.second));\n         }\n@@ -199,7 +198,7 @@ UniValue addnode(const JSONRPCRequest& request)\n         (strCommand != \"onetry\" && strCommand != \"add\" && strCommand != \"remove\"))\n         throw std::runtime_error(\n             \"addnode \\\"node\\\" \\\"add|remove|onetry\\\"\\n\"\n-            \"\\nAttempts add or remove a node from the addnode list.\\n\"\n+            \"\\nAttempts to add or remove a node from the addnode list.\\n\"\n             \"Or try a connection to a node once.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"node\\\"     (string, required) The node (see getpeerinfo for nodes)\\n\"\n@@ -290,7 +289,7 @@ UniValue getaddednodeinfo(const JSONRPCRequest& request)\n             \"\\nResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n-            \"    \\\"addednode\\\" : \\\"192.168.0.201\\\",   (string) The node ip address or name (as provided to addnode)\\n\"\n+            \"    \\\"addednode\\\" : \\\"192.168.0.201\\\",   (string) The node IP address or name (as provided to addnode)\\n\"\n             \"    \\\"connected\\\" : true|false,          (boolean) If connected\\n\"\n             \"    \\\"addresses\\\" : [                    (list of objects) Only when connected = true\\n\"\n             \"       {\\n\"\n@@ -302,17 +301,16 @@ UniValue getaddednodeinfo(const JSONRPCRequest& request)\n             \"  ,...\\n\"\n             \"]\\n\"\n             \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getaddednodeinfo\", \"true\")\n-            + HelpExampleCli(\"getaddednodeinfo\", \"true \\\"192.168.0.201\\\"\")\n-            + HelpExampleRpc(\"getaddednodeinfo\", \"true, \\\"192.168.0.201\\\"\")\n+            + HelpExampleCli(\"getaddednodeinfo\", \"\\\"192.168.0.201\\\"\")\n+            + HelpExampleRpc(\"getaddednodeinfo\", \"\\\"192.168.0.201\\\"\")\n         );\n \n     if(!g_connman)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n \n     std::vector<AddedNodeInfo> vInfo = g_connman->GetAddedNodeInfo();\n \n-    if (request.params.size() == 1) {\n+    if (request.params.size() == 1 && !request.params[0].isNull()) {\n         bool found = false;\n         for (const AddedNodeInfo& info : vInfo) {\n             if (info.strAddedNode == request.params[0].get_str()) {\n@@ -397,7 +395,7 @@ static UniValue GetNetworksInfo()\n     for(int n=0; n<NET_MAX; ++n)\n     {\n         enum Network network = static_cast<enum Network>(n);\n-        if(network == NET_UNROUTABLE)\n+        if(network == NET_UNROUTABLE || network == NET_INTERNAL)\n             continue;\n         proxyType proxy;\n         UniValue obj(UniValue::VOBJ);\n@@ -474,7 +472,7 @@ UniValue getnetworkinfo(const JSONRPCRequest& request)\n     UniValue localAddresses(UniValue::VARR);\n     {\n         LOCK(cs_mapLocalHost);\n-        BOOST_FOREACH(const PAIRTYPE(CNetAddr, LocalServiceInfo) &item, mapLocalHost)\n+        for (const std::pair<CNetAddr, LocalServiceInfo> &item : mapLocalHost)\n         {\n             UniValue rec(UniValue::VOBJ);\n             rec.push_back(Pair(\"address\", item.first.ToString()));\n@@ -497,12 +495,12 @@ UniValue setban(const JSONRPCRequest& request)\n         (strCommand != \"add\" && strCommand != \"remove\"))\n         throw std::runtime_error(\n                             \"setban \\\"subnet\\\" \\\"add|remove\\\" (bantime) (absolute)\\n\"\n-                            \"\\nAttempts add or remove a IP/Subnet from the banned list.\\n\"\n+                            \"\\nAttempts to add or remove an IP/Subnet from the banned list.\\n\"\n                             \"\\nArguments:\\n\"\n-                            \"1. \\\"subnet\\\"       (string, required) The IP/Subnet (see getpeerinfo for nodes ip) with a optional netmask (default is /32 = single ip)\\n\"\n-                            \"2. \\\"command\\\"      (string, required) 'add' to add a IP/Subnet to the list, 'remove' to remove a IP/Subnet from the list\\n\"\n-                            \"3. \\\"bantime\\\"      (numeric, optional) time in seconds how long (or until when if [absolute] is set) the ip is banned (0 or empty means using the default time of 24h which can also be overwritten by the -bantime startup argument)\\n\"\n-                            \"4. \\\"absolute\\\"     (boolean, optional) If set, the bantime must be a absolute timestamp in seconds since epoch (Jan 1 1970 GMT)\\n\"\n+                            \"1. \\\"subnet\\\"       (string, required) The IP/Subnet (see getpeerinfo for nodes IP) with an optional netmask (default is /32 = single IP)\\n\"\n+                            \"2. \\\"command\\\"      (string, required) 'add' to add an IP/Subnet to the list, 'remove' to remove an IP/Subnet from the list\\n\"\n+                            \"3. \\\"bantime\\\"      (numeric, optional) time in seconds how long (or until when if [absolute] is set) the IP is banned (0 or empty means using the default time of 24h which can also be overwritten by the -bantime startup argument)\\n\"\n+                            \"4. \\\"absolute\\\"     (boolean, optional) If set, the bantime must be an absolute timestamp in seconds since epoch (Jan 1 1970 GMT)\\n\"\n                             \"\\nExamples:\\n\"\n                             + HelpExampleCli(\"setban\", \"\\\"192.168.0.6\\\" \\\"add\\\" 86400\")\n                             + HelpExampleCli(\"setban\", \"\\\"192.168.0.0/24\\\" \\\"add\\\"\")"
      },
      {
        "sha": "b967f2dbf850b33b1da5a519d6cc723fffab12ac",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 119,
        "deletions": 49,
        "changes": 168,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -137,7 +137,7 @@ UniValue getrawtransaction(const JSONRPCRequest& request)\n \n     // Accept either a bool (true) or a num (>=1) to indicate verbose output.\n     bool fVerbose = false;\n-    if (request.params.size() > 1) {\n+    if (!request.params[1].isNull()) {\n         if (request.params[1].isNum()) {\n             if (request.params[1].get_int() != 0) {\n                 fVerbose = true;\n@@ -211,16 +211,20 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n     CBlockIndex* pblockindex = NULL;\n \n     uint256 hashBlock;\n-    if (request.params.size() > 1)\n+    if (!request.params[1].isNull())\n     {\n         hashBlock = uint256S(request.params[1].get_str());\n         if (!mapBlockIndex.count(hashBlock))\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         pblockindex = mapBlockIndex[hashBlock];\n     } else {\n-        const Coin& coin = AccessByTxid(*pcoinsTip, oneTxid);\n-        if (!coin.IsSpent() && coin.nHeight > 0 && coin.nHeight <= chainActive.Height()) {\n-            pblockindex = chainActive[coin.nHeight];\n+        // Loop through txids and try to find which block they're in. Exit loop once a block is found.\n+        for (const auto& tx : setTxids) {\n+            const Coin& coin = AccessByTxid(*pcoinsTip, tx);\n+            if (!coin.IsSpent()) {\n+                pblockindex = chainActive[coin.nHeight];\n+                break;\n+            }\n         }\n     }\n \n@@ -243,7 +247,7 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n         if (setTxids.count(tx->GetHash()))\n             ntxFound++;\n     if (ntxFound != setTxids.size())\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"(Not all) transactions not found in specified block\");\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Not all transactions found in specified or retrieved block\");\n \n     CDataStream ssMB(SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\n     CMerkleBlock mb(block, setTxids);\n@@ -281,7 +285,7 @@ UniValue verifytxoutproof(const JSONRPCRequest& request)\n     if (!mapBlockIndex.count(merkleBlock.header.GetHash()) || !chainActive.Contains(mapBlockIndex[merkleBlock.header.GetHash()]))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\n \n-    BOOST_FOREACH(const uint256& hash, vMatch)\n+    for (const uint256& hash : vMatch)\n         res.push_back(hash.GetHex());\n     return res;\n }\n@@ -290,7 +294,7 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n {\n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n         throw std::runtime_error(\n-            \"createrawtransaction [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] {\\\"address\\\":amount,\\\"data\\\":\\\"hex\\\",...} ( locktime ) ( optintorbf )\\n\"\n+            \"createrawtransaction [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] {\\\"address\\\":amount,\\\"data\\\":\\\"hex\\\",...} ( locktime ) ( replaceable )\\n\"\n             \"\\nCreate a transaction spending the given inputs and creating new outputs.\\n\"\n             \"Outputs can be addresses or data.\\n\"\n             \"Returns hex-encoded raw transaction.\\n\"\n@@ -314,7 +318,8 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n             \"      ,...\\n\"\n             \"    }\\n\"\n             \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n-            \"4. optintorbf                (boolean, optional, default=false) Allow this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n+            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n+            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"transaction\\\"              (string) hex string of the transaction\\n\"\n \n@@ -383,7 +388,7 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n \n     std::set<CBitcoinAddress> setAddress;\n     std::vector<std::string> addrList = sendTo.getKeys();\n-    BOOST_FOREACH(const std::string& name_, addrList) {\n+    for (const std::string& name_ : addrList) {\n \n         if (name_ == \"data\") {\n             std::vector<unsigned char> data = ParseHexV(sendTo[name_].getValStr(),\"Data\");\n@@ -407,8 +412,8 @@ UniValue createrawtransaction(const JSONRPCRequest& request)\n         }\n     }\n \n-    if (request.params.size() > 3 && rbfOptIn != SignalsOptInRBF(rawTx)) {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter combination: Sequence number(s) contradict optintorbf option\");\n+    if (!request.params[3].isNull() && rbfOptIn != SignalsOptInRBF(rawTx)) {\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter combination: Sequence number(s) contradict replaceable option\");\n     }\n \n     return EncodeHexTx(rawTx);\n@@ -549,6 +554,93 @@ static void TxInErrorToJSON(const CTxIn& txin, UniValue& vErrorsRet, const std::\n     vErrorsRet.push_back(entry);\n }\n \n+UniValue combinerawtransaction(const JSONRPCRequest& request)\n+{\n+\n+    if (request.fHelp || request.params.size() != 1)\n+        throw std::runtime_error(\n+            \"combinerawtransaction [\\\"hexstring\\\",...]\\n\"\n+            \"\\nCombine multiple partially signed transactions into one transaction.\\n\"\n+            \"The combined transaction may be another partially signed transaction or a \\n\"\n+            \"fully signed transaction.\"\n+\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"txs\\\"         (string) A json array of hex strings of partially signed transactions\\n\"\n+            \"    [\\n\"\n+            \"      \\\"hexstring\\\"     (string) A transaction hash\\n\"\n+            \"      ,...\\n\"\n+            \"    ]\\n\"\n+\n+            \"\\nResult:\\n\"\n+            \"\\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded raw transaction with signature(s)\\n\"\n+\n+            \"\\nExamples:\\n\"\n+            + HelpExampleCli(\"combinerawtransaction\", \"[\\\"myhex1\\\", \\\"myhex2\\\", \\\"myhex3\\\"]\")\n+        );\n+\n+\n+    UniValue txs = request.params[0].get_array();\n+    std::vector<CMutableTransaction> txVariants(txs.size());\n+\n+    for (unsigned int idx = 0; idx < txs.size(); idx++) {\n+        if (!DecodeHexTx(txVariants[idx], txs[idx].get_str(), true)) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed for tx %d\", idx));\n+        }\n+    }\n+\n+    if (txVariants.empty()) {\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Missing transactions\");\n+    }\n+\n+    // mergedTx will end up with all the signatures; it\n+    // starts as a clone of the rawtx:\n+    CMutableTransaction mergedTx(txVariants[0]);\n+\n+    // Fetch previous transactions (inputs):\n+    CCoinsView viewDummy;\n+    CCoinsViewCache view(&viewDummy);\n+    {\n+        LOCK(cs_main);\n+        LOCK(mempool.cs);\n+        CCoinsViewCache &viewChain = *pcoinsTip;\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n+\n+        for (const CTxIn& txin : mergedTx.vin) {\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n+        }\n+\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n+    }\n+\n+    // Use CTransaction for the constant parts of the\n+    // transaction to avoid rehashing.\n+    const CTransaction txConst(mergedTx);\n+    // Sign what we can:\n+    for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n+        CTxIn& txin = mergedTx.vin[i];\n+        const Coin& coin = view.AccessCoin(txin.prevout);\n+        if (coin.IsSpent()) {\n+            throw JSONRPCError(RPC_VERIFY_ERROR, \"Input not found or already spent\");\n+        }\n+        const CScript& prevPubKey = coin.out.scriptPubKey;\n+        const CAmount& amount = coin.out.nValue;\n+\n+        SignatureData sigdata;\n+\n+        // ... and merge in other signatures:\n+        for (const CMutableTransaction& txv : txVariants) {\n+            if (txv.vin.size() > i) {\n+                sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(txv, i));\n+            }\n+        }\n+\n+        UpdateTransaction(mergedTx, i, sigdata);\n+    }\n+\n+    return EncodeHexTx(mergedTx);\n+}\n+\n UniValue signrawtransaction(const JSONRPCRequest& request)\n {\n #ifdef ENABLE_WALLET\n@@ -621,26 +713,9 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n #endif\n     RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR, UniValue::VARR, UniValue::VSTR}, true);\n \n-    std::vector<unsigned char> txData(ParseHexV(request.params[0], \"argument 1\"));\n-    CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n-    std::vector<CMutableTransaction> txVariants;\n-    while (!ssData.empty()) {\n-        try {\n-            CMutableTransaction tx;\n-            ssData >> tx;\n-            txVariants.push_back(tx);\n-        }\n-        catch (const std::exception&) {\n-            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n-        }\n-    }\n-\n-    if (txVariants.empty())\n-        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Missing transaction\");\n-\n-    // mergedTx will end up with all the signatures; it\n-    // starts as a clone of the rawtx:\n-    CMutableTransaction mergedTx(txVariants[0]);\n+    CMutableTransaction mtx;\n+    if (!DecodeHexTx(mtx, request.params[0].get_str(), true))\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n \n     // Fetch previous transactions (inputs):\n     CCoinsView viewDummy;\n@@ -651,7 +726,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n         CCoinsViewMemPool viewMempool(&viewChain, mempool);\n         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n \n-        BOOST_FOREACH(const CTxIn& txin, mergedTx.vin) {\n+        for (const CTxIn& txin : mtx.vin) {\n             view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n         }\n \n@@ -776,10 +851,10 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n \n     // Use CTransaction for the constant parts of the\n     // transaction to avoid rehashing.\n-    const CTransaction txConst(mergedTx);\n+    const CTransaction txConst(mtx);\n     // Sign what we can:\n-    for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n-        CTxIn& txin = mergedTx.vin[i];\n+    for (unsigned int i = 0; i < mtx.vin.size(); i++) {\n+        CTxIn& txin = mtx.vin[i];\n         const Coin& coin = view.AccessCoin(txin.prevout);\n         if (coin.IsSpent()) {\n             TxInErrorToJSON(txin, vErrors, \"Input not found or already spent\");\n@@ -790,17 +865,11 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n \n         SignatureData sigdata;\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n-        if (!fHashSingle || (i < mergedTx.vout.size()))\n-            ProduceSignature(MutableTransactionSignatureCreator(&keystore, &mergedTx, i, amount, nHashType), prevPubKey, sigdata);\n+        if (!fHashSingle || (i < mtx.vout.size()))\n+            ProduceSignature(MutableTransactionSignatureCreator(&keystore, &mtx, i, amount, nHashType), prevPubKey, sigdata);\n+        sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(mtx, i));\n \n-        // ... and merge in other signatures:\n-        BOOST_FOREACH(const CMutableTransaction& txv, txVariants) {\n-            if (txv.vin.size() > i) {\n-                sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(txv, i));\n-            }\n-        }\n-\n-        UpdateTransaction(mergedTx, i, sigdata);\n+        UpdateTransaction(mtx, i, sigdata);\n \n         ScriptError serror = SCRIPT_ERR_OK;\n         if (!VerifyScript(txin.scriptSig, prevPubKey, &txin.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&txConst, i, amount), &serror)) {\n@@ -810,7 +879,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n     bool fComplete = vErrors.empty();\n \n     UniValue result(UniValue::VOBJ);\n-    result.push_back(Pair(\"hex\", EncodeHexTx(mergedTx)));\n+    result.push_back(Pair(\"hex\", EncodeHexTx(mtx)));\n     result.push_back(Pair(\"complete\", fComplete));\n     if (!vErrors.empty()) {\n         result.push_back(Pair(\"errors\", vErrors));\n@@ -852,7 +921,6 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n     CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n     const uint256& hashTx = tx->GetHash();\n \n-    bool fLimitFree = true;\n     CAmount nMaxRawTxFee = maxTxFee;\n     if (request.params.size() > 1 && request.params[1].get_bool())\n         nMaxRawTxFee = 0;\n@@ -868,6 +936,7 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n         // push to local node and sync with wallets\n         CValidationState state;\n         bool fMissingInputs;\n+        bool fLimitFree = true;\n         if (!AcceptToMemoryPool(mempool, state, std::move(tx), fLimitFree, &fMissingInputs, NULL, false, nMaxRawTxFee)) {\n             if (state.IsInvalid()) {\n                 throw JSONRPCError(RPC_TRANSACTION_REJECTED, strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason()));\n@@ -896,10 +965,11 @@ static const CRPCCommand commands[] =\n { //  category              name                      actor (function)         okSafeMode\n   //  --------------------- ------------------------  -----------------------  ----------\n     { \"rawtransactions\",    \"getrawtransaction\",      &getrawtransaction,      true,  {\"txid\",\"verbose\"} },\n-    { \"rawtransactions\",    \"createrawtransaction\",   &createrawtransaction,   true,  {\"inputs\",\"outputs\",\"locktime\"} },\n+    { \"rawtransactions\",    \"createrawtransaction\",   &createrawtransaction,   true,  {\"inputs\",\"outputs\",\"locktime\",\"replaceable\"} },\n     { \"rawtransactions\",    \"decoderawtransaction\",   &decoderawtransaction,   true,  {\"hexstring\"} },\n     { \"rawtransactions\",    \"decodescript\",           &decodescript,           true,  {\"hexstring\"} },\n     { \"rawtransactions\",    \"sendrawtransaction\",     &sendrawtransaction,     false, {\"hexstring\",\"allowhighfees\"} },\n+    { \"rawtransactions\",    \"combinerawtransaction\",  &combinerawtransaction,  true,  {\"txs\"} },\n     { \"rawtransactions\",    \"signrawtransaction\",     &signrawtransaction,     false, {\"hexstring\",\"prevtxs\",\"privkeys\",\"sighashtype\"} }, /* uses wallet if enabled */\n \n     { \"blockchain\",         \"gettxoutproof\",          &gettxoutproof,          true,  {\"txids\", \"blockhash\"} },"
      },
      {
        "sha": "63e4e9c630be3a0f9e271b64768f10f52e84f40c",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 6,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -17,10 +17,7 @@\n #include <univalue.h>\n \n #include <boost/bind.hpp>\n-#include <boost/foreach.hpp>\n-#include <boost/shared_ptr.hpp>\n #include <boost/signals2/signal.hpp>\n-#include <boost/thread.hpp>\n #include <boost/algorithm/string/case_conv.hpp> // for to_upper()\n #include <boost/algorithm/string/classification.hpp>\n #include <boost/algorithm/string/split.hpp>\n@@ -64,7 +61,7 @@ void RPCTypeCheck(const UniValue& params,\n                   bool fAllowNull)\n {\n     unsigned int i = 0;\n-    BOOST_FOREACH(UniValue::VType t, typesExpected)\n+    for (UniValue::VType t : typesExpected)\n     {\n         if (params.size() <= i)\n             break;\n@@ -103,7 +100,7 @@ void RPCTypeCheckObj(const UniValue& o,\n \n     if (fStrict)\n     {\n-        BOOST_FOREACH(const std::string& k, o.getKeys())\n+        for (const std::string& k : o.getKeys())\n         {\n             if (typesExpected.count(k) == 0)\n             {\n@@ -186,7 +183,7 @@ std::string CRPCTable::help(const std::string& strCommand, const JSONRPCRequest&\n     jreq.fHelp = true;\n     jreq.params = UniValue();\n \n-    BOOST_FOREACH(const PAIRTYPE(std::string, const CRPCCommand*)& command, vCommands)\n+    for (const std::pair<std::string, const CRPCCommand*>& command : vCommands)\n     {\n         const CRPCCommand *pcmd = command.second;\n         std::string strMethod = pcmd->name;\n@@ -260,6 +257,22 @@ UniValue stop(const JSONRPCRequest& jsonRequest)\n     return \"Bitcoin server stopping\";\n }\n \n+UniValue uptime(const JSONRPCRequest& jsonRequest)\n+{\n+    if (jsonRequest.fHelp || jsonRequest.params.size() > 1)\n+        throw std::runtime_error(\n+                \"uptime\\n\"\n+                        \"\\nReturns the total uptime of the server.\\n\"\n+                        \"\\nResult:\\n\"\n+                        \"ttt        (numeric) The number of seconds that the server has been running\\n\"\n+                        \"\\nExamples:\\n\"\n+                + HelpExampleCli(\"uptime\", \"\")\n+                + HelpExampleRpc(\"uptime\", \"\")\n+        );\n+\n+    return GetTime() - GetStartupTime();\n+}\n+\n /**\n  * Call Table\n  */\n@@ -269,6 +282,7 @@ static const CRPCCommand vRPCCommands[] =\n     /* Overall control/query calls */\n     { \"control\",            \"help\",                   &help,                   true,  {\"command\"}  },\n     { \"control\",            \"stop\",                   &stop,                   true,  {}  },\n+    { \"control\",            \"uptime\",                 &uptime,                 true,  {}  },\n };\n \n CRPCTable::CRPCTable()"
      },
      {
        "sha": "b20c8277274ac0df9d16d01e36f3b875298761d0",
        "filename": "src/rpc/server.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/server.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/rpc/server.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -28,9 +28,6 @@ namespace RPCServer\n     void OnPreCommand(std::function<void (const CRPCCommand&)> slot);\n }\n \n-class CBlockIndex;\n-class CNetAddr;\n-\n /** Wrapper for UniValue::VType, which includes typeAny:\n  * Used to denote don't care type. Only used by RPCTypeCheckObj */\n struct UniValueType {"
      },
      {
        "sha": "36a6d5110d940dd973562324a863c760eb3c76c2",
        "filename": "src/scheduler.cpp",
        "status": "modified",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/scheduler.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/scheduler.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scheduler.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -139,3 +139,69 @@ size_t CScheduler::getQueueInfo(boost::chrono::system_clock::time_point &first,\n     }\n     return result;\n }\n+\n+bool CScheduler::AreThreadsServicingQueue() const {\n+    return nThreadsServicingQueue;\n+}\n+\n+\n+void SingleThreadedSchedulerClient::MaybeScheduleProcessQueue() {\n+    {\n+        LOCK(m_cs_callbacks_pending);\n+        // Try to avoid scheduling too many copies here, but if we\n+        // accidentally have two ProcessQueue's scheduled at once its\n+        // not a big deal.\n+        if (m_are_callbacks_running) return;\n+        if (m_callbacks_pending.empty()) return;\n+    }\n+    m_pscheduler->schedule(std::bind(&SingleThreadedSchedulerClient::ProcessQueue, this));\n+}\n+\n+void SingleThreadedSchedulerClient::ProcessQueue() {\n+    std::function<void (void)> callback;\n+    {\n+        LOCK(m_cs_callbacks_pending);\n+        if (m_are_callbacks_running) return;\n+        if (m_callbacks_pending.empty()) return;\n+        m_are_callbacks_running = true;\n+\n+        callback = std::move(m_callbacks_pending.front());\n+        m_callbacks_pending.pop_front();\n+    }\n+\n+    // RAII the setting of fCallbacksRunning and calling MaybeScheduleProcessQueue\n+    // to ensure both happen safely even if callback() throws.\n+    struct RAIICallbacksRunning {\n+        SingleThreadedSchedulerClient* instance;\n+        RAIICallbacksRunning(SingleThreadedSchedulerClient* _instance) : instance(_instance) {}\n+        ~RAIICallbacksRunning() {\n+            {\n+                LOCK(instance->m_cs_callbacks_pending);\n+                instance->m_are_callbacks_running = false;\n+            }\n+            instance->MaybeScheduleProcessQueue();\n+        }\n+    } raiicallbacksrunning(this);\n+\n+    callback();\n+}\n+\n+void SingleThreadedSchedulerClient::AddToProcessQueue(std::function<void (void)> func) {\n+    assert(m_pscheduler);\n+\n+    {\n+        LOCK(m_cs_callbacks_pending);\n+        m_callbacks_pending.emplace_back(std::move(func));\n+    }\n+    MaybeScheduleProcessQueue();\n+}\n+\n+void SingleThreadedSchedulerClient::EmptyQueue() {\n+    assert(!m_pscheduler->AreThreadsServicingQueue());\n+    bool should_continue = true;\n+    while (should_continue) {\n+        ProcessQueue();\n+        LOCK(m_cs_callbacks_pending);\n+        should_continue = !m_callbacks_pending.empty();\n+    }\n+}"
      },
      {
        "sha": "0365d668b209b85eeedb6e1d51e60649d6b57692",
        "filename": "src/scheduler.h",
        "status": "modified",
        "additions": 32,
        "deletions": 1,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/scheduler.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/scheduler.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/scheduler.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -14,6 +14,8 @@\n #include <boost/thread.hpp>\n #include <map>\n \n+#include \"sync.h\"\n+\n //\n // Simple class for background tasks that should be run\n // periodically or once \"after a while\"\n@@ -41,7 +43,7 @@ class CScheduler\n     typedef std::function<void(void)> Function;\n \n     // Call func at/after time t\n-    void schedule(Function f, boost::chrono::system_clock::time_point t);\n+    void schedule(Function f, boost::chrono::system_clock::time_point t=boost::chrono::system_clock::now());\n \n     // Convenience method: call f once deltaSeconds from now\n     void scheduleFromNow(Function f, int64_t deltaMilliSeconds);\n@@ -69,6 +71,9 @@ class CScheduler\n     size_t getQueueInfo(boost::chrono::system_clock::time_point &first,\n                         boost::chrono::system_clock::time_point &last) const;\n \n+    // Returns true if there are threads actively running in serviceQueue()\n+    bool AreThreadsServicingQueue() const;\n+\n private:\n     std::multimap<boost::chrono::system_clock::time_point, Function> taskQueue;\n     boost::condition_variable newTaskScheduled;\n@@ -79,4 +84,30 @@ class CScheduler\n     bool shouldStop() { return stopRequested || (stopWhenEmpty && taskQueue.empty()); }\n };\n \n+/**\n+ * Class used by CScheduler clients which may schedule multiple jobs\n+ * which are required to be run serially. Does not require such jobs\n+ * to be executed on the same thread, but no two jobs will be executed\n+ * at the same time.\n+ */\n+class SingleThreadedSchedulerClient {\n+private:\n+    CScheduler *m_pscheduler;\n+\n+    CCriticalSection m_cs_callbacks_pending;\n+    std::list<std::function<void (void)>> m_callbacks_pending;\n+    bool m_are_callbacks_running = false;\n+\n+    void MaybeScheduleProcessQueue();\n+    void ProcessQueue();\n+\n+public:\n+    SingleThreadedSchedulerClient(CScheduler *pschedulerIn) : m_pscheduler(pschedulerIn) {}\n+    void AddToProcessQueue(std::function<void (void)> func);\n+\n+    // Processes all remaining queue members on the calling thread, blocking until queue is empty\n+    // Must be called after the CScheduler has no remaining processing threads!\n+    void EmptyQueue();\n+};\n+\n #endif"
      },
      {
        "sha": "4b71a42cdff54f87d267dda9655cce335c3eb4f1",
        "filename": "src/script/bitcoinconsensus.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/bitcoinconsensus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/bitcoinconsensus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/bitcoinconsensus.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -68,7 +68,7 @@ struct ECCryptoClosure\n };\n \n ECCryptoClosure instance_of_eccryptoclosure;\n-}\n+} // namespace\n \n /** Check that all specified flags are part of the libconsensus interface. */\n static bool verify_flags(unsigned int flags)"
      },
      {
        "sha": "8a121774a040e7ef3a2359c805e4e0fd3513a3fd",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -31,7 +31,7 @@ inline bool set_error(ScriptError* ret, const ScriptError serror)\n     return false;\n }\n \n-} // anon namespace\n+} // namespace\n \n bool CastToBool(const valtype& vch)\n {\n@@ -1099,7 +1099,7 @@ class CTransactionSignatureSerializer {\n         // Serialize the script\n         if (nInput != nIn)\n             // Blank out other inputs' signatures\n-            ::Serialize(s, CScriptBase());\n+            ::Serialize(s, CScript());\n         else\n             SerializeScriptCode(s);\n         // Serialize the nSequence\n@@ -1164,7 +1164,7 @@ uint256 GetOutputsHash(const CTransaction& txTo) {\n     return ss.GetHash();\n }\n \n-} // anon namespace\n+} // namespace\n \n PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo)\n {\n@@ -1207,7 +1207,7 @@ uint256 SignatureHash(const CScript& scriptCode, const CTransaction& txTo, unsig\n         // The prevout may already be contained in hashPrevout, and the nSequence\n         // may already be contain in hashSequence.\n         ss << txTo.vin[nIn].prevout;\n-        ss << static_cast<const CScriptBase&>(scriptCode);\n+        ss << scriptCode;\n         ss << amount;\n         ss << txTo.vin[nIn].nSequence;\n         // Outputs (none/one/all, depending on flags)"
      },
      {
        "sha": "ab1dc4e681b4c628898ff3a6885b9154b9e62df7",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -160,9 +160,9 @@ class TransactionSignatureChecker : public BaseSignatureChecker\n public:\n     TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(NULL) {}\n     TransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData& txdataIn) : txTo(txToIn), nIn(nInIn), amount(amountIn), txdata(&txdataIn) {}\n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const;\n-    bool CheckLockTime(const CScriptNum& nLockTime) const;\n-    bool CheckSequence(const CScriptNum& nSequence) const;\n+    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override;\n+    bool CheckLockTime(const CScriptNum& nLockTime) const override;\n+    bool CheckSequence(const CScriptNum& nSequence) const override;\n };\n \n class MutableTransactionSignatureChecker : public TransactionSignatureChecker"
      },
      {
        "sha": "0a39619734cfeaa12d3b69829ecf3c66f805355d",
        "filename": "src/script/ismine.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/ismine.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/ismine.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/ismine.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -11,14 +11,13 @@\n #include \"script/standard.h\"\n #include \"script/sign.h\"\n \n-#include <boost/foreach.hpp>\n \n typedef std::vector<unsigned char> valtype;\n \n unsigned int HaveKeys(const std::vector<valtype>& pubkeys, const CKeyStore& keystore)\n {\n     unsigned int nResult = 0;\n-    BOOST_FOREACH(const valtype& pubkey, pubkeys)\n+    for (const valtype& pubkey : pubkeys)\n     {\n         CKeyID keyID = CPubKey(pubkey).GetID();\n         if (keystore.HaveKey(keyID))"
      },
      {
        "sha": "d16bfd0e00eaa8868e299d728f72f68ef649f936",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -8,6 +8,7 @@\n \n #include \"crypto/common.h\"\n #include \"prevector.h\"\n+#include \"serialize.h\"\n \n #include <assert.h>\n #include <climits>\n@@ -404,6 +405,13 @@ class CScript : public CScriptBase\n     CScript(std::vector<unsigned char>::const_iterator pbegin, std::vector<unsigned char>::const_iterator pend) : CScriptBase(pbegin, pend) { }\n     CScript(const unsigned char* pbegin, const unsigned char* pend) : CScriptBase(pbegin, pend) { }\n \n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITE(static_cast<CScriptBase&>(*this));\n+    }\n+\n     CScript& operator+=(const CScript& b)\n     {\n         insert(end(), b.begin(), b.end());\n@@ -648,8 +656,9 @@ class CScript : public CScriptBase\n \n     void clear()\n     {\n-        // The default std::vector::clear() does not release memory.\n-        CScriptBase().swap(*this);\n+        // The default prevector::clear() does not release memory\n+        CScriptBase::clear();\n+        shrink_to_fit();\n     }\n };\n "
      },
      {
        "sha": "ceb573b2ec565340fa6c1fdabc7aa35b2b136868",
        "filename": "src/script/sigcache.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/sigcache.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/sigcache.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -66,18 +66,18 @@ class CSignatureCache\n  * signatureCache could be made local to VerifySignature.\n */\n static CSignatureCache signatureCache;\n-}\n+} // namespace\n \n // To be called once in AppInitMain/BasicTestingSetup to initialize the\n // signatureCache.\n void InitSignatureCache()\n {\n     // nMaxCacheSize is unsigned. If -maxsigcachesize is set to zero,\n     // setup_bytes creates the minimum possible cache (2 elements).\n-    size_t nMaxCacheSize = std::min(std::max((int64_t)0, GetArg(\"-maxsigcachesize\", DEFAULT_MAX_SIG_CACHE_SIZE)), MAX_MAX_SIG_CACHE_SIZE) * ((size_t) 1 << 20);\n+    size_t nMaxCacheSize = std::min(std::max((int64_t)0, GetArg(\"-maxsigcachesize\", DEFAULT_MAX_SIG_CACHE_SIZE) / 2), MAX_MAX_SIG_CACHE_SIZE) * ((size_t) 1 << 20);\n     size_t nElems = signatureCache.setup_bytes(nMaxCacheSize);\n-    LogPrintf(\"Using %zu MiB out of %zu requested for signature cache, able to store %zu elements\\n\",\n-            (nElems*sizeof(uint256)) >>20, nMaxCacheSize>>20, nElems);\n+    LogPrintf(\"Using %zu MiB out of %zu/2 requested for signature cache, able to store %zu elements\\n\",\n+            (nElems*sizeof(uint256)) >>20, (nMaxCacheSize*2)>>20, nElems);\n }\n \n bool CachingTransactionSignatureChecker::VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& pubkey, const uint256& sighash) const"
      },
      {
        "sha": "5832b264b36fdb344f3dd63d7645f21c6e0e4841",
        "filename": "src/script/sigcache.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/sigcache.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/sigcache.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sigcache.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -48,7 +48,7 @@ class CachingTransactionSignatureChecker : public TransactionSignatureChecker\n public:\n     CachingTransactionSignatureChecker(const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, bool storeIn, PrecomputedTransactionData& txdataIn) : TransactionSignatureChecker(txToIn, nInIn, amountIn, txdataIn), store(storeIn) {}\n \n-    bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const;\n+    bool VerifySignature(const std::vector<unsigned char>& vchSig, const CPubKey& vchPubKey, const uint256& sighash) const override;\n };\n \n void InitSignatureCache();"
      },
      {
        "sha": "dc50467d3f13f985cbb8a081ff9fb37a5b0cfcb3",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 9,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -12,7 +12,6 @@\n #include \"script/standard.h\"\n #include \"uint256.h\"\n \n-#include <boost/foreach.hpp>\n \n typedef std::vector<unsigned char> valtype;\n \n@@ -126,7 +125,7 @@ static bool SignStep(const BaseSignatureCreator& creator, const CScript& scriptP\n static CScript PushAll(const std::vector<valtype>& values)\n {\n     CScript result;\n-    BOOST_FOREACH(const valtype& v, values) {\n+    for (const valtype& v : values) {\n         if (v.size() == 0) {\n             result << OP_0;\n         } else if (v.size() == 1 && v[0] >= 1 && v[0] <= 16) {\n@@ -141,10 +140,9 @@ static CScript PushAll(const std::vector<valtype>& values)\n bool ProduceSignature(const BaseSignatureCreator& creator, const CScript& fromPubKey, SignatureData& sigdata)\n {\n     CScript script = fromPubKey;\n-    bool solved = true;\n     std::vector<valtype> result;\n     txnouttype whichType;\n-    solved = SignStep(creator, script, result, whichType, SIGVERSION_BASE);\n+    bool solved = SignStep(creator, script, result, whichType, SIGVERSION_BASE);\n     bool P2SH = false;\n     CScript subscript;\n     sigdata.scriptWitness.stack.clear();\n@@ -232,12 +230,12 @@ static std::vector<valtype> CombineMultisig(const CScript& scriptPubKey, const B\n {\n     // Combine all the signatures we've got:\n     std::set<valtype> allsigs;\n-    BOOST_FOREACH(const valtype& v, sigs1)\n+    for (const valtype& v : sigs1)\n     {\n         if (!v.empty())\n             allsigs.insert(v);\n     }\n-    BOOST_FOREACH(const valtype& v, sigs2)\n+    for (const valtype& v : sigs2)\n     {\n         if (!v.empty())\n             allsigs.insert(v);\n@@ -248,7 +246,7 @@ static std::vector<valtype> CombineMultisig(const CScript& scriptPubKey, const B\n     unsigned int nSigsRequired = vSolutions.front()[0];\n     unsigned int nPubKeys = vSolutions.size()-2;\n     std::map<valtype, valtype> sigs;\n-    BOOST_FOREACH(const valtype& sig, allsigs)\n+    for (const valtype& sig : allsigs)\n     {\n         for (unsigned int i = 0; i < nPubKeys; i++)\n         {\n@@ -394,13 +392,13 @@ class DummySignatureChecker : public BaseSignatureChecker\n public:\n     DummySignatureChecker() {}\n \n-    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const\n+    bool CheckSig(const std::vector<unsigned char>& scriptSig, const std::vector<unsigned char>& vchPubKey, const CScript& scriptCode, SigVersion sigversion) const override\n     {\n         return true;\n     }\n };\n const DummySignatureChecker dummyChecker;\n-}\n+} // namespace\n \n const BaseSignatureChecker& DummySignatureCreator::Checker() const\n {"
      },
      {
        "sha": "bd458628922253fe2e85a87019102b678819b628",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -40,8 +40,8 @@ class TransactionSignatureCreator : public BaseSignatureCreator {\n \n public:\n     TransactionSignatureCreator(const CKeyStore* keystoreIn, const CTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn=SIGHASH_ALL);\n-    const BaseSignatureChecker& Checker() const { return checker; }\n-    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const;\n+    const BaseSignatureChecker& Checker() const override { return checker; }\n+    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const override;\n };\n \n class MutableTransactionSignatureCreator : public TransactionSignatureCreator {\n@@ -55,8 +55,8 @@ class MutableTransactionSignatureCreator : public TransactionSignatureCreator {\n class DummySignatureCreator : public BaseSignatureCreator {\n public:\n     DummySignatureCreator(const CKeyStore* keystoreIn) : BaseSignatureCreator(keystoreIn) {}\n-    const BaseSignatureChecker& Checker() const;\n-    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const;\n+    const BaseSignatureChecker& Checker() const override;\n+    bool CreateSig(std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const override;\n };\n \n struct SignatureData {"
      },
      {
        "sha": "760a5305e506be3833264458723dc12059c2ccb8",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -10,7 +10,6 @@\n #include \"util.h\"\n #include \"utilstrencodings.h\"\n \n-#include <boost/foreach.hpp>\n \n typedef std::vector<unsigned char> valtype;\n \n@@ -94,7 +93,7 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::v\n \n     // Scan templates\n     const CScript& script1 = scriptPubKey;\n-    BOOST_FOREACH(const PAIRTYPE(txnouttype, CScript)& tplate, mTemplates)\n+    for (const std::pair<txnouttype, CScript>& tplate : mTemplates)\n     {\n         const CScript& script2 = tplate.second;\n         vSolutionsRet.clear();\n@@ -273,7 +272,7 @@ class CScriptVisitor : public boost::static_visitor<bool>\n         return true;\n     }\n };\n-}\n+} // namespace\n \n CScript GetScriptForDestination(const CTxDestination& dest)\n {\n@@ -293,7 +292,7 @@ CScript GetScriptForMultisig(int nRequired, const std::vector<CPubKey>& keys)\n     CScript script;\n \n     script << CScript::EncodeOP_N(nRequired);\n-    BOOST_FOREACH(const CPubKey& key, keys)\n+    for (const CPubKey& key : keys)\n         script << ToByteVector(key);\n     script << CScript::EncodeOP_N(keys.size()) << OP_CHECKMULTISIG;\n     return script;"
      },
      {
        "sha": "5198724bea15360d7c680e76ba8d0b2d3ef75641",
        "filename": "src/secp256k1/sage/group_prover.sage",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/secp256k1/sage/group_prover.sage",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/secp256k1/sage/group_prover.sage",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/sage/group_prover.sage?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -3,7 +3,7 @@\n # to independently set assumptions on input or intermediary variables.\n #\n # The general approach is:\n-# * A constraint is a tuple of two sets of of symbolic expressions:\n+# * A constraint is a tuple of two sets of symbolic expressions:\n #   the first of which are required to evaluate to zero, the second of which\n #   are required to evaluate to nonzero.\n #   - A constraint is said to be conflicting if any of its nonzero expressions"
      },
      {
        "sha": "bd2b629e1c2e9b9699533bc598fa7759918e0645",
        "filename": "src/secp256k1/src/asm/field_10x26_arm.s",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/secp256k1/src/asm/field_10x26_arm.s",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/secp256k1/src/asm/field_10x26_arm.s",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/asm/field_10x26_arm.s?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -11,7 +11,7 @@ Note:\n \n - To avoid unnecessary loads and make use of available registers, two\n   'passes' have every time been interleaved, with the odd passes accumulating c' and d' \n-  which will be added to c and d respectively in the the even passes\n+  which will be added to c and d respectively in the even passes\n \n */\n "
      },
      {
        "sha": "8b86a07a7676a6fa77d05fc155dcb2fd38996301",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -450,15 +450,15 @@ class LimitedString\n         }\n         string.resize(size);\n         if (size != 0)\n-            s.read((char*)&string[0], size);\n+            s.read((char*)string.data(), size);\n     }\n \n     template<typename Stream>\n     void Serialize(Stream& s) const\n     {\n         WriteCompactSize(s, string.size());\n         if (!string.empty())\n-            s.write((char*)&string[0], string.size());\n+            s.write((char*)string.data(), string.size());\n     }\n };\n \n@@ -556,7 +556,7 @@ void Serialize(Stream& os, const std::basic_string<C>& str)\n {\n     WriteCompactSize(os, str.size());\n     if (!str.empty())\n-        os.write((char*)&str[0], str.size() * sizeof(str[0]));\n+        os.write((char*)str.data(), str.size() * sizeof(C));\n }\n \n template<typename Stream, typename C>\n@@ -565,7 +565,7 @@ void Unserialize(Stream& is, std::basic_string<C>& str)\n     unsigned int nSize = ReadCompactSize(is);\n     str.resize(nSize);\n     if (nSize != 0)\n-        is.read((char*)&str[0], nSize * sizeof(str[0]));\n+        is.read((char*)str.data(), nSize * sizeof(C));\n }\n \n \n@@ -578,7 +578,7 @@ void Serialize_impl(Stream& os, const prevector<N, T>& v, const unsigned char&)\n {\n     WriteCompactSize(os, v.size());\n     if (!v.empty())\n-        os.write((char*)&v[0], v.size() * sizeof(T));\n+        os.write((char*)v.data(), v.size() * sizeof(T));\n }\n \n template<typename Stream, unsigned int N, typename T, typename V>\n@@ -646,7 +646,7 @@ void Serialize_impl(Stream& os, const std::vector<T, A>& v, const unsigned char&\n {\n     WriteCompactSize(os, v.size());\n     if (!v.empty())\n-        os.write((char*)&v[0], v.size() * sizeof(T));\n+        os.write((char*)v.data(), v.size() * sizeof(T));\n }\n \n template<typename Stream, typename T, typename A, typename V>"
      },
      {
        "sha": "245fb9cd8fdfc2ec965abce7e0d85332a4c494a1",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -389,7 +389,7 @@ class CDataStream\n     {\n         // Special case: stream << stream concatenates like stream += stream\n         if (!vch.empty())\n-            s.write((char*)&vch[0], vch.size() * sizeof(vch[0]));\n+            s.write((char*)vch.data(), vch.size() * sizeof(value_type));\n     }\n \n     template<typename T>"
      },
      {
        "sha": "90690876eee05893d7b13fa8cd795401b565832e",
        "filename": "src/support/events.h",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/support/events.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/support/events.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/events.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -27,26 +27,26 @@ MAKE_RAII(evhttp);\n MAKE_RAII(evhttp_request);\n MAKE_RAII(evhttp_connection);\n \n-raii_event_base obtain_event_base() {\n+inline raii_event_base obtain_event_base() {\n     auto result = raii_event_base(event_base_new());\n     if (!result.get())\n         throw std::runtime_error(\"cannot create event_base\");\n     return result;\n }\n \n-raii_event obtain_event(struct event_base* base, evutil_socket_t s, short events, event_callback_fn cb, void* arg) {\n+inline raii_event obtain_event(struct event_base* base, evutil_socket_t s, short events, event_callback_fn cb, void* arg) {\n     return raii_event(event_new(base, s, events, cb, arg));\n }\n \n-raii_evhttp obtain_evhttp(struct event_base* base) {\n+inline raii_evhttp obtain_evhttp(struct event_base* base) {\n     return raii_evhttp(evhttp_new(base));\n }\n \n-raii_evhttp_request obtain_evhttp_request(void(*cb)(struct evhttp_request *, void *), void *arg) {\n+inline raii_evhttp_request obtain_evhttp_request(void(*cb)(struct evhttp_request *, void *), void *arg) {\n     return raii_evhttp_request(evhttp_request_new(cb, arg));\n }\n \n-raii_evhttp_connection obtain_evhttp_connection_base(struct event_base* base, std::string host, uint16_t port) {\n+inline raii_evhttp_connection obtain_evhttp_connection_base(struct event_base* base, std::string host, uint16_t port) {\n     auto result = raii_evhttp_connection(evhttp_connection_base_new(base, NULL, host.c_str(), port));\n     if (!result.get())\n         throw std::runtime_error(\"create connection failed\");"
      },
      {
        "sha": "2df6b84a5997bfd1dbdaca1555e07899944f14a8",
        "filename": "src/support/lockedpool.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/support/lockedpool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/support/lockedpool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/support/lockedpool.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -148,9 +148,9 @@ class Win32LockedPageAllocator: public LockedPageAllocator\n {\n public:\n     Win32LockedPageAllocator();\n-    void* AllocateLocked(size_t len, bool *lockingSuccess);\n-    void FreeLocked(void* addr, size_t len);\n-    size_t GetLimit();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess) override;\n+    void FreeLocked(void* addr, size_t len) override;\n+    size_t GetLimit() override;\n private:\n     size_t page_size;\n };\n@@ -200,9 +200,9 @@ class PosixLockedPageAllocator: public LockedPageAllocator\n {\n public:\n     PosixLockedPageAllocator();\n-    void* AllocateLocked(size_t len, bool *lockingSuccess);\n-    void FreeLocked(void* addr, size_t len);\n-    size_t GetLimit();\n+    void* AllocateLocked(size_t len, bool *lockingSuccess) override;\n+    void FreeLocked(void* addr, size_t len) override;\n+    size_t GetLimit() override;\n private:\n     size_t page_size;\n };"
      },
      {
        "sha": "c359e8220b60417086ad7ba835649f6b27e5e966",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -9,7 +9,6 @@\n \n #include <stdio.h>\n \n-#include <boost/foreach.hpp>\n #include <boost/thread.hpp>\n \n #ifdef DEBUG_LOCKCONTENTION\n@@ -77,7 +76,7 @@ static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch,\n {\n     LogPrintf(\"POTENTIAL DEADLOCK DETECTED\\n\");\n     LogPrintf(\"Previous lock order was:\\n\");\n-    BOOST_FOREACH (const PAIRTYPE(void*, CLockLocation) & i, s2) {\n+    for (const std::pair<void*, CLockLocation> & i : s2) {\n         if (i.first == mismatch.first) {\n             LogPrintf(\" (1)\");\n         }\n@@ -87,7 +86,7 @@ static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch,\n         LogPrintf(\" %s\\n\", i.second.ToString());\n     }\n     LogPrintf(\"Current lock order is:\\n\");\n-    BOOST_FOREACH (const PAIRTYPE(void*, CLockLocation) & i, s1) {\n+    for (const std::pair<void*, CLockLocation> & i : s1) {\n         if (i.first == mismatch.first) {\n             LogPrintf(\" (1)\");\n         }\n@@ -108,7 +107,7 @@ static void push_lock(void* c, const CLockLocation& locklocation, bool fTry)\n \n     (*lockstack).push_back(std::make_pair(c, locklocation));\n \n-    BOOST_FOREACH (const PAIRTYPE(void*, CLockLocation) & i, (*lockstack)) {\n+    for (const std::pair<void*, CLockLocation> & i : (*lockstack)) {\n         if (i.first == c)\n             break;\n \n@@ -142,14 +141,14 @@ void LeaveCritical()\n std::string LocksHeld()\n {\n     std::string result;\n-    BOOST_FOREACH (const PAIRTYPE(void*, CLockLocation) & i, *lockstack)\n+    for (const std::pair<void*, CLockLocation> & i : *lockstack)\n         result += i.second.ToString() + std::string(\"\\n\");\n     return result;\n }\n \n void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs)\n {\n-    BOOST_FOREACH (const PAIRTYPE(void*, CLockLocation) & i, *lockstack)\n+    for (const std::pair<void*, CLockLocation> & i : *lockstack)\n         if (i.first == cs)\n             return;\n     fprintf(stderr, \"Assertion failed: lock %s not held in %s:%i; locks held:\\n%s\", pszName, pszFile, nLine, LocksHeld().c_str());"
      },
      {
        "sha": "20974f5fbc3901552c853a79873763fd71dbd6b9",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -9,7 +9,6 @@\n #include \"threadsafety.h\"\n \n #include <boost/thread/condition_variable.hpp>\n-#include <boost/thread/locks.hpp>\n #include <boost/thread/mutex.hpp>\n #include <boost/thread/recursive_mutex.hpp>\n "
      },
      {
        "sha": "4a284517a1232e30ec3401a301690021b16a1250",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -18,8 +18,6 @@\n \n #include <stdint.h>\n \n-#include <boost/date_time/posix_time/posix_time_types.hpp>\n-#include <boost/foreach.hpp>\n #include <boost/test/unit_test.hpp>\n \n // Tests these internal-to-net_processing.cpp methods:"
      },
      {
        "sha": "bc6aef2c1152fbb470ff8512f1f5130a2fa29144",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -27,7 +27,7 @@ class CAddrManTest : public CAddrMan\n         insecure_rand = FastRandomContext(true);\n     }\n \n-    int RandomInt(int nMax)\n+    int RandomInt(int nMax) override\n     {\n         state = (CHashWriter(SER_GETHASH, 0) << state).GetHash().GetCheapHash();\n         return (unsigned int)(state % nMax);"
      },
      {
        "sha": "4a533b5bf2fb5cbb376ef6b0db8b648649c4aa9a",
        "filename": "src/test/allocator_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/allocator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/allocator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/allocator_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -131,7 +131,7 @@ class TestLockedPageAllocator: public LockedPageAllocator\n {\n public:\n     TestLockedPageAllocator(int count_in, int lockedcount_in): count(count_in), lockedcount(lockedcount_in) {}\n-    void* AllocateLocked(size_t len, bool *lockingSuccess)\n+    void* AllocateLocked(size_t len, bool *lockingSuccess) override\n     {\n         *lockingSuccess = false;\n         if (count > 0) {\n@@ -146,10 +146,10 @@ class TestLockedPageAllocator: public LockedPageAllocator\n         }\n         return 0;\n     }\n-    void FreeLocked(void* addr, size_t len)\n+    void FreeLocked(void* addr, size_t len) override\n     {\n     }\n-    size_t GetLimit()\n+    size_t GetLimit() override\n     {\n         return std::numeric_limits<size_t>::max();\n     }"
      },
      {
        "sha": "2c98fbcfd67efa8da6fec19070934611c1770369",
        "filename": "src/test/arith_uint256_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/arith_uint256_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/arith_uint256_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/arith_uint256_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -219,7 +219,7 @@ BOOST_AUTO_TEST_CASE( unaryOperators ) // !    ~    -\n \n \n // Check if doing _A_ _OP_ _B_ results in the same as applying _OP_ onto each\n-// element of Aarray and Barray, and then converting the result into a arith_uint256.\n+// element of Aarray and Barray, and then converting the result into an arith_uint256.\n #define CHECKBITWISEOPERATOR(_A_,_B_,_OP_)                              \\\n     for (unsigned int i = 0; i < 32; ++i) { TmpArray[i] = _A_##Array[i] _OP_ _B_##Array[i]; } \\\n     BOOST_CHECK(arith_uint256V(std::vector<unsigned char>(TmpArray,TmpArray+32)) == (_A_##L _OP_ _B_##L));"
      },
      {
        "sha": "b33cdb9fe6bf72d34b2eb13a979f3a2981806aa9",
        "filename": "src/test/base58_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/base58_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/base58_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base58_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -15,7 +15,6 @@\n #include \"utilstrencodings.h\"\n #include \"test/test_bitcoin.h\"\n \n-#include <boost/foreach.hpp>\n #include <boost/test/unit_test.hpp>\n \n #include <univalue.h>"
      },
      {
        "sha": "6bcd550d7bed0174cf8b4d19b91079e064e02edd",
        "filename": "src/test/bip32_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/bip32_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/bip32_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bip32_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -93,7 +93,7 @@ void RunTest(const TestVector &test) {\n     CExtPubKey pubkey;\n     key.SetMaster(&seed[0], seed.size());\n     pubkey = key.Neuter();\n-    BOOST_FOREACH(const TestDerivation &derive, test.vDerive) {\n+    for (const TestDerivation &derive : test.vDerive) {\n         unsigned char data[74];\n         key.Encode(data);\n         pubkey.Encode(data);"
      },
      {
        "sha": "2085b5cb2b87f7e87caccd35e327c6dbc3ab1588",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -19,7 +19,6 @@\n #include <vector>\n \n #include <boost/test/unit_test.hpp>\n-#include <boost/tuple/tuple.hpp>\n \n BOOST_FIXTURE_TEST_SUITE(bloom_tests, BasicTestingSetup)\n "
      },
      {
        "sha": "6ae0bcadd02545f164a789bacb33be4ebd15e074",
        "filename": "src/test/checkqueue_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/checkqueue_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/checkqueue_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/checkqueue_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -402,12 +402,12 @@ BOOST_AUTO_TEST_CASE(test_CheckQueueControl_Locks)\n     {\n         boost::thread_group tg;\n         std::mutex m;\n-        bool has_lock {false};\n-        bool has_tried {false};\n-        bool done {false};\n-        bool done_ack {false};\n         std::condition_variable cv;\n         {\n+            bool has_lock {false};\n+            bool has_tried {false};\n+            bool done {false};\n+            bool done_ack {false};\n             std::unique_lock<std::mutex> l(m);\n             tg.create_thread([&]{\n                     CCheckQueueControl<FakeCheck> control(queue.get());"
      },
      {
        "sha": "e24431528a2a1e86f09b24333f83d32c8c454532",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 12,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -36,7 +36,7 @@ class CCoinsViewTest : public CCoinsView\n     std::map<COutPoint, Coin> map_;\n \n public:\n-    bool GetCoin(const COutPoint& outpoint, Coin& coin) const\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const override\n     {\n         std::map<COutPoint, Coin>::const_iterator it = map_.find(outpoint);\n         if (it == map_.end()) {\n@@ -50,15 +50,9 @@ class CCoinsViewTest : public CCoinsView\n         return true;\n     }\n \n-    bool HaveCoin(const COutPoint& outpoint) const\n-    {\n-        Coin coin;\n-        return GetCoin(outpoint, coin);\n-    }\n+    uint256 GetBestBlock() const override { return hashBestBlock_; }\n \n-    uint256 GetBestBlock() const { return hashBestBlock_; }\n-\n-    bool BatchWrite(CCoinsMap& mapCoins, const uint256& hashBlock)\n+    bool BatchWrite(CCoinsMap& mapCoins, const uint256& hashBlock) override\n     {\n         for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end(); ) {\n             if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n@@ -99,7 +93,7 @@ class CCoinsViewCacheTest : public CCoinsViewCache\n     size_t& usage() { return cachedCoinsUsage; }\n };\n \n-}\n+} // namespace\n \n BOOST_FIXTURE_TEST_SUITE(coins_tests, BasicTestingSetup)\n \n@@ -147,8 +141,22 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n         {\n             uint256 txid = txids[InsecureRandRange(txids.size())]; // txid we're going to modify in this iteration.\n             Coin& coin = result[COutPoint(txid, 0)];\n+\n+            // Determine whether to test HaveCoin before or after Access* (or both). As these functions\n+            // can influence each other's behaviour by pulling things into the cache, all combinations\n+            // are tested.\n+            bool test_havecoin_before = InsecureRandBits(2) == 0;\n+            bool test_havecoin_after = InsecureRandBits(2) == 0;\n+\n+            bool result_havecoin = test_havecoin_before ? stack.back()->HaveCoin(COutPoint(txid, 0)) : false;\n             const Coin& entry = (InsecureRandRange(500) == 0) ? AccessByTxid(*stack.back(), txid) : stack.back()->AccessCoin(COutPoint(txid, 0));\n             BOOST_CHECK(coin == entry);\n+            BOOST_CHECK(!test_havecoin_before || result_havecoin == !entry.IsSpent());\n+\n+            if (test_havecoin_after) {\n+                bool ret = stack.back()->HaveCoin(COutPoint(txid, 0));\n+                BOOST_CHECK(ret == !entry.IsSpent());\n+            }\n \n             if (InsecureRandRange(5) == 0 || coin.IsSpent()) {\n                 Coin newcoin;\n@@ -193,7 +201,7 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n                     found_an_entry = true;\n                 }\n             }\n-            BOOST_FOREACH(const CCoinsViewCacheTest *test, stack) {\n+            for (const CCoinsViewCacheTest *test : stack) {\n                 test->SelfTest();\n             }\n         }\n@@ -628,7 +636,7 @@ BOOST_AUTO_TEST_CASE(ccoins_access)\n     CheckAccessCoin(ABSENT, VALUE2, VALUE2, FRESH      , FRESH      );\n     CheckAccessCoin(ABSENT, VALUE2, VALUE2, DIRTY      , DIRTY      );\n     CheckAccessCoin(ABSENT, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoin(PRUNED, ABSENT, PRUNED, NO_ENTRY   , FRESH      );\n+    CheckAccessCoin(PRUNED, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   );\n     CheckAccessCoin(PRUNED, PRUNED, PRUNED, 0          , 0          );\n     CheckAccessCoin(PRUNED, PRUNED, PRUNED, FRESH      , FRESH      );\n     CheckAccessCoin(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );"
      },
      {
        "sha": "1004482224c8596cc3a35d862a5e1330c8bb9631",
        "filename": "src/test/cuckoocache_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/cuckoocache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/cuckoocache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/cuckoocache_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -7,8 +7,6 @@\n #include \"test/test_bitcoin.h\"\n #include \"random.h\"\n #include <thread>\n-#include <boost/thread.hpp>\n-\n \n /** Test Suite for CuckooCache\n  *"
      },
      {
        "sha": "698e8982312c97a52497ecbcab1e782f1da0bde4",
        "filename": "src/test/data/script_tests.json",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/data/script_tests.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/data/script_tests.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/script_tests.json?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -240,7 +240,7 @@\n [\"0\", \"IF NOP10 ENDIF 1\", \"P2SH,STRICTENC,DISCOURAGE_UPGRADABLE_NOPS\", \"OK\",\n  \"Discouraged NOPs are allowed if not executed\"],\n \n-[\"0\", \"IF 0xba ELSE 1 ENDIF\", \"P2SH,STRICTENC\", \"OK\", \"opcodes above NOP10 invalid if executed\"],\n+[\"0\", \"IF 0xba ELSE 1 ENDIF\", \"P2SH,STRICTENC\", \"OK\", \"opcodes above MAX_OPCODE invalid if executed\"],\n [\"0\", \"IF 0xbb ELSE 1 ENDIF\", \"P2SH,STRICTENC\", \"OK\"],\n [\"0\", \"IF 0xbc ELSE 1 ENDIF\", \"P2SH,STRICTENC\", \"OK\"],\n [\"0\", \"IF 0xbd ELSE 1 ENDIF\", \"P2SH,STRICTENC\", \"OK\"],\n@@ -878,7 +878,7 @@\n  \"P2SH,DISCOURAGE_UPGRADABLE_NOPS\", \"DISCOURAGE_UPGRADABLE_NOPS\", \"Discouraged NOP10 in redeemScript\"],\n \n [\"0x50\",\"1\", \"P2SH,STRICTENC\", \"BAD_OPCODE\", \"opcode 0x50 is reserved\"],\n-[\"1\", \"IF 0xba ELSE 1 ENDIF\", \"P2SH,STRICTENC\", \"BAD_OPCODE\", \"opcodes above NOP10 invalid if executed\"],\n+[\"1\", \"IF 0xba ELSE 1 ENDIF\", \"P2SH,STRICTENC\", \"BAD_OPCODE\", \"opcodes above MAX_OPCODE invalid if executed\"],\n [\"1\", \"IF 0xbb ELSE 1 ENDIF\", \"P2SH,STRICTENC\", \"BAD_OPCODE\"],\n [\"1\", \"IF 0xbc ELSE 1 ENDIF\", \"P2SH,STRICTENC\", \"BAD_OPCODE\"],\n [\"1\", \"IF 0xbd ELSE 1 ENDIF\", \"P2SH,STRICTENC\", \"BAD_OPCODE\"],\n@@ -1001,7 +1001,7 @@\n [\"1\",\"RESERVED\", \"P2SH,STRICTENC\", \"BAD_OPCODE\", \"OP_RESERVED is reserved\"],\n [\"1\",\"RESERVED1\", \"P2SH,STRICTENC\", \"BAD_OPCODE\", \"OP_RESERVED1 is reserved\"],\n [\"1\",\"RESERVED2\", \"P2SH,STRICTENC\", \"BAD_OPCODE\", \"OP_RESERVED2 is reserved\"],\n-[\"1\",\"0xba\", \"P2SH,STRICTENC\", \"BAD_OPCODE\", \"0xba == OP_NOP10 + 1\"],\n+[\"1\",\"0xba\", \"P2SH,STRICTENC\", \"BAD_OPCODE\", \"0xba == MAX_OPCODE + 1\"],\n \n [\"2147483648\", \"1ADD 1\", \"P2SH,STRICTENC\", \"UNKNOWN_ERROR\", \"We cannot do math on 5-byte integers\"],\n [\"2147483648\", \"NEGATE 1\", \"P2SH,STRICTENC\", \"UNKNOWN_ERROR\", \"We cannot do math on 5-byte integers\"],\n@@ -2506,7 +2506,7 @@\n ],\n \n [\"CHECKSEQUENCEVERIFY tests\"],\n-[\"\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY\", \"INVALID_STACK_OPERATION\", \"CSV automatically fails on a empty stack\"],\n+[\"\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY\", \"INVALID_STACK_OPERATION\", \"CSV automatically fails on an empty stack\"],\n [\"-1\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY\", \"NEGATIVE_LOCKTIME\", \"CSV automatically fails if stack top is negative\"],\n [\"0x0100\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY,MINIMALDATA\", \"UNKNOWN_ERROR\", \"CSV fails if stack top is not minimally encoded\"],\n [\"0\", \"CHECKSEQUENCEVERIFY\", \"CHECKSEQUENCEVERIFY\", \"UNSATISFIED_LOCKTIME\", \"CSV fails if stack top bit 1 << 31 is set and the tx version < 2\"],"
      },
      {
        "sha": "e6b382af13e70b8466eb935d5aaac65eab1f9b05",
        "filename": "src/test/data/tx_valid.json",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/data/tx_valid.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/data/tx_valid.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/data/tx_valid.json?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -174,7 +174,7 @@\n [[[\"5a6b0021a6042a686b6b94abc36b387bef9109847774e8b1e51eb8cc55c53921\", 1, \"DUP HASH160 0x14 0xee5a6aa40facefb2655ac23c0c28c57c65c41f9b EQUALVERIFY CHECKSIG\"]],\n \"01000000012139c555ccb81ee5b1e87477840991ef7b386bc3ab946b6b682a04a621006b5a01000000fdb40148304502201723e692e5f409a7151db386291b63524c5eb2030df652b1f53022fd8207349f022100b90d9bbf2f3366ce176e5e780a00433da67d9e5c79312c6388312a296a5800390148304502201723e692e5f409a7151db386291b63524c5eb2030df652b1f53022fd8207349f022100b90d9bbf2f3366ce176e5e780a00433da67d9e5c79312c6388312a296a5800390121038479a0fa998cd35259a2ef0a7a5c68662c1474f88ccb6d08a7677bbec7f2204148304502201723e692e5f409a7151db386291b63524c5eb2030df652b1f53022fd8207349f022100b90d9bbf2f3366ce176e5e780a00433da67d9e5c79312c6388312a296a5800390175ac4830450220646b72c35beeec51f4d5bc1cbae01863825750d7f490864af354e6ea4f625e9c022100f04b98432df3a9641719dbced53393022e7249fb59db993af1118539830aab870148304502201723e692e5f409a7151db386291b63524c5eb2030df652b1f53022fd8207349f022100b90d9bbf2f3366ce176e5e780a00433da67d9e5c79312c6388312a296a580039017521038479a0fa998cd35259a2ef0a7a5c68662c1474f88ccb6d08a7677bbec7f22041ffffffff010000000000000000016a00000000\", \"P2SH\"],\n \n-[\"Finally CHECKMULTISIG removes all signatures prior to hashing the script containing those signatures. In conjunction with the SIGHASH_SINGLE bug this lets us test whether or not FindAndDelete() is actually present in scriptPubKey/redeemScript evaluation by including a signature of the digest 0x01 We can compute in advance for our pubkey, embed it it in the scriptPubKey, and then also using a normal SIGHASH_ALL signature. If FindAndDelete() wasn't run, the 'bugged' signature would still be in the hashed script, and the normal signature would fail.\"],\n+[\"Finally CHECKMULTISIG removes all signatures prior to hashing the script containing those signatures. In conjunction with the SIGHASH_SINGLE bug this lets us test whether or not FindAndDelete() is actually present in scriptPubKey/redeemScript evaluation by including a signature of the digest 0x01 We can compute in advance for our pubkey, embed it in the scriptPubKey, and then also using a normal SIGHASH_ALL signature. If FindAndDelete() wasn't run, the 'bugged' signature would still be in the hashed script, and the normal signature would fail.\"],\n \n [\"Here's an example on mainnet within a P2SH redeemScript. Remarkably it's a standard transaction in <0.9\"],\n [[[\"b5b598de91787439afd5938116654e0b16b7a0d0f82742ba37564219c5afcbf9\", 0, \"DUP HASH160 0x14 0xf6f365c40f0739b61de827a44751e5e99032ed8f EQUALVERIFY CHECKSIG\"],"
      },
      {
        "sha": "6ed6e7744e3ed0064c06d005ac14447599c2a06a",
        "filename": "src/test/dbwrapper_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 23,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/dbwrapper_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/dbwrapper_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/dbwrapper_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -7,8 +7,6 @@\n #include \"random.h\"\n #include \"test/test_bitcoin.h\"\n \n-#include <boost/assign/std/vector.hpp> // for 'operator+=()'\n-#include <boost/assert.hpp>\n #include <boost/test/unit_test.hpp>\n \n // Test if a string consists entirely of null characters\n@@ -26,8 +24,7 @@ BOOST_FIXTURE_TEST_SUITE(dbwrapper_tests, BasicTestingSetup)\n BOOST_AUTO_TEST_CASE(dbwrapper)\n {\n     // Perform tests both obfuscated and non-obfuscated.\n-    for (int i = 0; i < 2; i++) {\n-        bool obfuscate = (bool)i;\n+    for (bool obfuscate : {false, true}) {\n         fs::path ph = fs::temp_directory_path() / fs::unique_path();\n         CDBWrapper dbw(ph, (1 << 20), true, false, obfuscate);\n         char key = 'k';\n@@ -47,8 +44,7 @@ BOOST_AUTO_TEST_CASE(dbwrapper)\n BOOST_AUTO_TEST_CASE(dbwrapper_batch)\n {\n     // Perform tests both obfuscated and non-obfuscated.\n-    for (int i = 0; i < 2; i++) {\n-        bool obfuscate = (bool)i;\n+    for (bool obfuscate : {false, true}) {\n         fs::path ph = fs::temp_directory_path() / fs::unique_path();\n         CDBWrapper dbw(ph, (1 << 20), true, false, obfuscate);\n \n@@ -84,8 +80,7 @@ BOOST_AUTO_TEST_CASE(dbwrapper_batch)\n BOOST_AUTO_TEST_CASE(dbwrapper_iterator)\n {\n     // Perform tests both obfuscated and non-obfuscated.\n-    for (int i = 0; i < 2; i++) {\n-        bool obfuscate = (bool)i;\n+    for (bool obfuscate : {false, true}) {\n         fs::path ph = fs::temp_directory_path() / fs::unique_path();\n         CDBWrapper dbw(ph, (1 << 20), true, false, obfuscate);\n \n@@ -97,7 +92,7 @@ BOOST_AUTO_TEST_CASE(dbwrapper_iterator)\n         uint256 in2 = InsecureRand256();\n         BOOST_CHECK(dbw.Write(key2, in2));\n \n-        std::unique_ptr<CDBIterator> it(const_cast<CDBWrapper*>(&dbw)->NewIterator());\n+        std::unique_ptr<CDBIterator> it(const_cast<CDBWrapper&>(dbw).NewIterator());\n \n         // Be sure to seek past the obfuscation key (if it exists)\n         it->Seek(key);\n@@ -212,13 +207,8 @@ BOOST_AUTO_TEST_CASE(iterator_ordering)\n         BOOST_CHECK(dbw.Write(key, value));\n     }\n \n-    std::unique_ptr<CDBIterator> it(const_cast<CDBWrapper*>(&dbw)->NewIterator());\n-    for (int c=0; c<2; ++c) {\n-        int seek_start;\n-        if (c == 0)\n-            seek_start = 0x00;\n-        else\n-            seek_start = 0x80;\n+    std::unique_ptr<CDBIterator> it(const_cast<CDBWrapper&>(dbw).NewIterator());\n+    for (int seek_start : {0x00, 0x80}) {\n         it->Seek((uint8_t)seek_start);\n         for (int x=seek_start; x<256; ++x) {\n             uint8_t key;\n@@ -288,13 +278,8 @@ BOOST_AUTO_TEST_CASE(iterator_string_ordering)\n         }\n     }\n \n-    std::unique_ptr<CDBIterator> it(const_cast<CDBWrapper*>(&dbw)->NewIterator());\n-    for (int c=0; c<2; ++c) {\n-        int seek_start;\n-        if (c == 0)\n-            seek_start = 0;\n-        else\n-            seek_start = 5;\n+    std::unique_ptr<CDBIterator> it(const_cast<CDBWrapper&>(dbw).NewIterator());\n+    for (int seek_start : {0, 5}) {\n         snprintf(buf, sizeof(buf), \"%d\", seek_start);\n         StringContentsSerializer seek_key(buf);\n         it->Seek(seek_key);"
      },
      {
        "sha": "c79675f5a6dd1a3b848187fcd1744f4980b45218",
        "filename": "src/test/getarg_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/getarg_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/getarg_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/getarg_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -9,7 +9,6 @@\n #include <vector>\n \n #include <boost/algorithm/string.hpp>\n-#include <boost/foreach.hpp>\n #include <boost/test/unit_test.hpp>\n \n BOOST_FIXTURE_TEST_SUITE(getarg_tests, BasicTestingSetup)\n@@ -25,7 +24,7 @@ static void ResetArgs(const std::string& strArg)\n \n     // Convert to char*:\n     std::vector<const char*> vecChar;\n-    BOOST_FOREACH(std::string& s, vecArg)\n+    for (std::string& s : vecArg)\n         vecChar.push_back(s.c_str());\n \n     ParseParameters(vecChar.size(), &vecChar[0]);"
      },
      {
        "sha": "eaff2ac70d3b5204454cd09419ece7919aa90e83",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -260,7 +260,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     {\n         tx.vout[0].nValue -= LOWFEE;\n         hash = tx.GetHash();\n-        bool spendsCoinbase = (i == 0) ? true : false; // only first tx spends coinbase\n+        bool spendsCoinbase = i == 0; // only first tx spends coinbase\n         // If we don't set the # of sig ops in the CTxMemPoolEntry, template creation fails\n         mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n@@ -274,7 +274,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     {\n         tx.vout[0].nValue -= LOWFEE;\n         hash = tx.GetHash();\n-        bool spendsCoinbase = (i == 0) ? true : false; // only first tx spends coinbase\n+        bool spendsCoinbase = i == 0; // only first tx spends coinbase\n         // If we do set the # of sig ops in the CTxMemPoolEntry, template creation passes\n         mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).SigOpsCost(80).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n@@ -295,7 +295,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     {\n         tx.vout[0].nValue -= LOWFEE;\n         hash = tx.GetHash();\n-        bool spendsCoinbase = (i == 0) ? true : false; // only first tx spends coinbase\n+        bool spendsCoinbase = i == 0; // only first tx spends coinbase\n         mempool.addUnchecked(hash, entry.Fee(LOWFEE).Time(GetTime()).SpendsCoinbase(spendsCoinbase).FromTx(tx));\n         tx.vin[0].prevout.hash = hash;\n     }"
      },
      {
        "sha": "c686f679c28c1ed381be87207f11e72c7f639217",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -14,7 +14,6 @@\n #include \"test/test_bitcoin.h\"\n \n \n-#include <boost/foreach.hpp>\n #include <boost/test/unit_test.hpp>\n \n typedef std::vector<unsigned char> valtype;\n@@ -28,7 +27,7 @@ sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transac\n \n     CScript result;\n     result << OP_0; // CHECKMULTISIG bug workaround\n-    BOOST_FOREACH(const CKey &key, keys)\n+    for (const CKey &key : keys)\n     {\n         std::vector<unsigned char> vchSig;\n         BOOST_CHECK(key.Sign(hash, vchSig));"
      },
      {
        "sha": "095d86834c0b3711512a8708b78d62275a78f4fe",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -29,7 +29,7 @@ class CAddrManSerializationMock : public CAddrMan\n class CAddrManUncorrupted : public CAddrManSerializationMock\n {\n public:\n-    void Serialize(CDataStream& s) const\n+    void Serialize(CDataStream& s) const override\n     {\n         CAddrMan::Serialize(s);\n     }\n@@ -38,7 +38,7 @@ class CAddrManUncorrupted : public CAddrManSerializationMock\n class CAddrManCorrupted : public CAddrManSerializationMock\n {\n public:\n-    void Serialize(CDataStream& s) const\n+    void Serialize(CDataStream& s) const override\n     {\n         // Produces corrupt output that claims addrman has 20 addrs when it only has one addr.\n         unsigned char nVersion = 1;"
      },
      {
        "sha": "1baf7643e544618448053a3732d109f4db422923",
        "filename": "src/test/netbase_tests.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/netbase_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/netbase_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/netbase_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -4,6 +4,7 @@\n \n #include \"netbase.h\"\n #include \"test/test_bitcoin.h\"\n+#include \"utilstrencodings.h\"\n \n #include <string>\n \n@@ -25,13 +26,21 @@ static CSubNet ResolveSubNet(const char* subnet)\n     return ret;\n }\n \n+static CNetAddr CreateInternal(const char* host)\n+{\n+    CNetAddr addr;\n+    addr.SetInternal(host);\n+    return addr;\n+}\n+\n BOOST_AUTO_TEST_CASE(netbase_networks)\n {\n     BOOST_CHECK(ResolveIP(\"127.0.0.1\").GetNetwork()                              == NET_UNROUTABLE);\n     BOOST_CHECK(ResolveIP(\"::1\").GetNetwork()                                    == NET_UNROUTABLE);\n     BOOST_CHECK(ResolveIP(\"8.8.8.8\").GetNetwork()                                == NET_IPV4);\n     BOOST_CHECK(ResolveIP(\"2001::8888\").GetNetwork()                             == NET_IPV6);\n     BOOST_CHECK(ResolveIP(\"FD87:D87E:EB43:edb1:8e4:3588:e546:35ca\").GetNetwork() == NET_TOR);\n+    BOOST_CHECK(CreateInternal(\"foo.com\").GetNetwork()                           == NET_INTERNAL);\n \n }\n \n@@ -58,6 +67,8 @@ BOOST_AUTO_TEST_CASE(netbase_properties)\n     BOOST_CHECK(ResolveIP(\"8.8.8.8\").IsRoutable());\n     BOOST_CHECK(ResolveIP(\"2001::1\").IsRoutable());\n     BOOST_CHECK(ResolveIP(\"127.0.0.1\").IsValid());\n+    BOOST_CHECK(CreateInternal(\"FD6B:88C0:8724:edb1:8e4:3588:e546:35ca\").IsInternal());\n+    BOOST_CHECK(CreateInternal(\"bar.com\").IsInternal());\n \n }\n \n@@ -103,6 +114,11 @@ BOOST_AUTO_TEST_CASE(netbase_lookupnumeric)\n     BOOST_CHECK(TestParse(\"[::]:8333\", \"[::]:8333\"));\n     BOOST_CHECK(TestParse(\"[127.0.0.1]\", \"127.0.0.1:65535\"));\n     BOOST_CHECK(TestParse(\":::\", \"[::]:0\"));\n+\n+    // verify that an internal address fails to resolve\n+    BOOST_CHECK(TestParse(\"[fd6b:88c0:8724:1:2:3:4:5]\", \"[::]:0\"));\n+    // and that a one-off resolves correctly\n+    BOOST_CHECK(TestParse(\"[fd6c:88c0:8724:1:2:3:4:5]\", \"[fd6c:88c0:8724:1:2:3:4:5]:65535\"));\n }\n \n BOOST_AUTO_TEST_CASE(onioncat_test)\n@@ -281,6 +297,9 @@ BOOST_AUTO_TEST_CASE(netbase_getgroup)\n     BOOST_CHECK(ResolveIP(\"2001:470:abcd:9999:9999:9999:9999:9999\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV6, 32, 1, 4, 112, 175})); //he.net\n     BOOST_CHECK(ResolveIP(\"2001:2001:9999:9999:9999:9999:9999:9999\").GetGroup() == std::vector<unsigned char>({(unsigned char)NET_IPV6, 32, 1, 32, 1})); //IPv6\n \n+    // baz.net sha256 hash: 12929400eb4607c4ac075f087167e75286b179c693eb059a01774b864e8fe505\n+    std::vector<unsigned char> internal_group = {NET_INTERNAL, 0x12, 0x92, 0x94, 0x00, 0xeb, 0x46, 0x07, 0xc4, 0xac, 0x07};\n+    BOOST_CHECK(CreateInternal(\"baz.net\").GetGroup() == internal_group);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "fd8f7191f4fafbf24e13be6ddbc817c19220953d",
        "filename": "src/test/policyestimator_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/policyestimator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/policyestimator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/policyestimator_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -177,16 +177,6 @@ BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n     for (int i = 2; i < 9; i++) { // At 9, the original estimate was already at the bottom (b/c scale = 2)\n         BOOST_CHECK(feeEst.estimateFee(i).GetFeePerK() < origFeeEst[i-1] - deltaFee);\n     }\n-\n-    // Test that if the mempool is limited, estimateSmartFee won't return a value below the mempool min fee\n-    mpool.addUnchecked(tx.GetHash(),  entry.Fee(feeV[5]).Time(GetTime()).Height(blocknum).FromTx(tx));\n-    // evict that transaction which should set a mempool min fee of minRelayTxFee + feeV[5]\n-    mpool.TrimToSize(1);\n-    BOOST_CHECK(mpool.GetMinFee(1).GetFeePerK() > feeV[5]);\n-    for (int i = 1; i < 10; i++) {\n-        BOOST_CHECK(feeEst.estimateSmartFee(i, NULL, mpool).GetFeePerK() >= feeEst.estimateRawFee(i, 0.85, FeeEstimateHorizon::MED_HALFLIFE).GetFeePerK());\n-        BOOST_CHECK(feeEst.estimateSmartFee(i, NULL, mpool).GetFeePerK() >= mpool.GetMinFee(1).GetFeePerK());\n-    }\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "345c4a2148c91bf780ec0256d371c7370767d0d7",
        "filename": "src/test/prevector_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/prevector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/prevector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/prevector_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -5,6 +5,7 @@\n #include <vector>\n #include \"prevector.h\"\n \n+#include \"reverse_iterator.h\"\n #include \"serialize.h\"\n #include \"streams.h\"\n \n@@ -53,16 +54,16 @@ class prevector_tester {\n         local_check(pretype(real_vector.begin(), real_vector.end()) == pre_vector);\n         local_check(pretype(pre_vector.begin(), pre_vector.end()) == pre_vector);\n         size_t pos = 0;\n-        BOOST_FOREACH(const T& v, pre_vector) {\n+        for (const T& v : pre_vector) {\n              local_check(v == real_vector[pos++]);\n         }\n-        BOOST_REVERSE_FOREACH(const T& v, pre_vector) {\n+        for (const T& v : reverse_iterate(pre_vector)) {\n              local_check(v == real_vector[--pos]);\n         }\n-        BOOST_FOREACH(const T& v, const_pre_vector) {\n+        for (const T& v : const_pre_vector) {\n              local_check(v == real_vector[pos++]);\n         }\n-        BOOST_REVERSE_FOREACH(const T& v, const_pre_vector) {\n+        for (const T& v : reverse_iterate(const_pre_vector)) {\n              local_check(v == real_vector[--pos]);\n         }\n         CDataStream ss1(SER_DISK, 0);"
      },
      {
        "sha": "a18471588adf63ffaa21b6e4d30c2513d363bea2",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -24,7 +24,6 @@\n #include <string>\n #include <vector>\n \n-#include <boost/foreach.hpp>\n #include <boost/test/unit_test.hpp>\n \n #include <univalue.h>\n@@ -468,7 +467,7 @@ std::string JSONPrettyPrint(const UniValue& univalue)\n     }\n     return ret;\n }\n-}\n+} // namespace\n \n BOOST_AUTO_TEST_CASE(script_build)\n {\n@@ -927,7 +926,7 @@ BOOST_AUTO_TEST_CASE(script_build)\n \n     std::string strGen;\n \n-    BOOST_FOREACH(TestBuilder& test, tests) {\n+    for (TestBuilder& test : tests) {\n         test.Test();\n         std::string str = JSONPrettyPrint(test.GetJSON());\n #ifndef UPDATE_JSON_TESTS\n@@ -1033,7 +1032,7 @@ sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transac\n     // and vice-versa)\n     //\n     result << OP_0;\n-    BOOST_FOREACH(const CKey &key, keys)\n+    for (const CKey &key : keys)\n     {\n         std::vector<unsigned char> vchSig;\n         BOOST_CHECK(key.Sign(hash, vchSig));"
      },
      {
        "sha": "d3b8b072288b6d1686daa72833654b205e964e78",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"consensus/tx_verify.h\"\n+#include \"consensus/validation.h\"\n #include \"pubkey.h\"\n #include \"key.h\"\n #include \"script/script.h\"\n@@ -12,7 +13,6 @@\n \n #include <vector>\n \n-#include <boost/foreach.hpp>\n #include <boost/test/unit_test.hpp>\n \n // Helpers:"
      },
      {
        "sha": "af2a152aa5e13d59ab717bfb4e7ef3d8d4386d79",
        "filename": "src/test/streams_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/streams_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/streams_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/streams_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -7,7 +7,6 @@\n #include \"test/test_bitcoin.h\"\n \n #include <boost/assign/std/vector.hpp> // for 'operator+=()'\n-#include <boost/assert.hpp>\n #include <boost/test/unit_test.hpp>\n \n using namespace boost::assign; // bring 'operator+=()' into scope"
      },
      {
        "sha": "3ba81ed17b5e7ed53582aff9df7e8e3eb981844d",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 3,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -25,8 +25,6 @@\n \n #include <memory>\n \n-#include <boost/thread.hpp>\n-\n uint256 insecure_rand_seed = GetRandHash();\n FastRandomContext insecure_rand_ctx(insecure_rand_seed);\n \n@@ -35,10 +33,12 @@ extern void noui_connect();\n \n BasicTestingSetup::BasicTestingSetup(const std::string& chainName)\n {\n+        RandomInit();\n         ECC_Start();\n         SetupEnvironment();\n         SetupNetworking();\n         InitSignatureCache();\n+        InitScriptExecutionCache();\n         fPrintToDebugLog = false; // don't want to write to debug.log file\n         fCheckBlockIndex = true;\n         SelectParams(chainName);\n@@ -62,6 +62,12 @@ TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(cha\n         pathTemp = GetTempPath() / strprintf(\"test_bitcoin_%lu_%i\", (unsigned long)GetTime(), (int)(InsecureRandRange(100000)));\n         fs::create_directories(pathTemp);\n         ForceSetArg(\"-datadir\", pathTemp.string());\n+\n+        // Note that because we don't bother running a scheduler thread here,\n+        // callbacks via CValidationInterface are unreliable, but that's OK,\n+        // our unit tests aren't testing multiple parts of the code at once.\n+        GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n+\n         mempool.setSanityCheck(1.0);\n         pblocktree = new CBlockTreeDB(1 << 20, true);\n         pcoinsdbview = new CCoinsViewDB(1 << 23, true);\n@@ -88,6 +94,8 @@ TestingSetup::~TestingSetup()\n         UnregisterNodeSignals(GetNodeSignals());\n         threadGroup.interrupt_all();\n         threadGroup.join_all();\n+        GetMainSignals().FlushBackgroundCallbacks();\n+        GetMainSignals().UnregisterBackgroundSignalScheduler();\n         UnloadBlockIndex();\n         delete pcoinsTip;\n         delete pcoinsdbview;\n@@ -121,7 +129,7 @@ TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>&\n \n     // Replace mempool-selected txns with just coinbase plus passed-in txns:\n     block.vtx.resize(1);\n-    BOOST_FOREACH(const CMutableTransaction& tx, txns)\n+    for (const CMutableTransaction& tx : txns)\n         block.vtx.push_back(MakeTransactionRef(tx));\n     // IncrementExtraNonce creates a valid coinbase and merkleRoot\n     unsigned int extraNonce = 0;"
      },
      {
        "sha": "dd3b13c8c8944d80e3ece2e3e9e57bd907c31bb7",
        "filename": "src/test/test_bitcoin.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/test_bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/test_bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -10,6 +10,7 @@\n #include \"key.h\"\n #include \"pubkey.h\"\n #include \"random.h\"\n+#include \"scheduler.h\"\n #include \"txdb.h\"\n #include \"txmempool.h\"\n \n@@ -33,7 +34,6 @@ static inline uint256 InsecureRand256() { return insecure_rand_ctx.rand256(); }\n static inline uint64_t InsecureRandBits(int bits) { return insecure_rand_ctx.randbits(bits); }\n static inline uint64_t InsecureRandRange(uint64_t range) { return insecure_rand_ctx.randrange(range); }\n static inline bool InsecureRandBool() { return insecure_rand_ctx.randbool(); }\n-static inline std::vector<unsigned char> InsecureRandBytes(size_t len) { return insecure_rand_ctx.randbytes(len); }\n \n /** Basic testing setup.\n  * This just configures logging and chain parameters.\n@@ -54,6 +54,7 @@ struct TestingSetup: public BasicTestingSetup {\n     fs::path pathTemp;\n     boost::thread_group threadGroup;\n     CConnman* connman;\n+    CScheduler scheduler;\n \n     TestingSetup(const std::string& chainName = CBaseChainParams::MAIN);\n     ~TestingSetup();"
      },
      {
        "sha": "6654634bf1338f1df94cfe1a52af3189ff80a9d9",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 8,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -27,7 +27,6 @@\n #include <boost/algorithm/string/classification.hpp>\n #include <boost/algorithm/string/split.hpp>\n #include <boost/test/unit_test.hpp>\n-#include <boost/foreach.hpp>\n \n #include <univalue.h>\n \n@@ -65,7 +64,7 @@ unsigned int ParseScriptFlags(std::string strFlags)\n     std::vector<std::string> words;\n     boost::algorithm::split(words, strFlags, boost::algorithm::is_any_of(\",\"));\n \n-    BOOST_FOREACH(std::string word, words)\n+    for (std::string word : words)\n     {\n         if (!mapFlagNames.count(word))\n             BOOST_ERROR(\"Bad test: unknown verification flag '\" << word << \"'\");\n@@ -393,7 +392,7 @@ void CheckWithFlag(const CTransactionRef& output, const CMutableTransaction& inp\n static CScript PushAll(const std::vector<valtype>& values)\n {\n     CScript result;\n-    BOOST_FOREACH(const valtype& v, values) {\n+    for (const valtype& v : values) {\n         if (v.size() == 0) {\n             result << OP_0;\n         } else if (v.size() == 1 && v[0] >= 1 && v[0] <= 16) {\n@@ -693,7 +692,7 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)\n     BOOST_CHECK(IsStandardTx(t, reason));\n \n     // Check dust with default relay fee:\n-    CAmount nDustThreshold = 182 * dustRelayFee.GetFeePerK()/1000 * 3;\n+    CAmount nDustThreshold = 182 * dustRelayFee.GetFeePerK()/1000;\n     BOOST_CHECK_EQUAL(nDustThreshold, 546);\n     // dust:\n     t.vout[0].nValue = nDustThreshold - 1;\n@@ -703,13 +702,13 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)\n     BOOST_CHECK(IsStandardTx(t, reason));\n \n     // Check dust with odd relay fee to verify rounding:\n-    // nDustThreshold = 182 * 1234 / 1000 * 3\n-    dustRelayFee = CFeeRate(1234);\n+    // nDustThreshold = 182 * 3702 / 1000\n+    dustRelayFee = CFeeRate(3702);\n     // dust:\n-    t.vout[0].nValue = 672 - 1;\n+    t.vout[0].nValue = 673 - 1;\n     BOOST_CHECK(!IsStandardTx(t, reason));\n     // not dust:\n-    t.vout[0].nValue = 672;\n+    t.vout[0].nValue = 673;\n     BOOST_CHECK(IsStandardTx(t, reason));\n     dustRelayFee = CFeeRate(DUST_RELAY_TX_FEE);\n "
      },
      {
        "sha": "f609cb1af4e0f046189f675cde02c715e6d2787b",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 284,
        "deletions": 0,
        "changes": 284,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -10,11 +10,17 @@\n #include \"txmempool.h\"\n #include \"random.h\"\n #include \"script/standard.h\"\n+#include \"script/sign.h\"\n #include \"test/test_bitcoin.h\"\n #include \"utiltime.h\"\n+#include \"core_io.h\"\n+#include \"keystore.h\"\n+#include \"policy/policy.h\"\n \n #include <boost/test/unit_test.hpp>\n \n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks);\n+\n BOOST_AUTO_TEST_SUITE(tx_validationcache_tests)\n \n static bool\n@@ -84,4 +90,282 @@ BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n     BOOST_CHECK_EQUAL(mempool.size(), 0);\n }\n \n+// Run CheckInputs (using pcoinsTip) on the given transaction, for all script\n+// flags.  Test that CheckInputs passes for all flags that don't overlap with\n+// the failing_flags argument, but otherwise fails.\n+// CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY (and future NOP codes that may\n+// get reassigned) have an interaction with DISCOURAGE_UPGRADABLE_NOPS: if\n+// the script flags used contain DISCOURAGE_UPGRADABLE_NOPS but don't contain\n+// CHECKLOCKTIMEVERIFY (or CHECKSEQUENCEVERIFY), but the script does contain\n+// OP_CHECKLOCKTIMEVERIFY (or OP_CHECKSEQUENCEVERIFY), then script execution\n+// should fail.\n+// Capture this interaction with the upgraded_nop argument: set it when evaluating\n+// any script flag that is implemented as an upgraded NOP code.\n+void ValidateCheckInputsForAllFlags(CMutableTransaction &tx, uint32_t failing_flags, bool add_to_cache, bool upgraded_nop)\n+{\n+    PrecomputedTransactionData txdata(tx);\n+    // If we add many more flags, this loop can get too expensive, but we can\n+    // rewrite in the future to randomly pick a set of flags to evaluate.\n+    for (uint32_t test_flags=0; test_flags < (1U << 16); test_flags += 1) {\n+        CValidationState state;\n+        // Filter out incompatible flag choices\n+        if ((test_flags & SCRIPT_VERIFY_CLEANSTACK)) {\n+            // CLEANSTACK requires P2SH and WITNESS, see VerifyScript() in\n+            // script/interpreter.cpp\n+            test_flags |= SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS;\n+        }\n+        if ((test_flags & SCRIPT_VERIFY_WITNESS)) {\n+            // WITNESS requires P2SH\n+            test_flags |= SCRIPT_VERIFY_P2SH;\n+        }\n+        bool ret = CheckInputs(tx, state, pcoinsTip, true, test_flags, true, add_to_cache, txdata, nullptr);\n+        // CheckInputs should succeed iff test_flags doesn't intersect with\n+        // failing_flags\n+        bool expected_return_value = !(test_flags & failing_flags);\n+        if (expected_return_value && upgraded_nop) {\n+            // If the script flag being tested corresponds to an upgraded NOP,\n+            // then script execution should fail if DISCOURAGE_UPGRADABLE_NOPS\n+            // is set.\n+            expected_return_value = !(test_flags & SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS);\n+        }\n+        BOOST_CHECK_EQUAL(ret, expected_return_value);\n+\n+        // Test the caching\n+        if (ret && add_to_cache) {\n+            // Check that we get a cache hit if the tx was valid\n+            std::vector<CScriptCheck> scriptchecks;\n+            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip, true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK(scriptchecks.empty());\n+        } else {\n+            // Check that we get script executions to check, if the transaction\n+            // was invalid, or we didn't add to cache.\n+            std::vector<CScriptCheck> scriptchecks;\n+            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip, true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK_EQUAL(scriptchecks.size(), tx.vin.size());\n+        }\n+    }\n+}\n+\n+BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n+{\n+    // Test that passing CheckInputs with one set of script flags doesn't imply\n+    // that we would pass again with a different set of flags.\n+    InitScriptExecutionCache();\n+\n+    CScript p2pk_scriptPubKey = CScript() << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n+    CScript p2sh_scriptPubKey = GetScriptForDestination(CScriptID(p2pk_scriptPubKey));\n+    CScript p2pkh_scriptPubKey = GetScriptForDestination(coinbaseKey.GetPubKey().GetID());\n+    CScript p2wpkh_scriptPubKey = GetScriptForWitness(p2pkh_scriptPubKey);\n+\n+    CBasicKeyStore keystore;\n+    keystore.AddKey(coinbaseKey);\n+    keystore.AddCScript(p2pk_scriptPubKey);\n+\n+    // flags to test: SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, SCRIPT_VERIFY_CHECKSEQUENCE_VERIFY, SCRIPT_VERIFY_NULLDUMMY, uncompressed pubkey thing\n+\n+    // Create 2 outputs that match the three scripts above, spending the first\n+    // coinbase tx.\n+    CMutableTransaction spend_tx;\n+\n+    spend_tx.nVersion = 1;\n+    spend_tx.vin.resize(1);\n+    spend_tx.vin[0].prevout.hash = coinbaseTxns[0].GetHash();\n+    spend_tx.vin[0].prevout.n = 0;\n+    spend_tx.vout.resize(4);\n+    spend_tx.vout[0].nValue = 11*CENT;\n+    spend_tx.vout[0].scriptPubKey = p2sh_scriptPubKey;\n+    spend_tx.vout[1].nValue = 11*CENT;\n+    spend_tx.vout[1].scriptPubKey = p2wpkh_scriptPubKey;\n+    spend_tx.vout[2].nValue = 11*CENT;\n+    spend_tx.vout[2].scriptPubKey = CScript() << OP_CHECKLOCKTIMEVERIFY << OP_DROP << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n+    spend_tx.vout[3].nValue = 11*CENT;\n+    spend_tx.vout[3].scriptPubKey = CScript() << OP_CHECKSEQUENCEVERIFY << OP_DROP << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n+\n+    // Sign, with a non-DER signature\n+    {\n+        std::vector<unsigned char> vchSig;\n+        uint256 hash = SignatureHash(p2pk_scriptPubKey, spend_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n+        vchSig.push_back((unsigned char) 0); // padding byte makes this non-DER\n+        vchSig.push_back((unsigned char)SIGHASH_ALL);\n+        spend_tx.vin[0].scriptSig << vchSig;\n+    }\n+\n+    LOCK(cs_main);\n+\n+    // Test that invalidity under a set of flags doesn't preclude validity\n+    // under other (eg consensus) flags.\n+    // spend_tx is invalid according to DERSIG\n+    {\n+        CValidationState state;\n+        PrecomputedTransactionData ptd_spend_tx(spend_tx);\n+\n+        BOOST_CHECK(!CheckInputs(spend_tx, state, pcoinsTip, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n+\n+        // If we call again asking for scriptchecks (as happens in\n+        // ConnectBlock), we should add a script check object for this -- we're\n+        // not caching invalidity (if that changes, delete this test case).\n+        std::vector<CScriptCheck> scriptchecks;\n+        BOOST_CHECK(CheckInputs(spend_tx, state, pcoinsTip, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n+        BOOST_CHECK_EQUAL(scriptchecks.size(), 1);\n+\n+        // Test that CheckInputs returns true iff DERSIG-enforcing flags are\n+        // not present.  Don't add these checks to the cache, so that we can\n+        // test later that block validation works fine in the absence of cached\n+        // successes.\n+        ValidateCheckInputsForAllFlags(spend_tx, SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC, false, false);\n+\n+        // And if we produce a block with this tx, it should be valid (DERSIG not\n+        // enabled yet), even though there's no cache entry.\n+        CBlock block;\n+\n+        block = CreateAndProcessBlock({spend_tx}, p2pk_scriptPubKey);\n+        BOOST_CHECK(chainActive.Tip()->GetBlockHash() == block.GetHash());\n+        BOOST_CHECK(pcoinsTip->GetBestBlock() == block.GetHash());\n+    }\n+\n+    // Test P2SH: construct a transaction that is valid without P2SH, and\n+    // then test validity with P2SH.\n+    {\n+        CMutableTransaction invalid_under_p2sh_tx;\n+        invalid_under_p2sh_tx.nVersion = 1;\n+        invalid_under_p2sh_tx.vin.resize(1);\n+        invalid_under_p2sh_tx.vin[0].prevout.hash = spend_tx.GetHash();\n+        invalid_under_p2sh_tx.vin[0].prevout.n = 0;\n+        invalid_under_p2sh_tx.vout.resize(1);\n+        invalid_under_p2sh_tx.vout[0].nValue = 11*CENT;\n+        invalid_under_p2sh_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n+        std::vector<unsigned char> vchSig2(p2pk_scriptPubKey.begin(), p2pk_scriptPubKey.end());\n+        invalid_under_p2sh_tx.vin[0].scriptSig << vchSig2;\n+\n+        ValidateCheckInputsForAllFlags(invalid_under_p2sh_tx, SCRIPT_VERIFY_P2SH, true, false);\n+    }\n+\n+    // Test CHECKLOCKTIMEVERIFY\n+    {\n+        CMutableTransaction invalid_with_cltv_tx;\n+        invalid_with_cltv_tx.nVersion = 1;\n+        invalid_with_cltv_tx.nLockTime = 100;\n+        invalid_with_cltv_tx.vin.resize(1);\n+        invalid_with_cltv_tx.vin[0].prevout.hash = spend_tx.GetHash();\n+        invalid_with_cltv_tx.vin[0].prevout.n = 2;\n+        invalid_with_cltv_tx.vin[0].nSequence = 0;\n+        invalid_with_cltv_tx.vout.resize(1);\n+        invalid_with_cltv_tx.vout[0].nValue = 11*CENT;\n+        invalid_with_cltv_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n+\n+        // Sign\n+        std::vector<unsigned char> vchSig;\n+        uint256 hash = SignatureHash(spend_tx.vout[2].scriptPubKey, invalid_with_cltv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n+        vchSig.push_back((unsigned char)SIGHASH_ALL);\n+        invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n+\n+        ValidateCheckInputsForAllFlags(invalid_with_cltv_tx, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true);\n+\n+        // Make it valid, and check again\n+        invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n+        CValidationState state;\n+        PrecomputedTransactionData txdata(invalid_with_cltv_tx);\n+        BOOST_CHECK(CheckInputs(invalid_with_cltv_tx, state, pcoinsTip, true, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n+    }\n+\n+    // TEST CHECKSEQUENCEVERIFY\n+    {\n+        CMutableTransaction invalid_with_csv_tx;\n+        invalid_with_csv_tx.nVersion = 2;\n+        invalid_with_csv_tx.vin.resize(1);\n+        invalid_with_csv_tx.vin[0].prevout.hash = spend_tx.GetHash();\n+        invalid_with_csv_tx.vin[0].prevout.n = 3;\n+        invalid_with_csv_tx.vin[0].nSequence = 100;\n+        invalid_with_csv_tx.vout.resize(1);\n+        invalid_with_csv_tx.vout[0].nValue = 11*CENT;\n+        invalid_with_csv_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n+\n+        // Sign\n+        std::vector<unsigned char> vchSig;\n+        uint256 hash = SignatureHash(spend_tx.vout[3].scriptPubKey, invalid_with_csv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n+        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n+        vchSig.push_back((unsigned char)SIGHASH_ALL);\n+        invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n+\n+        ValidateCheckInputsForAllFlags(invalid_with_csv_tx, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true);\n+\n+        // Make it valid, and check again\n+        invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n+        CValidationState state;\n+        PrecomputedTransactionData txdata(invalid_with_csv_tx);\n+        BOOST_CHECK(CheckInputs(invalid_with_csv_tx, state, pcoinsTip, true, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n+    }\n+\n+    // TODO: add tests for remaining script flags\n+\n+    // Test that passing CheckInputs with a valid witness doesn't imply success\n+    // for the same tx with a different witness.\n+    {\n+        CMutableTransaction valid_with_witness_tx;\n+        valid_with_witness_tx.nVersion = 1;\n+        valid_with_witness_tx.vin.resize(1);\n+        valid_with_witness_tx.vin[0].prevout.hash = spend_tx.GetHash();\n+        valid_with_witness_tx.vin[0].prevout.n = 1;\n+        valid_with_witness_tx.vout.resize(1);\n+        valid_with_witness_tx.vout[0].nValue = 11*CENT;\n+        valid_with_witness_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n+\n+        // Sign\n+        SignatureData sigdata;\n+        ProduceSignature(MutableTransactionSignatureCreator(&keystore, &valid_with_witness_tx, 0, 11*CENT, SIGHASH_ALL), spend_tx.vout[1].scriptPubKey, sigdata);\n+        UpdateTransaction(valid_with_witness_tx, 0, sigdata);\n+\n+        // This should be valid under all script flags.\n+        ValidateCheckInputsForAllFlags(valid_with_witness_tx, 0, true, false);\n+\n+        // Remove the witness, and check that it is now invalid.\n+        valid_with_witness_tx.vin[0].scriptWitness.SetNull();\n+        ValidateCheckInputsForAllFlags(valid_with_witness_tx, SCRIPT_VERIFY_WITNESS, true, false);\n+    }\n+\n+    {\n+        // Test a transaction with multiple inputs.\n+        CMutableTransaction tx;\n+\n+        tx.nVersion = 1;\n+        tx.vin.resize(2);\n+        tx.vin[0].prevout.hash = spend_tx.GetHash();\n+        tx.vin[0].prevout.n = 0;\n+        tx.vin[1].prevout.hash = spend_tx.GetHash();\n+        tx.vin[1].prevout.n = 1;\n+        tx.vout.resize(1);\n+        tx.vout[0].nValue = 22*CENT;\n+        tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n+\n+        // Sign\n+        for (int i=0; i<2; ++i) {\n+            SignatureData sigdata;\n+            ProduceSignature(MutableTransactionSignatureCreator(&keystore, &tx, i, 11*CENT, SIGHASH_ALL), spend_tx.vout[i].scriptPubKey, sigdata);\n+            UpdateTransaction(tx, i, sigdata);\n+        }\n+\n+        // This should be valid under all script flags\n+        ValidateCheckInputsForAllFlags(tx, 0, true, false);\n+\n+        // Check that if the second input is invalid, but the first input is\n+        // valid, the transaction is not cached.\n+        // Invalidate vin[1]\n+        tx.vin[1].scriptWitness.SetNull();\n+\n+        CValidationState state;\n+        PrecomputedTransactionData txdata(tx);\n+        // This transaction is now invalid under segwit, because of the second input.\n+        BOOST_CHECK(!CheckInputs(tx, state, pcoinsTip, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n+\n+        std::vector<CScriptCheck> scriptchecks;\n+        // Make sure this transaction was not cached (ie because the first\n+        // input was valid)\n+        BOOST_CHECK(CheckInputs(tx, state, pcoinsTip, true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n+        // Should get 2 script checks back -- caching is on a whole-transaction basis.\n+        BOOST_CHECK_EQUAL(scriptchecks.size(), 2);\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "722f6ae059ce4d8fc49fc8bc0e52a12a33b5c62a",
        "filename": "src/test/versionbits_tests.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/versionbits_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/test/versionbits_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/versionbits_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -22,11 +22,11 @@ class TestConditionChecker : public AbstractThresholdConditionChecker\n     mutable ThresholdConditionCache cache;\n \n public:\n-    int64_t BeginTime(const Consensus::Params& params) const { return TestTime(10000); }\n-    int64_t EndTime(const Consensus::Params& params) const { return TestTime(20000); }\n-    int Period(const Consensus::Params& params) const { return 1000; }\n-    int Threshold(const Consensus::Params& params) const { return 900; }\n-    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const { return (pindex->nVersion & 0x100); }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return TestTime(10000); }\n+    int64_t EndTime(const Consensus::Params& params) const override { return TestTime(20000); }\n+    int Period(const Consensus::Params& params) const override { return 1000; }\n+    int Threshold(const Consensus::Params& params) const override { return 900; }\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override { return (pindex->nVersion & 0x100); }\n \n     ThresholdState GetStateFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateFor(pindexPrev, paramsDummy, cache); }\n     int GetStateSinceHeightFor(const CBlockIndex* pindexPrev) const { return AbstractThresholdConditionChecker::GetStateSinceHeightFor(pindexPrev, paramsDummy, cache); }"
      },
      {
        "sha": "099ed7f04259e325c8df9eae81af4262a753f094",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -15,7 +15,6 @@\n #include \"utilstrencodings.h\"\n #include \"warnings.h\"\n \n-#include <boost/foreach.hpp>\n \n static CCriticalSection cs_nTimeOffset;\n static int64_t nTimeOffset = 0;\n@@ -95,7 +94,7 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n             {\n                 // If nobody has a time different than ours but within 5 minutes of ours, give a warning\n                 bool fMatch = false;\n-                BOOST_FOREACH(int64_t nOffset, vSorted)\n+                for (int64_t nOffset : vSorted)\n                     if (nOffset != 0 && abs64(nOffset) < 5 * 60)\n                         fMatch = true;\n \n@@ -110,7 +109,7 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n         }\n \n         if (LogAcceptCategory(BCLog::NET)) {\n-            BOOST_FOREACH(int64_t n, vSorted) {\n+            for (int64_t n : vSorted) {\n                 LogPrint(BCLog::NET, \"%+d  \", n);\n             }\n             LogPrint(BCLog::NET, \"|  \");"
      },
      {
        "sha": "ac13f73e705ea42256391619a1b28109bf4ebfec",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -17,8 +17,6 @@\n \n #include <boost/bind.hpp>\n #include <boost/signals2/signal.hpp>\n-#include <boost/foreach.hpp>\n-#include <boost/algorithm/string/predicate.hpp>\n #include <boost/algorithm/string/split.hpp>\n #include <boost/algorithm/string/classification.hpp>\n #include <boost/algorithm/string/replace.hpp>\n@@ -377,8 +375,10 @@ static std::pair<bool,std::string> ReadBinaryFile(const fs::path &filename, size\n     while ((n=fread(buffer, 1, sizeof(buffer), f)) > 0) {\n         // Check for reading errors so we don't return any data if we couldn't\n         // read the entire file (or up to maxsize)\n-        if (ferror(f))\n+        if (ferror(f)) {\n+            fclose(f);\n             return std::make_pair(false,\"\");\n+        }\n         retval.append(buffer, buffer+n);\n         if (retval.size() > maxsize)\n             break;\n@@ -406,7 +406,7 @@ static bool WriteBinaryFile(const fs::path &filename, const std::string &data)\n /****** Bitcoin specific TorController implementation ********/\n \n /** Controller that connects to Tor control socket, authenticate, then create\n- * and maintain a ephemeral hidden service.\n+ * and maintain an ephemeral hidden service.\n  */\n class TorController\n {\n@@ -487,7 +487,7 @@ void TorController::add_onion_cb(TorControlConnection& _conn, const TorControlRe\n {\n     if (reply.code == 250) {\n         LogPrint(BCLog::TOR, \"tor: ADD_ONION successful\\n\");\n-        BOOST_FOREACH(const std::string &s, reply.lines) {\n+        for (const std::string &s : reply.lines) {\n             std::map<std::string,std::string> m = ParseTorReplyMapping(s);\n             std::map<std::string,std::string>::iterator i;\n             if ((i = m.find(\"ServiceID\")) != m.end())\n@@ -617,7 +617,7 @@ void TorController::protocolinfo_cb(TorControlConnection& _conn, const TorContro\n          * 250-AUTH METHODS=NULL\n          * 250-AUTH METHODS=HASHEDPASSWORD\n          */\n-        BOOST_FOREACH(const std::string &s, reply.lines) {\n+        for (const std::string &s : reply.lines) {\n             std::pair<std::string,std::string> l = SplitTorReplyLine(s);\n             if (l.first == \"AUTH\") {\n                 std::map<std::string,std::string> m = ParseTorReplyMapping(l.second);\n@@ -634,7 +634,7 @@ void TorController::protocolinfo_cb(TorControlConnection& _conn, const TorContro\n                 }\n             }\n         }\n-        BOOST_FOREACH(const std::string &s, methods) {\n+        for (const std::string &s : methods) {\n             LogPrint(BCLog::TOR, \"tor: Supported authentication method: %s\\n\", s);\n         }\n         // Prefer NULL, otherwise SAFECOOKIE. If a password is provided, use HASHEDPASSWORD\n@@ -662,7 +662,7 @@ void TorController::protocolinfo_cb(TorControlConnection& _conn, const TorContro\n                 // _conn.Command(\"AUTHENTICATE \" + HexStr(status_cookie.second), boost::bind(&TorController::auth_cb, this, _1, _2));\n                 cookie = std::vector<uint8_t>(status_cookie.second.begin(), status_cookie.second.end());\n                 clientNonce = std::vector<uint8_t>(TOR_NONCE_SIZE, 0);\n-                GetRandBytes(&clientNonce[0], TOR_NONCE_SIZE);\n+                GetRandBytes(clientNonce.data(), TOR_NONCE_SIZE);\n                 _conn.Command(\"AUTHCHALLENGE SAFECOOKIE \" + HexStr(clientNonce), boost::bind(&TorController::authchallenge_cb, this, _1, _2));\n             } else {\n                 if (status_cookie.first) {"
      },
      {
        "sha": "aa0b73a41748badb54dd84c8d795681909864924",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 76,
        "deletions": 8,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -7,8 +7,12 @@\n \n #include \"chainparams.h\"\n #include \"hash.h\"\n+#include \"random.h\"\n #include \"pow.h\"\n #include \"uint256.h\"\n+#include \"util.h\"\n+#include \"ui_interface.h\"\n+#include \"init.h\"\n \n #include <stdint.h>\n \n@@ -21,6 +25,7 @@ static const char DB_TXINDEX = 't';\n static const char DB_BLOCK_INDEX = 'b';\n \n static const char DB_BEST_BLOCK = 'B';\n+static const char DB_HEAD_BLOCKS = 'H';\n static const char DB_FLAG = 'F';\n static const char DB_REINDEX_FLAG = 'R';\n static const char DB_LAST_BLOCK = 'l';\n@@ -68,10 +73,39 @@ uint256 CCoinsViewDB::GetBestBlock() const {\n     return hashBestChain;\n }\n \n+std::vector<uint256> CCoinsViewDB::GetHeadBlocks() const {\n+    std::vector<uint256> vhashHeadBlocks;\n+    if (!db.Read(DB_HEAD_BLOCKS, vhashHeadBlocks)) {\n+        return std::vector<uint256>();\n+    }\n+    return vhashHeadBlocks;\n+}\n+\n bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     CDBBatch batch(db);\n     size_t count = 0;\n     size_t changed = 0;\n+    size_t batch_size = (size_t)GetArg(\"-dbbatchsize\", nDefaultDbBatchSize);\n+    int crash_simulate = GetArg(\"-dbcrashratio\", 0);\n+    assert(!hashBlock.IsNull());\n+\n+    uint256 old_tip = GetBestBlock();\n+    if (old_tip.IsNull()) {\n+        // We may be in the middle of replaying.\n+        std::vector<uint256> old_heads = GetHeadBlocks();\n+        if (old_heads.size() == 2) {\n+            assert(old_heads[0] == hashBlock);\n+            old_tip = old_heads[1];\n+        }\n+    }\n+\n+    // In the first batch, mark the database as being in the middle of a\n+    // transition from old_tip to hashBlock.\n+    // A vector is used for future extensibility, as we may want to support\n+    // interrupting after partial writes from multiple independent reorgs.\n+    batch.Erase(DB_BEST_BLOCK);\n+    batch.Write(DB_HEAD_BLOCKS, std::vector<uint256>{hashBlock, old_tip});\n+\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n             CoinEntry entry(&it->first);\n@@ -84,10 +118,25 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n         count++;\n         CCoinsMap::iterator itOld = it++;\n         mapCoins.erase(itOld);\n+        if (batch.SizeEstimate() > batch_size) {\n+            LogPrint(BCLog::COINDB, \"Writing partial batch of %.2f MiB\\n\", batch.SizeEstimate() * (1.0 / 1048576.0));\n+            db.WriteBatch(batch);\n+            batch.Clear();\n+            if (crash_simulate) {\n+                static FastRandomContext rng;\n+                if (rng.randrange(crash_simulate) == 0) {\n+                    LogPrintf(\"Simulating a crash. Goodbye.\\n\");\n+                    _Exit(0);\n+                }\n+            }\n+        }\n     }\n-    if (!hashBlock.IsNull())\n-        batch.Write(DB_BEST_BLOCK, hashBlock);\n \n+    // In the last batch, mark the database as consistent with hashBlock again.\n+    batch.Erase(DB_HEAD_BLOCKS);\n+    batch.Write(DB_BEST_BLOCK, hashBlock);\n+\n+    LogPrint(BCLog::COINDB, \"Writing final batch of %.2f MiB\\n\", batch.SizeEstimate() * (1.0 / 1048576.0));\n     bool ret = db.WriteBatch(batch);\n     LogPrint(BCLog::COINDB, \"Committed %u changed transaction outputs (out of %u) to coin database...\\n\", (unsigned int)changed, (unsigned int)count);\n     return ret;\n@@ -123,7 +172,7 @@ bool CBlockTreeDB::ReadLastBlockFile(int &nFile) {\n \n CCoinsViewCursor *CCoinsViewDB::Cursor() const\n {\n-    CCoinsViewDBCursor *i = new CCoinsViewDBCursor(const_cast<CDBWrapper*>(&db)->NewIterator(), GetBestBlock());\n+    CCoinsViewDBCursor *i = new CCoinsViewDBCursor(const_cast<CDBWrapper&>(db).NewIterator(), GetBestBlock());\n     /* It seems that there are no \"const iterators\" for LevelDB.  Since we\n        only need read operations on it, use a const-cast to get around\n        that restriction.  */\n@@ -210,7 +259,7 @@ bool CBlockTreeDB::ReadFlag(const std::string &name, bool &fValue) {\n     return true;\n }\n \n-bool CBlockTreeDB::LoadBlockIndexGuts(std::function<CBlockIndex*(const uint256&)> insertBlockIndex)\n+bool CBlockTreeDB::LoadBlockIndexGuts(const Consensus::Params& consensusParams, std::function<CBlockIndex*(const uint256&)> insertBlockIndex)\n {\n     std::unique_ptr<CDBIterator> pcursor(NewIterator());\n \n@@ -238,12 +287,12 @@ bool CBlockTreeDB::LoadBlockIndexGuts(std::function<CBlockIndex*(const uint256&)\n                 pindexNew->nStatus        = diskindex.nStatus;\n                 pindexNew->nTx            = diskindex.nTx;\n \n-                if (!CheckProofOfWork(pindexNew->GetBlockHash(), pindexNew->nBits, Params().GetConsensus()))\n-                    return error(\"LoadBlockIndex(): CheckProofOfWork failed: %s\", pindexNew->ToString());\n+                if (!CheckProofOfWork(pindexNew->GetBlockHash(), pindexNew->nBits, consensusParams))\n+                    return error(\"%s: CheckProofOfWork failed: %s\", __func__, pindexNew->ToString());\n \n                 pcursor->Next();\n             } else {\n-                return error(\"LoadBlockIndex() : failed to read value\");\n+                return error(\"%s: failed to read value\", __func__);\n             }\n         } else {\n             break;\n@@ -319,13 +368,30 @@ bool CCoinsViewDB::Upgrade() {\n         return true;\n     }\n \n-    LogPrintf(\"Upgrading database...\\n\");\n+    int64_t count = 0;\n+    LogPrintf(\"Upgrading utxo-set database...\\n\");\n+    LogPrintf(\"[0%%]...\");\n     size_t batch_size = 1 << 24;\n     CDBBatch batch(db);\n+    uiInterface.SetProgressBreakAction(StartShutdown);\n+    int reportDone = 0;\n     while (pcursor->Valid()) {\n         boost::this_thread::interruption_point();\n+        if (ShutdownRequested()) {\n+            break;\n+        }\n         std::pair<unsigned char, uint256> key;\n         if (pcursor->GetKey(key) && key.first == DB_COINS) {\n+            if (count++ % 256 == 0) {\n+                uint32_t high = 0x100 * *key.second.begin() + *(key.second.begin() + 1);\n+                int percentageDone = (int)(high * 100.0 / 65536.0 + 0.5);\n+                uiInterface.ShowProgress(_(\"Upgrading UTXO database\") + \"\\n\"+ _(\"(press q to shutdown and continue later)\") + \"\\n\", percentageDone);\n+                if (reportDone < percentageDone/10) {\n+                    // report max. every 10% step\n+                    LogPrintf(\"[%d%%]...\", percentageDone);\n+                    reportDone = percentageDone/10;\n+                }\n+            }\n             CCoins old_coins;\n             if (!pcursor->GetValue(old_coins)) {\n                 return error(\"%s: cannot parse CCoins record\", __func__);\n@@ -350,5 +416,7 @@ bool CCoinsViewDB::Upgrade() {\n         }\n     }\n     db.WriteBatch(batch);\n+    uiInterface.SetProgressBreakAction(std::function<void(void)>());\n+    LogPrintf(\"[%s].\\n\", ShutdownRequested() ? \"CANCELLED\" : \"DONE\");\n     return true;\n }"
      },
      {
        "sha": "adcbc73380d116ef3cf8fd6fab5e112ea554a7b7",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -19,12 +19,12 @@ class CBlockIndex;\n class CCoinsViewDBCursor;\n class uint256;\n \n-//! Compensate for extra memory peak (x1.5-x1.9) at flush time.\n-static constexpr int DB_PEAK_USAGE_FACTOR = 2;\n //! No need to periodic flush if at least this much space still available.\n-static constexpr int MAX_BLOCK_COINSDB_USAGE = 10 * DB_PEAK_USAGE_FACTOR;\n+static constexpr int MAX_BLOCK_COINSDB_USAGE = 10;\n //! -dbcache default (MiB)\n static const int64_t nDefaultDbCache = 450;\n+//! -dbbatchsize default (bytes)\n+static const int64_t nDefaultDbBatchSize = 16 << 20;\n //! max. -dbcache (MiB)\n static const int64_t nMaxDbCache = sizeof(void*) > 4 ? 16384 : 1024;\n //! min. -dbcache (MiB)\n@@ -74,6 +74,7 @@ class CCoinsViewDB : public CCoinsView\n     bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n     bool HaveCoin(const COutPoint &outpoint) const override;\n     uint256 GetBestBlock() const override;\n+    std::vector<uint256> GetHeadBlocks() const override;\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n     CCoinsViewCursor *Cursor() const override;\n \n@@ -88,12 +89,12 @@ class CCoinsViewDBCursor: public CCoinsViewCursor\n public:\n     ~CCoinsViewDBCursor() {}\n \n-    bool GetKey(COutPoint &key) const;\n-    bool GetValue(Coin &coin) const;\n-    unsigned int GetValueSize() const;\n+    bool GetKey(COutPoint &key) const override;\n+    bool GetValue(Coin &coin) const override;\n+    unsigned int GetValueSize() const override;\n \n-    bool Valid() const;\n-    void Next();\n+    bool Valid() const override;\n+    void Next() override;\n \n private:\n     CCoinsViewDBCursor(CDBIterator* pcursorIn, const uint256 &hashBlockIn):\n@@ -122,7 +123,7 @@ class CBlockTreeDB : public CDBWrapper\n     bool WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> > &list);\n     bool WriteFlag(const std::string &name, bool fValue);\n     bool ReadFlag(const std::string &name, bool &fValue);\n-    bool LoadBlockIndexGuts(std::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n+    bool LoadBlockIndexGuts(const Consensus::Params& consensusParams, std::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n };\n \n #endif // BITCOIN_TXDB_H"
      },
      {
        "sha": "4a81055231b008e8bd74ce99010712be9cbce58d",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 38,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -11,6 +11,7 @@\n #include \"validation.h\"\n #include \"policy/policy.h\"\n #include \"policy/fees.h\"\n+#include \"reverse_iterator.h\"\n #include \"streams.h\"\n #include \"timedata.h\"\n #include \"util.h\"\n@@ -73,12 +74,12 @@ void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendan\n         setAllDescendants.insert(cit);\n         stageEntries.erase(cit);\n         const setEntries &setChildren = GetMemPoolChildren(cit);\n-        BOOST_FOREACH(const txiter childEntry, setChildren) {\n+        for (const txiter childEntry : setChildren) {\n             cacheMap::iterator cacheIt = cachedDescendants.find(childEntry);\n             if (cacheIt != cachedDescendants.end()) {\n                 // We've already calculated this one, just add the entries for this set\n                 // but don't traverse again.\n-                BOOST_FOREACH(const txiter cacheEntry, cacheIt->second) {\n+                for (const txiter cacheEntry : cacheIt->second) {\n                     setAllDescendants.insert(cacheEntry);\n                 }\n             } else if (!setAllDescendants.count(childEntry)) {\n@@ -92,7 +93,7 @@ void CTxMemPool::UpdateForDescendants(txiter updateIt, cacheMap &cachedDescendan\n     int64_t modifySize = 0;\n     CAmount modifyFee = 0;\n     int64_t modifyCount = 0;\n-    BOOST_FOREACH(txiter cit, setAllDescendants) {\n+    for (txiter cit : setAllDescendants) {\n         if (!setExclude.count(cit->GetTx().GetHash())) {\n             modifySize += cit->GetTxSize();\n             modifyFee += cit->GetModifiedFee();\n@@ -122,12 +123,12 @@ void CTxMemPool::UpdateTransactionsFromBlock(const std::vector<uint256> &vHashes\n     // accounted for in the state of their ancestors)\n     std::set<uint256> setAlreadyIncluded(vHashesToUpdate.begin(), vHashesToUpdate.end());\n \n-    // Iterate in reverse, so that whenever we are looking at at a transaction\n+    // Iterate in reverse, so that whenever we are looking at a transaction\n     // we are sure that all in-mempool descendants have already been processed.\n     // This maximizes the benefit of the descendant cache and guarantees that\n     // setMemPoolChildren will be updated, an assumption made in\n     // UpdateForDescendants.\n-    BOOST_REVERSE_FOREACH(const uint256 &hash, vHashesToUpdate) {\n+    for (const uint256 &hash : reverse_iterate(vHashesToUpdate)) {\n         // we cache the in-mempool children to avoid duplicate updates\n         setEntries setChildren;\n         // calculate children from mapNextTx\n@@ -202,7 +203,7 @@ bool CTxMemPool::CalculateMemPoolAncestors(const CTxMemPoolEntry &entry, setEntr\n         }\n \n         const setEntries & setMemPoolParents = GetMemPoolParents(stageit);\n-        BOOST_FOREACH(const txiter &phash, setMemPoolParents) {\n+        for (const txiter &phash : setMemPoolParents) {\n             // If this is a new ancestor, add it.\n             if (setAncestors.count(phash) == 0) {\n                 parentHashes.insert(phash);\n@@ -221,13 +222,13 @@ void CTxMemPool::UpdateAncestorsOf(bool add, txiter it, setEntries &setAncestors\n {\n     setEntries parentIters = GetMemPoolParents(it);\n     // add or remove this tx as a child of each parent\n-    BOOST_FOREACH(txiter piter, parentIters) {\n+    for (txiter piter : parentIters) {\n         UpdateChild(piter, it, add);\n     }\n     const int64_t updateCount = (add ? 1 : -1);\n     const int64_t updateSize = updateCount * it->GetTxSize();\n     const CAmount updateFee = updateCount * it->GetModifiedFee();\n-    BOOST_FOREACH(txiter ancestorIt, setAncestors) {\n+    for (txiter ancestorIt : setAncestors) {\n         mapTx.modify(ancestorIt, update_descendant_state(updateSize, updateFee, updateCount));\n     }\n }\n@@ -238,7 +239,7 @@ void CTxMemPool::UpdateEntryForAncestors(txiter it, const setEntries &setAncesto\n     int64_t updateSize = 0;\n     CAmount updateFee = 0;\n     int64_t updateSigOpsCost = 0;\n-    BOOST_FOREACH(txiter ancestorIt, setAncestors) {\n+    for (txiter ancestorIt : setAncestors) {\n         updateSize += ancestorIt->GetTxSize();\n         updateFee += ancestorIt->GetModifiedFee();\n         updateSigOpsCost += ancestorIt->GetSigOpCost();\n@@ -249,7 +250,7 @@ void CTxMemPool::UpdateEntryForAncestors(txiter it, const setEntries &setAncesto\n void CTxMemPool::UpdateChildrenForRemoval(txiter it)\n {\n     const setEntries &setMemPoolChildren = GetMemPoolChildren(it);\n-    BOOST_FOREACH(txiter updateIt, setMemPoolChildren) {\n+    for (txiter updateIt : setMemPoolChildren) {\n         UpdateParent(updateIt, it, false);\n     }\n }\n@@ -266,19 +267,19 @@ void CTxMemPool::UpdateForRemoveFromMempool(const setEntries &entriesToRemove, b\n         // Here we only update statistics and not data in mapLinks (which\n         // we need to preserve until we're finished with all operations that\n         // need to traverse the mempool).\n-        BOOST_FOREACH(txiter removeIt, entriesToRemove) {\n+        for (txiter removeIt : entriesToRemove) {\n             setEntries setDescendants;\n             CalculateDescendants(removeIt, setDescendants);\n             setDescendants.erase(removeIt); // don't update state for self\n             int64_t modifySize = -((int64_t)removeIt->GetTxSize());\n             CAmount modifyFee = -removeIt->GetModifiedFee();\n             int modifySigOps = -removeIt->GetSigOpCost();\n-            BOOST_FOREACH(txiter dit, setDescendants) {\n+            for (txiter dit : setDescendants) {\n                 mapTx.modify(dit, update_ancestor_state(modifySize, modifyFee, -1, modifySigOps));\n             }\n         }\n     }\n-    BOOST_FOREACH(txiter removeIt, entriesToRemove) {\n+    for (txiter removeIt : entriesToRemove) {\n         setEntries setAncestors;\n         const CTxMemPoolEntry &entry = *removeIt;\n         std::string dummy;\n@@ -307,7 +308,7 @@ void CTxMemPool::UpdateForRemoveFromMempool(const setEntries &entriesToRemove, b\n     // After updating all the ancestor sizes, we can now sever the link between each\n     // transaction being removed and any mempool children (ie, update setMemPoolParents\n     // for each direct child of a transaction being removed).\n-    BOOST_FOREACH(txiter removeIt, entriesToRemove) {\n+    for (txiter removeIt : entriesToRemove) {\n         UpdateChildrenForRemoval(removeIt);\n     }\n }\n@@ -401,7 +402,7 @@ bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry,\n     // to clean up the mess we're leaving here.\n \n     // Update ancestors with information about this tx\n-    BOOST_FOREACH (const uint256 &phash, setParentTransactions) {\n+    for (const uint256 &phash : setParentTransactions) {\n         txiter pit = mapTx.find(phash);\n         if (pit != mapTx.end()) {\n             UpdateParent(newit, pit, true);\n@@ -424,7 +425,7 @@ void CTxMemPool::removeUnchecked(txiter it, MemPoolRemovalReason reason)\n {\n     NotifyEntryRemoved(it->GetSharedTx(), reason);\n     const uint256 hash = it->GetTx().GetHash();\n-    BOOST_FOREACH(const CTxIn& txin, it->GetTx().vin)\n+    for (const CTxIn& txin : it->GetTx().vin)\n         mapNextTx.erase(txin.prevout);\n \n     if (vTxHashes.size() > 1) {\n@@ -466,7 +467,7 @@ void CTxMemPool::CalculateDescendants(txiter entryit, setEntries &setDescendants\n         stage.erase(it);\n \n         const setEntries &setChildren = GetMemPoolChildren(it);\n-        BOOST_FOREACH(const txiter &childiter, setChildren) {\n+        for (const txiter &childiter : setChildren) {\n             if (!setDescendants.count(childiter)) {\n                 stage.insert(childiter);\n             }\n@@ -498,7 +499,7 @@ void CTxMemPool::removeRecursive(const CTransaction &origTx, MemPoolRemovalReaso\n             }\n         }\n         setEntries setAllRemoves;\n-        BOOST_FOREACH(txiter it, txToRemove) {\n+        for (txiter it : txToRemove) {\n             CalculateDescendants(it, setAllRemoves);\n         }\n \n@@ -520,7 +521,7 @@ void CTxMemPool::removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMem\n             // So it's critical that we remove the tx and not depend on the LockPoints.\n             txToRemove.insert(it);\n         } else if (it->GetSpendsCoinbase()) {\n-            BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+            for (const CTxIn& txin : tx.vin) {\n                 indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n                 if (it2 != mapTx.end())\n                     continue;\n@@ -547,7 +548,7 @@ void CTxMemPool::removeConflicts(const CTransaction &tx)\n {\n     // Remove transactions which depend on inputs of tx, recursively\n     LOCK(cs);\n-    BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n+    for (const CTxIn &txin : tx.vin) {\n         auto it = mapNextTx.find(txin.prevout);\n         if (it != mapNextTx.end()) {\n             const CTransaction &txConflict = *it->second;\n@@ -642,7 +643,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n         setEntries setParentCheck;\n         int64_t parentSizes = 0;\n         int64_t parentSigOpCost = 0;\n-        BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n+        for (const CTxIn &txin : tx.vin) {\n             // Check that every mempool transaction's inputs refer to available coins, or other mempool tx's.\n             indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n             if (it2 != mapTx.end()) {\n@@ -674,7 +675,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n         CAmount nFeesCheck = it->GetModifiedFee();\n         int64_t nSigOpCheck = it->GetSigOpCost();\n \n-        BOOST_FOREACH(txiter ancestorIt, setAncestors) {\n+        for (txiter ancestorIt : setAncestors) {\n             nSizeCheck += ancestorIt->GetTxSize();\n             nFeesCheck += ancestorIt->GetModifiedFee();\n             nSigOpCheck += ancestorIt->GetSigOpCost();\n@@ -769,7 +770,7 @@ class DepthAndScoreComparator\n         return counta < countb;\n     }\n };\n-}\n+} // namespace\n \n std::vector<CTxMemPool::indexed_transaction_set::const_iterator> CTxMemPool::GetSortedDepthAndScore() const\n {\n@@ -848,14 +849,14 @@ void CTxMemPool::PrioritiseTransaction(const uint256& hash, const CAmount& nFeeD\n             uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\n             std::string dummy;\n             CalculateMemPoolAncestors(*it, setAncestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, false);\n-            BOOST_FOREACH(txiter ancestorIt, setAncestors) {\n+            for (txiter ancestorIt : setAncestors) {\n                 mapTx.modify(ancestorIt, update_descendant_state(0, nFeeDelta, 0));\n             }\n             // Now update all descendants' modified fees with ancestors\n             setEntries setDescendants;\n             CalculateDescendants(it, setDescendants);\n             setDescendants.erase(it);\n-            BOOST_FOREACH(txiter descendantIt, setDescendants) {\n+            for (txiter descendantIt : setDescendants) {\n                 mapTx.modify(descendantIt, update_ancestor_state(0, nFeeDelta, 0, 0));\n             }\n             ++nTransactionsUpdated;\n@@ -903,11 +904,7 @@ bool CCoinsViewMemPool::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n             return false;\n         }\n     }\n-    return (base->GetCoin(outpoint, coin) && !coin.IsSpent());\n-}\n-\n-bool CCoinsViewMemPool::HaveCoin(const COutPoint &outpoint) const {\n-    return mempool.exists(outpoint) || base->HaveCoin(outpoint);\n+    return base->GetCoin(outpoint, coin);\n }\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n@@ -919,7 +916,7 @@ size_t CTxMemPool::DynamicMemoryUsage() const {\n void CTxMemPool::RemoveStaged(setEntries &stage, bool updateDescendants, MemPoolRemovalReason reason) {\n     AssertLockHeld(cs);\n     UpdateForRemoveFromMempool(stage, updateDescendants);\n-    BOOST_FOREACH(const txiter& it, stage) {\n+    for (const txiter& it : stage) {\n         removeUnchecked(it, reason);\n     }\n }\n@@ -933,7 +930,7 @@ int CTxMemPool::Expire(int64_t time) {\n         it++;\n     }\n     setEntries stage;\n-    BOOST_FOREACH(txiter removeit, toremove) {\n+    for (txiter removeit : toremove) {\n         CalculateDescendants(removeit, stage);\n     }\n     RemoveStaged(stage, false, MemPoolRemovalReason::EXPIRY);\n@@ -1042,17 +1039,15 @@ void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpends\n         std::vector<CTransaction> txn;\n         if (pvNoSpendsRemaining) {\n             txn.reserve(stage.size());\n-            BOOST_FOREACH(txiter iter, stage)\n+            for (txiter iter : stage)\n                 txn.push_back(iter->GetTx());\n         }\n         RemoveStaged(stage, false, MemPoolRemovalReason::SIZELIMIT);\n         if (pvNoSpendsRemaining) {\n-            BOOST_FOREACH(const CTransaction& tx, txn) {\n-                BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+            for (const CTransaction& tx : txn) {\n+                for (const CTxIn& txin : tx.vin) {\n                     if (exists(txin.prevout.hash)) continue;\n-                    if (!mapNextTx.count(txin.prevout)) {\n-                        pvNoSpendsRemaining->push_back(txin.prevout);\n-                    }\n+                    pvNoSpendsRemaining->push_back(txin.prevout);\n                 }\n             }\n         }"
      },
      {
        "sha": "d272114a7c551e29f687e38fec85f8ad05cf5431",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 8,
        "deletions": 10,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -28,7 +28,6 @@\n \n #include <boost/signals2/signal.hpp>\n \n-class CAutoFile;\n class CBlockIndex;\n \n /** Fake height value used in Coin to signify they are only in the memory pool (since 0.8) */\n@@ -619,13 +618,6 @@ class CTxMemPool\n         return (mapTx.count(hash) != 0);\n     }\n \n-    bool exists(const COutPoint& outpoint) const\n-    {\n-        LOCK(cs);\n-        auto it = mapTx.find(outpoint.hash);\n-        return (it != mapTx.end() && outpoint.n < it->GetTx().vout.size());\n-    }\n-\n     CTransactionRef get(const uint256& hash) const;\n     TxMempoolInfo info(const uint256& hash) const;\n     std::vector<TxMempoolInfo> infoAll() const;\n@@ -677,6 +669,13 @@ class CTxMemPool\n /** \n  * CCoinsView that brings transactions from a memorypool into view.\n  * It does not check for spendings by memory pool transactions.\n+ * Instead, it provides access to all Coins which are either unspent in the\n+ * base CCoinsView, or are outputs from any mempool transaction!\n+ * This allows transaction replacement to work as expected, as you want to\n+ * have all inputs \"available\" to check signatures, and any cycles in the\n+ * dependency graph are checked directly in AcceptToMemoryPool.\n+ * It also allows you to sign a double-spend directly in signrawtransaction,\n+ * as long as the conflicting transaction is not yet confirmed.\n  */\n class CCoinsViewMemPool : public CCoinsViewBacked\n {\n@@ -685,8 +684,7 @@ class CCoinsViewMemPool : public CCoinsViewBacked\n \n public:\n     CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool& mempoolIn);\n-    bool GetCoin(const COutPoint &outpoint, Coin &coin) const;\n-    bool HaveCoin(const COutPoint &outpoint) const;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n };\n \n /**"
      },
      {
        "sha": "762dd19b1904184d471d861835614f37d1102bed",
        "filename": "src/ui_interface.h",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/ui_interface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/ui_interface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui_interface.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -12,9 +12,7 @@\n #include <boost/signals2/last_value.hpp>\n #include <boost/signals2/signal.hpp>\n \n-class CBasicKeyStore;\n class CWallet;\n-class uint256;\n class CBlockIndex;\n \n /** General change type (added, updated, removed). */\n@@ -99,6 +97,9 @@ class CClientUIInterface\n     /** Show progress e.g. for verifychain */\n     boost::signals2::signal<void (const std::string &title, int nProgress)> ShowProgress;\n \n+    /** Set progress break action (possible \"cancel button\" triggers that action) */\n+    boost::signals2::signal<void (std::function<void(void)> action)> SetProgressBreakAction;\n+\n     /** New block has been accepted */\n     boost::signals2::signal<void (bool, const CBlockIndex *)> NotifyBlockTip;\n "
      },
      {
        "sha": "0f9d041bbdc47aadb3745a75a0f2c0cf43f74350",
        "filename": "src/undo.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/undo.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/undo.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/undo.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -60,7 +60,8 @@ class TxInUndoDeserializer\n     TxInUndoDeserializer(Coin* coin) : txout(coin) {}\n };\n \n-static const size_t MAX_INPUTS_PER_BLOCK = MAX_BLOCK_BASE_SIZE / ::GetSerializeSize(CTxIn(), SER_NETWORK, PROTOCOL_VERSION);\n+static const size_t MIN_TRANSACTION_INPUT_WEIGHT = WITNESS_SCALE_FACTOR * ::GetSerializeSize(CTxIn(), SER_NETWORK, PROTOCOL_VERSION);\n+static const size_t MAX_INPUTS_PER_BLOCK = MAX_BLOCK_WEIGHT / MIN_TRANSACTION_INPUT_WEIGHT;\n \n /** Undo information for a CTransaction */\n class CTxUndo"
      },
      {
        "sha": "b76c173f90602e56d5457d1c1e9467c662df0663",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 8,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -77,16 +77,15 @@\n #endif\n \n #include <boost/algorithm/string/case_conv.hpp> // for to_lower()\n-#include <boost/algorithm/string/join.hpp>\n #include <boost/algorithm/string/predicate.hpp> // for startswith() and endswith()\n-#include <boost/foreach.hpp>\n #include <boost/program_options/detail/config_file.hpp>\n-#include <boost/program_options/parsers.hpp>\n #include <boost/thread.hpp>\n #include <openssl/crypto.h>\n #include <openssl/rand.h>\n #include <openssl/conf.h>\n \n+// Application startup time (used for uptime calculation)\n+const int64_t nStartupTime = GetTime();\n \n const char * const BITCOIN_CONF_FILENAME = \"bitcoin.conf\";\n const char * const BITCOIN_PID_FILENAME = \"bitcoind.pid\";\n@@ -423,7 +422,9 @@ void ArgsManager::ParseParameters(int argc, const char* const argv[])\n std::vector<std::string> ArgsManager::GetArgs(const std::string& strArg)\n {\n     LOCK(cs_args);\n-    return mapMultiArgs.at(strArg);\n+    if (IsArgSet(strArg))\n+        return mapMultiArgs.at(strArg);\n+    return {};\n }\n \n bool ArgsManager::IsArgSet(const std::string& strArg)\n@@ -477,6 +478,7 @@ void ArgsManager::ForceSetArg(const std::string& strArg, const std::string& strV\n {\n     LOCK(cs_args);\n     mapArgs[strArg] = strValue;\n+    mapMultiArgs[strArg].clear();\n     mapMultiArgs[strArg].push_back(strValue);\n }\n \n@@ -653,21 +655,21 @@ bool RenameOver(fs::path src, fs::path dest)\n }\n \n /**\n- * Ignores exceptions thrown by Boost's create_directory if the requested directory exists.\n+ * Ignores exceptions thrown by Boost's create_directories if the requested directory exists.\n  * Specifically handles case where path p exists, but it wasn't possible for the user to\n  * write to the parent directory.\n  */\n-bool TryCreateDirectory(const fs::path& p)\n+bool TryCreateDirectories(const fs::path& p)\n {\n     try\n     {\n-        return fs::create_directory(p);\n+        return fs::create_directories(p);\n     } catch (const fs::filesystem_error&) {\n         if (!fs::exists(p) || !fs::is_directory(p))\n             throw;\n     }\n \n-    // create_directory didn't create the directory, it had to have existed already\n+    // create_directories didn't create the directory, it had to have existed already\n     return false;\n }\n \n@@ -891,3 +893,9 @@ std::string CopyrightHolders(const std::string& strPrefix)\n     }\n     return strCopyrightHolders;\n }\n+\n+// Obtain the application startup time (used for uptime calculation)\n+int64_t GetStartupTime()\n+{\n+    return nStartupTime;\n+}"
      },
      {
        "sha": "e1bdfb1988fc0096fefb435387df596eeb5540e4",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 73,
        "deletions": 58,
        "changes": 131,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -5,7 +5,7 @@\n \n /**\n  * Server/client environment: argument handling, config file parsing,\n- * logging, thread wrappers\n+ * logging, thread wrappers, startup time\n  */\n #ifndef BITCOIN_UTIL_H\n #define BITCOIN_UTIL_H\n@@ -28,7 +28,9 @@\n #include <vector>\n \n #include <boost/signals2/signal.hpp>\n-#include <boost/thread/exceptions.hpp>\n+\n+// Application startup time (used for uptime calculation)\n+int64_t GetStartupTime();\n \n static const bool DEFAULT_LOGTIMEMICROS = false;\n static const bool DEFAULT_LOGIPS        = false;\n@@ -123,6 +125,17 @@ int LogPrintStr(const std::string &str);\n /** Get format string from VA_ARGS for error reporting */\n template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt, const Args&... args) { return fmt; }\n \n+static inline void MarkUsed() {}\n+template<typename T, typename... Args> static inline void MarkUsed(const T& t, const Args&... args)\n+{\n+    (void)t;\n+    MarkUsed(args...);\n+}\n+\n+#ifdef USE_COVERAGE\n+#define LogPrintf(...) do { MarkUsed(__VA_ARGS__); } while(0)\n+#define LogPrint(category, ...) do { MarkUsed(__VA_ARGS__); } while(0)\n+#else\n #define LogPrintf(...) do { \\\n     std::string _log_msg_; /* Unlikely name to avoid shadowing variables */ \\\n     try { \\\n@@ -139,6 +152,7 @@ template<typename... Args> std::string FormatStringFromLogArgs(const char *fmt,\n         LogPrintf(__VA_ARGS__); \\\n     } \\\n } while(0)\n+#endif\n \n template<typename... Args>\n bool error(const char* fmt, const Args&... args)\n@@ -153,7 +167,7 @@ bool TruncateFile(FILE *file, unsigned int length);\n int RaiseFileDescriptorLimit(int nMinFD);\n void AllocateFileRange(FILE *file, unsigned int offset, unsigned int length);\n bool RenameOver(fs::path src, fs::path dest);\n-bool TryCreateDirectory(const fs::path& p);\n+bool TryCreateDirectories(const fs::path& p);\n fs::path GetDefaultDataDir();\n const fs::path &GetDataDir(bool fNetSpecific = true);\n void ClearDatadirCache();\n@@ -188,62 +202,63 @@ class ArgsManager\n     void ParseParameters(int argc, const char*const argv[]);\n     void ReadConfigFile(const std::string& confPath);\n     std::vector<std::string> GetArgs(const std::string& strArg);\n-/**\n- * Return true if the given argument has been manually set\n- *\n- * @param strArg Argument to get (e.g. \"-foo\")\n- * @return true if the argument has been set\n- */\n-bool IsArgSet(const std::string& strArg);\n-\n-/**\n- * Return string argument or default value\n- *\n- * @param strArg Argument to get (e.g. \"-foo\")\n- * @param default (e.g. \"1\")\n- * @return command-line argument or default value\n- */\n-std::string GetArg(const std::string& strArg, const std::string& strDefault);\n-\n-/**\n- * Return integer argument or default value\n- *\n- * @param strArg Argument to get (e.g. \"-foo\")\n- * @param default (e.g. 1)\n- * @return command-line argument (0 if invalid number) or default value\n- */\n-int64_t GetArg(const std::string& strArg, int64_t nDefault);\n-\n-/**\n- * Return boolean argument or default value\n- *\n- * @param strArg Argument to get (e.g. \"-foo\")\n- * @param default (true or false)\n- * @return command-line argument or default value\n- */\n-bool GetBoolArg(const std::string& strArg, bool fDefault);\n-\n-/**\n- * Set an argument if it doesn't already have a value\n- *\n- * @param strArg Argument to set (e.g. \"-foo\")\n- * @param strValue Value (e.g. \"1\")\n- * @return true if argument gets set, false if it already had a value\n- */\n-bool SoftSetArg(const std::string& strArg, const std::string& strValue);\n-\n-/**\n- * Set a boolean argument if it doesn't already have a value\n- *\n- * @param strArg Argument to set (e.g. \"-foo\")\n- * @param fValue Value (e.g. false)\n- * @return true if argument gets set, false if it already had a value\n- */\n-bool SoftSetBoolArg(const std::string& strArg, bool fValue);\n \n-// Forces an arg setting. Called by SoftSetArg() if the arg hasn't already\n-// been set. Also called directly in testing.\n-void ForceSetArg(const std::string& strArg, const std::string& strValue);\n+    /**\n+     * Return true if the given argument has been manually set\n+     *\n+     * @param strArg Argument to get (e.g. \"-foo\")\n+     * @return true if the argument has been set\n+     */\n+    bool IsArgSet(const std::string& strArg);\n+\n+    /**\n+     * Return string argument or default value\n+     *\n+     * @param strArg Argument to get (e.g. \"-foo\")\n+     * @param strDefault (e.g. \"1\")\n+     * @return command-line argument or default value\n+     */\n+    std::string GetArg(const std::string& strArg, const std::string& strDefault);\n+\n+    /**\n+     * Return integer argument or default value\n+     *\n+     * @param strArg Argument to get (e.g. \"-foo\")\n+     * @param nDefault (e.g. 1)\n+     * @return command-line argument (0 if invalid number) or default value\n+     */\n+    int64_t GetArg(const std::string& strArg, int64_t nDefault);\n+\n+    /**\n+     * Return boolean argument or default value\n+     *\n+     * @param strArg Argument to get (e.g. \"-foo\")\n+     * @param fDefault (true or false)\n+     * @return command-line argument or default value\n+     */\n+    bool GetBoolArg(const std::string& strArg, bool fDefault);\n+\n+    /**\n+     * Set an argument if it doesn't already have a value\n+     *\n+     * @param strArg Argument to set (e.g. \"-foo\")\n+     * @param strValue Value (e.g. \"1\")\n+     * @return true if argument gets set, false if it already had a value\n+     */\n+    bool SoftSetArg(const std::string& strArg, const std::string& strValue);\n+\n+    /**\n+     * Set a boolean argument if it doesn't already have a value\n+     *\n+     * @param strArg Argument to set (e.g. \"-foo\")\n+     * @param fValue Value (e.g. false)\n+     * @return true if argument gets set, false if it already had a value\n+     */\n+    bool SoftSetBoolArg(const std::string& strArg, bool fValue);\n+\n+    // Forces an arg setting. Called by SoftSetArg() if the arg hasn't already\n+    // been set. Also called directly in testing.\n+    void ForceSetArg(const std::string& strArg, const std::string& strValue);\n };\n \n extern ArgsManager gArgs;"
      },
      {
        "sha": "9ee14070a219c3588320612944a17c12487e90f4",
        "filename": "src/utilstrencodings.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 6,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/utilstrencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/utilstrencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -91,6 +91,25 @@ std::vector<unsigned char> ParseHex(const std::string& str)\n     return ParseHex(str.c_str());\n }\n \n+void SplitHostPort(std::string in, int &portOut, std::string &hostOut) {\n+    size_t colon = in.find_last_of(':');\n+    // if a : is found, and it either follows a [...], or no other : is in the string, treat it as port separator\n+    bool fHaveColon = colon != in.npos;\n+    bool fBracketed = fHaveColon && (in[0]=='[' && in[colon-1]==']'); // if there is a colon, and in[0]=='[', colon is not 0, so in[colon-1] is safe\n+    bool fMultiColon = fHaveColon && (in.find_last_of(':',colon-1) != in.npos);\n+    if (fHaveColon && (colon==0 || fBracketed || !fMultiColon)) {\n+        int32_t n;\n+        if (ParseInt32(in.substr(colon + 1), &n) && n > 0 && n < 0x10000) {\n+            in = in.substr(0, colon);\n+            portOut = n;\n+        }\n+    }\n+    if (in.size()>0 && in[0] == '[' && in[in.size()-1] == ']')\n+        hostOut = in.substr(1, in.size()-2);\n+    else\n+        hostOut = in;\n+}\n+\n std::string EncodeBase64(const unsigned char* pch, size_t len)\n {\n     static const char *pbase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n@@ -228,7 +247,7 @@ std::vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid)\n std::string DecodeBase64(const std::string& str)\n {\n     std::vector<unsigned char> vchRet = DecodeBase64(str.c_str());\n-    return (vchRet.size() == 0) ? std::string() : std::string((const char*)&vchRet[0], vchRet.size());\n+    return std::string((const char*)vchRet.data(), vchRet.size());\n }\n \n std::string EncodeBase32(const unsigned char* pch, size_t len)\n@@ -415,7 +434,7 @@ std::vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid)\n std::string DecodeBase32(const std::string& str)\n {\n     std::vector<unsigned char> vchRet = DecodeBase32(str.c_str());\n-    return (vchRet.size() == 0) ? std::string() : std::string((const char*)&vchRet[0], vchRet.size());\n+    return std::string((const char*)vchRet.data(), vchRet.size());\n }\n \n static bool ParsePrechecks(const std::string& str)\n@@ -437,7 +456,7 @@ bool ParseInt32(const std::string& str, int32_t *out)\n     errno = 0; // strtol will not set errno if valid\n     long int n = strtol(str.c_str(), &endp, 10);\n     if(out) *out = (int32_t)n;\n-    // Note that strtol returns a *long int*, so even if strtol doesn't report a over/underflow\n+    // Note that strtol returns a *long int*, so even if strtol doesn't report an over/underflow\n     // we still have to check that the returned value is within the range of an *int32_t*. On 64-bit\n     // platforms the size of these types may be different.\n     return endp && *endp == 0 && !errno &&\n@@ -453,7 +472,7 @@ bool ParseInt64(const std::string& str, int64_t *out)\n     errno = 0; // strtoll will not set errno if valid\n     long long int n = strtoll(str.c_str(), &endp, 10);\n     if(out) *out = (int64_t)n;\n-    // Note that strtoll returns a *long long int*, so even if strtol doesn't report a over/underflow\n+    // Note that strtoll returns a *long long int*, so even if strtol doesn't report an over/underflow\n     // we still have to check that the returned value is within the range of an *int64_t*.\n     return endp && *endp == 0 && !errno &&\n         n >= std::numeric_limits<int64_t>::min() &&\n@@ -470,7 +489,7 @@ bool ParseUInt32(const std::string& str, uint32_t *out)\n     errno = 0; // strtoul will not set errno if valid\n     unsigned long int n = strtoul(str.c_str(), &endp, 10);\n     if(out) *out = (uint32_t)n;\n-    // Note that strtoul returns a *unsigned long int*, so even if it doesn't report a over/underflow\n+    // Note that strtoul returns a *unsigned long int*, so even if it doesn't report an over/underflow\n     // we still have to check that the returned value is within the range of an *uint32_t*. On 64-bit\n     // platforms the size of these types may be different.\n     return endp && *endp == 0 && !errno &&\n@@ -487,7 +506,7 @@ bool ParseUInt64(const std::string& str, uint64_t *out)\n     errno = 0; // strtoull will not set errno if valid\n     unsigned long long int n = strtoull(str.c_str(), &endp, 10);\n     if(out) *out = (uint64_t)n;\n-    // Note that strtoull returns a *unsigned long long int*, so even if it doesn't report a over/underflow\n+    // Note that strtoull returns a *unsigned long long int*, so even if it doesn't report an over/underflow\n     // we still have to check that the returned value is within the range of an *uint64_t*.\n     return endp && *endp == 0 && !errno &&\n         n <= std::numeric_limits<uint64_t>::max();"
      },
      {
        "sha": "707fdaad169b17f83104ad45ad70819f53ae83b3",
        "filename": "src/utilstrencodings.h",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/utilstrencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/utilstrencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -19,9 +19,6 @@\n #define UEND(a)             ((unsigned char*)&((&(a))[1]))\n #define ARRAYLEN(array)     (sizeof(array)/sizeof((array)[0]))\n \n-/** This is needed because the foreach macro can't get over the comma in pair<t1, t2> */\n-#define PAIRTYPE(t1, t2)    std::pair<t1, t2>\n-\n /** Used by SanitizeString() */\n enum SafeChars\n {\n@@ -51,6 +48,7 @@ std::string DecodeBase32(const std::string& str);\n std::string EncodeBase32(const unsigned char* pch, size_t len);\n std::string EncodeBase32(const std::string& str);\n \n+void SplitHostPort(std::string in, int &portOut, std::string &hostOut);\n std::string i64tostr(int64_t n);\n std::string itostr(int n);\n int64_t atoi64(const char* psz);"
      },
      {
        "sha": "9a00203e8fea3cad1345fb7b68f4b4ca2b9c4198",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 319,
        "deletions": 110,
        "changes": 429,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -14,6 +14,7 @@\n #include \"consensus/merkle.h\"\n #include \"consensus/tx_verify.h\"\n #include \"consensus/validation.h\"\n+#include \"cuckoocache.h\"\n #include \"fs.h\"\n #include \"hash.h\"\n #include \"init.h\"\n@@ -23,6 +24,7 @@\n #include \"primitives/block.h\"\n #include \"primitives/transaction.h\"\n #include \"random.h\"\n+#include \"reverse_iterator.h\"\n #include \"script/script.h\"\n #include \"script/sigcache.h\"\n #include \"script/standard.h\"\n@@ -44,7 +46,6 @@\n \n #include <boost/algorithm/string/replace.hpp>\n #include <boost/algorithm/string/join.hpp>\n-#include <boost/math/distributions/poisson.hpp>\n #include <boost/thread.hpp>\n \n #if defined(NDEBUG)\n@@ -97,7 +98,7 @@ namespace {\n \n     struct CBlockIndexWorkComparator\n     {\n-        bool operator()(CBlockIndex *pa, CBlockIndex *pb) const {\n+        bool operator()(const CBlockIndex *pa, const CBlockIndex *pb) const {\n             // First sort by most total work, ...\n             if (pa->nChainWork > pb->nChainWork) return false;\n             if (pa->nChainWork < pb->nChainWork) return true;\n@@ -160,7 +161,7 @@ namespace {\n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator)\n {\n     // Find the first block the caller has in the main chain\n-    BOOST_FOREACH(const uint256& hash, locator.vHave) {\n+    for (const uint256& hash : locator.vHave) {\n         BlockMap::iterator mi = mapBlockIndex.find(hash);\n         if (mi != mapBlockIndex.end())\n         {\n@@ -175,6 +176,7 @@ CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& loc\n     return chain.Genesis();\n }\n \n+CCoinsViewDB *pcoinsdbview = NULL;\n CCoinsViewCache *pcoinsTip = NULL;\n CBlockTreeDB *pblocktree = NULL;\n \n@@ -189,7 +191,7 @@ enum FlushStateMode {\n static bool FlushStateToDisk(const CChainParams& chainParams, CValidationState &state, FlushStateMode mode, int nManualPruneHeight=0);\n static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight);\n static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight);\n-static bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = NULL);\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = nullptr);\n static FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n \n bool CheckFinalTx(const CTransaction &tx, int flags)\n@@ -300,7 +302,7 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp, bool\n             // lock on a mempool input, so we can use the return value of\n             // CheckSequenceLocks to indicate the LockPoints validity\n             int maxInputHeight = 0;\n-            BOOST_FOREACH(int height, prevheights) {\n+            for (int height : prevheights) {\n                 // Can ignore mempool inputs since we'll fail if they had non-zero locks\n                 if (height != tip->nHeight+1) {\n                     maxInputHeight = std::max(maxInputHeight, height);\n@@ -312,6 +314,9 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp, bool\n     return EvaluateSequenceLocks(index, lockPair);\n }\n \n+// Returns the script flags which should be checked for a given block\n+static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& chainparams);\n+\n static void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age) {\n     int expired = pool.Expire(GetTime() - age);\n     if (expired != 0) {\n@@ -320,7 +325,7 @@ static void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age)\n \n     std::vector<COutPoint> vNoSpendsRemaining;\n     pool.TrimToSize(limit, &vNoSpendsRemaining);\n-    BOOST_FOREACH(const COutPoint& removed, vNoSpendsRemaining)\n+    for (const COutPoint& removed : vNoSpendsRemaining)\n         pcoinsTip->Uncache(removed);\n }\n \n@@ -395,6 +400,42 @@ void UpdateMempoolForReorg(DisconnectedBlockTransactions &disconnectpool, bool f\n     LimitMempoolSize(mempool, GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000, GetArg(\"-mempoolexpiry\", DEFAULT_MEMPOOL_EXPIRY) * 60 * 60);\n }\n \n+// Used to avoid mempool polluting consensus critical paths if CCoinsViewMempool\n+// were somehow broken and returning the wrong scriptPubKeys\n+static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &view, CTxMemPool& pool,\n+                 unsigned int flags, bool cacheSigStore, PrecomputedTransactionData& txdata) {\n+    AssertLockHeld(cs_main);\n+\n+    // pool.cs should be locked already, but go ahead and re-take the lock here\n+    // to enforce that mempool doesn't change between when we check the view\n+    // and when we actually call through to CheckInputs\n+    LOCK(pool.cs);\n+\n+    assert(!tx.IsCoinBase());\n+    for (const CTxIn& txin : tx.vin) {\n+        const Coin& coin = view.AccessCoin(txin.prevout);\n+\n+        // At this point we haven't actually checked if the coins are all\n+        // available (or shouldn't assume we have, since CheckInputs does).\n+        // So we just return failure if the inputs are not available here,\n+        // and then only have to check equivalence for available inputs.\n+        if (coin.IsSpent()) return false;\n+\n+        const CTransactionRef& txFrom = pool.get(txin.prevout.hash);\n+        if (txFrom) {\n+            assert(txFrom->GetHash() == txin.prevout.hash);\n+            assert(txFrom->vout.size() > txin.prevout.n);\n+            assert(txFrom->vout[txin.prevout.n] == coin.out);\n+        } else {\n+            const Coin& coinFromDisk = pcoinsTip->AccessCoin(txin.prevout);\n+            assert(!coinFromDisk.IsSpent());\n+            assert(coinFromDisk.out == coin.out);\n+        }\n+    }\n+\n+    return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n+}\n+\n static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx, bool fLimitFree,\n                               bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                               bool fOverrideMempoolLimit, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache)\n@@ -414,7 +455,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n     // Reject transactions with witness before segregated witness activates (override with -prematurewitness)\n     bool witnessEnabled = IsWitnessEnabled(chainActive.Tip(), chainparams.GetConsensus());\n-    if (!GetBoolArg(\"-prematurewitness\",false) && tx.HasWitness() && !witnessEnabled) {\n+    if (!GetBoolArg(\"-prematurewitness\", false) && tx.HasWitness() && !witnessEnabled) {\n         return state.DoS(0, false, REJECT_NONSTANDARD, \"no-witness-yet\", true);\n     }\n \n@@ -430,14 +471,15 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         return state.DoS(0, false, REJECT_NONSTANDARD, \"non-final\");\n \n     // is it already in the memory pool?\n-    if (pool.exists(hash))\n-        return state.Invalid(false, REJECT_ALREADY_KNOWN, \"txn-already-in-mempool\");\n+    if (pool.exists(hash)) {\n+        return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-in-mempool\");\n+    }\n \n     // Check for conflicts with in-memory transactions\n     std::set<uint256> setConflicts;\n     {\n     LOCK(pool.cs); // protect pool.mapNextTx\n-    BOOST_FOREACH(const CTxIn &txin, tx.vin)\n+    for (const CTxIn &txin : tx.vin)\n     {\n         auto itConflicting = pool.mapNextTx.find(txin.prevout);\n         if (itConflicting != pool.mapNextTx.end())\n@@ -460,7 +502,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 bool fReplacementOptOut = true;\n                 if (fEnableReplacement)\n                 {\n-                    BOOST_FOREACH(const CTxIn &_txin, ptxConflicting->vin)\n+                    for (const CTxIn &_txin : ptxConflicting->vin)\n                     {\n                         if (_txin.nSequence < std::numeric_limits<unsigned int>::max()-1)\n                         {\n@@ -469,8 +511,9 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                         }\n                     }\n                 }\n-                if (fReplacementOptOut)\n-                    return state.Invalid(false, REJECT_CONFLICT, \"txn-mempool-conflict\");\n+                if (fReplacementOptOut) {\n+                    return state.Invalid(false, REJECT_DUPLICATE, \"txn-mempool-conflict\");\n+                }\n \n                 setConflicts.insert(ptxConflicting->GetHash());\n             }\n@@ -489,24 +532,20 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         CCoinsViewMemPool viewMemPool(pcoinsTip, pool);\n         view.SetBackend(viewMemPool);\n \n-        // do we already have it?\n-        for (size_t out = 0; out < tx.vout.size(); out++) {\n-            COutPoint outpoint(hash, out);\n-            bool had_coin_in_cache = pcoinsTip->HaveCoinInCache(outpoint);\n-            if (view.HaveCoin(outpoint)) {\n-                if (!had_coin_in_cache) {\n-                    coins_to_uncache.push_back(outpoint);\n-                }\n-                return state.Invalid(false, REJECT_ALREADY_KNOWN, \"txn-already-known\");\n-            }\n-        }\n-\n         // do all inputs exist?\n-        BOOST_FOREACH(const CTxIn txin, tx.vin) {\n+        for (const CTxIn txin : tx.vin) {\n             if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n                 coins_to_uncache.push_back(txin.prevout);\n             }\n             if (!view.HaveCoin(txin.prevout)) {\n+                // Are inputs missing because we already have the tx?\n+                for (size_t out = 0; out < tx.vout.size(); out++) {\n+                    // Optimistically just do efficient check of cache for outputs\n+                    if (pcoinsTip->HaveCoinInCache(COutPoint(hash, out))) {\n+                        return state.Invalid(false, REJECT_DUPLICATE, \"txn-already-known\");\n+                    }\n+                }\n+                // Otherwise assume this might be an orphan tx for which we just haven't seen parents yet\n                 if (pfMissingInputs) {\n                     *pfMissingInputs = true;\n                 }\n@@ -550,7 +589,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // Keep track of transactions that spend a coinbase, which we re-scan\n         // during reorgs to ensure COINBASE_MATURITY is still met.\n         bool fSpendsCoinbase = false;\n-        BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n+        for (const CTxIn &txin : tx.vin) {\n             const Coin &coin = view.AccessCoin(txin.prevout);\n             if (coin.IsCoinBase()) {\n                 fSpendsCoinbase = true;\n@@ -601,7 +640,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // that we have the set of all ancestors we can detect this\n         // pathological case by making sure setConflicts and setAncestors don't\n         // intersect.\n-        BOOST_FOREACH(CTxMemPool::txiter ancestorIt, setAncestors)\n+        for (CTxMemPool::txiter ancestorIt : setAncestors)\n         {\n             const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n             if (setConflicts.count(hashAncestor))\n@@ -632,7 +671,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             std::set<uint256> setConflictsParents;\n             const int maxDescendantsToVisit = 100;\n             CTxMemPool::setEntries setIterConflicting;\n-            BOOST_FOREACH(const uint256 &hashConflicting, setConflicts)\n+            for (const uint256 &hashConflicting : setConflicts)\n             {\n                 CTxMemPool::txiter mi = pool.mapTx.find(hashConflicting);\n                 if (mi == pool.mapTx.end())\n@@ -668,7 +707,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                                   oldFeeRate.ToString()));\n                 }\n \n-                BOOST_FOREACH(const CTxIn &txin, mi->GetTx().vin)\n+                for (const CTxIn &txin : mi->GetTx().vin)\n                 {\n                     setConflictsParents.insert(txin.prevout.hash);\n                 }\n@@ -681,10 +720,10 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n             if (nConflictingCount <= maxDescendantsToVisit) {\n                 // If not too many to replace, then calculate the set of\n                 // transactions that would have to be evicted\n-                BOOST_FOREACH(CTxMemPool::txiter it, setIterConflicting) {\n+                for (CTxMemPool::txiter it : setIterConflicting) {\n                     pool.CalculateDescendants(it, allConflicting);\n                 }\n-                BOOST_FOREACH(CTxMemPool::txiter it, allConflicting) {\n+                for (CTxMemPool::txiter it : allConflicting) {\n                     nConflictingFees += it->GetModifiedFee();\n                     nConflictingSize += it->GetTxSize();\n                 }\n@@ -749,36 +788,55 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n         PrecomputedTransactionData txdata(tx);\n-        if (!CheckInputs(tx, state, view, true, scriptVerifyFlags, true, txdata)) {\n+        if (!CheckInputs(tx, state, view, true, scriptVerifyFlags, true, false, txdata)) {\n             // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n             // need to turn both off, and compare against just turning off CLEANSTACK\n             // to see if the failure is specifically due to witness validation.\n             CValidationState stateDummy; // Want reported failures to be from first CheckInputs\n-            if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, txdata) &&\n-                !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, txdata)) {\n+            if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n+                !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n                 // Only the witness is missing, so the transaction itself may be fine.\n                 state.SetCorruptionPossible();\n             }\n             return false; // state filled in by CheckInputs\n         }\n \n-        // Check again against just the consensus-critical mandatory script\n-        // verification flags, in case of bugs in the standard flags that cause\n+        // Check again against the current block tip's script verification\n+        // flags to cache our script execution flags. This is, of course,\n+        // useless if the next block has different script flags from the\n+        // previous one, but because the cache tracks script flags for us it\n+        // will auto-invalidate and we'll just have a few blocks of extra\n+        // misses on soft-fork activation.\n+        //\n+        // This is also useful in case of bugs in the standard flags that cause\n         // transactions to pass as valid when they're actually invalid. For\n         // instance the STRICTENC flag was incorrectly allowing certain\n         // CHECKSIG NOT scripts to pass, even though they were invalid.\n         //\n         // There is a similar check in CreateNewBlock() to prevent creating\n-        // invalid blocks, however allowing such transactions into the mempool\n-        // can be exploited as a DoS attack.\n-        if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true, txdata))\n+        // invalid blocks (using TestBlockValidity), however allowing such\n+        // transactions into the mempool can be exploited as a DoS attack.\n+        unsigned int currentBlockScriptVerifyFlags = GetBlockScriptFlags(chainActive.Tip(), Params().GetConsensus());\n+        if (!CheckInputsFromMempoolAndCache(tx, state, view, pool, currentBlockScriptVerifyFlags, true, txdata))\n         {\n-            return error(\"%s: BUG! PLEASE REPORT THIS! ConnectInputs failed against MANDATORY but not STANDARD flags %s, %s\",\n-                __func__, hash.ToString(), FormatStateMessage(state));\n+            // If we're using promiscuousmempoolflags, we may hit this normally\n+            // Check if current block has some flags that scriptVerifyFlags\n+            // does not before printing an ominous warning\n+            if (!(~scriptVerifyFlags & currentBlockScriptVerifyFlags)) {\n+                return error(\"%s: BUG! PLEASE REPORT THIS! ConnectInputs failed against latest-block but not STANDARD flags %s, %s\",\n+                    __func__, hash.ToString(), FormatStateMessage(state));\n+            } else {\n+                if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true, false, txdata)) {\n+                    return error(\"%s: ConnectInputs failed against MANDATORY but not STANDARD flags due to promiscuous mempool %s, %s\",\n+                        __func__, hash.ToString(), FormatStateMessage(state));\n+                } else {\n+                    LogPrintf(\"Warning: -promiscuousmempool flags set to not include currently enforced soft forks, this may break mining or otherwise cause instability!\\n\");\n+                }\n+            }\n         }\n \n         // Remove conflicting transactions from the mempool\n-        BOOST_FOREACH(const CTxMemPool::txiter it, allConflicting)\n+        for (const CTxMemPool::txiter it : allConflicting)\n         {\n             LogPrint(BCLog::MEMPOOL, \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n                     it->GetTx().GetHash().ToString(),\n@@ -820,7 +878,7 @@ static bool AcceptToMemoryPoolWithTime(const CChainParams& chainparams, CTxMemPo\n     std::vector<COutPoint> coins_to_uncache;\n     bool res = AcceptToMemoryPoolWorker(chainparams, pool, state, tx, fLimitFree, pfMissingInputs, nAcceptTime, plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee, coins_to_uncache);\n     if (!res) {\n-        BOOST_FOREACH(const COutPoint& hashTx, coins_to_uncache)\n+        for (const COutPoint& hashTx : coins_to_uncache)\n             pcoinsTip->Uncache(hashTx);\n     }\n     // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n@@ -1079,7 +1137,7 @@ static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n     // or a chain that is entirely longer than ours and invalid (note that this should be detected by both)\n     // We define it this way because it allows us to only store the highest fork tip (+ base) which meets\n     // the 7-block condition and from this always have the most-likely-to-cause-warning fork\n-    if (pfork && (!pindexBestForkTip || (pindexBestForkTip && pindexNewForkTip->nHeight > pindexBestForkTip->nHeight)) &&\n+    if (pfork && (!pindexBestForkTip || pindexNewForkTip->nHeight > pindexBestForkTip->nHeight) &&\n             pindexNewForkTip->nChainWork - pfork->nChainWork > (GetBlockProof(*pfork) * 7) &&\n             chainActive.Height() - pindexNewForkTip->nHeight < 72)\n     {\n@@ -1121,9 +1179,10 @@ void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txund\n     // mark inputs spent\n     if (!tx.IsCoinBase()) {\n         txundo.vprevout.reserve(tx.vin.size());\n-        BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n+        for (const CTxIn &txin : tx.vin) {\n             txundo.vprevout.emplace_back();\n-            inputs.SpendCoin(txin.prevout, &txundo.vprevout.back());\n+            bool is_spent = inputs.SpendCoin(txin.prevout, &txundo.vprevout.back());\n+            assert(is_spent);\n         }\n     }\n     // add outputs\n@@ -1149,12 +1208,34 @@ int GetSpendHeight(const CCoinsViewCache& inputs)\n     return pindexPrev->nHeight + 1;\n }\n \n+\n+static CuckooCache::cache<uint256, SignatureCacheHasher> scriptExecutionCache;\n+static uint256 scriptExecutionCacheNonce(GetRandHash());\n+\n+void InitScriptExecutionCache() {\n+    // nMaxCacheSize is unsigned. If -maxsigcachesize is set to zero,\n+    // setup_bytes creates the minimum possible cache (2 elements).\n+    size_t nMaxCacheSize = std::min(std::max((int64_t)0, GetArg(\"-maxsigcachesize\", DEFAULT_MAX_SIG_CACHE_SIZE) / 2), MAX_MAX_SIG_CACHE_SIZE) * ((size_t) 1 << 20);\n+    size_t nElems = scriptExecutionCache.setup_bytes(nMaxCacheSize);\n+    LogPrintf(\"Using %zu MiB out of %zu/2 requested for script execution cache, able to store %zu elements\\n\",\n+            (nElems*sizeof(uint256)) >>20, (nMaxCacheSize*2)>>20, nElems);\n+}\n+\n /**\n  * Check whether all inputs of this transaction are valid (no double spends, scripts & sigs, amounts)\n- * This does not modify the UTXO set. If pvChecks is not NULL, script checks are pushed onto it\n- * instead of being performed inline.\n+ * This does not modify the UTXO set.\n+ *\n+ * If pvChecks is not NULL, script checks are pushed onto it instead of being performed inline. Any\n+ * script checks which are not necessary (eg due to script execution cache hits) are, obviously,\n+ * not pushed onto pvChecks/run.\n+ *\n+ * Setting cacheSigStore/cacheFullScriptStore to false will remove elements from the corresponding cache\n+ * which are matched. This is useful for checking blocks where we will likely never need the cache\n+ * entry again.\n+ *\n+ * Non-static (and re-declared) in src/test/txvalidationcache_tests.cpp\n  */\n-static bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n {\n     if (!tx.IsCoinBase())\n     {\n@@ -1174,6 +1255,21 @@ static bool CheckInputs(const CTransaction& tx, CValidationState &state, const C\n         // Of course, if an assumed valid block is invalid due to false scriptSigs\n         // this optimization would allow an invalid chain to be accepted.\n         if (fScriptChecks) {\n+            // First check if script executions have been cached with the same\n+            // flags. Note that this assumes that the inputs provided are\n+            // correct (ie that the transaction hash which is in tx's prevouts\n+            // properly commits to the scriptPubKey in the inputs view of that\n+            // transaction).\n+            uint256 hashCacheEntry;\n+            // We only use the first 19 bytes of nonce to avoid a second SHA\n+            // round - giving us 19 + 32 + 4 = 55 bytes (+ 8 + 1 = 64)\n+            static_assert(55 - sizeof(flags) - 32 >= 128/8, \"Want at least 128 bits of nonce for script execution cache\");\n+            CSHA256().Write(scriptExecutionCacheNonce.begin(), 55 - sizeof(flags) - 32).Write(tx.GetWitnessHash().begin(), 32).Write((unsigned char*)&flags, sizeof(flags)).Finalize(hashCacheEntry.begin());\n+            AssertLockHeld(cs_main); //TODO: Remove this requirement by making CuckooCache not require external locks\n+            if (scriptExecutionCache.contains(hashCacheEntry, !cacheFullScriptStore)) {\n+                return true;\n+            }\n+\n             for (unsigned int i = 0; i < tx.vin.size(); i++) {\n                 const COutPoint &prevout = tx.vin[i].prevout;\n                 const Coin& coin = inputs.AccessCoin(prevout);\n@@ -1188,7 +1284,7 @@ static bool CheckInputs(const CTransaction& tx, CValidationState &state, const C\n                 const CAmount amount = coin.out.nValue;\n \n                 // Verify signature\n-                CScriptCheck check(scriptPubKey, amount, tx, i, flags, cacheStore, &txdata);\n+                CScriptCheck check(scriptPubKey, amount, tx, i, flags, cacheSigStore, &txdata);\n                 if (pvChecks) {\n                     pvChecks->push_back(CScriptCheck());\n                     check.swap(pvChecks->back());\n@@ -1201,12 +1297,12 @@ static bool CheckInputs(const CTransaction& tx, CValidationState &state, const C\n                         // avoid splitting the network between upgraded and\n                         // non-upgraded nodes.\n                         CScriptCheck check2(scriptPubKey, amount, tx, i,\n-                                flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheStore, &txdata);\n+                                flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n                         if (check2())\n                             return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                     }\n                     // Failures of other flags indicate a transaction that is\n-                    // invalid in new blocks, e.g. a invalid P2SH. We DoS ban\n+                    // invalid in new blocks, e.g. an invalid P2SH. We DoS ban\n                     // such nodes as they are not following the protocol. That\n                     // said during an upgrade careful thought should be taken\n                     // as to the correct behavior - we may want to continue\n@@ -1215,6 +1311,12 @@ static bool CheckInputs(const CTransaction& tx, CValidationState &state, const C\n                     return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n             }\n+\n+            if (cacheFullScriptStore && !pvChecks) {\n+                // We executed all of the provided scripts, and were told to\n+                // cache the result. Do so now.\n+                scriptExecutionCache.insert(hashCacheEntry);\n+            }\n         }\n     }\n \n@@ -1294,7 +1396,7 @@ bool AbortNode(CValidationState& state, const std::string& strMessage, const std\n     return state.Error(strMessage);\n }\n \n-} // anon namespace\n+} // namespace\n \n enum DisconnectResult\n {\n@@ -1328,17 +1430,19 @@ int ApplyTxInUndo(Coin&& undo, CCoinsViewCache& view, const COutPoint& out)\n             return DISCONNECT_FAILED; // adding output for transaction without known metadata\n         }\n     }\n-    view.AddCoin(out, std::move(undo), undo.fCoinBase);\n+    // The potential_overwrite parameter to AddCoin is only allowed to be false if we know for\n+    // sure that the coin did not already exist in the cache. As we have queried for that above\n+    // using HaveCoin, we don't need to guess. When fClean is false, a coin already existed and\n+    // it is an overwrite.\n+    view.AddCoin(out, std::move(undo), !fClean);\n \n     return fClean ? DISCONNECT_OK : DISCONNECT_UNCLEAN;\n }\n \n /** Undo the effects of this block (with given index) on the UTXO set represented by coins.\n- *  When UNCLEAN or FAILED is returned, view is left in an indeterminate state. */\n+ *  When FAILED is returned, view is left in an indeterminate state. */\n static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex* pindex, CCoinsViewCache& view)\n {\n-    assert(pindex->GetBlockHash() == view.GetBestBlock());\n-\n     bool fClean = true;\n \n     CBlockUndo blockUndo;\n@@ -1361,15 +1465,16 @@ static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex*\n     for (int i = block.vtx.size() - 1; i >= 0; i--) {\n         const CTransaction &tx = *(block.vtx[i]);\n         uint256 hash = tx.GetHash();\n+        bool is_coinbase = tx.IsCoinBase();\n \n         // Check that all outputs are available and match the outputs in the block itself\n         // exactly.\n         for (size_t o = 0; o < tx.vout.size(); o++) {\n             if (!tx.vout[o].scriptPubKey.IsUnspendable()) {\n                 COutPoint out(hash, o);\n                 Coin coin;\n-                view.SpendCoin(out, &coin);\n-                if (tx.vout[o] != coin.out) {\n+                bool is_spent = view.SpendCoin(out, &coin);\n+                if (!is_spent || tx.vout[o] != coin.out || pindex->nHeight != coin.nHeight || is_coinbase != coin.fCoinBase) {\n                     fClean = false; // transaction output mismatch\n                 }\n             }\n@@ -1459,12 +1564,12 @@ class WarningBitsConditionChecker : public AbstractThresholdConditionChecker\n public:\n     WarningBitsConditionChecker(int bitIn) : bit(bitIn) {}\n \n-    int64_t BeginTime(const Consensus::Params& params) const { return 0; }\n-    int64_t EndTime(const Consensus::Params& params) const { return std::numeric_limits<int64_t>::max(); }\n-    int Period(const Consensus::Params& params) const { return params.nMinerConfirmationWindow; }\n-    int Threshold(const Consensus::Params& params) const { return params.nRuleChangeActivationThreshold; }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return 0; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return std::numeric_limits<int64_t>::max(); }\n+    int Period(const Consensus::Params& params) const override { return params.nMinerConfirmationWindow; }\n+    int Threshold(const Consensus::Params& params) const override { return params.nRuleChangeActivationThreshold; }\n \n-    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override\n     {\n         return ((pindex->nVersion & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS) &&\n                ((pindex->nVersion >> bit) & 1) != 0 &&\n@@ -1475,6 +1580,41 @@ class WarningBitsConditionChecker : public AbstractThresholdConditionChecker\n // Protected by cs_main\n static ThresholdConditionCache warningcache[VERSIONBITS_NUM_BITS];\n \n+static unsigned int GetBlockScriptFlags(const CBlockIndex* pindex, const Consensus::Params& consensusparams) {\n+    AssertLockHeld(cs_main);\n+\n+    // BIP16 didn't become active until Apr 1 2012\n+    int64_t nBIP16SwitchTime = 1333238400;\n+    bool fStrictPayToScriptHash = (pindex->GetBlockTime() >= nBIP16SwitchTime);\n+\n+    unsigned int flags = fStrictPayToScriptHash ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE;\n+\n+    // Start enforcing the DERSIG (BIP66) rule\n+    if (pindex->nHeight >= consensusparams.BIP66Height) {\n+        flags |= SCRIPT_VERIFY_DERSIG;\n+    }\n+\n+    // Start enforcing CHECKLOCKTIMEVERIFY (BIP65) rule\n+    if (pindex->nHeight >= consensusparams.BIP65Height) {\n+        flags |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;\n+    }\n+\n+    // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.\n+    if (VersionBitsState(pindex->pprev, consensusparams, Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {\n+        flags |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n+    }\n+\n+    // Start enforcing WITNESS rules using versionbits logic.\n+    if (IsWitnessEnabled(pindex->pprev, consensusparams)) {\n+        flags |= SCRIPT_VERIFY_WITNESS;\n+        flags |= SCRIPT_VERIFY_NULLDUMMY;\n+    }\n+\n+    return flags;\n+}\n+\n+\n+\n static int64_t nTimeCheck = 0;\n static int64_t nTimeForks = 0;\n static int64_t nTimeVerify = 0;\n@@ -1578,34 +1718,14 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n         }\n     }\n \n-    // BIP16 didn't become active until Apr 1 2012\n-    int64_t nBIP16SwitchTime = 1333238400;\n-    bool fStrictPayToScriptHash = (pindex->GetBlockTime() >= nBIP16SwitchTime);\n-\n-    unsigned int flags = fStrictPayToScriptHash ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE;\n-\n-    // Start enforcing the DERSIG (BIP66) rule\n-    if (pindex->nHeight >= chainparams.GetConsensus().BIP66Height) {\n-        flags |= SCRIPT_VERIFY_DERSIG;\n-    }\n-\n-    // Start enforcing CHECKLOCKTIMEVERIFY (BIP65) rule\n-    if (pindex->nHeight >= chainparams.GetConsensus().BIP65Height) {\n-        flags |= SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY;\n-    }\n-\n     // Start enforcing BIP68 (sequence locks) and BIP112 (CHECKSEQUENCEVERIFY) using versionbits logic.\n     int nLockTimeFlags = 0;\n     if (VersionBitsState(pindex->pprev, chainparams.GetConsensus(), Consensus::DEPLOYMENT_CSV, versionbitscache) == THRESHOLD_ACTIVE) {\n-        flags |= SCRIPT_VERIFY_CHECKSEQUENCEVERIFY;\n         nLockTimeFlags |= LOCKTIME_VERIFY_SEQUENCE;\n     }\n \n-    // Start enforcing WITNESS rules using versionbits logic.\n-    if (IsWitnessEnabled(pindex->pprev, chainparams.GetConsensus())) {\n-        flags |= SCRIPT_VERIFY_WITNESS;\n-        flags |= SCRIPT_VERIFY_NULLDUMMY;\n-    }\n+    // Get the script flags for this block\n+    unsigned int flags = GetBlockScriptFlags(pindex, chainparams.GetConsensus());\n \n     int64_t nTime2 = GetTimeMicros(); nTimeForks += nTime2 - nTime1;\n     LogPrint(BCLog::BENCH, \"    - Fork checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime2 - nTime1), nTimeForks * 0.000001);\n@@ -1666,7 +1786,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n \n             std::vector<CScriptCheck> vChecks;\n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : NULL))\n+            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : NULL))\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n             control.Add(vChecks);\n@@ -1776,7 +1896,7 @@ bool static FlushStateToDisk(const CChainParams& chainparams, CValidationState &\n         nLastSetChain = nNow;\n     }\n     int64_t nMempoolSizeMax = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n-    int64_t cacheSize = pcoinsTip->DynamicMemoryUsage() * DB_PEAK_USAGE_FACTOR;\n+    int64_t cacheSize = pcoinsTip->DynamicMemoryUsage();\n     int64_t nTotalSpace = nCoinCacheUsage + std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0);\n     // The cache is large and we're within 10% and 10 MiB of the limit, but we have time now (not in the middle of a block processing).\n     bool fCacheLarge = mode == FLUSH_STATE_PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024);\n@@ -1943,6 +2063,7 @@ bool static DisconnectTip(CValidationState& state, const CChainParams& chainpara\n     int64_t nStart = GetTimeMicros();\n     {\n         CCoinsViewCache view(pcoinsTip);\n+        assert(view.GetBestBlock() == pindexDelete->GetBlockHash());\n         if (DisconnectBlock(block, pindexDelete, view) != DISCONNECT_OK)\n             return error(\"DisconnectTip(): DisconnectBlock %s failed\", pindexDelete->GetBlockHash().ToString());\n         bool flushed = view.Flush();\n@@ -2216,7 +2337,7 @@ static bool ActivateBestChainStep(CValidationState& state, const CChainParams& c\n         nHeight = nTargetHeight;\n \n         // Connect new blocks.\n-        BOOST_REVERSE_FOREACH(CBlockIndex *pindexConnect, vpindexToConnect) {\n+        for (CBlockIndex *pindexConnect : reverse_iterate(vpindexToConnect)) {\n             if (!ConnectTip(state, chainparams, pindexConnect, pindexConnect == pindexMostWork ? pblock : std::shared_ptr<const CBlock>(), connectTrace, disconnectpool)) {\n                 if (state.IsInvalid()) {\n                     // The block violates a consensus rule.\n@@ -2294,6 +2415,7 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n \n     CBlockIndex *pindexMostWork = NULL;\n     CBlockIndex *pindexNewTip = NULL;\n+    int nStopAtHeight = GetArg(\"-stopatheight\", DEFAULT_STOPATHEIGHT);\n     do {\n         boost::this_thread::interruption_point();\n         if (ShutdownRequested())\n@@ -2343,6 +2465,8 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n         if (pindexFork != pindexNewTip) {\n             uiInterface.NotifyBlockTip(fInitialDownload, pindexNewTip);\n         }\n+\n+        if (nStopAtHeight && pindexNewTip && pindexNewTip->nHeight >= nStopAtHeight) StartShutdown();\n     } while (pindexNewTip != pindexMostWork);\n     CheckBlockIndex(chainparams.GetConsensus());\n \n@@ -2351,9 +2475,6 @@ bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams,\n         return false;\n     }\n \n-    int nStopAtHeight = GetArg(\"-stopatheight\", DEFAULT_STOPATHEIGHT);\n-    if (nStopAtHeight && pindexNewTip && pindexNewTip->nHeight >= nStopAtHeight) StartShutdown();\n-\n     return true;\n }\n \n@@ -2678,7 +2799,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, const Consensus::P\n     // checks that use witness data may be performed here.\n \n     // Size limits\n-    if (block.vtx.empty() || block.vtx.size() > MAX_BLOCK_BASE_SIZE || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) > MAX_BLOCK_BASE_SIZE)\n+    if (block.vtx.empty() || block.vtx.size() * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT || ::GetSerializeSize(block, SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS) * WITNESS_SCALE_FACTOR > MAX_BLOCK_WEIGHT)\n         return state.DoS(100, false, REJECT_INVALID, \"bad-blk-length\", false, \"size limits failed\");\n \n     // First transaction must be coinbase, the rest must not be\n@@ -2765,7 +2886,7 @@ std::vector<unsigned char> GenerateCoinbaseCommitment(CBlock& block, const CBloc\n     if (consensusParams.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout != 0) {\n         if (commitpos == -1) {\n             uint256 witnessroot = BlockWitnessMerkleRoot(block, NULL);\n-            CHash256().Write(witnessroot.begin(), 32).Write(&ret[0], 32).Finalize(witnessroot.begin());\n+            CHash256().Write(witnessroot.begin(), 32).Write(ret.data(), 32).Finalize(witnessroot.begin());\n             CTxOut out;\n             out.nValue = 0;\n             out.scriptPubKey.resize(38);\n@@ -3111,7 +3232,7 @@ bool TestBlockValidity(CValidationState& state, const CChainParams& chainparams,\n static uint64_t CalculateCurrentUsage()\n {\n     uint64_t retval = 0;\n-    BOOST_FOREACH(const CBlockFileInfo &file, vinfoBlockFile) {\n+    for (const CBlockFileInfo &file : vinfoBlockFile) {\n         retval += file.nSize + file.nUndoSize;\n     }\n     return retval;\n@@ -3322,21 +3443,21 @@ CBlockIndex * InsertBlockIndex(uint256 hash)\n \n bool static LoadBlockIndexDB(const CChainParams& chainparams)\n {\n-    if (!pblocktree->LoadBlockIndexGuts(InsertBlockIndex))\n+    if (!pblocktree->LoadBlockIndexGuts(chainparams.GetConsensus(), InsertBlockIndex))\n         return false;\n \n     boost::this_thread::interruption_point();\n \n     // Calculate nChainWork\n     std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;\n     vSortedByHeight.reserve(mapBlockIndex.size());\n-    BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n+    for (const std::pair<uint256, CBlockIndex*>& item : mapBlockIndex)\n     {\n         CBlockIndex* pindex = item.second;\n         vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));\n     }\n     sort(vSortedByHeight.begin(), vSortedByHeight.end());\n-    BOOST_FOREACH(const PAIRTYPE(int, CBlockIndex*)& item, vSortedByHeight)\n+    for (const std::pair<int, CBlockIndex*>& item : vSortedByHeight)\n     {\n         CBlockIndex* pindex = item.second;\n         pindex->nChainWork = (pindex->pprev ? pindex->pprev->nChainWork : 0) + GetBlockProof(*pindex);\n@@ -3385,7 +3506,7 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n     // Check presence of blk files\n     LogPrintf(\"Checking all blk files are present...\\n\");\n     std::set<int> setBlkDataFiles;\n-    BOOST_FOREACH(const PAIRTYPE(uint256, CBlockIndex*)& item, mapBlockIndex)\n+    for (const std::pair<uint256, CBlockIndex*>& item : mapBlockIndex)\n     {\n         CBlockIndex* pindex = item.second;\n         if (pindex->nStatus & BLOCK_HAVE_DATA) {\n@@ -3414,20 +3535,25 @@ bool static LoadBlockIndexDB(const CChainParams& chainparams)\n     pblocktree->ReadFlag(\"txindex\", fTxIndex);\n     LogPrintf(\"%s: transaction index %s\\n\", __func__, fTxIndex ? \"enabled\" : \"disabled\");\n \n+    return true;\n+}\n+\n+void LoadChainTip(const CChainParams& chainparams)\n+{\n+    if (chainActive.Tip() && chainActive.Tip()->GetBlockHash() == pcoinsTip->GetBestBlock()) return;\n+\n     // Load pointer to end of best chain\n     BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n     if (it == mapBlockIndex.end())\n-        return true;\n+        return;\n     chainActive.SetTip(it->second);\n \n     PruneBlockIndexCandidates();\n \n-    LogPrintf(\"%s: hashBestChain=%s height=%d date=%s progress=%f\\n\", __func__,\n+    LogPrintf(\"Loaded best chain: hashBestChain=%s height=%d date=%s progress=%f\\n\",\n         chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(),\n         DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),\n         GuessVerificationProgress(chainparams.TxData(), chainActive.Tip()));\n-\n-    return true;\n }\n \n CVerifyDB::CVerifyDB()\n@@ -3447,9 +3573,7 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n         return true;\n \n     // Verify blocks in the best chain\n-    if (nCheckDepth <= 0)\n-        nCheckDepth = 1000000000; // suffices until the year 19000\n-    if (nCheckDepth > chainActive.Height())\n+    if (nCheckDepth <= 0 || nCheckDepth > chainActive.Height())\n         nCheckDepth = chainActive.Height();\n     nCheckLevel = std::max(0, std::min(4, nCheckLevel));\n     LogPrintf(\"Verifying last %i blocks at level %i\\n\", nCheckDepth, nCheckLevel);\n@@ -3496,6 +3620,7 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n         }\n         // check level 3: check for inconsistencies during memory-only disconnect of tip blocks\n         if (nCheckLevel >= 3 && pindex == pindexState && (coins.DynamicMemoryUsage() + pcoinsTip->DynamicMemoryUsage()) <= nCoinCacheUsage) {\n+            assert(coins.GetBestBlock() == pindex->GetBlockHash());\n             DisconnectResult res = DisconnectBlock(block, pindex, coins);\n             if (res == DISCONNECT_FAILED) {\n                 return error(\"VerifyDB(): *** irrecoverable inconsistency in block data at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n@@ -3535,6 +3660,92 @@ bool CVerifyDB::VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview,\n     return true;\n }\n \n+/** Apply the effects of a block on the utxo cache, ignoring that it may already have been applied. */\n+static bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs, const CChainParams& params)\n+{\n+    // TODO: merge with ConnectBlock\n+    CBlock block;\n+    if (!ReadBlockFromDisk(block, pindex, params.GetConsensus())) {\n+        return error(\"ReplayBlock(): ReadBlockFromDisk failed at %d, hash=%s\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+    }\n+\n+    for (const CTransactionRef& tx : block.vtx) {\n+        if (!tx->IsCoinBase()) {\n+            for (const CTxIn &txin : tx->vin) {\n+                inputs.SpendCoin(txin.prevout);\n+            }\n+        }\n+        // Pass check = true as every addition may be an overwrite.\n+        AddCoins(inputs, *tx, pindex->nHeight, true);\n+    }\n+    return true;\n+}\n+\n+bool ReplayBlocks(const CChainParams& params, CCoinsView* view)\n+{\n+    LOCK(cs_main);\n+\n+    CCoinsViewCache cache(view);\n+\n+    std::vector<uint256> hashHeads = view->GetHeadBlocks();\n+    if (hashHeads.empty()) return true; // We're already in a consistent state.\n+    if (hashHeads.size() != 2) return error(\"ReplayBlocks(): unknown inconsistent state\");\n+\n+    uiInterface.ShowProgress(_(\"Replaying blocks...\"), 0);\n+    LogPrintf(\"Replaying blocks\\n\");\n+\n+    const CBlockIndex* pindexOld = nullptr;  // Old tip during the interrupted flush.\n+    const CBlockIndex* pindexNew;            // New tip during the interrupted flush.\n+    const CBlockIndex* pindexFork = nullptr; // Latest block common to both the old and the new tip.\n+\n+    if (mapBlockIndex.count(hashHeads[0]) == 0) {\n+        return error(\"ReplayBlocks(): reorganization to unknown block requested\");\n+    }\n+    pindexNew = mapBlockIndex[hashHeads[0]];\n+\n+    if (!hashHeads[1].IsNull()) { // The old tip is allowed to be 0, indicating it's the first flush.\n+        if (mapBlockIndex.count(hashHeads[1]) == 0) {\n+            return error(\"ReplayBlocks(): reorganization from unknown block requested\");\n+        }\n+        pindexOld = mapBlockIndex[hashHeads[1]];\n+        pindexFork = LastCommonAncestor(pindexOld, pindexNew);\n+        assert(pindexFork != nullptr);\n+    }\n+\n+    // Rollback along the old branch.\n+    while (pindexOld != pindexFork) {\n+        if (pindexOld->nHeight > 0) { // Never disconnect the genesis block.\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, pindexOld, params.GetConsensus())) {\n+                return error(\"RollbackBlock(): ReadBlockFromDisk() failed at %d, hash=%s\", pindexOld->nHeight, pindexOld->GetBlockHash().ToString());\n+            }\n+            LogPrintf(\"Rolling back %s (%i)\\n\", pindexOld->GetBlockHash().ToString(), pindexOld->nHeight);\n+            DisconnectResult res = DisconnectBlock(block, pindexOld, cache);\n+            if (res == DISCONNECT_FAILED) {\n+                return error(\"RollbackBlock(): DisconnectBlock failed at %d, hash=%s\", pindexOld->nHeight, pindexOld->GetBlockHash().ToString());\n+            }\n+            // If DISCONNECT_UNCLEAN is returned, it means a non-existing UTXO was deleted, or an existing UTXO was\n+            // overwritten. It corresponds to cases where the block-to-be-disconnect never had all its operations\n+            // applied to the UTXO set. However, as both writing a UTXO and deleting a UTXO are idempotent operations,\n+            // the result is still a version of the UTXO set with the effects of that block undone.\n+        }\n+        pindexOld = pindexOld->pprev;\n+    }\n+\n+    // Roll forward from the forking point to the new tip.\n+    int nForkHeight = pindexFork ? pindexFork->nHeight : 0;\n+    for (int nHeight = nForkHeight + 1; nHeight <= pindexNew->nHeight; ++nHeight) {\n+        const CBlockIndex* pindex = pindexNew->GetAncestor(nHeight);\n+        LogPrintf(\"Rolling forward %s (%i)\\n\", pindex->GetBlockHash().ToString(), nHeight);\n+        if (!RollforwardBlock(pindex, cache, params)) return false;\n+    }\n+\n+    cache.SetBestBlock(pindexNew->GetBlockHash());\n+    cache.Flush();\n+    uiInterface.ShowProgress(\"\", 100);\n+    return true;\n+}\n+\n bool RewindBlockIndex(const CChainParams& params)\n {\n     LOCK(cs_main);\n@@ -3641,7 +3852,7 @@ void UnloadBlockIndex()\n         warningcache[b].clear();\n     }\n \n-    BOOST_FOREACH(BlockMap::value_type& entry, mapBlockIndex) {\n+    for (BlockMap::value_type& entry : mapBlockIndex) {\n         delete entry.second;\n     }\n     mapBlockIndex.clear();\n@@ -3684,8 +3895,6 @@ bool InitBlockIndex(const CChainParams& chainparams)\n             CBlockIndex *pindex = AddToBlockIndex(block);\n             if (!ReceivedBlockTransactions(block, state, pindex, blockPos, chainparams.GetConsensus()))\n                 return error(\"LoadBlockIndex(): genesis block not accepted\");\n-            // Force a chainstate write so that when we VerifyDB in a moment, it doesn't check stale data\n-            return FlushStateToDisk(chainparams, state, FLUSH_STATE_ALWAYS);\n         } catch (const std::runtime_error& e) {\n             return error(\"LoadBlockIndex(): failed to initialize block database: %s\", e.what());\n         }"
      },
      {
        "sha": "95c8e5b93e36bad8cf0f4b9cc22b479b6ded1b92",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 12,
        "deletions": 14,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -32,14 +32,13 @@\n \n class CBlockIndex;\n class CBlockTreeDB;\n-class CBloomFilter;\n class CChainParams;\n+class CCoinsViewDB;\n class CInv;\n class CConnman;\n class CScriptCheck;\n class CBlockPolicyEstimator;\n class CTxMemPool;\n-class CValidationInterface;\n class CValidationState;\n struct ChainTxData;\n \n@@ -261,20 +260,14 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n bool InitBlockIndex(const CChainParams& chainparams);\n /** Load the block tree and coins database from disk */\n bool LoadBlockIndex(const CChainParams& chainparams);\n+/** Update the chain tip based on database information. */\n+void LoadChainTip(const CChainParams& chainparams);\n /** Unload database information */\n void UnloadBlockIndex();\n /** Run an instance of the script checking thread */\n void ThreadScriptCheck();\n /** Check whether we are doing an initial block download (synchronizing from disk or network) */\n bool IsInitialBlockDownload();\n-/** Format a string that describes several potential problems detected by the core.\n- * strFor can have three values:\n- * - \"rpc\": get critical warnings, which should put the client in safe mode if non-empty\n- * - \"statusbar\": get all warnings\n- * - \"gui\": get all warnings, translated (where possible) for GUI\n- * This function only returns the highest priority warning of the set selected by strFor.\n- */\n-std::string GetWarnings(const std::string& strFor);\n /** Retrieve a transaction (from memory pool, or from disk, if possible) */\n bool GetTransaction(const uint256 &hash, CTransactionRef &tx, const Consensus::Params& params, uint256 &hashBlock, bool fAllowSlow = false);\n /** Find the best known block, and make it the tip of the block chain */\n@@ -392,6 +385,9 @@ class CScriptCheck\n     ScriptError GetScriptError() const { return error; }\n };\n \n+/** Initializes the script-execution cache */\n+void InitScriptExecutionCache();\n+\n \n /** Functions for disk access for blocks */\n bool ReadBlockFromDisk(CBlock& block, const CDiskBlockPos& pos, const Consensus::Params& consensusParams);\n@@ -425,6 +421,9 @@ class CVerifyDB {\n     bool VerifyDB(const CChainParams& chainparams, CCoinsView *coinsview, int nCheckLevel, int nCheckDepth);\n };\n \n+/** Replay blocks that aren't fully applied to the database. */\n+bool ReplayBlocks(const CChainParams& params, CCoinsView* view);\n+\n /** Find the last common block between the parameter chain and a locator. */\n CBlockIndex* FindForkInGlobalIndex(const CChain& chain, const CBlockLocator& locator);\n \n@@ -440,6 +439,9 @@ bool ResetBlockFailureFlags(CBlockIndex *pindex);\n /** The currently-connected chain of blocks (protected by cs_main). */\n extern CChain chainActive;\n \n+/** Global variable that points to the coins database (protected by cs_main) */\n+extern CCoinsViewDB *pcoinsdbview;\n+\n /** Global variable that points to the active CCoinsView (protected by cs_main) */\n extern CCoinsViewCache *pcoinsTip;\n \n@@ -467,10 +469,6 @@ int32_t ComputeBlockVersion(const CBlockIndex* pindexPrev, const Consensus::Para\n static const unsigned int REJECT_INTERNAL = 0x100;\n /** Too high fee. Can not be triggered by P2P transactions */\n static const unsigned int REJECT_HIGHFEE = 0x100;\n-/** Transaction is already known (either in mempool or blockchain) */\n-static const unsigned int REJECT_ALREADY_KNOWN = 0x101;\n-/** Transaction conflicts with a transaction already known */\n-static const unsigned int REJECT_CONFLICT = 0x102;\n \n /** Get block file info entry for one block file */\n CBlockFileInfo* GetBlockFileInfo(size_t n);"
      },
      {
        "sha": "bf20d606f833bf033df5787f210b606b8209dae2",
        "filename": "src/validationinterface.cpp",
        "status": "modified",
        "additions": 104,
        "deletions": 30,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/validationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/validationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -4,49 +4,123 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"validationinterface.h\"\n+#include \"init.h\"\n+#include \"scheduler.h\"\n+#include \"sync.h\"\n+#include \"util.h\"\n+\n+#include <list>\n+#include <atomic>\n+\n+#include <boost/signals2/signal.hpp>\n+\n+struct MainSignalsInstance {\n+    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n+    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n+    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex, const std::vector<CTransactionRef>&)> BlockConnected;\n+    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &)> BlockDisconnected;\n+    boost::signals2::signal<void (const CBlockLocator &)> SetBestChain;\n+    boost::signals2::signal<void (const uint256 &)> Inventory;\n+    boost::signals2::signal<void (int64_t nBestBlockTime, CConnman* connman)> Broadcast;\n+    boost::signals2::signal<void (const CBlock&, const CValidationState&)> BlockChecked;\n+    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n+\n+    // We are not allowed to assume the scheduler only runs in one thread,\n+    // but must ensure all callbacks happen in-order, so we end up creating\n+    // our own queue here :(\n+    SingleThreadedSchedulerClient m_schedulerClient;\n+\n+    MainSignalsInstance(CScheduler *pscheduler) : m_schedulerClient(pscheduler) {}\n+};\n \n static CMainSignals g_signals;\n \n+void CMainSignals::RegisterBackgroundSignalScheduler(CScheduler& scheduler) {\n+    assert(!m_internals);\n+    m_internals.reset(new MainSignalsInstance(&scheduler));\n+}\n+\n+void CMainSignals::UnregisterBackgroundSignalScheduler() {\n+    m_internals.reset(nullptr);\n+}\n+\n+void CMainSignals::FlushBackgroundCallbacks() {\n+    m_internals->m_schedulerClient.EmptyQueue();\n+}\n+\n CMainSignals& GetMainSignals()\n {\n     return g_signals;\n }\n \n void RegisterValidationInterface(CValidationInterface* pwalletIn) {\n-    g_signals.UpdatedBlockTip.connect(boost::bind(&CValidationInterface::UpdatedBlockTip, pwalletIn, _1, _2, _3));\n-    g_signals.TransactionAddedToMempool.connect(boost::bind(&CValidationInterface::TransactionAddedToMempool, pwalletIn, _1));\n-    g_signals.BlockConnected.connect(boost::bind(&CValidationInterface::BlockConnected, pwalletIn, _1, _2, _3));\n-    g_signals.BlockDisconnected.connect(boost::bind(&CValidationInterface::BlockDisconnected, pwalletIn, _1));\n-    g_signals.SetBestChain.connect(boost::bind(&CValidationInterface::SetBestChain, pwalletIn, _1));\n-    g_signals.Inventory.connect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));\n-    g_signals.Broadcast.connect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn, _1, _2));\n-    g_signals.BlockChecked.connect(boost::bind(&CValidationInterface::BlockChecked, pwalletIn, _1, _2));\n-    g_signals.ScriptForMining.connect(boost::bind(&CValidationInterface::GetScriptForMining, pwalletIn, _1));\n-    g_signals.NewPoWValidBlock.connect(boost::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2));\n+    g_signals.m_internals->UpdatedBlockTip.connect(boost::bind(&CValidationInterface::UpdatedBlockTip, pwalletIn, _1, _2, _3));\n+    g_signals.m_internals->TransactionAddedToMempool.connect(boost::bind(&CValidationInterface::TransactionAddedToMempool, pwalletIn, _1));\n+    g_signals.m_internals->BlockConnected.connect(boost::bind(&CValidationInterface::BlockConnected, pwalletIn, _1, _2, _3));\n+    g_signals.m_internals->BlockDisconnected.connect(boost::bind(&CValidationInterface::BlockDisconnected, pwalletIn, _1));\n+    g_signals.m_internals->SetBestChain.connect(boost::bind(&CValidationInterface::SetBestChain, pwalletIn, _1));\n+    g_signals.m_internals->Inventory.connect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));\n+    g_signals.m_internals->Broadcast.connect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn, _1, _2));\n+    g_signals.m_internals->BlockChecked.connect(boost::bind(&CValidationInterface::BlockChecked, pwalletIn, _1, _2));\n+    g_signals.m_internals->NewPoWValidBlock.connect(boost::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2));\n }\n \n void UnregisterValidationInterface(CValidationInterface* pwalletIn) {\n-    g_signals.ScriptForMining.disconnect(boost::bind(&CValidationInterface::GetScriptForMining, pwalletIn, _1));\n-    g_signals.BlockChecked.disconnect(boost::bind(&CValidationInterface::BlockChecked, pwalletIn, _1, _2));\n-    g_signals.Broadcast.disconnect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn, _1, _2));\n-    g_signals.Inventory.disconnect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));\n-    g_signals.SetBestChain.disconnect(boost::bind(&CValidationInterface::SetBestChain, pwalletIn, _1));\n-    g_signals.TransactionAddedToMempool.disconnect(boost::bind(&CValidationInterface::TransactionAddedToMempool, pwalletIn, _1));\n-    g_signals.BlockConnected.disconnect(boost::bind(&CValidationInterface::BlockConnected, pwalletIn, _1, _2, _3));\n-    g_signals.BlockDisconnected.disconnect(boost::bind(&CValidationInterface::BlockDisconnected, pwalletIn, _1));\n-    g_signals.UpdatedBlockTip.disconnect(boost::bind(&CValidationInterface::UpdatedBlockTip, pwalletIn, _1, _2, _3));\n-    g_signals.NewPoWValidBlock.disconnect(boost::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2));\n+    g_signals.m_internals->BlockChecked.disconnect(boost::bind(&CValidationInterface::BlockChecked, pwalletIn, _1, _2));\n+    g_signals.m_internals->Broadcast.disconnect(boost::bind(&CValidationInterface::ResendWalletTransactions, pwalletIn, _1, _2));\n+    g_signals.m_internals->Inventory.disconnect(boost::bind(&CValidationInterface::Inventory, pwalletIn, _1));\n+    g_signals.m_internals->SetBestChain.disconnect(boost::bind(&CValidationInterface::SetBestChain, pwalletIn, _1));\n+    g_signals.m_internals->TransactionAddedToMempool.disconnect(boost::bind(&CValidationInterface::TransactionAddedToMempool, pwalletIn, _1));\n+    g_signals.m_internals->BlockConnected.disconnect(boost::bind(&CValidationInterface::BlockConnected, pwalletIn, _1, _2, _3));\n+    g_signals.m_internals->BlockDisconnected.disconnect(boost::bind(&CValidationInterface::BlockDisconnected, pwalletIn, _1));\n+    g_signals.m_internals->UpdatedBlockTip.disconnect(boost::bind(&CValidationInterface::UpdatedBlockTip, pwalletIn, _1, _2, _3));\n+    g_signals.m_internals->NewPoWValidBlock.disconnect(boost::bind(&CValidationInterface::NewPoWValidBlock, pwalletIn, _1, _2));\n }\n \n void UnregisterAllValidationInterfaces() {\n-    g_signals.ScriptForMining.disconnect_all_slots();\n-    g_signals.BlockChecked.disconnect_all_slots();\n-    g_signals.Broadcast.disconnect_all_slots();\n-    g_signals.Inventory.disconnect_all_slots();\n-    g_signals.SetBestChain.disconnect_all_slots();\n-    g_signals.TransactionAddedToMempool.disconnect_all_slots();\n-    g_signals.BlockConnected.disconnect_all_slots();\n-    g_signals.BlockDisconnected.disconnect_all_slots();\n-    g_signals.UpdatedBlockTip.disconnect_all_slots();\n-    g_signals.NewPoWValidBlock.disconnect_all_slots();\n+    g_signals.m_internals->BlockChecked.disconnect_all_slots();\n+    g_signals.m_internals->Broadcast.disconnect_all_slots();\n+    g_signals.m_internals->Inventory.disconnect_all_slots();\n+    g_signals.m_internals->SetBestChain.disconnect_all_slots();\n+    g_signals.m_internals->TransactionAddedToMempool.disconnect_all_slots();\n+    g_signals.m_internals->BlockConnected.disconnect_all_slots();\n+    g_signals.m_internals->BlockDisconnected.disconnect_all_slots();\n+    g_signals.m_internals->UpdatedBlockTip.disconnect_all_slots();\n+    g_signals.m_internals->NewPoWValidBlock.disconnect_all_slots();\n+}\n+\n+void CMainSignals::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) {\n+    m_internals->UpdatedBlockTip(pindexNew, pindexFork, fInitialDownload);\n+}\n+\n+void CMainSignals::TransactionAddedToMempool(const CTransactionRef &ptx) {\n+    m_internals->TransactionAddedToMempool(ptx);\n+}\n+\n+void CMainSignals::BlockConnected(const std::shared_ptr<const CBlock> &pblock, const CBlockIndex *pindex, const std::vector<CTransactionRef>& vtxConflicted) {\n+    m_internals->BlockConnected(pblock, pindex, vtxConflicted);\n+}\n+\n+void CMainSignals::BlockDisconnected(const std::shared_ptr<const CBlock> &pblock) {\n+    m_internals->BlockDisconnected(pblock);\n+}\n+\n+void CMainSignals::SetBestChain(const CBlockLocator &locator) {\n+    m_internals->SetBestChain(locator);\n+}\n+\n+void CMainSignals::Inventory(const uint256 &hash) {\n+    m_internals->Inventory(hash);\n+}\n+\n+void CMainSignals::Broadcast(int64_t nBestBlockTime, CConnman* connman) {\n+    m_internals->Broadcast(nBestBlockTime, connman);\n+}\n+\n+void CMainSignals::BlockChecked(const CBlock& block, const CValidationState& state) {\n+    m_internals->BlockChecked(block, state);\n+}\n+\n+void CMainSignals::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock> &block) {\n+    m_internals->NewPoWValidBlock(pindex, block);\n }"
      },
      {
        "sha": "d6da2bc1fd2d28444ad925416af5f20136990e68",
        "filename": "src/validationinterface.h",
        "status": "modified",
        "additions": 42,
        "deletions": 29,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/validationinterface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/validationinterface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validationinterface.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -6,7 +6,6 @@\n #ifndef BITCOIN_VALIDATIONINTERFACE_H\n #define BITCOIN_VALIDATIONINTERFACE_H\n \n-#include <boost/signals2/signal.hpp>\n #include <memory>\n \n #include \"primitives/transaction.h\" // CTransaction(Ref)\n@@ -20,6 +19,7 @@ class CReserveScript;\n class CValidationInterface;\n class CValidationState;\n class uint256;\n+class CScheduler;\n \n // These functions dispatch to one or all registered wallets\n \n@@ -32,52 +32,65 @@ void UnregisterAllValidationInterfaces();\n \n class CValidationInterface {\n protected:\n-    virtual void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) {}\n-    virtual void TransactionAddedToMempool(const CTransactionRef &ptxn) {}\n-    virtual void BlockConnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex *pindex, const std::vector<CTransactionRef> &txnConflicted) {}\n-    virtual void BlockDisconnected(const std::shared_ptr<const CBlock> &block) {}\n-    virtual void SetBestChain(const CBlockLocator &locator) {}\n-    virtual void Inventory(const uint256 &hash) {}\n-    virtual void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman) {}\n-    virtual void BlockChecked(const CBlock&, const CValidationState&) {}\n-    virtual void GetScriptForMining(std::shared_ptr<CReserveScript>&) {};\n-    virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& block) {};\n-    friend void ::RegisterValidationInterface(CValidationInterface*);\n-    friend void ::UnregisterValidationInterface(CValidationInterface*);\n-    friend void ::UnregisterAllValidationInterfaces();\n-};\n-\n-struct CMainSignals {\n     /** Notifies listeners of updated block chain tip */\n-    boost::signals2::signal<void (const CBlockIndex *, const CBlockIndex *, bool fInitialDownload)> UpdatedBlockTip;\n+    virtual void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) {}\n     /** Notifies listeners of a transaction having been added to mempool. */\n-    boost::signals2::signal<void (const CTransactionRef &)> TransactionAddedToMempool;\n+    virtual void TransactionAddedToMempool(const CTransactionRef &ptxn) {}\n     /**\n      * Notifies listeners of a block being connected.\n      * Provides a vector of transactions evicted from the mempool as a result.\n      */\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex, const std::vector<CTransactionRef> &)> BlockConnected;\n+    virtual void BlockConnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex *pindex, const std::vector<CTransactionRef> &txnConflicted) {}\n     /** Notifies listeners of a block being disconnected */\n-    boost::signals2::signal<void (const std::shared_ptr<const CBlock> &)> BlockDisconnected;\n-    /** Notifies listeners of a new active block chain. */\n-    boost::signals2::signal<void (const CBlockLocator &)> SetBestChain;\n+    virtual void BlockDisconnected(const std::shared_ptr<const CBlock> &block) {}\n+    /** Notifies listeners of the new active block chain on-disk. */\n+    virtual void SetBestChain(const CBlockLocator &locator) {}\n     /** Notifies listeners about an inventory item being seen on the network. */\n-    boost::signals2::signal<void (const uint256 &)> Inventory;\n+    virtual void Inventory(const uint256 &hash) {}\n     /** Tells listeners to broadcast their data. */\n-    boost::signals2::signal<void (int64_t nBestBlockTime, CConnman* connman)> Broadcast;\n+    virtual void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman) {}\n     /**\n      * Notifies listeners of a block validation result.\n      * If the provided CValidationState IsValid, the provided block\n      * is guaranteed to be the current best block at the time the\n      * callback was generated (not necessarily now)\n      */\n-    boost::signals2::signal<void (const CBlock&, const CValidationState&)> BlockChecked;\n-    /** Notifies listeners that a key for mining is required (coinbase) */\n-    boost::signals2::signal<void (std::shared_ptr<CReserveScript>&)> ScriptForMining;\n+    virtual void BlockChecked(const CBlock&, const CValidationState&) {}\n     /**\n      * Notifies listeners that a block which builds directly on our current tip\n      * has been received and connected to the headers tree, though not validated yet */\n-    boost::signals2::signal<void (const CBlockIndex *, const std::shared_ptr<const CBlock>&)> NewPoWValidBlock;\n+    virtual void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& block) {};\n+    friend void ::RegisterValidationInterface(CValidationInterface*);\n+    friend void ::UnregisterValidationInterface(CValidationInterface*);\n+    friend void ::UnregisterAllValidationInterfaces();\n+};\n+\n+struct MainSignalsInstance;\n+class CMainSignals {\n+private:\n+    std::unique_ptr<MainSignalsInstance> m_internals;\n+\n+    friend void ::RegisterValidationInterface(CValidationInterface*);\n+    friend void ::UnregisterValidationInterface(CValidationInterface*);\n+    friend void ::UnregisterAllValidationInterfaces();\n+\n+public:\n+    /** Register a CScheduler to give callbacks which should run in the background (may only be called once) */\n+    void RegisterBackgroundSignalScheduler(CScheduler& scheduler);\n+    /** Unregister a CScheduler to give callbacks which should run in the background - these callbacks will now be dropped! */\n+    void UnregisterBackgroundSignalScheduler();\n+    /** Call any remaining callbacks on the calling thread */\n+    void FlushBackgroundCallbacks();\n+\n+    void UpdatedBlockTip(const CBlockIndex *, const CBlockIndex *, bool fInitialDownload);\n+    void TransactionAddedToMempool(const CTransactionRef &);\n+    void BlockConnected(const std::shared_ptr<const CBlock> &, const CBlockIndex *pindex, const std::vector<CTransactionRef> &);\n+    void BlockDisconnected(const std::shared_ptr<const CBlock> &);\n+    void SetBestChain(const CBlockLocator &);\n+    void Inventory(const uint256 &);\n+    void Broadcast(int64_t nBestBlockTime, CConnman* connman);\n+    void BlockChecked(const CBlock&, const CValidationState&);\n+    void NewPoWValidBlock(const CBlockIndex *, const std::shared_ptr<const CBlock>&);\n };\n \n CMainSignals& GetMainSignals();"
      },
      {
        "sha": "d5282124907d797a311052965f4a5d4f8b1d1173",
        "filename": "src/version.h",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/version.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/version.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/version.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -27,9 +27,6 @@ static const int CADDR_TIME_VERSION = 31402;\n //! BIP 0031, pong message, is enabled for all versions AFTER this one\n static const int BIP0031_VERSION = 60000;\n \n-//! \"mempool\" command, enhanced \"getdata\" behavior starts with this version\n-static const int MEMPOOL_GD_VERSION = 60002;\n-\n //! \"filter*\" commands are disabled without NODE_BLOOM after and including this version\n static const int NO_BLOOM_VERSION = 70011;\n "
      },
      {
        "sha": "8047e17aa826dab5f97848c2488a6ad273d17b3d",
        "filename": "src/versionbits.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/versionbits.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -174,12 +174,12 @@ class VersionBitsConditionChecker : public AbstractThresholdConditionChecker {\n     const Consensus::DeploymentPos id;\n \n protected:\n-    int64_t BeginTime(const Consensus::Params& params) const { return params.vDeployments[id].nStartTime; }\n-    int64_t EndTime(const Consensus::Params& params) const { return params.vDeployments[id].nTimeout; }\n-    int Period(const Consensus::Params& params) const { return params.nMinerConfirmationWindow; }\n-    int Threshold(const Consensus::Params& params) const { return params.nRuleChangeActivationThreshold; }\n+    int64_t BeginTime(const Consensus::Params& params) const override { return params.vDeployments[id].nStartTime; }\n+    int64_t EndTime(const Consensus::Params& params) const override { return params.vDeployments[id].nTimeout; }\n+    int Period(const Consensus::Params& params) const override { return params.nMinerConfirmationWindow; }\n+    int Threshold(const Consensus::Params& params) const override { return params.nRuleChangeActivationThreshold; }\n \n-    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const\n+    bool Condition(const CBlockIndex* pindex, const Consensus::Params& params) const override\n     {\n         return (((pindex->nVersion & VERSIONBITS_TOP_MASK) == VERSIONBITS_TOP_BITS) && (pindex->nVersion & Mask(params)) != 0);\n     }\n@@ -189,7 +189,7 @@ class VersionBitsConditionChecker : public AbstractThresholdConditionChecker {\n     uint32_t Mask(const Consensus::Params& params) const { return ((uint32_t)1) << params.vDeployments[id].bit; }\n };\n \n-}\n+} // namespace\n \n ThresholdState VersionBitsState(const CBlockIndex* pindexPrev, const Consensus::Params& params, Consensus::DeploymentPos pos, VersionBitsCache& cache)\n {"
      },
      {
        "sha": "fc0e7c519ed012637f301e7dd8e692848d1f57f2",
        "filename": "src/wallet/coincontrol.h",
        "status": "modified",
        "additions": 13,
        "deletions": 7,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/coincontrol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/coincontrol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coincontrol.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -6,9 +6,12 @@\n #define BITCOIN_WALLET_COINCONTROL_H\n \n #include \"policy/feerate.h\"\n+#include \"policy/fees.h\"\n #include \"primitives/transaction.h\"\n #include \"wallet/wallet.h\"\n \n+#include <boost/optional.hpp>\n+\n /** Coin Control Features. */\n class CCoinControl\n {\n@@ -18,14 +21,16 @@ class CCoinControl\n     bool fAllowOtherInputs;\n     //! Includes watch only addresses which match the ISMINE_WATCH_SOLVABLE criteria\n     bool fAllowWatchOnly;\n-    //! Override estimated feerate\n+    //! Override automatic min/max checks on fee, m_feerate must be set if true\n     bool fOverrideFeeRate;\n-    //! Feerate to use if overrideFeeRate is true\n-    CFeeRate nFeeRate;\n-    //! Override the default confirmation target, 0 = use default\n-    int nConfirmTarget;\n+    //! Override the default payTxFee if set\n+    boost::optional<CFeeRate> m_feerate;\n+    //! Override the default confirmation target if set\n+    boost::optional<unsigned int> m_confirm_target;\n     //! Signal BIP-125 replace by fee.\n     bool signalRbf;\n+    //! Fee estimation mode to control arguments to estimateSmartFee\n+    FeeEstimateMode m_fee_mode;\n \n     CCoinControl()\n     {\n@@ -38,10 +43,11 @@ class CCoinControl\n         fAllowOtherInputs = false;\n         fAllowWatchOnly = false;\n         setSelected.clear();\n-        nFeeRate = CFeeRate(0);\n+        m_feerate.reset();\n         fOverrideFeeRate = false;\n-        nConfirmTarget = 0;\n+        m_confirm_target.reset();\n         signalRbf = fWalletRbf;\n+        m_fee_mode = FeeEstimateMode::UNSET;\n     }\n \n     bool HasSelected() const"
      },
      {
        "sha": "dcce88cedc7e1b628c21ef48de10323ed9d45945",
        "filename": "src/wallet/crypter.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/crypter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/crypter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -12,7 +12,6 @@\n \n #include <string>\n #include <vector>\n-#include <boost/foreach.hpp>\n \n int CCrypter::BytesToKeySHA512AES(const std::vector<unsigned char>& chSalt, const SecureString& strKeyData, int count, unsigned char *key,unsigned char *iv) const\n {\n@@ -274,7 +273,6 @@ bool CCryptoKeyStore::GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) co\n         // Check for watch-only pubkeys\n         return CBasicKeyStore::GetPubKey(address, vchPubKeyOut);\n     }\n-    return false;\n }\n \n bool CCryptoKeyStore::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n@@ -285,7 +283,7 @@ bool CCryptoKeyStore::EncryptKeys(CKeyingMaterial& vMasterKeyIn)\n             return false;\n \n         fUseCrypto = true;\n-        BOOST_FOREACH(KeyMap::value_type& mKey, mapKeys)\n+        for (KeyMap::value_type& mKey : mapKeys)\n         {\n             const CKey &key = mKey.second;\n             CPubKey vchPubKey = key.GetPubKey();"
      },
      {
        "sha": "1dc44e424f631f4cd419443a0b338fc68b9f9f47",
        "filename": "src/wallet/crypter.h",
        "status": "modified",
        "additions": 5,
        "deletions": 7,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/crypter.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -9,8 +9,6 @@\n #include \"serialize.h\"\n #include \"support/allocators/secure.h\"\n \n-class uint256;\n-\n const unsigned int WALLET_CRYPTO_KEY_SIZE = 32;\n const unsigned int WALLET_CRYPTO_SALT_SIZE = 8;\n const unsigned int WALLET_CRYPTO_IV_SIZE = 16;\n@@ -159,8 +157,8 @@ class CCryptoKeyStore : public CBasicKeyStore\n     bool Lock();\n \n     virtual bool AddCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n-    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n-    bool HaveKey(const CKeyID &address) const\n+    bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey) override;\n+    bool HaveKey(const CKeyID &address) const override\n     {\n         {\n             LOCK(cs_KeyStore);\n@@ -170,9 +168,9 @@ class CCryptoKeyStore : public CBasicKeyStore\n         }\n         return false;\n     }\n-    bool GetKey(const CKeyID &address, CKey& keyOut) const;\n-    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const;\n-    void GetKeys(std::set<CKeyID> &setAddress) const\n+    bool GetKey(const CKeyID &address, CKey& keyOut) const override;\n+    bool GetPubKey(const CKeyID &address, CPubKey& vchPubKeyOut) const override;\n+    void GetKeys(std::set<CKeyID> &setAddress) const override\n     {\n         if (!IsCrypted())\n         {"
      },
      {
        "sha": "da2d1807563bcb2e89c0b1afb5239d5960744ff9",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 13,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -18,9 +18,7 @@\n #include <sys/stat.h>\n #endif\n \n-#include <boost/foreach.hpp>\n #include <boost/thread.hpp>\n-#include <boost/version.hpp>\n \n //\n // CDB\n@@ -75,7 +73,7 @@ bool CDBEnv::Open(const fs::path& pathIn)\n \n     strPath = pathIn.string();\n     fs::path pathLogDir = pathIn / \"database\";\n-    TryCreateDirectory(pathLogDir);\n+    TryCreateDirectories(pathLogDir);\n     fs::path pathErrorFile = pathIn / \"db.log\";\n     LogPrintf(\"CDBEnv::Open: LogDir=%s ErrorFile=%s\\n\", pathLogDir.string(), pathErrorFile.string());\n \n@@ -143,7 +141,7 @@ void CDBEnv::MakeMock()\n     fMockDb = true;\n }\n \n-CDBEnv::VerifyResult CDBEnv::Verify(const std::string& strFile, bool (*recoverFunc)(const std::string& strFile))\n+CDBEnv::VerifyResult CDBEnv::Verify(const std::string& strFile, recoverFunc_type recoverFunc, std::string& out_backup_filename)\n {\n     LOCK(cs_db);\n     assert(mapFileUseCount.count(strFile) == 0);\n@@ -156,21 +154,21 @@ CDBEnv::VerifyResult CDBEnv::Verify(const std::string& strFile, bool (*recoverFu\n         return RECOVER_FAIL;\n \n     // Try to recover:\n-    bool fRecovered = (*recoverFunc)(strFile);\n+    bool fRecovered = (*recoverFunc)(strFile, out_backup_filename);\n     return (fRecovered ? RECOVER_OK : RECOVER_FAIL);\n }\n \n-bool CDB::Recover(const std::string& filename, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue))\n+bool CDB::Recover(const std::string& filename, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& newFilename)\n {\n     // Recovery procedure:\n-    // move wallet file to wallet.timestamp.bak\n+    // move wallet file to walletfilename.timestamp.bak\n     // Call Salvage with fAggressive=true to\n     // get as much data as possible.\n     // Rewrite salvaged data to fresh wallet file\n     // Set -rescan so any missing transactions will be\n     // found.\n     int64_t now = GetTime();\n-    std::string newFilename = strprintf(\"wallet.%d.bak\", now);\n+    newFilename = strprintf(\"%s.%d.bak\", filename, now);\n \n     int result = bitdb.dbenv->dbrename(NULL, filename.c_str(), NULL,\n                                        newFilename.c_str(), DB_AUTO_COMMIT);\n@@ -205,7 +203,7 @@ bool CDB::Recover(const std::string& filename, void *callbackDataIn, bool (*reco\n     }\n \n     DbTxn* ptxn = bitdb.TxnBegin();\n-    BOOST_FOREACH(CDBEnv::KeyValPair& row, salvagedData)\n+    for (CDBEnv::KeyValPair& row : salvagedData)\n     {\n         if (recoverKVcallback)\n         {\n@@ -260,18 +258,19 @@ bool CDB::VerifyEnvironment(const std::string& walletFile, const fs::path& dataD\n     return true;\n }\n \n-bool CDB::VerifyDatabaseFile(const std::string& walletFile, const fs::path& dataDir, std::string& warningStr, std::string& errorStr, bool (*recoverFunc)(const std::string& strFile))\n+bool CDB::VerifyDatabaseFile(const std::string& walletFile, const fs::path& dataDir, std::string& warningStr, std::string& errorStr, CDBEnv::recoverFunc_type recoverFunc)\n {\n     if (fs::exists(dataDir / walletFile))\n     {\n-        CDBEnv::VerifyResult r = bitdb.Verify(walletFile, recoverFunc);\n+        std::string backup_filename;\n+        CDBEnv::VerifyResult r = bitdb.Verify(walletFile, recoverFunc, backup_filename);\n         if (r == CDBEnv::RECOVER_OK)\n         {\n             warningStr = strprintf(_(\"Warning: Wallet file corrupt, data salvaged!\"\n                                      \" Original %s saved as %s in %s; if\"\n                                      \" your balance or transactions are incorrect you should\"\n                                      \" restore from a backup.\"),\n-                                   walletFile, \"wallet.{timestamp}.bak\", dataDir);\n+                                   walletFile, backup_filename, dataDir);\n         }\n         if (r == CDBEnv::RECOVER_FAIL)\n         {\n@@ -360,7 +359,6 @@ void CDBEnv::CheckpointLSN(const std::string& strFile)\n \n CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb(NULL), activeTxn(NULL)\n {\n-    int ret;\n     fReadOnly = (!strchr(pszMode, '+') && !strchr(pszMode, 'w'));\n     fFlushOnClose = fFlushOnCloseIn;\n     env = dbw.env;\n@@ -383,6 +381,7 @@ CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb\n         ++env->mapFileUseCount[strFile];\n         pdb = env->mapDb[strFile];\n         if (pdb == NULL) {\n+            int ret;\n             pdb = new Db(env->dbenv, 0);\n \n             bool fMockDb = env->IsMock();\n@@ -433,6 +432,11 @@ void CDB::Flush()\n     env->dbenv->txn_checkpoint(nMinutes ? GetArg(\"-dblogsize\", DEFAULT_WALLET_DBLOGSIZE) * 1024 : 0, nMinutes, 0);\n }\n \n+void CWalletDBWrapper::IncrementUpdateCounter()\n+{\n+    ++nUpdateCounter;\n+}\n+\n void CDB::Close()\n {\n     if (!pdb)"
      },
      {
        "sha": "4f3ad0c42dee66bbf90fc0a6adb7e858c95ed7b1",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 15,
        "deletions": 6,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -13,6 +13,7 @@\n #include \"sync.h\"\n #include \"version.h\"\n \n+#include <atomic>\n #include <map>\n #include <string>\n #include <vector>\n@@ -55,7 +56,8 @@ class CDBEnv\n     enum VerifyResult { VERIFY_OK,\n                         RECOVER_OK,\n                         RECOVER_FAIL };\n-    VerifyResult Verify(const std::string& strFile, bool (*recoverFunc)(const std::string& strFile));\n+    typedef bool (*recoverFunc_type)(const std::string& strFile, std::string& out_backup_filename);\n+    VerifyResult Verify(const std::string& strFile, recoverFunc_type recoverFunc, std::string& out_backup_filename);\n     /**\n      * Salvage data from a file that Verify says is bad.\n      * fAggressive sets the DB_AGGRESSIVE flag (see berkeley DB->verify() method documentation).\n@@ -93,13 +95,13 @@ class CWalletDBWrapper\n     friend class CDB;\n public:\n     /** Create dummy DB handle */\n-    CWalletDBWrapper(): env(nullptr)\n+    CWalletDBWrapper() : nUpdateCounter(0), nLastSeen(0), nLastFlushed(0), nLastWalletUpdate(0), env(nullptr)\n     {\n     }\n \n     /** Create DB handle to real database */\n-    CWalletDBWrapper(CDBEnv *env_in, const std::string &strFile_in):\n-        env(env_in), strFile(strFile_in)\n+    CWalletDBWrapper(CDBEnv *env_in, const std::string &strFile_in) :\n+        nUpdateCounter(0), nLastSeen(0), nLastFlushed(0), nLastWalletUpdate(0), env(env_in), strFile(strFile_in)\n     {\n     }\n \n@@ -119,6 +121,13 @@ class CWalletDBWrapper\n      */\n     void Flush(bool shutdown);\n \n+    void IncrementUpdateCounter();\n+\n+    std::atomic<unsigned int> nUpdateCounter;\n+    unsigned int nLastSeen;\n+    unsigned int nLastFlushed;\n+    int64_t nLastWalletUpdate;\n+\n private:\n     /** BerkeleyDB specific */\n     CDBEnv *env;\n@@ -149,15 +158,15 @@ class CDB\n \n     void Flush();\n     void Close();\n-    static bool Recover(const std::string& filename, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue));\n+    static bool Recover(const std::string& filename, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& out_backup_filename);\n \n     /* flush the wallet passively (TRY_LOCK)\n        ideal to be called periodically */\n     static bool PeriodicFlush(CWalletDBWrapper& dbw);\n     /* verifies the database environment */\n     static bool VerifyEnvironment(const std::string& walletFile, const fs::path& dataDir, std::string& errorStr);\n     /* verifies the database file */\n-    static bool VerifyDatabaseFile(const std::string& walletFile, const fs::path& dataDir, std::string& warningStr, std::string& errorStr, bool (*recoverFunc)(const std::string& strFile));\n+    static bool VerifyDatabaseFile(const std::string& walletFile, const fs::path& dataDir, std::string& warningStr, std::string& errorStr, CDBEnv::recoverFunc_type recoverFunc);\n \n private:\n     CDB(const CDB&);"
      },
      {
        "sha": "4bfd8726a54f771b46c1df7fe478ab964a5415e3",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -3,6 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"consensus/validation.h\"\n+#include \"wallet/coincontrol.h\"\n #include \"wallet/feebumper.h\"\n #include \"wallet/wallet.h\"\n #include \"policy/fees.h\"\n@@ -66,7 +67,7 @@ bool CFeeBumper::preconditionChecks(const CWallet *pWallet, const CWalletTx& wtx\n     return true;\n }\n \n-CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConfirmTarget, bool ignoreGlobalPayTxFee, CAmount totalFee, bool newTxReplaceable)\n+CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, const CCoinControl& coin_control, CAmount totalFee)\n     :\n     txid(std::move(txidIn)),\n     nOldFee(0),\n@@ -165,7 +166,7 @@ CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConf\n         nNewFee = totalFee;\n         nNewFeeRate = CFeeRate(totalFee, maxNewTxSize);\n     } else {\n-        nNewFee = CWallet::GetMinimumFee(maxNewTxSize, newConfirmTarget, mempool, ::feeEstimator, ignoreGlobalPayTxFee);\n+        nNewFee = CWallet::GetMinimumFee(maxNewTxSize, coin_control, mempool, ::feeEstimator, nullptr /* FeeCalculation */);\n         nNewFeeRate = CFeeRate(nNewFee, maxNewTxSize);\n \n         // New fee rate must be at least old rate + minimum incremental relay rate\n@@ -220,7 +221,7 @@ CFeeBumper::CFeeBumper(const CWallet *pWallet, const uint256 txidIn, int newConf\n     }\n \n     // Mark new tx not replaceable, if requested.\n-    if (!newTxReplaceable) {\n+    if (!coin_control.signalRbf) {\n         for (auto& input : mtx.vin) {\n             if (input.nSequence < 0xfffffffe) input.nSequence = 0xfffffffe;\n         }"
      },
      {
        "sha": "3d64e53c15c850d4c8e839b0c36ad694eb540385",
        "filename": "src/wallet/feebumper.h",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/feebumper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/feebumper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -10,6 +10,8 @@\n class CWallet;\n class CWalletTx;\n class uint256;\n+class CCoinControl;\n+enum class FeeEstimateMode;\n \n enum class BumpFeeResult\n {\n@@ -24,7 +26,7 @@ enum class BumpFeeResult\n class CFeeBumper\n {\n public:\n-    CFeeBumper(const CWallet *pWalletIn, const uint256 txidIn, int newConfirmTarget, bool ignoreGlobalPayTxFee, CAmount totalFee, bool newTxReplaceable);\n+    CFeeBumper(const CWallet *pWalletIn, const uint256 txidIn, const CCoinControl& coin_control, CAmount totalFee);\n     BumpFeeResult getResult() const { return currentResult; }\n     const std::vector<std::string>& getErrors() const { return vErrors; }\n     CAmount getOldFee() const { return nOldFee; }"
      },
      {
        "sha": "5abf32480a846cfa482c4b49706caec6a80f8082",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 31,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -26,7 +26,6 @@\n \n #include <univalue.h>\n \n-#include <boost/foreach.hpp>\n \n std::string static EncodeDumpTime(int64_t nTime) {\n     return DateTimeStrFormat(\"%Y-%m-%dT%H:%M:%SZ\", nTime);\n@@ -47,7 +46,7 @@ int64_t static DecodeDumpTime(const std::string &str) {\n \n std::string static EncodeDumpString(const std::string &str) {\n     std::stringstream ret;\n-    BOOST_FOREACH(unsigned char c, str) {\n+    for (unsigned char c : str) {\n         if (c <= 32 || c >= 128 || c == '%') {\n             ret << '%' << HexStr(&c, &c + 1);\n         } else {\n@@ -107,12 +106,12 @@ UniValue importprivkey(const JSONRPCRequest& request)\n \n     std::string strSecret = request.params[0].get_str();\n     std::string strLabel = \"\";\n-    if (request.params.size() > 1)\n+    if (!request.params[1].isNull())\n         strLabel = request.params[1].get_str();\n \n     // Whether to perform rescan after import\n     bool fRescan = true;\n-    if (request.params.size() > 2)\n+    if (!request.params[2].isNull())\n         fRescan = request.params[2].get_bool();\n \n     if (fRescan && fPruneMode)\n@@ -148,7 +147,7 @@ UniValue importprivkey(const JSONRPCRequest& request)\n         pwallet->UpdateTimeFirstKey(1);\n \n         if (fRescan) {\n-            pwallet->ScanForWalletTransactions(chainActive.Genesis(), true);\n+            pwallet->RescanFromTime(TIMESTAMP_MIN, true /* update */);\n         }\n     }\n \n@@ -246,20 +245,20 @@ UniValue importaddress(const JSONRPCRequest& request)\n \n \n     std::string strLabel = \"\";\n-    if (request.params.size() > 1)\n+    if (!request.params[1].isNull())\n         strLabel = request.params[1].get_str();\n \n     // Whether to perform rescan after import\n     bool fRescan = true;\n-    if (request.params.size() > 2)\n+    if (!request.params[2].isNull())\n         fRescan = request.params[2].get_bool();\n \n     if (fRescan && fPruneMode)\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Rescan is disabled in pruned mode\");\n \n     // Whether to import a p2sh version, too\n     bool fP2SH = false;\n-    if (request.params.size() > 3)\n+    if (!request.params[3].isNull())\n         fP2SH = request.params[3].get_bool();\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n@@ -278,7 +277,7 @@ UniValue importaddress(const JSONRPCRequest& request)\n \n     if (fRescan)\n     {\n-        pwallet->ScanForWalletTransactions(chainActive.Genesis(), true);\n+        pwallet->RescanFromTime(TIMESTAMP_MIN, true /* update */);\n         pwallet->ReacceptWalletTransactions();\n     }\n \n@@ -362,7 +361,7 @@ UniValue removeprunedfunds(const JSONRPCRequest& request)\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"removeprunedfunds\", \"\\\"a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\\\"\") +\n             \"\\nAs a JSON-RPC call\\n\"\n-            + HelpExampleRpc(\"removprunedfunds\", \"\\\"a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\\\"\")\n+            + HelpExampleRpc(\"removeprunedfunds\", \"\\\"a8d0c0184dde994a09ec054286f1ce581bebf46446a512166eae7628734ea0a5\\\"\")\n         );\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n@@ -411,12 +410,12 @@ UniValue importpubkey(const JSONRPCRequest& request)\n \n \n     std::string strLabel = \"\";\n-    if (request.params.size() > 1)\n+    if (!request.params[1].isNull())\n         strLabel = request.params[1].get_str();\n \n     // Whether to perform rescan after import\n     bool fRescan = true;\n-    if (request.params.size() > 2)\n+    if (!request.params[2].isNull())\n         fRescan = request.params[2].get_bool();\n \n     if (fRescan && fPruneMode)\n@@ -436,7 +435,7 @@ UniValue importpubkey(const JSONRPCRequest& request)\n \n     if (fRescan)\n     {\n-        pwallet->ScanForWalletTransactions(chainActive.Genesis(), true);\n+        pwallet->RescanFromTime(TIMESTAMP_MIN, true /* update */);\n         pwallet->ReacceptWalletTransactions();\n     }\n \n@@ -536,11 +535,7 @@ UniValue importwallet(const JSONRPCRequest& request)\n     file.close();\n     pwallet->ShowProgress(\"\", 100); // hide progress dialog in GUI\n     pwallet->UpdateTimeFirstKey(nTimeBegin);\n-\n-    CBlockIndex *pindex = chainActive.FindEarliestAtLeast(nTimeBegin - TIMESTAMP_WINDOW);\n-\n-    LogPrintf(\"Rescanning last %i blocks\\n\", pindex ? chainActive.Height() - pindex->nHeight + 1 : 0);\n-    pwallet->ScanForWalletTransactions(pindex);\n+    pwallet->RescanFromTime(nTimeBegin, false /* update */);\n     pwallet->MarkDirty();\n \n     if (!fGood)\n@@ -1033,7 +1028,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n     // clang-format off\n     if (mainRequest.fHelp || mainRequest.params.size() < 1 || mainRequest.params.size() > 2)\n         throw std::runtime_error(\n-            \"importmulti \\\"requests\\\" \\\"options\\\"\\n\\n\"\n+            \"importmulti \\\"requests\\\" ( \\\"options\\\" )\\n\\n\"\n             \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n             \"Arguments:\\n\"\n             \"1. requests     (array, required) Data to be imported\\n\"\n@@ -1049,7 +1044,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n             \"      \\\"redeemscript\\\": \\\"<script>\\\"                            , (string, optional) Allowed only if the scriptPubKey is a P2SH address or a P2SH scriptPubKey\\n\"\n             \"      \\\"pubkeys\\\": [\\\"<pubKey>\\\", ... ]                         , (array, optional) Array of strings giving pubkeys that must occur in the output or redeemscript\\n\"\n             \"      \\\"keys\\\": [\\\"<key>\\\", ... ]                               , (array, optional) Array of strings giving private keys whose corresponding public keys must occur in the output or redeemscript\\n\"\n-            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be be treated as not incoming payments\\n\"\n+            \"      \\\"internal\\\": <true>                                    , (boolean, optional, default: false) Stating whether matching outputs should be treated as not incoming payments\\n\"\n             \"      \\\"watchonly\\\": <true>                                   , (boolean, optional, default: false) Stating whether matching outputs should be considered watched even when they're not spendable, only allowed if keys are empty\\n\"\n             \"      \\\"label\\\": <label>                                      , (string, optional, default: '') Label to assign to the address (aka account name, for now), only allowed with internal=false\\n\"\n             \"    }\\n\"\n@@ -1076,7 +1071,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n     //Default options\n     bool fRescan = true;\n \n-    if (mainRequest.params.size() > 1) {\n+    if (!mainRequest.params[1].isNull()) {\n         const UniValue& options = mainRequest.params[1];\n \n         if (options.exists(\"rescan\")) {\n@@ -1105,7 +1100,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     UniValue response(UniValue::VARR);\n \n-    BOOST_FOREACH (const UniValue& data, requests.getValues()) {\n+    for (const UniValue& data : requests.getValues()) {\n         const int64_t timestamp = std::max(GetImportTimestamp(data, now), minimumTimestamp);\n         const UniValue result = ProcessImport(pwallet, data, timestamp);\n         response.push_back(result);\n@@ -1126,14 +1121,10 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n     }\n \n     if (fRescan && fRunScan && requests.size()) {\n-        CBlockIndex* pindex = nLowestTimestamp > minimumTimestamp ? chainActive.FindEarliestAtLeast(std::max<int64_t>(nLowestTimestamp - TIMESTAMP_WINDOW, 0)) : chainActive.Genesis();\n-        CBlockIndex* scanFailed = nullptr;\n-        if (pindex) {\n-            scanFailed = pwallet->ScanForWalletTransactions(pindex, true);\n-            pwallet->ReacceptWalletTransactions();\n-        }\n+        int64_t scannedTime = pwallet->RescanFromTime(nLowestTimestamp, true /* update */);\n+        pwallet->ReacceptWalletTransactions();\n \n-        if (scanFailed) {\n+        if (scannedTime > nLowestTimestamp) {\n             std::vector<UniValue> results = response.getValues();\n             response.clear();\n             response.setArray();\n@@ -1143,7 +1134,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n                 // range, or if the import result already has an error set, let\n                 // the result stand unmodified. Otherwise replace the result\n                 // with an error message.\n-                if (GetImportTimestamp(request, now) - TIMESTAMP_WINDOW > scanFailed->GetBlockTimeMax() || results.at(i).exists(\"error\")) {\n+                if (scannedTime <= GetImportTimestamp(request, now) || results.at(i).exists(\"error\")) {\n                     response.push_back(results.at(i));\n                 } else {\n                     UniValue result = UniValue(UniValue::VOBJ);\n@@ -1159,7 +1150,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n                                       \"caused by pruning or data corruption (see bitcoind log for details) and could \"\n                                       \"be dealt with by downloading and rescanning the relevant blocks (see -reindex \"\n                                       \"and -rescan options).\",\n-                                GetImportTimestamp(request, now), scanFailed->GetBlockTimeMax(), TIMESTAMP_WINDOW)));\n+                                GetImportTimestamp(request, now), scannedTime - TIMESTAMP_WINDOW - 1, TIMESTAMP_WINDOW)));\n                     response.push_back(std::move(result));\n                 }\n                 ++i;"
      },
      {
        "sha": "4275a9181d6ac806d091906a99e8fecf513a7a8f",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 203,
        "deletions": 90,
        "changes": 293,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -9,13 +9,14 @@\n #include \"consensus/validation.h\"\n #include \"core_io.h\"\n #include \"init.h\"\n-#include \"wallet/coincontrol.h\"\n+#include \"httpserver.h\"\n #include \"validation.h\"\n #include \"net.h\"\n #include \"policy/feerate.h\"\n #include \"policy/fees.h\"\n #include \"policy/policy.h\"\n #include \"policy/rbf.h\"\n+#include \"rpc/mining.h\"\n #include \"rpc/server.h\"\n #include \"script/sign.h\"\n #include \"timedata.h\"\n@@ -30,9 +31,21 @@\n \n #include <univalue.h>\n \n+static const std::string WALLET_ENDPOINT_BASE = \"/wallet/\";\n+\n CWallet *GetWalletForJSONRPCRequest(const JSONRPCRequest& request)\n {\n-    return pwalletMain;\n+    if (request.URI.substr(0, WALLET_ENDPOINT_BASE.size()) == WALLET_ENDPOINT_BASE) {\n+        // wallet endpoint was used\n+        std::string requestedWallet = urlDecode(request.URI.substr(WALLET_ENDPOINT_BASE.size()));\n+        for (CWalletRef pwallet : ::vpwallets) {\n+            if (pwallet->GetName() == requestedWallet) {\n+                return pwallet;\n+            }\n+        }\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Requested wallet does not exist or is not loaded\");\n+    }\n+    return ::vpwallets.size() == 1 || (request.fHelp && ::vpwallets.size() > 0) ? ::vpwallets[0] : nullptr;\n }\n \n std::string HelpRequiringPassphrase(CWallet * const pwallet)\n@@ -77,7 +90,7 @@ void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)\n     uint256 hash = wtx.GetHash();\n     entry.push_back(Pair(\"txid\", hash.GetHex()));\n     UniValue conflicts(UniValue::VARR);\n-    BOOST_FOREACH(const uint256& conflict, wtx.GetConflicts())\n+    for (const uint256& conflict : wtx.GetConflicts())\n         conflicts.push_back(conflict.GetHex());\n     entry.push_back(Pair(\"walletconflicts\", conflicts));\n     entry.push_back(Pair(\"time\", wtx.GetTxTime()));\n@@ -95,7 +108,7 @@ void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)\n     }\n     entry.push_back(Pair(\"bip125-replaceable\", rbfStatus));\n \n-    BOOST_FOREACH(const PAIRTYPE(std::string, std::string)& item, wtx.mapValue)\n+    for (const std::pair<std::string, std::string>& item : wtx.mapValue)\n         entry.push_back(Pair(item.first, item.second));\n }\n \n@@ -133,7 +146,7 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n \n     // Parse the account first so we don't generate a key if there's an error\n     std::string strAccount;\n-    if (request.params.size() > 0)\n+    if (!request.params[0].isNull())\n         strAccount = AccountFromValue(request.params[0]);\n \n     if (!pwallet->IsLocked()) {\n@@ -204,7 +217,7 @@ UniValue getrawchangeaddress(const JSONRPCRequest& request)\n         return NullUniValue;\n     }\n \n-    if (request.fHelp || request.params.size() > 1)\n+    if (request.fHelp || request.params.size() > 0)\n         throw std::runtime_error(\n             \"getrawchangeaddress\\n\"\n             \"\\nReturns a new Bitcoin address, for receiving change.\\n\"\n@@ -355,7 +368,7 @@ UniValue getaddressesbyaccount(const JSONRPCRequest& request)\n     return ret;\n }\n \n-static void SendMoney(CWallet * const pwallet, const CTxDestination &address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx& wtxNew)\n+static void SendMoney(CWallet * const pwallet, const CTxDestination &address, CAmount nValue, bool fSubtractFeeFromAmount, CWalletTx& wtxNew, const CCoinControl& coin_control)\n {\n     CAmount curBalance = pwallet->GetBalance();\n \n@@ -381,7 +394,7 @@ static void SendMoney(CWallet * const pwallet, const CTxDestination &address, CA\n     int nChangePosRet = -1;\n     CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};\n     vecSend.push_back(recipient);\n-    if (!pwallet->CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError)) {\n+    if (!pwallet->CreateTransaction(vecSend, wtxNew, reservekey, nFeeRequired, nChangePosRet, strError, coin_control)) {\n         if (!fSubtractFeeFromAmount && nValue + nFeeRequired > curBalance)\n             strError = strprintf(\"Error: This transaction requires a transaction fee of at least %s\", FormatMoney(nFeeRequired));\n         throw JSONRPCError(RPC_WALLET_ERROR, strError);\n@@ -400,9 +413,9 @@ UniValue sendtoaddress(const JSONRPCRequest& request)\n         return NullUniValue;\n     }\n \n-    if (request.fHelp || request.params.size() < 2 || request.params.size() > 5)\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 8)\n         throw std::runtime_error(\n-            \"sendtoaddress \\\"address\\\" amount ( \\\"comment\\\" \\\"comment_to\\\" subtractfeefromamount )\\n\"\n+            \"sendtoaddress \\\"address\\\" amount ( \\\"comment\\\" \\\"comment_to\\\" subtractfeefromamount replaceable conf_target \\\"estimate_mode\\\")\\n\"\n             \"\\nSend an amount to a given address.\\n\"\n             + HelpRequiringPassphrase(pwallet) +\n             \"\\nArguments:\\n\"\n@@ -415,6 +428,12 @@ UniValue sendtoaddress(const JSONRPCRequest& request)\n             \"                             transaction, just kept in your wallet.\\n\"\n             \"5. subtractfeefromamount  (boolean, optional, default=false) The fee will be deducted from the amount being sent.\\n\"\n             \"                             The recipient will receive less bitcoins than you enter in the amount field.\\n\"\n+            \"6. replaceable            (boolean, optional) Allow this transaction to be replaced by a transaction with higher fees via BIP 125\\n\"\n+            \"7. conf_target            (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"8. \\\"estimate_mode\\\"      (string, optional, default=UNSET) The fee estimate mode, must be one of:\\n\"\n+            \"       \\\"UNSET\\\"\\n\"\n+            \"       \\\"ECONOMICAL\\\"\\n\"\n+            \"       \\\"CONSERVATIVE\\\"\\n\"\n             \"\\nResult:\\n\"\n             \"\\\"txid\\\"                  (string) The transaction id.\\n\"\n             \"\\nExamples:\\n\"\n@@ -443,12 +462,29 @@ UniValue sendtoaddress(const JSONRPCRequest& request)\n         wtx.mapValue[\"to\"]      = request.params[3].get_str();\n \n     bool fSubtractFeeFromAmount = false;\n-    if (request.params.size() > 4)\n+    if (request.params.size() > 4 && !request.params[4].isNull()) {\n         fSubtractFeeFromAmount = request.params[4].get_bool();\n+    }\n+\n+    CCoinControl coin_control;\n+    if (request.params.size() > 5 && !request.params[5].isNull()) {\n+        coin_control.signalRbf = request.params[5].get_bool();\n+    }\n+\n+    if (request.params.size() > 6 && !request.params[6].isNull()) {\n+        coin_control.m_confirm_target = ParseConfirmTarget(request.params[6]);\n+    }\n+\n+    if (request.params.size() > 7 && !request.params[7].isNull()) {\n+        if (!FeeModeFromString(request.params[7].get_str(), coin_control.m_fee_mode)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid estimate_mode parameter\");\n+        }\n+    }\n+\n \n     EnsureWalletIsUnlocked(pwallet);\n \n-    SendMoney(pwallet, address.Get(), nAmount, fSubtractFeeFromAmount, wtx);\n+    SendMoney(pwallet, address.Get(), nAmount, fSubtractFeeFromAmount, wtx, coin_control);\n \n     return wtx.GetHash().GetHex();\n }\n@@ -460,7 +496,7 @@ UniValue listaddressgroupings(const JSONRPCRequest& request)\n         return NullUniValue;\n     }\n \n-    if (request.fHelp)\n+    if (request.fHelp || request.params.size() != 0)\n         throw std::runtime_error(\n             \"listaddressgroupings\\n\"\n             \"\\nLists groups of addresses which have had their common ownership\\n\"\n@@ -489,7 +525,7 @@ UniValue listaddressgroupings(const JSONRPCRequest& request)\n     std::map<CTxDestination, CAmount> balances = pwallet->GetAddressBalances();\n     for (std::set<CTxDestination> grouping : pwallet->GetAddressGroupings()) {\n         UniValue jsonGrouping(UniValue::VARR);\n-        BOOST_FOREACH(CTxDestination address, grouping)\n+        for (CTxDestination address : grouping)\n         {\n             UniValue addressInfo(UniValue::VARR);\n             addressInfo.push_back(CBitcoinAddress(address).ToString());\n@@ -605,7 +641,7 @@ UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n \n     // Minimum confirmations\n     int nMinDepth = 1;\n-    if (request.params.size() > 1)\n+    if (!request.params[1].isNull())\n         nMinDepth = request.params[1].get_int();\n \n     // Tally\n@@ -615,7 +651,7 @@ UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n         if (wtx.IsCoinBase() || !CheckFinalTx(*wtx.tx))\n             continue;\n \n-        BOOST_FOREACH(const CTxOut& txout, wtx.tx->vout)\n+        for (const CTxOut& txout : wtx.tx->vout)\n             if (txout.scriptPubKey == scriptPubKey)\n                 if (wtx.GetDepthInMainChain() >= nMinDepth)\n                     nAmount += txout.nValue;\n@@ -656,7 +692,7 @@ UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n \n     // Minimum confirmations\n     int nMinDepth = 1;\n-    if (request.params.size() > 1)\n+    if (!request.params[1].isNull())\n         nMinDepth = request.params[1].get_int();\n \n     // Get the set of pub keys assigned to account\n@@ -670,7 +706,7 @@ UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n         if (wtx.IsCoinBase() || !CheckFinalTx(*wtx.tx))\n             continue;\n \n-        BOOST_FOREACH(const CTxOut& txout, wtx.tx->vout)\n+        for (const CTxOut& txout : wtx.tx->vout)\n         {\n             CTxDestination address;\n             if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*pwallet, address) && setAddress.count(address)) {\n@@ -716,9 +752,9 @@ UniValue getbalance(const JSONRPCRequest& request)\n             \"\\nResult:\\n\"\n             \"amount              (numeric) The total amount in \" + CURRENCY_UNIT + \" received for this account.\\n\"\n             \"\\nExamples:\\n\"\n-            \"\\nThe total amount in the wallet\\n\"\n+            \"\\nThe total amount in the wallet with 1 or more confirmations\\n\"\n             + HelpExampleCli(\"getbalance\", \"\") +\n-            \"\\nThe total amount in the wallet at least 5 blocks confirmed\\n\"\n+            \"\\nThe total amount in the wallet at least 6 blocks confirmed\\n\"\n             + HelpExampleCli(\"getbalance\", \"\\\"*\\\" 6\") +\n             \"\\nAs a json rpc call\\n\"\n             + HelpExampleRpc(\"getbalance\", \"\\\"*\\\", 6\")\n@@ -733,10 +769,10 @@ UniValue getbalance(const JSONRPCRequest& request)\n     const std::string* account = account_param != \"*\" ? &account_param : nullptr;\n \n     int nMinDepth = 1;\n-    if (request.params.size() > 1)\n+    if (!request.params[1].isNull())\n         nMinDepth = request.params[1].get_int();\n     isminefilter filter = ISMINE_SPENDABLE;\n-    if(request.params.size() > 2)\n+    if(!request.params[2].isNull())\n         if(request.params[2].get_bool())\n             filter = filter | ISMINE_WATCH_ONLY;\n \n@@ -874,7 +910,8 @@ UniValue sendfrom(const JSONRPCRequest& request)\n     if (nAmount > nBalance)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n \n-    SendMoney(pwallet, address.Get(), nAmount, false, wtx);\n+    CCoinControl no_coin_control; // This is a deprecated API\n+    SendMoney(pwallet, address.Get(), nAmount, false, wtx, no_coin_control);\n \n     return wtx.GetHash().GetHex();\n }\n@@ -887,9 +924,9 @@ UniValue sendmany(const JSONRPCRequest& request)\n         return NullUniValue;\n     }\n \n-    if (request.fHelp || request.params.size() < 2 || request.params.size() > 5)\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 8)\n         throw std::runtime_error(\n-            \"sendmany \\\"fromaccount\\\" {\\\"address\\\":amount,...} ( minconf \\\"comment\\\" [\\\"address\\\",...] )\\n\"\n+            \"sendmany \\\"fromaccount\\\" {\\\"address\\\":amount,...} ( minconf \\\"comment\\\" [\\\"address\\\",...] replaceable conf_target \\\"estimate_mode\\\")\\n\"\n             \"\\nSend multiple times. Amounts are double-precision floating point numbers.\"\n             + HelpRequiringPassphrase(pwallet) + \"\\n\"\n             \"\\nArguments:\\n\"\n@@ -909,7 +946,13 @@ UniValue sendmany(const JSONRPCRequest& request)\n             \"      \\\"address\\\"          (string) Subtract fee from this address\\n\"\n             \"      ,...\\n\"\n             \"    ]\\n\"\n-            \"\\nResult:\\n\"\n+            \"6. replaceable            (boolean, optional) Allow this transaction to be replaced by a transaction with higher fees via BIP 125\\n\"\n+            \"7. conf_target            (numeric, optional) Confirmation target (in blocks)\\n\"\n+            \"8. \\\"estimate_mode\\\"      (string, optional, default=UNSET) The fee estimate mode, must be one of:\\n\"\n+            \"       \\\"UNSET\\\"\\n\"\n+            \"       \\\"ECONOMICAL\\\"\\n\"\n+            \"       \\\"CONSERVATIVE\\\"\\n\"\n+             \"\\nResult:\\n\"\n             \"\\\"txid\\\"                   (string) The transaction id for the send. Only 1 transaction is created regardless of \\n\"\n             \"                                    the number of addresses.\\n\"\n             \"\\nExamples:\\n\"\n@@ -932,7 +975,7 @@ UniValue sendmany(const JSONRPCRequest& request)\n     std::string strAccount = AccountFromValue(request.params[0]);\n     UniValue sendTo = request.params[1].get_obj();\n     int nMinDepth = 1;\n-    if (request.params.size() > 2)\n+    if (!request.params[2].isNull())\n         nMinDepth = request.params[2].get_int();\n \n     CWalletTx wtx;\n@@ -941,15 +984,30 @@ UniValue sendmany(const JSONRPCRequest& request)\n         wtx.mapValue[\"comment\"] = request.params[3].get_str();\n \n     UniValue subtractFeeFromAmount(UniValue::VARR);\n-    if (request.params.size() > 4)\n+    if (request.params.size() > 4 && !request.params[4].isNull())\n         subtractFeeFromAmount = request.params[4].get_array();\n \n+    CCoinControl coin_control;\n+    if (request.params.size() > 5 && !request.params[5].isNull()) {\n+        coin_control.signalRbf = request.params[5].get_bool();\n+    }\n+\n+    if (request.params.size() > 6 && !request.params[6].isNull()) {\n+        coin_control.m_confirm_target = ParseConfirmTarget(request.params[6]);\n+    }\n+\n+    if (request.params.size() > 7 && !request.params[7].isNull()) {\n+        if (!FeeModeFromString(request.params[7].get_str(), coin_control.m_fee_mode)) {\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid estimate_mode parameter\");\n+        }\n+    }\n+\n     std::set<CBitcoinAddress> setAddress;\n     std::vector<CRecipient> vecSend;\n \n     CAmount totalAmount = 0;\n     std::vector<std::string> keys = sendTo.getKeys();\n-    BOOST_FOREACH(const std::string& name_, keys)\n+    for (const std::string& name_ : keys)\n     {\n         CBitcoinAddress address(name_);\n         if (!address.IsValid())\n@@ -988,7 +1046,7 @@ UniValue sendmany(const JSONRPCRequest& request)\n     CAmount nFeeRequired = 0;\n     int nChangePosRet = -1;\n     std::string strFailReason;\n-    bool fCreated = pwallet->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired, nChangePosRet, strFailReason);\n+    bool fCreated = pwallet->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired, nChangePosRet, strFailReason, coin_control);\n     if (!fCreated)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, strFailReason);\n     CValidationState state;\n@@ -1064,7 +1122,6 @@ class Witnessifier : public boost::static_visitor<bool>\n     bool operator()(const CNoDestination &dest) const { return false; }\n \n     bool operator()(const CKeyID &keyID) {\n-        CPubKey pubkey;\n         if (pwallet) {\n             CScript basescript = GetScriptForDestination(keyID);\n             isminetype typ;\n@@ -1165,16 +1222,16 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n {\n     // Minimum confirmations\n     int nMinDepth = 1;\n-    if (params.size() > 0)\n+    if (!params[0].isNull())\n         nMinDepth = params[0].get_int();\n \n     // Whether to include empty accounts\n     bool fIncludeEmpty = false;\n-    if (params.size() > 1)\n+    if (!params[1].isNull())\n         fIncludeEmpty = params[1].get_bool();\n \n     isminefilter filter = ISMINE_SPENDABLE;\n-    if(params.size() > 2)\n+    if(!params[2].isNull())\n         if(params[2].get_bool())\n             filter = filter | ISMINE_WATCH_ONLY;\n \n@@ -1190,7 +1247,7 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n         if (nDepth < nMinDepth)\n             continue;\n \n-        BOOST_FOREACH(const CTxOut& txout, wtx.tx->vout)\n+        for (const CTxOut& txout : wtx.tx->vout)\n         {\n             CTxDestination address;\n             if (!ExtractDestination(txout.scriptPubKey, address))\n@@ -1250,7 +1307,7 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n             UniValue transactions(UniValue::VARR);\n             if (it != mapTally.end())\n             {\n-                BOOST_FOREACH(const uint256& _item, (*it).second.txids)\n+                for (const uint256& _item : (*it).second.txids)\n                 {\n                     transactions.push_back(_item.GetHex());\n                 }\n@@ -1384,7 +1441,7 @@ void ListTransactions(CWallet* const pwallet, const CWalletTx& wtx, const std::s\n     // Sent\n     if ((!listSent.empty() || nFee != 0) && (fAllAccounts || strAccount == strSentAccount))\n     {\n-        BOOST_FOREACH(const COutputEntry& s, listSent)\n+        for (const COutputEntry& s : listSent)\n         {\n             UniValue entry(UniValue::VOBJ);\n             if (involvesWatchonly || (::IsMine(*pwallet, s.destination) & ISMINE_WATCH_ONLY)) {\n@@ -1409,7 +1466,7 @@ void ListTransactions(CWallet* const pwallet, const CWalletTx& wtx, const std::s\n     // Received\n     if (listReceived.size() > 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n     {\n-        BOOST_FOREACH(const COutputEntry& r, listReceived)\n+        for (const COutputEntry& r : listReceived)\n         {\n             std::string account;\n             if (pwallet->mapAddressBook.count(r.destination)) {\n@@ -1536,16 +1593,16 @@ UniValue listtransactions(const JSONRPCRequest& request)\n     LOCK2(cs_main, pwallet->cs_wallet);\n \n     std::string strAccount = \"*\";\n-    if (request.params.size() > 0)\n+    if (!request.params[0].isNull())\n         strAccount = request.params[0].get_str();\n     int nCount = 10;\n-    if (request.params.size() > 1)\n+    if (!request.params[1].isNull())\n         nCount = request.params[1].get_int();\n     int nFrom = 0;\n-    if (request.params.size() > 2)\n+    if (!request.params[2].isNull())\n         nFrom = request.params[2].get_int();\n     isminefilter filter = ISMINE_SPENDABLE;\n-    if(request.params.size() > 3)\n+    if(!request.params[3].isNull())\n         if(request.params[3].get_bool())\n             filter = filter | ISMINE_WATCH_ONLY;\n \n@@ -1654,11 +1711,11 @@ UniValue listaccounts(const JSONRPCRequest& request)\n             continue;\n         wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount, includeWatchonly);\n         mapAccountBalances[strSentAccount] -= nFee;\n-        BOOST_FOREACH(const COutputEntry& s, listSent)\n+        for (const COutputEntry& s : listSent)\n             mapAccountBalances[strSentAccount] -= s.amount;\n         if (nDepth >= nMinDepth)\n         {\n-            BOOST_FOREACH(const COutputEntry& r, listReceived)\n+            for (const COutputEntry& r : listReceived)\n                 if (pwallet->mapAddressBook.count(r.destination)) {\n                     mapAccountBalances[pwallet->mapAddressBook[r.destination].name] += r.amount;\n                 }\n@@ -1668,11 +1725,11 @@ UniValue listaccounts(const JSONRPCRequest& request)\n     }\n \n     const std::list<CAccountingEntry>& acentries = pwallet->laccentries;\n-    BOOST_FOREACH(const CAccountingEntry& entry, acentries)\n+    for (const CAccountingEntry& entry : acentries)\n         mapAccountBalances[entry.strAccount] += entry.nCreditDebit;\n \n     UniValue ret(UniValue::VOBJ);\n-    BOOST_FOREACH(const PAIRTYPE(std::string, CAmount)& accountBalance, mapAccountBalances) {\n+    for (const std::pair<std::string, CAmount>& accountBalance : mapAccountBalances) {\n         ret.push_back(Pair(accountBalance.first, ValueFromAmount(accountBalance.second)));\n     }\n     return ret;\n@@ -1685,7 +1742,7 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n         return NullUniValue;\n     }\n \n-    if (request.fHelp)\n+    if (request.fHelp || request.params.size() > 3)\n         throw std::runtime_error(\n             \"listsinceblock ( \\\"blockhash\\\" target_confirmations include_watchonly)\\n\"\n             \"\\nGet all transactions in blocks since block [blockhash], or all transactions if omitted\\n\"\n@@ -1732,7 +1789,7 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n     int target_confirms = 1;\n     isminefilter filter = ISMINE_SPENDABLE;\n \n-    if (request.params.size() > 0)\n+    if (!request.params[0].isNull())\n     {\n         uint256 blockId;\n \n@@ -1751,7 +1808,7 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n         }\n     }\n \n-    if (request.params.size() > 1)\n+    if (!request.params[1].isNull())\n     {\n         target_confirms = request.params[1].get_int();\n \n@@ -1843,7 +1900,7 @@ UniValue gettransaction(const JSONRPCRequest& request)\n     hash.SetHex(request.params[0].get_str());\n \n     isminefilter filter = ISMINE_SPENDABLE;\n-    if(request.params.size() > 1)\n+    if(!request.params[1].isNull())\n         if(request.params[1].get_bool())\n             filter = filter | ISMINE_WATCH_ONLY;\n \n@@ -1965,7 +2022,7 @@ UniValue keypoolrefill(const JSONRPCRequest& request)\n \n     // 0 is interpreted by TopUpKeyPool() as the default keypool size given by -keypool\n     unsigned int kpSize = 0;\n-    if (request.params.size() > 0) {\n+    if (!request.params[0].isNull()) {\n         if (request.params[0].get_int() < 0)\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, expected valid size.\");\n         kpSize = (unsigned int)request.params[0].get_int();\n@@ -2337,7 +2394,7 @@ UniValue listlockunspent(const JSONRPCRequest& request)\n \n     UniValue ret(UniValue::VARR);\n \n-    BOOST_FOREACH(COutPoint &outpt, vOutpts) {\n+    for (COutPoint &outpt : vOutpts) {\n         UniValue o(UniValue::VOBJ);\n \n         o.push_back(Pair(\"txid\", outpt.hash.GetHex()));\n@@ -2455,7 +2512,7 @@ UniValue resendwallettransactions(const JSONRPCRequest& request)\n \n     std::vector<uint256> txids = pwallet->ResendWalletTransactionsBefore(GetTime(), g_connman.get());\n     UniValue result(UniValue::VARR);\n-    BOOST_FOREACH(const uint256& txid, txids)\n+    for (const uint256& txid : txids)\n     {\n         result.push_back(txid.ToString());\n     }\n@@ -2558,7 +2615,7 @@ UniValue listunspent(const JSONRPCRequest& request)\n     CAmount nMinimumSumAmount = MAX_MONEY;\n     uint64_t nMaximumCount = 0;\n \n-    if (request.params.size() > 4) {\n+    if (!request.params[4].isNull()) {\n         const UniValue& options = request.params[4].get_obj();\n \n         if (options.exists(\"minimumAmount\"))\n@@ -2580,7 +2637,7 @@ UniValue listunspent(const JSONRPCRequest& request)\n     LOCK2(cs_main, pwallet->cs_wallet);\n \n     pwallet->AvailableCoins(vecOutputs, !include_unsafe, NULL, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount, nMinDepth, nMaxDepth);\n-    BOOST_FOREACH(const COutput& out, vecOutputs) {\n+    for (const COutput& out : vecOutputs) {\n         CTxDestination address;\n         const CScript& scriptPubKey = out.tx->tx->vout[out.i].scriptPubKey;\n         bool fValidAddress = ExtractDestination(scriptPubKey, address);\n@@ -2627,7 +2684,7 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n         return NullUniValue;\n     }\n \n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n         throw std::runtime_error(\n                             \"fundrawtransaction \\\"hexstring\\\" ( options )\\n\"\n                             \"\\nAdd inputs to a transaction until it has enough in value to meet its out value.\\n\"\n@@ -2648,15 +2705,20 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n                             \"     \\\"changePosition\\\"         (numeric, optional, default random) The index of the change output\\n\"\n                             \"     \\\"includeWatching\\\"        (boolean, optional, default false) Also select inputs which are watch only\\n\"\n                             \"     \\\"lockUnspents\\\"           (boolean, optional, default false) Lock selected unspent outputs\\n\"\n-                            \"     \\\"reserveChangeKey\\\"       (boolean, optional, default true) Reserves the change output key from the keypool\\n\"\n                             \"     \\\"feeRate\\\"                (numeric, optional, default not set: makes wallet determine the fee) Set a specific feerate (\" + CURRENCY_UNIT + \" per KB)\\n\"\n                             \"     \\\"subtractFeeFromOutputs\\\" (array, optional) A json array of integers.\\n\"\n                             \"                              The fee will be equally deducted from the amount of each specified output.\\n\"\n                             \"                              The outputs are specified by their zero-based index, before any change output is added.\\n\"\n                             \"                              Those recipients will receive less bitcoins than you enter in their corresponding amount field.\\n\"\n                             \"                              If no outputs are specified here, the sender pays the fee.\\n\"\n                             \"                                  [vout_index,...]\\n\"\n-                            \"     \\\"optIntoRbf\\\"             (boolean, optional) Allow this transaction to be replaced by a transaction with higher fees\\n\"\n+                            \"     \\\"replaceable\\\"            (boolean, optional) Marks this transaction as BIP125 replaceable.\\n\"\n+                            \"                              Allows this transaction to be replaced by a transaction with higher fees\\n\"\n+                            \"     \\\"conf_target\\\"            (numeric, optional) Confirmation target (in blocks)\\n\"\n+                            \"     \\\"estimate_mode\\\"          (string, optional, default=UNSET) The fee estimate mode, must be one of:\\n\"\n+                            \"         \\\"UNSET\\\"\\n\"\n+                            \"         \\\"ECONOMICAL\\\"\\n\"\n+                            \"         \\\"CONSERVATIVE\\\"\\n\"\n                             \"   }\\n\"\n                             \"                         for backward compatibility: passing in a true instead of an object will result in {\\\"includeWatching\\\":true}\\n\"\n                             \"\\nResult:\\n\"\n@@ -2679,17 +2741,12 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     RPCTypeCheck(request.params, {UniValue::VSTR});\n \n     CCoinControl coinControl;\n-    coinControl.destChange = CNoDestination();\n     int changePosition = -1;\n-    coinControl.fAllowWatchOnly = false;  // include watching\n     bool lockUnspents = false;\n-    bool reserveChangeKey = true;\n-    coinControl.nFeeRate = CFeeRate(0);\n-    coinControl.fOverrideFeeRate = false;\n     UniValue subtractFeeFromOutputs;\n     std::set<int> setSubtractFeeFromOutputs;\n \n-    if (request.params.size() > 1) {\n+    if (!request.params[1].isNull()) {\n       if (request.params[1].type() == UniValue::VBOOL) {\n         // backward compatibility bool only fallback\n         coinControl.fAllowWatchOnly = request.params[1].get_bool();\n@@ -2705,10 +2762,12 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n                 {\"changePosition\", UniValueType(UniValue::VNUM)},\n                 {\"includeWatching\", UniValueType(UniValue::VBOOL)},\n                 {\"lockUnspents\", UniValueType(UniValue::VBOOL)},\n-                {\"reserveChangeKey\", UniValueType(UniValue::VBOOL)},\n+                {\"reserveChangeKey\", UniValueType(UniValue::VBOOL)}, // DEPRECATED (and ignored), should be removed in 0.16 or so.\n                 {\"feeRate\", UniValueType()}, // will be checked below\n                 {\"subtractFeeFromOutputs\", UniValueType(UniValue::VARR)},\n-                {\"optIntoRbf\", UniValueType(UniValue::VBOOL)},\n+                {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+                {\"conf_target\", UniValueType(UniValue::VNUM)},\n+                {\"estimate_mode\", UniValueType(UniValue::VSTR)},\n             },\n             true, true);\n \n@@ -2730,20 +2789,25 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n         if (options.exists(\"lockUnspents\"))\n             lockUnspents = options[\"lockUnspents\"].get_bool();\n \n-        if (options.exists(\"reserveChangeKey\"))\n-            reserveChangeKey = options[\"reserveChangeKey\"].get_bool();\n-\n         if (options.exists(\"feeRate\"))\n         {\n-            coinControl.nFeeRate = CFeeRate(AmountFromValue(options[\"feeRate\"]));\n+            coinControl.m_feerate = CFeeRate(AmountFromValue(options[\"feeRate\"]));\n             coinControl.fOverrideFeeRate = true;\n         }\n \n         if (options.exists(\"subtractFeeFromOutputs\"))\n             subtractFeeFromOutputs = options[\"subtractFeeFromOutputs\"].get_array();\n \n-        if (options.exists(\"optIntoRbf\")) {\n-            coinControl.signalRbf = options[\"optIntoRbf\"].get_bool();\n+        if (options.exists(\"replaceable\")) {\n+            coinControl.signalRbf = options[\"replaceable\"].get_bool();\n+        }\n+        if (options.exists(\"conf_target\")) {\n+            coinControl.m_confirm_target = ParseConfirmTarget(options[\"conf_target\"]);\n+        }\n+        if (options.exists(\"estimate_mode\")) {\n+            if (!FeeModeFromString(options[\"estimate_mode\"].get_str(), coinControl.m_fee_mode)) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid estimate_mode parameter\");\n+            }\n         }\n       }\n     }\n@@ -2773,7 +2837,7 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     CAmount nFeeOut;\n     std::string strFailReason;\n \n-    if (!pwallet->FundTransaction(tx, nFeeOut, changePosition, strFailReason, lockUnspents, setSubtractFeeFromOutputs, coinControl, reserveChangeKey)) {\n+    if (!pwallet->FundTransaction(tx, nFeeOut, changePosition, strFailReason, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, strFailReason);\n     }\n \n@@ -2822,6 +2886,10 @@ UniValue bumpfee(const JSONRPCRequest& request)\n             \"                         so the new transaction will not be explicitly bip-125 replaceable (though it may\\n\"\n             \"                         still be replaceable in practice, for example if it has unconfirmed ancestors which\\n\"\n             \"                         are replaceable).\\n\"\n+            \"     \\\"estimate_mode\\\"     (string, optional, default=UNSET) The fee estimate mode, must be one of:\\n\"\n+            \"         \\\"UNSET\\\"\\n\"\n+            \"         \\\"ECONOMICAL\\\"\\n\"\n+            \"         \\\"CONSERVATIVE\\\"\\n\"\n             \"   }\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n@@ -2840,31 +2908,24 @@ UniValue bumpfee(const JSONRPCRequest& request)\n     hash.SetHex(request.params[0].get_str());\n \n     // optional parameters\n-    bool ignoreGlobalPayTxFee = false;\n-    int newConfirmTarget = nTxConfirmTarget;\n     CAmount totalFee = 0;\n-    bool replaceable = true;\n-    if (request.params.size() > 1) {\n+    CCoinControl coin_control;\n+    coin_control.signalRbf = true;\n+    if (!request.params[1].isNull()) {\n         UniValue options = request.params[1];\n         RPCTypeCheckObj(options,\n             {\n                 {\"confTarget\", UniValueType(UniValue::VNUM)},\n                 {\"totalFee\", UniValueType(UniValue::VNUM)},\n                 {\"replaceable\", UniValueType(UniValue::VBOOL)},\n+                {\"estimate_mode\", UniValueType(UniValue::VSTR)},\n             },\n             true, true);\n \n         if (options.exists(\"confTarget\") && options.exists(\"totalFee\")) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"confTarget and totalFee options should not both be set. Please provide either a confirmation target for fee estimation or an explicit total fee for the transaction.\");\n-        } else if (options.exists(\"confTarget\")) {\n-            // If the user has explicitly set a confTarget in this rpc call,\n-            // then override the default logic that uses the global payTxFee\n-            // instead of the confirmation target.\n-            ignoreGlobalPayTxFee = true;\n-            newConfirmTarget = options[\"confTarget\"].get_int();\n-            if (newConfirmTarget <= 0) { // upper-bound will be checked by estimatefee/smartfee\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid confTarget (cannot be <= 0)\");\n-            }\n+        } else if (options.exists(\"confTarget\")) { // TODO: alias this to conf_target\n+            coin_control.m_confirm_target = ParseConfirmTarget(options[\"confTarget\"]);\n         } else if (options.exists(\"totalFee\")) {\n             totalFee = options[\"totalFee\"].get_int64();\n             if (totalFee <= 0) {\n@@ -2873,14 +2934,19 @@ UniValue bumpfee(const JSONRPCRequest& request)\n         }\n \n         if (options.exists(\"replaceable\")) {\n-            replaceable = options[\"replaceable\"].get_bool();\n+            coin_control.signalRbf = options[\"replaceable\"].get_bool();\n+        }\n+        if (options.exists(\"estimate_mode\")) {\n+            if (!FeeModeFromString(options[\"estimate_mode\"].get_str(), coin_control.m_fee_mode)) {\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid estimate_mode parameter\");\n+            }\n         }\n     }\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n     EnsureWalletIsUnlocked(pwallet);\n \n-    CFeeBumper feeBump(pwallet, hash, newConfirmTarget, ignoreGlobalPayTxFee, totalFee, replaceable);\n+    CFeeBumper feeBump(pwallet, hash, coin_control, totalFee);\n     BumpFeeResult res = feeBump.getResult();\n     if (res != BumpFeeResult::OK)\n     {\n@@ -2923,6 +2989,51 @@ UniValue bumpfee(const JSONRPCRequest& request)\n     return result;\n }\n \n+UniValue generate(const JSONRPCRequest& request)\n+{\n+    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n+\n+    if (!EnsureWalletIsAvailable(pwallet, request.fHelp)) {\n+        return NullUniValue;\n+    }\n+\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n+        throw std::runtime_error(\n+            \"generate nblocks ( maxtries )\\n\"\n+            \"\\nMine up to nblocks blocks immediately (before the RPC call returns) to an address in the wallet.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. nblocks      (numeric, required) How many blocks are generated immediately.\\n\"\n+            \"2. maxtries     (numeric, optional) How many iterations to try (default = 1000000).\\n\"\n+            \"\\nResult:\\n\"\n+            \"[ blockhashes ]     (array) hashes of blocks generated\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nGenerate 11 blocks\\n\"\n+            + HelpExampleCli(\"generate\", \"11\")\n+        );\n+    }\n+\n+    int num_generate = request.params[0].get_int();\n+    uint64_t max_tries = 1000000;\n+    if (request.params.size() > 1 && !request.params[1].isNull()) {\n+        max_tries = request.params[1].get_int();\n+    }\n+\n+    std::shared_ptr<CReserveScript> coinbase_script;\n+    pwallet->GetScriptForMining(coinbase_script);\n+\n+    // If the keypool is exhausted, no script is returned at all.  Catch this.\n+    if (!coinbase_script) {\n+        throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n+    }\n+\n+    //throw an error if no script was provided\n+    if (coinbase_script->reserveScript.empty()) {\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"No coinbase script available\");\n+    }\n+\n+    return generateBlocks(coinbase_script, num_generate, max_tries, true);\n+}\n+\n extern UniValue abortrescan(const JSONRPCRequest& request); // in rpcdump.cpp\n extern UniValue dumpprivkey(const JSONRPCRequest& request); // in rpcdump.cpp\n extern UniValue importprivkey(const JSONRPCRequest& request);\n@@ -2977,15 +3088,17 @@ static const CRPCCommand commands[] =\n     { \"wallet\",             \"lockunspent\",              &lockunspent,              true,   {\"unlock\",\"transactions\"} },\n     { \"wallet\",             \"move\",                     &movecmd,                  false,  {\"fromaccount\",\"toaccount\",\"amount\",\"minconf\",\"comment\"} },\n     { \"wallet\",             \"sendfrom\",                 &sendfrom,                 false,  {\"fromaccount\",\"toaddress\",\"amount\",\"minconf\",\"comment\",\"comment_to\"} },\n-    { \"wallet\",             \"sendmany\",                 &sendmany,                 false,  {\"fromaccount\",\"amounts\",\"minconf\",\"comment\",\"subtractfeefrom\"} },\n-    { \"wallet\",             \"sendtoaddress\",            &sendtoaddress,            false,  {\"address\",\"amount\",\"comment\",\"comment_to\",\"subtractfeefromamount\"} },\n+    { \"wallet\",             \"sendmany\",                 &sendmany,                 false,  {\"fromaccount\",\"amounts\",\"minconf\",\"comment\",\"subtractfeefrom\",\"replaceable\",\"conf_target\",\"estimate_mode\"} },\n+    { \"wallet\",             \"sendtoaddress\",            &sendtoaddress,            false,  {\"address\",\"amount\",\"comment\",\"comment_to\",\"subtractfeefromamount\",\"replaceable\",\"conf_target\",\"estimate_mode\"} },\n     { \"wallet\",             \"setaccount\",               &setaccount,               true,   {\"address\",\"account\"} },\n     { \"wallet\",             \"settxfee\",                 &settxfee,                 true,   {\"amount\"} },\n     { \"wallet\",             \"signmessage\",              &signmessage,              true,   {\"address\",\"message\"} },\n     { \"wallet\",             \"walletlock\",               &walletlock,               true,   {} },\n     { \"wallet\",             \"walletpassphrasechange\",   &walletpassphrasechange,   true,   {\"oldpassphrase\",\"newpassphrase\"} },\n     { \"wallet\",             \"walletpassphrase\",         &walletpassphrase,         true,   {\"passphrase\",\"timeout\"} },\n     { \"wallet\",             \"removeprunedfunds\",        &removeprunedfunds,        true,   {\"txid\"} },\n+\n+    { \"generating\",         \"generate\",                 &generate,                 true,   {\"nblocks\",\"maxtries\"} },\n };\n \n void RegisterWalletRPCCommands(CRPCTable &t)"
      },
      {
        "sha": "31e2f6a69994dfabd3e06f8dc59b31bbb44f8b91",
        "filename": "src/wallet/rpcwallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/rpcwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/rpcwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -16,7 +16,7 @@ void RegisterWalletRPCCommands(CRPCTable &t);\n  * @param[in] request JSONRPCRequest that wishes to access a wallet\n  * @return NULL if no wallet should be used, or a pointer to the CWallet\n  */\n-CWallet *GetWalletForJSONRPCRequest(const JSONRPCRequest&);\n+CWallet *GetWalletForJSONRPCRequest(const JSONRPCRequest& request);\n \n std::string HelpRequiringPassphrase(CWallet *);\n void EnsureWalletIsUnlocked(CWallet *);"
      },
      {
        "sha": "330878ceb585a793a19cbeed7c0b4192cc97acbd",
        "filename": "src/wallet/test/accounting_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/test/accounting_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/test/accounting_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/accounting_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -8,7 +8,6 @@\n \n #include <stdint.h>\n \n-#include <boost/foreach.hpp>\n #include <boost/test/unit_test.hpp>\n \n extern CWallet* pwalletMain;\n@@ -23,7 +22,7 @@ GetResults(std::map<CAmount, CAccountingEntry>& results)\n     results.clear();\n     BOOST_CHECK(pwalletMain->ReorderTransactions() == DB_LOAD_OK);\n     pwalletMain->ListAccountCreditDebit(\"\", aes);\n-    BOOST_FOREACH(CAccountingEntry& ae, aes)\n+    for (CAccountingEntry& ae : aes)\n     {\n         results[ae.nOrderPos] = ae;\n     }"
      },
      {
        "sha": "922fcc8e898dd613d3a8d392f462785b26eab9e4",
        "filename": "src/wallet/test/wallet_test_fixture.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/test/wallet_test_fixture.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/test/wallet_test_fixture.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_test_fixture.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -8,6 +8,8 @@\n #include \"wallet/db.h\"\n #include \"wallet/wallet.h\"\n \n+CWallet *pwalletMain;\n+\n WalletTestingSetup::WalletTestingSetup(const std::string& chainName):\n     TestingSetup(chainName)\n {"
      },
      {
        "sha": "8176a0017c9fe6824a6be1afa0f7b5f238f709b4",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 9,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -13,12 +13,14 @@\n #include \"rpc/server.h\"\n #include \"test/test_bitcoin.h\"\n #include \"validation.h\"\n+#include \"wallet/coincontrol.h\"\n #include \"wallet/test/wallet_test_fixture.h\"\n \n-#include <boost/foreach.hpp>\n #include <boost/test/unit_test.hpp>\n #include <univalue.h>\n \n+extern CWallet* pwalletMain;\n+\n extern UniValue importmulti(const JSONRPCRequest& request);\n extern UniValue dumpwallet(const JSONRPCRequest& request);\n extern UniValue importwallet(const JSONRPCRequest& request);\n@@ -402,8 +404,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n     // after.\n     {\n         CWallet wallet;\n-        CWallet *backup = ::pwalletMain;\n-        ::pwalletMain = &wallet;\n+        vpwallets.insert(vpwallets.begin(), &wallet);\n         UniValue keys;\n         keys.setArray();\n         UniValue key;\n@@ -434,7 +435,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n                       \"downloading and rescanning the relevant blocks (see -reindex and -rescan \"\n                       \"options).\\\"}},{\\\"success\\\":true}]\",\n                               0, oldTip->GetBlockTimeMax(), TIMESTAMP_WINDOW));\n-        ::pwalletMain = backup;\n+        vpwallets.erase(vpwallets.begin());\n     }\n }\n \n@@ -444,7 +445,6 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n // than or equal to key birthday.\n BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n {\n-    CWallet *pwalletMainBackup = ::pwalletMain;\n     LOCK(cs_main);\n \n     // Create two blocks with same timestamp to verify that importwallet rescan\n@@ -470,7 +470,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n         JSONRPCRequest request;\n         request.params.setArray();\n         request.params.push_back(\"wallet.backup\");\n-        ::pwalletMain = &wallet;\n+        vpwallets.insert(vpwallets.begin(), &wallet);\n         ::dumpwallet(request);\n     }\n \n@@ -482,7 +482,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n         JSONRPCRequest request;\n         request.params.setArray();\n         request.params.push_back(\"wallet.backup\");\n-        ::pwalletMain = &wallet;\n+        vpwallets[0] = &wallet;\n         ::importwallet(request);\n \n         BOOST_CHECK_EQUAL(wallet.mapWallet.size(), 3);\n@@ -495,7 +495,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n     }\n \n     SetMockTime(0);\n-    ::pwalletMain = pwalletMainBackup;\n+    vpwallets.erase(vpwallets.begin());\n }\n \n // Check that GetImmatureCredit() returns a newly calculated value instead of\n@@ -618,7 +618,8 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         CAmount fee;\n         int changePos = -1;\n         std::string error;\n-        BOOST_CHECK(wallet->CreateTransaction({recipient}, wtx, reservekey, fee, changePos, error));\n+        CCoinControl dummy;\n+        BOOST_CHECK(wallet->CreateTransaction({recipient}, wtx, reservekey, fee, changePos, error, dummy));\n         CValidationState state;\n         BOOST_CHECK(wallet->CommitTransaction(wtx, reservekey, nullptr, state));\n         auto it = wallet->mapWallet.find(wtx.GetHash());"
      },
      {
        "sha": "223790aa40c5763f5231bb234eda785d7f48d5e4",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 468,
        "deletions": 312,
        "changes": 780,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -35,7 +35,7 @@\n #include <boost/algorithm/string/replace.hpp>\n #include <boost/thread.hpp>\n \n-CWallet* pwalletMain = NULL;\n+std::vector<CWalletRef> vpwallets;\n /** Transaction fee set by the user */\n CFeeRate payTxFee(DEFAULT_TRANSACTION_FEE);\n unsigned int nTxConfirmTarget = DEFAULT_TX_CONFIRM_TARGET;\n@@ -57,6 +57,8 @@ CFeeRate CWallet::minTxFee = CFeeRate(DEFAULT_TRANSACTION_MINFEE);\n  */\n CFeeRate CWallet::fallbackFee = CFeeRate(DEFAULT_FALLBACK_FEE);\n \n+CFeeRate CWallet::m_discard_rate = CFeeRate(DEFAULT_DISCARD_FEE);\n+\n const uint256 CMerkleTx::ABANDON_HASH(uint256S(\"0000000000000000000000000000000000000000000000000000000000000001\"));\n \n /** @defgroup mapWallet\n@@ -87,7 +89,7 @@ const CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n     return &(it->second);\n }\n \n-CPubKey CWallet::GenerateNewKey(bool internal)\n+CPubKey CWallet::GenerateNewKey(CWalletDB &walletdb, bool internal)\n {\n     AssertLockHeld(cs_wallet); // mapKeyMetadata\n     bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n@@ -100,27 +102,29 @@ CPubKey CWallet::GenerateNewKey(bool internal)\n \n     // use HD key derivation if HD was enabled during wallet creation\n     if (IsHDEnabled()) {\n-        DeriveNewChildKey(metadata, secret, (CanSupportFeature(FEATURE_HD_SPLIT) ? internal : false));\n+        DeriveNewChildKey(walletdb, metadata, secret, (CanSupportFeature(FEATURE_HD_SPLIT) ? internal : false));\n     } else {\n         secret.MakeNewKey(fCompressed);\n     }\n \n     // Compressed public keys were introduced in version 0.6.0\n-    if (fCompressed)\n+    if (fCompressed) {\n         SetMinVersion(FEATURE_COMPRPUBKEY);\n+    }\n \n     CPubKey pubkey = secret.GetPubKey();\n     assert(secret.VerifyPubKey(pubkey));\n \n     mapKeyMetadata[pubkey.GetID()] = metadata;\n     UpdateTimeFirstKey(nCreationTime);\n \n-    if (!AddKeyPubKey(secret, pubkey))\n+    if (!AddKeyPubKeyWithDB(walletdb, secret, pubkey)) {\n         throw std::runtime_error(std::string(__func__) + \": AddKey failed\");\n+    }\n     return pubkey;\n }\n \n-void CWallet::DeriveNewChildKey(CKeyMetadata& metadata, CKey& secret, bool internal)\n+void CWallet::DeriveNewChildKey(CWalletDB &walletdb, CKeyMetadata& metadata, CKey& secret, bool internal)\n {\n     // for now we use a fixed keypath scheme of m/0'/0'/k\n     CKey key;                      //master key seed (256bit)\n@@ -162,33 +166,52 @@ void CWallet::DeriveNewChildKey(CKeyMetadata& metadata, CKey& secret, bool inter\n     secret = childKey.key;\n     metadata.hdMasterKeyID = hdChain.masterKeyID;\n     // update the chain model in the database\n-    if (!CWalletDB(*dbw).WriteHDChain(hdChain))\n+    if (!walletdb.WriteHDChain(hdChain))\n         throw std::runtime_error(std::string(__func__) + \": Writing HD chain model failed\");\n }\n \n-bool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n+bool CWallet::AddKeyPubKeyWithDB(CWalletDB &walletdb, const CKey& secret, const CPubKey &pubkey)\n {\n     AssertLockHeld(cs_wallet); // mapKeyMetadata\n-    if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey))\n+\n+    // CCryptoKeyStore has no concept of wallet databases, but calls AddCryptedKey\n+    // which is overridden below.  To avoid flushes, the database handle is\n+    // tunneled through to it.\n+    bool needsDB = !pwalletdbEncryption;\n+    if (needsDB) {\n+        pwalletdbEncryption = &walletdb;\n+    }\n+    if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey)) {\n+        if (needsDB) pwalletdbEncryption = NULL;\n         return false;\n+    }\n+    if (needsDB) pwalletdbEncryption = NULL;\n \n     // check if we need to remove from watch-only\n     CScript script;\n     script = GetScriptForDestination(pubkey.GetID());\n-    if (HaveWatchOnly(script))\n+    if (HaveWatchOnly(script)) {\n         RemoveWatchOnly(script);\n+    }\n     script = GetScriptForRawPubKey(pubkey);\n-    if (HaveWatchOnly(script))\n+    if (HaveWatchOnly(script)) {\n         RemoveWatchOnly(script);\n+    }\n \n     if (!IsCrypted()) {\n-        return CWalletDB(*dbw).WriteKey(pubkey,\n+        return walletdb.WriteKey(pubkey,\n                                                  secret.GetPrivKey(),\n                                                  mapKeyMetadata[pubkey.GetID()]);\n     }\n     return true;\n }\n \n+bool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n+{\n+    CWalletDB walletdb(*dbw);\n+    return CWallet::AddKeyPubKeyWithDB(walletdb, secret, pubkey);\n+}\n+\n bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n                             const std::vector<unsigned char> &vchCryptedSecret)\n {\n@@ -205,7 +228,6 @@ bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n                                                             vchCryptedSecret,\n                                                             mapKeyMetadata[vchPubKey.GetID()]);\n     }\n-    return false;\n }\n \n bool CWallet::LoadKeyMetadata(const CTxDestination& keyID, const CKeyMetadata &meta)\n@@ -221,6 +243,10 @@ bool CWallet::LoadCryptedKey(const CPubKey &vchPubKey, const std::vector<unsigne\n     return CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret);\n }\n \n+/**\n+ * Update wallet first key creation time. This should be called whenever keys\n+ * are added to the wallet, with the oldest key creation time.\n+ */\n void CWallet::UpdateTimeFirstKey(int64_t nCreateTime)\n {\n     AssertLockHeld(cs_wallet);\n@@ -297,7 +323,7 @@ bool CWallet::Unlock(const SecureString& strWalletPassphrase)\n \n     {\n         LOCK(cs_wallet);\n-        BOOST_FOREACH(const MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n+        for (const MasterKeyMap::value_type& pMasterKey : mapMasterKeys)\n         {\n             if(!crypter.SetKeyFromPassphrase(strWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                 return false;\n@@ -320,7 +346,7 @@ bool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase,\n \n         CCrypter crypter;\n         CKeyingMaterial _vMasterKey;\n-        BOOST_FOREACH(MasterKeyMap::value_type& pMasterKey, mapMasterKeys)\n+        for (MasterKeyMap::value_type& pMasterKey : mapMasterKeys)\n         {\n             if(!crypter.SetKeyFromPassphrase(strOldWalletPassphrase, pMasterKey.second.vchSalt, pMasterKey.second.nDeriveIterations, pMasterKey.second.nDerivationMethod))\n                 return false;\n@@ -412,7 +438,7 @@ std::set<uint256> CWallet::GetConflicts(const uint256& txid) const\n \n     std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n \n-    BOOST_FOREACH(const CTxIn& txin, wtx.tx->vin)\n+    for (const CTxIn& txin : wtx.tx->vin)\n     {\n         if (mapTxSpends.count(txin.prevout) <= 1)\n             continue;  // No conflict if zero or one spends\n@@ -440,30 +466,40 @@ bool CWallet::Verify()\n     if (GetBoolArg(\"-disablewallet\", DEFAULT_DISABLE_WALLET))\n         return true;\n \n-    uiInterface.InitMessage(_(\"Verifying wallet...\"));\n-    std::string walletFile = GetArg(\"-wallet\", DEFAULT_WALLET_DAT);\n+    uiInterface.InitMessage(_(\"Verifying wallet(s)...\"));\n \n-    std::string strError;\n-    if (!CWalletDB::VerifyEnvironment(walletFile, GetDataDir().string(), strError))\n-        return InitError(strError);\n+    for (const std::string& walletFile : gArgs.GetArgs(\"-wallet\")) {\n+        if (boost::filesystem::path(walletFile).filename() != walletFile) {\n+            return InitError(_(\"-wallet parameter must only specify a filename (not a path)\"));\n+        } else if (SanitizeString(walletFile, SAFE_CHARS_FILENAME) != walletFile) {\n+            return InitError(_(\"Invalid characters in -wallet filename\"));\n+        }\n \n-    if (GetBoolArg(\"-salvagewallet\", false))\n-    {\n-        // Recover readable keypairs:\n-        CWallet dummyWallet;\n-        if (!CWalletDB::Recover(walletFile, (void *)&dummyWallet, CWalletDB::RecoverKeysOnlyFilter))\n+        std::string strError;\n+        if (!CWalletDB::VerifyEnvironment(walletFile, GetDataDir().string(), strError)) {\n+            return InitError(strError);\n+        }\n+\n+        if (GetBoolArg(\"-salvagewallet\", false)) {\n+            // Recover readable keypairs:\n+            CWallet dummyWallet;\n+            std::string backup_filename;\n+            if (!CWalletDB::Recover(walletFile, (void *)&dummyWallet, CWalletDB::RecoverKeysOnlyFilter, backup_filename)) {\n+                return false;\n+            }\n+        }\n+\n+        std::string strWarning;\n+        bool dbV = CWalletDB::VerifyDatabaseFile(walletFile, GetDataDir().string(), strWarning, strError);\n+        if (!strWarning.empty()) {\n+            InitWarning(strWarning);\n+        }\n+        if (!dbV) {\n+            InitError(strError);\n             return false;\n+        }\n     }\n \n-    std::string strWarning;\n-    bool dbV = CWalletDB::VerifyDatabaseFile(walletFile, GetDataDir().string(), strWarning, strError);\n-    if (!strWarning.empty())\n-        InitWarning(strWarning);\n-    if (!dbV)\n-    {\n-        InitError(strError);\n-        return false;\n-    }\n     return true;\n }\n \n@@ -544,7 +580,7 @@ void CWallet::AddToSpends(const uint256& wtxid)\n     if (thisTx.IsCoinBase()) // Coinbases don't spend anything!\n         return;\n \n-    BOOST_FOREACH(const CTxIn& txin, thisTx.tx->vin)\n+    for (const CTxIn& txin : thisTx.tx->vin)\n         AddToSpends(txin.prevout, wtxid);\n }\n \n@@ -659,7 +695,7 @@ DBErrors CWallet::ReorderTransactions()\n     }\n     std::list<CAccountingEntry> acentries;\n     walletdb.ListAccountCreditDebit(\"\", acentries);\n-    BOOST_FOREACH(CAccountingEntry& entry, acentries)\n+    for (CAccountingEntry& entry : acentries)\n     {\n         txByTime.insert(std::make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n     }\n@@ -689,7 +725,7 @@ DBErrors CWallet::ReorderTransactions()\n         else\n         {\n             int64_t nOrderPosOff = 0;\n-            BOOST_FOREACH(const int64_t& nOffsetStart, nOrderPosOffsets)\n+            for (const int64_t& nOffsetStart : nOrderPosOffsets)\n             {\n                 if (nOrderPos >= nOffsetStart)\n                     ++nOrderPosOff;\n@@ -778,7 +814,7 @@ bool CWallet::GetAccountPubkey(CPubKey &pubKey, std::string strAccount, bool bFo\n             for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin();\n                  it != mapWallet.end() && account.vchPubKey.IsValid();\n                  ++it)\n-                BOOST_FOREACH(const CTxOut& txout, (*it).second.tx->vout)\n+                for (const CTxOut& txout : (*it).second.tx->vout)\n                     if (txout.scriptPubKey == scriptPubKey) {\n                         bForceNew = true;\n                         break;\n@@ -804,7 +840,7 @@ void CWallet::MarkDirty()\n {\n     {\n         LOCK(cs_wallet);\n-        BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n+        for (std::pair<const uint256, CWalletTx>& item : mapWallet)\n             item.second.MarkDirty();\n     }\n }\n@@ -922,7 +958,7 @@ bool CWallet::LoadToWallet(const CWalletTx& wtxIn)\n     wtx.BindWallet(this);\n     wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, (CAccountingEntry*)0)));\n     AddToSpends(hash);\n-    BOOST_FOREACH(const CTxIn& txin, wtx.tx->vin) {\n+    for (const CTxIn& txin : wtx.tx->vin) {\n         if (mapWallet.count(txin.prevout.hash)) {\n             CWalletTx& prevtx = mapWallet[txin.prevout.hash];\n             if (prevtx.nIndex == -1 && !prevtx.hashUnset()) {\n@@ -954,7 +990,7 @@ bool CWallet::AddToWalletIfInvolvingMe(const CTransactionRef& ptx, const CBlockI\n         AssertLockHeld(cs_wallet);\n \n         if (pIndex != NULL) {\n-            BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n+            for (const CTxIn& txin : tx.vin) {\n                 std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range = mapTxSpends.equal_range(txin.prevout);\n                 while (range.first != range.second) {\n                     if (range.first->second != tx.GetHash()) {\n@@ -1035,7 +1071,7 @@ bool CWallet::AbandonTransaction(const uint256& hashTx)\n             }\n             // If a transaction changes 'conflicted' state, that changes the balance\n             // available of the outputs it spends. So force those to be recomputed\n-            BOOST_FOREACH(const CTxIn& txin, wtx.tx->vin)\n+            for (const CTxIn& txin : wtx.tx->vin)\n             {\n                 if (mapWallet.count(txin.prevout.hash))\n                     mapWallet[txin.prevout.hash].MarkDirty();\n@@ -1096,7 +1132,7 @@ void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n             }\n             // If a transaction changes 'conflicted' state, that changes the balance\n             // available of the outputs it spends. So force those to be recomputed\n-            BOOST_FOREACH(const CTxIn& txin, wtx.tx->vin)\n+            for (const CTxIn& txin : wtx.tx->vin)\n             {\n                 if (mapWallet.count(txin.prevout.hash))\n                     mapWallet[txin.prevout.hash].MarkDirty();\n@@ -1114,7 +1150,7 @@ void CWallet::SyncTransaction(const CTransactionRef& ptx, const CBlockIndex *pin\n     // If a transaction changes 'conflicted' state, that changes the balance\n     // available of the outputs it spends. So force those to be\n     // recomputed, also:\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    for (const CTxIn& txin : tx.vin)\n     {\n         if (mapWallet.count(txin.prevout.hash))\n             mapWallet[txin.prevout.hash].MarkDirty();\n@@ -1230,7 +1266,7 @@ CAmount CWallet::GetChange(const CTxOut& txout) const\n \n bool CWallet::IsMine(const CTransaction& tx) const\n {\n-    BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+    for (const CTxOut& txout : tx.vout)\n         if (IsMine(txout))\n             return true;\n     return false;\n@@ -1244,7 +1280,7 @@ bool CWallet::IsFromMe(const CTransaction& tx) const\n CAmount CWallet::GetDebit(const CTransaction& tx, const isminefilter& filter) const\n {\n     CAmount nDebit = 0;\n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    for (const CTxIn& txin : tx.vin)\n     {\n         nDebit += GetDebit(txin, filter);\n         if (!MoneyRange(nDebit))\n@@ -1257,7 +1293,7 @@ bool CWallet::IsAllFromMe(const CTransaction& tx, const isminefilter& filter) co\n {\n     LOCK(cs_wallet);\n \n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    for (const CTxIn& txin : tx.vin)\n     {\n         auto mi = mapWallet.find(txin.prevout.hash);\n         if (mi == mapWallet.end())\n@@ -1277,7 +1313,7 @@ bool CWallet::IsAllFromMe(const CTransaction& tx, const isminefilter& filter) co\n CAmount CWallet::GetCredit(const CTransaction& tx, const isminefilter& filter) const\n {\n     CAmount nCredit = 0;\n-    BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+    for (const CTxOut& txout : tx.vout)\n     {\n         nCredit += GetCredit(txout, filter);\n         if (!MoneyRange(nCredit))\n@@ -1289,7 +1325,7 @@ CAmount CWallet::GetCredit(const CTransaction& tx, const isminefilter& filter) c\n CAmount CWallet::GetChange(const CTransaction& tx) const\n {\n     CAmount nChange = 0;\n-    BOOST_FOREACH(const CTxOut& txout, tx.vout)\n+    for (const CTxOut& txout : tx.vout)\n     {\n         nChange += GetChange(txout);\n         if (!MoneyRange(nChange))\n@@ -1458,6 +1494,34 @@ void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n \n }\n \n+/**\n+ * Scan active chain for relevant transactions after importing keys. This should\n+ * be called whenever new keys are added to the wallet, with the oldest key\n+ * creation time.\n+ *\n+ * @return Earliest timestamp that could be successfully scanned from. Timestamp\n+ * returned will be higher than startTime if relevant blocks could not be read.\n+ */\n+int64_t CWallet::RescanFromTime(int64_t startTime, bool update)\n+{\n+    AssertLockHeld(cs_main);\n+    AssertLockHeld(cs_wallet);\n+\n+    // Find starting block. May be null if nCreateTime is greater than the\n+    // highest blockchain timestamp, in which case there is nothing that needs\n+    // to be scanned.\n+    CBlockIndex* const startBlock = chainActive.FindEarliestAtLeast(startTime - TIMESTAMP_WINDOW);\n+    LogPrintf(\"%s: Rescanning last %i blocks\\n\", __func__, startBlock ? chainActive.Height() - startBlock->nHeight + 1 : 0);\n+\n+    if (startBlock) {\n+        const CBlockIndex* const failedBlock = ScanForWalletTransactions(startBlock, update);\n+        if (failedBlock) {\n+            return failedBlock->GetBlockTimeMax() + TIMESTAMP_WINDOW + 1;\n+        }\n+    }\n+    return startTime;\n+}\n+\n /**\n  * Scan the block chain (starting in pindexStart) for transactions\n  * from or to us. If fUpdate is true, found transactions that already\n@@ -1479,11 +1543,6 @@ CBlockIndex* CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool f\n         fAbortRescan = false;\n         fScanningWallet = true;\n \n-        // no need to read and scan block, if block was created before\n-        // our wallet birthday (as adjusted for block time variability)\n-        while (pindex && nTimeFirstKey && (pindex->GetBlockTime() < (nTimeFirstKey - TIMESTAMP_WINDOW)))\n-            pindex = chainActive.Next(pindex);\n-\n         ShowProgress(_(\"Rescanning...\"), 0); // show rescan progress in GUI as dialog or on splashscreen, if -rescan on startup\n         double dProgressStart = GuessVerificationProgress(chainParams.TxData(), pindex);\n         double dProgressTip = GuessVerificationProgress(chainParams.TxData(), chainActive.Tip());\n@@ -1525,7 +1584,7 @@ void CWallet::ReacceptWalletTransactions()\n     std::map<int64_t, CWalletTx*> mapSorted;\n \n     // Sort pending wallet transactions based on their initial wallet insertion order\n-    BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n+    for (std::pair<const uint256, CWalletTx>& item : mapWallet)\n     {\n         const uint256& wtxid = item.first;\n         CWalletTx& wtx = item.second;\n@@ -1539,7 +1598,7 @@ void CWallet::ReacceptWalletTransactions()\n     }\n \n     // Try to add wallet transactions to memory pool\n-    BOOST_FOREACH(PAIRTYPE(const int64_t, CWalletTx*)& item, mapSorted)\n+    for (std::pair<const int64_t, CWalletTx*>& item : mapSorted)\n     {\n         CWalletTx& wtx = *(item.second);\n \n@@ -1682,7 +1741,7 @@ CAmount CWalletTx::GetAvailableCredit(bool fUseCache) const\n             const CTxOut &txout = tx->vout[i];\n             nCredit += pwallet->GetCredit(txout, ISMINE_SPENDABLE);\n             if (!MoneyRange(nCredit))\n-                throw std::runtime_error(\"CWalletTx::GetAvailableCredit() : value out of range\");\n+                throw std::runtime_error(std::string(__func__) + \" : value out of range\");\n         }\n     }\n \n@@ -1725,7 +1784,7 @@ CAmount CWalletTx::GetAvailableWatchOnlyCredit(const bool& fUseCache) const\n             const CTxOut &txout = tx->vout[i];\n             nCredit += pwallet->GetCredit(txout, ISMINE_WATCH_ONLY);\n             if (!MoneyRange(nCredit))\n-                throw std::runtime_error(\"CWalletTx::GetAvailableCredit() : value out of range\");\n+                throw std::runtime_error(std::string(__func__) + \": value out of range\");\n         }\n     }\n \n@@ -1767,7 +1826,7 @@ bool CWalletTx::IsTrusted() const\n         return false;\n \n     // Trusted if all inputs are from us and are in the mempool:\n-    BOOST_FOREACH(const CTxIn& txin, tx->vin)\n+    for (const CTxIn& txin : tx->vin)\n     {\n         // Transactions not sent by us: not trusted\n         const CWalletTx* parent = pwallet->GetWalletTx(txin.prevout.hash);\n@@ -1796,15 +1855,15 @@ std::vector<uint256> CWallet::ResendWalletTransactionsBefore(int64_t nTime, CCon\n     LOCK(cs_wallet);\n     // Sort them in chronological order\n     std::multimap<unsigned int, CWalletTx*> mapSorted;\n-    BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n+    for (std::pair<const uint256, CWalletTx>& item : mapWallet)\n     {\n         CWalletTx& wtx = item.second;\n         // Don't rebroadcast if newer than nTime:\n         if (wtx.nTimeReceived > nTime)\n             continue;\n         mapSorted.insert(std::make_pair(wtx.nTimeReceived, &wtx));\n     }\n-    BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n+    for (std::pair<const unsigned int, CWalletTx*>& item : mapSorted)\n     {\n         CWalletTx& wtx = *item.second;\n         if (wtx.RelayWalletTransaction(connman))\n@@ -2228,7 +2287,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMin\n \n     random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n \n-    BOOST_FOREACH(const COutput &output, vCoins)\n+    for (const COutput &output : vCoins)\n     {\n         if (!output.fSpendable)\n             continue;\n@@ -2328,7 +2387,7 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n     if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs)\n     {\n-        BOOST_FOREACH(const COutput& out, vCoins)\n+        for (const COutput& out : vCoins)\n         {\n             if (!out.fSpendable)\n                  continue;\n@@ -2345,7 +2404,7 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     std::vector<COutPoint> vPresetInputs;\n     if (coinControl)\n         coinControl->ListSelected(vPresetInputs);\n-    BOOST_FOREACH(const COutPoint& outpoint, vPresetInputs)\n+    for (const COutPoint& outpoint : vPresetInputs)\n     {\n         std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n         if (it != mapWallet.end())\n@@ -2414,7 +2473,7 @@ bool CWallet::SignTransaction(CMutableTransaction &tx)\n     return true;\n }\n \n-bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, std::string& strFailReason, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl coinControl, bool keepReserveKey)\n+bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, std::string& strFailReason, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl coinControl)\n {\n     std::vector<CRecipient> vecSend;\n \n@@ -2428,23 +2487,28 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC\n \n     coinControl.fAllowOtherInputs = true;\n \n-    BOOST_FOREACH(const CTxIn& txin, tx.vin)\n+    for (const CTxIn& txin : tx.vin)\n         coinControl.Select(txin.prevout);\n \n     CReserveKey reservekey(this);\n     CWalletTx wtx;\n-    if (!CreateTransaction(vecSend, wtx, reservekey, nFeeRet, nChangePosInOut, strFailReason, &coinControl, false))\n+    if (!CreateTransaction(vecSend, wtx, reservekey, nFeeRet, nChangePosInOut, strFailReason, coinControl, false)) {\n         return false;\n+    }\n \n-    if (nChangePosInOut != -1)\n+    if (nChangePosInOut != -1) {\n         tx.vout.insert(tx.vout.begin() + nChangePosInOut, wtx.tx->vout[nChangePosInOut]);\n+        // we dont have the normal Create/Commit cycle, and dont want to risk reusing change,\n+        // so just remove the key from the keypool here.\n+        reservekey.KeepKey();\n+    }\n \n     // Copy output sizes from new transaction; they may have had the fee subtracted from them\n     for (unsigned int idx = 0; idx < tx.vout.size(); idx++)\n         tx.vout[idx].nValue = wtx.tx->vout[idx].nValue;\n \n     // Add new txins (keeping original txin scriptSig/order)\n-    BOOST_FOREACH(const CTxIn& txin, wtx.tx->vin)\n+    for (const CTxIn& txin : wtx.tx->vin)\n     {\n         if (!coinControl.IsSelected(txin.prevout))\n         {\n@@ -2458,15 +2522,23 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC\n         }\n     }\n \n-    // optionally keep the change output key\n-    if (keepReserveKey)\n-        reservekey.KeepKey();\n \n     return true;\n }\n \n+static CFeeRate GetDiscardRate(const CBlockPolicyEstimator& estimator)\n+{\n+    unsigned int highest_target = estimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n+    CFeeRate discard_rate = estimator.estimateSmartFee(highest_target, nullptr /* FeeCalculation */, false /* conservative */);\n+    // Don't let discard_rate be greater than longest possible fee estimate if we get a valid fee estimate\n+    discard_rate = (discard_rate == CFeeRate(0)) ? CWallet::m_discard_rate : std::min(discard_rate, CWallet::m_discard_rate);\n+    // Discard rate must be at least dustRelayFee\n+    discard_rate = std::max(discard_rate, ::dustRelayFee);\n+    return discard_rate;\n+}\n+\n bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet,\n-                                int& nChangePosInOut, std::string& strFailReason, const CCoinControl* coinControl, bool sign)\n+                                int& nChangePosInOut, std::string& strFailReason, const CCoinControl& coin_control, bool sign)\n {\n     CAmount nValue = 0;\n     int nChangePosRequest = nChangePosInOut;\n@@ -2524,15 +2596,50 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n \n     assert(txNew.nLockTime <= (unsigned int)chainActive.Height());\n     assert(txNew.nLockTime < LOCKTIME_THRESHOLD);\n-\n+    FeeCalculation feeCalc;\n+    unsigned int nBytes;\n     {\n         std::set<CInputCoin> setCoins;\n         LOCK2(cs_main, cs_wallet);\n         {\n             std::vector<COutput> vAvailableCoins;\n-            AvailableCoins(vAvailableCoins, true, coinControl);\n+            AvailableCoins(vAvailableCoins, true, &coin_control);\n+\n+            // Create change script that will be used if we need change\n+            // TODO: pass in scriptChange instead of reservekey so\n+            // change transaction isn't always pay-to-bitcoin-address\n+            CScript scriptChange;\n+\n+            // coin control: send change to custom address\n+            if (!boost::get<CNoDestination>(&coin_control.destChange)) {\n+                scriptChange = GetScriptForDestination(coin_control.destChange);\n+            } else { // no coin control: send change to newly generated address\n+                // Note: We use a new key here to keep it from being obvious which side is the change.\n+                //  The drawback is that by not reusing a previous key, the change may be lost if a\n+                //  backup is restored, if the backup doesn't have the new private key for the change.\n+                //  If we reused the old key, it would be possible to add code to look for and\n+                //  rediscover unknown transactions that were written with keys of ours to recover\n+                //  post-backup change.\n+\n+                // Reserve a new key pair from key pool\n+                CPubKey vchPubKey;\n+                bool ret;\n+                ret = reservekey.GetReservedKey(vchPubKey, true);\n+                if (!ret)\n+                {\n+                    strFailReason = _(\"Keypool ran out, please call keypoolrefill first\");\n+                    return false;\n+                }\n+\n+                scriptChange = GetScriptForDestination(vchPubKey.GetID());\n+            }\n+            CTxOut change_prototype_txout(0, scriptChange);\n+            size_t change_prototype_size = GetSerializeSize(change_prototype_txout, SER_DISK, 0);\n \n+            CFeeRate discard_rate = GetDiscardRate(::feeEstimator);\n             nFeeRet = 0;\n+            bool pick_new_inputs = true;\n+            CAmount nValueIn = 0;\n             // Start with no fee and loop until there is enough fee\n             while (true)\n             {\n@@ -2578,80 +2685,29 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                 }\n \n                 // Choose coins to use\n-                CAmount nValueIn = 0;\n-                setCoins.clear();\n-                if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, coinControl))\n-                {\n-                    strFailReason = _(\"Insufficient funds\");\n-                    return false;\n+                if (pick_new_inputs) {\n+                    nValueIn = 0;\n+                    setCoins.clear();\n+                    if (!SelectCoins(vAvailableCoins, nValueToSelect, setCoins, nValueIn, &coin_control))\n+                    {\n+                        strFailReason = _(\"Insufficient funds\");\n+                        return false;\n+                    }\n                 }\n \n                 const CAmount nChange = nValueIn - nValueToSelect;\n+\n                 if (nChange > 0)\n                 {\n                     // Fill a vout to ourself\n-                    // TODO: pass in scriptChange instead of reservekey so\n-                    // change transaction isn't always pay-to-bitcoin-address\n-                    CScript scriptChange;\n-\n-                    // coin control: send change to custom address\n-                    if (coinControl && !boost::get<CNoDestination>(&coinControl->destChange))\n-                        scriptChange = GetScriptForDestination(coinControl->destChange);\n-\n-                    // no coin control: send change to newly generated address\n-                    else\n-                    {\n-                        // Note: We use a new key here to keep it from being obvious which side is the change.\n-                        //  The drawback is that by not reusing a previous key, the change may be lost if a\n-                        //  backup is restored, if the backup doesn't have the new private key for the change.\n-                        //  If we reused the old key, it would be possible to add code to look for and\n-                        //  rediscover unknown transactions that were written with keys of ours to recover\n-                        //  post-backup change.\n-\n-                        // Reserve a new key pair from key pool\n-                        CPubKey vchPubKey;\n-                        bool ret;\n-                        ret = reservekey.GetReservedKey(vchPubKey, true);\n-                        if (!ret)\n-                        {\n-                            strFailReason = _(\"Keypool ran out, please call keypoolrefill first\");\n-                            return false;\n-                        }\n-\n-                        scriptChange = GetScriptForDestination(vchPubKey.GetID());\n-                    }\n-\n                     CTxOut newTxOut(nChange, scriptChange);\n \n-                    // We do not move dust-change to fees, because the sender would end up paying more than requested.\n-                    // This would be against the purpose of the all-inclusive feature.\n-                    // So instead we raise the change and deduct from the recipient.\n-                    if (nSubtractFeeFromAmount > 0 && IsDust(newTxOut, ::dustRelayFee))\n-                    {\n-                        CAmount nDust = GetDustThreshold(newTxOut, ::dustRelayFee) - newTxOut.nValue;\n-                        newTxOut.nValue += nDust; // raise change until no more dust\n-                        for (unsigned int i = 0; i < vecSend.size(); i++) // subtract from first recipient\n-                        {\n-                            if (vecSend[i].fSubtractFeeFromAmount)\n-                            {\n-                                txNew.vout[i].nValue -= nDust;\n-                                if (IsDust(txNew.vout[i], ::dustRelayFee))\n-                                {\n-                                    strFailReason = _(\"The transaction amount is too small to send after the fee has been deducted\");\n-                                    return false;\n-                                }\n-                                break;\n-                            }\n-                        }\n-                    }\n-\n                     // Never create dust outputs; if we would, just\n                     // add the dust to the fee.\n-                    if (IsDust(newTxOut, ::dustRelayFee))\n+                    if (IsDust(newTxOut, discard_rate))\n                     {\n                         nChangePosInOut = -1;\n                         nFeeRet += nChange;\n-                        reservekey.ReturnKey();\n                     }\n                     else\n                     {\n@@ -2670,7 +2726,6 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                         txNew.vout.insert(position, newTxOut);\n                     }\n                 } else {\n-                    reservekey.ReturnKey();\n                     nChangePosInOut = -1;\n                 }\n \n@@ -2684,8 +2739,7 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                 // to avoid conflicting with other possible uses of nSequence,\n                 // and in the spirit of \"smallest possible change from prior\n                 // behavior.\"\n-                bool rbf = coinControl ? coinControl->signalRbf : fWalletRbf;\n-                const uint32_t nSequence = rbf ? MAX_BIP125_RBF_SEQUENCE : (std::numeric_limits<unsigned int>::max() - 1);\n+                const uint32_t nSequence = coin_control.signalRbf ? MAX_BIP125_RBF_SEQUENCE : (std::numeric_limits<unsigned int>::max() - 1);\n                 for (const auto& coin : setCoins)\n                     txNew.vin.push_back(CTxIn(coin.outpoint,CScript(),\n                                               nSequence));\n@@ -2696,24 +2750,15 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                     return false;\n                 }\n \n-                unsigned int nBytes = GetVirtualTransactionSize(txNew);\n-\n-                CTransaction txNewConst(txNew);\n+                nBytes = GetVirtualTransactionSize(txNew);\n \n                 // Remove scriptSigs to eliminate the fee calculation dummy signatures\n                 for (auto& vin : txNew.vin) {\n                     vin.scriptSig = CScript();\n                     vin.scriptWitness.SetNull();\n                 }\n \n-                // Allow to override the default confirmation target over the CoinControl instance\n-                int currentConfirmationTarget = nTxConfirmTarget;\n-                if (coinControl && coinControl->nConfirmTarget > 0)\n-                    currentConfirmationTarget = coinControl->nConfirmTarget;\n-\n-                CAmount nFeeNeeded = GetMinimumFee(nBytes, currentConfirmationTarget, ::mempool, ::feeEstimator);\n-                if (coinControl && coinControl->fOverrideFeeRate)\n-                    nFeeNeeded = coinControl->nFeeRate.GetFee(nBytes);\n+                CAmount nFeeNeeded = GetMinimumFee(nBytes, coin_control, ::mempool, ::feeEstimator, &feeCalc);\n \n                 // If we made it here and we aren't even able to meet the relay fee on the next pass, give up\n                 // because we must be at the maximum allowed fee.\n@@ -2724,16 +2769,30 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                 }\n \n                 if (nFeeRet >= nFeeNeeded) {\n-                    // Reduce fee to only the needed amount if we have change\n-                    // output to increase.  This prevents potential overpayment\n-                    // in fees if the coins selected to meet nFeeNeeded result\n-                    // in a transaction that requires less fee than the prior\n-                    // iteration.\n+                    // Reduce fee to only the needed amount if possible. This\n+                    // prevents potential overpayment in fees if the coins\n+                    // selected to meet nFeeNeeded result in a transaction that\n+                    // requires less fee than the prior iteration.\n+\n                     // TODO: The case where nSubtractFeeFromAmount > 0 remains\n                     // to be addressed because it requires returning the fee to\n                     // the payees and not the change output.\n-                    // TODO: The case where there is no change output remains\n-                    // to be addressed so we avoid creating too small an output.\n+\n+                    // If we have no change and a big enough excess fee, then\n+                    // try to construct transaction again only without picking\n+                    // new inputs. We now know we only need the smaller fee\n+                    // (because of reduced tx size) and so we should add a\n+                    // change output. Only try this once.\n+                    CAmount fee_needed_for_change = GetMinimumFee(change_prototype_size, coin_control, ::mempool, ::feeEstimator, nullptr);\n+                    CAmount minimum_value_for_change = GetDustThreshold(change_prototype_txout, discard_rate);\n+                    CAmount max_excess_fee = fee_needed_for_change + minimum_value_for_change;\n+                    if (nFeeRet > nFeeNeeded + max_excess_fee && nChangePosInOut == -1 && nSubtractFeeFromAmount == 0 && pick_new_inputs) {\n+                        pick_new_inputs = false;\n+                        nFeeRet = nFeeNeeded + fee_needed_for_change;\n+                        continue;\n+                    }\n+\n+                    // If we have change output already, just increase it\n                     if (nFeeRet > nFeeNeeded && nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n                         CAmount extraFeePaid = nFeeRet - nFeeNeeded;\n                         std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n@@ -2742,6 +2801,12 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n                     }\n                     break; // Done, enough fee included.\n                 }\n+                else if (!pick_new_inputs) {\n+                    // This shouldn't happen, we should have had enough excess\n+                    // fee to pay for the new output and still meet nFeeNeeded\n+                    strFailReason = _(\"Transaction fee and change calculation failed\");\n+                    return false;\n+                }\n \n                 // Try to reduce change to include necessary fee\n                 if (nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n@@ -2761,6 +2826,8 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n             }\n         }\n \n+        if (nChangePosInOut == -1) reservekey.ReturnKey(); // Return any reserved key if we don't have change\n+\n         if (sign)\n         {\n             CTransaction txNewConst(txNew);\n@@ -2808,6 +2875,15 @@ bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletT\n             return false;\n         }\n     }\n+\n+    LogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n+              nFeeRet, nBytes, feeCalc.returnedTarget, feeCalc.desiredTarget, StringForFeeReason(feeCalc.reason), feeCalc.est.decay,\n+              feeCalc.est.pass.start, feeCalc.est.pass.end,\n+              100 * feeCalc.est.pass.withinTarget / (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool),\n+              feeCalc.est.pass.withinTarget, feeCalc.est.pass.totalConfirmed, feeCalc.est.pass.inMempool, feeCalc.est.pass.leftMempool,\n+              feeCalc.est.fail.start, feeCalc.est.fail.end,\n+              100 * feeCalc.est.fail.withinTarget / (feeCalc.est.fail.totalConfirmed + feeCalc.est.fail.inMempool + feeCalc.est.fail.leftMempool),\n+              feeCalc.est.fail.withinTarget, feeCalc.est.fail.totalConfirmed, feeCalc.est.fail.inMempool, feeCalc.est.fail.leftMempool);\n     return true;\n }\n \n@@ -2828,7 +2904,7 @@ bool CWallet::CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey, CCon\n             AddToWallet(wtxNew);\n \n             // Notify that old coins are spent\n-            BOOST_FOREACH(const CTxIn& txin, wtxNew.tx->vin)\n+            for (const CTxIn& txin : wtxNew.tx->vin)\n             {\n                 CWalletTx &coin = mapWallet[txin.prevout.hash];\n                 coin.BindWallet(this);\n@@ -2867,8 +2943,9 @@ bool CWallet::AddAccountingEntry(const CAccountingEntry& acentry)\n \n bool CWallet::AddAccountingEntry(const CAccountingEntry& acentry, CWalletDB *pwalletdb)\n {\n-    if (!pwalletdb->WriteAccountingEntry_Backend(acentry))\n+    if (!pwalletdb->WriteAccountingEntry(++nAccountingEntryNumber, acentry)) {\n         return false;\n+    }\n \n     laccentries.push_back(acentry);\n     CAccountingEntry & entry = laccentries.back();\n@@ -2882,24 +2959,61 @@ CAmount CWallet::GetRequiredFee(unsigned int nTxBytes)\n     return std::max(minTxFee.GetFee(nTxBytes), ::minRelayTxFee.GetFee(nTxBytes));\n }\n \n-CAmount CWallet::GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, bool ignoreGlobalPayTxFee)\n-{\n-    // payTxFee is the user-set global for desired feerate\n-    CAmount nFeeNeeded = payTxFee.GetFee(nTxBytes);\n-    // User didn't set: use -txconfirmtarget to estimate...\n-    if (nFeeNeeded == 0 || ignoreGlobalPayTxFee) {\n-        int estimateFoundTarget = nConfirmTarget;\n-        nFeeNeeded = estimator.estimateSmartFee(nConfirmTarget, &estimateFoundTarget, pool).GetFee(nTxBytes);\n-        // ... unless we don't have enough mempool data for estimatefee, then use fallbackFee\n-        if (nFeeNeeded == 0)\n-            nFeeNeeded = fallbackFee.GetFee(nTxBytes);\n+CAmount CWallet::GetMinimumFee(unsigned int nTxBytes, const CCoinControl& coin_control, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, FeeCalculation *feeCalc)\n+{\n+    /* User control of how to calculate fee uses the following parameter precedence:\n+       1. coin_control.m_feerate\n+       2. coin_control.m_confirm_target\n+       3. payTxFee (user-set global variable)\n+       4. nTxConfirmTarget (user-set global variable)\n+       The first parameter that is set is used.\n+    */\n+    CAmount fee_needed;\n+    if (coin_control.m_feerate) { // 1.\n+        fee_needed = coin_control.m_feerate->GetFee(nTxBytes);\n+        if (feeCalc) feeCalc->reason = FeeReason::PAYTXFEE;\n+        // Allow to override automatic min/max check over coin control instance\n+        if (coin_control.fOverrideFeeRate) return fee_needed;\n+    }\n+    else if (!coin_control.m_confirm_target && ::payTxFee != CFeeRate(0)) { // 3. TODO: remove magic value of 0 for global payTxFee\n+        fee_needed = ::payTxFee.GetFee(nTxBytes);\n+        if (feeCalc) feeCalc->reason = FeeReason::PAYTXFEE;\n+    }\n+    else { // 2. or 4.\n+        // We will use smart fee estimation\n+        unsigned int target = coin_control.m_confirm_target ? *coin_control.m_confirm_target : ::nTxConfirmTarget;\n+        // By default estimates are economical iff we are signaling opt-in-RBF\n+        bool conservative_estimate = !coin_control.signalRbf;\n+        // Allow to override the default fee estimate mode over the CoinControl instance\n+        if (coin_control.m_fee_mode == FeeEstimateMode::CONSERVATIVE) conservative_estimate = true;\n+        else if (coin_control.m_fee_mode == FeeEstimateMode::ECONOMICAL) conservative_estimate = false;\n+\n+        fee_needed = estimator.estimateSmartFee(target, feeCalc, conservative_estimate).GetFee(nTxBytes);\n+        if (fee_needed == 0) {\n+            // if we don't have enough data for estimateSmartFee, then use fallbackFee\n+            fee_needed = fallbackFee.GetFee(nTxBytes);\n+            if (feeCalc) feeCalc->reason = FeeReason::FALLBACK;\n+        }\n+        // Obey mempool min fee when using smart fee estimation\n+        CAmount min_mempool_fee = pool.GetMinFee(GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000).GetFee(nTxBytes);\n+        if (fee_needed < min_mempool_fee) {\n+            fee_needed = min_mempool_fee;\n+            if (feeCalc) feeCalc->reason = FeeReason::MEMPOOL_MIN;\n+        }\n     }\n+\n     // prevent user from paying a fee below minRelayTxFee or minTxFee\n-    nFeeNeeded = std::max(nFeeNeeded, GetRequiredFee(nTxBytes));\n+    CAmount required_fee = GetRequiredFee(nTxBytes);\n+    if (required_fee > fee_needed) {\n+        fee_needed = required_fee;\n+        if (feeCalc) feeCalc->reason = FeeReason::REQUIRED;\n+    }\n     // But always obey the maximum\n-    if (nFeeNeeded > maxTxFee)\n-        nFeeNeeded = maxTxFee;\n-    return nFeeNeeded;\n+    if (fee_needed > maxTxFee) {\n+        fee_needed = maxTxFee;\n+        if (feeCalc) feeCalc->reason = FeeReason::MAXTXFEE;\n+    }\n+    return fee_needed;\n }\n \n \n@@ -2914,7 +3028,8 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n         if (dbw->Rewrite(\"\\x04pool\"))\n         {\n             LOCK(cs_wallet);\n-            setKeyPool.clear();\n+            setInternalKeyPool.clear();\n+            setExternalKeyPool.clear();\n             // Note: can't top-up keypool here, because wallet is locked.\n             // User will be prompted to unlock wallet the next operation\n             // that requires a new key.\n@@ -2942,7 +3057,8 @@ DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256\n     {\n         if (dbw->Rewrite(\"\\x04pool\"))\n         {\n-            setKeyPool.clear();\n+            setInternalKeyPool.clear();\n+            setExternalKeyPool.clear();\n             // Note: can't top-up keypool here, because wallet is locked.\n             // User will be prompted to unlock wallet the next operation\n             // that requires a new key.\n@@ -2967,7 +3083,8 @@ DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n         if (dbw->Rewrite(\"\\x04pool\"))\n         {\n             LOCK(cs_wallet);\n-            setKeyPool.clear();\n+            setInternalKeyPool.clear();\n+            setExternalKeyPool.clear();\n             // Note: can't top-up keypool here, because wallet is locked.\n             // User will be prompted to unlock wallet the next operation\n             // that requires a new key.\n@@ -3006,7 +3123,7 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n \n         // Delete destdata tuples associated with address\n         std::string strAddress = CBitcoinAddress(address).ToString();\n-        BOOST_FOREACH(const PAIRTYPE(std::string, std::string) &item, mapAddressBook[address].destdata)\n+        for (const std::pair<std::string, std::string> &item : mapAddressBook[address].destdata)\n         {\n             CWalletDB(*dbw).EraseDestData(strAddress, item.first);\n         }\n@@ -3051,9 +3168,16 @@ bool CWallet::NewKeyPool()\n     {\n         LOCK(cs_wallet);\n         CWalletDB walletdb(*dbw);\n-        BOOST_FOREACH(int64_t nIndex, setKeyPool)\n+\n+        for (int64_t nIndex : setInternalKeyPool) {\n+            walletdb.ErasePool(nIndex);\n+        }\n+        setInternalKeyPool.clear();\n+\n+        for (int64_t nIndex : setExternalKeyPool) {\n             walletdb.ErasePool(nIndex);\n-        setKeyPool.clear();\n+        }\n+        setExternalKeyPool.clear();\n \n         if (!TopUpKeyPool()) {\n             return false;\n@@ -3065,25 +3189,8 @@ bool CWallet::NewKeyPool()\n \n size_t CWallet::KeypoolCountExternalKeys()\n {\n-    AssertLockHeld(cs_wallet); // setKeyPool\n-\n-    // immediately return setKeyPool's size if HD or HD_SPLIT is disabled or not supported\n-    if (!IsHDEnabled() || !CanSupportFeature(FEATURE_HD_SPLIT))\n-        return setKeyPool.size();\n-\n-    CWalletDB walletdb(*dbw);\n-\n-    // count amount of external keys\n-    size_t amountE = 0;\n-    for(const int64_t& id : setKeyPool)\n-    {\n-        CKeyPool tmpKeypool;\n-        if (!walletdb.ReadPool(id, tmpKeypool))\n-            throw std::runtime_error(std::string(__func__) + \": read failed\");\n-        amountE += !tmpKeypool.fInternal;\n-    }\n-\n-    return amountE;\n+    AssertLockHeld(cs_wallet); // setExternalKeyPool\n+    return setExternalKeyPool.size();\n }\n \n bool CWallet::TopUpKeyPool(unsigned int kpSize)\n@@ -3103,10 +3210,8 @@ bool CWallet::TopUpKeyPool(unsigned int kpSize)\n \n         // count amount of available keys (internal, external)\n         // make sure the keypool of external and internal keys fits the user selected target (-keypool)\n-        int64_t amountExternal = KeypoolCountExternalKeys();\n-        int64_t amountInternal = setKeyPool.size() - amountExternal;\n-        int64_t missingExternal = std::max(std::max((int64_t) nTargetSize, (int64_t) 1) - amountExternal, (int64_t) 0);\n-        int64_t missingInternal = std::max(std::max((int64_t) nTargetSize, (int64_t) 1) - amountInternal, (int64_t) 0);\n+        int64_t missingExternal = std::max(std::max((int64_t) nTargetSize, (int64_t) 1) - (int64_t)setExternalKeyPool.size(), (int64_t) 0);\n+        int64_t missingInternal = std::max(std::max((int64_t) nTargetSize, (int64_t) 1) - (int64_t)setInternalKeyPool.size(), (int64_t) 0);\n \n         if (!IsHDEnabled() || !CanSupportFeature(FEATURE_HD_SPLIT))\n         {\n@@ -3117,21 +3222,31 @@ bool CWallet::TopUpKeyPool(unsigned int kpSize)\n         CWalletDB walletdb(*dbw);\n         for (int64_t i = missingInternal + missingExternal; i--;)\n         {\n-            int64_t nEnd = 1;\n-            if (i < missingInternal)\n+            if (i < missingInternal) {\n                 internal = true;\n-            if (!setKeyPool.empty())\n-                nEnd = *(--setKeyPool.end()) + 1;\n-            if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey(internal), internal)))\n+            }\n+\n+            assert(m_max_keypool_index < std::numeric_limits<int64_t>::max()); // How in the hell did you use so many keys?\n+            int64_t index = ++m_max_keypool_index;\n+\n+            if (!walletdb.WritePool(index, CKeyPool(GenerateNewKey(walletdb, internal), internal))) {\n                 throw std::runtime_error(std::string(__func__) + \": writing generated key failed\");\n-            setKeyPool.insert(nEnd);\n-            LogPrintf(\"keypool added key %d, size=%u, internal=%d\\n\", nEnd, setKeyPool.size(), internal);\n+            }\n+\n+            if (internal) {\n+                setInternalKeyPool.insert(index);\n+            } else {\n+                setExternalKeyPool.insert(index);\n+            }\n+        }\n+        if (missingInternal + missingExternal > 0) {\n+            LogPrintf(\"keypool added %d keys (%d internal), size=%u (%u internal)\\n\", missingInternal + missingExternal, missingInternal, setInternalKeyPool.size() + setExternalKeyPool.size(), setInternalKeyPool.size());\n         }\n     }\n     return true;\n }\n \n-void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool internal)\n+void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRequestedInternal)\n {\n     nIndex = -1;\n     keypool.vchPubKey = CPubKey();\n@@ -3141,30 +3256,30 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool int\n         if (!IsLocked())\n             TopUpKeyPool();\n \n+        bool fReturningInternal = IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT) && fRequestedInternal;\n+        std::set<int64_t>& setKeyPool = fReturningInternal ? setInternalKeyPool : setExternalKeyPool;\n+\n         // Get the oldest key\n         if(setKeyPool.empty())\n             return;\n \n         CWalletDB walletdb(*dbw);\n \n-        // try to find a key that matches the internal/external filter\n-        for(const int64_t& id : setKeyPool)\n-        {\n-            CKeyPool tmpKeypool;\n-            if (!walletdb.ReadPool(id, tmpKeypool))\n-                throw std::runtime_error(std::string(__func__) + \": read failed\");\n-            if (!HaveKey(tmpKeypool.vchPubKey.GetID()))\n-                throw std::runtime_error(std::string(__func__) + \": unknown key in key pool\");\n-            if (!IsHDEnabled() || !CanSupportFeature(FEATURE_HD_SPLIT) || tmpKeypool.fInternal == internal)\n-            {\n-                nIndex = id;\n-                keypool = tmpKeypool;\n-                setKeyPool.erase(id);\n-                assert(keypool.vchPubKey.IsValid());\n-                LogPrintf(\"keypool reserve %d\\n\", nIndex);\n-                return;\n-            }\n+        auto it = setKeyPool.begin();\n+        nIndex = *it;\n+        setKeyPool.erase(it);\n+        if (!walletdb.ReadPool(nIndex, keypool)) {\n+            throw std::runtime_error(std::string(__func__) + \": read failed\");\n         }\n+        if (!HaveKey(keypool.vchPubKey.GetID())) {\n+            throw std::runtime_error(std::string(__func__) + \": unknown key in key pool\");\n+        }\n+        if (keypool.fInternal != fReturningInternal) {\n+            throw std::runtime_error(std::string(__func__) + \": keypool entry misclassified\");\n+        }\n+\n+        assert(keypool.vchPubKey.IsValid());\n+        LogPrintf(\"keypool reserve %d\\n\", nIndex);\n     }\n }\n \n@@ -3176,27 +3291,32 @@ void CWallet::KeepKey(int64_t nIndex)\n     LogPrintf(\"keypool keep %d\\n\", nIndex);\n }\n \n-void CWallet::ReturnKey(int64_t nIndex)\n+void CWallet::ReturnKey(int64_t nIndex, bool fInternal)\n {\n     // Return to key pool\n     {\n         LOCK(cs_wallet);\n-        setKeyPool.insert(nIndex);\n+        if (fInternal) {\n+            setInternalKeyPool.insert(nIndex);\n+        } else {\n+            setExternalKeyPool.insert(nIndex);\n+        }\n     }\n     LogPrintf(\"keypool return %d\\n\", nIndex);\n }\n \n bool CWallet::GetKeyFromPool(CPubKey& result, bool internal)\n {\n-    int64_t nIndex = 0;\n     CKeyPool keypool;\n     {\n         LOCK(cs_wallet);\n+        int64_t nIndex = 0;\n         ReserveKeyFromKeyPool(nIndex, keypool, internal);\n         if (nIndex == -1)\n         {\n             if (IsLocked()) return false;\n-            result = GenerateNewKey(internal);\n+            CWalletDB walletdb(*dbw);\n+            result = GenerateNewKey(walletdb, internal);\n             return true;\n         }\n         KeepKey(nIndex);\n@@ -3205,48 +3325,35 @@ bool CWallet::GetKeyFromPool(CPubKey& result, bool internal)\n     return true;\n }\n \n-int64_t CWallet::GetOldestKeyPoolTime()\n-{\n-    LOCK(cs_wallet);\n-\n-    // if the keypool is empty, return <NOW>\n-    if (setKeyPool.empty())\n+static int64_t GetOldestKeyTimeInPool(const std::set<int64_t>& setKeyPool, CWalletDB& walletdb) {\n+    if (setKeyPool.empty()) {\n         return GetTime();\n+    }\n \n     CKeyPool keypool;\n-    CWalletDB walletdb(*dbw);\n-\n-    if (IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT))\n-    {\n-        // if HD & HD Chain Split is enabled, response max(oldest-internal-key, oldest-external-key)\n-        int64_t now = GetTime();\n-        int64_t oldest_external = now, oldest_internal = now;\n-\n-        for(const int64_t& id : setKeyPool)\n-        {\n-            if (!walletdb.ReadPool(id, keypool)) {\n-                throw std::runtime_error(std::string(__func__) + \": read failed\");\n-            }\n-            if (keypool.fInternal && keypool.nTime < oldest_internal) {\n-                oldest_internal = keypool.nTime;\n-            }\n-            else if (!keypool.fInternal && keypool.nTime < oldest_external) {\n-                oldest_external = keypool.nTime;\n-            }\n-            if (oldest_internal != now && oldest_external != now) {\n-                break;\n-            }\n-        }\n-        return std::max(oldest_internal, oldest_external);\n-    }\n-    // load oldest key from keypool, get time and return\n     int64_t nIndex = *(setKeyPool.begin());\n-    if (!walletdb.ReadPool(nIndex, keypool))\n+    if (!walletdb.ReadPool(nIndex, keypool)) {\n         throw std::runtime_error(std::string(__func__) + \": read oldest key in keypool failed\");\n+    }\n     assert(keypool.vchPubKey.IsValid());\n     return keypool.nTime;\n }\n \n+int64_t CWallet::GetOldestKeyPoolTime()\n+{\n+    LOCK(cs_wallet);\n+\n+    CWalletDB walletdb(*dbw);\n+\n+    // load oldest key from keypool, get time and return\n+    int64_t oldestKey = GetOldestKeyTimeInPool(setExternalKeyPool, walletdb);\n+    if (IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT)) {\n+        oldestKey = std::max(GetOldestKeyTimeInPool(setInternalKeyPool, walletdb), oldestKey);\n+    }\n+\n+    return oldestKey;\n+}\n+\n std::map<CTxDestination, CAmount> CWallet::GetAddressBalances()\n {\n     std::map<CTxDestination, CAmount> balances;\n@@ -3301,7 +3408,7 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n         {\n             bool any_mine = false;\n             // group all input addresses with each other\n-            BOOST_FOREACH(CTxIn txin, pcoin->tx->vin)\n+            for (CTxIn txin : pcoin->tx->vin)\n             {\n                 CTxDestination address;\n                 if(!IsMine(txin)) /* If this input isn't mine, ignore it */\n@@ -3315,7 +3422,7 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n             // group change with input addresses\n             if (any_mine)\n             {\n-               BOOST_FOREACH(CTxOut txout, pcoin->tx->vout)\n+               for (CTxOut txout : pcoin->tx->vout)\n                    if (IsChange(txout))\n                    {\n                        CTxDestination txoutAddr;\n@@ -3346,18 +3453,18 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n \n     std::set< std::set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n     std::map< CTxDestination, std::set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n-    BOOST_FOREACH(std::set<CTxDestination> _grouping, groupings)\n+    for (std::set<CTxDestination> _grouping : groupings)\n     {\n         // make a set of all the groups hit by this new group\n         std::set< std::set<CTxDestination>* > hits;\n         std::map< CTxDestination, std::set<CTxDestination>* >::iterator it;\n-        BOOST_FOREACH(CTxDestination address, _grouping)\n+        for (CTxDestination address : _grouping)\n             if ((it = setmap.find(address)) != setmap.end())\n                 hits.insert((*it).second);\n \n         // merge all hit groups into a new single group and delete old groups\n         std::set<CTxDestination>* merged = new std::set<CTxDestination>(_grouping);\n-        BOOST_FOREACH(std::set<CTxDestination>* hit, hits)\n+        for (std::set<CTxDestination>* hit : hits)\n         {\n             merged->insert(hit->begin(), hit->end());\n             uniqueGroupings.erase(hit);\n@@ -3366,12 +3473,12 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n         uniqueGroupings.insert(merged);\n \n         // update setmap\n-        BOOST_FOREACH(CTxDestination element, *merged)\n+        for (CTxDestination element : *merged)\n             setmap[element] = merged;\n     }\n \n     std::set< std::set<CTxDestination> > ret;\n-    BOOST_FOREACH(std::set<CTxDestination>* uniqueGrouping, uniqueGroupings)\n+    for (std::set<CTxDestination>* uniqueGrouping : uniqueGroupings)\n     {\n         ret.insert(*uniqueGrouping);\n         delete uniqueGrouping;\n@@ -3384,7 +3491,7 @@ std::set<CTxDestination> CWallet::GetAccountAddresses(const std::string& strAcco\n {\n     LOCK(cs_wallet);\n     std::set<CTxDestination> result;\n-    BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& item, mapAddressBook)\n+    for (const std::pair<CTxDestination, CAddressBookData>& item : mapAddressBook)\n     {\n         const CTxDestination& address = item.first;\n         const std::string& strName = item.second.name;\n@@ -3405,6 +3512,7 @@ bool CReserveKey::GetReservedKey(CPubKey& pubkey, bool internal)\n         else {\n             return false;\n         }\n+        fInternal = keypool.fInternal;\n     }\n     assert(vchPubKey.IsValid());\n     pubkey = vchPubKey;\n@@ -3421,29 +3529,39 @@ void CReserveKey::KeepKey()\n \n void CReserveKey::ReturnKey()\n {\n-    if (nIndex != -1)\n-        pwallet->ReturnKey(nIndex);\n+    if (nIndex != -1) {\n+        pwallet->ReturnKey(nIndex, fInternal);\n+    }\n     nIndex = -1;\n     vchPubKey = CPubKey();\n }\n \n+static void LoadReserveKeysToSet(std::set<CKeyID>& setAddress, const std::set<int64_t>& setKeyPool, CWalletDB& walletdb) {\n+    for (const int64_t& id : setKeyPool)\n+    {\n+        CKeyPool keypool;\n+        if (!walletdb.ReadPool(id, keypool))\n+            throw std::runtime_error(std::string(__func__) + \": read failed\");\n+        assert(keypool.vchPubKey.IsValid());\n+        CKeyID keyID = keypool.vchPubKey.GetID();\n+        setAddress.insert(keyID);\n+    }\n+}\n+\n void CWallet::GetAllReserveKeys(std::set<CKeyID>& setAddress) const\n {\n     setAddress.clear();\n \n     CWalletDB walletdb(*dbw);\n \n     LOCK2(cs_main, cs_wallet);\n-    BOOST_FOREACH(const int64_t& id, setKeyPool)\n-    {\n-        CKeyPool keypool;\n-        if (!walletdb.ReadPool(id, keypool))\n-            throw std::runtime_error(std::string(__func__) + \": read failed\");\n-        assert(keypool.vchPubKey.IsValid());\n-        CKeyID keyID = keypool.vchPubKey.GetID();\n-        if (!HaveKey(keyID))\n+    LoadReserveKeysToSet(setAddress, setInternalKeyPool, walletdb);\n+    LoadReserveKeysToSet(setAddress, setExternalKeyPool, walletdb);\n+\n+    for (const CKeyID& keyID : setAddress) {\n+        if (!HaveKey(keyID)) {\n             throw std::runtime_error(std::string(__func__) + \": unknown key in key pool\");\n-        setAddress.insert(keyID);\n+        }\n     }\n }\n \n@@ -3509,7 +3627,7 @@ class CAffectedKeysVisitor : public boost::static_visitor<void> {\n         std::vector<CTxDestination> vDest;\n         int nRequired;\n         if (ExtractDestinations(script, type, vDest, nRequired)) {\n-            BOOST_FOREACH(const CTxDestination &dest, vDest)\n+            for (const CTxDestination &dest : vDest)\n                 boost::apply_visitor(*this, dest);\n         }\n     }\n@@ -3544,7 +3662,7 @@ void CWallet::GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) c\n     std::map<CKeyID, CBlockIndex*> mapKeyFirstBlock;\n     std::set<CKeyID> setKeys;\n     GetKeys(setKeys);\n-    BOOST_FOREACH(const CKeyID &keyid, setKeys) {\n+    for (const CKeyID &keyid : setKeys) {\n         if (mapKeyBirth.count(keyid) == 0)\n             mapKeyFirstBlock[keyid] = pindexMax;\n     }\n@@ -3563,10 +3681,10 @@ void CWallet::GetKeyBirthTimes(std::map<CTxDestination, int64_t> &mapKeyBirth) c\n         if (blit != mapBlockIndex.end() && chainActive.Contains(blit->second)) {\n             // ... which are already in a block\n             int nHeight = blit->second->nHeight;\n-            BOOST_FOREACH(const CTxOut &txout, wtx.tx->vout) {\n+            for (const CTxOut &txout : wtx.tx->vout) {\n                 // iterate over all their outputs\n                 CAffectedKeysVisitor(*this, vAffected).Process(txout.scriptPubKey);\n-                BOOST_FOREACH(const CKeyID &keyid, vAffected) {\n+                for (const CKeyID &keyid : vAffected) {\n                     // ... and all their affected keys\n                     std::map<CKeyID, CBlockIndex*>::iterator rit = mapKeyFirstBlock.find(keyid);\n                     if (rit != mapKeyFirstBlock.end() && nHeight < rit->second->nHeight)\n@@ -3706,6 +3824,9 @@ std::string CWallet::GetWalletHelpString(bool showDebug)\n     strUsage += HelpMessageOpt(\"-keypool=<n>\", strprintf(_(\"Set key pool size to <n> (default: %u)\"), DEFAULT_KEYPOOL_SIZE));\n     strUsage += HelpMessageOpt(\"-fallbackfee=<amt>\", strprintf(_(\"A fee rate (in %s/kB) that will be used when fee estimation has insufficient data (default: %s)\"),\n                                                                CURRENCY_UNIT, FormatMoney(DEFAULT_FALLBACK_FEE)));\n+    strUsage += HelpMessageOpt(\"-discardfee=<amt>\", strprintf(_(\"The fee rate (in %s/kB) used to discard change (to fee) if it would be dust at this fee rate (default: %s) \"\n+                                                                \"Note: We will always discard up to the dust relay fee and a discard fee above that is limited by the longest target fee estimate\"),\n+                                                              CURRENCY_UNIT, FormatMoney(DEFAULT_DISCARD_FEE)));\n     strUsage += HelpMessageOpt(\"-mintxfee=<amt>\", strprintf(_(\"Fees (in %s/kB) smaller than this are considered zero fee for transaction creation (default: %s)\"),\n                                                             CURRENCY_UNIT, FormatMoney(DEFAULT_TRANSACTION_MINFEE)));\n     strUsage += HelpMessageOpt(\"-paytxfee=<amt>\", strprintf(_(\"Fee (in %s/kB) to add to transactions you send (default: %s)\"),\n@@ -3836,11 +3957,11 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n     else if (IsArgSet(\"-usehd\")) {\n         bool useHD = GetBoolArg(\"-usehd\", DEFAULT_USE_HD_WALLET);\n         if (walletInstance->IsHDEnabled() && !useHD) {\n-            InitError(strprintf(_(\"Error loading %s: You can't disable HD on a already existing HD wallet\"), walletFile));\n+            InitError(strprintf(_(\"Error loading %s: You can't disable HD on an already existing HD wallet\"), walletFile));\n             return NULL;\n         }\n         if (!walletInstance->IsHDEnabled() && useHD) {\n-            InitError(strprintf(_(\"Error loading %s: You can't enable HD on a already existing non-HD wallet\"), walletFile));\n+            InitError(strprintf(_(\"Error loading %s: You can't enable HD on an already existing non-HD wallet\"), walletFile));\n             return NULL;\n         }\n     }\n@@ -3860,7 +3981,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n     if (chainActive.Tip() && chainActive.Tip() != pindexRescan)\n     {\n         //We can't rescan beyond non-pruned blocks, stop and throw an error\n-        //this might happen if a user uses a old wallet within a pruned node\n+        //this might happen if a user uses an old wallet within a pruned node\n         // or if he ran -disablewallet for a longer time, then decided to re-enable\n         if (fPruneMode)\n         {\n@@ -3876,18 +3997,25 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n \n         uiInterface.InitMessage(_(\"Rescanning...\"));\n         LogPrintf(\"Rescanning last %i blocks (from block %i)...\\n\", chainActive.Height() - pindexRescan->nHeight, pindexRescan->nHeight);\n+\n+        // No need to read and scan block if block was created before\n+        // our wallet birthday (as adjusted for block time variability)\n+        while (pindexRescan && walletInstance->nTimeFirstKey && (pindexRescan->GetBlockTime() < (walletInstance->nTimeFirstKey - TIMESTAMP_WINDOW))) {\n+            pindexRescan = chainActive.Next(pindexRescan);\n+        }\n+\n         nStart = GetTimeMillis();\n         walletInstance->ScanForWalletTransactions(pindexRescan, true);\n         LogPrintf(\" rescan      %15dms\\n\", GetTimeMillis() - nStart);\n         walletInstance->SetBestChain(chainActive.GetLocator());\n-        CWalletDB::IncrementUpdateCounter();\n+        walletInstance->dbw->IncrementUpdateCounter();\n \n         // Restore wallet transaction metadata after -zapwallettxes=1\n         if (GetBoolArg(\"-zapwallettxes\", false) && GetArg(\"-zapwallettxes\", \"1\") != \"2\")\n         {\n             CWalletDB walletdb(*walletInstance->dbw);\n \n-            BOOST_FOREACH(const CWalletTx& wtxOld, vWtx)\n+            for (const CWalletTx& wtxOld : vWtx)\n             {\n                 uint256 hash = wtxOld.GetHash();\n                 std::map<uint256, CWalletTx>::iterator mi = walletInstance->mapWallet.find(hash);\n@@ -3922,24 +4050,17 @@ CWallet* CWallet::CreateWalletFromFile(const std::string walletFile)\n bool CWallet::InitLoadWallet()\n {\n     if (GetBoolArg(\"-disablewallet\", DEFAULT_DISABLE_WALLET)) {\n-        pwalletMain = NULL;\n         LogPrintf(\"Wallet disabled!\\n\");\n         return true;\n     }\n \n-    std::string walletFile = GetArg(\"-wallet\", DEFAULT_WALLET_DAT);\n-\n-    if (boost::filesystem::path(walletFile).filename() != walletFile) {\n-        return InitError(_(\"-wallet parameter must only specify a filename (not a path)\"));\n-    } else if (SanitizeString(walletFile, SAFE_CHARS_FILENAME) != walletFile) {\n-        return InitError(_(\"Invalid characters in -wallet filename\"));\n-    }\n-\n-    CWallet * const pwallet = CreateWalletFromFile(walletFile);\n-    if (!pwallet) {\n-        return false;\n+    for (const std::string& walletFile : gArgs.GetArgs(\"-wallet\")) {\n+        CWallet * const pwallet = CreateWalletFromFile(walletFile);\n+        if (!pwallet) {\n+            return false;\n+        }\n+        vpwallets.push_back(pwallet);\n     }\n-    pwalletMain = pwallet;\n \n     return true;\n }\n@@ -3960,21 +4081,46 @@ void CWallet::postInitProcess(CScheduler& scheduler)\n \n bool CWallet::ParameterInteraction()\n {\n+    SoftSetArg(\"-wallet\", DEFAULT_WALLET_DAT);\n+    const bool is_multiwallet = gArgs.GetArgs(\"-wallet\").size() > 1;\n+\n     if (GetBoolArg(\"-disablewallet\", DEFAULT_DISABLE_WALLET))\n         return true;\n \n     if (GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY) && SoftSetBoolArg(\"-walletbroadcast\", false)) {\n         LogPrintf(\"%s: parameter interaction: -blocksonly=1 -> setting -walletbroadcast=0\\n\", __func__);\n     }\n \n-    if (GetBoolArg(\"-salvagewallet\", false) && SoftSetBoolArg(\"-rescan\", true)) {\n+    if (GetBoolArg(\"-salvagewallet\", false)) {\n+        if (is_multiwallet) {\n+            return InitError(strprintf(\"%s is only allowed with a single wallet file\", \"-salvagewallet\"));\n+        }\n         // Rewrite just private keys: rescan to find transactions\n-        LogPrintf(\"%s: parameter interaction: -salvagewallet=1 -> setting -rescan=1\\n\", __func__);\n+        if (SoftSetBoolArg(\"-rescan\", true)) {\n+            LogPrintf(\"%s: parameter interaction: -salvagewallet=1 -> setting -rescan=1\\n\", __func__);\n+        }\n+    }\n+\n+    int zapwallettxes = GetArg(\"-zapwallettxes\", 0);\n+    // -zapwallettxes implies dropping the mempool on startup\n+    if (zapwallettxes != 0 && SoftSetBoolArg(\"-persistmempool\", false)) {\n+        LogPrintf(\"%s: parameter interaction: -zapwallettxes=%s -> setting -persistmempool=0\\n\", __func__, zapwallettxes);\n+    }\n+\n+    // -zapwallettxes implies a rescan\n+    if (zapwallettxes != 0) {\n+        if (is_multiwallet) {\n+            return InitError(strprintf(\"%s is only allowed with a single wallet file\", \"-zapwallettxes\"));\n+        }\n+        if (SoftSetBoolArg(\"-rescan\", true)) {\n+            LogPrintf(\"%s: parameter interaction: -zapwallettxes=%s -> setting -rescan=1\\n\", __func__, zapwallettxes);\n+        }\n     }\n \n-    // -zapwallettx implies a rescan\n-    if (GetBoolArg(\"-zapwallettxes\", false) && SoftSetBoolArg(\"-rescan\", true)) {\n-        LogPrintf(\"%s: parameter interaction: -zapwallettxes=<mode> -> setting -rescan=1\\n\", __func__);\n+    if (is_multiwallet) {\n+        if (GetBoolArg(\"-upgradewallet\", false)) {\n+            return InitError(strprintf(\"%s is only allowed with a single wallet file\", \"-upgradewallet\"));\n+        }\n     }\n \n     if (GetBoolArg(\"-sysperms\", false))\n@@ -4006,6 +4152,16 @@ bool CWallet::ParameterInteraction()\n                         _(\"This is the transaction fee you may pay when fee estimates are not available.\"));\n         CWallet::fallbackFee = CFeeRate(nFeePerK);\n     }\n+    if (IsArgSet(\"-discardfee\"))\n+    {\n+        CAmount nFeePerK = 0;\n+        if (!ParseMoney(GetArg(\"-discardfee\", \"\"), nFeePerK))\n+            return InitError(strprintf(_(\"Invalid amount for -discardfee=<amount>: '%s'\"), GetArg(\"-discardfee\", \"\")));\n+        if (nFeePerK > HIGH_TX_FEE_PER_KB)\n+            InitWarning(AmountHighWarn(\"-discardfee\") + \" \" +\n+                        _(\"This is the transaction fee you may discard if change is smaller than dust at this level\"));\n+        CWallet::m_discard_rate = CFeeRate(nFeePerK);\n+    }\n     if (IsArgSet(\"-paytxfee\"))\n     {\n         CAmount nFeePerK = 0;"
      },
      {
        "sha": "bcd7e4b4eed28bab3cef990c962b7960b6f16339",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 39,
        "deletions": 16,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -29,7 +29,8 @@\n #include <utility>\n #include <vector>\n \n-extern CWallet* pwalletMain;\n+typedef CWallet* CWalletRef;\n+extern std::vector<CWalletRef> vpwallets;\n \n /**\n  * Settings\n@@ -39,11 +40,13 @@ extern unsigned int nTxConfirmTarget;\n extern bool bSpendZeroConfChange;\n extern bool fWalletRbf;\n \n-static const unsigned int DEFAULT_KEYPOOL_SIZE = 100;\n+static const unsigned int DEFAULT_KEYPOOL_SIZE = 1000;\n //! -paytxfee default\n static const CAmount DEFAULT_TRANSACTION_FEE = 0;\n //! -fallbackfee default\n static const CAmount DEFAULT_FALLBACK_FEE = 20000;\n+//! -m_discard_rate default\n+static const CAmount DEFAULT_DISCARD_FEE = 10000;\n //! -mintxfee default\n static const CAmount DEFAULT_TRANSACTION_MINFEE = 1000;\n //! minimum recommended increment for BIP 125 replacement txs\n@@ -67,6 +70,8 @@ static const bool DEFAULT_USE_HD_WALLET = true;\n \n extern const char * DEFAULT_WALLET_DAT;\n \n+static const int64_t TIMESTAMP_MIN = 0;\n+\n class CBlockIndex;\n class CCoinControl;\n class COutput;\n@@ -76,6 +81,8 @@ class CScheduler;\n class CTxMemPool;\n class CBlockPolicyEstimator;\n class CWalletTx;\n+struct FeeCalculation;\n+enum class FeeEstimateMode;\n \n /** (client) version numbers for particular wallet features */\n enum WalletFeature\n@@ -692,9 +699,11 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     CHDChain hdChain;\n \n     /* HD derive new child key (on internal or external chain) */\n-    void DeriveNewChildKey(CKeyMetadata& metadata, CKey& secret, bool internal = false);\n+    void DeriveNewChildKey(CWalletDB &walletdb, CKeyMetadata& metadata, CKey& secret, bool internal = false);\n \n-    std::set<int64_t> setKeyPool;\n+    std::set<int64_t> setInternalKeyPool;\n+    std::set<int64_t> setExternalKeyPool;\n+    int64_t m_max_keypool_index;\n \n     int64_t nTimeFirstKey;\n \n@@ -737,9 +746,14 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n         }\n     }\n \n-    void LoadKeyPool(int nIndex, const CKeyPool &keypool)\n+    void LoadKeyPool(int64_t nIndex, const CKeyPool &keypool)\n     {\n-        setKeyPool.insert(nIndex);\n+        if (keypool.fInternal) {\n+            setInternalKeyPool.insert(nIndex);\n+        } else {\n+            setExternalKeyPool.insert(nIndex);\n+        }\n+        m_max_keypool_index = std::max(m_max_keypool_index, nIndex);\n \n         // If no metadata exists yet, create a default with the pool key's\n         // creation time. Note that this may be overwritten by actually\n@@ -782,8 +796,10 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n         nMasterKeyMaxID = 0;\n         pwalletdbEncryption = NULL;\n         nOrderPosNext = 0;\n+        nAccountingEntryNumber = 0;\n         nNextResend = 0;\n         nLastResend = 0;\n+        m_max_keypool_index = 0;\n         nTimeFirstKey = 0;\n         fBroadcastTransactions = false;\n         nRelockTime = 0;\n@@ -799,6 +815,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     TxItems wtxOrdered;\n \n     int64_t nOrderPosNext;\n+    uint64_t nAccountingEntryNumber;\n     std::map<uint256, int> mapRequestCount;\n \n     std::map<CTxDestination, CAddressBookData> mapAddressBook;\n@@ -854,9 +871,10 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n      * keystore implementation\n      * Generate a new key\n      */\n-    CPubKey GenerateNewKey(bool internal = false);\n+    CPubKey GenerateNewKey(CWalletDB& walletdb, bool internal = false);\n     //! Adds a key to the store, and saves it to disk.\n     bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey) override;\n+    bool AddKeyPubKeyWithDB(CWalletDB &walletdb,const CKey& key, const CPubKey &pubkey);\n     //! Adds a key to the store, without saving it to disk (used by LoadWallet)\n     bool LoadKey(const CKey& key, const CPubKey &pubkey) { return CCryptoKeyStore::AddKeyPubKey(key, pubkey); }\n     //! Load metadata (used by LoadWallet)\n@@ -915,6 +933,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex *pindex, const std::vector<CTransactionRef>& vtxConflicted) override;\n     void BlockDisconnected(const std::shared_ptr<const CBlock>& pblock) override;\n     bool AddToWalletIfInvolvingMe(const CTransactionRef& tx, const CBlockIndex* pIndex, int posInBlock, bool fUpdate);\n+    int64_t RescanFromTime(int64_t startTime, bool update);\n     CBlockIndex* ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate = false);\n     void ReacceptWalletTransactions();\n     void ResendWalletTransactions(int64_t nBestBlockTime, CConnman* connman) override;\n@@ -932,7 +951,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n      * Insert additional inputs into the transaction by\n      * calling CreateTransaction();\n      */\n-    bool FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, std::string& strFailReason, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl, bool keepReserveKey = true);\n+    bool FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, std::string& strFailReason, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl);\n     bool SignTransaction(CMutableTransaction& tx);\n \n     /**\n@@ -941,7 +960,7 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n      * @note passing nChangePosInOut as -1 will result in setting a random position\n      */\n     bool CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet, int& nChangePosInOut,\n-                           std::string& strFailReason, const CCoinControl *coinControl = NULL, bool sign = true);\n+                           std::string& strFailReason, const CCoinControl& coin_control, bool sign = true);\n     bool CommitTransaction(CWalletTx& wtxNew, CReserveKey& reservekey, CConnman* connman, CValidationState& state);\n \n     void ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries);\n@@ -952,11 +971,12 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n \n     static CFeeRate minTxFee;\n     static CFeeRate fallbackFee;\n+    static CFeeRate m_discard_rate;\n     /**\n      * Estimate the minimum fee considering user set parameters\n      * and the required fee\n      */\n-    static CAmount GetMinimumFee(unsigned int nTxBytes, unsigned int nConfirmTarget, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, bool ignoreGlobalPayTxFee = false);\n+    static CAmount GetMinimumFee(unsigned int nTxBytes, const CCoinControl& coin_control, const CTxMemPool& pool, const CBlockPolicyEstimator& estimator, FeeCalculation *feeCalc);\n     /**\n      * Return the minimum required fee taking into account the\n      * floating relay fee and user set minimum transaction fee\n@@ -966,9 +986,9 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n     bool NewKeyPool();\n     size_t KeypoolCountExternalKeys();\n     bool TopUpKeyPool(unsigned int kpSize = 0);\n-    void ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool internal);\n+    void ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRequestedInternal);\n     void KeepKey(int64_t nIndex);\n-    void ReturnKey(int64_t nIndex);\n+    void ReturnKey(int64_t nIndex, bool fInternal);\n     bool GetKeyFromPool(CPubKey &key, bool internal = false);\n     int64_t GetOldestKeyPoolTime();\n     void GetAllReserveKeys(std::set<CKeyID>& setAddress) const;\n@@ -1018,12 +1038,12 @@ class CWallet : public CCryptoKeyStore, public CValidationInterface\n         }\n     }\n \n-    void GetScriptForMining(std::shared_ptr<CReserveScript> &script) override;\n+    void GetScriptForMining(std::shared_ptr<CReserveScript> &script);\n     \n     unsigned int GetKeyPoolSize()\n     {\n-        AssertLockHeld(cs_wallet); // setKeyPool\n-        return setKeyPool.size();\n+        AssertLockHeld(cs_wallet); // set{Ex,In}ternalKeyPool\n+        return setInternalKeyPool.size() + setExternalKeyPool.size();\n     }\n \n     bool SetDefaultKey(const CPubKey &vchPubKey);\n@@ -1127,11 +1147,13 @@ class CReserveKey : public CReserveScript\n     CWallet* pwallet;\n     int64_t nIndex;\n     CPubKey vchPubKey;\n+    bool fInternal;\n public:\n     CReserveKey(CWallet* pwalletIn)\n     {\n         nIndex = -1;\n         pwallet = pwalletIn;\n+        fInternal = false;\n     }\n \n     CReserveKey() = default;\n@@ -1146,7 +1168,7 @@ class CReserveKey : public CReserveScript\n     void ReturnKey();\n     bool GetReservedKey(CPubKey &pubkey, bool internal = false);\n     void KeepKey();\n-    void KeepScript() { KeepKey(); }\n+    void KeepScript() override { KeepKey(); }\n };\n \n \n@@ -1204,4 +1226,5 @@ bool CWallet::DummySignTx(CMutableTransaction &txNew, const ContainerType &coins\n     }\n     return true;\n }\n+\n #endif // BITCOIN_WALLET_WALLET_H"
      },
      {
        "sha": "65a28af46dc24ddeaf5927abfa89198fc6a69249",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 64,
        "deletions": 106,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=d6e2da631a3f67c653902afb71de30817e36ada3",
        "patch": "@@ -18,127 +18,105 @@\n \n #include <atomic>\n \n-#include <boost/version.hpp>\n-#include <boost/foreach.hpp>\n #include <boost/thread.hpp>\n \n-static uint64_t nAccountingEntryNumber = 0;\n-\n-static std::atomic<unsigned int> nWalletDBUpdateCounter;\n-\n //\n // CWalletDB\n //\n \n bool CWalletDB::WriteName(const std::string& strAddress, const std::string& strName)\n {\n-    nWalletDBUpdateCounter++;\n-    return batch.Write(std::make_pair(std::string(\"name\"), strAddress), strName);\n+    return WriteIC(std::make_pair(std::string(\"name\"), strAddress), strName);\n }\n \n bool CWalletDB::EraseName(const std::string& strAddress)\n {\n     // This should only be used for sending addresses, never for receiving addresses,\n     // receiving addresses must always have an address book entry if they're not change return.\n-    nWalletDBUpdateCounter++;\n-    return batch.Erase(std::make_pair(std::string(\"name\"), strAddress));\n+    return EraseIC(std::make_pair(std::string(\"name\"), strAddress));\n }\n \n bool CWalletDB::WritePurpose(const std::string& strAddress, const std::string& strPurpose)\n {\n-    nWalletDBUpdateCounter++;\n-    return batch.Write(std::make_pair(std::string(\"purpose\"), strAddress), strPurpose);\n+    return WriteIC(std::make_pair(std::string(\"purpose\"), strAddress), strPurpose);\n }\n \n bool CWalletDB::ErasePurpose(const std::string& strPurpose)\n {\n-    nWalletDBUpdateCounter++;\n-    return batch.Erase(std::make_pair(std::string(\"purpose\"), strPurpose));\n+    return EraseIC(std::make_pair(std::string(\"purpose\"), strPurpose));\n }\n \n bool CWalletDB::WriteTx(const CWalletTx& wtx)\n {\n-    nWalletDBUpdateCounter++;\n-    return batch.Write(std::make_pair(std::string(\"tx\"), wtx.GetHash()), wtx);\n+    return WriteIC(std::make_pair(std::string(\"tx\"), wtx.GetHash()), wtx);\n }\n \n bool CWalletDB::EraseTx(uint256 hash)\n {\n-    nWalletDBUpdateCounter++;\n-    return batch.Erase(std::make_pair(std::string(\"tx\"), hash));\n+    return EraseIC(std::make_pair(std::string(\"tx\"), hash));\n }\n \n bool CWalletDB::WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, const CKeyMetadata& keyMeta)\n {\n-    nWalletDBUpdateCounter++;\n-\n-    if (!batch.Write(std::make_pair(std::string(\"keymeta\"), vchPubKey),\n-               keyMeta, false))\n+    if (!WriteIC(std::make_pair(std::string(\"keymeta\"), vchPubKey), keyMeta, false)) {\n         return false;\n+    }\n \n     // hash pubkey/privkey to accelerate wallet load\n     std::vector<unsigned char> vchKey;\n     vchKey.reserve(vchPubKey.size() + vchPrivKey.size());\n     vchKey.insert(vchKey.end(), vchPubKey.begin(), vchPubKey.end());\n     vchKey.insert(vchKey.end(), vchPrivKey.begin(), vchPrivKey.end());\n \n-    return batch.Write(std::make_pair(std::string(\"key\"), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false);\n+    return WriteIC(std::make_pair(std::string(\"key\"), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false);\n }\n \n bool CWalletDB::WriteCryptedKey(const CPubKey& vchPubKey,\n                                 const std::vector<unsigned char>& vchCryptedSecret,\n                                 const CKeyMetadata &keyMeta)\n {\n-    const bool fEraseUnencryptedKey = true;\n-    nWalletDBUpdateCounter++;\n-\n-    if (!batch.Write(std::make_pair(std::string(\"keymeta\"), vchPubKey),\n-            keyMeta))\n+    if (!WriteIC(std::make_pair(std::string(\"keymeta\"), vchPubKey), keyMeta)) {\n         return false;\n+    }\n \n-    if (!batch.Write(std::make_pair(std::string(\"ckey\"), vchPubKey), vchCryptedSecret, false))\n+    if (!WriteIC(std::make_pair(std::string(\"ckey\"), vchPubKey), vchCryptedSecret, false)) {\n         return false;\n-    if (fEraseUnencryptedKey)\n-    {\n-        batch.Erase(std::make_pair(std::string(\"key\"), vchPubKey));\n-        batch.Erase(std::make_pair(std::string(\"wkey\"), vchPubKey));\n     }\n+    EraseIC(std::make_pair(std::string(\"key\"), vchPubKey));\n+    EraseIC(std::make_pair(std::string(\"wkey\"), vchPubKey));\n     return true;\n }\n \n bool CWalletDB::WriteMasterKey(unsigned int nID, const CMasterKey& kMasterKey)\n {\n-    nWalletDBUpdateCounter++;\n-    return batch.Write(std::make_pair(std::string(\"mkey\"), nID), kMasterKey, true);\n+    return WriteIC(std::make_pair(std::string(\"mkey\"), nID), kMasterKey, true);\n }\n \n bool CWalletDB::WriteCScript(const uint160& hash, const CScript& redeemScript)\n {\n-    nWalletDBUpdateCounter++;\n-    return batch.Write(std::make_pair(std::string(\"cscript\"), hash), *(const CScriptBase*)(&redeemScript), false);\n+    return WriteIC(std::make_pair(std::string(\"cscript\"), hash), redeemScript, false);\n }\n \n bool CWalletDB::WriteWatchOnly(const CScript &dest, const CKeyMetadata& keyMeta)\n {\n-    nWalletDBUpdateCounter++;\n-    if (!batch.Write(std::make_pair(std::string(\"watchmeta\"), *(const CScriptBase*)(&dest)), keyMeta))\n+    if (!WriteIC(std::make_pair(std::string(\"watchmeta\"), dest), keyMeta)) {\n         return false;\n-    return batch.Write(std::make_pair(std::string(\"watchs\"), *(const CScriptBase*)(&dest)), '1');\n+    }\n+    return WriteIC(std::make_pair(std::string(\"watchs\"), dest), '1');\n }\n \n bool CWalletDB::EraseWatchOnly(const CScript &dest)\n {\n-    nWalletDBUpdateCounter++;\n-    if (!batch.Erase(std::make_pair(std::string(\"watchmeta\"), *(const CScriptBase*)(&dest))))\n+    if (!EraseIC(std::make_pair(std::string(\"watchmeta\"), dest))) {\n         return false;\n-    return batch.Erase(std::make_pair(std::string(\"watchs\"), *(const CScriptBase*)(&dest)));\n+    }\n+    return EraseIC(std::make_pair(std::string(\"watchs\"), dest));\n }\n \n bool CWalletDB::WriteBestBlock(const CBlockLocator& locator)\n {\n-    nWalletDBUpdateCounter++;\n-    batch.Write(std::string(\"bestblock\"), CBlockLocator()); // Write empty block locator so versions that require a merkle branch automatically rescan\n-    return batch.Write(std::string(\"bestblock_nomerkle\"), locator);\n+    WriteIC(std::string(\"bestblock\"), CBlockLocator()); // Write empty block locator so versions that require a merkle branch automatically rescan\n+    return WriteIC(std::string(\"bestblock_nomerkle\"), locator);\n }\n \n bool CWalletDB::ReadBestBlock(CBlockLocator& locator)\n@@ -149,14 +127,12 @@ bool CWalletDB::ReadBestBlock(CBlockLocator& locator)\n \n bool CWalletDB::WriteOrderPosNext(int64_t nOrderPosNext)\n {\n-    nWalletDBUpdateCounter++;\n-    return batch.Write(std::string(\"orderposnext\"), nOrderPosNext);\n+    return WriteIC(std::string(\"orderposnext\"), nOrderPosNext);\n }\n \n bool CWalletDB::WriteDefaultKey(const CPubKey& vchPubKey)\n {\n-    nWalletDBUpdateCounter++;\n-    return batch.Write(std::string(\"defaultkey\"), vchPubKey);\n+    return WriteIC(std::string(\"defaultkey\"), vchPubKey);\n }\n \n bool CWalletDB::ReadPool(int64_t nPool, CKeyPool& keypool)\n@@ -166,19 +142,17 @@ bool CWalletDB::ReadPool(int64_t nPool, CKeyPool& keypool)\n \n bool CWalletDB::WritePool(int64_t nPool, const CKeyPool& keypool)\n {\n-    nWalletDBUpdateCounter++;\n-    return batch.Write(std::make_pair(std::string(\"pool\"), nPool), keypool);\n+    return WriteIC(std::make_pair(std::string(\"pool\"), nPool), keypool);\n }\n \n bool CWalletDB::ErasePool(int64_t nPool)\n {\n-    nWalletDBUpdateCounter++;\n-    return batch.Erase(std::make_pair(std::string(\"pool\"), nPool));\n+    return EraseIC(std::make_pair(std::string(\"pool\"), nPool));\n }\n \n bool CWalletDB::WriteMinVersion(int nVersion)\n {\n-    return batch.Write(std::string(\"minversion\"), nVersion);\n+    return WriteIC(std::string(\"minversion\"), nVersion);\n }\n \n bool CWalletDB::ReadAccount(const std::string& strAccount, CAccount& account)\n@@ -189,17 +163,12 @@ bool CWalletDB::ReadAccount(const std::string& strAccount, CAccount& account)\n \n bool CWalletDB::WriteAccount(const std::string& strAccount, const CAccount& account)\n {\n-    return batch.Write(std::make_pair(std::string(\"acc\"), strAccount), account);\n+    return WriteIC(std::make_pair(std::string(\"acc\"), strAccount), account);\n }\n \n bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n {\n-    return batch.Write(std::make_pair(std::string(\"acentry\"), std::make_pair(acentry.strAccount, nAccEntryNum)), acentry);\n-}\n-\n-bool CWalletDB::WriteAccountingEntry_Backend(const CAccountingEntry& acentry)\n-{\n-    return WriteAccountingEntry(++nAccountingEntryNumber, acentry);\n+    return WriteIC(std::make_pair(std::string(\"acentry\"), std::make_pair(acentry.strAccount, nAccEntryNum)), acentry);\n }\n \n CAmount CWalletDB::GetAccountCreditDebit(const std::string& strAccount)\n@@ -208,7 +177,7 @@ CAmount CWalletDB::GetAccountCreditDebit(const std::string& strAccount)\n     ListAccountCreditDebit(strAccount, entries);\n \n     CAmount nCreditDebit = 0;\n-    BOOST_FOREACH (const CAccountingEntry& entry, entries)\n+    for (const CAccountingEntry& entry : entries)\n         nCreditDebit += entry.nCreditDebit;\n \n     return nCreditDebit;\n@@ -338,8 +307,9 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             ssKey >> strAccount;\n             uint64_t nNumber;\n             ssKey >> nNumber;\n-            if (nNumber > nAccountingEntryNumber)\n-                nAccountingEntryNumber = nNumber;\n+            if (nNumber > pwallet->nAccountingEntryNumber) {\n+                pwallet->nAccountingEntryNumber = nNumber;\n+            }\n \n             if (!wss.fAnyUnordered)\n             {\n@@ -353,7 +323,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         {\n             wss.nWatchKeys++;\n             CScript script;\n-            ssKey >> *(CScriptBase*)(&script);\n+            ssKey >> script;\n             char fYes;\n             ssValue >> fYes;\n             if (fYes == '1')\n@@ -470,7 +440,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             else if (strType == \"watchmeta\")\n             {\n               CScript script;\n-              ssKey >> *(CScriptBase*)(&script);\n+              ssKey >> script;\n               keyID = CScriptID(script);\n             }\n \n@@ -504,7 +474,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n             uint160 hash;\n             ssKey >> hash;\n             CScript script;\n-            ssValue >> *(CScriptBase*)(&script);\n+            ssValue >> script;\n             if (!pwallet->LoadCScript(script))\n             {\n                 strErr = \"Error reading wallet database: LoadCScript failed\";\n@@ -635,7 +605,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n     if ((wss.nKeys + wss.nCKeys + wss.nWatchKeys) != wss.nKeyMeta)\n         pwallet->UpdateTimeFirstKey(1);\n \n-    BOOST_FOREACH(uint256 hash, wss.vWalletUpgrade)\n+    for (uint256 hash : wss.vWalletUpgrade)\n         WriteTx(pwallet->mapWallet[hash]);\n \n     // Rewrite encrypted wallets of versions 0.4.0 and 0.5.0rc:\n@@ -650,7 +620,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n \n     pwallet->laccentries.clear();\n     ListAccountCreditDebit(\"*\", pwallet->laccentries);\n-    BOOST_FOREACH(CAccountingEntry& entry, pwallet->laccentries) {\n+    for (CAccountingEntry& entry : pwallet->laccentries) {\n         pwallet->wtxOrdered.insert(make_pair(entry.nOrderPos, CWallet::TxPair((CWalletTx*)0, &entry)));\n     }\n \n@@ -736,7 +706,7 @@ DBErrors CWalletDB::ZapSelectTx(std::vector<uint256>& vTxHashIn, std::vector<uin\n     // erase each matching wallet TX\n     bool delerror = false;\n     std::vector<uint256>::iterator it = vTxHashIn.begin();\n-    BOOST_FOREACH (uint256 hash, vTxHash) {\n+    for (uint256 hash : vTxHash) {\n         while (it < vTxHashIn.end() && (*it) < hash) {\n             it++;\n         }\n@@ -767,7 +737,7 @@ DBErrors CWalletDB::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n         return err;\n \n     // erase each wallet TX\n-    BOOST_FOREACH (uint256& hash, vTxHash) {\n+    for (uint256& hash : vTxHash) {\n         if (!EraseTx(hash))\n             return DB_CORRUPT;\n     }\n@@ -777,46 +747,47 @@ DBErrors CWalletDB::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n \n void MaybeCompactWalletDB()\n {\n-    static std::atomic<bool> fOneThread;\n+    static std::atomic<bool> fOneThread(false);\n     if (fOneThread.exchange(true)) {\n         return;\n     }\n     if (!GetBoolArg(\"-flushwallet\", DEFAULT_FLUSHWALLET)) {\n         return;\n     }\n \n-    static unsigned int nLastSeen = CWalletDB::GetUpdateCounter();\n-    static unsigned int nLastFlushed = CWalletDB::GetUpdateCounter();\n-    static int64_t nLastWalletUpdate = GetTime();\n+    for (CWalletRef pwallet : vpwallets) {\n+        CWalletDBWrapper& dbh = pwallet->GetDBHandle();\n \n-    if (nLastSeen != CWalletDB::GetUpdateCounter())\n-    {\n-        nLastSeen = CWalletDB::GetUpdateCounter();\n-        nLastWalletUpdate = GetTime();\n-    }\n+        unsigned int nUpdateCounter = dbh.nUpdateCounter;\n \n-    if (nLastFlushed != CWalletDB::GetUpdateCounter() && GetTime() - nLastWalletUpdate >= 2)\n-    {\n-        if (CDB::PeriodicFlush(pwalletMain->GetDBHandle())) {\n-            nLastFlushed = CWalletDB::GetUpdateCounter();\n+        if (dbh.nLastSeen != nUpdateCounter) {\n+            dbh.nLastSeen = nUpdateCounter;\n+            dbh.nLastWalletUpdate = GetTime();\n+        }\n+\n+        if (dbh.nLastFlushed != nUpdateCounter && GetTime() - dbh.nLastWalletUpdate >= 2) {\n+            if (CDB::PeriodicFlush(dbh)) {\n+                dbh.nLastFlushed = nUpdateCounter;\n+            }\n         }\n     }\n+\n     fOneThread = false;\n }\n \n //\n // Try to (very carefully!) recover wallet file if there is a problem.\n //\n-bool CWalletDB::Recover(const std::string& filename, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue))\n+bool CWalletDB::Recover(const std::string& filename, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& out_backup_filename)\n {\n-    return CDB::Recover(filename, callbackDataIn, recoverKVcallback);\n+    return CDB::Recover(filename, callbackDataIn, recoverKVcallback, out_backup_filename);\n }\n \n-bool CWalletDB::Recover(const std::string& filename)\n+bool CWalletDB::Recover(const std::string& filename, std::string& out_backup_filename)\n {\n     // recover without a key filter callback\n     // results in recovering all record types\n-    return CWalletDB::Recover(filename, NULL, NULL);\n+    return CWalletDB::Recover(filename, NULL, NULL, out_backup_filename);\n }\n \n bool CWalletDB::RecoverKeysOnlyFilter(void *callbackData, CDataStream ssKey, CDataStream ssValue)\n@@ -849,36 +820,23 @@ bool CWalletDB::VerifyEnvironment(const std::string& walletFile, const fs::path&\n \n bool CWalletDB::VerifyDatabaseFile(const std::string& walletFile, const fs::path& dataDir, std::string& warningStr, std::string& errorStr)\n {\n-    return CDB::VerifyDatabaseFile(walletFile, dataDir, errorStr, warningStr, CWalletDB::Recover);\n+    return CDB::VerifyDatabaseFile(walletFile, dataDir, warningStr, errorStr, CWalletDB::Recover);\n }\n \n bool CWalletDB::WriteDestData(const std::string &address, const std::string &key, const std::string &value)\n {\n-    nWalletDBUpdateCounter++;\n-    return batch.Write(std::make_pair(std::string(\"destdata\"), std::make_pair(address, key)), value);\n+    return WriteIC(std::make_pair(std::string(\"destdata\"), std::make_pair(address, key)), value);\n }\n \n bool CWalletDB::EraseDestData(const std::string &address, const std::string &key)\n {\n-    nWalletDBUpdateCounter++;\n-    return batch.Erase(std::make_pair(std::string(\"destdata\"), std::make_pair(address, key)));\n+    return EraseIC(std::make_pair(std::string(\"destdata\"), std::make_pair(address, key)));\n }\n \n \n bool CWalletDB::WriteHDChain(const CHDChain& chain)\n {\n-    nWalletDBUpdateCounter++;\n-    return batch.Write(std::string(\"hdchain\"), chain);\n-}\n-\n-void CWalletDB::IncrementUpdateCounter()\n-{\n-    nWalletDBUpdateCounter++;\n-}\n-\n-unsigned int CWalletDB::GetUpdateCounter()\n-{\n-    return nWalletDBUpdateCounter;\n+    return WriteIC(std::string(\"hdchain\"), chain);\n }\n \n bool CWalletDB::TxnBegin()"
      },
      {
        "sha": "d78f143ebd65ea3077cbcd2f4a37a20043729865",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "fd0ca5394233c92fbaeab10a5f80a75edf63a835",
        "filename": "src/warnings.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/warnings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/warnings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/warnings.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "1790fe56982a1a34c0521ce9c70bf910e0da765f",
        "filename": "src/zmq/zmqpublishnotifier.h",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/src/zmq/zmqpublishnotifier.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/src/zmq/zmqpublishnotifier.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqpublishnotifier.h?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "868eb667ae206e1509e3f4043639706136af2ce6",
        "filename": "test/README.md",
        "status": "modified",
        "additions": 131,
        "deletions": 43,
        "changes": 174,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/README.md?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "96fe0beccea9c0b50bcdfb2e8064e72901878cd3",
        "filename": "test/functional/README.md",
        "status": "modified",
        "additions": 110,
        "deletions": 64,
        "changes": 174,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/README.md?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "f00232c9ffe0398f4456b4881c48144873f5d336",
        "filename": "test/functional/bip9-softforks.py",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/bip9-softforks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/bip9-softforks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bip9-softforks.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "a7034e6bcdbab5f2d743cfaab9cbfefb9a570840",
        "filename": "test/functional/blockchain.py",
        "status": "modified",
        "additions": 23,
        "deletions": 2,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/blockchain.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "9237f0924012b1b1952037d4aab9475f16f45cf3",
        "filename": "test/functional/bumpfee.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bumpfee.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "8339305f5e45250d40540c8aebbfbec3a2c3dccf",
        "filename": "test/functional/dbcrash.py",
        "status": "added",
        "additions": 281,
        "deletions": 0,
        "changes": 281,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/dbcrash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/dbcrash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/dbcrash.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "1ba5f756cd4a05cd4f7388ffad125b0f899bceef",
        "filename": "test/functional/example_test.py",
        "status": "added",
        "additions": 219,
        "deletions": 0,
        "changes": 219,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "e52e773918b01253eba4acbe2791a8eb38bd8633",
        "filename": "test/functional/fundrawtransaction.py",
        "status": "modified",
        "additions": 5,
        "deletions": 16,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/fundrawtransaction.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "fca99c7df5715a767e30a31e7946d8ba993b79f5",
        "filename": "test/functional/getblocktemplate_proposals.py",
        "status": "removed",
        "additions": 0,
        "deletions": 157,
        "changes": 157,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/getblocktemplate_proposals.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b229ad9a5a183867921440b4b3a86b84b10c96d3/test/functional/getblocktemplate_proposals.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/getblocktemplate_proposals.py?ref=b229ad9a5a183867921440b4b3a86b84b10c96d3"
      },
      {
        "sha": "e8be559918d52ae8449aec4ef1535c6b01c3bc3d",
        "filename": "test/functional/keypool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/keypool.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "f75a8e29cc7a0b76e4c38451f2b53b16f1faa210",
        "filename": "test/functional/listtransactions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/listtransactions.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "bcc65c8408eeb7b3c3eec102d850a3b53ae824bc",
        "filename": "test/functional/merkle_blocks.py",
        "status": "modified",
        "additions": 15,
        "deletions": 10,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/merkle_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/merkle_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/merkle_blocks.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "dbd4e29ecae80cb92f40b1964eee2a2863b69b4d",
        "filename": "test/functional/mining.py",
        "status": "added",
        "additions": 124,
        "deletions": 0,
        "changes": 124,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/mining.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/mining.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "a30e15ace9e43b9e7653d4eb1d890ea453543fc7",
        "filename": "test/functional/multi_rpc.py",
        "status": "modified",
        "additions": 51,
        "deletions": 7,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/multi_rpc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/multi_rpc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/multi_rpc.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "2b4dd2d3e7db5a4a22e75ab730f53d8d3b4baf52",
        "filename": "test/functional/multiwallet.py",
        "status": "added",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/multiwallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/multiwallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/multiwallet.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "63dfbb8ae6e564a02f1c067f380f23dc339fd60b",
        "filename": "test/functional/p2p-segwit.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-segwit.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "0af91e0658904fc5422922642d80e946fd7e4313",
        "filename": "test/functional/pruning.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/pruning.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "6272fc69b783cdfda19e2b0b65bf56ea493260f3",
        "filename": "test/functional/rawtransactions.py",
        "status": "modified",
        "additions": 53,
        "deletions": 4,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/rawtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/rawtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rawtransactions.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "19d99c9c9e9750241da3a46c59bebb9f21eae28f",
        "filename": "test/functional/receivedby.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/receivedby.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/receivedby.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/receivedby.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "bc6765498750dc27df3a9b59e5a5a063777f1fbf",
        "filename": "test/functional/replace-by-fee.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/replace-by-fee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/replace-by-fee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/replace-by-fee.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "a69dbb501333a58e3a8372c316fc9023768ae155",
        "filename": "test/functional/rest.py",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rest.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "951685aa7606a16c089c4280d0b221e836902774",
        "filename": "test/functional/rpcbind_test.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/rpcbind_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/rpcbind_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpcbind_test.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "415727268a30ab4b680ff90dba20c788ab556262",
        "filename": "test/functional/signrawtransactions.py",
        "status": "modified",
        "additions": 0,
        "deletions": 16,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/signrawtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/signrawtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/signrawtransactions.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "bc42a319df79dc061a89eab78351911972c6f087",
        "filename": "test/functional/smartfees.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/smartfees.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/smartfees.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/smartfees.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "b3671cbdc51ed3ed272c9c84d0119060b6e62d98",
        "filename": "test/functional/test_framework/authproxy.py",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/test_framework/authproxy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/test_framework/authproxy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/authproxy.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "227b1a17afbea0dee0ffef49ef5c84adb1e06133",
        "filename": "test/functional/test_framework/coverage.py",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/test_framework/coverage.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/test_framework/coverage.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/coverage.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "688347a68ff53db386e8bbec62e091627ca4c43e",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      },
      {
        "sha": "8d698a73276a1eb38f4963fb67e4b5d0fb71d6f5",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 157,
        "deletions": 47,
        "changes": 204,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d6e2da631a3f67c653902afb71de30817e36ada3/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=d6e2da631a3f67c653902afb71de30817e36ada3"
      }
    ]
  },
  {
    "sha": "ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZTZjYTFlYzdhZDQyNGM2NGRlMDEyOWZlZjk0MDRhMmRjYjIxMjAw",
    "commit": {
      "author": {
        "name": "globaltoken",
        "email": "heisenbergakatheking@gmail.com",
        "date": "2017-07-20T21:18:56Z"
      },
      "committer": {
        "name": "globaltoken",
        "email": "heisenbergakatheking@gmail.com",
        "date": "2017-07-20T21:18:56Z"
      },
      "message": "Base Params for Globaltoken added\n\nChanged Bitcoin Params to Globaltoken Params",
      "tree": {
        "sha": "381510f2e676d3e08eb06ad78e4d288d938d3853",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/381510f2e676d3e08eb06ad78e4d288d938d3853"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "d6e2da631a3f67c653902afb71de30817e36ada3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d6e2da631a3f67c653902afb71de30817e36ada3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d6e2da631a3f67c653902afb71de30817e36ada3"
      }
    ],
    "stats": {
      "total": 1460,
      "additions": 147,
      "deletions": 1313
    },
    "files": [
      {
        "sha": "4e017fe2355eaac76d15d3fcdaa64fdb665d03aa",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 10,
        "deletions": 8,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "patch": "@@ -1,23 +1,25 @@\n dnl require autoconf 2.60 (AS_ECHO/AS_ECHO_N)\n AC_PREREQ([2.60])\n-define(_CLIENT_VERSION_MAJOR, 0)\n-define(_CLIENT_VERSION_MINOR, 14)\n-define(_CLIENT_VERSION_REVISION, 99)\n+define(_CLIENT_VERSION_MAJOR, 1)\n+define(_CLIENT_VERSION_MINOR, 0)\n+define(_CLIENT_VERSION_REVISION, 4)\n define(_CLIENT_VERSION_BUILD, 0)\n define(_CLIENT_VERSION_IS_RELEASE, false)\n+define(_COPYRIGHT_GLT_START, 2016)\n define(_COPYRIGHT_YEAR, 2017)\n define(_COPYRIGHT_HOLDERS,[The %s developers])\n define(_COPYRIGHT_HOLDERS_SUBSTITUTION,[[Bitcoin Core]])\n-AC_INIT([Bitcoin Core],[_CLIENT_VERSION_MAJOR._CLIENT_VERSION_MINOR._CLIENT_VERSION_REVISION],[https://github.com/bitcoin/bitcoin/issues],[bitcoin],[https://bitcoincore.org/])\n+define(_COPYRIGHT_HOLDERS_SUBSTITUTION,[[Globaltoken Core]])\n+AC_INIT([Globaltoken Core],[_CLIENT_VERSION_MAJOR._CLIENT_VERSION_MINOR._CLIENT_VERSION_REVISION],[https://github.com/bitcoin/bitcoin/issues],[bitcoin],[https://bitcoincore.org/])\n AC_CONFIG_SRCDIR([src/validation.cpp])\n AC_CONFIG_HEADERS([src/config/bitcoin-config.h])\n AC_CONFIG_AUX_DIR([build-aux])\n AC_CONFIG_MACRO_DIR([build-aux/m4])\n \n-BITCOIN_DAEMON_NAME=bitcoind\n-BITCOIN_GUI_NAME=bitcoin-qt\n-BITCOIN_CLI_NAME=bitcoin-cli\n-BITCOIN_TX_NAME=bitcoin-tx\n+BITCOIN_DAEMON_NAME=globaltokend\n+BITCOIN_GUI_NAME=globaltoken-qt\n+BITCOIN_CLI_NAME=globaltoken-cli\n+BITCOIN_TX_NAME=globaltoken-tx\n \n dnl Unless the user specified ARFLAGS, force it to be cr\n AC_ARG_VAR(ARFLAGS, [Flags for the archiver, defaults to <cr> if not set])"
      },
      {
        "sha": "120711561f253111a8a09a948625fb0100a2bc98",
        "filename": "src/amount.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/amount.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/amount.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/amount.h?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "patch": "@@ -1,5 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n // Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -23,7 +24,7 @@ static const CAmount CENT = 1000000;\n  * critical; in unusual circumstances like a(nother) overflow bug that allowed\n  * for the creation of coins out of thin air modification could lead to a fork.\n  * */\n-static const CAmount MAX_MONEY = 21000000 * COIN;\n+static const CAmount MAX_MONEY = 168000000 * COIN;\n inline bool MoneyRange(const CAmount& nValue) { return (nValue >= 0 && nValue <= MAX_MONEY); }\n \n #endif //  BITCOIN_AMOUNT_H"
      },
      {
        "sha": "1db406769055b403aa4bd012f7e3907fa2a08123",
        "filename": "src/bench/base58.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/bench/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/bench/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/base58.cpp?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "patch": "@@ -1,4 +1,5 @@\n // Copyright (c) 2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -46,7 +47,7 @@ static void Base58CheckEncode(benchmark::State& state)\n \n static void Base58Decode(benchmark::State& state)\n {\n-    const char* addr = \"17VZNX1SN5NtKa8UQFxwQbFeFc3iqRYhem\";\n+    const char* addr = \"Gbgpx5gAB4wUr1ps7o8RydZsgeVnuHL97Y\";\n     std::vector<unsigned char> vch;\n     while (state.KeepRunning()) {\n         DecodeBase58(addr, vch);"
      },
      {
        "sha": "056a4a0183a5921989feae6e1f8365d5d8beb9cf",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "patch": "@@ -1,5 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n // Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -84,10 +85,10 @@ static int AppInitRPC(int argc, char* argv[])\n         std::string strUsage = strprintf(_(\"%s RPC client version\"), _(PACKAGE_NAME)) + \" \" + FormatFullVersion() + \"\\n\";\n         if (!IsArgSet(\"-version\")) {\n             strUsage += \"\\n\" + _(\"Usage:\") + \"\\n\" +\n-                  \"  bitcoin-cli [options] <command> [params]  \" + strprintf(_(\"Send command to %s\"), _(PACKAGE_NAME)) + \"\\n\" +\n-                  \"  bitcoin-cli [options] -named <command> [name=value] ... \" + strprintf(_(\"Send command to %s (with named arguments)\"), _(PACKAGE_NAME)) + \"\\n\" +\n-                  \"  bitcoin-cli [options] help                \" + _(\"List commands\") + \"\\n\" +\n-                  \"  bitcoin-cli [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n+                  \"  globaltoken-cli [options] <command> [params]  \" + strprintf(_(\"Send command to %s\"), _(PACKAGE_NAME)) + \"\\n\" +\n+                  \"  globaltoken-cli [options] -named <command> [name=value] ... \" + strprintf(_(\"Send command to %s (with named arguments)\"), _(PACKAGE_NAME)) + \"\\n\" +\n+                  \"  globaltoken-cli [options] help                \" + _(\"List commands\") + \"\\n\" +\n+                  \"  globaltoken-cli [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n \n             strUsage += \"\\n\" + HelpMessageCli();\n         }"
      },
      {
        "sha": "1e5d131df32c8aedd74bb64e7bd42ae84040f7d7",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "patch": "@@ -1,4 +1,5 @@\n // Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -54,10 +55,10 @@ static int AppInitRawTx(int argc, char* argv[])\n     if (argc<2 || IsArgSet(\"-?\") || IsArgSet(\"-h\") || IsArgSet(\"-help\"))\n     {\n         // First part of help message is specific to this utility\n-        std::string strUsage = strprintf(_(\"%s bitcoin-tx utility version\"), _(PACKAGE_NAME)) + \" \" + FormatFullVersion() + \"\\n\\n\" +\n+        std::string strUsage = strprintf(_(\"%s globaltoken-tx utility version\"), _(PACKAGE_NAME)) + \" \" + FormatFullVersion() + \"\\n\\n\" +\n             _(\"Usage:\") + \"\\n\" +\n-              \"  bitcoin-tx [options] <hex-tx> [commands]  \" + _(\"Update hex-encoded bitcoin transaction\") + \"\\n\" +\n-              \"  bitcoin-tx [options] -create [commands]   \" + _(\"Create hex-encoded bitcoin transaction\") + \"\\n\" +\n+              \"  globaltoken-tx [options] <hex-tx> [commands]  \" + _(\"Update hex-encoded bitcoin transaction\") + \"\\n\" +\n+              \"  globaltoken-tx [options] -create [commands]   \" + _(\"Create hex-encoded bitcoin transaction\") + \"\\n\" +\n               \"\\n\";\n \n         fprintf(stdout, \"%s\", strUsage.c_str());"
      },
      {
        "sha": "f450aac07a1fac585a1896528e6f969d2b5f2dca",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "patch": "@@ -1,5 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n // Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -85,7 +86,7 @@ bool AppInit(int argc, char* argv[])\n         else\n         {\n             strUsage += \"\\n\" + _(\"Usage:\") + \"\\n\" +\n-                  \"  bitcoind [options]                     \" + strprintf(_(\"Start %s Daemon\"), _(PACKAGE_NAME)) + \"\\n\";\n+                  \"  globaltokend [options]                     \" + strprintf(_(\"Start %s Daemon\"), _(PACKAGE_NAME)) + \"\\n\";\n \n             strUsage += \"\\n\" + HelpMessage(HMM_BITCOIND);\n         }\n@@ -119,7 +120,7 @@ bool AppInit(int argc, char* argv[])\n         // Error out when loose non-argument tokens are encountered on command line\n         for (int i = 1; i < argc; i++) {\n             if (!IsSwitchChar(argv[i][0])) {\n-                fprintf(stderr, \"Error: Command line contains unexpected token '%s', see bitcoind -h for a list of options.\\n\", argv[i]);\n+                fprintf(stderr, \"Error: Command line contains unexpected token '%s', see globaltokend -h for a list of options.\\n\", argv[i]);\n                 exit(EXIT_FAILURE);\n             }\n         }"
      },
      {
        "sha": "ccffe9e081ac0d7bf5fda36f99aed9796f62e540",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "patch": "@@ -1,5 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n // Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -18,7 +19,7 @@\n  * Maximum amount of time that a block timestamp is allowed to exceed the\n  * current network-adjusted time before the block will be accepted.\n  */\n-static const int64_t MAX_FUTURE_BLOCK_TIME = 2 * 60 * 60;\n+static const int64_t MAX_FUTURE_BLOCK_TIME = 2 * 60 * 6;\n \n /**\n  * Timestamp window used as a grace period by code that compares external"
      },
      {
        "sha": "1560228caa10795e20370c7e6e0a1841e1863897",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 84,
        "deletions": 91,
        "changes": 175,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "patch": "@@ -1,5 +1,6 @@\n // Copyright (c) 2010 Satoshi Nakamoto\n // Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -48,7 +49,7 @@ static CBlock CreateGenesisBlock(const char* pszTimestamp, const CScript& genesi\n  */\n static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)\n {\n-    const char* pszTimestamp = \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\";\n+    const char* pszTimestamp = \"05.12.2016 18.27h UTC plus 1 created Globaltoken\";\n     const CScript genesisOutputScript = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n     return CreateGenesisBlock(pszTimestamp, genesisOutputScript, nTime, nNonce, nBits, nVersion, genesisReward);\n }\n@@ -74,66 +75,62 @@ class CMainParams : public CChainParams {\n public:\n     CMainParams() {\n         strNetworkID = \"main\";\n-        consensus.nSubsidyHalvingInterval = 210000;\n-        consensus.BIP34Height = 227931;\n-        consensus.BIP34Hash = uint256S(\"0x000000000000024b89b42a942fe0d9fea3bb44ab7bd1b19115dd6a759c0808b8\");\n-        consensus.BIP65Height = 388381; // 000000000000000004c2b624ed5d7756c508d90fd0da2c7c679febfa6c4735f0\n-        consensus.BIP66Height = 363725; // 00000000000000000379eaa19dce8c9b722d46ae6a57c2f1a988119488b50931\n+        consensus.nSubsidyHalvingInterval = 840000;\n+        consensus.BIP34Height = 1;\n+        consensus.BIP34Hash = uint256S(\"0x0000000097fcef2abcd5b827feffb2625fa50ef1794d8efc75ddbfaa3daeb499\");\n+        consensus.BIP65Height = 280000; // not hashed yet ...\n+        consensus.BIP66Height = 260000; // not hashed yet ...\n         consensus.powLimit = uint256S(\"00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n-        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n-        consensus.nPowTargetSpacing = 10 * 60;\n+        consensus.nPowTargetTimespan = 10 * 60; // ten minutes\n+        consensus.nPowTargetSpacing = 60;\n         consensus.fPowAllowMinDifficultyBlocks = false;\n         consensus.fPowNoRetargeting = false;\n-        consensus.nRuleChangeActivationThreshold = 1916; // 95% of 2016\n-        consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing\n+        consensus.nRuleChangeActivationThreshold = 8; // 95% of 2016 // Changed to 8 because 9.5 is up to ten.\n+        consensus.nMinerConfirmationWindow = 10; // nPowTargetTimespan / nPowTargetSpacing\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n         // Deployment of BIP68, BIP112, and BIP113.\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1462060800; // May 1st, 2016\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1506729600; // Sat, 30 Sep 2017\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1509494400; // Wed, 01 Nov 2017\n \n         // Deployment of SegWit (BIP141, BIP143, and BIP147)\n         consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1479168000; // November 15th, 2016.\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1510704000; // November 15th, 2017.\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1519862400; // Thu, 01 Mar 2018.\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1551398400; // Fri, 01 Mar 2019.\n \n         // The best chain should have at least this much work.\n         consensus.nMinimumChainWork = uint256S(\"0x0000000000000000000000000000000000000000003f94d1ad391682fe038bf5\");\n \n         // By default assume that the signatures in ancestors of this block are valid.\n-        consensus.defaultAssumeValid = uint256S(\"0x00000000000000000013176bf8d7dfeab4e1db31dc93bc311b436e82ab226b90\"); //453354\n+        consensus.defaultAssumeValid = uint256S(\"0x000000000000014cf4dc216dcc925bf0c6d7096aa6ab82e1af64e946d876df7d\"); //200000\n \n         /**\n          * The message start string is designed to be unlikely to occur in normal data.\n          * The characters are rarely used upper ASCII, not valid as UTF-8, and produce\n          * a large 32-bit integer with any alignment.\n          */\n-        pchMessageStart[0] = 0xf9;\n-        pchMessageStart[1] = 0xbe;\n-        pchMessageStart[2] = 0xb4;\n-        pchMessageStart[3] = 0xd9;\n-        nDefaultPort = 8333;\n-        nPruneAfterHeight = 100000;\n-\n-        genesis = CreateGenesisBlock(1231006505, 2083236893, 0x1d00ffff, 1, 50 * COIN);\n+        pchMessageStart[0] = 0xc7;\n+        pchMessageStart[1] = 0x08;\n+        pchMessageStart[2] = 0xd3;\n+        pchMessageStart[3] = 0x2d;\n+        nDefaultPort = 9319;\n+        nPruneAfterHeight = 750000;\n+\n+        genesis = CreateGenesisBlock(1480961109, 2864352084, 0x1d00ffff, 1, 100 * COIN);\n         consensus.hashGenesisBlock = genesis.GetHash();\n-        assert(consensus.hashGenesisBlock == uint256S(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\"));\n-        assert(genesis.hashMerkleRoot == uint256S(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\n+        assert(consensus.hashGenesisBlock == uint256S(\"0x00000000fe3e3e93344a6b73888137397413eb11f601b4231b5196390d24d3b6\"));\n+        assert(genesis.hashMerkleRoot == uint256S(\"0xe217ce769444458c180ca6a5944cbbc22828f377cfd0e1790158034299827ffc\"));\n \n         // Note that of those with the service bits flag, most only support a subset of possible options\n-        vSeeds.emplace_back(\"seed.bitcoin.sipa.be\", true); // Pieter Wuille, only supports x1, x5, x9, and xd\n-        vSeeds.emplace_back(\"dnsseed.bluematt.me\", true); // Matt Corallo, only supports x9\n-        vSeeds.emplace_back(\"dnsseed.bitcoin.dashjr.org\", false); // Luke Dashjr\n-        vSeeds.emplace_back(\"seed.bitcoinstats.com\", true); // Christian Decker, supports x1 - xf\n-        vSeeds.emplace_back(\"seed.bitcoin.jonasschnelli.ch\", true); // Jonas Schnelli, only supports x1, x5, x9, and xd\n-        vSeeds.emplace_back(\"seed.btc.petertodd.org\", true); // Peter Todd, only supports x1, x5, x9, and xd\n-\n-        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);\n+\n+        vSeeds.emplace_back(\"134.255.221.7\", false); // Globaltoken Base Node\n+\n+        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,38);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);\n-        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,128);\n+        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,166);\n         base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x88, 0xB2, 0x1E};\n         base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x88, 0xAD, 0xE4};\n \n@@ -145,28 +142,26 @@ class CMainParams : public CChainParams {\n \n         checkpointData = (CCheckpointData) {\n             {\n-                { 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\")},\n-                { 33333, uint256S(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\")},\n-                { 74000, uint256S(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\")},\n-                {105000, uint256S(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\")},\n-                {134444, uint256S(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\")},\n-                {168000, uint256S(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\")},\n-                {193000, uint256S(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\")},\n-                {210000, uint256S(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\")},\n-                {216116, uint256S(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\")},\n-                {225430, uint256S(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\")},\n-                {250000, uint256S(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\")},\n-                {279000, uint256S(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\")},\n-                {295000, uint256S(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\")},\n+                {     0, uint256S(\"0x00000000fe3e3e93344a6b73888137397413eb11f601b4231b5196390d24d3b6\")},\n+\t\t\t\t{   253, uint256S(\"0x000000000001a9597538194df736eda73c35c17d78ec14ac99b9d392d0892ce3\")},\n+\t\t\t\t{ 13500, uint256S(\"0x000000000029c7baaad2daf1720df2da5075deb4c27660f3e80a54d93cda0432\")},\n+\t\t\t\t{ 44446, uint256S(\"0x000000000004ddd47d2e6033af4d034e63171d61e4eaca2702f9e8b9a8ffdb5a\")},\n+\t\t\t\t{ 62399, uint256S(\"0x0000000000293411d6ad5adad3f4205f883e73fd912560acd00329705c22168c\")},\n+\t\t\t\t{ 84049, uint256S(\"0x000000000003e444f034474726fdfe69cd6103699650e9e221e53d0a4b4a38f7\")},\n+\t\t\t\t{ 87757, uint256S(\"0x000000000001356d0e351660b8356f8f6a12a5b029b2c10a5b47d753b8cd8f29\")},\n+\t\t\t\t{ 93644, uint256S(\"0x0000000000004b51b629b2f41e586e46f7b5bacce68e4575079d5ec53ecf5dbb\")},\n+\t\t\t\t{122548, uint256S(\"0x00000000000016ab86f4d91ace5087e92ffe80ce565e0b50ebc6487ed7ef855e\")},\n+\t\t\t\t{174987, uint256S(\"0x0000000000004a80520dfce6d2017d6f403a9def13fe99629d31f6b7a90b7c31\")},\n+\t\t\t\t{210000, uint256S(\"0x00000000000001b9719d694b2c6b2a74173d9333ba7e629439d8de8bd42e993f\")},\n             }\n         };\n \n         chainTxData = ChainTxData{\n-            // Data as of block 00000000000000000166d612d5595e2b1cd88d71d695fc580af64d8da8658c23 (height 446482).\n-            1483472411, // * UNIX timestamp of last known number of transactions\n-            184495391,  // * total number of transactions between genesis and that timestamp\n+            // Data as of block 000000000000008693613d3912b046912aa73a8a1587f22ff04b3ccef61f7eab (height 216752).\n+            1500577431, // * UNIX timestamp of last known number of transactions\n+            269785,     // * total number of transactions between genesis and that timestamp\n                         //   (the tx=... number in the SetBestChain debug.log lines)\n-            3.2         // * estimated number of transactions per second after that timestamp\n+            0.00001     // * estimated number of transactions per second after that timestamp\n         };\n     }\n };\n@@ -178,57 +173,55 @@ class CTestNetParams : public CChainParams {\n public:\n     CTestNetParams() {\n         strNetworkID = \"test\";\n-        consensus.nSubsidyHalvingInterval = 210000;\n-        consensus.BIP34Height = 21111;\n-        consensus.BIP34Hash = uint256S(\"0x0000000023b3a96d3484e5abb3755c413e7d41500f8e2a5c3f0dd01299cd8ef8\");\n-        consensus.BIP65Height = 581885; // 00000000007f6655f22f98e72ed80d8b06dc761d5da09df0fa1dc4be4f861eb6\n-        consensus.BIP66Height = 330776; // 000000002104c8c45e99a8853285a3b592602a3ccde2b832481da85e9e4ba182\n+        consensus.nSubsidyHalvingInterval = 840000;\n+        consensus.BIP34Height = 1;\n+        consensus.BIP34Hash = uint256S(\"0x00000000fe3e3e93344a6b73888137397413eb11f601b4231b5196390d24d3b6\");\n+        consensus.BIP65Height = 100; // not hashed yet.\n+        consensus.BIP66Height = 10;  // not hashed yet.\n         consensus.powLimit = uint256S(\"00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n-        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n-        consensus.nPowTargetSpacing = 10 * 60;\n+        consensus.nPowTargetTimespan = 10 * 60; // ten minutes\n+        consensus.nPowTargetSpacing = 60;\n         consensus.fPowAllowMinDifficultyBlocks = true;\n         consensus.fPowNoRetargeting = false;\n-        consensus.nRuleChangeActivationThreshold = 1512; // 75% for testchains\n-        consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing\n+        consensus.nRuleChangeActivationThreshold = 8; // 75% for testchains\n+        consensus.nMinerConfirmationWindow = 10; // nPowTargetTimespan / nPowTargetSpacing\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n         consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n \n         // Deployment of BIP68, BIP112, and BIP113.\n         consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1456790400; // March 1st, 2016\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1506729600; // Sat, 30 Sep 2017\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1509494400; // Wed, 01 Nov 2017\n \n         // Deployment of SegWit (BIP141, BIP143, and BIP147)\n         consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1462060800; // May 1st 2016\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1493596800; // May 1st 2017\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1519862400; // Thu, 01 Mar 2018.\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1551398400; // Fri, 01 Mar 2019.\n \n         // The best chain should have at least this much work.\n         consensus.nMinimumChainWork = uint256S(\"0x00000000000000000000000000000000000000000000001f057509eba81aed91\");\n \n         // By default assume that the signatures in ancestors of this block are valid.\n-        consensus.defaultAssumeValid = uint256S(\"0x00000000000128796ee387cf110ccb9d2f36cffaf7f73079c995377c65ac0dcc\"); //1079274\n+        consensus.defaultAssumeValid = uint256S(\"0x00000000fe3e3e93344a6b73888137397413eb11f601b4231b5196390d24d3b6\"); //0\n \n-        pchMessageStart[0] = 0x0b;\n-        pchMessageStart[1] = 0x11;\n-        pchMessageStart[2] = 0x09;\n-        pchMessageStart[3] = 0x07;\n-        nDefaultPort = 18333;\n+        pchMessageStart[0] = 0x3a;\n+        pchMessageStart[1] = 0x6f;\n+        pchMessageStart[2] = 0x37;\n+        pchMessageStart[3] = 0x5b;\n+        nDefaultPort = 19319;\n         nPruneAfterHeight = 1000;\n \n-        genesis = CreateGenesisBlock(1296688602, 414098458, 0x1d00ffff, 1, 50 * COIN);\n+        genesis = CreateGenesisBlock(1480961109, 2864352084, 0x1d00ffff, 1, 100 * COIN);\n         consensus.hashGenesisBlock = genesis.GetHash();\n-        assert(consensus.hashGenesisBlock == uint256S(\"0x000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943\"));\n-        assert(genesis.hashMerkleRoot == uint256S(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\n+        assert(consensus.hashGenesisBlock == uint256S(\"0x00000000fe3e3e93344a6b73888137397413eb11f601b4231b5196390d24d3b6\"));\n+        assert(genesis.hashMerkleRoot == uint256S(\"0xe217ce769444458c180ca6a5944cbbc22828f377cfd0e1790158034299827ffc\"));\n \n         vFixedSeeds.clear();\n         vSeeds.clear();\n         // nodes with support for servicebits filtering should be at the top\n-        vSeeds.emplace_back(\"testnet-seed.bitcoin.jonasschnelli.ch\", true);\n-        vSeeds.emplace_back(\"seed.tbtc.petertodd.org\", true);\n-        vSeeds.emplace_back(\"testnet-seed.bluematt.me\", false);\n-        vSeeds.emplace_back(\"testnet-seed.bitcoin.schildbach.de\", false);\n+\n+        vSeeds.emplace_back(\"134.255.221.7\", false);\n \n         base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);\n         base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);\n@@ -245,15 +238,15 @@ class CTestNetParams : public CChainParams {\n \n         checkpointData = (CCheckpointData) {\n             {\n-                {546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\")},\n+                {0, uint256S(\"00000000fe3e3e93344a6b73888137397413eb11f601b4231b5196390d24d3b6\")},\n             }\n         };\n \n         chainTxData = ChainTxData{\n             // Data as of block 00000000c2872f8f8a8935c8e3c5862be9038c97d4de2cf37ed496991166928a (height 1063660)\n-            1483546230,\n-            12834668,\n-            0.15\n+            1480961109,\n+            1,\n+            1\n         };\n \n     }\n@@ -272,8 +265,8 @@ class CRegTestParams : public CChainParams {\n         consensus.BIP65Height = 1351; // BIP65 activated on regtest (Used in rpc activation tests)\n         consensus.BIP66Height = 1251; // BIP66 activated on regtest (Used in rpc activation tests)\n         consensus.powLimit = uint256S(\"7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n-        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n-        consensus.nPowTargetSpacing = 10 * 60;\n+        consensus.nPowTargetTimespan = 10 * 60; // ten minutes\n+        consensus.nPowTargetSpacing = 60;\n         consensus.fPowAllowMinDifficultyBlocks = true;\n         consensus.fPowNoRetargeting = true;\n         consensus.nRuleChangeActivationThreshold = 108; // 75% for testchains\n@@ -294,17 +287,17 @@ class CRegTestParams : public CChainParams {\n         // By default assume that the signatures in ancestors of this block are valid.\n         consensus.defaultAssumeValid = uint256S(\"0x00\");\n \n-        pchMessageStart[0] = 0xfa;\n-        pchMessageStart[1] = 0xbf;\n-        pchMessageStart[2] = 0xb5;\n-        pchMessageStart[3] = 0xda;\n+        pchMessageStart[0] = 0x14;\n+        pchMessageStart[1] = 0x76;\n+        pchMessageStart[2] = 0x69;\n+        pchMessageStart[3] = 0xd6;\n         nDefaultPort = 18444;\n         nPruneAfterHeight = 1000;\n \n-        genesis = CreateGenesisBlock(1296688602, 2, 0x207fffff, 1, 50 * COIN);\n+        genesis = CreateGenesisBlock(1480961109, 2, 0x207fffff, 1, 100 * COIN);\n         consensus.hashGenesisBlock = genesis.GetHash();\n-        assert(consensus.hashGenesisBlock == uint256S(\"0x0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"));\n-        assert(genesis.hashMerkleRoot == uint256S(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\n+        assert(consensus.hashGenesisBlock == uint256S(\"0x1ba3490ecf1653fbe7a53d1e0fb7e051c2a1c506d84f4dd3b01522544cd1fc6f\"));\n+        assert(genesis.hashMerkleRoot == uint256S(\"0xe217ce769444458c180ca6a5944cbbc22828f377cfd0e1790158034299827ffc\"));\n \n         vFixedSeeds.clear(); //!< Regtest mode doesn't have any fixed seeds.\n         vSeeds.clear();      //!< Regtest mode doesn't have any DNS seeds.\n@@ -315,7 +308,7 @@ class CRegTestParams : public CChainParams {\n \n         checkpointData = (CCheckpointData) {\n             {\n-                {0, uint256S(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\")},\n+                {0, uint256S(\"1ba3490ecf1653fbe7a53d1e0fb7e051c2a1c506d84f4dd3b01522544cd1fc6f\")},\n             }\n         };\n "
      },
      {
        "sha": "e3a880fda4cca76a66db022455e40f7fa739dccc",
        "filename": "src/chainparamsbase.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "patch": "@@ -1,5 +1,6 @@\n // Copyright (c) 2010 Satoshi Nakamoto\n // Copyright (c) 2009-2015 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -32,7 +33,7 @@ class CBaseMainParams : public CBaseChainParams\n public:\n     CBaseMainParams()\n     {\n-        nRPCPort = 8332;\n+        nRPCPort = 9320;\n     }\n };\n \n@@ -44,7 +45,7 @@ class CBaseTestNetParams : public CBaseChainParams\n public:\n     CBaseTestNetParams()\n     {\n-        nRPCPort = 18332;\n+        nRPCPort = 19320;\n         strDataDir = \"testnet3\";\n     }\n };\n@@ -57,7 +58,7 @@ class CBaseRegTestParams : public CBaseChainParams\n public:\n     CBaseRegTestParams()\n     {\n-        nRPCPort = 18332;\n+        nRPCPort = 18443;\n         strDataDir = \"regtest\";\n     }\n };"
      },
      {
        "sha": "46dfc0243319744a5d18b528de6d39c630126bd9",
        "filename": "src/chainparamsseeds.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1179,
        "changes": 1184,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/chainparamsseeds.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/chainparamsseeds.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsseeds.h?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200"
      },
      {
        "sha": "c1b339f82ed136f39ab0bf92065c8d86c6421fd4",
        "filename": "src/clientversion.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/clientversion.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/clientversion.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.cpp?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "patch": "@@ -1,4 +1,5 @@\n // Copyright (c) 2012-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -13,7 +14,7 @@\n  * for both bitcoind and bitcoin-core, to make it harder for attackers to\n  * target servers or GUI users specifically.\n  */\n-const std::string CLIENT_NAME(\"Satoshi\");\n+const std::string CLIENT_NAME(\"Globaltokshi\");\n \n /**\n  * Client version number"
      },
      {
        "sha": "839002f12844a335fbe1717267a713a0f5c9b4a0",
        "filename": "src/policy/feerate.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/policy/feerate.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/policy/feerate.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/feerate.cpp?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "patch": "@@ -1,13 +1,14 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n // Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"feerate.h\"\n \n #include \"tinyformat.h\"\n \n-const std::string CURRENCY_UNIT = \"BTC\";\n+const std::string CURRENCY_UNIT = \"GLT\";\n \n CFeeRate::CFeeRate(const CAmount& nFeePaid, size_t nBytes_)\n {"
      },
      {
        "sha": "e904f00b702b583150aa3b2252137c075217d9b0",
        "filename": "src/qt/bitcoinunits.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/qt/bitcoinunits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/qt/bitcoinunits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinunits.cpp?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "patch": "@@ -1,4 +1,5 @@\n-// Copyright (c) 2011-2016 The Bitcoin Core developers\n+\ufeff// Copyright (c) 2011-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -40,9 +41,9 @@ QString BitcoinUnits::name(int unit)\n {\n     switch(unit)\n     {\n-    case BTC: return QString(\"BTC\");\n-    case mBTC: return QString(\"mBTC\");\n-    case uBTC: return QString::fromUtf8(\"\u03bcBTC\");\n+    case BTC: return QString(\"GLT\");\n+    case mBTC: return QString(\"mGLT\");\n+    case uBTC: return QString::fromUtf8(\"\u03bcGLT\");\n     default: return QString(\"???\");\n     }\n }\n@@ -51,9 +52,9 @@ QString BitcoinUnits::description(int unit)\n {\n     switch(unit)\n     {\n-    case BTC: return QString(\"Bitcoins\");\n-    case mBTC: return QString(\"Milli-Bitcoins (1 / 1\" THIN_SP_UTF8 \"000)\");\n-    case uBTC: return QString(\"Micro-Bitcoins (1 / 1\" THIN_SP_UTF8 \"000\" THIN_SP_UTF8 \"000)\");\n+    case BTC: return QString(\"Globaltokens\");\n+    case mBTC: return QString(\"Milli-Globaltokens (1 / 1\" THIN_SP_UTF8 \"000)\");\n+    case uBTC: return QString(\"Micro-Globaltokens (1 / 1\" THIN_SP_UTF8 \"000\" THIN_SP_UTF8 \"000)\");\n     default: return QString(\"???\");\n     }\n }"
      },
      {
        "sha": "01fe2a3fca05ff695ba237494c8433a297fadbdd",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "patch": "@@ -1,5 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n // Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -87,8 +88,8 @@\n // Application startup time (used for uptime calculation)\n const int64_t nStartupTime = GetTime();\n \n-const char * const BITCOIN_CONF_FILENAME = \"bitcoin.conf\";\n-const char * const BITCOIN_PID_FILENAME = \"bitcoind.pid\";\n+const char * const BITCOIN_CONF_FILENAME = \"globaltoken.conf\";\n+const char * const BITCOIN_PID_FILENAME = \"globaltokend.pid\";\n \n ArgsManager gArgs;\n bool fPrintToConsole = false;\n@@ -530,7 +531,7 @@ fs::path GetDefaultDataDir()\n     // Unix: ~/.bitcoin\n #ifdef WIN32\n     // Windows\n-    return GetSpecialFolderPath(CSIDL_APPDATA) / \"Bitcoin\";\n+    return GetSpecialFolderPath(CSIDL_APPDATA) / \"Globaltoken\";\n #else\n     fs::path pathRet;\n     char* pszHome = getenv(\"HOME\");\n@@ -540,10 +541,10 @@ fs::path GetDefaultDataDir()\n         pathRet = fs::path(pszHome);\n #ifdef MAC_OSX\n     // Mac\n-    return pathRet / \"Library/Application Support/Bitcoin\";\n+    return pathRet / \"Library/Application Support/Globaltoken\";\n #else\n     // Unix\n-    return pathRet / \".bitcoin\";\n+    return pathRet / \".globaltoken\";\n #endif\n #endif\n }"
      },
      {
        "sha": "51af3ff7fcf67d22fd436816add74d5279fcf161",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "patch": "@@ -1,5 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n // Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -91,7 +92,7 @@ static void CheckBlockIndex(const Consensus::Params& consensusParams);\n /** Constant stuff for coinbase transactions we create: */\n CScript COINBASE_FLAGS;\n \n-const std::string strMessageMagic = \"Bitcoin Signed Message:\\n\";\n+const std::string strMessageMagic = \"Globaltoken Signed Message:\\n\";\n \n // Internal stuff\n namespace {\n@@ -1023,8 +1024,8 @@ CAmount GetBlockSubsidy(int nHeight, const Consensus::Params& consensusParams)\n     if (halvings >= 64)\n         return 0;\n \n-    CAmount nSubsidy = 50 * COIN;\n-    // Subsidy is cut in half every 210,000 blocks which will occur approximately every 4 years.\n+    CAmount nSubsidy = 100 * COIN;\n+    // Subsidy is cut in half every 840,000 blocks\n     nSubsidy >>= halvings;\n     return nSubsidy;\n }\n@@ -1694,8 +1695,8 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n     // two in the chain that violate it. This prevents exploiting the issue against nodes during their\n     // initial block download.\n     bool fEnforceBIP30 = (!pindex->phashBlock) || // Enforce on CreateNewBlock invocations which don't have a hash.\n-                          !((pindex->nHeight==91842 && pindex->GetBlockHash() == uint256S(\"0x00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec\")) ||\n-                           (pindex->nHeight==91880 && pindex->GetBlockHash() == uint256S(\"0x00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721\")));\n+                          !((pindex->nHeight==0 && pindex->GetBlockHash() == uint256S(\"0x00000000fe3e3e93344a6b73888137397413eb11f601b4231b5196390d24d3b6\")) ||\n+                           (pindex->nHeight==0 && pindex->GetBlockHash() == uint256S(\"0x00000000fe3e3e93344a6b73888137397413eb11f601b4231b5196390d24d3b6\")));\n \n     // Once BIP34 activated it was not possible to create new duplicate coinbases and thus other than starting\n     // with the 2 existing duplicate coinbase pairs, not possible to create overwriting txs.  But by the"
      },
      {
        "sha": "60b6123a79bb915d53cd9a8b502d6a799d04271d",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ae6ca1ec7ad424c64de0129fef9404a2dcb21200/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "patch": "@@ -2,6 +2,7 @@\n # Copyright (c) 2010 ArtForz -- public domain half-a-node\n # Copyright (c) 2012 Jeff Garzik\n # Copyright (c) 2010-2016 The Bitcoin Core developers\n+# Copyright (c) 2017 The Globaltoken Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Bitcoin P2P network half-a-node.\n@@ -515,7 +516,7 @@ def calc_sha256(self, with_witness=False):\n     def is_valid(self):\n         self.calc_sha256()\n         for tout in self.vout:\n-            if tout.nValue < 0 or tout.nValue > 21000000 * COIN:\n+            if tout.nValue < 0 or tout.nValue > 168000000 * COIN:\n                 return False\n         return True\n "
      }
    ]
  },
  {
    "sha": "7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZDZjNjcxZjg3N2RkZmMxYWMyYzRhMzFmZDJjOGZjN2RlNDU0MTdj",
    "commit": {
      "author": {
        "name": "globaltoken",
        "email": "heisenbergakatheking@gmail.com",
        "date": "2017-07-20T23:53:39Z"
      },
      "committer": {
        "name": "globaltoken",
        "email": "heisenbergakatheking@gmail.com",
        "date": "2017-07-20T23:53:39Z"
      },
      "message": "Globaltoken Bugfixs & Improvements\n\nGlobaltoken Bugfixs & Improvements",
      "tree": {
        "sha": "d60e28eafe6d69f89f2ef6edc61a40bc3e293dce",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d60e28eafe6d69f89f2ef6edc61a40bc3e293dce"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ae6ca1ec7ad424c64de0129fef9404a2dcb21200",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ae6ca1ec7ad424c64de0129fef9404a2dcb21200"
      }
    ],
    "stats": {
      "total": 82,
      "additions": 43,
      "deletions": 39
    },
    "files": [
      {
        "sha": "a6af9da0151afc89534c0ed0ca8e0ef518b9cbc0",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
        "patch": "@@ -9,7 +9,7 @@ define(_COPYRIGHT_GLT_START, 2016)\n define(_COPYRIGHT_YEAR, 2017)\n define(_COPYRIGHT_HOLDERS,[The %s developers])\n define(_COPYRIGHT_HOLDERS_SUBSTITUTION,[[Bitcoin Core]])\n-define(_COPYRIGHT_HOLDERS_SUBSTITUTION,[[Globaltoken Core]])\n+define(_COPYRIGHT_HOLDERS_SUBSTITUTION_GLT,[[Globaltoken Core]])\n AC_INIT([Globaltoken Core],[_CLIENT_VERSION_MAJOR._CLIENT_VERSION_MINOR._CLIENT_VERSION_REVISION],[https://github.com/bitcoin/bitcoin/issues],[bitcoin],[https://bitcoincore.org/])\n AC_CONFIG_SRCDIR([src/validation.cpp])\n AC_CONFIG_HEADERS([src/config/bitcoin-config.h])"
      },
      {
        "sha": "b21845732cf4bbc23d1564771a47ae0efdb5b30c",
        "filename": "src/bitcoin-cli-res.rc",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/bitcoin-cli-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/bitcoin-cli-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli-res.rc?ref=7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
        "patch": "@@ -16,14 +16,14 @@ BEGIN\n     BEGIN\n         BLOCK \"040904E4\" // U.S. English - multilingual (hex)\n         BEGIN\n-            VALUE \"CompanyName\",        \"Bitcoin\"\n-            VALUE \"FileDescription\",    \"bitcoin-cli (JSON-RPC client for \" PACKAGE_NAME \")\"\n+            VALUE \"CompanyName\",        \"Globaltoken\"\n+            VALUE \"FileDescription\",    \"globaltoken-cli (JSON-RPC client for \" PACKAGE_NAME \")\"\n             VALUE \"FileVersion\",        VER_FILEVERSION_STR\n-            VALUE \"InternalName\",       \"bitcoin-cli\"\n+            VALUE \"InternalName\",       \"globaltoken-cli\"\n             VALUE \"LegalCopyright\",     COPYRIGHT_STR\n             VALUE \"LegalTrademarks1\",   \"Distributed under the MIT software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\"\n-            VALUE \"OriginalFilename\",   \"bitcoin-cli.exe\"\n-            VALUE \"ProductName\",        \"bitcoin-cli\"\n+            VALUE \"OriginalFilename\",   \"globaltoken-cli.exe\"\n+            VALUE \"ProductName\",        \"globaltoken-cli\"\n             VALUE \"ProductVersion\",     VER_PRODUCTVERSION_STR\n         END\n     END"
      },
      {
        "sha": "1dfef148e0c9595ff2907ac9899a698324e543ab",
        "filename": "src/bitcoin-tx-res.rc",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/bitcoin-tx-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/bitcoin-tx-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx-res.rc?ref=7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
        "patch": "@@ -16,14 +16,14 @@ BEGIN\n     BEGIN\n         BLOCK \"040904E4\" // U.S. English - multilingual (hex)\n         BEGIN\n-            VALUE \"CompanyName\",        \"Bitcoin\"\n-            VALUE \"FileDescription\",    \"bitcoin-tx (CLI Bitcoin transaction editor utility)\"\n+            VALUE \"CompanyName\",        \"Globaltoken\"\n+            VALUE \"FileDescription\",    \"globaltoken-tx (CLI Globaltoken transaction editor utility)\"\n             VALUE \"FileVersion\",        VER_FILEVERSION_STR\n-            VALUE \"InternalName\",       \"bitcoin-tx\"\n+            VALUE \"InternalName\",       \"globaltoken-tx\"\n             VALUE \"LegalCopyright\",     COPYRIGHT_STR\n             VALUE \"LegalTrademarks1\",   \"Distributed under the MIT software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\"\n-            VALUE \"OriginalFilename\",   \"bitcoin-tx.exe\"\n-            VALUE \"ProductName\",        \"bitcoin-tx\"\n+            VALUE \"OriginalFilename\",   \"globaltoken-tx.exe\"\n+            VALUE \"ProductName\",        \"globaltoken-tx\"\n             VALUE \"ProductVersion\",     VER_PRODUCTVERSION_STR\n         END\n     END"
      },
      {
        "sha": "e693834ad5d7a4202915b19f0166ba0be667b326",
        "filename": "src/bitcoind-res.rc",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/bitcoind-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/bitcoind-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind-res.rc?ref=7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
        "patch": "@@ -16,14 +16,14 @@ BEGIN\n     BEGIN\n         BLOCK \"040904E4\" // U.S. English - multilingual (hex)\n         BEGIN\n-            VALUE \"CompanyName\",        \"Bitcoin\"\n-            VALUE \"FileDescription\",    \"bitcoind (Bitcoin node with a JSON-RPC server)\"\n+            VALUE \"CompanyName\",        \"Globaltoken\"\n+            VALUE \"FileDescription\",    \"globaltokend (Globaltoken node with a JSON-RPC server)\"\n             VALUE \"FileVersion\",        VER_FILEVERSION_STR\n-            VALUE \"InternalName\",       \"bitcoind\"\n+            VALUE \"InternalName\",       \"globaltokend\"\n             VALUE \"LegalCopyright\",     COPYRIGHT_STR\n             VALUE \"LegalTrademarks1\",   \"Distributed under the MIT software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\"\n-            VALUE \"OriginalFilename\",   \"bitcoind.exe\"\n-            VALUE \"ProductName\",        \"bitcoind\"\n+            VALUE \"OriginalFilename\",   \"globaltokend.exe\"\n+            VALUE \"ProductName\",        \"globaltokend\"\n             VALUE \"ProductVersion\",     VER_PRODUCTVERSION_STR\n         END\n     END"
      },
      {
        "sha": "ec7839b3410a34cf68d28523ead2bea0b55eaa6e",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
        "patch": "@@ -1,4 +1,5 @@\n // Copyright (c) 2011-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -872,7 +873,7 @@ void BitcoinGUI::setNumBlocks(int count, const QDateTime& blockDate, double nVer\n \n void BitcoinGUI::message(const QString &title, const QString &message, unsigned int style, bool *ret)\n {\n-    QString strTitle = tr(\"Bitcoin\"); // default title\n+    QString strTitle = tr(\"GlobalToken\"); // default title\n     // Default to information icon\n     int nMBoxIcon = QMessageBox::Information;\n     int nNotifyIcon = Notificator::Information;"
      },
      {
        "sha": "2735a03d748bd9685c74b9cf9b7144fc39129310",
        "filename": "src/qt/guiconstants.h",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/guiconstants.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/guiconstants.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiconstants.h?ref=7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
        "patch": "@@ -1,4 +1,5 @@\n // Copyright (c) 2011-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -48,9 +49,9 @@ static const int MAX_URI_LENGTH = 255;\n /* Number of frames in spinner animation */\n #define SPINNER_FRAMES 36\n \n-#define QAPP_ORG_NAME \"Bitcoin\"\n-#define QAPP_ORG_DOMAIN \"bitcoin.org\"\n-#define QAPP_APP_NAME_DEFAULT \"Bitcoin-Qt\"\n-#define QAPP_APP_NAME_TESTNET \"Bitcoin-Qt-testnet\"\n+#define QAPP_ORG_NAME \"Globaltoken\"\n+#define QAPP_ORG_DOMAIN \"globaltoken.org\"\n+#define QAPP_APP_NAME_DEFAULT \"Globaltoken-Qt\"\n+#define QAPP_APP_NAME_TESTNET \"Globaltoken-Qt-testnet\"\n \n #endif // BITCOIN_QT_GUICONSTANTS_H"
      },
      {
        "sha": "6323e8a407643b555ec9cc68936028728f5d613f",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 12,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
        "patch": "@@ -1,4 +1,5 @@\n // Copyright (c) 2011-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -145,8 +146,8 @@ void setupAmountWidget(QLineEdit *widget, QWidget *parent)\n \n bool parseBitcoinURI(const QUrl &uri, SendCoinsRecipient *out)\n {\n-    // return if URI is not valid or is no bitcoin: URI\n-    if(!uri.isValid() || uri.scheme() != QString(\"bitcoin\"))\n+    // return if URI is not valid or is no globaltoken: URI\n+    if(!uri.isValid() || uri.scheme() != QString(\"globaltoken\"))\n         return false;\n \n     SendCoinsRecipient rv;\n@@ -206,21 +207,21 @@ bool parseBitcoinURI(const QUrl &uri, SendCoinsRecipient *out)\n \n bool parseBitcoinURI(QString uri, SendCoinsRecipient *out)\n {\n-    // Convert bitcoin:// to bitcoin:\n+    // Convert globaltoken:// to globaltoken:\n     //\n-    //    Cannot handle this later, because bitcoin:// will cause Qt to see the part after // as host,\n+    //    Cannot handle this later, because globaltoken:// will cause Qt to see the part after // as host,\n     //    which will lower-case it (and thus invalidate the address).\n-    if(uri.startsWith(\"bitcoin://\", Qt::CaseInsensitive))\n+    if(uri.startsWith(\"globaltoken://\", Qt::CaseInsensitive))\n     {\n-        uri.replace(0, 10, \"bitcoin:\");\n+        uri.replace(0, 10, \"globaltoken:\");\n     }\n     QUrl uriInstance(uri);\n     return parseBitcoinURI(uriInstance, out);\n }\n \n QString formatBitcoinURI(const SendCoinsRecipient &info)\n {\n-    QString ret = QString(\"bitcoin:%1\").arg(info.address);\n+    QString ret = QString(\"globaltoken:%1\").arg(info.address);\n     int paramCount = 0;\n \n     if (info.amount)\n@@ -427,7 +428,7 @@ bool openBitcoinConf()\n     \n     configFile.close();\n     \n-    /* Open bitcoin.conf with the associated application */\n+    /* Open globaltoken.conf with the associated application */\n     return QDesktopServices::openUrl(QUrl::fromLocalFile(boostPathToQString(pathConfig)));\n }\n \n@@ -713,8 +714,8 @@ fs::path static GetAutostartFilePath()\n {\n     std::string chain = ChainNameFromCommandLine();\n     if (chain == CBaseChainParams::MAIN)\n-        return GetAutostartDir() / \"bitcoin.desktop\";\n-    return GetAutostartDir() / strprintf(\"bitcoin-%s.lnk\", chain);\n+        return GetAutostartDir() / \"globaltoken.desktop\";\n+    return GetAutostartDir() / strprintf(\"globaltoken-%s.lnk\", chain);\n }\n \n bool GetStartOnSystemStartup()\n@@ -753,7 +754,7 @@ bool SetStartOnSystemStartup(bool fAutoStart)\n         if (!optionFile.good())\n             return false;\n         std::string chain = ChainNameFromCommandLine();\n-        // Write a bitcoin.desktop file to the autostart directory:\n+        // Write a globaltoken.desktop file to the autostart directory:\n         optionFile << \"[Desktop Entry]\\n\";\n         optionFile << \"Type=Application\\n\";\n         if (chain == CBaseChainParams::MAIN)\n@@ -780,7 +781,7 @@ bool SetStartOnSystemStartup(bool fAutoStart)\n LSSharedFileListItemRef findStartupItemInList(LSSharedFileListRef list, CFURLRef findUrl);\n LSSharedFileListItemRef findStartupItemInList(LSSharedFileListRef list, CFURLRef findUrl)\n {\n-    // loop through the list of startup items and try to find the bitcoin app\n+    // loop through the list of startup items and try to find the globaltoken app\n     CFArrayRef listSnapshot = LSSharedFileListCopySnapshot(list, NULL);\n     for(int i = 0; i < CFArrayGetCount(listSnapshot); i++) {\n         LSSharedFileListItemRef item = (LSSharedFileListItemRef)CFArrayGetValueAtIndex(listSnapshot, i);"
      },
      {
        "sha": "30ac0e0dd3160a44bffbcab7b6f73dce7bcf652b",
        "filename": "src/qt/intro.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/intro.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/intro.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/intro.cpp?ref=7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
        "patch": "@@ -1,4 +1,5 @@\n // Copyright (c) 2011-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -127,7 +128,7 @@ Intro::Intro(QWidget *parent) :\n         .arg(tr(PACKAGE_NAME))\n         .arg(BLOCK_CHAIN_SIZE)\n         .arg(2009)\n-        .arg(tr(\"Bitcoin\"))\n+        .arg(tr(\"Globaltoken\"))\n     );\n     ui->lblExplanation2->setText(ui->lblExplanation2->text().arg(tr(PACKAGE_NAME)));\n "
      },
      {
        "sha": "45c5740805ff1685cecc7acada3b116b8aa2aa28",
        "filename": "src/qt/res/bitcoin-qt-res.rc",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/res/bitcoin-qt-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/res/bitcoin-qt-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/bitcoin-qt-res.rc?ref=7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
        "patch": "@@ -19,13 +19,13 @@ BEGIN\n     BEGIN\n         BLOCK \"040904E4\" // U.S. English - multilingual (hex)\n         BEGIN\n-            VALUE \"CompanyName\",        \"Bitcoin\"\n-            VALUE \"FileDescription\",    PACKAGE_NAME \" (GUI node for Bitcoin)\"\n+            VALUE \"CompanyName\",        \"Globaltoken\"\n+            VALUE \"FileDescription\",    PACKAGE_NAME \" (GUI node for Globaltoken)\"\n             VALUE \"FileVersion\",        VER_FILEVERSION_STR\n-            VALUE \"InternalName\",       \"bitcoin-qt\"\n+            VALUE \"InternalName\",       \"globaltoken-qt\"\n             VALUE \"LegalCopyright\",     COPYRIGHT_STR\n             VALUE \"LegalTrademarks1\",   \"Distributed under the MIT software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\"\n-            VALUE \"OriginalFilename\",   \"bitcoin-qt.exe\"\n+            VALUE \"OriginalFilename\",   \"globaltoken-qt.exe\"\n             VALUE \"ProductName\",        PACKAGE_NAME\n             VALUE \"ProductVersion\",     VER_PRODUCTVERSION_STR\n         END"
      },
      {
        "sha": "28b1bb64d3126ddcd9005934f0b1d91abdad4433",
        "filename": "src/qt/res/icons/about.png",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/res/icons/about.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/res/icons/about.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/icons/about.png?ref=7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c"
      },
      {
        "sha": "5a34c36f7ea825d8e177b21400dc644b92097898",
        "filename": "src/qt/res/icons/bitcoin.ico",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/res/icons/bitcoin.ico",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/res/icons/bitcoin.ico",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/icons/bitcoin.ico?ref=7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c"
      },
      {
        "sha": "58ee37682d4008e68bfd364ed777f84962ac42fa",
        "filename": "src/qt/res/icons/bitcoin.png",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/res/icons/bitcoin.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/qt/res/icons/bitcoin.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/icons/bitcoin.png?ref=7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c"
      },
      {
        "sha": "effe4d46ec0efa26a22183ed5cd1c249f1184625",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
        "patch": "@@ -506,7 +506,7 @@ static std::string FormatException(const std::exception* pex, const char* pszThr\n     char pszModule[MAX_PATH] = \"\";\n     GetModuleFileNameA(NULL, pszModule, sizeof(pszModule));\n #else\n-    const char* pszModule = \"bitcoin\";\n+    const char* pszModule = \"globaltoken\";\n #endif\n     if (pex)\n         return strprintf("
      }
    ]
  },
  {
    "sha": "3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozYTJkZjNmYTIyZTU5N2JhOTNlYzFiY2ZmYzdhZDljYWY4MWViYjAw",
    "commit": {
      "author": {
        "name": "globaltoken",
        "email": "heisenbergakatheking@gmail.com",
        "date": "2017-07-21T17:05:54Z"
      },
      "committer": {
        "name": "globaltoken",
        "email": "heisenbergakatheking@gmail.com",
        "date": "2017-07-21T17:05:54Z"
      },
      "message": "Simular fixxes\n\nSimular fixxes",
      "tree": {
        "sha": "cc128516b69dbadecfb4c2a5b6e03ffafc13b588",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/cc128516b69dbadecfb4c2a5b6e03ffafc13b588"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7d6c671f877ddfc1ac2c4a31fd2c8fc7de45417c"
      }
    ],
    "stats": {
      "total": 1187,
      "additions": 602,
      "deletions": 585
    },
    "files": [
      {
        "sha": "e491054edaaeadaea9eec629ebaa57f1d0a168c6",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -2,12 +2,12 @@\n \n *.exe\n src/bitcoin\n-src/bitcoind\n+src/globaltokend\n src/bitcoin-cli\n-src/bitcoin-tx\n+src/globaltoken-tx\n src/test/test_bitcoin\n src/test/test_bitcoin_fuzzy\n-src/qt/test/test_bitcoin-qt\n+src/qt/test/test_globaltoken-qt\n \n # autoreconf\n Makefile.in\n@@ -74,12 +74,12 @@ src/qt/test/moc*.cpp\n # Compilation and Qt preprocessor part\n *.qm\n Makefile\n-bitcoin-qt\n+globaltoken-qt\n Bitcoin-Qt.app\n \n # Unit-tests\n Makefile.test\n-bitcoin-qt_test\n+globaltoken-qt_test\n \n # Resources cpp\n qrc_*.cpp"
      },
      {
        "sha": "48dee0e2d40053a42aef25453b214171a07799db",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -29,7 +29,7 @@ env:\n     - HOST=i686-pc-linux-gnu PACKAGES=\"g++-multilib bc python3-zmq\" DEP_OPTS=\"NO_QT=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\" USE_SHELL=\"/bin/dash\"\n # Win64\n     - HOST=x86_64-w64-mingw32 DPKG_ADD_ARCH=\"i386\" DEP_OPTS=\"NO_QT=1\" PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine1.6 bc\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-reduce-exports\"\n-# bitcoind\n+# globaltokend\n     - HOST=x86_64-unknown-linux-gnu PACKAGES=\"bc python3-zmq\" DEP_OPTS=\"NO_QT=1 NO_UPNP=1 DEBUG=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-zmq --enable-glibc-back-compat --enable-reduce-exports CPPFLAGS=-DDEBUG_LOCKORDER\"\n # No wallet\n     - HOST=x86_64-unknown-linux-gnu PACKAGES=\"python3\" DEP_OPTS=\"NO_WALLET=1\" RUN_TESTS=true GOAL=\"install\" BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports\""
      },
      {
        "sha": "cac5dabde39e5ab878e7a79c7fbee00d953edd52",
        "filename": "CONTRIBUTING.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/CONTRIBUTING.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/CONTRIBUTING.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/CONTRIBUTING.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -57,7 +57,7 @@ the pull request affects. Valid areas as:\n \n   - *Consensus* for changes to consensus critical code\n   - *Docs* for changes to the documentation\n-  - *Qt* for changes to bitcoin-qt\n+  - *Qt* for changes to globaltoken-qt\n   - *Mining* for changes to the mining code\n   - *Net* or *P2P* for changes to the peer-to-peer network code\n   - *RPC/REST/ZMQ* for changes to the RPC, REST or ZMQ APIs"
      },
      {
        "sha": "bc424868f8ef4070bf10926d827395a42f7ef260",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -40,8 +40,8 @@ OSX_QT_TRANSLATIONS = da,de,es,hu,ru,uk,zh_CN,zh_TW\n \n DIST_DOCS = $(wildcard doc/*.md) $(wildcard doc/release-notes/*.md)\n DIST_CONTRIB = $(top_srcdir)/contrib/bitcoin-cli.bash-completion \\\n-\t       $(top_srcdir)/contrib/bitcoin-tx.bash-completion \\\n-\t       $(top_srcdir)/contrib/bitcoind.bash-completion \\\n+\t       $(top_srcdir)/contrib/globaltoken-tx.bash-completion \\\n+\t       $(top_srcdir)/contrib/globaltokend.bash-completion \\\n \t       $(top_srcdir)/contrib/init \\\n \t       $(top_srcdir)/contrib/rpm\n "
      },
      {
        "sha": "d38bc6efe16140ef470ea0cc9e458b13a98dee54",
        "filename": "build-aux/m4/bitcoin_qt.m4",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/build-aux/m4/bitcoin_qt.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/build-aux/m4/bitcoin_qt.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_qt.m4?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -7,7 +7,7 @@ dnl Output: If qt version is auto, set bitcoin_enable_qt to false. Else, exit.\n AC_DEFUN([BITCOIN_QT_FAIL],[\n   if test \"x$bitcoin_qt_want_version\" = \"xauto\" && test x$bitcoin_qt_force != xyes; then\n     if test x$bitcoin_enable_qt != xno; then\n-      AC_MSG_WARN([$1; bitcoin-qt frontend will not be built])\n+      AC_MSG_WARN([$1; globaltoken-qt frontend will not be built])\n     fi\n     bitcoin_enable_qt=no\n     bitcoin_enable_qt_test=no\n@@ -54,7 +54,7 @@ AC_DEFUN([BITCOIN_QT_INIT],[\n   dnl enable qt support\n   AC_ARG_WITH([gui],\n     [AS_HELP_STRING([--with-gui@<:@=no|qt4|qt5|auto@:>@],\n-    [build bitcoin-qt GUI (default=auto, qt5 tried first)])],\n+    [build globaltoken-qt GUI (default=auto, qt5 tried first)])],\n     [\n      bitcoin_qt_want_version=$withval\n      if test x$bitcoin_qt_want_version = xyes; then"
      },
      {
        "sha": "e6d1a54a87de51e1310b5f07e7100ea420b0a093",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -5,7 +5,7 @@ define(_CLIENT_VERSION_MINOR, 0)\n define(_CLIENT_VERSION_REVISION, 4)\n define(_CLIENT_VERSION_BUILD, 0)\n define(_CLIENT_VERSION_IS_RELEASE, false)\n-define(_COPYRIGHT_GLT_START, 2016)\n+define(_COPYRIGHT_GLT_START, 2017)\n define(_COPYRIGHT_YEAR, 2017)\n define(_COPYRIGHT_HOLDERS,[The %s developers])\n define(_COPYRIGHT_HOLDERS_SUBSTITUTION,[[Bitcoin Core]])\n@@ -284,7 +284,7 @@ CPPFLAGS=\"$CPPFLAGS -DHAVE_BUILD_INFO -D__STDC_FORMAT_MACROS\"\n \n AC_ARG_WITH([utils],\n   [AS_HELP_STRING([--with-utils],\n-  [build bitcoin-cli bitcoin-tx (default=yes)])],\n+  [build bitcoin-cli globaltoken-tx (default=yes)])],\n   [build_bitcoin_utils=$withval],\n   [build_bitcoin_utils=yes])\n \n@@ -296,9 +296,9 @@ AC_ARG_WITH([libs],\n \n AC_ARG_WITH([daemon],\n   [AS_HELP_STRING([--with-daemon],\n-  [build bitcoind daemon (default=yes)])],\n-  [build_bitcoind=$withval],\n-  [build_bitcoind=yes])\n+  [build globaltokend daemon (default=yes)])],\n+  [build_globaltokend=$withval],\n+  [build_globaltokend=yes])\n \n use_pkgconfig=yes\n case $host in\n@@ -709,7 +709,7 @@ BITCOIN_QT_INIT\n dnl sets $bitcoin_enable_qt, $bitcoin_enable_qt_test, $bitcoin_enable_qt_dbus\n BITCOIN_QT_CONFIGURE([$use_pkgconfig], [qt5])\n \n-if test x$build_bitcoin_utils$build_bitcoind$bitcoin_enable_qt$use_tests$use_bench = xnonononono; then\n+if test x$build_bitcoin_utils$build_globaltokend$bitcoin_enable_qt$use_tests$use_bench = xnonononono; then\n     use_boost=no\n else\n     use_boost=yes\n@@ -895,7 +895,7 @@ if test x$use_pkgconfig = xyes; then\n       if test x$use_qr != xno; then\n         BITCOIN_QT_CHECK([PKG_CHECK_MODULES([QR], [libqrencode], [have_qrencode=yes], [have_qrencode=no])])\n       fi\n-      if test x$build_bitcoin_utils$build_bitcoind$bitcoin_enable_qt$use_tests != xnononono; then\n+      if test x$build_bitcoin_utils$build_globaltokend$bitcoin_enable_qt$use_tests != xnononono; then\n         PKG_CHECK_MODULES([EVENT], [libevent],, [AC_MSG_ERROR(libevent not found.)])\n         if test x$TARGET_OS != xwindows; then\n           PKG_CHECK_MODULES([EVENT_PTHREADS], [libevent_pthreads],, [AC_MSG_ERROR(libevent_pthreads not found.)])\n@@ -920,7 +920,7 @@ else\n   AC_CHECK_HEADER([openssl/ssl.h],, AC_MSG_ERROR(libssl headers missing),)\n   AC_CHECK_LIB([ssl],         [main],SSL_LIBS=-lssl, AC_MSG_ERROR(libssl missing))\n \n-  if test x$build_bitcoin_utils$build_bitcoind$bitcoin_enable_qt$use_tests != xnononono; then\n+  if test x$build_bitcoin_utils$build_globaltokend$bitcoin_enable_qt$use_tests != xnononono; then\n     AC_CHECK_HEADER([event2/event.h],, AC_MSG_ERROR(libevent headers missing),)\n     AC_CHECK_LIB([event],[main],EVENT_LIBS=-levent,AC_MSG_ERROR(libevent missing))\n     if test x$TARGET_OS != xwindows; then\n@@ -969,7 +969,7 @@ dnl univalue check\n \n need_bundled_univalue=yes\n \n-if test x$build_bitcoin_utils$build_bitcoind$bitcoin_enable_qt$use_tests$use_bench = xnonononono; then\n+if test x$build_bitcoin_utils$build_globaltokend$bitcoin_enable_qt$use_tests$use_bench = xnonononono; then\n   need_bundled_univalue=no\n else\n \n@@ -1015,11 +1015,11 @@ AC_SUBST(UNIVALUE_LIBS)\n \n BITCOIN_QT_PATH_PROGS([PROTOC], [protoc],$protoc_bin_path)\n \n-AC_MSG_CHECKING([whether to build bitcoind])\n-AM_CONDITIONAL([BUILD_BITCOIND], [test x$build_bitcoind = xyes])\n-AC_MSG_RESULT($build_bitcoind)\n+AC_MSG_CHECKING([whether to build globaltokend])\n+AM_CONDITIONAL([BUILD_BITCOIND], [test x$build_globaltokend = xyes])\n+AC_MSG_RESULT($build_globaltokend)\n \n-AC_MSG_CHECKING([whether to build utils (bitcoin-cli bitcoin-tx)])\n+AC_MSG_CHECKING([whether to build utils (bitcoin-cli globaltoken-tx)])\n AM_CONDITIONAL([BUILD_BITCOIN_UTILS], [test x$build_bitcoin_utils = xyes])\n AC_MSG_RESULT($build_bitcoin_utils)\n \n@@ -1120,7 +1120,7 @@ if test x$bitcoin_enable_qt != xno; then\n     AC_MSG_WARN(\"xgettext is required to update qt translations\")\n   fi\n \n-  AC_MSG_CHECKING([whether to build test_bitcoin-qt])\n+  AC_MSG_CHECKING([whether to build test_globaltoken-qt])\n   if test x$use_gui_tests$bitcoin_enable_qt_test = xyesyes; then\n     AC_MSG_RESULT([yes])\n     BUILD_TEST_QT=\"yes\"\n@@ -1147,7 +1147,7 @@ else\n   AC_MSG_RESULT([no])\n fi\n \n-if test x$build_bitcoin_utils$build_bitcoin_libs$build_bitcoind$bitcoin_enable_qt$use_bench$use_tests = xnononononono; then\n+if test x$build_bitcoin_utils$build_bitcoin_libs$build_globaltokend$bitcoin_enable_qt$use_bench$use_tests = xnononononono; then\n   AC_MSG_ERROR([No targets! Please specify at least one of: --with-utils --with-libs --with-daemon --with-gui --enable-bench or --enable-tests])\n fi\n "
      },
      {
        "sha": "c7587f85c0b302390bbf9d3d918ee96ae4efd611",
        "filename": "contrib/README.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/README.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -13,7 +13,7 @@ Construct a linear, no-fork, best version of the blockchain.\n \n ### [Qos](/contrib/qos) ###\n \n-A Linux bash script that will set up traffic control (tc) to limit the outgoing bandwidth for connections to the Bitcoin network. This means one can have an always-on bitcoind instance running, and another local bitcoind/bitcoin-qt instance which connects to this node and receives blocks from it.\n+A Linux bash script that will set up traffic control (tc) to limit the outgoing bandwidth for connections to the Bitcoin network. This means one can have an always-on globaltokend instance running, and another local globaltokend/globaltoken-qt instance which connects to this node and receives blocks from it.\n \n ### [Seeds](/contrib/seeds) ###\n Utility to generate the pnSeed[] array that is compiled into the client.\n@@ -22,8 +22,8 @@ Build Tools and Keys\n ---------------------\n \n ### [Debian](/contrib/debian) ###\n-Contains files used to package bitcoind/bitcoin-qt\n-for Debian-based Linux systems. If you compile bitcoind/bitcoin-qt yourself, there are some useful files here.\n+Contains files used to package globaltokend/globaltoken-qt\n+for Debian-based Linux systems. If you compile globaltokend/globaltoken-qt yourself, there are some useful files here.\n \n ### [Gitian-descriptors](/contrib/gitian-descriptors) ###\n Notes on getting Gitian builds up and running using KVM."
      },
      {
        "sha": "5ae0d6accbe24c6ac7c8a03a9b5a5f2e294f29e9",
        "filename": "contrib/bitcoin-tx.bash-completion",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/bitcoin-tx.bash-completion",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/bitcoin-tx.bash-completion",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/bitcoin-tx.bash-completion?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,4 +1,4 @@\n-# bash programmable completion for bitcoin-tx(1)\n+# bash programmable completion for globaltoken-tx(1)\n # Copyright (c) 2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n@@ -7,7 +7,7 @@ _bitcoin_tx() {\n     local cur prev words=() cword\n     local bitcoin_tx\n \n-    # save and use original argument to invoke bitcoin-tx for -help\n+    # save and use original argument to invoke globaltoken-tx for -help\n     # it might not be in $PATH\n     bitcoin_tx=\"$1\"\n \n@@ -27,7 +27,7 @@ _bitcoin_tx() {\n \n     if [[ \"$cword\" == 1 || ( \"$prev\" != \"-create\" && \"$prev\" == -* ) ]]; then\n         # only options (or an uncompletable hex-string) allowed\n-        # parse bitcoin-tx -help for options\n+        # parse globaltoken-tx -help for options\n         local helpopts\n         helpopts=$($bitcoin_tx -help | sed -e '/^  -/ p' -e d )\n         COMPREPLY=( $( compgen -W \"$helpopts\" -- \"$cur\" ) )\n@@ -46,7 +46,7 @@ _bitcoin_tx() {\n \n     return 0\n } &&\n-complete -F _bitcoin_tx bitcoin-tx\n+complete -F _bitcoin_tx globaltoken-tx\n \n # Local variables:\n # mode: shell-script"
      },
      {
        "sha": "524808f58e6c36c9af08024ac95d237a5c415b12",
        "filename": "contrib/bitcoind.bash-completion",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/bitcoind.bash-completion",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/bitcoind.bash-completion",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/bitcoind.bash-completion?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,15 +1,15 @@\n-# bash programmable completion for bitcoind(1) and bitcoin-qt(1)\n+# bash programmable completion for globaltokend(1) and globaltoken-qt(1)\n # Copyright (c) 2012-2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-_bitcoind() {\n+_globaltokend() {\n     local cur prev words=() cword\n-    local bitcoind\n+    local globaltokend\n \n-    # save and use original argument to invoke bitcoind for -help\n+    # save and use original argument to invoke globaltokend for -help\n     # it might not be in $PATH\n-    bitcoind=\"$1\"\n+    globaltokend=\"$1\"\n \n     COMPREPLY=()\n     _get_comp_words_by_ref -n = cur prev words cword\n@@ -33,7 +33,7 @@ _bitcoind() {\n             # only parse -help if senseful\n             if [[ -z \"$cur\" || \"$cur\" =~ ^- ]]; then\n                 local helpopts\n-                helpopts=$($bitcoind -help 2>&1 | awk '$1 ~ /^-/ { sub(/=.*/, \"=\"); print $1 }' )\n+                helpopts=$($globaltokend -help 2>&1 | awk '$1 ~ /^-/ { sub(/=.*/, \"=\"); print $1 }' )\n                 COMPREPLY=( $( compgen -W \"$helpopts\" -- \"$cur\" ) )\n             fi\n \n@@ -45,7 +45,7 @@ _bitcoind() {\n             ;;\n     esac\n } &&\n-complete -F _bitcoind bitcoind bitcoin-qt\n+complete -F _globaltokend globaltokend globaltoken-qt\n \n # Local variables:\n # mode: shell-script"
      },
      {
        "sha": "6c5b46a99dac5fe9fe605afbf3a64e41a4967fd5",
        "filename": "contrib/debian/README.md",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/README.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,21 +1,21 @@\n \n Debian\n ====================\n-This directory contains files used to package bitcoind/bitcoin-qt\n-for Debian-based Linux systems. If you compile bitcoind/bitcoin-qt yourself, there are some useful files here.\n+This directory contains files used to package globaltokend/globaltoken-qt\n+for Debian-based Linux systems. If you compile globaltokend/globaltoken-qt yourself, there are some useful files here.\n \n ## bitcoin: URI support ##\n \n \n-bitcoin-qt.desktop  (Gnome / Open Desktop)\n+globaltoken-qt.desktop  (Gnome / Open Desktop)\n To install:\n \n-\tsudo desktop-file-install bitcoin-qt.desktop\n+\tsudo desktop-file-install globaltoken-qt.desktop\n \tsudo update-desktop-database\n \n If you build yourself, you will either need to modify the paths in\n-the .desktop file or copy or symlink your bitcoin-qt binary to `/usr/bin`\n+the .desktop file or copy or symlink your globaltoken-qt binary to `/usr/bin`\n and the `../../share/pixmaps/bitcoin128.png` to `/usr/share/pixmaps`\n \n-bitcoin-qt.protocol (KDE)\n+globaltoken-qt.protocol (KDE)\n "
      },
      {
        "sha": "198b896611cb68c378c7a1fac262e039bb9dd5f7",
        "filename": "contrib/debian/bitcoin-qt.desktop",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-qt.desktop",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-qt.desktop",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/bitcoin-qt.desktop?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -5,7 +5,7 @@ Comment=Connect to the Bitcoin P2P Network\n Comment[de]=Verbinde mit dem Bitcoin peer-to-peer Netzwerk\n Comment[fr]=Bitcoin, monnaie virtuelle cryptographique pair \u00e0 pair\n Comment[tr]=Bitcoin, e\u015ften e\u015fe kriptografik sanal para birimi\n-Exec=bitcoin-qt %u\n+Exec=globaltoken-qt %u\n Terminal=false\n Type=Application\n Icon=bitcoin128"
      },
      {
        "sha": "21e93ec328e98984403d396e300c9b2e16a1f466",
        "filename": "contrib/debian/bitcoin-qt.install",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-qt.install",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-qt.install",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/bitcoin-qt.install?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,6 +1,6 @@\n-usr/local/bin/bitcoin-qt usr/bin\n+usr/local/bin/globaltoken-qt usr/bin\n share/pixmaps/bitcoin32.xpm usr/share/pixmaps\n share/pixmaps/bitcoin16.xpm usr/share/pixmaps\n share/pixmaps/bitcoin128.png usr/share/pixmaps\n-debian/bitcoin-qt.desktop usr/share/applications\n-debian/bitcoin-qt.protocol usr/share/kde4/services/\n+debian/globaltoken-qt.desktop usr/share/applications\n+debian/globaltoken-qt.protocol usr/share/kde4/services/"
      },
      {
        "sha": "948e95d5a7ebbb047faa02a895578bca475925d5",
        "filename": "contrib/debian/bitcoin-qt.lintian-overrides",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-qt.lintian-overrides",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-qt.lintian-overrides",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/bitcoin-qt.lintian-overrides?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,2 +1,2 @@\n # Linked code is Expat - only Debian packaging is GPL-2+\n-bitcoin-qt: possible-gpl-code-linked-with-openssl\n+globaltoken-qt: possible-gpl-code-linked-with-openssl"
      },
      {
        "sha": "18684ba32f2e5cb2abfc7d4abcb5ffd43be074e1",
        "filename": "contrib/debian/bitcoin-qt.manpages",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-qt.manpages",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-qt.manpages",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/bitcoin-qt.manpages?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1 +1 @@\n-doc/man/bitcoin-qt.1\n+doc/man/globaltoken-qt.1"
      },
      {
        "sha": "c9db0d07ecfff7b92692ca81e31bef5764cd3174",
        "filename": "contrib/debian/bitcoin-qt.protocol",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-qt.protocol",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-qt.protocol",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/bitcoin-qt.protocol?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,5 +1,5 @@\n [Protocol]\n-exec=bitcoin-qt '%u'\n+exec=globaltoken-qt '%u'\n protocol=bitcoin\n input=none\n output=none"
      },
      {
        "sha": "bf49ea78958c925e492a2230aeeacccaa864468c",
        "filename": "contrib/debian/bitcoin-tx.bash-completion",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-tx.bash-completion",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-tx.bash-completion",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/bitcoin-tx.bash-completion?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1 +1 @@\n-contrib/bitcoin-tx.bash-completion\tbitcoin-tx\n+contrib/globaltoken-tx.bash-completion\tglobaltoken-tx"
      },
      {
        "sha": "d99f1ee8893d2c700cec134473b5b348aabb2930",
        "filename": "contrib/debian/bitcoin-tx.install",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-tx.install",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-tx.install",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/bitcoin-tx.install?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1 +1 @@\n-usr/local/bin/bitcoin-tx usr/bin\n+usr/local/bin/globaltoken-tx usr/bin"
      },
      {
        "sha": "ec35e21db9b9af838a54ad775ecbad8919e35f19",
        "filename": "contrib/debian/bitcoin-tx.manpages",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-tx.manpages",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoin-tx.manpages",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/bitcoin-tx.manpages?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1 +1 @@\n-doc/man/bitcoin-tx.1\n+doc/man/globaltoken-tx.1"
      },
      {
        "sha": "e79c66ead3f0468f78389c1c7344695065b5ae60",
        "filename": "contrib/debian/bitcoind.bash-completion",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoind.bash-completion",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoind.bash-completion",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/bitcoind.bash-completion?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,2 +1,2 @@\n-contrib/bitcoind.bash-completion\tbitcoind\n+contrib/globaltokend.bash-completion\tglobaltokend\n contrib/bitcoin-cli.bash-completion\tbitcoin-cli"
      },
      {
        "sha": "11febfd3208d484928d6d718f49e291613f2d209",
        "filename": "contrib/debian/bitcoind.install",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoind.install",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoind.install",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/bitcoind.install?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,2 +1,2 @@\n-usr/local/bin/bitcoind usr/bin\n+usr/local/bin/globaltokend usr/bin\n usr/local/bin/bitcoin-cli usr/bin"
      },
      {
        "sha": "b6afcd3720c84db2544d00d84deba2f03942ce8e",
        "filename": "contrib/debian/bitcoind.lintian-overrides",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoind.lintian-overrides",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoind.lintian-overrides",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/bitcoind.lintian-overrides?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,2 +1,2 @@\n # Linked code is Expat - only Debian packaging is GPL-2+\n-bitcoind: possible-gpl-code-linked-with-openssl\n+globaltokend: possible-gpl-code-linked-with-openssl"
      },
      {
        "sha": "680cea2d472d993680c9cd21887cf5df3f580608",
        "filename": "contrib/debian/bitcoind.manpages",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoind.manpages",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/bitcoind.manpages",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/bitcoind.manpages?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,2 +1,2 @@\n-doc/man/bitcoind.1\n+doc/man/globaltokend.1\n doc/man/bitcoin-cli.1"
      },
      {
        "sha": "b8e2000012d081f7f372d5fa965e65a697781f5c",
        "filename": "contrib/debian/changelog",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/changelog",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/changelog",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/changelog?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -43,7 +43,7 @@ bitcoin (0.13.1-trusty2) trusty; urgency=medium\n bitcoin (0.13.1-trusty1) trusty; urgency=medium\n \n   * New upstream release.\n-  * Backport updated bitcoin-qt.desktop from upstream master\n+  * Backport updated globaltoken-qt.desktop from upstream master\n   * Add zmq dependency\n   * Switch to Qt5 (breaks precise, but that was already broken by C++11)\n \n@@ -278,7 +278,7 @@ bitcoin (0.6.1-natty0) natty; urgency=low\n bitcoin (0.6.0-natty0) natty; urgency=low\n \n   * New upstream release.\n-  * Add GNOME/KDE support for bitcoin-qt's bitcoin: URI support.\n+  * Add GNOME/KDE support for globaltoken-qt's bitcoin: URI support.\n     Thanks to luke-jr for the KDE .protocol file.\n \n  -- Matt Corallo <matt@bluematt.me>  Sat, 31 Mar 2012 15:35:00 -0500\n@@ -331,7 +331,7 @@ bitcoin (0.5.0~rc7-natty0) natty; urgency=low\n bitcoin (0.5.0~rc3-natty0) natty; urgency=low\n \n   * New upstream release candidate.\n-  * Don't set rpcpassword for bitcoin-qt.\n+  * Don't set rpcpassword for globaltoken-qt.\n \n  -- Matt Corallo <matt@bluematt.me>  Tue, 8 Nov 2011 11:56:00 -0400\n \n@@ -354,7 +354,7 @@ bitcoin (0.5.0~rc1-natty0) natty; urgency=low\n \n bitcoin (0.5.0~rc1-2) experimental; urgency=low\n \n-  * Add bitcoin-qt\n+  * Add globaltoken-qt\n \n  -- Matt Corallo <matt@bluematt.me>  Tue, 25 Oct 2011 15:24:18 -0400\n \n@@ -403,7 +403,7 @@ bitcoin (0.3.24~dfsg-1) unstable; urgency=low\n \n   [ Jonas Smedegaard ]\n   * Improve various usage hints:\n-    + Explicitly mention in long description that bitcoind contains\n+    + Explicitly mention in long description that globaltokend contains\n       daemon and command-line interface.\n     + Extend README.Debian with section on lack of GUI, and add primary\n       headline.\n@@ -484,15 +484,15 @@ bitcoin (0.3.20.01~dfsg-1) unstable; urgency=low\n   * Add myself as uploader.\n \n   [ Jonas Smedegaard ]\n-  * Add wrapper for bitcoind to ease initial startup.\n+  * Add wrapper for globaltokend to ease initial startup.\n   * Update patches:\n     + Drop patch 2002: Applied upstream.\n     + Add patch 1005 to add phtread linker option.\n       Closes: bug#615619. Thanks to Shane Wegner.\n     + Refresh patches.\n   * Extend copyright years in rules file header.\n   * Rewrite copyright file using draft svn166 of DEP5 format.\n-  * Rename binary package to bitcoind (from bincoin-cli).\n+  * Rename binary package to globaltokend (from bincoin-cli).\n     Closes: bug#614025. Thanks to Luke-Jr.\n \n  -- Jonas Smedegaard <dr@jones.dk>  Tue, 01 Mar 2011 15:55:04 +0100\n@@ -527,7 +527,7 @@ bitcoin (0.3.19~dfsg-4) unstable; urgency=low\n \n   [ Micah Anderson ]\n   * Provide example bitcoin.conf.\n-  * Add bitcoind(1) and bitcoin.conf(5) man pages.\n+  * Add globaltokend(1) and bitcoin.conf(5) man pages.\n \n   [ Jonas Smedegaard ]\n   * Ease backporting:"
      },
      {
        "sha": "bc11f6819540be6087594b1070f486403179355e",
        "filename": "contrib/debian/control",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/control",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/control",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/control?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -30,7 +30,7 @@ Homepage: https://bitcoincore.org/\n Vcs-Git: git://github.com/bitcoin/bitcoin.git\n Vcs-Browser: https://github.com/bitcoin/bitcoin\n \n-Package: bitcoind\n+Package: globaltokend\n Architecture: any\n Depends: ${shlibs:Depends}, ${misc:Depends}\n Description: peer-to-peer network based digital currency - daemon\n@@ -40,10 +40,10 @@ Description: peer-to-peer network based digital currency - daemon\n  transact directly with each other, with the help of a P2P network to\n  check for double-spending.\n  .\n- This package provides the daemon, bitcoind, and the CLI tool\n+ This package provides the daemon, globaltokend, and the CLI tool\n  bitcoin-cli to interact with the daemon.\n \n-Package: bitcoin-qt\n+Package: globaltoken-qt\n Architecture: any\n Depends: ${shlibs:Depends}, ${misc:Depends}\n Description: peer-to-peer network based digital currency - Qt GUI\n@@ -55,7 +55,7 @@ Description: peer-to-peer network based digital currency - Qt GUI\n  .\n  This package provides Bitcoin-Qt, a GUI for Bitcoin based on Qt.\n \n-Package: bitcoin-tx\n+Package: globaltoken-tx\n Architecture: any\n Depends: ${shlibs:Depends}, ${misc:Depends}\n Description: peer-to-peer digital currency - standalone transaction tool\n@@ -65,6 +65,6 @@ Description: peer-to-peer digital currency - standalone transaction tool\n  transact directly with each other, with the help of a P2P network to\n  check for double-spending.\n  .\n- This package provides bitcoin-tx, a command-line transaction creation\n+ This package provides globaltoken-tx, a command-line transaction creation\n  tool which can be used without a bitcoin daemon.  Some means of\n  exchanging minimal transaction data with peers is still required."
      },
      {
        "sha": "5aaeea5d9213d991aeb4b91b78d2a4d5acb35b75",
        "filename": "contrib/debian/examples/bitcoin.conf",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/examples/bitcoin.conf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/examples/bitcoin.conf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/examples/bitcoin.conf?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -57,18 +57,18 @@\n #maxconnections=\n \n #\n-# JSON-RPC options (for controlling a running Bitcoin/bitcoind process)\n+# JSON-RPC options (for controlling a running Bitcoin/globaltokend process)\n #\n \n-# server=1 tells Bitcoin-Qt and bitcoind to accept JSON-RPC commands\n+# server=1 tells Bitcoin-Qt and globaltokend to accept JSON-RPC commands\n #server=0\n \n # Bind to given address to listen for JSON-RPC connections. Use [host]:port notation for IPv6.\n # This option can be specified multiple times (default: bind to all interfaces)\n #rpcbind=<addr>\n \n # If no rpcpassword is set, rpc cookie auth is sought. The default `-rpccookiefile` name\n-# is .cookie and found in the `-datadir` being used for bitcoind. This option is typically used\n+# is .cookie and found in the `-datadir` being used for globaltokend. This option is typically used\n # when the server and client are run as the same user.\n #\n # If not, you must set rpcuser and rpcpassword to secure the JSON-RPC api. The first\n@@ -104,15 +104,15 @@\n # because the rpcpassword is transmitted over the network unencrypted.\n \n # server=1 tells Bitcoin-Qt to accept JSON-RPC commands.\n-# it is also read by bitcoind to determine if RPC should be enabled \n+# it is also read by globaltokend to determine if RPC should be enabled \n #rpcallowip=10.1.1.34/255.255.255.0\n #rpcallowip=1.2.3.4/24\n #rpcallowip=2001:db8:85a3:0:0:8a2e:370:7334/96\n \n # Listen for RPC connections on this TCP port:\n #rpcport=8332\n \n-# You can use Bitcoin or bitcoind to send commands to Bitcoin/bitcoind\n+# You can use Bitcoin or globaltokend to send commands to Bitcoin/globaltokend\n # running on another host using this option:\n #rpcconnect=127.0.0.1\n "
      },
      {
        "sha": "0872de8e2992cddbff589b523fb7741a8355acbf",
        "filename": "contrib/debian/rules",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/rules",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/debian/rules",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/rules?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -2,7 +2,7 @@\n # -*- mode: makefile; coding: utf-8 -*-\n \n #DEB_MAKE_CHECK_TARGET = test_bitcoin\n-#build/bitcoind::\n+#build/globaltokend::\n #\t$(if $(filter nocheck,$(DEB_BUILD_OPTIONS)),,src/test_bitcoin)\n \n %:"
      },
      {
        "sha": "a1e60f564aa43049ce646c6322d7b962e9c3c1e6",
        "filename": "contrib/devtools/gen-manpages.sh",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/devtools/gen-manpages.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/devtools/gen-manpages.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/gen-manpages.sh?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -4,19 +4,19 @@ TOPDIR=${TOPDIR:-$(git rev-parse --show-toplevel)}\n SRCDIR=${SRCDIR:-$TOPDIR/src}\n MANDIR=${MANDIR:-$TOPDIR/doc/man}\n \n-BITCOIND=${BITCOIND:-$SRCDIR/bitcoind}\n+BITCOIND=${BITCOIND:-$SRCDIR/globaltokend}\n BITCOINCLI=${BITCOINCLI:-$SRCDIR/bitcoin-cli}\n-BITCOINTX=${BITCOINTX:-$SRCDIR/bitcoin-tx}\n-BITCOINQT=${BITCOINQT:-$SRCDIR/qt/bitcoin-qt}\n+BITCOINTX=${BITCOINTX:-$SRCDIR/globaltoken-tx}\n+BITCOINQT=${BITCOINQT:-$SRCDIR/qt/globaltoken-qt}\n \n [ ! -x $BITCOIND ] && echo \"$BITCOIND not found or not executable.\" && exit 1\n \n # The autodetected version git tag can screw up manpage output a little bit\n BTCVER=($($BITCOINCLI --version | head -n1 | awk -F'[ -]' '{ print $6, $7 }'))\n \n # Create a footer file with copyright content.\n-# This gets autodetected fine for bitcoind if --version-string is not set,\n-# but has different outcomes for bitcoin-qt and bitcoin-cli.\n+# This gets autodetected fine for globaltokend if --version-string is not set,\n+# but has different outcomes for globaltoken-qt and bitcoin-cli.\n echo \"[COPYRIGHT]\" > footer.h2m\n $BITCOIND --version | sed -n '1!p' >> footer.h2m\n "
      },
      {
        "sha": "887c3c59572b96f1775eaa94df26409c9d60c6df",
        "filename": "contrib/devtools/symbol-check.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/devtools/symbol-check.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/devtools/symbol-check.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/symbol-check.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -53,7 +53,7 @@\n CPPFILT_CMD = os.getenv('CPPFILT', '/usr/bin/c++filt')\n # Allowed NEEDED libraries\n ALLOWED_LIBRARIES = {\n-# bitcoind and bitcoin-qt\n+# globaltokend and globaltoken-qt\n b'libgcc_s.so.1', # GCC base support\n b'libc.so.6', # C library\n b'libpthread.so.0', # threading\n@@ -62,7 +62,7 @@\n b'librt.so.1', # real-time (clock)\n b'ld-linux-x86-64.so.2', # 64-bit dynamic linker\n b'ld-linux.so.2', # 32-bit dynamic linker\n-# bitcoin-qt only\n+# globaltoken-qt only\n b'libX11-xcb.so.1', # part of X11\n b'libX11.so.6', # part of X11\n b'libxcb.so.1', # part of X11"
      },
      {
        "sha": "2ed77c036736d26c2c4fecf2a0ae2ac617e5a7ab",
        "filename": "contrib/init/README.md",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/init/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/init/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/README.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,11 +1,11 @@\n Sample configuration files for:\n ```\n-SystemD: bitcoind.service\n-Upstart: bitcoind.conf\n-OpenRC:  bitcoind.openrc\n-         bitcoind.openrcconf\n-CentOS:  bitcoind.init\n-OS X:    org.bitcoin.bitcoind.plist\n+SystemD: globaltokend.service\n+Upstart: globaltokend.conf\n+OpenRC:  globaltokend.openrc\n+         globaltokend.openrcconf\n+CentOS:  globaltokend.init\n+OS X:    org.bitcoin.globaltokend.plist\n ```\n have been made available to assist packagers in creating node packages here.\n "
      },
      {
        "sha": "1ad6a4aff2573252dd76698e9b9d5a3d3ceffc20",
        "filename": "contrib/init/bitcoind.conf",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/init/bitcoind.conf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/init/bitcoind.conf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/bitcoind.conf?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -3,14 +3,14 @@ description \"Bitcoin Core Daemon\"\n start on runlevel [2345]\n stop on starting rc RUNLEVEL=[016]\n \n-env BITCOIND_BIN=\"/usr/bin/bitcoind\"\n+env BITCOIND_BIN=\"/usr/bin/globaltokend\"\n env BITCOIND_USER=\"bitcoin\"\n env BITCOIND_GROUP=\"bitcoin\"\n-env BITCOIND_PIDDIR=\"/var/run/bitcoind\"\n+env BITCOIND_PIDDIR=\"/var/run/globaltokend\"\n # upstart can't handle variables constructed with other variables\n-env BITCOIND_PIDFILE=\"/var/run/bitcoind/bitcoind.pid\"\n+env BITCOIND_PIDFILE=\"/var/run/globaltokend/globaltokend.pid\"\n env BITCOIND_CONFIGFILE=\"/etc/bitcoin/bitcoin.conf\"\n-env BITCOIND_DATADIR=\"/var/lib/bitcoind\"\n+env BITCOIND_DATADIR=\"/var/lib/globaltokend\"\n \n expect fork\n \n@@ -20,12 +20,12 @@ kill timeout 60\n \n pre-start script\n     # this will catch non-existent config files\n-    # bitcoind will check and exit with this very warning, but it can do so\n+    # globaltokend will check and exit with this very warning, but it can do so\n     # long after forking, leaving upstart to think everything started fine.\n     # since this is a commonly encountered case on install, just check and\n     # warn here.\n     if ! grep -qs '^rpcpassword=' \"$BITCOIND_CONFIGFILE\" ; then\n-        echo \"ERROR: You must set a secure rpcpassword to run bitcoind.\"\n+        echo \"ERROR: You must set a secure rpcpassword to run globaltokend.\"\n         echo \"The setting must appear in $BITCOIND_CONFIGFILE\"\n         echo\n         echo \"This password is security critical to securing wallets \""
      },
      {
        "sha": "557ded3ebe6e2b92373b0e488c18de1e55e3e656",
        "filename": "contrib/init/bitcoind.init",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/init/bitcoind.init",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/init/bitcoind.init",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/bitcoind.init?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,36 +1,36 @@\n #!/bin/bash\n #\n-#  bitcoind The bitcoin core server.\n+#  globaltokend The bitcoin core server.\n #\n #\n # chkconfig: 345 80 20\n-# description: bitcoind\n-# processname: bitcoind\n+# description: globaltokend\n+# processname: globaltokend\n #\n \n # Source function library.\n . /etc/init.d/functions\n \n-# you can override defaults in /etc/sysconfig/bitcoind, see below\n-if [ -f /etc/sysconfig/bitcoind ]; then\n-        . /etc/sysconfig/bitcoind\n+# you can override defaults in /etc/sysconfig/globaltokend, see below\n+if [ -f /etc/sysconfig/globaltokend ]; then\n+        . /etc/sysconfig/globaltokend\n fi\n \n RETVAL=0\n \n-prog=bitcoind\n-# you can override the lockfile via BITCOIND_LOCKFILE in /etc/sysconfig/bitcoind\n-lockfile=${BITCOIND_LOCKFILE-/var/lock/subsys/bitcoind}\n+prog=globaltokend\n+# you can override the lockfile via BITCOIND_LOCKFILE in /etc/sysconfig/globaltokend\n+lockfile=${BITCOIND_LOCKFILE-/var/lock/subsys/globaltokend}\n \n-# bitcoind defaults to /usr/bin/bitcoind, override with BITCOIND_BIN\n-bitcoind=${BITCOIND_BIN-/usr/bin/bitcoind}\n+# globaltokend defaults to /usr/bin/globaltokend, override with BITCOIND_BIN\n+globaltokend=${BITCOIND_BIN-/usr/bin/globaltokend}\n \n-# bitcoind opts default to -disablewallet, override with BITCOIND_OPTS\n-bitcoind_opts=${BITCOIND_OPTS--disablewallet}\n+# globaltokend opts default to -disablewallet, override with BITCOIND_OPTS\n+globaltokend_opts=${BITCOIND_OPTS--disablewallet}\n \n start() {\n     echo -n $\"Starting $prog: \"\n-    daemon $DAEMONOPTS $bitcoind $bitcoind_opts\n+    daemon $DAEMONOPTS $globaltokend $globaltokend_opts\n     RETVAL=$?\n     echo\n     [ $RETVAL -eq 0 ] && touch $lockfile"
      },
      {
        "sha": "9071aa513ef305cca547548293271b38ef139cb4",
        "filename": "contrib/init/bitcoind.openrc",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/init/bitcoind.openrc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/init/bitcoind.openrc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/bitcoind.openrc?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -5,23 +5,23 @@\n if [ -d \"/var/lib/bitcoin/.bitcoin\" ]; then\n \tBITCOIND_DEFAULT_DATADIR=\"/var/lib/bitcoin/.bitcoin\"\n else\n-\tBITCOIND_DEFAULT_DATADIR=\"/var/lib/bitcoind\"\n+\tBITCOIND_DEFAULT_DATADIR=\"/var/lib/globaltokend\"\n fi\n \n BITCOIND_CONFIGFILE=${BITCOIND_CONFIGFILE:-/etc/bitcoin/bitcoin.conf}\n-BITCOIND_PIDDIR=${BITCOIND_PIDDIR:-/var/run/bitcoind}\n-BITCOIND_PIDFILE=${BITCOIND_PIDFILE:-${BITCOIND_PIDDIR}/bitcoind.pid}\n+BITCOIND_PIDDIR=${BITCOIND_PIDDIR:-/var/run/globaltokend}\n+BITCOIND_PIDFILE=${BITCOIND_PIDFILE:-${BITCOIND_PIDDIR}/globaltokend.pid}\n BITCOIND_DATADIR=${BITCOIND_DATADIR:-${BITCOIND_DEFAULT_DATADIR}}\n BITCOIND_USER=${BITCOIND_USER:-${BITCOIN_USER:-bitcoin}}\n BITCOIND_GROUP=${BITCOIND_GROUP:-bitcoin}\n-BITCOIND_BIN=${BITCOIND_BIN:-/usr/bin/bitcoind}\n+BITCOIND_BIN=${BITCOIND_BIN:-/usr/bin/globaltokend}\n BITCOIND_NICE=${BITCOIND_NICE:-${NICELEVEL:-0}}\n BITCOIND_OPTS=\"${BITCOIND_OPTS:-${BITCOIN_OPTS}}\"\n \n name=\"Bitcoin Core Daemon\"\n description=\"Bitcoin cryptocurrency P2P network daemon\"\n \n-command=\"/usr/bin/bitcoind\"\n+command=\"/usr/bin/globaltokend\"\n command_args=\"-pid=\\\"${BITCOIND_PIDFILE}\\\" \\\n \t\t-conf=\\\"${BITCOIND_CONFIGFILE}\\\" \\\n \t\t-datadir=\\\"${BITCOIND_DATADIR}\\\" \\\n@@ -71,7 +71,7 @@ checkconfig()\n {\n \tif ! grep -qs '^rpcpassword=' \"${BITCOIND_CONFIGFILE}\" ; then\n \t\teerror \"\"\n-\t\teerror \"ERROR: You must set a secure rpcpassword to run bitcoind.\"\n+\t\teerror \"ERROR: You must set a secure rpcpassword to run globaltokend.\"\n \t\teerror \"The setting must appear in ${BITCOIND_CONFIGFILE}\"\n \t\teerror \"\"\n \t\teerror \"This password is security critical to securing wallets \""
      },
      {
        "sha": "7e3514d43996f674ed58a42c3615464ca46673fc",
        "filename": "contrib/init/bitcoind.openrcconf",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/init/bitcoind.openrcconf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/init/bitcoind.openrcconf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/bitcoind.openrcconf?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,31 +1,31 @@\n-# /etc/conf.d/bitcoind: config file for /etc/init.d/bitcoind\n+# /etc/conf.d/globaltokend: config file for /etc/init.d/globaltokend\n \n # Config file location\n #BITCOIND_CONFIGFILE=\"/etc/bitcoin/bitcoin.conf\"\n \n # What directory to write pidfile to?  (created and owned by $BITCOIND_USER)\n-#BITCOIND_PIDDIR=\"/var/run/bitcoind\"\n+#BITCOIND_PIDDIR=\"/var/run/globaltokend\"\n \n # What filename to give the pidfile\n-#BITCOIND_PIDFILE=\"${BITCOIND_PIDDIR}/bitcoind.pid\"\n+#BITCOIND_PIDFILE=\"${BITCOIND_PIDDIR}/globaltokend.pid\"\n \n-# Where to write bitcoind data (be mindful that the blockchain is large)\n-#BITCOIND_DATADIR=\"/var/lib/bitcoind\"\n+# Where to write globaltokend data (be mindful that the blockchain is large)\n+#BITCOIND_DATADIR=\"/var/lib/globaltokend\"\n \n-# User and group to own bitcoind process\n+# User and group to own globaltokend process\n #BITCOIND_USER=\"bitcoin\"\n #BITCOIND_GROUP=\"bitcoin\"\n \n-# Path to bitcoind executable\n-#BITCOIND_BIN=\"/usr/bin/bitcoind\"\n+# Path to globaltokend executable\n+#BITCOIND_BIN=\"/usr/bin/globaltokend\"\n \n-# Nice value to run bitcoind under\n+# Nice value to run globaltokend under\n #BITCOIND_NICE=0\n \n # Additional options (avoid -conf and -datadir, use flags above)\n #BITCOIND_OPTS=\"\"\n \n-# The timeout in seconds OpenRC will wait for bitcoind to terminate\n+# The timeout in seconds OpenRC will wait for globaltokend to terminate\n # after a SIGTERM has been raised.\n # Note that this will be mapped as argument to start-stop-daemon's\n # '--retry' option, which means you can specify a retry schedule"
      },
      {
        "sha": "d1f6ea1320fa250eefe093f8e156fb243aed3c39",
        "filename": "contrib/init/bitcoind.service",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/init/bitcoind.service",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/init/bitcoind.service",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/bitcoind.service?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -7,9 +7,9 @@ User=bitcoin\n Group=bitcoin\n \n Type=forking\n-PIDFile=/var/lib/bitcoind/bitcoind.pid\n-ExecStart=/usr/bin/bitcoind -daemon -pid=/var/lib/bitcoind/bitcoind.pid \\\n--conf=/etc/bitcoin/bitcoin.conf -datadir=/var/lib/bitcoind -disablewallet\n+PIDFile=/var/lib/globaltokend/globaltokend.pid\n+ExecStart=/usr/bin/globaltokend -daemon -pid=/var/lib/globaltokend/globaltokend.pid \\\n+-conf=/etc/bitcoin/bitcoin.conf -datadir=/var/lib/globaltokend -disablewallet\n \n Restart=always\n PrivateTmp=true"
      },
      {
        "sha": "32aaad03ef9909964495fe094c8b77d2a888f736",
        "filename": "contrib/init/org.bitcoin.bitcoind.plist",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/init/org.bitcoin.bitcoind.plist",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/init/org.bitcoin.bitcoind.plist",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/init/org.bitcoin.bitcoind.plist?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -3,10 +3,10 @@\n <plist version=\"1.0\">\n <dict>\n \t<key>Label</key>\n-\t<string>org.bitcoin.bitcoind</string>\n+\t<string>org.bitcoin.globaltokend</string>\n \t<key>ProgramArguments</key>\n \t<array>\n-\t\t<string>/usr/local/bin/bitcoind</string>\n+\t\t<string>/usr/local/bin/globaltokend</string>\n \t\t<string>-daemon</string>\n \t</array>\n \t<key>RunAtLoad</key>"
      },
      {
        "sha": "6665596fff271079bee2c3ee13e6f1440439477f",
        "filename": "contrib/linearize/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/linearize/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/linearize/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/README.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -21,7 +21,7 @@ standalone hash lists but safe to use with linearize-data.py, which will output\n the same data no matter which byte format is chosen.\n \n The `linearize-hashes` script requires a connection, local or remote, to a\n-JSON-RPC server. Running `bitcoind` or `bitcoin-qt -server` will be sufficient.\n+JSON-RPC server. Running `globaltokend` or `globaltoken-qt -server` will be sufficient.\n \n ## Step 2: Copy local block data\n \n@@ -39,7 +39,7 @@ will be printed.\n respectively, to the current time and to the timestamp of the most recent block\n written to the script's blockchain.\n * `genesis`: The hash of the genesis block in the blockchain.\n-* `input`: bitcoind blocks/ directory containing blkNNNNN.dat\n+* `input`: globaltokend blocks/ directory containing blkNNNNN.dat\n * `hashlist`: text file containing list of block hashes created by\n linearize-hashes.py.\n * `max_out_sz`: Maximum size for files created by the `output_file` option."
      },
      {
        "sha": "e3a14ea71c1752247a0e01ab6817b0c8434fcf8f",
        "filename": "contrib/linearize/example-linearize.cfg",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/linearize/example-linearize.cfg",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/linearize/example-linearize.cfg",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/example-linearize.cfg?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,4 +1,4 @@\n-# bitcoind RPC settings (linearize-hashes)\n+# globaltokend RPC settings (linearize-hashes)\n rpcuser=someuser\n rpcpassword=somepassword\n #datadir=~/.bitcoin"
      },
      {
        "sha": "4fa3cfa4ba15cebbccb7e54a8019d4c202a91514",
        "filename": "contrib/qos/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/qos/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/qos/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/qos/README.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -2,4 +2,4 @@\n \n This is a Linux bash script that will set up tc to limit the outgoing bandwidth for connections to the Bitcoin network. It limits outbound TCP traffic with a source or destination port of 8333, but not if the destination IP is within a LAN.\n \n-This means one can have an always-on bitcoind instance running, and another local bitcoind/bitcoin-qt instance which connects to this node and receives blocks from it.\n+This means one can have an always-on globaltokend instance running, and another local globaltokend/globaltoken-qt instance which connects to this node and receives blocks from it."
      },
      {
        "sha": "ebba5e93a0771c3200b9b91d907e07448d4c735c",
        "filename": "contrib/rpm/bitcoin.fc",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/rpm/bitcoin.fc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/rpm/bitcoin.fc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/rpm/bitcoin.fc?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,8 +1,8 @@\n /usr/bin/bitcoin-cli\t\t--\tgen_context(system_u:object_r:bitcoin_exec_t,s0)\n-/usr/sbin/bitcoind\t\t--\tgen_context(system_u:object_r:bitcoin_exec_t,s0)\n-/usr/lib(64)?/bitcoin/bitcoind\t\t--\tgen_context(system_u:object_r:bitcoin_exec_t,s0)\n+/usr/sbin/globaltokend\t\t--\tgen_context(system_u:object_r:bitcoin_exec_t,s0)\n+/usr/lib(64)?/bitcoin/globaltokend\t\t--\tgen_context(system_u:object_r:bitcoin_exec_t,s0)\n \n /etc/bitcoin(/.*)?\t\tgen_context(system_u:object_r:bitcoin_conf_t,s0)\n /var/lib/bitcoin(/.*)?\t\tgen_context(system_u:object_r:bitcoin_var_lib_t,s0)\n \n-(/var)?/run/bitcoind(/.*)?   gen_context(system_u:object_r:bitcoin_var_run_t,s0)\n+(/var)?/run/globaltokend(/.*)?   gen_context(system_u:object_r:bitcoin_var_run_t,s0)"
      },
      {
        "sha": "8cc2e65c90aa5e1e7720a327188c964b55a6f615",
        "filename": "contrib/rpm/bitcoin.spec",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/rpm/bitcoin.spec",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/rpm/bitcoin.spec",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/rpm/bitcoin.spec?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -27,13 +27,13 @@ Source1:\thttp://download.oracle.com/berkeley-db/db-%{bdbv}.NC.tar.gz\n Source10:\thttps://raw.githubusercontent.com/bitcoin/bitcoin/v%{version}/contrib/debian/examples/bitcoin.conf\n \n #man pages\n-Source20:\thttps://raw.githubusercontent.com/bitcoin/bitcoin/v%{version}/doc/man/bitcoind.1\n+Source20:\thttps://raw.githubusercontent.com/bitcoin/bitcoin/v%{version}/doc/man/globaltokend.1\n Source21:\thttps://raw.githubusercontent.com/bitcoin/bitcoin/v%{version}/doc/man/bitcoin-cli.1\n-Source22:\thttps://raw.githubusercontent.com/bitcoin/bitcoin/v%{version}/doc/man/bitcoin-qt.1\n+Source22:\thttps://raw.githubusercontent.com/bitcoin/bitcoin/v%{version}/doc/man/globaltoken-qt.1\n \n #selinux\n Source30:\thttps://raw.githubusercontent.com/bitcoin/bitcoin/v%{version}/contrib/rpm/bitcoin.te\n-# Source31 - what about bitcoin-tx and bench_bitcoin ???\n+# Source31 - what about globaltoken-tx and bench_bitcoin ???\n Source31:\thttps://raw.githubusercontent.com/bitcoin/bitcoin/v%{version}/contrib/rpm/bitcoin.fc\n Source32:\thttps://raw.githubusercontent.com/bitcoin/bitcoin/v%{version}/contrib/rpm/bitcoin.if\n \n@@ -142,7 +142,7 @@ This package provides several command line utilities for interacting with a\n bitcoin-core daemon.\n \n The bitcoin-cli utility allows you to communicate and control a bitcoin daemon\n-over RPC, the bitcoin-tx utility allows you to create a custom transaction, and\n+over RPC, the globaltoken-tx utility allows you to create a custom transaction, and\n the bench_bitcoin utility can be used to perform some benchmarks.\n \n This package contains utilities needed by the bitcoin-server package.\n@@ -182,12 +182,12 @@ popd\n make install DESTDIR=%{buildroot}\n \n mkdir -p -m755 %{buildroot}%{_sbindir}\n-mv %{buildroot}%{_bindir}/bitcoind %{buildroot}%{_sbindir}/bitcoind\n+mv %{buildroot}%{_bindir}/globaltokend %{buildroot}%{_sbindir}/globaltokend\n \n # systemd stuff\n mkdir -p %{buildroot}%{_tmpfilesdir}\n cat <<EOF > %{buildroot}%{_tmpfilesdir}/bitcoin.conf\n-d /run/bitcoind 0750 bitcoin bitcoin -\n+d /run/globaltokend 0750 bitcoin bitcoin -\n EOF\n touch -a -m -t 201504280000 %{buildroot}%{_tmpfilesdir}/bitcoin.conf\n \n@@ -202,7 +202,7 @@ OPTIONS=\"\"\n # Don't change these unless you know what you're doing.\n CONFIG_FILE=\"%{_sysconfdir}/bitcoin/bitcoin.conf\"\n DATA_DIR=\"%{_localstatedir}/lib/bitcoin\"\n-PID_FILE=\"/run/bitcoind/bitcoind.pid\"\n+PID_FILE=\"/run/globaltokend/globaltokend.pid\"\n EOF\n touch -a -m -t 201504280000 %{buildroot}%{_sysconfdir}/sysconfig/bitcoin\n \n@@ -214,7 +214,7 @@ After=syslog.target network.target\n \n [Service]\n Type=forking\n-ExecStart=%{_sbindir}/bitcoind -daemon -conf=\\${CONFIG_FILE} -datadir=\\${DATA_DIR} -pid=\\${PID_FILE} \\$OPTIONS\n+ExecStart=%{_sbindir}/globaltokend -daemon -conf=\\${CONFIG_FILE} -datadir=\\${DATA_DIR} -pid=\\${PID_FILE} \\$OPTIONS\n EnvironmentFile=%{_sysconfdir}/sysconfig/bitcoin\n User=bitcoin\n Group=bitcoin\n@@ -269,7 +269,7 @@ Name=Bitcoin\n Comment=Bitcoin P2P Cryptocurrency\n Comment[fr]=Bitcoin, monnaie virtuelle cryptographique pair \u00e0 pair\n Comment[tr]=Bitcoin, e\u015ften e\u015fe kriptografik sanal para birimi\n-Exec=bitcoin-qt %u\n+Exec=globaltoken-qt %u\n Terminal=false\n Type=Application\n Icon=bitcoin128\n@@ -284,7 +284,7 @@ touch -a -m -t 201511100546 %{buildroot}%{_datadir}/applications/bitcoin-core.de\n mkdir -p %{buildroot}%{_datadir}/kde4/services\n cat <<EOF > %{buildroot}%{_datadir}/kde4/services/bitcoin-core.protocol\n [Protocol]\n-exec=bitcoin-qt '%u'\n+exec=globaltoken-qt '%u'\n protocol=bitcoin\n input=none\n output=none\n@@ -300,10 +300,10 @@ touch -a -m -t 201511100546 %{buildroot}%{_datadir}/kde4/services/bitcoin-core.p\n %endif\n \n # man pages\n-install -D -p %{SOURCE20} %{buildroot}%{_mandir}/man1/bitcoind.1\n+install -D -p %{SOURCE20} %{buildroot}%{_mandir}/man1/globaltokend.1\n install -p %{SOURCE21} %{buildroot}%{_mandir}/man1/bitcoin-cli.1\n %if %{_buildqt}\n-install -p %{SOURCE22} %{buildroot}%{_mandir}/man1/bitcoin-qt.1\n+install -p %{SOURCE22} %{buildroot}%{_mandir}/man1/globaltoken-qt.1\n %endif\n \n # nuke these, we do extensive testing of binaries in %%check before packaging\n@@ -372,15 +372,15 @@ rm -rf %{buildroot}\n %defattr(-,root,root,-)\n %license COPYING db-%{bdbv}.NC-LICENSE\n %doc COPYING bitcoin.conf.example doc/README.md doc/bips.md doc/files.md doc/multiwallet-qt.md doc/reduce-traffic.md doc/release-notes.md doc/tor.md\n-%attr(0755,root,root) %{_bindir}/bitcoin-qt\n+%attr(0755,root,root) %{_bindir}/globaltoken-qt\n %attr(0644,root,root) %{_datadir}/applications/bitcoin-core.desktop\n %attr(0644,root,root) %{_datadir}/kde4/services/bitcoin-core.protocol\n %attr(0644,root,root) %{_datadir}/pixmaps/*.ico\n %attr(0644,root,root) %{_datadir}/pixmaps/*.bmp\n %attr(0644,root,root) %{_datadir}/pixmaps/*.svg\n %attr(0644,root,root) %{_datadir}/pixmaps/*.png\n %attr(0644,root,root) %{_datadir}/pixmaps/*.xpm\n-%attr(0644,root,root) %{_mandir}/man1/bitcoin-qt.1*\n+%attr(0644,root,root) %{_mandir}/man1/globaltoken-qt.1*\n %endif\n \n %files libs\n@@ -403,21 +403,21 @@ rm -rf %{buildroot}\n %defattr(-,root,root,-)\n %license COPYING db-%{bdbv}.NC-LICENSE\n %doc COPYING bitcoin.conf.example doc/README.md doc/REST-interface.md doc/bips.md doc/dnsseed-policy.md doc/files.md doc/reduce-traffic.md doc/release-notes.md doc/tor.md\n-%attr(0755,root,root) %{_sbindir}/bitcoind\n+%attr(0755,root,root) %{_sbindir}/globaltokend\n %attr(0644,root,root) %{_tmpfilesdir}/bitcoin.conf\n %attr(0644,root,root) %{_unitdir}/bitcoin.service\n %dir %attr(0750,bitcoin,bitcoin) %{_sysconfdir}/bitcoin\n %dir %attr(0750,bitcoin,bitcoin) %{_localstatedir}/lib/bitcoin\n %config(noreplace) %attr(0600,root,root) %{_sysconfdir}/sysconfig/bitcoin\n %attr(0644,root,root) %{_datadir}/selinux/*/*.pp\n-%attr(0644,root,root) %{_mandir}/man1/bitcoind.1*\n+%attr(0644,root,root) %{_mandir}/man1/globaltokend.1*\n \n %files utils\n %defattr(-,root,root,-)\n %license COPYING\n %doc COPYING bitcoin.conf.example doc/README.md\n %attr(0755,root,root) %{_bindir}/bitcoin-cli\n-%attr(0755,root,root) %{_bindir}/bitcoin-tx\n+%attr(0755,root,root) %{_bindir}/globaltoken-tx\n %attr(0755,root,root) %{_bindir}/bench_bitcoin\n %attr(0644,root,root) %{_mandir}/man1/bitcoin-cli.1*\n "
      },
      {
        "sha": "114c71ae5a3581ddb136d76256f317e61d2c8e33",
        "filename": "contrib/zmq/zmq_sub.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/zmq/zmq_sub.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/zmq/zmq_sub.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/zmq/zmq_sub.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -7,7 +7,7 @@\n     ZMQ example using python3's asyncio\n \n     Bitcoin should be started with the command line arguments:\n-        bitcoind -testnet -daemon \\\n+        globaltokend -testnet -daemon \\\n                 -zmqpubhashblock=tcp://127.0.0.1:28332 \\\n                 -zmqpubrawtx=tcp://127.0.0.1:28332 \\\n                 -zmqpubhashtx=tcp://127.0.0.1:28332 \\"
      },
      {
        "sha": "a433d8966c348236acdc402079bf6eac1e4fef17",
        "filename": "contrib/zmq/zmq_sub3.4.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/zmq/zmq_sub3.4.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/contrib/zmq/zmq_sub3.4.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/zmq/zmq_sub3.4.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -7,7 +7,7 @@\n     ZMQ example using python3's asyncio\n \n     Bitcoin should be started with the command line arguments:\n-        bitcoind -testnet -daemon \\\n+        globaltokend -testnet -daemon \\\n                 -zmqpubhashblock=tcp://127.0.0.1:28332 \\\n                 -zmqpubrawtx=tcp://127.0.0.1:28332 \\\n                 -zmqpubhashtx=tcp://127.0.0.1:28332 \\"
      },
      {
        "sha": "2ae6adb9e0e21e600983b27c9b02e56378a8e431",
        "filename": "doc/README.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -15,12 +15,12 @@ The following are some helpful notes on how to run Bitcoin on your native platfo\n \n Unpack the files into a directory and run:\n \n-- `bin/bitcoin-qt` (GUI) or\n-- `bin/bitcoind` (headless)\n+- `bin/globaltoken-qt` (GUI) or\n+- `bin/globaltokend` (headless)\n \n ### Windows\n \n-Unpack the files into a directory, and then run bitcoin-qt.exe.\n+Unpack the files into a directory, and then run globaltoken-qt.exe.\n \n ### OS X\n "
      },
      {
        "sha": "58a6e36ce91f4b9f56351956a38efd309b918645",
        "filename": "doc/README_windows.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/README_windows.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/README_windows.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README_windows.txt?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -11,7 +11,7 @@ with each other, with the help of a P2P network to check for double-spending.\n \r\n Setup\r\n -----\r\n-Unpack the files into a directory and run bitcoin-qt.exe.\r\n+Unpack the files into a directory and run globaltoken-qt.exe.\r\n \r\n Bitcoin Core is the original Bitcoin client and it builds the backbone of the network.\r\n However, it downloads and stores the entire history of Bitcoin transactions;\r"
      },
      {
        "sha": "9f86ee6dc0fbdf8a4ac03b48c110f7e8a654b829",
        "filename": "doc/REST-interface.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/REST-interface.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/REST-interface.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/REST-interface.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -99,4 +99,4 @@ Only supports JSON as output format.\n \n Risks\n -------------\n-Running a web browser on the same node with a REST enabled bitcoind can be a risk. Accessing prepared XSS websites could read out tx/block data of your node by placing links like `<script src=\"http://127.0.0.1:8332/rest/tx/1234567890.json\">` which might break the nodes privacy.\n+Running a web browser on the same node with a REST enabled globaltokend can be a risk. Accessing prepared XSS websites could read out tx/block data of your node by placing links like `<script src=\"http://127.0.0.1:8332/rest/tx/1234567890.json\">` which might break the nodes privacy."
      },
      {
        "sha": "a0cce2bd828115f3ec0c2ddcb4f5870f6407e4d5",
        "filename": "doc/build-openbsd.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/build-openbsd.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/build-openbsd.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-openbsd.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -2,7 +2,7 @@ OpenBSD build guide\n ======================\n (updated for OpenBSD 6.0)\n \n-This guide describes how to build bitcoind and command-line utilities on OpenBSD.\n+This guide describes how to build globaltokend and command-line utilities on OpenBSD.\n \n As OpenBSD is most common as a server OS, we will not bother with the GUI.\n "
      },
      {
        "sha": "aec3bccf80de63ac8527836022c0fb2f74f203e6",
        "filename": "doc/build-osx.md",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/build-osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/build-osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-osx.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -53,15 +53,15 @@ Build Bitcoin Core\n Running\n -------\n \n-Bitcoin Core is now available at `./src/bitcoind`\n+Bitcoin Core is now available at `./src/globaltokend`\n \n Before running, it's recommended you create an RPC configuration file.\n \n     echo -e \"rpcuser=bitcoinrpc\\nrpcpassword=$(xxd -l 16 -p /dev/urandom)\" > \"/Users/${USER}/Library/Application Support/Bitcoin/bitcoin.conf\"\n \n     chmod 600 \"/Users/${USER}/Library/Application Support/Bitcoin/bitcoin.conf\"\n \n-The first time you run bitcoind, it will start downloading the blockchain. This process could take several hours.\n+The first time you run globaltokend, it will start downloading the blockchain. This process could take several hours.\n \n You can monitor the download process by looking at the debug.log file:\n \n@@ -70,7 +70,7 @@ You can monitor the download process by looking at the debug.log file:\n Other commands:\n -------\n \n-    ./src/bitcoind -daemon # Starts the bitcoin daemon.\n+    ./src/globaltokend -daemon # Starts the bitcoin daemon.\n     ./src/bitcoin-cli --help # Outputs a list of command-line options.\n     ./src/bitcoin-cli help # Outputs a list of RPC commands when the daemon is running.\n \n@@ -83,7 +83,7 @@ Uncheck everything except Qt Creator during the installation process.\n 1. Make sure you installed everything through Homebrew mentioned above\n 2. Do a proper ./configure --enable-debug\n 3. In Qt Creator do \"New Project\" -> Import Project -> Import Existing Project\n-4. Enter \"bitcoin-qt\" as project name, enter src/qt as location\n+4. Enter \"globaltoken-qt\" as project name, enter src/qt as location\n 5. Leave the file selection as it is\n 6. Confirm the \"summary page\"\n 7. In the \"Projects\" tab select \"Manage Kits...\""
      },
      {
        "sha": "01a22738ea10b48ab75a7a66bfad5cb9d3bee580",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -24,7 +24,7 @@ make\n make install # optional\n ```\n \n-This will build bitcoin-qt as well if the dependencies are met.\n+This will build globaltoken-qt as well if the dependencies are met.\n \n Dependencies\n ---------------------\n@@ -124,7 +124,7 @@ libqrencode (optional) can be installed with:\n \n     sudo apt-get install libqrencode-dev\n \n-Once these are installed, they will be found by configure and a bitcoin-qt executable will be\n+Once these are installed, they will be found by configure and a globaltoken-qt executable will be\n built by default.\n \n Dependency Build Instructions: Fedora\n@@ -147,7 +147,7 @@ libqrencode (optional) can be installed with:\n \n Notes\n -----\n-The release is built with GCC and then \"strip bitcoind\" to strip the debug\n+The release is built with GCC and then \"strip globaltokend\" to strip the debug\n symbols, which reduces the executable size by about 90%.\n \n "
      },
      {
        "sha": "e9d8e29d76e114168a2f41c2020852c8f3ba050c",
        "filename": "doc/files.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/files.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/files.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/files.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,14 +1,14 @@\n \n * banlist.dat: stores the IPs/Subnets of banned nodes\n-* bitcoin.conf: contains configuration settings for bitcoind or bitcoin-qt\n-* bitcoind.pid: stores the process id of bitcoind while running\n+* bitcoin.conf: contains configuration settings for globaltokend or globaltoken-qt\n+* globaltokend.pid: stores the process id of globaltokend while running\n * blocks/blk000??.dat: block data (custom, 128 MiB per file); since 0.8.0\n * blocks/rev000??.dat; block undo data (custom); since 0.8.0 (format changed since pre-0.8)\n * blocks/index/*; block index (LevelDB); since 0.8.0\n * chainstate/*; block chain state database (LevelDB); since 0.8.0\n * database/*: BDB database environment; only used for wallet since 0.8.0\n * db.log: wallet database log file\n-* debug.log: contains debug information and general logging generated by bitcoind or bitcoin-qt\n+* debug.log: contains debug information and general logging generated by globaltokend or globaltoken-qt\n * fee_estimates.dat: stores statistics used to estimate minimum transaction fees and priorities required for confirmation; since 0.10.0\n * mempool.dat: dump of the mempool's transactions; since 0.14.0.\n * peers.dat: peer IP address database (custom format); since 0.7.0"
      },
      {
        "sha": "a3b556e434a3f171bb282465b58eb4b2b7cc0e26",
        "filename": "doc/init.md",
        "status": "modified",
        "additions": 32,
        "deletions": 32,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/init.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/init.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/init.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,44 +1,44 @@\n-Sample init scripts and service configuration for bitcoind\n+Sample init scripts and service configuration for globaltokend\n ==========================================================\n \n Sample scripts and configuration files for systemd, Upstart and OpenRC\n can be found in the contrib/init folder.\n \n-    contrib/init/bitcoind.service:    systemd service unit configuration\n-    contrib/init/bitcoind.openrc:     OpenRC compatible SysV style init script\n-    contrib/init/bitcoind.openrcconf: OpenRC conf.d file\n-    contrib/init/bitcoind.conf:       Upstart service configuration file\n-    contrib/init/bitcoind.init:       CentOS compatible SysV style init script\n+    contrib/init/globaltokend.service:    systemd service unit configuration\n+    contrib/init/globaltokend.openrc:     OpenRC compatible SysV style init script\n+    contrib/init/globaltokend.openrcconf: OpenRC conf.d file\n+    contrib/init/globaltokend.conf:       Upstart service configuration file\n+    contrib/init/globaltokend.init:       CentOS compatible SysV style init script\n \n 1. Service User\n ---------------------------------\n \n All three Linux startup configurations assume the existence of a \"bitcoin\" user\n and group.  They must be created before attempting to use these scripts.\n-The OS X configuration assumes bitcoind will be set up for the current user.\n+The OS X configuration assumes globaltokend will be set up for the current user.\n \n 2. Configuration\n ---------------------------------\n \n-At a bare minimum, bitcoind requires that the rpcpassword setting be set\n+At a bare minimum, globaltokend requires that the rpcpassword setting be set\n when running as a daemon.  If the configuration file does not exist or this\n-setting is not set, bitcoind will shutdown promptly after startup.\n+setting is not set, globaltokend will shutdown promptly after startup.\n \n This password does not have to be remembered or typed as it is mostly used\n-as a fixed token that bitcoind and client programs read from the configuration\n+as a fixed token that globaltokend and client programs read from the configuration\n file, however it is recommended that a strong and secure password be used\n as this password is security critical to securing the wallet should the\n wallet be enabled.\n \n-If bitcoind is run with the \"-server\" flag (set by default), and no rpcpassword is set,\n+If globaltokend is run with the \"-server\" flag (set by default), and no rpcpassword is set,\n it will use a special cookie file for authentication. The cookie is generated with random\n content when the daemon starts, and deleted when it exits. Read access to this file\n controls who can access it through RPC.\n \n By default the cookie is stored in the data directory, but it's location can be overridden\n with the option '-rpccookiefile'.\n \n-This allows for running bitcoind without having to do any manual configuration.\n+This allows for running globaltokend without having to do any manual configuration.\n \n `conf`, `pid`, and `wallet` accept relative paths which are interpreted as\n relative to the data directory. `wallet` *only* supports relative paths.\n@@ -53,21 +53,21 @@ see `contrib/debian/examples/bitcoin.conf`.\n \n All three configurations assume several paths that might need to be adjusted.\n \n-Binary:              `/usr/bin/bitcoind`  \n+Binary:              `/usr/bin/globaltokend`  \n Configuration file:  `/etc/bitcoin/bitcoin.conf`  \n-Data directory:      `/var/lib/bitcoind`  \n-PID file:            `/var/run/bitcoind/bitcoind.pid` (OpenRC and Upstart) or `/var/lib/bitcoind/bitcoind.pid` (systemd)  \n-Lock file:           `/var/lock/subsys/bitcoind` (CentOS)  \n+Data directory:      `/var/lib/globaltokend`  \n+PID file:            `/var/run/globaltokend/globaltokend.pid` (OpenRC and Upstart) or `/var/lib/globaltokend/globaltokend.pid` (systemd)  \n+Lock file:           `/var/lock/subsys/globaltokend` (CentOS)  \n \n The configuration file, PID directory (if applicable) and data directory\n should all be owned by the bitcoin user and group.  It is advised for security\n reasons to make the configuration file and data directory only readable by the\n-bitcoin user and group.  Access to bitcoin-cli and other bitcoind rpc clients\n+bitcoin user and group.  Access to bitcoin-cli and other globaltokend rpc clients\n can then be controlled by group membership.\n \n 3b) Mac OS X\n \n-Binary:              `/usr/local/bin/bitcoind`  \n+Binary:              `/usr/local/bin/globaltokend`  \n Configuration file:  `~/Library/Application Support/Bitcoin/bitcoin.conf`  \n Data directory:      `~/Library/Application Support/Bitcoin`\n Lock file:           `~/Library/Application Support/Bitcoin/.lock`\n@@ -81,41 +81,41 @@ Installing this .service file consists of just copying it to\n /usr/lib/systemd/system directory, followed by the command\n `systemctl daemon-reload` in order to update running systemd configuration.\n \n-To test, run `systemctl start bitcoind` and to enable for system startup run\n-`systemctl enable bitcoind`\n+To test, run `systemctl start globaltokend` and to enable for system startup run\n+`systemctl enable globaltokend`\n \n 4b) OpenRC\n \n-Rename bitcoind.openrc to bitcoind and drop it in /etc/init.d.  Double\n+Rename globaltokend.openrc to globaltokend and drop it in /etc/init.d.  Double\n check ownership and permissions and make it executable.  Test it with\n-`/etc/init.d/bitcoind start` and configure it to run on startup with\n-`rc-update add bitcoind`\n+`/etc/init.d/globaltokend start` and configure it to run on startup with\n+`rc-update add globaltokend`\n \n 4c) Upstart (for Debian/Ubuntu based distributions)\n \n-Drop bitcoind.conf in /etc/init.  Test by running `service bitcoind start`\n+Drop globaltokend.conf in /etc/init.  Test by running `service globaltokend start`\n it will automatically start on reboot.\n \n NOTE: This script is incompatible with CentOS 5 and Amazon Linux 2014 as they\n use old versions of Upstart and do not supply the start-stop-daemon utility.\n \n 4d) CentOS\n \n-Copy bitcoind.init to /etc/init.d/bitcoind. Test by running `service bitcoind start`.\n+Copy globaltokend.init to /etc/init.d/globaltokend. Test by running `service globaltokend start`.\n \n-Using this script, you can adjust the path and flags to the bitcoind program by\n+Using this script, you can adjust the path and flags to the globaltokend program by\n setting the BITCOIND and FLAGS environment variables in the file\n-/etc/sysconfig/bitcoind. You can also use the DAEMONOPTS environment variable here.\n+/etc/sysconfig/globaltokend. You can also use the DAEMONOPTS environment variable here.\n \n 4e) Mac OS X\n \n-Copy org.bitcoin.bitcoind.plist into ~/Library/LaunchAgents. Load the launch agent by\n-running `launchctl load ~/Library/LaunchAgents/org.bitcoin.bitcoind.plist`.\n+Copy org.bitcoin.globaltokend.plist into ~/Library/LaunchAgents. Load the launch agent by\n+running `launchctl load ~/Library/LaunchAgents/org.bitcoin.globaltokend.plist`.\n \n-This Launch Agent will cause bitcoind to start whenever the user logs in.\n+This Launch Agent will cause globaltokend to start whenever the user logs in.\n \n-NOTE: This approach is intended for those wanting to run bitcoind as the current user.\n-You will need to modify org.bitcoin.bitcoind.plist if you intend to use it as a\n+NOTE: This approach is intended for those wanting to run globaltokend as the current user.\n+You will need to modify org.bitcoin.globaltokend.plist if you intend to use it as a\n Launch Daemon with a dedicated bitcoin user.\n \n 5. Auto-respawn"
      },
      {
        "sha": "ed0cdb4a837eafa4b4aaa5e2744124fdb52cc9a9",
        "filename": "doc/man/Makefile.am",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/man/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/man/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/man/Makefile.am?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,13 +1,13 @@\n dist_man1_MANS=\n \n if BUILD_BITCOIND\n-  dist_man1_MANS+=bitcoind.1\n+  dist_man1_MANS+=globaltokend.1\n endif\n \n if ENABLE_QT\n-  dist_man1_MANS+=bitcoin-qt.1\n+  dist_man1_MANS+=globaltoken-qt.1\n endif\n \n if BUILD_BITCOIN_UTILS\n-  dist_man1_MANS+=bitcoin-cli.1 bitcoin-tx.1\n+  dist_man1_MANS+=bitcoin-cli.1 globaltoken-tx.1\n endif"
      },
      {
        "sha": "9ec09b3762b0ad02e8ce20400fbdb82500100f30",
        "filename": "doc/man/bitcoin-qt.1",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/man/bitcoin-qt.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/man/bitcoin-qt.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/man/bitcoin-qt.1?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,7 +1,7 @@\n .\\\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.4.\n-.TH BITCOIN-QT \"1\" \"February 2017\" \"bitcoin-qt v0.14.99.0\" \"User Commands\"\n+.TH BITCOIN-QT \"1\" \"February 2017\" \"globaltoken-qt v0.14.99.0\" \"User Commands\"\n .SH NAME\n-bitcoin-qt \\- manual page for bitcoin-qt v0.14.99.0\n+globaltoken-qt \\- manual page for globaltoken-qt v0.14.99.0\n .SH DESCRIPTION\n Bitcoin Core version v0.14.99.0 (64\\-bit)\n Usage:\n@@ -77,7 +77,7 @@ leave that many cores free, default: 0)\n .HP\n \\fB\\-pid=\\fR<file>\n .IP\n-Specify pid file (default: bitcoind.pid)\n+Specify pid file (default: globaltokend.pid)\n .HP\n \\fB\\-prune=\\fR<n>\n .IP"
      },
      {
        "sha": "76b86423353245579a6ab7a8ae79659ae1d324e6",
        "filename": "doc/man/bitcoin-tx.1",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/man/bitcoin-tx.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/man/bitcoin-tx.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/man/bitcoin-tx.1?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,7 +1,7 @@\n .\\\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.4.\n-.TH BITCOIN-TX \"1\" \"February 2017\" \"bitcoin-tx v0.14.99.0\" \"User Commands\"\n+.TH BITCOIN-TX \"1\" \"February 2017\" \"globaltoken-tx v0.14.99.0\" \"User Commands\"\n .SH NAME\n-bitcoin-tx \\- manual page for bitcoin-tx v0.14.99.0\n+globaltoken-tx \\- manual page for globaltoken-tx v0.14.99.0\n .SH DESCRIPTION\n Bitcoin Core bitcoin\\-tx utility version v0.14.99.0\n .SS \"Usage:\""
      },
      {
        "sha": "5635e404e6d901b1810944342a4476de54fc2da3",
        "filename": "doc/man/bitcoind.1",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/man/bitcoind.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/man/bitcoind.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/man/bitcoind.1?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,12 +1,12 @@\n .\\\" DO NOT MODIFY THIS FILE!  It was generated by help2man 1.47.4.\n-.TH BITCOIND \"1\" \"February 2017\" \"bitcoind v0.14.99.0\" \"User Commands\"\n+.TH BITCOIND \"1\" \"February 2017\" \"globaltokend v0.14.99.0\" \"User Commands\"\n .SH NAME\n-bitcoind \\- manual page for bitcoind v0.14.99.0\n+globaltokend \\- manual page for globaltokend v0.14.99.0\n .SH DESCRIPTION\n Bitcoin Core Daemon version v0.14.99.0\n .SS \"Usage:\"\n .TP\n-bitcoind [options]\n+globaltokend [options]\n Start Bitcoin Core Daemon\n .SH OPTIONS\n .HP\n@@ -82,7 +82,7 @@ leave that many cores free, default: 0)\n .HP\n \\fB\\-pid=\\fR<file>\n .IP\n-Specify pid file (default: bitcoind.pid)\n+Specify pid file (default: globaltokend.pid)\n .HP\n \\fB\\-prune=\\fR<n>\n .IP"
      },
      {
        "sha": "446ec1798c9e2886089d1e5f301b4e8a242f2e80",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -64,13 +64,13 @@ Low-level RPC changes\n   or subnet is invalid. Previously returned RPC_CLIENT_NODE_ALREADY_ADDED.\n   - `setban` now returns RPC_CLIENT_INVALID_IP_OR_SUBNET if the user tries to unban\n   a node that has not previously been banned. Previously returned RPC_MISC_ERROR.\n-  - `removeprunedfunds` now returns RPC_WALLET_ERROR if bitcoind is unable to remove\n+  - `removeprunedfunds` now returns RPC_WALLET_ERROR if globaltokend is unable to remove\n   the transaction. Previously returned RPC_INTERNAL_ERROR.\n   - `removeprunedfunds` now returns RPC_INVALID_PARAMETER if the transaction does not\n   exist in the wallet. Previously returned RPC_INTERNAL_ERROR.\n   - `fundrawtransaction` now returns RPC_INVALID_ADDRESS_OR_KEY if an invalid change\n   address is provided. Previously returned RPC_INVALID_PARAMETER.\n-  - `fundrawtransaction` now returns RPC_WALLET_ERROR if bitcoind is unable to create\n+  - `fundrawtransaction` now returns RPC_WALLET_ERROR if globaltokend is unable to create\n   the transaction. The error message provides further details. Previously returned\n   RPC_INTERNAL_ERROR.\n   - `bumpfee` now returns RPC_INVALID_PARAMETER if the provided transaction has"
      },
      {
        "sha": "24c72d09d36ea8fe558ced83ba4a33d99047c7ec",
        "filename": "doc/release-notes/release-notes-0.10.0.md",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.10.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.10.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.10.0.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -18,7 +18,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n Downgrading warning\n ---------------------\n@@ -252,17 +252,17 @@ actually using them on mainnet has been previously inconvenient as\n standard Bitcoin Core nodes wouldn't relay them to miners, nor would\n most miners include them in blocks they mined.\n \n-bitcoin-tx\n+globaltoken-tx\n ----------\n \n-It has been observed that many of the RPC functions offered by bitcoind are\n-\"pure functions\", and operate independently of the bitcoind wallet. This\n+It has been observed that many of the RPC functions offered by globaltokend are\n+\"pure functions\", and operate independently of the globaltokend wallet. This\n included many of the RPC \"raw transaction\" API functions, such as\n createrawtransaction.\n \n-bitcoin-tx is a newly introduced command line utility designed to enable easy\n+globaltoken-tx is a newly introduced command line utility designed to enable easy\n manipulation of bitcoin transactions. A summary of its operation may be\n-obtained via \"bitcoin-tx --help\" Transactions may be created or signed in a\n+obtained via \"globaltoken-tx --help\" Transactions may be created or signed in a\n manner similar to the RPC raw tx API. Transactions may be updated, deleting\n inputs or outputs, or appending new inputs and outputs. Custom scripts may be\n easily composed using a simple text notation, borrowed from the bitcoin test\n@@ -340,7 +340,7 @@ RPC:\n - `f923c07` Support IPv6 lookup in bitcoin-cli even when IPv6 only bound on localhost\n - `b641c9c` Fix addnode \"onetry\": Connect with OpenNetworkConnection\n - `171ca77` estimatefee / estimatepriority RPC methods\n-- `b750cf1` Remove cli functionality from bitcoind\n+- `b750cf1` Remove cli functionality from globaltokend\n - `f6984e8` Add \"chain\" to getmininginfo, improve help in getblockchaininfo\n - `99ddc6c` Add nLocalServices info to RPC getinfo\n - `cf0c47b` Remove getwork() RPC call\n@@ -391,7 +391,7 @@ Command-line options:\n - `4278b1d` Clarify error message when invalid -rpcallowip\n - `6b407e4` -datadir is now allowed in config files\n - `bdd5b58` Add option `-sysperms` to disable 077 umask (create new files with system default umask)\n-- `cbe39a3` Add \"bitcoin-tx\" command line utility and supporting modules\n+- `cbe39a3` Add \"globaltoken-tx\" command line utility and supporting modules\n - `dbca89b` Trigger -alertnotify if network is upgrading without you\n - `ad96e7c` Make -reindex cope with out-of-order blocks\n - `16d5194` Skip reindexed blocks individually\n@@ -492,7 +492,7 @@ Build system:\n - `9ce0774` build: Fix windows configure when using --with-qt-libdir\n - `ea96475` build: Add mention of --disable-wallet to bdb48 error messages\n - `1dec09b` depends: add shared dependency builder\n-- `c101c76` build: Add --with-utils (bitcoin-cli and bitcoin-tx, default=yes). Help string consistency tweaks. Target sanity check fix\n+- `c101c76` build: Add --with-utils (bitcoin-cli and globaltoken-tx, default=yes). Help string consistency tweaks. Target sanity check fix\n - `e432a5f` build: add option for reducing exports (v2)\n - `6134b43` Fixing condition 'sabotaging' MSVC build\n - `af0bd5e` osx: fix signing to make Gatekeeper happy (again)\n@@ -585,8 +585,8 @@ Tests:\n - `4cac5db` script tests: value with trailing 0x00 is true\n - `89101c6` script test: test case for 5-byte bools\n - `d2d9dc0` script tests: add tests for CHECKMULTISIG limits\n-- `d789386` Add \"it works\" test for bitcoin-tx\n-- `df4d61e` Add bitcoin-tx tests\n+- `d789386` Add \"it works\" test for globaltoken-tx\n+- `df4d61e` Add globaltoken-tx tests\n - `aa41ac2` Test IsPushOnly() with invalid push\n - `6022b5d` Make `script_{valid,invalid}.json` validation flags configurable\n - `8138cbe` Add automatic script test generation, and actual checksig tests\n@@ -598,7 +598,7 @@ Tests:\n - `2b62e17` Clearly separate PUSHDATA and numeric argument MINIMALDATA tests\n - `16d78bd` Add valid invert of invalid every numeric opcode tests\n - `f635269` tests: enable alertnotify test for Windows\n-- `7a41614` tests: allow rpc-tests to get filenames for bitcoind and bitcoin-cli from the environment\n+- `7a41614` tests: allow rpc-tests to get filenames for globaltokend and bitcoin-cli from the environment\n - `5122ea7` tests: fix forknotify.py on windows\n - `fa7f8cd` tests: remove old pull-tester scripts\n - `7667850` tests: replace the old (unused since Travis) tests with new rpc test scripts\n@@ -635,7 +635,7 @@ Miscellaneous:\n - `cd01a5e` Enable paranoid corruption checks in LevelDB >= 1.16\n - `9365937` Add comment about never updating nTimeOffset past 199 samples\n - `403c1bf` contrib: remove getwork-based pyminer (as getwork API call has been removed)\n-- `0c3e101` contrib: Added systemd .service file in order to help distributions integrate bitcoind\n+- `0c3e101` contrib: Added systemd .service file in order to help distributions integrate globaltokend\n - `0a0878d` doc: Add new DNSseed policy\n - `2887bff` Update coding style and add .clang-format\n - `5cbda4f` Changed LevelDB cursors to use scoped pointers to ensure destruction when going out of scope"
      },
      {
        "sha": "2dfc4e4c68b91f2289331b0d3e18f7fa21871062",
        "filename": "doc/release-notes/release-notes-0.10.1.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.10.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.10.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.10.1.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -18,7 +18,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n Downgrade warning\n ------------------"
      },
      {
        "sha": "70a76607b760ec1a022ad3c17ecda2745cb0da7f",
        "filename": "doc/release-notes/release-notes-0.10.2.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.10.2.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.10.2.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.10.2.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -18,7 +18,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n Downgrade warning\n ------------------"
      },
      {
        "sha": "1dde2a4eb4326ce6ca64c655785858eeaba08204",
        "filename": "doc/release-notes/release-notes-0.10.3.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.10.3.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.10.3.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.10.3.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -18,7 +18,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n Downgrade warning\n ------------------"
      },
      {
        "sha": "4a70cd96cd2e404327c716f12301926e475647a6",
        "filename": "doc/release-notes/release-notes-0.10.4.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.10.4.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.10.4.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.10.4.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -19,7 +19,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n Downgrade warning\n ------------------\n@@ -129,8 +129,8 @@ git merge commit are mentioned.\n - #6953 `a2f2fb6` build: disable -Wself-assign\n - #6953 `cf67d8b` Bugfix: Allow mining on top of old tip blocks for testnet (fixes testnet-in-a-box use case)\n - #6953 `b3964e3` Drop \"with minimal dependencies\" from description\n-- #6953 `43c2789` Split bitcoin-tx into its own package\n-- #6953 `dfe0d4d` Include bitcoin-tx binary on Debian/Ubuntu\n+- #6953 `43c2789` Split globaltoken-tx into its own package\n+- #6953 `dfe0d4d` Include globaltoken-tx binary on Debian/Ubuntu\n - #6953 `612efe8` [Qt] Raise debug window when requested\n - #6953 `3ad96bd` Fix locking in GetTransaction\n - #6953 `9c81005` Fix spelling of Qt"
      },
      {
        "sha": "1ef1e247782da8c925a9b49bcf92eb18e36b875a",
        "filename": "doc/release-notes/release-notes-0.11.0.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.11.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.11.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.11.0.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -18,7 +18,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n Downgrade warning\n ------------------\n@@ -396,7 +396,7 @@ git merge commit are mentioned.\n - #5839 `86eb461` keys: remove libsecp256k1 verification until it's actually supported\n - #5749 `d734d87` Help messages correctly formatted (79 chars)\n - #5884 `7077fe6` BUGFIX: Stack around the variable 'rv' was corrupted\n-- #5849 `41259ca` contrib/init/bitcoind.openrc: Compatibility with previous OpenRC init script variables\n+- #5849 `41259ca` contrib/init/globaltokend.openrc: Compatibility with previous OpenRC init script variables\n - #5950 `41113e3` Fix locale fallback and guard tests against invalid locale settings\n - #5965 `7c6bfb1` Add git-subtree-check.sh script\n - #6033 `1623f6e` FreeBSD, OpenBSD thread renaming\n@@ -406,7 +406,7 @@ git merge commit are mentioned.\n - #5964 `b4c219b` Lightweight task scheduler\n - #6116 `30dc3c1` [OSX] rename Bitcoin-Qt.app to Bitcoin-Core.app\n - #6168 `b3024f0` contrib/linearize: Support linearization of testnet blocks\n-- #6098 `7708fcd` Update Windows resource files (and add one for bitcoin-tx)\n+- #6098 `7708fcd` Update Windows resource files (and add one for globaltoken-tx)\n - #6159 `e1412d3` Catch errors on datadir lock and pidfile delete\n - #6186 `182686c` Fix two problems in CSubnet parsing\n - #6174 `df992b9` doc: add translation strings policy"
      },
      {
        "sha": "139e2729cb82de0383a81c48c1e181f591d18517",
        "filename": "doc/release-notes/release-notes-0.11.1.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.11.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.11.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.11.1.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -18,7 +18,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n Downgrade warning\n ------------------"
      },
      {
        "sha": "2c8dfcf93b934f016e9f4a839e188b82b6c301eb",
        "filename": "doc/release-notes/release-notes-0.11.2.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.11.2.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.11.2.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.11.2.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -19,7 +19,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n Downgrade warning\n ------------------\n@@ -176,8 +176,8 @@ git merge commit are mentioned.\n - #6351 `6af25b0` Add BIP65 to getblockchaininfo softforks list\n - #6688 `01878c9` Fix locking in GetTransaction\n - #6653 `b3eaa30` [Qt] Raise debug window when requested\n-- #6600 `1e672ae` Debian/Ubuntu: Include bitcoin-tx binary\n-- #6600 `2394f4d` Debian/Ubuntu: Split bitcoin-tx into its own package\n+- #6600 `1e672ae` Debian/Ubuntu: Include globaltoken-tx binary\n+- #6600 `2394f4d` Debian/Ubuntu: Split globaltoken-tx into its own package\n - #5987 `33d6825` Bugfix: Allow mining on top of old tip blocks for testnet\n - #6852 `21e58b8` build: make sure OpenSSL heeds noexecstack\n - #6846 `af6edac` alias `-h` for `--help`"
      },
      {
        "sha": "f7eecd2c170b3570806fb1bf42e18c71a6ee5d28",
        "filename": "doc/release-notes/release-notes-0.12.0.md",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.12.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.12.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.12.0.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -17,7 +17,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n Downgrade warning\n -----------------\n@@ -173,7 +173,7 @@ overridden with the option `-rpccookiefile`.\n This is similar to Tor's CookieAuthentication: see\n https://www.torproject.org/docs/tor-manual.html.en\n \n-This allows running bitcoind without having to do any manual configuration.\n+This allows running globaltokend without having to do any manual configuration.\n \n Relay: Any sequence of pushdatas in OP_RETURN outputs now allowed\n -----------------------------------------------------------------\n@@ -379,7 +379,7 @@ and are affected by this change:\n - RPC `decodescript`\n - REST `/rest/tx/` (JSON format)\n - REST `/rest/block/` (JSON format when including extended tx details)\n-- `bitcoin-tx -json`\n+- `globaltoken-tx -json`\n \n For example, the `scriptSig.asm` property of a transaction input that\n previously showed an assembly representation of:\n@@ -436,7 +436,7 @@ caching. A sample config for apache2 could look like:\n         # AuthType Digest\n         # ...\n \n-        # optional bypass bitcoind rpc basic auth\n+        # optional bypass globaltokend rpc basic auth\n         # RequestHeader set Authorization \"Basic <hash>\"\n         # get the <hash> from the shell with: base64 <<< bitcoinrpc:<password>\n     </Location>\n@@ -459,7 +459,7 @@ Other P2P Changes\n -----------------\n \n The list of banned peers is now stored on disk rather than in memory.\n-Restarting bitcoind will no longer clear out the list of banned peers; instead\n+Restarting globaltokend will no longer clear out the list of banned peers; instead\n a new RPC call (`clearbanned`) can be used to manually clear the list.  The new\n `setban` RPC call can also be used to manually ban or unban a peer.\n \n@@ -644,7 +644,7 @@ git merge commit are mentioned.\n - #6373 `1ae3196` depends: non-qt bumps for 0.12 (Cory Fields)\n - #6434 `059b352` Preserve user-passed CXXFLAGS with --enable-debug (Gavin Andresen)\n - #6501 `fee6554` Misc build fixes (Cory Fields)\n-- #6600 `ef4945f` Include bitcoin-tx binary on Debian/Ubuntu (Zak Wilcox)\n+- #6600 `ef4945f` Include globaltoken-tx binary on Debian/Ubuntu (Zak Wilcox)\n - #6619 `4862708` depends: bump miniupnpc and ccache (Michael Ford)\n - #6801 `ae69a75` [depends] Latest config.guess and config.sub (Michael Ford)\n - #6938 `193f7b5` build: If both Qt4 and Qt5 are installed, use Qt5 (Wladimir J. van der Laan)\n@@ -719,7 +719,7 @@ git merge commit are mentioned.\n - #6337 `0564c5b` Testing infrastructure: mocktime fixes (Gavin Andresen)\n - #6350 `60abba1` add unit tests for the decodescript rpc (mruddy)\n - #5881 `3203a08` Fix and improve txn_doublespend.py test (Tom Harding)\n-- #6390 `6a73d66` tests: Fix bitcoin-tx signing test case (Wladimir J. van der Laan)\n+- #6390 `6a73d66` tests: Fix globaltoken-tx signing test case (Wladimir J. van der Laan)\n - #6368 `7fc25c2` CLTV: Add more tests to improve coverage (Esteban Ordano)\n - #6414 `5121c68` Fix intermittent test failure, reduce test time (Tom Harding)\n - #6417 `44fa82d` [QA] fix possible reorg issue in (fund)rawtransaction(s).py RPC test (Jonas Schnelli)"
      },
      {
        "sha": "9b4f5e86476f63df9892cf06333b67be96fcfe8e",
        "filename": "doc/release-notes/release-notes-0.12.1.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.12.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.12.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.12.1.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -18,7 +18,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n Downgrade warning\n -----------------"
      },
      {
        "sha": "dbe95017c1ff9f36b4f8c146db6f51b52224c63b",
        "filename": "doc/release-notes/release-notes-0.13.0.md",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.13.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.13.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.13.0.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -338,7 +338,7 @@ Low-level RPC changes\n     - RPC `decodescript`\n     - REST `/rest/tx/` (JSON format)\n     - REST `/rest/block/` (JSON format when including extended tx details)\n-    - `bitcoin-tx -json`\n+    - `globaltoken-tx -json`\n \n - The sorting of the output of the `getrawmempool` output has changed.\n \n@@ -540,7 +540,7 @@ git merge commit are mentioned.\n - #7604 `354b03d` build: Remove spurious dollar sign. Fixes #7189 (dooglus)\n - #7605 `7f001bd` Remove openssl info from init/log and from Qt debug window (jonasschnelli)\n - #7628 `87d6562` Add 'copy full transaction details' option (ericshawlinux)\n-- #7613 `3798e5d` Add autocomplete to bitcoin-qt's console window (GamerSg)\n+- #7613 `3798e5d` Add autocomplete to globaltoken-qt's console window (GamerSg)\n - #7668 `b24266c` Fix history deletion bug after font size change (achow101)\n - #7680 `41d2dfa` Remove reflection from `about` icon (laanwj)\n - #7686 `f034bce` Remove 0-fee from send dialog (MarcoFalke)\n@@ -559,8 +559,8 @@ git merge commit are mentioned.\n - #8129 `ee1533e` Fix RPC console auto completer (UdjinM6)\n - #7636 `fb0ac48` Add bitcoin address label to request payment QR code (makevoid)\n - #8231 `760a6c7` Fix a bug where the SplashScreen will not be hidden during startup (jonasschnelli)\n-- #8256 `af2421c` BUG: bitcoin-qt crash (fsb4000)\n-- #8257 `ff03c50` Do not ask a UI question from bitcoind (sipa)\n+- #8256 `af2421c` BUG: globaltoken-qt crash (fsb4000)\n+- #8257 `ff03c50` Do not ask a UI question from globaltokend (sipa)\n - #8288 `91abb77` Network-specific example address (laanwj)\n - #7707 `a914968` UI support for abandoned transactions (jonasschnelli)\n - #8207 `f7a403b` Add a link to the Bitcoin-Core repository and website to the About Dialog (MarcoFalke)\n@@ -650,7 +650,7 @@ git merge commit are mentioned.\n - #8038 `e2bf830` Various minor fixes (MarcoFalke)\n - #8072 `1b87e5b` Travis: 'make check' in parallel and verbose (theuni)\n - #8056 `8844ef1` Remove hardcoded \"4 nodes\" from test_framework (MarcoFalke)\n-- #8047 `37f9a1f` Test_framework: Set wait-timeout for bitcoind procs (MarcoFalke)\n+- #8047 `37f9a1f` Test_framework: Set wait-timeout for globaltokend procs (MarcoFalke)\n - #8095 `6700cc9` Test framework: only cleanup on successful test runs (sdaftuar)\n - #8098 `06bd4f6` Test_framework: Append portseed to tmpdir (MarcoFalke)\n - #8104 `6ff2c8d` Add timeout to sync_blocks() and sync_mempools() (sdaftuar)\n@@ -670,7 +670,7 @@ git merge commit are mentioned.\n - #8216 `0d41d70` Assert 'changePosition out of bounds'  (MarcoFalke)\n - #8222 `961893f` Enable mempool consistency checks in unit tests (sipa)\n - #7751 `84370d5` test_framework: python3.4 authproxy compat (laanwj)\n-- #7744 `d8e862a` test_framework: detect failure of bitcoind startup (laanwj)\n+- #7744 `d8e862a` test_framework: detect failure of globaltokend startup (laanwj)\n - #8280 `115735d` Increase sync_blocks() timeouts in pruning.py (MarcoFalke)\n - #8340 `af9b7a9` Solve trivial merge conflict in p2p-segwit.py (MarcoFalke)\n - #8067 `3e4cf8f` Travis: use slim generic image, and some fixups (theuni)"
      },
      {
        "sha": "fd343acfb6e351a324acc9ca257d2bbe1178c6c5",
        "filename": "doc/release-notes/release-notes-0.13.1.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.13.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.13.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.13.1.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -320,7 +320,7 @@ git merge commit are mentioned.\n - #8418 `ff893aa` Add tests for compact blocks (sdaftuar)\n - #8803 `375437c` Ping regularly in p2p-segwit.py to keep connection alive (jl2012)\n - #8827 `9bbe66e` Split up slow RPC calls to avoid pruning test timeouts (sdaftuar)\n-- #8829 `2a8bca4` Add bitcoin-tx JSON tests (jnewbery)\n+- #8829 `2a8bca4` Add globaltoken-tx JSON tests (jnewbery)\n - #8834 `1dd1783` blockstore: Switch to dumb dbm (MarcoFalke)\n - #8835 `d87227d` nulldummy.py: Don't run unused code (MarcoFalke)\n - #8836 `eb18cc1` bitcoin-util-test.py should fail if the output file is empty (jnewbery)\n@@ -329,7 +329,7 @@ git merge commit are mentioned.\n - #8841 `3e4abb5` Fix nulldummy test (jl2012)\n - #8854 `624a007` Fix race condition in p2p-compactblocks test (sdaftuar)\n - #8857 `1f60d45` mininode: Only allow named args in wait_until (MarcoFalke)\n-- #8860 `0bee740` util: Move wait_bitcoinds() into stop_nodes() (MarcoFalke)\n+- #8860 `0bee740` util: Move wait_globaltokends() into stop_nodes() (MarcoFalke)\n - #8882 `b73f065` Fix race conditions in p2p-compactblocks.py and sendheaders.py (sdaftuar)\n - #8904 `cc6f551` Fix compact block shortids for a test case (dagurval)\n \n@@ -352,7 +352,7 @@ git merge commit are mentioned.\n - #8742 `d31ac72` Specify Protobuf version 2 in paymentrequest.proto (fanquake)\n - #8414,#8558,#8676,#8700,#8701,#8702 Add missing copyright headers (isle2983, kazcw)\n - #8899 `4ed2627` Fix wake from sleep issue with Boost 1.59.0 (fanquake)\n-- #8817 `bcf3806` update bitcoin-tx to output witness data (jnewbery)\n+- #8817 `bcf3806` update globaltoken-tx to output witness data (jnewbery)\n - #8513 `4e5fc31` Fix a type error that would not compile on OSX. (JeremyRubin)\n - #8392 `30eac2d` Fix several node initialization issues (sipa)\n - #8548 `305d8ac` Use `__func__` to get function name for output printing (MarcoFalke)"
      },
      {
        "sha": "d78c8de4edd085b4a14dfda1c7f157838406936f",
        "filename": "doc/release-notes/release-notes-0.13.2.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.13.2.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.13.2.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.13.2.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -111,7 +111,7 @@ git merge commit are mentioned.\n - #8972 `6f86b53` Make warnings label selectable (jonasschnelli) (MarcoFalke)\n - #9185 `6d70a73` Fix coincontrol sort issue (jonasschnelli)\n - #9094 `5f3a12c` Use correct conversion function for boost::path datadir (laanwj)\n-- #8908 `4a974b2` Update bitcoin-qt.desktop (s-matthew-english)\n+- #8908 `4a974b2` Update globaltoken-qt.desktop (s-matthew-english)\n - #9190 `dc46b10` Plug many memory leaks (laanwj)\n \n ### Wallet\n@@ -134,7 +134,7 @@ git merge commit are mentioned.\n - #8838 `094848b` Calculate size and weight of block correctly in CreateNewBlock() (jnewbery)\n - #8920 `40169dc` Set minimum required Boost to 1.47.0 (fanquake)\n - #9251 `a710a43` Improvement of documentation of command line parameter 'whitelist' (wodry)\n-- #8932 `106da69` Allow bitcoin-tx to create v2 transactions (btcdrak)\n+- #8932 `106da69` Allow globaltoken-tx to create v2 transactions (btcdrak)\n - #8929 `12428b4` add software-properties-common (sigwo)\n - #9120 `08d1c90` bug: Missed one \"return false\" in recent refactoring in #9067 (UdjinM6)\n - #9067 `f85ee01` Fix exit codes (UdjinM6)"
      },
      {
        "sha": "67a865461be40f9ee9efa8ffc2b175bc0430b3f7",
        "filename": "doc/release-notes/release-notes-0.14.0.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.14.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.14.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.14.0.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -718,18 +718,18 @@ and git merge commit are mentioned.\n - #8291 `5cac8b1` util: CopyrightHolders: Check for untranslated substitution (MarcoFalke)\n - #8557 `44691f3` contrib: Rework verifybinaries (MarcoFalke)\n - #8621 `e8ed6eb` contrib: python: Don't use shell=True (MarcoFalke)\n-- #8813 `fb24d7e` bitcoind: Daemonize using daemon(3) (laanwj)\n+- #8813 `fb24d7e` globaltokend: Daemonize using daemon(3) (laanwj)\n - #9004 `67728a3` Clarify `listenonion` (unsystemizer)\n - #8674 `bae81b8` tools for analyzing, updating and adding copyright headers in source files (isle2983)\n - #8976 `8c6218a` libconsensus: Add input validation of flags (laanwj)\n - #9112 `46027e8` Avoid ugly exception in log on unknown inv type (laanwj)\n-- #8837 `2108911` Allow bitcoin-tx to parse partial transactions (jnewbery)\n+- #8837 `2108911` Allow globaltoken-tx to parse partial transactions (jnewbery)\n - #9204 `74ced54` Clarify CreateTransaction error messages (instagibbs)\n - #9265 `31bcc66` bitcoin-cli: Make error message less confusing (laanwj)\n - #9303 `72bf1b3` Update comments in ctaes (sipa)\n - #9417 `c4b7d4f` Do not evaluate hidden LogPrint arguments (sipa)\n - #9506 `593a00c` RFC: Improve style for if indentation (sipa)\n-- #8883 `d5d4ad8` Add all standard TXO types to bitcoin-tx (jnewbery)\n+- #8883 `d5d4ad8` Add all standard TXO types to globaltoken-tx (jnewbery)\n - #9531 `23281a4` Release notes for estimation changes  (morcos)\n - #9486 `f62bc10` Make peer=%d log prints consistent (TheBlueMatt)\n - #9552 `41cb05c` Add IPv6 support to qos.sh (jamesmacwhite)"
      },
      {
        "sha": "991204fa61391f28a195632297747f64416c1223",
        "filename": "doc/release-notes/release-notes-0.14.1.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.14.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.14.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.14.1.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -75,7 +75,7 @@ this parameter.\n \n Additional information relating to running on low-memory systems can be found\n here:\n-[reducing-bitcoind-memory-usage.md](https://gist.github.com/laanwj/efe29c7661ce9b6620a7).\n+[reducing-globaltokend-memory-usage.md](https://gist.github.com/laanwj/efe29c7661ce9b6620a7).\n \n 0.14.1 Change log\n =================\n@@ -117,7 +117,7 @@ git merge commit are mentioned.\n ### Miscellaneous\n - #10037 `4d8e660` Trivial: Fix typo in help getrawtransaction RPC (keystrike)\n - #10120 `e4c9a90` util: Work around (virtual) memory exhaustion on 32-bit w/ glibc (laanwj)\n-- #10130 `ecc5232` bitcoin-tx input verification (awemany, jnewbery)\n+- #10130 `ecc5232` globaltoken-tx input verification (awemany, jnewbery)\n \n Credits\n ======="
      },
      {
        "sha": "ca32f97821c09384414ca62d56e5cc87b24bd493",
        "filename": "doc/release-notes/release-notes-0.3.21.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.3.21.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.3.21.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.3.21.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -3,7 +3,7 @@ Binaries for Bitcoin version 0.3.21 are available at:\n \n Changes and new features from the 0.3.20 release include:\n \n-* Universal Plug and Play support.  Enable automatic opening of a port for incoming connections by running bitcoin or bitcoind with the - -upnp=1 command line switch or using the Options dialog box.\n+* Universal Plug and Play support.  Enable automatic opening of a port for incoming connections by running bitcoin or globaltokend with the - -upnp=1 command line switch or using the Options dialog box.\n \n * Support for full-precision bitcoin amounts.  You can now send, and bitcoin will display, bitcoin amounts smaller than 0.01.  However, sending fewer than 0.01 bitcoins still requires a 0.01 bitcoin fee (so you can send 1.0001 bitcoins without a fee, but you will be asked to pay a fee if you try to send 0.0001).\n \n@@ -13,7 +13,7 @@ For developers, changes to bitcoin's remote-procedure-call API:\n \n * New rpc command \"sendmany\" to send bitcoins to more than one address in a single transaction.\n \n-* Several bug fixes, including a serious intermittent bug that would sometimes cause bitcoind to stop accepting rpc requests. \n+* Several bug fixes, including a serious intermittent bug that would sometimes cause globaltokend to stop accepting rpc requests. \n \n * -logtimestamps option, to add a timestamp to each line in debug.log.\n "
      },
      {
        "sha": "26224f9e38b9cef5aca87521dff8be802126c8ee",
        "filename": "doc/release-notes/release-notes-0.3.24.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.3.24.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.3.24.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.3.24.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -13,7 +13,7 @@ Notable changes in v0.3.24:\n \n C1) DNS seeding enabled by default.\n \n-C2) UPNP enabled by default in the GUI client.  The percentage of bitcoin clients that accept incoming connections is quite small, and that is a problem.  This should help.  bitcoind, and unofficial builds, are unchanged (though we encourage use of \"-upnp\" to help the network!)\n+C2) UPNP enabled by default in the GUI client.  The percentage of bitcoin clients that accept incoming connections is quite small, and that is a problem.  This should help.  globaltokend, and unofficial builds, are unchanged (though we encourage use of \"-upnp\" to help the network!)\n \n C3) Initial unit testing framework.  Bitcoin sorely needs automated tests, and this is a beginning.  Contributions welcome.\n "
      },
      {
        "sha": "ed29ac9878f2751ca9c882c8fb58c738746675c6",
        "filename": "doc/release-notes/release-notes-0.4.1.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.4.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.4.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.4.1.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -11,7 +11,7 @@ The wallet encryption feature introduced in Bitcoin version 0.4.0 did not suffic\n managed to get a copy of your encrypted wallet.dat file might be able to recover some or all of the unencrypted keys and steal the\n associated coins.\n \n-If you have a previously encrypted wallet.dat, the first time you run wxbitcoin or bitcoind the wallet will be rewritten, Bitcoin will\n+If you have a previously encrypted wallet.dat, the first time you run wxbitcoin or globaltokend the wallet will be rewritten, Bitcoin will\n shut down, and you will be prompted to restart it to run with the new, properly encrypted file.\n \n If you had a previously encrypted wallet.dat that might have been copied or stolen (for example, you backed it up to a public\n@@ -26,7 +26,7 @@ new private keys are properly backed up you should:\n \n 2. Run it again, then ask it for a new bitcoin address.\n wxBitcoin: new address visible on main window\n-bitcoind: run the 'walletpassphrase' RPC command to unlock the wallet,  then run the 'getnewaddress' RPC command.\n+globaltokend: run the 'walletpassphrase' RPC command to unlock the wallet,  then run the 'getnewaddress' RPC command.\n \n 3. If your encrypted wallet.dat may have been copied or stolen, send all of your bitcoins to the new bitcoin address.\n "
      },
      {
        "sha": "82b7697395a3c49b71ef8e0b0ec042b67c9356ef",
        "filename": "doc/release-notes/release-notes-0.4.3.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.4.3.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.4.3.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.4.3.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,5 +1,5 @@\n-bitcoind version 0.4.3 is now available for download at:\n-http://luke.dashjr.org/programs/bitcoin/files/bitcoind-0.4.3/ (until Gavin uploads to SourceForge)\n+globaltokend version 0.4.3 is now available for download at:\n+http://luke.dashjr.org/programs/bitcoin/files/globaltokend-0.4.3/ (until Gavin uploads to SourceForge)\n \n This is a bugfix-only release based on 0.4.0.\n \n@@ -9,7 +9,7 @@ Please report bugs for the daemon only using the issue tracker at github:\n https://github.com/bitcoin/bitcoin/issues\n \n Stable source code is hosted at Gitorious:\n-http://gitorious.org/bitcoin/bitcoind-stable/archive-tarball/v0.4.3#.tar.gz\n+http://gitorious.org/bitcoin/globaltokend-stable/archive-tarball/v0.4.3#.tar.gz\n \n BUG FIXES\n "
      },
      {
        "sha": "203e2ba87ed146b2ac61a029d7ab4b6640e29554",
        "filename": "doc/release-notes/release-notes-0.4.4.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.4.4.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.4.4.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.4.4.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,5 +1,5 @@\n Bitcoin version 0.4.4 is now available for download at:\n-http://luke.dashjr.org/programs/bitcoin/files/bitcoind-0.4.4/\n+http://luke.dashjr.org/programs/bitcoin/files/globaltokend-0.4.4/\n \n This is a bugfix-only release based on 0.4.0.\n \n@@ -9,7 +9,7 @@ Please report bugs for the daemon only using the issue tracker at github:\n https://github.com/bitcoin/bitcoin/issues\n \n Stable source code is hosted at Gitorious:\n-http://gitorious.org/bitcoin/bitcoind-stable/archive-tarball/v0.4.4#.tar.gz\n+http://gitorious.org/bitcoin/globaltokend-stable/archive-tarball/v0.4.4#.tar.gz\n \n BUG FIXES\n \n@@ -24,7 +24,7 @@ Several shutdown issues have been fixed.\n Check that keys stored in the wallet are valid at startup, and if not,\n report corruption.\n Various build fixes.\n-If no password is specified to bitcoind, recommend a secure password.\n+If no password is specified to globaltokend, recommend a secure password.\n Update hard-coded fallback seed nodes, choosing recent ones with long uptime and versions at least 0.4.0.\n Add checkpoint at block 168,000.\n "
      },
      {
        "sha": "930594c839f46a425b2088f3be1e2b16a0a3b4ed",
        "filename": "doc/release-notes/release-notes-0.4.6.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.4.6.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.4.6.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.4.6.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,7 +1,7 @@\n-bitcoind version 0.4.6 is now available for download at:\n+globaltokend version 0.4.6 is now available for download at:\n Windows: installer | zip (sig)\n Source: tar.gz\n-bitcoind and Bitcoin-Qt version 0.6.0.7 are also tagged in git, but it is recommended to upgrade to 0.6.1.\n+globaltokend and Bitcoin-Qt version 0.6.0.7 are also tagged in git, but it is recommended to upgrade to 0.6.1.\n \n These are bugfix-only releases.\n "
      },
      {
        "sha": "26a7c0e25304ef8d7e15fb21eefae564d1ff00ae",
        "filename": "doc/release-notes/release-notes-0.5.0.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.5.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.5.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.5.0.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -9,15 +9,15 @@ https://www.transifex.net/projects/p/bitcoin/\n Please report bugs using the issue tracker at github:\n https://github.com/bitcoin/bitcoin/issues\n \n-For Ubuntu users, there is a new ppa maintained by Matt Corallo which you can add to your system so that it will automatically keep bitcoin up-to-date.  Just type \"sudo apt-add-repository ppa:bitcoin/bitcoin\" in your terminal, then install the bitcoin-qt package.\n+For Ubuntu users, there is a new ppa maintained by Matt Corallo which you can add to your system so that it will automatically keep bitcoin up-to-date.  Just type \"sudo apt-add-repository ppa:bitcoin/bitcoin\" in your terminal, then install the globaltoken-qt package.\n \n MAJOR BUG FIX  (CVE-2011-4447)\n \n The wallet encryption feature introduced in Bitcoin version 0.4.0 did not sufficiently secure the private keys. An attacker who\n managed to get a copy of your encrypted wallet.dat file might be able to recover some or all of the unencrypted keys and steal the\n associated coins.\n \n-If you have a previously encrypted wallet.dat, the first time you run bitcoin-qt or bitcoind the wallet will be rewritten, Bitcoin will\n+If you have a previously encrypted wallet.dat, the first time you run globaltoken-qt or globaltokend the wallet will be rewritten, Bitcoin will\n shut down, and you will be prompted to restart it to run with the new, properly encrypted file.\n \n If you had a previously encrypted wallet.dat that might have been copied or stolen (for example, you backed it up to a public\n@@ -32,7 +32,7 @@ new private keys are properly backed up you should:\n \n 2. Run it again, then ask it for a new bitcoin address.\n Bitcoin-Qt: Address Book, then New Address...\n-bitcoind: run the 'walletpassphrase' RPC command to unlock the wallet,  then run the 'getnewaddress' RPC command.\n+globaltokend: run the 'walletpassphrase' RPC command to unlock the wallet,  then run the 'getnewaddress' RPC command.\n \n 3. If your encrypted wallet.dat may have been copied or stolen, send  all of your bitcoins to the new bitcoin address.\n "
      },
      {
        "sha": "0020813c4b3c24a293bb7239461ea591939824a2",
        "filename": "doc/release-notes/release-notes-0.5.1.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.5.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.5.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.5.1.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -21,7 +21,7 @@ For Ubuntu users, there is a new ppa maintained by Matt Corallo which\n you can add to your system so that it will automatically keep\n bitcoin up-to-date.  Just type\n sudo apt-add-repository ppa:bitcoin/bitcoin\n-in your terminal, then install the bitcoin-qt package.\n+in your terminal, then install the globaltoken-qt package.\n \n \n BUG FIXES\n@@ -40,4 +40,4 @@ orphan blocks.\n \n The wallet passphrase dialog now warns you if the caps lock key was pressed.\n \n-Improved searching in addresses and labels in bitcoin-qt.\n+Improved searching in addresses and labels in globaltoken-qt."
      },
      {
        "sha": "52d892f5ce5d0c454d568d533d34eebd4035c7aa",
        "filename": "doc/release-notes/release-notes-0.5.2.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.5.2.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.5.2.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.5.2.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -7,7 +7,7 @@ Please report bugs using the issue tracker at github:\n https://github.com/bitcoin/bitcoin/issues\n \n Stable source code is hosted at Gitorious:\n-http://gitorious.org/bitcoin/bitcoind-stable/archive-tarball/v0.5.2#.tar.gz\n+http://gitorious.org/bitcoin/globaltokend-stable/archive-tarball/v0.5.2#.tar.gz\n \n BUG FIXES\n "
      },
      {
        "sha": "c7f860c628d13901292223cc0c84c9ae37e5b4d5",
        "filename": "doc/release-notes/release-notes-0.5.3.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.5.3.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.5.3.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.5.3.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -8,7 +8,7 @@ Please report bugs using the issue tracker at github:\n https://github.com/bitcoin/bitcoin/issues\n \n Stable source code is hosted at Gitorious:\n-http://gitorious.org/bitcoin/bitcoind-stable/archive-tarball/v0.5.3#.tar.gz\n+http://gitorious.org/bitcoin/globaltokend-stable/archive-tarball/v0.5.3#.tar.gz\n \n PROTOCOL UPDATES\n \n@@ -33,7 +33,7 @@ Revert to \"global progress indication\", as starting from zero every time was con\n Check that keys stored in the wallet are valid at startup, and if not, report corruption.\n Enable accessible widgets on Windows, so that people with screen readers such as NVDA can make sense of it.\n Various build fixes.\n-If no password is specified to bitcoind, recommend a secure password.\n+If no password is specified to globaltokend, recommend a secure password.\n Automatically focus and scroll to new \"Send coins\" entries in Bitcoin-Qt.\n Show a message box for --help on Windows, for Bitcoin-Qt.\n Add missing \"About Qt\" menu option to show built-in Qt About dialog."
      },
      {
        "sha": "c26162fa32e530b765ba129957cd1613ffd40ea4",
        "filename": "doc/release-notes/release-notes-0.5.4.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.5.4.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.5.4.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.5.4.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -8,7 +8,7 @@ Please report bugs using the issue tracker at github:\n https://github.com/bitcoin/bitcoin/issues\n \n Stable source code is hosted at Gitorious:\n-http://gitorious.org/bitcoin/bitcoind-stable/archive-tarball/v0.5.4#.tar.gz\n+http://gitorious.org/bitcoin/globaltokend-stable/archive-tarball/v0.5.4#.tar.gz\n \n PROTOCOL UPDATES\n "
      },
      {
        "sha": "65d38b4d08d42f00020c2482febeef5f7999c73b",
        "filename": "doc/release-notes/release-notes-0.5.5.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.5.5.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.5.5.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.5.5.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,7 +1,7 @@\n-bitcoind and Bitcoin-Qt version 0.5.5 are now available for download at:\n+globaltokend and Bitcoin-Qt version 0.5.5 are now available for download at:\n Windows: installer | zip (sig)\n Source: tar.gz\n-bitcoind and Bitcoin-Qt version 0.6.0.7 are also tagged in git, but it is recommended to upgrade to 0.6.1.\n+globaltokend and Bitcoin-Qt version 0.6.0.7 are also tagged in git, but it is recommended to upgrade to 0.6.1.\n \n These are bugfix-only releases.\n "
      },
      {
        "sha": "157f1a42d09a421efba225e12b78226d4ff32360",
        "filename": "doc/release-notes/release-notes-0.6.0.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.6.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.6.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.6.0.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -19,7 +19,7 @@ For Ubuntu users, there is a ppa maintained by Matt Corallo which\n you can add to your system so that it will automatically keep\n bitcoin up-to-date.  Just type\n sudo apt-add-repository ppa:bitcoin/bitcoin\n-in your terminal, then install the bitcoin-qt package.\n+in your terminal, then install the globaltoken-qt package.\n \n \n KNOWN ISSUES\n@@ -54,7 +54,7 @@ transactions and less traffic on the bitcoin\n network. The shorter keys are already supported\n by the network but wallet.dat files containing\n short keys are not compatible with earlier\n-versions of Bitcoin-Qt/bitcoind.\n+versions of Bitcoin-Qt/globaltokend.\n \n New command-line argument -blocknotify=<command>\n that will spawn a shell process to run <command> "
      },
      {
        "sha": "3fa3efdbe90262773c61a40e07f21591934d2065",
        "filename": "doc/release-notes/release-notes-0.7.0.md",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.7.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.7.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.7.0.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,7 +1,7 @@\n Bitcoin version 0.7.0 is now available for download at:\n   http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.7.0/\n \n-We recommend that everybody running prior versions of bitcoind/Bitcoin-Qt\n+We recommend that everybody running prior versions of globaltokend/Bitcoin-Qt\n upgrade to this release, except for users running Mac OSX 10.5.\n \n Please report bugs using the issue tracker at github:\n@@ -17,8 +17,8 @@ maintained by Matt Corallo to automatically keep\n bitcoin up-to-date.  Just type\n   sudo apt-add-repository ppa:bitcoin/bitcoin\n   sudo apt-get update\n-in your terminal, then install the bitcoin-qt package:\n-  sudo apt-get install bitcoin-qt\n+in your terminal, then install the globaltoken-qt package:\n+  sudo apt-get install globaltoken-qt\n \n \n How to Upgrade\n@@ -30,7 +30,7 @@ Code:\n /Applications/Bitcoin-Qt\n (on Mac) or\n Code:\n-bitcoind/bitcoin-qt\n+globaltokend/globaltoken-qt\n (on Linux).\n \n If you were running on Linux with a version that might have been compiled\n@@ -119,8 +119,8 @@ Qt GUI\n * Much better translations\n * Override progress bar design on platforms with segmented progress bars to assist with readability\n * Added 'immature balance' display on the overview page\n-* (Windows only): enable ASLR and DEP for bitcoin-qt.exe\n-* (Windows only): add meta-data to bitcoin-qt.exe (e.g. description)\n+* (Windows only): enable ASLR and DEP for globaltoken-qt.exe\n+* (Windows only): add meta-data to globaltoken-qt.exe (e.g. description)\n \n Internal codebase\n \n@@ -131,7 +131,7 @@ Internal codebase\n Miscellaneous\n \n * Reopen debug.log upon SIGHUP\n-* Bash programmable completion for bitcoind(1)\n+* Bash programmable completion for globaltokend(1)\n * On supported OS's, each thread is given a useful name\n \n "
      },
      {
        "sha": "252df844ba8dd8424caa24650df9a9a80d4ee73c",
        "filename": "doc/release-notes/release-notes-0.7.1.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.7.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.7.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.7.1.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -16,8 +16,8 @@ maintained by Matt Corallo to automatically keep\n up-to-date.  Just type:\n   sudo apt-add-repository ppa:bitcoin/bitcoin\n   sudo apt-get update\n-in your terminal, then install the bitcoin-qt package:\n-  sudo apt-get install bitcoin-qt\n+in your terminal, then install the globaltoken-qt package:\n+  sudo apt-get install globaltoken-qt\n \n KNOWN ISSUES\n ------------\n@@ -30,7 +30,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait\n until it has completely shut down (which might take a few minutes for older\n versions), then run the installer (on Windows) or just copy over\n-/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).\n+/Applications/Bitcoin-Qt (on Mac) or globaltokend/globaltoken-qt (on Linux).\n \n If you were running on Linux with a version that might have been compiled\n with a different version of Berkeley DB (for example, if you were using an"
      },
      {
        "sha": "6e1cc63113b3ca6fe111ead4ef37a9f6d3dc6451",
        "filename": "doc/release-notes/release-notes-0.7.2.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.7.2.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.7.2.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.7.2.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -12,7 +12,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait\n until it has completely shut down (which might take a few minutes for older\n versions), then run the installer (on Windows) or just copy over\n-/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).\n+/Applications/Bitcoin-Qt (on Mac) or globaltokend/globaltoken-qt (on Linux).\n \n If you were running on Linux with a version that might have been compiled\n with a different version of Berkeley DB (for example, if you were using an"
      },
      {
        "sha": "349e16cf536557c596390c9e3813b4b28e268a06",
        "filename": "doc/release-notes/release-notes-0.8.0.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.8.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.8.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.8.0.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -13,7 +13,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait\n until it has completely shut down (which might take a few minutes for older\n versions), then run the installer (on Windows) or just copy over\n-/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).\n+/Applications/Bitcoin-Qt (on Mac) or globaltokend/globaltoken-qt (on Linux).\n \n The first time you run after the upgrade a re-indexing process will be\n started that will take anywhere from 30 minutes to several hours,"
      },
      {
        "sha": "c8759d5384efe6bcba0f24e15d7b17d1b945354f",
        "filename": "doc/release-notes/release-notes-0.8.1.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.8.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.8.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.8.1.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,4 +1,4 @@\n-Bitcoin-Qt/bitcoind version 0.8.1 is now available from:\n+Bitcoin-Qt/globaltokend version 0.8.1 is now available from:\n   http://sourceforge.net/projects/bitcoin/files/Bitcoin/bitcoin-0.8.1/\n \n This is a maintenance release that adds a new network rule to avoid\n@@ -14,7 +14,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait\n until it has completely shut down (which might take a few minutes for older\n versions), then run the installer (on Windows) or just copy over\n-/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).\n+/Applications/Bitcoin-Qt (on Mac) or globaltokend/globaltoken-qt (on Linux).\n \n If you are upgrading from version 0.7.2 or earlier, the first time you\n run 0.8.1 your blockchain files will be re-indexed, which will take"
      },
      {
        "sha": "84c0855fb56b45c5bc4aa8fb09624c19382b5c80",
        "filename": "doc/release-notes/release-notes-0.8.2.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.8.2.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.8.2.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.8.2.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -13,7 +13,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait\n until it has completely shut down (which might take a few minutes for older\n versions), then run the installer (on Windows) or just copy over\n-/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).\n+/Applications/Bitcoin-Qt (on Mac) or globaltokend/globaltoken-qt (on Linux).\n \n If you are upgrading from version 0.7.2 or earlier, the first time you\n run 0.8.2 your blockchain files will be re-indexed, which will take"
      },
      {
        "sha": "71e075f405f5a22ab868158417e7118b603f1c37",
        "filename": "doc/release-notes/release-notes-0.8.4.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.8.4.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.8.4.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.8.4.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -14,7 +14,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait\n until it has completely shut down (which might take a few minutes for older\n versions), then run the installer (on Windows) or just copy over\n-/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).\n+/Applications/Bitcoin-Qt (on Mac) or globaltokend/globaltoken-qt (on Linux).\n \n If you are upgrading from version 0.7.2 or earlier, the first time you\n run 0.8.4 your blockchain files will be re-indexed, which will take\n@@ -29,7 +29,7 @@ Security issues\n \n An attacker could send a series of messages that resulted in\n an integer division-by-zero error in the Bloom Filter handling\n-code, causing the Bitcoin-Qt or bitcoind process to crash.\n+code, causing the Bitcoin-Qt or globaltokend process to crash.\n Bloom filters were introduced with version 0.8, so versions 0.8.0\n through 0.8.3 are vulnerable to this critical denial-of-service attack.\n "
      },
      {
        "sha": "1b1db521effcd4a4ee1d3a9b0205d04a93bd8758",
        "filename": "doc/release-notes/release-notes-0.8.5.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.8.5.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.8.5.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.8.5.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -14,7 +14,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait\n until it has completely shut down (which might take a few minutes for older\n versions), then run the installer (on Windows) or just copy over\n-/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).\n+/Applications/Bitcoin-Qt (on Mac) or globaltokend/globaltoken-qt (on Linux).\n \n If you are upgrading from version 0.7.2 or earlier, the first time you\n run 0.8.5 your blockchain files will be re-indexed, which will take"
      },
      {
        "sha": "12a51e674df58debdca3a4d9b738112759e9ce42",
        "filename": "doc/release-notes/release-notes-0.8.6.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.8.6.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.8.6.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.8.6.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -16,7 +16,7 @@ If you already downloaded 0.8.6rc1 you do not need to re-download. This release\n If you are running an older version, shut it down. Wait\n until it has completely shut down (which might take a few minutes for older\n versions), then run the installer (on Windows) or just copy over\n-/Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).\n+/Applications/Bitcoin-Qt (on Mac) or globaltokend/globaltoken-qt (on Linux).\n \n If you are upgrading from version 0.7.2 or earlier, the first time you\n run 0.8.6 your blockchain files will be re-indexed, which will take"
      },
      {
        "sha": "100605c33b58b986a503aead4929032a836ddecb",
        "filename": "doc/release-notes/release-notes-0.9.0.md",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.9.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.9.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.9.0.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -15,7 +15,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), uninstall all\n earlier versions of Bitcoin, then run the installer (on Windows) or just copy\n-over /Applications/Bitcoin-Qt (on Mac) or bitcoind/bitcoin-qt (on Linux).\n+over /Applications/Bitcoin-Qt (on Mac) or globaltokend/globaltoken-qt (on Linux).\n \n If you are upgrading from version 0.7.2 or earlier, the first time you run\n 0.9.0 your blockchain files will be re-indexed, which will take anywhere from \n@@ -86,19 +86,19 @@ For 0.9.0 we switched to an autotools-based build system instead of individual\n (q)makefiles.\n \n Using the standard \"./autogen.sh; ./configure; make\" to build Bitcoin-Qt and\n-bitcoind makes it easier for experienced open source developers to contribute \n+globaltokend makes it easier for experienced open source developers to contribute \n to the project.\n \n Be sure to check doc/build-*.md for your platform before building from source.\n \n Bitcoin-cli\n -------------\n \n-Another change in the 0.9 release is moving away from the bitcoind executable\n+Another change in the 0.9 release is moving away from the globaltokend executable\n functioning both as a server and as a RPC client. The RPC client functionality\n (\"tell the running bitcoin daemon to do THIS\") was split into a separate\n executable, 'bitcoin-cli'. The RPC client code will eventually be removed from\n-bitcoind, but will be kept for backwards compatibility for a release or two.\n+globaltokend, but will be kept for backwards compatibility for a release or two.\n \n `walletpassphrase` RPC\n -----------------------\n@@ -197,13 +197,13 @@ Command-line options:\n - New option: -nospendzeroconfchange to never spend unconfirmed change outputs\n - New option: -zapwallettxes to rebuild the wallet's transaction information\n - Rename option '-tor' to '-onion' to better reflect what it does\n-- Add '-disablewallet' mode to let bitcoind run entirely without wallet (when\n+- Add '-disablewallet' mode to let globaltokend run entirely without wallet (when\n   built with wallet)\n - Update default '-rpcsslciphers' to include TLSv1.2\n - make '-logtimestamps' default on and rework help-message\n - RPC client option: '-rpcwait', to wait for server start\n - Remove '-logtodebugger'\n-- Allow `-noserver` with bitcoind\n+- Allow `-noserver` with globaltokend\n \n Block-chain handling and storage:\n \n@@ -305,7 +305,7 @@ GUI:\n   notifications\n - OS X: Added NSHighResolutionCapable flag to Info.plist for better font\n   rendering on Retina displays.\n-- OS X: Fix bitcoin-qt startup crash when clicking dock icon\n+- OS X: Fix globaltoken-qt startup crash when clicking dock icon\n - Linux: Fix Gnome bitcoin: URI handler\n \n Miscellaneous:"
      },
      {
        "sha": "df54e9166808f98e6d40a92031bb6902a6e72538",
        "filename": "doc/release-notes/release-notes-0.9.1.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.9.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.9.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.9.1.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -7,7 +7,7 @@ as soon as possible.\n \n It is especially important to upgrade if you currently have version\n 0.9.0 installed and are using the graphical interface OR you are using\n-bitcoind from any pre-0.9.1 version, and have enabled SSL for RPC and\n+globaltokend from any pre-0.9.1 version, and have enabled SSL for RPC and\n have configured allowip to allow rpc connections from potentially\n hostile hosts.\n \n@@ -21,7 +21,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n If you are upgrading from version 0.7.2 or earlier, the first time you run\n 0.9.1 your blockchain files will be re-indexed, which will take anywhere from "
      },
      {
        "sha": "9426d414848236c0498a93059ab09dfb9b6809a6",
        "filename": "doc/release-notes/release-notes-0.9.2.1.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.9.2.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.9.2.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.9.2.1.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -16,7 +16,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n If you are upgrading from version 0.7.2 or earlier, the first time you run\n 0.9.2.1 your blockchain files will be re-indexed, which will take anywhere from "
      },
      {
        "sha": "7131179b4214649935b41d6d7cc0b62cf72ca8ff",
        "filename": "doc/release-notes/release-notes-0.9.2.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.9.2.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.9.2.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.9.2.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -16,7 +16,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n If you are upgrading from version 0.7.2 or earlier, the first time you run\n 0.9.2 your blockchain files will be re-indexed, which will take anywhere from "
      },
      {
        "sha": "0fdcbc5c5ed8456127bfa631814690634e19ffb5",
        "filename": "doc/release-notes/release-notes-0.9.3.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.9.3.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.9.3.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.9.3.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -18,7 +18,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n If you are upgrading from version 0.7.2 or earlier, the first time you run\n 0.9.3 your blockchain files will be re-indexed, which will take anywhere from "
      },
      {
        "sha": "16ab3a1ac88a361df40a70c0497c0a58d978eecd",
        "filename": "doc/release-notes/release-notes-0.9.4.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.9.4.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.9.4.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.9.4.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -15,7 +15,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n OpenSSL Warning\n ================"
      },
      {
        "sha": "035ba5fe77adf0fe05b6985504df156f005a5b8f",
        "filename": "doc/release-notes/release-notes-0.9.5.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.9.5.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/release-notes/release-notes-0.9.5.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.9.5.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -16,7 +16,7 @@ How to Upgrade\n If you are running an older version, shut it down. Wait until it has completely\n shut down (which might take a few minutes for older versions), then run the\n installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n-bitcoind/bitcoin-qt (on Linux).\n+globaltokend/globaltoken-qt (on Linux).\n \n Notable changes\n ================"
      },
      {
        "sha": "2b124e7d9180d0dd404371758b314ffc0dcd7264",
        "filename": "doc/tor.md",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/tor.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/tor.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/tor.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -46,7 +46,7 @@ config file):\n \tHiddenServicePort 18333 127.0.0.1:18333\n \n The directory can be different of course, but (both) port numbers should be equal to\n-your bitcoind's P2P listen port (8333 by default).\n+your globaltokend's P2P listen port (8333 by default).\n \n \t-externalip=X   You can tell bitcoin about its publicly reachable address using\n \t                this option, and this can be a .onion address. Given the above\n@@ -68,18 +68,18 @@ your bitcoind's P2P listen port (8333 by default).\n \n In a typical situation, where you're only reachable via Tor, this should suffice:\n \n-\t./bitcoind -proxy=127.0.0.1:9050 -externalip=57qr3yd1nyntf5k.onion -listen\n+\t./globaltokend -proxy=127.0.0.1:9050 -externalip=57qr3yd1nyntf5k.onion -listen\n \n (obviously, replace the Onion address with your own). It should be noted that you still\n listen on all devices and another node could establish a clearnet connection, when knowing\n your address. To mitigate this, additionally bind the address of your Tor proxy:\n \n-\t./bitcoind ... -bind=127.0.0.1\n+\t./globaltokend ... -bind=127.0.0.1\n \n If you don't care too much about hiding your node, and want to be reachable on IPv4\n as well, use `discover` instead:\n \n-\t./bitcoind ... -discover\n+\t./globaltokend ... -discover\n \n and open port 8333 on your firewall (or use -upnp).\n \n@@ -105,12 +105,12 @@ and, if not disabled, configured using the `-torcontrol` and `-torpassword` sett\n To show verbose debugging information, pass `-debug=tor`.\n \n Connecting to Tor's control socket API requires one of two authentication methods to be \n-configured. For cookie authentication the user running bitcoind must have write access \n+configured. For cookie authentication the user running globaltokend must have write access \n to the `CookieAuthFile` specified in Tor configuration. In some cases this is \n preconfigured and the creation of a hidden service is automatic. If permission problems \n are seen with `-debug=tor` they can be resolved by adding both the user running tor and \n-the user running bitcoind to the same group and setting permissions appropriately. On \n-Debian-based systems the user running bitcoind can be added to the debian-tor group, \n+the user running globaltokend to the same group and setting permissions appropriately. On \n+Debian-based systems the user running globaltokend can be added to the debian-tor group, \n which has the appropriate permissions. An alternative authentication method is the use \n of the `-torpassword` flag and a `hash-password` which can be enabled and specified in \n Tor configuration."
      },
      {
        "sha": "a5400f42e6529316ecb18138cd30e5a3244115e9",
        "filename": "doc/translation_process.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/translation_process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/translation_process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/translation_process.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -22,7 +22,7 @@ cd src/\n make translate\n ```\n \n-`contrib/bitcoin-qt.pro` takes care of generating `.qm` (binary compiled) files from `.ts` (source files) files. It\u2019s mostly automated, and you shouldn\u2019t need to worry about it.\n+`contrib/globaltoken-qt.pro` takes care of generating `.qm` (binary compiled) files from `.ts` (source files) files. It\u2019s mostly automated, and you shouldn\u2019t need to worry about it.\n \n **Example Qt translation**\n ```cpp"
      },
      {
        "sha": "94b9e30b0c9fddb6f6d891d2040250d0290ffecc",
        "filename": "doc/zmq.md",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/zmq.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/doc/zmq.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/zmq.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -45,7 +45,7 @@ operation.\n \n By default, the ZeroMQ feature is automatically compiled in if the\n necessary prerequisites are found.  To disable, use --disable-zmq\n-during the *configure* step of building bitcoind:\n+during the *configure* step of building globaltokend:\n \n     $ ./configure --disable-zmq (other options)\n \n@@ -66,8 +66,8 @@ address. The same address can be used in more than one notification.\n \n For instance:\n \n-    $ bitcoind -zmqpubhashtx=tcp://127.0.0.1:28332 \\\n-               -zmqpubrawtx=ipc:///tmp/bitcoind.tx.raw\n+    $ globaltokend -zmqpubhashtx=tcp://127.0.0.1:28332 \\\n+               -zmqpubrawtx=ipc:///tmp/globaltokend.tx.raw\n \n Each PUB notification has a topic and body, where the header\n corresponds to the notification type. For instance, for the\n@@ -87,9 +87,9 @@ arriving. Please see `contrib/zmq/zmq_sub.py` for a working example.\n \n ## Remarks\n \n-From the perspective of bitcoind, the ZeroMQ socket is write-only; PUB\n+From the perspective of globaltokend, the ZeroMQ socket is write-only; PUB\n sockets don't even have a read function. Thus, there is no state\n-introduced into bitcoind directly. Furthermore, no information is\n+introduced into globaltokend directly. Furthermore, no information is\n broadcast that wasn't already received from the public P2P network.\n \n No authentication or authorization is done on connecting clients; it"
      },
      {
        "sha": "ec0a81d79d350908c4e6e9f39105c20b9f071fd6",
        "filename": "share/certs/PrivateKeyNotes.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/share/certs/PrivateKeyNotes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/share/certs/PrivateKeyNotes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/certs/PrivateKeyNotes.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -17,7 +17,7 @@ Threat analysis\n --\n \n Gavin is a single point of failure. He could be coerced to divulge the secret signing keys,\n-allowing somebody to distribute a Bitcoin-Qt.app or bitcoin-qt-setup.exe with a valid\n+allowing somebody to distribute a Bitcoin-Qt.app or globaltoken-qt-setup.exe with a valid\n signature but containing a malicious binary.\n \n Or the machine Gavin uses to sign the binaries could be compromised, either remotely or\n@@ -34,7 +34,7 @@ or divulge the private keys).\n \n Windows binaries are reproducibly 'gitian-built', and the setup.exe file created\n by the NSIS installer system is a 7zip archive, so you could check to make sure\n-that the bitcoin-qt.exe file inside the installer had not been tampered with.\n+that the globaltoken-qt.exe file inside the installer had not been tampered with.\n However, an attacker could modify the installer's code, so when the setup.exe\n was run it compromised users' systems. A volunteer to write an auditing tool\n that checks the setup.exe for tampering, and checks the files in it against"
      },
      {
        "sha": "549808997992c72036e2297890a48496a16eb545",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -66,11 +66,11 @@ TESTS =\n BENCHMARKS =\n \n if BUILD_BITCOIND\n-  bin_PROGRAMS += bitcoind\n+  bin_PROGRAMS += globaltokend\n endif\n \n if BUILD_BITCOIN_UTILS\n-  bin_PROGRAMS += bitcoin-cli bitcoin-tx\n+  bin_PROGRAMS += bitcoin-cli globaltoken-tx\n endif\n \n .PHONY: FORCE check-symbols check-security\n@@ -178,7 +178,7 @@ obj/build.h: FORCE\n \t  \"$(abs_top_srcdir)\"\n libbitcoin_util_a-clientversion.$(OBJEXT): obj/build.h\n \n-# server: shared between bitcoind and bitcoin-qt\n+# server: shared between globaltokend and globaltoken-qt\n libbitcoin_server_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(MINIUPNPC_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n libbitcoin_server_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_server_a_SOURCES = \\\n@@ -231,7 +231,7 @@ libbitcoin_zmq_a_SOURCES = \\\n endif\n \n \n-# wallet: shared between bitcoind and bitcoin-qt, but only linked\n+# wallet: shared between globaltokend and globaltoken-qt, but only linked\n # when wallet enabled\n libbitcoin_wallet_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_wallet_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n@@ -302,7 +302,7 @@ libbitcoin_consensus_a_SOURCES = \\\n   utilstrencodings.h \\\n   version.h\n \n-# common: shared between bitcoind, and bitcoin-qt and non-server tools\n+# common: shared between globaltokend, and globaltoken-qt and non-server tools\n libbitcoin_common_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_common_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_common_a_SOURCES = \\\n@@ -352,7 +352,7 @@ if GLIBC_BACK_COMPAT\n libbitcoin_util_a_SOURCES += compat/glibc_compat.cpp\n endif\n \n-# cli: shared between bitcoin-cli and bitcoin-qt\n+# cli: shared between bitcoin-cli and globaltoken-qt\n libbitcoin_cli_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_cli_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_cli_a_SOURCES = \\\n@@ -362,17 +362,17 @@ libbitcoin_cli_a_SOURCES = \\\n nodist_libbitcoin_util_a_SOURCES = $(srcdir)/obj/build.h\n #\n \n-# bitcoind binary #\n-bitcoind_SOURCES = bitcoind.cpp\n-bitcoind_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n-bitcoind_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-bitcoind_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+# globaltokend binary #\n+globaltokend_SOURCES = globaltokend.cpp\n+globaltokend_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+globaltokend_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+globaltokend_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n if TARGET_WINDOWS\n-bitcoind_SOURCES += bitcoind-res.rc\n+globaltokend_SOURCES += globaltokend-res.rc\n endif\n \n-bitcoind_LDADD = \\\n+globaltokend_LDADD = \\\n   $(LIBBITCOIN_SERVER) \\\n   $(LIBBITCOIN_COMMON) \\\n   $(LIBUNIVALUE) \\\n@@ -386,7 +386,7 @@ bitcoind_LDADD = \\\n   $(LIBMEMENV) \\\n   $(LIBSECP256K1)\n \n-bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS)\n+globaltokend_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS)\n \n # bitcoin-cli binary #\n bitcoin_cli_SOURCES = bitcoin-cli.cpp\n@@ -407,14 +407,14 @@ bitcoin_cli_LDADD = \\\n bitcoin_cli_LDADD += $(BOOST_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(EVENT_LIBS)\n #\n \n-# bitcoin-tx binary #\n-bitcoin_tx_SOURCES = bitcoin-tx.cpp\n+# globaltoken-tx binary #\n+bitcoin_tx_SOURCES = globaltoken-tx.cpp\n bitcoin_tx_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n bitcoin_tx_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n bitcoin_tx_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n if TARGET_WINDOWS\n-bitcoin_tx_SOURCES += bitcoin-tx-res.rc\n+bitcoin_tx_SOURCES += globaltoken-tx-res.rc\n endif\n \n bitcoin_tx_LDADD = \\"
      },
      {
        "sha": "97249549437405e0cfec192ee0bcd75c2387899d",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -2,7 +2,7 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-bin_PROGRAMS += qt/bitcoin-qt\n+bin_PROGRAMS += qt/globaltoken-qt\n EXTRA_LIBRARIES += qt/libbitcoinqt.a\n \n # bitcoin qt core #\n@@ -360,7 +360,7 @@ RES_IMAGES =\n \n RES_MOVIES = $(wildcard $(srcdir)/qt/res/movies/spinner-*.png)\n \n-BITCOIN_RC = qt/res/bitcoin-qt-res.rc\n+BITCOIN_RC = qt/res/globaltoken-qt-res.rc\n \n BITCOIN_QT_INCLUDES = -I$(builddir)/qt -I$(srcdir)/qt -I$(srcdir)/qt/forms \\\n   -I$(builddir)/qt/forms -DQT_NO_KEYWORDS\n@@ -388,7 +388,7 @@ $(qt_libbitcoinqt_a_OBJECTS) $(qt_bitcoin_qt_OBJECTS) : | $(QT_MOC)\n $(QT_MOC): $(PROTOBUF_H)\n $(QT_MOC_CPP): $(PROTOBUF_H)\n \n-# bitcoin-qt binary #\n+# globaltoken-qt binary #\n qt_bitcoin_qt_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BITCOIN_QT_INCLUDES) \\\n   $(QT_INCLUDES) $(PROTOBUF_CFLAGS) $(QR_CFLAGS)\n qt_bitcoin_qt_CXXFLAGS = $(AM_CXXFLAGS) $(QT_PIE_FLAGS)\n@@ -443,9 +443,9 @@ CLEAN_QT = $(nodist_qt_libbitcoinqt_a_SOURCES) $(QT_QM) $(QT_FORMS_H) qt/*.gcda\n CLEANFILES += $(CLEAN_QT)\n \n bitcoin_qt_clean: FORCE\n-\trm -f $(CLEAN_QT) $(qt_libbitcoinqt_a_OBJECTS) $(qt_bitcoin_qt_OBJECTS) qt/bitcoin-qt$(EXEEXT) $(LIBBITCOINQT)\n+\trm -f $(CLEAN_QT) $(qt_libbitcoinqt_a_OBJECTS) $(qt_bitcoin_qt_OBJECTS) qt/globaltoken-qt$(EXEEXT) $(LIBBITCOINQT)\n \n-bitcoin_qt : qt/bitcoin-qt$(EXEEXT)\n+bitcoin_qt : qt/globaltoken-qt$(EXEEXT)\n \n ui_%.h: %.ui\n \t@test -f $(UIC)"
      },
      {
        "sha": "3c83e767681fe076421f08c2e25cd2ef1a84e7b9",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -2,8 +2,8 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-bin_PROGRAMS += qt/test/test_bitcoin-qt\n-TESTS += qt/test/test_bitcoin-qt\n+bin_PROGRAMS += qt/test/test_globaltoken-qt\n+TESTS += qt/test/test_globaltoken-qt\n \n TEST_QT_MOC_CPP = \\\n   qt/test/moc_compattests.cpp \\\n@@ -70,9 +70,9 @@ CLEAN_BITCOIN_QT_TEST = $(TEST_QT_MOC_CPP) qt/test/*.gcda qt/test/*.gcno\n \n CLEANFILES += $(CLEAN_BITCOIN_QT_TEST)\n \n-test_bitcoin_qt : qt/test/test_bitcoin-qt$(EXEEXT)\n+test_bitcoin_qt : qt/test/test_globaltoken-qt$(EXEEXT)\n \n-test_bitcoin_qt_check : qt/test/test_bitcoin-qt$(EXEEXT) FORCE\n+test_bitcoin_qt_check : qt/test/test_globaltoken-qt$(EXEEXT) FORCE\n \t$(MAKE) check-TESTS TESTS=$^\n \n test_bitcoin_qt_clean: FORCE"
      },
      {
        "sha": "2fde76d9c9bab80d544dec5e2ee69c65999950d0",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -47,7 +47,7 @@ std::string HelpMessageCli()\n     strUsage += HelpMessageOpt(\"-rpcpassword=<pw>\", _(\"Password for JSON-RPC connections\"));\n     strUsage += HelpMessageOpt(\"-rpcclienttimeout=<n>\", strprintf(_(\"Timeout in seconds during HTTP requests, or 0 for no timeout. (default: %d)\"), DEFAULT_HTTP_CLIENT_TIMEOUT));\n     strUsage += HelpMessageOpt(\"-stdin\", _(\"Read extra arguments from standard input, one per line until EOF/Ctrl-D (recommended for sensitive information such as passphrases)\"));\n-    strUsage += HelpMessageOpt(\"-rpcwallet=<walletname>\", _(\"Send RPC for non-default wallet on RPC server (argument is wallet filename in bitcoind directory, required if bitcoind/-Qt runs with multiple wallets)\"));\n+    strUsage += HelpMessageOpt(\"-rpcwallet=<walletname>\", _(\"Send RPC for non-default wallet on RPC server (argument is wallet filename in globaltokend directory, required if globaltokend/-Qt runs with multiple wallets)\"));\n \n     return strUsage;\n }"
      },
      {
        "sha": "1b41dbec7ec4f1b9e9606482ec7b231985ed8ba1",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -125,7 +125,7 @@ bool AppInit(int argc, char* argv[])\n             }\n         }\n \n-        // -server defaults to true for bitcoind but not for the GUI so do this here\n+        // -server defaults to true for globaltokend but not for the GUI so do this here\n         SoftSetBoolArg(\"-server\", true);\n         // Set this early so that parameter interactions go to console\n         InitLogging();\n@@ -192,7 +192,7 @@ int main(int argc, char* argv[])\n {\n     SetupEnvironment();\n \n-    // Connect bitcoind signal handlers\n+    // Connect globaltokend signal handlers\n     noui_connect();\n \n     return (AppInit(argc, argv) ? EXIT_SUCCESS : EXIT_FAILURE);"
      },
      {
        "sha": "7cc750f389a26aa03417fa38d4a25cd1614c2a3c",
        "filename": "src/chainparamsbase.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/chainparamsbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/chainparamsbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.h?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -10,7 +10,7 @@\n #include <vector>\n \n /**\n- * CBaseChainParams defines the base parameters (shared between bitcoin-cli and bitcoind)\n+ * CBaseChainParams defines the base parameters (shared between bitcoin-cli and globaltokend)\n  * of a given instance of the Bitcoin system.\n  */\n class CBaseChainParams"
      },
      {
        "sha": "bf9e5ee02a06677103286947937c76585c60f211",
        "filename": "src/clientversion.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/clientversion.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/clientversion.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.cpp?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -11,7 +11,7 @@\n \n /**\n  * Name of client reported in the 'version' message. Report the same name\n- * for both bitcoind and bitcoin-core, to make it harder for attackers to\n+ * for both globaltokend and bitcoin-core, to make it harder for attackers to\n  * target servers or GUI users specifically.\n  */\n const std::string CLIENT_NAME(\"Globaltokshi\");"
      },
      {
        "sha": "4f466a66c7d7dafc71cb651b4afb64102d9beeef",
        "filename": "src/clientversion.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/clientversion.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/clientversion.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.h?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -25,7 +25,7 @@\n #define COPYRIGHT_STR \"2009-\" STRINGIZE(COPYRIGHT_YEAR) \" \" COPYRIGHT_HOLDERS_FINAL\n \n /**\n- * bitcoind-res.rc includes this file, but it cannot cope with real c++ code.\n+ * globaltokend-res.rc includes this file, but it cannot cope with real c++ code.\n  * WINDRES_PREPROC is defined to indicate that its pre-processor is running.\n  * Anything other than a define should be guarded below.\n  */"
      },
      {
        "sha": "3106f155a839c2209a029f46e0ce5858f740d80a",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,5 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n // Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -131,7 +132,7 @@ bool ShutdownRequested()\n /**\n  * This is a minimally invasive approach to shutdown on LevelDB read errors from the\n  * chainstate, while keeping user interface out of the common library, which is shared\n- * between bitcoind, and bitcoin-qt and non-server tools.\n+ * between globaltokend, and globaltoken-qt and non-server tools.\n */\n class CCoinsViewErrorCatcher : public CCoinsViewBacked\n {\n@@ -519,10 +520,10 @@ std::string HelpMessage(HelpMessageMode mode)\n \n std::string LicenseInfo()\n {\n-    const std::string URL_SOURCE_CODE = \"<https://github.com/bitcoin/bitcoin>\";\n-    const std::string URL_WEBSITE = \"<https://bitcoincore.org>\";\n+    const std::string URL_SOURCE_CODE = \"<https://github.com/globaltoken/globaltoken>\";\n+    const std::string URL_WEBSITE = \"<https://globaltoken.org>\";\n \n-    return CopyrightHolders(strprintf(_(\"Copyright (C) %i-%i\"), 2009, COPYRIGHT_YEAR) + \" \") + \"\\n\" +\n+    return CopyrightHolders(strprintf(_(\"Copyright (C) %i-%i\"), 2009, COPYRIGHT_YEAR) + \" \") + \"\\n\" + CopyrightHoldersGLT(strprintf(_(\"Copyright (C) %i\"), COPYRIGHT_YEAR) + \" \") + \"\\n\" +\n            \"\\n\" +\n            strprintf(_(\"Please contribute if you find %s useful. \"\n                        \"Visit %s for further information about the software.\"),"
      },
      {
        "sha": "774c208356b50601ca05da5084b7c43571e587a1",
        "filename": "src/noui.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/noui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/noui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/noui.cpp?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -51,7 +51,7 @@ static void noui_InitMessage(const std::string& message)\n \n void noui_connect()\n {\n-    // Connect bitcoind signal handlers\n+    // Connect globaltokend signal handlers\n     uiInterface.ThreadSafeMessageBox.connect(noui_ThreadSafeMessageBox);\n     uiInterface.ThreadSafeQuestion.connect(noui_ThreadSafeQuestion);\n     uiInterface.InitMessage.connect(noui_InitMessage);"
      },
      {
        "sha": "697c1c2b2d338790900da1aabe88b6d4e96ac461",
        "filename": "src/qt/Makefile",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/Makefile?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -5,5 +5,5 @@ clean: FORCE\n \t$(MAKE) -C .. bitcoin_qt_clean test_bitcoin_qt_clean\n check: FORCE\n \t$(MAKE) -C .. test_bitcoin_qt_check\n-bitcoin-qt bitcoin-qt.exe: FORCE\n+globaltoken-qt globaltoken-qt.exe: FORCE\n \t $(MAKE) -C .. bitcoin_qt"
      },
      {
        "sha": "b4724071340f1de4985237f0d10771c229040c4b",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -371,7 +371,7 @@ void BitcoinGUI::createActions()\n     usedReceivingAddressesAction->setStatusTip(tr(\"Show the list of used receiving addresses and labels\"));\n \n     openAction = new QAction(platformStyle->TextColorIcon(\":/icons/open\"), tr(\"Open &URI...\"), this);\n-    openAction->setStatusTip(tr(\"Open a bitcoin: URI or payment request\"));\n+    openAction->setStatusTip(tr(\"Open a globaltoken: URI or payment request\"));\n \n     showHelpMessageAction = new QAction(platformStyle->TextColorIcon(\":/icons/info\"), tr(\"&Command-line options\"), this);\n     showHelpMessageAction->setMenuRole(QAction::NoRole);"
      },
      {
        "sha": "3767c279854e337e6b3adefd3c0b93d3a92dd3c7",
        "filename": "src/qt/intro.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/intro.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/intro.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/intro.cpp?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -229,7 +229,7 @@ bool Intro::pickDataDirectory()\n     }\n     /* Only override -datadir if different from the default, to make it possible to\n      * override -datadir in the bitcoin.conf file in the default data directory\n-     * (to be consistent with bitcoind behavior)\n+     * (to be consistent with globaltokend behavior)\n      */\n     if(dataDir != getDefaultDataDirectory())\n         SoftSetArg(\"-datadir\", GUIUtil::qstringToBoostPath(dataDir).string()); // use OS locale for path setting"
      },
      {
        "sha": "479f1d823520957bcb9ad13f87e8ef200a338b3e",
        "filename": "src/qt/res/bitcoin-qt-res.rc",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/res/bitcoin-qt-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/res/bitcoin-qt-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/bitcoin-qt-res.rc?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,4 +1,4 @@\n-IDI_ICON1 ICON DISCARDABLE \"icons/bitcoin.ico\"\n+IDI_ICON1 ICON DISCARDABLE \"icons/icon_wallet.ico\"\n IDI_ICON2 ICON DISCARDABLE \"icons/bitcoin_testnet.ico\"\n \n #include <windows.h>             // needed for VERSIONINFO"
      },
      {
        "sha": "c195ef3085efdeb3c9cfd8edc123e64b0a1f9dd7",
        "filename": "src/qt/res/icons/bitcoin_testnet.ico",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/res/icons/bitcoin_testnet.ico",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/res/icons/bitcoin_testnet.ico",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/icons/bitcoin_testnet.ico?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00"
      },
      {
        "sha": "dfab84db6d2cda6837191899f7460abc2d2267c0",
        "filename": "src/qt/res/icons/icon_wallet.ico",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/res/icons/icon_wallet.ico",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/res/icons/icon_wallet.ico",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/icons/icon_wallet.ico?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00"
      },
      {
        "sha": "5484ea8e579602be9716b1c7cac2881f42ffeb22",
        "filename": "src/qt/splashscreen.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/splashscreen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/splashscreen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.cpp?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,4 +1,5 @@\n // Copyright (c) 2011-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -45,6 +46,7 @@ SplashScreen::SplashScreen(Qt::WindowFlags f, const NetworkStyle *networkStyle)\n     QString titleText       = tr(PACKAGE_NAME);\n     QString versionText     = QString(\"Version %1\").arg(QString::fromStdString(FormatFullVersion()));\n     QString copyrightText   = QString::fromUtf8(CopyrightHolders(strprintf(\"\\xc2\\xA9 %u-%u \", 2009, COPYRIGHT_YEAR)).c_str());\n+\tQString globaltokenText = QString::fromUtf8(CopyrightHoldersGLT(strprintf(\"\\xc2\\xA9 %u \", COPYRIGHT_YEAR)).c_str());\n     QString titleAddText    = networkStyle->getTitleAddText();\n \n     QString font            = QApplication::font().toString();\n@@ -105,8 +107,11 @@ SplashScreen::SplashScreen(Qt::WindowFlags f, const NetworkStyle *networkStyle)\n         pixPaint.setFont(QFont(font, 10*fontFactor));\n         const int x = pixmap.width()/devicePixelRatio-titleTextWidth-paddingRight;\n         const int y = paddingTop+titleCopyrightVSpace;\n+\t\tconst int y_glt = paddingTop+titleCopyrightVSpace+12;\n         QRect copyrightRect(x, y, pixmap.width() - x - paddingRight, pixmap.height() - y);\n+\t\tQRect copyrightRect_GLT(x, y_glt, pixmap.width() - x - paddingRight, pixmap.height() - y_glt);\n         pixPaint.drawText(copyrightRect, Qt::AlignLeft | Qt::AlignTop | Qt::TextWordWrap, copyrightText);\n+\t\tpixPaint.drawText(copyrightRect, Qt::AlignLeft | Qt::AlignTop | Qt::TextWordWrap, globaltokenText);\n     }\n \n     // draw additional text if special network"
      },
      {
        "sha": "8ff9926a4254513fd3be04e6ac317f3cecd4cc91",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -137,9 +137,9 @@ void BumpFee(TransactionView& view, const uint256& txid, bool expectDisabled, st\n //\n // This also requires overriding the default minimal Qt platform:\n //\n-//     src/qt/test/test_bitcoin-qt -platform xcb      # Linux\n-//     src/qt/test/test_bitcoin-qt -platform windows  # Windows\n-//     src/qt/test/test_bitcoin-qt -platform cocoa    # macOS\n+//     src/qt/test/test_globaltoken-qt -platform xcb      # Linux\n+//     src/qt/test/test_globaltoken-qt -platform windows  # Windows\n+//     src/qt/test/test_globaltoken-qt -platform cocoa    # macOS\n void TestSendCoins()\n {\n     // Set up wallet and chain with 105 blocks (5 mature blocks for spending)."
      },
      {
        "sha": "2ff639587e326584ed2690dcbafa346647c6e8d4",
        "filename": "src/qt/utilitydialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/utilitydialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/qt/utilitydialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.cpp?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -70,7 +70,7 @@ HelpMessageDialog::HelpMessageDialog(QWidget *parent, bool about) :\n     } else {\n         setWindowTitle(tr(\"Command-line options\"));\n         QString header = tr(\"Usage:\") + \"\\n\" +\n-            \"  bitcoin-qt [\" + tr(\"command-line options\") + \"]                     \" + \"\\n\";\n+            \"  globaltoken-qt [\" + tr(\"command-line options\") + \"]                     \" + \"\\n\";\n         QTextCursor cursor(ui->helpMessage->document());\n         cursor.insertText(version);\n         cursor.insertBlock();"
      },
      {
        "sha": "fe3d8b70d77f224d4eb12202fbf42ffdce029cc5",
        "filename": "src/rpc/protocol.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/rpc/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/rpc/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/protocol.h?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -39,7 +39,7 @@ enum RPCErrorCode\n     // It should not be used for application-layer errors.\n     RPC_METHOD_NOT_FOUND = -32601,\n     RPC_INVALID_PARAMS   = -32602,\n-    // RPC_INTERNAL_ERROR should only be used for genuine errors in bitcoind\n+    // RPC_INTERNAL_ERROR should only be used for genuine errors in globaltokend\n     // (for example datadir corruption).\n     RPC_INTERNAL_ERROR   = -32603,\n     RPC_PARSE_ERROR      = -32700,"
      },
      {
        "sha": "1b3f525edff88cbfef66026287a2f7f3bb641907",
        "filename": "src/test/README.md",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/test/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/test/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/README.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -5,15 +5,15 @@ and tests weren't explicitly disabled.\n \n After configuring, they can be run with `make check`.\n \n-To run the bitcoind tests manually, launch `src/test/test_bitcoin`.\n+To run the globaltokend tests manually, launch `src/test/test_bitcoin`.\n \n-To add more bitcoind tests, add `BOOST_AUTO_TEST_CASE` functions to the existing\n+To add more globaltokend tests, add `BOOST_AUTO_TEST_CASE` functions to the existing\n .cpp files in the `test/` directory or add new .cpp files that\n implement new BOOST_AUTO_TEST_SUITE sections.\n \n-To run the bitcoin-qt tests manually, launch `src/qt/test/test_bitcoin-qt`\n+To run the globaltoken-qt tests manually, launch `src/qt/test/test_globaltoken-qt`\n \n-To add more bitcoin-qt tests, add them to the `src/qt/test/` directory and\n+To add more globaltoken-qt tests, add them to the `src/qt/test/` directory and\n the `src/qt/test/test_main.cpp` file.\n \n ### Running individual tests"
      },
      {
        "sha": "03a840a134907ef84f780c4b5f11b8af15318ead",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -895,6 +895,17 @@ std::string CopyrightHolders(const std::string& strPrefix)\n     return strCopyrightHolders;\n }\n \n+std::string CopyrightHoldersGLT(const std::string& strPrefix)\n+{\n+    std::string strCopyrightHolders = strPrefix + strprintf(_(COPYRIGHT_HOLDERS), _(COPYRIGHT_HOLDERS_SUBSTITUTION_GLT));\n+\n+    // Check for untranslated substitution to make sure Bitcoin Core copyright is not removed by accident\n+    if (strprintf(COPYRIGHT_HOLDERS, COPYRIGHT_HOLDERS_SUBSTITUTION_GLT).find(\"Globaltoken Core\") == std::string::npos) {\n+        strCopyrightHolders += \"\\n\" + strPrefix + \"The Globaltoken Core developers\";\n+    }\n+    return strCopyrightHolders;\n+}\n+\n // Obtain the application startup time (used for uptime calculation)\n int64_t GetStartupTime()\n {"
      },
      {
        "sha": "954cfabe6e735d1c9c01970237c9e12a78a121f4",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -597,7 +597,7 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n             \"dumpwallet \\\"filename\\\"\\n\"\n             \"\\nDumps all wallet keys in a human-readable format.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. \\\"filename\\\"    (string, required) The filename with path (either absolute or relative to bitcoind)\\n\"\n+            \"1. \\\"filename\\\"    (string, required) The filename with path (either absolute or relative to globaltokend)\\n\"\n             \"\\nResult:\\n\"\n             \"{                           (json object)\\n\"\n             \"  \\\"filename\\\" : {        (string) The filename with full absolute path\\n\"\n@@ -1147,7 +1147,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n                                       \"block from time %d, which is after or within %d seconds of key creation, and \"\n                                       \"could contain transactions pertaining to the key. As a result, transactions \"\n                                       \"and coins using this key may not appear in the wallet. This error could be \"\n-                                      \"caused by pruning or data corruption (see bitcoind log for details) and could \"\n+                                      \"caused by pruning or data corruption (see globaltokend log for details) and could \"\n                                       \"be dealt with by downloading and rescanning the relevant blocks (see -reindex \"\n                                       \"and -rescan options).\",\n                                 GetImportTimestamp(request, now), scannedTime - TIMESTAMP_WINDOW - 1, TIMESTAMP_WINDOW)));"
      },
      {
        "sha": "443602ff7fef5d73f27239ce4529cf86044f7078",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -431,7 +431,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n                       \"timestamp %d. There was an error reading a block from time %d, which is after or within %d \"\n                       \"seconds of key creation, and could contain transactions pertaining to the key. As a result, \"\n                       \"transactions and coins using this key may not appear in the wallet. This error could be caused \"\n-                      \"by pruning or data corruption (see bitcoind log for details) and could be dealt with by \"\n+                      \"by pruning or data corruption (see globaltokend log for details) and could be dealt with by \"\n                       \"downloading and rescanning the relevant blocks (see -reindex and -rescan \"\n                       \"options).\\\"}},{\\\"success\\\":true}]\",\n                               0, oldTip->GetBlockTimeMax(), TIMESTAMP_WINDOW));"
      },
      {
        "sha": "6d865a1f5ae4043036fad16e48133d70342402dc",
        "filename": "test/README.md",
        "status": "modified",
        "additions": 21,
        "deletions": 21,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/README.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,15 +1,15 @@\n-This directory contains integration tests that test bitcoind and its\n+This directory contains integration tests that test globaltokend and its\n utilities in their entirety. It does not contain unit tests, which\n can be found in [/src/test](/src/test), [/src/wallet/test](/src/wallet/test),\n etc.\n \n There are currently two sets of tests in this directory:\n \n - [functional](/test/functional) which test the functionality of \n-bitcoind and bitcoin-qt by interacting with them through the RPC and P2P\n+globaltokend and globaltoken-qt by interacting with them through the RPC and P2P\n interfaces.\n - [util](test/util) which tests the bitcoin utilities, currently only\n-bitcoin-tx.\n+globaltoken-tx.\n \n The util tests are run as part of `make check` target. The functional\n tests are run by the travis continuous build process whenever a pull\n@@ -70,29 +70,29 @@ options. Run `test_runner.py -h` to see them all.\n \n ##### Resource contention\n \n-The P2P and RPC ports used by the bitcoind nodes-under-test are chosen to make\n-conflicts with other processes unlikely. However, if there is another bitcoind\n+The P2P and RPC ports used by the globaltokend nodes-under-test are chosen to make\n+conflicts with other processes unlikely. However, if there is another globaltokend\n process running on the system (perhaps from a previous test which hasn't successfully\n-killed all its bitcoind nodes), then there may be a port conflict which will\n+killed all its globaltokend nodes), then there may be a port conflict which will\n cause the test to fail. It is recommended that you run the tests on a system\n-where no other bitcoind processes are running.\n+where no other globaltokend processes are running.\n \n On linux, the test_framework will warn if there is another\n-bitcoind process running when the tests are started.\n+globaltokend process running when the tests are started.\n \n-If there are zombie bitcoind processes after test failure, you can kill them\n+If there are zombie globaltokend processes after test failure, you can kill them\n by running the following commands. **Note that these commands will kill all\n-bitcoind processes running on the system, so should not be used if any non-test\n-bitcoind processes are being run.**\n+globaltokend processes running on the system, so should not be used if any non-test\n+globaltokend processes are being run.**\n \n ```bash\n-killall bitcoind\n+killall globaltokend\n ```\n \n or\n \n ```bash\n-pkill -9 bitcoind\n+pkill -9 globaltokend\n ```\n \n \n@@ -103,11 +103,11 @@ functional test is run and is stored in test/cache. This speeds up\n test startup times since new blockchains don't need to be generated for\n each test. However, the cache may get into a bad state, in which case\n tests will fail. If this happens, remove the cache directory (and make\n-sure bitcoind processes are stopped as above):\n+sure globaltokend processes are stopped as above):\n \n ```bash\n rm -rf cache\n-killall bitcoind\n+killall globaltokend\n ```\n \n ##### Test logging\n@@ -120,13 +120,13 @@ default:\n - when run directly, *all* logs are written to `test_framework.log` and INFO\n   level and above are output to the console.\n - when run on Travis, no logs are output to the console. However, if a test\n-  fails, the `test_framework.log` and bitcoind `debug.log`s will all be dumped\n+  fails, the `test_framework.log` and globaltokend `debug.log`s will all be dumped\n   to the console to help troubleshooting.\n \n To change the level of logs output to the console, use the `-l` command line\n argument.\n \n-`test_framework.log` and bitcoind `debug.log`s can be combined into a single\n+`test_framework.log` and globaltokend `debug.log`s can be combined into a single\n aggregate log by running the `combine_logs.py` script. The output can be plain\n text, colorized text or html. For example:\n \n@@ -153,9 +153,9 @@ import pdb; pdb.set_trace()\n ```\n \n anywhere in the test. You will then be able to inspect variables, as well as\n-call methods that interact with the bitcoind nodes-under-test.\n+call methods that interact with the globaltokend nodes-under-test.\n \n-If further introspection of the bitcoind instances themselves becomes\n+If further introspection of the globaltokend instances themselves becomes\n necessary, this can be accomplished by first setting a pdb breakpoint\n at an appropriate location, running the test to that point, then using\n `gdb` to attach to the process and debug.\n@@ -169,8 +169,8 @@ For instance, to attach to `self.node[1]` during a run:\n use the directory path to get the pid from the pid file:\n \n ```bash\n-cat /tmp/user/1000/testo9vsdjo3/node1/regtest/bitcoind.pid\n-gdb /home/example/bitcoind <pid>\n+cat /tmp/user/1000/testo9vsdjo3/node1/regtest/globaltokend.pid\n+gdb /home/example/globaltokend <pid>\n ```\n \n Note: gdb attach step may require `sudo`"
      },
      {
        "sha": "48fc9003509960fea04110e9bb1a0288de38a49a",
        "filename": "test/functional/README.md",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/README.md?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -60,10 +60,10 @@ over the network (`CBlock`, `CTransaction`, etc, along with the network-level\n wrappers for them, `msg_block`, `msg_tx`, etc).\n \n - P2P tests have two threads. One thread handles all network communication\n-with the bitcoind(s) being tested (using python's asyncore package); the other\n+with the globaltokend(s) being tested (using python's asyncore package); the other\n implements the test logic.\n \n-- `NodeConn` is the class used to connect to a bitcoind.  If you implement\n+- `NodeConn` is the class used to connect to a globaltokend.  If you implement\n a callback class that derives from `NodeConnCB` and pass that to the\n `NodeConn` object, your code will receive the appropriate callbacks when\n events of interest arrive.\n@@ -78,14 +78,14 @@ Examples tests are `p2p-accept-block.py`, `p2p-compactblocks.py`.\n #### Comptool\n \n - Comptool is a Testing framework for writing tests that compare the block/tx acceptance\n-behavior of a bitcoind against 1 or more other bitcoind instances. It should not be used\n+behavior of a globaltokend against 1 or more other globaltokend instances. It should not be used\n to write static tests with known outcomes, since that type of test is easier to write and\n maintain using the standard BitcoinTestFramework.\n \n - Set the `num_nodes` variable (defined in `ComparisonTestFramework`) to start up\n 1 or more nodes.  If using 1 node, then `--testbinary` can be used as a command line\n-option to change the bitcoind binary used by the test.  If using 2 or more nodes,\n-then `--refbinary` can be optionally used to change the bitcoind that will be used\n+option to change the globaltokend binary used by the test.  If using 2 or more nodes,\n+then `--refbinary` can be optionally used to change the globaltokend that will be used\n on nodes 2 and up.\n \n - Implement a (generator) function called `get_tests()` which yields `TestInstance`s.\n@@ -94,13 +94,13 @@ Each `TestInstance` consists of:\n     * `object` is a `CBlock`, `CTransaction`, or\n     `CBlockHeader`.  `CBlock`'s and `CTransaction`'s are tested for\n     acceptance.  `CBlockHeader`s can be used so that the test runner can deliver\n-    complete headers-chains when requested from the bitcoind, to allow writing\n+    complete headers-chains when requested from the globaltokend, to allow writing\n     tests where blocks can be delivered out of order but still processed by\n-    headers-first bitcoind's.\n+    headers-first globaltokend's.\n     * `outcome` is `True`, `False`, or `None`.  If `True`\n     or `False`, the tip is compared with the expected tip -- either the\n     block passed in, or the hash specified as the optional 3rd entry.  If\n-    `None` is specified, then the test will compare all the bitcoind's\n+    `None` is specified, then the test will compare all the globaltokend's\n     being tested to see if they all agree on what the best tip is.\n     * `hash` is the block hash of the tip to compare against. Optional to\n     specify; if left out then the hash of the block passed in will be used as\n@@ -114,7 +114,7 @@ Each `TestInstance` consists of:\n     sequence and synced (this is slower when processing many blocks).\n   - `sync_every_transaction`: `True/False`.  Analogous to\n     `sync_every_block`, except if the outcome on the last tx is \"None\",\n-    then the contents of the entire mempool are compared across all bitcoind\n+    then the contents of the entire mempool are compared across all globaltokend\n     connections.  If `True` or `False`, then only the last tx's\n     acceptance is tested against the given outcome.\n \n@@ -133,7 +133,7 @@ Base class for functional tests.\n Generally useful functions.\n \n #### [test_framework/mininode.py](test_framework/mininode.py)\n-Basic code to support P2P connectivity to a bitcoind.\n+Basic code to support P2P connectivity to a globaltokend.\n \n #### [test_framework/comptool.py](test_framework/comptool.py)\n Framework for comparison-tool style, P2P tests."
      },
      {
        "sha": "6449134b086ff3b4146bd5cfe037478ec6775cc0",
        "filename": "test/functional/blockchain.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/blockchain.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -139,13 +139,13 @@ def _test_stopatheight(self):\n         self.nodes[0].generate(6)\n         assert_equal(self.nodes[0].getblockcount(), 206)\n         self.log.debug('Node should not stop at this height')\n-        assert_raises(subprocess.TimeoutExpired, lambda: self.bitcoind_processes[0].wait(timeout=3))\n+        assert_raises(subprocess.TimeoutExpired, lambda: self.globaltokend_processes[0].wait(timeout=3))\n         try:\n             self.nodes[0].generate(1)\n         except (ConnectionError, http.client.BadStatusLine):\n             pass  # The node already shut down before response\n         self.log.debug('Node should stop at this height...')\n-        self.bitcoind_processes[0].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n+        self.globaltokend_processes[0].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n         self.nodes[0] = self.start_node(0, self.options.tmpdir)\n         assert_equal(self.nodes[0].getblockcount(), 207)\n "
      },
      {
        "sha": "5c84617a09f05a8db03cca61802fe7270c23f38d",
        "filename": "test/functional/bumpfee.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/bumpfee.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/bumpfee.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/bumpfee.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -42,7 +42,7 @@ def setup_network(self, split=False):\n \n         # Encrypt wallet for test_locked_wallet_fails test\n         self.nodes[1].encryptwallet(WALLET_PASSPHRASE)\n-        self.bitcoind_processes[1].wait()\n+        self.globaltokend_processes[1].wait()\n         self.nodes[1] = self.start_node(1, self.options.tmpdir, extra_args[1])\n         self.nodes[1].walletpassphrase(WALLET_PASSPHRASE, WALLET_PASSPHRASE_TIMEOUT)\n "
      },
      {
        "sha": "09a4345a85c1159a02b0f23930349fce7721215a",
        "filename": "test/functional/dbcrash.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/dbcrash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/dbcrash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/dbcrash.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -83,14 +83,14 @@ def restart_node(self, node_index, expected_tip):\n                 return utxo_hash\n             except:\n                 # An exception here should mean the node is about to crash.\n-                # If bitcoind exits, then try again.  wait_for_node_exit()\n-                # should raise an exception if bitcoind doesn't exit.\n+                # If globaltokend exits, then try again.  wait_for_node_exit()\n+                # should raise an exception if globaltokend doesn't exit.\n                 self.wait_for_node_exit(node_index, timeout=10)\n             self.crashed_on_restart += 1\n             time.sleep(1)\n \n-        # If we got here, bitcoind isn't coming back up on restart.  Could be a\n-        # bug in bitcoind, or we've gotten unlucky with our dbcrash ratio --\n+        # If we got here, globaltokend isn't coming back up on restart.  Could be a\n+        # bug in globaltokend, or we've gotten unlucky with our dbcrash ratio --\n         # perhaps we generated a test case that blew up our cache?\n         # TODO: If this happens a lot, we should try to restart without -dbcrashratio\n         # and make sure that recovery happens."
      },
      {
        "sha": "822ba0edce799667e495154e1a18f0e10244eb0f",
        "filename": "test/functional/forknotify.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/forknotify.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/forknotify.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/forknotify.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -40,7 +40,7 @@ def run_test(self):\n         self.nodes[1].generate(1)\n         self.sync_all()\n \n-        # Give bitcoind 10 seconds to write the alert notification\n+        # Give globaltokend 10 seconds to write the alert notification\n         timeout = 10.0\n         while timeout > 0:\n             if os.path.exists(self.alert_filename) and os.path.getsize(self.alert_filename):"
      },
      {
        "sha": "0ec640ec605687a12cadbcc90c8de743cfb893b0",
        "filename": "test/functional/fundrawtransaction.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/fundrawtransaction.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -452,7 +452,7 @@ def run_test(self):\n         self.stop_node(2)\n         self.stop_node(3)\n         self.nodes[1].encryptwallet(\"test\")\n-        self.bitcoind_processes[1].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n+        self.globaltokend_processes[1].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n \n         self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir)\n         # This test is not meant to test fee estimation and we'd like"
      },
      {
        "sha": "df34de82da27ca9173f2638957d7af6234524bce",
        "filename": "test/functional/httpbasics.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/httpbasics.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/httpbasics.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/httpbasics.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -90,7 +90,7 @@ def run_test(self):\n         conn.request('POST', '/', '{\"method\": \"getbestblockhash\"}', headers)\n         out1 = conn.getresponse().read()\n         assert(b'\"error\":null' in out1)\n-        assert(conn.sock!=None) #connection must be closed because bitcoind should use keep-alive by default\n+        assert(conn.sock!=None) #connection must be closed because globaltokend should use keep-alive by default\n \n         # Check excessive request size\n         conn = http.client.HTTPConnection(urlNode2.hostname, urlNode2.port)"
      },
      {
        "sha": "b0932f46b719f8c0eafde8e0845724a37daaf101",
        "filename": "test/functional/keypool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/keypool.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -18,7 +18,7 @@ def run_test(self):\n         \n         # Encrypt wallet and wait to terminate\n         nodes[0].encryptwallet('test')\n-        self.bitcoind_processes[0].wait()\n+        self.globaltokend_processes[0].wait()\n         # Restart node 0\n         nodes[0] = self.start_node(0, self.options.tmpdir)\n         # Keep creating keys"
      },
      {
        "sha": "8da13399c62f9d11f0f4969c4aa17e36646f2f11",
        "filename": "test/functional/mempool_persist.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/mempool_persist.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/mempool_persist.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_persist.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -4,7 +4,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test mempool persistence.\n \n-By default, bitcoind will dump mempool on shutdown and\n+By default, globaltokend will dump mempool on shutdown and\n then reload it on startup. This can be overridden with\n the -persistmempool=0 command line option.\n \n@@ -67,7 +67,7 @@ def run_test(self):\n         self.nodes = []\n         self.nodes.append(self.start_node(0, self.options.tmpdir))\n         self.nodes.append(self.start_node(1, self.options.tmpdir))\n-        # Give bitcoind a second to reload the mempool\n+        # Give globaltokend a second to reload the mempool\n         time.sleep(1)\n         assert wait_until(lambda: len(self.nodes[0].getrawmempool()) == 5)\n         assert_equal(len(self.nodes[1].getrawmempool()), 0)\n@@ -76,7 +76,7 @@ def run_test(self):\n         self.stop_nodes()\n         self.nodes = []\n         self.nodes.append(self.start_node(0, self.options.tmpdir, [\"-persistmempool=0\"]))\n-        # Give bitcoind a second to reload the mempool\n+        # Give globaltokend a second to reload the mempool\n         time.sleep(1)\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n "
      },
      {
        "sha": "6972c8edb7efb938f360c006b49d969bd9c4894c",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -57,8 +57,8 @@\n class AcceptBlockTest(BitcoinTestFramework):\n     def add_options(self, parser):\n         parser.add_option(\"--testbinary\", dest=\"testbinary\",\n-                          default=os.getenv(\"BITCOIND\", \"bitcoind\"),\n-                          help=\"bitcoind binary to test\")\n+                          default=os.getenv(\"BITCOIND\", \"globaltokend\"),\n+                          help=\"globaltokend binary to test\")\n \n     def __init__(self):\n         super().__init__()"
      },
      {
        "sha": "fb0d78e4ee7c0e9759a011b346b0fdc40afd2608",
        "filename": "test/functional/p2p-compactblocks.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/p2p-compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/p2p-compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-compactblocks.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -14,7 +14,7 @@\n from test_framework.blocktools import create_block, create_coinbase, add_witness_commitment\n from test_framework.script import CScript, OP_TRUE\n \n-# TestNode: A peer we use to send messages to bitcoind, and store responses.\n+# TestNode: A peer we use to send messages to globaltokend, and store responses.\n class TestNode(NodeConnCB):\n     def __init__(self):\n         super().__init__()\n@@ -240,7 +240,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n             old_node.request_headers_and_sync(locator=[tip])\n             check_announcement_of_new_block(node, old_node, lambda p: \"cmpctblock\" in p.last_message)\n \n-    # This test actually causes bitcoind to (reasonably!) disconnect us, so do this last.\n+    # This test actually causes globaltokend to (reasonably!) disconnect us, so do this last.\n     def test_invalid_cmpctblock_message(self):\n         self.nodes[0].generate(101)\n         block = self.build_block_on_tip(self.nodes[0])\n@@ -255,7 +255,7 @@ def test_invalid_cmpctblock_message(self):\n         assert_equal(int(self.nodes[0].getbestblockhash(), 16), block.hashPrevBlock)\n \n     # Compare the generated shortids to what we expect based on BIP 152, given\n-    # bitcoind's choice of nonce.\n+    # globaltokend's choice of nonce.\n     def test_compactblock_construction(self, node, test_node, version, use_witness_address):\n         # Generate a bunch of transactions.\n         node.generate(101)\n@@ -370,7 +370,7 @@ def check_compactblock_construction_from_block(self, version, header_and_shortid\n                 header_and_shortids.shortids.pop(0)\n             index += 1\n \n-    # Test that bitcoind requests compact blocks when we announce new blocks\n+    # Test that globaltokend requests compact blocks when we announce new blocks\n     # via header or inv, and that responding to getblocktxn causes the block\n     # to be successfully reconstructed.\n     # Post-segwit: upgraded nodes would only make this request of cb-version-2,\n@@ -554,7 +554,7 @@ def test_incorrect_blocktxn_response(self, node, test_node, version):\n         assert_equal(absolute_indexes, [6, 7, 8, 9, 10])\n \n         # Now give an incorrect response.\n-        # Note that it's possible for bitcoind to be smart enough to know we're\n+        # Note that it's possible for globaltokend to be smart enough to know we're\n         # lying, since it could check to see if the shortid matches what we're\n         # sending, and eg disconnect us for misbehavior.  If that behavior\n         # change were made, we could just modify this test by having a\n@@ -585,7 +585,7 @@ def test_incorrect_blocktxn_response(self, node, test_node, version):\n         assert_equal(int(node.getbestblockhash(), 16), block.sha256)\n \n     def test_getblocktxn_handler(self, node, test_node, version):\n-        # bitcoind will not send blocktxn responses for blocks whose height is\n+        # globaltokend will not send blocktxn responses for blocks whose height is\n         # more than 10 blocks deep.\n         MAX_GETBLOCKTXN_DEPTH = 10\n         chain_height = node.getblockcount()"
      },
      {
        "sha": "cf01675c036a3f669e72dee312667edf8ddb7d0b",
        "filename": "test/functional/p2p-fullblocktest.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/p2p-fullblocktest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/p2p-fullblocktest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-fullblocktest.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -396,7 +396,7 @@ def update_block(block_number, new_transactions):\n         b26 = update_block(26, [])\n         yield rejected(RejectResult(16, b'bad-cb-length'))\n \n-        # Extend the b26 chain to make sure bitcoind isn't accepting b26\n+        # Extend the b26 chain to make sure globaltokend isn't accepting b26\n         b27 = block(27, spend=out[7])\n         yield rejected(False)\n \n@@ -408,7 +408,7 @@ def update_block(block_number, new_transactions):\n         b28 = update_block(28, [])\n         yield rejected(RejectResult(16, b'bad-cb-length'))\n \n-        # Extend the b28 chain to make sure bitcoind isn't accepting b28\n+        # Extend the b28 chain to make sure globaltokend isn't accepting b28\n         b29 = block(29, spend=out[7])\n         yield rejected(False)\n "
      },
      {
        "sha": "1b59c30c8f2a149b1e778413906855d0fccb2c29",
        "filename": "test/functional/p2p-leaktests.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/p2p-leaktests.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/p2p-leaktests.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-leaktests.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -58,7 +58,7 @@ def on_blocktxn(self, conn, message): self.bad_message(message)\n # anyway, and eventually get disconnected.\n class CNodeNoVersionBan(CLazyNode):\n     # send a bunch of veracks without sending a message. This should get us disconnected.\n-    # NOTE: implementation-specific check here. Remove if bitcoind ban behavior changes\n+    # NOTE: implementation-specific check here. Remove if globaltokend ban behavior changes\n     def on_open(self, conn):\n         super().on_open(conn)\n         for i in range(banscore):"
      },
      {
        "sha": "a2c8cd55b02c899ade9a6d53034e0b90869f0fa4",
        "filename": "test/functional/p2p-segwit.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/p2p-segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/p2p-segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-segwit.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -204,7 +204,7 @@ def test_unnecessary_witness_before_segwit_activation(self):\n         # rule).\n         self.test_node.test_witness_block(block, accepted=False)\n         # TODO: fix synchronization so we can test reject reason\n-        # Right now, bitcoind delays sending reject messages for blocks\n+        # Right now, globaltokend delays sending reject messages for blocks\n         # until the future, making synchronization here difficult.\n         #assert_equal(self.test_node.last_message[\"reject\"].reason, \"unexpected-witness\")\n \n@@ -528,7 +528,7 @@ def test_submit_block(self):\n         self.nodes[0].submitblock(bytes_to_hex_str(block.serialize(True)))\n         assert(self.nodes[0].getbestblockhash() != block.hash)\n \n-        # Now redo commitment with the standard nonce, but let bitcoind fill it in.\n+        # Now redo commitment with the standard nonce, but let globaltokend fill it in.\n         add_witness_commitment(block, nonce=0)\n         block.vtx[0].wit = CTxWitness()\n         block.solve()\n@@ -1448,7 +1448,7 @@ def test_p2sh_witness(self, segwit_activated):\n         # This transaction should not be accepted into the mempool pre- or\n         # post-segwit.  Mempool acceptance will use SCRIPT_VERIFY_WITNESS which\n         # will require a witness to spend a witness program regardless of\n-        # segwit activation.  Note that older bitcoind's that are not\n+        # segwit activation.  Note that older globaltokend's that are not\n         # segwit-aware would also reject this for failing CLEANSTACK.\n         self.test_node.test_transaction_acceptance(spend_tx, with_witness=False, accepted=False)\n \n@@ -1484,12 +1484,12 @@ def test_p2sh_witness(self, segwit_activated):\n     # Test the behavior of starting up a segwit-aware node after the softfork\n     # has activated.  As segwit requires different block data than pre-segwit\n     # nodes would have stored, this requires special handling.\n-    # To enable this test, pass --oldbinary=<path-to-pre-segwit-bitcoind> to\n+    # To enable this test, pass --oldbinary=<path-to-pre-segwit-globaltokend> to\n     # the test.\n     def test_upgrade_after_activation(self, node_id):\n         self.log.info(\"Testing software upgrade after softfork activation\")\n \n-        assert(node_id != 0) # node0 is assumed to be a segwit-active bitcoind\n+        assert(node_id != 0) # node0 is assumed to be a segwit-active globaltokend\n \n         # Make sure the nodes are all up\n         sync_blocks(self.nodes)"
      },
      {
        "sha": "f01ce6acf72a043876aef88789231a5a4bae9b6d",
        "filename": "test/functional/p2p-timeouts.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/p2p-timeouts.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/p2p-timeouts.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-timeouts.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -4,7 +4,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test various net timeouts.\n \n-- Create three bitcoind nodes:\n+- Create three globaltokend nodes:\n \n     no_verack_node - we never send a verack in response to their version\n     no_version_node - we never send a version (only a ping)"
      },
      {
        "sha": "28e36e316bc6b5a7e24e8e619214b99a3f4857e5",
        "filename": "test/functional/proxy_test.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/proxy_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/proxy_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/proxy_test.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -2,13 +2,13 @@\n # Copyright (c) 2015-2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test bitcoind with different proxy configuration.\n+\"\"\"Test globaltokend with different proxy configuration.\n \n Test plan:\n-- Start bitcoind's with different proxy configurations\n+- Start globaltokend's with different proxy configurations\n - Use addnode to initiate connections\n - Verify that proxies are connected to, and the right connection command is given\n-- Proxy configurations to test on bitcoind side:\n+- Proxy configurations to test on globaltokend side:\n     - `-proxy` (proxy everything)\n     - `-onion` (proxy just onions)\n     - `-proxyrandomize` Circuit randomization\n@@ -18,8 +18,8 @@\n     - proxy on IPv6\n \n - Create various proxies (as threads)\n-- Create bitcoinds that connect to them\n-- Manipulate the bitcoinds using addnode (onetry) an observe effects\n+- Create globaltokends that connect to them\n+- Manipulate the globaltokends using addnode (onetry) an observe effects\n \n addnode connect to IPv4\n addnode connect to IPv6\n@@ -97,7 +97,7 @@ def node_test(self, node, proxies, auth, test_onion=True):\n         node.addnode(\"15.61.23.23:1234\", \"onetry\")\n         cmd = proxies[0].queue.get()\n         assert(isinstance(cmd, Socks5Command))\n-        # Note: bitcoind's SOCKS5 implementation only sends atyp DOMAINNAME, even if connecting directly to IPv4/IPv6\n+        # Note: globaltokend's SOCKS5 implementation only sends atyp DOMAINNAME, even if connecting directly to IPv4/IPv6\n         assert_equal(cmd.atyp, AddressType.DOMAINNAME)\n         assert_equal(cmd.addr, b\"15.61.23.23\")\n         assert_equal(cmd.port, 1234)\n@@ -111,7 +111,7 @@ def node_test(self, node, proxies, auth, test_onion=True):\n             node.addnode(\"[1233:3432:2434:2343:3234:2345:6546:4534]:5443\", \"onetry\")\n             cmd = proxies[1].queue.get()\n             assert(isinstance(cmd, Socks5Command))\n-            # Note: bitcoind's SOCKS5 implementation only sends atyp DOMAINNAME, even if connecting directly to IPv4/IPv6\n+            # Note: globaltokend's SOCKS5 implementation only sends atyp DOMAINNAME, even if connecting directly to IPv4/IPv6\n             assert_equal(cmd.atyp, AddressType.DOMAINNAME)\n             assert_equal(cmd.addr, b\"1233:3432:2434:2343:3234:2345:6546:4534\")\n             assert_equal(cmd.port, 5443)"
      },
      {
        "sha": "0878ef884735bf3ea13e9b740854d9f299abfd18",
        "filename": "test/functional/reindex.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/reindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/reindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/reindex.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -2,7 +2,7 @@\n # Copyright (c) 2014-2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test running bitcoind with -reindex and -reindex-chainstate options.\n+\"\"\"Test running globaltokend with -reindex and -reindex-chainstate options.\n \n - Start a single node and generate 3 blocks.\n - Stop the node and restart it with -reindex. Verify that the node has reindexed up to block 3."
      },
      {
        "sha": "79b42bd30d0bcc3cd88838165da4d27c96bc6d0a",
        "filename": "test/functional/rpcbind_test.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/rpcbind_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/rpcbind_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpcbind_test.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -2,7 +2,7 @@\n # Copyright (c) 2014-2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Test running bitcoind with the -rpcbind and -rpcallowip options.\"\"\"\n+\"\"\"Test running globaltokend with the -rpcbind and -rpcallowip options.\"\"\"\n \n import socket\n import sys\n@@ -37,7 +37,7 @@ def run_bind_test(self, allow_ips, connect_to, addresses, expected):\n             base_args += ['-rpcallowip=' + x for x in allow_ips]\n         binds = ['-rpcbind='+addr for addr in addresses]\n         self.nodes = self.start_nodes(self.num_nodes, self.options.tmpdir, [base_args + binds], connect_to)\n-        pid = self.bitcoind_processes[0].pid\n+        pid = self.globaltokend_processes[0].pid\n         assert_equal(set(get_bind_addrs(pid)), set(expected))\n         self.stop_nodes()\n "
      },
      {
        "sha": "9c9f49c7fcb9b2080089a2c3bceda8e852e40592",
        "filename": "test/functional/test_framework/authproxy.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/test_framework/authproxy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/test_framework/authproxy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/authproxy.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -19,7 +19,7 @@\n # You should have received a copy of the GNU Lesser General Public License\n # along with this software; if not, write to the Free Software\n # Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA\n-\"\"\"HTTP proxy for opening RPC connection to bitcoind.\n+\"\"\"HTTP proxy for opening RPC connection to globaltokend.\n \n AuthServiceProxy has the following improvements over python-jsonrpc's\n ServiceProxy class:"
      },
      {
        "sha": "e10aa9dc2a97623c64193732b767aa0fb9e40902",
        "filename": "test/functional/test_framework/comptool.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/test_framework/comptool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/test_framework/comptool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/comptool.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -2,7 +2,7 @@\n # Copyright (c) 2015-2016 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\"\"\"Compare two or more bitcoinds to each other.\n+\"\"\"Compare two or more globaltokends to each other.\n \n To use, create a class that implements get_tests(), and pass it in\n as the test generator to TestManager.  get_tests() should be a python"
      },
      {
        "sha": "5ddff45bbb194d259df7e009becddb9fac506658",
        "filename": "test/functional/test_framework/mininode.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/test_framework/mininode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/test_framework/mininode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/mininode.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -216,7 +216,7 @@ def FromHex(obj, hex_string):\n def ToHex(obj):\n     return bytes_to_hex_str(obj.serialize())\n \n-# Objects that map to bitcoind objects, which can be serialized/deserialized\n+# Objects that map to globaltokend objects, which can be serialized/deserialized\n \n class CAddress(object):\n     def __init__(self):\n@@ -448,7 +448,7 @@ def deserialize(self, f):\n         if len(self.vin) == 0:\n             flags = struct.unpack(\"<B\", f.read(1))[0]\n             # Not sure why flags can't be zero, but this\n-            # matches the implementation in bitcoind\n+            # matches the implementation in globaltokend\n             if (flags != 0):\n                 self.vin = deser_vector(f, CTxIn)\n                 self.vout = deser_vector(f, CTxOut)\n@@ -1313,7 +1313,7 @@ def __init__(self):\n         self.headers = []\n \n     def deserialize(self, f):\n-        # comment in bitcoind indicates these should be deserialized as blocks\n+        # comment in globaltokend indicates these should be deserialized as blocks\n         blocks = deser_vector(f, CBlock)\n         for x in blocks:\n             self.headers.append(CBlockHeader(x))\n@@ -1471,7 +1471,7 @@ def serialize(self):\n         return r\n \n class NodeConnCB(object):\n-    \"\"\"Callback and helper functions for P2P connection to a bitcoind node.\n+    \"\"\"Callback and helper functions for P2P connection to a globaltokend node.\n \n     Individual testcases should subclass this and override the on_* methods\n     if they want to alter message handling behaviour."
      },
      {
        "sha": "d65bc475af43c5b463a23a053c9545bd4bc5c2c5",
        "filename": "test/functional/test_framework/test_framework.py",
        "status": "modified",
        "additions": 36,
        "deletions": 36,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/test_framework/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/test_framework/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_framework.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -69,7 +69,7 @@ def __init__(self):\n         self.num_nodes = 4\n         self.setup_clean_chain = False\n         self.nodes = []\n-        self.bitcoind_processes = {}\n+        self.globaltokend_processes = {}\n         self.mocktime = 0\n \n     def add_options(self, parser):\n@@ -107,11 +107,11 @@ def main(self):\n \n         parser = optparse.OptionParser(usage=\"%prog [options]\")\n         parser.add_option(\"--nocleanup\", dest=\"nocleanup\", default=False, action=\"store_true\",\n-                          help=\"Leave bitcoinds and test.* datadir on exit or error\")\n+                          help=\"Leave globaltokends and test.* datadir on exit or error\")\n         parser.add_option(\"--noshutdown\", dest=\"noshutdown\", default=False, action=\"store_true\",\n-                          help=\"Don't stop bitcoinds after the test execution\")\n+                          help=\"Don't stop globaltokends after the test execution\")\n         parser.add_option(\"--srcdir\", dest=\"srcdir\", default=os.path.normpath(os.path.dirname(os.path.realpath(__file__)) + \"/../../../src\"),\n-                          help=\"Source directory containing bitcoind/bitcoin-cli (default: %default)\")\n+                          help=\"Source directory containing globaltokend/bitcoin-cli (default: %default)\")\n         parser.add_option(\"--cachedir\", dest=\"cachedir\", default=os.path.normpath(os.path.dirname(os.path.realpath(__file__)) + \"/../../cache\"),\n                           help=\"Directory for caching pregenerated datadirs\")\n         parser.add_option(\"--tmpdir\", dest=\"tmpdir\", help=\"Root directory for datadirs\")\n@@ -167,7 +167,7 @@ def main(self):\n             if self.nodes:\n                 self.stop_nodes()\n         else:\n-            self.log.info(\"Note: bitcoinds were not stopped and may still be running\")\n+            self.log.info(\"Note: globaltokends were not stopped and may still be running\")\n \n         if not self.options.nocleanup and not self.options.noshutdown and success != TestStatus.FAILED:\n             self.log.info(\"Cleaning up\")\n@@ -204,17 +204,17 @@ def main(self):\n     # Public helper methods. These can be accessed by the subclass test scripts.\n \n     def start_node(self, i, dirname, extra_args=None, rpchost=None, timewait=None, binary=None, stderr=None):\n-        \"\"\"Start a bitcoind and return RPC connection to it\"\"\"\n+        \"\"\"Start a globaltokend and return RPC connection to it\"\"\"\n \n         datadir = os.path.join(dirname, \"node\" + str(i))\n         if binary is None:\n-            binary = os.getenv(\"BITCOIND\", \"bitcoind\")\n+            binary = os.getenv(\"BITCOIND\", \"globaltokend\")\n         args = [binary, \"-datadir=\" + datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-debugexclude=libevent\", \"-debugexclude=leveldb\", \"-mocktime=\" + str(self.mocktime), \"-uacomment=testnode%d\" % i]\n         if extra_args is not None:\n             args.extend(extra_args)\n-        self.bitcoind_processes[i] = subprocess.Popen(args, stderr=stderr)\n-        self.log.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n-        self._wait_for_bitcoind_start(self.bitcoind_processes[i], datadir, i, rpchost)\n+        self.globaltokend_processes[i] = subprocess.Popen(args, stderr=stderr)\n+        self.log.debug(\"initialize_chain: globaltokend started, waiting for RPC to come up\")\n+        self._wait_for_globaltokend_start(self.globaltokend_processes[i], datadir, i, rpchost)\n         self.log.debug(\"initialize_chain: RPC successfully started\")\n         proxy = get_rpc_proxy(rpc_url(datadir, i, rpchost), i, timeout=timewait)\n \n@@ -224,7 +224,7 @@ def start_node(self, i, dirname, extra_args=None, rpchost=None, timewait=None, b\n         return proxy\n \n     def start_nodes(self, num_nodes, dirname, extra_args=None, rpchost=None, timewait=None, binary=None):\n-        \"\"\"Start multiple bitcoinds, return RPC connections to them\"\"\"\n+        \"\"\"Start multiple globaltokends, return RPC connections to them\"\"\"\n \n         if extra_args is None:\n             extra_args = [None] * num_nodes\n@@ -247,45 +247,45 @@ def start_nodes(self, num_nodes, dirname, extra_args=None, rpchost=None, timewai\n         return rpcs\n \n     def stop_node(self, i):\n-        \"\"\"Stop a bitcoind test node\"\"\"\n+        \"\"\"Stop a globaltokend test node\"\"\"\n \n         self.log.debug(\"Stopping node %d\" % i)\n         try:\n             self.nodes[i].stop()\n         except http.client.CannotSendRequest as e:\n             self.log.exception(\"Unable to stop node\")\n-        return_code = self.bitcoind_processes[i].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n-        del self.bitcoind_processes[i]\n+        return_code = self.globaltokend_processes[i].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n+        del self.globaltokend_processes[i]\n         assert_equal(return_code, 0)\n \n     def stop_nodes(self):\n-        \"\"\"Stop multiple bitcoind test nodes\"\"\"\n+        \"\"\"Stop multiple globaltokend test nodes\"\"\"\n \n         for i in range(len(self.nodes)):\n             self.stop_node(i)\n-        assert not self.bitcoind_processes.values()  # All connections must be gone now\n+        assert not self.globaltokend_processes.values()  # All connections must be gone now\n \n     def assert_start_raises_init_error(self, i, dirname, extra_args=None, expected_msg=None):\n         with tempfile.SpooledTemporaryFile(max_size=2**16) as log_stderr:\n             try:\n                 self.start_node(i, dirname, extra_args, stderr=log_stderr)\n                 self.stop_node(i)\n             except Exception as e:\n-                assert 'bitcoind exited' in str(e)  # node must have shutdown\n+                assert 'globaltokend exited' in str(e)  # node must have shutdown\n                 if expected_msg is not None:\n                     log_stderr.seek(0)\n                     stderr = log_stderr.read().decode('utf-8')\n                     if expected_msg not in stderr:\n                         raise AssertionError(\"Expected error \\\"\" + expected_msg + \"\\\" not found in:\\n\" + stderr)\n             else:\n                 if expected_msg is None:\n-                    assert_msg = \"bitcoind should have exited with an error\"\n+                    assert_msg = \"globaltokend should have exited with an error\"\n                 else:\n-                    assert_msg = \"bitcoind should have exited with expected error \" + expected_msg\n+                    assert_msg = \"globaltokend should have exited with expected error \" + expected_msg\n                 raise AssertionError(assert_msg)\n \n     def wait_for_node_exit(self, i, timeout):\n-        self.bitcoind_processes[i].wait(timeout)\n+        self.globaltokend_processes[i].wait(timeout)\n \n     def split_network(self):\n         \"\"\"\n@@ -339,7 +339,7 @@ def _start_logging(self):\n         # User can provide log level as a number or string (eg DEBUG). loglevel was caught as a string, so try to convert it to an int\n         ll = int(self.options.loglevel) if self.options.loglevel.isdigit() else self.options.loglevel.upper()\n         ch.setLevel(ll)\n-        # Format logs the same as bitcoind's debug.log with microprecision (so log files can be concatenated and sorted)\n+        # Format logs the same as globaltokend's debug.log with microprecision (so log files can be concatenated and sorted)\n         formatter = logging.Formatter(fmt='%(asctime)s.%(msecs)03d000 %(name)s (%(levelname)s): %(message)s', datefmt='%Y-%m-%d %H:%M:%S')\n         formatter.converter = time.gmtime\n         fh.setFormatter(formatter)\n@@ -376,15 +376,15 @@ def _initialize_chain(self, test_dir, num_nodes, cachedir):\n                 if os.path.isdir(os.path.join(cachedir, \"node\" + str(i))):\n                     shutil.rmtree(os.path.join(cachedir, \"node\" + str(i)))\n \n-            # Create cache directories, run bitcoinds:\n+            # Create cache directories, run globaltokends:\n             for i in range(MAX_NODES):\n                 datadir = initialize_datadir(cachedir, i)\n-                args = [os.getenv(\"BITCOIND\", \"bitcoind\"), \"-server\", \"-keypool=1\", \"-datadir=\" + datadir, \"-discover=0\"]\n+                args = [os.getenv(\"BITCOIND\", \"globaltokend\"), \"-server\", \"-keypool=1\", \"-datadir=\" + datadir, \"-discover=0\"]\n                 if i > 0:\n                     args.append(\"-connect=127.0.0.1:\" + str(p2p_port(0)))\n-                self.bitcoind_processes[i] = subprocess.Popen(args)\n-                self.log.debug(\"initialize_chain: bitcoind started, waiting for RPC to come up\")\n-                self._wait_for_bitcoind_start(self.bitcoind_processes[i], datadir, i)\n+                self.globaltokend_processes[i] = subprocess.Popen(args)\n+                self.log.debug(\"initialize_chain: globaltokend started, waiting for RPC to come up\")\n+                self._wait_for_globaltokend_start(self.globaltokend_processes[i], datadir, i)\n                 self.log.debug(\"initialize_chain: RPC successfully started\")\n \n             self.nodes = []\n@@ -437,14 +437,14 @@ def _initialize_chain_clean(self, test_dir, num_nodes):\n         for i in range(num_nodes):\n             initialize_datadir(test_dir, i)\n \n-    def _wait_for_bitcoind_start(self, process, datadir, i, rpchost=None):\n-        \"\"\"Wait for bitcoind to start.\n+    def _wait_for_globaltokend_start(self, process, datadir, i, rpchost=None):\n+        \"\"\"Wait for globaltokend to start.\n \n         This means that RPC is accessible and fully initialized.\n-        Raise an exception if bitcoind exits during initialization.\"\"\"\n+        Raise an exception if globaltokend exits during initialization.\"\"\"\n         while True:\n             if process.poll() is not None:\n-                raise Exception('bitcoind exited with status %i during initialization' % process.returncode)\n+                raise Exception('globaltokend exited with status %i during initialization' % process.returncode)\n             try:\n                 # Check if .cookie file to be created\n                 rpc = get_rpc_proxy(rpc_url(datadir, i, rpchost), i, coveragedir=self.options.coveragedir)\n@@ -456,15 +456,15 @@ def _wait_for_bitcoind_start(self, process, datadir, i, rpchost=None):\n             except JSONRPCException as e:  # Initialization phase\n                 if e.error['code'] != -28:  # RPC in warmup?\n                     raise  # unknown JSON RPC exception\n-            except ValueError as e:  # cookie file not found and no rpcuser or rpcassword. bitcoind still starting\n+            except ValueError as e:  # cookie file not found and no rpcuser or rpcassword. globaltokend still starting\n                 if \"No RPC credentials\" not in str(e):\n                     raise\n             time.sleep(0.25)\n \n class ComparisonTestFramework(BitcoinTestFramework):\n     \"\"\"Test framework for doing p2p comparison testing\n \n-    Sets up some bitcoind binaries:\n+    Sets up some globaltokend binaries:\n     - 1 binary: test binary\n     - 2 binaries: 1 test binary, 1 ref binary\n     - n>2 binaries: 1 test binary, n-1 ref binaries\"\"\"\n@@ -476,11 +476,11 @@ def __init__(self):\n \n     def add_options(self, parser):\n         parser.add_option(\"--testbinary\", dest=\"testbinary\",\n-                          default=os.getenv(\"BITCOIND\", \"bitcoind\"),\n-                          help=\"bitcoind binary to test\")\n+                          default=os.getenv(\"BITCOIND\", \"globaltokend\"),\n+                          help=\"globaltokend binary to test\")\n         parser.add_option(\"--refbinary\", dest=\"refbinary\",\n-                          default=os.getenv(\"BITCOIND\", \"bitcoind\"),\n-                          help=\"bitcoind binary to use for reference nodes (if any)\")\n+                          default=os.getenv(\"BITCOIND\", \"globaltokend\"),\n+                          help=\"globaltokend binary to use for reference nodes (if any)\")\n \n     def setup_network(self):\n         extra_args = [['-whitelist=127.0.0.1']]*self.num_nodes"
      },
      {
        "sha": "69e08444b0c474b621917c22ceee6782ff3919d4",
        "filename": "test/functional/test_runner.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/test_runner.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/test_runner.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_runner.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -203,16 +203,16 @@ def main():\n \n     enable_wallet = config[\"components\"].getboolean(\"ENABLE_WALLET\")\n     enable_utils = config[\"components\"].getboolean(\"ENABLE_UTILS\")\n-    enable_bitcoind = config[\"components\"].getboolean(\"ENABLE_BITCOIND\")\n+    enable_globaltokend = config[\"components\"].getboolean(\"ENABLE_BITCOIND\")\n \n     if config[\"environment\"][\"EXEEXT\"] == \".exe\" and not args.force:\n         # https://github.com/bitcoin/bitcoin/commit/d52802551752140cf41f0d9a225a43e84404d3e9\n         # https://github.com/bitcoin/bitcoin/pull/5677#issuecomment-136646964\n         print(\"Tests currently disabled on Windows by default. Use --force option to enable\")\n         sys.exit(0)\n \n-    if not (enable_wallet and enable_utils and enable_bitcoind):\n-        print(\"No functional tests to run. Wallet, utils, and bitcoind must all be enabled\")\n+    if not (enable_wallet and enable_utils and enable_globaltokend):\n+        print(\"No functional tests to run. Wallet, utils, and globaltokend must all be enabled\")\n         print(\"Rerun `configure` with -enable-wallet, -with-utils and -with-daemon and rerun make\")\n         sys.exit(0)\n \n@@ -264,10 +264,10 @@ def main():\n     run_tests(test_list, config[\"environment\"][\"SRCDIR\"], config[\"environment\"][\"BUILDDIR\"], config[\"environment\"][\"EXEEXT\"], tmpdir, args.jobs, args.coverage, passon_args)\n \n def run_tests(test_list, src_dir, build_dir, exeext, tmpdir, jobs=1, enable_coverage=False, args=[]):\n-    # Warn if bitcoind is already running (unix only)\n+    # Warn if globaltokend is already running (unix only)\n     try:\n-        if subprocess.check_output([\"pidof\", \"bitcoind\"]) is not None:\n-            print(\"%sWARNING!%s There is already a bitcoind process running on this system. Tests may fail unexpectedly due to resource contention!\" % (BOLD[1], BOLD[0]))\n+        if subprocess.check_output([\"pidof\", \"globaltokend\"]) is not None:\n+            print(\"%sWARNING!%s There is already a globaltokend process running on this system. Tests may fail unexpectedly due to resource contention!\" % (BOLD[1], BOLD[0]))\n     except (OSError, subprocess.SubprocessError):\n         pass\n \n@@ -278,7 +278,7 @@ def run_tests(test_list, src_dir, build_dir, exeext, tmpdir, jobs=1, enable_cove\n \n     #Set env vars\n     if \"BITCOIND\" not in os.environ:\n-        os.environ[\"BITCOIND\"] = build_dir + '/src/bitcoind' + exeext\n+        os.environ[\"BITCOIND\"] = build_dir + '/src/globaltokend' + exeext\n \n     tests_dir = src_dir + '/test/functional/'\n \n@@ -363,7 +363,7 @@ def __init__(self, num_tests_parallel, tests_dir, tmpdir, test_list=None, flags=\n         self.test_list = test_list\n         self.flags = flags\n         self.num_running = 0\n-        # In case there is a graveyard of zombie bitcoinds, we can apply a\n+        # In case there is a graveyard of zombie globaltokends, we can apply a\n         # pseudorandom offset to hopefully jump over them.\n         # (625 is PORT_RANGE/MAX_NODES)\n         self.portseed_offset = int(time.time() * 1000) % 625"
      },
      {
        "sha": "3897835ff1670e124bef6e3c8b7d1650d15fd417",
        "filename": "test/functional/wallet-dump.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/wallet-dump.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/wallet-dump.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-dump.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -95,7 +95,7 @@ def run_test (self):\n \n         #encrypt wallet, restart, unlock and dump\n         self.nodes[0].encryptwallet('test')\n-        self.bitcoind_processes[0].wait()\n+        self.globaltokend_processes[0].wait()\n         self.nodes[0] = self.start_node(0, self.options.tmpdir, self.extra_args[0])\n         self.nodes[0].walletpassphrase('test', 10)\n         # Should be a no-op:"
      },
      {
        "sha": "4a2c6cf97872d76bbeb13ac01c79660b6a912aab",
        "filename": "test/functional/wallet-encryption.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/wallet-encryption.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/wallet-encryption.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet-encryption.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -31,7 +31,7 @@ def run_test(self):\n \n         # Encrypt the wallet\n         self.nodes[0].encryptwallet(passphrase)\n-        self.bitcoind_processes[0].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n+        self.globaltokend_processes[0].wait(timeout=BITCOIND_PROC_WAIT_TIMEOUT)\n         self.nodes[0] = self.start_node(0, self.options.tmpdir)\n \n         # Test that the wallet is encrypted"
      },
      {
        "sha": "329a4fe9ecc6e9565a34d4534548e638f6d9682e",
        "filename": "test/functional/zapwallettxes.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/zapwallettxes.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/zapwallettxes.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/zapwallettxes.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -4,7 +4,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test the zapwallettxes functionality.\n \n-- start two bitcoind nodes\n+- start two globaltokend nodes\n - create two transactions on node 0 - one is confirmed and one is unconfirmed.\n - restart node 0 and verify that both the confirmed and the unconfirmed\n   transactions are still available."
      },
      {
        "sha": "755c7335f285bccb6b49d6f19ed4db68c8ab1a02",
        "filename": "test/functional/zmq_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/zmq_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/functional/zmq_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/zmq_test.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -32,7 +32,7 @@ def setup_nodes(self):\n         config.read_file(open(self.options.configfile))\n \n         if not config[\"components\"].getboolean(\"ENABLE_ZMQ\"):\n-            raise SkipTest(\"bitcoind has not been built with zmq enabled.\")\n+            raise SkipTest(\"globaltokend has not been built with zmq enabled.\")\n \n         self.zmqContext = zmq.Context()\n         self.zmqSubSocket = self.zmqContext.socket(zmq.SUB)"
      },
      {
        "sha": "7cbd361f5e6b82a6ce070264edbe9179ad08ff0b",
        "filename": "test/util/bitcoin-util-test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/util/bitcoin-util-test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/util/bitcoin-util-test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/bitcoin-util-test.py?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -146,7 +146,7 @@ def bctest(testDir, testObj, buildenv):\n         want_error = testObj[\"error_txt\"]\n         # Compare error text\n         # TODO: ideally, we'd compare the strings exactly and also assert\n-        # That stderr is empty if no errors are expected. However, bitcoin-tx\n+        # That stderr is empty if no errors are expected. However, globaltoken-tx\n         # emits DISPLAY errors when running as a windows application on\n         # linux through wine. Just assert that the expected error text appears\n         # somewhere in stderr."
      },
      {
        "sha": "664f1ae244778133e8cab63c628725d5932e2426",
        "filename": "test/util/data/bitcoin-util-test.json",
        "status": "modified",
        "additions": 60,
        "deletions": 60,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/util/data/bitcoin-util-test.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00/test/util/data/bitcoin-util-test.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/data/bitcoin-util-test.json?ref=3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "patch": "@@ -1,114 +1,114 @@\n [\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-create\", \"nversion=1\"],\n     \"output_cmp\": \"blanktxv1.hex\",\n     \"description\": \"Creates a blank v1 transaction\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\",\"-create\", \"nversion=1\"],\n     \"output_cmp\": \"blanktxv1.json\",\n     \"description\": \"Creates a blank v1 transaction (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-\"],\n     \"input\": \"blanktxv2.hex\",\n     \"output_cmp\": \"blanktxv2.hex\",\n-    \"description\": \"Creates a blank transaction when nothing is piped into bitcoin-tx\"\n+    \"description\": \"Creates a blank transaction when nothing is piped into globaltoken-tx\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\",\"-create\"],\n     \"output_cmp\": \"blanktxv2.json\",\n     \"description\": \"Creates a blank transaction (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\",\"-\"],\n     \"input\": \"blanktxv2.hex\",\n     \"output_cmp\": \"blanktxv2.json\",\n-    \"description\": \"Creates a blank transaction when nothing is piped into bitcoin-tx (output in json)\"\n+    \"description\": \"Creates a blank transaction when nothing is piped into globaltoken-tx (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-\", \"delin=1\"],\n     \"input\": \"tx394b54bb.hex\",\n     \"output_cmp\": \"tt-delin1-out.hex\",\n     \"description\": \"Deletes a single input from a transaction\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\", \"-\", \"delin=1\"],\n     \"input\": \"tx394b54bb.hex\",\n     \"output_cmp\": \"tt-delin1-out.json\",\n     \"description\": \"Deletes a single input from a transaction (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-\", \"delin=31\"],\n     \"input\": \"tx394b54bb.hex\",\n     \"return_code\": 1,\n     \"error_txt\": \"error: Invalid TX input index '31'\",\n     \"description\": \"Attempts to delete an input with a bad index from a transaction. Expected to fail.\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-\", \"delout=1\"],\n     \"input\": \"tx394b54bb.hex\",\n     \"output_cmp\": \"tt-delout1-out.hex\",\n     \"description\": \"Deletes a single output from a transaction\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\", \"-\", \"delout=1\"],\n     \"input\": \"tx394b54bb.hex\",\n     \"output_cmp\": \"tt-delout1-out.json\",\n     \"description\": \"Deletes a single output from a transaction (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-\", \"delout=2\"],\n     \"input\": \"tx394b54bb.hex\",\n     \"return_code\": 1,\n     \"error_txt\": \"error: Invalid TX output index '2'\",\n     \"description\": \"Attempts to delete an output with a bad index from a transaction. Expected to fail.\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-\", \"locktime=317000\"],\n     \"input\": \"tx394b54bb.hex\",\n     \"output_cmp\": \"tt-locktime317000-out.hex\",\n     \"description\": \"Adds an nlocktime to a transaction\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\", \"-\", \"locktime=317000\"],\n     \"input\": \"tx394b54bb.hex\",\n     \"output_cmp\": \"tt-locktime317000-out.json\",\n     \"description\": \"Adds an nlocktime to a transaction (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-create\",\n      \"outaddr=1\"],\n     \"return_code\": 1,\n     \"error_txt\": \"error: TX output missing or too many separators\",\n     \"description\": \"Malformed outaddr argument (no address specified). Expected to fail.\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-create\",\n      \"outaddr=1:13tuJJDR2RgArmgfv6JScSdreahzgc4T6o:garbage\"],\n     \"return_code\": 1,\n     \"error_txt\": \"error: TX output missing or too many separators\",\n     \"description\": \"Malformed outaddr argument (too many separators). Expected to fail.\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-create\",\n      \"outpubkey=0\"],\n     \"return_code\": 1,\n     \"error_txt\": \"error: TX output missing or too many separators\",\n     \"description\": \"Malformed outpubkey argument (no pubkey specified). Expected to fail.\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-create\",\n      \"outpubkey=0:02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397:W:non53nse\"],\n     \"return_code\": 1,\n     \"error_txt\": \"error: TX output missing or too many separators\",\n     \"description\": \"Malformed outpubkey argument (too many separators). Expected to fail.\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-create\",\n      \"in=5897de6bd6027a475eadd57019d4e6872c396d0716c4875a5f1a6fcfdf385c1f:0\",\n@@ -119,7 +119,7 @@\n     \"output_cmp\": \"txcreate1.hex\",\n     \"description\": \"Creates a new transaction with three inputs and two outputs\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-json\",\n      \"-create\",\n@@ -131,67 +131,67 @@\n     \"output_cmp\": \"txcreate1.json\",\n     \"description\": \"Creates a new transaction with three inputs and two outputs (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-create\", \"outscript=0:\"],\n     \"output_cmp\": \"txcreate2.hex\",\n     \"description\": \"Creates a new transaction with a single empty output script\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\", \"-create\", \"outscript=0:\"],\n     \"output_cmp\": \"txcreate2.json\",\n     \"description\": \"Creates a new transaction with a single empty output script (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"02000000000100000000000000000000000000\"],\n     \"output_cmp\": \"txcreate2.hex\",\n     \"description\": \"Parses a transation with no inputs and a single output script\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\", \"02000000000100000000000000000000000000\"],\n     \"output_cmp\": \"txcreate2.json\",\n     \"description\": \"Parses a transation with no inputs and a single output script (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-create\", \"outscript=0:OP_DROP\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatescript1.hex\",\n     \"description\": \"Create a new transaction with a single output script (OP_DROP)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\", \"-create\", \"outscript=0:OP_DROP\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatescript1.json\",\n     \"description\": \"Create a new transaction with a single output script (OP_DROP) (output as json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-create\", \"outscript=0:OP_DROP:S\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatescript2.hex\",\n     \"description\": \"Create a new transaction with a single output script (OP_DROP) in a P2SH\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\", \"-create\", \"outscript=0:OP_DROP:S\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatescript2.json\",\n     \"description\": \"Create a new transaction with a single output script (OP_DROP) in a P2SH (output as json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-create\", \"outscript=0:OP_DROP:W\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatescript3.hex\",\n     \"description\": \"Create a new transaction with a single output script (OP_DROP) in a P2WSH\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\", \"-create\", \"outscript=0:OP_DROP:W\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatescript3.json\",\n     \"description\": \"Create a new transaction with a single output script (OP_DROP) in a P2WSH (output as json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-create\", \"outscript=0:OP_DROP:WS\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatescript4.hex\",\n     \"description\": \"Create a new transaction with a single output script (OP_DROP) in a P2WSH, wrapped in a P2SH\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\", \"-create\", \"outscript=0:OP_DROP:WS\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatescript4.json\",\n     \"description\": \"Create a new transaction with a single output script (OP_DROP) in a P2SH, wrapped in a P2SH (output as json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-create\", \"nversion=1\",\n      \"in=4d49a71ec9da436f71ec4ee231d04f292a29cd316f598bb7068feccabdc59485:0\",\n@@ -202,7 +202,7 @@\n     \"output_cmp\": \"txcreatesignv1.hex\",\n     \"description\": \"Creates a new v1 transaction with a single input and a single output, and then signs the transaction\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-json\",\n      \"-create\", \"nversion=1\",\n@@ -214,7 +214,7 @@\n     \"output_cmp\": \"txcreatesignv1.json\",\n     \"description\": \"Creates a new v1 transaction with a single input and a single output, and then signs the transaction (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-create\",\n       \"in=4d49a71ec9da436f71ec4ee231d04f292a29cd316f598bb7068feccabdc59485:0\",\n@@ -225,43 +225,43 @@\n     \"output_cmp\": \"txcreatesignv2.hex\",\n     \"description\": \"Creates a new transaction with a single input and a single output, and then signs the transaction\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-create\", \"outpubkey=0:02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397\", \"nversion=1\"],\n     \"output_cmp\": \"txcreateoutpubkey1.hex\",\n     \"description\": \"Creates a new transaction with a single pay-to-pubkey output\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-json\", \"-create\", \"outpubkey=0:02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397\", \"nversion=1\"],\n     \"output_cmp\": \"txcreateoutpubkey1.json\",\n     \"description\": \"Creates a new transaction with a single pay-to-pubkey output (output as json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-create\", \"outpubkey=0:02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397:W\", \"nversion=1\"],\n     \"output_cmp\": \"txcreateoutpubkey2.hex\",\n     \"description\": \"Creates a new transaction with a single pay-to-witness-pubkey output\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-json\", \"-create\", \"outpubkey=0:02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397:W\", \"nversion=1\"],\n     \"output_cmp\": \"txcreateoutpubkey2.json\",\n     \"description\": \"Creates a new transaction with a single pay-to-witness-pubkey output (output as json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-create\", \"outpubkey=0:02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397:WS\", \"nversion=1\"],\n     \"output_cmp\": \"txcreateoutpubkey3.hex\",\n     \"description\": \"Creates a new transaction with a single pay-to-witness-pubkey, wrapped in P2SH output\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-json\", \"-create\", \"outpubkey=0:02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397:WS\", \"nversion=1\"],\n     \"output_cmp\": \"txcreateoutpubkey3.json\",\n     \"description\": \"Creates a new transaction with a single pay-to-pub-key output, wrapped in P2SH (output as json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-create\",\n      \"in=5897de6bd6027a475eadd57019d4e6872c396d0716c4875a5f1a6fcfdf385c1f:0\",\n@@ -270,7 +270,7 @@\n     \"error_txt\": \"error: invalid TX output data\",\n     \"description\": \"Attempts to create a new transaction with one input and an output with malformed hex data. Expected to fail\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-create\",\n      \"in=5897de6bd6027a475eadd57019d4e6872c396d0716c4875a5f1a6fcfdf385c1f:0\",\n@@ -279,7 +279,7 @@\n     \"error_txt\": \"error: invalid TX output data\",\n     \"description\": \"Attempts to create a new transaction with one input and an output with no value and malformed hex data. Expected to fail\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-create\",\n      \"in=5897de6bd6027a475eadd57019d4e6872c396d0716c4875a5f1a6fcfdf385c1f:0\",\n@@ -288,7 +288,7 @@\n     \"output_cmp\": \"txcreatedata1.hex\",\n     \"description\": \"Creates a new transaction with one input, one address output and one data output\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-json\",\n      \"-create\", \"nversion=1\",\n@@ -298,7 +298,7 @@\n     \"output_cmp\": \"txcreatedata1.json\",\n     \"description\": \"Creates a new v1 transaction with one input, one address output and one data output (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-create\",\n      \"in=5897de6bd6027a475eadd57019d4e6872c396d0716c4875a5f1a6fcfdf385c1f:0\",\n@@ -307,7 +307,7 @@\n     \"output_cmp\": \"txcreatedata2.hex\",\n     \"description\": \"Creates a new transaction with one input, one address output and one data (zero value) output\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-json\",\n      \"-create\",\n@@ -317,15 +317,15 @@\n     \"output_cmp\": \"txcreatedata2.json\",\n     \"description\": \"Creates a new transaction with one input, one address output and one data (zero value) output (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-create\",\n      \"in=5897de6bd6027a475eadd57019d4e6872c396d0716c4875a5f1a6fcfdf385c1f:0:4294967293\",\n      \"outaddr=0.18:13tuJJDR2RgArmgfv6JScSdreahzgc4T6o\"],\n     \"output_cmp\": \"txcreatedata_seq0.hex\",\n     \"description\": \"Creates a new transaction with one input with sequence number and one address output\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-json\",\n      \"-create\",\n@@ -334,57 +334,57 @@\n     \"output_cmp\": \"txcreatedata_seq0.json\",\n     \"description\": \"Creates a new transaction with one input with sequence number and one address output (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"01000000011f5c38dfcf6f1a5f5a87c416076d392c87e6d41970d5ad5e477a02d66bde97580000000000fdffffff0180a81201000000001976a9141fc11f39be1729bf973a7ab6a615ca4729d6457488ac00000000\",\n      \"in=5897de6bd6027a475eadd57019d4e6872c396d0716c4875a5f1a6fcfdf385c1f:0:1\"],\n     \"output_cmp\": \"txcreatedata_seq1.hex\",\n     \"description\": \"Adds a new input with sequence number to a transaction\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\":\n     [\"-json\",\n      \"01000000011f5c38dfcf6f1a5f5a87c416076d392c87e6d41970d5ad5e477a02d66bde97580000000000fdffffff0180a81201000000001976a9141fc11f39be1729bf973a7ab6a615ca4729d6457488ac00000000\",\n      \"in=5897de6bd6027a475eadd57019d4e6872c396d0716c4875a5f1a6fcfdf385c1f:0:1\"],\n     \"output_cmp\": \"txcreatedata_seq1.json\",\n     \"description\": \"Adds a new input with sequence number to a transaction (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-create\", \"outmultisig=1:2:3:02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397:021ac43c7ff740014c3b33737ede99c967e4764553d1b2b83db77c83b8715fa72d:02df2089105c77f266fa11a9d33f05c735234075f2e8780824c6b709415f9fb485\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatemultisig1.hex\",\n     \"description\": \"Creates a new transaction with a single 2-of-3 multisig output\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\", \"-create\", \"outmultisig=1:2:3:02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397:021ac43c7ff740014c3b33737ede99c967e4764553d1b2b83db77c83b8715fa72d:02df2089105c77f266fa11a9d33f05c735234075f2e8780824c6b709415f9fb485\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatemultisig1.json\",\n     \"description\": \"Creates a new transaction with a single 2-of-3 multisig output (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-create\", \"outmultisig=1:2:3:02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397:021ac43c7ff740014c3b33737ede99c967e4764553d1b2b83db77c83b8715fa72d:02df2089105c77f266fa11a9d33f05c735234075f2e8780824c6b709415f9fb485:S\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatemultisig2.hex\",\n     \"description\": \"Creates a new transaction with a single 2-of-3 multisig in a P2SH output\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\", \"-create\", \"outmultisig=1:2:3:02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397:021ac43c7ff740014c3b33737ede99c967e4764553d1b2b83db77c83b8715fa72d:02df2089105c77f266fa11a9d33f05c735234075f2e8780824c6b709415f9fb485:S\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatemultisig2.json\",\n     \"description\": \"Creates a new transaction with a single 2-of-3 multisig in a P2SH output (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-create\", \"outmultisig=1:2:3:02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397:021ac43c7ff740014c3b33737ede99c967e4764553d1b2b83db77c83b8715fa72d:02df2089105c77f266fa11a9d33f05c735234075f2e8780824c6b709415f9fb485:W\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatemultisig3.hex\",\n     \"description\": \"Creates a new transaction with a single 2-of-3 multisig in a P2WSH output\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\", \"-create\", \"outmultisig=1:2:3:02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397:021ac43c7ff740014c3b33737ede99c967e4764553d1b2b83db77c83b8715fa72d:02df2089105c77f266fa11a9d33f05c735234075f2e8780824c6b709415f9fb485:W\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatemultisig3.json\",\n     \"description\": \"Creates a new transaction with a single 2-of-3 multisig in a P2WSH output (output in json)\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-create\", \"outmultisig=1:2:3:02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397:021ac43c7ff740014c3b33737ede99c967e4764553d1b2b83db77c83b8715fa72d:02df2089105c77f266fa11a9d33f05c735234075f2e8780824c6b709415f9fb485:WS\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatemultisig4.hex\",\n     \"description\": \"Creates a new transaction with a single 2-of-3 multisig in a P2WSH output, wrapped in P2SH\"\n   },\n-  { \"exec\": \"./bitcoin-tx\",\n+  { \"exec\": \"./globaltoken-tx\",\n     \"args\": [\"-json\", \"-create\", \"outmultisig=1:2:3:02a5613bd857b7048924264d1e70e08fb2a7e6527d32b7ab1bb993ac59964ff397:021ac43c7ff740014c3b33737ede99c967e4764553d1b2b83db77c83b8715fa72d:02df2089105c77f266fa11a9d33f05c735234075f2e8780824c6b709415f9fb485:WS\", \"nversion=1\"],\n     \"output_cmp\": \"txcreatemultisig4.json\",\n     \"description\": \"Creates a new transaction with a single 2-of-3 multisig in a P2WSH output, wrapped in P2SH (output in json)\""
      }
    ]
  },
  {
    "sha": "0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZmUyZTJjNjU1OTc4MzYwOGE3YTc4ZDIzMmE4ZDA5NDNiNjBjMmJh",
    "commit": {
      "author": {
        "name": "globaltoken",
        "email": "heisenbergakatheking@gmail.com",
        "date": "2017-07-21T19:49:12Z"
      },
      "committer": {
        "name": "globaltoken",
        "email": "heisenbergakatheking@gmail.com",
        "date": "2017-07-21T19:49:12Z"
      },
      "message": "Compile issues fixxed\n\nCompile issues fixxed",
      "tree": {
        "sha": "6fadeb451180760c035a6aa959f2da18620f3ced",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6fadeb451180760c035a6aa959f2da18620f3ced"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3a2df3fa22e597ba93ec1bcffc7ad9caf81ebb00"
      }
    ],
    "stats": {
      "total": 78,
      "additions": 42,
      "deletions": 36
    },
    "files": [
      {
        "sha": "35a6a5b6a6e032d01b66fc2b5364d0c0bc0aa1ed",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
        "patch": "@@ -1171,8 +1171,10 @@ AC_DEFINE(CLIENT_VERSION_REVISION, _CLIENT_VERSION_REVISION, [Build revision])\n AC_DEFINE(CLIENT_VERSION_BUILD, _CLIENT_VERSION_BUILD, [Version Build])\n AC_DEFINE(CLIENT_VERSION_IS_RELEASE, _CLIENT_VERSION_IS_RELEASE, [Version is release])\n AC_DEFINE(COPYRIGHT_YEAR, _COPYRIGHT_YEAR, [Copyright year])\n+AC_DEFINE(COPYRIGHT_GLT_START, _COPYRIGHT_GLT_START, [Copyright year of GLT Start])\n AC_DEFINE(COPYRIGHT_HOLDERS, \"_COPYRIGHT_HOLDERS\", [Copyright holder(s) before %s replacement])\n AC_DEFINE(COPYRIGHT_HOLDERS_SUBSTITUTION, \"_COPYRIGHT_HOLDERS_SUBSTITUTION\", [Replacement for %s in copyright holders string])\n+AC_DEFINE(COPYRIGHT_HOLDERS_SUBSTITUTION_GLT, \"_COPYRIGHT_HOLDERS_SUBSTITUTION_GLT\", [Replacement for %s in copyright holders string])\n define(_COPYRIGHT_HOLDERS_FINAL, [patsubst(_COPYRIGHT_HOLDERS, [%s], [_COPYRIGHT_HOLDERS_SUBSTITUTION])])\n AC_DEFINE(COPYRIGHT_HOLDERS_FINAL, \"_COPYRIGHT_HOLDERS_FINAL\", [Copyright holder(s)])\n AC_SUBST(CLIENT_VERSION_MAJOR, _CLIENT_VERSION_MAJOR)\n@@ -1181,8 +1183,10 @@ AC_SUBST(CLIENT_VERSION_REVISION, _CLIENT_VERSION_REVISION)\n AC_SUBST(CLIENT_VERSION_BUILD, _CLIENT_VERSION_BUILD)\n AC_SUBST(CLIENT_VERSION_IS_RELEASE, _CLIENT_VERSION_IS_RELEASE)\n AC_SUBST(COPYRIGHT_YEAR, _COPYRIGHT_YEAR)\n+AC_SUBST(COPYRIGHT_GLT_START, _COPYRIGHT_GLT_START)\n AC_SUBST(COPYRIGHT_HOLDERS, \"_COPYRIGHT_HOLDERS\")\n AC_SUBST(COPYRIGHT_HOLDERS_SUBSTITUTION, \"_COPYRIGHT_HOLDERS_SUBSTITUTION\")\n+AC_SUBST(COPYRIGHT_HOLDERS_SUBSTITUTION_GLT, \"_COPYRIGHT_HOLDERS_SUBSTITUTION_GLT\")\n AC_SUBST(COPYRIGHT_HOLDERS_FINAL, \"_COPYRIGHT_HOLDERS_FINAL\")\n AC_SUBST(BITCOIN_DAEMON_NAME)\n AC_SUBST(BITCOIN_GUI_NAME)"
      },
      {
        "sha": "06b09404a767fe0bf591e6b07d26b657a881bae7",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
        "patch": "@@ -66,11 +66,11 @@ TESTS =\n BENCHMARKS =\n \n if BUILD_BITCOIND\n-  bin_PROGRAMS += globaltokend\n+  bin_PROGRAMS += bitcoind\n endif\n \n if BUILD_BITCOIN_UTILS\n-  bin_PROGRAMS += bitcoin-cli globaltoken-tx\n+  bin_PROGRAMS += bitcoin-cli bitcoin-tx\n endif\n \n .PHONY: FORCE check-symbols check-security\n@@ -178,7 +178,7 @@ obj/build.h: FORCE\n \t  \"$(abs_top_srcdir)\"\n libbitcoin_util_a-clientversion.$(OBJEXT): obj/build.h\n \n-# server: shared between globaltokend and globaltoken-qt\n+# server: shared between bitcoind and bitcoin-qt\n libbitcoin_server_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(MINIUPNPC_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n libbitcoin_server_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_server_a_SOURCES = \\\n@@ -231,7 +231,7 @@ libbitcoin_zmq_a_SOURCES = \\\n endif\n \n \n-# wallet: shared between globaltokend and globaltoken-qt, but only linked\n+# wallet: shared between bitcoind and bitcoin-qt, but only linked\n # when wallet enabled\n libbitcoin_wallet_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_wallet_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n@@ -302,7 +302,7 @@ libbitcoin_consensus_a_SOURCES = \\\n   utilstrencodings.h \\\n   version.h\n \n-# common: shared between globaltokend, and globaltoken-qt and non-server tools\n+# common: shared between bitcoind, and bitcoin-qt and non-server tools\n libbitcoin_common_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_common_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_common_a_SOURCES = \\\n@@ -352,7 +352,7 @@ if GLIBC_BACK_COMPAT\n libbitcoin_util_a_SOURCES += compat/glibc_compat.cpp\n endif\n \n-# cli: shared between bitcoin-cli and globaltoken-qt\n+# cli: shared between bitcoin-cli and bitcoin-qt\n libbitcoin_cli_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_cli_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_cli_a_SOURCES = \\\n@@ -362,17 +362,17 @@ libbitcoin_cli_a_SOURCES = \\\n nodist_libbitcoin_util_a_SOURCES = $(srcdir)/obj/build.h\n #\n \n-# globaltokend binary #\n-globaltokend_SOURCES = globaltokend.cpp\n-globaltokend_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n-globaltokend_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-globaltokend_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+# bitcoind binary #\n+bitcoind_SOURCES = bitcoind.cpp\n+bitcoind_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+bitcoind_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+bitcoind_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n if TARGET_WINDOWS\n-globaltokend_SOURCES += globaltokend-res.rc\n+bitcoind_SOURCES += bitcoind-res.rc\n endif\n \n-globaltokend_LDADD = \\\n+bitcoind_LDADD = \\\n   $(LIBBITCOIN_SERVER) \\\n   $(LIBBITCOIN_COMMON) \\\n   $(LIBUNIVALUE) \\\n@@ -386,7 +386,7 @@ globaltokend_LDADD = \\\n   $(LIBMEMENV) \\\n   $(LIBSECP256K1)\n \n-globaltokend_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS)\n+bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS)\n \n # bitcoin-cli binary #\n bitcoin_cli_SOURCES = bitcoin-cli.cpp\n@@ -407,14 +407,14 @@ bitcoin_cli_LDADD = \\\n bitcoin_cli_LDADD += $(BOOST_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(EVENT_LIBS)\n #\n \n-# globaltoken-tx binary #\n-bitcoin_tx_SOURCES = globaltoken-tx.cpp\n+# bitcoin-tx binary #\n+bitcoin_tx_SOURCES = bitcoin-tx.cpp\n bitcoin_tx_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n bitcoin_tx_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n bitcoin_tx_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n if TARGET_WINDOWS\n-bitcoin_tx_SOURCES += globaltoken-tx-res.rc\n+bitcoin_tx_SOURCES += bitcoin-tx-res.rc\n endif\n \n bitcoin_tx_LDADD = \\"
      },
      {
        "sha": "e4b64c1ca79c3e6ab98e9c5d3662b9c3f9a315bb",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
        "patch": "@@ -2,7 +2,7 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-bin_PROGRAMS += qt/globaltoken-qt\n+bin_PROGRAMS += qt/bitcoin-qt\n EXTRA_LIBRARIES += qt/libbitcoinqt.a\n \n # bitcoin qt core #\n@@ -360,7 +360,7 @@ RES_IMAGES =\n \n RES_MOVIES = $(wildcard $(srcdir)/qt/res/movies/spinner-*.png)\n \n-BITCOIN_RC = qt/res/globaltoken-qt-res.rc\n+BITCOIN_RC = qt/res/bitcoin-qt-res.rc\n \n BITCOIN_QT_INCLUDES = -I$(builddir)/qt -I$(srcdir)/qt -I$(srcdir)/qt/forms \\\n   -I$(builddir)/qt/forms -DQT_NO_KEYWORDS\n@@ -388,7 +388,7 @@ $(qt_libbitcoinqt_a_OBJECTS) $(qt_bitcoin_qt_OBJECTS) : | $(QT_MOC)\n $(QT_MOC): $(PROTOBUF_H)\n $(QT_MOC_CPP): $(PROTOBUF_H)\n \n-# globaltoken-qt binary #\n+# bitcoin-qt binary #\n qt_bitcoin_qt_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BITCOIN_QT_INCLUDES) \\\n   $(QT_INCLUDES) $(PROTOBUF_CFLAGS) $(QR_CFLAGS)\n qt_bitcoin_qt_CXXFLAGS = $(AM_CXXFLAGS) $(QT_PIE_FLAGS)\n@@ -443,9 +443,9 @@ CLEAN_QT = $(nodist_qt_libbitcoinqt_a_SOURCES) $(QT_QM) $(QT_FORMS_H) qt/*.gcda\n CLEANFILES += $(CLEAN_QT)\n \n bitcoin_qt_clean: FORCE\n-\trm -f $(CLEAN_QT) $(qt_libbitcoinqt_a_OBJECTS) $(qt_bitcoin_qt_OBJECTS) qt/globaltoken-qt$(EXEEXT) $(LIBBITCOINQT)\n+\trm -f $(CLEAN_QT) $(qt_libbitcoinqt_a_OBJECTS) $(qt_bitcoin_qt_OBJECTS) qt/bitcoin-qt$(EXEEXT) $(LIBBITCOINQT)\n \n-bitcoin_qt : qt/globaltoken-qt$(EXEEXT)\n+bitcoin_qt : qt/bitcoin-qt$(EXEEXT)\n \n ui_%.h: %.ui\n \t@test -f $(UIC)"
      },
      {
        "sha": "02f30bc9527b10ade4e91c36a1da2141539908a6",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
        "patch": "@@ -2,8 +2,8 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-bin_PROGRAMS += qt/test/test_globaltoken-qt\n-TESTS += qt/test/test_globaltoken-qt\n+bin_PROGRAMS += qt/test/test_bitcoin-qt\n+TESTS += qt/test/test_bitcoin-qt\n \n TEST_QT_MOC_CPP = \\\n   qt/test/moc_compattests.cpp \\\n@@ -70,9 +70,9 @@ CLEAN_BITCOIN_QT_TEST = $(TEST_QT_MOC_CPP) qt/test/*.gcda qt/test/*.gcno\n \n CLEANFILES += $(CLEAN_BITCOIN_QT_TEST)\n \n-test_bitcoin_qt : qt/test/test_globaltoken-qt$(EXEEXT)\n+test_bitcoin_qt : qt/test/test_bitcoin-qt$(EXEEXT)\n \n-test_bitcoin_qt_check : qt/test/test_globaltoken-qt$(EXEEXT) FORCE\n+test_bitcoin_qt_check : qt/test/test_bitcoin-qt$(EXEEXT) FORCE\n \t$(MAKE) check-TESTS TESTS=$^\n \n test_bitcoin_qt_clean: FORCE"
      },
      {
        "sha": "5d97ee1e9aedbee38d630422c04fbe47bf5bf9d6",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
        "patch": "@@ -148,7 +148,7 @@ bool AppInit(int argc, char* argv[])\n         if (GetBoolArg(\"-daemon\", false))\n         {\n #if HAVE_DECL_DAEMON\n-            fprintf(stdout, \"Bitcoin server starting\\n\");\n+            fprintf(stdout, \"Globaltoken server starting\\n\");\n \n             // Daemonize\n             if (daemon(1, 0)) { // don't chdir (1), do close FDs (0)"
      },
      {
        "sha": "66829b2d44d63e1e6612a6d864b8640f50f262c3",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
        "patch": "@@ -76,10 +76,10 @@ class CMainParams : public CChainParams {\n     CMainParams() {\n         strNetworkID = \"main\";\n         consensus.nSubsidyHalvingInterval = 840000;\n-        consensus.BIP34Height = 1;\n-        consensus.BIP34Hash = uint256S(\"0x0000000097fcef2abcd5b827feffb2625fa50ef1794d8efc75ddbfaa3daeb499\");\n-        consensus.BIP65Height = 280000; // not hashed yet ...\n-        consensus.BIP66Height = 260000; // not hashed yet ...\n+        consensus.BIP34Height = 299999;\n+        // consensus.BIP34Hash = uint256S(\"0x0000000097fcef2abcd5b827feffb2625fa50ef1794d8efc75ddbfaa3daeb499\"); rejected because Version 2 Blocks should be active now\n+        consensus.BIP65Height = 380000; // not hashed yet ...\n+        consensus.BIP66Height = 360000; // not hashed yet ...\n         consensus.powLimit = uint256S(\"00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n         consensus.nPowTargetTimespan = 10 * 60; // ten minutes\n         consensus.nPowTargetSpacing = 60;"
      },
      {
        "sha": "b9dcf0c5992216013d27464202cc86d2e8c31c93",
        "filename": "src/qt/Makefile",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/qt/Makefile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/qt/Makefile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/Makefile?ref=0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
        "patch": "@@ -5,5 +5,5 @@ clean: FORCE\n \t$(MAKE) -C .. bitcoin_qt_clean test_bitcoin_qt_clean\n check: FORCE\n \t$(MAKE) -C .. test_bitcoin_qt_check\n-globaltoken-qt globaltoken-qt.exe: FORCE\n+bitcoin-qt bitcoin-qt.exe: FORCE\n \t $(MAKE) -C .. bitcoin_qt"
      },
      {
        "sha": "7c53942f763740b7b72e79f9e496da8f53cb9c77",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
        "patch": "@@ -897,13 +897,13 @@ std::string CopyrightHolders(const std::string& strPrefix)\n \n std::string CopyrightHoldersGLT(const std::string& strPrefix)\n {\n-    std::string strCopyrightHolders = strPrefix + strprintf(_(COPYRIGHT_HOLDERS), _(COPYRIGHT_HOLDERS_SUBSTITUTION_GLT));\n+    std::string strCopyrightHoldersGLT = strPrefix + strprintf(_(COPYRIGHT_HOLDERS), _(COPYRIGHT_HOLDERS_SUBSTITUTION_GLT));\n \n     // Check for untranslated substitution to make sure Bitcoin Core copyright is not removed by accident\n     if (strprintf(COPYRIGHT_HOLDERS, COPYRIGHT_HOLDERS_SUBSTITUTION_GLT).find(\"Globaltoken Core\") == std::string::npos) {\n-        strCopyrightHolders += \"\\n\" + strPrefix + \"The Globaltoken Core developers\";\n+        strCopyrightHoldersGLT += \"\\n\" + strPrefix + \"The Globaltoken Core developers\";\n     }\n-    return strCopyrightHolders;\n+    return strCopyrightHoldersGLT;\n }\n \n // Obtain the application startup time (used for uptime calculation)"
      },
      {
        "sha": "50cd5e58c5f94bc1ba6a9bf8e51f642f07769c78",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
        "patch": "@@ -1,5 +1,6 @@\n // Copyright (c) 2009-2010 Satoshi Nakamoto\n // Copyright (c) 2009-2016 The Bitcoin Core developers\n+// Copyright (c) 2017 The Globaltoken Core developers\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -364,5 +365,6 @@ template <typename Callable> void TraceThread(const char* name,  Callable func)\n }\n \n std::string CopyrightHolders(const std::string& strPrefix);\n+std::string CopyrightHoldersGLT(const std::string& strPrefix);\n \n #endif // BITCOIN_UTIL_H"
      },
      {
        "sha": "586fcba6ecc0ceb1db74ceabe40791533ba358b7",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0fe2e2c6559783608a7a78d232a8d0943b60c2ba/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
        "patch": "@@ -1706,7 +1706,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n     // If we're on the known chain at height greater than where BIP34 activated, we can save the db accesses needed for the BIP30 check.\n     CBlockIndex *pindexBIP34height = pindex->pprev->GetAncestor(chainparams.GetConsensus().BIP34Height);\n     //Only continue to enforce if we're below BIP34 activation height or the block hash at that height doesn't correspond.\n-    fEnforceBIP30 = fEnforceBIP30 && (!pindexBIP34height || !(pindexBIP34height->GetBlockHash() == chainparams.GetConsensus().BIP34Hash));\n+    fEnforceBIP30 = fEnforceBIP30 && (!pindexBIP34height /* || !(pindexBIP34height->GetBlockHash() == chainparams.GetConsensus().BIP34Hash) Disabled because Blocks with V.2 should be longer active. */);\n \n     if (fEnforceBIP30) {\n         for (const auto& tx : block.vtx) {"
      }
    ]
  },
  {
    "sha": "8d2f73698cedbf152cb601af04a56cede1e02ee8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZDJmNzM2OThjZWRiZjE1MmNiNjAxYWYwNGE1NmNlZGUxZTAyZWU4",
    "commit": {
      "author": {
        "name": "globaltoken",
        "email": "heisenbergakatheking@gmail.com",
        "date": "2017-07-22T00:56:56Z"
      },
      "committer": {
        "name": "globaltoken",
        "email": "heisenbergakatheking@gmail.com",
        "date": "2017-07-22T00:56:56Z"
      },
      "message": "Globaltoken Issue fix\n\nGlobaltoken Issue fix",
      "tree": {
        "sha": "789512d3b9c93719bf9b8cfb2319f771a0ca6bf5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/789512d3b9c93719bf9b8cfb2319f771a0ca6bf5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8d2f73698cedbf152cb601af04a56cede1e02ee8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d2f73698cedbf152cb601af04a56cede1e02ee8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8d2f73698cedbf152cb601af04a56cede1e02ee8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d2f73698cedbf152cb601af04a56cede1e02ee8/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0fe2e2c6559783608a7a78d232a8d0943b60c2ba",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0fe2e2c6559783608a7a78d232a8d0943b60c2ba"
      }
    ],
    "stats": {
      "total": 228,
      "additions": 115,
      "deletions": 113
    },
    "files": [
      {
        "sha": "30d9fdd3812fd9f9999416bccaee01bbc44761e2",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d2f73698cedbf152cb601af04a56cede1e02ee8/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d2f73698cedbf152cb601af04a56cede1e02ee8/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=8d2f73698cedbf152cb601af04a56cede1e02ee8",
        "patch": "@@ -1176,7 +1176,9 @@ AC_DEFINE(COPYRIGHT_HOLDERS, \"_COPYRIGHT_HOLDERS\", [Copyright holder(s) before %\n AC_DEFINE(COPYRIGHT_HOLDERS_SUBSTITUTION, \"_COPYRIGHT_HOLDERS_SUBSTITUTION\", [Replacement for %s in copyright holders string])\n AC_DEFINE(COPYRIGHT_HOLDERS_SUBSTITUTION_GLT, \"_COPYRIGHT_HOLDERS_SUBSTITUTION_GLT\", [Replacement for %s in copyright holders string])\n define(_COPYRIGHT_HOLDERS_FINAL, [patsubst(_COPYRIGHT_HOLDERS, [%s], [_COPYRIGHT_HOLDERS_SUBSTITUTION])])\n+define(_COPYRIGHT_HOLDERS_FINAL_GLT, [patsubst(_COPYRIGHT_HOLDERS, [%s], [_COPYRIGHT_HOLDERS_SUBSTITUTION_GLT])])\n AC_DEFINE(COPYRIGHT_HOLDERS_FINAL, \"_COPYRIGHT_HOLDERS_FINAL\", [Copyright holder(s)])\n+AC_DEFINE(COPYRIGHT_HOLDERS_FINAL_GLT, \"_COPYRIGHT_HOLDERS_FINAL_GLT\", [Copyright holder(s) GLT])\n AC_SUBST(CLIENT_VERSION_MAJOR, _CLIENT_VERSION_MAJOR)\n AC_SUBST(CLIENT_VERSION_MINOR, _CLIENT_VERSION_MINOR)\n AC_SUBST(CLIENT_VERSION_REVISION, _CLIENT_VERSION_REVISION)"
      },
      {
        "sha": "08ff4d6ac1d5cc1135ee6c38d54d17fcfd7252eb",
        "filename": "doc/man/Makefile.am",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d2f73698cedbf152cb601af04a56cede1e02ee8/doc/man/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d2f73698cedbf152cb601af04a56cede1e02ee8/doc/man/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/man/Makefile.am?ref=8d2f73698cedbf152cb601af04a56cede1e02ee8",
        "patch": "@@ -1,13 +1,13 @@\n dist_man1_MANS=\n \n if BUILD_BITCOIND\n-  dist_man1_MANS+=globaltokend.1\n+  dist_man1_MANS+=bitcoind.1\n endif\n \n if ENABLE_QT\n-  dist_man1_MANS+=globaltoken-qt.1\n+  dist_man1_MANS+=bitcoin-qt.1\n endif\n \n if BUILD_BITCOIN_UTILS\n-  dist_man1_MANS+=bitcoin-cli.1 globaltoken-tx.1\n+  dist_man1_MANS+=bitcoin-cli.1 bitcoin-tx.1\n endif"
      },
      {
        "sha": "887deade2db317225b4cb5671c653b17fabf230f",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 31,
        "deletions": 31,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=8d2f73698cedbf152cb601af04a56cede1e02ee8",
        "patch": "@@ -66,15 +66,15 @@ TESTS =\n BENCHMARKS =\n \n if BUILD_BITCOIND\n-  bin_PROGRAMS += bitcoind\n+  bin_PROGRAMS += globaltokend\n endif\n \n if BUILD_BITCOIN_UTILS\n-  bin_PROGRAMS += bitcoin-cli bitcoin-tx\n+  bin_PROGRAMS += globaltoken-cli globaltoken-tx\n endif\n \n .PHONY: FORCE check-symbols check-security\n-# bitcoin core #\n+# globaltoken core #\n BITCOIN_CORE_H = \\\n   addrdb.h \\\n   addrman.h \\\n@@ -178,7 +178,7 @@ obj/build.h: FORCE\n \t  \"$(abs_top_srcdir)\"\n libbitcoin_util_a-clientversion.$(OBJEXT): obj/build.h\n \n-# server: shared between bitcoind and bitcoin-qt\n+# server: shared between globaltokend and globaltoken-qt\n libbitcoin_server_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(MINIUPNPC_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n libbitcoin_server_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_server_a_SOURCES = \\\n@@ -231,7 +231,7 @@ libbitcoin_zmq_a_SOURCES = \\\n endif\n \n \n-# wallet: shared between bitcoind and bitcoin-qt, but only linked\n+# wallet: shared between globaltokend and globaltoken-qt, but only linked\n # when wallet enabled\n libbitcoin_wallet_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_wallet_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n@@ -302,7 +302,7 @@ libbitcoin_consensus_a_SOURCES = \\\n   utilstrencodings.h \\\n   version.h\n \n-# common: shared between bitcoind, and bitcoin-qt and non-server tools\n+# common: shared between globaltokend, and globaltoken-qt and non-server tools\n libbitcoin_common_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_common_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_common_a_SOURCES = \\\n@@ -352,7 +352,7 @@ if GLIBC_BACK_COMPAT\n libbitcoin_util_a_SOURCES += compat/glibc_compat.cpp\n endif\n \n-# cli: shared between bitcoin-cli and bitcoin-qt\n+# cli: shared between globaltoken-cli and globaltoken-qt\n libbitcoin_cli_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_cli_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_cli_a_SOURCES = \\\n@@ -362,17 +362,17 @@ libbitcoin_cli_a_SOURCES = \\\n nodist_libbitcoin_util_a_SOURCES = $(srcdir)/obj/build.h\n #\n \n-# bitcoind binary #\n-bitcoind_SOURCES = bitcoind.cpp\n-bitcoind_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n-bitcoind_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-bitcoind_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+# globaltokend binary #\n+globaltokend_SOURCES = bitcoind.cpp\n+globaltokend_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+globaltokend_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+globaltokend_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n if TARGET_WINDOWS\n-bitcoind_SOURCES += bitcoind-res.rc\n+globaltokend_SOURCES += bitcoind-res.rc\n endif\n \n-bitcoind_LDADD = \\\n+globaltokend_LDADD = \\\n   $(LIBBITCOIN_SERVER) \\\n   $(LIBBITCOIN_COMMON) \\\n   $(LIBUNIVALUE) \\\n@@ -386,46 +386,46 @@ bitcoind_LDADD = \\\n   $(LIBMEMENV) \\\n   $(LIBSECP256K1)\n \n-bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS)\n+globaltokend_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS)\n \n-# bitcoin-cli binary #\n-bitcoin_cli_SOURCES = bitcoin-cli.cpp\n-bitcoin_cli_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(EVENT_CFLAGS)\n-bitcoin_cli_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-bitcoin_cli_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+# globaltoken-cli binary #\n+globaltoken_cli_SOURCES = bitcoin-cli.cpp\n+globaltoken_cli_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(EVENT_CFLAGS)\n+globaltoken_cli_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+globaltoken_cli_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n if TARGET_WINDOWS\n-bitcoin_cli_SOURCES += bitcoin-cli-res.rc\n+globaltoken_cli_SOURCES += bitcoin-cli-res.rc\n endif\n \n-bitcoin_cli_LDADD = \\\n+globaltoken_cli_LDADD = \\\n   $(LIBBITCOIN_CLI) \\\n   $(LIBUNIVALUE) \\\n   $(LIBBITCOIN_UTIL) \\\n   $(LIBBITCOIN_CRYPTO)\n \n-bitcoin_cli_LDADD += $(BOOST_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(EVENT_LIBS)\n+globaltoken_cli_LDADD += $(BOOST_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(EVENT_LIBS)\n #\n \n-# bitcoin-tx binary #\n-bitcoin_tx_SOURCES = bitcoin-tx.cpp\n-bitcoin_tx_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n-bitcoin_tx_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-bitcoin_tx_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+# globaltoken-tx binary #\n+globaltoken_tx_SOURCES = bitcoin-tx.cpp\n+globaltoken_tx_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+globaltoken_tx_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+globaltoken_tx_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n if TARGET_WINDOWS\n-bitcoin_tx_SOURCES += bitcoin-tx-res.rc\n+globaltoken_tx_SOURCES += bitcoin-tx-res.rc\n endif\n \n-bitcoin_tx_LDADD = \\\n+globaltoken_tx_LDADD = \\\n   $(LIBUNIVALUE) \\\n   $(LIBBITCOIN_COMMON) \\\n   $(LIBBITCOIN_UTIL) \\\n   $(LIBBITCOIN_CONSENSUS) \\\n   $(LIBBITCOIN_CRYPTO) \\\n   $(LIBSECP256K1)\n \n-bitcoin_tx_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+globaltoken_tx_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n #\n \n # bitcoinconsensus library #"
      },
      {
        "sha": "b9f0d2114d0ac74cf9147e293fbed801bf1ba3bc",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 15,
        "deletions": 15,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=8d2f73698cedbf152cb601af04a56cede1e02ee8",
        "patch": "@@ -2,15 +2,15 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-bin_PROGRAMS += bench/bench_bitcoin\n+bin_PROGRAMS += bench/bench_globaltoken\n BENCH_SRCDIR = bench\n-BENCH_BINARY = bench/bench_bitcoin$(EXEEXT)\n+BENCH_BINARY = bench/bench_globaltoken$(EXEEXT)\n \n RAW_TEST_FILES = \\\n   bench/data/block413567.raw\n GENERATED_TEST_FILES = $(RAW_TEST_FILES:.raw=.raw.h)\n \n-bench_bench_bitcoin_SOURCES = \\\n+bench_bench_globaltoken_SOURCES = \\\n   bench/bench_bitcoin.cpp \\\n   bench/bench.cpp \\\n   bench/bench.h \\\n@@ -28,11 +28,11 @@ bench_bench_bitcoin_SOURCES = \\\n   bench/perf.h \\\n   bench/prevector_destructor.cpp\n \n-nodist_bench_bench_bitcoin_SOURCES = $(GENERATED_TEST_FILES)\n+nodist_bench_bench_globaltoken_SOURCES = $(GENERATED_TEST_FILES)\n \n-bench_bench_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(EVENT_CLFAGS) $(EVENT_PTHREADS_CFLAGS) -I$(builddir)/bench/\n-bench_bench_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-bench_bench_bitcoin_LDADD = \\\n+bench_bench_globaltoken_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(EVENT_CLFAGS) $(EVENT_PTHREADS_CFLAGS) -I$(builddir)/bench/\n+bench_bench_globaltoken_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+bench_bench_globaltoken_LDADD = \\\n   $(LIBBITCOIN_SERVER) \\\n   $(LIBBITCOIN_COMMON) \\\n   $(LIBBITCOIN_UTIL) \\\n@@ -45,30 +45,30 @@ bench_bench_bitcoin_LDADD = \\\n   $(LIBUNIVALUE)\n \n if ENABLE_ZMQ\n-bench_bench_bitcoin_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n+bench_bench_globaltoken_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n \n if ENABLE_WALLET\n-bench_bench_bitcoin_SOURCES += bench/coin_selection.cpp\n-bench_bench_bitcoin_LDADD += $(LIBBITCOIN_WALLET) $(LIBBITCOIN_CRYPTO)\n+bench_bench_globaltoken_SOURCES += bench/coin_selection.cpp\n+bench_bench_globaltoken_LDADD += $(LIBBITCOIN_WALLET) $(LIBBITCOIN_CRYPTO)\n endif\n \n-bench_bench_bitcoin_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n-bench_bench_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+bench_bench_globaltoken_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n+bench_bench_globaltoken_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n CLEAN_BITCOIN_BENCH = bench/*.gcda bench/*.gcno $(GENERATED_TEST_FILES)\n \n CLEANFILES += $(CLEAN_BITCOIN_BENCH)\n \n bench/checkblock.cpp: bench/data/block413567.raw.h\n \n-bitcoin_bench: $(BENCH_BINARY)\n+globaltoken_bench: $(BENCH_BINARY)\n \n bench: $(BENCH_BINARY) FORCE\n \t$(BENCH_BINARY)\n \n-bitcoin_bench_clean : FORCE\n-\trm -f $(CLEAN_BITCOIN_BENCH) $(bench_bench_bitcoin_OBJECTS) $(BENCH_BINARY)\n+globaltoken_bench_clean : FORCE\n+\trm -f $(CLEAN_BITCOIN_BENCH) $(bench_bench_globaltoken_OBJECTS) $(BENCH_BINARY)\n \n %.raw.h: %.raw\n \t@$(MKDIR_P) $(@D)"
      },
      {
        "sha": "ca970566b2e1fca5521ad9f5934fc86775cd15b6",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 18,
        "deletions": 18,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=8d2f73698cedbf152cb601af04a56cede1e02ee8",
        "patch": "@@ -2,10 +2,10 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-bin_PROGRAMS += qt/bitcoin-qt\n+bin_PROGRAMS += qt/globaltoken-qt\n EXTRA_LIBRARIES += qt/libbitcoinqt.a\n \n-# bitcoin qt core #\n+# globaltoken qt core #\n QT_TS = \\\n   qt/locale/bitcoin_af.ts \\\n   qt/locale/bitcoin_af_ZA.ts \\\n@@ -381,37 +381,37 @@ QT_FORMS_H=$(join $(dir $(QT_FORMS_UI)),$(addprefix ui_, $(notdir $(QT_FORMS_UI:\n # Most files will depend on the forms and moc files as includes. Generate them\n # before anything else.\n $(QT_MOC): $(QT_FORMS_H)\n-$(qt_libbitcoinqt_a_OBJECTS) $(qt_bitcoin_qt_OBJECTS) : | $(QT_MOC)\n+$(qt_libbitcoinqt_a_OBJECTS) $(qt_globaltoken_qt_OBJECTS) : | $(QT_MOC)\n \n #Generating these with a half-written protobuf header leads to wacky results.\n #This makes sure it's done.\n $(QT_MOC): $(PROTOBUF_H)\n $(QT_MOC_CPP): $(PROTOBUF_H)\n \n-# bitcoin-qt binary #\n-qt_bitcoin_qt_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BITCOIN_QT_INCLUDES) \\\n+# globaltoken-qt binary #\n+qt_globaltoken_qt_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BITCOIN_QT_INCLUDES) \\\n   $(QT_INCLUDES) $(PROTOBUF_CFLAGS) $(QR_CFLAGS)\n-qt_bitcoin_qt_CXXFLAGS = $(AM_CXXFLAGS) $(QT_PIE_FLAGS)\n+qt_globaltoken_qt_CXXFLAGS = $(AM_CXXFLAGS) $(QT_PIE_FLAGS)\n \n-qt_bitcoin_qt_SOURCES = qt/bitcoin.cpp\n+qt_globaltoken_qt_SOURCES = qt/bitcoin.cpp\n if TARGET_DARWIN\n-  qt_bitcoin_qt_SOURCES += $(BITCOIN_MM)\n+  qt_globaltoken_qt_SOURCES += $(BITCOIN_MM)\n endif\n if TARGET_WINDOWS\n-  qt_bitcoin_qt_SOURCES += $(BITCOIN_RC)\n+  qt_globaltoken_qt_SOURCES += $(BITCOIN_RC)\n endif\n-qt_bitcoin_qt_LDADD = qt/libbitcoinqt.a $(LIBBITCOIN_SERVER)\n+qt_globaltoken_qt_LDADD = qt/libbitcoinqt.a $(LIBBITCOIN_SERVER)\n if ENABLE_WALLET\n-qt_bitcoin_qt_LDADD += $(LIBBITCOIN_WALLET)\n+qt_globaltoken_qt_LDADD += $(LIBBITCOIN_WALLET)\n endif\n if ENABLE_ZMQ\n-qt_bitcoin_qt_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n+qt_globaltoken_qt_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n-qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) \\\n+qt_globaltoken_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) \\\n   $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n   $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n-qt_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-qt_bitcoin_qt_LIBTOOLFLAGS = --tag CXX\n+qt_globaltoken_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+qt_globaltoken_qt_LIBTOOLFLAGS = --tag CXX\n \n #locale/foo.ts -> locale/foo.qm\n QT_QM=$(QT_TS:.ts=.qm)\n@@ -442,10 +442,10 @@ CLEAN_QT = $(nodist_qt_libbitcoinqt_a_SOURCES) $(QT_QM) $(QT_FORMS_H) qt/*.gcda\n \n CLEANFILES += $(CLEAN_QT)\n \n-bitcoin_qt_clean: FORCE\n-\trm -f $(CLEAN_QT) $(qt_libbitcoinqt_a_OBJECTS) $(qt_bitcoin_qt_OBJECTS) qt/bitcoin-qt$(EXEEXT) $(LIBBITCOINQT)\n+globaltoken_qt_clean: FORCE\n+\trm -f $(CLEAN_QT) $(qt_libbitcoinqt_a_OBJECTS) $(qt_globaltoken_qt_OBJECTS) qt/globaltoken-qt$(EXEEXT) $(LIBBITCOINQT)\n \n-bitcoin_qt : qt/bitcoin-qt$(EXEEXT)\n+globaltoken_qt : qt/globaltoken-qt$(EXEEXT)\n \n ui_%.h: %.ui\n \t@test -f $(UIC)"
      },
      {
        "sha": "5bb7a6709c9744de2ad1b2c30a186a9abfb78940",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=8d2f73698cedbf152cb601af04a56cede1e02ee8",
        "patch": "@@ -2,8 +2,8 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-bin_PROGRAMS += qt/test/test_bitcoin-qt\n-TESTS += qt/test/test_bitcoin-qt\n+bin_PROGRAMS += qt/test/test_globaltoken-qt\n+TESTS += qt/test/test_globaltoken-qt\n \n TEST_QT_MOC_CPP = \\\n   qt/test/moc_compattests.cpp \\\n@@ -32,10 +32,10 @@ TEST_BITCOIN_H = \\\n   test/test_bitcoin.h \\\n   test/testutil.h\n \n-qt_test_test_bitcoin_qt_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BITCOIN_QT_INCLUDES) \\\n+qt_test_test_globaltoken_qt_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BITCOIN_QT_INCLUDES) \\\n   $(QT_INCLUDES) $(QT_TEST_INCLUDES) $(PROTOBUF_CFLAGS)\n \n-qt_test_test_bitcoin_qt_SOURCES = \\\n+qt_test_test_globaltoken_qt_SOURCES = \\\n   qt/test/compattests.cpp \\\n   qt/test/rpcnestedtests.cpp \\\n   qt/test/test_main.cpp \\\n@@ -44,36 +44,36 @@ qt_test_test_bitcoin_qt_SOURCES = \\\n   $(TEST_BITCOIN_CPP) \\\n   $(TEST_BITCOIN_H)\n if ENABLE_WALLET\n-qt_test_test_bitcoin_qt_SOURCES += \\\n+qt_test_test_globaltoken_qt_SOURCES += \\\n   qt/test/paymentservertests.cpp \\\n   qt/test/wallettests.cpp \\\n   wallet/test/wallet_test_fixture.cpp\n endif\n \n-nodist_qt_test_test_bitcoin_qt_SOURCES = $(TEST_QT_MOC_CPP)\n+nodist_qt_test_test_globaltoken_qt_SOURCES = $(TEST_QT_MOC_CPP)\n \n-qt_test_test_bitcoin_qt_LDADD = $(LIBBITCOINQT) $(LIBBITCOIN_SERVER)\n+qt_test_test_globaltoken_qt_LDADD = $(LIBBITCOINQT) $(LIBBITCOIN_SERVER)\n if ENABLE_WALLET\n-qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_WALLET)\n+qt_test_test_globaltoken_qt_LDADD += $(LIBBITCOIN_WALLET)\n endif\n if ENABLE_ZMQ\n-qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n+qt_test_test_globaltoken_qt_LDADD += $(LIBBITCOIN_ZMQ) $(ZMQ_LIBS)\n endif\n-qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) \\\n+qt_test_test_globaltoken_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) \\\n   $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n   $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n   $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n-qt_test_test_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-qt_test_test_bitcoin_qt_CXXFLAGS = $(AM_CXXFLAGS) $(QT_PIE_FLAGS)\n+qt_test_test_globaltoken_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+qt_test_test_globaltoken_qt_CXXFLAGS = $(AM_CXXFLAGS) $(QT_PIE_FLAGS)\n \n CLEAN_BITCOIN_QT_TEST = $(TEST_QT_MOC_CPP) qt/test/*.gcda qt/test/*.gcno\n \n CLEANFILES += $(CLEAN_BITCOIN_QT_TEST)\n \n-test_bitcoin_qt : qt/test/test_bitcoin-qt$(EXEEXT)\n+test_globaltoken_qt : qt/test/test_globaltoken-qt$(EXEEXT)\n \n-test_bitcoin_qt_check : qt/test/test_bitcoin-qt$(EXEEXT) FORCE\n+test_globaltoken_qt_check : qt/test/test_globaltoken-qt$(EXEEXT) FORCE\n \t$(MAKE) check-TESTS TESTS=$^\n \n-test_bitcoin_qt_clean: FORCE\n-\trm -f $(CLEAN_BITCOIN_QT_TEST) $(qt_test_test_bitcoin_qt_OBJECTS)\n+test_globaltoken_qt_clean: FORCE\n+\trm -f $(CLEAN_BITCOIN_QT_TEST) $(qt_test_test_globaltoken_qt_OBJECTS)"
      },
      {
        "sha": "d9adc433ad4142a8b0903ed895846dcb064084b1",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 26,
        "deletions": 26,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=8d2f73698cedbf152cb601af04a56cede1e02ee8",
        "patch": "@@ -2,11 +2,11 @@\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-TESTS += test/test_bitcoin\n-bin_PROGRAMS += test/test_bitcoin\n-noinst_PROGRAMS += test/test_bitcoin_fuzzy\n+TESTS += test/test_globaltoken\n+bin_PROGRAMS += test/test_globaltoken\n+noinst_PROGRAMS += test/test_globaltoken_fuzzy\n TEST_SRCDIR = test\n-TEST_BINARY=test/test_bitcoin$(EXEEXT)\n+TEST_BINARY=test/test_globaltoken$(EXEEXT)\n \n JSON_TEST_FILES = \\\n   test/data/script_tests.json \\\n@@ -21,7 +21,7 @@ RAW_TEST_FILES =\n \n GENERATED_TEST_FILES = $(JSON_TEST_FILES:.json=.json.h) $(RAW_TEST_FILES:.raw=.raw.h)\n \n-# test_bitcoin binary #\n+# test_globaltoken binary #\n BITCOIN_TESTS =\\\n   test/arith_uint256_tests.cpp \\\n   test/scriptnum10.h \\\n@@ -94,31 +94,31 @@ BITCOIN_TESTS += \\\n   wallet/test/crypto_tests.cpp\n endif\n \n-test_test_bitcoin_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)\n-test_test_bitcoin_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -I$(builddir)/test/ $(TESTDEFS) $(EVENT_CFLAGS)\n-test_test_bitcoin_LDADD =\n+test_test_globaltoken_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)\n+test_test_globaltoken_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) -I$(builddir)/test/ $(TESTDEFS) $(EVENT_CFLAGS)\n+test_test_globaltoken_LDADD =\n if ENABLE_WALLET\n-test_test_bitcoin_LDADD += $(LIBBITCOIN_WALLET)\n+test_test_globaltoken_LDADD += $(LIBBITCOIN_WALLET)\n endif\n-test_test_bitcoin_LDADD += $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) \\\n+test_test_globaltoken_LDADD += $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) \\\n   $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n-test_test_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_test_globaltoken_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n \n-test_test_bitcoin_LDADD += $(LIBBITCOIN_CONSENSUS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS)\n-test_test_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) -static\n+test_test_globaltoken_LDADD += $(LIBBITCOIN_CONSENSUS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS)\n+test_test_globaltoken_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) -static\n \n if ENABLE_ZMQ\n-test_test_bitcoin_LDADD += $(ZMQ_LIBS)\n+test_test_globaltoken_LDADD += $(ZMQ_LIBS)\n endif\n #\n \n-# test_bitcoin_fuzzy binary #\n-test_test_bitcoin_fuzzy_SOURCES = test/test_bitcoin_fuzzy.cpp\n-test_test_bitcoin_fuzzy_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n-test_test_bitcoin_fuzzy_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-test_test_bitcoin_fuzzy_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n+# test_globaltoken_fuzzy binary #\n+test_test_globaltoken_fuzzy_SOURCES = test/test_bitcoin_fuzzy.cpp\n+test_test_globaltoken_fuzzy_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n+test_test_globaltoken_fuzzy_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+test_test_globaltoken_fuzzy_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n-test_test_bitcoin_fuzzy_LDADD = \\\n+test_test_globaltoken_fuzzy_LDADD = \\\n   $(LIBUNIVALUE) \\\n   $(LIBBITCOIN_SERVER) \\\n   $(LIBBITCOIN_COMMON) \\\n@@ -127,24 +127,24 @@ test_test_bitcoin_fuzzy_LDADD = \\\n   $(LIBBITCOIN_CRYPTO) \\\n   $(LIBSECP256K1)\n \n-test_test_bitcoin_fuzzy_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n+test_test_globaltoken_fuzzy_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n #\n \n-nodist_test_test_bitcoin_SOURCES = $(GENERATED_TEST_FILES)\n+nodist_test_test_globaltoken_SOURCES = $(GENERATED_TEST_FILES)\n \n $(BITCOIN_TESTS): $(GENERATED_TEST_FILES)\n \n CLEAN_BITCOIN_TEST = test/*.gcda test/*.gcno $(GENERATED_TEST_FILES)\n \n CLEANFILES += $(CLEAN_BITCOIN_TEST)\n \n-bitcoin_test: $(TEST_BINARY)\n+globaltoken_test: $(TEST_BINARY)\n \n-bitcoin_test_check: $(TEST_BINARY) FORCE\n+globaltoken_test_check: $(TEST_BINARY) FORCE\n \t$(MAKE) check-TESTS TESTS=$^\n \n-bitcoin_test_clean : FORCE\n-\trm -f $(CLEAN_BITCOIN_TEST) $(test_test_bitcoin_OBJECTS) $(TEST_BINARY)\n+globaltoken_test_clean : FORCE\n+\trm -f $(CLEAN_BITCOIN_TEST) $(test_test_globaltoken_OBJECTS) $(TEST_BINARY)\n \n check-local:\n \t@echo \"Running test/util/bitcoin-util-test.py...\""
      },
      {
        "sha": "fbba156ddef8f587e44a40e06ba0bd5be66f9f8d",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=8d2f73698cedbf152cb601af04a56cede1e02ee8",
        "patch": "@@ -102,7 +102,7 @@ class CMainParams : public CChainParams {\n         consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1551398400; // Fri, 01 Mar 2019.\n \n         // The best chain should have at least this much work.\n-        consensus.nMinimumChainWork = uint256S(\"0x0000000000000000000000000000000000000000003f94d1ad391682fe038bf5\");\n+        consensus.nMinimumChainWork = uint256S(\"0x000000000000000000000000000000000000000000000031f5ad0ca02ffaa440\");\n \n         // By default assume that the signatures in ancestors of this block are valid.\n         consensus.defaultAssumeValid = uint256S(\"0x000000000000014cf4dc216dcc925bf0c6d7096aa6ab82e1af64e946d876df7d\"); //200000"
      },
      {
        "sha": "c6342aa05cdff10e27e80457caa98f12275bdea4",
        "filename": "src/clientversion.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/clientversion.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/clientversion.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.h?ref=8d2f73698cedbf152cb601af04a56cede1e02ee8",
        "patch": "@@ -22,7 +22,7 @@\n #define DO_STRINGIZE(X) #X\n \n //! Copyright string used in Windows .rc files\n-#define COPYRIGHT_STR \"2009-\" STRINGIZE(COPYRIGHT_YEAR) \" \" COPYRIGHT_HOLDERS_FINAL\n+#define COPYRIGHT_STR \"2009-\" STRINGIZE(COPYRIGHT_YEAR) \" \" COPYRIGHT_HOLDERS_FINAL \"\\n2017 \" COPYRIGHT_HOLDERS_FINAL_GLT\n \n /**\n  * globaltokend-res.rc includes this file, but it cannot cope with real c++ code."
      },
      {
        "sha": "45c5740805ff1685cecc7acada3b116b8aa2aa28",
        "filename": "src/qt/res/bitcoin-qt-res.rc",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/qt/res/bitcoin-qt-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/qt/res/bitcoin-qt-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/bitcoin-qt-res.rc?ref=8d2f73698cedbf152cb601af04a56cede1e02ee8",
        "patch": "@@ -1,4 +1,4 @@\n-IDI_ICON1 ICON DISCARDABLE \"icons/icon_wallet.ico\"\n+IDI_ICON1 ICON DISCARDABLE \"icons/bitcoin.ico\"\n IDI_ICON2 ICON DISCARDABLE \"icons/bitcoin_testnet.ico\"\n \n #include <windows.h>             // needed for VERSIONINFO"
      },
      {
        "sha": "93e55482b9002499a21f897ed6675708b557d829",
        "filename": "src/qt/splashscreen.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/qt/splashscreen.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8d2f73698cedbf152cb601af04a56cede1e02ee8/src/qt/splashscreen.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/splashscreen.cpp?ref=8d2f73698cedbf152cb601af04a56cede1e02ee8",
        "patch": "@@ -111,7 +111,7 @@ SplashScreen::SplashScreen(Qt::WindowFlags f, const NetworkStyle *networkStyle)\n         QRect copyrightRect(x, y, pixmap.width() - x - paddingRight, pixmap.height() - y);\n \t\tQRect copyrightRect_GLT(x, y_glt, pixmap.width() - x - paddingRight, pixmap.height() - y_glt);\n         pixPaint.drawText(copyrightRect, Qt::AlignLeft | Qt::AlignTop | Qt::TextWordWrap, copyrightText);\n-\t\tpixPaint.drawText(copyrightRect, Qt::AlignLeft | Qt::AlignTop | Qt::TextWordWrap, globaltokenText);\n+\t\tpixPaint.drawText(copyrightRect_GLT, Qt::AlignLeft | Qt::AlignTop | Qt::TextWordWrap, globaltokenText);\n     }\n \n     // draw additional text if special network"
      }
    ]
  },
  {
    "sha": "c6f9ea0aadcf6d5bbd302e6403c47e6a1e7b2de9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNmY5ZWEwYWFkY2Y2ZDViYmQzMDJlNjQwM2M0N2U2YTFlN2IyZGU5",
    "commit": {
      "author": {
        "name": "globaltoken",
        "email": "heisenbergakatheking@gmail.com",
        "date": "2017-07-22T10:15:18Z"
      },
      "committer": {
        "name": "globaltoken",
        "email": "heisenbergakatheking@gmail.com",
        "date": "2017-07-22T10:15:18Z"
      },
      "message": "QT Icon fix\n\nQT Icon fix",
      "tree": {
        "sha": "92e724c7372ee622c9f1e0d640b9f98093db9070",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/92e724c7372ee622c9f1e0d640b9f98093db9070"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c6f9ea0aadcf6d5bbd302e6403c47e6a1e7b2de9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6f9ea0aadcf6d5bbd302e6403c47e6a1e7b2de9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c6f9ea0aadcf6d5bbd302e6403c47e6a1e7b2de9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6f9ea0aadcf6d5bbd302e6403c47e6a1e7b2de9/comments",
    "author": null,
    "committer": null,
    "parents": [
      {
        "sha": "8d2f73698cedbf152cb601af04a56cede1e02ee8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8d2f73698cedbf152cb601af04a56cede1e02ee8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8d2f73698cedbf152cb601af04a56cede1e02ee8"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "a76b6934e94a0544f525092768e1c96467cc9cc6",
        "filename": "src/qt/res/bitcoin-qt-res.rc",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6f9ea0aadcf6d5bbd302e6403c47e6a1e7b2de9/src/qt/res/bitcoin-qt-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6f9ea0aadcf6d5bbd302e6403c47e6a1e7b2de9/src/qt/res/bitcoin-qt-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/bitcoin-qt-res.rc?ref=c6f9ea0aadcf6d5bbd302e6403c47e6a1e7b2de9",
        "patch": "@@ -1,4 +1,4 @@\n-IDI_ICON1 ICON DISCARDABLE \"icons/bitcoin.ico\"\n+IDI_ICON1 ICON DISCARDABLE \"icons/app_icon.ico\"\n IDI_ICON2 ICON DISCARDABLE \"icons/bitcoin_testnet.ico\"\n \n #include <windows.h>             // needed for VERSIONINFO"
      },
      {
        "sha": "cdb42df9161a5e3961926238725b1a3e2d637023",
        "filename": "src/qt/res/icons/app_icon.ico",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6f9ea0aadcf6d5bbd302e6403c47e6a1e7b2de9/src/qt/res/icons/app_icon.ico",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6f9ea0aadcf6d5bbd302e6403c47e6a1e7b2de9/src/qt/res/icons/app_icon.ico",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/icons/app_icon.ico?ref=c6f9ea0aadcf6d5bbd302e6403c47e6a1e7b2de9"
      }
    ]
  }
]