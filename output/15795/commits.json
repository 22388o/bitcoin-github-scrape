[
  {
    "sha": "fa1d3ee8d81762dfb0525a47fdc11386a8307f24",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmYTFkM2VlOGQ4MTc2MmRmYjA1MjVhNDdmZGMxMTM4NmE4MzA3ZjI0",
    "commit": {
      "author": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-04-11T14:48:56Z"
      },
      "committer": {
        "name": "MarcoFalke",
        "email": "falke.marco@gmail.com",
        "date": "2019-04-11T16:43:46Z"
      },
      "message": "scripted-diff: Avoid name collisions in CChainState\n\n-BEGIN VERIFY SCRIPT-\nSRC=(\"chainActive\" \"mapBlockIndex\" \"mapBlocksUnlinked\" \"pindexBestInvalid\")\nDST=(\"m_chain\"     \"m_block_index\" \"m_blocks_unlinked\" \"index_best_invalid\")\n\n # Hand picked line ranges of CChainState member functions\n # Found with `git grep -n -p -W  'CChainState::'  | grep --extended-regexp ':[0-9]+:'   | sed --regexp-extended 's/src.validation.cpp.([0-9]+).*/\\1/g' | tr '\\n' ' '`\nMEMBER_FUN_BEGIN=(1296 1562 1773 2266 2386 2445 2500 2515 2636 2738 2770 2859 2897 2934 3327 3449 3776 3796 4043 4063 4133 4134 4169 4281 4338 4490)\n # Found with `git grep -n -p -W  'CChainState::'  | grep --extended-regexp '\\-[0-9]+\\-}'| sed --regexp-extended 's/src.validation.cpp.([0-9]+).*/\\1/g' | tr '\\n' ' '`\nMEMBER_FUN_END=(  1304 1617 2055 2310 2439 2497 2509 2596 2732 2765 2853 2891 2931 2978 3406 3526 3794 3844 4061 4127 4131 4167 4260 4285 4361 4672)\n\nfor i in ${!DST[*]}\ndo\n echo \"Replace ${SRC[$i]} with ${DST[$i]} ...\"\n sed -i -r -e \"1,165{s/(    .+ \\*?)${SRC[$i]}/\\1${DST[$i]}/g}\"   src/validation.cpp\n sed -i -e \"s/g_chainstate.${SRC[$i]}/g_chainstate.${DST[$i]}/g\" src/validation.cpp\n\n for j in ${!MEMBER_FUN_BEGIN[*]}\n do\n  echo \" ... from line ${MEMBER_FUN_BEGIN[$j]} to ${MEMBER_FUN_BEGIN[$j]}\"\n  sed -i -e \"${MEMBER_FUN_BEGIN[$j]},${MEMBER_FUN_END[$j]}{s/\\<${SRC[$i]}\\>/${DST[$i]}/g}\"  src/validation.cpp\n done\ndone\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "0c850143c9d3a8264f8b6d0e041d7a1787a54916",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0c850143c9d3a8264f8b6d0e041d7a1787a54916"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fa1d3ee8d81762dfb0525a47fdc11386a8307f24",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unknown_key",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQGcBAABCgAGBQJcKq2AAAoJEM4rdWl+aaVIbj4MALctPdNWNFtAWSxf5CkYs0q0\nac/KeByNE0yqat/iu0TOYqevpbtsrpA0/t6Njc9KKqZvFgD7+TUZRKwaXR2PGlq+\n/h+L8EeBEcPUB8TnFbvnDaCaZgXhhEIzl2KudCLYuZI375gSs8zxdxo4St8u3Kc1\nDDFHA3YjLPGRZt23fyRoPcTSBAjaAttfKip5OSDCNkDjKo73VQ4C13jPRJ+OGZR2\nIb/6/W0dbZc4pKT/XgvdmyxmJ92E1zakm47oXnloKr1ZsXAmWApZqJ1JsqFzc/6C\n+Qwgf7yb6htlrJqiwJcjlgQkogDgUG200DN19XpwqyjJfkrjAKtB+zJ4PbAc79Yh\nZa9c2zFFhAID5dzkYR1U72VwqQdYm17Y3QnV1ucWeDbL8NfClKbNZ7/Pp6Zgpzwg\nX7B9swFCaC+gNsXZ61TppFVisu6IRSkEEJsP0QrxfzkdxQQe8vMFEg+wUEB3Xw26\nw/+vL6mGqaXBmTw97fL3mPrkDieKF8zRR5af2LGGeQ==\n=1/l5\n-----END PGP SIGNATURE-----",
        "payload": "tree 0c850143c9d3a8264f8b6d0e041d7a1787a54916\nparent 6a135fbe5b30c3603616589b4779b1ce602c9392\nauthor MarcoFalke <falke.marco@gmail.com> 1554994136 -0400\ncommitter MarcoFalke <falke.marco@gmail.com> 1555001026 -0400\n\nscripted-diff: Avoid name collisions in CChainState\n\n-BEGIN VERIFY SCRIPT-\nSRC=(\"chainActive\" \"mapBlockIndex\" \"mapBlocksUnlinked\" \"pindexBestInvalid\")\nDST=(\"m_chain\"     \"m_block_index\" \"m_blocks_unlinked\" \"index_best_invalid\")\n\n # Hand picked line ranges of CChainState member functions\n # Found with `git grep -n -p -W  'CChainState::'  | grep --extended-regexp ':[0-9]+:'   | sed --regexp-extended 's/src.validation.cpp.([0-9]+).*/\\1/g' | tr '\\n' ' '`\nMEMBER_FUN_BEGIN=(1296 1562 1773 2266 2386 2445 2500 2515 2636 2738 2770 2859 2897 2934 3327 3449 3776 3796 4043 4063 4133 4134 4169 4281 4338 4490)\n # Found with `git grep -n -p -W  'CChainState::'  | grep --extended-regexp '\\-[0-9]+\\-}'| sed --regexp-extended 's/src.validation.cpp.([0-9]+).*/\\1/g' | tr '\\n' ' '`\nMEMBER_FUN_END=(  1304 1617 2055 2310 2439 2497 2509 2596 2732 2765 2853 2891 2931 2978 3406 3526 3794 3844 4061 4127 4131 4167 4260 4285 4361 4672)\n\nfor i in ${!DST[*]}\ndo\n echo \"Replace ${SRC[$i]} with ${DST[$i]} ...\"\n sed -i -r -e \"1,165{s/(    .+ \\*?)${SRC[$i]}/\\1${DST[$i]}/g}\"   src/validation.cpp\n sed -i -e \"s/g_chainstate.${SRC[$i]}/g_chainstate.${DST[$i]}/g\" src/validation.cpp\n\n for j in ${!MEMBER_FUN_BEGIN[*]}\n do\n  echo \" ... from line ${MEMBER_FUN_BEGIN[$j]} to ${MEMBER_FUN_BEGIN[$j]}\"\n  sed -i -e \"${MEMBER_FUN_BEGIN[$j]},${MEMBER_FUN_END[$j]}{s/\\<${SRC[$i]}\\>/${DST[$i]}/g}\"  src/validation.cpp\n done\ndone\n-END VERIFY SCRIPT-\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa1d3ee8d81762dfb0525a47fdc11386a8307f24",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fa1d3ee8d81762dfb0525a47fdc11386a8307f24",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fa1d3ee8d81762dfb0525a47fdc11386a8307f24/comments",
    "author": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "MarcoFalke",
      "id": 6399679,
      "node_id": "MDQ6VXNlcjYzOTk2Nzk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6399679?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/MarcoFalke",
      "html_url": "https://github.com/MarcoFalke",
      "followers_url": "https://api.github.com/users/MarcoFalke/followers",
      "following_url": "https://api.github.com/users/MarcoFalke/following{/other_user}",
      "gists_url": "https://api.github.com/users/MarcoFalke/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/MarcoFalke/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/MarcoFalke/subscriptions",
      "organizations_url": "https://api.github.com/users/MarcoFalke/orgs",
      "repos_url": "https://api.github.com/users/MarcoFalke/repos",
      "events_url": "https://api.github.com/users/MarcoFalke/events{/privacy}",
      "received_events_url": "https://api.github.com/users/MarcoFalke/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6a135fbe5b30c3603616589b4779b1ce602c9392",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a135fbe5b30c3603616589b4779b1ce602c9392",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6a135fbe5b30c3603616589b4779b1ce602c9392"
      }
    ],
    "stats": {
      "total": 230,
      "additions": 115,
      "deletions": 115
    },
    "files": [
      {
        "sha": "c8898a245699307b5773fc5d1809e39d4f9c870d",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 115,
        "deletions": 115,
        "changes": 230,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fa1d3ee8d81762dfb0525a47fdc11386a8307f24/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fa1d3ee8d81762dfb0525a47fdc11386a8307f24/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=fa1d3ee8d81762dfb0525a47fdc11386a8307f24",
        "patch": "@@ -133,17 +133,17 @@ class CChainState {\n       * blocks which we tried to connect and found to be invalid here (ie which\n       * were set to BLOCK_FAILED_VALID since the last restart). We can then\n       * walk this set and check if a new header is a descendant of something in\n-      * this set, preventing us from having to walk mapBlockIndex when we try\n+      * this set, preventing us from having to walk m_block_index when we try\n       * to connect a bad block and fail.\n       *\n       * While this is more complicated than marking everything which descends\n       * from an invalid block as invalid at the time we discover it to be\n-      * invalid, doing so would require walking all of mapBlockIndex to find all\n+      * invalid, doing so would require walking all of m_block_index to find all\n       * descendants. Since this case should be very rare, keeping track of all\n       * BLOCK_FAILED_VALID blocks in a set should be just fine and work just as\n       * well.\n       *\n-      * Because we already walk mapBlockIndex in height-order at startup, we go\n+      * Because we already walk m_block_index in height-order at startup, we go\n       * ahead and mark descendants of invalid blocks as FAILED_CHILD at that time,\n       * instead of putting things in this set.\n       */\n@@ -156,10 +156,10 @@ class CChainState {\n     CCriticalSection m_cs_chainstate;\n \n public:\n-    CChain chainActive;\n-    BlockMap mapBlockIndex GUARDED_BY(cs_main);\n-    std::multimap<CBlockIndex*, CBlockIndex*> mapBlocksUnlinked;\n-    CBlockIndex *pindexBestInvalid = nullptr;\n+    CChain m_chain;\n+    BlockMap m_block_index GUARDED_BY(cs_main);\n+    std::multimap<CBlockIndex*, CBlockIndex*> m_blocks_unlinked;\n+    CBlockIndex *index_best_invalid = nullptr;\n \n     bool LoadBlockIndex(const Consensus::Params& consensus_params, CBlockTreeDB& blocktree) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n \n@@ -229,8 +229,8 @@ class CChainState {\n  */\n RecursiveMutex cs_main;\n \n-BlockMap& mapBlockIndex = g_chainstate.mapBlockIndex;\n-CChain& chainActive = g_chainstate.chainActive;\n+BlockMap& mapBlockIndex = g_chainstate.m_block_index;\n+CChain& chainActive = g_chainstate.m_chain;\n CBlockIndex *pindexBestHeader = nullptr;\n Mutex g_best_block_mutex;\n std::condition_variable g_best_block_cv;\n@@ -263,12 +263,12 @@ CScript COINBASE_FLAGS;\n \n // Internal stuff\n namespace {\n-    CBlockIndex *&pindexBestInvalid = g_chainstate.pindexBestInvalid;\n+    CBlockIndex *&pindexBestInvalid = g_chainstate.index_best_invalid;\n \n     /** All pairs A->B, where A (or one of its ancestors) misses transactions, but B has transactions.\n      * Pruned nodes may have entries where B is missing data.\n      */\n-    std::multimap<CBlockIndex*, CBlockIndex*>& mapBlocksUnlinked = g_chainstate.mapBlocksUnlinked;\n+    std::multimap<CBlockIndex*, CBlockIndex*>& mapBlocksUnlinked = g_chainstate.m_blocks_unlinked;\n \n     CCriticalSection cs_LastBlockFile;\n     std::vector<CBlockFileInfo> vinfoBlockFile;\n@@ -1822,8 +1822,8 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         //  relative to a piece of software is an objective fact these defaults can be easily reviewed.\n         // This setting doesn't force the selection of any particular chain but makes validating some faster by\n         //  effectively caching the result of part of the verification.\n-        BlockMap::const_iterator  it = mapBlockIndex.find(hashAssumeValid);\n-        if (it != mapBlockIndex.end()) {\n+        BlockMap::const_iterator  it = m_block_index.find(hashAssumeValid);\n+        if (it != m_block_index.end()) {\n             if (it->second->GetAncestor(pindex->nHeight) == pindex &&\n                 pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&\n                 pindexBestHeader->nChainWork >= nMinimumChainWork) {\n@@ -2265,7 +2265,7 @@ void static UpdateTip(const CBlockIndex *pindexNew, const CChainParams& chainPar\n   */\n bool CChainState::DisconnectTip(CValidationState& state, const CChainParams& chainparams, DisconnectedBlockTransactions *disconnectpool)\n {\n-    CBlockIndex *pindexDelete = chainActive.Tip();\n+    CBlockIndex *pindexDelete = m_chain.Tip();\n     assert(pindexDelete);\n     // Read block from disk.\n     std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n@@ -2300,7 +2300,7 @@ bool CChainState::DisconnectTip(CValidationState& state, const CChainParams& cha\n         }\n     }\n \n-    chainActive.SetTip(pindexDelete->pprev);\n+    m_chain.SetTip(pindexDelete->pprev);\n \n     UpdateTip(pindexDelete->pprev, chainparams);\n     // Let wallets know transactions went from 1-confirmed to\n@@ -2385,7 +2385,7 @@ class ConnectTrace {\n  */\n bool CChainState::ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool)\n {\n-    assert(pindexNew->pprev == chainActive.Tip());\n+    assert(pindexNew->pprev == m_chain.Tip());\n     // Read block from disk.\n     int64_t nTime1 = GetTimeMicros();\n     std::shared_ptr<const CBlock> pthisBlock;\n@@ -2426,8 +2426,8 @@ bool CChainState::ConnectTip(CValidationState& state, const CChainParams& chainp\n     // Remove conflicting transactions from the mempool.;\n     mempool.removeForBlock(blockConnecting.vtx, pindexNew->nHeight);\n     disconnectpool.removeForBlock(blockConnecting.vtx);\n-    // Update chainActive & related variables.\n-    chainActive.SetTip(pindexNew);\n+    // Update m_chain & related variables.\n+    m_chain.SetTip(pindexNew);\n     UpdateTip(pindexNew, chainparams);\n \n     int64_t nTime6 = GetTimeMicros(); nTimePostConnect += nTime6 - nTime5; nTimeTotal += nTime6 - nTime1;\n@@ -2458,7 +2458,7 @@ CBlockIndex* CChainState::FindMostWorkChain() {\n         // Just going until the active chain is an optimization, as we know all blocks in it are valid already.\n         CBlockIndex *pindexTest = pindexNew;\n         bool fInvalidAncestor = false;\n-        while (pindexTest && !chainActive.Contains(pindexTest)) {\n+        while (pindexTest && !m_chain.Contains(pindexTest)) {\n             assert(pindexTest->HaveTxsDownloaded() || pindexTest->nHeight == 0);\n \n             // Pruned nodes may have entries in setBlockIndexCandidates for\n@@ -2469,18 +2469,18 @@ CBlockIndex* CChainState::FindMostWorkChain() {\n             bool fMissingData = !(pindexTest->nStatus & BLOCK_HAVE_DATA);\n             if (fFailedChain || fMissingData) {\n                 // Candidate chain is not usable (either invalid or missing data)\n-                if (fFailedChain && (pindexBestInvalid == nullptr || pindexNew->nChainWork > pindexBestInvalid->nChainWork))\n-                    pindexBestInvalid = pindexNew;\n+                if (fFailedChain && (index_best_invalid == nullptr || pindexNew->nChainWork > index_best_invalid->nChainWork))\n+                    index_best_invalid = pindexNew;\n                 CBlockIndex *pindexFailed = pindexNew;\n                 // Remove the entire chain from the set.\n                 while (pindexTest != pindexFailed) {\n                     if (fFailedChain) {\n                         pindexFailed->nStatus |= BLOCK_FAILED_CHILD;\n                     } else if (fMissingData) {\n-                        // If we're missing data, then add back to mapBlocksUnlinked,\n+                        // If we're missing data, then add back to m_blocks_unlinked,\n                         // so that if the block arrives in the future we can try adding\n                         // to setBlockIndexCandidates again.\n-                        mapBlocksUnlinked.insert(std::make_pair(pindexFailed->pprev, pindexFailed));\n+                        m_blocks_unlinked.insert(std::make_pair(pindexFailed->pprev, pindexFailed));\n                     }\n                     setBlockIndexCandidates.erase(pindexFailed);\n                     pindexFailed = pindexFailed->pprev;\n@@ -2501,7 +2501,7 @@ void CChainState::PruneBlockIndexCandidates() {\n     // Note that we can't delete the current block itself, as we may need to return to it later in case a\n     // reorganization to a better block fails.\n     std::set<CBlockIndex*, CBlockIndexWorkComparator>::iterator it = setBlockIndexCandidates.begin();\n-    while (it != setBlockIndexCandidates.end() && setBlockIndexCandidates.value_comp()(*it, chainActive.Tip())) {\n+    while (it != setBlockIndexCandidates.end() && setBlockIndexCandidates.value_comp()(*it, m_chain.Tip())) {\n         setBlockIndexCandidates.erase(it++);\n     }\n     // Either the current tip or a successor of it we're working towards is left in setBlockIndexCandidates.\n@@ -2516,13 +2516,13 @@ bool CChainState::ActivateBestChainStep(CValidationState& state, const CChainPar\n {\n     AssertLockHeld(cs_main);\n \n-    const CBlockIndex *pindexOldTip = chainActive.Tip();\n-    const CBlockIndex *pindexFork = chainActive.FindFork(pindexMostWork);\n+    const CBlockIndex *pindexOldTip = m_chain.Tip();\n+    const CBlockIndex *pindexFork = m_chain.FindFork(pindexMostWork);\n \n     // Disconnect active blocks which are no longer in the best chain.\n     bool fBlocksDisconnected = false;\n     DisconnectedBlockTransactions disconnectpool;\n-    while (chainActive.Tip() && chainActive.Tip() != pindexFork) {\n+    while (m_chain.Tip() && m_chain.Tip() != pindexFork) {\n         if (!DisconnectTip(state, chainparams, &disconnectpool)) {\n             // This is likely a fatal error, but keep the mempool consistent,\n             // just in case. Only remove from the mempool in this case.\n@@ -2570,7 +2570,7 @@ bool CChainState::ActivateBestChainStep(CValidationState& state, const CChainPar\n                 }\n             } else {\n                 PruneBlockIndexCandidates();\n-                if (!pindexOldTip || chainActive.Tip()->nChainWork > pindexOldTip->nChainWork) {\n+                if (!pindexOldTip || m_chain.Tip()->nChainWork > pindexOldTip->nChainWork) {\n                     // We're in a better position than we were. Return temporarily to release the lock.\n                     fContinue = false;\n                     break;\n@@ -2662,7 +2662,7 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n \n         {\n             LOCK(cs_main);\n-            CBlockIndex* starting_tip = chainActive.Tip();\n+            CBlockIndex* starting_tip = m_chain.Tip();\n             bool blocks_connected = false;\n             do {\n                 // We absolutely may not unlock cs_main until we've made forward progress\n@@ -2674,7 +2674,7 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n                 }\n \n                 // Whether we have anything to do at all.\n-                if (pindexMostWork == nullptr || pindexMostWork == chainActive.Tip()) {\n+                if (pindexMostWork == nullptr || pindexMostWork == m_chain.Tip()) {\n                     break;\n                 }\n \n@@ -2688,16 +2688,16 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n                     // Wipe cache, we may need another branch now.\n                     pindexMostWork = nullptr;\n                 }\n-                pindexNewTip = chainActive.Tip();\n+                pindexNewTip = m_chain.Tip();\n \n                 for (const PerBlockConnectTrace& trace : connectTrace.GetBlocksConnected()) {\n                     assert(trace.pblock && trace.pindex);\n                     GetMainSignals().BlockConnected(trace.pblock, trace.pindex, trace.conflictedTxs);\n                 }\n-            } while (!chainActive.Tip() || (starting_tip && CBlockIndexWorkComparator()(chainActive.Tip(), starting_tip)));\n+            } while (!m_chain.Tip() || (starting_tip && CBlockIndexWorkComparator()(m_chain.Tip(), starting_tip)));\n             if (!blocks_connected) return true;\n \n-            const CBlockIndex* pindexFork = chainActive.FindFork(starting_tip);\n+            const CBlockIndex* pindexFork = m_chain.FindFork(starting_tip);\n             bool fInitialDownload = IsInitialBlockDownload();\n \n             // Notify external listeners about the new tip.\n@@ -2739,15 +2739,15 @@ bool CChainState::PreciousBlock(CValidationState& state, const CChainParams& par\n {\n     {\n         LOCK(cs_main);\n-        if (pindex->nChainWork < chainActive.Tip()->nChainWork) {\n+        if (pindex->nChainWork < m_chain.Tip()->nChainWork) {\n             // Nothing to do, this block is not at the tip.\n             return true;\n         }\n-        if (chainActive.Tip()->nChainWork > nLastPreciousChainwork) {\n+        if (m_chain.Tip()->nChainWork > nLastPreciousChainwork) {\n             // The chain has been extended since the last call, reset the counter.\n             nBlockReverseSequenceId = -1;\n         }\n-        nLastPreciousChainwork = chainActive.Tip()->nChainWork;\n+        nLastPreciousChainwork = m_chain.Tip()->nChainWork;\n         setBlockIndexCandidates.erase(pindex);\n         pindex->nSequenceId = nBlockReverseSequenceId;\n         if (nBlockReverseSequenceId > std::numeric_limits<int32_t>::min()) {\n@@ -2781,11 +2781,11 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n         LimitValidationInterfaceQueue();\n \n         LOCK(cs_main);\n-        if (!chainActive.Contains(pindex)) break;\n+        if (!m_chain.Contains(pindex)) break;\n         pindex_was_in_chain = true;\n-        CBlockIndex *invalid_walk_tip = chainActive.Tip();\n+        CBlockIndex *invalid_walk_tip = m_chain.Tip();\n \n-        // ActivateBestChain considers blocks already in chainActive\n+        // ActivateBestChain considers blocks already in m_chain\n         // unconditionally valid already, so force disconnect away from it.\n         DisconnectedBlockTransactions disconnectpool;\n         bool ret = DisconnectTip(state, chainparams, &disconnectpool);\n@@ -2796,7 +2796,7 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n         // keeping the mempool up to date is probably futile anyway).\n         UpdateMempoolForReorg(disconnectpool, /* fAddToMempool = */ (++disconnected <= 10) && ret);\n         if (!ret) return false;\n-        assert(invalid_walk_tip->pprev == chainActive.Tip());\n+        assert(invalid_walk_tip->pprev == m_chain.Tip());\n \n         // We immediately mark the disconnected blocks as invalid.\n         // This prevents a case where pruned nodes may fail to invalidateblock\n@@ -2821,7 +2821,7 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n \n     {\n         LOCK(cs_main);\n-        if (chainActive.Contains(to_mark_failed)) {\n+        if (m_chain.Contains(to_mark_failed)) {\n             // If the to-be-marked invalid block is in the active chain, something is interfering and we can't proceed.\n             return false;\n         }\n@@ -2834,9 +2834,9 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n \n         // The resulting new best tip may not be in setBlockIndexCandidates anymore, so\n         // add it again.\n-        BlockMap::iterator it = mapBlockIndex.begin();\n-        while (it != mapBlockIndex.end()) {\n-            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(it->second, chainActive.Tip())) {\n+        BlockMap::iterator it = m_block_index.begin();\n+        while (it != m_block_index.end()) {\n+            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && !setBlockIndexCandidates.value_comp()(it->second, m_chain.Tip())) {\n                 setBlockIndexCandidates.insert(it->second);\n             }\n             it++;\n@@ -2862,17 +2862,17 @@ void CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n     int nHeight = pindex->nHeight;\n \n     // Remove the invalidity flag from this block and all its descendants.\n-    BlockMap::iterator it = mapBlockIndex.begin();\n-    while (it != mapBlockIndex.end()) {\n+    BlockMap::iterator it = m_block_index.begin();\n+    while (it != m_block_index.end()) {\n         if (!it->second->IsValid() && it->second->GetAncestor(nHeight) == pindex) {\n             it->second->nStatus &= ~BLOCK_FAILED_MASK;\n             setDirtyBlockIndex.insert(it->second);\n-            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && setBlockIndexCandidates.value_comp()(chainActive.Tip(), it->second)) {\n+            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->HaveTxsDownloaded() && setBlockIndexCandidates.value_comp()(m_chain.Tip(), it->second)) {\n                 setBlockIndexCandidates.insert(it->second);\n             }\n-            if (it->second == pindexBestInvalid) {\n+            if (it->second == index_best_invalid) {\n                 // Reset invalid block marker if it was pointing to one of those.\n-                pindexBestInvalid = nullptr;\n+                index_best_invalid = nullptr;\n             }\n             m_failed_blocks.erase(it->second);\n         }\n@@ -2900,8 +2900,8 @@ CBlockIndex* CChainState::AddToBlockIndex(const CBlockHeader& block)\n \n     // Check for duplicate\n     uint256 hash = block.GetHash();\n-    BlockMap::iterator it = mapBlockIndex.find(hash);\n-    if (it != mapBlockIndex.end())\n+    BlockMap::iterator it = m_block_index.find(hash);\n+    if (it != m_block_index.end())\n         return it->second;\n \n     // Construct new block index object\n@@ -2910,10 +2910,10 @@ CBlockIndex* CChainState::AddToBlockIndex(const CBlockHeader& block)\n     // to avoid miners withholding blocks but broadcasting headers, to get a\n     // competitive advantage.\n     pindexNew->nSequenceId = 0;\n-    BlockMap::iterator mi = mapBlockIndex.insert(std::make_pair(hash, pindexNew)).first;\n+    BlockMap::iterator mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n-    BlockMap::iterator miPrev = mapBlockIndex.find(block.hashPrevBlock);\n-    if (miPrev != mapBlockIndex.end())\n+    BlockMap::iterator miPrev = m_block_index.find(block.hashPrevBlock);\n+    if (miPrev != m_block_index.end())\n     {\n         pindexNew->pprev = (*miPrev).second;\n         pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n@@ -2959,20 +2959,20 @@ void CChainState::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pi\n                 LOCK(cs_nBlockSequenceId);\n                 pindex->nSequenceId = nBlockSequenceId++;\n             }\n-            if (chainActive.Tip() == nullptr || !setBlockIndexCandidates.value_comp()(pindex, chainActive.Tip())) {\n+            if (m_chain.Tip() == nullptr || !setBlockIndexCandidates.value_comp()(pindex, m_chain.Tip())) {\n                 setBlockIndexCandidates.insert(pindex);\n             }\n-            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = mapBlocksUnlinked.equal_range(pindex);\n+            std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> range = m_blocks_unlinked.equal_range(pindex);\n             while (range.first != range.second) {\n                 std::multimap<CBlockIndex*, CBlockIndex*>::iterator it = range.first;\n                 queue.push_back(it->second);\n                 range.first++;\n-                mapBlocksUnlinked.erase(it);\n+                m_blocks_unlinked.erase(it);\n             }\n         }\n     } else {\n         if (pindexNew->pprev && pindexNew->pprev->IsValid(BLOCK_VALID_TREE)) {\n-            mapBlocksUnlinked.insert(std::make_pair(pindexNew->pprev, pindexNew));\n+            m_blocks_unlinked.insert(std::make_pair(pindexNew->pprev, pindexNew));\n         }\n     }\n }\n@@ -3329,10 +3329,10 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n     AssertLockHeld(cs_main);\n     // Check for duplicate\n     uint256 hash = block.GetHash();\n-    BlockMap::iterator miSelf = mapBlockIndex.find(hash);\n+    BlockMap::iterator miSelf = m_block_index.find(hash);\n     CBlockIndex *pindex = nullptr;\n     if (hash != chainparams.GetConsensus().hashGenesisBlock) {\n-        if (miSelf != mapBlockIndex.end()) {\n+        if (miSelf != m_block_index.end()) {\n             // Block header is already known.\n             pindex = miSelf->second;\n             if (ppindex)\n@@ -3347,8 +3347,8 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n \n         // Get prev block index\n         CBlockIndex* pindexPrev = nullptr;\n-        BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n-        if (mi == mapBlockIndex.end())\n+        BlockMap::iterator mi = m_block_index.find(block.hashPrevBlock);\n+        if (mi == m_block_index.end())\n             return state.DoS(10, error(\"%s: prev block not found\", __func__), 0, \"prev-blk-not-found\");\n         pindexPrev = (*mi).second;\n         if (pindexPrev->nStatus & BLOCK_FAILED_MASK)\n@@ -3463,13 +3463,13 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n     // process an unrequested block if it's new and has enough work to\n     // advance our tip, and isn't too many blocks ahead.\n     bool fAlreadyHave = pindex->nStatus & BLOCK_HAVE_DATA;\n-    bool fHasMoreOrSameWork = (chainActive.Tip() ? pindex->nChainWork >= chainActive.Tip()->nChainWork : true);\n+    bool fHasMoreOrSameWork = (m_chain.Tip() ? pindex->nChainWork >= m_chain.Tip()->nChainWork : true);\n     // Blocks that are too out-of-order needlessly limit the effectiveness of\n     // pruning, because pruning will not delete block files that contain any\n     // blocks which are too close in height to the tip.  Apply this test\n     // regardless of whether pruning is enabled; it should generally be safe to\n     // not process unrequested blocks.\n-    bool fTooFarAhead = (pindex->nHeight > int(chainActive.Height() + MIN_BLOCKS_TO_KEEP));\n+    bool fTooFarAhead = (pindex->nHeight > int(m_chain.Height() + MIN_BLOCKS_TO_KEEP));\n \n     // TODO: Decouple this function from the block download logic by removing fRequested\n     // This requires some new chain data structure to efficiently look up if a\n@@ -3502,7 +3502,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n \n     // Header is valid/has work, merkle tree and segwit merkle tree are good...RELAY NOW\n     // (but if it does not build on our best tip, let the SendMessages loop relay it)\n-    if (!IsInitialBlockDownload() && chainActive.Tip() == pindex->pprev)\n+    if (!IsInitialBlockDownload() && m_chain.Tip() == pindex->pprev)\n         GetMainSignals().NewPoWValidBlock(pindex, pblock);\n \n     // Write block to history file\n@@ -3781,13 +3781,13 @@ CBlockIndex * CChainState::InsertBlockIndex(const uint256& hash)\n         return nullptr;\n \n     // Return existing\n-    BlockMap::iterator mi = mapBlockIndex.find(hash);\n-    if (mi != mapBlockIndex.end())\n+    BlockMap::iterator mi = m_block_index.find(hash);\n+    if (mi != m_block_index.end())\n         return (*mi).second;\n \n     // Create new\n     CBlockIndex* pindexNew = new CBlockIndex();\n-    mi = mapBlockIndex.insert(std::make_pair(hash, pindexNew)).first;\n+    mi = m_block_index.insert(std::make_pair(hash, pindexNew)).first;\n     pindexNew->phashBlock = &((*mi).first);\n \n     return pindexNew;\n@@ -3800,8 +3800,8 @@ bool CChainState::LoadBlockIndex(const Consensus::Params& consensus_params, CBlo\n \n     // Calculate nChainWork\n     std::vector<std::pair<int, CBlockIndex*> > vSortedByHeight;\n-    vSortedByHeight.reserve(mapBlockIndex.size());\n-    for (const std::pair<const uint256, CBlockIndex*>& item : mapBlockIndex)\n+    vSortedByHeight.reserve(m_block_index.size());\n+    for (const std::pair<const uint256, CBlockIndex*>& item : m_block_index)\n     {\n         CBlockIndex* pindex = item.second;\n         vSortedByHeight.push_back(std::make_pair(pindex->nHeight, pindex));\n@@ -3820,7 +3820,7 @@ bool CChainState::LoadBlockIndex(const Consensus::Params& consensus_params, CBlo\n                     pindex->nChainTx = pindex->pprev->nChainTx + pindex->nTx;\n                 } else {\n                     pindex->nChainTx = 0;\n-                    mapBlocksUnlinked.insert(std::make_pair(pindex->pprev, pindex));\n+                    m_blocks_unlinked.insert(std::make_pair(pindex->pprev, pindex));\n                 }\n             } else {\n                 pindex->nChainTx = pindex->nTx;\n@@ -3832,8 +3832,8 @@ bool CChainState::LoadBlockIndex(const Consensus::Params& consensus_params, CBlo\n         }\n         if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->HaveTxsDownloaded() || pindex->pprev == nullptr))\n             setBlockIndexCandidates.insert(pindex);\n-        if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n-            pindexBestInvalid = pindex;\n+        if (pindex->nStatus & BLOCK_FAILED_MASK && (!index_best_invalid || pindex->nChainWork > index_best_invalid->nChainWork))\n+            index_best_invalid = pindex;\n         if (pindex->pprev)\n             pindex->BuildSkip();\n         if (pindex->IsValid(BLOCK_VALID_TREE) && (pindexBestHeader == nullptr || CBlockIndexWorkComparator()(pindexBestHeader, pindex)))\n@@ -4077,16 +4077,16 @@ bool CChainState::ReplayBlocks(const CChainParams& params, CCoinsView* view)\n     const CBlockIndex* pindexNew;            // New tip during the interrupted flush.\n     const CBlockIndex* pindexFork = nullptr; // Latest block common to both the old and the new tip.\n \n-    if (mapBlockIndex.count(hashHeads[0]) == 0) {\n+    if (m_block_index.count(hashHeads[0]) == 0) {\n         return error(\"ReplayBlocks(): reorganization to unknown block requested\");\n     }\n-    pindexNew = mapBlockIndex[hashHeads[0]];\n+    pindexNew = m_block_index[hashHeads[0]];\n \n     if (!hashHeads[1].IsNull()) { // The old tip is allowed to be 0, indicating it's the first flush.\n-        if (mapBlockIndex.count(hashHeads[1]) == 0) {\n+        if (m_block_index.count(hashHeads[1]) == 0) {\n             return error(\"ReplayBlocks(): reorganization from unknown block requested\");\n         }\n-        pindexOld = mapBlockIndex[hashHeads[1]];\n+        pindexOld = m_block_index[hashHeads[1]];\n         pindexFork = LastCommonAncestor(pindexOld, pindexNew);\n         assert(pindexFork != nullptr);\n     }\n@@ -4134,7 +4134,7 @@ bool ReplayBlocks(const CChainParams& params, CCoinsView* view) {\n void CChainState::EraseBlockData(CBlockIndex* index)\n {\n     AssertLockHeld(cs_main);\n-    assert(!chainActive.Contains(index)); // Make sure this block isn't active\n+    assert(!m_chain.Contains(index)); // Make sure this block isn't active\n \n     // Reduce validity\n     index->nStatus = std::min<unsigned int>(index->nStatus & BLOCK_VALID_MASK, BLOCK_VALID_TREE) | (index->nStatus & ~BLOCK_VALID_MASK);\n@@ -4152,10 +4152,10 @@ void CChainState::EraseBlockData(CBlockIndex* index)\n     setDirtyBlockIndex.insert(index);\n     // Update indexes\n     setBlockIndexCandidates.erase(index);\n-    std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> ret = mapBlocksUnlinked.equal_range(index->pprev);\n+    std::pair<std::multimap<CBlockIndex*, CBlockIndex*>::iterator, std::multimap<CBlockIndex*, CBlockIndex*>::iterator> ret = m_blocks_unlinked.equal_range(index->pprev);\n     while (ret.first != ret.second) {\n         if (ret.first->second == index) {\n-            mapBlocksUnlinked.erase(ret.first++);\n+            m_blocks_unlinked.erase(ret.first++);\n         } else {\n             ++ret.first;\n         }\n@@ -4168,15 +4168,15 @@ void CChainState::EraseBlockData(CBlockIndex* index)\n \n bool CChainState::RewindBlockIndex(const CChainParams& params)\n {\n-    // Note that during -reindex-chainstate we are called with an empty chainActive!\n+    // Note that during -reindex-chainstate we are called with an empty m_chain!\n \n     // First erase all post-segwit blocks without witness not in the main chain,\n     // as this can we done without costly DisconnectTip calls. Active\n     // blocks will be dealt with below (releasing cs_main in between).\n     {\n         LOCK(cs_main);\n-        for (const auto& entry : mapBlockIndex) {\n-            if (IsWitnessEnabled(entry.second->pprev, params.GetConsensus()) && !(entry.second->nStatus & BLOCK_OPT_WITNESS) && !chainActive.Contains(entry.second)) {\n+        for (const auto& entry : m_block_index) {\n+            if (IsWitnessEnabled(entry.second->pprev, params.GetConsensus()) && !(entry.second->nStatus & BLOCK_OPT_WITNESS) && !m_chain.Contains(entry.second)) {\n                 EraseBlockData(entry.second);\n             }\n         }\n@@ -4187,17 +4187,17 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n     int nHeight = 1;\n     {\n         LOCK(cs_main);\n-        while (nHeight <= chainActive.Height()) {\n+        while (nHeight <= m_chain.Height()) {\n             // Although SCRIPT_VERIFY_WITNESS is now generally enforced on all\n             // blocks in ConnectBlock, we don't need to go back and\n             // re-download/re-verify blocks from before segwit actually activated.\n-            if (IsWitnessEnabled(chainActive[nHeight - 1], params.GetConsensus()) && !(chainActive[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {\n+            if (IsWitnessEnabled(m_chain[nHeight - 1], params.GetConsensus()) && !(m_chain[nHeight]->nStatus & BLOCK_OPT_WITNESS)) {\n                 break;\n             }\n             nHeight++;\n         }\n \n-        tip = chainActive.Tip();\n+        tip = m_chain.Tip();\n     }\n     // nHeight is now the height of the first insufficiently-validated block, or tipheight + 1\n \n@@ -4207,7 +4207,7 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n         {\n             LOCK(cs_main);\n             // Make sure nothing changed from under us (this won't happen because RewindBlockIndex runs before importing/network are active)\n-            assert(tip == chainActive.Tip());\n+            assert(tip == m_chain.Tip());\n             if (tip == nullptr || tip->nHeight < nHeight) break;\n             if (fPruneMode && !(tip->nStatus & BLOCK_HAVE_DATA)) {\n                 // If pruning, don't try rewinding past the HAVE_DATA point;\n@@ -4227,9 +4227,9 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n             // We do this after actual disconnecting, otherwise we'll end up writing the lack of data\n             // to disk before writing the chainstate, resulting in a failure to continue if interrupted.\n             // Note: If we encounter an insufficiently validated block that\n-            // is on chainActive, it must be because we are a pruning node, and\n+            // is on m_chain, it must be because we are a pruning node, and\n             // this block or some successor doesn't HAVE_DATA, so we were unable to\n-            // rewind all the way.  Blocks remaining on chainActive at this point\n+            // rewind all the way.  Blocks remaining on m_chain at this point\n             // must not have their validity reduced.\n             EraseBlockData(tip);\n \n@@ -4247,9 +4247,9 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n \n     {\n         LOCK(cs_main);\n-        if (chainActive.Tip() != nullptr) {\n+        if (m_chain.Tip() != nullptr) {\n             // We can't prune block index candidates based on our tip if we have\n-            // no tip due to chainActive being empty!\n+            // no tip due to m_chain being empty!\n             PruneBlockIndexCandidates();\n \n             CheckBlockIndex(params.GetConsensus());\n@@ -4340,10 +4340,10 @@ bool CChainState::LoadGenesisBlock(const CChainParams& chainparams)\n     LOCK(cs_main);\n \n     // Check whether we're already initialized by checking for genesis in\n-    // mapBlockIndex. Note that we can't use chainActive here, since it is\n+    // m_block_index. Note that we can't use m_chain here, since it is\n     // set based on the coins db, not the block index db, which is the only\n     // thing loaded at this point.\n-    if (mapBlockIndex.count(chainparams.GenesisBlock().GetHash()))\n+    if (m_block_index.count(chainparams.GenesisBlock().GetHash()))\n         return true;\n \n     try {\n@@ -4496,20 +4496,20 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n     LOCK(cs_main);\n \n     // During a reindex, we read the genesis block and call CheckBlockIndex before ActivateBestChain,\n-    // so we have the genesis block in mapBlockIndex but no active chain.  (A few of the tests when\n-    // iterating the block tree require that chainActive has been initialized.)\n-    if (chainActive.Height() < 0) {\n-        assert(mapBlockIndex.size() <= 1);\n+    // so we have the genesis block in m_block_index but no active chain.  (A few of the tests when\n+    // iterating the block tree require that m_chain has been initialized.)\n+    if (m_chain.Height() < 0) {\n+        assert(m_block_index.size() <= 1);\n         return;\n     }\n \n     // Build forward-pointing map of the entire block tree.\n     std::multimap<CBlockIndex*,CBlockIndex*> forward;\n-    for (const std::pair<const uint256, CBlockIndex*>& entry : mapBlockIndex) {\n+    for (const std::pair<const uint256, CBlockIndex*>& entry : m_block_index) {\n         forward.insert(std::make_pair(entry.second->pprev, entry.second));\n     }\n \n-    assert(forward.size() == mapBlockIndex.size());\n+    assert(forward.size() == m_block_index.size());\n \n     std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeGenesis = forward.equal_range(nullptr);\n     CBlockIndex *pindex = rangeGenesis.first->second;\n@@ -4542,7 +4542,7 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n         if (pindex->pprev == nullptr) {\n             // Genesis block checks.\n             assert(pindex->GetBlockHash() == consensusParams.hashGenesisBlock); // Genesis block's hash must match.\n-            assert(pindex == chainActive.Genesis()); // The current active chain's genesis block must be this block.\n+            assert(pindex == m_chain.Genesis()); // The current active chain's genesis block must be this block.\n         }\n         if (!pindex->HaveTxsDownloaded()) assert(pindex->nSequenceId <= 0); // nSequenceId can't be set positive for blocks that aren't linked (negative is used for preciousblock)\n         // VALID_TRANSACTIONS is equivalent to nTx > 0 for all nodes (whether or not pruning has occurred).\n@@ -4563,32 +4563,32 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n         assert(pindex->nHeight == nHeight); // nHeight must be consistent.\n         assert(pindex->pprev == nullptr || pindex->nChainWork >= pindex->pprev->nChainWork); // For every block except the genesis block, the chainwork must be larger than the parent's.\n         assert(nHeight < 2 || (pindex->pskip && (pindex->pskip->nHeight < nHeight))); // The pskip pointer must point back for all but the first 2 blocks.\n-        assert(pindexFirstNotTreeValid == nullptr); // All mapBlockIndex entries must at least be TREE valid\n+        assert(pindexFirstNotTreeValid == nullptr); // All m_block_index entries must at least be TREE valid\n         if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_TREE) assert(pindexFirstNotTreeValid == nullptr); // TREE valid implies all parents are TREE valid\n         if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_CHAIN) assert(pindexFirstNotChainValid == nullptr); // CHAIN valid implies all parents are CHAIN valid\n         if ((pindex->nStatus & BLOCK_VALID_MASK) >= BLOCK_VALID_SCRIPTS) assert(pindexFirstNotScriptsValid == nullptr); // SCRIPTS valid implies all parents are SCRIPTS valid\n         if (pindexFirstInvalid == nullptr) {\n             // Checks for not-invalid blocks.\n             assert((pindex->nStatus & BLOCK_FAILED_MASK) == 0); // The failed mask cannot be set for blocks without invalid parents.\n         }\n-        if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && pindexFirstNeverProcessed == nullptr) {\n+        if (!CBlockIndexWorkComparator()(pindex, m_chain.Tip()) && pindexFirstNeverProcessed == nullptr) {\n             if (pindexFirstInvalid == nullptr) {\n                 // If this block sorts at least as good as the current tip and\n                 // is valid and we have all data for its parents, it must be in\n-                // setBlockIndexCandidates.  chainActive.Tip() must also be there\n+                // setBlockIndexCandidates.  m_chain.Tip() must also be there\n                 // even if some data has been pruned.\n-                if (pindexFirstMissing == nullptr || pindex == chainActive.Tip()) {\n+                if (pindexFirstMissing == nullptr || pindex == m_chain.Tip()) {\n                     assert(setBlockIndexCandidates.count(pindex));\n                 }\n                 // If some parent is missing, then it could be that this block was in\n                 // setBlockIndexCandidates but had to be removed because of the missing data.\n-                // In this case it must be in mapBlocksUnlinked -- see test below.\n+                // In this case it must be in m_blocks_unlinked -- see test below.\n             }\n         } else { // If this block sorts worse than the current tip or some ancestor's block has never been seen, it cannot be in setBlockIndexCandidates.\n             assert(setBlockIndexCandidates.count(pindex) == 0);\n         }\n-        // Check whether this block is in mapBlocksUnlinked.\n-        std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeUnlinked = mapBlocksUnlinked.equal_range(pindex->pprev);\n+        // Check whether this block is in m_blocks_unlinked.\n+        std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeUnlinked = m_blocks_unlinked.equal_range(pindex->pprev);\n         bool foundInUnlinked = false;\n         while (rangeUnlinked.first != rangeUnlinked.second) {\n             assert(rangeUnlinked.first->first == pindex->pprev);\n@@ -4599,23 +4599,23 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n             rangeUnlinked.first++;\n         }\n         if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed != nullptr && pindexFirstInvalid == nullptr) {\n-            // If this block has block data available, some parent was never received, and has no invalid parents, it must be in mapBlocksUnlinked.\n+            // If this block has block data available, some parent was never received, and has no invalid parents, it must be in m_blocks_unlinked.\n             assert(foundInUnlinked);\n         }\n-        if (!(pindex->nStatus & BLOCK_HAVE_DATA)) assert(!foundInUnlinked); // Can't be in mapBlocksUnlinked if we don't HAVE_DATA\n-        if (pindexFirstMissing == nullptr) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in mapBlocksUnlinked.\n+        if (!(pindex->nStatus & BLOCK_HAVE_DATA)) assert(!foundInUnlinked); // Can't be in m_blocks_unlinked if we don't HAVE_DATA\n+        if (pindexFirstMissing == nullptr) assert(!foundInUnlinked); // We aren't missing data for any parent -- cannot be in m_blocks_unlinked.\n         if (pindex->pprev && (pindex->nStatus & BLOCK_HAVE_DATA) && pindexFirstNeverProcessed == nullptr && pindexFirstMissing != nullptr) {\n             // We HAVE_DATA for this block, have received data for all parents at some point, but we're currently missing data for some parent.\n             assert(fHavePruned); // We must have pruned.\n-            // This block may have entered mapBlocksUnlinked if:\n+            // This block may have entered m_blocks_unlinked if:\n             //  - it has a descendant that at some point had more work than the\n             //    tip, and\n             //  - we tried switching to that descendant but were missing\n-            //    data for some intermediate block between chainActive and the\n+            //    data for some intermediate block between m_chain and the\n             //    tip.\n-            // So if this block is itself better than chainActive.Tip() and it wasn't in\n-            // setBlockIndexCandidates, then it must be in mapBlocksUnlinked.\n-            if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && setBlockIndexCandidates.count(pindex) == 0) {\n+            // So if this block is itself better than m_chain.Tip() and it wasn't in\n+            // setBlockIndexCandidates, then it must be in m_blocks_unlinked.\n+            if (!CBlockIndexWorkComparator()(pindex, m_chain.Tip()) && setBlockIndexCandidates.count(pindex) == 0) {\n                 if (pindexFirstInvalid == nullptr) {\n                     assert(foundInUnlinked);\n                 }"
      }
    ]
  }
]