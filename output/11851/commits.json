[
  {
    "sha": "ea23945dbc6ad239c5acac374d2b54aa12870838",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYTIzOTQ1ZGJjNmFkMjM5YzVhY2FjMzc0ZDJiNTRhYTEyODcwODM4",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-12-08T11:39:22Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2018-04-07T16:48:27Z"
      },
      "message": "scripted-diff: Rename wallet database classes\n\n-BEGIN VERIFY SCRIPT-\n\nsed -i 's/\\<CWalletDBWrapper\\>/BerkeleyDatabase/g' src/wallet/db.h src/wallet/db.cpp\nsed -i '/statuses/i/** Backend-agnostic database type. */\\nusing WalletDatabase = BerkeleyDatabase\\;\\n' src/wallet/walletdb.h\nren() { git grep -l \"\\<$1\\>\" 'src/*.cpp' 'src/*.h' ':(exclude)*dbwrapper*' test | xargs sed -i \"s:\\<$1\\>:$2:g\"; }\nren CDBEnv           BerkeleyEnvironment\nren CDB              BerkeleyBatch\nren CWalletDBWrapper WalletDatabase\nren CWalletDB        WalletBatch\nren dbw              database\nren m_dbw            m_database\nren walletdb         batch\nren pwalletdb        batch\nren pwalletdbIn      batch_in\nren wallet/batch.h   wallet/walletdb.h\nren pwalletdbEncryption encrypted_batch\n\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "d2ce7e636037accf153bcca2c4b170b91d1e0dd2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d2ce7e636037accf153bcca2c4b170b91d1e0dd2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ea23945dbc6ad239c5acac374d2b54aa12870838",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ea23945dbc6ad239c5acac374d2b54aa12870838",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ea23945dbc6ad239c5acac374d2b54aa12870838",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ea23945dbc6ad239c5acac374d2b54aa12870838/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b2e5fe8b559b2f6561ee8f220e9141e401929f5e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2e5fe8b559b2f6561ee8f220e9141e401929f5e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b2e5fe8b559b2f6561ee8f220e9141e401929f5e"
      }
    ],
    "stats": {
      "total": 633,
      "additions": 318,
      "deletions": 315
    },
    "files": [
      {
        "sha": "64ec056c4dae5ea6f2df7613b7be80187862ce78",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea23945dbc6ad239c5acac374d2b54aa12870838/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea23945dbc6ad239c5acac374d2b54aa12870838/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=ea23945dbc6ad239c5acac374d2b54aa12870838",
        "patch": "@@ -33,7 +33,7 @@ static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<CO\n // (https://github.com/bitcoin/bitcoin/issues/7883#issuecomment-224807484)\n static void CoinSelection(benchmark::State& state)\n {\n-    const CWallet wallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n+    const CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n     std::vector<COutput> vCoins;\n     LOCK(wallet.cs_wallet);\n "
      },
      {
        "sha": "6221f9017caf57c52fe1c6f03005c3af5fe4a847",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea23945dbc6ad239c5acac374d2b54aa12870838/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea23945dbc6ad239c5acac374d2b54aa12870838/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=ea23945dbc6ad239c5acac374d2b54aa12870838",
        "patch": "@@ -158,7 +158,7 @@ void TestGUI()\n     for (int i = 0; i < 5; ++i) {\n         test.CreateAndProcessBlock({}, GetScriptForRawPubKey(test.coinbaseKey.GetPubKey()));\n     }\n-    CWallet wallet(\"mock\", CWalletDBWrapper::CreateMock());\n+    CWallet wallet(\"mock\", WalletDatabase::CreateMock());\n     bool firstRun;\n     wallet.LoadWallet(firstRun);\n     {"
      },
      {
        "sha": "bb2789fed9b9c369a79881dae2f4d709675acbd5",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea23945dbc6ad239c5acac374d2b54aa12870838/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea23945dbc6ad239c5acac374d2b54aa12870838/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=ea23945dbc6ad239c5acac374d2b54aa12870838",
        "patch": "@@ -62,7 +62,7 @@ BOOST_AUTO_TEST_CASE(util_ParseHex)\n     result = ParseHex(\"12 34 56 78\");\n     BOOST_CHECK(result.size() == 4 && result[0] == 0x12 && result[1] == 0x34 && result[2] == 0x56 && result[3] == 0x78);\n \n-    // Leading space must be supported (used in CDBEnv::Salvage)\n+    // Leading space must be supported (used in BerkeleyEnvironment::Salvage)\n     result = ParseHex(\" 89 34 56 78\");\n     BOOST_CHECK(result.size() == 4 && result[0] == 0x89 && result[1] == 0x34 && result[2] == 0x56 && result[3] == 0x78);\n "
      },
      {
        "sha": "67e497e4545a26ad27178bb8336d67e2416dde2e",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 72,
        "deletions": 72,
        "changes": 144,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=ea23945dbc6ad239c5acac374d2b54aa12870838",
        "patch": "@@ -30,14 +30,14 @@ namespace {\n //! (https://docs.oracle.com/cd/E17275_01/html/programmer_reference/program_copy.html),\n //! so bitcoin should never create different databases with the same fileid, but\n //! this error can be triggered if users manually copy database files.\n-void CheckUniqueFileid(const CDBEnv& env, const std::string& filename, Db& db)\n+void CheckUniqueFileid(const BerkeleyEnvironment& env, const std::string& filename, Db& db)\n {\n     if (env.IsMock()) return;\n \n     u_int8_t fileid[DB_FILE_ID_LEN];\n     int ret = db.get_mpf()->get_fileid(fileid);\n     if (ret != 0) {\n-        throw std::runtime_error(strprintf(\"CDB: Can't open database %s (get_fileid failed with %d)\", filename, ret));\n+        throw std::runtime_error(strprintf(\"BerkeleyBatch: Can't open database %s (get_fileid failed with %d)\", filename, ret));\n     }\n \n     for (const auto& item : env.mapDb) {\n@@ -46,18 +46,18 @@ void CheckUniqueFileid(const CDBEnv& env, const std::string& filename, Db& db)\n             memcmp(fileid, item_fileid, sizeof(fileid)) == 0) {\n             const char* item_filename = nullptr;\n             item.second->get_dbname(&item_filename, nullptr);\n-            throw std::runtime_error(strprintf(\"CDB: Can't open database %s (duplicates fileid %s from %s)\", filename,\n+            throw std::runtime_error(strprintf(\"BerkeleyBatch: Can't open database %s (duplicates fileid %s from %s)\", filename,\n                 HexStr(std::begin(item_fileid), std::end(item_fileid)),\n                 item_filename ? item_filename : \"(unknown database)\"));\n         }\n     }\n }\n \n CCriticalSection cs_db;\n-std::map<std::string, CDBEnv> g_dbenvs; //!< Map from directory name to open db environment.\n+std::map<std::string, BerkeleyEnvironment> g_dbenvs; //!< Map from directory name to open db environment.\n } // namespace\n \n-CDBEnv* GetWalletEnv(const fs::path& wallet_path, std::string& database_filename)\n+BerkeleyEnvironment* GetWalletEnv(const fs::path& wallet_path, std::string& database_filename)\n {\n     fs::path env_directory;\n     if (fs::is_regular_file(wallet_path)) {\n@@ -73,18 +73,18 @@ CDBEnv* GetWalletEnv(const fs::path& wallet_path, std::string& database_filename\n         database_filename = \"wallet.dat\";\n     }\n     LOCK(cs_db);\n-    // Note: An ununsed temporary CDBEnv object may be created inside the\n+    // Note: An ununsed temporary BerkeleyEnvironment object may be created inside the\n     // emplace function if the key already exists. This is a little inefficient,\n     // but not a big concern since the map will be changed in the future to hold\n     // pointers instead of objects, anyway.\n     return &g_dbenvs.emplace(std::piecewise_construct, std::forward_as_tuple(env_directory.string()), std::forward_as_tuple(env_directory)).first->second;\n }\n \n //\n-// CDB\n+// BerkeleyBatch\n //\n \n-void CDBEnv::Close()\n+void BerkeleyEnvironment::Close()\n {\n     if (!fDbEnvInit)\n         return;\n@@ -103,29 +103,29 @@ void CDBEnv::Close()\n \n     int ret = dbenv->close(0);\n     if (ret != 0)\n-        LogPrintf(\"CDBEnv::EnvShutdown: Error %d shutting down database environment: %s\\n\", ret, DbEnv::strerror(ret));\n+        LogPrintf(\"BerkeleyEnvironment::EnvShutdown: Error %d shutting down database environment: %s\\n\", ret, DbEnv::strerror(ret));\n     if (!fMockDb)\n         DbEnv((u_int32_t)0).remove(strPath.c_str(), 0);\n }\n \n-void CDBEnv::Reset()\n+void BerkeleyEnvironment::Reset()\n {\n     dbenv.reset(new DbEnv(DB_CXX_NO_EXCEPTIONS));\n     fDbEnvInit = false;\n     fMockDb = false;\n }\n \n-CDBEnv::CDBEnv(const fs::path& dir_path) : strPath(dir_path.string())\n+BerkeleyEnvironment::BerkeleyEnvironment(const fs::path& dir_path) : strPath(dir_path.string())\n {\n     Reset();\n }\n \n-CDBEnv::~CDBEnv()\n+BerkeleyEnvironment::~BerkeleyEnvironment()\n {\n     Close();\n }\n \n-bool CDBEnv::Open(bool retry)\n+bool BerkeleyEnvironment::Open(bool retry)\n {\n     if (fDbEnvInit)\n         return true;\n@@ -142,7 +142,7 @@ bool CDBEnv::Open(bool retry)\n     fs::path pathLogDir = pathIn / \"database\";\n     TryCreateDirectories(pathLogDir);\n     fs::path pathErrorFile = pathIn / \"db.log\";\n-    LogPrintf(\"CDBEnv::Open: LogDir=%s ErrorFile=%s\\n\", pathLogDir.string(), pathErrorFile.string());\n+    LogPrintf(\"BerkeleyEnvironment::Open: LogDir=%s ErrorFile=%s\\n\", pathLogDir.string(), pathErrorFile.string());\n \n     unsigned int nEnvFlags = 0;\n     if (gArgs.GetBoolArg(\"-privdb\", DEFAULT_WALLET_PRIVDB))\n@@ -170,7 +170,7 @@ bool CDBEnv::Open(bool retry)\n                          S_IRUSR | S_IWUSR);\n     if (ret != 0) {\n         dbenv->close(0);\n-        LogPrintf(\"CDBEnv::Open: Error %d opening database environment: %s\\n\", ret, DbEnv::strerror(ret));\n+        LogPrintf(\"BerkeleyEnvironment::Open: Error %d opening database environment: %s\\n\", ret, DbEnv::strerror(ret));\n         if (retry) {\n             // try moving the database env out of the way\n             fs::path pathDatabaseBak = pathIn / strprintf(\"database.%d.bak\", GetTime());\n@@ -195,14 +195,14 @@ bool CDBEnv::Open(bool retry)\n     return true;\n }\n \n-void CDBEnv::MakeMock()\n+void BerkeleyEnvironment::MakeMock()\n {\n     if (fDbEnvInit)\n-        throw std::runtime_error(\"CDBEnv::MakeMock: Already initialized\");\n+        throw std::runtime_error(\"BerkeleyEnvironment::MakeMock: Already initialized\");\n \n     boost::this_thread::interruption_point();\n \n-    LogPrint(BCLog::DB, \"CDBEnv::MakeMock\\n\");\n+    LogPrint(BCLog::DB, \"BerkeleyEnvironment::MakeMock\\n\");\n \n     dbenv->set_cachesize(1, 0, 1);\n     dbenv->set_lg_bsize(10485760 * 4);\n@@ -221,13 +221,13 @@ void CDBEnv::MakeMock()\n                              DB_PRIVATE,\n                          S_IRUSR | S_IWUSR);\n     if (ret > 0)\n-        throw std::runtime_error(strprintf(\"CDBEnv::MakeMock: Error %d opening database environment.\", ret));\n+        throw std::runtime_error(strprintf(\"BerkeleyEnvironment::MakeMock: Error %d opening database environment.\", ret));\n \n     fDbEnvInit = true;\n     fMockDb = true;\n }\n \n-CDBEnv::VerifyResult CDBEnv::Verify(const std::string& strFile, recoverFunc_type recoverFunc, std::string& out_backup_filename)\n+BerkeleyEnvironment::VerifyResult BerkeleyEnvironment::Verify(const std::string& strFile, recoverFunc_type recoverFunc, std::string& out_backup_filename)\n {\n     LOCK(cs_db);\n     assert(mapFileUseCount.count(strFile) == 0);\n@@ -244,10 +244,10 @@ CDBEnv::VerifyResult CDBEnv::Verify(const std::string& strFile, recoverFunc_type\n     return (fRecovered ? VerifyResult::RECOVER_OK : VerifyResult::RECOVER_FAIL);\n }\n \n-bool CDB::Recover(const fs::path& file_path, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& newFilename)\n+bool BerkeleyBatch::Recover(const fs::path& file_path, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& newFilename)\n {\n     std::string filename;\n-    CDBEnv* env = GetWalletEnv(file_path, filename);\n+    BerkeleyEnvironment* env = GetWalletEnv(file_path, filename);\n \n     // Recovery procedure:\n     // move wallet file to walletfilename.timestamp.bak\n@@ -269,7 +269,7 @@ bool CDB::Recover(const fs::path& file_path, void *callbackDataIn, bool (*recove\n         return false;\n     }\n \n-    std::vector<CDBEnv::KeyValPair> salvagedData;\n+    std::vector<BerkeleyEnvironment::KeyValPair> salvagedData;\n     bool fSuccess = env->Salvage(newFilename, true, salvagedData);\n     if (salvagedData.empty())\n     {\n@@ -292,7 +292,7 @@ bool CDB::Recover(const fs::path& file_path, void *callbackDataIn, bool (*recove\n     }\n \n     DbTxn* ptxn = env->TxnBegin();\n-    for (CDBEnv::KeyValPair& row : salvagedData)\n+    for (BerkeleyEnvironment::KeyValPair& row : salvagedData)\n     {\n         if (recoverKVcallback)\n         {\n@@ -313,10 +313,10 @@ bool CDB::Recover(const fs::path& file_path, void *callbackDataIn, bool (*recove\n     return fSuccess;\n }\n \n-bool CDB::VerifyEnvironment(const fs::path& file_path, std::string& errorStr)\n+bool BerkeleyBatch::VerifyEnvironment(const fs::path& file_path, std::string& errorStr)\n {\n     std::string walletFile;\n-    CDBEnv* env = GetWalletEnv(file_path, walletFile);\n+    BerkeleyEnvironment* env = GetWalletEnv(file_path, walletFile);\n     fs::path walletDir = env->Directory();\n \n     LogPrintf(\"Using BerkeleyDB version %s\\n\", DbEnv::version(0, 0, 0));\n@@ -337,25 +337,25 @@ bool CDB::VerifyEnvironment(const fs::path& file_path, std::string& errorStr)\n     return true;\n }\n \n-bool CDB::VerifyDatabaseFile(const fs::path& file_path, std::string& warningStr, std::string& errorStr, CDBEnv::recoverFunc_type recoverFunc)\n+bool BerkeleyBatch::VerifyDatabaseFile(const fs::path& file_path, std::string& warningStr, std::string& errorStr, BerkeleyEnvironment::recoverFunc_type recoverFunc)\n {\n     std::string walletFile;\n-    CDBEnv* env = GetWalletEnv(file_path, walletFile);\n+    BerkeleyEnvironment* env = GetWalletEnv(file_path, walletFile);\n     fs::path walletDir = env->Directory();\n \n     if (fs::exists(walletDir / walletFile))\n     {\n         std::string backup_filename;\n-        CDBEnv::VerifyResult r = env->Verify(walletFile, recoverFunc, backup_filename);\n-        if (r == CDBEnv::VerifyResult::RECOVER_OK)\n+        BerkeleyEnvironment::VerifyResult r = env->Verify(walletFile, recoverFunc, backup_filename);\n+        if (r == BerkeleyEnvironment::VerifyResult::RECOVER_OK)\n         {\n             warningStr = strprintf(_(\"Warning: Wallet file corrupt, data salvaged!\"\n                                      \" Original %s saved as %s in %s; if\"\n                                      \" your balance or transactions are incorrect you should\"\n                                      \" restore from a backup.\"),\n                                    walletFile, backup_filename, walletDir);\n         }\n-        if (r == CDBEnv::VerifyResult::RECOVER_FAIL)\n+        if (r == BerkeleyEnvironment::VerifyResult::RECOVER_FAIL)\n         {\n             errorStr = strprintf(_(\"%s corrupt, salvage failed\"), walletFile);\n             return false;\n@@ -370,7 +370,7 @@ static const char *HEADER_END = \"HEADER=END\";\n /* End of key/value data */\n static const char *DATA_END = \"DATA=END\";\n \n-bool CDBEnv::Salvage(const std::string& strFile, bool fAggressive, std::vector<CDBEnv::KeyValPair>& vResult)\n+bool BerkeleyEnvironment::Salvage(const std::string& strFile, bool fAggressive, std::vector<BerkeleyEnvironment::KeyValPair>& vResult)\n {\n     LOCK(cs_db);\n     assert(mapFileUseCount.count(strFile) == 0);\n@@ -384,14 +384,14 @@ bool CDBEnv::Salvage(const std::string& strFile, bool fAggressive, std::vector<C\n     Db db(dbenv.get(), 0);\n     int result = db.verify(strFile.c_str(), nullptr, &strDump, flags);\n     if (result == DB_VERIFY_BAD) {\n-        LogPrintf(\"CDBEnv::Salvage: Database salvage found errors, all data may not be recoverable.\\n\");\n+        LogPrintf(\"BerkeleyEnvironment::Salvage: Database salvage found errors, all data may not be recoverable.\\n\");\n         if (!fAggressive) {\n-            LogPrintf(\"CDBEnv::Salvage: Rerun with aggressive mode to ignore errors and continue.\\n\");\n+            LogPrintf(\"BerkeleyEnvironment::Salvage: Rerun with aggressive mode to ignore errors and continue.\\n\");\n             return false;\n         }\n     }\n     if (result != 0 && result != DB_VERIFY_BAD) {\n-        LogPrintf(\"CDBEnv::Salvage: Database salvage failed with result %d.\\n\", result);\n+        LogPrintf(\"BerkeleyEnvironment::Salvage: Database salvage failed with result %d.\\n\", result);\n         return false;\n     }\n \n@@ -415,23 +415,23 @@ bool CDBEnv::Salvage(const std::string& strFile, bool fAggressive, std::vector<C\n                 break;\n             getline(strDump, valueHex);\n             if (valueHex == DATA_END) {\n-                LogPrintf(\"CDBEnv::Salvage: WARNING: Number of keys in data does not match number of values.\\n\");\n+                LogPrintf(\"BerkeleyEnvironment::Salvage: WARNING: Number of keys in data does not match number of values.\\n\");\n                 break;\n             }\n             vResult.push_back(make_pair(ParseHex(keyHex), ParseHex(valueHex)));\n         }\n     }\n \n     if (keyHex != DATA_END) {\n-        LogPrintf(\"CDBEnv::Salvage: WARNING: Unexpected end of file while reading salvage output.\\n\");\n+        LogPrintf(\"BerkeleyEnvironment::Salvage: WARNING: Unexpected end of file while reading salvage output.\\n\");\n         return false;\n     }\n \n     return (result == 0);\n }\n \n \n-void CDBEnv::CheckpointLSN(const std::string& strFile)\n+void BerkeleyEnvironment::CheckpointLSN(const std::string& strFile)\n {\n     dbenv->txn_checkpoint(0, 0, 0);\n     if (fMockDb)\n@@ -440,15 +440,15 @@ void CDBEnv::CheckpointLSN(const std::string& strFile)\n }\n \n \n-CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb(nullptr), activeTxn(nullptr)\n+BerkeleyBatch::BerkeleyBatch(BerkeleyDatabase& database, const char* pszMode, bool fFlushOnCloseIn) : pdb(nullptr), activeTxn(nullptr)\n {\n     fReadOnly = (!strchr(pszMode, '+') && !strchr(pszMode, 'w'));\n     fFlushOnClose = fFlushOnCloseIn;\n-    env = dbw.env;\n-    if (dbw.IsDummy()) {\n+    env = database.env;\n+    if (database.IsDummy()) {\n         return;\n     }\n-    const std::string &strFilename = dbw.strFile;\n+    const std::string &strFilename = database.strFile;\n \n     bool fCreate = strchr(pszMode, 'c') != nullptr;\n     unsigned int nFlags = DB_THREAD;\n@@ -458,7 +458,7 @@ CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb\n     {\n         LOCK(cs_db);\n         if (!env->Open(false /* retry */))\n-            throw std::runtime_error(\"CDB: Failed to open database environment.\");\n+            throw std::runtime_error(\"BerkeleyBatch: Failed to open database environment.\");\n \n         pdb = env->mapDb[strFilename];\n         if (pdb == nullptr) {\n@@ -470,7 +470,7 @@ CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb\n                 DbMpoolFile* mpf = pdb_temp->get_mpf();\n                 ret = mpf->set_flags(DB_MPOOL_NOFILE, 1);\n                 if (ret != 0) {\n-                    throw std::runtime_error(strprintf(\"CDB: Failed to configure for no temp file backing for database %s\", strFilename));\n+                    throw std::runtime_error(strprintf(\"BerkeleyBatch: Failed to configure for no temp file backing for database %s\", strFilename));\n                 }\n             }\n \n@@ -482,7 +482,7 @@ CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb\n                             0);\n \n             if (ret != 0) {\n-                throw std::runtime_error(strprintf(\"CDB: Error %d, can't open database %s\", ret, strFilename));\n+                throw std::runtime_error(strprintf(\"BerkeleyBatch: Error %d, can't open database %s\", ret, strFilename));\n             }\n \n             // Call CheckUniqueFileid on the containing BDB environment to\n@@ -519,7 +519,7 @@ CDB::CDB(CWalletDBWrapper& dbw, const char* pszMode, bool fFlushOnCloseIn) : pdb\n     }\n }\n \n-void CDB::Flush()\n+void BerkeleyBatch::Flush()\n {\n     if (activeTxn)\n         return;\n@@ -532,12 +532,12 @@ void CDB::Flush()\n     env->dbenv->txn_checkpoint(nMinutes ? gArgs.GetArg(\"-dblogsize\", DEFAULT_WALLET_DBLOGSIZE) * 1024 : 0, nMinutes, 0);\n }\n \n-void CWalletDBWrapper::IncrementUpdateCounter()\n+void BerkeleyDatabase::IncrementUpdateCounter()\n {\n     ++nUpdateCounter;\n }\n \n-void CDB::Close()\n+void BerkeleyBatch::Close()\n {\n     if (!pdb)\n         return;\n@@ -555,7 +555,7 @@ void CDB::Close()\n     }\n }\n \n-void CDBEnv::CloseDb(const std::string& strFile)\n+void BerkeleyEnvironment::CloseDb(const std::string& strFile)\n {\n     {\n         LOCK(cs_db);\n@@ -569,13 +569,13 @@ void CDBEnv::CloseDb(const std::string& strFile)\n     }\n }\n \n-bool CDB::Rewrite(CWalletDBWrapper& dbw, const char* pszSkip)\n+bool BerkeleyBatch::Rewrite(BerkeleyDatabase& database, const char* pszSkip)\n {\n-    if (dbw.IsDummy()) {\n+    if (database.IsDummy()) {\n         return true;\n     }\n-    CDBEnv *env = dbw.env;\n-    const std::string& strFile = dbw.strFile;\n+    BerkeleyEnvironment *env = database.env;\n+    const std::string& strFile = database.strFile;\n     while (true) {\n         {\n             LOCK(cs_db);\n@@ -586,10 +586,10 @@ bool CDB::Rewrite(CWalletDBWrapper& dbw, const char* pszSkip)\n                 env->mapFileUseCount.erase(strFile);\n \n                 bool fSuccess = true;\n-                LogPrintf(\"CDB::Rewrite: Rewriting %s...\\n\", strFile);\n+                LogPrintf(\"BerkeleyBatch::Rewrite: Rewriting %s...\\n\", strFile);\n                 std::string strFileRes = strFile + \".rewrite\";\n                 { // surround usage of db with extra {}\n-                    CDB db(dbw, \"r\");\n+                    BerkeleyBatch db(database, \"r\");\n                     std::unique_ptr<Db> pdbCopy = MakeUnique<Db>(env->dbenv.get(), 0);\n \n                     int ret = pdbCopy->open(nullptr,               // Txn pointer\n@@ -599,7 +599,7 @@ bool CDB::Rewrite(CWalletDBWrapper& dbw, const char* pszSkip)\n                                             DB_CREATE,          // Flags\n                                             0);\n                     if (ret > 0) {\n-                        LogPrintf(\"CDB::Rewrite: Can't create database file %s\\n\", strFileRes);\n+                        LogPrintf(\"BerkeleyBatch::Rewrite: Can't create database file %s\\n\", strFileRes);\n                         fSuccess = false;\n                     }\n \n@@ -649,7 +649,7 @@ bool CDB::Rewrite(CWalletDBWrapper& dbw, const char* pszSkip)\n                         fSuccess = false;\n                 }\n                 if (!fSuccess)\n-                    LogPrintf(\"CDB::Rewrite: Failed to rewrite database file %s\\n\", strFileRes);\n+                    LogPrintf(\"BerkeleyBatch::Rewrite: Failed to rewrite database file %s\\n\", strFileRes);\n                 return fSuccess;\n             }\n         }\n@@ -658,11 +658,11 @@ bool CDB::Rewrite(CWalletDBWrapper& dbw, const char* pszSkip)\n }\n \n \n-void CDBEnv::Flush(bool fShutdown)\n+void BerkeleyEnvironment::Flush(bool fShutdown)\n {\n     int64_t nStart = GetTimeMillis();\n     // Flush log data to the actual data file on all files that are not in use\n-    LogPrint(BCLog::DB, \"CDBEnv::Flush: Flush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\");\n+    LogPrint(BCLog::DB, \"BerkeleyEnvironment::Flush: Flush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\");\n     if (!fDbEnvInit)\n         return;\n     {\n@@ -671,21 +671,21 @@ void CDBEnv::Flush(bool fShutdown)\n         while (mi != mapFileUseCount.end()) {\n             std::string strFile = (*mi).first;\n             int nRefCount = (*mi).second;\n-            LogPrint(BCLog::DB, \"CDBEnv::Flush: Flushing %s (refcount = %d)...\\n\", strFile, nRefCount);\n+            LogPrint(BCLog::DB, \"BerkeleyEnvironment::Flush: Flushing %s (refcount = %d)...\\n\", strFile, nRefCount);\n             if (nRefCount == 0) {\n                 // Move log data to the dat file\n                 CloseDb(strFile);\n-                LogPrint(BCLog::DB, \"CDBEnv::Flush: %s checkpoint\\n\", strFile);\n+                LogPrint(BCLog::DB, \"BerkeleyEnvironment::Flush: %s checkpoint\\n\", strFile);\n                 dbenv->txn_checkpoint(0, 0, 0);\n-                LogPrint(BCLog::DB, \"CDBEnv::Flush: %s detach\\n\", strFile);\n+                LogPrint(BCLog::DB, \"BerkeleyEnvironment::Flush: %s detach\\n\", strFile);\n                 if (!fMockDb)\n                     dbenv->lsn_reset(strFile.c_str(), 0);\n-                LogPrint(BCLog::DB, \"CDBEnv::Flush: %s closed\\n\", strFile);\n+                LogPrint(BCLog::DB, \"BerkeleyEnvironment::Flush: %s closed\\n\", strFile);\n                 mapFileUseCount.erase(mi++);\n             } else\n                 mi++;\n         }\n-        LogPrint(BCLog::DB, \"CDBEnv::Flush: Flush(%s)%s took %15dms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\", GetTimeMillis() - nStart);\n+        LogPrint(BCLog::DB, \"BerkeleyEnvironment::Flush: Flush(%s)%s took %15dms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\", GetTimeMillis() - nStart);\n         if (fShutdown) {\n             char** listp;\n             if (mapFileUseCount.empty()) {\n@@ -698,14 +698,14 @@ void CDBEnv::Flush(bool fShutdown)\n     }\n }\n \n-bool CDB::PeriodicFlush(CWalletDBWrapper& dbw)\n+bool BerkeleyBatch::PeriodicFlush(BerkeleyDatabase& database)\n {\n-    if (dbw.IsDummy()) {\n+    if (database.IsDummy()) {\n         return true;\n     }\n     bool ret = false;\n-    CDBEnv *env = dbw.env;\n-    const std::string& strFile = dbw.strFile;\n+    BerkeleyEnvironment *env = database.env;\n+    const std::string& strFile = database.strFile;\n     TRY_LOCK(cs_db, lockDb);\n     if (lockDb)\n     {\n@@ -741,12 +741,12 @@ bool CDB::PeriodicFlush(CWalletDBWrapper& dbw)\n     return ret;\n }\n \n-bool CWalletDBWrapper::Rewrite(const char* pszSkip)\n+bool BerkeleyDatabase::Rewrite(const char* pszSkip)\n {\n-    return CDB::Rewrite(*this, pszSkip);\n+    return BerkeleyBatch::Rewrite(*this, pszSkip);\n }\n \n-bool CWalletDBWrapper::Backup(const std::string& strDest)\n+bool BerkeleyDatabase::Backup(const std::string& strDest)\n {\n     if (IsDummy()) {\n         return false;\n@@ -787,7 +787,7 @@ bool CWalletDBWrapper::Backup(const std::string& strDest)\n     }\n }\n \n-void CWalletDBWrapper::Flush(bool shutdown)\n+void BerkeleyDatabase::Flush(bool shutdown)\n {\n     if (!IsDummy()) {\n         env->Flush(shutdown);"
      },
      {
        "sha": "5e61280f7a7ba690c239259b420f5a8962f7b64e",
        "filename": "src/wallet/db.h",
        "status": "modified",
        "additions": 25,
        "deletions": 25,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/db.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/db.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.h?ref=ea23945dbc6ad239c5acac374d2b54aa12870838",
        "patch": "@@ -25,7 +25,7 @@\n static const unsigned int DEFAULT_WALLET_DBLOGSIZE = 100;\n static const bool DEFAULT_WALLET_PRIVDB = true;\n \n-class CDBEnv\n+class BerkeleyEnvironment\n {\n private:\n     bool fDbEnvInit;\n@@ -39,8 +39,8 @@ class CDBEnv\n     std::map<std::string, int> mapFileUseCount;\n     std::map<std::string, Db*> mapDb;\n \n-    CDBEnv(const fs::path& env_directory);\n-    ~CDBEnv();\n+    BerkeleyEnvironment(const fs::path& env_directory);\n+    ~BerkeleyEnvironment();\n     void Reset();\n \n     void MakeMock();\n@@ -86,23 +86,23 @@ class CDBEnv\n     }\n };\n \n-/** Get CDBEnv and database filename given a wallet path. */\n-CDBEnv* GetWalletEnv(const fs::path& wallet_path, std::string& database_filename);\n+/** Get BerkeleyEnvironment and database filename given a wallet path. */\n+BerkeleyEnvironment* GetWalletEnv(const fs::path& wallet_path, std::string& database_filename);\n \n /** An instance of this class represents one database.\n  * For BerkeleyDB this is just a (env, strFile) tuple.\n  **/\n-class CWalletDBWrapper\n+class BerkeleyDatabase\n {\n-    friend class CDB;\n+    friend class BerkeleyBatch;\n public:\n     /** Create dummy DB handle */\n-    CWalletDBWrapper() : nUpdateCounter(0), nLastSeen(0), nLastFlushed(0), nLastWalletUpdate(0), env(nullptr)\n+    BerkeleyDatabase() : nUpdateCounter(0), nLastSeen(0), nLastFlushed(0), nLastWalletUpdate(0), env(nullptr)\n     {\n     }\n \n     /** Create DB handle to real database */\n-    CWalletDBWrapper(const fs::path& wallet_path, bool mock = false) :\n+    BerkeleyDatabase(const fs::path& wallet_path, bool mock = false) :\n         nUpdateCounter(0), nLastSeen(0), nLastFlushed(0), nLastWalletUpdate(0)\n     {\n         env = GetWalletEnv(wallet_path, strFile);\n@@ -114,21 +114,21 @@ class CWalletDBWrapper\n     }\n \n     /** Return object for accessing database at specified path. */\n-    static std::unique_ptr<CWalletDBWrapper> Create(const fs::path& path)\n+    static std::unique_ptr<BerkeleyDatabase> Create(const fs::path& path)\n     {\n-        return MakeUnique<CWalletDBWrapper>(path);\n+        return MakeUnique<BerkeleyDatabase>(path);\n     }\n \n     /** Return object for accessing dummy database with no read/write capabilities. */\n-    static std::unique_ptr<CWalletDBWrapper> CreateDummy()\n+    static std::unique_ptr<BerkeleyDatabase> CreateDummy()\n     {\n-        return MakeUnique<CWalletDBWrapper>();\n+        return MakeUnique<BerkeleyDatabase>();\n     }\n \n     /** Return object for accessing temporary in-memory database. */\n-    static std::unique_ptr<CWalletDBWrapper> CreateMock()\n+    static std::unique_ptr<BerkeleyDatabase> CreateMock()\n     {\n-        return MakeUnique<CWalletDBWrapper>(\"\", true /* mock */);\n+        return MakeUnique<BerkeleyDatabase>(\"\", true /* mock */);\n     }\n \n     /** Rewrite the entire database on disk, with the exception of key pszSkip if non-zero\n@@ -152,7 +152,7 @@ class CWalletDBWrapper\n \n private:\n     /** BerkeleyDB specific */\n-    CDBEnv *env;\n+    BerkeleyEnvironment *env;\n     std::string strFile;\n \n     /** Return whether this database handle is a dummy for testing.\n@@ -164,34 +164,34 @@ class CWalletDBWrapper\n \n \n /** RAII class that provides access to a Berkeley database */\n-class CDB\n+class BerkeleyBatch\n {\n protected:\n     Db* pdb;\n     std::string strFile;\n     DbTxn* activeTxn;\n     bool fReadOnly;\n     bool fFlushOnClose;\n-    CDBEnv *env;\n+    BerkeleyEnvironment *env;\n \n public:\n-    explicit CDB(CWalletDBWrapper& dbw, const char* pszMode = \"r+\", bool fFlushOnCloseIn=true);\n-    ~CDB() { Close(); }\n+    explicit BerkeleyBatch(BerkeleyDatabase& database, const char* pszMode = \"r+\", bool fFlushOnCloseIn=true);\n+    ~BerkeleyBatch() { Close(); }\n \n-    CDB(const CDB&) = delete;\n-    CDB& operator=(const CDB&) = delete;\n+    BerkeleyBatch(const BerkeleyBatch&) = delete;\n+    BerkeleyBatch& operator=(const BerkeleyBatch&) = delete;\n \n     void Flush();\n     void Close();\n     static bool Recover(const fs::path& file_path, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& out_backup_filename);\n \n     /* flush the wallet passively (TRY_LOCK)\n        ideal to be called periodically */\n-    static bool PeriodicFlush(CWalletDBWrapper& dbw);\n+    static bool PeriodicFlush(BerkeleyDatabase& database);\n     /* verifies the database environment */\n     static bool VerifyEnvironment(const fs::path& file_path, std::string& errorStr);\n     /* verifies the database file */\n-    static bool VerifyDatabaseFile(const fs::path& file_path, std::string& warningStr, std::string& errorStr, CDBEnv::recoverFunc_type recoverFunc);\n+    static bool VerifyDatabaseFile(const fs::path& file_path, std::string& warningStr, std::string& errorStr, BerkeleyEnvironment::recoverFunc_type recoverFunc);\n \n public:\n     template <typename K, typename T>\n@@ -387,7 +387,7 @@ class CDB\n         return Write(std::string(\"version\"), nVersion);\n     }\n \n-    bool static Rewrite(CWalletDBWrapper& dbw, const char* pszSkip = nullptr);\n+    bool static Rewrite(BerkeleyDatabase& database, const char* pszSkip = nullptr);\n };\n \n #endif // BITCOIN_WALLET_DB_H"
      },
      {
        "sha": "b6f4a0e1e1185d14faaa156c04419c237997c0f4",
        "filename": "src/wallet/init.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/init.cpp?ref=ea23945dbc6ad239c5acac374d2b54aa12870838",
        "patch": "@@ -277,21 +277,21 @@ bool WalletInit::Verify()\n         }\n \n         std::string strError;\n-        if (!CWalletDB::VerifyEnvironment(wallet_path, strError)) {\n+        if (!WalletBatch::VerifyEnvironment(wallet_path, strError)) {\n             return InitError(strError);\n         }\n \n         if (gArgs.GetBoolArg(\"-salvagewallet\", false)) {\n             // Recover readable keypairs:\n-            CWallet dummyWallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n+            CWallet dummyWallet(\"dummy\", WalletDatabase::CreateDummy());\n             std::string backup_filename;\n-            if (!CWalletDB::Recover(wallet_path, (void *)&dummyWallet, CWalletDB::RecoverKeysOnlyFilter, backup_filename)) {\n+            if (!WalletBatch::Recover(wallet_path, (void *)&dummyWallet, WalletBatch::RecoverKeysOnlyFilter, backup_filename)) {\n                 return false;\n             }\n         }\n \n         std::string strWarning;\n-        bool dbV = CWalletDB::VerifyDatabaseFile(wallet_path, strWarning, strError);\n+        bool dbV = WalletBatch::VerifyDatabaseFile(wallet_path, strWarning, strError);\n         if (!strWarning.empty()) {\n             InitWarning(strWarning);\n         }"
      },
      {
        "sha": "ac47d4448a9a73a09b41c1221b1e5d23696a64e2",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=ea23945dbc6ad239c5acac374d2b54aa12870838",
        "patch": "@@ -28,7 +28,7 @@ std::vector<std::unique_ptr<CWalletTx>> wtxn;\n typedef std::set<CInputCoin> CoinSet;\n \n static std::vector<COutput> vCoins;\n-static CWallet testWallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n+static CWallet testWallet(\"dummy\", WalletDatabase::CreateDummy());\n static CAmount balance = 0;\n \n CoinEligibilityFilter filter_standard(1, 6, 0);"
      },
      {
        "sha": "35a133ca072d6e8877f0314aee080e64a09ac183",
        "filename": "src/wallet/test/wallet_test_fixture.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/test/wallet_test_fixture.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/test/wallet_test_fixture.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_test_fixture.cpp?ref=ea23945dbc6ad239c5acac374d2b54aa12870838",
        "patch": "@@ -9,7 +9,7 @@\n #include <wallet/wallet.h>\n \n WalletTestingSetup::WalletTestingSetup(const std::string& chainName):\n-    TestingSetup(chainName), m_wallet(\"mock\", CWalletDBWrapper::CreateMock())\n+    TestingSetup(chainName), m_wallet(\"mock\", WalletDatabase::CreateMock())\n {\n     bool fFirstRun;\n     m_wallet.LoadWallet(fFirstRun);"
      },
      {
        "sha": "727c6caf96f06d863669836f921bb76c65ad4c13",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=ea23945dbc6ad239c5acac374d2b54aa12870838",
        "patch": "@@ -46,7 +46,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n     // Verify ScanForWalletTransactions picks up transactions in both the old\n     // and new block files.\n     {\n-        CWallet wallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n+        CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n         AddKey(wallet, coinbaseKey);\n         WalletRescanReserver reserver(&wallet);\n         reserver.reserve();\n@@ -61,7 +61,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n     // Verify ScanForWalletTransactions only picks transactions in the new block\n     // file.\n     {\n-        CWallet wallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n+        CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n         AddKey(wallet, coinbaseKey);\n         WalletRescanReserver reserver(&wallet);\n         reserver.reserve();\n@@ -73,7 +73,7 @@ BOOST_FIXTURE_TEST_CASE(rescan, TestChain100Setup)\n     // before the missing block, and success for a key whose creation time is\n     // after.\n     {\n-        CWallet wallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n+        CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n         vpwallets.insert(vpwallets.begin(), &wallet);\n         UniValue keys;\n         keys.setArray();\n@@ -132,7 +132,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n \n     // Import key into wallet and call dumpwallet to create backup file.\n     {\n-        CWallet wallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n+        CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n         LOCK(wallet.cs_wallet);\n         wallet.mapKeyMetadata[coinbaseKey.GetPubKey().GetID()].nCreateTime = KEY_TIME;\n         wallet.AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey());\n@@ -147,7 +147,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n     // Call importwallet RPC and verify all blocks with timestamps >= BLOCK_TIME\n     // were scanned, and no prior blocks were scanned.\n     {\n-        CWallet wallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n+        CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n \n         JSONRPCRequest request;\n         request.params.setArray();\n@@ -177,7 +177,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n // debit functions.\n BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n {\n-    CWallet wallet(\"dummy\", CWalletDBWrapper::CreateDummy());\n+    CWallet wallet(\"dummy\", WalletDatabase::CreateDummy());\n     CWalletTx wtx(&wallet, MakeTransactionRef(coinbaseTxns.back()));\n     LOCK2(cs_main, wallet.cs_wallet);\n     wtx.hashBlock = chainActive.Tip()->GetBlockHash();\n@@ -270,7 +270,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n     ListCoinsTestingSetup()\n     {\n         CreateAndProcessBlock({}, GetScriptForRawPubKey(coinbaseKey.GetPubKey()));\n-        wallet = MakeUnique<CWallet>(\"mock\", CWalletDBWrapper::CreateMock());\n+        wallet = MakeUnique<CWallet>(\"mock\", WalletDatabase::CreateMock());\n         bool firstRun;\n         wallet->LoadWallet(firstRun);\n         AddKey(*wallet, coinbaseKey);"
      },
      {
        "sha": "f722d852af2596633b43f8bb8c22857cc9b3fc51",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 122,
        "deletions": 122,
        "changes": 244,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=ea23945dbc6ad239c5acac374d2b54aa12870838",
        "patch": "@@ -131,7 +131,7 @@ const CWalletTx* CWallet::GetWalletTx(const uint256& hash) const\n     return &(it->second);\n }\n \n-CPubKey CWallet::GenerateNewKey(CWalletDB &walletdb, bool internal)\n+CPubKey CWallet::GenerateNewKey(WalletBatch &batch, bool internal)\n {\n     AssertLockHeld(cs_wallet); // mapKeyMetadata\n     bool fCompressed = CanSupportFeature(FEATURE_COMPRPUBKEY); // default to compressed public keys if we want 0.6.0 wallets\n@@ -144,7 +144,7 @@ CPubKey CWallet::GenerateNewKey(CWalletDB &walletdb, bool internal)\n \n     // use HD key derivation if HD was enabled during wallet creation\n     if (IsHDEnabled()) {\n-        DeriveNewChildKey(walletdb, metadata, secret, (CanSupportFeature(FEATURE_HD_SPLIT) ? internal : false));\n+        DeriveNewChildKey(batch, metadata, secret, (CanSupportFeature(FEATURE_HD_SPLIT) ? internal : false));\n     } else {\n         secret.MakeNewKey(fCompressed);\n     }\n@@ -160,13 +160,13 @@ CPubKey CWallet::GenerateNewKey(CWalletDB &walletdb, bool internal)\n     mapKeyMetadata[pubkey.GetID()] = metadata;\n     UpdateTimeFirstKey(nCreationTime);\n \n-    if (!AddKeyPubKeyWithDB(walletdb, secret, pubkey)) {\n+    if (!AddKeyPubKeyWithDB(batch, secret, pubkey)) {\n         throw std::runtime_error(std::string(__func__) + \": AddKey failed\");\n     }\n     return pubkey;\n }\n \n-void CWallet::DeriveNewChildKey(CWalletDB &walletdb, CKeyMetadata& metadata, CKey& secret, bool internal)\n+void CWallet::DeriveNewChildKey(WalletBatch &batch, CKeyMetadata& metadata, CKey& secret, bool internal)\n {\n     // for now we use a fixed keypath scheme of m/0'/0'/k\n     CKey key;                      //master key seed (256bit)\n@@ -208,26 +208,26 @@ void CWallet::DeriveNewChildKey(CWalletDB &walletdb, CKeyMetadata& metadata, CKe\n     secret = childKey.key;\n     metadata.hdMasterKeyID = hdChain.masterKeyID;\n     // update the chain model in the database\n-    if (!walletdb.WriteHDChain(hdChain))\n+    if (!batch.WriteHDChain(hdChain))\n         throw std::runtime_error(std::string(__func__) + \": Writing HD chain model failed\");\n }\n \n-bool CWallet::AddKeyPubKeyWithDB(CWalletDB &walletdb, const CKey& secret, const CPubKey &pubkey)\n+bool CWallet::AddKeyPubKeyWithDB(WalletBatch &batch, const CKey& secret, const CPubKey &pubkey)\n {\n     AssertLockHeld(cs_wallet); // mapKeyMetadata\n \n     // CCryptoKeyStore has no concept of wallet databases, but calls AddCryptedKey\n     // which is overridden below.  To avoid flushes, the database handle is\n     // tunneled through to it.\n-    bool needsDB = !pwalletdbEncryption;\n+    bool needsDB = !encrypted_batch;\n     if (needsDB) {\n-        pwalletdbEncryption = &walletdb;\n+        encrypted_batch = &batch;\n     }\n     if (!CCryptoKeyStore::AddKeyPubKey(secret, pubkey)) {\n-        if (needsDB) pwalletdbEncryption = nullptr;\n+        if (needsDB) encrypted_batch = nullptr;\n         return false;\n     }\n-    if (needsDB) pwalletdbEncryption = nullptr;\n+    if (needsDB) encrypted_batch = nullptr;\n \n     // check if we need to remove from watch-only\n     CScript script;\n@@ -241,7 +241,7 @@ bool CWallet::AddKeyPubKeyWithDB(CWalletDB &walletdb, const CKey& secret, const\n     }\n \n     if (!IsCrypted()) {\n-        return walletdb.WriteKey(pubkey,\n+        return batch.WriteKey(pubkey,\n                                                  secret.GetPrivKey(),\n                                                  mapKeyMetadata[pubkey.GetID()]);\n     }\n@@ -250,8 +250,8 @@ bool CWallet::AddKeyPubKeyWithDB(CWalletDB &walletdb, const CKey& secret, const\n \n bool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n {\n-    CWalletDB walletdb(*dbw);\n-    return CWallet::AddKeyPubKeyWithDB(walletdb, secret, pubkey);\n+    WalletBatch batch(*database);\n+    return CWallet::AddKeyPubKeyWithDB(batch, secret, pubkey);\n }\n \n bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n@@ -261,12 +261,12 @@ bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n         return false;\n     {\n         LOCK(cs_wallet);\n-        if (pwalletdbEncryption)\n-            return pwalletdbEncryption->WriteCryptedKey(vchPubKey,\n+        if (encrypted_batch)\n+            return encrypted_batch->WriteCryptedKey(vchPubKey,\n                                                         vchCryptedSecret,\n                                                         mapKeyMetadata[vchPubKey.GetID()]);\n         else\n-            return CWalletDB(*dbw).WriteCryptedKey(vchPubKey,\n+            return WalletBatch(*database).WriteCryptedKey(vchPubKey,\n                                                             vchCryptedSecret,\n                                                             mapKeyMetadata[vchPubKey.GetID()]);\n     }\n@@ -313,7 +313,7 @@ bool CWallet::AddCScript(const CScript& redeemScript)\n {\n     if (!CCryptoKeyStore::AddCScript(redeemScript))\n         return false;\n-    return CWalletDB(*dbw).WriteCScript(Hash160(redeemScript), redeemScript);\n+    return WalletBatch(*database).WriteCScript(Hash160(redeemScript), redeemScript);\n }\n \n bool CWallet::LoadCScript(const CScript& redeemScript)\n@@ -339,7 +339,7 @@ bool CWallet::AddWatchOnly(const CScript& dest)\n     const CKeyMetadata& meta = m_script_metadata[CScriptID(dest)];\n     UpdateTimeFirstKey(meta.nCreateTime);\n     NotifyWatchonlyChanged(true);\n-    return CWalletDB(*dbw).WriteWatchOnly(dest, meta);\n+    return WalletBatch(*database).WriteWatchOnly(dest, meta);\n }\n \n bool CWallet::AddWatchOnly(const CScript& dest, int64_t nCreateTime)\n@@ -355,7 +355,7 @@ bool CWallet::RemoveWatchOnly(const CScript &dest)\n         return false;\n     if (!HaveWatchOnly())\n         NotifyWatchonlyChanged(false);\n-    if (!CWalletDB(*dbw).EraseWatchOnly(dest))\n+    if (!WalletBatch(*database).EraseWatchOnly(dest))\n         return false;\n \n     return true;\n@@ -421,7 +421,7 @@ bool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase,\n                     return false;\n                 if (!crypter.Encrypt(_vMasterKey, pMasterKey.second.vchCryptedKey))\n                     return false;\n-                CWalletDB(*dbw).WriteMasterKey(pMasterKey.first, pMasterKey.second);\n+                WalletBatch(*database).WriteMasterKey(pMasterKey.first, pMasterKey.second);\n                 if (fWasLocked)\n                     Lock();\n                 return true;\n@@ -434,11 +434,11 @@ bool CWallet::ChangeWalletPassphrase(const SecureString& strOldWalletPassphrase,\n \n void CWallet::SetBestChain(const CBlockLocator& loc)\n {\n-    CWalletDB walletdb(*dbw);\n-    walletdb.WriteBestBlock(loc);\n+    WalletBatch batch(*database);\n+    batch.WriteBestBlock(loc);\n }\n \n-bool CWallet::SetMinVersion(enum WalletFeature nVersion, CWalletDB* pwalletdbIn, bool fExplicit)\n+bool CWallet::SetMinVersion(enum WalletFeature nVersion, WalletBatch* batch_in, bool fExplicit)\n {\n     LOCK(cs_wallet); // nWalletVersion\n     if (nWalletVersion >= nVersion)\n@@ -454,11 +454,11 @@ bool CWallet::SetMinVersion(enum WalletFeature nVersion, CWalletDB* pwalletdbIn,\n         nWalletMaxVersion = nVersion;\n \n     {\n-        CWalletDB* pwalletdb = pwalletdbIn ? pwalletdbIn : new CWalletDB(*dbw);\n+        WalletBatch* batch = batch_in ? batch_in : new WalletBatch(*database);\n         if (nWalletVersion > 40000)\n-            pwalletdb->WriteMinVersion(nWalletVersion);\n-        if (!pwalletdbIn)\n-            delete pwalletdb;\n+            batch->WriteMinVersion(nWalletVersion);\n+        if (!batch_in)\n+            delete batch;\n     }\n \n     return true;\n@@ -508,7 +508,7 @@ bool CWallet::HasWalletSpend(const uint256& txid) const\n \n void CWallet::Flush(bool shutdown)\n {\n-    dbw->Flush(shutdown);\n+    database->Flush(shutdown);\n }\n \n void CWallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> range)\n@@ -631,36 +631,36 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n     {\n         LOCK(cs_wallet);\n         mapMasterKeys[++nMasterKeyMaxID] = kMasterKey;\n-        assert(!pwalletdbEncryption);\n-        pwalletdbEncryption = new CWalletDB(*dbw);\n-        if (!pwalletdbEncryption->TxnBegin()) {\n-            delete pwalletdbEncryption;\n-            pwalletdbEncryption = nullptr;\n+        assert(!encrypted_batch);\n+        encrypted_batch = new WalletBatch(*database);\n+        if (!encrypted_batch->TxnBegin()) {\n+            delete encrypted_batch;\n+            encrypted_batch = nullptr;\n             return false;\n         }\n-        pwalletdbEncryption->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n+        encrypted_batch->WriteMasterKey(nMasterKeyMaxID, kMasterKey);\n \n         if (!EncryptKeys(_vMasterKey))\n         {\n-            pwalletdbEncryption->TxnAbort();\n-            delete pwalletdbEncryption;\n+            encrypted_batch->TxnAbort();\n+            delete encrypted_batch;\n             // We now probably have half of our keys encrypted in memory, and half not...\n             // die and let the user reload the unencrypted wallet.\n             assert(false);\n         }\n \n         // Encryption was introduced in version 0.4.0\n-        SetMinVersion(FEATURE_WALLETCRYPT, pwalletdbEncryption, true);\n+        SetMinVersion(FEATURE_WALLETCRYPT, encrypted_batch, true);\n \n-        if (!pwalletdbEncryption->TxnCommit()) {\n-            delete pwalletdbEncryption;\n+        if (!encrypted_batch->TxnCommit()) {\n+            delete encrypted_batch;\n             // We now have keys encrypted in memory, but not on disk...\n             // die to avoid confusion and let the user reload the unencrypted wallet.\n             assert(false);\n         }\n \n-        delete pwalletdbEncryption;\n-        pwalletdbEncryption = nullptr;\n+        delete encrypted_batch;\n+        encrypted_batch = nullptr;\n \n         Lock();\n         Unlock(strWalletPassphrase);\n@@ -677,7 +677,7 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n \n         // Need to completely rewrite the wallet file; if we don't, bdb might keep\n         // bits of the unencrypted private key in slack space in the database file.\n-        dbw->Rewrite();\n+        database->Rewrite();\n \n     }\n     NotifyStatusChanged(this);\n@@ -688,7 +688,7 @@ bool CWallet::EncryptWallet(const SecureString& strWalletPassphrase)\n DBErrors CWallet::ReorderTransactions()\n {\n     LOCK(cs_wallet);\n-    CWalletDB walletdb(*dbw);\n+    WalletBatch batch(*database);\n \n     // Old wallets didn't have any defined order for transactions\n     // Probably a bad idea to change the output of this\n@@ -704,7 +704,7 @@ DBErrors CWallet::ReorderTransactions()\n         txByTime.insert(std::make_pair(wtx->nTimeReceived, TxPair(wtx, nullptr)));\n     }\n     std::list<CAccountingEntry> acentries;\n-    walletdb.ListAccountCreditDebit(\"\", acentries);\n+    batch.ListAccountCreditDebit(\"\", acentries);\n     for (CAccountingEntry& entry : acentries)\n     {\n         txByTime.insert(std::make_pair(entry.nTime, TxPair(nullptr, &entry)));\n@@ -725,11 +725,11 @@ DBErrors CWallet::ReorderTransactions()\n \n             if (pwtx)\n             {\n-                if (!walletdb.WriteTx(*pwtx))\n+                if (!batch.WriteTx(*pwtx))\n                     return DBErrors::LOAD_FAIL;\n             }\n             else\n-                if (!walletdb.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n+                if (!batch.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n                     return DBErrors::LOAD_FAIL;\n         }\n         else\n@@ -749,71 +749,71 @@ DBErrors CWallet::ReorderTransactions()\n             // Since we're changing the order, write it back\n             if (pwtx)\n             {\n-                if (!walletdb.WriteTx(*pwtx))\n+                if (!batch.WriteTx(*pwtx))\n                     return DBErrors::LOAD_FAIL;\n             }\n             else\n-                if (!walletdb.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n+                if (!batch.WriteAccountingEntry(pacentry->nEntryNo, *pacentry))\n                     return DBErrors::LOAD_FAIL;\n         }\n     }\n-    walletdb.WriteOrderPosNext(nOrderPosNext);\n+    batch.WriteOrderPosNext(nOrderPosNext);\n \n     return DBErrors::LOAD_OK;\n }\n \n-int64_t CWallet::IncOrderPosNext(CWalletDB *pwalletdb)\n+int64_t CWallet::IncOrderPosNext(WalletBatch *batch)\n {\n     AssertLockHeld(cs_wallet); // nOrderPosNext\n     int64_t nRet = nOrderPosNext++;\n-    if (pwalletdb) {\n-        pwalletdb->WriteOrderPosNext(nOrderPosNext);\n+    if (batch) {\n+        batch->WriteOrderPosNext(nOrderPosNext);\n     } else {\n-        CWalletDB(*dbw).WriteOrderPosNext(nOrderPosNext);\n+        WalletBatch(*database).WriteOrderPosNext(nOrderPosNext);\n     }\n     return nRet;\n }\n \n bool CWallet::AccountMove(std::string strFrom, std::string strTo, CAmount nAmount, std::string strComment)\n {\n-    CWalletDB walletdb(*dbw);\n-    if (!walletdb.TxnBegin())\n+    WalletBatch batch(*database);\n+    if (!batch.TxnBegin())\n         return false;\n \n     int64_t nNow = GetAdjustedTime();\n \n     // Debit\n     CAccountingEntry debit;\n-    debit.nOrderPos = IncOrderPosNext(&walletdb);\n+    debit.nOrderPos = IncOrderPosNext(&batch);\n     debit.strAccount = strFrom;\n     debit.nCreditDebit = -nAmount;\n     debit.nTime = nNow;\n     debit.strOtherAccount = strTo;\n     debit.strComment = strComment;\n-    AddAccountingEntry(debit, &walletdb);\n+    AddAccountingEntry(debit, &batch);\n \n     // Credit\n     CAccountingEntry credit;\n-    credit.nOrderPos = IncOrderPosNext(&walletdb);\n+    credit.nOrderPos = IncOrderPosNext(&batch);\n     credit.strAccount = strTo;\n     credit.nCreditDebit = nAmount;\n     credit.nTime = nNow;\n     credit.strOtherAccount = strFrom;\n     credit.strComment = strComment;\n-    AddAccountingEntry(credit, &walletdb);\n+    AddAccountingEntry(credit, &batch);\n \n-    if (!walletdb.TxnCommit())\n+    if (!batch.TxnCommit())\n         return false;\n \n     return true;\n }\n \n bool CWallet::GetLabelDestination(CTxDestination &dest, const std::string& label, bool bForceNew)\n {\n-    CWalletDB walletdb(*dbw);\n+    WalletBatch batch(*database);\n \n     CAccount account;\n-    walletdb.ReadAccount(label, account);\n+    batch.ReadAccount(label, account);\n \n     if (!bForceNew) {\n         if (!account.vchPubKey.IsValid())\n@@ -840,7 +840,7 @@ bool CWallet::GetLabelDestination(CTxDestination &dest, const std::string& label\n         LearnRelatedScripts(account.vchPubKey, m_default_address_type);\n         dest = GetDestinationForKey(account.vchPubKey, m_default_address_type);\n         SetAddressBook(dest, label, \"receive\");\n-        walletdb.WriteAccount(label, account);\n+        batch.WriteAccount(label, account);\n     } else {\n         dest = GetDestinationForKey(account.vchPubKey, m_default_address_type);\n     }\n@@ -873,11 +873,11 @@ bool CWallet::MarkReplaced(const uint256& originalHash, const uint256& newHash)\n \n     wtx.mapValue[\"replaced_by_txid\"] = newHash.ToString();\n \n-    CWalletDB walletdb(*dbw, \"r+\");\n+    WalletBatch batch(*database, \"r+\");\n \n     bool success = true;\n-    if (!walletdb.WriteTx(wtx)) {\n-        LogPrintf(\"%s: Updating walletdb tx %s failed\\n\", __func__, wtx.GetHash().ToString());\n+    if (!batch.WriteTx(wtx)) {\n+        LogPrintf(\"%s: Updating batch tx %s failed\\n\", __func__, wtx.GetHash().ToString());\n         success = false;\n     }\n \n@@ -890,7 +890,7 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n {\n     LOCK(cs_wallet);\n \n-    CWalletDB walletdb(*dbw, \"r+\", fFlushOnClose);\n+    WalletBatch batch(*database, \"r+\", fFlushOnClose);\n \n     uint256 hash = wtxIn.GetHash();\n \n@@ -902,7 +902,7 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n     if (fInsertedNew)\n     {\n         wtx.nTimeReceived = GetAdjustedTime();\n-        wtx.nOrderPos = IncOrderPosNext(&walletdb);\n+        wtx.nOrderPos = IncOrderPosNext(&batch);\n         wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, nullptr)));\n         wtx.nTimeSmart = ComputeTimeSmart(wtx);\n         AddToSpends(hash);\n@@ -949,7 +949,7 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n \n     // Write to disk\n     if (fInsertedNew || fUpdated)\n-        if (!walletdb.WriteTx(wtx))\n+        if (!batch.WriteTx(wtx))\n             return false;\n \n     // Break debit/credit balance caches:\n@@ -1074,7 +1074,7 @@ bool CWallet::AbandonTransaction(const uint256& hashTx)\n {\n     LOCK2(cs_main, cs_wallet);\n \n-    CWalletDB walletdb(*dbw, \"r+\");\n+    WalletBatch batch(*database, \"r+\");\n \n     std::set<uint256> todo;\n     std::set<uint256> done;\n@@ -1106,7 +1106,7 @@ bool CWallet::AbandonTransaction(const uint256& hashTx)\n             wtx.nIndex = -1;\n             wtx.setAbandoned();\n             wtx.MarkDirty();\n-            walletdb.WriteTx(wtx);\n+            batch.WriteTx(wtx);\n             NotifyTransactionChanged(this, wtx.GetHash(), CT_UPDATED);\n             // Iterate over all its outputs, and mark transactions in the wallet that spend them abandoned too\n             TxSpends::const_iterator iter = mapTxSpends.lower_bound(COutPoint(hashTx, 0));\n@@ -1148,7 +1148,7 @@ void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n         return;\n \n     // Do not flush the wallet here for performance reasons\n-    CWalletDB walletdb(*dbw, \"r+\", false);\n+    WalletBatch batch(*database, \"r+\", false);\n \n     std::set<uint256> todo;\n     std::set<uint256> done;\n@@ -1169,7 +1169,7 @@ void CWallet::MarkConflicted(const uint256& hashBlock, const uint256& hashTx)\n             wtx.nIndex = -1;\n             wtx.hashBlock = hashBlock;\n             wtx.MarkDirty();\n-            walletdb.WriteTx(wtx);\n+            batch.WriteTx(wtx);\n             // Iterate over all its outputs, and mark transactions in the wallet that spend them conflicted too\n             TxSpends::const_iterator iter = mapTxSpends.lower_bound(COutPoint(now, 0));\n             while (iter != mapTxSpends.end() && iter->first.hash == now) {\n@@ -1473,7 +1473,7 @@ bool CWallet::SetHDMasterKey(const CPubKey& pubkey)\n bool CWallet::SetHDChain(const CHDChain& chain, bool memonly)\n {\n     LOCK(cs_wallet);\n-    if (!memonly && !CWalletDB(*dbw).WriteHDChain(chain))\n+    if (!memonly && !WalletBatch(*database).WriteHDChain(chain))\n         throw std::runtime_error(std::string(__func__) + \": writing chain failed\");\n \n     hdChain = chain;\n@@ -2231,7 +2231,7 @@ CAmount CWallet::GetLegacyBalance(const isminefilter& filter, int minDepth, cons\n     }\n \n     if (account) {\n-        balance += CWalletDB(*dbw).GetAccountCreditDebit(*account);\n+        balance += WalletBatch(*database).GetAccountCreditDebit(*account);\n     }\n \n     return balance;\n@@ -3115,20 +3115,20 @@ bool CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::ve\n }\n \n void CWallet::ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries) {\n-    CWalletDB walletdb(*dbw);\n-    return walletdb.ListAccountCreditDebit(strAccount, entries);\n+    WalletBatch batch(*database);\n+    return batch.ListAccountCreditDebit(strAccount, entries);\n }\n \n bool CWallet::AddAccountingEntry(const CAccountingEntry& acentry)\n {\n-    CWalletDB walletdb(*dbw);\n+    WalletBatch batch(*database);\n \n-    return AddAccountingEntry(acentry, &walletdb);\n+    return AddAccountingEntry(acentry, &batch);\n }\n \n-bool CWallet::AddAccountingEntry(const CAccountingEntry& acentry, CWalletDB *pwalletdb)\n+bool CWallet::AddAccountingEntry(const CAccountingEntry& acentry, WalletBatch *batch)\n {\n-    if (!pwalletdb->WriteAccountingEntry(++nAccountingEntryNumber, acentry)) {\n+    if (!batch->WriteAccountingEntry(++nAccountingEntryNumber, acentry)) {\n         return false;\n     }\n \n@@ -3144,10 +3144,10 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n     LOCK2(cs_main, cs_wallet);\n \n     fFirstRunRet = false;\n-    DBErrors nLoadWalletRet = CWalletDB(*dbw,\"cr+\").LoadWallet(this);\n+    DBErrors nLoadWalletRet = WalletBatch(*database,\"cr+\").LoadWallet(this);\n     if (nLoadWalletRet == DBErrors::NEED_REWRITE)\n     {\n-        if (dbw->Rewrite(\"\\x04pool\"))\n+        if (database->Rewrite(\"\\x04pool\"))\n         {\n             setInternalKeyPool.clear();\n             setExternalKeyPool.clear();\n@@ -3172,13 +3172,13 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut)\n {\n     AssertLockHeld(cs_wallet); // mapWallet\n-    DBErrors nZapSelectTxRet = CWalletDB(*dbw,\"cr+\").ZapSelectTx(vHashIn, vHashOut);\n+    DBErrors nZapSelectTxRet = WalletBatch(*database,\"cr+\").ZapSelectTx(vHashIn, vHashOut);\n     for (uint256 hash : vHashOut)\n         mapWallet.erase(hash);\n \n     if (nZapSelectTxRet == DBErrors::NEED_REWRITE)\n     {\n-        if (dbw->Rewrite(\"\\x04pool\"))\n+        if (database->Rewrite(\"\\x04pool\"))\n         {\n             setInternalKeyPool.clear();\n             setExternalKeyPool.clear();\n@@ -3200,10 +3200,10 @@ DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256\n \n DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n {\n-    DBErrors nZapWalletTxRet = CWalletDB(*dbw,\"cr+\").ZapWalletTx(vWtx);\n+    DBErrors nZapWalletTxRet = WalletBatch(*database,\"cr+\").ZapWalletTx(vWtx);\n     if (nZapWalletTxRet == DBErrors::NEED_REWRITE)\n     {\n-        if (dbw->Rewrite(\"\\x04pool\"))\n+        if (database->Rewrite(\"\\x04pool\"))\n         {\n             LOCK(cs_wallet);\n             setInternalKeyPool.clear();\n@@ -3235,9 +3235,9 @@ bool CWallet::SetAddressBook(const CTxDestination& address, const std::string& s\n     }\n     NotifyAddressBookChanged(this, address, strName, ::IsMine(*this, address) != ISMINE_NO,\n                              strPurpose, (fUpdated ? CT_UPDATED : CT_NEW) );\n-    if (!strPurpose.empty() && !CWalletDB(*dbw).WritePurpose(EncodeDestination(address), strPurpose))\n+    if (!strPurpose.empty() && !WalletBatch(*database).WritePurpose(EncodeDestination(address), strPurpose))\n         return false;\n-    return CWalletDB(*dbw).WriteName(EncodeDestination(address), strName);\n+    return WalletBatch(*database).WriteName(EncodeDestination(address), strName);\n }\n \n bool CWallet::DelAddressBook(const CTxDestination& address)\n@@ -3249,15 +3249,15 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n         std::string strAddress = EncodeDestination(address);\n         for (const std::pair<std::string, std::string> &item : mapAddressBook[address].destdata)\n         {\n-            CWalletDB(*dbw).EraseDestData(strAddress, item.first);\n+            WalletBatch(*database).EraseDestData(strAddress, item.first);\n         }\n         mapAddressBook.erase(address);\n     }\n \n     NotifyAddressBookChanged(this, address, \"\", ::IsMine(*this, address) != ISMINE_NO, \"\", CT_DELETED);\n \n-    CWalletDB(*dbw).ErasePurpose(EncodeDestination(address));\n-    return CWalletDB(*dbw).EraseName(EncodeDestination(address));\n+    WalletBatch(*database).ErasePurpose(EncodeDestination(address));\n+    return WalletBatch(*database).EraseName(EncodeDestination(address));\n }\n \n const std::string& CWallet::GetLabelName(const CScript& scriptPubKey) const\n@@ -3283,15 +3283,15 @@ bool CWallet::NewKeyPool()\n {\n     {\n         LOCK(cs_wallet);\n-        CWalletDB walletdb(*dbw);\n+        WalletBatch batch(*database);\n \n         for (int64_t nIndex : setInternalKeyPool) {\n-            walletdb.ErasePool(nIndex);\n+            batch.ErasePool(nIndex);\n         }\n         setInternalKeyPool.clear();\n \n         for (int64_t nIndex : setExternalKeyPool) {\n-            walletdb.ErasePool(nIndex);\n+            batch.ErasePool(nIndex);\n         }\n         setExternalKeyPool.clear();\n \n@@ -3356,7 +3356,7 @@ bool CWallet::TopUpKeyPool(unsigned int kpSize)\n             missingInternal = 0;\n         }\n         bool internal = false;\n-        CWalletDB walletdb(*dbw);\n+        WalletBatch batch(*database);\n         for (int64_t i = missingInternal + missingExternal; i--;)\n         {\n             if (i < missingInternal) {\n@@ -3366,8 +3366,8 @@ bool CWallet::TopUpKeyPool(unsigned int kpSize)\n             assert(m_max_keypool_index < std::numeric_limits<int64_t>::max()); // How in the hell did you use so many keys?\n             int64_t index = ++m_max_keypool_index;\n \n-            CPubKey pubkey(GenerateNewKey(walletdb, internal));\n-            if (!walletdb.WritePool(index, CKeyPool(pubkey, internal))) {\n+            CPubKey pubkey(GenerateNewKey(batch, internal));\n+            if (!batch.WritePool(index, CKeyPool(pubkey, internal))) {\n                 throw std::runtime_error(std::string(__func__) + \": writing generated key failed\");\n             }\n \n@@ -3402,12 +3402,12 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRe\n         if(setKeyPool.empty())\n             return;\n \n-        CWalletDB walletdb(*dbw);\n+        WalletBatch batch(*database);\n \n         auto it = setKeyPool.begin();\n         nIndex = *it;\n         setKeyPool.erase(it);\n-        if (!walletdb.ReadPool(nIndex, keypool)) {\n+        if (!batch.ReadPool(nIndex, keypool)) {\n             throw std::runtime_error(std::string(__func__) + \": read failed\");\n         }\n         if (!HaveKey(keypool.vchPubKey.GetID())) {\n@@ -3426,8 +3426,8 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool, bool fRe\n void CWallet::KeepKey(int64_t nIndex)\n {\n     // Remove from key pool\n-    CWalletDB walletdb(*dbw);\n-    walletdb.ErasePool(nIndex);\n+    WalletBatch batch(*database);\n+    batch.ErasePool(nIndex);\n     LogPrintf(\"keypool keep %d\\n\", nIndex);\n }\n \n@@ -3456,8 +3456,8 @@ bool CWallet::GetKeyFromPool(CPubKey& result, bool internal)\n         if (nIndex == -1)\n         {\n             if (IsLocked()) return false;\n-            CWalletDB walletdb(*dbw);\n-            result = GenerateNewKey(walletdb, internal);\n+            WalletBatch batch(*database);\n+            result = GenerateNewKey(batch, internal);\n             return true;\n         }\n         KeepKey(nIndex);\n@@ -3466,14 +3466,14 @@ bool CWallet::GetKeyFromPool(CPubKey& result, bool internal)\n     return true;\n }\n \n-static int64_t GetOldestKeyTimeInPool(const std::set<int64_t>& setKeyPool, CWalletDB& walletdb) {\n+static int64_t GetOldestKeyTimeInPool(const std::set<int64_t>& setKeyPool, WalletBatch& batch) {\n     if (setKeyPool.empty()) {\n         return GetTime();\n     }\n \n     CKeyPool keypool;\n     int64_t nIndex = *(setKeyPool.begin());\n-    if (!walletdb.ReadPool(nIndex, keypool)) {\n+    if (!batch.ReadPool(nIndex, keypool)) {\n         throw std::runtime_error(std::string(__func__) + \": read oldest key in keypool failed\");\n     }\n     assert(keypool.vchPubKey.IsValid());\n@@ -3484,12 +3484,12 @@ int64_t CWallet::GetOldestKeyPoolTime()\n {\n     LOCK(cs_wallet);\n \n-    CWalletDB walletdb(*dbw);\n+    WalletBatch batch(*database);\n \n     // load oldest key from keypool, get time and return\n-    int64_t oldestKey = GetOldestKeyTimeInPool(setExternalKeyPool, walletdb);\n+    int64_t oldestKey = GetOldestKeyTimeInPool(setExternalKeyPool, batch);\n     if (IsHDEnabled() && CanSupportFeature(FEATURE_HD_SPLIT)) {\n-        oldestKey = std::max(GetOldestKeyTimeInPool(setInternalKeyPool, walletdb), oldestKey);\n+        oldestKey = std::max(GetOldestKeyTimeInPool(setInternalKeyPool, batch), oldestKey);\n     }\n \n     return oldestKey;\n@@ -3685,17 +3685,17 @@ void CWallet::MarkReserveKeysAsUsed(int64_t keypool_id)\n     std::set<int64_t> *setKeyPool = internal ? &setInternalKeyPool : &setExternalKeyPool;\n     auto it = setKeyPool->begin();\n \n-    CWalletDB walletdb(*dbw);\n+    WalletBatch batch(*database);\n     while (it != std::end(*setKeyPool)) {\n         const int64_t& index = *(it);\n         if (index > keypool_id) break; // set*KeyPool is ordered\n \n         CKeyPool keypool;\n-        if (walletdb.ReadPool(index, keypool)) { //TODO: This should be unnecessary\n+        if (batch.ReadPool(index, keypool)) { //TODO: This should be unnecessary\n             m_pool_key_to_index.erase(keypool.vchPubKey.GetID());\n         }\n         LearnAllRelatedScripts(keypool.vchPubKey);\n-        walletdb.ErasePool(index);\n+        batch.ErasePool(index);\n         LogPrintf(\"keypool index %d removed\\n\", index);\n         it = setKeyPool->erase(it);\n     }\n@@ -3872,14 +3872,14 @@ bool CWallet::AddDestData(const CTxDestination &dest, const std::string &key, co\n         return false;\n \n     mapAddressBook[dest].destdata.insert(std::make_pair(key, value));\n-    return CWalletDB(*dbw).WriteDestData(EncodeDestination(dest), key, value);\n+    return WalletBatch(*database).WriteDestData(EncodeDestination(dest), key, value);\n }\n \n bool CWallet::EraseDestData(const CTxDestination &dest, const std::string &key)\n {\n     if (!mapAddressBook[dest].destdata.erase(key))\n         return false;\n-    return CWalletDB(*dbw).EraseDestData(EncodeDestination(dest), key);\n+    return WalletBatch(*database).EraseDestData(EncodeDestination(dest), key);\n }\n \n bool CWallet::LoadDestData(const CTxDestination &dest, const std::string &key, const std::string &value)\n@@ -3928,7 +3928,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path&\n     if (gArgs.GetBoolArg(\"-zapwallettxes\", false)) {\n         uiInterface.InitMessage(_(\"Zapping all transactions from wallet...\"));\n \n-        std::unique_ptr<CWallet> tempWallet = MakeUnique<CWallet>(name, CWalletDBWrapper::Create(path));\n+        std::unique_ptr<CWallet> tempWallet = MakeUnique<CWallet>(name, WalletDatabase::Create(path));\n         DBErrors nZapWalletRet = tempWallet->ZapWalletTx(vWtx);\n         if (nZapWalletRet != DBErrors::LOAD_OK) {\n             InitError(strprintf(_(\"Error loading %s: Wallet corrupted\"), walletFile));\n@@ -3940,7 +3940,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path&\n \n     int64_t nStart = GetTimeMillis();\n     bool fFirstRun = true;\n-    CWallet *walletInstance = new CWallet(name, CWalletDBWrapper::Create(path));\n+    CWallet *walletInstance = new CWallet(name, WalletDatabase::Create(path));\n     DBErrors nLoadWalletRet = walletInstance->LoadWallet(fFirstRun);\n     if (nLoadWalletRet != DBErrors::LOAD_OK)\n     {\n@@ -4045,9 +4045,9 @@ CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path&\n     CBlockIndex *pindexRescan = chainActive.Genesis();\n     if (!gArgs.GetBoolArg(\"-rescan\", false))\n     {\n-        CWalletDB walletdb(*walletInstance->dbw);\n+        WalletBatch batch(*walletInstance->database);\n         CBlockLocator locator;\n-        if (walletdb.ReadBestBlock(locator))\n+        if (batch.ReadBestBlock(locator))\n             pindexRescan = FindForkInGlobalIndex(chainActive, locator);\n     }\n \n@@ -4091,12 +4091,12 @@ CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path&\n         }\n         LogPrintf(\" rescan      %15dms\\n\", GetTimeMillis() - nStart);\n         walletInstance->SetBestChain(chainActive.GetLocator());\n-        walletInstance->dbw->IncrementUpdateCounter();\n+        walletInstance->database->IncrementUpdateCounter();\n \n         // Restore wallet transaction metadata after -zapwallettxes=1\n         if (gArgs.GetBoolArg(\"-zapwallettxes\", false) && gArgs.GetArg(\"-zapwallettxes\", \"1\") != \"2\")\n         {\n-            CWalletDB walletdb(*walletInstance->dbw);\n+            WalletBatch batch(*walletInstance->database);\n \n             for (const CWalletTx& wtxOld : vWtx)\n             {\n@@ -4113,7 +4113,7 @@ CWallet* CWallet::CreateWalletFromFile(const std::string& name, const fs::path&\n                     copyTo->fFromMe = copyFrom->fFromMe;\n                     copyTo->strFromAccount = copyFrom->strFromAccount;\n                     copyTo->nOrderPos = copyFrom->nOrderPos;\n-                    walletdb.WriteTx(*copyTo);\n+                    batch.WriteTx(*copyTo);\n                 }\n             }\n         }\n@@ -4146,7 +4146,7 @@ void CWallet::postInitProcess(CScheduler& scheduler)\n \n bool CWallet::BackupWallet(const std::string& strDest)\n {\n-    return dbw->Backup(strDest);\n+    return database->Backup(strDest);\n }\n \n CKeyPool::CKeyPool()"
      },
      {
        "sha": "170e60d48530e272db678defac71eca70a787871",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=ea23945dbc6ad239c5acac374d2b54aa12870838",
        "patch": "@@ -666,7 +666,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     std::mutex mutexScanning;\n     friend class WalletRescanReserver;\n \n-    CWalletDB *pwalletdbEncryption = nullptr;\n+    WalletBatch *encrypted_batch = nullptr;\n \n     //! the current wallet version: clients below this version are not able to load the wallet\n     int nWalletVersion = FEATURE_BASE;\n@@ -701,7 +701,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     CHDChain hdChain;\n \n     /* HD derive new child key (on internal or external chain) */\n-    void DeriveNewChildKey(CWalletDB &walletdb, CKeyMetadata& metadata, CKey& secret, bool internal = false);\n+    void DeriveNewChildKey(WalletBatch &batch, CKeyMetadata& metadata, CKey& secret, bool internal = false);\n \n     std::set<int64_t> setInternalKeyPool;\n     std::set<int64_t> setExternalKeyPool;\n@@ -729,7 +729,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     std::string m_name;\n \n     /** Internal database handle. */\n-    std::unique_ptr<CWalletDBWrapper> dbw;\n+    std::unique_ptr<WalletDatabase> database;\n \n     /**\n      * The following is used to keep track of how far behind the wallet is\n@@ -753,9 +753,9 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     /** Get database handle used by this wallet. Ideally this function would\n      * not be necessary.\n      */\n-    CWalletDBWrapper& GetDBHandle()\n+    WalletDatabase& GetDBHandle()\n     {\n-        return *dbw;\n+        return *database;\n     }\n \n     /**\n@@ -783,14 +783,14 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     unsigned int nMasterKeyMaxID = 0;\n \n     /** Construct wallet with specified name and database implementation. */\n-    CWallet(std::string name, std::unique_ptr<CWalletDBWrapper> dbw) : m_name(std::move(name)), dbw(std::move(dbw))\n+    CWallet(std::string name, std::unique_ptr<WalletDatabase> database) : m_name(std::move(name)), database(std::move(database))\n     {\n     }\n \n     ~CWallet()\n     {\n-        delete pwalletdbEncryption;\n-        pwalletdbEncryption = nullptr;\n+        delete encrypted_batch;\n+        encrypted_batch = nullptr;\n     }\n \n     std::map<uint256, CWalletTx> mapWallet;\n@@ -856,10 +856,10 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * keystore implementation\n      * Generate a new key\n      */\n-    CPubKey GenerateNewKey(CWalletDB& walletdb, bool internal = false);\n+    CPubKey GenerateNewKey(WalletBatch& batch, bool internal = false);\n     //! Adds a key to the store, and saves it to disk.\n     bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey) override;\n-    bool AddKeyPubKeyWithDB(CWalletDB &walletdb,const CKey& key, const CPubKey &pubkey);\n+    bool AddKeyPubKeyWithDB(WalletBatch &batch,const CKey& key, const CPubKey &pubkey);\n     //! Adds a key to the store, without saving it to disk (used by LoadWallet)\n     bool LoadKey(const CKey& key, const CPubKey &pubkey) { return CCryptoKeyStore::AddKeyPubKey(key, pubkey); }\n     //! Load metadata (used by LoadWallet)\n@@ -907,7 +907,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n      * Increment the next transaction order id\n      * @return next transaction order id\n      */\n-    int64_t IncOrderPosNext(CWalletDB *pwalletdb = nullptr);\n+    int64_t IncOrderPosNext(WalletBatch *batch = nullptr);\n     DBErrors ReorderTransactions();\n     bool AccountMove(std::string strFrom, std::string strTo, CAmount nAmount, std::string strComment = \"\");\n     bool GetLabelDestination(CTxDestination &dest, const std::string& label, bool bForceNew = false);\n@@ -955,7 +955,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n \n     void ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries);\n     bool AddAccountingEntry(const CAccountingEntry&);\n-    bool AddAccountingEntry(const CAccountingEntry&, CWalletDB *pwalletdb);\n+    bool AddAccountingEntry(const CAccountingEntry&, WalletBatch *batch);\n     bool DummySignTx(CMutableTransaction &txNew, const std::set<CTxOut> &txouts) const\n     {\n         std::vector<CTxOut> v_txouts(txouts.size());\n@@ -1039,7 +1039,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     }\n \n     //! signify that a particular wallet feature is now used. this may change nWalletVersion and nWalletMaxVersion if those are lower\n-    bool SetMinVersion(enum WalletFeature, CWalletDB* pwalletdbIn = nullptr, bool fExplicit = false);\n+    bool SetMinVersion(enum WalletFeature, WalletBatch* batch_in = nullptr, bool fExplicit = false);\n \n     //! change which version we're allowed to upgrade to (note that this does not immediately imply upgrading to that format)\n     bool SetMaxVersion(int nVersion);"
      },
      {
        "sha": "bcf3ba7b67309c709a2b45b4d4f42c3648c99aee",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 50,
        "deletions": 50,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=ea23945dbc6ad239c5acac374d2b54aa12870838",
        "patch": "@@ -21,42 +21,42 @@\n #include <boost/thread.hpp>\n \n //\n-// CWalletDB\n+// WalletBatch\n //\n \n-bool CWalletDB::WriteName(const std::string& strAddress, const std::string& strName)\n+bool WalletBatch::WriteName(const std::string& strAddress, const std::string& strName)\n {\n     return WriteIC(std::make_pair(std::string(\"name\"), strAddress), strName);\n }\n \n-bool CWalletDB::EraseName(const std::string& strAddress)\n+bool WalletBatch::EraseName(const std::string& strAddress)\n {\n     // This should only be used for sending addresses, never for receiving addresses,\n     // receiving addresses must always have an address book entry if they're not change return.\n     return EraseIC(std::make_pair(std::string(\"name\"), strAddress));\n }\n \n-bool CWalletDB::WritePurpose(const std::string& strAddress, const std::string& strPurpose)\n+bool WalletBatch::WritePurpose(const std::string& strAddress, const std::string& strPurpose)\n {\n     return WriteIC(std::make_pair(std::string(\"purpose\"), strAddress), strPurpose);\n }\n \n-bool CWalletDB::ErasePurpose(const std::string& strAddress)\n+bool WalletBatch::ErasePurpose(const std::string& strAddress)\n {\n     return EraseIC(std::make_pair(std::string(\"purpose\"), strAddress));\n }\n \n-bool CWalletDB::WriteTx(const CWalletTx& wtx)\n+bool WalletBatch::WriteTx(const CWalletTx& wtx)\n {\n     return WriteIC(std::make_pair(std::string(\"tx\"), wtx.GetHash()), wtx);\n }\n \n-bool CWalletDB::EraseTx(uint256 hash)\n+bool WalletBatch::EraseTx(uint256 hash)\n {\n     return EraseIC(std::make_pair(std::string(\"tx\"), hash));\n }\n \n-bool CWalletDB::WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, const CKeyMetadata& keyMeta)\n+bool WalletBatch::WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, const CKeyMetadata& keyMeta)\n {\n     if (!WriteIC(std::make_pair(std::string(\"keymeta\"), vchPubKey), keyMeta, false)) {\n         return false;\n@@ -71,7 +71,7 @@ bool CWalletDB::WriteKey(const CPubKey& vchPubKey, const CPrivKey& vchPrivKey, c\n     return WriteIC(std::make_pair(std::string(\"key\"), vchPubKey), std::make_pair(vchPrivKey, Hash(vchKey.begin(), vchKey.end())), false);\n }\n \n-bool CWalletDB::WriteCryptedKey(const CPubKey& vchPubKey,\n+bool WalletBatch::WriteCryptedKey(const CPubKey& vchPubKey,\n                                 const std::vector<unsigned char>& vchCryptedSecret,\n                                 const CKeyMetadata &keyMeta)\n {\n@@ -87,86 +87,86 @@ bool CWalletDB::WriteCryptedKey(const CPubKey& vchPubKey,\n     return true;\n }\n \n-bool CWalletDB::WriteMasterKey(unsigned int nID, const CMasterKey& kMasterKey)\n+bool WalletBatch::WriteMasterKey(unsigned int nID, const CMasterKey& kMasterKey)\n {\n     return WriteIC(std::make_pair(std::string(\"mkey\"), nID), kMasterKey, true);\n }\n \n-bool CWalletDB::WriteCScript(const uint160& hash, const CScript& redeemScript)\n+bool WalletBatch::WriteCScript(const uint160& hash, const CScript& redeemScript)\n {\n     return WriteIC(std::make_pair(std::string(\"cscript\"), hash), redeemScript, false);\n }\n \n-bool CWalletDB::WriteWatchOnly(const CScript &dest, const CKeyMetadata& keyMeta)\n+bool WalletBatch::WriteWatchOnly(const CScript &dest, const CKeyMetadata& keyMeta)\n {\n     if (!WriteIC(std::make_pair(std::string(\"watchmeta\"), dest), keyMeta)) {\n         return false;\n     }\n     return WriteIC(std::make_pair(std::string(\"watchs\"), dest), '1');\n }\n \n-bool CWalletDB::EraseWatchOnly(const CScript &dest)\n+bool WalletBatch::EraseWatchOnly(const CScript &dest)\n {\n     if (!EraseIC(std::make_pair(std::string(\"watchmeta\"), dest))) {\n         return false;\n     }\n     return EraseIC(std::make_pair(std::string(\"watchs\"), dest));\n }\n \n-bool CWalletDB::WriteBestBlock(const CBlockLocator& locator)\n+bool WalletBatch::WriteBestBlock(const CBlockLocator& locator)\n {\n     WriteIC(std::string(\"bestblock\"), CBlockLocator()); // Write empty block locator so versions that require a merkle branch automatically rescan\n     return WriteIC(std::string(\"bestblock_nomerkle\"), locator);\n }\n \n-bool CWalletDB::ReadBestBlock(CBlockLocator& locator)\n+bool WalletBatch::ReadBestBlock(CBlockLocator& locator)\n {\n     if (batch.Read(std::string(\"bestblock\"), locator) && !locator.vHave.empty()) return true;\n     return batch.Read(std::string(\"bestblock_nomerkle\"), locator);\n }\n \n-bool CWalletDB::WriteOrderPosNext(int64_t nOrderPosNext)\n+bool WalletBatch::WriteOrderPosNext(int64_t nOrderPosNext)\n {\n     return WriteIC(std::string(\"orderposnext\"), nOrderPosNext);\n }\n \n-bool CWalletDB::ReadPool(int64_t nPool, CKeyPool& keypool)\n+bool WalletBatch::ReadPool(int64_t nPool, CKeyPool& keypool)\n {\n     return batch.Read(std::make_pair(std::string(\"pool\"), nPool), keypool);\n }\n \n-bool CWalletDB::WritePool(int64_t nPool, const CKeyPool& keypool)\n+bool WalletBatch::WritePool(int64_t nPool, const CKeyPool& keypool)\n {\n     return WriteIC(std::make_pair(std::string(\"pool\"), nPool), keypool);\n }\n \n-bool CWalletDB::ErasePool(int64_t nPool)\n+bool WalletBatch::ErasePool(int64_t nPool)\n {\n     return EraseIC(std::make_pair(std::string(\"pool\"), nPool));\n }\n \n-bool CWalletDB::WriteMinVersion(int nVersion)\n+bool WalletBatch::WriteMinVersion(int nVersion)\n {\n     return WriteIC(std::string(\"minversion\"), nVersion);\n }\n \n-bool CWalletDB::ReadAccount(const std::string& strAccount, CAccount& account)\n+bool WalletBatch::ReadAccount(const std::string& strAccount, CAccount& account)\n {\n     account.SetNull();\n     return batch.Read(std::make_pair(std::string(\"acc\"), strAccount), account);\n }\n \n-bool CWalletDB::WriteAccount(const std::string& strAccount, const CAccount& account)\n+bool WalletBatch::WriteAccount(const std::string& strAccount, const CAccount& account)\n {\n     return WriteIC(std::make_pair(std::string(\"acc\"), strAccount), account);\n }\n \n-bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n+bool WalletBatch::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n {\n     return WriteIC(std::make_pair(std::string(\"acentry\"), std::make_pair(acentry.strAccount, nAccEntryNum)), acentry);\n }\n \n-CAmount CWalletDB::GetAccountCreditDebit(const std::string& strAccount)\n+CAmount WalletBatch::GetAccountCreditDebit(const std::string& strAccount)\n {\n     std::list<CAccountingEntry> entries;\n     ListAccountCreditDebit(strAccount, entries);\n@@ -178,7 +178,7 @@ CAmount CWalletDB::GetAccountCreditDebit(const std::string& strAccount)\n     return nCreditDebit;\n }\n \n-void CWalletDB::ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries)\n+void WalletBatch::ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries)\n {\n     bool fAllAccounts = (strAccount == \"*\");\n \n@@ -512,13 +512,13 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n     return true;\n }\n \n-bool CWalletDB::IsKeyType(const std::string& strType)\n+bool WalletBatch::IsKeyType(const std::string& strType)\n {\n     return (strType== \"key\" || strType == \"wkey\" ||\n             strType == \"mkey\" || strType == \"ckey\");\n }\n \n-DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n+DBErrors WalletBatch::LoadWallet(CWallet* pwallet)\n {\n     CWalletScanState wss;\n     bool fNoncriticalErrors = false;\n@@ -624,7 +624,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n     return result;\n }\n \n-DBErrors CWalletDB::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWalletTx>& vWtx)\n+DBErrors WalletBatch::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWalletTx>& vWtx)\n {\n     DBErrors result = DBErrors::LOAD_OK;\n \n@@ -683,7 +683,7 @@ DBErrors CWalletDB::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWal\n     return result;\n }\n \n-DBErrors CWalletDB::ZapSelectTx(std::vector<uint256>& vTxHashIn, std::vector<uint256>& vTxHashOut)\n+DBErrors WalletBatch::ZapSelectTx(std::vector<uint256>& vTxHashIn, std::vector<uint256>& vTxHashOut)\n {\n     // build list of wallet TXs and hashes\n     std::vector<uint256> vTxHash;\n@@ -721,7 +721,7 @@ DBErrors CWalletDB::ZapSelectTx(std::vector<uint256>& vTxHashIn, std::vector<uin\n     return DBErrors::LOAD_OK;\n }\n \n-DBErrors CWalletDB::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n+DBErrors WalletBatch::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n {\n     // build list of wallet TXs\n     std::vector<uint256> vTxHash;\n@@ -749,7 +749,7 @@ void MaybeCompactWalletDB()\n     }\n \n     for (CWalletRef pwallet : vpwallets) {\n-        CWalletDBWrapper& dbh = pwallet->GetDBHandle();\n+        WalletDatabase& dbh = pwallet->GetDBHandle();\n \n         unsigned int nUpdateCounter = dbh.nUpdateCounter;\n \n@@ -759,7 +759,7 @@ void MaybeCompactWalletDB()\n         }\n \n         if (dbh.nLastFlushed != nUpdateCounter && GetTime() - dbh.nLastWalletUpdate >= 2) {\n-            if (CDB::PeriodicFlush(dbh)) {\n+            if (BerkeleyBatch::PeriodicFlush(dbh)) {\n                 dbh.nLastFlushed = nUpdateCounter;\n             }\n         }\n@@ -771,19 +771,19 @@ void MaybeCompactWalletDB()\n //\n // Try to (very carefully!) recover wallet file if there is a problem.\n //\n-bool CWalletDB::Recover(const fs::path& wallet_path, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& out_backup_filename)\n+bool WalletBatch::Recover(const fs::path& wallet_path, void *callbackDataIn, bool (*recoverKVcallback)(void* callbackData, CDataStream ssKey, CDataStream ssValue), std::string& out_backup_filename)\n {\n-    return CDB::Recover(wallet_path, callbackDataIn, recoverKVcallback, out_backup_filename);\n+    return BerkeleyBatch::Recover(wallet_path, callbackDataIn, recoverKVcallback, out_backup_filename);\n }\n \n-bool CWalletDB::Recover(const fs::path& wallet_path, std::string& out_backup_filename)\n+bool WalletBatch::Recover(const fs::path& wallet_path, std::string& out_backup_filename)\n {\n     // recover without a key filter callback\n     // results in recovering all record types\n-    return CWalletDB::Recover(wallet_path, nullptr, nullptr, out_backup_filename);\n+    return WalletBatch::Recover(wallet_path, nullptr, nullptr, out_backup_filename);\n }\n \n-bool CWalletDB::RecoverKeysOnlyFilter(void *callbackData, CDataStream ssKey, CDataStream ssValue)\n+bool WalletBatch::RecoverKeysOnlyFilter(void *callbackData, CDataStream ssKey, CDataStream ssValue)\n {\n     CWallet *dummyWallet = reinterpret_cast<CWallet*>(callbackData);\n     CWalletScanState dummyWss;\n@@ -799,60 +799,60 @@ bool CWalletDB::RecoverKeysOnlyFilter(void *callbackData, CDataStream ssKey, CDa\n         return false;\n     if (!fReadOK)\n     {\n-        LogPrintf(\"WARNING: CWalletDB::Recover skipping %s: %s\\n\", strType, strErr);\n+        LogPrintf(\"WARNING: WalletBatch::Recover skipping %s: %s\\n\", strType, strErr);\n         return false;\n     }\n \n     return true;\n }\n \n-bool CWalletDB::VerifyEnvironment(const fs::path& wallet_path, std::string& errorStr)\n+bool WalletBatch::VerifyEnvironment(const fs::path& wallet_path, std::string& errorStr)\n {\n-    return CDB::VerifyEnvironment(wallet_path, errorStr);\n+    return BerkeleyBatch::VerifyEnvironment(wallet_path, errorStr);\n }\n \n-bool CWalletDB::VerifyDatabaseFile(const fs::path& wallet_path, std::string& warningStr, std::string& errorStr)\n+bool WalletBatch::VerifyDatabaseFile(const fs::path& wallet_path, std::string& warningStr, std::string& errorStr)\n {\n-    return CDB::VerifyDatabaseFile(wallet_path, warningStr, errorStr, CWalletDB::Recover);\n+    return BerkeleyBatch::VerifyDatabaseFile(wallet_path, warningStr, errorStr, WalletBatch::Recover);\n }\n \n-bool CWalletDB::WriteDestData(const std::string &address, const std::string &key, const std::string &value)\n+bool WalletBatch::WriteDestData(const std::string &address, const std::string &key, const std::string &value)\n {\n     return WriteIC(std::make_pair(std::string(\"destdata\"), std::make_pair(address, key)), value);\n }\n \n-bool CWalletDB::EraseDestData(const std::string &address, const std::string &key)\n+bool WalletBatch::EraseDestData(const std::string &address, const std::string &key)\n {\n     return EraseIC(std::make_pair(std::string(\"destdata\"), std::make_pair(address, key)));\n }\n \n \n-bool CWalletDB::WriteHDChain(const CHDChain& chain)\n+bool WalletBatch::WriteHDChain(const CHDChain& chain)\n {\n     return WriteIC(std::string(\"hdchain\"), chain);\n }\n \n-bool CWalletDB::TxnBegin()\n+bool WalletBatch::TxnBegin()\n {\n     return batch.TxnBegin();\n }\n \n-bool CWalletDB::TxnCommit()\n+bool WalletBatch::TxnCommit()\n {\n     return batch.TxnCommit();\n }\n \n-bool CWalletDB::TxnAbort()\n+bool WalletBatch::TxnAbort()\n {\n     return batch.TxnAbort();\n }\n \n-bool CWalletDB::ReadVersion(int& nVersion)\n+bool WalletBatch::ReadVersion(int& nVersion)\n {\n     return batch.ReadVersion(nVersion);\n }\n \n-bool CWalletDB::WriteVersion(int nVersion)\n+bool WalletBatch::WriteVersion(int nVersion)\n {\n     return batch.WriteVersion(nVersion);\n }"
      },
      {
        "sha": "23a19ad1c83b8358e7f002deebb38bd16ca5639a",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 19,
        "deletions": 16,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea23945dbc6ad239c5acac374d2b54aa12870838/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=ea23945dbc6ad239c5acac374d2b54aa12870838",
        "patch": "@@ -20,15 +20,15 @@\n /**\n  * Overview of wallet database classes:\n  *\n- * - CDBEnv is an environment in which the database exists (has no analog in dbwrapper.h)\n- * - CWalletDBWrapper represents a wallet database (similar to CDBWrapper in dbwrapper.h)\n- * - CDB is a low-level database transaction (similar to CDBBatch in dbwrapper.h)\n- * - CWalletDB is a modifier object for the wallet, and encapsulates a database\n+ * - BerkeleyEnvironment is an environment in which the database exists (has no analog in dbwrapper.h)\n+ * - WalletDatabase represents a wallet database (similar to CDBWrapper in dbwrapper.h)\n+ * - BerkeleyBatch is a low-level database transaction (similar to CDBBatch in dbwrapper.h)\n+ * - WalletBatch is a modifier object for the wallet, and encapsulates a database\n  *   transaction as well as methods to act on the database (no analog in\n  *   dbwrapper.h)\n  *\n- * The latter two are named confusingly, in contrast to what the names CDB\n- * and CWalletDB suggest they are transient transaction objects and don't\n+ * The latter two are named confusingly, in contrast to what the names BerkeleyBatch\n+ * and WalletBatch suggest they are transient transaction objects and don't\n  * represent the database itself.\n  */\n \n@@ -45,6 +45,9 @@ class CWalletTx;\n class uint160;\n class uint256;\n \n+/** Backend-agnostic database type. */\n+using WalletDatabase = BerkeleyDatabase;\n+\n /** Error statuses for the wallet database */\n enum class DBErrors\n {\n@@ -138,7 +141,7 @@ class CKeyMetadata\n  * database. It will be committed when the object goes out of scope.\n  * Optionally (on by default) it will flush to disk as well.\n  */\n-class CWalletDB\n+class WalletBatch\n {\n private:\n     template <typename K, typename T>\n@@ -147,7 +150,7 @@ class CWalletDB\n         if (!batch.Write(key, value, fOverwrite)) {\n             return false;\n         }\n-        m_dbw.IncrementUpdateCounter();\n+        m_database.IncrementUpdateCounter();\n         return true;\n     }\n \n@@ -157,18 +160,18 @@ class CWalletDB\n         if (!batch.Erase(key)) {\n             return false;\n         }\n-        m_dbw.IncrementUpdateCounter();\n+        m_database.IncrementUpdateCounter();\n         return true;\n     }\n \n public:\n-    explicit CWalletDB(CWalletDBWrapper& dbw, const char* pszMode = \"r+\", bool _fFlushOnClose = true) :\n-        batch(dbw, pszMode, _fFlushOnClose),\n-        m_dbw(dbw)\n+    explicit WalletBatch(WalletDatabase& database, const char* pszMode = \"r+\", bool _fFlushOnClose = true) :\n+        batch(database, pszMode, _fFlushOnClose),\n+        m_database(database)\n     {\n     }\n-    CWalletDB(const CWalletDB&) = delete;\n-    CWalletDB& operator=(const CWalletDB&) = delete;\n+    WalletBatch(const WalletBatch&) = delete;\n+    WalletBatch& operator=(const WalletBatch&) = delete;\n \n     bool WriteName(const std::string& strAddress, const std::string& strName);\n     bool EraseName(const std::string& strAddress);\n@@ -244,8 +247,8 @@ class CWalletDB\n     //! Write wallet version\n     bool WriteVersion(int nVersion);\n private:\n-    CDB batch;\n-    CWalletDBWrapper& m_dbw;\n+    BerkeleyBatch batch;\n+    WalletDatabase& m_database;\n };\n \n //! Compacts BDB state so that wallet.dat is self-contained (if there are changes)"
      },
      {
        "sha": "0a24d34398aec2a38b97083cd98016a519363dd0",
        "filename": "test/functional/wallet_multiwallet.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ea23945dbc6ad239c5acac374d2b54aa12870838/test/functional/wallet_multiwallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ea23945dbc6ad239c5acac374d2b54aa12870838/test/functional/wallet_multiwallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/wallet_multiwallet.py?ref=ea23945dbc6ad239c5acac374d2b54aa12870838",
        "patch": "@@ -77,7 +77,7 @@ def run_test(self):\n \n         # should not initialize if one wallet is a copy of another\n         shutil.copyfile(wallet_dir('w8'), wallet_dir('w8_copy'))\n-        exp_stderr = \"CDB: Can't open database w8_copy \\(duplicates fileid \\w+ from w8\\)\"\n+        exp_stderr = \"BerkeleyBatch: Can't open database w8_copy \\(duplicates fileid \\w+ from w8\\)\"\n         self.nodes[0].assert_start_raises_init_error(['-wallet=w8', '-wallet=w8_copy'], exp_stderr, match=ErrorMatch.PARTIAL_REGEX)\n \n         # should not initialize if wallet file is a symlink"
      }
    ]
  },
  {
    "sha": "398c6f0f9d5ec788997f5574cc0ca9a8a7995950",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozOThjNmYwZjlkNWVjNzg4OTk3ZjU1NzRjYzBjYTlhOGE3OTk1OTUw",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2017-12-08T18:48:54Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2018-04-07T16:48:27Z"
      },
      "message": "Update walletdb comment after renaming.\n\nText from https://github.com/bitcoin/bitcoin/pull/11851#issuecomment-350320608\nby John Newbery <john@johnnewbery.com>.",
      "tree": {
        "sha": "a31b879c323e647e310f8e7aeff4808ab588164f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a31b879c323e647e310f8e7aeff4808ab588164f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/398c6f0f9d5ec788997f5574cc0ca9a8a7995950",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/398c6f0f9d5ec788997f5574cc0ca9a8a7995950",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/398c6f0f9d5ec788997f5574cc0ca9a8a7995950",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/398c6f0f9d5ec788997f5574cc0ca9a8a7995950/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ea23945dbc6ad239c5acac374d2b54aa12870838",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ea23945dbc6ad239c5acac374d2b54aa12870838",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ea23945dbc6ad239c5acac374d2b54aa12870838"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 7,
      "deletions": 10
    },
    "files": [
      {
        "sha": "fc61228be1c82f0d858a92b4d0ee92d64aab7593",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 7,
        "deletions": 10,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/398c6f0f9d5ec788997f5574cc0ca9a8a7995950/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/398c6f0f9d5ec788997f5574cc0ca9a8a7995950/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=398c6f0f9d5ec788997f5574cc0ca9a8a7995950",
        "patch": "@@ -20,16 +20,13 @@\n /**\n  * Overview of wallet database classes:\n  *\n- * - BerkeleyEnvironment is an environment in which the database exists (has no analog in dbwrapper.h)\n- * - WalletDatabase represents a wallet database (similar to CDBWrapper in dbwrapper.h)\n- * - BerkeleyBatch is a low-level database transaction (similar to CDBBatch in dbwrapper.h)\n- * - WalletBatch is a modifier object for the wallet, and encapsulates a database\n- *   transaction as well as methods to act on the database (no analog in\n- *   dbwrapper.h)\n+ * - WalletBatch is an abstract modifier object for the wallet database, and encapsulates a database\n+ *   batch update as well as methods to act on the database. It should be agnostic to the database implementation.\n  *\n- * The latter two are named confusingly, in contrast to what the names BerkeleyBatch\n- * and WalletBatch suggest they are transient transaction objects and don't\n- * represent the database itself.\n+ * The following classes are implementation specific:\n+ * - BerkeleyEnvironment is an environment in which the database exists.\n+ * - BerkeleyDatabase represents a wallet database.\n+ * - BerkeleyBatch is a low-level database batch update.\n  */\n \n static const bool DEFAULT_FLUSHWALLET = true;\n@@ -137,7 +134,7 @@ class CKeyMetadata\n };\n \n /** Access to the wallet database.\n- * This should really be named CWalletDBBatch, as it represents a single transaction at the\n+ * This represents a single transaction at the\n  * database. It will be committed when the object goes out of scope.\n  * Optionally (on by default) it will flush to disk as well.\n  */"
      }
    ]
  },
  {
    "sha": "9b0f0c5513f74825b06a728ab9bb2fd0e4224c9f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YjBmMGM1NTEzZjc0ODI1YjA2YTcyOGFiOWJiMmZkMGU0MjI0Yzlm",
    "commit": {
      "author": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2018-03-20T18:48:33Z"
      },
      "committer": {
        "name": "Russell Yanofsky",
        "email": "russ@yanofsky.org",
        "date": "2018-04-07T16:48:27Z"
      },
      "message": "Add m_ prefix to WalletBatch::m_batch",
      "tree": {
        "sha": "2bb0998e11f4238330ee72d89314ad2ba5097f04",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2bb0998e11f4238330ee72d89314ad2ba5097f04"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9b0f0c5513f74825b06a728ab9bb2fd0e4224c9f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b0f0c5513f74825b06a728ab9bb2fd0e4224c9f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9b0f0c5513f74825b06a728ab9bb2fd0e4224c9f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b0f0c5513f74825b06a728ab9bb2fd0e4224c9f/comments",
    "author": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ryanofsky",
      "id": 7133040,
      "node_id": "MDQ6VXNlcjcxMzMwNDA=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7133040?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ryanofsky",
      "html_url": "https://github.com/ryanofsky",
      "followers_url": "https://api.github.com/users/ryanofsky/followers",
      "following_url": "https://api.github.com/users/ryanofsky/following{/other_user}",
      "gists_url": "https://api.github.com/users/ryanofsky/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ryanofsky/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ryanofsky/subscriptions",
      "organizations_url": "https://api.github.com/users/ryanofsky/orgs",
      "repos_url": "https://api.github.com/users/ryanofsky/repos",
      "events_url": "https://api.github.com/users/ryanofsky/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ryanofsky/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "398c6f0f9d5ec788997f5574cc0ca9a8a7995950",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/398c6f0f9d5ec788997f5574cc0ca9a8a7995950",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/398c6f0f9d5ec788997f5574cc0ca9a8a7995950"
      }
    ],
    "stats": {
      "total": 42,
      "additions": 21,
      "deletions": 21
    },
    "files": [
      {
        "sha": "57261bb922b3c2f615ca720eff2ae3139576446d",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b0f0c5513f74825b06a728ab9bb2fd0e4224c9f/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b0f0c5513f74825b06a728ab9bb2fd0e4224c9f/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=9b0f0c5513f74825b06a728ab9bb2fd0e4224c9f",
        "patch": "@@ -121,8 +121,8 @@ bool WalletBatch::WriteBestBlock(const CBlockLocator& locator)\n \n bool WalletBatch::ReadBestBlock(CBlockLocator& locator)\n {\n-    if (batch.Read(std::string(\"bestblock\"), locator) && !locator.vHave.empty()) return true;\n-    return batch.Read(std::string(\"bestblock_nomerkle\"), locator);\n+    if (m_batch.Read(std::string(\"bestblock\"), locator) && !locator.vHave.empty()) return true;\n+    return m_batch.Read(std::string(\"bestblock_nomerkle\"), locator);\n }\n \n bool WalletBatch::WriteOrderPosNext(int64_t nOrderPosNext)\n@@ -132,7 +132,7 @@ bool WalletBatch::WriteOrderPosNext(int64_t nOrderPosNext)\n \n bool WalletBatch::ReadPool(int64_t nPool, CKeyPool& keypool)\n {\n-    return batch.Read(std::make_pair(std::string(\"pool\"), nPool), keypool);\n+    return m_batch.Read(std::make_pair(std::string(\"pool\"), nPool), keypool);\n }\n \n bool WalletBatch::WritePool(int64_t nPool, const CKeyPool& keypool)\n@@ -153,7 +153,7 @@ bool WalletBatch::WriteMinVersion(int nVersion)\n bool WalletBatch::ReadAccount(const std::string& strAccount, CAccount& account)\n {\n     account.SetNull();\n-    return batch.Read(std::make_pair(std::string(\"acc\"), strAccount), account);\n+    return m_batch.Read(std::make_pair(std::string(\"acc\"), strAccount), account);\n }\n \n bool WalletBatch::WriteAccount(const std::string& strAccount, const CAccount& account)\n@@ -182,7 +182,7 @@ void WalletBatch::ListAccountCreditDebit(const std::string& strAccount, std::lis\n {\n     bool fAllAccounts = (strAccount == \"*\");\n \n-    Dbc* pcursor = batch.GetCursor();\n+    Dbc* pcursor = m_batch.GetCursor();\n     if (!pcursor)\n         throw std::runtime_error(std::string(__func__) + \": cannot create DB cursor\");\n     bool setRange = true;\n@@ -193,7 +193,7 @@ void WalletBatch::ListAccountCreditDebit(const std::string& strAccount, std::lis\n         if (setRange)\n             ssKey << std::make_pair(std::string(\"acentry\"), std::make_pair((fAllAccounts ? std::string(\"\") : strAccount), uint64_t(0)));\n         CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-        int ret = batch.ReadAtCursor(pcursor, ssKey, ssValue, setRange);\n+        int ret = m_batch.ReadAtCursor(pcursor, ssKey, ssValue, setRange);\n         setRange = false;\n         if (ret == DB_NOTFOUND)\n             break;\n@@ -527,15 +527,15 @@ DBErrors WalletBatch::LoadWallet(CWallet* pwallet)\n     LOCK(pwallet->cs_wallet);\n     try {\n         int nMinVersion = 0;\n-        if (batch.Read((std::string)\"minversion\", nMinVersion))\n+        if (m_batch.Read((std::string)\"minversion\", nMinVersion))\n         {\n             if (nMinVersion > CLIENT_VERSION)\n                 return DBErrors::TOO_NEW;\n             pwallet->LoadMinVersion(nMinVersion);\n         }\n \n         // Get cursor\n-        Dbc* pcursor = batch.GetCursor();\n+        Dbc* pcursor = m_batch.GetCursor();\n         if (!pcursor)\n         {\n             LogPrintf(\"Error getting wallet database cursor\\n\");\n@@ -547,7 +547,7 @@ DBErrors WalletBatch::LoadWallet(CWallet* pwallet)\n             // Read next record\n             CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n             CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-            int ret = batch.ReadAtCursor(pcursor, ssKey, ssValue);\n+            int ret = m_batch.ReadAtCursor(pcursor, ssKey, ssValue);\n             if (ret == DB_NOTFOUND)\n                 break;\n             else if (ret != 0)\n@@ -630,14 +630,14 @@ DBErrors WalletBatch::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CW\n \n     try {\n         int nMinVersion = 0;\n-        if (batch.Read((std::string)\"minversion\", nMinVersion))\n+        if (m_batch.Read((std::string)\"minversion\", nMinVersion))\n         {\n             if (nMinVersion > CLIENT_VERSION)\n                 return DBErrors::TOO_NEW;\n         }\n \n         // Get cursor\n-        Dbc* pcursor = batch.GetCursor();\n+        Dbc* pcursor = m_batch.GetCursor();\n         if (!pcursor)\n         {\n             LogPrintf(\"Error getting wallet database cursor\\n\");\n@@ -649,7 +649,7 @@ DBErrors WalletBatch::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CW\n             // Read next record\n             CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n             CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n-            int ret = batch.ReadAtCursor(pcursor, ssKey, ssValue);\n+            int ret = m_batch.ReadAtCursor(pcursor, ssKey, ssValue);\n             if (ret == DB_NOTFOUND)\n                 break;\n             else if (ret != 0)\n@@ -834,25 +834,25 @@ bool WalletBatch::WriteHDChain(const CHDChain& chain)\n \n bool WalletBatch::TxnBegin()\n {\n-    return batch.TxnBegin();\n+    return m_batch.TxnBegin();\n }\n \n bool WalletBatch::TxnCommit()\n {\n-    return batch.TxnCommit();\n+    return m_batch.TxnCommit();\n }\n \n bool WalletBatch::TxnAbort()\n {\n-    return batch.TxnAbort();\n+    return m_batch.TxnAbort();\n }\n \n bool WalletBatch::ReadVersion(int& nVersion)\n {\n-    return batch.ReadVersion(nVersion);\n+    return m_batch.ReadVersion(nVersion);\n }\n \n bool WalletBatch::WriteVersion(int nVersion)\n {\n-    return batch.WriteVersion(nVersion);\n+    return m_batch.WriteVersion(nVersion);\n }"
      },
      {
        "sha": "040aa092e176de944dfbdf45964a25e420cd66fc",
        "filename": "src/wallet/walletdb.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b0f0c5513f74825b06a728ab9bb2fd0e4224c9f/src/wallet/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b0f0c5513f74825b06a728ab9bb2fd0e4224c9f/src/wallet/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.h?ref=9b0f0c5513f74825b06a728ab9bb2fd0e4224c9f",
        "patch": "@@ -144,7 +144,7 @@ class WalletBatch\n     template <typename K, typename T>\n     bool WriteIC(const K& key, const T& value, bool fOverwrite = true)\n     {\n-        if (!batch.Write(key, value, fOverwrite)) {\n+        if (!m_batch.Write(key, value, fOverwrite)) {\n             return false;\n         }\n         m_database.IncrementUpdateCounter();\n@@ -154,7 +154,7 @@ class WalletBatch\n     template <typename K>\n     bool EraseIC(const K& key)\n     {\n-        if (!batch.Erase(key)) {\n+        if (!m_batch.Erase(key)) {\n             return false;\n         }\n         m_database.IncrementUpdateCounter();\n@@ -163,7 +163,7 @@ class WalletBatch\n \n public:\n     explicit WalletBatch(WalletDatabase& database, const char* pszMode = \"r+\", bool _fFlushOnClose = true) :\n-        batch(database, pszMode, _fFlushOnClose),\n+        m_batch(database, pszMode, _fFlushOnClose),\n         m_database(database)\n     {\n     }\n@@ -244,7 +244,7 @@ class WalletBatch\n     //! Write wallet version\n     bool WriteVersion(int nVersion);\n private:\n-    BerkeleyBatch batch;\n+    BerkeleyBatch m_batch;\n     WalletDatabase& m_database;\n };\n "
      }
    ]
  }
]