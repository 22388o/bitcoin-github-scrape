[
  {
    "sha": "d2bb681f96fb327b4c4d5b2b113692ca22fdffbf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMmJiNjgxZjk2ZmIzMjdiNGM0ZDViMmIxMTM2OTJjYTIyZmRmZmJm",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-08-31T08:39:00Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-09-11T11:35:39Z"
      },
      "message": "util: move HasPrefix() so it can be reused\n\nMove the function `HasPrefix()` from `netaddress.cpp` to `util/string.h`\nso it can be reused by `CNetAddr` methods (and possibly others).",
      "tree": {
        "sha": "21e9dd765e4d7d389f55cc0b5c6fca7ddce2ff2d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/21e9dd765e4d7d389f55cc0b5c6fca7ddce2ff2d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d2bb681f96fb327b4c4d5b2b113692ca22fdffbf",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl9bYW4ACgkQVN8G9ktV\ny78SHB/+I3G+E8xYvMUdGkpUJwuD0jdzOKsSijGcCCvSY9m82ahDb5tj5wtFt4Mm\n3jAv4Nb2RGmaA4fUK/zFTBIZaIJKbEDG2DeWlqp4L3TebSv6fyrgQw4sZ2cZIy2z\nO7FsvZtZ+Et7tAGwf0mBEbEQL8Yf3xILoAnFjsnxYhFIvGn1GJdp/lFnohopfO7A\naX4RyqtnlZ/IKQeatWQwxYkfmB23hT78szoCuldxOhwOtuMiltwv0snUe7hMDFP7\nRu8rHWxWN5NSglwd9vTivfRKXQXAuHjhqpsMQs8mTERJ5sN3C9M8gycAkuhJYkda\nk8O+M9csbL38vVxepE0WTQErBYp2dnEnWJRT5eYZr4Lb58hDQpavi2X7KQUoCyI8\n0mJoujjlrlPw9ZFpuoZw14ko9phCjnV7uXmo4lg5bbqqB9irQdO4GvGT+X4O3/cC\n4iR1FXSP/z90ZwmK27uz7+58lamuoRmgU+ce7dSElsXxSc2Zj4FTRp+tgDuGi5IV\n40ZByEWmQ4iJ/JqkkA/ivGcDSSe2rl+4W4PEAkgG1D6a4kcdAI+48Od3Dffmh8XR\nNATwC76HAutYU0DadsL7LbYyZUEzpZPJaipji/swgWmm750VT1vFulJCCRrYwV6p\nE2hBbhifJirC51h11kR+o+Y9O26fIt1TUMhOyKwJvfD0CHo/rTray5SzRWrf5Tp1\nSYnpbixMsgHkAOsJVM/QPE0/XTWGKaduQb9PTzflylbHDPyIEOmiiBU9svS5BmeA\nqTxO2jrn26EkKzDNjW0/wYNghQXzfdXx7wi+GJVe2CQXNBRSZ+BhrxzJWSAEy1LG\nWrqoCwOYKTkpOxhA26f9oJuvFil6gE5iErgfqPF1tchsz8BViWVxMPwukWW3k9zI\nmgkIS3n8m6A7TU7CpFxVCvL4W6/1nTaoK7h77EhphwrTjIz8rv9nJqpXxJkl8eLc\nBP9sETwmaKKiAgwaO2Uwx/emeFJZAxh4xNr22+Ss9sQUnGLxP+xLWNJizR2X9SCf\ngnIUfYoxVaVDRcoF+og53NQwXfJfg1q0COFWmj0tHrXBo7zM799f1Bv6DEvpTUof\npHp0EVPFEVgzy4fCLv+dQta3RTVOOWMbi7hhllmXT0AcUKLhhnuYQwFaKTNqtNOW\np/I4X63YjPV4ofDYdAPvS3hfXCYCk+1aO6BDF4idx4ZS+ic5MlKIZxrPCblaTAMZ\nUoX0shLSPr0XQM/dsOC3Hquocqt81arJ2ZV29h9zeCpfg/lhVOpZk25QGFK/MnP9\n6OZFiXneSYQa+WVvD0BqIlRTtz9RbugBIDNTE4uN6b/0n8+GIDsccreG4f4QaWAn\nFae/QR09mNuSl5LJJ8GSGaZsMGcxuQ==\n=hMuq\n-----END PGP SIGNATURE-----",
        "payload": "tree 21e9dd765e4d7d389f55cc0b5c6fca7ddce2ff2d\nparent a47e5964861dfb98d61719c9852e12fd6da84c31\nauthor Vasil Dimov <vd@FreeBSD.org> 1598863140 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1599824139 +0200\n\nutil: move HasPrefix() so it can be reused\n\nMove the function `HasPrefix()` from `netaddress.cpp` to `util/string.h`\nso it can be reused by `CNetAddr` methods (and possibly others).\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2bb681f96fb327b4c4d5b2b113692ca22fdffbf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d2bb681f96fb327b4c4d5b2b113692ca22fdffbf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2bb681f96fb327b4c4d5b2b113692ca22fdffbf/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a47e5964861dfb98d61719c9852e12fd6da84c31",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a47e5964861dfb98d61719c9852e12fd6da84c31",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a47e5964861dfb98d61719c9852e12fd6da84c31"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 15,
      "deletions": 8
    },
    "files": [
      {
        "sha": "86fca451f0a03dd447fe51cad07a3a1a612eb7a0",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 8,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d2bb681f96fb327b4c4d5b2b113692ca22fdffbf/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d2bb681f96fb327b4c4d5b2b113692ca22fdffbf/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=d2bb681f96fb327b4c4d5b2b113692ca22fdffbf",
        "patch": "@@ -7,8 +7,9 @@\n \n #include <hash.h>\n #include <tinyformat.h>\n-#include <util/strencodings.h>\n #include <util/asmap.h>\n+#include <util/strencodings.h>\n+#include <util/string.h>\n \n #include <algorithm>\n #include <array>\n@@ -50,13 +51,6 @@ void CNetAddr::SetIP(const CNetAddr& ipIn)\n     m_addr = ipIn.m_addr;\n }\n \n-template <typename T1, size_t PREFIX_LEN>\n-inline bool HasPrefix(const T1& obj, const std::array<uint8_t, PREFIX_LEN>& prefix)\n-{\n-    return obj.size() >= PREFIX_LEN &&\n-           std::equal(std::begin(prefix), std::end(prefix), std::begin(obj));\n-}\n-\n void CNetAddr::SetLegacyIPv6(Span<const uint8_t> ipv6)\n {\n     assert(ipv6.size() == ADDR_IPV6_SIZE);"
      },
      {
        "sha": "a0c87bd00cdfa5408b167831aaa37c380ab48612",
        "filename": "src/util/string.h",
        "status": "modified",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d2bb681f96fb327b4c4d5b2b113692ca22fdffbf/src/util/string.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d2bb681f96fb327b4c4d5b2b113692ca22fdffbf/src/util/string.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/string.h?ref=d2bb681f96fb327b4c4d5b2b113692ca22fdffbf",
        "patch": "@@ -7,6 +7,8 @@\n \n #include <attributes.h>\n \n+#include <algorithm>\n+#include <array>\n #include <cstring>\n #include <locale>\n #include <sstream>\n@@ -74,4 +76,15 @@ std::string ToString(const T& t)\n     return oss.str();\n }\n \n+/**\n+ * Check whether a container begins with the given prefix.\n+ */\n+template <typename T1, size_t PREFIX_LEN>\n+NODISCARD inline bool HasPrefix(const T1& obj,\n+                                const std::array<uint8_t, PREFIX_LEN>& prefix)\n+{\n+    return obj.size() >= PREFIX_LEN &&\n+           std::equal(std::begin(prefix), std::end(prefix), std::begin(obj));\n+}\n+\n #endif // BITCOIN_UTIL_STRENCODINGS_H"
      }
    ]
  },
  {
    "sha": "fe42411b4b07b99c591855f5f00ad45dfeec8e30",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZTQyNDExYjRiMDdiOTljNTkxODU1ZjVmMDBhZDQ1ZGZlZWM4ZTMw",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-08-31T11:16:13Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-09-17T12:45:17Z"
      },
      "message": "test: move HasReason so it can be reused\n\nMove the class `HasReason` from `miner_tests.cpp` to\n`setup_common.h` so that it can be reused by other tests.",
      "tree": {
        "sha": "9b87f884e89db127a6580319c18868a7b9f74858",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9b87f884e89db127a6580319c18868a7b9f74858"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fe42411b4b07b99c591855f5f00ad45dfeec8e30",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl9jWnYACgkQVN8G9ktV\ny7+GKiAAkWS8qyPNiB6FeFtepJM0l3WOG0Clp1OotvC6nCY3hgzmYVfveSKtiN18\nLYuGr+hW1zFyX9LnK+l4s4m/vns6BepP1Asu3oSUTiHrlgk0/dSmioxMdGY1iULi\n4ERJonBoHOKhO5b9QDu8ctkLiuFya1elxu0pqdaRhJF7iYkOGje8jzxsNsN30dJu\nAniMaSDbct7RBQ3dknuYAxLUqd8EdYU+HoOlgLa40WaUAgbjItd2gnwqpmpISlvW\nS4qEWfNl4EOWyQN9EBKajeAO73lg5PGlMqlPIzEzKe47vyL2M9Ik8P19z+wCk3qc\ntRwarpGg8+0iP4yRBcBP7PbJE0jvRJC6w3Z3MqBVPycPHxzNgyjU7pC3mLmAMSd5\n6BLT4bYweAJv6aQvWYnDJ65K369fTSV2bw4MuGyq+RTdo0tnmD6LyO1vTv0juZdA\njfs+UgbMyn3AKYskIBQSFHFGrZIzNhrhKZcjQJpqsp06XjRe8nRQqs++/ZoOSzdW\n89GFSFtOPw0etVyuu5XitEF/zcl2wpeuMmfF2wVugm/6NETLWgc7T/HcxROTQLY4\ndQFLQJJgEazSnNoxM7EAZiQ41hALYu4NdLdUDWooFNNL9UlF1XouPjRFrq2xE51e\no79RaEo1eEGh3d8rBn7LCBCiSvZbr/CvNbL1fXGvFnR3MPBW/E9+Egj4SyvQxzt5\ny1k91VHbtoO5nXcVnKF2dUpLcmHuxPF/p76npXnWt8qvyPuMPvZU4oQ95r/mj6gH\nF+QWYx6kb8B8+RXPBf6f6CbW2wYQTY0ia1nhnreBFykZJolrU/khzIexdAZTgWb+\nI5AGqyXPKweJZjTvXLndx3FclaCOxbRrsGCjdE0JF6L0CYF8Oko3Y1NlIofmCyt1\nGL0xAYTQBkqVhXlD8lImhfjdvgY8aS2melHLAAZCzOQRvPvnTqGNr5vXuXKiMt+S\ng2XzmcI4/2lKK4aPNSiPTf9NyPpq/ssIUFVlWlaF+DVf6s7Um385IYC8/OifnoxP\nAyjVAy68ihSRfS+eyxtgnfIoUnzmkVzGEKGShi7x08qTkf3OE48JUebYR69ZBDDo\nnrZ2RgQVZSA4jpaZ/GDxxZmXd33USK5rE1W52IKVXVTKHO5hmcf2CZi82UEVMGsX\nywOG8KuCcDUVW0XQyTY7JTEE5SFtnJUR9XOJeigIjQsmHJPVVczo20C4TRE/9DK5\nzmvJz887lmY94xsUoq0gx4wFO3KZySgZ+2VsS0+1oBygKPsujLi+PRsVnvm+jFy2\n8uzDbj599WFM/xFwww0/kGFKlla2s62tAJozrsIComkXTOM1uN5jnBA4hXXU37Vn\nLi373E8A3IdxpxYVB8zUxbo5bNnpkA==\n=fR47\n-----END PGP SIGNATURE-----",
        "payload": "tree 9b87f884e89db127a6580319c18868a7b9f74858\nparent d2bb681f96fb327b4c4d5b2b113692ca22fdffbf\nauthor Vasil Dimov <vd@FreeBSD.org> 1598872573 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1600346717 +0200\n\ntest: move HasReason so it can be reused\n\nMove the class `HasReason` from `miner_tests.cpp` to\n`setup_common.h` so that it can be reused by other tests.\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe42411b4b07b99c591855f5f00ad45dfeec8e30",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fe42411b4b07b99c591855f5f00ad45dfeec8e30",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe42411b4b07b99c591855f5f00ad45dfeec8e30/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d2bb681f96fb327b4c4d5b2b113692ca22fdffbf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d2bb681f96fb327b4c4d5b2b113692ca22fdffbf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d2bb681f96fb327b4c4d5b2b113692ca22fdffbf"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 16,
      "deletions": 11
    },
    "files": [
      {
        "sha": "8686012af7e4962316dac0f143028371fe567450",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fe42411b4b07b99c591855f5f00ad45dfeec8e30/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fe42411b4b07b99c591855f5f00ad45dfeec8e30/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=fe42411b4b07b99c591855f5f00ad45dfeec8e30",
        "patch": "@@ -36,17 +36,6 @@ struct MinerTestingSetup : public TestingSetup {\n \n BOOST_FIXTURE_TEST_SUITE(miner_tests, MinerTestingSetup)\n \n-// BOOST_CHECK_EXCEPTION predicates to check the specific validation error\n-class HasReason {\n-public:\n-    explicit HasReason(const std::string& reason) : m_reason(reason) {}\n-    bool operator() (const std::runtime_error& e) const {\n-        return std::string(e.what()).find(m_reason) != std::string::npos;\n-    };\n-private:\n-    const std::string m_reason;\n-};\n-\n static CFeeRate blockMinFeeRate = CFeeRate(DEFAULT_BLOCK_MIN_TX_FEE);\n \n BlockAssembler MinerTestingSetup::AssemblerForTest(const CChainParams& params)"
      },
      {
        "sha": "a09c8c122d63f45a680da817ebe5014fb916ea9d",
        "filename": "src/test/util/setup_common.h",
        "status": "modified",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fe42411b4b07b99c591855f5f00ad45dfeec8e30/src/test/util/setup_common.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fe42411b4b07b99c591855f5f00ad45dfeec8e30/src/test/util/setup_common.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.h?ref=fe42411b4b07b99c591855f5f00ad45dfeec8e30",
        "patch": "@@ -153,4 +153,20 @@ CBlock getBlock13b8a();\n // define an implicit conversion here so that uint256 may be used directly in BOOST_CHECK_*\n std::ostream& operator<<(std::ostream& os, const uint256& num);\n \n+/**\n+ * BOOST_CHECK_EXCEPTION predicates to check the specific validation error.\n+ * Use as\n+ * BOOST_CHECK_EXCEPTION(code that throws, exception type, HasReason(\"foo\"));\n+ */\n+class HasReason {\n+public:\n+    explicit HasReason(const std::string& reason) : m_reason(reason) {}\n+    template <typename E>\n+    bool operator() (const E& e) const {\n+        return std::string(e.what()).find(m_reason) != std::string::npos;\n+    };\n+private:\n+    const std::string m_reason;\n+};\n+\n #endif"
      }
    ]
  },
  {
    "sha": "e0d73573a37bf4b519f6f61e5678572d48a64517",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMGQ3MzU3M2EzN2JmNGI1MTlmNmY2MWU1Njc4NTcyZDQ4YTY0NTE3",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-05-19T13:01:50Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-09-17T20:17:17Z"
      },
      "message": "net: CNetAddr: add support to (un)serialize as ADDRv2\n\nCo-authored-by: Carl Dong <contact@carldong.me>",
      "tree": {
        "sha": "62d7661d4afc81dc8b3547b4d57a31f49fd9cc8f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/62d7661d4afc81dc8b3547b4d57a31f49fd9cc8f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e0d73573a37bf4b519f6f61e5678572d48a64517",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl9jxE0ACgkQVN8G9ktV\ny79osR/7BgGBTUowK+FDaPF3pxE+Z9HEtSrruWqM0EyBmrn5rWuvflfSOvbo2eso\ntyH2VWp7aUgbKKHYiOTZNpaAgYZRVELxWMXORmO8G6wKU0pcM4kB+WhEeNQcDfhe\nX4eN8VL3Wzv/2t+Q0BcXA+EaeQjo9f9YLP9S7jfw2qwo1IzE2XCPe2Kp7+H4aH2X\nelN7DpFAyuRQm/QQCvyoa2aXEA9RIicCbnnE/ojUQ9/qJziBq5TBb4P+v3220UW4\n5oqfK31hEgQAMiIZ8tOP9RQxCLiwGPtgD9N7AdnYwriBZam6Wv2M3Bz5w5A9Te0p\nH0fUEmiH7j319vO6Ud5Sa5ZaGl6iO69wzJFDBqDuY1LORbT59u5TTiVAKg+WOGeR\nQrNVwbv2XtJg4M56CJFD23R8a4iDf3dxs6FFpUXniIfbOvTfKw2mgrJrWLauYD/S\no4ZHGR+TF0s9TkHqtM79CuF/XKwtVKAKVpNLGeFZ6BR5Lq35VhSA5MLJC+SB1lCu\nJsFTmdO1CLUVjiuFbWyDwuU+RIehRQZA94nvz+Y58+uJYsrbbQAJc06AgIQ6O1EH\nTRfK2OOQLVc9d4Bgvy/yO9GsNY9qXsjjVkshcNsF8eT1oU2RLJBrcvC2/npjARl0\nfIM8HFjaeXXXzoaiuvd0fEwG0qexhYydcgHplI+r6jkmNzN/By3QTpH52S/fEwt8\ntYVIF6EGVZpcQidUHr5bPD2aG6ozWOYTnfgtTJ+P3rVT5pzo3E0WKrvXOoDu25pL\nAJBmfMDKhJq86qIW9/ypTuj8fwFjwouSQ1o+QzlRN8n7y4cRBQqE77dd5OtQieCI\n81mmIEC1SlBiKYOlVJKrfdHVgm9+U+abM+GysbBs0peJ8ceqz4TFfC9bBgGMG0h2\n7/bvopjkXuarEthvfyk1o8iCmZy8V7BUgvpwtnb+hmBtCNbG875rXINIS1LllQxl\nbXPbl1u/4Ka/2fCW9eH0kkf6J1UNXrZrFQOHLyRUKBnhIZRtNpMpx+O9GqPYGSeR\n8OWAZitJX45DS7wEsLPF7ob3LbCfCxxkeBg4wrfpOtpbMn7WbVvyYLh42IDMYIZ1\nlQ10fOAQrNhICz8OjGHLnnTSvGm1ymAGX6RwyJizVVK30YfecujYgkVeuh97CGeV\nge/oLSIwPaVdpZIrwk3O3xGH7g9DQsiz/pWvZ7wH+wbJhcuYdAIjtdtMPEa5C4RO\n4xfCKdjrRCXyaVnBJqvsCFL3/s5mM/bU7o6LjqPggGen17K2xLd8juq3HqKYJbZO\nh0UKmSErAiDPh0aPfRvmls2Tn3OpIvIshn7nOGmV6r8232aZ7TKQS+X9k/FUxSQ8\nVEHJ+ptMFBnyvfgfE/oPD0EJclfSHw==\n=HYp0\n-----END PGP SIGNATURE-----",
        "payload": "tree 62d7661d4afc81dc8b3547b4d57a31f49fd9cc8f\nparent fe42411b4b07b99c591855f5f00ad45dfeec8e30\nauthor Vasil Dimov <vd@FreeBSD.org> 1589893310 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1600373837 +0200\n\nnet: CNetAddr: add support to (un)serialize as ADDRv2\n\nCo-authored-by: Carl Dong <contact@carldong.me>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e0d73573a37bf4b519f6f61e5678572d48a64517",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e0d73573a37bf4b519f6f61e5678572d48a64517",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e0d73573a37bf4b519f6f61e5678572d48a64517/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "fe42411b4b07b99c591855f5f00ad45dfeec8e30",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fe42411b4b07b99c591855f5f00ad45dfeec8e30",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/fe42411b4b07b99c591855f5f00ad45dfeec8e30"
      }
    ],
    "stats": {
      "total": 392,
      "additions": 389,
      "deletions": 3
    },
    "files": [
      {
        "sha": "e60c2f15588c03e03eaf5bd4624d32df066792b3",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 0,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e0d73573a37bf4b519f6f61e5678572d48a64517/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e0d73573a37bf4b519f6f61e5678572d48a64517/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=e0d73573a37bf4b519f6f61e5678572d48a64517",
        "patch": "@@ -14,10 +14,65 @@\n #include <algorithm>\n #include <array>\n #include <cstdint>\n+#include <ios>\n #include <iterator>\n #include <tuple>\n \n constexpr size_t CNetAddr::V1_SERIALIZATION_SIZE;\n+constexpr size_t CNetAddr::MAX_ADDRV2_SIZE;\n+\n+CNetAddr::BIP155Network CNetAddr::GetBIP155Network() const\n+{\n+    switch (m_net) {\n+    case NET_IPV4:\n+        return BIP155Network::IPV4;\n+    case NET_IPV6:\n+        return BIP155Network::IPV6;\n+    case NET_ONION:\n+        return BIP155Network::TORV2;\n+    case NET_INTERNAL:   // should have been handled before calling this function\n+    case NET_UNROUTABLE: // m_net is never and should not be set to NET_UNROUTABLE\n+    case NET_MAX:        // m_net is never and should not be set to NET_MAX\n+        assert(false);\n+    } // no default case, so the compiler can warn about missing cases\n+\n+    assert(false);\n+}\n+\n+bool CNetAddr::SetNetFromBIP155Network(uint8_t possible_bip155_net, size_t address_size)\n+{\n+    switch (possible_bip155_net) {\n+    case BIP155Network::IPV4:\n+        if (address_size == ADDR_IPV4_SIZE) {\n+            m_net = NET_IPV4;\n+            return true;\n+        }\n+        throw std::ios_base::failure(\n+            strprintf(\"BIP155 IPv4 address with length %u (should be %u)\", address_size,\n+                      ADDR_IPV4_SIZE));\n+    case BIP155Network::IPV6:\n+        if (address_size == ADDR_IPV6_SIZE) {\n+            m_net = NET_IPV6;\n+            return true;\n+        }\n+        throw std::ios_base::failure(\n+            strprintf(\"BIP155 IPv6 address with length %u (should be %u)\", address_size,\n+                      ADDR_IPV6_SIZE));\n+    case BIP155Network::TORV2:\n+        if (address_size == ADDR_TORV2_SIZE) {\n+            m_net = NET_ONION;\n+            return true;\n+        }\n+        throw std::ios_base::failure(\n+            strprintf(\"BIP155 TORv2 address with length %u (should be %u)\", address_size,\n+                      ADDR_TORV2_SIZE));\n+    }\n+\n+    // Don't throw on addresses with unknown network ids (maybe from the future).\n+    // Instead silently drop them and have the unserialization code consume\n+    // subsequent ones which may be known to us.\n+    return false;\n+}\n \n /**\n  * Construct an unspecified IPv6 network address (::/128)."
      },
      {
        "sha": "08857ae729994f1426df057f53639260837595a9",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 132,
        "deletions": 2,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e0d73573a37bf4b519f6f61e5678572d48a64517/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e0d73573a37bf4b519f6f61e5678572d48a64517/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=e0d73573a37bf4b519f6f61e5678572d48a64517",
        "patch": "@@ -13,12 +13,24 @@\n #include <compat.h>\n #include <prevector.h>\n #include <serialize.h>\n+#include <tinyformat.h>\n+#include <util/strencodings.h>\n+#include <util/string.h>\n \n #include <array>\n #include <cstdint>\n+#include <ios>\n #include <string>\n #include <vector>\n \n+/**\n+ * A flag that is ORed into the protocol version to designate that addresses\n+ * should be serialized in (unserialized from) v2 format (BIP155).\n+ * Make sure that this does not collide with any of the values in `version.h`\n+ * or with `SERIALIZE_TRANSACTION_NO_WITNESS`.\n+ */\n+static const int ADDRV2_FORMAT = 0x20000000;\n+\n /**\n  * A network type.\n  * @note An address may belong to more than one network, for example `10.0.0.1`\n@@ -177,7 +189,11 @@ class CNetAddr\n         template <typename Stream>\n         void Serialize(Stream& s) const\n         {\n-            SerializeV1Stream(s);\n+            if (s.GetVersion() & ADDRV2_FORMAT) {\n+                SerializeV2Stream(s);\n+            } else {\n+                SerializeV1Stream(s);\n+            }\n         }\n \n         /**\n@@ -186,17 +202,53 @@ class CNetAddr\n         template <typename Stream>\n         void Unserialize(Stream& s)\n         {\n-            UnserializeV1Stream(s);\n+            if (s.GetVersion() & ADDRV2_FORMAT) {\n+                UnserializeV2Stream(s);\n+            } else {\n+                UnserializeV1Stream(s);\n+            }\n         }\n \n         friend class CSubNet;\n \n     private:\n+        /**\n+         * BIP155 network ids recognized by this software.\n+         */\n+        enum BIP155Network : uint8_t {\n+            IPV4 = 1,\n+            IPV6 = 2,\n+            TORV2 = 3,\n+        };\n+\n         /**\n          * Size of CNetAddr when serialized as ADDRv1 (pre-BIP155) (in bytes).\n          */\n         static constexpr size_t V1_SERIALIZATION_SIZE = ADDR_IPV6_SIZE;\n \n+        /**\n+         * Maximum size of an address as defined in BIP155 (in bytes).\n+         * This is only the size of the address, not the entire CNetAddr object\n+         * when serialized.\n+         */\n+        static constexpr size_t MAX_ADDRV2_SIZE = 512;\n+\n+        /**\n+         * Get the BIP155 network id of this address.\n+         * Must not be called for IsInternal() objects.\n+         * @returns BIP155 network id\n+         */\n+        BIP155Network GetBIP155Network() const;\n+\n+        /**\n+         * Set `m_net` from the provided BIP155 network id and size after validation.\n+         * @retval true the network was recognized, is valid and `m_net` was set\n+         * @retval false not recognised (from future?) and should be silently ignored\n+         * @throws std::ios_base::failure if the network is one of the BIP155 founding\n+         * networks recognized by this software (id 1..3) and has wrong address size.\n+         */\n+        bool SetNetFromBIP155Network(uint8_t possible_bip155_net, size_t address_size);\n+\n         /**\n          * Serialize in pre-ADDRv2/BIP155 format to an array.\n          * Some addresses (e.g. TORv3) cannot be serialized in pre-BIP155 format.\n@@ -250,6 +302,25 @@ class CNetAddr\n             s << serialized;\n         }\n \n+        /**\n+         * Serialize as ADDRv2 / BIP155.\n+         */\n+        template <typename Stream>\n+        void SerializeV2Stream(Stream& s) const\n+        {\n+            if (IsInternal()) {\n+                // Serialize NET_INTERNAL as embedded in IPv6. We need to\n+                // serialize such addresses from addrman.\n+                s << static_cast<uint8_t>(BIP155Network::IPV6);\n+                s << COMPACTSIZE(ADDR_IPV6_SIZE);\n+                SerializeV1Stream(s);\n+                return;\n+            }\n+\n+            s << static_cast<uint8_t>(GetBIP155Network());\n+            s << m_addr;\n+        }\n+\n         /**\n          * Unserialize from a pre-ADDRv2/BIP155 format from an array.\n          */\n@@ -272,6 +343,65 @@ class CNetAddr\n \n             UnserializeV1Array(serialized);\n         }\n+\n+        /**\n+         * Unserialize from a ADDRv2 / BIP155 format.\n+         */\n+        template <typename Stream>\n+        void UnserializeV2Stream(Stream& s)\n+        {\n+            uint8_t bip155_net;\n+            s >> bip155_net;\n+\n+            size_t address_size;\n+            s >> COMPACTSIZE(address_size);\n+\n+            if (address_size > MAX_ADDRV2_SIZE) {\n+                throw std::ios_base::failure(strprintf(\n+                    \"Address too long: %u > %u\", address_size, MAX_ADDRV2_SIZE));\n+            }\n+\n+            scopeId = 0;\n+\n+            if (SetNetFromBIP155Network(bip155_net, address_size)) {\n+                m_addr.resize(address_size);\n+                s >> MakeSpan(m_addr);\n+\n+                if (m_net != NET_IPV6) {\n+                    return;\n+                }\n+\n+                // Do some special checks on IPv6 addresses.\n+\n+                // Recognize NET_INTERNAL embedded in IPv6, such addresses are not\n+                // gossiped but could be coming from addrman, when unserializing from\n+                // disk.\n+                if (HasPrefix(m_addr, INTERNAL_IN_IPV6_PREFIX)) {\n+                    m_net = NET_INTERNAL;\n+                    memmove(m_addr.data(), m_addr.data() + INTERNAL_IN_IPV6_PREFIX.size(),\n+                            ADDR_INTERNAL_SIZE);\n+                    m_addr.resize(ADDR_INTERNAL_SIZE);\n+                    return;\n+                }\n+\n+                if (!HasPrefix(m_addr, IPV4_IN_IPV6_PREFIX) &&\n+                    !HasPrefix(m_addr, TORV2_IN_IPV6_PREFIX)) {\n+                    return;\n+                }\n+\n+                // IPv4 and TORv2 are not supposed to be embedded in IPv6 (like in V1\n+                // encoding). Unserialize as !IsValid(), thus ignoring them.\n+            } else {\n+                // If we receive an unknown BIP155 network id (from the future?) then\n+                // ignore the address - unserialize as !IsValid().\n+                s.ignore(address_size);\n+            }\n+\n+            // Mimic a default-constructed CNetAddr object which is !IsValid() and thus\n+            // will not be gossiped, but continue reading next addresses from the stream.\n+            m_net = NET_IPV6;\n+            m_addr.assign(ADDR_IPV6_SIZE, 0x0);\n+        }\n };\n \n class CSubNet"
      },
      {
        "sha": "77cb1781a487b6bb0142c7daaab00b39d1b6ce75",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e0d73573a37bf4b519f6f61e5678572d48a64517/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e0d73573a37bf4b519f6f61e5678572d48a64517/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=e0d73573a37bf4b519f6f61e5678572d48a64517",
        "patch": "@@ -14,6 +14,12 @@\n \n #include <tuple>\n \n+/**\n+ * A flag that is ORed into the protocol version to designate that a transaction\n+ * should be (un)serialized without witness data.\n+ * Make sure that this does not collide with any of the values in `version.h`\n+ * or with `ADDRV2_FORMAT`.\n+ */\n static const int SERIALIZE_TRANSACTION_NO_WITNESS = 0x40000000;\n \n /** An outpoint - a combination of a transaction hash and an index n into its vout */"
      },
      {
        "sha": "0bf3aa3e1fae5c360590174e6a7c5b428aba0968",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 193,
        "deletions": 1,
        "changes": 194,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e0d73573a37bf4b519f6f61e5678572d48a64517/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e0d73573a37bf4b519f6f61e5678572d48a64517/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=e0d73573a37bf4b519f6f61e5678572d48a64517",
        "patch": "@@ -10,6 +10,7 @@\n #include <net.h>\n #include <netbase.h>\n #include <serialize.h>\n+#include <span.h>\n #include <streams.h>\n #include <test/util/setup_common.h>\n #include <util/memory.h>\n@@ -20,6 +21,7 @@\n \n #include <boost/test/unit_test.hpp>\n \n+#include <ios>\n #include <memory>\n #include <string>\n \n@@ -261,17 +263,207 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_CHECK_EQUAL(addr.ToString(), \"esffpvrt3wpeaygy.internal\");\n }\n \n-BOOST_AUTO_TEST_CASE(cnetaddr_serialize)\n+BOOST_AUTO_TEST_CASE(cnetaddr_serialize_v1)\n {\n     CNetAddr addr;\n     CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n \n+    s << addr;\n+    BOOST_CHECK_EQUAL(HexStr(s), \"00000000000000000000000000000000\");\n+    s.clear();\n+\n+    BOOST_REQUIRE(LookupHost(\"1.2.3.4\", addr, false));\n+    s << addr;\n+    BOOST_CHECK_EQUAL(HexStr(s), \"00000000000000000000ffff01020304\");\n+    s.clear();\n+\n+    BOOST_REQUIRE(LookupHost(\"1a1b:2a2b:3a3b:4a4b:5a5b:6a6b:7a7b:8a8b\", addr, false));\n+    s << addr;\n+    BOOST_CHECK_EQUAL(HexStr(s), \"1a1b2a2b3a3b4a4b5a5b6a6b7a7b8a8b\");\n+    s.clear();\n+\n+    BOOST_REQUIRE(addr.SetSpecial(\"6hzph5hv6337r6p2.onion\"));\n+    s << addr;\n+    BOOST_CHECK_EQUAL(HexStr(s), \"fd87d87eeb43f1f2f3f4f5f6f7f8f9fa\");\n+    s.clear();\n+\n     addr.SetInternal(\"a\");\n     s << addr;\n     BOOST_CHECK_EQUAL(HexStr(s), \"fd6b88c08724ca978112ca1bbdcafac2\");\n     s.clear();\n }\n \n+BOOST_AUTO_TEST_CASE(cnetaddr_serialize_v2)\n+{\n+    CNetAddr addr;\n+    CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n+    // Add ADDRV2_FORMAT to the version so that the CNetAddr\n+    // serialize method produces an address in v2 format.\n+    s.SetVersion(s.GetVersion() | ADDRV2_FORMAT);\n+\n+    s << addr;\n+    BOOST_CHECK_EQUAL(HexStr(s), \"021000000000000000000000000000000000\");\n+    s.clear();\n+\n+    BOOST_REQUIRE(LookupHost(\"1.2.3.4\", addr, false));\n+    s << addr;\n+    BOOST_CHECK_EQUAL(HexStr(s), \"010401020304\");\n+    s.clear();\n+\n+    BOOST_REQUIRE(LookupHost(\"1a1b:2a2b:3a3b:4a4b:5a5b:6a6b:7a7b:8a8b\", addr, false));\n+    s << addr;\n+    BOOST_CHECK_EQUAL(HexStr(s), \"02101a1b2a2b3a3b4a4b5a5b6a6b7a7b8a8b\");\n+    s.clear();\n+\n+    BOOST_REQUIRE(addr.SetSpecial(\"6hzph5hv6337r6p2.onion\"));\n+    s << addr;\n+    BOOST_CHECK_EQUAL(HexStr(s), \"030af1f2f3f4f5f6f7f8f9fa\");\n+    s.clear();\n+\n+    BOOST_REQUIRE(addr.SetInternal(\"a\"));\n+    s << addr;\n+    BOOST_CHECK_EQUAL(HexStr(s), \"0210fd6b88c08724ca978112ca1bbdcafac2\");\n+    s.clear();\n+}\n+\n+BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n+{\n+    CNetAddr addr;\n+    CDataStream s(SER_NETWORK, PROTOCOL_VERSION);\n+    // Add ADDRV2_FORMAT to the version so that the CNetAddr\n+    // unserialize method expects an address in v2 format.\n+    s.SetVersion(s.GetVersion() | ADDRV2_FORMAT);\n+\n+    // Valid IPv4.\n+    s << MakeSpan(ParseHex(\"01\"          // network type (IPv4)\n+                           \"04\"          // address length\n+                           \"01020304\")); // address\n+    s >> addr;\n+    BOOST_CHECK(addr.IsValid());\n+    BOOST_CHECK(addr.IsIPv4());\n+    BOOST_CHECK_EQUAL(addr.ToString(), \"1.2.3.4\");\n+    BOOST_REQUIRE(s.empty());\n+\n+    // Invalid IPv4, valid length but address itself is shorter.\n+    s << MakeSpan(ParseHex(\"01\"      // network type (IPv4)\n+                           \"04\"      // address length\n+                           \"0102\")); // address\n+    BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure, HasReason(\"end of data\"));\n+    BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n+    s.clear();\n+\n+    // Invalid IPv4, with bogus length.\n+    s << MakeSpan(ParseHex(\"01\"          // network type (IPv4)\n+                           \"05\"          // address length\n+                           \"01020304\")); // address\n+    BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure,\n+                          HasReason(\"BIP155 IPv4 address with length 5 (should be 4)\"));\n+    BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n+    s.clear();\n+\n+    // Invalid IPv4, with extreme length.\n+    s << MakeSpan(ParseHex(\"01\"          // network type (IPv4)\n+                           \"fd0102\"      // address length (513 as CompactSize)\n+                           \"01020304\")); // address\n+    BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure,\n+                          HasReason(\"Address too long: 513 > 512\"));\n+    BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n+    s.clear();\n+\n+    // Valid IPv6.\n+    s << MakeSpan(ParseHex(\"02\"                                  // network type (IPv6)\n+                           \"10\"                                  // address length\n+                           \"0102030405060708090a0b0c0d0e0f10\")); // address\n+    s >> addr;\n+    BOOST_CHECK(addr.IsValid());\n+    BOOST_CHECK(addr.IsIPv6());\n+    BOOST_CHECK_EQUAL(addr.ToString(), \"102:304:506:708:90a:b0c:d0e:f10\");\n+    BOOST_REQUIRE(s.empty());\n+\n+    // Valid IPv6, contains embedded \"internal\".\n+    s << MakeSpan(ParseHex(\n+        \"02\"                                  // network type (IPv6)\n+        \"10\"                                  // address length\n+        \"fd6b88c08724ca978112ca1bbdcafac2\")); // address: 0xfd + sha256(\"bitcoin\")[0:5] +\n+                                              // sha256(name)[0:10]\n+    s >> addr;\n+    BOOST_CHECK(addr.IsInternal());\n+    BOOST_CHECK_EQUAL(addr.ToString(), \"zklycewkdo64v6wc.internal\");\n+    BOOST_REQUIRE(s.empty());\n+\n+    // Invalid IPv6, with bogus length.\n+    s << MakeSpan(ParseHex(\"02\"    // network type (IPv6)\n+                           \"04\"    // address length\n+                           \"00\")); // address\n+    BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure,\n+                          HasReason(\"BIP155 IPv6 address with length 4 (should be 16)\"));\n+    BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n+    s.clear();\n+\n+    // Invalid IPv6, contains embedded IPv4.\n+    s << MakeSpan(ParseHex(\"02\"                                  // network type (IPv6)\n+                           \"10\"                                  // address length\n+                           \"00000000000000000000ffff01020304\")); // address\n+    s >> addr;\n+    BOOST_CHECK(!addr.IsValid());\n+    BOOST_REQUIRE(s.empty());\n+\n+    // Invalid IPv6, contains embedded TORv2.\n+    s << MakeSpan(ParseHex(\"02\"                                  // network type (IPv6)\n+                           \"10\"                                  // address length\n+                           \"fd87d87eeb430102030405060708090a\")); // address\n+    s >> addr;\n+    BOOST_CHECK(!addr.IsValid());\n+    BOOST_REQUIRE(s.empty());\n+\n+    // Valid TORv2.\n+    s << MakeSpan(ParseHex(\"03\"                      // network type (TORv2)\n+                           \"0a\"                      // address length\n+                           \"f1f2f3f4f5f6f7f8f9fa\")); // address\n+    s >> addr;\n+    BOOST_CHECK(addr.IsValid());\n+    BOOST_CHECK(addr.IsTor());\n+    BOOST_CHECK_EQUAL(addr.ToString(), \"6hzph5hv6337r6p2.onion\");\n+    BOOST_REQUIRE(s.empty());\n+\n+    // Invalid TORv2, with bogus length.\n+    s << MakeSpan(ParseHex(\"03\"    // network type (TORv2)\n+                           \"07\"    // address length\n+                           \"00\")); // address\n+    BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure,\n+                          HasReason(\"BIP155 TORv2 address with length 7 (should be 10)\"));\n+    BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n+    s.clear();\n+\n+    // Unknown, with extreme length.\n+    s << MakeSpan(ParseHex(\"aa\"             // network type (unknown)\n+                           \"fe00000002\"     // address length (CompactSize's MAX_SIZE)\n+                           \"01020304050607\" // address\n+                           ));\n+    BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure,\n+                          HasReason(\"Address too long: 33554432 > 512\"));\n+    BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n+    s.clear();\n+\n+    // Unknown, with reasonable length.\n+    s << MakeSpan(ParseHex(\"aa\"       // network type (unknown)\n+                           \"04\"       // address length\n+                           \"01020304\" // address\n+                           ));\n+    s >> addr;\n+    BOOST_CHECK(!addr.IsValid());\n+    BOOST_REQUIRE(s.empty());\n+\n+    // Unknown, with zero length.\n+    s << MakeSpan(ParseHex(\"aa\" // network type (unknown)\n+                           \"00\" // address length\n+                           \"\"   // address\n+                           ));\n+    s >> addr;\n+    BOOST_CHECK(!addr.IsValid());\n+    BOOST_REQUIRE(s.empty());\n+}\n+\n // prior to PR #14728, this test triggers an undefined behavior\n BOOST_AUTO_TEST_CASE(ipv4_peer_with_ipv6_addrMe_test)\n {"
      },
      {
        "sha": "019c3a3ae71fbbcb1861aed57ada199a490b0150",
        "filename": "src/version.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e0d73573a37bf4b519f6f61e5678572d48a64517/src/version.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e0d73573a37bf4b519f6f61e5678572d48a64517/src/version.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/version.h?ref=e0d73573a37bf4b519f6f61e5678572d48a64517",
        "patch": "@@ -38,4 +38,7 @@ static const int INVALID_CB_NO_BAN_VERSION = 70015;\n //! \"wtxidrelay\" command for wtxid-based relay starts with this version\n static const int WTXID_RELAY_VERSION = 70016;\n \n+// Make sure that none of the values above collide with\n+// `SERIALIZE_TRANSACTION_NO_WITNESS` or `ADDRV2_FORMAT`.\n+\n #endif // BITCOIN_VERSION_H"
      }
    ]
  },
  {
    "sha": "7be6ff61875a8d5d2335bff5d1f16ba40557adb0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YmU2ZmY2MTg3NWE4ZDVkMjMzNWJmZjVkMWYxNmJhNDA1NTdhZGIw",
    "commit": {
      "author": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-08-27T09:03:21Z"
      },
      "committer": {
        "name": "Vasil Dimov",
        "email": "vd@FreeBSD.org",
        "date": "2020-09-21T08:13:34Z"
      },
      "message": "net: recognize TORv3/I2P/CJDNS networks\n\nRecognizing addresses from those networks allows us to accept and gossip\nthem, even though we don't know how to connect to them (yet).\n\nCo-authored-by: eriknylund <erik@daychanged.com>",
      "tree": {
        "sha": "a2c60b8c3ad2144f697f334c05b6f6a508743459",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a2c60b8c3ad2144f697f334c05b6f6a508743459"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7be6ff61875a8d5d2335bff5d1f16ba40557adb0",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQQzBAABCAAdFiEE5k2NRWFNsHVF2czBVN8G9ktVy78FAl9oYNUACgkQVN8G9ktV\ny78XIR//adenx+n7P+joVzE0BNrnwcGI9iOzSD5XYLrQCMDnPdgOQ+wXL1+DH4al\naApl7+D5J+0vjWyUwvR/EzPSYrIFsTnYn28DeDFsLJT2As4bRogQdEbg/QTVKwYN\nTSUxGIfnVlrNqJqgVqW1QgT+8MDGI++QTPoD33A6B2ccp/jKYN6kGLhvnD9X/7yi\n6dmGZOE9YqVp+RNX1/XpPjdo71LD9oTDfKokFiSMqimsWor0/rUb/wc9viq2jDJL\nFmFbVHEMkmMCDCBiIEG6YxBi5ombiRmE1Lq6Xk5vtTcvAtBFsVhg8kHwB67iTCmQ\nyNiZlGsgwI/U/D+QchvZeQAbm6q1Y1iyu07P29aVcuXXWQuBrcMvCTMLXfT44LWB\ng38ktNfb3Kzh75NMQVUSNVNh8Moo8DM+0HeGsU1hAGo1tAeJWPGBN8c/CBpPQb8U\nVC6mTLFFkL94JXnT4gVwFA2NqsC6lFQ68IfnnPkiY1o3nr3AfklUirBybglVulUn\nYcNOHNh4hgYU1F50HeA1gDSErHe80MADSxdwe8XIyLVTBt0LUgWtgBPVmEe4Fw07\n2SDyMLXCkJzcMEjOSAP7rtaaEPXio0DAZERAhhSrIJHJiOYByVHovnIW8ZSYkFcw\nsTxC09QNvLw4SAPs4jI1+eft+CQhPYQiDUHn5gjlM19gFLEeK5AU3HIskhMcURvq\nbJYtZHR4+T6cRbu/8rYYWIDW2FDpk9PuSEj4uIMO6imq2r28ImduNxCHBkUHl8n6\nh+GAl11N55aOfvYPhmYImoVHjvDR0kjj4j2xettQab3Bbn2pJnj8TLhdon2Q/tZV\nRpjpXuSp1W/c8Kk4Uz3FGm8hXsfyiZUhFYZ4rqLdL3rDXSj9a5tM36gSfO03jxfK\nT5YueFyqzQ97PHzv947+hD0T+2INLv1gGlZQCTp5DmtGP553jXYE101i0S9g7kT+\nU41JImidRUndmsmmtS+BvrRaTOnjg1YK7DkebgmmPWOrYgjP7rAKgTcnU/B21Ig1\nPd56FHhvrYBTzL9TE/KiC1iHPYA0fn4zVWd4JQDec8yWxxsi+SVyJDrfNRvMf32z\nqztJFCLuiOGzI1lG7LjG82EX/Qa4FR0LaSWwoSEuvbnByXxXz898FLkGdRuMIUEp\nrHkp9WamXxlagIH1fmKS9CWFiCGowhb5LJKwfQ2u7E04ubq9KWjNYwdb0DMmHL6m\nxkXYQM8tYEYYZbLYBZPIzRtrPyDk7i3JoTR1XCygoV/53uLiY8+ZQ9sjePGmP5GM\nTEIrgIxgeC9aSGm9GNkbE6RPAhkrB8dQajgvbSTaacUvjW0XPlk/qVXkclgGL0bf\nM7fjzhdVivWH9JmhSxCZ3jNCRmctlw==\n=gBUI\n-----END PGP SIGNATURE-----",
        "payload": "tree a2c60b8c3ad2144f697f334c05b6f6a508743459\nparent e0d73573a37bf4b519f6f61e5678572d48a64517\nauthor Vasil Dimov <vd@FreeBSD.org> 1598519001 +0200\ncommitter Vasil Dimov <vd@FreeBSD.org> 1600676014 +0200\n\nnet: recognize TORv3/I2P/CJDNS networks\n\nRecognizing addresses from those networks allows us to accept and gossip\nthem, even though we don't know how to connect to them (yet).\n\nCo-authored-by: eriknylund <erik@daychanged.com>\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7be6ff61875a8d5d2335bff5d1f16ba40557adb0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7be6ff61875a8d5d2335bff5d1f16ba40557adb0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7be6ff61875a8d5d2335bff5d1f16ba40557adb0/comments",
    "author": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "vasild",
      "id": 266751,
      "node_id": "MDQ6VXNlcjI2Njc1MQ==",
      "avatar_url": "https://avatars.githubusercontent.com/u/266751?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/vasild",
      "html_url": "https://github.com/vasild",
      "followers_url": "https://api.github.com/users/vasild/followers",
      "following_url": "https://api.github.com/users/vasild/following{/other_user}",
      "gists_url": "https://api.github.com/users/vasild/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/vasild/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/vasild/subscriptions",
      "organizations_url": "https://api.github.com/users/vasild/orgs",
      "repos_url": "https://api.github.com/users/vasild/repos",
      "events_url": "https://api.github.com/users/vasild/events{/privacy}",
      "received_events_url": "https://api.github.com/users/vasild/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e0d73573a37bf4b519f6f61e5678572d48a64517",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e0d73573a37bf4b519f6f61e5678572d48a64517",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e0d73573a37bf4b519f6f61e5678572d48a64517"
      }
    ],
    "stats": {
      "total": 422,
      "additions": 365,
      "deletions": 57
    },
    "files": [
      {
        "sha": "c1acf8b22e4ec91e4235f3760909bd1dec2c948f",
        "filename": "src/crypto/common.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7be6ff61875a8d5d2335bff5d1f16ba40557adb0/src/crypto/common.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7be6ff61875a8d5d2335bff5d1f16ba40557adb0/src/crypto/common.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/common.h?ref=7be6ff61875a8d5d2335bff5d1f16ba40557adb0",
        "patch": "@@ -53,6 +53,13 @@ void static inline WriteLE64(unsigned char* ptr, uint64_t x)\n     memcpy(ptr, (char*)&v, 8);\n }\n \n+uint16_t static inline ReadBE16(const unsigned char* ptr)\n+{\n+    uint16_t x;\n+    memcpy((char*)&x, ptr, 2);\n+    return be16toh(x);\n+}\n+\n uint32_t static inline ReadBE32(const unsigned char* ptr)\n {\n     uint32_t x;"
      },
      {
        "sha": "08714dc2ecdc7b91cb2036aa064588a6c9f63280",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 198,
        "deletions": 45,
        "changes": 243,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7be6ff61875a8d5d2335bff5d1f16ba40557adb0/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7be6ff61875a8d5d2335bff5d1f16ba40557adb0/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=7be6ff61875a8d5d2335bff5d1f16ba40557adb0",
        "patch": "@@ -5,7 +5,10 @@\n \n #include <netaddress.h>\n \n+#include <crypto/common.h>\n+#include <crypto/sha3.h>\n #include <hash.h>\n+#include <prevector.h>\n #include <tinyformat.h>\n #include <util/asmap.h>\n #include <util/strencodings.h>\n@@ -29,7 +32,18 @@ CNetAddr::BIP155Network CNetAddr::GetBIP155Network() const\n     case NET_IPV6:\n         return BIP155Network::IPV6;\n     case NET_ONION:\n-        return BIP155Network::TORV2;\n+        switch (m_addr.size()) {\n+        case ADDR_TORV2_SIZE:\n+            return BIP155Network::TORV2;\n+        case ADDR_TORV3_SIZE:\n+            return BIP155Network::TORV3;\n+        default:\n+            assert(false);\n+        }\n+    case NET_I2P:\n+        return BIP155Network::I2P;\n+    case NET_CJDNS:\n+        return BIP155Network::CJDNS;\n     case NET_INTERNAL:   // should have been handled before calling this function\n     case NET_UNROUTABLE: // m_net is never and should not be set to NET_UNROUTABLE\n     case NET_MAX:        // m_net is never and should not be set to NET_MAX\n@@ -66,6 +80,30 @@ bool CNetAddr::SetNetFromBIP155Network(uint8_t possible_bip155_net, size_t addre\n         throw std::ios_base::failure(\n             strprintf(\"BIP155 TORv2 address with length %u (should be %u)\", address_size,\n                       ADDR_TORV2_SIZE));\n+    case BIP155Network::TORV3:\n+        if (address_size == ADDR_TORV3_SIZE) {\n+            m_net = NET_ONION;\n+            return true;\n+        }\n+        throw std::ios_base::failure(\n+            strprintf(\"BIP155 TORv3 address with length %u (should be %u)\", address_size,\n+                      ADDR_TORV3_SIZE));\n+    case BIP155Network::I2P:\n+        if (address_size == ADDR_I2P_SIZE) {\n+            m_net = NET_I2P;\n+            return true;\n+        }\n+        throw std::ios_base::failure(\n+            strprintf(\"BIP155 I2P address with length %u (should be %u)\", address_size,\n+                      ADDR_I2P_SIZE));\n+    case BIP155Network::CJDNS:\n+        if (address_size == ADDR_CJDNS_SIZE) {\n+            m_net = NET_CJDNS;\n+            return true;\n+        }\n+        throw std::ios_base::failure(\n+            strprintf(\"BIP155 CJDNS address with length %u (should be %u)\", address_size,\n+                      ADDR_CJDNS_SIZE));\n     }\n \n     // Don't throw on addresses with unknown network ids (maybe from the future).\n@@ -92,7 +130,13 @@ void CNetAddr::SetIP(const CNetAddr& ipIn)\n         assert(ipIn.m_addr.size() == ADDR_IPV6_SIZE);\n         break;\n     case NET_ONION:\n-        assert(ipIn.m_addr.size() == ADDR_TORV2_SIZE);\n+        assert(ipIn.m_addr.size() == ADDR_TORV2_SIZE || ipIn.m_addr.size() == ADDR_TORV3_SIZE);\n+        break;\n+    case NET_I2P:\n+        assert(ipIn.m_addr.size() == ADDR_I2P_SIZE);\n+        break;\n+    case NET_CJDNS:\n+        assert(ipIn.m_addr.size() == ADDR_CJDNS_SIZE);\n         break;\n     case NET_INTERNAL:\n         assert(ipIn.m_addr.size() == ADDR_INTERNAL_SIZE);\n@@ -150,24 +194,80 @@ bool CNetAddr::SetInternal(const std::string &name)\n     return true;\n }\n \n+namespace torv3 {\n+// https://gitweb.torproject.org/torspec.git/tree/rend-spec-v3.txt#n2135\n+static constexpr size_t CHECKSUM_LEN = 2;\n+static const unsigned char VERSION[] = {3};\n+static constexpr size_t TOTAL_LEN = ADDR_TORV3_SIZE + CHECKSUM_LEN + sizeof(VERSION);\n+\n+static void Checksum(Span<const uint8_t> addr_pubkey, uint8_t (&checksum)[CHECKSUM_LEN])\n+{\n+    // TORv3 CHECKSUM = H(\".onion checksum\" | PUBKEY | VERSION)[:2]\n+    static const unsigned char prefix[] = \".onion checksum\";\n+    static constexpr size_t prefix_len = 15;\n+\n+    SHA3_256 hasher;\n+\n+    hasher.Write(MakeSpan(prefix).first(prefix_len));\n+    hasher.Write(addr_pubkey);\n+    hasher.Write(VERSION);\n+\n+    uint8_t checksum_full[SHA3_256::OUTPUT_SIZE];\n+\n+    hasher.Finalize(checksum_full);\n+\n+    memcpy(checksum, checksum_full, sizeof(checksum));\n+}\n+\n+}; // namespace torv3\n+\n /**\n- * Parse a TORv2 address and set this object to it.\n+ * Parse a TOR address and set this object to it.\n  *\n  * @returns Whether or not the operation was successful.\n  *\n  * @see CNetAddr::IsTor()\n  */\n-bool CNetAddr::SetSpecial(const std::string &strName)\n+bool CNetAddr::SetSpecial(const std::string& str)\n {\n-    if (strName.size()>6 && strName.substr(strName.size() - 6, 6) == \".onion\") {\n-        std::vector<unsigned char> vchAddr = DecodeBase32(strName.substr(0, strName.size() - 6).c_str());\n-        if (vchAddr.size() != ADDR_TORV2_SIZE) {\n+    static const char* suffix{\".onion\"};\n+    static constexpr size_t suffix_len{6};\n+\n+    if (!ValidAsCString(str) || str.size() <= suffix_len ||\n+        str.substr(str.size() - suffix_len) != suffix) {\n+        return false;\n+    }\n+\n+    bool invalid;\n+    const auto& input = DecodeBase32(str.substr(0, str.size() - suffix_len).c_str(), &invalid);\n+\n+    if (invalid) {\n+        return false;\n+    }\n+\n+    switch (input.size()) {\n+    case ADDR_TORV2_SIZE:\n+        m_net = NET_ONION;\n+        m_addr.assign(input.begin(), input.end());\n+        return true;\n+    case torv3::TOTAL_LEN: {\n+        Span<const uint8_t> input_pubkey{input.data(), ADDR_TORV3_SIZE};\n+        Span<const uint8_t> input_checksum{input.data() + ADDR_TORV3_SIZE, torv3::CHECKSUM_LEN};\n+        Span<const uint8_t> input_version{input.data() + ADDR_TORV3_SIZE + torv3::CHECKSUM_LEN, sizeof(torv3::VERSION)};\n+\n+        uint8_t calculated_checksum[torv3::CHECKSUM_LEN];\n+        torv3::Checksum(input_pubkey, calculated_checksum);\n+\n+        if (input_checksum != calculated_checksum || input_version != torv3::VERSION) {\n             return false;\n         }\n+\n         m_net = NET_ONION;\n-        m_addr.assign(vchAddr.begin(), vchAddr.end());\n+        m_addr.assign(input_pubkey.begin(), input_pubkey.end());\n         return true;\n     }\n+    }\n+\n     return false;\n }\n \n@@ -284,13 +384,21 @@ bool CNetAddr::IsHeNet() const\n }\n \n /**\n- * @returns Whether or not this is a dummy address that maps an onion address\n- *          into IPv6.\n- *\n+ * Check whether this object represents a TOR address.\n  * @see CNetAddr::SetSpecial(const std::string &)\n  */\n bool CNetAddr::IsTor() const { return m_net == NET_ONION; }\n \n+/**\n+ * Check whether this object represents an I2P address.\n+ */\n+bool CNetAddr::IsI2P() const { return m_net == NET_I2P; }\n+\n+/**\n+ * Check whether this object represents a CJDNS address.\n+ */\n+bool CNetAddr::IsCJDNS() const { return m_net == NET_CJDNS; }\n+\n bool CNetAddr::IsLocal() const\n {\n     // IPv4 loopback (127.0.0.0/8 or 0.0.0.0/8)\n@@ -377,28 +485,72 @@ enum Network CNetAddr::GetNetwork() const\n     return m_net;\n }\n \n+static std::string IPv6ToString(Span<const uint8_t> a)\n+{\n+    assert(a.size() == ADDR_IPV6_SIZE);\n+    // clang-format off\n+    return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n+                     ReadBE16(&a[0]),\n+                     ReadBE16(&a[2]),\n+                     ReadBE16(&a[4]),\n+                     ReadBE16(&a[6]),\n+                     ReadBE16(&a[8]),\n+                     ReadBE16(&a[10]),\n+                     ReadBE16(&a[12]),\n+                     ReadBE16(&a[14]));\n+    // clang-format on\n+}\n+\n std::string CNetAddr::ToStringIP() const\n {\n-    if (IsTor())\n-        return EncodeBase32(m_addr) + \".onion\";\n-    if (IsInternal())\n+    switch (m_net) {\n+    case NET_IPV4:\n+    case NET_IPV6: {\n+        CService serv(*this, 0);\n+        struct sockaddr_storage sockaddr;\n+        socklen_t socklen = sizeof(sockaddr);\n+        if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n+            char name[1025] = \"\";\n+            if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name,\n+                             sizeof(name), nullptr, 0, NI_NUMERICHOST))\n+                return std::string(name);\n+        }\n+        if (m_net == NET_IPV4) {\n+            return strprintf(\"%u.%u.%u.%u\", m_addr[0], m_addr[1], m_addr[2], m_addr[3]);\n+        }\n+        return IPv6ToString(m_addr);\n+    }\n+    case NET_ONION:\n+        switch (m_addr.size()) {\n+        case ADDR_TORV2_SIZE:\n+            return EncodeBase32(m_addr) + \".onion\";\n+        case ADDR_TORV3_SIZE: {\n+\n+            uint8_t checksum[torv3::CHECKSUM_LEN];\n+            torv3::Checksum(m_addr, checksum);\n+\n+            // TORv3 onion_address = base32(PUBKEY | CHECKSUM | VERSION) + \".onion\"\n+            prevector<torv3::TOTAL_LEN, uint8_t> address{m_addr.begin(), m_addr.end()};\n+            address.insert(address.end(), checksum, checksum + torv3::CHECKSUM_LEN);\n+            address.insert(address.end(), torv3::VERSION, torv3::VERSION + sizeof(torv3::VERSION));\n+\n+            return EncodeBase32(address) + \".onion\";\n+        }\n+        default:\n+            assert(false);\n+        }\n+    case NET_I2P:\n+        return EncodeBase32(m_addr, false /* don't pad with = */) + \".b32.i2p\";\n+    case NET_CJDNS:\n+        return IPv6ToString(m_addr);\n+    case NET_INTERNAL:\n         return EncodeBase32(m_addr) + \".internal\";\n-    CService serv(*this, 0);\n-    struct sockaddr_storage sockaddr;\n-    socklen_t socklen = sizeof(sockaddr);\n-    if (serv.GetSockAddr((struct sockaddr*)&sockaddr, &socklen)) {\n-        char name[1025] = \"\";\n-        if (!getnameinfo((const struct sockaddr*)&sockaddr, socklen, name, sizeof(name), nullptr, 0, NI_NUMERICHOST))\n-            return std::string(name);\n-    }\n-    if (IsIPv4())\n-        return strprintf(\"%u.%u.%u.%u\", m_addr[0], m_addr[1], m_addr[2], m_addr[3]);\n-    assert(IsIPv6());\n-    return strprintf(\"%x:%x:%x:%x:%x:%x:%x:%x\",\n-                     m_addr[0] << 8 | m_addr[1], m_addr[2] << 8 | m_addr[3],\n-                     m_addr[4] << 8 | m_addr[5], m_addr[6] << 8 | m_addr[7],\n-                     m_addr[8] << 8 | m_addr[9], m_addr[10] << 8 | m_addr[11],\n-                     m_addr[12] << 8 | m_addr[13], m_addr[14] << 8 | m_addr[15]);\n+    case NET_UNROUTABLE: // m_net is never and should not be set to NET_UNROUTABLE\n+    case NET_MAX:        // m_net is never and should not be set to NET_MAX\n+        assert(false);\n+    } // no default case, so the compiler can warn about missing cases\n+\n+    assert(false);\n }\n \n std::string CNetAddr::ToString() const\n@@ -477,21 +629,22 @@ uint32_t CNetAddr::GetLinkedIPv4() const\n     assert(false);\n }\n \n-uint32_t CNetAddr::GetNetClass() const {\n-    uint32_t net_class = NET_IPV6;\n-    if (IsLocal()) {\n-        net_class = 255;\n-    }\n+uint32_t CNetAddr::GetNetClass() const\n+{\n+    // Make sure that if we return NET_IPV6, then IsIPv6() is true. The callers expect that.\n+\n+    // Check for \"internal\" first because such addresses are also !IsRoutable()\n+    // and we don't want to return NET_UNROUTABLE in that case.\n     if (IsInternal()) {\n-        net_class = NET_INTERNAL;\n-    } else if (!IsRoutable()) {\n-        net_class = NET_UNROUTABLE;\n-    } else if (HasLinkedIPv4()) {\n-        net_class = NET_IPV4;\n-    } else if (IsTor()) {\n-        net_class = NET_ONION;\n+        return NET_INTERNAL;\n     }\n-    return net_class;\n+    if (!IsRoutable()) {\n+        return NET_UNROUTABLE;\n+    }\n+    if (HasLinkedIPv4()) {\n+        return NET_IPV4;\n+    }\n+    return m_net;\n }\n \n uint32_t CNetAddr::GetMappedAS(const std::vector<bool> &asmap) const {\n@@ -566,7 +719,7 @@ std::vector<unsigned char> CNetAddr::GetGroup(const std::vector<bool> &asmap) co\n         vchRet.push_back((ipv4 >> 24) & 0xFF);\n         vchRet.push_back((ipv4 >> 16) & 0xFF);\n         return vchRet;\n-    } else if (IsTor()) {\n+    } else if (IsTor() || IsI2P() || IsCJDNS()) {\n         nBits = 4;\n     } else if (IsHeNet()) {\n         // for he.net, use /36 groups\n@@ -791,7 +944,7 @@ std::string CService::ToStringPort() const\n \n std::string CService::ToStringIPPort() const\n {\n-    if (IsIPv4() || IsTor() || IsInternal()) {\n+    if (IsIPv4() || IsTor() || IsI2P() || IsInternal()) {\n         return ToStringIP() + \":\" + ToStringPort();\n     } else {\n         return \"[\" + ToStringIP() + \"]:\" + ToStringPort();"
      },
      {
        "sha": "59f1b87ad3f84ef1de50432e2cf2d8f89e220877",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 32,
        "deletions": 5,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7be6ff61875a8d5d2335bff5d1f16ba40557adb0/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7be6ff61875a8d5d2335bff5d1f16ba40557adb0/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=7be6ff61875a8d5d2335bff5d1f16ba40557adb0",
        "patch": "@@ -51,9 +51,15 @@ enum Network\n     /// IPv6\n     NET_IPV6,\n \n-    /// TORv2\n+    /// TOR (v2 or v3)\n     NET_ONION,\n \n+    /// I2P\n+    NET_I2P,\n+\n+    /// CJDNS\n+    NET_CJDNS,\n+\n     /// A set of addresses that represent the hash of a string or FQDN. We use\n     /// them in CAddrMan to keep track of which DNS seeds were used.\n     NET_INTERNAL,\n@@ -94,6 +100,16 @@ static constexpr size_t ADDR_IPV6_SIZE = 16;\n /// Size of TORv2 address (in bytes).\n static constexpr size_t ADDR_TORV2_SIZE = 10;\n \n+/// Size of TORv3 address (in bytes). This is the length of just the address\n+/// as used in BIP155, without the checksum and the version byte.\n+static constexpr size_t ADDR_TORV3_SIZE = 32;\n+\n+/// Size of I2P address (in bytes).\n+static constexpr size_t ADDR_I2P_SIZE = 32;\n+\n+/// Size of CJDNS address (in bytes).\n+static constexpr size_t ADDR_CJDNS_SIZE = 16;\n+\n /// Size of \"internal\" (NET_INTERNAL) address (in bytes).\n static constexpr size_t ADDR_INTERNAL_SIZE = 10;\n \n@@ -151,6 +167,8 @@ class CNetAddr\n         bool IsRFC6145() const; // IPv6 IPv4-translated address (::FFFF:0:0:0/96) (actually defined in RFC2765)\n         bool IsHeNet() const;   // IPv6 Hurricane Electric - https://he.net (2001:0470::/36)\n         bool IsTor() const;\n+        bool IsI2P() const;\n+        bool IsCJDNS() const;\n         bool IsLocal() const;\n         bool IsRoutable() const;\n         bool IsInternal() const;\n@@ -219,6 +237,9 @@ class CNetAddr\n             IPV4 = 1,\n             IPV6 = 2,\n             TORV2 = 3,\n+            TORV3 = 4,\n+            I2P = 5,\n+            CJDNS = 6,\n         };\n \n         /**\n@@ -245,13 +266,12 @@ class CNetAddr\n          * @retval true the network was recognized, is valid and `m_net` was set\n          * @retval false not recognised (from future?) and should be silently ignored\n          * @throws std::ios_base::failure if the network is one of the BIP155 founding\n-         * networks recognized by this software (id 1..3) and has wrong address size.\n+         * networks (id 1..6) with wrong address size.\n          */\n         bool SetNetFromBIP155Network(uint8_t possible_bip155_net, size_t address_size);\n \n         /**\n          * Serialize in pre-ADDRv2/BIP155 format to an array.\n-         * Some addresses (e.g. TORv3) cannot be serialized in pre-BIP155 format.\n          */\n         void SerializeV1Array(uint8_t (&arr)[V1_SERIALIZATION_SIZE]) const\n         {\n@@ -269,6 +289,9 @@ class CNetAddr\n                 memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n                 return;\n             case NET_ONION:\n+                if (m_addr.size() == ADDR_TORV3_SIZE) {\n+                    break;\n+                }\n                 prefix_size = sizeof(TORV2_IN_IPV6_PREFIX);\n                 assert(prefix_size + m_addr.size() == sizeof(arr));\n                 memcpy(arr, TORV2_IN_IPV6_PREFIX.data(), prefix_size);\n@@ -280,17 +303,21 @@ class CNetAddr\n                 memcpy(arr, INTERNAL_IN_IPV6_PREFIX.data(), prefix_size);\n                 memcpy(arr + prefix_size, m_addr.data(), m_addr.size());\n                 return;\n+            case NET_I2P:\n+                break;\n+            case NET_CJDNS:\n+                break;\n             case NET_UNROUTABLE:\n             case NET_MAX:\n                 assert(false);\n             } // no default case, so the compiler can warn about missing cases\n \n-            assert(false);\n+            // Serialize TORv3, I2P and CJDNS as all-zeros.\n+            memset(arr, 0x0, V1_SERIALIZATION_SIZE);\n         }\n \n         /**\n          * Serialize in pre-ADDRv2/BIP155 format to a stream.\n-         * Some addresses (e.g. TORv3) cannot be serialized in pre-BIP155 format.\n          */\n         template <typename Stream>\n         void SerializeV1Stream(Stream& s) const"
      },
      {
        "sha": "d519eca859932d8116014ba253c1a180c87785c2",
        "filename": "src/test/base32_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7be6ff61875a8d5d2335bff5d1f16ba40557adb0/src/test/base32_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7be6ff61875a8d5d2335bff5d1f16ba40557adb0/src/test/base32_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base32_tests.cpp?ref=7be6ff61875a8d5d2335bff5d1f16ba40557adb0",
        "patch": "@@ -13,10 +13,13 @@ BOOST_AUTO_TEST_CASE(base32_testvectors)\n {\n     static const std::string vstrIn[]  = {\"\",\"f\",\"fo\",\"foo\",\"foob\",\"fooba\",\"foobar\"};\n     static const std::string vstrOut[] = {\"\",\"my======\",\"mzxq====\",\"mzxw6===\",\"mzxw6yq=\",\"mzxw6ytb\",\"mzxw6ytboi======\"};\n+    static const std::string vstrOutNoPadding[] = {\"\",\"my\",\"mzxq\",\"mzxw6\",\"mzxw6yq\",\"mzxw6ytb\",\"mzxw6ytboi\"};\n     for (unsigned int i=0; i<sizeof(vstrIn)/sizeof(vstrIn[0]); i++)\n     {\n         std::string strEnc = EncodeBase32(vstrIn[i]);\n         BOOST_CHECK_EQUAL(strEnc, vstrOut[i]);\n+        strEnc = EncodeBase32(vstrIn[i], false);\n+        BOOST_CHECK_EQUAL(strEnc, vstrOutNoPadding[i]);\n         std::string strDec = DecodeBase32(vstrOut[i]);\n         BOOST_CHECK_EQUAL(strDec, vstrIn[i]);\n     }"
      },
      {
        "sha": "261396cd0c9a3c8b8eec8fedd34265c4a11120c2",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 103,
        "deletions": 1,
        "changes": 104,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7be6ff61875a8d5d2335bff5d1f16ba40557adb0/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7be6ff61875a8d5d2335bff5d1f16ba40557adb0/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=7be6ff61875a8d5d2335bff5d1f16ba40557adb0",
        "patch": "@@ -247,20 +247,48 @@ BOOST_AUTO_TEST_CASE(cnetaddr_basic)\n     BOOST_CHECK_EQUAL(addr.ToString(), \"1122:3344:5566:7788:9900:aabb:ccdd:eeff\");\n \n     // TORv2\n-    addr.SetSpecial(\"6hzph5hv6337r6p2.onion\");\n+    BOOST_REQUIRE(addr.SetSpecial(\"6hzph5hv6337r6p2.onion\"));\n     BOOST_REQUIRE(addr.IsValid());\n     BOOST_REQUIRE(addr.IsTor());\n \n     BOOST_CHECK(!addr.IsBindAny());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"6hzph5hv6337r6p2.onion\");\n \n+    // TORv3\n+    const char* torv3_addr = \"pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion\";\n+    BOOST_REQUIRE(addr.SetSpecial(torv3_addr));\n+    BOOST_REQUIRE(addr.IsValid());\n+    BOOST_REQUIRE(addr.IsTor());\n+\n+    BOOST_CHECK(!addr.IsBindAny());\n+    BOOST_CHECK_EQUAL(addr.ToString(), torv3_addr);\n+\n+    // TORv3, broken, with wrong checksum\n+    BOOST_CHECK(!addr.SetSpecial(\"pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscsad.onion\"));\n+\n+    // TORv3, broken, with wrong version\n+    BOOST_CHECK(!addr.SetSpecial(\"pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscrye.onion\"));\n+\n+    // TORv3, malicious\n+    BOOST_CHECK(!addr.SetSpecial(std::string{\n+        \"pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd\\0wtf.onion\", 66}));\n+\n+    // TOR, bogus length\n+    BOOST_CHECK(!addr.SetSpecial(std::string{\"mfrggzak.onion\"}));\n+\n+    // TOR, invalid base32\n+    BOOST_CHECK(!addr.SetSpecial(std::string{\"mf*g zak.onion\"}));\n+\n     // Internal\n     addr.SetInternal(\"esffpp\");\n     BOOST_REQUIRE(!addr.IsValid()); // \"internal\" is considered invalid\n     BOOST_REQUIRE(addr.IsInternal());\n \n     BOOST_CHECK(!addr.IsBindAny());\n     BOOST_CHECK_EQUAL(addr.ToString(), \"esffpvrt3wpeaygy.internal\");\n+\n+    // Totally bogus\n+    BOOST_CHECK(!addr.SetSpecial(\"totally bogus\"));\n }\n \n BOOST_AUTO_TEST_CASE(cnetaddr_serialize_v1)\n@@ -287,6 +315,11 @@ BOOST_AUTO_TEST_CASE(cnetaddr_serialize_v1)\n     BOOST_CHECK_EQUAL(HexStr(s), \"fd87d87eeb43f1f2f3f4f5f6f7f8f9fa\");\n     s.clear();\n \n+    BOOST_REQUIRE(addr.SetSpecial(\"pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion\"));\n+    s << addr;\n+    BOOST_CHECK_EQUAL(HexStr(s), \"00000000000000000000000000000000\");\n+    s.clear();\n+\n     addr.SetInternal(\"a\");\n     s << addr;\n     BOOST_CHECK_EQUAL(HexStr(s), \"fd6b88c08724ca978112ca1bbdcafac2\");\n@@ -320,6 +353,11 @@ BOOST_AUTO_TEST_CASE(cnetaddr_serialize_v2)\n     BOOST_CHECK_EQUAL(HexStr(s), \"030af1f2f3f4f5f6f7f8f9fa\");\n     s.clear();\n \n+    BOOST_REQUIRE(addr.SetSpecial(\"kpgvmscirrdqpekbqjsvw5teanhatztpp2gl6eee4zkowvwfxwenqaid.onion\"));\n+    s << addr;\n+    BOOST_CHECK_EQUAL(HexStr(s), \"042053cd5648488c4707914182655b7664034e09e66f7e8cbf1084e654eb56c5bd88\");\n+    s.clear();\n+\n     BOOST_REQUIRE(addr.SetInternal(\"a\"));\n     s << addr;\n     BOOST_CHECK_EQUAL(HexStr(s), \"0210fd6b88c08724ca978112ca1bbdcafac2\");\n@@ -435,6 +473,70 @@ BOOST_AUTO_TEST_CASE(cnetaddr_unserialize_v2)\n     BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n     s.clear();\n \n+    // Valid TORv3.\n+    s << MakeSpan(ParseHex(\"04\"                               // network type (TORv3)\n+                           \"20\"                               // address length\n+                           \"79bcc625184b05194975c28b66b66b04\" // address\n+                           \"69f7f6556fb1ac3189a79b40dda32f1f\"\n+                           ));\n+    s >> addr;\n+    BOOST_CHECK(addr.IsValid());\n+    BOOST_CHECK(addr.IsTor());\n+    BOOST_CHECK_EQUAL(addr.ToString(),\n+                      \"pg6mmjiyjmcrsslvykfwnntlaru7p5svn6y2ymmju6nubxndf4pscryd.onion\");\n+    BOOST_REQUIRE(s.empty());\n+\n+    // Invalid TORv3, with bogus length.\n+    s << MakeSpan(ParseHex(\"04\" // network type (TORv3)\n+                           \"00\" // address length\n+                           \"00\" // address\n+                           ));\n+    BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure,\n+                          HasReason(\"BIP155 TORv3 address with length 0 (should be 32)\"));\n+    BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n+    s.clear();\n+\n+    // Valid I2P.\n+    s << MakeSpan(ParseHex(\"05\"                               // network type (I2P)\n+                           \"20\"                               // address length\n+                           \"a2894dabaec08c0051a481a6dac88b64\" // address\n+                           \"f98232ae42d4b6fd2fa81952dfe36a87\"));\n+    s >> addr;\n+    BOOST_CHECK(addr.IsValid());\n+    BOOST_CHECK_EQUAL(addr.ToString(),\n+                      \"ukeu3k5oycgaauneqgtnvselmt4yemvoilkln7jpvamvfx7dnkdq.b32.i2p\");\n+    BOOST_REQUIRE(s.empty());\n+\n+    // Invalid I2P, with bogus length.\n+    s << MakeSpan(ParseHex(\"05\" // network type (I2P)\n+                           \"03\" // address length\n+                           \"00\" // address\n+                           ));\n+    BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure,\n+                          HasReason(\"BIP155 I2P address with length 3 (should be 32)\"));\n+    BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n+    s.clear();\n+\n+    // Valid CJDNS.\n+    s << MakeSpan(ParseHex(\"06\"                               // network type (CJDNS)\n+                           \"10\"                               // address length\n+                           \"fc000001000200030004000500060007\" // address\n+                           ));\n+    s >> addr;\n+    BOOST_CHECK(addr.IsValid());\n+    BOOST_CHECK_EQUAL(addr.ToString(), \"fc00:1:2:3:4:5:6:7\");\n+    BOOST_REQUIRE(s.empty());\n+\n+    // Invalid CJDNS, with bogus length.\n+    s << MakeSpan(ParseHex(\"06\" // network type (CJDNS)\n+                           \"01\" // address length\n+                           \"00\" // address\n+                           ));\n+    BOOST_CHECK_EXCEPTION(s >> addr, std::ios_base::failure,\n+                          HasReason(\"BIP155 CJDNS address with length 1 (should be 16)\"));\n+    BOOST_REQUIRE(!s.empty()); // The stream is not consumed on invalid input.\n+    s.clear();\n+\n     // Unknown, with extreme length.\n     s << MakeSpan(ParseHex(\"aa\"             // network type (unknown)\n                            \"fe00000002\"     // address length (CompactSize's MAX_SIZE)"
      },
      {
        "sha": "3236184b0ba345f2f1cddbce246fd3f98ee12f1b",
        "filename": "src/util/strencodings.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7be6ff61875a8d5d2335bff5d1f16ba40557adb0/src/util/strencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7be6ff61875a8d5d2335bff5d1f16ba40557adb0/src/util/strencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/strencodings.cpp?ref=7be6ff61875a8d5d2335bff5d1f16ba40557adb0",
        "patch": "@@ -201,20 +201,24 @@ std::string DecodeBase64(const std::string& str, bool* pf_invalid)\n     return std::string((const char*)vchRet.data(), vchRet.size());\n }\n \n-std::string EncodeBase32(Span<const unsigned char> input)\n+std::string EncodeBase32(Span<const unsigned char> input, bool pad)\n {\n     static const char *pbase32 = \"abcdefghijklmnopqrstuvwxyz234567\";\n \n     std::string str;\n     str.reserve(((input.size() + 4) / 5) * 8);\n     ConvertBits<8, 5, true>([&](int v) { str += pbase32[v]; }, input.begin(), input.end());\n-    while (str.size() % 8) str += '=';\n+    if (pad) {\n+        while (str.size() % 8) {\n+            str += '=';\n+        }\n+    }\n     return str;\n }\n \n-std::string EncodeBase32(const std::string& str)\n+std::string EncodeBase32(const std::string& str, bool pad)\n {\n-    return EncodeBase32(MakeUCharSpan(str));\n+    return EncodeBase32(MakeUCharSpan(str), pad);\n }\n \n std::vector<unsigned char> DecodeBase32(const char* p, bool* pf_invalid)"
      },
      {
        "sha": "1a217dd12d540ecc36ecff8fd2a2324d110e541a",
        "filename": "src/util/strencodings.h",
        "status": "modified",
        "additions": 14,
        "deletions": 2,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7be6ff61875a8d5d2335bff5d1f16ba40557adb0/src/util/strencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7be6ff61875a8d5d2335bff5d1f16ba40557adb0/src/util/strencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/strencodings.h?ref=7be6ff61875a8d5d2335bff5d1f16ba40557adb0",
        "patch": "@@ -52,8 +52,20 @@ std::string EncodeBase64(Span<const unsigned char> input);\n std::string EncodeBase64(const std::string& str);\n std::vector<unsigned char> DecodeBase32(const char* p, bool* pf_invalid = nullptr);\n std::string DecodeBase32(const std::string& str, bool* pf_invalid = nullptr);\n-std::string EncodeBase32(Span<const unsigned char> input);\n-std::string EncodeBase32(const std::string& str);\n+\n+/**\n+ * Base32 encode.\n+ * If `pad` is true, then the output will be padded with '=' so that its length\n+ * is a multiple of 8.\n+ */\n+std::string EncodeBase32(Span<const unsigned char> input, bool pad = true);\n+\n+/**\n+ * Base32 encode.\n+ * If `pad` is true, then the output will be padded with '=' so that its length\n+ * is a multiple of 8.\n+ */\n+std::string EncodeBase32(const std::string& str, bool pad = true);\n \n void SplitHostPort(std::string in, int& portOut, std::string& hostOut);\n int64_t atoi64(const std::string& str);"
      }
    ]
  }
]