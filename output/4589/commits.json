[
  {
    "sha": "ca15dd5464ba892ec062f908644066a097356596",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYTE1ZGQ1NDY0YmE4OTJlYzA2MmY5MDg2NDQwNjZhMDk3MzU2NTk2",
    "commit": {
      "author": {
        "name": "Whit J",
        "email": "whitj00@users.noreply.github.com",
        "date": "2014-07-26T17:25:28Z"
      },
      "committer": {
        "name": "Whit J",
        "email": "whitj00@users.noreply.github.com",
        "date": "2014-07-26T17:25:28Z"
      },
      "message": "Update build-msw.md",
      "tree": {
        "sha": "dce8b39d58cc9aaa0a740c2ffb746aa004cf9745",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/dce8b39d58cc9aaa0a740c2ffb746aa004cf9745"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ca15dd5464ba892ec062f908644066a097356596",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca15dd5464ba892ec062f908644066a097356596",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ca15dd5464ba892ec062f908644066a097356596",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca15dd5464ba892ec062f908644066a097356596/comments",
    "author": {
      "login": "whitj00",
      "id": 6721742,
      "node_id": "MDQ6VXNlcjY3MjE3NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6721742?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitj00",
      "html_url": "https://github.com/whitj00",
      "followers_url": "https://api.github.com/users/whitj00/followers",
      "following_url": "https://api.github.com/users/whitj00/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitj00/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitj00/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitj00/subscriptions",
      "organizations_url": "https://api.github.com/users/whitj00/orgs",
      "repos_url": "https://api.github.com/users/whitj00/repos",
      "events_url": "https://api.github.com/users/whitj00/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitj00/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "whitj00",
      "id": 6721742,
      "node_id": "MDQ6VXNlcjY3MjE3NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6721742?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitj00",
      "html_url": "https://github.com/whitj00",
      "followers_url": "https://api.github.com/users/whitj00/followers",
      "following_url": "https://api.github.com/users/whitj00/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitj00/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitj00/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitj00/subscriptions",
      "organizations_url": "https://api.github.com/users/whitj00/orgs",
      "repos_url": "https://api.github.com/users/whitj00/repos",
      "events_url": "https://api.github.com/users/whitj00/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitj00/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8047fb04ed38f94782221a9724e59a4300460a5e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8047fb04ed38f94782221a9724e59a4300460a5e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8047fb04ed38f94782221a9724e59a4300460a5e"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "2dbcaa26f746648b6b9411a7ede105353b36726f",
        "filename": "doc/build-msw.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca15dd5464ba892ec062f908644066a097356596/doc/build-msw.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca15dd5464ba892ec062f908644066a097356596/doc/build-msw.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-msw.md?ref=ca15dd5464ba892ec062f908644066a097356596",
        "patch": "@@ -14,7 +14,7 @@ Libraries you need to download separately and build:\n \n \tname            default path               download\n \t--------------------------------------------------------------------------------------------------------------------\n-\tOpenSSL         \\openssl-1.0.1c-mgw        http://www.openssl.org/source/\n+\tOpenSSL         \\openssl-1.0.1h-mgw        http://www.openssl.org/source/\n \tBerkeley DB     \\db-4.8.30.NC-mgw          http://www.oracle.com/technology/software/products/berkeley-db/index.html\n \tBoost           \\boost-1.50.0-mgw          http://www.boost.org/users/download/\n \tminiupnpc       \\miniupnpc-1.6-mgw         http://miniupnp.tuxfamily.org/files/\n@@ -28,7 +28,7 @@ Their licenses:\n \n Versions used in this release:\n \n-\tOpenSSL      1.0.1c\n+\tOpenSSL      1.0.1h\n \tBerkeley DB  4.8.30.NC\n \tBoost        1.50.0\n \tminiupnpc    1.6\n@@ -41,7 +41,7 @@ MSYS shell:\n un-tar sources with MSYS 'tar xfz' to avoid issue with symlinks (OpenSSL ticket 2377)\n change 'MAKE' env. variable from 'C:\\MinGW32\\bin\\mingw32-make.exe' to '/c/MinGW32/bin/mingw32-make.exe'\n \n-\tcd /c/openssl-1.0.1c-mgw\n+\tcd /c/openssl-1.0.1h-mgw\n \t./config\n \tmake\n "
      }
    ]
  },
  {
    "sha": "4ee28bc7f748491cb846c34e5c89e5e7a573a020",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZWUyOGJjN2Y3NDg0OTFjYjg0NmMzNGU1Yzg5ZTVlN2E1NzNhMDIw",
    "commit": {
      "author": {
        "name": "Whit J",
        "email": "whitj00@users.noreply.github.com",
        "date": "2014-07-26T17:33:56Z"
      },
      "committer": {
        "name": "Whit J",
        "email": "whitj00@users.noreply.github.com",
        "date": "2014-07-26T17:33:56Z"
      },
      "message": "Update README.md",
      "tree": {
        "sha": "b48ae3d38a2b590cb9252451889db3cb6b569405",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b48ae3d38a2b590cb9252451889db3cb6b569405"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4ee28bc7f748491cb846c34e5c89e5e7a573a020",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ee28bc7f748491cb846c34e5c89e5e7a573a020",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4ee28bc7f748491cb846c34e5c89e5e7a573a020",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ee28bc7f748491cb846c34e5c89e5e7a573a020/comments",
    "author": {
      "login": "whitj00",
      "id": 6721742,
      "node_id": "MDQ6VXNlcjY3MjE3NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6721742?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitj00",
      "html_url": "https://github.com/whitj00",
      "followers_url": "https://api.github.com/users/whitj00/followers",
      "following_url": "https://api.github.com/users/whitj00/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitj00/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitj00/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitj00/subscriptions",
      "organizations_url": "https://api.github.com/users/whitj00/orgs",
      "repos_url": "https://api.github.com/users/whitj00/repos",
      "events_url": "https://api.github.com/users/whitj00/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitj00/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "whitj00",
      "id": 6721742,
      "node_id": "MDQ6VXNlcjY3MjE3NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6721742?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitj00",
      "html_url": "https://github.com/whitj00",
      "followers_url": "https://api.github.com/users/whitj00/followers",
      "following_url": "https://api.github.com/users/whitj00/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitj00/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitj00/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitj00/subscriptions",
      "organizations_url": "https://api.github.com/users/whitj00/orgs",
      "repos_url": "https://api.github.com/users/whitj00/repos",
      "events_url": "https://api.github.com/users/whitj00/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitj00/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ca15dd5464ba892ec062f908644066a097356596",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca15dd5464ba892ec062f908644066a097356596",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ca15dd5464ba892ec062f908644066a097356596"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "924f5a8a694c5a995f8f46501ba4da89571e36e9",
        "filename": "doc/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ee28bc7f748491cb846c34e5c89e5e7a573a020/doc/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ee28bc7f748491cb846c34e5c89e5e7a573a020/doc/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README.md?ref=4ee28bc7f748491cb846c34e5c89e5e7a573a020",
        "patch": "@@ -72,5 +72,5 @@ The Bitcoin repo's [root README](https://github.com/bitcoin/bitcoin/blob/master/\n License\n ---------------------\n Distributed under the [MIT/X11 software license](http://www.opensource.org/licenses/mit-license.php).\n-This product includes software developed by the OpenSSL Project for use in the [OpenSSL Toolkit](http://www.openssl.org/). This product includes\n+This product includes software developed by the OpenSSL Project for use in the [OpenSSL Toolkit](https://www.openssl.org/). This product includes\n cryptographic software written by Eric Young ([eay@cryptsoft.com](mailto:eay@cryptsoft.com)), and UPnP software written by Thomas Bernard."
      }
    ]
  },
  {
    "sha": "e93c4b0608f752135b7f0dcaa893b02a3b08102f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplOTNjNGIwNjA4Zjc1MjEzNWI3ZjBkY2FhODkzYjAyYTNiMDgxMDJm",
    "commit": {
      "author": {
        "name": "Whit J",
        "email": "whitj00@users.noreply.github.com",
        "date": "2014-07-26T17:42:38Z"
      },
      "committer": {
        "name": "Whit J",
        "email": "whitj00@users.noreply.github.com",
        "date": "2014-07-26T17:42:38Z"
      },
      "message": "Update build-osx.md",
      "tree": {
        "sha": "7faa6736d7acbfd3e4cf8c8c4fb338c426ee0ca7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7faa6736d7acbfd3e4cf8c8c4fb338c426ee0ca7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e93c4b0608f752135b7f0dcaa893b02a3b08102f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e93c4b0608f752135b7f0dcaa893b02a3b08102f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e93c4b0608f752135b7f0dcaa893b02a3b08102f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e93c4b0608f752135b7f0dcaa893b02a3b08102f/comments",
    "author": {
      "login": "whitj00",
      "id": 6721742,
      "node_id": "MDQ6VXNlcjY3MjE3NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6721742?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitj00",
      "html_url": "https://github.com/whitj00",
      "followers_url": "https://api.github.com/users/whitj00/followers",
      "following_url": "https://api.github.com/users/whitj00/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitj00/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitj00/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitj00/subscriptions",
      "organizations_url": "https://api.github.com/users/whitj00/orgs",
      "repos_url": "https://api.github.com/users/whitj00/repos",
      "events_url": "https://api.github.com/users/whitj00/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitj00/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "whitj00",
      "id": 6721742,
      "node_id": "MDQ6VXNlcjY3MjE3NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6721742?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitj00",
      "html_url": "https://github.com/whitj00",
      "followers_url": "https://api.github.com/users/whitj00/followers",
      "following_url": "https://api.github.com/users/whitj00/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitj00/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitj00/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitj00/subscriptions",
      "organizations_url": "https://api.github.com/users/whitj00/orgs",
      "repos_url": "https://api.github.com/users/whitj00/repos",
      "events_url": "https://api.github.com/users/whitj00/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitj00/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4ee28bc7f748491cb846c34e5c89e5e7a573a020",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ee28bc7f748491cb846c34e5c89e5e7a573a020",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4ee28bc7f748491cb846c34e5c89e5e7a573a020"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 1,
      "deletions": 3
    },
    "files": [
      {
        "sha": "6deb106dc312151f093244473ad534dfc371af6d",
        "filename": "doc/build-osx.md",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e93c4b0608f752135b7f0dcaa893b02a3b08102f/doc/build-osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e93c4b0608f752135b7f0dcaa893b02a3b08102f/doc/build-osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-osx.md?ref=e93c4b0608f752135b7f0dcaa893b02a3b08102f",
        "patch": "@@ -30,9 +30,7 @@ available via Homebrew or MacPorts.\n \n You will also need to install [Homebrew](http://brew.sh)\n or [MacPorts](https://www.macports.org/) in order to install library\n-dependencies. It's largely a religious decision which to choose, but, as of\n-December 2012, MacPorts is a little easier because you can just install the\n-dependencies immediately - no other work required. If you're unsure, read\n+dependencies. It's largely a religious decision which to choose. If you're unsure, read\n the instructions through first in order to assess what you want to do.\n Homebrew is a little more popular among those newer to OS X.\n "
      }
    ]
  },
  {
    "sha": "c5299f3973abd32f40acd60514cce1b0f3f5630b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNTI5OWYzOTczYWJkMzJmNDBhY2Q2MDUxNGNjZTFiMGYzZjU2MzBi",
    "commit": {
      "author": {
        "name": "Whit J",
        "email": "whitj00@users.noreply.github.com",
        "date": "2014-07-26T17:47:43Z"
      },
      "committer": {
        "name": "Whit J",
        "email": "whitj00@users.noreply.github.com",
        "date": "2014-07-26T17:47:43Z"
      },
      "message": "Update README_windows.txt",
      "tree": {
        "sha": "0550b4e714c654bd1f6d053f734f7b71c497b05e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0550b4e714c654bd1f6d053f734f7b71c497b05e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c5299f3973abd32f40acd60514cce1b0f3f5630b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c5299f3973abd32f40acd60514cce1b0f3f5630b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c5299f3973abd32f40acd60514cce1b0f3f5630b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c5299f3973abd32f40acd60514cce1b0f3f5630b/comments",
    "author": {
      "login": "whitj00",
      "id": 6721742,
      "node_id": "MDQ6VXNlcjY3MjE3NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6721742?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitj00",
      "html_url": "https://github.com/whitj00",
      "followers_url": "https://api.github.com/users/whitj00/followers",
      "following_url": "https://api.github.com/users/whitj00/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitj00/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitj00/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitj00/subscriptions",
      "organizations_url": "https://api.github.com/users/whitj00/orgs",
      "repos_url": "https://api.github.com/users/whitj00/repos",
      "events_url": "https://api.github.com/users/whitj00/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitj00/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "whitj00",
      "id": 6721742,
      "node_id": "MDQ6VXNlcjY3MjE3NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6721742?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitj00",
      "html_url": "https://github.com/whitj00",
      "followers_url": "https://api.github.com/users/whitj00/followers",
      "following_url": "https://api.github.com/users/whitj00/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitj00/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitj00/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitj00/subscriptions",
      "organizations_url": "https://api.github.com/users/whitj00/orgs",
      "repos_url": "https://api.github.com/users/whitj00/repos",
      "events_url": "https://api.github.com/users/whitj00/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitj00/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e93c4b0608f752135b7f0dcaa893b02a3b08102f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e93c4b0608f752135b7f0dcaa893b02a3b08102f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e93c4b0608f752135b7f0dcaa893b02a3b08102f"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "368f2b45e1fbcae64e1758b6fa56d24af0e56410",
        "filename": "doc/README_windows.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c5299f3973abd32f40acd60514cce1b0f3f5630b/doc/README_windows.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c5299f3973abd32f40acd60514cce1b0f3f5630b/doc/README_windows.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README_windows.txt?ref=c5299f3973abd32f40acd60514cce1b0f3f5630b",
        "patch": "@@ -5,7 +5,7 @@ Copyright (c) 2009-2014 Bitcoin Core Developers\n Distributed under the MIT/X11 software license, see the accompanying\r\n file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n This product includes software developed by the OpenSSL Project for use in\r\n-the OpenSSL Toolkit (http://www.openssl.org/).  This product includes\r\n+the OpenSSL Toolkit (https://www.openssl.org/).  This product includes\r\n cryptographic software written by Eric Young (eay@cryptsoft.com).\r\n \r\n \r"
      }
    ]
  },
  {
    "sha": "ff3047c56406f61af18e69eb16c9404b01b45f8d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZjMwNDdjNTY0MDZmNjFhZjE4ZTY5ZWIxNmM5NDA0YjAxYjQ1Zjhk",
    "commit": {
      "author": {
        "name": "Whit J",
        "email": "whitj00@users.noreply.github.com",
        "date": "2014-07-26T17:51:32Z"
      },
      "committer": {
        "name": "Whit J",
        "email": "whitj00@users.noreply.github.com",
        "date": "2014-07-26T17:51:32Z"
      },
      "message": "Update bitcoin_el_GR.ts",
      "tree": {
        "sha": "ad337cec8e9a60e3db658808b6bcd7b0b353c08e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad337cec8e9a60e3db658808b6bcd7b0b353c08e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ff3047c56406f61af18e69eb16c9404b01b45f8d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff3047c56406f61af18e69eb16c9404b01b45f8d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ff3047c56406f61af18e69eb16c9404b01b45f8d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff3047c56406f61af18e69eb16c9404b01b45f8d/comments",
    "author": {
      "login": "whitj00",
      "id": 6721742,
      "node_id": "MDQ6VXNlcjY3MjE3NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6721742?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitj00",
      "html_url": "https://github.com/whitj00",
      "followers_url": "https://api.github.com/users/whitj00/followers",
      "following_url": "https://api.github.com/users/whitj00/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitj00/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitj00/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitj00/subscriptions",
      "organizations_url": "https://api.github.com/users/whitj00/orgs",
      "repos_url": "https://api.github.com/users/whitj00/repos",
      "events_url": "https://api.github.com/users/whitj00/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitj00/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "whitj00",
      "id": 6721742,
      "node_id": "MDQ6VXNlcjY3MjE3NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6721742?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitj00",
      "html_url": "https://github.com/whitj00",
      "followers_url": "https://api.github.com/users/whitj00/followers",
      "following_url": "https://api.github.com/users/whitj00/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitj00/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitj00/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitj00/subscriptions",
      "organizations_url": "https://api.github.com/users/whitj00/orgs",
      "repos_url": "https://api.github.com/users/whitj00/repos",
      "events_url": "https://api.github.com/users/whitj00/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitj00/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c5299f3973abd32f40acd60514cce1b0f3f5630b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c5299f3973abd32f40acd60514cce1b0f3f5630b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c5299f3973abd32f40acd60514cce1b0f3f5630b"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 3,
      "deletions": 3
    },
    "files": [
      {
        "sha": "ad4c46a293fbfed5d230a91dea0b09d54ea545b9",
        "filename": "src/qt/locale/bitcoin_el_GR.ts",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff3047c56406f61af18e69eb16c9404b01b45f8d/src/qt/locale/bitcoin_el_GR.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff3047c56406f61af18e69eb16c9404b01b45f8d/src/qt/locale/bitcoin_el_GR.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_el_GR.ts?ref=ff3047c56406f61af18e69eb16c9404b01b45f8d",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</translation>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>\n@@ -3388,4 +3388,4 @@ If the file does not exist, create it with owner-readable-only file permissions.\n \u0395\u03ac\u03bd \u03c4\u03bf \u03b1\u03c1\u03c7\u03b5\u03af\u03bf \u03b4\u03b5\u03bd \u03c5\u03c0\u03ac\u03c1\u03c7\u03b5\u03b9, \u03b4\u03b7\u03bc\u03b9\u03bf\u03cd\u03c1\u03b3\u03b7\u03c3\u03b5 \u03c4\u03bf \u03bc\u03b5 \u03b4\u03b9\u03ba\u03b1\u03b9\u03ce\u03bc\u03b1\u03c4\u03b1 \u03bc\u03cc\u03bd\u03bf \u03b3\u03b9\u03b1 \u03b1\u03bd\u03ac\u03b3\u03bd\u03c9\u03c3\u03b7 \u03b1\u03c0\u03cc \u03c4\u03bf\u03bd \u03b4\u03b7\u03bc\u03b9\u03bf\u03c5\u03c1\u03b3\u03cc</translation>\n     </message>\n </context>\n-</TS>\n\\ No newline at end of file\n+</TS>"
      }
    ]
  },
  {
    "sha": "468d4a22956961130124dcc8b42b4c8c5e657cc5",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NjhkNGEyMjk1Njk2MTEzMDEyNGRjYzhiNDJiNGM4YzVlNjU3Y2M1",
    "commit": {
      "author": {
        "name": "whitj00",
        "email": "whitj00@ymail.com",
        "date": "2014-07-26T17:55:23Z"
      },
      "committer": {
        "name": "whitj00",
        "email": "whitj00@ymail.com",
        "date": "2014-07-26T17:55:23Z"
      },
      "message": "Merge branch 'master' of https://github.com/bitcoin/bitcoin into openssl\n\nConflicts:\n\tdoc/build-osx.md",
      "tree": {
        "sha": "129d6e1e247007bc44fc684c1472b610fc536ed6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/129d6e1e247007bc44fc684c1472b610fc536ed6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/468d4a22956961130124dcc8b42b4c8c5e657cc5",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/468d4a22956961130124dcc8b42b4c8c5e657cc5",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/468d4a22956961130124dcc8b42b4c8c5e657cc5",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/468d4a22956961130124dcc8b42b4c8c5e657cc5/comments",
    "author": {
      "login": "whitj00",
      "id": 6721742,
      "node_id": "MDQ6VXNlcjY3MjE3NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6721742?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitj00",
      "html_url": "https://github.com/whitj00",
      "followers_url": "https://api.github.com/users/whitj00/followers",
      "following_url": "https://api.github.com/users/whitj00/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitj00/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitj00/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitj00/subscriptions",
      "organizations_url": "https://api.github.com/users/whitj00/orgs",
      "repos_url": "https://api.github.com/users/whitj00/repos",
      "events_url": "https://api.github.com/users/whitj00/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitj00/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "whitj00",
      "id": 6721742,
      "node_id": "MDQ6VXNlcjY3MjE3NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6721742?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitj00",
      "html_url": "https://github.com/whitj00",
      "followers_url": "https://api.github.com/users/whitj00/followers",
      "following_url": "https://api.github.com/users/whitj00/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitj00/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitj00/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitj00/subscriptions",
      "organizations_url": "https://api.github.com/users/whitj00/orgs",
      "repos_url": "https://api.github.com/users/whitj00/repos",
      "events_url": "https://api.github.com/users/whitj00/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitj00/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ff3047c56406f61af18e69eb16c9404b01b45f8d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ff3047c56406f61af18e69eb16c9404b01b45f8d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ff3047c56406f61af18e69eb16c9404b01b45f8d"
      },
      {
        "sha": "3955c3940eff83518c186facfec6f50545b5aab5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3955c3940eff83518c186facfec6f50545b5aab5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3955c3940eff83518c186facfec6f50545b5aab5"
      }
    ],
    "stats": {
      "total": 13230,
      "additions": 8777,
      "deletions": 4453
    },
    "files": [
      {
        "sha": "4169a2d96c1bc08c81f8c1855ab5c321f53f0dc6",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 10,
        "deletions": 3,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -13,12 +13,19 @@ autom4te.cache/\n config.log\n config.status\n configure\n-src/bitcoin-config.h\n-src/bitcoin-config.h.in\n+src/config/bitcoin-config.h\n+src/config/bitcoin-config.h.in\n+src/config/stamp-h1\n src/build-aux/\n-src/stamp-h1\n share/setup.nsi\n share/qt/Info.plist\n+# Libtool\n+libtool\n+src/m4/libtool.m4\n+src/m4/ltoptions.m4\n+src/m4/ltsugar.m4\n+src/m4/ltversion.m4\n+src/m4/lt~obsolete.m4\n \n src/qt/*.moc\n src/qt/moc_*.cpp"
      },
      {
        "sha": "6219bd75a64975f94aa512cd25d9e5adf047a8f6",
        "filename": "COPYING",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/COPYING",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/COPYING",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/COPYING?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -1,4 +1,4 @@\n-Copyright (c) 2009-2013 Bitcoin Developers\n+Copyright (c) 2009-2014 Bitcoin Developers\n \n Permission is hereby granted, free of charge, to any person obtaining a copy\n of this software and associated documentation files (the \"Software\"), to deal"
      },
      {
        "sha": "3a6a6b6d885305475bf0a3ee9809d59786e05cfc",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -35,6 +35,7 @@ COVERAGE_INFO = baseline_filtered_combined.info baseline.info block_test.info \\\n \n dist-hook:\n \t-$(MAKE) -C $(top_distdir)/src/leveldb clean\n+\t-$(MAKE) -C $(top_distdir)/src/secp256k1 distclean\n \t-$(GIT) archive --format=tar HEAD -- src/version.cpp | $(AMTAR) -C $(top_distdir) -xf -\n \n distcheck-hook:"
      },
      {
        "sha": "081af80dcf1f5a0cb64bc22fa404c794116ea366",
        "filename": "README.md",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -1,7 +1,7 @@\n Bitcoin Core integration/staging tree\n =====================================\n \n-http://www.bitcoin.org\n+https://www.bitcoin.org\n \n Copyright (c) 2009-2014 Bitcoin Core Developers\n \n@@ -15,7 +15,7 @@ out collectively by the network. Bitcoin Core is the name of open source\n software which enables the use of this currency.\n \n For more information, as well as an immediately useable, binary version of\n-the Bitcoin Core software, see http://www.bitcoin.org/en/download.\n+the Bitcoin Core software, see https://www.bitcoin.org/en/download.\n \n License\n -------\n@@ -76,12 +76,14 @@ Translations\n Changes to translations as well as new translations can be submitted to\n [Bitcoin Core's Transifex page](https://www.transifex.com/projects/p/bitcoin/).\n \n-Periodically the translations are pulled from Transifex and merged into the git repository. See the\n+Translations are periodically pulled from Transifex and merged into the git repository. See the\n [translation process](doc/translation_process.md) for details on how this works.\n \n-**Important**: We do not accept translation changes as github pull request because the next\n+**Important**: We do not accept translation changes as GitHub pull requests because the next\n pull from Transifex would automatically overwrite them again.\n \n+Translators should also subscribe to the [mailing list](https://groups.google.com/forum/#!forum/bitcoin-translators).\n+\n Development tips and tricks\n ---------------------------\n "
      },
      {
        "sha": "50b85bcba0638d7628f33fc03360f1c3f53dfe0e",
        "filename": "autogen.sh",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/autogen.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/autogen.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/autogen.sh?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -2,4 +2,7 @@\n set -e\n srcdir=\"$(dirname $0)\"\n cd \"$srcdir\"\n+if [ -z ${LIBTOOLIZE} ] && GLIBTOOLIZE=\"`which glibtoolize 2>/dev/null`\"; then\n+  export LIBTOOLIZE=\"${GLIBTOOLIZE}\"\n+fi\n autoreconf --install --force"
      },
      {
        "sha": "719b06da67a91ef828a3a0bf85ceb64803b2954b",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 24,
        "deletions": 9,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -9,6 +9,7 @@ define(_COPYRIGHT_YEAR, 2014)\n AC_INIT([Bitcoin Core],[_CLIENT_VERSION_MAJOR._CLIENT_VERSION_MINOR._CLIENT_VERSION_REVISION],[info@bitcoin.org],[bitcoin])\n AC_CONFIG_AUX_DIR([src/build-aux])\n AC_CONFIG_MACRO_DIR([src/m4])\n+LT_INIT([disable-shared])\n AC_CANONICAL_HOST\n AH_TOP([#ifndef BITCOIN_CONFIG_H])\n AH_TOP([#define BITCOIN_CONFIG_H])\n@@ -111,7 +112,7 @@ AC_ARG_WITH([protoc-bindir],[AS_HELP_STRING([--with-protoc-bindir=BIN_DIR],[spec\n \n \n AC_CONFIG_SRCDIR([src])\n-AC_CONFIG_HEADERS([src/bitcoin-config.h])\n+AC_CONFIG_HEADERS([src/config/bitcoin-config.h])\n \n dnl Checks for programs.\n AC_PROG_CXX\n@@ -192,10 +193,13 @@ case $host in\n      AC_CHECK_LIB([iphlpapi],      [main],, AC_MSG_ERROR(lib missing))\n      AC_CHECK_LIB([crypt32],      [main],, AC_MSG_ERROR(lib missing))\n \n-     AX_CHECK_LINK_FLAG([[-static]],[LDFLAGS=\"$LDFLAGS -static\"])\n      AX_CHECK_LINK_FLAG([[-static-libgcc]],[LDFLAGS=\"$LDFLAGS -static-libgcc\"])\n      AX_CHECK_LINK_FLAG([[-static-libstdc++]],[LDFLAGS=\"$LDFLAGS -static-libstdc++\"])\n \n+     # -static is interpreted by libtool, where it has a different meaning.\n+     # In libtool-speak, it's -all-static.\n+     AX_CHECK_LINK_FLAG([[-static]],[LDFLAGS=\"$LDFLAGS -static\"; LIBTOOL_LDFLAGS=\"$LIBTOOL_LDFLAGS -all-static\"])\n+\n      AC_PATH_PROG([MAKENSIS], [makensis], none)\n      if test x$MAKENSIS = xnone; then\n        AC_MSG_WARN(\"makensis not found. Cannot create installer.\")\n@@ -254,6 +258,9 @@ case $host in\n \n      CPPFLAGS=\"$CPPFLAGS -DMAC_OSX\"\n      ;;\n+   *linux*)\n+     TARGET_OS=linux\n+     ;;\n    *)\n      ;;\n esac\n@@ -368,7 +375,14 @@ if test x$TARGET_OS = xdarwin; then\n   AX_CHECK_LINK_FLAG([[-Wl,-dead_strip]], [LDFLAGS=\"$LDFLAGS -Wl,-dead_strip\"])\n fi\n \n-AC_CHECK_HEADERS([stdio.h stdlib.h unistd.h strings.h sys/types.h sys/stat.h])\n+AC_CHECK_HEADERS([endian.h stdio.h stdlib.h unistd.h strings.h sys/types.h sys/stat.h sys/select.h])\n+AC_SEARCH_LIBS([getaddrinfo_a], [anl], [AC_DEFINE(HAVE_GETADDRINFO_A, 1, [Define this symbol if you have getaddrinfo_a])])\n+AC_SEARCH_LIBS([inet_pton], [nsl resolv], [AC_DEFINE(HAVE_INET_PTON, 1, [Define this symbol if you have inet_pton])])\n+\n+AC_CHECK_DECLS([le32toh, le64toh, htole32, htole64, be32toh, be64toh, htobe32, htobe64],,,\n+\t\t[#if HAVE_ENDIAN_H\n+                 #include <endian.h>\n+                 #endif])\n \n dnl Check for MSG_NOSIGNAL\n AC_MSG_CHECKING(for MSG_NOSIGNAL)\n@@ -378,6 +392,8 @@ AC_TRY_COMPILE([#include <sys/socket.h>],\n  [ AC_MSG_RESULT(no)]\n )\n \n+AC_SEARCH_LIBS([clock_gettime],[rt])\n+\n LEVELDB_CPPFLAGS=\n LIBLEVELDB=\n LIBMEMENV=\n@@ -446,11 +462,8 @@ dnl after 1.56.\n dnl If neither is available, abort.\n dnl If sleep_for is used, boost_chrono becomes a requirement.\n if test x$ax_cv_boost_chrono = xyes; then\n-dnl Allow passing extra needed dependency libraries for boost-chrono from static gitian build\n-BOOST_CHRONO_LIB=\"$BOOST_CHRONO_LIB $BOOST_CHRONO_EXTRALIBS\"\n-\n TEMP_LIBS=\"$LIBS\"\n-LIBS=\"$LIBS $BOOST_LIBS $BOOST_CHRONO_LIB\"\n+LIBS=\"$BOOST_LIBS $BOOST_CHRONO_LIB $LIBS\"\n TEMP_CPPFLAGS=\"$CPPFLAGS\"\n CPPFLAGS=\"$CPPFLAGS $BOOST_CPPFLAGS\"\n AC_TRY_LINK([\n@@ -472,7 +485,7 @@ fi\n \n if test x$boost_sleep != xyes; then\n TEMP_LIBS=\"$LIBS\"\n-LIBS=\"$LIBS $BOOST_LIBS\"\n+LIBS=\"$BOOST_LIBS $LIBS\"\n TEMP_CPPFLAGS=\"$CPPFLAGS\"\n CPPFLAGS=\"$CPPFLAGS $BOOST_CPPFLAGS\"\n AC_TRY_LINK([\n@@ -512,7 +525,7 @@ BITCOIN_QT_INIT\n \n if test x$use_pkgconfig = xyes; then\n \n-  if test x$PKG_CONFIG == x; then\n+  if test x\"$PKG_CONFIG\" == \"x\"; then\n     AC_MSG_ERROR(pkg-config not found.)\n   fi\n \n@@ -674,6 +687,7 @@ AM_CONDITIONAL([USE_LCOV],[test x$use_lcov == xyes])\n AM_CONDITIONAL([USE_COMPARISON_TOOL],[test x$use_comparison_tool != xno])\n AM_CONDITIONAL([USE_COMPARISON_TOOL_REORG_TESTS],[test x$use_comparison_tool_reorg_test != xno])\n AM_CONDITIONAL([GLIBC_BACK_COMPAT],[test x$use_glibc_compat = xyes])\n+AM_CONDITIONAL([USE_LIBSECP256K1],[test x$use_libsecp256k1 = xyes])\n \n AC_DEFINE(CLIENT_VERSION_MAJOR, _CLIENT_VERSION_MAJOR, [Major version])\n AC_DEFINE(CLIENT_VERSION_MINOR, _CLIENT_VERSION_MINOR, [Minor version])\n@@ -689,6 +703,7 @@ AC_SUBST(CLIENT_VERSION_IS_RELEASE, _CLIENT_VERSION_IS_RELEASE)\n AC_SUBST(COPYRIGHT_YEAR, _COPYRIGHT_YEAR)\n \n \n+AC_SUBST(LIBTOOL_LDFLAGS)\n AC_SUBST(USE_UPNP)\n AC_SUBST(USE_QRCODE)\n AC_SUBST(INCLUDES)"
      },
      {
        "sha": "63b1875d3075870dea071a61a07b91214703b302",
        "filename": "contrib/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/README.md?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -21,11 +21,11 @@ Construct a linear, no-fork, best version of the blockchain.\n \n ### [PyMiner](/contrib/pyminer) ###\n \n-This is a 'getwork' CPU mining client for Bitcoin. It is pure-python, and therefore very, very slow.  The purpose is to provide a reference implementation of a miner, for study.\n+This is a 'getwork' CPU mining client for Bitcoin. It is pure-python, and therefore very, very slow.  The purpose is to provide a reference implementation of a miner in order to study and develop other mining programs.\n \n ### [Qos](/contrib/qos) ###\n \n-A Linux bash script that will set up tc to limit the outgoing bandwidth for connections to the Bitcoin network. This means one can have an always-on bitcoind instance running, and another local bitcoind/bitcoin-qt instance which connects to this node and receives blocks from it.\n+A Linux bash script that will set up traffic control (tc) to limit the outgoing bandwidth for connections to the Bitcoin network. This means one can have an always-on bitcoind instance running, and another local bitcoind/bitcoin-qt instance which connects to this node and receives blocks from it.\n \n ### [Seeds](/contrib/seeds) ###\n Utility to generate the pnSeed[] array that is compiled into the client."
      },
      {
        "sha": "02577b1b6aab76987a71e5aea9c9ce023b4fd66e",
        "filename": "contrib/bitrpc/bitrpc.py",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/bitrpc/bitrpc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/bitrpc/bitrpc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/bitrpc/bitrpc.py?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -22,6 +22,18 @@\n         print access.backupwallet(path)\n     except:\n         print \"\\n---An error occurred---\\n\"\n+        \n+elif cmd == \"encryptwallet\":\n+    try:\n+        pwd = getpass.getpass(prompt=\"Enter passphrase: \")\n+        pwd2 = getpass.getpass(prompt=\"Repeat passphrase: \")\n+        if pwd == pwd2:\n+            access.encryptwallet(pwd)\n+            print \"\\n---Wallet encrypted. Server stopping, restart to run with encrypted wallet---\\n\"\n+        else:\n+            print \"\\n---Passphrases do not match---\\n\"\n+    except:\n+        print \"\\n---An error occurred---\\n\"\n \n elif cmd == \"getaccount\":\n     try:"
      },
      {
        "sha": "ac635f43e0f103191e7594051ecebe2d8a79e5d6",
        "filename": "contrib/debian/control",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/debian/control",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/debian/control",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/control?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -6,6 +6,7 @@ Uploaders: Micah Anderson <micah@debian.org>\n Build-Depends: debhelper,\n  devscripts,\n  automake,\n+ libtool,\n  bash-completion,\n  libboost-system-dev (>> 1.35) | libboost-system1.35-dev,\n  libdb4.8++-dev,\n@@ -38,8 +39,9 @@ Description: peer-to-peer network based digital currency - daemon\n  Full transaction history is stored locally at each client.  This\n  requires 20+ GB of space, slowly growing.\n  .\n- This package provides bitcoind, a combined daemon and CLI tool to\n- interact with the daemon.\n+\n+ This package provides the daemon, bitcoind, and the CLI tool\n+ bitcoin-cli to interact with the daemon.\n \n Package: bitcoin-qt\n Architecture: any"
      },
      {
        "sha": "31cca981e0a2a5bfd86d142ef351524068f0ad50",
        "filename": "contrib/debian/examples/bitcoin.conf",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/debian/examples/bitcoin.conf",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/debian/examples/bitcoin.conf",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/examples/bitcoin.conf?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -10,7 +10,7 @@\n # Run a regression test network\n #regtest=0\n \n-# Connect via a socks4 proxy\n+# Connect via a SOCKS5 proxy\n #proxy=127.0.0.1:9050\n \n ##############################################################"
      },
      {
        "sha": "a023582bc025930bde66119479235c5ee838b19f",
        "filename": "contrib/debian/manpages/bitcoin-qt.1",
        "status": "modified",
        "additions": 1,
        "deletions": 4,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/debian/manpages/bitcoin-qt.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/debian/manpages/bitcoin-qt.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/manpages/bitcoin-qt.1?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -32,10 +32,7 @@ Set database cache size in megabytes (default: 25)\n Specify connection timeout in milliseconds (default: 5000)\n .TP\n \\fB\\-proxy=\\fR<ip:port>\n-Connect through socks proxy\n-.TP\n-\\fB\\-socks=\\fR<n>\n-Select the version of socks proxy to use (4\\-5, default: 5)\n+Connect through SOCKS5 proxy\n .TP\n \\fB\\-tor=\\fR<ip:port>\n Use proxy to reach tor hidden services (default: same as \\fB\\-proxy\\fR)"
      },
      {
        "sha": "8a0078d5d58a28990dc025bbf9834b4367fc2843",
        "filename": "contrib/debian/manpages/bitcoin.conf.5",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/debian/manpages/bitcoin.conf.5",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/debian/manpages/bitcoin.conf.5",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/manpages/bitcoin.conf.5?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -2,7 +2,7 @@\n .SH NAME\n bitcoin.conf \\- bitcoin configuration file\n .SH SYNOPSIS\n-All command-line options (except for '\\-datadir' and '\\-conf') may be specified in a configuration file, and all configuration file options may also be specified on the command line. Command-line options override values set in the configuration file.\n+All command-line options (except for '\\-conf') may be specified in a configuration file, and all configuration file options may also be specified on the command line. Command-line options override values set in the configuration file.\n .TP\n The configuration file is a list of 'setting=value' pairs, one per line, with optional comments starting with the '#' character.\n .TP"
      },
      {
        "sha": "a1b17d6077f4a687dcd63dad55b1cc9724a31d3a",
        "filename": "contrib/debian/manpages/bitcoind.1",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/debian/manpages/bitcoind.1",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/debian/manpages/bitcoind.1",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/debian/manpages/bitcoind.1?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -28,7 +28,7 @@ Start minimized\n Specify data directory\n .TP\n \\fB\\-proxy=\\fR<ip:port>\n-Connect through socks4 proxy\n+Connect through SOCKS5 proxy\n .TP\n \\fB\\-addnode=\\fR<ip>\n Add a node to connect to"
      },
      {
        "sha": "30b0227bdd0e03e09487199dedca1a3a2d492c88",
        "filename": "contrib/gitian-descriptors/gitian-linux.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/gitian-descriptors/gitian-linux.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/gitian-descriptors/gitian-linux.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-linux.yml?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -59,7 +59,7 @@ script: |\n     local: *;\n   };' > $LINKER_SCRIPT\n   function do_configure {\n-      ./configure \"$@\" --enable-upnp-default --prefix=$STAGING --with-protoc-bindir=$STAGING/host/bin --with-qt-bindir=$STAGING/bin --with-boost=$STAGING --disable-maintainer-mode --disable-dependency-tracking PKG_CONFIG_PATH=\"$STAGING/lib/pkgconfig\" CPPFLAGS=\"-I$STAGING/include ${OPTFLAGS}\" LDFLAGS=\"-L$STAGING/lib -Wl,--version-script=$LINKER_SCRIPT ${OPTFLAGS}\" CXXFLAGS=\"-frandom-seed=bitcoin ${OPTFLAGS}\" BOOST_CHRONO_EXTRALIBS=\"-lrt\" --enable-glibc-back-compat\n+      ./configure \"$@\" --enable-upnp-default --prefix=$STAGING --with-protoc-bindir=$STAGING/host/bin --with-qt-bindir=$STAGING/bin --with-boost=$STAGING --disable-maintainer-mode --disable-dependency-tracking PKG_CONFIG_PATH=\"$STAGING/lib/pkgconfig\" CPPFLAGS=\"-I$STAGING/include ${OPTFLAGS}\" LDFLAGS=\"-L$STAGING/lib -Wl,--version-script=$LINKER_SCRIPT ${OPTFLAGS}\" CXXFLAGS=\"-frandom-seed=bitcoin ${OPTFLAGS}\" --enable-glibc-back-compat\n   }\n   #\n   cd bitcoin"
      },
      {
        "sha": "bc3d561c357089535420f7d25d9abcf57dc8838f",
        "filename": "contrib/gitian-descriptors/gitian-osx-bitcoin.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/gitian-descriptors/gitian-osx-bitcoin.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/gitian-descriptors/gitian-osx-bitcoin.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx-bitcoin.yml?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -11,6 +11,7 @@ packages:\n - \"bsdmainutils\"\n - \"pkg-config\"\n - \"p7zip-full\"\n+- \"libtool\"\n \n reference_datetime: \"2013-06-01 00:00:00\"\n remotes:"
      },
      {
        "sha": "fdad28018fa22057d3eed56bc3ddde71c57587f8",
        "filename": "contrib/macdeploy/macdeployqtplus",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/macdeploy/macdeployqtplus",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/macdeploy/macdeployqtplus",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/macdeployqtplus?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -211,6 +211,7 @@ def getFrameworks(binaryPath, verbose):\n     \n     libraries = []\n     for line in otoolLines:\n+        line = line.replace(\"@loader_path\", os.path.dirname(binaryPath))\n         info = FrameworkInfo.fromOtoolLibraryLine(line.strip())\n         if info is not None:\n             if verbose >= 3:\n@@ -307,7 +308,7 @@ def deployFrameworks(frameworks, bundlePath, binaryPath, strip, verbose, deploym\n         if deploymentInfo.qtPath is None and framework.isQtFramework():\n             deploymentInfo.detectQtPath(framework.frameworkDirectory)\n         \n-        if framework.installName.startswith(\"@executable_path\"):\n+        if framework.installName.startswith(\"@executable_path\") or framework.installName.startswith(bundlePath):\n             if verbose >= 2:\n                 print framework.frameworkName, \"already deployed, skipping.\"\n             continue"
      },
      {
        "sha": "706a10b39d113abc58def71ee6311a1865637d53",
        "filename": "contrib/pyminer/pyminer.py",
        "status": "modified",
        "additions": 237,
        "deletions": 220,
        "changes": 457,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/pyminer/pyminer.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/pyminer/pyminer.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/pyminer/pyminer.py?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -5,248 +5,265 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n #\n \n+import sys\n+from multiprocessing import Process\n import time\n-import json\n-import pprint\n-import hashlib\n import struct\n-import re\n+import hashlib\n import base64\n+import re\n import httplib\n-import sys\n-from multiprocessing import Process\n+import json\n \n ERR_SLEEP = 15\n MAX_NONCE = 1000000L\n \n settings = {}\n-pp = pprint.PrettyPrinter(indent=4)\n+\n \n class BitcoinRPC:\n-\tOBJID = 1\n-\n-\tdef __init__(self, host, port, username, password):\n-\t\tauthpair = \"%s:%s\" % (username, password)\n-\t\tself.authhdr = \"Basic %s\" % (base64.b64encode(authpair))\n-\t\tself.conn = httplib.HTTPConnection(host, port, False, 30)\n-\tdef rpc(self, method, params=None):\n-\t\tself.OBJID += 1\n-\t\tobj = { 'version' : '1.1',\n-\t\t\t'method' : method,\n-\t\t\t'id' : self.OBJID }\n-\t\tif params is None:\n-\t\t\tobj['params'] = []\n-\t\telse:\n-\t\t\tobj['params'] = params\n-\t\tself.conn.request('POST', '/', json.dumps(obj),\n-\t\t\t{ 'Authorization' : self.authhdr,\n-\t\t\t  'Content-type' : 'application/json' })\n-\n-\t\tresp = self.conn.getresponse()\n-\t\tif resp is None:\n-\t\t\tprint \"JSON-RPC: no response\"\n-\t\t\treturn None\n-\n-\t\tbody = resp.read()\n-\t\tresp_obj = json.loads(body)\n-\t\tif resp_obj is None:\n-\t\t\tprint \"JSON-RPC: cannot JSON-decode body\"\n-\t\t\treturn None\n-\t\tif 'error' in resp_obj and resp_obj['error'] != None:\n-\t\t\treturn resp_obj['error']\n-\t\tif 'result' not in resp_obj:\n-\t\t\tprint \"JSON-RPC: no result in object\"\n-\t\t\treturn None\n-\n-\t\treturn resp_obj['result']\n-\tdef getblockcount(self):\n-\t\treturn self.rpc('getblockcount')\n-\tdef getwork(self, data=None):\n-\t\treturn self.rpc('getwork', data)\n+    object_id = 1\n+\n+    def __init__(self, host, port, username, password):\n+        authpair = \"{0}:{1}\".format(username, password)\n+        self.authhdr = \"Basic {0}\".format(base64.b64encode(authpair))\n+        self.conn = httplib.HTTPConnection(host, port, strict=False, timeout=30)\n+\n+    def rpc(self, method, params=None):\n+        self.object_id += 1\n+        obj = {'version' : '1.1',\n+               'method' : method,\n+               'id' : self.object_id,\n+               'params' : params or []}\n+\n+        self.conn.request('POST', '/', json.dumps(obj),\n+            { 'Authorization' : self.authhdr,\n+              'Content-type' : 'application/json' })\n+\n+        resp = self.conn.getresponse()\n+\n+        if resp is None:\n+            print(\"JSON-RPC: no response\")\n+            return None\n+\n+        body = resp.read()\n+        resp_obj = json.loads(body)\n+\n+        if resp_obj is None:\n+            print(\"JSON-RPC: cannot JSON-decode body\")\n+            return None\n+\n+        if 'error' in resp_obj and resp_obj['error'] != None:\n+            return resp_obj['error']\n+\n+        if 'result' not in resp_obj:\n+            print(\"JSON-RPC: no result in object\")\n+            return None\n+\n+        return resp_obj['result']\n+\n+    def getblockcount(self):\n+        return self.rpc('getblockcount')\n+\n+    def getwork(self, data=None):\n+        return self.rpc('getwork', data)\n \n def uint32(x):\n-\treturn x & 0xffffffffL\n+    return x & 0xffffffffL\n \n def bytereverse(x):\n-\treturn uint32(( ((x) << 24) | (((x) << 8) & 0x00ff0000) |\n-\t\t\t(((x) >> 8) & 0x0000ff00) | ((x) >> 24) ))\n+    return uint32(( ((x) << 24) | (((x) << 8) & 0x00ff0000) |\n+            (((x) >> 8) & 0x0000ff00) | ((x) >> 24) ))\n \n def bufreverse(in_buf):\n-\tout_words = []\n-\tfor i in range(0, len(in_buf), 4):\n-\t\tword = struct.unpack('@I', in_buf[i:i+4])[0]\n-\t\tout_words.append(struct.pack('@I', bytereverse(word)))\n-\treturn ''.join(out_words)\n+    out_words = []\n+\n+    for i in range(0, len(in_buf), 4):\n+        word = struct.unpack('@I', in_buf[i:i+4])[0]\n+        out_words.append(struct.pack('@I', bytereverse(word)))\n+\n+    return ''.join(out_words)\n \n def wordreverse(in_buf):\n-\tout_words = []\n-\tfor i in range(0, len(in_buf), 4):\n-\t\tout_words.append(in_buf[i:i+4])\n-\tout_words.reverse()\n-\treturn ''.join(out_words)\n+    out_words = []\n+\n+    for i in range(0, len(in_buf), 4):\n+        out_words.append(in_buf[i:i+4])\n+\n+    out_words.reverse()\n+\n+    return ''.join(out_words)\n+\n \n class Miner:\n-\tdef __init__(self, id):\n-\t\tself.id = id\n-\t\tself.max_nonce = MAX_NONCE\n-\n-\tdef work(self, datastr, targetstr):\n-\t\t# decode work data hex string to binary\n-\t\tstatic_data = datastr.decode('hex')\n-\t\tstatic_data = bufreverse(static_data)\n-\n-\t\t# the first 76b of 80b do not change\n-\t\tblk_hdr = static_data[:76]\n-\n-\t\t# decode 256-bit target value\n-\t\ttargetbin = targetstr.decode('hex')\n-\t\ttargetbin = targetbin[::-1]\t# byte-swap and dword-swap\n-\t\ttargetbin_str = targetbin.encode('hex')\n-\t\ttarget = long(targetbin_str, 16)\n-\n-\t\t# pre-hash first 76b of block header\n-\t\tstatic_hash = hashlib.sha256()\n-\t\tstatic_hash.update(blk_hdr)\n-\n-\t\tfor nonce in xrange(self.max_nonce):\n-\n-\t\t\t# encode 32-bit nonce value\n-\t\t\tnonce_bin = struct.pack(\"<I\", nonce)\n-\n-\t\t\t# hash final 4b, the nonce value\n-\t\t\thash1_o = static_hash.copy()\n-\t\t\thash1_o.update(nonce_bin)\n-\t\t\thash1 = hash1_o.digest()\n-\n-\t\t\t# sha256 hash of sha256 hash\n-\t\t\thash_o = hashlib.sha256()\n-\t\t\thash_o.update(hash1)\n-\t\t\thash = hash_o.digest()\n-\n-\t\t\t# quick test for winning solution: high 32 bits zero?\n-\t\t\tif hash[-4:] != '\\0\\0\\0\\0':\n-\t\t\t\tcontinue\n-\n-\t\t\t# convert binary hash to 256-bit Python long\n-\t\t\thash = bufreverse(hash)\n-\t\t\thash = wordreverse(hash)\n-\n-\t\t\thash_str = hash.encode('hex')\n-\t\t\tl = long(hash_str, 16)\n-\n-\t\t\t# proof-of-work test:  hash < target\n-\t\t\tif l < target:\n-\t\t\t\tprint time.asctime(), \"PROOF-OF-WORK found: %064x\" % (l,)\n-\t\t\t\treturn (nonce + 1, nonce_bin)\n-\t\t\telse:\n-\t\t\t\tprint time.asctime(), \"PROOF-OF-WORK false positive %064x\" % (l,)\n-#\t\t\t\treturn (nonce + 1, nonce_bin)\n-\n-\t\treturn (nonce + 1, None)\n-\n-\tdef submit_work(self, rpc, original_data, nonce_bin):\n-\t\tnonce_bin = bufreverse(nonce_bin)\n-\t\tnonce = nonce_bin.encode('hex')\n-\t\tsolution = original_data[:152] + nonce + original_data[160:256]\n-\t\tparam_arr = [ solution ]\n-\t\tresult = rpc.getwork(param_arr)\n-\t\tprint time.asctime(), \"--> Upstream RPC result:\", result\n-\n-\tdef iterate(self, rpc):\n-\t\twork = rpc.getwork()\n-\t\tif work is None:\n-\t\t\ttime.sleep(ERR_SLEEP)\n-\t\t\treturn\n-\t\tif 'data' not in work or 'target' not in work:\n-\t\t\ttime.sleep(ERR_SLEEP)\n-\t\t\treturn\n-\n-\t\ttime_start = time.time()\n-\n-\t\t(hashes_done, nonce_bin) = self.work(work['data'],\n-\t\t\t\t\t\t     work['target'])\n-\n-\t\ttime_end = time.time()\n-\t\ttime_diff = time_end - time_start\n-\n-\t\tself.max_nonce = long(\n-\t\t\t(hashes_done * settings['scantime']) / time_diff)\n-\t\tif self.max_nonce > 0xfffffffaL:\n-\t\t\tself.max_nonce = 0xfffffffaL\n-\n-\t\tif settings['hashmeter']:\n-\t\t\tprint \"HashMeter(%d): %d hashes, %.2f Khash/sec\" % (\n-\t\t\t      self.id, hashes_done,\n-\t\t\t      (hashes_done / 1000.0) / time_diff)\n-\n-\t\tif nonce_bin is not None:\n-\t\t\tself.submit_work(rpc, work['data'], nonce_bin)\n-\n-\tdef loop(self):\n-\t\trpc = BitcoinRPC(settings['host'], settings['port'],\n-\t\t\t\t settings['rpcuser'], settings['rpcpass'])\n-\t\tif rpc is None:\n-\t\t\treturn\n-\n-\t\twhile True:\n-\t\t\tself.iterate(rpc)\n+    def __init__(self, id):\n+        self.id = id\n+        self.max_nonce = MAX_NONCE\n+\n+    def work(self, datastr, targetstr):\n+        # decode work data hex string to binary\n+        static_data = datastr.decode('hex')\n+        static_data = bufreverse(static_data)\n+\n+        # the first 76b of 80b do not change\n+        blk_hdr = static_data[:76]\n+\n+        # decode 256-bit target value\n+        targetbin = targetstr.decode('hex')\n+        targetbin = targetbin[::-1]    # byte-swap and dword-swap\n+        targetbin_str = targetbin.encode('hex')\n+        target = long(targetbin_str, 16)\n+\n+        # pre-hash first 76b of block header\n+        static_hash = hashlib.sha256()\n+        static_hash.update(blk_hdr)\n+\n+        for nonce in xrange(self.max_nonce):\n+\n+            # encode 32-bit nonce value\n+            nonce_bin = struct.pack(\"<I\", nonce)\n+\n+            # hash final 4b, the nonce value\n+            hash1_o = static_hash.copy()\n+            hash1_o.update(nonce_bin)\n+            hash1 = hash1_o.digest()\n+\n+            # sha256 hash of sha256 hash\n+            hash_o = hashlib.sha256()\n+            hash_o.update(hash1)\n+            hash = hash_o.digest()\n+\n+            # quick test for winning solution: high 32 bits zero?\n+            if hash[-4:] != '\\0\\0\\0\\0':\n+                continue\n+\n+            # convert binary hash to 256-bit Python long\n+            hash = bufreverse(hash)\n+            hash = wordreverse(hash)\n+\n+            hash_str = hash.encode('hex')\n+            long_hash = long(hash_str, 16)\n+\n+            # proof-of-work test:  hash < target\n+            if long_hash < target:\n+                print(time.asctime(), \"PROOF-OF-WORK found: \"\n+                                      \"{0:064x}\".format(long_hash))\n+                return (nonce + 1, nonce_bin)\n+            else:\n+                print(time.asctime(), \"PROOF-OF-WORK false\"\n+                                      \"positive {0:064x}\".format(long_hash))\n+\n+        return (nonce + 1, None)\n+\n+    def submit_work(self, rpc, original_data, nonce_bin):\n+        nonce_bin = bufreverse(nonce_bin)\n+        nonce = nonce_bin.encode('hex')\n+        solution = original_data[:152] + nonce + original_data[160:256]\n+        param_arr = [ solution ]\n+        result = rpc.getwork(param_arr)\n+\n+        print(time.asctime(), \"--> Upstream RPC result:\", result)\n+\n+    def iterate(self, rpc):\n+        work = rpc.getwork()\n+\n+        if work is None:\n+            time.sleep(ERR_SLEEP)\n+            return\n+\n+        if 'data' not in work or 'target' not in work:\n+            time.sleep(ERR_SLEEP)\n+            return\n+\n+        time_start = time.time()\n+\n+        (hashes_done, nonce_bin) = self.work(work['data'],\n+                             work['target'])\n+\n+        time_end = time.time()\n+        time_diff = time_end - time_start\n+\n+        self.max_nonce = long(\n+            (hashes_done * settings['scantime']) / time_diff)\n+\n+        if self.max_nonce > 0xfffffffaL:\n+            self.max_nonce = 0xfffffffaL\n+\n+        if settings['hashmeter']:\n+            print(\"HashMeter({:d}): {:d} hashes, {:.2f} Khash/sec\".format(\n+                  self.id, hashes_done, (hashes_done / 1000.0) / time_diff))\n+\n+        if nonce_bin is not None:\n+            self.submit_work(rpc, work['data'], nonce_bin)\n+\n+    def loop(self):\n+        rpc = BitcoinRPC(settings['host'], settings['port'],\n+                 settings['rpcuser'], settings['rpcpass'])\n+\n+        if rpc is not None:\n+\n+            while True:\n+                self.iterate(rpc)\n+        \n+        self.conn.close()\n+\n \n def miner_thread(id):\n-\tminer = Miner(id)\n-\tminer.loop()\n+    miner = Miner(id)\n+    miner.loop()\n \n if __name__ == '__main__':\n-\tif len(sys.argv) != 2:\n-\t\tprint \"Usage: pyminer.py CONFIG-FILE\"\n-\t\tsys.exit(1)\n-\n-\tf = open(sys.argv[1])\n-\tfor line in f:\n-\t\t# skip comment lines\n-\t\tm = re.search('^\\s*#', line)\n-\t\tif m:\n-\t\t\tcontinue\n-\n-\t\t# parse key=value lines\n-\t\tm = re.search('^(\\w+)\\s*=\\s*(\\S.*)$', line)\n-\t\tif m is None:\n-\t\t\tcontinue\n-\t\tsettings[m.group(1)] = m.group(2)\n-\tf.close()\n-\n-\tif 'host' not in settings:\n-\t\tsettings['host'] = '127.0.0.1'\n-\tif 'port' not in settings:\n-\t\tsettings['port'] = 8332\n-\tif 'threads' not in settings:\n-\t\tsettings['threads'] = 1\n-\tif 'hashmeter' not in settings:\n-\t\tsettings['hashmeter'] = 0\n-\tif 'scantime' not in settings:\n-\t\tsettings['scantime'] = 30L\n-\tif 'rpcuser' not in settings or 'rpcpass' not in settings:\n-\t\tprint \"Missing username and/or password in cfg file\"\n-\t\tsys.exit(1)\n-\n-\tsettings['port'] = int(settings['port'])\n-\tsettings['threads'] = int(settings['threads'])\n-\tsettings['hashmeter'] = int(settings['hashmeter'])\n-\tsettings['scantime'] = long(settings['scantime'])\n-\n-\tthr_list = []\n-\tfor thr_id in range(settings['threads']):\n-\t\tp = Process(target=miner_thread, args=(thr_id,))\n-\t\tp.start()\n-\t\tthr_list.append(p)\n-\t\ttime.sleep(1)\t\t\t# stagger threads\n-\n-\tprint settings['threads'], \"mining threads started\"\n-\n-\tprint time.asctime(), \"Miner Starts - %s:%s\" % (settings['host'], settings['port'])\n-\ttry:\n-\t\tfor thr_proc in thr_list:\n-\t\t\tthr_proc.join()\n-\texcept KeyboardInterrupt:\n-\t\tpass\n-\tprint time.asctime(), \"Miner Stops - %s:%s\" % (settings['host'], settings['port'])\n-\n+    if len(sys.argv) != 2:\n+        print(\"Usage: pyminer.py CONFIG-FILE\")\n+        sys.exit(1)\n+\n+    with open(sys.argv[1]) as f:\n+\n+        for line in f:\n+            # skip comment lines\n+            m = re.search('^\\s*#', line)\n+            if m:\n+                continue\n+\n+            # parse key=value lines\n+            m = re.search('^(\\w+)\\s*=\\s*(\\S.*)$', line)\n+            if m is None:\n+                continue\n+\n+            settings[m.group(1)] = m.group(2)\n+\n+    settings.setdefault('host', '127.0.0.1')\n+    settings.setdefault('port', 8332)\n+    settings.setdefault('threads', 1)\n+    settings.setdefault('hashmeter', 0)\n+    settings.setdefault('scantime', 30L)\n+\n+    if 'rpcuser' not in settings or 'rpcpass' not in settings:\n+        print(\"Missing username and/or password in cfg file\")\n+        sys.exit(1)\n+\n+    settings['port'] = int(settings['port'])\n+    settings['threads'] = int(settings['threads'])\n+    settings['hashmeter'] = int(settings['hashmeter'])\n+    settings['scantime'] = long(settings['scantime'])\n+\n+    thread_list = []\n+\n+    for thread_id in range(settings['threads']):\n+        p = Process(target=miner_thread, args=(thread_id,))\n+        p.start()\n+        thread_list.append(p)\n+        time.sleep(1) # stagger threads\n+\n+    print(settings['threads'], \"mining threads started\")\n+\n+    print(time.asctime(), \"Miner Starts - {0}:{1}\".format(settings['host'],\n+                                                          settings['port']))\n+    try:\n+        for thread_process in thread_list:\n+            thread_process.join()\n+    except KeyboardInterrupt:\n+        pass\n+\n+    print(time.asctime(), \"Miner Stops - {0}:{1}\".format(settings['host'],\n+                                                         settings['port']))"
      },
      {
        "sha": "8c038865bdaff592aed1cd8757733b4a78e23507",
        "filename": "contrib/verifysfbinaries/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/verifysfbinaries/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/verifysfbinaries/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verifysfbinaries/README.md?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -1,5 +1,5 @@\n ### Verify SF Binaries ###\n-This script attempts to download the signature file `SHA256SUMS.asc` from SourceForge.\n+This script attempts to download the signature file `SHA256SUMS.asc` from https://bitcoin.org.\n \n It first checks if the signature passes, and then downloads the files specified in the file, and checks if the hashes of these files match those that are specified in the signature file.\n "
      },
      {
        "sha": "3eb46938835cc3e8ad4fe1a6d9b73bad602fc5c0",
        "filename": "contrib/verifysfbinaries/verify.sh",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/verifysfbinaries/verify.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/contrib/verifysfbinaries/verify.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/verifysfbinaries/verify.sh?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -1,6 +1,6 @@\n #!/bin/bash\n \n-###   This script attempts to download the signature file SHA256SUMS.asc from SourceForge\n+###   This script attempts to download the signature file SHA256SUMS.asc from bitcoin.org\n ###   It first checks if the signature passes, and then downloads the files specified in\n ###   the file, and checks if the hashes of these files match those that are specified\n ###   in the signature file.\n@@ -18,11 +18,11 @@ WORKINGDIR=\"/tmp/bitcoin\"\n TMPFILE=\"hashes.tmp\"\n \n #this URL is used if a version number is not specified as an argument to the script\n-SIGNATUREFILE=\"http://downloads.sourceforge.net/project/bitcoin/Bitcoin/bitcoin-0.9.0rc1/SHA256SUMS.asc\"\n+SIGNATUREFILE=\"https://bitcoin.org/bin/0.9.2.1/SHA256SUMS.asc\"\n \n SIGNATUREFILENAME=\"SHA256SUMS.asc\"\n RCSUBDIR=\"test/\"\n-BASEDIR=\"http://downloads.sourceforge.net/project/bitcoin/Bitcoin/\"\n+BASEDIR=\"https://bitcoin.org/bin/\"\n VERSIONPREFIX=\"bitcoin-\"\n RCVERSIONSTRING=\"rc\"\n \n@@ -62,7 +62,7 @@ WGETOUT=$(wget -N \"$BASEDIR$SIGNATUREFILENAME\" 2>&1)\n #and then see if wget completed successfully\n if [ $? -ne 0 ]; then\n    echo \"Error: couldn't fetch signature file. Have you specified the version number in the following format?\"\n-   echo \"[bitcoin-]<version>-[rc[0-9]] (example: bitcoin-0.7.1-rc1)\"\n+   echo \"[bitcoin-]<version>-[rc[0-9]] (example: bitcoin-0.9.2-rc1)\"\n    echo \"wget output:\"\n    echo \"$WGETOUT\"|sed 's/^/\\t/g'\n    exit 2"
      },
      {
        "sha": "6b8ea43134e58262c8333f690e5c0c6627182f8e",
        "filename": "doc/build-osx.md",
        "status": "modified",
        "additions": 13,
        "deletions": 9,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/build-osx.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/build-osx.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-osx.md?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -22,17 +22,22 @@ Xcode 4.3 or later, you'll need to install its command line tools. This can\n be done in `Xcode > Preferences > Downloads > Components` and generally must\n be re-done or updated every time Xcode is updated.\n \n-There's an assumption that you already have `git` installed, as well. If\n+There's also an assumption that you already have `git` installed. If\n not, it's the path of least resistance to install [Github for Mac](https://mac.github.com/)\n (OS X 10.7+) or\n [Git for OS X](https://code.google.com/p/git-osx-installer/). It is also\n available via Homebrew or MacPorts.\n \n You will also need to install [Homebrew](http://brew.sh)\n or [MacPorts](https://www.macports.org/) in order to install library\n+<<<<<<< HEAD\n dependencies. It's largely a religious decision which to choose. If you're unsure, read\n the instructions through first in order to assess what you want to do.\n Homebrew is a little more popular among those newer to OS X.\n+=======\n+dependencies. It's largely a religious decision which to choose, however, Homebrew\n+is now used for building release versions.\n+>>>>>>> 3955c3940eff83518c186facfec6f50545b5aab5\n \n The installation of the actual dependencies is covered in the Instructions\n sections below.\n@@ -42,9 +47,7 @@ Instructions: MacPorts\n \n ### Install dependencies\n \n-Installing the dependencies using MacPorts is very straightforward.\n-\n-    sudo port install boost db48@+no_java openssl miniupnpc autoconf pkgconfig automake\n+    sudo port install boost db48@+no_java openssl miniupnpc autoconf pkgconfig automake libtool\n \n Optional: install Qt4\n \n@@ -72,13 +75,13 @@ Instructions: Homebrew\n \n #### Install dependencies using Homebrew\n \n-        brew install autoconf automake berkeley-db4 boost miniupnpc openssl pkg-config protobuf qt\n+        brew install autoconf automake libtool berkeley-db4 boost miniupnpc openssl pkg-config protobuf qt\n \n Note: After you have installed the dependencies, you should check that the Homebrew installed version of OpenSSL is the one available for compilation. You can check this by typing\n \n         openssl version\n \n-into Terminal. You should see OpenSSL 1.0.1f 6 Jan 2014.\n+into Terminal. You should see OpenSSL 1.0.1h 5 Jun 2014.\n \n If not, you can ensure that the Homebrew OpenSSL is correctly linked by running\n \n@@ -101,7 +104,7 @@ PATH.\n         ./configure\n         make\n \n-3.  It is a good idea to build and run the unit tests, too:\n+3.  It is also a good idea to build and run the unit tests:\n \n         make check\n \n@@ -129,7 +132,7 @@ For MacPorts, that means editing your macports.conf and setting\n ... and then uninstalling and re-installing, or simply rebuilding, all ports.\n \n As of December 2012, the `boost` port does not obey `macosx_deployment_target`.\n-Download `http://gavinandresen-bitcoin.s3.amazonaws.com/boost_macports_fix.zip`\n+Download `https://gavinandresen-bitcoin.s3.amazonaws.com/boost_macports_fix.zip`\n for a fix.\n \n Once dependencies are compiled, see release-process.md for how the Bitcoin-Qt.app\n@@ -147,13 +150,14 @@ commands:\n     echo -e \"rpcuser=bitcoinrpc\\nrpcpassword=$(xxd -l 16 -p /dev/urandom)\" > \"/Users/${USER}/Library/Application Support/Bitcoin/bitcoin.conf\"\n     chmod 600 \"/Users/${USER}/Library/Application Support/Bitcoin/bitcoin.conf\"\n \n-When next you run it, it will start downloading the blockchain, but it won't\n+The next time you run it, it will start downloading the blockchain, but it won't\n output anything while it's doing this. This process may take several hours;\n you can monitor its process by looking at the debug.log file, like this:\n \n     tail -f $HOME/Library/Application\\ Support/Bitcoin/debug.log\n \n Other commands:\n+-------\n \n     ./bitcoind -daemon # to start the bitcoin daemon.\n     ./bitcoin-cli --help  # for a list of command-line options."
      },
      {
        "sha": "0f381d56c561da5f860742fac1ebf8cdc9097300",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 4,
        "deletions": 7,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -61,10 +61,8 @@ Dependency Build Instructions: Ubuntu & Debian\n ----------------------------------------------\n Build requirements:\n \n-\tsudo apt-get install build-essential\n-\tsudo apt-get install libtool autotools-dev autoconf\n-\tsudo apt-get install libssl-dev\n-\n+\tsudo apt-get install build-essential libtool autotools-dev autoconf pkg-config libssl-dev\n+\t\n for Ubuntu 12.04 and later:\n \n \tsudo apt-get install libboost-all-dev\n@@ -93,10 +91,9 @@ To enable the change run\n \n \tsudo apt-get update\n \n-for other Ubuntu & Debian:\n+for other Debian & Ubuntu (with ppa):\n \n-\tsudo apt-get install libdb4.8-dev\n-\tsudo apt-get install libdb4.8++-dev\n+\tsudo apt-get install libdb4.8-dev libdb4.8++-dev\n \n Optional:\n "
      },
      {
        "sha": "2f332e92f0e938e865badd3c5d4bf989c98f0417",
        "filename": "doc/coding.md",
        "status": "modified",
        "additions": 48,
        "deletions": 27,
        "changes": 75,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/coding.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/coding.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/coding.md?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -4,44 +4,65 @@ Coding\n Please be consistent with the existing coding style.\n \n Block style:\n-\n-\tbool Function(char* psz, int n)\n-\t{\n-\t    // Comment summarising what this section of code does\n-\t    for (int i = 0; i < n; i++)\n-\t    {\n-\t        // When something fails, return early\n-\t        if (!Something())\n-\t            return false;\n-\t        ...\n-\t    }\n-\t\n-\t    // Success return is usually at the end\n-\t    return true;\n-\t}\n-\n+```c++\n+    bool Function(char* psz, int n)\n+    {\n+        // Comment summarising what this section of code does\n+        for (int i = 0; i < n; i++)\n+        {\n+            // When something fails, return early\n+            if (!Something())\n+                return false;\n+            ...\n+        }\n+\n+        // Success return is usually at the end\n+        return true;\n+    }\n+```\n - ANSI/Allman block style\n - 4 space indenting, no tabs\n - No extra spaces inside parenthesis; please don't do ( this )\n - No space after function names, one space after if, for and while\n+- Includes need to be ordered alphabetically, separate own and foreign headers with a new-line (example key.cpp):\n+```c++\n+#include \"key.h\"\n+\n+#include \"crypto/sha2.h\"\n+#include \"util.h\"\n \n+#include <openssl/foo.h>\n+```\n+- Class or struct keywords in header files need to be ordered alphabetically:\n+```c++\n+class CAlpha;\n+class CBeta;\n+```\n+- When using namespace keyword use the following form:\n+```c++\n+namespace Foo {\n+\n+...\n+\n+} // Foo\n+```\n Variable names begin with the type in lowercase, like nSomeVariable.\n Please don't put the first word of the variable name in lowercase like\n someVariable.\n \n Common types:\n \n-\tn       integer number: short, unsigned short, int, unsigned int, int64, uint64, sometimes char if used as a number\n-\td       double, float\n-\tf       flag\n-\thash    uint256\n-\tp       pointer or array, one p for each level of indirection\n-\tpsz     pointer to null terminated string\n-\tstr     string object\n-\tv       vector or similar list objects\n-\tmap     map or multimap\n-\tset     set or multiset\n-\tbn      CBigNum\n+    n       integer number: short, unsigned short, int, unsigned int, int64, uint64, sometimes char if used as a number\n+    d       double, float\n+    f       flag\n+    hash    uint256\n+    p       pointer or array, one p for each level of indirection\n+    psz     pointer to null terminated string\n+    str     string object\n+    v       vector or similar list objects\n+    map     map or multimap\n+    set     set or multiset\n+    bn      CBigNum\n \n Doxygen comments\n -----------------"
      },
      {
        "sha": "b356a5d88d8d28bae1f683b8c17448e409ee162f",
        "filename": "doc/gitian-building.md",
        "status": "modified",
        "additions": 17,
        "deletions": 18,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/gitian-building.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/gitian-building.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/gitian-building.md?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -4,8 +4,8 @@ Gitian building\n *Setup instructions for a gitian build of Bitcoin using a Debian VM or physical system.*\n \n Gitian is the deterministic build process that is used to build the Bitcoin\n-Core executables [1]. It provides a way to be reasonably sure that the\n-executables are really built from source on github. It also makes sure that\n+Core executables. It provides a way to be reasonably sure that the\n+executables are really built from source on GitHub. It also makes sure that\n the same, tested dependencies are used and statically built into the executable.\n \n Multiple developers build the source code by following a specific descriptor\n@@ -17,9 +17,6 @@ More independent gitian builders are needed, which is why I wrote this\n guide. It is preferred to follow these steps yourself instead of using someone else's\n VM image to avoid 'contaminating' the build.\n \n-[1] For all platforms except for MacOSX, at this point. Work for deterministic\n-builds for Mac is under way here: https://github.com/theuni/osx-cross-depends .\n-\n Table of Contents\n ------------------\n \n@@ -38,7 +35,7 @@ Preparing the Gitian builder host\n ---------------------------------\n \n The first step is to prepare the host environment that will be used to perform the Gitian builds.\n-In this guide it is explained how to set up the environment, and how to get the builds started.\n+This guide explains how to set up the environment, and how to start the builds.\n \n Debian Linux was chosen as the host distribution because it has a lightweight install (in contrast to Ubuntu) and is readily available.\n Any kind of virtualization can be used, for example:\n@@ -134,7 +131,7 @@ and proceed, just press `Enter`. To select a different button, press `Tab`.\n \n ![](gitian-building/debian_install_5_configure_the_network.png)\n \n-- Choose a root password and enter it twice (and remember it for later) \n+- Choose a root password and enter it twice (remember it for later) \n \n ![](gitian-building/debian_install_6a_set_up_root_password.png)\n \n@@ -143,7 +140,7 @@ and proceed, just press `Enter`. To select a different button, press `Tab`.\n ![](gitian-building/debian_install_7_set_up_user_fullname.png)\n ![](gitian-building/debian_install_8_set_up_username.png)\n \n-- Choose a user password and enter it twice (and remember it for later) \n+- Choose a user password and enter it twice (remember it for later) \n \n ![](gitian-building/debian_install_9_user_password.png)\n \n@@ -236,7 +233,7 @@ adduser debian sudo\n When you get a colorful screen with a question about the 'LXC directory', just\n go with the default (`/var/lib/lxc`).\n \n-Then set up LXC and the rest with the following is a complex jumble of settings and workarounds:\n+Then set up LXC and the rest with the following, which is a complex jumble of settings and workarounds:\n \n ```bash\n # the version of lxc-start in Debian 7.4 needs to run as root, so make sure\n@@ -280,7 +277,7 @@ cd ..\n \n **Note**: When sudo asks for a password, enter the password for the user *debian* not for *root*.\n \n-Clone the git repositories for bitcoin and gitian and then checkout the bitcoin version that you are willing to build.\n+Clone the git repositories for bitcoin and gitian and then checkout the bitcoin version that you want to build.\n \n ```bash\n git clone https://github.com/devrandom/gitian-builder.git\n@@ -319,10 +316,10 @@ you will find a list of `wget` commands that can be executed to get the dependen\n \n I needed to add `--no-check-certificate` to the OpenSSL wget line to make it work.\n Likely this is because the ca-certificates in Debian 7.4 is fairly old. This does not create a \n-security issue as the gitian descriptors check integrity of the input archives and refuse to work\n+security issue as the gitian descriptors check the integrity of the input archives and refuse to work\n if any one is corrupted.\n \n-After downloading the archives, execute the `gbuild` commends to build the dependencies.\n+After downloading the archives, execute the `gbuild` commands to build the dependencies.\n This can take a long time, but only has to be done when the dependencies change, for example\n to upgrade the used version.\n \n@@ -339,7 +336,7 @@ tail -f var/build.log\n Building Bitcoin\n ----------------\n \n-To build Bitcoin (for Linux and/or Windows) just follow the steps under 'perform\n+To build Bitcoin (for Linux, OSX and Windows) just follow the steps under 'perform\n gitian builds' in [doc/release-process.md](release-process.md) in the bitcoin repository.\n \n Output from `gbuild` will look something like\n@@ -372,7 +369,7 @@ can be inspected in `var/install.log` and `var/build.log`.\n Building an alternative repository\n -----------------------------------\n \n-If you want to do a test build of a pull on github it can be useful to point\n+If you want to do a test build of a pull on GitHub it can be useful to point\n the gitian builder at an alternative repository, using the same descriptors\n and inputs.\n \n@@ -382,22 +379,24 @@ URL=https://github.com/laanwj/bitcoin.git\n COMMIT=2014_03_windows_unicode_path\n ./bin/gbuild --commit bitcoin=${COMMIT} --url bitcoin=${URL} ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n ./bin/gbuild --commit bitcoin=${COMMIT} --url bitcoin=${URL} ../bitcoin/contrib/gitian-descriptors/gitian-win.yml\n+./bin/gbuild --commit bitcoin=${COMMIT} --url bitcoin=${URL} ../bitcoin/contrib/gitian-descriptors/gitian-osx.yml\n ```\n \n Signing externally\n -------------------\n \n-If you want to do the PGP signing on another device that's possible too; just define `SIGNER` as mentioned\n-and follow the steps in the build process as normally.\n+If you want to do the PGP signing on another device that's also possible; just define `SIGNER` as mentioned\n+and follow the steps in the build process as normal.\n \n     gpg: skipped \"laanwj\": secret key not available\n \n When you execute `gsign` you will get an error from GPG, which can be ignored. Copy the resulting `.assert` files\n in `gitian.sigs` to your signing machine and do\n \n ```bash\n-    gpg --detach-sign ${VERSION}/${SIGNER}/bitcoin-build.assert\n+    gpg --detach-sign ${VERSION}-linux/${SIGNER}/bitcoin-build.assert\n     gpg --detach-sign ${VERSION}-win/${SIGNER}/bitcoin-build.assert\n+    gpg --detach-sign ${VERSION}-osx/${SIGNER}/bitcoin-build.assert\n ```\n \n This will create the `.sig` files that can be committed together with the `.assert` files to assert your\n@@ -407,5 +406,5 @@ Uploading signatures\n ---------------------\n \n After building and signing you can push your signatures (both the `.assert` and `.assert.sig` files) to the\n-[bitcoin/gitian.sigs](https://github.com/bitcoin/gitian.sigs/) repository, or if not possible create a pull\n+[bitcoin/gitian.sigs](https://github.com/bitcoin/gitian.sigs/) repository, or if that's not possible create a pull\n request. You can also mail the files to me (laanwj@gmail.com) and I'll commit them."
      },
      {
        "sha": "967a39a0e7faadaa76566c5d02093cbcaa4d39de",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -1,6 +1,26 @@\n (note: this is a temporary file, to be added-to by anybody, and moved to\n release-notes at release time)\n \n+Transaction fee changes\n+=======================\n+\n+This release automatically estimates how high a transaction fee (or how\n+high a priority) transactions require to be confirmed quickly. The default\n+settings will create transactions that confirm quickly; see the new\n+'txconfirmtarget' setting to control the tradeoff between fees and\n+confirmation times.\n+\n+Prior releases used hard-coded fees (and priorities), and would\n+sometimes create transactions that took a very long time to confirm.\n+\n+\n+New Command Line Options\n+========================\n+\n+-txconfirmtarget=n : create transactions that have enough fees (or priority)\n+so they are likely to confirm within n blocks (default: 1). This setting\n+is over-ridden by the -paytxfee option.\n+\n New RPC methods\n ===============\n "
      },
      {
        "sha": "3168ad1a5ad79a7d9ea5dcbf35b8e924dcaaa752",
        "filename": "doc/release-notes/release-notes-0.9.2.1.md",
        "status": "added",
        "additions": 207,
        "deletions": 0,
        "changes": 207,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/release-notes/release-notes-0.9.2.1.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/release-notes/release-notes-0.9.2.1.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.9.2.1.md?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,207 @@\n+Bitcoin Core version 0.9.2.1 is now available from:\n+\n+  https://bitcoin.org/bin/0.9.2.1/\n+\n+This is a new minor version release, bringing mostly bug fixes and some minor\n+improvements. OpenSSL has been updated because of a security issue (CVE-2014-0224).\n+Upgrading to this release is recommended.\n+\n+Please report bugs using the issue tracker at github:\n+\n+  https://github.com/bitcoin/bitcoin/issues\n+\n+How to Upgrade\n+--------------\n+\n+If you are running an older version, shut it down. Wait until it has completely\n+shut down (which might take a few minutes for older versions), then run the\n+installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n+bitcoind/bitcoin-qt (on Linux).\n+\n+If you are upgrading from version 0.7.2 or earlier, the first time you run\n+0.9.2.1 your blockchain files will be re-indexed, which will take anywhere from \n+30 minutes to several hours, depending on the speed of your machine.\n+\n+Downgrading warnings\n+--------------------\n+\n+The 'chainstate' for this release is not always compatible with previous\n+releases, so if you run 0.9.x and then decide to switch back to a\n+0.8.x release you might get a blockchain validation error when starting the\n+old release (due to 'pruned outputs' being omitted from the index of\n+unspent transaction outputs).\n+\n+Running the old release with the -reindex option will rebuild the chainstate\n+data structures and correct the problem.\n+\n+Also, the first time you run a 0.8.x release on a 0.9 wallet it will rescan\n+the blockchain for missing spent coins, which will take a long time (tens\n+of minutes on a typical machine).\n+\n+Important changes\n+==================\n+\n+Gitian OSX build\n+-----------------\n+\n+The deterministic build system that was already used for Windows and Linux\n+builds is now used for OSX as well. Although the resulting executables have\n+been tested quite a bit, there could be possible regressions. Be sure to report\n+these on the Github bug tracker mentioned above.\n+\n+Compatibility of Linux build\n+-----------------------------\n+\n+For Linux we now build against Qt 4.6, and filter the symbols for libstdc++ and glibc.\n+This brings back compatibility with\n+\n+- Debian 6+ / Tails\n+- Ubuntu 10.04\n+- CentOS 6.5\n+\n+0.9.2 - 0.9.2.1 Release notes\n+=======================\n+\n+The OpenSSL dependency in the gitian builds has been upgraded to 1.0.1h because of CVE-2014-0224.\n+\n+RPC:\n+\n+- Add `getwalletinfo`, `getblockchaininfo` and `getnetworkinfo` calls (will replace hodge-podge `getinfo` at some point)\n+- Add a `relayfee` field to `getnetworkinfo`\n+- Fix RPC related shutdown hangs and leaks\n+- Always show syncnode in `getpeerinfo`\n+- `sendrawtransaction`: report the reject code and reason, and make it possible to re-send transactions that are already in the mempool\n+- `getmininginfo` show right genproclimit\n+\n+Command-line options:\n+\n+- Fix `-printblocktree` output\n+- Show error message if ReadConfigFile fails\n+\n+Block-chain handling and storage:\n+\n+- Fix for GetBlockValue() after block 13,440,000 (BIP42)\n+- Upgrade leveldb to 1.17\n+\n+Protocol and network code:\n+\n+- Per-peer block download tracking and stalled download detection\n+- Add new DNS seed from bitnodes.io\n+- Prevent socket leak in ThreadSocketHandler and correct some proxy related socket leaks\n+- Use pnode->nLastRecv as sync score (was the wrong way around)\n+\n+Wallet:\n+\n+- Make GetAvailableCredit run GetHash() only once per transaction (performance improvement)\n+- Lower paytxfee warning threshold from 0.25 BTC to 0.01 BTC\n+- Fix importwallet nTimeFirstKey (trigger necessary rescans)\n+- Log BerkeleyDB version at startup\n+- CWallet init fix\n+\n+Build system:\n+\n+- Add OSX build descriptors to gitian\n+- Fix explicit --disable-qt-dbus\n+- Don't require db_cxx.h when compiling with wallet disabled and GUI enabled\n+- Improve missing boost error reporting\n+- Upgrade miniupnpc version to 1.9\n+- gitian-linux: --enable-glibc-back-compat for binary compatibility with old distributions\n+- gitian: don't export any symbols from executable\n+- gitian: build against Qt 4.6\n+- devtools: add script to check symbols from Linux gitian executables\n+- Remove build-time no-IPv6 setting\n+\n+GUI:\n+\n+- Fix various coin control visual issues\n+- Show number of in/out connections in debug console\n+- Show weeks as well as years behind for long timespans behind\n+- Enable and disable the Show and Remove buttons for requested payments history based on whether any entry is selected.\n+- Show also value for options overridden on command line in options dialog\n+- Fill in label from address book also for URIs\n+- Fixes feel when resizing the last column on tables (issue #2862)\n+- Fix ESC in disablewallet mode\n+- Add expert section to wallet tab in optionsdialog\n+- Do proper boost::path conversion (fixes unicode in datadir)\n+- Only override -datadir if different from the default (fixes -datadir in config file)\n+- Show rescan progress at start-up\n+- Show importwallet progress\n+- Get required locks upfront in polling functions (avoids hanging on locks)\n+- Catch Windows shutdown events while client is running\n+- Optionally add third party links to transaction context menu\n+- Check for !pixmap() before trying to export QR code (avoids crashes when no QR code could be generated)\n+- Fix \"Start bitcoin on system login\"\n+\n+Miscellaneous:\n+\n+- Replace non-threadsafe C functions (gmtime, strerror and setlocale)\n+- Add missing cs_main and wallet locks\n+- Avoid exception at startup when system locale not recognized\n+- Changed bitrpc.py's raw_input to getpass for passwords to conceal characters during command line input\n+- devtools: add a script to fetch and postprocess translations\n+\n+Credits\n+--------\n+\n+Thanks to everyone who contributed to this release:\n+\n+- Addy Yeow\n+- Altoidnerd\n+- Andrea D'Amore\n+- Andreas Schildbach\n+- Bardi Harborow\n+- Brandon Dahler\n+- Bryan Bishop\n+- Chris Beams\n+- Christian von Roques\n+- Cory Fields\n+- Cozz Lovan\n+- daniel\n+- Daniel Newton\n+- David A. Harding\n+- ditto-b\n+- duanemoody\n+- Eric S. Bullington\n+- Fabian Raetz\n+- Gavin Andresen\n+- Gregory Maxwell\n+- gubatron\n+- Haakon Nilsen\n+- harry\n+- Hector Jusforgues\n+- Isidoro Ghezzi\n+- Jeff Garzik\n+- Johnathan Corgan\n+- jtimon\n+- Kamil Domanski\n+- langerhans\n+- Luke Dashjr\n+- Manuel Araoz\n+- Mark Friedenbach\n+- Matt Corallo\n+- Matthew Bogosian\n+- Meeh\n+- Michael Ford\n+- Michagogo\n+- Mikael Wikman\n+- Mike Hearn\n+- olalonde\n+- paveljanik\n+- peryaudo\n+- Philip Kaufmann\n+- philsong\n+- Pieter Wuille\n+- R E Broadley\n+- richierichrawr\n+- Rune K. Svendsen\n+- rxl\n+- shshshsh\n+- Simon de la Rouviere\n+- Stuart Cardall\n+- super3\n+- Telepatheic\n+- Thomas Zander\n+- Torstein Huseb\u00f8\n+- Warren Togami\n+- Wladimir J. van der Laan\n+- Yoichi Hirai"
      },
      {
        "sha": "a2749e549f7663f674d496da600c0bf282a851d2",
        "filename": "doc/release-notes/release-notes-0.9.2.md",
        "status": "added",
        "additions": 207,
        "deletions": 0,
        "changes": 207,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/release-notes/release-notes-0.9.2.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/release-notes/release-notes-0.9.2.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-0.9.2.md?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,207 @@\n+Bitcoin Core version 0.9.2 is now available from:\n+\n+  https://bitcoin.org/bin/0.9.2/\n+\n+This is a new minor version release, bringing mostly bug fixes and some minor\n+improvements. OpenSSL has been updated because of a security issue (CVE-2014-0224).\n+Upgrading to this release is recommended.\n+\n+Please report bugs using the issue tracker at github:\n+\n+  https://github.com/bitcoin/bitcoin/issues\n+\n+How to Upgrade\n+--------------\n+\n+If you are running an older version, shut it down. Wait until it has completely\n+shut down (which might take a few minutes for older versions), then run the\n+installer (on Windows) or just copy over /Applications/Bitcoin-Qt (on Mac) or\n+bitcoind/bitcoin-qt (on Linux).\n+\n+If you are upgrading from version 0.7.2 or earlier, the first time you run\n+0.9.2 your blockchain files will be re-indexed, which will take anywhere from \n+30 minutes to several hours, depending on the speed of your machine.\n+\n+Downgrading warnings\n+--------------------\n+\n+The 'chainstate' for this release is not always compatible with previous\n+releases, so if you run 0.9.x and then decide to switch back to a\n+0.8.x release you might get a blockchain validation error when starting the\n+old release (due to 'pruned outputs' being omitted from the index of\n+unspent transaction outputs).\n+\n+Running the old release with the -reindex option will rebuild the chainstate\n+data structures and correct the problem.\n+\n+Also, the first time you run a 0.8.x release on a 0.9 wallet it will rescan\n+the blockchain for missing spent coins, which will take a long time (tens\n+of minutes on a typical machine).\n+\n+Important changes\n+==================\n+\n+Gitian OSX build\n+-----------------\n+\n+The deterministic build system that was already used for Windows and Linux\n+builds is now used for OSX as well. Although the resulting executables have\n+been tested quite a bit, there could be possible regressions. Be sure to report\n+these on the Github bug tracker mentioned above.\n+\n+Compatibility of Linux build\n+-----------------------------\n+\n+For Linux we now build against Qt 4.6, and filter the symbols for libstdc++ and glibc.\n+This brings back compatibility with\n+\n+- Debian 6+ / Tails\n+- Ubuntu 10.04\n+- CentOS 6.5\n+\n+0.9.2 Release notes\n+=======================\n+\n+The OpenSSL dependency in the gitian builds has been upgraded to 1.0.1h because of CVE-2014-0224.\n+\n+RPC:\n+\n+- Add `getwalletinfo`, `getblockchaininfo` and `getnetworkinfo` calls (will replace hodge-podge `getinfo` at some point)\n+- Add a `relayfee` field to `getnetworkinfo`\n+- Fix RPC related shutdown hangs and leaks\n+- Always show syncnode in `getpeerinfo`\n+- `sendrawtransaction`: report the reject code and reason, and make it possible to re-send transactions that are already in the mempool\n+- `getmininginfo` show right genproclimit\n+\n+Command-line options:\n+\n+- Fix `-printblocktree` output\n+- Show error message if ReadConfigFile fails\n+\n+Block-chain handling and storage:\n+\n+- Fix for GetBlockValue() after block 13,440,000 (BIP42)\n+- Upgrade leveldb to 1.17\n+\n+Protocol and network code:\n+\n+- Per-peer block download tracking and stalled download detection\n+- Add new DNS seed from bitnodes.io\n+- Prevent socket leak in ThreadSocketHandler and correct some proxy related socket leaks\n+- Use pnode->nLastRecv as sync score (was the wrong way around)\n+\n+Wallet:\n+\n+- Make GetAvailableCredit run GetHash() only once per transaction (performance improvement)\n+- Lower paytxfee warning threshold from 0.25 BTC to 0.01 BTC\n+- Fix importwallet nTimeFirstKey (trigger necessary rescans)\n+- Log BerkeleyDB version at startup\n+- CWallet init fix\n+\n+Build system:\n+\n+- Add OSX build descriptors to gitian\n+- Fix explicit --disable-qt-dbus\n+- Don't require db_cxx.h when compiling with wallet disabled and GUI enabled\n+- Improve missing boost error reporting\n+- Upgrade miniupnpc version to 1.9\n+- gitian-linux: --enable-glibc-back-compat for binary compatibility with old distributions\n+- gitian: don't export any symbols from executable\n+- gitian: build against Qt 4.6\n+- devtools: add script to check symbols from Linux gitian executables\n+- Remove build-time no-IPv6 setting\n+\n+GUI:\n+\n+- Fix various coin control visual issues\n+- Show number of in/out connections in debug console\n+- Show weeks as well as years behind for long timespans behind\n+- Enable and disable the Show and Remove buttons for requested payments history based on whether any entry is selected.\n+- Show also value for options overridden on command line in options dialog\n+- Fill in label from address book also for URIs\n+- Fixes feel when resizing the last column on tables (issue #2862)\n+- Fix ESC in disablewallet mode\n+- Add expert section to wallet tab in optionsdialog\n+- Do proper boost::path conversion (fixes unicode in datadir)\n+- Only override -datadir if different from the default (fixes -datadir in config file)\n+- Show rescan progress at start-up\n+- Show importwallet progress\n+- Get required locks upfront in polling functions (avoids hanging on locks)\n+- Catch Windows shutdown events while client is running\n+- Optionally add third party links to transaction context menu\n+- Check for !pixmap() before trying to export QR code (avoids crashes when no QR code could be generated)\n+- Fix \"Start bitcoin on system login\"\n+\n+Miscellaneous:\n+\n+- Replace non-threadsafe C functions (gmtime, strerror and setlocale)\n+- Add missing cs_main and wallet locks\n+- Avoid exception at startup when system locale not recognized\n+- Changed bitrpc.py's raw_input to getpass for passwords to conceal characters during command line input\n+- devtools: add a script to fetch and postprocess translations\n+\n+Credits\n+--------\n+\n+Thanks to everyone who contributed to this release:\n+\n+- Addy Yeow\n+- Altoidnerd\n+- Andrea D'Amore\n+- Andreas Schildbach\n+- Bardi Harborow\n+- Brandon Dahler\n+- Bryan Bishop\n+- Chris Beams\n+- Christian von Roques\n+- Cory Fields\n+- Cozz Lovan\n+- daniel\n+- Daniel Newton\n+- David A. Harding\n+- ditto-b\n+- duanemoody\n+- Eric S. Bullington\n+- Fabian Raetz\n+- Gavin Andresen\n+- Gregory Maxwell\n+- gubatron\n+- Haakon Nilsen\n+- harry\n+- Hector Jusforgues\n+- Isidoro Ghezzi\n+- Jeff Garzik\n+- Johnathan Corgan\n+- jtimon\n+- Kamil Domanski\n+- langerhans\n+- Luke Dashjr\n+- Manuel Araoz\n+- Mark Friedenbach\n+- Matt Corallo\n+- Matthew Bogosian\n+- Meeh\n+- Michael Ford\n+- Michagogo\n+- Mikael Wikman\n+- Mike Hearn\n+- olalonde\n+- paveljanik\n+- peryaudo\n+- Philip Kaufmann\n+- philsong\n+- Pieter Wuille\n+- R E Broadley\n+- richierichrawr\n+- Rune K. Svendsen\n+- rxl\n+- shshshsh\n+- Simon de la Rouviere\n+- Stuart Cardall\n+- super3\n+- Telepatheic\n+- Thomas Zander\n+- Torstein Huseb\u00f8\n+- Warren Togami\n+- Wladimir J. van der Laan\n+- Yoichi Hirai"
      },
      {
        "sha": "c58838141196c6202a255920af551a7328b19209",
        "filename": "doc/release-process.md",
        "status": "modified",
        "additions": 27,
        "deletions": 47,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/release-process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/release-process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-process.md?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -23,7 +23,7 @@ Release Process\n \n * * *\n \n-##perform gitian builds\n+###perform gitian builds\n \n  From a directory containing the bitcoin source, gitian-builder and gitian.sigs\n   \n@@ -33,26 +33,31 @@ Release Process\n \tgit checkout v${VERSION}\n \tpopd\n \tpushd ./gitian-builder\n-        mkdir -p inputs; cd inputs/\n \n- Register and download the Apple SDK (see OSX Readme for details)\n-\tvisit https://developer.apple.com/downloads/download.action?path=Developer_Tools/xcode_4.6.3/xcode4630916281a.dmg\n+###fetch and build inputs: (first time, or when dependency versions change)\n  \n- Using a Mac, create a tarball for the 10.7 SDK\n-\ttar -C /Volumes/Xcode/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/ -czf MacOSX10.7.sdk.tar.gz MacOSX10.7.sdk\n+\tmkdir -p inputs; cd inputs/\n \n- Fetch and build inputs: (first time, or when dependency versions change)\n+ Register and download the Apple SDK: (see OSX Readme for details)\n+ \n+ https://developer.apple.com/downloads/download.action?path=Developer_Tools/xcode_4.6.3/xcode4630916281a.dmg\n+ \n+ Using a Mac, create a tarball for the 10.7 SDK and copy it to the inputs directory:\n+ \n+\ttar -C /Volumes/Xcode/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/ -czf MacOSX10.7.sdk.tar.gz MacOSX10.7.sdk\n \n+ Download remaining inputs, and build everything:\n+ \n \twget 'http://miniupnp.free.fr/files/download.php?file=miniupnpc-1.9.tar.gz' -O miniupnpc-1.9.tar.gz\n \twget 'https://www.openssl.org/source/openssl-1.0.1h.tar.gz'\n \twget 'http://download.oracle.com/berkeley-db/db-4.8.30.NC.tar.gz'\n \twget 'http://zlib.net/zlib-1.2.8.tar.gz'\n \twget 'ftp://ftp.simplesystems.org/pub/png/src/history/libpng16/libpng-1.6.8.tar.gz'\n \twget 'https://fukuchi.org/works/qrencode/qrencode-3.4.3.tar.bz2'\n \twget 'https://downloads.sourceforge.net/project/boost/boost/1.55.0/boost_1_55_0.tar.bz2'\n-\twget 'https://svn.boost.org/trac/boost/raw-attachment/ticket/7262/boost-mingw.patch' -O \\ \n-\t     boost-mingw-gas-cross-compile-2013-03-03.patch\n+\twget 'https://svn.boost.org/trac/boost/raw-attachment/ticket/7262/boost-mingw.patch' -O boost-mingw-gas-cross-compile-2013-03-03.patch\n \twget 'https://download.qt-project.org/official_releases/qt/5.2/5.2.0/single/qt-everywhere-opensource-src-5.2.0.tar.gz'\n+\twget 'https://download.qt-project.org/official_releases/qt/5.2/5.2.1/single/qt-everywhere-opensource-src-5.2.1.tar.gz'\n \twget 'https://download.qt-project.org/archive/qt/4.6/qt-everywhere-opensource-src-4.6.4.tar.gz'\n \twget 'https://protobuf.googlecode.com/files/protobuf-2.5.0.tar.bz2'\n \twget 'https://github.com/mingwandroid/toolchain4/archive/10cc648683617cca8bcbeae507888099b41b530c.tar.gz'\n@@ -61,10 +66,8 @@ Release Process\n \twget 'http://www.opensource.apple.com/tarballs/ld64/ld64-127.2.tar.gz'\n \twget 'http://cdrkit.org/releases/cdrkit-1.1.11.tar.gz'\n \twget 'https://github.com/theuni/libdmg-hfsplus/archive/libdmg-hfsplus-v0.1.tar.gz'\n-\twget 'http://llvm.org/releases/3.2/clang+llvm-3.2-x86-linux-ubuntu-12.04.tar.gz' -O \\\n-\t     clang-llvm-3.2-x86-linux-ubuntu-12.04.tar.gz\n-        wget 'https://raw.githubusercontent.com/theuni/osx-cross-depends/master/patches/cdrtools/genisoimage.diff' -O \\\n-\t     cdrkit-deterministic.patch\n+\twget 'http://llvm.org/releases/3.2/clang+llvm-3.2-x86-linux-ubuntu-12.04.tar.gz' -O clang-llvm-3.2-x86-linux-ubuntu-12.04.tar.gz\n+\twget 'https://raw.githubusercontent.com/theuni/osx-cross-depends/master/patches/cdrtools/genisoimage.diff' -O cdrkit-deterministic.patch\n \tcd ..\n \t./bin/gbuild ../bitcoin/contrib/gitian-descriptors/boost-linux.yml\n \tmv build/out/boost-*.zip inputs/\n@@ -89,10 +92,10 @@ Release Process\n \n  The expected SHA256 hashes of the intermediate inputs are:\n \n-    46710f673467e367738d8806e45b4cb5931aaeea61f4b6b55a68eea56d5006c5  bitcoin-deps-linux32-gitian-r6.zip\n-    f03be39fb26670243d3a659e64d18e19d03dec5c11e9912011107768390b5268  bitcoin-deps-linux64-gitian-r6.zip\n     f29b7d9577417333fb56e023c2977f5726a7c297f320b175a4108cf7cd4c2d29  boost-linux32-1.55.0-gitian-r1.zip\n     88232451c4104f7eb16e469ac6474fd1231bd485687253f7b2bdf46c0781d535  boost-linux64-1.55.0-gitian-r1.zip\n+    46710f673467e367738d8806e45b4cb5931aaeea61f4b6b55a68eea56d5006c5  bitcoin-deps-linux32-gitian-r6.zip\n+    f03be39fb26670243d3a659e64d18e19d03dec5c11e9912011107768390b5268  bitcoin-deps-linux64-gitian-r6.zip\n     57e57dbdadc818cd270e7e00500a5e1085b3bcbdef69a885f0fb7573a8d987e1  qt-linux32-4.6.4-gitian-r1.tar.gz\n     60eb4b9c5779580b7d66529efa5b2836ba1a70edde2a0f3f696d647906a826be  qt-linux64-4.6.4-gitian-r1.tar.gz\n     60dc2d3b61e9c7d5dbe2f90d5955772ad748a47918ff2d8b74e8db9b1b91c909  boost-win32-1.55.0-gitian-r6.zip\n@@ -103,11 +106,15 @@ Release Process\n     751c579830d173ef3e6f194e83d18b92ebef6df03289db13ab77a52b6bc86ef0  qt-win64-5.2.0-gitian-r3.zip\n     e2e403e1a08869c7eed4d4293bce13d51ec6a63592918b90ae215a0eceb44cb4  protobuf-win32-2.5.0-gitian-r4.zip\n     a0999037e8b0ef9ade13efd88fee261ba401f5ca910068b7e0cd3262ba667db0  protobuf-win64-2.5.0-gitian-r4.zip\n+    512bc0622c883e2e0f4cbc3fedfd8c2402d06c004ce6fb32303cc2a6f405b6df  osx-native-depends-r3.tar.gz\n+    927e4b222be6d590b4bc2fc185872a5d0ca5c322adb983764d3ed84be6bdbc81  osx-depends-r4.tar.gz\n+    ec95abef1df2b096a970359787c01d8c45e2a4475b7ae34e12c022634fbdba8a  osx-depends-qt-5.2.1-r4.tar.gz\n+\n \n- Build bitcoind and bitcoin-qt on Linux32, Linux64, and Win32:\n+ Build Bitcoin Core for Linux, Windows, and OS X:\n   \n \t./bin/gbuild --commit bitcoin=v${VERSION} ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n-\t./bin/gsign --signer $SIGNER --release ${VERSION} --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n+\t./bin/gsign --signer $SIGNER --release ${VERSION}-linux --destination ../gitian.sigs/ ../bitcoin/contrib/gitian-descriptors/gitian-linux.yml\n \tpushd build/out\n \tzip -r bitcoin-${VERSION}-linux-gitian.zip *\n \tmv bitcoin-${VERSION}-linux-gitian.zip ../../../\n@@ -130,7 +137,7 @@ Release Process\n   1. linux 32-bit and 64-bit binaries + source (bitcoin-${VERSION}-linux-gitian.zip)\n   2. windows 32-bit and 64-bit binaries + installer + source (bitcoin-${VERSION}-win-gitian.zip)\n   3. OSX installer (Bitcoin-Qt.dmg)\n-  4. Gitian signatures (in gitian.sigs/${VERSION}[-win|-osx]/(your gitian key)/\n+  4. Gitian signatures (in gitian.sigs/${VERSION}-<linux|win|osx>/(your gitian key)/\n \n repackage gitian builds for release as stand-alone zip/tar/installer exe\n \n@@ -170,8 +177,9 @@ repackage gitian builds for release as stand-alone zip/tar/installer exe\n Commit your signature to gitian.sigs:\n \n \tpushd gitian.sigs\n-\tgit add ${VERSION}/${SIGNER}\n+\tgit add ${VERSION}-linux/${SIGNER}\n \tgit add ${VERSION}-win/${SIGNER}\n+\tgit add ${VERSION}-osx/${SIGNER}\n \tgit commit -a\n \tgit push  # Assuming you can push to the gitian.sigs tree\n \tpopd\n@@ -180,34 +188,6 @@ Commit your signature to gitian.sigs:\n \n ### After 3 or more people have gitian-built, repackage gitian-signed zips:\n \n-From a directory containing bitcoin source, gitian.sigs and gitian zips\n-\n-\texport VERSION=(new version, e.g. 0.8.0)\n-\tmkdir bitcoin-${VERSION}-linux-gitian\n-\tpushd bitcoin-${VERSION}-linux-gitian\n-\tunzip ../bitcoin-${VERSION}-linux-gitian.zip\n-\tmkdir gitian\n-\tcp ../bitcoin/contrib/gitian-downloader/*.pgp ./gitian/\n-\tfor signer in $(ls ../gitian.sigs/${VERSION}/); do\n-\t cp ../gitian.sigs/${VERSION}/${signer}/bitcoin-build.assert ./gitian/${signer}-build.assert\n-\t cp ../gitian.sigs/${VERSION}/${signer}/bitcoin-build.assert.sig ./gitian/${signer}-build.assert.sig\n-\tdone\n-\tzip -r bitcoin-${VERSION}-linux-gitian.zip *\n-\tcp bitcoin-${VERSION}-linux-gitian.zip ../\n-\tpopd\n-\tmkdir bitcoin-${VERSION}-win-gitian\n-\tpushd bitcoin-${VERSION}-win-gitian\n-\tunzip ../bitcoin-${VERSION}-win-gitian.zip\n-\tmkdir gitian\n-\tcp ../bitcoin/contrib/gitian-downloader/*.pgp ./gitian/\n-\tfor signer in $(ls ../gitian.sigs/${VERSION}-win/); do\n-\t cp ../gitian.sigs/${VERSION}-win/${signer}/bitcoin-build.assert ./gitian/${signer}-build.assert\n-\t cp ../gitian.sigs/${VERSION}-win/${signer}/bitcoin-build.assert.sig ./gitian/${signer}-build.assert.sig\n-\tdone\n-\tzip -r bitcoin-${VERSION}-win-gitian.zip *\n-\tcp bitcoin-${VERSION}-win-gitian.zip ../\n-\tpopd\n-\n - Upload gitian zips to SourceForge\n \n - Announce the release:"
      },
      {
        "sha": "560f71fa27c3965c41f7ed4dcb0679c8bf30e288",
        "filename": "doc/tor.md",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/tor.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/doc/tor.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/tor.md?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -13,11 +13,6 @@ configure Tor.\n The first step is running Bitcoin behind a Tor proxy. This will already make all\n outgoing connections be anonymized, but more is possible.\n \n-\t-socks=5        SOCKS5 supports connecting-to-hostname, which can be used instead\n-\t                of doing a (leaking) local DNS lookup. SOCKS5 is the default,\n-\t                but SOCKS4 does not support this. (SOCKS4a does, but isn't\n-\t                implemented).\n-\t\n \t-proxy=ip:port  Set the proxy server. If SOCKS5 is selected (default), this proxy\n \t                server will be used to try to reach .onion addresses as well.\n \t"
      },
      {
        "sha": "ecc42e12b199a7131073588613df545d0075bf3b",
        "filename": "qa/pull-tester/run-bitcoind-for-test.sh.in",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/pull-tester/run-bitcoind-for-test.sh.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/pull-tester/run-bitcoind-for-test.sh.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/pull-tester/run-bitcoind-for-test.sh.in?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -10,7 +10,7 @@ touch \"$DATADIR/regtest/debug.log\"\n tail -q -n 1 -F \"$DATADIR/regtest/debug.log\" | grep -m 1 -q \"Done loading\" &\n WAITER=$!\n PORT=`expr $BASHPID + 10000`\n-\"@abs_top_builddir@/src/bitcoind@EXEEXT@\" -connect=0.0.0.0 -datadir=\"$DATADIR\" -rpcuser=user -rpcpassword=pass -listen -keypool=3 -debug -debug=net -logtimestamps -port=$PORT -regtest -rpcport=`expr $PORT + 1` &\n+\"@abs_top_builddir@/src/bitcoind@EXEEXT@\" -connect=0.0.0.0 -datadir=\"$DATADIR\" -rpcuser=user -rpcpassword=pass -listen -keypool=3 -debug -debug=net -logtimestamps -port=$PORT -whitelist=127.0.0.1 -regtest -rpcport=`expr $PORT + 1` &\n BITCOIND=$!\n \n #Install a watchdog."
      },
      {
        "sha": "3e916a7688d34c01f7a73a00e85f033de1bd4887",
        "filename": "qa/rpc-tests/README.md",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/README.md?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -6,8 +6,8 @@ Git subtree of [https://github.com/jgarzik/python-bitcoinrpc](https://github.com\n Changes to python-bitcoinrpc should be made upstream, and then\n pulled here using git subtree.\n \n-### [skeleton.py](skeleton.py)\n-Copy this to create new regression tests.\n+### [test_framework.py](test_framework.py)\n+Base class for new regression tests.\n \n ### [listtransactions.py](listtransactions.py)\n Tests for the listtransactions RPC call."
      },
      {
        "sha": "8d97719ec34644205113899d7029a2c001d6e131",
        "filename": "qa/rpc-tests/getblocktemplate.py",
        "status": "added",
        "additions": 94,
        "deletions": 0,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/getblocktemplate.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/getblocktemplate.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/getblocktemplate.py?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,94 @@\n+#!/usr/bin/env python\n+# Copyright (c) 2014 The Bitcoin Core developers\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+# Exercise the listtransactions API\n+\n+from test_framework import BitcoinTestFramework\n+from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n+from util import *\n+\n+\n+def check_array_result(object_array, to_match, expected):\n+    \"\"\"\n+    Pass in array of JSON objects, a dictionary with key/value pairs\n+    to match against, and another dictionary with expected key/value\n+    pairs.\n+    \"\"\"\n+    num_matched = 0\n+    for item in object_array:\n+        all_match = True\n+        for key,value in to_match.items():\n+            if item[key] != value:\n+                all_match = False\n+        if not all_match:\n+            continue\n+        for key,value in expected.items():\n+            if item[key] != value:\n+                raise AssertionError(\"%s : expected %s=%s\"%(str(item), str(key), str(value)))\n+            num_matched = num_matched+1\n+    if num_matched == 0:\n+        raise AssertionError(\"No objects matched %s\"%(str(to_match)))\n+\n+import threading\n+\n+class LongpollThread(threading.Thread):\n+    def __init__(self, node):\n+        threading.Thread.__init__(self)\n+        # query current longpollid\n+        templat = node.getblocktemplate()\n+        self.longpollid = templat['longpollid']\n+        # create a new connection to the node, we can't use the same\n+        # connection from two threads\n+        self.node = AuthServiceProxy(node.url, timeout=600)\n+\n+    def run(self):\n+        self.node.getblocktemplate({'longpollid':self.longpollid})\n+\n+class GetBlockTemplateTest(BitcoinTestFramework):\n+    '''\n+    Test longpolling with getblocktemplate.\n+    '''\n+\n+    def run_test(self, nodes):\n+        print \"Warning: this test will take about 70 seconds in the best case. Be patient.\"\n+        nodes[0].setgenerate(True, 10)\n+        templat = nodes[0].getblocktemplate()\n+        longpollid = templat['longpollid']\n+        # longpollid should not change between successive invocations if nothing else happens\n+        templat2 = nodes[0].getblocktemplate()\n+        assert(templat2['longpollid'] == longpollid)\n+\n+        # Test 1: test that the longpolling wait if we do nothing\n+        thr = LongpollThread(nodes[0])\n+        thr.start()\n+        # check that thread still lives\n+        thr.join(5)  # wait 5 seconds or until thread exits\n+        assert(thr.is_alive())\n+\n+        # Test 2: test that longpoll will terminate if another node generates a block\n+        nodes[1].setgenerate(True, 1)  # generate a block on another node\n+        # check that thread will exit now that new transaction entered mempool\n+        thr.join(5)  # wait 5 seconds or until thread exits\n+        assert(not thr.is_alive())\n+\n+        # Test 3: test that longpoll will terminate if we generate a block ourselves\n+        thr = LongpollThread(nodes[0])\n+        thr.start()\n+        nodes[0].setgenerate(True, 1)  # generate a block on another node\n+        thr.join(5)  # wait 5 seconds or until thread exits\n+        assert(not thr.is_alive())\n+\n+        # Test 4: test that introducing a new transaction into the mempool will terminate the longpoll\n+        thr = LongpollThread(nodes[0])\n+        thr.start()\n+        # generate a random transaction and submit it\n+        (txid, txhex, fee) = random_transaction(nodes, Decimal(\"1.1\"), Decimal(\"0.0\"), Decimal(\"0.001\"), 20)\n+        # after one minute, every 10 seconds the mempool is probed, so in 80 seconds it should have returned\n+        thr.join(60 + 20)\n+        assert(not thr.is_alive())\n+\n+if __name__ == '__main__':\n+    GetBlockTemplateTest().main()\n+"
      },
      {
        "sha": "86ad20de525df55beaa1f2eff2d5d1e870c04f69",
        "filename": "qa/rpc-tests/keypool.py",
        "status": "added",
        "additions": 132,
        "deletions": 0,
        "changes": 132,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/keypool.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/keypool.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/keypool.py?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,132 @@\n+#!/usr/bin/env python\n+# Copyright (c) 2014 The Bitcoin Core developers\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+# Exercise the wallet keypool, and interaction with wallet encryption/locking\n+\n+# Add python-bitcoinrpc to module search path:\n+import os\n+import sys\n+sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinrpc\"))\n+\n+import json\n+import shutil\n+import subprocess\n+import tempfile\n+import traceback\n+\n+from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n+from util import *\n+\n+\n+def check_array_result(object_array, to_match, expected):\n+    \"\"\"\n+    Pass in array of JSON objects, a dictionary with key/value pairs\n+    to match against, and another dictionary with expected key/value\n+    pairs.\n+    \"\"\"\n+    num_matched = 0\n+    for item in object_array:\n+        all_match = True\n+        for key,value in to_match.items():\n+            if item[key] != value:\n+                all_match = False\n+        if not all_match:\n+            continue\n+        for key,value in expected.items():\n+            if item[key] != value:\n+                raise AssertionError(\"%s : expected %s=%s\"%(str(item), str(key), str(value)))\n+            num_matched = num_matched+1\n+    if num_matched == 0:\n+        raise AssertionError(\"No objects matched %s\"%(str(to_match)))\n+\n+def run_test(nodes, tmpdir):\n+    # Encrypt wallet and wait to terminate\n+    nodes[0].encryptwallet('test')\n+    bitcoind_processes[0].wait()\n+    # Restart node 0\n+    nodes[0] = start_node(0, tmpdir)\n+    # Keep creating keys\n+    addr = nodes[0].getnewaddress()\n+    try:\n+        addr = nodes[0].getnewaddress()\n+        raise AssertionError('Keypool should be exhausted after one address')\n+    except JSONRPCException,e:\n+        assert(e.error['code']==-12)\n+\n+    # put three new keys in the keypool\n+    nodes[0].walletpassphrase('test', 12000)\n+    nodes[0].keypoolrefill(3)\n+    nodes[0].walletlock()\n+\n+    # drain the keys\n+    addr = set()\n+    addr.add(nodes[0].getrawchangeaddress())\n+    addr.add(nodes[0].getrawchangeaddress())\n+    addr.add(nodes[0].getrawchangeaddress())\n+    addr.add(nodes[0].getrawchangeaddress())\n+    # assert that four unique addresses were returned\n+    assert(len(addr) == 4)\n+    # the next one should fail\n+    try:\n+        addr = nodes[0].getrawchangeaddress()\n+        raise AssertionError('Keypool should be exhausted after three addresses')\n+    except JSONRPCException,e:\n+        assert(e.error['code']==-12)\n+\n+\n+def main():\n+    import optparse\n+\n+    parser = optparse.OptionParser(usage=\"%prog [options]\")\n+    parser.add_option(\"--nocleanup\", dest=\"nocleanup\", default=False, action=\"store_true\",\n+                      help=\"Leave bitcoinds and test.* datadir on exit or error\")\n+    parser.add_option(\"--srcdir\", dest=\"srcdir\", default=\"../../src\",\n+                      help=\"Source directory containing bitcoind/bitcoin-cli (default: %default%)\")\n+    parser.add_option(\"--tmpdir\", dest=\"tmpdir\", default=tempfile.mkdtemp(prefix=\"test\"),\n+                      help=\"Root directory for datadirs\")\n+    (options, args) = parser.parse_args()\n+\n+    os.environ['PATH'] = options.srcdir+\":\"+os.environ['PATH']\n+\n+    check_json_precision()\n+\n+    success = False\n+    nodes = []\n+    try:\n+        print(\"Initializing test directory \"+options.tmpdir)\n+        if not os.path.isdir(options.tmpdir):\n+            os.makedirs(options.tmpdir)\n+        initialize_chain(options.tmpdir)\n+\n+        nodes = start_nodes(1, options.tmpdir)\n+\n+        run_test(nodes, options.tmpdir)\n+\n+        success = True\n+\n+    except AssertionError as e:\n+        print(\"Assertion failed: \"+e.message)\n+    except JSONRPCException as e:\n+        print(\"JSONRPC error: \"+e.error['message'])\n+        traceback.print_tb(sys.exc_info()[2])\n+    except Exception as e:\n+        print(\"Unexpected exception caught during testing: \"+str(sys.exc_info()[0]))\n+        traceback.print_tb(sys.exc_info()[2])\n+\n+    if not options.nocleanup:\n+        print(\"Cleaning up\")\n+        stop_nodes(nodes)\n+        wait_bitcoinds()\n+        shutil.rmtree(options.tmpdir)\n+\n+    if success:\n+        print(\"Tests successful\")\n+        sys.exit(0)\n+    else:\n+        print(\"Failed\")\n+        sys.exit(1)\n+\n+if __name__ == '__main__':\n+    main()"
      },
      {
        "sha": "50385b437208c943759737df508b30680d2e98bc",
        "filename": "qa/rpc-tests/listtransactions.py",
        "status": "modified",
        "additions": 62,
        "deletions": 121,
        "changes": 183,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/listtransactions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/listtransactions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/listtransactions.py?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -5,17 +5,7 @@\n \n # Exercise the listtransactions API\n \n-# Add python-bitcoinrpc to module search path:\n-import os\n-import sys\n-sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinrpc\"))\n-\n-import json\n-import shutil\n-import subprocess\n-import tempfile\n-import traceback\n-\n+from test_framework import BitcoinTestFramework\n from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n from util import *\n \n@@ -41,116 +31,67 @@ def check_array_result(object_array, to_match, expected):\n     if num_matched == 0:\n         raise AssertionError(\"No objects matched %s\"%(str(to_match)))\n \n-def run_test(nodes):\n-    # Simple send, 0 to 1:\n-    txid = nodes[0].sendtoaddress(nodes[1].getnewaddress(), 0.1)\n-    sync_mempools(nodes)\n-    check_array_result(nodes[0].listtransactions(),\n-                       {\"txid\":txid},\n-                       {\"category\":\"send\",\"account\":\"\",\"amount\":Decimal(\"-0.1\"),\"confirmations\":0})\n-    check_array_result(nodes[1].listtransactions(),\n-                       {\"txid\":txid},\n-                       {\"category\":\"receive\",\"account\":\"\",\"amount\":Decimal(\"0.1\"),\"confirmations\":0})\n-    # mine a block, confirmations should change:\n-    nodes[0].setgenerate(True, 1)\n-    sync_blocks(nodes)\n-    check_array_result(nodes[0].listtransactions(),\n-                       {\"txid\":txid},\n-                       {\"category\":\"send\",\"account\":\"\",\"amount\":Decimal(\"-0.1\"),\"confirmations\":1})\n-    check_array_result(nodes[1].listtransactions(),\n-                       {\"txid\":txid},\n-                       {\"category\":\"receive\",\"account\":\"\",\"amount\":Decimal(\"0.1\"),\"confirmations\":1})\n-\n-    # send-to-self:\n-    txid = nodes[0].sendtoaddress(nodes[0].getnewaddress(), 0.2)\n-    check_array_result(nodes[0].listtransactions(),\n-                       {\"txid\":txid, \"category\":\"send\"},\n-                       {\"amount\":Decimal(\"-0.2\")})\n-    check_array_result(nodes[0].listtransactions(),\n-                       {\"txid\":txid, \"category\":\"receive\"},\n-                       {\"amount\":Decimal(\"0.2\")})\n-\n-    # sendmany from node1: twice to self, twice to node2:\n-    send_to = { nodes[0].getnewaddress() : 0.11, nodes[1].getnewaddress() : 0.22,\n-                nodes[0].getaccountaddress(\"from1\") : 0.33, nodes[1].getaccountaddress(\"toself\") : 0.44 }\n-    txid = nodes[1].sendmany(\"\", send_to)\n-    sync_mempools(nodes)\n-    check_array_result(nodes[1].listtransactions(),\n-                       {\"category\":\"send\",\"amount\":Decimal(\"-0.11\")},\n-                       {\"txid\":txid} )\n-    check_array_result(nodes[0].listtransactions(),\n-                       {\"category\":\"receive\",\"amount\":Decimal(\"0.11\")},\n-                       {\"txid\":txid} )\n-    check_array_result(nodes[1].listtransactions(),\n-                       {\"category\":\"send\",\"amount\":Decimal(\"-0.22\")},\n-                       {\"txid\":txid} )\n-    check_array_result(nodes[1].listtransactions(),\n-                       {\"category\":\"receive\",\"amount\":Decimal(\"0.22\")},\n-                       {\"txid\":txid} )\n-    check_array_result(nodes[1].listtransactions(),\n-                       {\"category\":\"send\",\"amount\":Decimal(\"-0.33\")},\n-                       {\"txid\":txid} )\n-    check_array_result(nodes[0].listtransactions(),\n-                       {\"category\":\"receive\",\"amount\":Decimal(\"0.33\")},\n-                       {\"txid\":txid, \"account\" : \"from1\"} )\n-    check_array_result(nodes[1].listtransactions(),\n-                       {\"category\":\"send\",\"amount\":Decimal(\"-0.44\")},\n-                       {\"txid\":txid, \"account\" : \"\"} )\n-    check_array_result(nodes[1].listtransactions(),\n-                       {\"category\":\"receive\",\"amount\":Decimal(\"0.44\")},\n-                       {\"txid\":txid, \"account\" : \"toself\"} )\n-    \n-\n-def main():\n-    import optparse\n-\n-    parser = optparse.OptionParser(usage=\"%prog [options]\")\n-    parser.add_option(\"--nocleanup\", dest=\"nocleanup\", default=False, action=\"store_true\",\n-                      help=\"Leave bitcoinds and test.* datadir on exit or error\")\n-    parser.add_option(\"--srcdir\", dest=\"srcdir\", default=\"../../src\",\n-                      help=\"Source directory containing bitcoind/bitcoin-cli (default: %default%)\")\n-    parser.add_option(\"--tmpdir\", dest=\"tmpdir\", default=tempfile.mkdtemp(prefix=\"test\"),\n-                      help=\"Root directory for datadirs\")\n-    (options, args) = parser.parse_args()\n-\n-    os.environ['PATH'] = options.srcdir+\":\"+os.environ['PATH']\n-\n-    check_json_precision()\n-\n-    success = False\n-    nodes = []\n-    try:\n-        print(\"Initializing test directory \"+options.tmpdir)\n-        if not os.path.isdir(options.tmpdir):\n-            os.makedirs(options.tmpdir)\n-        initialize_chain(options.tmpdir)\n-\n-        nodes = start_nodes(2, options.tmpdir)\n-        connect_nodes(nodes[1], 0)\n+class ListTransactionsTest(BitcoinTestFramework):\n+\n+    def run_test(self, nodes):\n+        # Simple send, 0 to 1:\n+        txid = nodes[0].sendtoaddress(nodes[1].getnewaddress(), 0.1)\n+        sync_mempools(nodes)\n+        check_array_result(nodes[0].listtransactions(),\n+                           {\"txid\":txid},\n+                           {\"category\":\"send\",\"account\":\"\",\"amount\":Decimal(\"-0.1\"),\"confirmations\":0})\n+        check_array_result(nodes[1].listtransactions(),\n+                           {\"txid\":txid},\n+                           {\"category\":\"receive\",\"account\":\"\",\"amount\":Decimal(\"0.1\"),\"confirmations\":0})\n+        # mine a block, confirmations should change:\n+        nodes[0].setgenerate(True, 1)\n         sync_blocks(nodes)\n-\n-        run_test(nodes)\n-\n-        success = True\n-\n-    except AssertionError as e:\n-        print(\"Assertion failed: \"+e.message)\n-    except Exception as e:\n-        print(\"Unexpected exception caught during testing: \"+str(e))\n-        traceback.print_tb(sys.exc_info()[2])\n-\n-    if not options.nocleanup:\n-        print(\"Cleaning up\")\n-        stop_nodes(nodes)\n-        wait_bitcoinds()\n-        shutil.rmtree(options.tmpdir)\n-\n-    if success:\n-        print(\"Tests successful\")\n-        sys.exit(0)\n-    else:\n-        print(\"Failed\")\n-        sys.exit(1)\n+        check_array_result(nodes[0].listtransactions(),\n+                           {\"txid\":txid},\n+                           {\"category\":\"send\",\"account\":\"\",\"amount\":Decimal(\"-0.1\"),\"confirmations\":1})\n+        check_array_result(nodes[1].listtransactions(),\n+                           {\"txid\":txid},\n+                           {\"category\":\"receive\",\"account\":\"\",\"amount\":Decimal(\"0.1\"),\"confirmations\":1})\n+\n+        # send-to-self:\n+        txid = nodes[0].sendtoaddress(nodes[0].getnewaddress(), 0.2)\n+        check_array_result(nodes[0].listtransactions(),\n+                           {\"txid\":txid, \"category\":\"send\"},\n+                           {\"amount\":Decimal(\"-0.2\")})\n+        check_array_result(nodes[0].listtransactions(),\n+                           {\"txid\":txid, \"category\":\"receive\"},\n+                           {\"amount\":Decimal(\"0.2\")})\n+\n+        # sendmany from node1: twice to self, twice to node2:\n+        send_to = { nodes[0].getnewaddress() : 0.11, nodes[1].getnewaddress() : 0.22,\n+                    nodes[0].getaccountaddress(\"from1\") : 0.33, nodes[1].getaccountaddress(\"toself\") : 0.44 }\n+        txid = nodes[1].sendmany(\"\", send_to)\n+        sync_mempools(nodes)\n+        check_array_result(nodes[1].listtransactions(),\n+                           {\"category\":\"send\",\"amount\":Decimal(\"-0.11\")},\n+                           {\"txid\":txid} )\n+        check_array_result(nodes[0].listtransactions(),\n+                           {\"category\":\"receive\",\"amount\":Decimal(\"0.11\")},\n+                           {\"txid\":txid} )\n+        check_array_result(nodes[1].listtransactions(),\n+                           {\"category\":\"send\",\"amount\":Decimal(\"-0.22\")},\n+                           {\"txid\":txid} )\n+        check_array_result(nodes[1].listtransactions(),\n+                           {\"category\":\"receive\",\"amount\":Decimal(\"0.22\")},\n+                           {\"txid\":txid} )\n+        check_array_result(nodes[1].listtransactions(),\n+                           {\"category\":\"send\",\"amount\":Decimal(\"-0.33\")},\n+                           {\"txid\":txid} )\n+        check_array_result(nodes[0].listtransactions(),\n+                           {\"category\":\"receive\",\"amount\":Decimal(\"0.33\")},\n+                           {\"txid\":txid, \"account\" : \"from1\"} )\n+        check_array_result(nodes[1].listtransactions(),\n+                           {\"category\":\"send\",\"amount\":Decimal(\"-0.44\")},\n+                           {\"txid\":txid, \"account\" : \"\"} )\n+        check_array_result(nodes[1].listtransactions(),\n+                           {\"category\":\"receive\",\"amount\":Decimal(\"0.44\")},\n+                           {\"txid\":txid, \"account\" : \"toself\"} )\n \n if __name__ == '__main__':\n-    main()\n+    ListTransactionsTest().main()\n+"
      },
      {
        "sha": "bc7d655fdfe97c912d945c5d534948dc6848623c",
        "filename": "qa/rpc-tests/python-bitcoinrpc/bitcoinrpc/authproxy.py",
        "status": "modified",
        "additions": 23,
        "deletions": 7,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/python-bitcoinrpc/bitcoinrpc/authproxy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/python-bitcoinrpc/bitcoinrpc/authproxy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/python-bitcoinrpc/bitcoinrpc/authproxy.py?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -39,8 +39,9 @@\n except ImportError:\n     import httplib\n import base64\n-import json\n import decimal\n+import json\n+import logging\n try:\n     import urllib.parse as urlparse\n except ImportError:\n@@ -50,14 +51,22 @@\n \n HTTP_TIMEOUT = 30\n \n+log = logging.getLogger(\"BitcoinRPC\")\n \n class JSONRPCException(Exception):\n     def __init__(self, rpc_error):\n         Exception.__init__(self)\n         self.error = rpc_error\n \n \n+def EncodeDecimal(o):\n+    if isinstance(o, decimal.Decimal):\n+        return round(o, 8)\n+    raise TypeError(repr(o) + \" is not JSON serializable\")\n+\n class AuthServiceProxy(object):\n+    __id_count = 0\n+\n     def __init__(self, service_url, service_name=None, timeout=HTTP_TIMEOUT, connection=None):\n         self.__service_url = service_url\n         self.__service_name = service_name\n@@ -66,7 +75,6 @@ def __init__(self, service_url, service_name=None, timeout=HTTP_TIMEOUT, connect\n             port = 80\n         else:\n             port = self.__url.port\n-        self.__id_count = 0\n         (user, passwd) = (self.__url.username, self.__url.password)\n         try:\n             user = user.encode('utf8')\n@@ -99,12 +107,14 @@ def __getattr__(self, name):\n         return AuthServiceProxy(self.__service_url, name, connection=self.__conn)\n \n     def __call__(self, *args):\n-        self.__id_count += 1\n+        AuthServiceProxy.__id_count += 1\n \n+        log.debug(\"-%s-> %s %s\"%(AuthServiceProxy.__id_count, self.__service_name,\n+                                 json.dumps(args, default=EncodeDecimal)))\n         postdata = json.dumps({'version': '1.1',\n                                'method': self.__service_name,\n                                'params': args,\n-                               'id': self.__id_count})\n+                               'id': AuthServiceProxy.__id_count}, default=EncodeDecimal)\n         self.__conn.request('POST', self.__url.path, postdata,\n                             {'Host': self.__url.hostname,\n                              'User-Agent': USER_AGENT,\n@@ -121,7 +131,8 @@ def __call__(self, *args):\n             return response['result']\n \n     def _batch(self, rpc_call_list):\n-        postdata = json.dumps(list(rpc_call_list))\n+        postdata = json.dumps(list(rpc_call_list), default=EncodeDecimal)\n+        log.debug(\"--> \"+postdata)\n         self.__conn.request('POST', self.__url.path, postdata,\n                             {'Host': self.__url.hostname,\n                              'User-Agent': USER_AGENT,\n@@ -136,5 +147,10 @@ def _get_response(self):\n             raise JSONRPCException({\n                 'code': -342, 'message': 'missing HTTP response from server'})\n \n-        return json.loads(http_response.read().decode('utf8'),\n-                          parse_float=decimal.Decimal)\n+        responsedata = http_response.read().decode('utf8')\n+        response = json.loads(responsedata, parse_float=decimal.Decimal)\n+        if \"error\" in response and response[\"error\"] is None:\n+            log.debug(\"<-%s- %s\"%(response[\"id\"], json.dumps(response[\"result\"], default=EncodeDecimal)))\n+        else:\n+            log.debug(\"<-- \"+responsedata)\n+        return response"
      },
      {
        "sha": "61f5e0452b589d00a0d490983ca8a9f6db472618",
        "filename": "qa/rpc-tests/receivedby.py",
        "status": "added",
        "additions": 166,
        "deletions": 0,
        "changes": 166,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/receivedby.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/receivedby.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/receivedby.py?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,166 @@\n+#!/usr/bin/env python\n+# Copyright (c) 2014 The Bitcoin Core developers\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+# Exercise the listreceivedbyaddress API\n+\n+from test_framework import BitcoinTestFramework\n+from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n+from util import *\n+\n+\n+def get_sub_array_from_array(object_array, to_match):\n+    '''\n+        Finds and returns a sub array from an array of arrays.\n+        to_match should be a unique idetifier of a sub array\n+    '''\n+    num_matched = 0\n+    for item in object_array:\n+        all_match = True\n+        for key,value in to_match.items():\n+            if item[key] != value:\n+                all_match = False\n+        if not all_match:\n+            continue\n+        return item\n+    return []\n+\n+def check_array_result(object_array, to_match, expected, should_not_find = False):\n+    \"\"\"\n+        Pass in array of JSON objects, a dictionary with key/value pairs\n+        to match against, and another dictionary with expected key/value\n+        pairs.\n+        If the should_not_find flag is true, to_match should not be found in object_array\n+        \"\"\"\n+    if should_not_find == True:\n+        expected = { }\n+    num_matched = 0\n+    for item in object_array:\n+        all_match = True\n+        for key,value in to_match.items():\n+            if item[key] != value:\n+                all_match = False\n+        if not all_match:\n+            continue\n+        for key,value in expected.items():\n+            if item[key] != value:\n+                raise AssertionError(\"%s : expected %s=%s\"%(str(item), str(key), str(value)))\n+            num_matched = num_matched+1\n+    if num_matched == 0 and should_not_find != True:\n+        raise AssertionError(\"No objects matched %s\"%(str(to_match)))\n+    if num_matched > 0 and should_not_find == True:\n+        raise AssertionError(\"Objects was matched %s\"%(str(to_match)))\n+\n+class ReceivedByTest(BitcoinTestFramework):\n+\n+    def run_test(self, nodes):\n+        '''\n+        listreceivedbyaddress Test\n+        '''\n+        # Send from node 0 to 1\n+        addr = nodes[1].getnewaddress()\n+        txid = nodes[0].sendtoaddress(addr, 0.1)\n+        sync_mempools(nodes)\n+\n+        #Check not listed in listreceivedbyaddress because has 0 confirmations\n+        check_array_result(nodes[1].listreceivedbyaddress(),\n+                           {\"address\":addr},\n+                           { },\n+                           True)\n+        #Bury Tx under 10 block so it will be returned by listreceivedbyaddress\n+        nodes[1].setgenerate(True, 10)\n+        sync_blocks(nodes)\n+        check_array_result(nodes[1].listreceivedbyaddress(),\n+                           {\"address\":addr},\n+                           {\"address\":addr, \"account\":\"\", \"amount\":Decimal(\"0.1\"), \"confirmations\":10, \"txids\":[txid,]})\n+        #With min confidence < 10\n+        check_array_result(nodes[1].listreceivedbyaddress(5),\n+                           {\"address\":addr},\n+                           {\"address\":addr, \"account\":\"\", \"amount\":Decimal(\"0.1\"), \"confirmations\":10, \"txids\":[txid,]})\n+        #With min confidence > 10, should not find Tx\n+        check_array_result(nodes[1].listreceivedbyaddress(11),{\"address\":addr},{ },True)\n+\n+        #Empty Tx\n+        addr = nodes[1].getnewaddress()\n+        check_array_result(nodes[1].listreceivedbyaddress(0,True),\n+                           {\"address\":addr},\n+                           {\"address\":addr, \"account\":\"\", \"amount\":0, \"confirmations\":0, \"txids\":[]})\n+\n+        '''\n+            getreceivedbyaddress Test\n+        '''\n+        # Send from node 0 to 1\n+        addr = nodes[1].getnewaddress()\n+        txid = nodes[0].sendtoaddress(addr, 0.1)\n+        sync_mempools(nodes)\n+\n+        #Check balance is 0 because of 0 confirmations\n+        balance = nodes[1].getreceivedbyaddress(addr)\n+        if balance != Decimal(\"0.0\"):\n+            raise AssertionError(\"Wrong balance returned by getreceivedbyaddress, %0.2f\"%(balance))\n+\n+        #Check balance is 0.1\n+        balance = nodes[1].getreceivedbyaddress(addr,0)\n+        if balance != Decimal(\"0.1\"):\n+            raise AssertionError(\"Wrong balance returned by getreceivedbyaddress, %0.2f\"%(balance))\n+\n+        #Bury Tx under 10 block so it will be returned by the default getreceivedbyaddress\n+        nodes[1].setgenerate(True, 10)\n+        sync_blocks(nodes)\n+        balance = nodes[1].getreceivedbyaddress(addr)\n+        if balance != Decimal(\"0.1\"):\n+            raise AssertionError(\"Wrong balance returned by getreceivedbyaddress, %0.2f\"%(balance))\n+\n+        '''\n+            listreceivedbyaccount + getreceivedbyaccount Test\n+        '''\n+        #set pre-state\n+        addrArr = nodes[1].getnewaddress()\n+        account = nodes[1].getaccount(addrArr)\n+        received_by_account_json = get_sub_array_from_array(nodes[1].listreceivedbyaccount(),{\"account\":account})\n+        if len(received_by_account_json) == 0:\n+            raise AssertionError(\"No accounts found in node\")\n+        balance_by_account = rec_by_accountArr = nodes[1].getreceivedbyaccount(account)\n+\n+        txid = nodes[0].sendtoaddress(addr, 0.1)\n+\n+        # listreceivedbyaccount should return received_by_account_json because of 0 confirmations\n+        check_array_result(nodes[1].listreceivedbyaccount(),\n+                           {\"account\":account},\n+                           received_by_account_json)\n+\n+        # getreceivedbyaddress should return same balance because of 0 confirmations\n+        balance = nodes[1].getreceivedbyaccount(account)\n+        if balance != balance_by_account:\n+            raise AssertionError(\"Wrong balance returned by getreceivedbyaccount, %0.2f\"%(balance))\n+\n+        nodes[1].setgenerate(True, 10)\n+        sync_blocks(nodes)\n+        # listreceivedbyaccount should return updated account balance\n+        check_array_result(nodes[1].listreceivedbyaccount(),\n+                           {\"account\":account},\n+                           {\"account\":received_by_account_json[\"account\"], \"amount\":(received_by_account_json[\"amount\"] + Decimal(\"0.1\"))})\n+\n+        # getreceivedbyaddress should return updates balance\n+        balance = nodes[1].getreceivedbyaccount(account)\n+        if balance != balance_by_account + Decimal(\"0.1\"):\n+            raise AssertionError(\"Wrong balance returned by getreceivedbyaccount, %0.2f\"%(balance))\n+\n+        #Create a new account named \"mynewaccount\" that has a 0 balance\n+        nodes[1].getaccountaddress(\"mynewaccount\")\n+        received_by_account_json = get_sub_array_from_array(nodes[1].listreceivedbyaccount(0,True),{\"account\":\"mynewaccount\"})\n+        if len(received_by_account_json) == 0:\n+            raise AssertionError(\"No accounts found in node\")\n+\n+        # Test includeempty of listreceivedbyaccount\n+        if received_by_account_json[\"amount\"] != Decimal(\"0.0\"):\n+            raise AssertionError(\"Wrong balance returned by listreceivedbyaccount, %0.2f\"%(received_by_account_json[\"amount\"]))\n+\n+        # Test getreceivedbyaccount for 0 amount accounts\n+        balance = nodes[1].getreceivedbyaccount(\"mynewaccount\")\n+        if balance != Decimal(\"0.0\"):\n+            raise AssertionError(\"Wrong balance returned by getreceivedbyaccount, %0.2f\"%(balance))\n+\n+if __name__ == '__main__':\n+    ReceivedByTest().main()"
      },
      {
        "sha": "a823404e0046da4f3ec84d1c3c75a5bb45daa90b",
        "filename": "qa/rpc-tests/rpcbind_test.py",
        "status": "modified",
        "additions": 12,
        "deletions": 10,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/rpcbind_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/rpcbind_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/rpcbind_test.py?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -39,7 +39,7 @@ def run_bind_test(tmpdir, allow_ips, connect_to, addresses, expected):\n         stop_nodes(nodes)\n         wait_bitcoinds()\n \n-def run_allowip_test(tmpdir, allow_ips, rpchost):\n+def run_allowip_test(tmpdir, allow_ips, rpchost, rpcport):\n     '''\n     Start a node with rpcwallow IP, and request getinfo\n     at a non-localhost IP.\n@@ -48,7 +48,7 @@ def run_allowip_test(tmpdir, allow_ips, rpchost):\n     nodes = start_nodes(1, tmpdir, [base_args])\n     try:\n         # connect to node through non-loopback interface\n-        url = \"http://rt:rt@%s:%d\" % (rpchost, START_RPC_PORT,)\n+        url = \"http://rt:rt@%s:%d\" % (rpchost, rpcport,)\n         node = AuthServiceProxy(url)\n         node.getinfo()\n     finally:\n@@ -69,15 +69,17 @@ def run_test(tmpdir):\n         assert(not 'This test requires at least one non-loopback IPv4 interface')\n     print(\"Using interface %s for testing\" % non_loopback_ip)\n \n+    defaultport = rpc_port(0)\n+\n     # check default without rpcallowip (IPv4 and IPv6 localhost)\n     run_bind_test(tmpdir, None, '127.0.0.1', [],\n-        [('127.0.0.1', 11100), ('::1', 11100)])\n+        [('127.0.0.1', defaultport), ('::1', defaultport)])\n     # check default with rpcallowip (IPv6 any)\n     run_bind_test(tmpdir, ['127.0.0.1'], '127.0.0.1', [],\n-        [('::0', 11100)])\n+        [('::0', defaultport)])\n     # check only IPv4 localhost (explicit)\n     run_bind_test(tmpdir, ['127.0.0.1'], '127.0.0.1', ['127.0.0.1'],\n-        [('127.0.0.1', START_RPC_PORT)])\n+        [('127.0.0.1', defaultport)])\n     # check only IPv4 localhost (explicit) with alternative port\n     run_bind_test(tmpdir, ['127.0.0.1'], '127.0.0.1:32171', ['127.0.0.1:32171'],\n         [('127.0.0.1', 32171)])\n@@ -86,18 +88,18 @@ def run_test(tmpdir):\n         [('127.0.0.1', 32171), ('127.0.0.1', 32172)])\n     # check only IPv6 localhost (explicit)\n     run_bind_test(tmpdir, ['[::1]'], '[::1]', ['[::1]'],\n-        [('::1', 11100)])\n+        [('::1', defaultport)])\n     # check both IPv4 and IPv6 localhost (explicit)\n     run_bind_test(tmpdir, ['127.0.0.1'], '127.0.0.1', ['127.0.0.1', '[::1]'],\n-        [('127.0.0.1', START_RPC_PORT), ('::1', START_RPC_PORT)])\n+        [('127.0.0.1', defaultport), ('::1', defaultport)])\n     # check only non-loopback interface\n     run_bind_test(tmpdir, [non_loopback_ip], non_loopback_ip, [non_loopback_ip],\n-        [(non_loopback_ip, START_RPC_PORT)])\n+        [(non_loopback_ip, defaultport)])\n \n     # Check that with invalid rpcallowip, we are denied\n-    run_allowip_test(tmpdir, [non_loopback_ip], non_loopback_ip)\n+    run_allowip_test(tmpdir, [non_loopback_ip], non_loopback_ip, defaultport)\n     try:\n-        run_allowip_test(tmpdir, ['1.1.1.1'], non_loopback_ip)\n+        run_allowip_test(tmpdir, ['1.1.1.1'], non_loopback_ip, defaultport)\n         assert(not 'Connection not denied by rpcallowip as expected')\n     except ValueError:\n         pass"
      },
      {
        "sha": "126b6bfaf41ceb3d13d7ff135e2e5ae80470cadb",
        "filename": "qa/rpc-tests/skeleton.py",
        "status": "removed",
        "additions": 0,
        "deletions": 83,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff3047c56406f61af18e69eb16c9404b01b45f8d/qa/rpc-tests/skeleton.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff3047c56406f61af18e69eb16c9404b01b45f8d/qa/rpc-tests/skeleton.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/skeleton.py?ref=ff3047c56406f61af18e69eb16c9404b01b45f8d",
        "patch": "@@ -1,83 +0,0 @@\n-#!/usr/bin/env python\n-# Copyright (c) 2014 The Bitcoin Core developers\n-# Distributed under the MIT/X11 software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-# Skeleton for python-based regression tests using\n-# JSON-RPC\n-\n-\n-# Add python-bitcoinrpc to module search path:\n-import os\n-import sys\n-sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinrpc\"))\n-\n-import json\n-import shutil\n-import subprocess\n-import tempfile\n-import traceback\n-\n-from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n-from util import *\n-\n-\n-def run_test(nodes):\n-    # Replace this as appropriate\n-    for node in nodes:\n-        assert_equal(node.getblockcount(), 200)\n-        assert_equal(node.getbalance(), 25*50)\n-\n-def main():\n-    import optparse\n-\n-    parser = optparse.OptionParser(usage=\"%prog [options]\")\n-    parser.add_option(\"--nocleanup\", dest=\"nocleanup\", default=False, action=\"store_true\",\n-                      help=\"Leave bitcoinds and test.* datadir on exit or error\")\n-    parser.add_option(\"--srcdir\", dest=\"srcdir\", default=\"../../src\",\n-                      help=\"Source directory containing bitcoind/bitcoin-cli (default: %default%)\")\n-    parser.add_option(\"--tmpdir\", dest=\"tmpdir\", default=tempfile.mkdtemp(prefix=\"test\"),\n-                      help=\"Root directory for datadirs\")\n-    (options, args) = parser.parse_args()\n-\n-    os.environ['PATH'] = options.srcdir+\":\"+os.environ['PATH']\n-\n-    check_json_precision()\n-\n-    success = False\n-    nodes = []\n-    try:\n-        print(\"Initializing test directory \"+options.tmpdir)\n-        if not os.path.isdir(options.tmpdir):\n-            os.makedirs(options.tmpdir)\n-        initialize_chain(options.tmpdir)\n-\n-        nodes = start_nodes(2, options.tmpdir)\n-        connect_nodes(nodes[1], 0)\n-        sync_blocks(nodes)\n-\n-        run_test(nodes)\n-\n-        success = True\n-\n-    except AssertionError as e:\n-        print(\"Assertion failed: \"+e.message)\n-    except Exception as e:\n-        print(\"Unexpected exception caught during testing: \"+str(e))\n-        traceback.print_tb(sys.exc_info()[2])\n-\n-    if not options.nocleanup:\n-        print(\"Cleaning up\")\n-        stop_nodes(nodes)\n-        wait_bitcoinds()\n-        shutil.rmtree(options.tmpdir)\n-\n-    if success:\n-        print(\"Tests successful\")\n-        sys.exit(0)\n-    else:\n-        print(\"Failed\")\n-        sys.exit(1)\n-\n-if __name__ == '__main__':\n-    main()"
      },
      {
        "sha": "352a1de2d005c5e242d458f995a931371598b0ff",
        "filename": "qa/rpc-tests/smartfees.py",
        "status": "modified",
        "additions": 71,
        "deletions": 124,
        "changes": 195,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/smartfees.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/smartfees.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/smartfees.py?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -4,139 +4,86 @@\n # Test fee estimation code\n #\n \n-# Add python-bitcoinrpc to module search path:\n-import os\n-import sys\n-sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinrpc\"))\n-\n-import json\n-import random\n-import shutil\n-import subprocess\n-import tempfile\n-import traceback\n-\n+from test_framework import BitcoinTestFramework\n from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n from util import *\n \n+class EstimateFeeTest(BitcoinTestFramework):\n \n-def run_test(nodes, test_dir):\n-    nodes.append(start_node(0, test_dir,\n+    def setup_network(self, test_dir):\n+        nodes = []\n+        nodes.append(start_node(0, test_dir,\n                             [\"-debug=mempool\", \"-debug=estimatefee\"]))\n-    # Node1 mines small-but-not-tiny blocks, and allows free transactions.\n-    # NOTE: the CreateNewBlock code starts counting block size at 1,000 bytes,\n-    # so blockmaxsize of 2,000 is really just 1,000 bytes (room enough for\n-    # 6 or 7 transactions)\n-    nodes.append(start_node(1, test_dir,\n-                            [\"-blockprioritysize=1500\", \"-blockmaxsize=2000\",\n-                             \"-debug=mempool\", \"-debug=estimatefee\"]))\n-    connect_nodes(nodes[1], 0)\n-\n-    # Node2 is a stingy miner, that\n-    # produces very small blocks (room for only 3 or so transactions)\n-    node2args = [ \"-blockprioritysize=0\", \"-blockmaxsize=1500\",\n-                             \"-debug=mempool\", \"-debug=estimatefee\"]\n-    nodes.append(start_node(2, test_dir, node2args))\n-    connect_nodes(nodes[2], 0)\n-\n-    sync_blocks(nodes)\n-\n-    # Prime the memory pool with pairs of transactions\n-    # (high-priority, random fee and zero-priority, random fee)\n-    min_fee = Decimal(\"0.001\")\n-    fees_per_kb = [];\n-    for i in range(12):\n-        (txid, txhex, fee) = random_zeropri_transaction(nodes, Decimal(\"1.1\"),\n-                                                        min_fee, min_fee, 20)\n-        tx_kbytes = (len(txhex)/2)/1000.0\n-        fees_per_kb.append(float(fee)/tx_kbytes)\n-\n-    # Mine blocks with node2 until the memory pool clears:\n-    count_start = nodes[2].getblockcount()\n-    while len(nodes[2].getrawmempool()) > 0:\n-        nodes[2].setgenerate(True, 1)\n-        sync_blocks(nodes)\n-\n-    all_estimates = [ nodes[0].estimatefee(i) for i in range(1,20) ]\n-    print(\"Fee estimates, super-stingy miner: \"+str([str(e) for e in all_estimates]))\n-\n-    # Estimates should be within the bounds of what transactions fees actually were:\n-    delta = 1.0e-6 # account for rounding error\n-    for e in filter(lambda x: x >= 0, all_estimates):\n-        if float(e)+delta < min(fees_per_kb) or float(e)-delta > max(fees_per_kb):\n-            raise AssertionError(\"Estimated fee (%f) out of range (%f,%f)\"%(float(e), min_fee_kb, max_fee_kb))\n+        # Node1 mines small-but-not-tiny blocks, and allows free transactions.\n+        # NOTE: the CreateNewBlock code starts counting block size at 1,000 bytes,\n+        # so blockmaxsize of 2,000 is really just 1,000 bytes (room enough for\n+        # 6 or 7 transactions)\n+        nodes.append(start_node(1, test_dir,\n+                                [\"-blockprioritysize=1500\", \"-blockmaxsize=2000\",\n+                                 \"-debug=mempool\", \"-debug=estimatefee\"]))\n+        connect_nodes(nodes[1], 0)\n+\n+        # Node2 is a stingy miner, that\n+        # produces very small blocks (room for only 3 or so transactions)\n+        node2args = [ \"-blockprioritysize=0\", \"-blockmaxsize=1500\",\n+                      \"-debug=mempool\", \"-debug=estimatefee\"]\n+        nodes.append(start_node(2, test_dir, node2args))\n+        connect_nodes(nodes[2], 0)\n \n-    # Generate transactions while mining 30 more blocks, this time with node1:\n-    for i in range(30):\n-        for j in range(random.randrange(6-4,6+4)):\n-            (txid, txhex, fee) = random_transaction(nodes, Decimal(\"1.1\"),\n-                                                    Decimal(\"0.0\"), min_fee, 20)\n+        sync_blocks(nodes)\n+        return nodes\n+        \n+\n+    def run_test(self, nodes):\n+        # Prime the memory pool with pairs of transactions\n+        # (high-priority, random fee and zero-priority, random fee)\n+        min_fee = Decimal(\"0.001\")\n+        fees_per_kb = [];\n+        for i in range(12):\n+            (txid, txhex, fee) = random_zeropri_transaction(nodes, Decimal(\"1.1\"),\n+                                                            min_fee, min_fee, 20)\n             tx_kbytes = (len(txhex)/2)/1000.0\n             fees_per_kb.append(float(fee)/tx_kbytes)\n-        nodes[1].setgenerate(True, 1)\n-        sync_blocks(nodes)\n \n-    all_estimates = [ nodes[0].estimatefee(i) for i in range(1,20) ]\n-    print(\"Fee estimates, more generous miner: \"+str([ str(e) for e in all_estimates]))\n-    for e in filter(lambda x: x >= 0, all_estimates):\n-        if float(e)+delta < min(fees_per_kb) or float(e)-delta > max(fees_per_kb):\n-            raise AssertionError(\"Estimated fee (%f) out of range (%f,%f)\"%(float(e), min_fee_kb, max_fee_kb))\n-\n-    # Finish by mining a normal-sized block:\n-    while len(nodes[0].getrawmempool()) > 0:\n-        nodes[0].setgenerate(True, 1)\n-        sync_blocks(nodes)\n+        # Mine blocks with node2 until the memory pool clears:\n+        count_start = nodes[2].getblockcount()\n+        while len(nodes[2].getrawmempool()) > 0:\n+            nodes[2].setgenerate(True, 1)\n+            sync_blocks(nodes)\n+\n+        all_estimates = [ nodes[0].estimatefee(i) for i in range(1,20) ]\n+        print(\"Fee estimates, super-stingy miner: \"+str([str(e) for e in all_estimates]))\n+\n+        # Estimates should be within the bounds of what transactions fees actually were:\n+        delta = 1.0e-6 # account for rounding error\n+        for e in filter(lambda x: x >= 0, all_estimates):\n+            if float(e)+delta < min(fees_per_kb) or float(e)-delta > max(fees_per_kb):\n+                raise AssertionError(\"Estimated fee (%f) out of range (%f,%f)\"%(float(e), min_fee_kb, max_fee_kb))\n+\n+        # Generate transactions while mining 30 more blocks, this time with node1:\n+        for i in range(30):\n+            for j in range(random.randrange(6-4,6+4)):\n+                (txid, txhex, fee) = random_transaction(nodes, Decimal(\"1.1\"),\n+                                                        Decimal(\"0.0\"), min_fee, 20)\n+                tx_kbytes = (len(txhex)/2)/1000.0\n+                fees_per_kb.append(float(fee)/tx_kbytes)\n+            nodes[1].setgenerate(True, 1)\n+            sync_blocks(nodes)\n+\n+        all_estimates = [ nodes[0].estimatefee(i) for i in range(1,20) ]\n+        print(\"Fee estimates, more generous miner: \"+str([ str(e) for e in all_estimates]))\n+        for e in filter(lambda x: x >= 0, all_estimates):\n+            if float(e)+delta < min(fees_per_kb) or float(e)-delta > max(fees_per_kb):\n+                raise AssertionError(\"Estimated fee (%f) out of range (%f,%f)\"%(float(e), min_fee_kb, max_fee_kb))\n+\n+        # Finish by mining a normal-sized block:\n+        while len(nodes[0].getrawmempool()) > 0:\n+            nodes[0].setgenerate(True, 1)\n+            sync_blocks(nodes)\n+\n+        final_estimates = [ nodes[0].estimatefee(i) for i in range(1,20) ]\n+        print(\"Final fee estimates: \"+str([ str(e) for e in final_estimates]))\n \n-    final_estimates = [ nodes[0].estimatefee(i) for i in range(1,20) ]\n-    print(\"Final fee estimates: \"+str([ str(e) for e in final_estimates]))\n-\n-def main():\n-    import optparse\n-\n-    parser = optparse.OptionParser(usage=\"%prog [options]\")\n-    parser.add_option(\"--nocleanup\", dest=\"nocleanup\", default=False, action=\"store_true\",\n-                      help=\"Leave bitcoinds and test.* datadir on exit or error\")\n-    parser.add_option(\"--srcdir\", dest=\"srcdir\", default=\"../../src\",\n-                      help=\"Source directory containing bitcoind/bitcoin-cli (default: %default%)\")\n-    parser.add_option(\"--tmpdir\", dest=\"tmpdir\", default=tempfile.mkdtemp(prefix=\"test\"),\n-                      help=\"Root directory for datadirs\")\n-    (options, args) = parser.parse_args()\n-\n-    os.environ['PATH'] = options.srcdir+\":\"+os.environ['PATH']\n-\n-    check_json_precision()\n-\n-    success = False\n-    nodes = []\n-    try:\n-        print(\"Initializing test directory \"+options.tmpdir)\n-        print(\"  node0 running at: 127.0.0.1:%d\"%(p2p_port(0)))\n-        if not os.path.isdir(options.tmpdir):\n-            os.makedirs(options.tmpdir)\n-        initialize_chain(options.tmpdir)\n-\n-        run_test(nodes, options.tmpdir)\n-\n-        success = True\n-\n-    except AssertionError as e:\n-        print(\"Assertion failed: \"+e.message)\n-    except Exception as e:\n-        print(\"Unexpected exception caught during testing: \"+str(e))\n-        traceback.print_tb(sys.exc_info()[2])\n-\n-    if not options.nocleanup:\n-        print(\"Cleaning up\")\n-        stop_nodes(nodes)\n-        wait_bitcoinds()\n-        shutil.rmtree(options.tmpdir)\n-\n-    if success:\n-        print(\"Tests successful\")\n-        sys.exit(0)\n-    else:\n-        print(\"Failed\")\n-        sys.exit(1)\n \n if __name__ == '__main__':\n-    main()\n+    EstimateFeeTest().main()"
      },
      {
        "sha": "5a185566553f408611f59aefd1dc805b7305bb5a",
        "filename": "qa/rpc-tests/test_framework.py",
        "status": "added",
        "additions": 92,
        "deletions": 0,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/test_framework.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/test_framework.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/test_framework.py?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,92 @@\n+#!/usr/bin/env python\n+# Copyright (c) 2014 The Bitcoin Core developers\n+# Distributed under the MIT/X11 software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+# Base class for RPC testing\n+\n+# Add python-bitcoinrpc to module search path:\n+import os\n+import sys\n+sys.path.append(os.path.join(os.path.dirname(os.path.abspath(__file__)), \"python-bitcoinrpc\"))\n+\n+import shutil\n+import tempfile\n+import traceback\n+\n+from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n+from util import *\n+\n+\n+class BitcoinTestFramework(object):\n+\n+    # These may be over-ridden by subclasses:\n+    def run_test(self, nodes):\n+            assert_equal(node.getblockcount(), 200)\n+            assert_equal(node.getbalance(), 25*50)\n+\n+    def add_options(self, parser):\n+        pass\n+\n+    def setup_chain(self, tmp_directory):\n+        print(\"Initializing test directory \"+tmp_directory)\n+        initialize_chain(tmp_directory)\n+\n+    def setup_network(self, tmp_directory):\n+        nodes = start_nodes(2, tmp_directory)\n+        connect_nodes(nodes[1], 0)\n+        sync_blocks(nodes)\n+        return nodes\n+\n+    def main(self):\n+        import optparse\n+\n+        parser = optparse.OptionParser(usage=\"%prog [options]\")\n+        parser.add_option(\"--nocleanup\", dest=\"nocleanup\", default=False, action=\"store_true\",\n+                          help=\"Leave bitcoinds and test.* datadir on exit or error\")\n+        parser.add_option(\"--srcdir\", dest=\"srcdir\", default=\"../../src\",\n+                          help=\"Source directory containing bitcoind/bitcoin-cli (default: %default%)\")\n+        parser.add_option(\"--tmpdir\", dest=\"tmpdir\", default=tempfile.mkdtemp(prefix=\"test\"),\n+                          help=\"Root directory for datadirs\")\n+        self.add_options(parser)\n+        (self.options, self.args) = parser.parse_args()\n+\n+        os.environ['PATH'] = self.options.srcdir+\":\"+os.environ['PATH']\n+\n+        check_json_precision()\n+\n+        success = False\n+        nodes = []\n+        try:\n+            if not os.path.isdir(self.options.tmpdir):\n+                os.makedirs(self.options.tmpdir)\n+            self.setup_chain(self.options.tmpdir)\n+\n+            nodes = self.setup_network(self.options.tmpdir)\n+\n+            self.run_test(nodes)\n+\n+            success = True\n+\n+        except JSONRPCException as e:\n+            print(\"JSONRPC error: \"+e.error['message'])\n+            traceback.print_tb(sys.exc_info()[2])\n+        except AssertionError as e:\n+            print(\"Assertion failed: \"+e.message)\n+            traceback.print_tb(sys.exc_info()[2])\n+        except Exception as e:\n+            print(\"Unexpected exception caught during testing: \"+str(e))\n+            traceback.print_tb(sys.exc_info()[2])\n+\n+        if not self.options.nocleanup:\n+            print(\"Cleaning up\")\n+            stop_nodes(nodes)\n+            wait_bitcoinds()\n+            shutil.rmtree(self.options.tmpdir)\n+\n+        if success:\n+            print(\"Tests successful\")\n+            sys.exit(0)\n+        else:\n+            print(\"Failed\")\n+            sys.exit(1)"
      },
      {
        "sha": "da2b6df19799ca827ef9ad7eff08e9f9cda9e2fa",
        "filename": "qa/rpc-tests/util.py",
        "status": "modified",
        "additions": 19,
        "deletions": 8,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/util.py?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -59,7 +59,7 @@ def sync_mempools(rpc_connections):\n         time.sleep(1)\n         \n \n-bitcoind_processes = []\n+bitcoind_processes = {}\n \n def initialize_datadir(dir, n):\n     datadir = os.path.join(dir, \"node\"+str(n))\n@@ -85,10 +85,10 @@ def initialize_chain(test_dir):\n         # Create cache directories, run bitcoinds:\n         for i in range(4):\n             datadir=initialize_datadir(\"cache\", i)\n-            args = [ \"bitcoind\", \"-keypool=1\", \"-datadir=\"+datadir ]\n+            args = [ \"bitcoind\", \"-keypool=1\", \"-datadir=\"+datadir, \"-discover=0\" ]\n             if i > 0:\n                 args.append(\"-connect=127.0.0.1:\"+str(p2p_port(0)))\n-            bitcoind_processes.append(subprocess.Popen(args))\n+            bitcoind_processes[i] = subprocess.Popen(args)\n             subprocess.check_call([ \"bitcoin-cli\", \"-datadir=\"+datadir,\n                                     \"-rpcwait\", \"getblockcount\"], stdout=devnull)\n         devnull.close()\n@@ -147,16 +147,18 @@ def start_node(i, dir, extra_args=None, rpchost=None):\n     Start a bitcoind and return RPC connection to it\n     \"\"\"\n     datadir = os.path.join(dir, \"node\"+str(i))\n-    args = [ \"bitcoind\", \"-datadir=\"+datadir, \"-keypool=1\" ]\n+    args = [ \"bitcoind\", \"-datadir=\"+datadir, \"-keypool=1\", \"-discover=0\" ]\n     if extra_args is not None: args.extend(extra_args)\n-    bitcoind_processes.append(subprocess.Popen(args))\n+    bitcoind_processes[i] = subprocess.Popen(args)\n     devnull = open(\"/dev/null\", \"w+\")\n     subprocess.check_call([ \"bitcoin-cli\", \"-datadir=\"+datadir] +\n                           _rpchost_to_args(rpchost)  +\n                           [\"-rpcwait\", \"getblockcount\"], stdout=devnull)\n     devnull.close()\n     url = \"http://rt:rt@%s:%d\" % (rpchost or '127.0.0.1', rpc_port(i))\n-    return AuthServiceProxy(url)\n+    proxy = AuthServiceProxy(url)\n+    proxy.url = url # store URL on proxy for info\n+    return proxy\n \n def start_nodes(num_nodes, dir, extra_args=None, rpchost=None):\n     \"\"\"\n@@ -168,20 +170,29 @@ def start_nodes(num_nodes, dir, extra_args=None, rpchost=None):\n def debug_log(dir, n_node):\n     return os.path.join(dir, \"node\"+str(n_node), \"regtest\", \"debug.log\")\n \n+def stop_node(node, i):\n+    node.stop()\n+    bitcoind_processes[i].wait()\n+    del bitcoind_processes[i]\n+\n def stop_nodes(nodes):\n     for i in range(len(nodes)):\n         nodes[i].stop()\n     del nodes[:] # Emptying array closes connections as a side effect\n \n def wait_bitcoinds():\n     # Wait for all bitcoinds to cleanly exit\n-    for bitcoind in bitcoind_processes:\n+    for bitcoind in bitcoind_processes.values():\n         bitcoind.wait()\n-    del bitcoind_processes[:]\n+    bitcoind_processes.clear()\n \n def connect_nodes(from_connection, node_num):\n     ip_port = \"127.0.0.1:\"+str(p2p_port(node_num))\n     from_connection.addnode(ip_port, \"onetry\")\n+    # poll until version handshake complete to avoid race conditions\n+    # with transaction relaying\n+    while any(peer['version'] == 0 for peer in from_connection.getpeerinfo()):\n+        time.sleep(0.1)\n \n def find_output(node, txid, amount):\n     \"\"\""
      },
      {
        "sha": "b726ef627fac4139a690f058df3d25e2aa617bb9",
        "filename": "qa/rpc-tests/util.sh",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/util.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/util.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/util.sh?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -38,6 +38,10 @@ function AssertEqual {\n   if (( $( echo \"$1 == $2\" | bc ) == 0 ))\n   then\n     echoerr \"AssertEqual: $1 != $2\"\n+    declare -f CleanUp > /dev/null 2>&1\n+    if [[ $? -eq 0 ]] ; then\n+        CleanUp\n+    fi\n     exit 1\n   fi\n }\n@@ -49,6 +53,10 @@ function CheckBalance {\n   if (( $( echo \"$B == $EXPECT\" | bc ) == 0 ))\n   then\n     echoerr \"bad balance: $B (expected $2)\"\n+    declare -f CleanUp > /dev/null 2>&1\n+    if [[ $? -eq 0 ]] ; then\n+        CleanUp\n+    fi\n     exit 1\n   fi\n }"
      },
      {
        "sha": "bc52a7dacd205bc1364f33992ccc2b5ace1fe7b6",
        "filename": "qa/rpc-tests/zapwallettxes.sh",
        "status": "added",
        "additions": 161,
        "deletions": 0,
        "changes": 161,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/zapwallettxes.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/qa/rpc-tests/zapwallettxes.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/zapwallettxes.sh?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,161 @@\n+#!/usr/bin/env bash\n+\n+# Test -zapwallettxes=<mode>\n+\n+if [ $# -lt 1 ]; then\n+        echo \"Usage: $0 path_to_binaries\"\n+        echo \"e.g. $0 ../../src\"\n+        exit 1\n+fi\n+\n+set -f\n+\n+BITCOIND=${1}/bitcoind\n+CLI=${1}/bitcoin-cli\n+\n+DIR=\"${BASH_SOURCE%/*}\"\n+SENDANDWAIT=\"${DIR}/send.sh\"\n+if [[ ! -d \"$DIR\" ]]; then DIR=\"$PWD\"; fi\n+. \"$DIR/util.sh\"\n+\n+D=$(mktemp -d test.XXXXX)\n+\n+D1=${D}/node1\n+CreateDataDir \"$D1\" port=11000 rpcport=11001\n+B1ARGS=\"-datadir=$D1\"\n+$BITCOIND $B1ARGS &\n+B1PID=$!\n+\n+D2=${D}/node2\n+CreateDataDir \"$D2\" port=11010 rpcport=11011\n+B2ARGS=\"-datadir=$D2\"\n+$BITCOIND $B2ARGS &\n+B2PID=$!\n+\n+function CleanUp {\n+$CLI $B2ARGS stop > /dev/null 2>&1\n+wait $B2PID\n+$CLI $B1ARGS stop > /dev/null 2>&1\n+wait $B1PID\n+\n+rm -rf $D\n+}\n+\n+# 110 blocks, 10 mature == 500 XBT\n+$CLI $B1ARGS setgenerate true 110\n+$CLI $B2ARGS setgenerate true 110\n+\n+CheckBalance \"$B1ARGS\" 500\n+CheckBalance \"$B2ARGS\" 500\n+\n+# Send 10 XBT\n+TXID1_DEFAULT=$($CLI $B1ARGS sendtoaddress \"mrhz5ZgSF3C1BSdyCKt3gEdhKoRL5BNfJV\" 10)\n+TXID2_DEFAULT=$($CLI $B2ARGS sendtoaddress \"mrhz5ZgSF3C1BSdyCKt3gEdhKoRL5BNfJV\" 10)\n+\n+CheckBalance $B1ARGS 490\n+CheckBalance $B2ARGS 490\n+\n+# Move 10 XBT to testaccount\n+TMP=$($CLI $B1ARGS move \"\" \"testaccount\" 10)\n+TMP=$($CLI $B2ARGS move \"\" \"testaccount\" 10)\n+\n+CheckBalance $B1ARGS 10 \"testaccount\"\n+CheckBalance $B2ARGS 10 \"testaccount\"\n+\n+# Send 1 XBT from testaccount\n+TXID1_TESTACCOUNT=$($CLI $B1ARGS sendfrom \"testaccount\" \"mrhz5ZgSF3C1BSdyCKt3gEdhKoRL5BNfJV\" 1)\n+TXID2_TESTACCOUNT=$($CLI $B2ARGS sendfrom \"testaccount\" \"mrhz5ZgSF3C1BSdyCKt3gEdhKoRL5BNfJV\" 1)\n+\n+CheckBalance $B1ARGS 9 \"testaccount\"\n+CheckBalance $B2ARGS 9 \"testaccount\"\n+\n+CheckBalance $B1ARGS 489\n+CheckBalance $B2ARGS 489\n+\n+# Confirm transactions\n+$CLI $B1ARGS setgenerate true 1\n+$CLI $B2ARGS setgenerate true 1\n+\n+# Create unconfirmed transaction\n+TXID1_UNCONFIRMED=$($CLI $B1ARGS sendtoaddress \"mrhz5ZgSF3C1BSdyCKt3gEdhKoRL5BNfJV\" 1)\n+TXID2_UNCONFIRMED=$($CLI $B2ARGS sendtoaddress \"mrhz5ZgSF3C1BSdyCKt3gEdhKoRL5BNfJV\" 1)\n+\n+# check balance (we created another 50 and spent 1 in the meantime)\n+CheckBalance $B1ARGS 538\n+CheckBalance $B2ARGS 538\n+\n+# Safety check, if unconfirmed transactions are there\n+$CLI $B1ARGS gettransaction $TXID1_UNCONFIRMED > /dev/null 2>&1\n+if [[ $? -ne 0 ]] ; then\n+    echoerr \"gettransaction1_1: $TXID1_UNCONFIRMED failed\"\n+    CleanUp\n+    exit 1\n+fi\n+$CLI $B2ARGS gettransaction $TXID2_UNCONFIRMED > /dev/null 2>&1\n+if [[ $? -ne 0 ]] ; then\n+    echoerr \"gettransaction2_1: $TXID2_UNCONFIRMED failed\"\n+    CleanUp\n+    exit 1\n+fi\n+\n+# stop nodes\n+$CLI $B2ARGS stop > /dev/null 2>&1\n+wait $B2PID\n+$CLI $B1ARGS stop > /dev/null 2>&1\n+wait $B1PID\n+\n+# restart nodes with -zapwallettxes\n+$BITCOIND -zapwallettxes=1 $B1ARGS &\n+B1PID=$!\n+$BITCOIND -zapwallettxes=2 $B2ARGS &\n+B2PID=$!\n+\n+# check if confirmed transactions are there\n+$CLI $B1ARGS gettransaction $TXID1_DEFAULT > /dev/null 2>&1\n+if [[ $? -ne 0 ]] ; then\n+    echoerr \"check confirmed transaction 1: $TXID1_DEFAULT failed\"\n+    CleanUp\n+    exit 1\n+fi\n+$CLI $B2ARGS gettransaction $TXID2_DEFAULT > /dev/null 2>&1\n+if [[ $? -ne 0 ]] ; then\n+    echoerr \"check confirmed transaction 2: $TXID2_DEFAULT failed\"\n+    CleanUp\n+    exit 1\n+fi\n+$CLI $B1ARGS gettransaction $TXID1_TESTACCOUNT > /dev/null 2>&1\n+if [[ $? -ne 0 ]] ; then\n+    echoerr \"check confirmed transaction 3: $TXID1_TESTACCOUNT failed\"\n+    CleanUp\n+    exit 1\n+fi\n+$CLI $B2ARGS gettransaction $TXID2_TESTACCOUNT > /dev/null 2>&1\n+if [[ $? -ne 0 ]] ; then\n+    echoerr \"check confirmed transaction 4: $TXID2_TESTACCOUNT failed\"\n+    CleanUp\n+    exit 1\n+fi\n+\n+# check if unconfirmed transaction is gone\n+$CLI $B1ARGS gettransaction $TXID1_UNCONFIRMED > /dev/null 2>&1\n+if [[ $? -eq 0 ]] ; then\n+    echoerr \"check unconfirmed transaction 1: $TXID1_UNCONFIRMED failed\"\n+    CleanUp\n+    exit 1\n+fi\n+$CLI $B2ARGS gettransaction $TXID2_UNCONFIRMED > /dev/null 2>&1\n+if [[ $? -eq 0 ]] ; then\n+    echoerr \"check unconfirmed transaction 2: $TXID2_UNCONFIRMED failed\"\n+    CleanUp\n+    exit 1\n+fi\n+\n+# check zapwallet mode 1, testaccount balance must be 9 (keeping transaction metadata)\n+CheckBalance $B1ARGS 9 \"testaccount\"\n+\n+# check zapwallet mode 2, testaccount balance must be 10 (dropping transaction metadata)\n+CheckBalance $B2ARGS 10 \"testaccount\"\n+\n+echo \"Tests successful, cleaning up\"\n+CleanUp\n+exit 0"
      },
      {
        "sha": "d4bd58513884cca3409ddbce15cdb3c381490bfb",
        "filename": "share/qt/extract_strings_qt.py",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/share/qt/extract_strings_qt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/share/qt/extract_strings_qt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/qt/extract_strings_qt.py?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -7,8 +7,9 @@\n import glob\n import operator\n import os\n+import sys\n \n-OUT_CPP=\"src/qt/bitcoinstrings.cpp\"\n+OUT_CPP=\"qt/bitcoinstrings.cpp\"\n EMPTY=['\"\"']\n \n def parse_po(text):\n@@ -47,7 +48,7 @@ def parse_po(text):\n \n     return messages\n \n-files = glob.glob('src/*.cpp') + glob.glob('src/*.h') \n+files = sys.argv[1:]\n \n # xgettext -n --keyword=_ $FILES\n XGETTEXT=os.getenv('XGETTEXT', 'xgettext')"
      },
      {
        "sha": "ff23747592512602209b7fc5f182144a539fa89e",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 87,
        "deletions": 24,
        "changes": 111,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -1,6 +1,10 @@\n AM_CPPFLAGS =  $(INCLUDES)\n-AM_LDFLAGS = $(PTHREAD_CFLAGS)\n+AM_LDFLAGS = $(PTHREAD_CFLAGS) $(LIBTOOL_LDFLAGS)\n \n+if USE_LIBSECP256K1\n+secp256k1/libsecp256k1.la: $(wildcard secp256k1/src/*) $(wildcard secp256k1/include/*)\n+\t@$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)\n+endif\n \n if EMBEDDED_LEVELDB\n LEVELDB_CPPFLAGS += -I$(srcdir)/leveldb/include\n@@ -17,12 +21,27 @@ $(LIBLEVELDB) $(LIBMEMENV):\n           OPT=\"$(CXXFLAGS) $(CPPFLAGS)\"\n endif\n \n+BITCOIN_CONFIG_INCLUDES=-I$(builddir)/config\n BITCOIN_INCLUDES=-I$(builddir) -I$(builddir)/obj $(BOOST_CPPFLAGS) $(LEVELDB_CPPFLAGS)\n \n+if USE_LIBSECP256K1\n+BITCOIN_INCLUDES += -I$(srcdir)/secp256k1/include\n+endif\n+\n+LIBBITCOIN_SERVER=libbitcoin_server.a\n+LIBBITCOIN_WALLET=libbitcoin_wallet.a\n+LIBBITCOIN_COMMON=libbitcoin_common.a\n+LIBBITCOIN_CLI=libbitcoin_cli.a\n+LIBBITCOIN_UTIL=libbitcoin_util.a\n+LIBBITCOIN_CRYPTO=crypto/libbitcoin_crypto.a\n+LIBBITCOINQT=qt/libbitcoinqt.a\n+\n noinst_LIBRARIES = \\\n   libbitcoin_server.a \\\n   libbitcoin_common.a \\\n-  libbitcoin_cli.a\n+  libbitcoin_cli.a \\\n+  libbitcoin_util.a \\\n+  crypto/libbitcoin_crypto.a\n if ENABLE_WALLET\n BITCOIN_INCLUDES += $(BDB_CPPFLAGS)\n noinst_LIBRARIES += libbitcoin_wallet.a\n@@ -48,6 +67,7 @@ BITCOIN_CORE_H = \\\n   base58.h \\\n   bloom.h \\\n   chainparams.h \\\n+  chainparamsbase.h \\\n   checkpoints.h \\\n   checkqueue.h \\\n   clientversion.h \\\n@@ -69,14 +89,17 @@ BITCOIN_CORE_H = \\\n   netbase.h \\\n   net.h \\\n   noui.h \\\n+  pow.h \\\n   protocol.h \\\n+  random.h \\\n   rpcclient.h \\\n   rpcprotocol.h \\\n   rpcserver.h \\\n   script.h \\\n   serialize.h \\\n   sync.h \\\n   threadsafety.h \\\n+  timedata.h \\\n   tinyformat.h \\\n   txdb.h \\\n   txmempool.h \\\n@@ -85,7 +108,8 @@ BITCOIN_CORE_H = \\\n   util.h \\\n   version.h \\\n   walletdb.h \\\n-  wallet.h\n+  wallet.h \\\n+  compat/sanity.h\n \n JSON_H = \\\n   json/json_spirit.h \\\n@@ -102,33 +126,36 @@ obj/build.h: FORCE\n \t@$(MKDIR_P) $(builddir)/obj\n \t@$(top_srcdir)/share/genbuild.sh $(abs_top_builddir)/src/obj/build.h \\\n \t  $(abs_top_srcdir)\n-libbitcoin_common_a-version.$(OBJEXT): obj/build.h\n+libbitcoin_util_a-version.$(OBJEXT): obj/build.h\n \n+# server: shared between bitcoind and bitcoin-qt\n libbitcoin_server_a_CPPFLAGS = $(BITCOIN_INCLUDES)\n libbitcoin_server_a_SOURCES = \\\n   addrman.cpp \\\n   alert.cpp \\\n   bloom.cpp \\\n   checkpoints.cpp \\\n-  coins.cpp \\\n   init.cpp \\\n-  keystore.cpp \\\n   leveldbwrapper.cpp \\\n   main.cpp \\\n   miner.cpp \\\n   net.cpp \\\n   noui.cpp \\\n+  pow.cpp \\\n   rpcblockchain.cpp \\\n   rpcmining.cpp \\\n   rpcmisc.cpp \\\n   rpcnet.cpp \\\n   rpcrawtransaction.cpp \\\n   rpcserver.cpp \\\n+  timedata.cpp \\\n   txdb.cpp \\\n   txmempool.cpp \\\n   $(JSON_H) \\\n   $(BITCOIN_CORE_H)\n \n+# wallet: shared between bitcoind and bitcoin-qt, but only linked\n+# when wallet enabled\n libbitcoin_wallet_a_CPPFLAGS = $(BITCOIN_INCLUDES)\n libbitcoin_wallet_a_SOURCES = \\\n   db.cpp \\\n@@ -139,42 +166,75 @@ libbitcoin_wallet_a_SOURCES = \\\n   walletdb.cpp \\\n   $(BITCOIN_CORE_H)\n \n+# crypto primitives library\n+crypto_libbitcoin_crypto_a_CPPFLAGS = $(BITCOIN_CONFIG_INCLUDES)\n+crypto_libbitcoin_crypto_a_SOURCES = \\\n+  crypto/sha1.cpp \\\n+  crypto/sha2.cpp \\\n+  crypto/ripemd160.cpp \\\n+  crypto/common.h \\\n+  crypto/sha2.h \\\n+  crypto/sha1.h \\\n+  crypto/ripemd160.h\n+\n+# common: shared between bitcoind, and bitcoin-qt and non-server tools\n libbitcoin_common_a_CPPFLAGS = $(BITCOIN_INCLUDES)\n libbitcoin_common_a_SOURCES = \\\n-  base58.cpp \\\n   allocators.cpp \\\n+  base58.cpp \\\n   chainparams.cpp \\\n+  coins.cpp \\\n   core.cpp \\\n   hash.cpp \\\n   key.cpp \\\n+  keystore.cpp \\\n   netbase.cpp \\\n   protocol.cpp \\\n-  rpcprotocol.cpp \\\n   script.cpp \\\n+  $(BITCOIN_CORE_H)\n+\n+# util: shared between all executables.\n+# This library *must* be included to make sure that the glibc\n+# backward-compatibility objects and their sanity checks are linked.\n+libbitcoin_util_a_CPPFLAGS = $(BITCOIN_INCLUDES)\n+libbitcoin_util_a_SOURCES = \\\n+  compat/glibc_sanity.cpp \\\n+  compat/glibcxx_sanity.cpp \\\n+  chainparamsbase.cpp \\\n+  random.cpp \\\n+  rpcprotocol.cpp \\\n   sync.cpp \\\n+  uint256.cpp \\\n   util.cpp \\\n   version.cpp \\\n   $(BITCOIN_CORE_H)\n \n if GLIBC_BACK_COMPAT\n-libbitcoin_common_a_SOURCES += compat/glibc_compat.cpp\n-libbitcoin_common_a_SOURCES += compat/glibcxx_compat.cpp\n+libbitcoin_util_a_SOURCES += compat/glibc_compat.cpp\n+libbitcoin_util_a_SOURCES += compat/glibcxx_compat.cpp\n endif\n \n+# cli: shared between bitcoin-cli and bitcoin-qt\n libbitcoin_cli_a_SOURCES = \\\n   rpcclient.cpp \\\n   $(BITCOIN_CORE_H)\n \n-nodist_libbitcoin_common_a_SOURCES = $(srcdir)/obj/build.h\n+nodist_libbitcoin_util_a_SOURCES = $(srcdir)/obj/build.h\n #\n \n # bitcoind binary #\n bitcoind_LDADD = \\\n-  libbitcoin_server.a \\\n-  libbitcoin_cli.a \\\n-  libbitcoin_common.a \\\n+  $(LIBBITCOIN_SERVER) \\\n+  $(LIBBITCOIN_COMMON) \\\n+  $(LIBBITCOIN_UTIL) \\\n+  $(LIBBITCOIN_CRYPTO) \\\n   $(LIBLEVELDB) \\\n   $(LIBMEMENV)\n+\n+if USE_LIBSECP256K1\n+  bitcoind_LDADD += secp256k1/libsecp256k1.la\n+endif\n+\n if ENABLE_WALLET\n bitcoind_LDADD += libbitcoin_wallet.a\n endif\n@@ -190,10 +250,17 @@ bitcoind_CPPFLAGS = $(BITCOIN_INCLUDES)\n \n # bitcoin-cli binary #\n bitcoin_cli_LDADD = \\\n-  libbitcoin_cli.a \\\n-  libbitcoin_common.a \\\n+  $(LIBBITCOIN_CLI) \\\n+  $(LIBBITCOIN_COMMON) \\\n+  $(LIBBITCOIN_UTIL) \\\n+  $(LIBBITCOIN_CRYPTO) \\\n   $(BOOST_LIBS)\n-bitcoin_cli_SOURCES = bitcoin-cli.cpp\n+bitcoin_cli_SOURCES = \\\n+  bitcoin-cli.cpp\n+\n+if USE_LIBSECP256K1\n+  bitcoin_cli_LDADD += secp256k1/libsecp256k1.la\n+endif\n bitcoin_cli_CPPFLAGS = $(BITCOIN_INCLUDES)\n #\n \n@@ -205,11 +272,13 @@ CLEANFILES = leveldb/libleveldb.a leveldb/libmemenv.a *.gcda *.gcno\n \n DISTCLEANFILES = obj/build.h\n \n-EXTRA_DIST = leveldb\n+EXTRA_DIST = leveldb secp256k1\n \n clean-local:\n \t-$(MAKE) -C leveldb clean\n+\t-$(MAKE) -C secp256k1 clean 2>/dev/null\n \trm -f leveldb/*/*.gcno leveldb/helpers/memenv/*.gcno\n+\t-rm -f config.h\n \n .rc.o:\n \t@test -f $(WINDRES)\n@@ -223,12 +292,6 @@ clean-local:\n \t@test -f $(PROTOC)\n \t$(AM_V_GEN) $(PROTOC) --cpp_out=$(@D) --proto_path=$(abspath $(<D) $<)\n \n-LIBBITCOIN_SERVER=libbitcoin_server.a\n-LIBBITCOIN_WALLET=libbitcoin_wallet.a\n-LIBBITCOIN_COMMON=libbitcoin_common.a\n-LIBBITCOIN_CLI=libbitcoin_cli.a\n-LIBBITCOINQT=qt/libbitcoinqt.a\n-\n if ENABLE_TESTS\n include Makefile.test.include\n endif"
      },
      {
        "sha": "2772bc753ace81635f2a52c5ed080926fa48078f",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 12,
        "deletions": 5,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -145,6 +145,7 @@ BITCOIN_MM = \\\n \n QT_MOC = \\\n   qt/bitcoin.moc \\\n+  qt/bitcoinamountfield.moc \\\n   qt/intro.moc \\\n   qt/overviewpage.moc \\\n   qt/rpcconsole.moc\n@@ -252,7 +253,10 @@ RES_ICONS = \\\n   qt/res/icons/tx_inout.png \\\n   qt/res/icons/tx_input.png \\\n   qt/res/icons/tx_output.png \\\n-  qt/res/icons/tx_mined.png\n+  qt/res/icons/tx_mined.png \\\n+  qt/res/icons/unit_btc.png \\\n+  qt/res/icons/unit_mbtc.png \\\n+  qt/res/icons/unit_ubtc.png\n \n BITCOIN_QT_CPP = \\\n   qt/bitcoinaddressvalidator.cpp \\\n@@ -355,18 +359,21 @@ qt_bitcoin_qt_LDADD = qt/libbitcoinqt.a $(LIBBITCOIN_SERVER)\n if ENABLE_WALLET\n qt_bitcoin_qt_LDADD += $(LIBBITCOIN_WALLET)\n endif\n-qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBLEVELDB) $(LIBMEMENV) \\\n+qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(LIBLEVELDB) $(LIBMEMENV) \\\n   $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS)\n-qt_bitcoin_qt_LDFLAGS = $(QT_LDFLAGS)\n+if USE_LIBSECP256K1\n+  qt_bitcoin_qt_LDADD += secp256k1/libsecp256k1.la\n+endif\n+qt_bitcoin_qt_LDFLAGS = $(AM_LDFLAGS) $(QT_LDFLAGS)\n \n #locale/foo.ts -> locale/foo.qm\n QT_QM=$(QT_TS:.ts=.qm)\n \n .SECONDARY: $(QT_QM)\n \n-qt/bitcoinstrings.cpp: $(libbitcoin_server_a_SOURCES) $(libbitcoin_common_a_SOURCES) $(libbitcoin_cli_a_SOURCES)\n+qt/bitcoinstrings.cpp: $(libbitcoin_server_a_SOURCES) $(libbitcoin_wallet_a_SOURCES)\n \t@test -n $(XGETTEXT) || echo \"xgettext is required for updating translations\"\n-\t$(AM_V_GEN) cd $(top_srcdir); XGETTEXT=$(XGETTEXT) share/qt/extract_strings_qt.py\n+\t$(AM_V_GEN) cd $(srcdir); XGETTEXT=$(XGETTEXT) ../share/qt/extract_strings_qt.py $^\n \n translate: qt/bitcoinstrings.cpp $(QT_FORMS_UI) $(QT_FORMS_UI) $(BITCOIN_QT_CPP) $(BITCOIN_QT_H) $(BITCOIN_MM)\n \t@test -n $(LUPDATE) || echo \"lupdate is required for updating translations\""
      },
      {
        "sha": "51ce006fc13bdcdba6bb51e0cb27465547df6855",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -30,10 +30,13 @@ qt_test_test_bitcoin_qt_LDADD = $(LIBBITCOINQT) $(LIBBITCOIN_SERVER)\n if ENABLE_WALLET\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_WALLET)\n endif\n-qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBLEVELDB) \\\n+qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(LIBLEVELDB) \\\n   $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n   $(QR_LIBS) $(PROTOBUF_LIBS) $(BDB_LIBS)\n-qt_test_test_bitcoin_qt_LDFLAGS = $(QT_LDFLAGS)\n+if USE_LIBSECP256K1\n+  qt_test_test_bitcoin_qt_LDADD += secp256k1/libsecp256k1.la\n+endif\n+qt_test_test_bitcoin_qt_LDFLAGS = $(AM_LDFLAGS) $(QT_LDFLAGS)\n \n CLEAN_BITCOIN_QT_TEST = $(TEST_QT_MOC_CPP) qt/test/*.gcda qt/test/*.gcno\n "
      },
      {
        "sha": "12b90adca3e7d8190de63841619e8e610d52a405",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -31,8 +31,10 @@ BITCOIN_TESTS =\\\n   test/checkblock_tests.cpp \\\n   test/Checkpoints_tests.cpp \\\n   test/compress_tests.cpp \\\n+  test/crypto_tests.cpp \\\n   test/DoS_tests.cpp \\\n   test/getarg_tests.cpp \\\n+  test/hash_tests.cpp \\\n   test/key_tests.cpp \\\n   test/main_tests.cpp \\\n   test/miner_tests.cpp \\\n@@ -45,6 +47,7 @@ BITCOIN_TESTS =\\\n   test/script_tests.cpp \\\n   test/serialize_tests.cpp \\\n   test/sigopcount_tests.cpp \\\n+  test/skiplist_tests.cpp \\\n   test/test_bitcoin.cpp \\\n   test/transaction_tests.cpp \\\n   test/uint256_tests.cpp \\\n@@ -61,11 +64,16 @@ endif\n \n test_test_bitcoin_SOURCES = $(BITCOIN_TESTS) $(JSON_TEST_FILES) $(RAW_TEST_FILES)\n test_test_bitcoin_CPPFLAGS = $(BITCOIN_INCLUDES) -I$(builddir)/test/ $(TESTDEFS)\n-test_test_bitcoin_LDADD = $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBLEVELDB) $(LIBMEMENV) \\\n+test_test_bitcoin_LDADD = $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CRYPTO) $(LIBLEVELDB) $(LIBMEMENV) \\\n   $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB)\n if ENABLE_WALLET\n test_test_bitcoin_LDADD += $(LIBBITCOIN_WALLET)\n endif\n+\n+if USE_LIBSECP256K1\n+  test_test_bitcoin_LDADD += secp256k1/libsecp256k1.la\n+endif\n+\n test_test_bitcoin_LDADD += $(BDB_LIBS)\n \n nodist_test_test_bitcoin_SOURCES = $(GENERATED_TEST_FILES)"
      },
      {
        "sha": "052d364655fef9b70187d84e8b8e124b8939cbe1",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 134,
        "deletions": 132,
        "changes": 266,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -7,16 +7,16 @@\n \n #include \"netbase.h\"\n #include \"protocol.h\"\n+#include \"random.h\"\n #include \"sync.h\"\n+#include \"timedata.h\"\n #include \"util.h\"\n \n #include <map>\n #include <set>\n #include <stdint.h>\n #include <vector>\n \n-#include <openssl/rand.h>\n-\n /** Extended statistics about a CAddress */\n class CAddrInfo : public CAddress\n {\n@@ -245,145 +245,147 @@ class CAddrMan\n     void Connected_(const CService &addr, int64_t nTime);\n \n public:\n+    // serialized format:\n+    // * version byte (currently 0)\n+    // * nKey\n+    // * nNew\n+    // * nTried\n+    // * number of \"new\" buckets\n+    // * all nNew addrinfos in vvNew\n+    // * all nTried addrinfos in vvTried\n+    // * for each bucket:\n+    //   * number of elements\n+    //   * for each element: index\n+    //\n+    // Notice that vvTried, mapAddr and vVector are never encoded explicitly;\n+    // they are instead reconstructed from the other information.\n+    //\n+    // vvNew is serialized, but only used if ADDRMAN_UNKOWN_BUCKET_COUNT didn't change,\n+    // otherwise it is reconstructed as well.\n+    //\n+    // This format is more complex, but significantly smaller (at most 1.5 MiB), and supports\n+    // changes to the ADDRMAN_ parameters without breaking the on-disk structure.\n+    //\n+    // We don't use IMPLEMENT_SERIALIZE since the serialization and deserialization code has\n+    // very little in common.\n+    template<typename Stream>\n+    void Serialize(Stream &s, int nType, int nVersionDummy) const\n+    {\n+        LOCK(cs);\n+\n+        unsigned char nVersion = 0;\n+        s << nVersion;\n+        s << nKey;\n+        s << nNew;\n+        s << nTried;\n+\n+        int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT;\n+        s << nUBuckets;\n+        std::map<int, int> mapUnkIds;\n+        int nIds = 0;\n+        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n+            if (nIds == nNew) break; // this means nNew was wrong, oh ow\n+            mapUnkIds[(*it).first] = nIds;\n+            const CAddrInfo &info = (*it).second;\n+            if (info.nRefCount) {\n+                s << info;\n+                nIds++;\n+            }\n+        }\n+        nIds = 0;\n+        for (std::map<int, CAddrInfo>::const_iterator it = mapInfo.begin(); it != mapInfo.end(); it++) {\n+            if (nIds == nTried) break; // this means nTried was wrong, oh ow\n+            const CAddrInfo &info = (*it).second;\n+            if (info.fInTried) {\n+                s << info;\n+                nIds++;\n+            }\n+        }\n+        for (std::vector<std::set<int> >::const_iterator it = vvNew.begin(); it != vvNew.end(); it++) {\n+            const std::set<int> &vNew = (*it);\n+            int nSize = vNew.size();\n+            s << nSize;\n+            for (std::set<int>::const_iterator it2 = vNew.begin(); it2 != vNew.end(); it2++) {\n+                int nIndex = mapUnkIds[*it2];\n+                s << nIndex;\n+            }\n+        }\n+    }\n \n-    IMPLEMENT_SERIALIZE\n-    (({\n-        // serialized format:\n-        // * version byte (currently 0)\n-        // * nKey\n-        // * nNew\n-        // * nTried\n-        // * number of \"new\" buckets\n-        // * all nNew addrinfos in vvNew\n-        // * all nTried addrinfos in vvTried\n-        // * for each bucket:\n-        //   * number of elements\n-        //   * for each element: index\n-        //\n-        // Notice that vvTried, mapAddr and vVector are never encoded explicitly;\n-        // they are instead reconstructed from the other information.\n-        //\n-        // vvNew is serialized, but only used if ADDRMAN_UNKOWN_BUCKET_COUNT didn't change,\n-        // otherwise it is reconstructed as well.\n-        //\n-        // This format is more complex, but significantly smaller (at most 1.5 MiB), and supports\n-        // changes to the ADDRMAN_ parameters without breaking the on-disk structure.\n-        {\n-            LOCK(cs);\n-            unsigned char nVersion = 0;\n-            READWRITE(nVersion);\n-            READWRITE(nKey);\n-            READWRITE(nNew);\n-            READWRITE(nTried);\n-\n-            CAddrMan *am = const_cast<CAddrMan*>(this);\n-            if (fWrite)\n-            {\n-                int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT;\n-                READWRITE(nUBuckets);\n-                std::map<int, int> mapUnkIds;\n-                int nIds = 0;\n-                for (std::map<int, CAddrInfo>::iterator it = am->mapInfo.begin(); it != am->mapInfo.end(); it++)\n-                {\n-                    if (nIds == nNew) break; // this means nNew was wrong, oh ow\n-                    mapUnkIds[(*it).first] = nIds;\n-                    CAddrInfo &info = (*it).second;\n-                    if (info.nRefCount)\n-                    {\n-                        READWRITE(info);\n-                        nIds++;\n-                    }\n-                }\n-                nIds = 0;\n-                for (std::map<int, CAddrInfo>::iterator it = am->mapInfo.begin(); it != am->mapInfo.end(); it++)\n-                {\n-                    if (nIds == nTried) break; // this means nTried was wrong, oh ow\n-                    CAddrInfo &info = (*it).second;\n-                    if (info.fInTried)\n-                    {\n-                        READWRITE(info);\n-                        nIds++;\n-                    }\n-                }\n-                for (std::vector<std::set<int> >::iterator it = am->vvNew.begin(); it != am->vvNew.end(); it++)\n-                {\n-                    const std::set<int> &vNew = (*it);\n-                    int nSize = vNew.size();\n-                    READWRITE(nSize);\n-                    for (std::set<int>::iterator it2 = vNew.begin(); it2 != vNew.end(); it2++)\n-                    {\n-                        int nIndex = mapUnkIds[*it2];\n-                        READWRITE(nIndex);\n-                    }\n-                }\n+    template<typename Stream>\n+    void Unserialize(Stream& s, int nType, int nVersionDummy)\n+    {\n+        LOCK(cs);\n+\n+        unsigned char nVersion;\n+        s >> nVersion;\n+        s >> nKey;\n+        s >> nNew;\n+        s >> nTried;\n+\n+        int nUBuckets = 0;\n+        s >> nUBuckets;\n+        nIdCount = 0;\n+        mapInfo.clear();\n+        mapAddr.clear();\n+        vRandom.clear();\n+        vvTried = std::vector<std::vector<int> >(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0));\n+        vvNew = std::vector<std::set<int> >(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>());\n+        for (int n = 0; n < nNew; n++) {\n+            CAddrInfo &info = mapInfo[n];\n+            s >> info;\n+            mapAddr[info] = n;\n+            info.nRandomPos = vRandom.size();\n+            vRandom.push_back(n);\n+            if (nUBuckets != ADDRMAN_NEW_BUCKET_COUNT) {\n+                vvNew[info.GetNewBucket(nKey)].insert(n);\n+                info.nRefCount++;\n+            }\n+        }\n+        nIdCount = nNew;\n+        int nLost = 0;\n+        for (int n = 0; n < nTried; n++) {\n+            CAddrInfo info;\n+            s >> info;\n+            std::vector<int> &vTried = vvTried[info.GetTriedBucket(nKey)];\n+            if (vTried.size() < ADDRMAN_TRIED_BUCKET_SIZE) {\n+                info.nRandomPos = vRandom.size();\n+                info.fInTried = true;\n+                vRandom.push_back(nIdCount);\n+                mapInfo[nIdCount] = info;\n+                mapAddr[info] = nIdCount;\n+                vTried.push_back(nIdCount);\n+                nIdCount++;\n             } else {\n-                int nUBuckets = 0;\n-                READWRITE(nUBuckets);\n-                am->nIdCount = 0;\n-                am->mapInfo.clear();\n-                am->mapAddr.clear();\n-                am->vRandom.clear();\n-                am->vvTried = std::vector<std::vector<int> >(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0));\n-                am->vvNew = std::vector<std::set<int> >(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>());\n-                for (int n = 0; n < am->nNew; n++)\n-                {\n-                    CAddrInfo &info = am->mapInfo[n];\n-                    READWRITE(info);\n-                    am->mapAddr[info] = n;\n-                    info.nRandomPos = vRandom.size();\n-                    am->vRandom.push_back(n);\n-                    if (nUBuckets != ADDRMAN_NEW_BUCKET_COUNT)\n-                    {\n-                        am->vvNew[info.GetNewBucket(am->nKey)].insert(n);\n-                        info.nRefCount++;\n-                    }\n-                }\n-                am->nIdCount = am->nNew;\n-                int nLost = 0;\n-                for (int n = 0; n < am->nTried; n++)\n-                {\n-                    CAddrInfo info;\n-                    READWRITE(info);\n-                    std::vector<int> &vTried = am->vvTried[info.GetTriedBucket(am->nKey)];\n-                    if (vTried.size() < ADDRMAN_TRIED_BUCKET_SIZE)\n-                    {\n-                        info.nRandomPos = vRandom.size();\n-                        info.fInTried = true;\n-                        am->vRandom.push_back(am->nIdCount);\n-                        am->mapInfo[am->nIdCount] = info;\n-                        am->mapAddr[info] = am->nIdCount;\n-                        vTried.push_back(am->nIdCount);\n-                        am->nIdCount++;\n-                    } else {\n-                        nLost++;\n-                    }\n-                }\n-                am->nTried -= nLost;\n-                for (int b = 0; b < nUBuckets; b++)\n-                {\n-                    std::set<int> &vNew = am->vvNew[b];\n-                    int nSize = 0;\n-                    READWRITE(nSize);\n-                    for (int n = 0; n < nSize; n++)\n-                    {\n-                        int nIndex = 0;\n-                        READWRITE(nIndex);\n-                        CAddrInfo &info = am->mapInfo[nIndex];\n-                        if (nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS)\n-                        {\n-                            info.nRefCount++;\n-                            vNew.insert(nIndex);\n-                        }\n-                    }\n+                nLost++;\n+            }\n+        }\n+        nTried -= nLost;\n+        for (int b = 0; b < nUBuckets; b++) {\n+            std::set<int> &vNew = vvNew[b];\n+            int nSize = 0;\n+            s >> nSize;\n+            for (int n = 0; n < nSize; n++) {\n+                int nIndex = 0;\n+                s >> nIndex;\n+                CAddrInfo &info = mapInfo[nIndex];\n+                if (nUBuckets == ADDRMAN_NEW_BUCKET_COUNT && info.nRefCount < ADDRMAN_NEW_BUCKETS_PER_ADDRESS) {\n+                    info.nRefCount++;\n+                    vNew.insert(nIndex);\n                 }\n             }\n         }\n-    });)\n+    }\n+\n+    unsigned int GetSerializeSize(int nType, int nVersion) const\n+    {\n+        return (CSizeComputer(nType, nVersion) << *this).size();\n+    }\n \n     CAddrMan() : vRandom(0), vvTried(ADDRMAN_TRIED_BUCKET_COUNT, std::vector<int>(0)), vvNew(ADDRMAN_NEW_BUCKET_COUNT, std::set<int>())\n     {\n          nKey.resize(32);\n-         RAND_bytes(&nKey[0], 32);\n+         GetRandBytes(&nKey[0], 32);\n \n          nIdCount = 0;\n          nTried = 0;"
      },
      {
        "sha": "258a2b52c4f770a7266aad5385a6aba1db0e9514",
        "filename": "src/alert.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/alert.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/alert.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/alert.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -8,6 +8,7 @@\n #include \"chainparams.h\"\n #include \"key.h\"\n #include \"net.h\"\n+#include \"timedata.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n "
      },
      {
        "sha": "be0be7ab96371b283c96264ecc3178025dc8f9ef",
        "filename": "src/allocators.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/allocators.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/allocators.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/allocators.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -131,7 +131,7 @@ class MemoryPageLocker\n  * Due to the unpredictable order of static initializers, we have to make sure the\n  * LockedPageManager instance exists before any other STL-based objects that use\n  * secure_allocator are created. So instead of having LockedPageManager also be\n- * static-intialized, it is created on demand.\n+ * static-initialized, it is created on demand.\n  */\n class LockedPageManager: public LockedPageManagerBase<MemoryPageLocker>\n {"
      },
      {
        "sha": "c9e91beef1d5cf4f4b29017d8dcaff6ca152ac36",
        "filename": "src/base58.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/base58.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/base58.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -114,9 +114,8 @@ std::string EncodeBase58Check(const std::vector<unsigned char>& vchIn) {\n }\n \n bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet) {\n-    if (!DecodeBase58(psz, vchRet))\n-        return false;\n-    if (vchRet.size() < 4)\n+    if (!DecodeBase58(psz, vchRet) ||\n+        (vchRet.size() < 4))\n     {\n         vchRet.clear();\n         return false;\n@@ -154,8 +153,8 @@ void CBase58Data::SetData(const std::vector<unsigned char> &vchVersionIn, const\n \n bool CBase58Data::SetString(const char* psz, unsigned int nVersionBytes) {\n     std::vector<unsigned char> vchTemp;\n-    DecodeBase58Check(psz, vchTemp);\n-    if (vchTemp.size() < nVersionBytes) {\n+    bool rc58 = DecodeBase58Check(psz, vchTemp);\n+    if ((!rc58) || (vchTemp.size() < nVersionBytes)) {\n         vchData.clear();\n         vchVersion.clear();\n         return false;\n@@ -187,6 +186,7 @@ int CBase58Data::CompareTo(const CBase58Data& b58) const {\n }\n \n namespace {\n+\n     class CBitcoinAddressVisitor : public boost::static_visitor<bool> {\n     private:\n         CBitcoinAddress *addr;\n@@ -197,7 +197,8 @@ namespace {\n         bool operator()(const CScriptID &id) const { return addr->Set(id); }\n         bool operator()(const CNoDestination &no) const { return false; }\n     };\n-};\n+\n+} // anon namespace\n \n bool CBitcoinAddress::Set(const CKeyID &id) {\n     SetData(Params().Base58Prefix(CChainParams::PUBKEY_ADDRESS), &id, 20);"
      },
      {
        "sha": "b1aa1b0e167e166ef608a90502423d855dd916f6",
        "filename": "src/bitcoin-cli-res.rc",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/bitcoin-cli-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/bitcoin-cli-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli-res.rc?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -5,7 +5,6 @@\n #define VER_PRODUCTVERSION_STR STRINGIZE(CLIENT_VERSION_MAJOR) \".\" STRINGIZE(CLIENT_VERSION_MINOR) \".\" STRINGIZE(CLIENT_VERSION_REVISION) \".\" STRINGIZE(CLIENT_VERSION_BUILD)\n #define VER_FILEVERSION        VER_PRODUCTVERSION\n #define VER_FILEVERSION_STR    VER_PRODUCTVERSION_STR\n-#define COPYRIGHT_STR          \"2009-\" STRINGIZE(COPYRIGHT_YEAR) \" The Bitcoin Core developers\"\n \n VS_VERSION_INFO VERSIONINFO\n FILEVERSION     VER_FILEVERSION"
      },
      {
        "sha": "016b2f50f5bdefeac2be055a8d8bc96fc93d49de",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 167,
        "deletions": 10,
        "changes": 177,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -7,11 +7,39 @@\n #include \"init.h\"\n #include \"rpcclient.h\"\n #include \"rpcprotocol.h\"\n-#include \"ui_interface.h\" /* for _(...) */\n-#include \"chainparams.h\"\n+#include \"chainparamsbase.h\"\n \n #include <boost/filesystem/operations.hpp>\n \n+#define _(x) std::string(x) /* Keep the _() around in case gettext or such will be used later to translate non-UI */\n+\n+using namespace std;\n+using namespace boost;\n+using namespace boost::asio;\n+using namespace json_spirit;\n+\n+std::string HelpMessageCli()\n+{\n+    string strUsage;\n+    strUsage += _(\"Options:\") + \"\\n\";\n+    strUsage += \"  -?                     \" + _(\"This help message\") + \"\\n\";\n+    strUsage += \"  -conf=<file>           \" + _(\"Specify configuration file (default: bitcoin.conf)\") + \"\\n\";\n+    strUsage += \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\";\n+    strUsage += \"  -testnet               \" + _(\"Use the test network\") + \"\\n\";\n+    strUsage += \"  -regtest               \" + _(\"Enter regression test mode, which uses a special chain in which blocks can be \"\n+                                                \"solved instantly. This is intended for regression testing tools and app development.\") + \"\\n\";\n+    strUsage += \"  -rpcconnect=<ip>       \" + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\") + \"\\n\";\n+    strUsage += \"  -rpcport=<port>        \" + _(\"Connect to JSON-RPC on <port> (default: 8332 or testnet: 18332)\") + \"\\n\";\n+    strUsage += \"  -rpcwait               \" + _(\"Wait for RPC server to start\") + \"\\n\";\n+    strUsage += \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\";\n+    strUsage += \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\";\n+\n+    strUsage += \"\\n\" + _(\"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") + \"\\n\";\n+    strUsage += \"  -rpcssl                \" + _(\"Use OpenSSL (https) for JSON-RPC connections\") + \"\\n\";\n+\n+    return strUsage;\n+}\n+\n //////////////////////////////////////////////////////////////////////////////\n //\n // Start\n@@ -33,12 +61,11 @@ static bool AppInitRPC(int argc, char* argv[])\n         fprintf(stderr,\"Error reading configuration file: %s\\n\", e.what());\n         return false;\n     }\n-    // Check for -testnet or -regtest parameter (Params() calls are only valid after this clause)\n-    if (!SelectParamsFromCommandLine()) {\n+    // Check for -testnet or -regtest parameter (BaseParams() calls are only valid after this clause)\n+    if (!SelectBaseParamsFromCommandLine()) {\n         fprintf(stderr, \"Error: Invalid combination of -regtest and -testnet.\\n\");\n         return false;\n     }\n-\n     if (argc<2 || mapArgs.count(\"-?\") || mapArgs.count(\"-help\") || mapArgs.count(\"-version\"))\n     {\n         std::string strUsage = _(\"Bitcoin Core RPC client version\") + \" \" + FormatFullVersion() + \"\\n\";\n@@ -49,7 +76,7 @@ static bool AppInitRPC(int argc, char* argv[])\n                   \"  bitcoin-cli [options] help                \" + _(\"List commands\") + \"\\n\" +\n                   \"  bitcoin-cli [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n \n-            strUsage += \"\\n\" + HelpMessageCli(true);\n+            strUsage += \"\\n\" + HelpMessageCli();\n         }\n \n         fprintf(stdout, \"%s\", strUsage.c_str());\n@@ -58,24 +85,154 @@ static bool AppInitRPC(int argc, char* argv[])\n     return true;\n }\n \n+Object CallRPC(const string& strMethod, const Array& params)\n+{\n+    if (mapArgs[\"-rpcuser\"] == \"\" && mapArgs[\"-rpcpassword\"] == \"\")\n+        throw runtime_error(strprintf(\n+            _(\"You must set rpcpassword=<password> in the configuration file:\\n%s\\n\"\n+              \"If the file does not exist, create it with owner-readable-only file permissions.\"),\n+                GetConfigFile().string().c_str()));\n+\n+    // Connect to localhost\n+    bool fUseSSL = GetBoolArg(\"-rpcssl\", false);\n+    asio::io_service io_service;\n+    ssl::context context(io_service, ssl::context::sslv23);\n+    context.set_options(ssl::context::no_sslv2);\n+    asio::ssl::stream<asio::ip::tcp::socket> sslStream(io_service, context);\n+    SSLIOStreamDevice<asio::ip::tcp> d(sslStream, fUseSSL);\n+    iostreams::stream< SSLIOStreamDevice<asio::ip::tcp> > stream(d);\n+\n+    bool fWait = GetBoolArg(\"-rpcwait\", false); // -rpcwait means try until server has started\n+    do {\n+        bool fConnected = d.connect(GetArg(\"-rpcconnect\", \"127.0.0.1\"), GetArg(\"-rpcport\", itostr(BaseParams().RPCPort())));\n+        if (fConnected) break;\n+        if (fWait)\n+            MilliSleep(1000);\n+        else\n+            throw runtime_error(\"couldn't connect to server\");\n+    } while (fWait);\n+\n+    // HTTP basic authentication\n+    string strUserPass64 = EncodeBase64(mapArgs[\"-rpcuser\"] + \":\" + mapArgs[\"-rpcpassword\"]);\n+    map<string, string> mapRequestHeaders;\n+    mapRequestHeaders[\"Authorization\"] = string(\"Basic \") + strUserPass64;\n+\n+    // Send request\n+    string strRequest = JSONRPCRequest(strMethod, params, 1);\n+    string strPost = HTTPPost(strRequest, mapRequestHeaders);\n+    stream << strPost << std::flush;\n+\n+    // Receive HTTP reply status\n+    int nProto = 0;\n+    int nStatus = ReadHTTPStatus(stream, nProto);\n+\n+    // Receive HTTP reply message headers and body\n+    map<string, string> mapHeaders;\n+    string strReply;\n+    ReadHTTPMessage(stream, mapHeaders, strReply, nProto);\n+\n+    if (nStatus == HTTP_UNAUTHORIZED)\n+        throw runtime_error(\"incorrect rpcuser or rpcpassword (authorization failed)\");\n+    else if (nStatus >= 400 && nStatus != HTTP_BAD_REQUEST && nStatus != HTTP_NOT_FOUND && nStatus != HTTP_INTERNAL_SERVER_ERROR)\n+        throw runtime_error(strprintf(\"server returned HTTP error %d\", nStatus));\n+    else if (strReply.empty())\n+        throw runtime_error(\"no response from server\");\n+\n+    // Parse reply\n+    Value valReply;\n+    if (!read_string(strReply, valReply))\n+        throw runtime_error(\"couldn't parse reply from server\");\n+    const Object& reply = valReply.get_obj();\n+    if (reply.empty())\n+        throw runtime_error(\"expected reply to have result, error and id properties\");\n+\n+    return reply;\n+}\n+\n+int CommandLineRPC(int argc, char *argv[])\n+{\n+    string strPrint;\n+    int nRet = 0;\n+    try\n+    {\n+        // Skip switches\n+        while (argc > 1 && IsSwitchChar(argv[1][0]))\n+        {\n+            argc--;\n+            argv++;\n+        }\n+\n+        // Method\n+        if (argc < 2)\n+            throw runtime_error(\"too few parameters\");\n+        string strMethod = argv[1];\n+\n+        // Parameters default to strings\n+        std::vector<std::string> strParams(&argv[2], &argv[argc]);\n+        Array params = RPCConvertValues(strMethod, strParams);\n+\n+        // Execute\n+        Object reply = CallRPC(strMethod, params);\n+\n+        // Parse reply\n+        const Value& result = find_value(reply, \"result\");\n+        const Value& error  = find_value(reply, \"error\");\n+\n+        if (error.type() != null_type)\n+        {\n+            // Error\n+            strPrint = \"error: \" + write_string(error, false);\n+            int code = find_value(error.get_obj(), \"code\").get_int();\n+            nRet = abs(code);\n+        }\n+        else\n+        {\n+            // Result\n+            if (result.type() == null_type)\n+                strPrint = \"\";\n+            else if (result.type() == str_type)\n+                strPrint = result.get_str();\n+            else\n+                strPrint = write_string(result, true);\n+        }\n+    }\n+    catch (boost::thread_interrupted) {\n+        throw;\n+    }\n+    catch (std::exception& e) {\n+        strPrint = string(\"error: \") + e.what();\n+        nRet = EXIT_FAILURE;\n+    }\n+    catch (...) {\n+        PrintExceptionContinue(NULL, \"CommandLineRPC()\");\n+        throw;\n+    }\n+\n+    if (strPrint != \"\")\n+    {\n+        fprintf((nRet == 0 ? stdout : stderr), \"%s\\n\", strPrint.c_str());\n+    }\n+    return nRet;\n+}\n+\n int main(int argc, char* argv[])\n {\n     SetupEnvironment();\n \n     try\n     {\n         if(!AppInitRPC(argc, argv))\n-            return abs(RPC_MISC_ERROR);\n+            return EXIT_FAILURE;\n     }\n     catch (std::exception& e) {\n         PrintExceptionContinue(&e, \"AppInitRPC()\");\n-        return abs(RPC_MISC_ERROR);\n+        return EXIT_FAILURE;\n     } catch (...) {\n         PrintExceptionContinue(NULL, \"AppInitRPC()\");\n-        return abs(RPC_MISC_ERROR);\n+        return EXIT_FAILURE;\n     }\n \n-    int ret = abs(RPC_MISC_ERROR);\n+    int ret = EXIT_FAILURE;\n     try\n     {\n         ret = CommandLineRPC(argc, argv);"
      },
      {
        "sha": "2e6d754495070b84475404f5ee9ed89ef5bd4e1e",
        "filename": "src/bitcoind-res.rc",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/bitcoind-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/bitcoind-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind-res.rc?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -5,7 +5,6 @@\n #define VER_PRODUCTVERSION_STR STRINGIZE(CLIENT_VERSION_MAJOR) \".\" STRINGIZE(CLIENT_VERSION_MINOR) \".\" STRINGIZE(CLIENT_VERSION_REVISION) \".\" STRINGIZE(CLIENT_VERSION_BUILD)\n #define VER_FILEVERSION        VER_PRODUCTVERSION\n #define VER_FILEVERSION_STR    VER_PRODUCTVERSION_STR\n-#define COPYRIGHT_STR          \"2009-\" STRINGIZE(COPYRIGHT_YEAR) \" The Bitcoin Core developers\"\n \n VS_VERSION_INFO VERSIONINFO\n FILEVERSION     VER_FILEVERSION"
      },
      {
        "sha": "880955481b0e041fae5adeceef99ace9b9826d3d",
        "filename": "src/bitcoind.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 9,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoind.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -4,7 +4,6 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"rpcserver.h\"\n-#include \"rpcclient.h\"\n #include \"init.h\"\n #include \"main.h\"\n #include \"noui.h\"\n@@ -94,14 +93,9 @@ bool AppInit(int argc, char* argv[])\n             else\n             {\n                 strUsage += \"\\n\" + _(\"Usage:\") + \"\\n\" +\n-                      \"  bitcoind [options]                     \" + _(\"Start Bitcoin Core Daemon\") + \"\\n\" +\n-                    _(\"Usage (deprecated, use bitcoin-cli):\") + \"\\n\" +\n-                      \"  bitcoind [options] <command> [params]  \" + _(\"Send command to Bitcoin Core\") + \"\\n\" +\n-                      \"  bitcoind [options] help                \" + _(\"List commands\") + \"\\n\" +\n-                      \"  bitcoind [options] help <command>      \" + _(\"Get help for a command\") + \"\\n\";\n+                      \"  bitcoind [options]                     \" + _(\"Start Bitcoin Core Daemon\") + \"\\n\";\n \n                 strUsage += \"\\n\" + HelpMessage(HMM_BITCOIND);\n-                strUsage += \"\\n\" + HelpMessageCli(false);\n             }\n \n             fprintf(stdout, \"%s\", strUsage.c_str());\n@@ -116,8 +110,8 @@ bool AppInit(int argc, char* argv[])\n \n         if (fCommandLine)\n         {\n-            int ret = CommandLineRPC(argc, argv);\n-            exit(ret);\n+            fprintf(stderr, \"Error: There is no RPC client functionality in bitcoind anymore. Use the bitcoin-cli utility instead.\\n\");\n+            exit(1);\n         }\n #ifndef WIN32\n         fDaemon = GetBoolArg(\"-daemon\", false);"
      },
      {
        "sha": "26e366179cad0b8ff2d2023289a6f4aac1af9242",
        "filename": "src/bloom.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/bloom.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/bloom.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -99,7 +99,7 @@ bool CBloomFilter::IsWithinSizeConstraints() const\n     return vData.size() <= MAX_BLOOM_FILTER_SIZE && nHashFuncs <= MAX_HASH_FUNCS;\n }\n \n-bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx, const uint256& hash)\n+bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx)\n {\n     bool fFound = false;\n     // Match if the filter contains the hash of tx\n@@ -108,6 +108,7 @@ bool CBloomFilter::IsRelevantAndUpdate(const CTransaction& tx, const uint256& ha\n         return true;\n     if (isEmpty)\n         return false;\n+    const uint256& hash = tx.GetHash();\n     if (contains(hash))\n         fFound = true;\n "
      },
      {
        "sha": "956bead87f872e0d155fd785d37e22d91261f2ea",
        "filename": "src/bloom.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/bloom.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/bloom.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bloom.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -83,7 +83,7 @@ class CBloomFilter\n     bool IsWithinSizeConstraints() const;\n \n     // Also adds any outputs which match the filter to the filter (to match their spending txes)\n-    bool IsRelevantAndUpdate(const CTransaction& tx, const uint256& hash);\n+    bool IsRelevantAndUpdate(const CTransaction& tx);\n \n     // Checks for empty and full filters to avoid wasting cpu\n     void UpdateEmptyFull();"
      },
      {
        "sha": "fb1d05f8333388adfafc511adaa74da5646ba158",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 28,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -6,10 +6,12 @@\n #include \"chainparams.h\"\n \n #include \"assert.h\"\n+#include \"random.h\"\n #include \"util.h\"\n \n #include <boost/assign/list_of.hpp>\n \n+using namespace std;\n using namespace boost::assign;\n \n //\n@@ -98,7 +100,8 @@ unsigned int pnSeed[] =\n class CMainParams : public CChainParams {\n public:\n     CMainParams() {\n-        networkID = CChainParams::MAIN;\n+        networkID = CBaseChainParams::MAIN;\n+        strNetworkID = \"main\";\n         // The message start string is designed to be unlikely to occur in normal data.\n         // The characters are rarely used upper ASCII, not valid as UTF-8, and produce\n         // a large 4-byte int at any alignment.\n@@ -108,13 +111,14 @@ class CMainParams : public CChainParams {\n         pchMessageStart[3] = 0xd9;\n         vAlertPubKey = ParseHex(\"04fc9702847840aaf195de8442ebecedf5b095cdbb9bc716bda9110971b28a49e0ead8564ff0db22209e0374782c093bb899692d524e9d6a6956e7c5ecbcd68284\");\n         nDefaultPort = 8333;\n-        nRPCPort = 8332;\n         bnProofOfWorkLimit = ~uint256(0) >> 32;\n         nSubsidyHalvingInterval = 210000;\n         nEnforceBlockUpgradeMajority = 750;\n         nRejectBlockOutdatedMajority = 950;\n         nToCheckBlockUpgradeMajority = 1000;\n         nMinerThreads = 0;\n+        nTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n+        nTargetSpacing = 10 * 60;\n \n         // Build the genesis block. Note that the output of the genesis coinbase cannot\n         // be spent as it did not originally exist in the database.\n@@ -125,7 +129,7 @@ class CMainParams : public CChainParams {\n         //     CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B)\n         //   vMerkleTree: 4a5e1e\n         const char* pszTimestamp = \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\";\n-        CTransaction txNew;\n+        CMutableTransaction txNew;\n         txNew.vin.resize(1);\n         txNew.vout.resize(1);\n         txNew.vin[0].scriptSig = CScript() << 486604799 << CScriptNum(4) << vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n@@ -148,6 +152,7 @@ class CMainParams : public CChainParams {\n         vSeeds.push_back(CDNSSeedData(\"dashjr.org\", \"dnsseed.bitcoin.dashjr.org\"));\n         vSeeds.push_back(CDNSSeedData(\"bitcoinstats.com\", \"seed.bitcoinstats.com\"));\n         vSeeds.push_back(CDNSSeedData(\"bitnodes.io\", \"seed.bitnodes.io\"));\n+        vSeeds.push_back(CDNSSeedData(\"open-nodes.org\", \"seeds.bitcoin.open-nodes.org\"));\n         vSeeds.push_back(CDNSSeedData(\"xf2.org\", \"bitseed.xf2.org\"));\n \n         base58Prefixes[PUBKEY_ADDRESS] = list_of(0);\n@@ -176,7 +181,6 @@ class CMainParams : public CChainParams {\n         fDefaultCheckMemPool = false;\n         fAllowMinDifficultyBlocks = false;\n         fRequireStandard = true;\n-        fRPCisTestNet = false;\n         fMineBlocksOnDemand = false;\n     }\n };\n@@ -188,7 +192,8 @@ static CMainParams mainParams;\n class CTestNetParams : public CMainParams {\n public:\n     CTestNetParams() {\n-        networkID = CChainParams::TESTNET;\n+        networkID = CBaseChainParams::TESTNET;\n+        strNetworkID = \"test\";\n         // The message start string is designed to be unlikely to occur in normal data.\n         // The characters are rarely used upper ASCII, not valid as UTF-8, and produce\n         // a large 4-byte int at any alignment.\n@@ -198,11 +203,12 @@ class CTestNetParams : public CMainParams {\n         pchMessageStart[3] = 0x07;\n         vAlertPubKey = ParseHex(\"04302390343f91cc401d56d68b123028bf52e5fca1939df127f63c6467cdf9c8e2c14b61104cf817d0b780da337893ecc4aaff1309e536162dabbdb45200ca2b0a\");\n         nDefaultPort = 18333;\n-        nRPCPort = 18332;\n         nEnforceBlockUpgradeMajority = 51;\n         nRejectBlockOutdatedMajority = 75;\n         nToCheckBlockUpgradeMajority = 100;\n-        strDataDir = \"testnet3\";\n+        nMinerThreads = 0;\n+        nTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n+        nTargetSpacing = 10 * 60;\n \n         // Modify the testnet genesis block so the timestamp is valid for a later start.\n         genesis.nTime = 1296688602;\n@@ -227,7 +233,6 @@ class CTestNetParams : public CMainParams {\n         fDefaultCheckMemPool = false;\n         fAllowMinDifficultyBlocks = true;\n         fRequireStandard = false;\n-        fRPCisTestNet = true;\n         fMineBlocksOnDemand = false;\n     }\n };\n@@ -239,7 +244,8 @@ static CTestNetParams testNetParams;\n class CRegTestParams : public CTestNetParams {\n public:\n     CRegTestParams() {\n-        networkID = CChainParams::REGTEST;\n+        networkID = CBaseChainParams::REGTEST;\n+        strNetworkID = \"regtest\";\n         pchMessageStart[0] = 0xfa;\n         pchMessageStart[1] = 0xbf;\n         pchMessageStart[2] = 0xb5;\n@@ -249,13 +255,14 @@ class CRegTestParams : public CTestNetParams {\n         nRejectBlockOutdatedMajority = 950;\n         nToCheckBlockUpgradeMajority = 1000;\n         nMinerThreads = 1;\n+        nTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n+        nTargetSpacing = 10 * 60;\n         bnProofOfWorkLimit = ~uint256(0) >> 1;\n         genesis.nTime = 1296688602;\n         genesis.nBits = 0x207fffff;\n         genesis.nNonce = 2;\n         hashGenesisBlock = genesis.GetHash();\n         nDefaultPort = 18444;\n-        strDataDir = \"regtest\";\n         assert(hashGenesisBlock == uint256(\"0x0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"));\n \n         vSeeds.clear();  // Regtest mode doesn't have any DNS seeds.\n@@ -265,27 +272,28 @@ class CRegTestParams : public CTestNetParams {\n         fDefaultCheckMemPool = true;\n         fAllowMinDifficultyBlocks = true;\n         fRequireStandard = false;\n-        fRPCisTestNet = true;\n         fMineBlocksOnDemand = true;\n     }\n };\n static CRegTestParams regTestParams;\n \n-static CChainParams *pCurrentParams = &mainParams;\n+static CChainParams *pCurrentParams = 0;\n \n const CChainParams &Params() {\n+    assert(pCurrentParams);\n     return *pCurrentParams;\n }\n \n-void SelectParams(CChainParams::Network network) {\n+void SelectParams(CBaseChainParams::Network network) {\n+    SelectBaseParams(network);\n     switch (network) {\n-        case CChainParams::MAIN:\n+        case CBaseChainParams::MAIN:\n             pCurrentParams = &mainParams;\n             break;\n-        case CChainParams::TESTNET:\n+        case CBaseChainParams::TESTNET:\n             pCurrentParams = &testNetParams;\n             break;\n-        case CChainParams::REGTEST:\n+        case CBaseChainParams::REGTEST:\n             pCurrentParams = &regTestParams;\n             break;\n         default:\n@@ -295,19 +303,9 @@ void SelectParams(CChainParams::Network network) {\n }\n \n bool SelectParamsFromCommandLine() {\n-    bool fRegTest = GetBoolArg(\"-regtest\", false);\n-    bool fTestNet = GetBoolArg(\"-testnet\", false);\n-\n-    if (fTestNet && fRegTest) {\n+    if (!SelectBaseParamsFromCommandLine())\n         return false;\n-    }\n \n-    if (fRegTest) {\n-        SelectParams(CChainParams::REGTEST);\n-    } else if (fTestNet) {\n-        SelectParams(CChainParams::TESTNET);\n-    } else {\n-        SelectParams(CChainParams::MAIN);\n-    }\n+    SelectParams(BaseParams().NetworkID());\n     return true;\n }"
      },
      {
        "sha": "446256ba82a7020ac822a89d2ef974a8f07f2d55",
        "filename": "src/chainparams.h",
        "status": "modified",
        "additions": 20,
        "deletions": 28,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/chainparams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/chainparams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -7,18 +7,17 @@\n #define BITCOIN_CHAIN_PARAMS_H\n \n #include \"core.h\"\n+#include \"chainparamsbase.h\"\n #include \"protocol.h\"\n #include \"uint256.h\"\n \n #include <vector>\n \n-using namespace std;\n-\n typedef unsigned char MessageStartChars[MESSAGE_START_SIZE];\n \n struct CDNSSeedData {\n-    string name, host;\n-    CDNSSeedData(const string &strName, const string &strHost) : name(strName), host(strHost) {}\n+    std::string name, host;\n+    CDNSSeedData(const std::string &strName, const std::string &strHost) : name(strName), host(strHost) {}\n };\n \n /**\n@@ -31,14 +30,6 @@ struct CDNSSeedData {\n class CChainParams\n {\n public:\n-    enum Network {\n-        MAIN,\n-        TESTNET,\n-        REGTEST,\n-\n-        MAX_NETWORK_TYPES\n-    };\n-\n     enum Base58Type {\n         PUBKEY_ADDRESS,\n         SCRIPT_ADDRESS,\n@@ -51,7 +42,7 @@ class CChainParams\n \n     const uint256& HashGenesisBlock() const { return hashGenesisBlock; }\n     const MessageStartChars& MessageStart() const { return pchMessageStart; }\n-    const vector<unsigned char>& AlertKey() const { return vAlertPubKey; }\n+    const std::vector<unsigned char>& AlertKey() const { return vAlertPubKey; }\n     int GetDefaultPort() const { return nDefaultPort; }\n     const uint256& ProofOfWorkLimit() const { return bnProofOfWorkLimit; }\n     int SubsidyHalvingInterval() const { return nSubsidyHalvingInterval; }\n@@ -72,44 +63,45 @@ class CChainParams\n     bool AllowMinDifficultyBlocks() const { return fAllowMinDifficultyBlocks; }\n     /* Make standard checks */\n     bool RequireStandard() const { return fRequireStandard; }\n-    /* Make standard checks */\n-    bool RPCisTestNet() const { return fRPCisTestNet; }\n-    const string& DataDir() const { return strDataDir; }\n+    int64_t TargetTimespan() const { return nTargetTimespan; }\n+    int64_t TargetSpacing() const { return nTargetSpacing; }\n+    int64_t Interval() const { return nTargetTimespan / nTargetSpacing; }\n     /* Make miner stop after a block is found. In RPC, don't return\n      * until nGenProcLimit blocks are generated */\n     bool MineBlocksOnDemand() const { return fMineBlocksOnDemand; }\n-    Network NetworkID() const { return networkID; }\n-    const vector<CDNSSeedData>& DNSSeeds() const { return vSeeds; }\n+    CBaseChainParams::Network NetworkID() const { return networkID; }\n+    /* Return the BIP70 network string (main, test or regtest) */\n+    std::string NetworkIDString() const { return strNetworkID; }\n+    const std::vector<CDNSSeedData>& DNSSeeds() const { return vSeeds; }\n     const std::vector<unsigned char>& Base58Prefix(Base58Type type) const { return base58Prefixes[type]; }\n-    const vector<CAddress>& FixedSeeds() const { return vFixedSeeds; }\n-    int RPCPort() const { return nRPCPort; }\n+    const std::vector<CAddress>& FixedSeeds() const { return vFixedSeeds; }\n protected:\n     CChainParams() {}\n \n     uint256 hashGenesisBlock;\n     MessageStartChars pchMessageStart;\n     // Raw pub key bytes for the broadcast alert signing key.\n-    vector<unsigned char> vAlertPubKey;\n+    std::vector<unsigned char> vAlertPubKey;\n     int nDefaultPort;\n-    int nRPCPort;\n     uint256 bnProofOfWorkLimit;\n     int nSubsidyHalvingInterval;\n     int nEnforceBlockUpgradeMajority;\n     int nRejectBlockOutdatedMajority;\n     int nToCheckBlockUpgradeMajority;\n-    string strDataDir;\n+    int64_t nTargetTimespan;\n+    int64_t nTargetSpacing;\n     int nMinerThreads;\n-    vector<CDNSSeedData> vSeeds;\n+    std::vector<CDNSSeedData> vSeeds;\n     std::vector<unsigned char> base58Prefixes[MAX_BASE58_TYPES];\n-    Network networkID;\n+    CBaseChainParams::Network networkID;\n+    std::string strNetworkID;\n     CBlock genesis;\n-    vector<CAddress> vFixedSeeds;\n+    std::vector<CAddress> vFixedSeeds;\n     bool fRequireRPCPassword;\n     bool fMiningRequiresPeers;\n     bool fDefaultCheckMemPool;\n     bool fAllowMinDifficultyBlocks;\n     bool fRequireStandard;\n-    bool fRPCisTestNet;\n     bool fMineBlocksOnDemand;\n };\n \n@@ -120,7 +112,7 @@ class CChainParams\n const CChainParams &Params();\n \n /** Sets the params returned by Params() to those for the given network. */\n-void SelectParams(CChainParams::Network network);\n+void SelectParams(CBaseChainParams::Network network);\n \n /**\n  * Looks for -regtest or -testnet and then calls SelectParams as appropriate."
      },
      {
        "sha": "720e24c4a8b22fd860d1bfeb87f27d70434cf769",
        "filename": "src/chainparamsbase.cpp",
        "status": "added",
        "additions": 97,
        "deletions": 0,
        "changes": 97,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/chainparamsbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/chainparamsbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,97 @@\n+// Copyright (c) 2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"chainparamsbase.h\"\n+\n+#include \"assert.h\"\n+#include \"util.h\"\n+\n+#include <boost/assign/list_of.hpp>\n+\n+using namespace boost::assign;\n+\n+//\n+// Main network\n+//\n+\n+class CBaseMainParams : public CBaseChainParams {\n+public:\n+    CBaseMainParams() {\n+        networkID = CBaseChainParams::MAIN;\n+        nRPCPort = 8332;\n+    }\n+};\n+static CBaseMainParams mainParams;\n+\n+//\n+// Testnet (v3)\n+//\n+class CBaseTestNetParams : public CBaseMainParams {\n+public:\n+    CBaseTestNetParams() {\n+        networkID = CBaseChainParams::TESTNET;\n+        nRPCPort = 18332;\n+        strDataDir = \"testnet3\";\n+    }\n+};\n+static CBaseTestNetParams testNetParams;\n+\n+//\n+// Regression test\n+//\n+class CBaseRegTestParams : public CBaseTestNetParams {\n+public:\n+    CBaseRegTestParams() {\n+        networkID = CBaseChainParams::REGTEST;\n+        strDataDir = \"regtest\";\n+    }\n+};\n+static CBaseRegTestParams regTestParams;\n+\n+static CBaseChainParams *pCurrentBaseParams = 0;\n+\n+const CBaseChainParams &BaseParams() {\n+    assert(pCurrentBaseParams);\n+    return *pCurrentBaseParams;\n+}\n+\n+void SelectBaseParams(CBaseChainParams::Network network) {\n+    switch (network) {\n+        case CBaseChainParams::MAIN:\n+            pCurrentBaseParams = &mainParams;\n+            break;\n+        case CBaseChainParams::TESTNET:\n+            pCurrentBaseParams = &testNetParams;\n+            break;\n+        case CBaseChainParams::REGTEST:\n+            pCurrentBaseParams = &regTestParams;\n+            break;\n+        default:\n+            assert(false && \"Unimplemented network\");\n+            return;\n+    }\n+}\n+\n+bool SelectBaseParamsFromCommandLine() {\n+    bool fRegTest = GetBoolArg(\"-regtest\", false);\n+    bool fTestNet = GetBoolArg(\"-testnet\", false);\n+\n+    if (fTestNet && fRegTest) {\n+        return false;\n+    }\n+\n+    if (fRegTest) {\n+        SelectBaseParams(CBaseChainParams::REGTEST);\n+    } else if (fTestNet) {\n+        SelectBaseParams(CBaseChainParams::TESTNET);\n+    } else {\n+        SelectBaseParams(CBaseChainParams::MAIN);\n+    }\n+    return true;\n+}\n+\n+bool AreBaseParamsConfigured() {\n+    return pCurrentBaseParams != NULL;\n+}"
      },
      {
        "sha": "4398f6954805088a280bd1eb022104da2954073e",
        "filename": "src/chainparamsbase.h",
        "status": "added",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/chainparamsbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/chainparamsbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparamsbase.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,58 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CHAIN_PARAMS_BASE_H\n+#define BITCOIN_CHAIN_PARAMS_BASE_H\n+\n+#include <vector>\n+#include <string>\n+\n+/**\n+ * CBaseChainParams defines the base parameters (shared between bitcoin-cli and bitcoind)\n+ * of a given instance of the Bitcoin system.\n+ */\n+class CBaseChainParams\n+{\n+public:\n+    enum Network {\n+        MAIN,\n+        TESTNET,\n+        REGTEST,\n+\n+        MAX_NETWORK_TYPES\n+    };\n+\n+    const std::string& DataDir() const { return strDataDir; }\n+    int RPCPort() const { return nRPCPort; }\n+    Network NetworkID() const { return networkID; }\n+protected:\n+    CBaseChainParams() {}\n+\n+    int nRPCPort;\n+    std::string strDataDir;\n+    Network networkID;\n+};\n+\n+/**\n+ * Return the currently selected parameters. This won't change after app startup\n+ * outside of the unit tests.\n+ */\n+const CBaseChainParams &BaseParams();\n+\n+/** Sets the params returned by Params() to those for the given network. */\n+void SelectBaseParams(CBaseChainParams::Network network);\n+\n+/**\n+ * Looks for -regtest or -testnet and then calls SelectParams as appropriate.\n+ * Returns false if an invalid combination is given.\n+ */\n+bool SelectBaseParamsFromCommandLine();\n+\n+/**\n+ * Return true if SelectBaseParamsFromCommandLine() has been called to select\n+ * a network.\n+ */\n+bool AreBaseParamsConfigured();\n+\n+#endif"
      },
      {
        "sha": "4cab11db3d4bff62db8dd466f27e01f3d638a622",
        "filename": "src/checkpoints.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/checkpoints.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/checkpoints.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -12,8 +12,8 @@\n #include <boost/assign/list_of.hpp> // for 'map_list_of()'\n #include <boost/foreach.hpp>\n \n-namespace Checkpoints\n-{\n+namespace Checkpoints {\n+\n     typedef std::map<int, uint256> MapCheckpoints;\n \n     // How many times we expect transactions after the last checkpoint to\n@@ -83,9 +83,9 @@ namespace Checkpoints\n     };\n \n     const CCheckpointData &Checkpoints() {\n-        if (Params().NetworkID() == CChainParams::TESTNET)\n+        if (Params().NetworkID() == CBaseChainParams::TESTNET)\n             return dataTestnet;\n-        else if (Params().NetworkID() == CChainParams::MAIN)\n+        else if (Params().NetworkID() == CBaseChainParams::MAIN)\n             return data;\n         else\n             return dataRegtest;\n@@ -127,7 +127,7 @@ namespace Checkpoints\n         } else {\n             double nCheapBefore = data.nTransactionsLastCheckpoint;\n             double nExpensiveBefore = pindex->nChainTx - data.nTransactionsLastCheckpoint;\n-            double nExpensiveAfter = (nNow - pindex->nTime)/86400.0*data.fTransactionsPerDay;\n+            double nExpensiveAfter = (nNow - pindex->GetBlockTime())/86400.0*data.fTransactionsPerDay;\n             fWorkBefore = nCheapBefore + nExpensiveBefore*fSigcheckVerificationFactor;\n             fWorkAfter = nExpensiveAfter*fSigcheckVerificationFactor;\n         }\n@@ -161,4 +161,5 @@ namespace Checkpoints\n         }\n         return NULL;\n     }\n-}\n+\n+} // namespace Checkpoints"
      },
      {
        "sha": "2cf8d41b9d6ea1e7573cc260e7a325f674943265",
        "filename": "src/checkpoints.h",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/checkpoints.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/checkpoints.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/checkpoints.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -13,8 +13,8 @@ class uint256;\n /** Block-chain checkpoints are compiled-in sanity checks.\n  * They are updated every release or three.\n  */\n-namespace Checkpoints\n-{\n+namespace Checkpoints {\n+\n     // Returns true if block passes checkpoint checks\n     bool CheckBlock(int nHeight, const uint256& hash);\n \n@@ -27,6 +27,7 @@ namespace Checkpoints\n     double GuessVerificationProgress(CBlockIndex *pindex, bool fSigchecks = true);\n \n     extern bool fEnabled;\n-}\n+\n+} //namespace Checkpoints\n \n #endif"
      },
      {
        "sha": "6c718a9f797872b383c43791b36bec1becf3d465",
        "filename": "src/clientversion.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/clientversion.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/clientversion.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -2,13 +2,13 @@\n #define CLIENTVERSION_H\n \n #if defined(HAVE_CONFIG_H)\n-#include \"bitcoin-config.h\"\n+#include \"config/bitcoin-config.h\"\n #else\n //\n // client versioning and copyright year\n //\n \n-// These need to be macros, as version.cpp's and bitcoin-qt.rc's voodoo requires it\n+// These need to be macros, as version.cpp's and bitcoin*-res.rc's voodoo requires it\n #define CLIENT_VERSION_MAJOR       0\n #define CLIENT_VERSION_MINOR       9\n #define CLIENT_VERSION_REVISION    99\n@@ -28,4 +28,7 @@\n #define STRINGIZE(X) DO_STRINGIZE(X)\n #define DO_STRINGIZE(X) #X\n \n+// Copyright string used in Windows .rc files\n+#define COPYRIGHT_STR          \"2009-\" STRINGIZE(COPYRIGHT_YEAR) \" The Bitcoin Core Developers\"\n+\n #endif // CLIENTVERSION_H"
      },
      {
        "sha": "fe40911db7d7f4a28565ad18949d5fe602dc351a",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 10,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -4,6 +4,8 @@\n \n #include \"coins.h\"\n \n+#include \"random.h\"\n+\n #include <assert.h>\n \n // calculate number of bytes for the bitmask, and its number of non-zero bytes\n@@ -55,7 +57,7 @@ bool CCoinsView::SetCoins(const uint256 &txid, const CCoins &coins) { return fal\n bool CCoinsView::HaveCoins(const uint256 &txid) { return false; }\n uint256 CCoinsView::GetBestBlock() { return uint256(0); }\n bool CCoinsView::SetBestBlock(const uint256 &hashBlock) { return false; }\n-bool CCoinsView::BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock) { return false; }\n+bool CCoinsView::BatchWrite(const CCoinsMap &mapCoins, const uint256 &hashBlock) { return false; }\n bool CCoinsView::GetStats(CCoinsStats &stats) { return false; }\n \n \n@@ -66,9 +68,11 @@ bool CCoinsViewBacked::HaveCoins(const uint256 &txid) { return base->HaveCoins(t\n uint256 CCoinsViewBacked::GetBestBlock() { return base->GetBestBlock(); }\n bool CCoinsViewBacked::SetBestBlock(const uint256 &hashBlock) { return base->SetBestBlock(hashBlock); }\n void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n-bool CCoinsViewBacked::BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n+bool CCoinsViewBacked::BatchWrite(const CCoinsMap &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n bool CCoinsViewBacked::GetStats(CCoinsStats &stats) { return base->GetStats(stats); }\n \n+CCoinsKeyHasher::CCoinsKeyHasher() : salt(GetRandHash()) {}\n+\n CCoinsViewCache::CCoinsViewCache(CCoinsView &baseIn, bool fDummy) : CCoinsViewBacked(baseIn), hashBlock(0) { }\n \n bool CCoinsViewCache::GetCoins(const uint256 &txid, CCoins &coins) {\n@@ -83,20 +87,20 @@ bool CCoinsViewCache::GetCoins(const uint256 &txid, CCoins &coins) {\n     return false;\n }\n \n-std::map<uint256,CCoins>::iterator CCoinsViewCache::FetchCoins(const uint256 &txid) {\n-    std::map<uint256,CCoins>::iterator it = cacheCoins.lower_bound(txid);\n-    if (it != cacheCoins.end() && it->first == txid)\n+CCoinsMap::iterator CCoinsViewCache::FetchCoins(const uint256 &txid) {\n+    CCoinsMap::iterator it = cacheCoins.find(txid);\n+    if (it != cacheCoins.end())\n         return it;\n     CCoins tmp;\n     if (!base->GetCoins(txid,tmp))\n         return cacheCoins.end();\n-    std::map<uint256,CCoins>::iterator ret = cacheCoins.insert(it, std::make_pair(txid, CCoins()));\n+    CCoinsMap::iterator ret = cacheCoins.insert(it, std::make_pair(txid, CCoins()));\n     tmp.swap(ret->second);\n     return ret;\n }\n \n CCoins &CCoinsViewCache::GetCoins(const uint256 &txid) {\n-    std::map<uint256,CCoins>::iterator it = FetchCoins(txid);\n+    CCoinsMap::iterator it = FetchCoins(txid);\n     assert(it != cacheCoins.end());\n     return it->second;\n }\n@@ -107,7 +111,12 @@ bool CCoinsViewCache::SetCoins(const uint256 &txid, const CCoins &coins) {\n }\n \n bool CCoinsViewCache::HaveCoins(const uint256 &txid) {\n-    return FetchCoins(txid) != cacheCoins.end();\n+    CCoinsMap::iterator it = FetchCoins(txid);\n+    // We're using vtx.empty() instead of IsPruned here for performance reasons,\n+    // as we only care about the case where an transaction was replaced entirely\n+    // in a reorganization (which wipes vout entirely, as opposed to spending\n+    // which just cleans individual outputs).\n+    return (it != cacheCoins.end() && !it->second.vout.empty());\n }\n \n uint256 CCoinsViewCache::GetBestBlock() {\n@@ -121,8 +130,8 @@ bool CCoinsViewCache::SetBestBlock(const uint256 &hashBlockIn) {\n     return true;\n }\n \n-bool CCoinsViewCache::BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlockIn) {\n-    for (std::map<uint256, CCoins>::const_iterator it = mapCoins.begin(); it != mapCoins.end(); it++)\n+bool CCoinsViewCache::BatchWrite(const CCoinsMap &mapCoins, const uint256 &hashBlockIn) {\n+    for (CCoinsMap::const_iterator it = mapCoins.begin(); it != mapCoins.end(); it++)\n         cacheCoins[it->first] = it->second;\n     hashBlock = hashBlockIn;\n     return true;"
      },
      {
        "sha": "9f90fe6bd03f549667efdf8d0651e2fa831c308d",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 19,
        "deletions": 5,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -13,6 +13,7 @@\n #include <stdint.h>\n \n #include <boost/foreach.hpp>\n+#include <boost/unordered_map.hpp>\n \n /** pruned version of CTransaction: only retains metadata and unspent transaction outputs\n  *\n@@ -239,6 +240,19 @@ class CCoins\n     }\n };\n \n+class CCoinsKeyHasher\n+{\n+private:\n+    uint256 salt;\n+\n+public:\n+    CCoinsKeyHasher();\n+    uint64_t operator()(const uint256& key) const {\n+        return key.GetHash(salt);\n+    }\n+};\n+\n+typedef boost::unordered_map<uint256, CCoins, CCoinsKeyHasher> CCoinsMap;\n \n struct CCoinsStats\n {\n@@ -275,7 +289,7 @@ class CCoinsView\n     virtual bool SetBestBlock(const uint256 &hashBlock);\n \n     // Do a bulk modification (multiple SetCoins + one SetBestBlock)\n-    virtual bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock);\n+    virtual bool BatchWrite(const CCoinsMap &mapCoins, const uint256 &hashBlock);\n \n     // Calculate statistics about the unspent transaction output set\n     virtual bool GetStats(CCoinsStats &stats);\n@@ -299,7 +313,7 @@ class CCoinsViewBacked : public CCoinsView\n     uint256 GetBestBlock();\n     bool SetBestBlock(const uint256 &hashBlock);\n     void SetBackend(CCoinsView &viewIn);\n-    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock);\n+    bool BatchWrite(const CCoinsMap &mapCoins, const uint256 &hashBlock);\n     bool GetStats(CCoinsStats &stats);\n };\n \n@@ -309,7 +323,7 @@ class CCoinsViewCache : public CCoinsViewBacked\n {\n protected:\n     uint256 hashBlock;\n-    std::map<uint256,CCoins> cacheCoins;\n+    CCoinsMap cacheCoins;\n \n public:\n     CCoinsViewCache(CCoinsView &baseIn, bool fDummy = false);\n@@ -320,7 +334,7 @@ class CCoinsViewCache : public CCoinsViewBacked\n     bool HaveCoins(const uint256 &txid);\n     uint256 GetBestBlock();\n     bool SetBestBlock(const uint256 &hashBlock);\n-    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock);\n+    bool BatchWrite(const CCoinsMap &mapCoins, const uint256 &hashBlock);\n \n     // Return a modifiable reference to a CCoins. Check HaveCoins first.\n     // Many methods explicitly require a CCoinsViewCache because of this method, to reduce\n@@ -352,7 +366,7 @@ class CCoinsViewCache : public CCoinsViewBacked\n     const CTxOut &GetOutputFor(const CTxIn& input);\n \n private:\n-    std::map<uint256,CCoins>::iterator FetchCoins(const uint256 &txid);\n+    CCoinsMap::iterator FetchCoins(const uint256 &txid);\n };\n \n #endif"
      },
      {
        "sha": "1b3a60d11b9747a089d506e59660604d9f7ea639",
        "filename": "src/compat.h",
        "status": "modified",
        "additions": 0,
        "deletions": 15,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/compat.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/compat.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -59,19 +59,4 @@ typedef u_int SOCKET;\n #define SOCKET_ERROR        -1\n #endif\n \n-inline int myclosesocket(SOCKET& hSocket)\n-{\n-    if (hSocket == INVALID_SOCKET)\n-        return WSAENOTSOCK;\n-#ifdef WIN32\n-    int ret = closesocket(hSocket);\n-#else\n-    int ret = close(hSocket);\n-#endif\n-    hSocket = INVALID_SOCKET;\n-    return ret;\n-}\n-#define closesocket(s)      myclosesocket(s)\n-\n-\n #endif"
      },
      {
        "sha": "22f82e4259b9473fc2da2ea1222e9623bc8debd7",
        "filename": "src/compat/glibc_compat.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 5,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/compat/glibc_compat.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/compat/glibc_compat.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibc_compat.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -1,19 +1,28 @@\n-#include \"bitcoin-config.h\"\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n #include <cstddef>\n+#if defined(HAVE_SYS_SELECT_H)\n #include <sys/select.h>\n+#endif\n \n // Prior to GLIBC_2.14, memcpy was aliased to memmove.\n extern \"C\" void* memmove(void* a, const void* b, size_t c);\n extern \"C\" void* memcpy(void* a, const void* b, size_t c)\n {\n-  return memmove(a, b, c);\n+    return memmove(a, b, c);\n }\n \n extern \"C\" void __chk_fail (void) __attribute__((__noreturn__));\n extern \"C\" FDELT_TYPE __fdelt_warn(FDELT_TYPE a)\n {\n-  if (a >= FD_SETSIZE)\n-    __chk_fail ();\n-  return a / __NFDBITS;\n+    if (a >= FD_SETSIZE)\n+        __chk_fail ();\n+    return a / __NFDBITS;\n }\n extern \"C\" FDELT_TYPE __fdelt_chk(FDELT_TYPE) __attribute__((weak, alias(\"__fdelt_warn\")));"
      },
      {
        "sha": "d93602e0fe07c0bc65469f99ad06099494759a7c",
        "filename": "src/compat/glibc_sanity.cpp",
        "status": "added",
        "additions": 67,
        "deletions": 0,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/compat/glibc_sanity.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/compat/glibc_sanity.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibc_sanity.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,67 @@\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"config/bitcoin-config.h\"\n+#endif\n+\n+#include <cstddef>\n+#if defined(HAVE_SYS_SELECT_H)\n+#include <sys/select.h>\n+#endif\n+\n+extern \"C\" void* memcpy(void* a, const void* b, size_t c);\n+void* memcpy_int(void* a, const void* b, size_t c)\n+{\n+    return memcpy(a,b,c);\n+}\n+\n+namespace {\n+// trigger: Use the memcpy_int wrapper which calls our internal memcpy.\n+//   A direct call to memcpy may be optimized away by the compiler.\n+// test: Fill an array with a sequence of integers. memcpy to a new empty array.\n+//   Verify that the arrays are equal. Use an odd size to decrease the odds of\n+//   the call being optimized away.\n+template <unsigned int T>\n+bool sanity_test_memcpy()\n+{\n+    unsigned int memcpy_test[T];\n+    unsigned int memcpy_verify[T] = {};\n+    for (unsigned int i = 0; i != T; ++i)\n+        memcpy_test[i] = i;\n+\n+    memcpy_int(memcpy_verify,memcpy_test,sizeof(memcpy_test));\n+\n+    for (unsigned int i = 0; i != T; ++i)\n+    {\n+        if(memcpy_verify[i] != i)\n+            return false;\n+    }\n+    return true;\n+}\n+\n+#if defined(HAVE_SYS_SELECT_H)\n+// trigger: Call FD_SET to trigger __fdelt_chk. FORTIFY_SOURCE must be defined\n+//   as >0 and optimizations must be set to at least -O2.\n+// test: Add a file descriptor to an empty fd_set. Verify that it has been\n+//   correctly added.\n+bool sanity_test_fdelt()\n+{\n+    fd_set fds;\n+    FD_ZERO(&fds);\n+    FD_SET(0, &fds);\n+    return FD_ISSET(0,&fds);\n+}\n+#endif\n+\n+} // anon namespace\n+\n+bool glibc_sanity_test()\n+{\n+#if defined(HAVE_SYS_SELECT_H)\n+    if (!sanity_test_fdelt())\n+        return false;\n+#endif\n+    return sanity_test_memcpy<1025>();\n+}"
      },
      {
        "sha": "417166aedae815f197c24642c08df88f5b9d7449",
        "filename": "src/compat/glibcxx_compat.cpp",
        "status": "modified",
        "additions": 28,
        "deletions": 22,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/compat/glibcxx_compat.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/compat/glibcxx_compat.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibcxx_compat.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -1,49 +1,55 @@\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n #include <cstddef>\n #include <istream>\n #include <stdexcept>\n #include <typeinfo>\n \n #ifndef _GLIBCXX_USE_NOEXCEPT\n-    #define _GLIBCXX_USE_NOEXCEPT throw()\n+#define _GLIBCXX_USE_NOEXCEPT throw()\n #endif\n \n namespace std {\n \n const char* bad_exception::what() const throw()\n {\n-  return \"std::bad_exception\";\n+    return \"std::bad_exception\";\n }\n \n const char* bad_cast::what() const throw()\n {\n-  return \"std::bad_cast\";\n+    return \"std::bad_cast\";\n }\n \n const char* bad_alloc::what() const throw()\n {\n-  return \"std::bad_alloc\";\n+    return \"std::bad_alloc\";\n }\n \n namespace __detail\n {\n struct _List_node_base\n {\n-  void _M_hook(std::__detail::_List_node_base* const __position) throw () __attribute__((used))\n-  {\n-    _M_next = __position;\n-    _M_prev = __position->_M_prev;\n-    __position->_M_prev->_M_next = this;\n-    __position->_M_prev = this;\n-  }\n-  void _M_unhook() __attribute__((used))\n-  {\n-    _List_node_base* const __next_node = _M_next;\n-    _List_node_base* const __prev_node = _M_prev;\n-    __prev_node->_M_next = __next_node;\n-    __next_node->_M_prev = __prev_node;\n-  }\n-  _List_node_base* _M_next;\n-  _List_node_base* _M_prev;\n+    void _M_hook(std::__detail::_List_node_base* const __position) throw () __attribute__((used))\n+    {\n+        _M_next = __position;\n+        _M_prev = __position->_M_prev;\n+        __position->_M_prev->_M_next = this;\n+        __position->_M_prev = this;\n+    }\n+\n+    void _M_unhook() __attribute__((used))\n+    {\n+        _List_node_base* const __next_node = _M_next;\n+        _List_node_base* const __prev_node = _M_prev;\n+        __prev_node->_M_next = __next_node;\n+        __next_node->_M_prev = __prev_node;\n+    }\n+\n+    _List_node_base* _M_next;\n+    _List_node_base* _M_prev;\n };\n } // namespace detail\n \n@@ -61,8 +67,8 @@ out_of_range::~out_of_range() _GLIBCXX_USE_NOEXCEPT { }\n // Used with permission.\n // See: https://github.com/madlib/madlib/commit/c3db418c0d34d6813608f2137fef1012ce03043d\n \n-void\n-ctype<char>::_M_widen_init() const {\n+void ctype<char>::_M_widen_init() const\n+{\n     char __tmp[sizeof(_M_widen)];\n     for (unsigned __i = 0; __i < sizeof(_M_widen); ++__i)\n         __tmp[__i] = __i;"
      },
      {
        "sha": "cd8da4fd675d76773bd67e246b085b87f3d36fc2",
        "filename": "src/compat/glibcxx_sanity.cpp",
        "status": "added",
        "additions": 65,
        "deletions": 0,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/compat/glibcxx_sanity.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/compat/glibcxx_sanity.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibcxx_sanity.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,65 @@\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <list>\n+#include <locale>\n+#include <stdexcept>\n+\n+namespace{\n+\n+// trigger: use ctype<char>::widen to trigger ctype<char>::_M_widen_init().\n+// test: convert a char from narrow to wide and back. Verify that the result\n+//   matches the original.\n+bool sanity_test_widen(char testchar)\n+{\n+    const std::ctype<char>& test(std::use_facet< std::ctype<char> >(std::locale()));\n+    return test.narrow(test.widen(testchar),'b') == testchar;\n+}\n+\n+// trigger: use list::push_back and list::pop_back to trigger _M_hook and\n+//   _M_unhook.\n+// test: Push a sequence of integers into a list. Pop them off and verify that\n+//   they match the original sequence.\n+bool sanity_test_list(unsigned int size)\n+{\n+    std::list<unsigned int> test;\n+    for (unsigned int i = 0; i != size; ++i)\n+        test.push_back(i+1);\n+\n+    if (test.size() != size)\n+        return false;\n+\n+    while (!test.empty())\n+    {\n+        if(test.back() != test.size())\n+            return false;\n+        test.pop_back();\n+    }\n+    return true;\n+}\n+\n+} // anon namespace\n+\n+// trigger: string::at(x) on an empty string to trigger __throw_out_of_range_fmt.\n+// test: force std::string to throw an out_of_range exception. Verify that\n+//   it's caught correctly.\n+bool sanity_test_range_fmt()\n+{\n+    std::string test;\n+    try\n+    {\n+        test.at(1);\n+    }\n+    catch (const std::out_of_range&)\n+    {\n+        return true;\n+    }\n+    catch (...){}\n+    return false;\n+}\n+\n+bool glibcxx_sanity_test()\n+{\n+    return sanity_test_widen('a') && sanity_test_list(100) && sanity_test_range_fmt();\n+}"
      },
      {
        "sha": "e7df44307a1a7e49a2d03201171ffca363d0ddb8",
        "filename": "src/compat/sanity.h",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/compat/sanity.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/compat/sanity.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/sanity.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,11 @@\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCON_COMPAT_SANITY_H\n+#define BITCON_COMPAT_SANITY_H\n+\n+bool glibc_sanity_test();\n+bool glibcxx_sanity_test();\n+\n+#endif // BITCON_COMPAT_SANITY_H"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "src/config/.empty",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/config/.empty",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/config/.empty",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/config/.empty?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5"
      },
      {
        "sha": "149b3532a18f23561dee2a3b7d363554611fba44",
        "filename": "src/core.cpp",
        "status": "modified",
        "additions": 31,
        "deletions": 3,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/core.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/core.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -80,9 +80,14 @@ CFeeRate::CFeeRate(int64_t nFeePaid, size_t nSize)\n         nSatoshisPerK = 0;\n }\n \n-int64_t CFeeRate::GetFee(size_t nSize)\n+int64_t CFeeRate::GetFee(size_t nSize) const\n {\n-    return nSatoshisPerK*nSize / 1000;\n+    int64_t nFee = nSatoshisPerK*nSize / 1000;\n+\n+    if (nFee == 0 && nSatoshisPerK > 0)\n+        nFee = nSatoshisPerK;\n+\n+    return nFee;\n }\n \n std::string CFeeRate::ToString() const\n@@ -91,11 +96,34 @@ std::string CFeeRate::ToString() const\n     return result;\n }\n \n-uint256 CTransaction::GetHash() const\n+CMutableTransaction::CMutableTransaction() : nVersion(CTransaction::CURRENT_VERSION), nLockTime(0) {}\n+CMutableTransaction::CMutableTransaction(const CTransaction& tx) : nVersion(tx.nVersion), vin(tx.vin), vout(tx.vout), nLockTime(tx.nLockTime) {}\n+\n+uint256 CMutableTransaction::GetHash() const\n {\n     return SerializeHash(*this);\n }\n \n+void CTransaction::UpdateHash() const\n+{\n+    *const_cast<uint256*>(&hash) = SerializeHash(*this);\n+}\n+\n+CTransaction::CTransaction() : hash(0), nVersion(CTransaction::CURRENT_VERSION), vin(), vout(), nLockTime(0) { }\n+\n+CTransaction::CTransaction(const CMutableTransaction &tx) : nVersion(tx.nVersion), vin(tx.vin), vout(tx.vout), nLockTime(tx.nLockTime) {\n+    UpdateHash();\n+}\n+\n+CTransaction& CTransaction::operator=(const CTransaction &tx) {\n+    *const_cast<int*>(&nVersion) = tx.nVersion;\n+    *const_cast<std::vector<CTxIn>*>(&vin) = tx.vin;\n+    *const_cast<std::vector<CTxOut>*>(&vout) = tx.vout;\n+    *const_cast<unsigned int*>(&nLockTime) = tx.nLockTime;\n+    *const_cast<uint256*>(&hash) = tx.hash;\n+    return *this;\n+}\n+\n int64_t CTransaction::GetValueOut() const\n {\n     int64_t nValueOut = 0;"
      },
      {
        "sha": "fb64e6c08e47f8824628b2286d9fe72bd29face8",
        "filename": "src/core.h",
        "status": "modified",
        "additions": 66,
        "deletions": 42,
        "changes": 108,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/core.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/core.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -125,13 +125,14 @@ class CFeeRate\n     CFeeRate(int64_t nFeePaid, size_t nSize);\n     CFeeRate(const CFeeRate& other) { nSatoshisPerK = other.nSatoshisPerK; }\n \n-    int64_t GetFee(size_t size); // unit returned is satoshis\n-    int64_t GetFeePerK() { return GetFee(1000); } // satoshis-per-1000-bytes\n+    int64_t GetFee(size_t size) const; // unit returned is satoshis\n+    int64_t GetFeePerK() const { return GetFee(1000); } // satoshis-per-1000-bytes\n \n     friend bool operator<(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK < b.nSatoshisPerK; }\n     friend bool operator>(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK > b.nSatoshisPerK; }\n     friend bool operator==(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK == b.nSatoshisPerK; }\n-\n+    friend bool operator<=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK <= b.nSatoshisPerK; }\n+    friend bool operator>=(const CFeeRate& a, const CFeeRate& b) { return a.nSatoshisPerK >= b.nSatoshisPerK; }\n     std::string ToString() const;\n \n     IMPLEMENT_SERIALIZE( READWRITE(nSatoshisPerK); )\n@@ -203,49 +204,57 @@ class CTxOut\n };\n \n \n+struct CMutableTransaction;\n+\n /** The basic transaction that is broadcasted on the network and contained in\n  * blocks.  A transaction can contain multiple inputs and outputs.\n  */\n class CTransaction\n {\n+private:\n+    /** Memory only. */\n+    const uint256 hash;\n+    void UpdateHash() const;\n+\n public:\n-    static CFeeRate minTxFee;\n-    static CFeeRate minRelayTxFee;\n     static const int CURRENT_VERSION=1;\n-    int nVersion;\n-    std::vector<CTxIn> vin;\n-    std::vector<CTxOut> vout;\n-    unsigned int nLockTime;\n \n-    CTransaction()\n-    {\n-        SetNull();\n-    }\n+    // The local variables are made const to prevent unintended modification\n+    // without updating the cached hash value. However, CTransaction is not\n+    // actually immutable; deserialization and assignment are implemented,\n+    // and bypass the constness. This is safe, as they update the entire\n+    // structure, including the hash.\n+    const int nVersion;\n+    const std::vector<CTxIn> vin;\n+    const std::vector<CTxOut> vout;\n+    const unsigned int nLockTime;\n \n-    IMPLEMENT_SERIALIZE\n-    (\n-        READWRITE(this->nVersion);\n+    /** Construct a CTransaction that qualifies as IsNull() */\n+    CTransaction();\n+\n+    /** Convert a CMutableTransaction into a CTransaction. */\n+    CTransaction(const CMutableTransaction &tx);\n+\n+    CTransaction& operator=(const CTransaction& tx);\n+\n+    IMPLEMENT_SERIALIZE(\n+        READWRITE(*const_cast<int*>(&this->nVersion));\n         nVersion = this->nVersion;\n-        READWRITE(vin);\n-        READWRITE(vout);\n-        READWRITE(nLockTime);\n+        READWRITE(*const_cast<std::vector<CTxIn>*>(&vin));\n+        READWRITE(*const_cast<std::vector<CTxOut>*>(&vout));\n+        READWRITE(*const_cast<unsigned int*>(&nLockTime));\n+        if (fRead)\n+            UpdateHash();\n     )\n \n-    void SetNull()\n-    {\n-        nVersion = CTransaction::CURRENT_VERSION;\n-        vin.clear();\n-        vout.clear();\n-        nLockTime = 0;\n+    bool IsNull() const {\n+        return vin.empty() && vout.empty();\n     }\n \n-    bool IsNull() const\n-    {\n-        return (vin.empty() && vout.empty());\n+    const uint256& GetHash() const {\n+        return hash;\n     }\n \n-    uint256 GetHash() const;\n-\n     // Return sum of txouts.\n     int64_t GetValueOut() const;\n     // GetValueIn() is a method on CCoinsViewCache, because\n@@ -261,22 +270,43 @@ class CTransaction\n \n     friend bool operator==(const CTransaction& a, const CTransaction& b)\n     {\n-        return (a.nVersion  == b.nVersion &&\n-                a.vin       == b.vin &&\n-                a.vout      == b.vout &&\n-                a.nLockTime == b.nLockTime);\n+        return a.hash == b.hash;\n     }\n \n     friend bool operator!=(const CTransaction& a, const CTransaction& b)\n     {\n-        return !(a == b);\n+        return a.hash != b.hash;\n     }\n \n-\n     std::string ToString() const;\n     void print() const;\n };\n \n+/** A mutable version of CTransaction. */\n+struct CMutableTransaction\n+{\n+    int nVersion;\n+    std::vector<CTxIn> vin;\n+    std::vector<CTxOut> vout;\n+    unsigned int nLockTime;\n+\n+    CMutableTransaction();\n+    CMutableTransaction(const CTransaction& tx);\n+\n+    IMPLEMENT_SERIALIZE(\n+        READWRITE(this->nVersion);\n+        nVersion = this->nVersion;\n+        READWRITE(vin);\n+        READWRITE(vout);\n+        READWRITE(nLockTime);\n+    )\n+\n+    /** Compute the hash of this CMutableTransaction. This is computed on the\n+     * fly, as opposed to GetHash() in CTransaction, which uses a cached result.\n+     */\n+    uint256 GetHash() const;\n+};\n+\n /** wrapper for CTxOut that provides a more compact serialization */\n class CTxOutCompressor\n {\n@@ -465,12 +495,6 @@ class CBlock : public CBlockHeader\n \n     uint256 BuildMerkleTree() const;\n \n-    const uint256 &GetTxHash(unsigned int nIndex) const {\n-        assert(vMerkleTree.size() > 0); // BuildMerkleTree must have been called first\n-        assert(nIndex < vtx.size());\n-        return vMerkleTree[nIndex];\n-    }\n-\n     std::vector<uint256> GetMerkleBranch(int nIndex) const;\n     static uint256 CheckMerkleBranch(uint256 hash, const std::vector<uint256>& vMerkleBranch, int nIndex);\n     void print() const;"
      },
      {
        "sha": "8f675a16c5befec8b1427a4ea2fcf810d413afb1",
        "filename": "src/crypto/common.h",
        "status": "added",
        "additions": 93,
        "deletions": 0,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/crypto/common.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/crypto/common.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/common.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,93 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_CRYPTO_COMMON_H\n+#define BITCOIN_CRYPTO_COMMON_H\n+\n+#if defined(HAVE_CONFIG_H)\n+#include \"bitcoin-config.h\"\n+#endif\n+#include <stdint.h>\n+#if defined(HAVE_ENDIAN_H)\n+#include <endian.h>\n+#endif\n+\n+uint32_t static inline ReadLE32(const unsigned char *ptr) {\n+#if HAVE_DECL_LE32TOH == 1\n+    return le32toh(*((uint32_t*)ptr));\n+#elif !defined(WORDS_BIGENDIAN)\n+    return *((uint32_t*)ptr);\n+#else\n+    return ((uint32_t)ptr[3] << 24 | (uint32_t)ptr[2] << 16 | (uint32_t)ptr[1] << 8 | (uint32_t)ptr[0]);\n+#endif\n+}\n+\n+uint64_t static inline ReadLE64(const unsigned char *ptr) {\n+\n+#if HAVE_DECL_LE64TOH == 1\n+    return le64toh(*((uint64_t*)ptr));\n+#elif !defined(WORDS_BIGENDIAN)\n+    return *((uint64_t*)ptr);\n+#else\n+    return ((uint64_t)ptr[7] << 56 | (uint64_t)ptr[6] << 48 | (uint64_t)ptr[5] << 40 | (uint64_t)ptr[4] << 32 |\n+            (uint64_t)ptr[3] << 24 | (uint64_t)ptr[2] << 16 | (uint64_t)ptr[1] << 8 | (uint64_t)ptr[0]);\n+#endif\n+}\n+\n+void static inline WriteLE32(unsigned char *ptr, uint32_t x) {\n+#if HAVE_DECL_HTOLE32 == 1\n+    *((uint32_t*)ptr) = htole32(x);\n+#elif !defined(WORDS_BIGENDIAN)\n+    *((uint32_t*)ptr) = x;\n+#else\n+    ptr[3] = x >> 24; ptr[2] = x >> 16; ptr[1] = x >> 8; ptr[0] = x;\n+#endif\n+}\n+\n+void static inline WriteLE64(unsigned char *ptr, uint64_t x) {\n+#if HAVE_DECL_HTOLE64 == 1\n+    *((uint64_t*)ptr) = htole64(x);\n+#elif !defined(WORDS_BIGENDIAN)\n+    *((uint64_t*)ptr) = x;\n+#else\n+    ptr[7] = x >> 56; ptr[6] = x >> 48; ptr[5] = x >> 40; ptr[4] = x >> 32;\n+    ptr[3] = x >> 24; ptr[2] = x >> 16; ptr[1] = x >> 8; ptr[0] = x;\n+#endif\n+}\n+\n+uint32_t static inline ReadBE32(const unsigned char *ptr) {\n+#if HAVE_DECL_BE32TOH == 1\n+    return be32toh(*((uint32_t*)ptr));\n+#else\n+    return ((uint32_t)ptr[0] << 24 | (uint32_t)ptr[1] << 16 | (uint32_t)ptr[2] << 8 | (uint32_t)ptr[3]);\n+#endif\n+}\n+\n+uint64_t static inline ReadBE64(const unsigned char *ptr) {\n+#if HAVE_DECL_BE64TOH == 1\n+    return be64toh(*((uint64_t*)ptr));\n+#else\n+    return ((uint64_t)ptr[0] << 56 | (uint64_t)ptr[1] << 48 | (uint64_t)ptr[2] << 40 | (uint64_t)ptr[3] << 32 |\n+            (uint64_t)ptr[4] << 24 | (uint64_t)ptr[5] << 16 | (uint64_t)ptr[6] << 8 | (uint64_t)ptr[7]);\n+#endif\n+}\n+\n+void static inline WriteBE32(unsigned char *ptr, uint32_t x) {\n+#if HAVE_DECL_HTOBE32 == 1\n+    *((uint32_t*)ptr) = htobe32(x);\n+#else\n+    ptr[0] = x >> 24; ptr[1] = x >> 16; ptr[2] = x >> 8; ptr[3] = x;\n+#endif\n+}\n+\n+void static inline WriteBE64(unsigned char *ptr, uint64_t x) {\n+#if HAVE_DECL_HTOBE64 == 1\n+    *((uint64_t*)ptr) = htobe64(x);\n+#else\n+    ptr[0] = x >> 56; ptr[1] = x >> 48; ptr[2] = x >> 40; ptr[3] = x >> 32;\n+    ptr[4] = x >> 24; ptr[5] = x >> 16; ptr[6] = x >> 8; ptr[7] = x;\n+#endif\n+}\n+\n+#endif"
      },
      {
        "sha": "24bd318d43e60ce1313fb0fa215fc85d23d5770c",
        "filename": "src/crypto/ripemd160.cpp",
        "status": "added",
        "additions": 204,
        "deletions": 0,
        "changes": 204,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/crypto/ripemd160.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/crypto/ripemd160.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/ripemd160.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,204 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"crypto/ripemd160.h\"\n+\n+#include \"crypto/common.h\"\n+#include <string.h>\n+\n+// Internal implementation code.\n+namespace {\n+\n+/// Internal RIPEMD-160 implementation.\n+namespace ripemd160 {\n+\n+uint32_t inline f1(uint32_t x, uint32_t y, uint32_t z) { return x ^ y ^ z; }\n+uint32_t inline f2(uint32_t x, uint32_t y, uint32_t z) { return (x & y) | (~x & z); }\n+uint32_t inline f3(uint32_t x, uint32_t y, uint32_t z) { return (x | ~y) ^ z; }\n+uint32_t inline f4(uint32_t x, uint32_t y, uint32_t z) { return (x & z) | (y & ~z); }\n+uint32_t inline f5(uint32_t x, uint32_t y, uint32_t z) { return x ^ (y | ~z); }\n+\n+/** Initialize RIPEMD-160 state. */\n+void inline Initialize(uint32_t *s) {\n+    s[0] = 0x67452301ul;\n+    s[1] = 0xEFCDAB89ul;\n+    s[2] = 0x98BADCFEul;\n+    s[3] = 0x10325476ul;\n+    s[4] = 0xC3D2E1F0ul;\n+}\n+\n+uint32_t inline rol(uint32_t x, int i) { return (x << i) | (x >> (32-i)); }\n+\n+void inline Round(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t f, uint32_t x, uint32_t k, int r) {\n+    a = rol(a + f + x + k, r) + e;\n+    c = rol(c, 10);\n+}\n+\n+void inline R11(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f1(b, c, d), x,            0, r); }\n+void inline R21(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f2(b, c, d), x, 0x5A827999ul, r); }\n+void inline R31(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f3(b, c, d), x, 0x6ED9EBA1ul, r); }\n+void inline R41(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f4(b, c, d), x, 0x8F1BBCDCul, r); }\n+void inline R51(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f5(b, c, d), x, 0xA953FD4Eul, r); }\n+\n+void inline R12(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f5(b, c, d), x, 0x50A28BE6ul, r); }\n+void inline R22(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f4(b, c, d), x, 0x5C4DD124ul, r); }\n+void inline R32(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f3(b, c, d), x, 0x6D703EF3ul, r); }\n+void inline R42(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f2(b, c, d), x, 0x7A6D76E9ul, r); }\n+void inline R52(uint32_t &a, uint32_t b, uint32_t &c, uint32_t d, uint32_t e, uint32_t x, int r) { Round(a, b, c, d, e, f1(b, c, d), x,            0, r); }\n+\n+/** Perform a RIPEMD-160 transformation, processing a 64-byte chunk. */\n+void Transform(uint32_t *s, const unsigned char *chunk) {\n+    uint32_t a1 = s[0], b1 = s[1], c1 = s[2], d1 = s[3], e1 = s[4];\n+    uint32_t a2 = a1  , b2 = b1  , c2 = c1  , d2 = d1  , e2 = e1  ;\n+    uint32_t w0  = ReadLE32(chunk +  0), w1  = ReadLE32(chunk +  4), w2  = ReadLE32(chunk +  8), w3  = ReadLE32(chunk + 12);\n+    uint32_t w4  = ReadLE32(chunk + 16), w5  = ReadLE32(chunk + 20), w6  = ReadLE32(chunk + 24), w7  = ReadLE32(chunk + 28);\n+    uint32_t w8  = ReadLE32(chunk + 32), w9  = ReadLE32(chunk + 36), w10 = ReadLE32(chunk + 40), w11 = ReadLE32(chunk + 44);\n+    uint32_t w12 = ReadLE32(chunk + 48), w13 = ReadLE32(chunk + 52), w14 = ReadLE32(chunk + 56), w15 = ReadLE32(chunk + 60);\n+\n+    R11(a1, b1, c1, d1, e1, w0 , 11); R12(a2, b2, c2, d2, e2, w5 ,  8);\n+    R11(e1, a1, b1, c1, d1, w1 , 14); R12(e2, a2, b2, c2, d2, w14,  9);\n+    R11(d1, e1, a1, b1, c1, w2 , 15); R12(d2, e2, a2, b2, c2, w7 ,  9);\n+    R11(c1, d1, e1, a1, b1, w3 , 12); R12(c2, d2, e2, a2, b2, w0 , 11);\n+    R11(b1, c1, d1, e1, a1, w4 ,  5); R12(b2, c2, d2, e2, a2, w9 , 13);\n+    R11(a1, b1, c1, d1, e1, w5 ,  8); R12(a2, b2, c2, d2, e2, w2 , 15);\n+    R11(e1, a1, b1, c1, d1, w6 ,  7); R12(e2, a2, b2, c2, d2, w11, 15);\n+    R11(d1, e1, a1, b1, c1, w7 ,  9); R12(d2, e2, a2, b2, c2, w4 ,  5);\n+    R11(c1, d1, e1, a1, b1, w8 , 11); R12(c2, d2, e2, a2, b2, w13,  7);\n+    R11(b1, c1, d1, e1, a1, w9 , 13); R12(b2, c2, d2, e2, a2, w6 ,  7);\n+    R11(a1, b1, c1, d1, e1, w10, 14); R12(a2, b2, c2, d2, e2, w15,  8);\n+    R11(e1, a1, b1, c1, d1, w11, 15); R12(e2, a2, b2, c2, d2, w8 , 11);\n+    R11(d1, e1, a1, b1, c1, w12,  6); R12(d2, e2, a2, b2, c2, w1 , 14);\n+    R11(c1, d1, e1, a1, b1, w13,  7); R12(c2, d2, e2, a2, b2, w10, 14);\n+    R11(b1, c1, d1, e1, a1, w14,  9); R12(b2, c2, d2, e2, a2, w3 , 12);\n+    R11(a1, b1, c1, d1, e1, w15,  8); R12(a2, b2, c2, d2, e2, w12,  6);\n+\n+    R21(e1, a1, b1, c1, d1, w7 ,  7); R22(e2, a2, b2, c2, d2, w6 ,  9);\n+    R21(d1, e1, a1, b1, c1, w4 ,  6); R22(d2, e2, a2, b2, c2, w11, 13);\n+    R21(c1, d1, e1, a1, b1, w13,  8); R22(c2, d2, e2, a2, b2, w3 , 15);\n+    R21(b1, c1, d1, e1, a1, w1 , 13); R22(b2, c2, d2, e2, a2, w7 ,  7);\n+    R21(a1, b1, c1, d1, e1, w10, 11); R22(a2, b2, c2, d2, e2, w0 , 12);\n+    R21(e1, a1, b1, c1, d1, w6 ,  9); R22(e2, a2, b2, c2, d2, w13,  8);\n+    R21(d1, e1, a1, b1, c1, w15,  7); R22(d2, e2, a2, b2, c2, w5 ,  9);\n+    R21(c1, d1, e1, a1, b1, w3 , 15); R22(c2, d2, e2, a2, b2, w10, 11);\n+    R21(b1, c1, d1, e1, a1, w12,  7); R22(b2, c2, d2, e2, a2, w14,  7);\n+    R21(a1, b1, c1, d1, e1, w0 , 12); R22(a2, b2, c2, d2, e2, w15,  7);\n+    R21(e1, a1, b1, c1, d1, w9 , 15); R22(e2, a2, b2, c2, d2, w8 , 12);\n+    R21(d1, e1, a1, b1, c1, w5 ,  9); R22(d2, e2, a2, b2, c2, w12,  7);\n+    R21(c1, d1, e1, a1, b1, w2 , 11); R22(c2, d2, e2, a2, b2, w4 ,  6);\n+    R21(b1, c1, d1, e1, a1, w14,  7); R22(b2, c2, d2, e2, a2, w9 , 15);\n+    R21(a1, b1, c1, d1, e1, w11, 13); R22(a2, b2, c2, d2, e2, w1 , 13);\n+    R21(e1, a1, b1, c1, d1, w8 , 12); R22(e2, a2, b2, c2, d2, w2 , 11);\n+\n+    R31(d1, e1, a1, b1, c1, w3 , 11); R32(d2, e2, a2, b2, c2, w15,  9);\n+    R31(c1, d1, e1, a1, b1, w10, 13); R32(c2, d2, e2, a2, b2, w5 ,  7);\n+    R31(b1, c1, d1, e1, a1, w14,  6); R32(b2, c2, d2, e2, a2, w1 , 15);\n+    R31(a1, b1, c1, d1, e1, w4 ,  7); R32(a2, b2, c2, d2, e2, w3 , 11);\n+    R31(e1, a1, b1, c1, d1, w9 , 14); R32(e2, a2, b2, c2, d2, w7 ,  8);\n+    R31(d1, e1, a1, b1, c1, w15,  9); R32(d2, e2, a2, b2, c2, w14,  6);\n+    R31(c1, d1, e1, a1, b1, w8 , 13); R32(c2, d2, e2, a2, b2, w6 ,  6);\n+    R31(b1, c1, d1, e1, a1, w1 , 15); R32(b2, c2, d2, e2, a2, w9 , 14);\n+    R31(a1, b1, c1, d1, e1, w2 , 14); R32(a2, b2, c2, d2, e2, w11, 12);\n+    R31(e1, a1, b1, c1, d1, w7 ,  8); R32(e2, a2, b2, c2, d2, w8 , 13);\n+    R31(d1, e1, a1, b1, c1, w0 , 13); R32(d2, e2, a2, b2, c2, w12,  5);\n+    R31(c1, d1, e1, a1, b1, w6 ,  6); R32(c2, d2, e2, a2, b2, w2 , 14);\n+    R31(b1, c1, d1, e1, a1, w13,  5); R32(b2, c2, d2, e2, a2, w10, 13);\n+    R31(a1, b1, c1, d1, e1, w11, 12); R32(a2, b2, c2, d2, e2, w0 , 13);\n+    R31(e1, a1, b1, c1, d1, w5 ,  7); R32(e2, a2, b2, c2, d2, w4 ,  7);\n+    R31(d1, e1, a1, b1, c1, w12,  5); R32(d2, e2, a2, b2, c2, w13,  5);\n+\n+    R41(c1, d1, e1, a1, b1, w1 , 11); R42(c2, d2, e2, a2, b2, w8 , 15);\n+    R41(b1, c1, d1, e1, a1, w9 , 12); R42(b2, c2, d2, e2, a2, w6 ,  5);\n+    R41(a1, b1, c1, d1, e1, w11, 14); R42(a2, b2, c2, d2, e2, w4 ,  8);\n+    R41(e1, a1, b1, c1, d1, w10, 15); R42(e2, a2, b2, c2, d2, w1 , 11);\n+    R41(d1, e1, a1, b1, c1, w0 , 14); R42(d2, e2, a2, b2, c2, w3 , 14);\n+    R41(c1, d1, e1, a1, b1, w8 , 15); R42(c2, d2, e2, a2, b2, w11, 14);\n+    R41(b1, c1, d1, e1, a1, w12,  9); R42(b2, c2, d2, e2, a2, w15,  6);\n+    R41(a1, b1, c1, d1, e1, w4 ,  8); R42(a2, b2, c2, d2, e2, w0 , 14);\n+    R41(e1, a1, b1, c1, d1, w13,  9); R42(e2, a2, b2, c2, d2, w5 ,  6);\n+    R41(d1, e1, a1, b1, c1, w3 , 14); R42(d2, e2, a2, b2, c2, w12,  9);\n+    R41(c1, d1, e1, a1, b1, w7 ,  5); R42(c2, d2, e2, a2, b2, w2 , 12);\n+    R41(b1, c1, d1, e1, a1, w15,  6); R42(b2, c2, d2, e2, a2, w13,  9);\n+    R41(a1, b1, c1, d1, e1, w14,  8); R42(a2, b2, c2, d2, e2, w9 , 12);\n+    R41(e1, a1, b1, c1, d1, w5 ,  6); R42(e2, a2, b2, c2, d2, w7 ,  5);\n+    R41(d1, e1, a1, b1, c1, w6 ,  5); R42(d2, e2, a2, b2, c2, w10, 15);\n+    R41(c1, d1, e1, a1, b1, w2 , 12); R42(c2, d2, e2, a2, b2, w14,  8);\n+\n+    R51(b1, c1, d1, e1, a1, w4 ,  9); R52(b2, c2, d2, e2, a2, w12,  8);\n+    R51(a1, b1, c1, d1, e1, w0 , 15); R52(a2, b2, c2, d2, e2, w15,  5);\n+    R51(e1, a1, b1, c1, d1, w5 ,  5); R52(e2, a2, b2, c2, d2, w10, 12);\n+    R51(d1, e1, a1, b1, c1, w9 , 11); R52(d2, e2, a2, b2, c2, w4 ,  9);\n+    R51(c1, d1, e1, a1, b1, w7 ,  6); R52(c2, d2, e2, a2, b2, w1 , 12);\n+    R51(b1, c1, d1, e1, a1, w12,  8); R52(b2, c2, d2, e2, a2, w5 ,  5);\n+    R51(a1, b1, c1, d1, e1, w2 , 13); R52(a2, b2, c2, d2, e2, w8 , 14);\n+    R51(e1, a1, b1, c1, d1, w10, 12); R52(e2, a2, b2, c2, d2, w7 ,  6);\n+    R51(d1, e1, a1, b1, c1, w14,  5); R52(d2, e2, a2, b2, c2, w6 ,  8);\n+    R51(c1, d1, e1, a1, b1, w1 , 12); R52(c2, d2, e2, a2, b2, w2 , 13);\n+    R51(b1, c1, d1, e1, a1, w3 , 13); R52(b2, c2, d2, e2, a2, w13,  6);\n+    R51(a1, b1, c1, d1, e1, w8 , 14); R52(a2, b2, c2, d2, e2, w14,  5);\n+    R51(e1, a1, b1, c1, d1, w11, 11); R52(e2, a2, b2, c2, d2, w0 , 15);\n+    R51(d1, e1, a1, b1, c1, w6 ,  8); R52(d2, e2, a2, b2, c2, w3 , 13);\n+    R51(c1, d1, e1, a1, b1, w15,  5); R52(c2, d2, e2, a2, b2, w9 , 11);\n+    R51(b1, c1, d1, e1, a1, w13,  6); R52(b2, c2, d2, e2, a2, w11, 11);\n+\n+    uint32_t t = s[0];\n+    s[0] = s[1] + c1 + d2;\n+    s[1] = s[2] + d1 + e2;\n+    s[2] = s[3] + e1 + a2;\n+    s[3] = s[4] + a1 + b2;\n+    s[4] = t    + b1 + c2;\n+}\n+\n+}  // namespace ripemd160\n+\n+}  // namespace\n+\n+////// RIPEMD160\n+\n+CRIPEMD160::CRIPEMD160() : bytes(0) {\n+    ripemd160::Initialize(s);\n+}\n+\n+CRIPEMD160& CRIPEMD160::Write(const unsigned char *data, size_t len) {\n+    const unsigned char *end = data + len;\n+    size_t bufsize = bytes % 64;\n+    if (bufsize && bufsize + len >= 64) {\n+        // Fill the buffer, and process it.\n+        memcpy(buf + bufsize, data, 64 - bufsize);\n+        bytes += 64 - bufsize;\n+        data += 64 - bufsize;\n+        ripemd160::Transform(s, buf);\n+        bufsize = 0;\n+    }\n+    while (end >= data + 64) {\n+        // Process full chunks directly from the source.\n+        ripemd160::Transform(s, data);\n+        bytes += 64;\n+        data += 64;\n+    }\n+    if (end > data) {\n+        // Fill the buffer with what remains.\n+        memcpy(buf + bufsize, data, end - data);\n+        bytes += end - data;\n+    }\n+    return *this;\n+}\n+\n+void CRIPEMD160::Finalize(unsigned char hash[OUTPUT_SIZE]) {\n+    static const unsigned char pad[64] = {0x80};\n+    unsigned char sizedesc[8];\n+    WriteLE64(sizedesc, bytes << 3);\n+    Write(pad, 1 + ((119 - (bytes % 64)) % 64));\n+    Write(sizedesc, 8);\n+    WriteLE32(hash, s[0]);\n+    WriteLE32(hash+4, s[1]);\n+    WriteLE32(hash+8, s[2]);\n+    WriteLE32(hash+12, s[3]);\n+    WriteLE32(hash+16, s[4]);\n+}\n+\n+CRIPEMD160& CRIPEMD160::Reset() {\n+    bytes = 0;\n+    ripemd160::Initialize(s);\n+    return *this;\n+}"
      },
      {
        "sha": "44bd4879a5098f820619104356e4e740e3c7f159",
        "filename": "src/crypto/ripemd160.h",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/crypto/ripemd160.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/crypto/ripemd160.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/ripemd160.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,27 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RIPEMD160_H\n+#define BITCOIN_RIPEMD160_H\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+/** A hasher class for RIPEMD-160. */\n+class CRIPEMD160 {\n+private:\n+    uint32_t s[5];\n+    unsigned char buf[64];\n+    size_t bytes;\n+\n+public:\n+    static const size_t OUTPUT_SIZE = 20;\n+\n+    CRIPEMD160();\n+    CRIPEMD160& Write(const unsigned char *data, size_t len);\n+    void Finalize(unsigned char hash[OUTPUT_SIZE]);\n+    CRIPEMD160& Reset();\n+};\n+\n+#endif"
      },
      {
        "sha": "304401a50fa64a5f66258ed56ca8fd54a8387ae7",
        "filename": "src/crypto/sha1.cpp",
        "status": "added",
        "additions": 192,
        "deletions": 0,
        "changes": 192,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/crypto/sha1.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/crypto/sha1.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha1.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,192 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"crypto/sha1.h\"\n+\n+#include \"crypto/common.h\"\n+#include <string.h>\n+\n+// Internal implementation code.\n+namespace {\n+\n+/// Internal SHA-1 implementation.\n+namespace sha1 {\n+\n+/** One round of SHA-1. */\n+void inline Round(uint32_t a, uint32_t &b, uint32_t c, uint32_t d, uint32_t &e,\n+                  uint32_t f, uint32_t k, uint32_t w) {\n+    e += ((a << 5) | (a >> 27)) + f + k + w;\n+    b = (b << 30) | (b >> 2);\n+}\n+\n+uint32_t inline f1(uint32_t b, uint32_t c, uint32_t d) { return d ^ (b & (c ^ d)); }\n+uint32_t inline f2(uint32_t b, uint32_t c, uint32_t d) { return b ^ c ^ d; }\n+uint32_t inline f3(uint32_t b, uint32_t c, uint32_t d) { return (b & c) | (d & (b | c)); }\n+\n+uint32_t inline left(uint32_t x) { return (x << 1) | (x >> 31); }\n+\n+/** Initialize SHA-1 state. */\n+void inline Initialize(uint32_t *s) {\n+    s[0] = 0x67452301ul;\n+    s[1] = 0xEFCDAB89ul;\n+    s[2] = 0x98BADCFEul;\n+    s[3] = 0x10325476ul;\n+    s[4] = 0xC3D2E1F0ul;\n+}\n+\n+const uint32_t k1 = 0x5A827999ul;\n+const uint32_t k2 = 0x6ED9EBA1ul;\n+const uint32_t k3 = 0x8F1BBCDCul;\n+const uint32_t k4 = 0xCA62C1D6ul;\n+\n+/** Perform a SHA-1 transformation, processing a 64-byte chunk. */\n+void Transform(uint32_t *s, const unsigned char *chunk) {\n+    uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4];\n+    uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n+\n+    Round(a, b, c, d, e, f1(b, c, d), k1, w0  = ReadBE32(chunk +  0));\n+    Round(e, a, b, c, d, f1(a, b, c), k1, w1  = ReadBE32(chunk +  4));\n+    Round(d, e, a, b, c, f1(e, a, b), k1, w2  = ReadBE32(chunk +  8));\n+    Round(c, d, e, a, b, f1(d, e, a), k1, w3  = ReadBE32(chunk + 12));\n+    Round(b, c, d, e, a, f1(c, d, e), k1, w4  = ReadBE32(chunk + 16));\n+    Round(a, b, c, d, e, f1(b, c, d), k1, w5  = ReadBE32(chunk + 20));\n+    Round(e, a, b, c, d, f1(a, b, c), k1, w6  = ReadBE32(chunk + 24));\n+    Round(d, e, a, b, c, f1(e, a, b), k1, w7  = ReadBE32(chunk + 28));\n+    Round(c, d, e, a, b, f1(d, e, a), k1, w8  = ReadBE32(chunk + 32));\n+    Round(b, c, d, e, a, f1(c, d, e), k1, w9  = ReadBE32(chunk + 36));\n+    Round(a, b, c, d, e, f1(b, c, d), k1, w10 = ReadBE32(chunk + 40));\n+    Round(e, a, b, c, d, f1(a, b, c), k1, w11 = ReadBE32(chunk + 44));\n+    Round(d, e, a, b, c, f1(e, a, b), k1, w12 = ReadBE32(chunk + 48));\n+    Round(c, d, e, a, b, f1(d, e, a), k1, w13 = ReadBE32(chunk + 52));\n+    Round(b, c, d, e, a, f1(c, d, e), k1, w14 = ReadBE32(chunk + 56));\n+    Round(a, b, c, d, e, f1(b, c, d), k1, w15 = ReadBE32(chunk + 60));\n+\n+    Round(e, a, b, c, d, f1(a, b, c), k1, w0  = left(w0  ^ w13 ^ w8  ^ w2 ));\n+    Round(d, e, a, b, c, f1(e, a, b), k1, w1  = left(w1  ^ w14 ^ w9  ^ w3 ));\n+    Round(c, d, e, a, b, f1(d, e, a), k1, w2  = left(w2  ^ w15 ^ w10 ^ w4 ));\n+    Round(b, c, d, e, a, f1(c, d, e), k1, w3  = left(w3  ^ w0  ^ w11 ^ w5 ));\n+    Round(a, b, c, d, e, f2(b, c, d), k2, w4  = left(w4  ^ w1  ^ w12 ^ w6 ));\n+    Round(e, a, b, c, d, f2(a, b, c), k2, w5  = left(w5  ^ w2  ^ w13 ^ w7 ));\n+    Round(d, e, a, b, c, f2(e, a, b), k2, w6  = left(w6  ^ w3  ^ w14 ^ w8 ));\n+    Round(c, d, e, a, b, f2(d, e, a), k2, w7  = left(w7  ^ w4  ^ w15 ^ w9 ));\n+    Round(b, c, d, e, a, f2(c, d, e), k2, w8  = left(w8  ^ w5  ^ w0  ^ w10));\n+    Round(a, b, c, d, e, f2(b, c, d), k2, w9  = left(w9  ^ w6  ^ w1  ^ w11));\n+    Round(e, a, b, c, d, f2(a, b, c), k2, w10 = left(w10 ^ w7  ^ w2  ^ w12));\n+    Round(d, e, a, b, c, f2(e, a, b), k2, w11 = left(w11 ^ w8  ^ w3  ^ w13));\n+    Round(c, d, e, a, b, f2(d, e, a), k2, w12 = left(w12 ^ w9  ^ w4  ^ w14));\n+    Round(b, c, d, e, a, f2(c, d, e), k2, w13 = left(w13 ^ w10 ^ w5  ^ w15));\n+    Round(a, b, c, d, e, f2(b, c, d), k2, w14 = left(w14 ^ w11 ^ w6  ^ w0 ));\n+    Round(e, a, b, c, d, f2(a, b, c), k2, w15 = left(w15 ^ w12 ^ w7  ^ w1 ));\n+\n+    Round(d, e, a, b, c, f2(e, a, b), k2, w0  = left(w0  ^ w13 ^ w8  ^ w2 ));\n+    Round(c, d, e, a, b, f2(d, e, a), k2, w1  = left(w1  ^ w14 ^ w9  ^ w3 ));\n+    Round(b, c, d, e, a, f2(c, d, e), k2, w2  = left(w2  ^ w15 ^ w10 ^ w4 ));\n+    Round(a, b, c, d, e, f2(b, c, d), k2, w3  = left(w3  ^ w0  ^ w11 ^ w5 ));\n+    Round(e, a, b, c, d, f2(a, b, c), k2, w4  = left(w4  ^ w1  ^ w12 ^ w6 ));\n+    Round(d, e, a, b, c, f2(e, a, b), k2, w5  = left(w5  ^ w2  ^ w13 ^ w7 ));\n+    Round(c, d, e, a, b, f2(d, e, a), k2, w6  = left(w6  ^ w3  ^ w14 ^ w8 ));\n+    Round(b, c, d, e, a, f2(c, d, e), k2, w7  = left(w7  ^ w4  ^ w15 ^ w9 ));\n+    Round(a, b, c, d, e, f3(b, c, d), k3, w8  = left(w8  ^ w5  ^ w0  ^ w10));\n+    Round(e, a, b, c, d, f3(a, b, c), k3, w9  = left(w9  ^ w6  ^ w1  ^ w11));\n+    Round(d, e, a, b, c, f3(e, a, b), k3, w10 = left(w10 ^ w7  ^ w2  ^ w12));\n+    Round(c, d, e, a, b, f3(d, e, a), k3, w11 = left(w11 ^ w8  ^ w3  ^ w13));\n+    Round(b, c, d, e, a, f3(c, d, e), k3, w12 = left(w12 ^ w9  ^ w4  ^ w14));\n+    Round(a, b, c, d, e, f3(b, c, d), k3, w13 = left(w13 ^ w10 ^ w5  ^ w15));\n+    Round(e, a, b, c, d, f3(a, b, c), k3, w14 = left(w14 ^ w11 ^ w6  ^ w0 ));\n+    Round(d, e, a, b, c, f3(e, a, b), k3, w15 = left(w15 ^ w12 ^ w7  ^ w1 ));\n+\n+    Round(c, d, e, a, b, f3(d, e, a), k3, w0  = left(w0  ^ w13 ^ w8  ^ w2 ));\n+    Round(b, c, d, e, a, f3(c, d, e), k3, w1  = left(w1  ^ w14 ^ w9  ^ w3 ));\n+    Round(a, b, c, d, e, f3(b, c, d), k3, w2  = left(w2  ^ w15 ^ w10 ^ w4 ));\n+    Round(e, a, b, c, d, f3(a, b, c), k3, w3  = left(w3  ^ w0  ^ w11 ^ w5 ));\n+    Round(d, e, a, b, c, f3(e, a, b), k3, w4  = left(w4  ^ w1  ^ w12 ^ w6 ));\n+    Round(c, d, e, a, b, f3(d, e, a), k3, w5  = left(w5  ^ w2  ^ w13 ^ w7 ));\n+    Round(b, c, d, e, a, f3(c, d, e), k3, w6  = left(w6  ^ w3  ^ w14 ^ w8 ));\n+    Round(a, b, c, d, e, f3(b, c, d), k3, w7  = left(w7  ^ w4  ^ w15 ^ w9 ));\n+    Round(e, a, b, c, d, f3(a, b, c), k3, w8  = left(w8  ^ w5  ^ w0  ^ w10));\n+    Round(d, e, a, b, c, f3(e, a, b), k3, w9  = left(w9  ^ w6  ^ w1  ^ w11));\n+    Round(c, d, e, a, b, f3(d, e, a), k3, w10 = left(w10 ^ w7  ^ w2  ^ w12));\n+    Round(b, c, d, e, a, f3(c, d, e), k3, w11 = left(w11 ^ w8  ^ w3  ^ w13));\n+    Round(a, b, c, d, e, f2(b, c, d), k4, w12 = left(w12 ^ w9  ^ w4  ^ w14));\n+    Round(e, a, b, c, d, f2(a, b, c), k4, w13 = left(w13 ^ w10 ^ w5  ^ w15));\n+    Round(d, e, a, b, c, f2(e, a, b), k4, w14 = left(w14 ^ w11 ^ w6  ^ w0 ));\n+    Round(c, d, e, a, b, f2(d, e, a), k4, w15 = left(w15 ^ w12 ^ w7  ^ w1 ));\n+\n+    Round(b, c, d, e, a, f2(c, d, e), k4, w0  = left(w0  ^ w13 ^ w8  ^ w2 ));\n+    Round(a, b, c, d, e, f2(b, c, d), k4, w1  = left(w1  ^ w14 ^ w9  ^ w3 ));\n+    Round(e, a, b, c, d, f2(a, b, c), k4, w2  = left(w2  ^ w15 ^ w10 ^ w4 ));\n+    Round(d, e, a, b, c, f2(e, a, b), k4, w3  = left(w3  ^ w0  ^ w11 ^ w5 ));\n+    Round(c, d, e, a, b, f2(d, e, a), k4, w4  = left(w4  ^ w1  ^ w12 ^ w6 ));\n+    Round(b, c, d, e, a, f2(c, d, e), k4, w5  = left(w5  ^ w2  ^ w13 ^ w7 ));\n+    Round(a, b, c, d, e, f2(b, c, d), k4, w6  = left(w6  ^ w3  ^ w14 ^ w8 ));\n+    Round(e, a, b, c, d, f2(a, b, c), k4, w7  = left(w7  ^ w4  ^ w15 ^ w9 ));\n+    Round(d, e, a, b, c, f2(e, a, b), k4, w8  = left(w8  ^ w5  ^ w0  ^ w10));\n+    Round(c, d, e, a, b, f2(d, e, a), k4, w9  = left(w9  ^ w6  ^ w1  ^ w11));\n+    Round(b, c, d, e, a, f2(c, d, e), k4, w10 = left(w10 ^ w7  ^ w2  ^ w12));\n+    Round(a, b, c, d, e, f2(b, c, d), k4, w11 = left(w11 ^ w8  ^ w3  ^ w13));\n+    Round(e, a, b, c, d, f2(a, b, c), k4, w12 = left(w12 ^ w9  ^ w4  ^ w14));\n+    Round(d, e, a, b, c, f2(e, a, b), k4,       left(w13 ^ w10 ^ w5  ^ w15));\n+    Round(c, d, e, a, b, f2(d, e, a), k4,       left(w14 ^ w11 ^ w6  ^ w0 ));\n+    Round(b, c, d, e, a, f2(c, d, e), k4,       left(w15 ^ w12 ^ w7  ^ w1 ));\n+\n+    s[0] += a;\n+    s[1] += b;\n+    s[2] += c;\n+    s[3] += d;\n+    s[4] += e;\n+}\n+\n+}  // namespace sha1\n+\n+}  // namespace\n+\n+////// SHA1\n+\n+CSHA1::CSHA1() : bytes(0) {\n+    sha1::Initialize(s);\n+}\n+\n+CSHA1& CSHA1::Write(const unsigned char *data, size_t len) {\n+    const unsigned char *end = data + len;\n+    size_t bufsize = bytes % 64;\n+    if (bufsize && bufsize + len >= 64) {\n+        // Fill the buffer, and process it.\n+        memcpy(buf + bufsize, data, 64 - bufsize);\n+        bytes += 64 - bufsize;\n+        data += 64 - bufsize;\n+        sha1::Transform(s, buf);\n+        bufsize = 0;\n+    }\n+    while (end >= data + 64) {\n+        // Process full chunks directly from the source.\n+        sha1::Transform(s, data);\n+        bytes += 64;\n+        data += 64;\n+    }\n+    if (end > data) {\n+        // Fill the buffer with what remains.\n+        memcpy(buf + bufsize, data, end - data);\n+        bytes += end - data;\n+    }\n+    return *this;\n+}\n+\n+void CSHA1::Finalize(unsigned char hash[OUTPUT_SIZE]) {\n+    static const unsigned char pad[64] = {0x80};\n+    unsigned char sizedesc[8];\n+    WriteBE64(sizedesc, bytes << 3);\n+    Write(pad, 1 + ((119 - (bytes % 64)) % 64));\n+    Write(sizedesc, 8);\n+    WriteBE32(hash, s[0]);\n+    WriteBE32(hash+4, s[1]);\n+    WriteBE32(hash+8, s[2]);\n+    WriteBE32(hash+12, s[3]);\n+    WriteBE32(hash+16, s[4]);\n+}\n+\n+CSHA1& CSHA1::Reset() {\n+    bytes = 0;\n+    sha1::Initialize(s);\n+    return *this;\n+}"
      },
      {
        "sha": "b16f2c88ce7c7223659cb866a0f2d09d0ee68d1f",
        "filename": "src/crypto/sha1.h",
        "status": "added",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/crypto/sha1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/crypto/sha1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha1.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,27 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SHA1_H\n+#define BITCOIN_SHA1_H\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+/** A hasher class for SHA1. */\n+class CSHA1 {\n+private:\n+    uint32_t s[5];\n+    unsigned char buf[64];\n+    size_t bytes;\n+\n+public:\n+    static const size_t OUTPUT_SIZE = 20;\n+\n+    CSHA1();\n+    CSHA1& Write(const unsigned char *data, size_t len);\n+    void Finalize(unsigned char hash[OUTPUT_SIZE]);\n+    CSHA1& Reset();\n+};\n+\n+#endif"
      },
      {
        "sha": "99a251cb1274d05cdc7c8423f6654e566140967b",
        "filename": "src/crypto/sha2.cpp",
        "status": "added",
        "additions": 398,
        "deletions": 0,
        "changes": 398,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/crypto/sha2.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/crypto/sha2.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha2.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,398 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"crypto/sha2.h\"\n+\n+#include \"crypto/common.h\"\n+#include <string.h>\n+\n+// Internal implementation code.\n+namespace {\n+\n+/// Internal SHA-256 implementation.\n+namespace sha256 {\n+\n+uint32_t inline Ch(uint32_t x, uint32_t y, uint32_t z) { return z ^ (x & (y ^ z)); }\n+uint32_t inline Maj(uint32_t x, uint32_t y, uint32_t z) { return (x & y) | (z & (x | y)); }\n+uint32_t inline Sigma0(uint32_t x) { return (x >> 2 | x << 30) ^ (x >> 13 | x << 19) ^ (x >> 22 | x << 10); }\n+uint32_t inline Sigma1(uint32_t x) { return (x >> 6 | x << 26) ^ (x >> 11 | x << 21) ^ (x >> 25 | x << 7); }\n+uint32_t inline sigma0(uint32_t x) { return (x >> 7 | x << 25) ^ (x >> 18 | x << 14) ^ (x >> 3); }\n+uint32_t inline sigma1(uint32_t x) { return (x >> 17 | x << 15) ^ (x >> 19 | x << 13) ^ (x >> 10); }\n+\n+/** One round of SHA-256. */\n+void inline Round(uint32_t a, uint32_t b, uint32_t c, uint32_t &d,\n+                  uint32_t e, uint32_t f, uint32_t g, uint32_t &h,\n+                  uint32_t k, uint32_t w) {\n+    uint32_t t1 = h + Sigma1(e) + Ch(e, f, g) + k + w;\n+    uint32_t t2 = Sigma0(a) + Maj(a, b, c);\n+    d += t1;\n+    h = t1 + t2;\n+}\n+\n+/** Initialize SHA-256 state. */\n+void inline Initialize(uint32_t *s) {\n+    s[0] = 0x6a09e667ul;\n+    s[1] = 0xbb67ae85ul;\n+    s[2] = 0x3c6ef372ul;\n+    s[3] = 0xa54ff53aul;\n+    s[4] = 0x510e527ful;\n+    s[5] = 0x9b05688cul;\n+    s[6] = 0x1f83d9abul;\n+    s[7] = 0x5be0cd19ul;\n+}\n+\n+/** Perform one SHA-256 transformation, processing a 64-byte chunk. */\n+void Transform(uint32_t *s, const unsigned char *chunk) {\n+    uint32_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];\n+    uint32_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n+\n+    Round(a, b, c, d, e, f, g, h, 0x428a2f98,  w0 = ReadBE32(chunk + 0));\n+    Round(h, a, b, c, d, e, f, g, 0x71374491,  w1 = ReadBE32(chunk + 4));\n+    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcf,  w2 = ReadBE32(chunk + 8));\n+    Round(f, g, h, a, b, c, d, e, 0xe9b5dba5,  w3 = ReadBE32(chunk + 12));\n+    Round(e, f, g, h, a, b, c, d, 0x3956c25b,  w4 = ReadBE32(chunk + 16));\n+    Round(d, e, f, g, h, a, b, c, 0x59f111f1,  w5 = ReadBE32(chunk + 20));\n+    Round(c, d, e, f, g, h, a, b, 0x923f82a4,  w6 = ReadBE32(chunk + 24));\n+    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5,  w7 = ReadBE32(chunk + 28));\n+    Round(a, b, c, d, e, f, g, h, 0xd807aa98,  w8 = ReadBE32(chunk + 32));\n+    Round(h, a, b, c, d, e, f, g, 0x12835b01,  w9 = ReadBE32(chunk + 36));\n+    Round(g, h, a, b, c, d, e, f, 0x243185be, w10 = ReadBE32(chunk + 40));\n+    Round(f, g, h, a, b, c, d, e, 0x550c7dc3, w11 = ReadBE32(chunk + 44));\n+    Round(e, f, g, h, a, b, c, d, 0x72be5d74, w12 = ReadBE32(chunk + 48));\n+    Round(d, e, f, g, h, a, b, c, 0x80deb1fe, w13 = ReadBE32(chunk + 52));\n+    Round(c, d, e, f, g, h, a, b, 0x9bdc06a7, w14 = ReadBE32(chunk + 56));\n+    Round(b, c, d, e, f, g, h, a, 0xc19bf174, w15 = ReadBE32(chunk + 60));\n+\n+    Round(a, b, c, d, e, f, g, h, 0xe49b69c1,  w0 += sigma1(w14) +  w9 + sigma0( w1));\n+    Round(h, a, b, c, d, e, f, g, 0xefbe4786,  w1 += sigma1(w15) + w10 + sigma0( w2));\n+    Round(g, h, a, b, c, d, e, f, 0x0fc19dc6,  w2 += sigma1( w0) + w11 + sigma0( w3));\n+    Round(f, g, h, a, b, c, d, e, 0x240ca1cc,  w3 += sigma1( w1) + w12 + sigma0( w4));\n+    Round(e, f, g, h, a, b, c, d, 0x2de92c6f,  w4 += sigma1( w2) + w13 + sigma0( w5));\n+    Round(d, e, f, g, h, a, b, c, 0x4a7484aa,  w5 += sigma1( w3) + w14 + sigma0( w6));\n+    Round(c, d, e, f, g, h, a, b, 0x5cb0a9dc,  w6 += sigma1( w4) + w15 + sigma0( w7));\n+    Round(b, c, d, e, f, g, h, a, 0x76f988da,  w7 += sigma1( w5) +  w0 + sigma0( w8));\n+    Round(a, b, c, d, e, f, g, h, 0x983e5152,  w8 += sigma1( w6) +  w1 + sigma0( w9));\n+    Round(h, a, b, c, d, e, f, g, 0xa831c66d,  w9 += sigma1( w7) +  w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0xb00327c8, w10 += sigma1( w8) +  w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0xbf597fc7, w11 += sigma1( w9) +  w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0xc6e00bf3, w12 += sigma1(w10) +  w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0xd5a79147, w13 += sigma1(w11) +  w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0x06ca6351, w14 += sigma1(w12) +  w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0x14292967, w15 += sigma1(w13) +  w8 + sigma0( w0));\n+\n+    Round(a, b, c, d, e, f, g, h, 0x27b70a85,  w0 += sigma1(w14) +  w9 + sigma0( w1));\n+    Round(h, a, b, c, d, e, f, g, 0x2e1b2138,  w1 += sigma1(w15) + w10 + sigma0( w2));\n+    Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc,  w2 += sigma1( w0) + w11 + sigma0( w3));\n+    Round(f, g, h, a, b, c, d, e, 0x53380d13,  w3 += sigma1( w1) + w12 + sigma0( w4));\n+    Round(e, f, g, h, a, b, c, d, 0x650a7354,  w4 += sigma1( w2) + w13 + sigma0( w5));\n+    Round(d, e, f, g, h, a, b, c, 0x766a0abb,  w5 += sigma1( w3) + w14 + sigma0( w6));\n+    Round(c, d, e, f, g, h, a, b, 0x81c2c92e,  w6 += sigma1( w4) + w15 + sigma0( w7));\n+    Round(b, c, d, e, f, g, h, a, 0x92722c85,  w7 += sigma1( w5) +  w0 + sigma0( w8));\n+    Round(a, b, c, d, e, f, g, h, 0xa2bfe8a1,  w8 += sigma1( w6) +  w1 + sigma0( w9));\n+    Round(h, a, b, c, d, e, f, g, 0xa81a664b,  w9 += sigma1( w7) +  w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0xc24b8b70, w10 += sigma1( w8) +  w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0xc76c51a3, w11 += sigma1( w9) +  w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0xd192e819, w12 += sigma1(w10) +  w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0xd6990624, w13 += sigma1(w11) +  w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0xf40e3585, w14 += sigma1(w12) +  w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0x106aa070, w15 += sigma1(w13) +  w8 + sigma0( w0));\n+\n+    Round(a, b, c, d, e, f, g, h, 0x19a4c116,  w0 += sigma1(w14) +  w9 + sigma0( w1));\n+    Round(h, a, b, c, d, e, f, g, 0x1e376c08,  w1 += sigma1(w15) + w10 + sigma0( w2));\n+    Round(g, h, a, b, c, d, e, f, 0x2748774c,  w2 += sigma1( w0) + w11 + sigma0( w3));\n+    Round(f, g, h, a, b, c, d, e, 0x34b0bcb5,  w3 += sigma1( w1) + w12 + sigma0( w4));\n+    Round(e, f, g, h, a, b, c, d, 0x391c0cb3,  w4 += sigma1( w2) + w13 + sigma0( w5));\n+    Round(d, e, f, g, h, a, b, c, 0x4ed8aa4a,  w5 += sigma1( w3) + w14 + sigma0( w6));\n+    Round(c, d, e, f, g, h, a, b, 0x5b9cca4f,  w6 += sigma1( w4) + w15 + sigma0( w7));\n+    Round(b, c, d, e, f, g, h, a, 0x682e6ff3,  w7 += sigma1( w5) +  w0 + sigma0( w8));\n+    Round(a, b, c, d, e, f, g, h, 0x748f82ee,  w8 += sigma1( w6) +  w1 + sigma0( w9));\n+    Round(h, a, b, c, d, e, f, g, 0x78a5636f,  w9 += sigma1( w7) +  w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0x84c87814, w10 += sigma1( w8) +  w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0x8cc70208, w11 += sigma1( w9) +  w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0x90befffa, w12 += sigma1(w10) +  w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0xa4506ceb, w13 += sigma1(w11) +  w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0xbef9a3f7, w14  + sigma1(w12) +  w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0xc67178f2, w15  + sigma1(w13) +  w8 + sigma0( w0));\n+\n+    s[0] += a;\n+    s[1] += b;\n+    s[2] += c;\n+    s[3] += d;\n+    s[4] += e;\n+    s[5] += f;\n+    s[6] += g;\n+    s[7] += h;\n+}\n+\n+}  // namespace sha256\n+\n+/// Internal SHA-512 implementation.\n+namespace sha512 {\n+\n+uint64_t inline Ch(uint64_t x, uint64_t y, uint64_t z) { return z ^ (x & (y ^ z)); }\n+uint64_t inline Maj(uint64_t x, uint64_t y, uint64_t z) { return (x & y) | (z & (x | y)); }\n+uint64_t inline Sigma0(uint64_t x) { return (x >> 28 | x << 36) ^ (x >> 34 | x << 30) ^ (x >> 39 | x << 25); }\n+uint64_t inline Sigma1(uint64_t x) { return (x >> 14 | x << 50) ^ (x >> 18 | x << 46) ^ (x >> 41 | x << 23); }\n+uint64_t inline sigma0(uint64_t x) { return (x >> 1 | x << 63) ^ (x >> 8 | x << 56) ^ (x >> 7); }\n+uint64_t inline sigma1(uint64_t x) { return (x >> 19 | x << 45) ^ (x >> 61 | x << 3) ^ (x >> 6); }\n+\n+/** One round of SHA-512. */\n+void inline Round(uint64_t a, uint64_t b, uint64_t c, uint64_t &d,\n+                  uint64_t e, uint64_t f, uint64_t g, uint64_t &h,\n+                  uint64_t k, uint64_t w) {\n+    uint64_t t1 = h + Sigma1(e) + Ch(e, f, g) + k + w;\n+    uint64_t t2 = Sigma0(a) + Maj(a, b, c);\n+    d += t1;\n+    h = t1 + t2;\n+}\n+\n+/** Initialize SHA-256 state. */\n+void inline Initialize(uint64_t *s) {\n+    s[0] = 0x6a09e667f3bcc908ull;\n+    s[1] = 0xbb67ae8584caa73bull;\n+    s[2] = 0x3c6ef372fe94f82bull;\n+    s[3] = 0xa54ff53a5f1d36f1ull;\n+    s[4] = 0x510e527fade682d1ull;\n+    s[5] = 0x9b05688c2b3e6c1full;\n+    s[6] = 0x1f83d9abfb41bd6bull;\n+    s[7] = 0x5be0cd19137e2179ull;\n+}\n+\n+/** Perform one SHA-512 transformation, processing a 128-byte chunk. */\n+void Transform(uint64_t *s, const unsigned char *chunk) {\n+    uint64_t a = s[0], b = s[1], c = s[2], d = s[3], e = s[4], f = s[5], g = s[6], h = s[7];\n+    uint64_t w0, w1, w2, w3, w4, w5, w6, w7, w8, w9, w10, w11, w12, w13, w14, w15;\n+\n+    Round(a, b, c, d, e, f, g, h, 0x428a2f98d728ae22ull,  w0 = ReadBE64(chunk + 0));\n+    Round(h, a, b, c, d, e, f, g, 0x7137449123ef65cdull,  w1 = ReadBE64(chunk + 8));\n+    Round(g, h, a, b, c, d, e, f, 0xb5c0fbcfec4d3b2full,  w2 = ReadBE64(chunk + 16));\n+    Round(f, g, h, a, b, c, d, e, 0xe9b5dba58189dbbcull,  w3 = ReadBE64(chunk + 24));\n+    Round(e, f, g, h, a, b, c, d, 0x3956c25bf348b538ull,  w4 = ReadBE64(chunk + 32));\n+    Round(d, e, f, g, h, a, b, c, 0x59f111f1b605d019ull,  w5 = ReadBE64(chunk + 40));\n+    Round(c, d, e, f, g, h, a, b, 0x923f82a4af194f9bull,  w6 = ReadBE64(chunk + 48));\n+    Round(b, c, d, e, f, g, h, a, 0xab1c5ed5da6d8118ull,  w7 = ReadBE64(chunk + 56));\n+    Round(a, b, c, d, e, f, g, h, 0xd807aa98a3030242ull,  w8 = ReadBE64(chunk + 64));\n+    Round(h, a, b, c, d, e, f, g, 0x12835b0145706fbeull,  w9 = ReadBE64(chunk + 72));\n+    Round(g, h, a, b, c, d, e, f, 0x243185be4ee4b28cull, w10 = ReadBE64(chunk + 80));\n+    Round(f, g, h, a, b, c, d, e, 0x550c7dc3d5ffb4e2ull, w11 = ReadBE64(chunk + 88));\n+    Round(e, f, g, h, a, b, c, d, 0x72be5d74f27b896full, w12 = ReadBE64(chunk + 96));\n+    Round(d, e, f, g, h, a, b, c, 0x80deb1fe3b1696b1ull, w13 = ReadBE64(chunk + 104));\n+    Round(c, d, e, f, g, h, a, b, 0x9bdc06a725c71235ull, w14 = ReadBE64(chunk + 112));\n+    Round(b, c, d, e, f, g, h, a, 0xc19bf174cf692694ull, w15 = ReadBE64(chunk + 120));\n+\n+    Round(a, b, c, d, e, f, g, h, 0xe49b69c19ef14ad2ull,  w0 += sigma1(w14) +  w9 + sigma0( w1));\n+    Round(h, a, b, c, d, e, f, g, 0xefbe4786384f25e3ull,  w1 += sigma1(w15) + w10 + sigma0( w2));\n+    Round(g, h, a, b, c, d, e, f, 0x0fc19dc68b8cd5b5ull,  w2 += sigma1( w0) + w11 + sigma0( w3));\n+    Round(f, g, h, a, b, c, d, e, 0x240ca1cc77ac9c65ull,  w3 += sigma1( w1) + w12 + sigma0( w4));\n+    Round(e, f, g, h, a, b, c, d, 0x2de92c6f592b0275ull,  w4 += sigma1( w2) + w13 + sigma0( w5));\n+    Round(d, e, f, g, h, a, b, c, 0x4a7484aa6ea6e483ull,  w5 += sigma1( w3) + w14 + sigma0( w6));\n+    Round(c, d, e, f, g, h, a, b, 0x5cb0a9dcbd41fbd4ull,  w6 += sigma1( w4) + w15 + sigma0( w7));\n+    Round(b, c, d, e, f, g, h, a, 0x76f988da831153b5ull,  w7 += sigma1( w5) +  w0 + sigma0( w8));\n+    Round(a, b, c, d, e, f, g, h, 0x983e5152ee66dfabull,  w8 += sigma1( w6) +  w1 + sigma0( w9));\n+    Round(h, a, b, c, d, e, f, g, 0xa831c66d2db43210ull,  w9 += sigma1( w7) +  w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0xb00327c898fb213full, w10 += sigma1( w8) +  w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0xbf597fc7beef0ee4ull, w11 += sigma1( w9) +  w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0xc6e00bf33da88fc2ull, w12 += sigma1(w10) +  w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0xd5a79147930aa725ull, w13 += sigma1(w11) +  w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0x06ca6351e003826full, w14 += sigma1(w12) +  w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0x142929670a0e6e70ull, w15 += sigma1(w13) +  w8 + sigma0( w0));\n+\n+    Round(a, b, c, d, e, f, g, h, 0x27b70a8546d22ffcull,  w0 += sigma1(w14) +  w9 + sigma0( w1));\n+    Round(h, a, b, c, d, e, f, g, 0x2e1b21385c26c926ull,  w1 += sigma1(w15) + w10 + sigma0( w2));\n+    Round(g, h, a, b, c, d, e, f, 0x4d2c6dfc5ac42aedull,  w2 += sigma1( w0) + w11 + sigma0( w3));\n+    Round(f, g, h, a, b, c, d, e, 0x53380d139d95b3dfull,  w3 += sigma1( w1) + w12 + sigma0( w4));\n+    Round(e, f, g, h, a, b, c, d, 0x650a73548baf63deull,  w4 += sigma1( w2) + w13 + sigma0( w5));\n+    Round(d, e, f, g, h, a, b, c, 0x766a0abb3c77b2a8ull,  w5 += sigma1( w3) + w14 + sigma0( w6));\n+    Round(c, d, e, f, g, h, a, b, 0x81c2c92e47edaee6ull,  w6 += sigma1( w4) + w15 + sigma0( w7));\n+    Round(b, c, d, e, f, g, h, a, 0x92722c851482353bull,  w7 += sigma1( w5) +  w0 + sigma0( w8));\n+    Round(a, b, c, d, e, f, g, h, 0xa2bfe8a14cf10364ull,  w8 += sigma1( w6) +  w1 + sigma0( w9));\n+    Round(h, a, b, c, d, e, f, g, 0xa81a664bbc423001ull,  w9 += sigma1( w7) +  w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0xc24b8b70d0f89791ull, w10 += sigma1( w8) +  w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0xc76c51a30654be30ull, w11 += sigma1( w9) +  w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0xd192e819d6ef5218ull, w12 += sigma1(w10) +  w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0xd69906245565a910ull, w13 += sigma1(w11) +  w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0xf40e35855771202aull, w14 += sigma1(w12) +  w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0x106aa07032bbd1b8ull, w15 += sigma1(w13) +  w8 + sigma0( w0));\n+\n+    Round(a, b, c, d, e, f, g, h, 0x19a4c116b8d2d0c8ull,  w0 += sigma1(w14) +  w9 + sigma0( w1));\n+    Round(h, a, b, c, d, e, f, g, 0x1e376c085141ab53ull,  w1 += sigma1(w15) + w10 + sigma0( w2));\n+    Round(g, h, a, b, c, d, e, f, 0x2748774cdf8eeb99ull,  w2 += sigma1( w0) + w11 + sigma0( w3));\n+    Round(f, g, h, a, b, c, d, e, 0x34b0bcb5e19b48a8ull,  w3 += sigma1( w1) + w12 + sigma0( w4));\n+    Round(e, f, g, h, a, b, c, d, 0x391c0cb3c5c95a63ull,  w4 += sigma1( w2) + w13 + sigma0( w5));\n+    Round(d, e, f, g, h, a, b, c, 0x4ed8aa4ae3418acbull,  w5 += sigma1( w3) + w14 + sigma0( w6));\n+    Round(c, d, e, f, g, h, a, b, 0x5b9cca4f7763e373ull,  w6 += sigma1( w4) + w15 + sigma0( w7));\n+    Round(b, c, d, e, f, g, h, a, 0x682e6ff3d6b2b8a3ull,  w7 += sigma1( w5) +  w0 + sigma0( w8));\n+    Round(a, b, c, d, e, f, g, h, 0x748f82ee5defb2fcull,  w8 += sigma1( w6) +  w1 + sigma0( w9));\n+    Round(h, a, b, c, d, e, f, g, 0x78a5636f43172f60ull,  w9 += sigma1( w7) +  w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0x84c87814a1f0ab72ull, w10 += sigma1( w8) +  w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0x8cc702081a6439ecull, w11 += sigma1( w9) +  w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0x90befffa23631e28ull, w12 += sigma1(w10) +  w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0xa4506cebde82bde9ull, w13 += sigma1(w11) +  w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0xbef9a3f7b2c67915ull, w14 += sigma1(w12) +  w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0xc67178f2e372532bull, w15 += sigma1(w13) +  w8 + sigma0( w0));\n+\n+    Round(a, b, c, d, e, f, g, h, 0xca273eceea26619cull,  w0 += sigma1(w14) +  w9 + sigma0( w1));\n+    Round(h, a, b, c, d, e, f, g, 0xd186b8c721c0c207ull,  w1 += sigma1(w15) + w10 + sigma0( w2));\n+    Round(g, h, a, b, c, d, e, f, 0xeada7dd6cde0eb1eull,  w2 += sigma1( w0) + w11 + sigma0( w3));\n+    Round(f, g, h, a, b, c, d, e, 0xf57d4f7fee6ed178ull,  w3 += sigma1( w1) + w12 + sigma0( w4));\n+    Round(e, f, g, h, a, b, c, d, 0x06f067aa72176fbaull,  w4 += sigma1( w2) + w13 + sigma0( w5));\n+    Round(d, e, f, g, h, a, b, c, 0x0a637dc5a2c898a6ull,  w5 += sigma1( w3) + w14 + sigma0( w6));\n+    Round(c, d, e, f, g, h, a, b, 0x113f9804bef90daeull,  w6 += sigma1( w4) + w15 + sigma0( w7));\n+    Round(b, c, d, e, f, g, h, a, 0x1b710b35131c471bull,  w7 += sigma1( w5) +  w0 + sigma0( w8));\n+    Round(a, b, c, d, e, f, g, h, 0x28db77f523047d84ull,  w8 += sigma1( w6) +  w1 + sigma0( w9));\n+    Round(h, a, b, c, d, e, f, g, 0x32caab7b40c72493ull,  w9 += sigma1( w7) +  w2 + sigma0(w10));\n+    Round(g, h, a, b, c, d, e, f, 0x3c9ebe0a15c9bebcull, w10 += sigma1( w8) +  w3 + sigma0(w11));\n+    Round(f, g, h, a, b, c, d, e, 0x431d67c49c100d4cull, w11 += sigma1( w9) +  w4 + sigma0(w12));\n+    Round(e, f, g, h, a, b, c, d, 0x4cc5d4becb3e42b6ull, w12 += sigma1(w10) +  w5 + sigma0(w13));\n+    Round(d, e, f, g, h, a, b, c, 0x597f299cfc657e2aull, w13 += sigma1(w11) +  w6 + sigma0(w14));\n+    Round(c, d, e, f, g, h, a, b, 0x5fcb6fab3ad6faecull, w14 += sigma1(w12) +  w7 + sigma0(w15));\n+    Round(b, c, d, e, f, g, h, a, 0x6c44198c4a475817ull, w15 += sigma1(w13) +  w8 + sigma0( w0));\n+\n+    s[0] += a;\n+    s[1] += b;\n+    s[2] += c;\n+    s[3] += d;\n+    s[4] += e;\n+    s[5] += f;\n+    s[6] += g;\n+    s[7] += h;\n+}\n+\n+}  // namespace sha512\n+\n+}  // namespace\n+\n+\n+////// SHA-256\n+\n+CSHA256::CSHA256() : bytes(0) {\n+    sha256::Initialize(s);\n+}\n+\n+CSHA256& CSHA256::Write(const unsigned char *data, size_t len) {\n+    const unsigned char *end = data + len;\n+    size_t bufsize = bytes % 64;\n+    if (bufsize && bufsize + len >= 64) {\n+        // Fill the buffer, and process it.\n+        memcpy(buf + bufsize, data, 64 - bufsize);\n+        bytes += 64 - bufsize;\n+        data += 64 - bufsize;\n+        sha256::Transform(s, buf);\n+        bufsize = 0;\n+    }\n+    while (end >= data + 64) {\n+        // Process full chunks directly from the source.\n+        sha256::Transform(s, data);\n+        bytes += 64;\n+        data += 64;\n+    }\n+    if (end > data) {\n+        // Fill the buffer with what remains.\n+        memcpy(buf + bufsize, data, end - data);\n+        bytes += end - data;\n+    }\n+    return *this;\n+}\n+\n+void CSHA256::Finalize(unsigned char hash[OUTPUT_SIZE]) {\n+    static const unsigned char pad[64] = {0x80};\n+    unsigned char sizedesc[8];\n+    WriteBE64(sizedesc, bytes << 3);\n+    Write(pad, 1 + ((119 - (bytes % 64)) % 64));\n+    Write(sizedesc, 8);\n+    WriteBE32(hash, s[0]);\n+    WriteBE32(hash+4, s[1]);\n+    WriteBE32(hash+8, s[2]);\n+    WriteBE32(hash+12, s[3]);\n+    WriteBE32(hash+16, s[4]);\n+    WriteBE32(hash+20, s[5]);\n+    WriteBE32(hash+24, s[6]);\n+    WriteBE32(hash+28, s[7]);\n+}\n+\n+CSHA256& CSHA256::Reset() {\n+    bytes = 0;\n+    sha256::Initialize(s);\n+    return *this;\n+}\n+\n+////// SHA-512\n+\n+CSHA512::CSHA512() : bytes(0) {\n+    sha512::Initialize(s);\n+}\n+\n+CSHA512& CSHA512::Write(const unsigned char *data, size_t len) {\n+    const unsigned char *end = data + len;\n+    size_t bufsize = bytes % 128;\n+    if (bufsize && bufsize + len >= 128) {\n+        // Fill the buffer, and process it.\n+        memcpy(buf + bufsize, data, 128 - bufsize);\n+        bytes += 128 - bufsize;\n+        data += 128 - bufsize;\n+        sha512::Transform(s, buf);\n+        bufsize = 0;\n+    }\n+    while (end >= data + 128) {\n+        // Process full chunks directly from the source.\n+        sha512::Transform(s, data);\n+        data += 128;\n+        bytes += 128;\n+    }\n+    if (end > data) {\n+        // Fill the buffer with what remains.\n+        memcpy(buf + bufsize, data, end - data);\n+        bytes += end - data;\n+    }\n+    return *this;\n+}\n+\n+void CSHA512::Finalize(unsigned char hash[OUTPUT_SIZE]) {\n+    static const unsigned char pad[128] = {0x80};\n+    unsigned char sizedesc[16] = {0x00};\n+    WriteBE64(sizedesc+8, bytes << 3);\n+    Write(pad, 1 + ((239 - (bytes % 128)) % 128));\n+    Write(sizedesc, 16);\n+    WriteBE64(hash, s[0]);\n+    WriteBE64(hash+8, s[1]);\n+    WriteBE64(hash+16, s[2]);\n+    WriteBE64(hash+24, s[3]);\n+    WriteBE64(hash+32, s[4]);\n+    WriteBE64(hash+40, s[5]);\n+    WriteBE64(hash+48, s[6]);\n+    WriteBE64(hash+56, s[7]);\n+}\n+\n+CSHA512& CSHA512::Reset() {\n+    bytes = 0;\n+    sha512::Initialize(s);\n+    return *this;\n+}\n+\n+////// HMAC-SHA-512\n+\n+CHMAC_SHA512::CHMAC_SHA512(const unsigned char *key, size_t keylen) {\n+    unsigned char rkey[128];\n+    if (keylen <= 128) {\n+        memcpy(rkey, key, keylen);\n+        memset(rkey + keylen, 0, 128 - keylen);\n+    } else {\n+        CSHA512().Write(key, keylen).Finalize(rkey);\n+        memset(rkey + 64, 0, 64);\n+    }\n+\n+    for (int n=0; n<128; n++)\n+        rkey[n] ^= 0x5c;\n+    outer.Write(rkey, 128);\n+\n+    for (int n=0; n<128; n++)\n+        rkey[n] ^= 0x5c ^ 0x36;\n+    inner.Write(rkey, 128);\n+}\n+\n+void CHMAC_SHA512::Finalize(unsigned char hash[OUTPUT_SIZE]) {\n+    unsigned char temp[64];\n+    inner.Finalize(temp);\n+    outer.Write(temp, 64).Finalize(hash);\n+}"
      },
      {
        "sha": "088d5e194c734793c5759ec2ecf27410e401e2fd",
        "filename": "src/crypto/sha2.h",
        "status": "added",
        "additions": 60,
        "deletions": 0,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/crypto/sha2.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/crypto/sha2.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/sha2.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,60 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_SHA2_H\n+#define BITCOIN_SHA2_H\n+\n+#include <stdint.h>\n+#include <stdlib.h>\n+\n+/** A hasher class for SHA-256. */\n+class CSHA256 {\n+private:\n+    uint32_t s[8];\n+    unsigned char buf[64];\n+    size_t bytes;\n+\n+public:\n+    static const size_t OUTPUT_SIZE = 32;\n+\n+    CSHA256();\n+    CSHA256& Write(const unsigned char *data, size_t len);\n+    void Finalize(unsigned char hash[OUTPUT_SIZE]);\n+    CSHA256& Reset();\n+};\n+\n+/** A hasher class for SHA-512. */\n+class CSHA512 {\n+private:\n+    uint64_t s[8];\n+    unsigned char buf[128];\n+    size_t bytes;\n+\n+public:\n+    static const size_t OUTPUT_SIZE = 64;\n+\n+    CSHA512();\n+    CSHA512& Write(const unsigned char *data, size_t len);\n+    void Finalize(unsigned char hash[OUTPUT_SIZE]);\n+    CSHA512& Reset();\n+};\n+\n+/** A hasher class for HMAC-SHA-512. */\n+class CHMAC_SHA512 {\n+private:\n+    CSHA512 outer;\n+    CSHA512 inner;\n+\n+public:\n+    static const size_t OUTPUT_SIZE = 64;\n+\n+    CHMAC_SHA512(const unsigned char *key, size_t keylen);\n+    CHMAC_SHA512& Write(const unsigned char *data, size_t len) {\n+        inner.Write(data, len);\n+        return *this;\n+    }\n+    void Finalize(unsigned char hash[OUTPUT_SIZE]);\n+};\n+\n+#endif"
      },
      {
        "sha": "bddd8abf38d045a171fa4868c11f72b12b59f179",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 41,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -56,44 +56,3 @@ unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char\n \n     return h1;\n }\n-\n-int HMAC_SHA512_Init(HMAC_SHA512_CTX *pctx, const void *pkey, size_t len)\n-{\n-    unsigned char key[128];\n-    if (len <= 128)\n-    {\n-        memcpy(key, pkey, len);\n-        memset(key + len, 0, 128-len);\n-    }\n-    else\n-    {\n-        SHA512_CTX ctxKey;\n-        SHA512_Init(&ctxKey);\n-        SHA512_Update(&ctxKey, pkey, len);\n-        SHA512_Final(key, &ctxKey);\n-        memset(key + 64, 0, 64);\n-    }\n-\n-    for (int n=0; n<128; n++)\n-        key[n] ^= 0x5c;\n-    SHA512_Init(&pctx->ctxOuter);\n-    SHA512_Update(&pctx->ctxOuter, key, 128);\n-\n-    for (int n=0; n<128; n++)\n-        key[n] ^= 0x5c ^ 0x36;\n-    SHA512_Init(&pctx->ctxInner);\n-    return SHA512_Update(&pctx->ctxInner, key, 128);\n-}\n-\n-int HMAC_SHA512_Update(HMAC_SHA512_CTX *pctx, const void *pdata, size_t len)\n-{\n-    return SHA512_Update(&pctx->ctxInner, pdata, len);\n-}\n-\n-int HMAC_SHA512_Final(unsigned char *pmd, HMAC_SHA512_CTX *pctx)\n-{\n-    unsigned char buf[64];\n-    SHA512_Final(buf, &pctx->ctxInner);\n-    SHA512_Update(&pctx->ctxOuter, buf, 64);\n-    return SHA512_Final(pmd, &pctx->ctxOuter);\n-}"
      },
      {
        "sha": "f2a0ebfe1f2575cbcdb22e768419eae1daa91c07",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 106,
        "deletions": 83,
        "changes": 189,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -6,55 +6,138 @@\n #ifndef BITCOIN_HASH_H\n #define BITCOIN_HASH_H\n \n+#include \"crypto/sha2.h\"\n+#include \"crypto/ripemd160.h\"\n #include \"serialize.h\"\n #include \"uint256.h\"\n #include \"version.h\"\n \n #include <vector>\n \n-#include <openssl/ripemd.h>\n-#include <openssl/sha.h>\n+/** A hasher class for Bitcoin's 256-bit hash (double SHA-256). */\n+class CHash256 {\n+private:\n+    CSHA256 sha;\n+public:\n+    static const size_t OUTPUT_SIZE = CSHA256::OUTPUT_SIZE;\n+\n+    void Finalize(unsigned char hash[OUTPUT_SIZE]) {\n+        unsigned char buf[sha.OUTPUT_SIZE];\n+        sha.Finalize(buf);\n+        sha.Reset().Write(buf, sha.OUTPUT_SIZE).Finalize(hash);\n+    }\n+\n+    CHash256& Write(const unsigned char *data, size_t len) {\n+        sha.Write(data, len);\n+        return *this;\n+    }\n+\n+    CHash256& Reset() {\n+        sha.Reset();\n+        return *this;\n+    }\n+};\n \n+/** A hasher class for Bitcoin's 160-bit hash (SHA-256 + RIPEMD-160). */\n+class CHash160 {\n+private:\n+    CSHA256 sha;\n+public:\n+    static const size_t OUTPUT_SIZE = CRIPEMD160::OUTPUT_SIZE;\n+\n+    void Finalize(unsigned char hash[OUTPUT_SIZE]) {\n+        unsigned char buf[sha.OUTPUT_SIZE];\n+        sha.Finalize(buf);\n+        CRIPEMD160().Write(buf, sha.OUTPUT_SIZE).Finalize(hash);\n+    }\n+\n+    CHash160& Write(const unsigned char *data, size_t len) {\n+        sha.Write(data, len);\n+        return *this;\n+    }\n+\n+    CHash160& Reset() {\n+        sha.Reset();\n+        return *this;\n+    }\n+};\n+\n+/** Compute the 256-bit hash of an object. */\n template<typename T1>\n inline uint256 Hash(const T1 pbegin, const T1 pend)\n {\n-    static unsigned char pblank[1];\n-    uint256 hash1;\n-    SHA256((pbegin == pend ? pblank : (unsigned char*)&pbegin[0]), (pend - pbegin) * sizeof(pbegin[0]), (unsigned char*)&hash1);\n-    uint256 hash2;\n-    SHA256((unsigned char*)&hash1, sizeof(hash1), (unsigned char*)&hash2);\n-    return hash2;\n+    static const unsigned char pblank[1] = {};\n+    uint256 result;\n+    CHash256().Write(pbegin == pend ? pblank : (const unsigned char*)&pbegin[0], (pend - pbegin) * sizeof(pbegin[0]))\n+              .Finalize((unsigned char*)&result);\n+    return result;\n+}\n+\n+/** Compute the 256-bit hash of the concatenation of two objects. */\n+template<typename T1, typename T2>\n+inline uint256 Hash(const T1 p1begin, const T1 p1end,\n+                    const T2 p2begin, const T2 p2end) {\n+    static const unsigned char pblank[1] = {};\n+    uint256 result;\n+    CHash256().Write(p1begin == p1end ? pblank : (const unsigned char*)&p1begin[0], (p1end - p1begin) * sizeof(p1begin[0]))\n+              .Write(p2begin == p2end ? pblank : (const unsigned char*)&p2begin[0], (p2end - p2begin) * sizeof(p2begin[0]))\n+              .Finalize((unsigned char*)&result);\n+    return result;\n+}\n+\n+/** Compute the 256-bit hash of the concatenation of three objects. */\n+template<typename T1, typename T2, typename T3>\n+inline uint256 Hash(const T1 p1begin, const T1 p1end,\n+                    const T2 p2begin, const T2 p2end,\n+                    const T3 p3begin, const T3 p3end) {\n+    static const unsigned char pblank[1] = {};\n+    uint256 result;\n+    CHash256().Write(p1begin == p1end ? pblank : (const unsigned char*)&p1begin[0], (p1end - p1begin) * sizeof(p1begin[0]))\n+              .Write(p2begin == p2end ? pblank : (const unsigned char*)&p2begin[0], (p2end - p2begin) * sizeof(p2begin[0]))\n+              .Write(p3begin == p3end ? pblank : (const unsigned char*)&p3begin[0], (p3end - p3begin) * sizeof(p3begin[0]))\n+              .Finalize((unsigned char*)&result);\n+    return result;\n+}\n+\n+/** Compute the 160-bit hash an object. */\n+template<typename T1>\n+inline uint160 Hash160(const T1 pbegin, const T1 pend)\n+{\n+    static unsigned char pblank[1] = {};\n+    uint160 result;\n+    CHash160().Write(pbegin == pend ? pblank : (const unsigned char*)&pbegin[0], (pend - pbegin) * sizeof(pbegin[0]))\n+              .Finalize((unsigned char*)&result);\n+    return result;\n }\n \n+/** Compute the 160-bit hash of a vector. */\n+inline uint160 Hash160(const std::vector<unsigned char>& vch)\n+{\n+    return Hash160(vch.begin(), vch.end());\n+}\n+\n+/** A writer stream (for serialization) that computes a 256-bit hash. */\n class CHashWriter\n {\n private:\n-    SHA256_CTX ctx;\n+    CHash256 ctx;\n \n public:\n     int nType;\n     int nVersion;\n \n-    void Init() {\n-        SHA256_Init(&ctx);\n-    }\n-\n-    CHashWriter(int nTypeIn, int nVersionIn) : nType(nTypeIn), nVersion(nVersionIn) {\n-        Init();\n-    }\n+    CHashWriter(int nTypeIn, int nVersionIn) : nType(nTypeIn), nVersion(nVersionIn) {}\n \n     CHashWriter& write(const char *pch, size_t size) {\n-        SHA256_Update(&ctx, pch, size);\n+        ctx.Write((const unsigned char*)pch, size);\n         return (*this);\n     }\n \n     // invalidates the object\n     uint256 GetHash() {\n-        uint256 hash1;\n-        SHA256_Final((unsigned char*)&hash1, &ctx);\n-        uint256 hash2;\n-        SHA256((unsigned char*)&hash1, sizeof(hash1), (unsigned char*)&hash2);\n-        return hash2;\n+        uint256 result;\n+        ctx.Finalize((unsigned char*)&result);\n+        return result;\n     }\n \n     template<typename T>\n@@ -65,41 +148,7 @@ class CHashWriter\n     }\n };\n \n-\n-template<typename T1, typename T2>\n-inline uint256 Hash(const T1 p1begin, const T1 p1end,\n-                    const T2 p2begin, const T2 p2end)\n-{\n-    static unsigned char pblank[1];\n-    uint256 hash1;\n-    SHA256_CTX ctx;\n-    SHA256_Init(&ctx);\n-    SHA256_Update(&ctx, (p1begin == p1end ? pblank : (unsigned char*)&p1begin[0]), (p1end - p1begin) * sizeof(p1begin[0]));\n-    SHA256_Update(&ctx, (p2begin == p2end ? pblank : (unsigned char*)&p2begin[0]), (p2end - p2begin) * sizeof(p2begin[0]));\n-    SHA256_Final((unsigned char*)&hash1, &ctx);\n-    uint256 hash2;\n-    SHA256((unsigned char*)&hash1, sizeof(hash1), (unsigned char*)&hash2);\n-    return hash2;\n-}\n-\n-template<typename T1, typename T2, typename T3>\n-inline uint256 Hash(const T1 p1begin, const T1 p1end,\n-                    const T2 p2begin, const T2 p2end,\n-                    const T3 p3begin, const T3 p3end)\n-{\n-    static unsigned char pblank[1];\n-    uint256 hash1;\n-    SHA256_CTX ctx;\n-    SHA256_Init(&ctx);\n-    SHA256_Update(&ctx, (p1begin == p1end ? pblank : (unsigned char*)&p1begin[0]), (p1end - p1begin) * sizeof(p1begin[0]));\n-    SHA256_Update(&ctx, (p2begin == p2end ? pblank : (unsigned char*)&p2begin[0]), (p2end - p2begin) * sizeof(p2begin[0]));\n-    SHA256_Update(&ctx, (p3begin == p3end ? pblank : (unsigned char*)&p3begin[0]), (p3end - p3begin) * sizeof(p3begin[0]));\n-    SHA256_Final((unsigned char*)&hash1, &ctx);\n-    uint256 hash2;\n-    SHA256((unsigned char*)&hash1, sizeof(hash1), (unsigned char*)&hash2);\n-    return hash2;\n-}\n-\n+/** Compute the 256-bit hash of an object's serialization. */\n template<typename T>\n uint256 SerializeHash(const T& obj, int nType=SER_GETHASH, int nVersion=PROTOCOL_VERSION)\n {\n@@ -108,32 +157,6 @@ uint256 SerializeHash(const T& obj, int nType=SER_GETHASH, int nVersion=PROTOCOL\n     return ss.GetHash();\n }\n \n-template<typename T1>\n-inline uint160 Hash160(const T1 pbegin, const T1 pend)\n-{\n-    static unsigned char pblank[1];\n-    uint256 hash1;\n-    SHA256((pbegin == pend ? pblank : (unsigned char*)&pbegin[0]), (pend - pbegin) * sizeof(pbegin[0]), (unsigned char*)&hash1);\n-    uint160 hash2;\n-    RIPEMD160((unsigned char*)&hash1, sizeof(hash1), (unsigned char*)&hash2);\n-    return hash2;\n-}\n-\n-inline uint160 Hash160(const std::vector<unsigned char>& vch)\n-{\n-    return Hash160(vch.begin(), vch.end());\n-}\n-\n unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char>& vDataToHash);\n \n-typedef struct\n-{\n-    SHA512_CTX ctxInner;\n-    SHA512_CTX ctxOuter;\n-} HMAC_SHA512_CTX;\n-\n-int HMAC_SHA512_Init(HMAC_SHA512_CTX *pctx, const void *pkey, size_t len);\n-int HMAC_SHA512_Update(HMAC_SHA512_CTX *pctx, const void *pdata, size_t len);\n-int HMAC_SHA512_Final(unsigned char *pmd, HMAC_SHA512_CTX *pctx);\n-\n #endif"
      },
      {
        "sha": "3488a8bedf807a893f997dfaa646265746747770",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 160,
        "deletions": 72,
        "changes": 232,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -4,7 +4,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #if defined(HAVE_CONFIG_H)\n-#include \"bitcoin-config.h\"\n+#include \"config/bitcoin-config.h\"\n #endif\n \n #include \"init.h\"\n@@ -31,14 +31,15 @@\n #ifndef WIN32\n #include <signal.h>\n #endif\n+#include \"compat/sanity.h\"\n \n #include <boost/algorithm/string/predicate.hpp>\n #include <boost/filesystem.hpp>\n #include <boost/interprocess/sync/file_lock.hpp>\n #include <openssl/crypto.h>\n \n-using namespace std;\n using namespace boost;\n+using namespace std;\n \n #ifdef ENABLE_WALLET\n CWallet* pwalletMain;\n@@ -57,10 +58,12 @@ CWallet* pwalletMain;\n enum BindFlags {\n     BF_NONE         = 0,\n     BF_EXPLICIT     = (1U << 0),\n-    BF_REPORT_ERROR = (1U << 1)\n+    BF_REPORT_ERROR = (1U << 1),\n+    BF_WHITELIST    = (1U << 2),\n };\n \n static const char* FEE_ESTIMATES_FILENAME=\"fee_estimates.dat\";\n+CClientUIInterface uiInterface;\n \n //////////////////////////////////////////////////////////////////////////////\n //\n@@ -107,15 +110,15 @@ static CCoinsViewDB *pcoinsdbview;\n \n void Shutdown()\n {\n-    LogPrintf(\"Shutdown : In progress...\\n\");\n+    LogPrintf(\"%s: In progress...\\n\", __func__);\n     static CCriticalSection cs_Shutdown;\n     TRY_LOCK(cs_Shutdown, lockShutdown);\n-    if (!lockShutdown) return;\n+    if (!lockShutdown)\n+        return;\n \n     RenameThread(\"bitcoin-shutoff\");\n     mempool.AddTransactionsUpdated(1);\n     StopRPCThreads();\n-    ShutdownRPCMining();\n #ifdef ENABLE_WALLET\n     if (pwalletMain)\n         bitdb.Flush(false);\n@@ -124,12 +127,14 @@ void Shutdown()\n     StopNode();\n     UnregisterNodeSignals(GetNodeSignals());\n \n-    boost::filesystem::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n-    CAutoFile est_fileout = CAutoFile(fopen(est_path.string().c_str(), \"wb\"), SER_DISK, CLIENT_VERSION);\n-    if (est_fileout)\n-        mempool.WriteFeeEstimates(est_fileout);\n-    else\n-        LogPrintf(\"failed to write fee estimates\");\n+    {\n+        boost::filesystem::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n+        CAutoFile est_fileout(fopen(est_path.string().c_str(), \"wb\"), SER_DISK, CLIENT_VERSION);\n+        if (est_fileout)\n+            mempool.WriteFeeEstimates(est_fileout);\n+        else\n+            LogPrintf(\"%s: Failed to write fee estimates to %s\\n\", __func__, est_path.string());\n+    }\n \n     {\n         LOCK(cs_main);\n@@ -141,9 +146,12 @@ void Shutdown()\n             pblocktree->Flush();\n         if (pcoinsTip)\n             pcoinsTip->Flush();\n-        delete pcoinsTip; pcoinsTip = NULL;\n-        delete pcoinsdbview; pcoinsdbview = NULL;\n-        delete pblocktree; pblocktree = NULL;\n+        delete pcoinsTip;\n+        pcoinsTip = NULL;\n+        delete pcoinsdbview;\n+        pcoinsdbview = NULL;\n+        delete pblocktree;\n+        pblocktree = NULL;\n     }\n #ifdef ENABLE_WALLET\n     if (pwalletMain)\n@@ -155,7 +163,7 @@ void Shutdown()\n     if (pwalletMain)\n         delete pwalletMain;\n #endif\n-    LogPrintf(\"Shutdown : done\\n\");\n+    LogPrintf(\"%s: done\\n\", __func__);\n }\n \n //\n@@ -173,53 +181,57 @@ void HandleSIGHUP(int)\n \n bool static InitError(const std::string &str)\n {\n-    uiInterface.ThreadSafeMessageBox(str, \"\", CClientUIInterface::MSG_ERROR | CClientUIInterface::NOSHOWGUI);\n+    uiInterface.ThreadSafeMessageBox(str, \"\", CClientUIInterface::MSG_ERROR);\n     return false;\n }\n \n bool static InitWarning(const std::string &str)\n {\n-    uiInterface.ThreadSafeMessageBox(str, \"\", CClientUIInterface::MSG_WARNING | CClientUIInterface::NOSHOWGUI);\n+    uiInterface.ThreadSafeMessageBox(str, \"\", CClientUIInterface::MSG_WARNING);\n     return true;\n }\n \n bool static Bind(const CService &addr, unsigned int flags) {\n     if (!(flags & BF_EXPLICIT) && IsLimited(addr))\n         return false;\n     std::string strError;\n-    if (!BindListenPort(addr, strError)) {\n+    if (!BindListenPort(addr, strError, flags & BF_WHITELIST)) {\n         if (flags & BF_REPORT_ERROR)\n             return InitError(strError);\n         return false;\n     }\n     return true;\n }\n \n-std::string HelpMessage(HelpMessageMode hmm)\n+std::string HelpMessage(HelpMessageMode mode)\n {\n+    // When adding new options to the categories, please keep and ensure alphabetical ordering.\n     string strUsage = _(\"Options:\") + \"\\n\";\n     strUsage += \"  -?                     \" + _(\"This help message\") + \"\\n\";\n     strUsage += \"  -alertnotify=<cmd>     \" + _(\"Execute command when a relevant alert is received or we see a really long fork (%s in cmd is replaced by message)\") + \"\\n\";\n     strUsage += \"  -blocknotify=<cmd>     \" + _(\"Execute command when the best block changes (%s in cmd is replaced by block hash)\") + \"\\n\";\n     strUsage += \"  -checkblocks=<n>       \" + _(\"How many blocks to check at startup (default: 288, 0 = all)\") + \"\\n\";\n     strUsage += \"  -checklevel=<n>        \" + _(\"How thorough the block verification of -checkblocks is (0-4, default: 3)\") + \"\\n\";\n     strUsage += \"  -conf=<file>           \" + _(\"Specify configuration file (default: bitcoin.conf)\") + \"\\n\";\n-    if (hmm == HMM_BITCOIND)\n+    if (mode == HMM_BITCOIND)\n     {\n #if !defined(WIN32)\n         strUsage += \"  -daemon                \" + _(\"Run in the background as a daemon and accept commands\") + \"\\n\";\n #endif\n     }\n     strUsage += \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\";\n     strUsage += \"  -dbcache=<n>           \" + strprintf(_(\"Set database cache size in megabytes (%d to %d, default: %d)\"), nMinDbCache, nMaxDbCache, nDefaultDbCache) + \"\\n\";\n-    strUsage += \"  -keypool=<n>           \" + _(\"Set key pool size to <n> (default: 100)\") + \"\\n\";\n     strUsage += \"  -loadblock=<file>      \" + _(\"Imports blocks from external blk000??.dat file\") + \" \" + _(\"on startup\") + \"\\n\";\n     strUsage += \"  -maxorphanblocks=<n>   \" + strprintf(_(\"Keep at most <n> unconnectable blocks in memory (default: %u)\"), DEFAULT_MAX_ORPHAN_BLOCKS) + \"\\n\";\n     strUsage += \"  -par=<n>               \" + strprintf(_(\"Set the number of script verification threads (%u to %d, 0 = auto, <0 = leave that many cores free, default: %d)\"), -(int)boost::thread::hardware_concurrency(), MAX_SCRIPTCHECK_THREADS, DEFAULT_SCRIPTCHECK_THREADS) + \"\\n\";\n     strUsage += \"  -pid=<file>            \" + _(\"Specify pid file (default: bitcoind.pid)\") + \"\\n\";\n     strUsage += \"  -reindex               \" + _(\"Rebuild block chain index from current blk000??.dat files\") + \" \" + _(\"on startup\") + \"\\n\";\n+#if !defined(WIN32)\n+    strUsage += \"  -sysperms              \" + _(\"Create new files with system default permissions, instead of umask 077 (only effective with disabled wallet functionality)\") + \"\\n\";\n+#endif\n     strUsage += \"  -txindex               \" + _(\"Maintain a full transaction index (default: 0)\") + \"\\n\";\n \n+\n     strUsage += \"\\n\" + _(\"Connection options:\") + \"\\n\";\n     strUsage += \"  -addnode=<ip>          \" + _(\"Add a node to connect to and attempt to keep the connection open\") + \"\\n\";\n     strUsage += \"  -banscore=<n>          \" + _(\"Threshold for disconnecting misbehaving peers (default: 100)\") + \"\\n\";\n@@ -236,10 +248,10 @@ std::string HelpMessage(HelpMessageMode hmm)\n     strUsage += \"  -maxsendbuffer=<n>     \" + _(\"Maximum per-connection send buffer, <n>*1000 bytes (default: 1000)\") + \"\\n\";\n     strUsage += \"  -onion=<ip:port>       \" + _(\"Use separate SOCKS5 proxy to reach peers via Tor hidden services (default: -proxy)\") + \"\\n\";\n     strUsage += \"  -onlynet=<net>         \" + _(\"Only connect to nodes in network <net> (IPv4, IPv6 or Tor)\") + \"\\n\";\n+    strUsage += \"  -permitbaremultisig    \" + _(\"Relay non-P2SH multisig (default: 1)\") + \"\\n\";\n     strUsage += \"  -port=<port>           \" + _(\"Listen for connections on <port> (default: 8333 or testnet: 18333)\") + \"\\n\";\n-    strUsage += \"  -proxy=<ip:port>       \" + _(\"Connect through SOCKS proxy\") + \"\\n\";\n+    strUsage += \"  -proxy=<ip:port>       \" + _(\"Connect through SOCKS5 proxy\") + \"\\n\";\n     strUsage += \"  -seednode=<ip>         \" + _(\"Connect to a node to retrieve peer addresses, and disconnect\") + \"\\n\";\n-    strUsage += \"  -socks=<n>             \" + _(\"Select SOCKS version for -proxy (4 or 5, default: 5)\") + \"\\n\";\n     strUsage += \"  -timeout=<n>           \" + _(\"Specify connection timeout in milliseconds (default: 5000)\") + \"\\n\";\n #ifdef USE_UPNP\n #if USE_UPNP\n@@ -248,18 +260,26 @@ std::string HelpMessage(HelpMessageMode hmm)\n     strUsage += \"  -upnp                  \" + _(\"Use UPnP to map the listening port (default: 0)\") + \"\\n\";\n #endif\n #endif\n+    strUsage += \"  -whitebind=<addr>      \" + _(\"Bind to given address and whitelist peers connecting to it. Use [host]:port notation for IPv6\") + \"\\n\";\n+    strUsage += \"  -whitelist=<netmask>   \" + _(\"Whitelist peers connecting from the given netmask or ip. Can be specified multiple times.\") + \"\\n\";\n \n #ifdef ENABLE_WALLET\n     strUsage += \"\\n\" + _(\"Wallet options:\") + \"\\n\";\n     strUsage += \"  -disablewallet         \" + _(\"Do not load the wallet and disable wallet RPC calls\") + \"\\n\";\n-    strUsage += \"  -paytxfee=<amt>        \" + _(\"Fee per kB to add to transactions you send\") + \"\\n\";\n+    strUsage += \"  -keypool=<n>           \" + _(\"Set key pool size to <n> (default: 100)\") + \"\\n\";\n+    if (GetBoolArg(\"-help-debug\", false))\n+        strUsage += \"  -mintxfee=<amt>        \" + strprintf(_(\"Fees (in BTC/Kb) smaller than this are considered zero fee for transaction creation (default: %s)\"), FormatMoney(CWallet::minTxFee.GetFeePerK())) + \"\\n\";\n+    strUsage += \"  -paytxfee=<amt>        \" + strprintf(_(\"Fee (in BTC/kB) to add to transactions you send (default: %s)\"), FormatMoney(payTxFee.GetFeePerK())) + \"\\n\";\n     strUsage += \"  -rescan                \" + _(\"Rescan the block chain for missing wallet transactions\") + \" \" + _(\"on startup\") + \"\\n\";\n+    strUsage += \"  -respendnotify=<cmd>   \" + _(\"Execute command when a network tx respends wallet tx input (%s=respend TxID, %t=wallet TxID)\") + \"\\n\";\n     strUsage += \"  -salvagewallet         \" + _(\"Attempt to recover private keys from a corrupt wallet.dat\") + \" \" + _(\"on startup\") + \"\\n\";\n     strUsage += \"  -spendzeroconfchange   \" + _(\"Spend unconfirmed change when sending transactions (default: 1)\") + \"\\n\";\n+    strUsage += \"  -txconfirmtarget=<n>   \" + _(\"If paytxfee is not set, include enough fee so transactions are confirmed on average within n blocks (default: 1)\") + \"\\n\";\n     strUsage += \"  -upgradewallet         \" + _(\"Upgrade wallet to latest format\") + \" \" + _(\"on startup\") + \"\\n\";\n     strUsage += \"  -wallet=<file>         \" + _(\"Specify wallet file (within data directory)\") + \" \" + _(\"(default: wallet.dat)\") + \"\\n\";\n     strUsage += \"  -walletnotify=<cmd>    \" + _(\"Execute command when a wallet transaction changes (%s in cmd is replaced by TxID)\") + \"\\n\";\n-    strUsage += \"  -zapwallettxes         \" + _(\"Clear list of wallet transactions (diagnostic tool; implies -rescan)\") + \"\\n\";\n+    strUsage += \"  -zapwallettxes=<mode>  \" + _(\"Delete all wallet transactions and only recover those part of the blockchain through -rescan on startup\") + \"\\n\";\n+    strUsage += \"                         \" + _(\"(default: 1, 1 = keep tx meta data e.g. account owner and payment request information, 2 = drop tx meta data)\") + \"\\n\";\n #endif\n \n     strUsage += \"\\n\" + _(\"Debugging/Testing options:\") + \"\\n\";\n@@ -273,25 +293,28 @@ std::string HelpMessage(HelpMessageMode hmm)\n         strUsage += \"  -dropmessagestest=<n>  \" + _(\"Randomly drop 1 of every <n> network messages\") + \"\\n\";\n         strUsage += \"  -fuzzmessagestest=<n>  \" + _(\"Randomly fuzz 1 of every <n> network messages\") + \"\\n\";\n         strUsage += \"  -flushwallet           \" + _(\"Run a thread to flush wallet periodically (default: 1)\") + \"\\n\";\n+        strUsage += \"  -stopafterblockimport  \" + _(\"Stop running after importing blocks from disk (default: 0)\") + \"\\n\";\n     }\n     strUsage += \"  -debug=<category>      \" + _(\"Output debugging information (default: 0, supplying <category> is optional)\") + \"\\n\";\n     strUsage += \"                         \" + _(\"If <category> is not supplied, output all debugging information.\") + \"\\n\";\n     strUsage += \"                         \" + _(\"<category> can be:\");\n     strUsage +=                                 \" addrman, alert, coindb, db, lock, rand, rpc, selectcoins, mempool, net\"; // Don't translate these and qt below\n-    if (hmm == HMM_BITCOIN_QT)\n+    if (mode == HMM_BITCOIN_QT)\n         strUsage += \", qt\";\n     strUsage += \".\\n\";\n+#ifdef ENABLE_WALLET\n     strUsage += \"  -gen                   \" + _(\"Generate coins (default: 0)\") + \"\\n\";\n     strUsage += \"  -genproclimit=<n>      \" + _(\"Set the processor limit for when generation is on (-1 = unlimited, default: -1)\") + \"\\n\";\n+#endif\n     strUsage += \"  -help-debug            \" + _(\"Show all debugging options (usage: --help -help-debug)\") + \"\\n\";\n+    strUsage += \"  -logips                \" + _(\"Include IP addresses in debug output (default: 0)\") + \"\\n\";\n     strUsage += \"  -logtimestamps         \" + _(\"Prepend debug output with timestamp (default: 1)\") + \"\\n\";\n     if (GetBoolArg(\"-help-debug\", false))\n     {\n         strUsage += \"  -limitfreerelay=<n>    \" + _(\"Continuously rate-limit free transactions to <n>*1000 bytes per minute (default:15)\") + \"\\n\";\n         strUsage += \"  -maxsigcachesize=<n>   \" + _(\"Limit size of signature cache to <n> entries (default: 50000)\") + \"\\n\";\n     }\n-    strUsage += \"  -mintxfee=<amt>        \" + _(\"Fees smaller than this are considered zero fee (for transaction creation) (default:\") + \" \" + FormatMoney(CTransaction::minTxFee.GetFeePerK()) + \")\" + \"\\n\";\n-    strUsage += \"  -minrelaytxfee=<amt>   \" + _(\"Fees smaller than this are considered zero fee (for relaying) (default:\") + \" \" + FormatMoney(CTransaction::minRelayTxFee.GetFeePerK()) + \")\" + \"\\n\";\n+    strUsage += \"  -minrelaytxfee=<amt>   \" + strprintf(_(\"Fees (in BTC/Kb) smaller than this are considered zero fee for relaying (default: %s)\"), FormatMoney(::minRelayTxFee.GetFeePerK())) + \"\\n\";\n     strUsage += \"  -printtoconsole        \" + _(\"Send trace/debug info to console instead of debug.log file\") + \"\\n\";\n     if (GetBoolArg(\"-help-debug\", false))\n     {\n@@ -306,6 +329,9 @@ std::string HelpMessage(HelpMessageMode hmm)\n     strUsage += \"  -shrinkdebugfile       \" + _(\"Shrink debug.log file on client startup (default: 1 when no -debug)\") + \"\\n\";\n     strUsage += \"  -testnet               \" + _(\"Use the test network\") + \"\\n\";\n \n+    strUsage += \"\\n\" + _(\"Node relay options:\") + \"\\n\";\n+    strUsage += \"  -datacarrier           \" + _(\"Relay and mine data carrier transactions (default: 1)\") + \"\\n\";\n+\n     strUsage += \"\\n\" + _(\"Block creation options:\") + \"\\n\";\n     strUsage += \"  -blockminsize=<n>      \" + _(\"Set minimum block size in bytes (default: 0)\") + \"\\n\";\n     strUsage += \"  -blockmaxsize=<n>      \" + strprintf(_(\"Set maximum block size in bytes (default: %d)\"), DEFAULT_BLOCK_MAX_SIZE) + \"\\n\";\n@@ -317,7 +343,7 @@ std::string HelpMessage(HelpMessageMode hmm)\n     strUsage += \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\";\n     strUsage += \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\";\n     strUsage += \"  -rpcport=<port>        \" + _(\"Listen for JSON-RPC connections on <port> (default: 8332 or testnet: 18332)\") + \"\\n\";\n-    strUsage += \"  -rpcallowip=<ip>       \" + _(\"Allow JSON-RPC connections from specified IP address. This option can be specified multiple times\") + \"\\n\";\n+    strUsage += \"  -rpcallowip=<ip>       \" + _(\"Allow JSON-RPC connections from specified source. Valid for <ip> are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\") + \"\\n\";\n     strUsage += \"  -rpcthreads=<n>        \" + _(\"Set the number of threads to service RPC calls (default: 4)\") + \"\\n\";\n \n     strUsage += \"\\n\" + _(\"RPC SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") + \"\\n\";\n@@ -404,6 +430,11 @@ void ThreadImport(std::vector<boost::filesystem::path> vImportFiles)\n             LogPrintf(\"Warning: Could not open blocks file %s\\n\", path.string());\n         }\n     }\n+\n+    if (GetBoolArg(\"-stopafterblockimport\", false)) {\n+        LogPrintf(\"Stopping after block import\\n\");\n+        StartShutdown();\n+    }\n }\n \n /** Sanity checks\n@@ -417,8 +448,8 @@ bool InitSanityCheck(void)\n                   \"information, visit https://en.bitcoin.it/wiki/OpenSSL_and_EC_Libraries\");\n         return false;\n     }\n-\n-    // TODO: remaining sanity checks, see #4081\n+    if (!glibc_sanity_test() || !glibcxx_sanity_test())\n+        return false;\n \n     return true;\n }\n@@ -460,7 +491,15 @@ bool AppInit2(boost::thread_group& threadGroup)\n     }\n #endif\n #ifndef WIN32\n-    umask(077);\n+\n+    if (GetBoolArg(\"-sysperms\", false)) {\n+#ifdef ENABLE_WALLET\n+        if (!GetBoolArg(\"-disablewallet\", false))\n+            return InitError(\"Error: -sysperms is not allowed in combination with enabled wallet functionality\");\n+#endif\n+    } else {\n+        umask(077);\n+    }\n \n     // Clean shutdown on SIGTERM\n     struct sigaction sa;\n@@ -485,11 +524,11 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n     // ********************************************************* Step 2: parameter interactions\n \n-    if (mapArgs.count(\"-bind\")) {\n+    if (mapArgs.count(\"-bind\") || mapArgs.count(\"-whitebind\")) {\n         // when specifying an explicit binding address, you want to listen on it\n         // even when -connect or -proxy is specified\n         if (SoftSetBoolArg(\"-listen\", true))\n-            LogPrintf(\"AppInit2 : parameter interaction: -bind set -> setting -listen=1\\n\");\n+            LogPrintf(\"AppInit2 : parameter interaction: -bind or -whitebind set -> setting -listen=1\\n\");\n     }\n \n     if (mapArgs.count(\"-connect\") && mapMultiArgs[\"-connect\"].size() > 0) {\n@@ -529,11 +568,11 @@ bool AppInit2(boost::thread_group& threadGroup)\n     // -zapwallettx implies a rescan\n     if (GetBoolArg(\"-zapwallettxes\", false)) {\n         if (SoftSetBoolArg(\"-rescan\", true))\n-            LogPrintf(\"AppInit2 : parameter interaction: -zapwallettxes=1 -> setting -rescan=1\\n\");\n+            LogPrintf(\"AppInit2 : parameter interaction: -zapwallettxes=<mode> -> setting -rescan=1\\n\");\n     }\n \n     // Make sure enough file descriptors are available\n-    int nBind = std::max((int)mapArgs.count(\"-bind\"), 1);\n+    int nBind = std::max((int)mapArgs.count(\"-bind\") + (int)mapArgs.count(\"-whitebind\"), 1);\n     nMaxConnections = GetArg(\"-maxconnections\", 125);\n     nMaxConnections = std::max(std::min(nMaxConnections, (int)(FD_SETSIZE - nBind - MIN_CORE_FILEDESCRIPTORS)), 0);\n     int nFD = RaiseFileDescriptorLimit(nMaxConnections + MIN_CORE_FILEDESCRIPTORS);\n@@ -550,9 +589,15 @@ bool AppInit2(boost::thread_group& threadGroup)\n     if (GetBoolArg(\"-nodebug\", false) || find(categories.begin(), categories.end(), string(\"0\")) != categories.end())\n         fDebug = false;\n \n-    // Check for -debugnet (deprecated)\n+    // Check for -debugnet\n     if (GetBoolArg(\"-debugnet\", false))\n-        InitWarning(_(\"Warning: Deprecated argument -debugnet ignored, use -debug=net\"));\n+        InitWarning(_(\"Warning: Unsupported argument -debugnet ignored, use -debug=net.\"));\n+    // Check for -socks - as this is a privacy risk to continue, exit here\n+    if (mapArgs.count(\"-socks\"))\n+        return InitError(_(\"Error: Unsupported argument -socks found. Setting SOCKS version isn't possible anymore, only SOCKS5 proxies are supported.\"));\n+    // Check for -tor - as this is a privacy risk to continue, exit here\n+    if (GetBoolArg(\"-tor\", false))\n+        return InitError(_(\"Error: Unsupported argument -tor found, use -onion.\"));\n \n     fBenchmark = GetBoolArg(\"-benchmark\", false);\n     // Checkmempool defaults to true in regtest mode\n@@ -571,6 +616,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n     fServer = GetBoolArg(\"-server\", false);\n     fPrintToConsole = GetBoolArg(\"-printtoconsole\", false);\n     fLogTimestamps = GetBoolArg(\"-logtimestamps\", true);\n+    fLogIPs = GetBoolArg(\"-logips\", false);\n     setvbuf(stdout, NULL, _IOLBF, 0);\n #ifdef ENABLE_WALLET\n     bool fDisableWallet = GetBoolArg(\"-disablewallet\", false);\n@@ -595,24 +641,24 @@ bool AppInit2(boost::thread_group& threadGroup)\n     // a transaction spammer can cheaply fill blocks using\n     // 1-satoshi-fee transactions. It should be set above the real\n     // cost to you of processing a transaction.\n-    if (mapArgs.count(\"-mintxfee\"))\n-    {\n-        int64_t n = 0;\n-        if (ParseMoney(mapArgs[\"-mintxfee\"], n) && n > 0)\n-            CTransaction::minTxFee = CFeeRate(n);\n-        else\n-            return InitError(strprintf(_(\"Invalid amount for -mintxfee=<amount>: '%s'\"), mapArgs[\"-mintxfee\"]));\n-    }\n     if (mapArgs.count(\"-minrelaytxfee\"))\n     {\n         int64_t n = 0;\n         if (ParseMoney(mapArgs[\"-minrelaytxfee\"], n) && n > 0)\n-            CTransaction::minRelayTxFee = CFeeRate(n);\n+            ::minRelayTxFee = CFeeRate(n);\n         else\n             return InitError(strprintf(_(\"Invalid amount for -minrelaytxfee=<amount>: '%s'\"), mapArgs[\"-minrelaytxfee\"]));\n     }\n \n #ifdef ENABLE_WALLET\n+    if (mapArgs.count(\"-mintxfee\"))\n+    {\n+        int64_t n = 0;\n+        if (ParseMoney(mapArgs[\"-mintxfee\"], n) && n > 0)\n+            CWallet::minTxFee = CFeeRate(n);\n+        else\n+            return InitError(strprintf(_(\"Invalid amount for -mintxfee=<amount>: '%s'\"), mapArgs[\"-mintxfee\"]));\n+    }\n     if (mapArgs.count(\"-paytxfee\"))\n     {\n         int64_t nFeePerK = 0;\n@@ -621,11 +667,20 @@ bool AppInit2(boost::thread_group& threadGroup)\n         if (nFeePerK > nHighTransactionFeeWarning)\n             InitWarning(_(\"Warning: -paytxfee is set very high! This is the transaction fee you will pay if you send a transaction.\"));\n         payTxFee = CFeeRate(nFeePerK, 1000);\n+        if (payTxFee < ::minRelayTxFee)\n+        {\n+            return InitError(strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)\"),\n+                                       mapArgs[\"-paytxfee\"], ::minRelayTxFee.ToString()));\n+        }\n     }\n+    nTxConfirmTarget = GetArg(\"-txconfirmtarget\", 1);\n     bSpendZeroConfChange = GetArg(\"-spendzeroconfchange\", true);\n \n     std::string strWalletFile = GetArg(\"-wallet\", \"wallet.dat\");\n-#endif\n+#endif // ENABLE_WALLET\n+\n+    fIsBareMultisigStd = GetArg(\"-permitbaremultisig\", true);\n+\n     // ********************************************************* Step 4: application initialization: dir lock, daemonize, pidfile, debug log\n     // Sanity check\n     if (!InitSanityCheck())\n@@ -722,10 +777,6 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n     RegisterNodeSignals(GetNodeSignals());\n \n-    int nSocksVersion = GetArg(\"-socks\", 5);\n-    if (nSocksVersion != 4 && nSocksVersion != 5)\n-        return InitError(strprintf(_(\"Unknown -socks proxy version requested: %i\"), nSocksVersion));\n-\n     if (mapArgs.count(\"-onlynet\")) {\n         std::set<enum Network> nets;\n         BOOST_FOREACH(std::string snet, mapMultiArgs[\"-onlynet\"]) {\n@@ -741,6 +792,15 @@ bool AppInit2(boost::thread_group& threadGroup)\n         }\n     }\n \n+    if (mapArgs.count(\"-whitelist\")) {\n+        BOOST_FOREACH(const std::string& net, mapMultiArgs[\"-whitelist\"]) {\n+            CSubNet subnet(net);\n+            if (!subnet.IsValid())\n+                return InitError(strprintf(_(\"Invalid netmask specified in -whitelist: '%s'\"), net));\n+            CNode::AddWhitelistedRange(subnet);\n+        }\n+    }\n+\n     CService addrProxy;\n     bool fProxy = false;\n     if (mapArgs.count(\"-proxy\")) {\n@@ -749,30 +809,24 @@ bool AppInit2(boost::thread_group& threadGroup)\n             return InitError(strprintf(_(\"Invalid -proxy address: '%s'\"), mapArgs[\"-proxy\"]));\n \n         if (!IsLimited(NET_IPV4))\n-            SetProxy(NET_IPV4, addrProxy, nSocksVersion);\n-        if (nSocksVersion > 4) {\n-            if (!IsLimited(NET_IPV6))\n-                SetProxy(NET_IPV6, addrProxy, nSocksVersion);\n-            SetNameProxy(addrProxy, nSocksVersion);\n-        }\n+            SetProxy(NET_IPV4, addrProxy);\n+        if (!IsLimited(NET_IPV6))\n+            SetProxy(NET_IPV6, addrProxy);\n+        SetNameProxy(addrProxy);\n         fProxy = true;\n     }\n \n     // -onion can override normal proxy, -noonion disables tor entirely\n-    // -tor here is a temporary backwards compatibility measure\n-    if (mapArgs.count(\"-tor\"))\n-        printf(\"Notice: option -tor has been replaced with -onion and will be removed in a later version.\\n\");\n     if (!(mapArgs.count(\"-onion\") && mapArgs[\"-onion\"] == \"0\") &&\n-        !(mapArgs.count(\"-tor\") && mapArgs[\"-tor\"] == \"0\") &&\n-         (fProxy || mapArgs.count(\"-onion\") || mapArgs.count(\"-tor\"))) {\n+        (fProxy || mapArgs.count(\"-onion\"))) {\n         CService addrOnion;\n-        if (!mapArgs.count(\"-onion\") && !mapArgs.count(\"-tor\"))\n+        if (!mapArgs.count(\"-onion\"))\n             addrOnion = addrProxy;\n         else\n-            addrOnion = mapArgs.count(\"-onion\")?CService(mapArgs[\"-onion\"], 9050):CService(mapArgs[\"-tor\"], 9050);\n+            addrOnion = CService(mapArgs[\"-onion\"], 9050);\n         if (!addrOnion.IsValid())\n-            return InitError(strprintf(_(\"Invalid -onion address: '%s'\"), mapArgs.count(\"-onion\")?mapArgs[\"-onion\"]:mapArgs[\"-tor\"]));\n-        SetProxy(NET_TOR, addrOnion, 5);\n+            return InitError(strprintf(_(\"Invalid -onion address: '%s'\"), mapArgs[\"-onion\"]));\n+        SetProxy(NET_TOR, addrOnion);\n         SetReachable(NET_TOR);\n     }\n \n@@ -783,13 +837,21 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n     bool fBound = false;\n     if (fListen) {\n-        if (mapArgs.count(\"-bind\")) {\n+        if (mapArgs.count(\"-bind\") || mapArgs.count(\"-whitebind\")) {\n             BOOST_FOREACH(std::string strBind, mapMultiArgs[\"-bind\"]) {\n                 CService addrBind;\n                 if (!Lookup(strBind.c_str(), addrBind, GetListenPort(), false))\n                     return InitError(strprintf(_(\"Cannot resolve -bind address: '%s'\"), strBind));\n                 fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR));\n             }\n+            BOOST_FOREACH(std::string strBind, mapMultiArgs[\"-whitebind\"]) {\n+                CService addrBind;\n+                if (!Lookup(strBind.c_str(), addrBind, 0, false))\n+                    return InitError(strprintf(_(\"Cannot resolve -whitebind address: '%s'\"), strBind));\n+                if (addrBind.GetPort() == 0)\n+                    return InitError(strprintf(_(\"Need to specify a port with -whitebind: '%s'\"), strBind));\n+                fBound |= Bind(addrBind, (BF_EXPLICIT | BF_REPORT_ERROR | BF_WHITELIST));\n+            }\n         }\n         else {\n             struct in_addr inaddr_any;\n@@ -977,6 +1039,7 @@ bool AppInit2(boost::thread_group& threadGroup)\n \n     boost::filesystem::path est_path = GetDataDir() / FEE_ESTIMATES_FILENAME;\n     CAutoFile est_filein = CAutoFile(fopen(est_path.string().c_str(), \"rb\"), SER_DISK, CLIENT_VERSION);\n+    // Allowed to fail as this file IS missing on first startup.\n     if (est_filein)\n         mempool.ReadFeeEstimates(est_filein);\n \n@@ -986,11 +1049,15 @@ bool AppInit2(boost::thread_group& threadGroup)\n         pwalletMain = NULL;\n         LogPrintf(\"Wallet disabled!\\n\");\n     } else {\n+\n+        // needed to restore wallet transaction meta data after -zapwallettxes\n+        std::vector<CWalletTx> vWtx;\n+\n         if (GetBoolArg(\"-zapwallettxes\", false)) {\n             uiInterface.InitMessage(_(\"Zapping all transactions from wallet...\"));\n \n             pwalletMain = new CWallet(strWalletFile);\n-            DBErrors nZapWalletRet = pwalletMain->ZapWalletTx();\n+            DBErrors nZapWalletRet = pwalletMain->ZapWalletTx(vWtx);\n             if (nZapWalletRet != DB_LOAD_OK) {\n                 uiInterface.InitMessage(_(\"Error loading wallet.dat: Wallet corrupted\"));\n                 return false;\n@@ -1085,6 +1152,29 @@ bool AppInit2(boost::thread_group& threadGroup)\n             LogPrintf(\" rescan      %15dms\\n\", GetTimeMillis() - nStart);\n             pwalletMain->SetBestChain(chainActive.GetLocator());\n             nWalletDBUpdated++;\n+\n+            // Restore wallet transaction metadata after -zapwallettxes=1\n+            if (GetBoolArg(\"-zapwallettxes\", false) && GetArg(\"-zapwallettxes\", \"1\") != \"2\")\n+            {\n+                BOOST_FOREACH(const CWalletTx& wtxOld, vWtx)\n+                {\n+                    uint256 hash = wtxOld.GetHash();\n+                    std::map<uint256, CWalletTx>::iterator mi = pwalletMain->mapWallet.find(hash);\n+                    if (mi != pwalletMain->mapWallet.end())\n+                    {\n+                        const CWalletTx* copyFrom = &wtxOld;\n+                        CWalletTx* copyTo = &mi->second;\n+                        copyTo->mapValue = copyFrom->mapValue;\n+                        copyTo->vOrderForm = copyFrom->vOrderForm;\n+                        copyTo->nTimeReceived = copyFrom->nTimeReceived;\n+                        copyTo->nTimeSmart = copyFrom->nTimeSmart;\n+                        copyTo->fFromMe = copyFrom->fFromMe;\n+                        copyTo->strFromAccount = copyFrom->strFromAccount;\n+                        copyTo->nOrderPos = copyFrom->nOrderPos;\n+                        copyTo->WriteToDisk();\n+                    }\n+                }\n+            }\n         }\n     } // (!fDisableWallet)\n #else // ENABLE_WALLET\n@@ -1140,8 +1230,6 @@ bool AppInit2(boost::thread_group& threadGroup)\n #endif\n \n     StartNode(threadGroup);\n-    // InitRPCMining is needed here so getwork/getblocktemplate in the GUI debug console works properly.\n-    InitRPCMining();\n     if (fServer)\n         StartRPCThreads();\n "
      },
      {
        "sha": "626525c9adb5fe8a3b239294e8dfb9ec37ae2935",
        "filename": "src/init.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/init.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/init.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -12,7 +12,7 @@ class CWallet;\n \n namespace boost {\n     class thread_group;\n-};\n+} // namespace boost\n \n extern CWallet* pwalletMain;\n "
      },
      {
        "sha": "a253f8666abcd7a02be58e927bb5f0580358c4a3",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 131,
        "deletions": 29,
        "changes": 160,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -1,17 +1,38 @@\n-// Copyright (c) 2009-2013 The Bitcoin developers\n+// Copyright (c) 2009-2014 The Bitcoin developers\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include \"key.h\"\n \n+#include \"crypto/sha2.h\"\n+#include \"random.h\"\n+\n+#ifdef USE_SECP256K1\n+#include <secp256k1.h>\n+#else\n #include <openssl/bn.h>\n #include <openssl/ecdsa.h>\n #include <openssl/obj_mac.h>\n-#include <openssl/rand.h>\n+#endif\n \n // anonymous namespace with local implementation code (OpenSSL interaction)\n namespace {\n \n+#ifdef USE_SECP256K1\n+#include <secp256k1.h>\n+class CSecp256k1Init {\n+public:\n+    CSecp256k1Init() {\n+        secp256k1_start();\n+    }\n+    ~CSecp256k1Init() {\n+        secp256k1_stop();\n+    }\n+};\n+static CSecp256k1Init instance_of_csecp256k1;\n+\n+#else\n+\n // Generate a private key from just the secret parameter\n int EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)\n {\n@@ -173,7 +194,7 @@ class CECKey {\n         if (d2i_ECPrivateKey(&pkey, &pbegin, privkey.size())) {\n             if(fSkipCheck)\n                 return true;\n-            \n+\n             // d2i_ECPrivateKey returns true if parsing succeeds.\n             // This doesn't necessarily mean the key is valid.\n             if (EC_KEY_check_key(pkey))\n@@ -332,6 +353,8 @@ class CECKey {\n     }\n };\n \n+#endif\n+\n int CompareBigEndian(const unsigned char *c1, size_t c1len, const unsigned char *c2, size_t c2len) {\n     while (c1len > c2len) {\n         if (*c1)\n@@ -375,8 +398,7 @@ const unsigned char vchMaxModHalfOrder[32] = {\n \n const unsigned char vchZero[0] = {};\n \n-\n-}; // end of anonymous namespace\n+} // anon namespace\n \n bool CKey::Check(const unsigned char *vch) {\n     return CompareBigEndian(vch, 32, vchZero, 0) > 0 &&\n@@ -390,117 +412,190 @@ bool CKey::CheckSignatureElement(const unsigned char *vch, int len, bool half) {\n \n void CKey::MakeNewKey(bool fCompressedIn) {\n     do {\n-        RAND_bytes(vch, sizeof(vch));\n+        GetRandBytes(vch, sizeof(vch));\n     } while (!Check(vch));\n     fValid = true;\n     fCompressed = fCompressedIn;\n }\n \n bool CKey::SetPrivKey(const CPrivKey &privkey, bool fCompressedIn) {\n+#ifdef USE_SECP256K1\n+    if (!secp256k1_ecdsa_privkey_import((unsigned char*)begin(), &privkey[0], privkey.size()))\n+        return false;\n+#else\n     CECKey key;\n     if (!key.SetPrivKey(privkey))\n         return false;\n     key.GetSecretBytes(vch);\n+#endif\n     fCompressed = fCompressedIn;\n     fValid = true;\n     return true;\n }\n \n CPrivKey CKey::GetPrivKey() const {\n     assert(fValid);\n+    CPrivKey privkey;\n+#ifdef USE_SECP256K1\n+    privkey.resize(279);\n+    int privkeylen = 279;\n+    int ret = secp256k1_ecdsa_privkey_export(begin(), (unsigned char*)&privkey[0], &privkeylen, fCompressed);\n+    assert(ret);\n+    privkey.resize(privkeylen);\n+#else\n     CECKey key;\n     key.SetSecretBytes(vch);\n-    CPrivKey privkey;\n     key.GetPrivKey(privkey, fCompressed);\n+#endif\n     return privkey;\n }\n \n CPubKey CKey::GetPubKey() const {\n     assert(fValid);\n+    CPubKey pubkey;\n+#ifdef USE_SECP256K1\n+    int clen = 65;\n+    int ret = secp256k1_ecdsa_pubkey_create((unsigned char*)pubkey.begin(), &clen, begin(), fCompressed);\n+    assert(ret);\n+    assert(pubkey.IsValid());\n+    assert((int)pubkey.size() == clen);\n+#else\n     CECKey key;\n     key.SetSecretBytes(vch);\n-    CPubKey pubkey;\n     key.GetPubKey(pubkey, fCompressed);\n+#endif\n     return pubkey;\n }\n \n bool CKey::Sign(const uint256 &hash, std::vector<unsigned char>& vchSig) const {\n     if (!fValid)\n         return false;\n+#ifdef USE_SECP256K1\n+    vchSig.resize(72);\n+    int nSigLen = 72;\n+    CKey nonce;\n+    do {\n+        nonce.MakeNewKey(true);\n+        if (secp256k1_ecdsa_sign((const unsigned char*)&hash, 32, (unsigned char*)&vchSig[0], &nSigLen, begin(), nonce.begin()))\n+            break;\n+    } while(true);\n+    vchSig.resize(nSigLen);\n+    return true;\n+#else\n     CECKey key;\n     key.SetSecretBytes(vch);\n     return key.Sign(hash, vchSig);\n+#endif\n }\n \n bool CKey::SignCompact(const uint256 &hash, std::vector<unsigned char>& vchSig) const {\n     if (!fValid)\n         return false;\n-    CECKey key;\n-    key.SetSecretBytes(vch);\n     vchSig.resize(65);\n     int rec = -1;\n+#ifdef USE_SECP256K1\n+    CKey nonce;\n+    do {\n+        nonce.MakeNewKey(true);\n+        if (secp256k1_ecdsa_sign_compact((const unsigned char*)&hash, 32, &vchSig[1], begin(), nonce.begin(), &rec))\n+            break;\n+    } while(true);\n+#else\n+    CECKey key;\n+    key.SetSecretBytes(vch);\n     if (!key.SignCompact(hash, &vchSig[1], rec))\n         return false;\n+#endif\n     assert(rec != -1);\n     vchSig[0] = 27 + rec + (fCompressed ? 4 : 0);\n     return true;\n }\n \n bool CKey::Load(CPrivKey &privkey, CPubKey &vchPubKey, bool fSkipCheck=false) {\n+#ifdef USE_SECP256K1\n+    if (!secp256k1_ecdsa_privkey_import((unsigned char*)begin(), &privkey[0], privkey.size()))\n+        return false;\n+#else\n     CECKey key;\n     if (!key.SetPrivKey(privkey, fSkipCheck))\n         return false;\n-    \n     key.GetSecretBytes(vch);\n+#endif\n     fCompressed = vchPubKey.IsCompressed();\n     fValid = true;\n-    \n+\n     if (fSkipCheck)\n         return true;\n-    \n+\n     if (GetPubKey() != vchPubKey)\n         return false;\n-    \n+\n     return true;\n }\n \n bool CPubKey::Verify(const uint256 &hash, const std::vector<unsigned char>& vchSig) const {\n     if (!IsValid())\n         return false;\n+#ifdef USE_SECP256K1\n+    if (secp256k1_ecdsa_verify((const unsigned char*)&hash, 32, &vchSig[0], vchSig.size(), begin(), size()) != 1)\n+        return false;\n+#else\n     CECKey key;\n     if (!key.SetPubKey(*this))\n         return false;\n     if (!key.Verify(hash, vchSig))\n         return false;\n+#endif\n     return true;\n }\n \n bool CPubKey::RecoverCompact(const uint256 &hash, const std::vector<unsigned char>& vchSig) {\n     if (vchSig.size() != 65)\n         return false;\n+    int recid = (vchSig[0] - 27) & 3;\n+    bool fComp = (vchSig[0] - 27) & 4;\n+#ifdef USE_SECP256K1\n+    int pubkeylen = 65;\n+    if (!secp256k1_ecdsa_recover_compact((const unsigned char*)&hash, 32, &vchSig[1], (unsigned char*)begin(), &pubkeylen, fComp, recid))\n+        return false;\n+    assert((int)size() == pubkeylen);\n+#else\n     CECKey key;\n-    if (!key.Recover(hash, &vchSig[1], (vchSig[0] - 27) & ~4))\n+    if (!key.Recover(hash, &vchSig[1], recid))\n         return false;\n-    key.GetPubKey(*this, (vchSig[0] - 27) & 4);\n+    key.GetPubKey(*this, fComp);\n+#endif\n     return true;\n }\n \n bool CPubKey::IsFullyValid() const {\n     if (!IsValid())\n         return false;\n+#ifdef USE_SECP256K1\n+    if (!secp256k1_ecdsa_pubkey_verify(begin(), size()))\n+        return false;\n+#else\n     CECKey key;\n     if (!key.SetPubKey(*this))\n         return false;\n+#endif\n     return true;\n }\n \n bool CPubKey::Decompress() {\n     if (!IsValid())\n         return false;\n+#ifdef USE_SECP256K1\n+    int clen = size();\n+    int ret = secp256k1_ecdsa_pubkey_decompress((unsigned char*)begin(), &clen);\n+    assert(ret);\n+    assert(clen == (int)size());\n+#else\n     CECKey key;\n     if (!key.SetPubKey(*this))\n         return false;\n     key.GetPubKey(*this, false);\n+#endif\n     return true;\n }\n \n@@ -510,12 +605,10 @@ void static BIP32Hash(const unsigned char chainCode[32], unsigned int nChild, un\n     num[1] = (nChild >> 16) & 0xFF;\n     num[2] = (nChild >>  8) & 0xFF;\n     num[3] = (nChild >>  0) & 0xFF;\n-    HMAC_SHA512_CTX ctx;\n-    HMAC_SHA512_Init(&ctx, chainCode, 32);\n-    HMAC_SHA512_Update(&ctx, &header, 1);\n-    HMAC_SHA512_Update(&ctx, data, 32);\n-    HMAC_SHA512_Update(&ctx, num, 4);\n-    HMAC_SHA512_Final(output, &ctx);\n+    CHMAC_SHA512(chainCode, 32).Write(&header, 1)\n+                               .Write(data, 32)\n+                               .Write(num, 4)\n+                               .Finalize(output);\n }\n \n bool CKey::Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild, const unsigned char cc[32]) const {\n@@ -532,7 +625,12 @@ bool CKey::Derive(CKey& keyChild, unsigned char ccChild[32], unsigned int nChild\n         BIP32Hash(cc, nChild, 0, begin(), out);\n     }\n     memcpy(ccChild, out+32, 32);\n+#ifdef USE_SECP256K1\n+    memcpy((unsigned char*)keyChild.begin(), begin(), 32);\n+    bool ret = secp256k1_ecdsa_privkey_tweak_add((unsigned char*)keyChild.begin(), out);\n+#else\n     bool ret = CECKey::TweakSecret((unsigned char*)keyChild.begin(), begin(), out);\n+#endif\n     UnlockObject(out);\n     keyChild.fCompressed = true;\n     keyChild.fValid = ret;\n@@ -546,10 +644,15 @@ bool CPubKey::Derive(CPubKey& pubkeyChild, unsigned char ccChild[32], unsigned i\n     unsigned char out[64];\n     BIP32Hash(cc, nChild, *begin(), begin()+1, out);\n     memcpy(ccChild, out+32, 32);\n+#ifdef USE_SECP256K1\n+    pubkeyChild = *this;\n+    bool ret = secp256k1_ecdsa_pubkey_tweak_add((unsigned char*)pubkeyChild.begin(), pubkeyChild.size(), out);\n+#else\n     CECKey key;\n     bool ret = key.SetPubKey(*this);\n     ret &= key.TweakPublic(out);\n     key.GetPubKey(pubkeyChild, true);\n+#endif\n     return ret;\n }\n \n@@ -562,13 +665,10 @@ bool CExtKey::Derive(CExtKey &out, unsigned int nChild) const {\n }\n \n void CExtKey::SetMaster(const unsigned char *seed, unsigned int nSeedLen) {\n-    static const char hashkey[] = {'B','i','t','c','o','i','n',' ','s','e','e','d'};\n-    HMAC_SHA512_CTX ctx;\n-    HMAC_SHA512_Init(&ctx, hashkey, sizeof(hashkey));\n-    HMAC_SHA512_Update(&ctx, seed, nSeedLen);\n+    static const unsigned char hashkey[] = {'B','i','t','c','o','i','n',' ','s','e','e','d'};\n     unsigned char out[64];\n     LockObject(out);\n-    HMAC_SHA512_Final(out, &ctx);\n+    CHMAC_SHA512(hashkey, sizeof(hashkey)).Write(seed, nSeedLen).Finalize(out);\n     key.Set(&out[0], &out[32], true);\n     memcpy(vchChainCode, &out[32], 32);\n     UnlockObject(out);\n@@ -633,13 +733,15 @@ bool CExtPubKey::Derive(CExtPubKey &out, unsigned int nChild) const {\n }\n \n bool ECC_InitSanityCheck() {\n+#ifdef USE_SECP256K1\n+    return true;\n+#else\n     EC_KEY *pkey = EC_KEY_new_by_curve_name(NID_secp256k1);\n     if(pkey == NULL)\n         return false;\n     EC_KEY_free(pkey);\n \n     // TODO Is there more EC functionality that could be missing?\n     return true;\n+#endif\n }\n-\n-"
      },
      {
        "sha": "2a4c88d5656dd28d96bc0319a27b47ed730fc957",
        "filename": "src/keystore.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/keystore.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/keystore.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -59,3 +59,15 @@ bool CBasicKeyStore::GetCScript(const CScriptID &hash, CScript& redeemScriptOut)\n     return false;\n }\n \n+bool CBasicKeyStore::AddWatchOnly(const CScript &dest)\n+{\n+    LOCK(cs_KeyStore);\n+    setWatchOnly.insert(dest);\n+    return true;\n+}\n+\n+bool CBasicKeyStore::HaveWatchOnly(const CScript &dest) const\n+{\n+    LOCK(cs_KeyStore);\n+    return setWatchOnly.count(dest) > 0;\n+}"
      },
      {
        "sha": "72411a1387c0eac6416828bb4606216807f40319",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -8,11 +8,21 @@\n \n #include \"key.h\"\n #include \"sync.h\"\n+#include \"script.h\"     // for CNoDestination\n \n #include <boost/signals2/signal.hpp>\n+#include <boost/variant.hpp>\n \n class CScript;\n \n+/** A txout script template with a specific destination. It is either:\n+ *  * CNoDestination: no destination set\n+ *  * CKeyID: TX_PUBKEYHASH destination\n+ *  * CScriptID: TX_SCRIPTHASH destination\n+ *  A CTxDestination is the internal data type encoded in a CBitcoinAddress\n+ */\n+typedef boost::variant<CNoDestination, CKeyID, CScriptID> CTxDestination;\n+\n /** A virtual base class for key stores */\n class CKeyStore\n {\n@@ -36,17 +46,23 @@ class CKeyStore\n     virtual bool AddCScript(const CScript& redeemScript) =0;\n     virtual bool HaveCScript(const CScriptID &hash) const =0;\n     virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const =0;\n+\n+    // Support for Watch-only addresses\n+    virtual bool AddWatchOnly(const CScript &dest) =0;\n+    virtual bool HaveWatchOnly(const CScript &dest) const =0;\n };\n \n typedef std::map<CKeyID, CKey> KeyMap;\n typedef std::map<CScriptID, CScript > ScriptMap;\n+typedef std::set<CScript> WatchOnlySet;\n \n /** Basic key store, that keeps keys in an address->secret map */\n class CBasicKeyStore : public CKeyStore\n {\n protected:\n     KeyMap mapKeys;\n     ScriptMap mapScripts;\n+    WatchOnlySet setWatchOnly;\n \n public:\n     bool AddKeyPubKey(const CKey& key, const CPubKey &pubkey);\n@@ -88,6 +104,9 @@ class CBasicKeyStore : public CKeyStore\n     virtual bool AddCScript(const CScript& redeemScript);\n     virtual bool HaveCScript(const CScriptID &hash) const;\n     virtual bool GetCScript(const CScriptID &hash, CScript& redeemScriptOut) const;\n+\n+    virtual bool AddWatchOnly(const CScript &dest);\n+    virtual bool HaveWatchOnly(const CScript &dest) const;\n };\n \n typedef std::vector<unsigned char, secure_allocator<unsigned char> > CKeyingMaterial;"
      },
      {
        "sha": "9e849696a8480988e160a4b3e075ac03a8fcbf2b",
        "filename": "src/leveldbwrapper.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/leveldbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/leveldbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldbwrapper.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -32,6 +32,11 @@ static leveldb::Options GetOptions(size_t nCacheSize) {\n     options.filter_policy = leveldb::NewBloomFilterPolicy(10);\n     options.compression = leveldb::kNoCompression;\n     options.max_open_files = 64;\n+    if (leveldb::kMajorVersion > 1 || (leveldb::kMajorVersion == 1 && leveldb::kMinorVersion >= 16)) {\n+        // LevelDB versions before 1.16 consider short writes to be corruption. Only trigger error\n+        // on corruption in later versions.\n+        options.paranoid_checks = true;\n+    }\n     return options;\n }\n "
      },
      {
        "sha": "9356aac37fbc675637dd5d91da2215fa7c035536",
        "filename": "src/m4/bitcoin_qt.m4",
        "status": "modified",
        "additions": 61,
        "deletions": 49,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/m4/bitcoin_qt.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/m4/bitcoin_qt.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/m4/bitcoin_qt.m4?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -86,14 +86,68 @@ AC_DEFUN([BITCOIN_QT_CONFIGURE],[\n   fi\n \n   if test x$use_pkgconfig = xyes; then\n-    if test x$PKG_CONFIG == x; then\n-      AC_MSG_ERROR(pkg-config not found.)\n-    fi\n     BITCOIN_QT_CHECK([_BITCOIN_QT_FIND_LIBS_WITH_PKGCONFIG([$2])])\n   else\n     BITCOIN_QT_CHECK([_BITCOIN_QT_FIND_LIBS_WITHOUT_PKGCONFIG])\n   fi\n \n+  dnl This is ugly and complicated. Yuck. Works as follows:\n+  dnl We can't discern whether Qt4 builds are static or not. For Qt5, we can\n+  dnl check a header to find out. When Qt is built statically, some plugins must\n+  dnl be linked into the final binary as well. These plugins have changed between\n+  dnl Qt4 and Qt5. With Qt5, languages moved into core and the WindowsIntegration\n+  dnl plugin was added. Since we can't tell if Qt4 is static or not, it is\n+  dnl assumed for windows builds.\n+  dnl _BITCOIN_QT_CHECK_STATIC_PLUGINS does a quick link-check and appends the\n+  dnl results to QT_LIBS.\n+  BITCOIN_QT_CHECK([\n+  TEMP_CPPFLAGS=$CPPFLAGS\n+  CPPFLAGS=$QT_INCLUDES\n+  if test x$bitcoin_qt_got_major_vers == x5; then\n+    _BITCOIN_QT_IS_STATIC\n+    if test x$bitcoin_cv_static_qt == xyes; then\n+      AC_DEFINE(QT_STATICPLUGIN, 1, [Define this symbol if qt plugins are static])\n+      if test x$qt_plugin_path != x; then\n+        QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/accessible\"\n+        if test x$bitcoin_qt_got_major_vers == x5; then\n+          QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/platforms\"\n+        else\n+          QT_LIBS=\"$QT_LIBS -L$qt_plugin_path/codecs\"\n+        fi\n+      fi\n+      if test x$use_pkgconfig = xyes; then\n+        PKG_CHECK_MODULES([QTPLATFORM], [Qt5PlatformSupport], [QT_LIBS=\"$QTPLATFORM_LIBS $QT_LIBS\"])\n+      fi\n+      _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(AccessibleFactory)], [-lqtaccessiblewidgets])\n+      if test x$TARGET_OS == xwindows; then\n+        _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin)],[-lqwindows])\n+        AC_DEFINE(QT_QPA_PLATFORM_WINDOWS, 1, [Define this symbol if the qt platform is windows])\n+      elif test x$TARGET_OS == xlinux; then\n+        _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QXcbIntegrationPlugin)],[-lqxcb -lxcb-static -lxcb])\n+        AC_DEFINE(QT_QPA_PLATFORM_XCB, 1, [Define this symbol if the qt platform is xcb])\n+      elif test x$TARGET_OS == xdarwin; then\n+        if test x$use_pkgconfig = xyes; then\n+          PKG_CHECK_MODULES([QTPRINT], [Qt5PrintSupport], [QT_LIBS=\"$QTPRINT_LIBS $QT_LIBS\"])\n+        fi\n+        AX_CHECK_LINK_FLAG([[-framework IOKit]],[QT_LIBS=\"$QT_LIBS -framework IOKit\"],[AC_MSG_ERROR(could not iokit framework)])\n+        _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QCocoaIntegrationPlugin)],[-lqcocoa])\n+        AC_DEFINE(QT_QPA_PLATFORM_COCOA, 1, [Define this symbol if the qt platform is cocoa])\n+      fi\n+    fi\n+  else\n+    if test x$TARGET_OS == xwindows; then\n+      AC_DEFINE(QT_STATICPLUGIN, 1, [Define this symbol if qt plugins are static])\n+      _BITCOIN_QT_CHECK_STATIC_PLUGINS([\n+         Q_IMPORT_PLUGIN(qcncodecs)\n+         Q_IMPORT_PLUGIN(qjpcodecs)\n+         Q_IMPORT_PLUGIN(qtwcodecs)\n+         Q_IMPORT_PLUGIN(qkrcodecs)\n+         Q_IMPORT_PLUGIN(AccessibleFactory)],\n+         [-lqcncodecs -lqjpcodecs -lqtwcodecs -lqkrcodecs -lqtaccessiblewidgets])\n+    fi\n+  fi\n+  CPPFLAGS=$TEMP_CPPFLAGS\n+  ])\n   BITCOIN_QT_PATH_PROGS([MOC], [moc-qt${bitcoin_qt_got_major_vers} moc${bitcoin_qt_got_major_vers} moc], $qt_bin_path)\n   BITCOIN_QT_PATH_PROGS([UIC], [uic-qt${bitcoin_qt_got_major_vers} uic${bitcoin_qt_got_major_vers} uic], $qt_bin_path)\n   BITCOIN_QT_PATH_PROGS([RCC], [rcc-qt${bitcoin_qt_got_major_vers} rcc${bitcoin_qt_got_major_vers} rcc], $qt_bin_path)\n@@ -303,26 +357,15 @@ AC_DEFUN([_BITCOIN_QT_FIND_LIBS_WITHOUT_PKGCONFIG],[\n   ])\n \n   BITCOIN_QT_CHECK([\n-    LIBS=\n-    if test x$qt_lib_path != x; then\n-      LIBS=\"$LIBS -L$qt_lib_path\"\n-    fi\n-    if test x$qt_plugin_path != x; then\n-      LIBS=\"$LIBS -L$qt_plugin_path/accessible\"\n-      if test x$bitcoin_qt_got_major_vers == x5; then\n-        LIBS=\"$LIBS -L$qt_plugin_path/platforms\"\n-      else\n-        LIBS=\"$LIBS -L$qt_plugin_path/codecs\"\n-      fi\n-    fi\n-\n     if test x$TARGET_OS == xwindows; then\n       AC_CHECK_LIB([imm32],      [main],, BITCOIN_QT_FAIL(libimm32 not found))\n     fi\n   ])\n \n-  BITCOIN_QT_CHECK(AC_CHECK_LIB([z] ,[main],,BITCOIN_QT_FAIL(zlib not found)))\n-  BITCOIN_QT_CHECK(AC_CHECK_LIB([png] ,[main],,BITCOIN_QT_FAIL(png not found)))\n+  BITCOIN_QT_CHECK(AC_CHECK_LIB([z] ,[main],,AC_MSG_WARN([zlib not found. Assuming qt has it built-in])))\n+  BITCOIN_QT_CHECK(AC_CHECK_LIB([png] ,[main],,AC_MSG_WARN([libpng not found. Assuming qt has it built-in])))\n+  BITCOIN_QT_CHECK(AC_CHECK_LIB([jpeg] ,[main],,AC_MSG_WARN([libjpeg not found. Assuming qt has it built-in])))\n+  BITCOIN_QT_CHECK(AC_CHECK_LIB([pcre] ,[main],,AC_MSG_WARN([libpcre not found. Assuming qt has it built-in])))\n   BITCOIN_QT_CHECK(AC_CHECK_LIB([${QT_LIB_PREFIX}Core]   ,[main],,BITCOIN_QT_FAIL(lib$QT_LIB_PREFIXCore not found)))\n   BITCOIN_QT_CHECK(AC_CHECK_LIB([${QT_LIB_PREFIX}Gui]    ,[main],,BITCOIN_QT_FAIL(lib$QT_LIB_PREFIXGui not found)))\n   BITCOIN_QT_CHECK(AC_CHECK_LIB([${QT_LIB_PREFIX}Network],[main],,BITCOIN_QT_FAIL(lib$QT_LIB_PREFIXNetwork not found)))\n@@ -332,37 +375,6 @@ AC_DEFUN([_BITCOIN_QT_FIND_LIBS_WITHOUT_PKGCONFIG],[\n   QT_LIBS=\"$LIBS\"\n   LIBS=\"$TEMP_LIBS\"\n \n-  dnl This is ugly and complicated. Yuck. Works as follows:\n-  dnl We can't discern whether Qt4 builds are static or not. For Qt5, we can\n-  dnl check a header to find out. When Qt is built statically, some plugins must\n-  dnl be linked into the final binary as well. These plugins have changed between\n-  dnl Qt4 and Qt5. With Qt5, languages moved into core and the WindowsIntegration\n-  dnl plugin was added. Since we can't tell if Qt4 is static or not, it is \n-  dnl assumed for all non-pkg-config builds.\n-  dnl _BITCOIN_QT_CHECK_STATIC_PLUGINS does a quick link-check and appends the\n-  dnl results to QT_LIBS.\n-  BITCOIN_QT_CHECK([\n-    if test x$bitcoin_qt_got_major_vers == x5; then\n-      _BITCOIN_QT_IS_STATIC\n-      if test x$bitcoin_cv_static_qt == xyes; then \n-        AC_DEFINE(QT_STATICPLUGIN, 1, [Define this symbol if qt plugins are static])\n-        _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(AccessibleFactory)], [-lqtaccessiblewidgets])\n-        if test x$TARGET_OS == xwindows; then\n-          _BITCOIN_QT_CHECK_STATIC_PLUGINS([Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin)],[-lqwindows])\n-        fi\n-      fi\n-    else\n-      AC_DEFINE(QT_STATICPLUGIN, 1, [Define this symbol if qt plugins are static])\n-      _BITCOIN_QT_CHECK_STATIC_PLUGINS([\n-         Q_IMPORT_PLUGIN(qcncodecs)\n-         Q_IMPORT_PLUGIN(qjpcodecs)\n-         Q_IMPORT_PLUGIN(qtwcodecs)\n-         Q_IMPORT_PLUGIN(qkrcodecs)\n-         Q_IMPORT_PLUGIN(AccessibleFactory)],\n-         [-lqcncodecs -lqjpcodecs -lqtwcodecs -lqkrcodecs -lqtaccessiblewidgets])\n-    fi\n-  ])\n-\n   BITCOIN_QT_CHECK([\n     LIBS=\n     if test x$qt_lib_path != x; then"
      },
      {
        "sha": "06ce15b5b3da96d51dcb0be8f65aeabfe61cd108",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 272,
        "deletions": 247,
        "changes": 519,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -12,6 +12,7 @@\n #include \"checkqueue.h\"\n #include \"init.h\"\n #include \"net.h\"\n+#include \"pow.h\"\n #include \"txdb.h\"\n #include \"txmempool.h\"\n #include \"ui_interface.h\"\n@@ -36,22 +37,23 @@ using namespace boost;\n \n CCriticalSection cs_main;\n \n-CTxMemPool mempool;\n-\n map<uint256, CBlockIndex*> mapBlockIndex;\n CChain chainActive;\n int64_t nTimeBestReceived = 0;\n+CWaitableCriticalSection csBestBlock;\n+CConditionVariable cvBlockChange;\n int nScriptCheckThreads = 0;\n bool fImporting = false;\n bool fReindex = false;\n bool fBenchmark = false;\n bool fTxIndex = false;\n+bool fIsBareMultisigStd = true;\n unsigned int nCoinCacheSize = 5000;\n \n-/** Fees smaller than this (in satoshi) are considered zero fee (for transaction creation) */\n-CFeeRate CTransaction::minTxFee = CFeeRate(10000);  // Override with -mintxfee\n /** Fees smaller than this (in satoshi) are considered zero fee (for relaying and mining) */\n-CFeeRate CTransaction::minRelayTxFee = CFeeRate(1000);\n+CFeeRate minRelayTxFee = CFeeRate(1000);\n+\n+CTxMemPool mempool(::minRelayTxFee);\n \n struct COrphanBlock {\n     uint256 hashBlock;\n@@ -71,6 +73,7 @@ const string strMessageMagic = \"Bitcoin Signed Message:\\n\";\n \n // Internal stuff\n namespace {\n+\n     struct CBlockIndexWorkComparator\n     {\n         bool operator()(CBlockIndex *pa, CBlockIndex *pb) {\n@@ -119,7 +122,8 @@ namespace {\n     };\n     map<uint256, pair<NodeId, list<QueuedBlock>::iterator> > mapBlocksInFlight;\n     map<uint256, pair<NodeId, list<uint256>::iterator> > mapBlocksToDownload;\n-}\n+\n+} // anon namespace\n \n //////////////////////////////////////////////////////////////////////////////\n //\n@@ -129,9 +133,10 @@ namespace {\n // These functions dispatch to one or all registered wallets\n \n namespace {\n+\n struct CMainSignals {\n-    // Notifies listeners of updated transaction data (passing hash, transaction, and optionally the block it is found in.\n-    boost::signals2::signal<void (const uint256 &, const CTransaction &, const CBlock *)> SyncTransaction;\n+    // Notifies listeners of updated transaction data (transaction, and optionally the block it is found in.\n+    boost::signals2::signal<void (const CTransaction &, const CBlock *)> SyncTransaction;\n     // Notifies listeners of an erased transaction (currently disabled, requires transaction replacement).\n     boost::signals2::signal<void (const uint256 &)> EraseTransaction;\n     // Notifies listeners of an updated transaction without new data (for now: a coinbase potentially becoming visible).\n@@ -143,10 +148,11 @@ struct CMainSignals {\n     // Tells listeners to broadcast their data.\n     boost::signals2::signal<void ()> Broadcast;\n } g_signals;\n-}\n+\n+} // anon namespace\n \n void RegisterWallet(CWalletInterface* pwalletIn) {\n-    g_signals.SyncTransaction.connect(boost::bind(&CWalletInterface::SyncTransaction, pwalletIn, _1, _2, _3));\n+    g_signals.SyncTransaction.connect(boost::bind(&CWalletInterface::SyncTransaction, pwalletIn, _1, _2));\n     g_signals.EraseTransaction.connect(boost::bind(&CWalletInterface::EraseFromWallet, pwalletIn, _1));\n     g_signals.UpdatedTransaction.connect(boost::bind(&CWalletInterface::UpdatedTransaction, pwalletIn, _1));\n     g_signals.SetBestChain.connect(boost::bind(&CWalletInterface::SetBestChain, pwalletIn, _1));\n@@ -160,7 +166,7 @@ void UnregisterWallet(CWalletInterface* pwalletIn) {\n     g_signals.SetBestChain.disconnect(boost::bind(&CWalletInterface::SetBestChain, pwalletIn, _1));\n     g_signals.UpdatedTransaction.disconnect(boost::bind(&CWalletInterface::UpdatedTransaction, pwalletIn, _1));\n     g_signals.EraseTransaction.disconnect(boost::bind(&CWalletInterface::EraseFromWallet, pwalletIn, _1));\n-    g_signals.SyncTransaction.disconnect(boost::bind(&CWalletInterface::SyncTransaction, pwalletIn, _1, _2, _3));\n+    g_signals.SyncTransaction.disconnect(boost::bind(&CWalletInterface::SyncTransaction, pwalletIn, _1, _2));\n }\n \n void UnregisterAllWallets() {\n@@ -172,8 +178,8 @@ void UnregisterAllWallets() {\n     g_signals.SyncTransaction.disconnect_all_slots();\n }\n \n-void SyncWithWallets(const uint256 &hash, const CTransaction &tx, const CBlock *pblock) {\n-    g_signals.SyncTransaction(hash, tx, pblock);\n+void SyncWithWallets(const CTransaction &tx, const CBlock *pblock) {\n+    g_signals.SyncTransaction(tx, pblock);\n }\n \n //////////////////////////////////////////////////////////////////////////////\n@@ -196,12 +202,16 @@ struct CBlockReject {\n struct CNodeState {\n     // Accumulated misbehaviour score for this peer.\n     int nMisbehavior;\n-    // Whether this peer should be disconnected and banned.\n+    // Whether this peer should be disconnected and banned (unless whitelisted).\n     bool fShouldBan;\n     // String name of this peer (debugging/logging purposes).\n     std::string name;\n     // List of asynchronously-determined block rejections to notify this peer about.\n     std::vector<CBlockReject> rejects;\n+    // The best known block we know this peer has announced.\n+    CBlockIndex *pindexBestKnownBlock;\n+    // The hash of the last unknown block this peer has announced.\n+    uint256 hashLastUnknownBlock;\n     list<QueuedBlock> vBlocksInFlight;\n     int nBlocksInFlight;\n     list<uint256> vBlocksToDownload;\n@@ -212,6 +222,8 @@ struct CNodeState {\n     CNodeState() {\n         nMisbehavior = 0;\n         fShouldBan = false;\n+        pindexBestKnownBlock = NULL;\n+        hashLastUnknownBlock = uint256(0);\n         nBlocksToDownload = 0;\n         nBlocksInFlight = 0;\n         nLastBlockReceive = 0;\n@@ -273,7 +285,6 @@ void MarkBlockAsReceived(const uint256 &hash, NodeId nodeFrom = -1) {\n             state->nLastBlockReceive = GetTimeMicros();\n         mapBlocksInFlight.erase(itInFlight);\n     }\n-\n }\n \n // Requires cs_main.\n@@ -309,14 +320,48 @@ void MarkBlockAsInFlight(NodeId nodeid, const uint256 &hash) {\n     mapBlocksInFlight[hash] = std::make_pair(nodeid, it);\n }\n \n+/** Check whether the last unknown block a peer advertized is not yet known. */\n+void ProcessBlockAvailability(NodeId nodeid) {\n+    CNodeState *state = State(nodeid);\n+    assert(state != NULL);\n+\n+    if (state->hashLastUnknownBlock != 0) {\n+        map<uint256, CBlockIndex*>::iterator itOld = mapBlockIndex.find(state->hashLastUnknownBlock);\n+        if (itOld != mapBlockIndex.end() && itOld->second->nChainWork > 0) {\n+            if (state->pindexBestKnownBlock == NULL || itOld->second->nChainWork >= state->pindexBestKnownBlock->nChainWork)\n+                state->pindexBestKnownBlock = itOld->second;\n+            state->hashLastUnknownBlock = uint256(0);\n+        }\n+    }\n+}\n+\n+/** Update tracking information about which blocks a peer is assumed to have. */\n+void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) {\n+    CNodeState *state = State(nodeid);\n+    assert(state != NULL);\n+\n+    ProcessBlockAvailability(nodeid);\n+\n+    map<uint256, CBlockIndex*>::iterator it = mapBlockIndex.find(hash);\n+    if (it != mapBlockIndex.end() && it->second->nChainWork > 0) {\n+        // An actually better block was announced.\n+        if (state->pindexBestKnownBlock == NULL || it->second->nChainWork >= state->pindexBestKnownBlock->nChainWork)\n+            state->pindexBestKnownBlock = it->second;\n+    } else {\n+        // An unknown block was announced; just assume that the latest one is the best one.\n+        state->hashLastUnknownBlock = hash;\n+    }\n }\n \n+} // anon namespace\n+\n bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     LOCK(cs_main);\n     CNodeState *state = State(nodeid);\n     if (state == NULL)\n         return false;\n     stats.nMisbehavior = state->nMisbehavior;\n+    stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n     return true;\n }\n \n@@ -370,12 +415,13 @@ CBlockLocator CChain::GetLocator(const CBlockIndex *pindex) const {\n             break;\n         // Exponentially larger steps back, plus the genesis block.\n         int nHeight = std::max(pindex->nHeight - nStep, 0);\n-        // In case pindex is not in this chain, iterate pindex->pprev to find blocks.\n-        while (pindex->nHeight > nHeight && !Contains(pindex))\n-            pindex = pindex->pprev;\n-        // If pindex is in this chain, use direct height-based access.\n-        if (pindex->nHeight > nHeight)\n+        if (Contains(pindex)) {\n+            // Use O(1) CChain index if possible.\n             pindex = (*this)[nHeight];\n+        } else {\n+            // Otherwise, use O(log n) skiplist.\n+            pindex = pindex->GetAncestor(nHeight);\n+        }\n         if (vHave.size() > 10)\n             nStep *= 2;\n     }\n@@ -398,6 +444,8 @@ CBlockIndex *CChain::FindFork(const CBlockLocator &locator) const {\n }\n \n CBlockIndex *CChain::FindFork(CBlockIndex *pindex) const {\n+    if (pindex->nHeight > Height())\n+        pindex = pindex->GetAncestor(Height());\n     while (pindex && !Contains(pindex))\n         pindex = pindex->pprev;\n     return pindex;\n@@ -487,7 +535,7 @@ bool IsStandardTx(const CTransaction& tx, string& reason)\n     // Treat non-final transactions as non-standard to prevent a specific type\n     // of double-spend attack, as well as DoS attacks. (if the transaction\n     // can't be mined, the attacker isn't expending resources broadcasting it)\n-    // Basically we don't want to propagate transactions that can't included in\n+    // Basically we don't want to propagate transactions that can't be included in\n     // the next block.\n     //\n     // However, IsFinalTx() is confusing... Without arguments, it uses\n@@ -520,7 +568,7 @@ bool IsStandardTx(const CTransaction& tx, string& reason)\n     {\n         // Biggest 'standard' txin is a 15-of-15 P2SH multisig with compressed\n         // keys. (remember the 520 byte limit on redeemScript size) That works\n-        // out to a (15*(33+1))+3=513 byte redeemScript, 513+1+15*(73+1)=1624\n+        // out to a (15*(33+1))+3=513 byte redeemScript, 513+1+15*(73+1)+3=1627\n         // bytes of scriptSig, which we round off to 1650 bytes for some minor\n         // future-proofing. That's also enough to spend a 20-of-20\n         // CHECKMULTISIG scriptPubKey, though such a scriptPubKey is not\n@@ -546,9 +594,13 @@ bool IsStandardTx(const CTransaction& tx, string& reason)\n             reason = \"scriptpubkey\";\n             return false;\n         }\n+\n         if (whichType == TX_NULL_DATA)\n             nDataOut++;\n-        else if (txout.IsDust(CTransaction::minRelayTxFee)) {\n+        else if ((whichType == TX_MULTISIG) && (!fIsBareMultisigStd)) {\n+            reason = \"bare-multisig\";\n+            return false;\n+        } else if (txout.IsDust(::minRelayTxFee)) {\n             reason = \"dust\";\n             return false;\n         }\n@@ -582,15 +634,13 @@ bool IsFinalTx(const CTransaction &tx, int nBlockHeight, int64_t nBlockTime)\n }\n \n //\n-// Check transaction inputs, and make sure any\n-// pay-to-script-hash transactions are evaluating IsStandard scripts\n+// Check transaction inputs to mitigate two\n+// potential denial-of-service attacks:\n //\n-// Why bother? To avoid denial-of-service attacks; an attacker\n-// can submit a standard HASH... OP_EQUAL transaction,\n-// which will get accepted into blocks. The redemption\n-// script can be anything; an attacker could use a very\n-// expensive-to-check-upon-redemption script like:\n-//   DUP CHECKSIG DROP ... repeated 100 times... OP_1\n+// 1. scriptSigs with extra data stuffed into them,\n+//    not consumed by scriptPubKey (or P2SH script)\n+// 2. P2SH scripts with a crazy number of expensive\n+//    CHECKSIG/CHECKMULTISIG operations\n //\n bool AreInputsStandard(const CTransaction& tx, CCoinsViewCache& mapInputs)\n {\n@@ -614,8 +664,9 @@ bool AreInputsStandard(const CTransaction& tx, CCoinsViewCache& mapInputs)\n         // Transactions with extra stuff in their scriptSigs are\n         // non-standard. Note that this EvalScript() call will\n         // be quick, because if there are any operations\n-        // beside \"push data\" in the scriptSig the\n-        // IsStandard() call returns false\n+        // beside \"push data\" in the scriptSig\n+        // IsStandard() will have already returned false\n+        // and this method isn't called.\n         vector<vector<unsigned char> > stack;\n         if (!EvalScript(stack, tx.vin[i].scriptSig, tx, i, false, 0))\n             return false;\n@@ -627,16 +678,20 @@ bool AreInputsStandard(const CTransaction& tx, CCoinsViewCache& mapInputs)\n             CScript subscript(stack.back().begin(), stack.back().end());\n             vector<vector<unsigned char> > vSolutions2;\n             txnouttype whichType2;\n-            if (!Solver(subscript, whichType2, vSolutions2))\n-                return false;\n-            if (whichType2 == TX_SCRIPTHASH)\n-                return false;\n-\n-            int tmpExpected;\n-            tmpExpected = ScriptSigArgsExpected(whichType2, vSolutions2);\n-            if (tmpExpected < 0)\n-                return false;\n-            nArgsExpected += tmpExpected;\n+            if (Solver(subscript, whichType2, vSolutions2))\n+            {\n+                int tmpExpected = ScriptSigArgsExpected(whichType2, vSolutions2);\n+                if (tmpExpected < 0)\n+                    return false;\n+                nArgsExpected += tmpExpected;\n+            }\n+            else\n+            {\n+                // Any other Script with less than 15 sigops OK:\n+                unsigned int sigops = subscript.GetSigOpCount(true);\n+                // ... extra data left on the stack after execution is OK, too:\n+                return (sigops <= MAX_P2SH_SIGOPS);\n+            }\n         }\n \n         if (stack.size() != (unsigned int)nArgsExpected)\n@@ -786,22 +841,27 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state)\n     return true;\n }\n \n-int64_t GetMinFee(const CTransaction& tx, unsigned int nBytes, bool fAllowFree, enum GetMinFee_mode mode)\n+int64_t GetMinRelayFee(const CTransaction& tx, unsigned int nBytes, bool fAllowFree)\n {\n-    // Base fee is either minTxFee or minRelayTxFee\n-    CFeeRate baseFeeRate = (mode == GMF_RELAY) ? tx.minRelayTxFee : tx.minTxFee;\n+    {\n+        LOCK(mempool.cs);\n+        uint256 hash = tx.GetHash();\n+        double dPriorityDelta = 0;\n+        int64_t nFeeDelta = 0;\n+        mempool.ApplyDeltas(hash, dPriorityDelta, nFeeDelta);\n+        if (dPriorityDelta > 0 || nFeeDelta > 0)\n+            return 0;\n+    }\n \n-    int64_t nMinFee = baseFeeRate.GetFee(nBytes);\n+    int64_t nMinFee = ::minRelayTxFee.GetFee(nBytes);\n \n     if (fAllowFree)\n     {\n         // There is a free transaction area in blocks created by most miners,\n         // * If we are relaying we allow transactions up to DEFAULT_BLOCK_PRIORITY_SIZE - 1000\n         //   to be considered to fall into this category. We don't want to encourage sending\n         //   multiple transactions instead of one big transaction to avoid fees.\n-        // * If we are creating a transaction we allow transactions up to 1,000 bytes\n-        //   to be considered safe and assume they can likely make it into this section.\n-        if (nBytes < (mode == GMF_SEND ? 1000 : (DEFAULT_BLOCK_PRIORITY_SIZE - 1000)))\n+        if (nBytes < (DEFAULT_BLOCK_PRIORITY_SIZE - 1000))\n             nMinFee = 0;\n     }\n \n@@ -907,7 +967,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         unsigned int nSize = entry.GetTxSize();\n \n         // Don't accept it if it can't get into a block\n-        int64_t txMinFee = GetMinFee(tx, nSize, true, GMF_RELAY);\n+        int64_t txMinFee = GetMinRelayFee(tx, nSize, true);\n         if (fLimitFree && nFees < txMinFee)\n             return state.DoS(0, error(\"AcceptToMemoryPool : not enough fees %s, %d < %d\",\n                                       hash.ToString(), nFees, txMinFee),\n@@ -916,7 +976,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         // Continuously rate-limit free (really, very-low-fee)transactions\n         // This mitigates 'penny-flooding' -- sending thousands of free transactions just to\n         // be annoying or make others' transactions take longer to confirm.\n-        if (fLimitFree && nFees < CTransaction::minRelayTxFee.GetFee(nSize))\n+        if (fLimitFree && nFees < ::minRelayTxFee.GetFee(nSize))\n         {\n             static CCriticalSection csFreeLimiter;\n             static double dFreeCount;\n@@ -937,10 +997,10 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n             dFreeCount += nSize;\n         }\n \n-        if (fRejectInsaneFee && nFees > CTransaction::minRelayTxFee.GetFee(nSize) * 10000)\n+        if (fRejectInsaneFee && nFees > ::minRelayTxFee.GetFee(nSize) * 10000)\n             return error(\"AcceptToMemoryPool: : insane fees %s, %d > %d\",\n                          hash.ToString(),\n-                         nFees, CTransaction::minRelayTxFee.GetFee(nSize) * 10000);\n+                         nFees, ::minRelayTxFee.GetFee(nSize) * 10000);\n \n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n@@ -952,7 +1012,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         pool.addUnchecked(hash, entry);\n     }\n \n-    g_signals.SyncTransaction(hash, tx, NULL);\n+    g_signals.SyncTransaction(tx, NULL);\n \n     return true;\n }\n@@ -1002,10 +1062,10 @@ int CMerkleTx::GetBlocksToMaturity() const\n }\n \n \n-bool CMerkleTx::AcceptToMemoryPool(bool fLimitFree)\n+bool CMerkleTx::AcceptToMemoryPool(bool fLimitFree, bool fRejectInsaneFee)\n {\n     CValidationState state;\n-    return ::AcceptToMemoryPool(mempool, state, *this, fLimitFree, NULL);\n+    return ::AcceptToMemoryPool(mempool, state, *this, fLimitFree, NULL, fRejectInsaneFee);\n }\n \n \n@@ -1194,118 +1254,6 @@ int64_t GetBlockValue(int nHeight, int64_t nFees)\n     return nSubsidy + nFees;\n }\n \n-static const int64_t nTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n-static const int64_t nTargetSpacing = 10 * 60;\n-static const int64_t nInterval = nTargetTimespan / nTargetSpacing;\n-\n-//\n-// minimum amount of work that could possibly be required nTime after\n-// minimum work required was nBase\n-//\n-unsigned int ComputeMinWork(unsigned int nBase, int64_t nTime)\n-{\n-    const uint256 &bnLimit = Params().ProofOfWorkLimit();\n-    // Testnet has min-difficulty blocks\n-    // after nTargetSpacing*2 time between blocks:\n-    if (Params().AllowMinDifficultyBlocks() && nTime > nTargetSpacing*2)\n-        return bnLimit.GetCompact();\n-\n-    uint256 bnResult;\n-    bnResult.SetCompact(nBase);\n-    while (nTime > 0 && bnResult < bnLimit)\n-    {\n-        // Maximum 400% adjustment...\n-        bnResult *= 4;\n-        // ... in best-case exactly 4-times-normal target time\n-        nTime -= nTargetTimespan*4;\n-    }\n-    if (bnResult > bnLimit)\n-        bnResult = bnLimit;\n-    return bnResult.GetCompact();\n-}\n-\n-unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock)\n-{\n-    unsigned int nProofOfWorkLimit = Params().ProofOfWorkLimit().GetCompact();\n-\n-    // Genesis block\n-    if (pindexLast == NULL)\n-        return nProofOfWorkLimit;\n-\n-    // Only change once per interval\n-    if ((pindexLast->nHeight+1) % nInterval != 0)\n-    {\n-        if (Params().AllowMinDifficultyBlocks())\n-        {\n-            // Special difficulty rule for testnet:\n-            // If the new block's timestamp is more than 2* 10 minutes\n-            // then allow mining of a min-difficulty block.\n-            if (pblock->nTime > pindexLast->nTime + nTargetSpacing*2)\n-                return nProofOfWorkLimit;\n-            else\n-            {\n-                // Return the last non-special-min-difficulty-rules-block\n-                const CBlockIndex* pindex = pindexLast;\n-                while (pindex->pprev && pindex->nHeight % nInterval != 0 && pindex->nBits == nProofOfWorkLimit)\n-                    pindex = pindex->pprev;\n-                return pindex->nBits;\n-            }\n-        }\n-        return pindexLast->nBits;\n-    }\n-\n-    // Go back by what we want to be 14 days worth of blocks\n-    const CBlockIndex* pindexFirst = pindexLast;\n-    for (int i = 0; pindexFirst && i < nInterval-1; i++)\n-        pindexFirst = pindexFirst->pprev;\n-    assert(pindexFirst);\n-\n-    // Limit adjustment step\n-    int64_t nActualTimespan = pindexLast->GetBlockTime() - pindexFirst->GetBlockTime();\n-    LogPrintf(\"  nActualTimespan = %d  before bounds\\n\", nActualTimespan);\n-    if (nActualTimespan < nTargetTimespan/4)\n-        nActualTimespan = nTargetTimespan/4;\n-    if (nActualTimespan > nTargetTimespan*4)\n-        nActualTimespan = nTargetTimespan*4;\n-\n-    // Retarget\n-    uint256 bnNew;\n-    uint256 bnOld;\n-    bnNew.SetCompact(pindexLast->nBits);\n-    bnOld = bnNew;\n-    bnNew *= nActualTimespan;\n-    bnNew /= nTargetTimespan;\n-\n-    if (bnNew > Params().ProofOfWorkLimit())\n-        bnNew = Params().ProofOfWorkLimit();\n-\n-    /// debug print\n-    LogPrintf(\"GetNextWorkRequired RETARGET\\n\");\n-    LogPrintf(\"nTargetTimespan = %d    nActualTimespan = %d\\n\", nTargetTimespan, nActualTimespan);\n-    LogPrintf(\"Before: %08x  %s\\n\", pindexLast->nBits, bnOld.ToString());\n-    LogPrintf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.ToString());\n-\n-    return bnNew.GetCompact();\n-}\n-\n-bool CheckProofOfWork(uint256 hash, unsigned int nBits)\n-{\n-    bool fNegative;\n-    bool fOverflow;\n-    uint256 bnTarget;\n-    bnTarget.SetCompact(nBits, &fNegative, &fOverflow);\n-\n-    // Check range\n-    if (fNegative || bnTarget == 0 || fOverflow || bnTarget > Params().ProofOfWorkLimit())\n-        return error(\"CheckProofOfWork() : nBits below minimum work\");\n-\n-    // Check proof of work matches claimed amount\n-    if (hash > bnTarget)\n-        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n-\n-    return true;\n-}\n-\n bool IsInitialBlockDownload()\n {\n     LOCK(cs_main);\n@@ -1416,7 +1364,8 @@ void Misbehaving(NodeId pnode, int howmuch)\n         return;\n \n     state->nMisbehavior += howmuch;\n-    if (state->nMisbehavior >= GetArg(\"-banscore\", 100))\n+    int banscore = GetArg(\"-banscore\", 100);\n+    if (state->nMisbehavior >= banscore && state->nMisbehavior - howmuch < banscore)\n     {\n         LogPrintf(\"Misbehaving: %s (%d -> %d) BAN THRESHOLD EXCEEDED\\n\", state->name, state->nMisbehavior-howmuch, state->nMisbehavior);\n         state->fShouldBan = true;\n@@ -1479,7 +1428,7 @@ void UpdateTime(CBlockHeader& block, const CBlockIndex* pindexPrev)\n \n \n \n-void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCache &inputs, CTxUndo &txundo, int nHeight, const uint256 &txhash)\n+void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCache &inputs, CTxUndo &txundo, int nHeight)\n {\n     bool ret;\n     // mark inputs spent\n@@ -1494,7 +1443,7 @@ void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCach\n     }\n \n     // add outputs\n-    ret = inputs.SetCoins(txhash, CCoins(tx, nHeight));\n+    ret = inputs.SetCoins(tx.GetHash(), CCoins(tx, nHeight));\n     assert(ret);\n }\n \n@@ -1767,8 +1716,8 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n                           !((pindex->nHeight==91842 && pindex->GetBlockHash() == uint256(\"0x00000000000a4d0a398161ffc163c503763b1f4360639393e0e4c8e300e0caec\")) ||\n                            (pindex->nHeight==91880 && pindex->GetBlockHash() == uint256(\"0x00000000000743f190a18c5577a3c2d2a1f610ae9601ac046a38084ccb7cd721\")));\n     if (fEnforceBIP30) {\n-        for (unsigned int i = 0; i < block.vtx.size(); i++) {\n-            uint256 hash = block.GetTxHash(i);\n+        BOOST_FOREACH(const CTransaction& tx, block.vtx) {\n+            const uint256& hash = tx.GetHash();\n             if (view.HaveCoins(hash) && !view.GetCoins(hash).IsPruned())\n                 return state.DoS(100, error(\"ConnectBlock() : tried to overwrite transaction\"),\n                                  REJECT_INVALID, \"bad-txns-BIP30\");\n@@ -1777,7 +1726,7 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n \n     // BIP16 didn't become active until Apr 1 2012\n     int64_t nBIP16SwitchTime = 1333238400;\n-    bool fStrictPayToScriptHash = (pindex->nTime >= nBIP16SwitchTime);\n+    bool fStrictPayToScriptHash = (pindex->GetBlockTime() >= nBIP16SwitchTime);\n \n     unsigned int flags = SCRIPT_VERIFY_NOCACHE |\n                          (fStrictPayToScriptHash ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE);\n@@ -1829,11 +1778,11 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n         }\n \n         CTxUndo txundo;\n-        UpdateCoins(tx, state, view, txundo, pindex->nHeight, block.GetTxHash(i));\n+        UpdateCoins(tx, state, view, txundo, pindex->nHeight);\n         if (!tx.IsCoinBase())\n             blockundo.vtxundo.push_back(txundo);\n \n-        vPos.push_back(std::make_pair(block.GetTxHash(i), pos));\n+        vPos.push_back(std::make_pair(tx.GetHash(), pos));\n         pos.nTxOffset += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n     }\n     int64_t nTime = GetTimeMicros() - nStart;\n@@ -1892,21 +1841,21 @@ bool ConnectBlock(CBlock& block, CValidationState& state, CBlockIndex* pindex, C\n     assert(ret);\n \n     // Watch for transactions paying to me\n-    for (unsigned int i = 0; i < block.vtx.size(); i++)\n-        g_signals.SyncTransaction(block.GetTxHash(i), block.vtx[i], &block);\n+    BOOST_FOREACH(const CTransaction& tx, block.vtx)\n+        g_signals.SyncTransaction(tx, &block);\n \n     // Watch for changes to the previous coinbase transaction.\n     static uint256 hashPrevBestCoinBase;\n     g_signals.UpdatedTransaction(hashPrevBestCoinBase);\n-    hashPrevBestCoinBase = block.GetTxHash(0);\n+    hashPrevBestCoinBase = block.vtx[0].GetHash();\n \n     return true;\n }\n \n // Update the on-disk chain state.\n bool static WriteChainState(CValidationState &state) {\n     static int64_t nLastWrite = 0;\n-    if (!IsInitialBlockDownload() || pcoinsTip->GetCacheSize() > nCoinCacheSize || GetTimeMicros() > nLastWrite + 600*1000000) {\n+    if (pcoinsTip->GetCacheSize() > nCoinCacheSize || (!IsInitialBlockDownload() && GetTimeMicros() > nLastWrite + 600*1000000)) {\n         // Typical CCoins structures on disk are around 100 bytes in size.\n         // Pushing a new one to the database can cause it to be written\n         // twice (once in the log, and once in the tables). This is already\n@@ -1935,11 +1884,14 @@ void static UpdateTip(CBlockIndex *pindexNew) {\n     // New best block\n     nTimeBestReceived = GetTime();\n     mempool.AddTransactionsUpdated(1);\n+\n     LogPrintf(\"UpdateTip: new best=%s  height=%d  log2_work=%.8g  tx=%lu  date=%s progress=%f\\n\",\n       chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(), log(chainActive.Tip()->nChainWork.getdouble())/log(2.0), (unsigned long)chainActive.Tip()->nChainTx,\n       DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),\n       Checkpoints::GuessVerificationProgress(chainActive.Tip()));\n \n+    cvBlockChange.notify_all();\n+\n     // Check the version of the last 100 blocks to see if we need to upgrade:\n     if (!fIsInitialDownload)\n     {\n@@ -1996,7 +1948,7 @@ bool static DisconnectTip(CValidationState &state) {\n     // Let wallets know transactions went from 1-confirmed to\n     // 0-confirmed or conflicted:\n     BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n-        SyncWithWallets(tx.GetHash(), tx, NULL);\n+        SyncWithWallets(tx, NULL);\n     }\n     return true;\n }\n@@ -2036,11 +1988,11 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew) {\n     // Tell wallet about transactions that went from mempool\n     // to conflicted:\n     BOOST_FOREACH(const CTransaction &tx, txConflicted) {\n-        SyncWithWallets(tx.GetHash(), tx, NULL);\n+        SyncWithWallets(tx, NULL);\n     }\n     // ... and about transactions that got confirmed:\n     BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n-        SyncWithWallets(tx.GetHash(), tx, &block);\n+        SyncWithWallets(tx, &block);\n     }\n     return true;\n }\n@@ -2064,7 +2016,7 @@ static CBlockIndex* FindMostWorkChain() {\n         CBlockIndex *pindexTest = pindexNew;\n         bool fInvalidAncestor = false;\n         while (pindexTest && !chainActive.Contains(pindexTest)) {\n-            if (!pindexTest->IsValid(BLOCK_VALID_TRANSACTIONS) || !(pindexTest->nStatus & BLOCK_HAVE_DATA)) {\n+            if (pindexTest->nStatus & BLOCK_FAILED_MASK) {\n                 // Candidate has an invalid ancestor, remove entire chain from the set.\n                 if (pindexBestInvalid == NULL || pindexNew->nChainWork > pindexBestInvalid->nChainWork)\n                     pindexBestInvalid = pindexNew;\n@@ -2074,6 +2026,7 @@ static CBlockIndex* FindMostWorkChain() {\n                     setBlockIndexValid.erase(pindexFailed);\n                     pindexFailed = pindexFailed->pprev;\n                 }\n+                setBlockIndexValid.erase(pindexTest);\n                 fInvalidAncestor = true;\n                 break;\n             }\n@@ -2206,6 +2159,7 @@ CBlockIndex* AddToBlockIndex(CBlockHeader& block)\n     {\n         pindexNew->pprev = (*miPrev).second;\n         pindexNew->nHeight = pindexNew->pprev->nHeight + 1;\n+        pindexNew->BuildSkip();\n     }\n     pindexNew->nChainWork = (pindexNew->pprev ? pindexNew->pprev->nChainWork : 0) + pindexNew->GetBlockWork();\n     pindexNew->RaiseValidity(BLOCK_VALID_TREE);\n@@ -2351,28 +2305,6 @@ bool CheckBlockHeader(const CBlockHeader& block, CValidationState& state, bool f\n         return state.Invalid(error(\"CheckBlockHeader() : block timestamp too far in the future\"),\n                              REJECT_INVALID, \"time-too-new\");\n \n-    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n-    if (pcheckpoint && block.hashPrevBlock != (chainActive.Tip() ? chainActive.Tip()->GetBlockHash() : uint256(0)))\n-    {\n-        // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n-        int64_t deltaTime = block.GetBlockTime() - pcheckpoint->nTime;\n-        if (deltaTime < 0)\n-        {\n-            return state.DoS(100, error(\"CheckBlockHeader() : block with timestamp before last checkpoint\"),\n-                             REJECT_CHECKPOINT, \"time-too-old\");\n-        }\n-        bool fOverflow = false;\n-        uint256 bnNewBlock;\n-        bnNewBlock.SetCompact(block.nBits, NULL, &fOverflow);\n-        uint256 bnRequired;\n-        bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n-        if (fOverflow || bnNewBlock > bnRequired)\n-        {\n-            return state.DoS(100, error(\"CheckBlockHeader() : block with too little proof-of-work\"),\n-                             REJECT_INVALID, \"bad-diffbits\");\n-        }\n-    }\n-\n     return true;\n }\n \n@@ -2403,16 +2335,11 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n         if (!CheckTransaction(tx, state))\n             return error(\"CheckBlock() : CheckTransaction failed\");\n \n-    // Build the merkle tree already. We need it anyway later, and it makes the\n-    // block cache the transaction hashes, which means they don't need to be\n-    // recalculated many times during this block's validation.\n-    block.BuildMerkleTree();\n-\n     // Check for duplicate txids. This is caught by ConnectInputs(),\n     // but catching it earlier avoids a potential DoS attack:\n     set<uint256> uniqueTx;\n-    for (unsigned int i = 0; i < block.vtx.size(); i++) {\n-        uniqueTx.insert(block.GetTxHash(i));\n+    BOOST_FOREACH(const CTransaction &tx, block.vtx) {\n+        uniqueTx.insert(tx.GetHash());\n     }\n     if (uniqueTx.size() != block.vtx.size())\n         return state.DoS(100, error(\"CheckBlock() : duplicate transaction\"),\n@@ -2428,7 +2355,7 @@ bool CheckBlock(const CBlock& block, CValidationState& state, bool fCheckPOW, bo\n                          REJECT_INVALID, \"bad-blk-sigops\", true);\n \n     // Check merkle root\n-    if (fCheckMerkleRoot && block.hashMerkleRoot != block.vMerkleTree.back())\n+    if (fCheckMerkleRoot && block.hashMerkleRoot != block.BuildMerkleTree())\n         return state.DoS(100, error(\"CheckBlock() : hashMerkleRoot mismatch\"),\n                          REJECT_INVALID, \"bad-txnmrklroot\", true);\n \n@@ -2448,6 +2375,28 @@ bool AcceptBlockHeader(CBlockHeader& block, CValidationState& state, CBlockIndex\n             return state.Invalid(error(\"AcceptBlock() : block is marked invalid\"), 0, \"duplicate\");\n     }\n \n+    CBlockIndex* pcheckpoint = Checkpoints::GetLastCheckpoint(mapBlockIndex);\n+    if (pcheckpoint && block.hashPrevBlock != (chainActive.Tip() ? chainActive.Tip()->GetBlockHash() : uint256(0)))\n+    {\n+        // Extra checks to prevent \"fill up memory by spamming with bogus blocks\"\n+        int64_t deltaTime = block.GetBlockTime() - pcheckpoint->GetBlockTime();\n+        if (deltaTime < 0)\n+        {\n+            return state.DoS(100, error(\"CheckBlockHeader() : block with timestamp before last checkpoint\"),\n+                             REJECT_CHECKPOINT, \"time-too-old\");\n+        }\n+        bool fOverflow = false;\n+        uint256 bnNewBlock;\n+        bnNewBlock.SetCompact(block.nBits, NULL, &fOverflow);\n+        uint256 bnRequired;\n+        bnRequired.SetCompact(ComputeMinWork(pcheckpoint->nBits, deltaTime));\n+        if (fOverflow || bnNewBlock > bnRequired)\n+        {\n+            return state.DoS(100, error(\"CheckBlockHeader() : block with too little proof-of-work\"),\n+                             REJECT_INVALID, \"bad-diffbits\");\n+        }\n+    }\n+\n     // Get prev block index\n     CBlockIndex* pindexPrev = NULL;\n     int nHeight = 0;\n@@ -2506,7 +2455,7 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex** ppindex,\n         return false;\n \n     if (!CheckBlock(block, state)) {\n-        if (state.Invalid() && !state.CorruptionPossible()) {\n+        if (state.IsInvalid() && !state.CorruptionPossible()) {\n             pindex->nStatus |= BLOCK_FAILED_VALID;\n         }\n         return false;\n@@ -2541,7 +2490,7 @@ bool AcceptBlock(CBlock& block, CValidationState& state, CBlockIndex** ppindex,\n         CDiskBlockPos blockPos;\n         if (dbp != NULL)\n             blockPos = *dbp;\n-        if (!FindBlockPos(state, blockPos, nBlockSize+8, nHeight, block.nTime, dbp != NULL))\n+        if (!FindBlockPos(state, blockPos, nBlockSize+8, nHeight, block.GetBlockTime(), dbp != NULL))\n             return error(\"AcceptBlock() : FindBlockPos failed\");\n         if (dbp == NULL)\n             if (!WriteBlockToDisk(block, blockPos))\n@@ -2568,6 +2517,55 @@ bool CBlockIndex::IsSuperMajority(int minVersion, const CBlockIndex* pstart, uns\n     return (nFound >= nRequired);\n }\n \n+/** Turn the lowest '1' bit in the binary representation of a number into a '0'. */\n+int static inline InvertLowestOne(int n) { return n & (n - 1); }\n+\n+/** Compute what height to jump back to with the CBlockIndex::pskip pointer. */\n+int static inline GetSkipHeight(int height) {\n+    if (height < 2)\n+        return 0;\n+\n+    // Determine which height to jump back to. Any number strictly lower than height is acceptable,\n+    // but the following expression seems to perform well in simulations (max 110 steps to go back\n+    // up to 2**18 blocks).\n+    return (height & 1) ? InvertLowestOne(InvertLowestOne(height - 1)) + 1 : InvertLowestOne(height);\n+}\n+\n+CBlockIndex* CBlockIndex::GetAncestor(int height)\n+{\n+    if (height > nHeight || height < 0)\n+        return NULL;\n+\n+    CBlockIndex* pindexWalk = this;\n+    int heightWalk = nHeight;\n+    while (heightWalk > height) {\n+        int heightSkip = GetSkipHeight(heightWalk);\n+        int heightSkipPrev = GetSkipHeight(heightWalk - 1);\n+        if (heightSkip == height ||\n+            (heightSkip > height && !(heightSkipPrev < heightSkip - 2 &&\n+                                      heightSkipPrev >= height))) {\n+            // Only follow pskip if pprev->pskip isn't better than pskip->pprev.\n+            pindexWalk = pindexWalk->pskip;\n+            heightWalk = heightSkip;\n+        } else {\n+            pindexWalk = pindexWalk->pprev;\n+            heightWalk--;\n+        }\n+    }\n+    return pindexWalk;\n+}\n+\n+const CBlockIndex* CBlockIndex::GetAncestor(int height) const\n+{\n+    return const_cast<CBlockIndex*>(this)->GetAncestor(height);\n+}\n+\n+void CBlockIndex::BuildSkip()\n+{\n+    if (pprev)\n+        pskip = pprev->GetAncestor(GetSkipHeight(nHeight));\n+}\n+\n void PushGetBlocks(CNode* pnode, CBlockIndex* pindexBegin, uint256 hashEnd)\n {\n     AssertLockHeld(cs_main);\n@@ -2682,8 +2680,8 @@ CMerkleBlock::CMerkleBlock(const CBlock& block, CBloomFilter& filter)\n \n     for (unsigned int i = 0; i < block.vtx.size(); i++)\n     {\n-        uint256 hash = block.vtx[i].GetHash();\n-        if (filter.IsRelevantAndUpdate(block.vtx[i], hash))\n+        const uint256& hash = block.vtx[i].GetHash();\n+        if (filter.IsRelevantAndUpdate(block.vtx[i]))\n         {\n             vMatch.push_back(true);\n             vMatchedTxn.push_back(make_pair(i, hash));\n@@ -2918,6 +2916,8 @@ bool static LoadBlockIndexDB()\n             setBlockIndexValid.insert(pindex);\n         if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n             pindexBestInvalid = pindex;\n+        if (pindex->pprev)\n+            pindex->BuildSkip();\n     }\n \n     // Load block file info\n@@ -3088,7 +3088,7 @@ bool InitBlockIndex() {\n             unsigned int nBlockSize = ::GetSerializeSize(block, SER_DISK, CLIENT_VERSION);\n             CDiskBlockPos blockPos;\n             CValidationState state;\n-            if (!FindBlockPos(state, blockPos, nBlockSize+8, 0, block.nTime))\n+            if (!FindBlockPos(state, blockPos, nBlockSize+8, 0, block.GetBlockTime()))\n                 return error(\"LoadBlockIndex() : FindBlockPos failed\");\n             if (!WriteBlockToDisk(block, blockPos))\n                 return error(\"LoadBlockIndex() : writing genesis block to disk failed\");\n@@ -3477,10 +3477,10 @@ void static ProcessGetData(CNode* pfrom)\n     }\n }\n \n-bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n+bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv, int64_t nTimeReceived)\n {\n     RandAddSeedPerfmon();\n-    LogPrint(\"net\", \"received: %s (%u bytes)\\n\", strCommand, vRecv.size());\n+    LogPrint(\"net\", \"received: %s (%u bytes) peer=%d\\n\", strCommand, vRecv.size(), pfrom->id);\n     if (mapArgs.count(\"-dropmessagestest\") && GetRand(atoi(mapArgs[\"-dropmessagestest\"])) == 0)\n     {\n         LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n@@ -3512,7 +3512,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         if (pfrom->nVersion < MIN_PEER_PROTO_VERSION)\n         {\n             // disconnect from peers older than this proto version\n-            LogPrintf(\"partner %s using obsolete version %i; disconnecting\\n\", pfrom->addr.ToString(), pfrom->nVersion);\n+            LogPrintf(\"peer=%d using obsolete version %i; disconnecting\\n\", pfrom->id, pfrom->nVersion);\n             pfrom->PushMessage(\"reject\", strCommand, REJECT_OBSOLETE,\n                                strprintf(\"Version must be %d or greater\", MIN_PEER_PROTO_VERSION));\n             pfrom->fDisconnect = true;\n@@ -3593,7 +3593,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         pfrom->fSuccessfullyConnected = true;\n \n-        LogPrintf(\"receive version message: %s: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", pfrom->cleanSubVer, pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString(), addrFrom.ToString(), pfrom->addr.ToString());\n+        LogPrintf(\"receive version message: %s: version %d, blocks=%d, us=%s, peer=%d\\n\", pfrom->cleanSubVer, pfrom->nVersion, pfrom->nStartingHeight, addrMe.ToString(), pfrom->id);\n \n         AddTimeData(pfrom->addr, nTime);\n     }\n@@ -3700,7 +3700,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             pfrom->AddInventoryKnown(inv);\n \n             bool fAlreadyHave = AlreadyHave(inv);\n-            LogPrint(\"net\", \"  got inventory: %s  %s\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\");\n+            LogPrint(\"net\", \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->id);\n \n             if (!fAlreadyHave) {\n                 if (!fImporting && !fReindex) {\n@@ -3713,6 +3713,9 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                 PushGetBlocks(pfrom, chainActive.Tip(), GetOrphanRoot(inv.hash));\n             }\n \n+            if (inv.type == MSG_BLOCK)\n+                UpdateBlockAvailability(pfrom->GetId(), inv.hash);\n+\n             // Track requests for our stuff\n             g_signals.Inventory(inv.hash);\n         }\n@@ -3730,10 +3733,10 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         }\n \n         if (fDebug || (vInv.size() != 1))\n-            LogPrint(\"net\", \"received getdata (%u invsz)\\n\", vInv.size());\n+            LogPrint(\"net\", \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom->id);\n \n         if ((fDebug && vInv.size() > 0) || (vInv.size() == 1))\n-            LogPrint(\"net\", \"received getdata for: %s\\n\", vInv[0].ToString());\n+            LogPrint(\"net\", \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->id);\n \n         pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());\n         ProcessGetData(pfrom);\n@@ -3755,7 +3758,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         if (pindex)\n             pindex = chainActive.Next(pindex);\n         int nLimit = 500;\n-        LogPrint(\"net\", \"getblocks %d to %s limit %d\\n\", (pindex ? pindex->nHeight : -1), hashStop.ToString(), nLimit);\n+        LogPrint(\"net\", \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop==uint256(0) ? \"end\" : hashStop.ToString(), nLimit, pfrom->id);\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             if (pindex->GetBlockHash() == hashStop)\n@@ -3832,14 +3835,14 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         if (AcceptToMemoryPool(mempool, state, tx, true, &fMissingInputs))\n         {\n             mempool.check(pcoinsTip);\n-            RelayTransaction(tx, inv.hash);\n+            RelayTransaction(tx);\n             mapAlreadyAskedFor.erase(inv);\n             vWorkQueue.push_back(inv.hash);\n             vEraseQueue.push_back(inv.hash);\n \n \n-            LogPrint(\"mempool\", \"AcceptToMemoryPool: %s %s : accepted %s (poolsz %u)\\n\",\n-                pfrom->addr.ToString(), pfrom->cleanSubVer,\n+            LogPrint(\"mempool\", \"AcceptToMemoryPool: peer=%d %s : accepted %s (poolsz %u)\\n\",\n+                pfrom->id, pfrom->cleanSubVer,\n                 tx.GetHash().ToString(),\n                 mempool.mapTx.size());\n \n@@ -3862,7 +3865,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n                     if (AcceptToMemoryPool(mempool, stateDummy, orphanTx, true, &fMissingInputs2))\n                     {\n                         LogPrint(\"mempool\", \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n-                        RelayTransaction(orphanTx, orphanHash);\n+                        RelayTransaction(orphanTx);\n                         mapAlreadyAskedFor.erase(CInv(MSG_TX, orphanHash));\n                         vWorkQueue.push_back(orphanHash);\n                         vEraseQueue.push_back(orphanHash);\n@@ -3888,12 +3891,17 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             unsigned int nEvicted = LimitOrphanTxSize(MAX_ORPHAN_TRANSACTIONS);\n             if (nEvicted > 0)\n                 LogPrint(\"mempool\", \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n+        } else if (pfrom->fWhitelisted) {\n+            // Always relay transactions received from whitelisted peers, even\n+            // if they are already in the mempool (allowing the node to function\n+            // as a gateway for nodes hidden behind it).\n+            RelayTransaction(tx);\n         }\n         int nDoS = 0;\n         if (state.IsInvalid(nDoS))\n         {\n-            LogPrint(\"mempool\", \"%s from %s %s was not accepted into the memory pool: %s\\n\", tx.GetHash().ToString(),\n-                pfrom->addr.ToString(), pfrom->cleanSubVer,\n+            LogPrint(\"mempool\", \"%s from peer=%d %s was not accepted into the memory pool: %s\\n\", tx.GetHash().ToString(),\n+                pfrom->id, pfrom->cleanSubVer,\n                 state.GetRejectReason());\n             pfrom->PushMessage(\"reject\", strCommand, state.GetRejectCode(),\n                                state.GetRejectReason(), inv.hash);\n@@ -3908,7 +3916,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         CBlock block;\n         vRecv >> block;\n \n-        LogPrint(\"net\", \"received block %s\\n\", block.GetHash().ToString());\n+        LogPrint(\"net\", \"received block %s peer=%d\\n\", block.GetHash().ToString(), pfrom->id);\n         // block.print();\n \n         CInv inv(MSG_BLOCK, block.GetHash());\n@@ -3923,6 +3931,16 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n         CValidationState state;\n         ProcessBlock(state, pfrom, &block);\n+        int nDoS;\n+        if (state.IsInvalid(nDoS)) {\n+            pfrom->PushMessage(\"reject\", strCommand, state.GetRejectCode(),\n+                               state.GetRejectReason(), inv.hash);\n+            if (nDoS > 0) {\n+                LOCK(cs_main);\n+                Misbehaving(pfrom->GetId(), nDoS);\n+            }\n+        }\n+\n     }\n \n \n@@ -3947,7 +3965,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n             CTransaction tx;\n             bool fInMemPool = mempool.lookup(hash, tx);\n             if (!fInMemPool) continue; // another thread removed since queryHashes, maybe...\n-            if ((pfrom->pfilter && pfrom->pfilter->IsRelevantAndUpdate(tx, hash)) ||\n+            if ((pfrom->pfilter && pfrom->pfilter->IsRelevantAndUpdate(tx)) ||\n                (!pfrom->pfilter))\n                 vInv.push_back(inv);\n             if (vInv.size() == MAX_INV_SZ) {\n@@ -3984,7 +4002,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n \n     else if (strCommand == \"pong\")\n     {\n-        int64_t pingUsecEnd = GetTimeMicros();\n+        int64_t pingUsecEnd = nTimeReceived;\n         uint64_t nonce = 0;\n         size_t nAvail = vRecv.in_avail();\n         bool bPingFinished = false;\n@@ -4025,8 +4043,8 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n         }\n \n         if (!(sProblem.empty())) {\n-            LogPrint(\"net\", \"pong %s %s: %s, %x expected, %x received, %u bytes\\n\",\n-                pfrom->addr.ToString(),\n+            LogPrint(\"net\", \"pong peer=%d %s: %s, %x expected, %x received, %u bytes\\n\",\n+                pfrom->id,\n                 pfrom->cleanSubVer,\n                 sProblem,\n                 pfrom->nPingNonceSent,\n@@ -4144,6 +4162,7 @@ bool static ProcessMessage(CNode* pfrom, string strCommand, CDataStream& vRecv)\n     else\n     {\n         // Ignore unknown commands for extensibility\n+        LogPrint(\"net\", \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->id);\n     }\n \n \n@@ -4234,7 +4253,7 @@ bool ProcessMessages(CNode* pfrom)\n         bool fRet = false;\n         try\n         {\n-            fRet = ProcessMessage(pfrom, strCommand, vRecv);\n+            fRet = ProcessMessage(pfrom, strCommand, vRecv, msg.nTime);\n             boost::this_thread::interruption_point();\n         }\n         catch (std::ios_base::failure& e)\n@@ -4265,7 +4284,7 @@ bool ProcessMessages(CNode* pfrom)\n         }\n \n         if (!fRet)\n-            LogPrintf(\"ProcessMessage(%s, %u bytes) FAILED\\n\", strCommand, nMessageSize);\n+            LogPrintf(\"ProcessMessage(%s, %u bytes) FAILED peer=%d\\n\", strCommand, nMessageSize, pfrom->id);\n \n         break;\n     }\n@@ -4300,7 +4319,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n         if (pingSend) {\n             uint64_t nonce = 0;\n             while (nonce == 0) {\n-                RAND_bytes((unsigned char*)&nonce, sizeof(nonce));\n+                GetRandBytes((unsigned char*)&nonce, sizeof(nonce));\n             }\n             pto->fPingQueued = false;\n             pto->nPingUsecStart = GetTimeMicros();\n@@ -4370,11 +4389,14 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n \n         CNodeState &state = *State(pto->GetId());\n         if (state.fShouldBan) {\n-            if (pto->addr.IsLocal())\n-                LogPrintf(\"Warning: not banning local node %s!\\n\", pto->addr.ToString());\n+            if (pto->fWhitelisted)\n+                LogPrintf(\"Warning: not punishing whitelisted peer %s!\\n\", pto->addr.ToString());\n             else {\n                 pto->fDisconnect = true;\n-                CNode::Ban(pto->addr);\n+                if (pto->addr.IsLocal())\n+                    LogPrintf(\"Warning: not banning local peer %s!\\n\", pto->addr.ToString());\n+                else\n+                    CNode::Ban(pto->addr);\n             }\n             state.fShouldBan = false;\n         }\n@@ -4458,6 +4480,9 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             pto->fDisconnect = true;\n         }\n \n+        // Update knowledge of peer's block availability.\n+        ProcessBlockAvailability(pto->GetId());\n+\n         //\n         // Message: getdata (blocks)\n         //\n@@ -4466,7 +4491,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             uint256 hash = state.vBlocksToDownload.front();\n             vGetData.push_back(CInv(MSG_BLOCK, hash));\n             MarkBlockAsInFlight(pto->GetId(), hash);\n-            LogPrint(\"net\", \"Requesting block %s from %s\\n\", hash.ToString(), state.name);\n+            LogPrint(\"net\", \"Requesting block %s peer=%d\\n\", hash.ToString(), pto->id);\n             if (vGetData.size() >= 1000)\n             {\n                 pto->PushMessage(\"getdata\", vGetData);\n@@ -4483,7 +4508,7 @@ bool SendMessages(CNode* pto, bool fSendTrickle)\n             if (!AlreadyHave(inv))\n             {\n                 if (fDebug)\n-                    LogPrint(\"net\", \"sending getdata: %s\\n\", inv.ToString());\n+                    LogPrint(\"net\", \"Requesting %s peer=%d\\n\", inv.ToString(), pto->id);\n                 vGetData.push_back(inv);\n                 if (vGetData.size() >= 1000)\n                 {"
      },
      {
        "sha": "5f231fa45b380343d325b8659868523743917284",
        "filename": "src/main.h",
        "status": "modified",
        "additions": 30,
        "deletions": 36,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/main.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/main.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -7,7 +7,7 @@\n #define BITCOIN_MAIN_H\n \n #if defined(HAVE_CONFIG_H)\n-#include \"bitcoin-config.h\"\n+#include \"config/bitcoin-config.h\"\n #endif\n \n #include \"chainparams.h\"\n@@ -43,6 +43,8 @@ static const unsigned int DEFAULT_BLOCK_PRIORITY_SIZE = 50000;\n static const unsigned int MAX_STANDARD_TX_SIZE = 100000;\n /** The maximum allowed number of signature check operations in a block (network rule) */\n static const unsigned int MAX_BLOCK_SIGOPS = MAX_BLOCK_SIZE/50;\n+/** Maxiumum number of signature check operations in an IsStandard() P2SH script */\n+static const unsigned int MAX_P2SH_SIGOPS = 15;\n /** The maximum number of orphan transactions kept in memory */\n static const unsigned int MAX_ORPHAN_TRANSACTIONS = MAX_BLOCK_SIZE/100;\n /** Default for -maxorphanblocks, maximum number of orphan blocks kept in memory */\n@@ -85,12 +87,16 @@ extern uint64_t nLastBlockTx;\n extern uint64_t nLastBlockSize;\n extern const std::string strMessageMagic;\n extern int64_t nTimeBestReceived;\n+extern CWaitableCriticalSection csBestBlock;\n+extern CConditionVariable cvBlockChange;\n extern bool fImporting;\n extern bool fReindex;\n extern bool fBenchmark;\n extern int nScriptCheckThreads;\n extern bool fTxIndex;\n+extern bool fIsBareMultisigStd;\n extern unsigned int nCoinCacheSize;\n+extern CFeeRate minRelayTxFee;\n \n // Minimum disk space required - used in CheckDiskSpace()\n static const uint64_t nMinDiskSpace = 52428800;\n@@ -113,7 +119,7 @@ void UnregisterWallet(CWalletInterface* pwalletIn);\n /** Unregister all wallets from core */\n void UnregisterAllWallets();\n /** Push an updated transaction to all registered wallets */\n-void SyncWithWallets(const uint256 &hash, const CTransaction& tx, const CBlock* pblock = NULL);\n+void SyncWithWallets(const CTransaction& tx, const CBlock* pblock = NULL);\n \n /** Register with a network node to receive its signals */\n void RegisterNodeSignals(CNodeSignals& nodeSignals);\n@@ -146,10 +152,6 @@ bool ProcessMessages(CNode* pfrom);\n bool SendMessages(CNode* pto, bool fSendTrickle);\n /** Run an instance of the script checking thread */\n void ThreadScriptCheck();\n-/** Check whether a block hash satisfies the proof-of-work requirement specified by nBits */\n-bool CheckProofOfWork(uint256 hash, unsigned int nBits);\n-/** Calculate the minimum amount of work a received block needs, without knowing its direct parent */\n-unsigned int ComputeMinWork(unsigned int nBase, int64_t nTime);\n /** Check whether we are doing an initial block download (synchronizing from disk or network) */\n bool IsInitialBlockDownload();\n /** Format a string that describes several potential problems detected by the core */\n@@ -159,7 +161,6 @@ bool GetTransaction(const uint256 &hash, CTransaction &tx, uint256 &hashBlock, b\n /** Find the best known block, and make it the tip of the block chain */\n bool ActivateBestChain(CValidationState &state);\n int64_t GetBlockValue(int nHeight, int64_t nFees);\n-unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock);\n \n void UpdateTime(CBlockHeader& block, const CBlockIndex* pindexPrev);\n \n@@ -188,6 +189,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n \n struct CNodeStateStats {\n     int nMisbehavior;\n+    int nSyncHeight;\n };\n \n struct CDiskBlockPos\n@@ -244,14 +246,7 @@ struct CDiskTxPos : public CDiskBlockPos\n };\n \n \n-\n-enum GetMinFee_mode\n-{\n-    GMF_RELAY,\n-    GMF_SEND,\n-};\n-\n-int64_t GetMinFee(const CTransaction& tx, unsigned int nBytes, bool fAllowFree, enum GetMinFee_mode mode);\n+int64_t GetMinRelayFee(const CTransaction& tx, unsigned int nBytes, bool fAllowFree);\n \n //\n // Check transaction inputs, and make sure any\n@@ -294,7 +289,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, CCoinsViewCach\n                  std::vector<CScriptCheck> *pvChecks = NULL);\n \n // Apply the effects of this transaction on the UTXO set represented by view\n-void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCache &inputs, CTxUndo &txundo, int nHeight, const uint256 &txhash);\n+void UpdateCoins(const CTransaction& tx, CValidationState &state, CCoinsViewCache &inputs, CTxUndo &txundo, int nHeight);\n \n // Context-independent validity checks\n bool CheckTransaction(const CTransaction& tx, CValidationState& state);\n@@ -458,7 +453,7 @@ class CMerkleTx : public CTransaction\n     int GetDepthInMainChain() const { CBlockIndex *pindexRet; return GetDepthInMainChain(pindexRet); }\n     bool IsInMainChain() const { CBlockIndex *pindexRet; return GetDepthInMainChainINTERNAL(pindexRet) > 0; }\n     int GetBlocksToMaturity() const;\n-    bool AcceptToMemoryPool(bool fLimitFree=true);\n+    bool AcceptToMemoryPool(bool fLimitFree=true, bool fRejectInsaneFee=true);\n };\n \n \n@@ -679,6 +674,9 @@ class CBlockIndex\n     // pointer to the index of the predecessor of this block\n     CBlockIndex* pprev;\n \n+    // pointer to the index of some further predecessor of this block\n+    CBlockIndex* pskip;\n+\n     // height of the entry in the chain. The genesis block has height 0\n     int nHeight;\n \n@@ -714,10 +712,11 @@ class CBlockIndex\n     // (memory only) Sequencial id assigned to distinguish order in which blocks are received.\n     uint32_t nSequenceId;\n \n-    CBlockIndex()\n+    void SetNull()\n     {\n         phashBlock = NULL;\n         pprev = NULL;\n+        pskip = NULL;\n         nHeight = 0;\n         nFile = 0;\n         nDataPos = 0;\n@@ -735,19 +734,14 @@ class CBlockIndex\n         nNonce         = 0;\n     }\n \n+    CBlockIndex()\n+    {\n+        SetNull();\n+    }\n+\n     CBlockIndex(CBlockHeader& block)\n     {\n-        phashBlock = NULL;\n-        pprev = NULL;\n-        nHeight = 0;\n-        nFile = 0;\n-        nDataPos = 0;\n-        nUndoPos = 0;\n-        nChainWork = 0;\n-        nTx = 0;\n-        nChainTx = 0;\n-        nStatus = 0;\n-        nSequenceId = 0;\n+        SetNull();\n \n         nVersion       = block.nVersion;\n         hashMerkleRoot = block.hashMerkleRoot;\n@@ -812,11 +806,6 @@ class CBlockIndex\n         return (~bnTarget / (bnTarget + 1)) + 1;\n     }\n \n-    bool CheckIndex() const\n-    {\n-        return CheckProofOfWork(GetBlockHash(), nBits);\n-    }\n-\n     enum { nMedianTimeSpan=11 };\n \n     int64_t GetMedianTimePast() const\n@@ -876,9 +865,14 @@ class CBlockIndex\n         }\n         return false;\n     }\n-};\n \n+    // Build the skiplist pointer for this entry.\n+    void BuildSkip();\n \n+    // Efficiently find an ancestor of this block.\n+    CBlockIndex* GetAncestor(int height);\n+    const CBlockIndex* GetAncestor(int height) const;\n+};\n \n /** Used to marshal pointers into hashes for db storage. */\n class CDiskBlockIndex : public CBlockIndex\n@@ -1129,7 +1123,7 @@ class CMerkleBlock\n \n class CWalletInterface {\n protected:\n-    virtual void SyncTransaction(const uint256 &hash, const CTransaction &tx, const CBlock *pblock) =0;\n+    virtual void SyncTransaction(const CTransaction &tx, const CBlock *pblock) =0;\n     virtual void EraseFromWallet(const uint256 &hash) =0;\n     virtual void SetBestChain(const CBlockLocator &locator) =0;\n     virtual void UpdatedTransaction(const uint256 &hash) =0;"
      },
      {
        "sha": "ec56c7119267b0d16c9c1160567ca6771c2dec82",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 146,
        "deletions": 226,
        "changes": 372,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -3,55 +3,26 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <inttypes.h>\n+\n #include \"miner.h\"\n \n #include \"core.h\"\n+#include \"hash.h\"\n #include \"main.h\"\n #include \"net.h\"\n+#include \"pow.h\"\n #ifdef ENABLE_WALLET\n #include \"wallet.h\"\n #endif\n+\n+using namespace std;\n+\n //////////////////////////////////////////////////////////////////////////////\n //\n // BitcoinMiner\n //\n \n-int static FormatHashBlocks(void* pbuffer, unsigned int len)\n-{\n-    unsigned char* pdata = (unsigned char*)pbuffer;\n-    unsigned int blocks = 1 + ((len + 8) / 64);\n-    unsigned char* pend = pdata + 64 * blocks;\n-    memset(pdata + len, 0, 64 * blocks - len);\n-    pdata[len] = 0x80;\n-    unsigned int bits = len * 8;\n-    pend[-1] = (bits >> 0) & 0xff;\n-    pend[-2] = (bits >> 8) & 0xff;\n-    pend[-3] = (bits >> 16) & 0xff;\n-    pend[-4] = (bits >> 24) & 0xff;\n-    return blocks;\n-}\n-\n-static const unsigned int pSHA256InitState[8] =\n-{0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n-\n-void SHA256Transform(void* pstate, void* pinput, const void* pinit)\n-{\n-    SHA256_CTX ctx;\n-    unsigned char data[64];\n-\n-    SHA256_Init(&ctx);\n-\n-    for (int i = 0; i < 16; i++)\n-        ((uint32_t*)data)[i] = ByteReverse(((uint32_t*)pinput)[i]);\n-\n-    for (int i = 0; i < 8; i++)\n-        ctx.h[i] = ((uint32_t*)pinit)[i];\n-\n-    SHA256_Update(&ctx, data, sizeof(data));\n-    for (int i = 0; i < 8; i++)\n-        ((uint32_t*)pstate)[i] = ctx.h[i];\n-}\n-\n //\n // Unconfirmed transactions in the memory pool often depend on other\n // transactions in the memory pool. When we select transactions from the\n@@ -81,7 +52,6 @@ class COrphan\n     }\n };\n \n-\n uint64_t nLastBlockTx = 0;\n uint64_t nLastBlockSize = 0;\n \n@@ -90,8 +60,10 @@ typedef boost::tuple<double, CFeeRate, const CTransaction*> TxPriority;\n class TxPriorityCompare\n {\n     bool byFee;\n+\n public:\n     TxPriorityCompare(bool _byFee) : byFee(_byFee) { }\n+\n     bool operator()(const TxPriority& a, const TxPriority& b)\n     {\n         if (byFee)\n@@ -118,14 +90,14 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n     CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n \n     // Create coinbase tx\n-    CTransaction txNew;\n+    CMutableTransaction txNew;\n     txNew.vin.resize(1);\n     txNew.vin[0].prevout.SetNull();\n     txNew.vout.resize(1);\n     txNew.vout[0].scriptPubKey = scriptPubKeyIn;\n \n-    // Add our coinbase tx as first transaction\n-    pblock->vtx.push_back(txNew);\n+    // Add dummy coinbase tx as first transaction\n+    pblock->vtx.push_back(CTransaction());\n     pblocktemplate->vTxFees.push_back(-1); // updated at end\n     pblocktemplate->vTxSigOps.push_back(-1); // updated at end\n \n@@ -146,6 +118,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n \n     // Collect memory pool transactions into the block\n     int64_t nFees = 0;\n+\n     {\n         LOCK2(cs_main, mempool.cs);\n         CBlockIndex* pindexPrev = chainActive.Tip();\n@@ -215,6 +188,9 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             unsigned int nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n             dPriority = tx.ComputePriority(dPriority, nTxSize);\n \n+            uint256 hash = tx.GetHash();\n+            mempool.ApplyDeltas(hash, dPriority, nTotalIn);\n+\n             CFeeRate feeRate(nTotalIn-tx.GetValueOut(), nTxSize);\n \n             if (porphan)\n@@ -256,10 +232,14 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n                 continue;\n \n             // Skip free transactions if we're past the minimum block size:\n-            if (fSortedByFee && (feeRate < CTransaction::minRelayTxFee) && (nBlockSize + nTxSize >= nBlockMinSize))\n+            const uint256& hash = tx.GetHash();\n+            double dPriorityDelta = 0;\n+            int64_t nFeeDelta = 0;\n+            mempool.ApplyDeltas(hash, dPriorityDelta, nFeeDelta);\n+            if (fSortedByFee && (dPriorityDelta <= 0) && (nFeeDelta <= 0) && (feeRate < ::minRelayTxFee) && (nBlockSize + nTxSize >= nBlockMinSize))\n                 continue;\n \n-            // Prioritize by fee once past the priority size or we run out of high-priority\n+            // Prioritise by fee once past the priority size or we run out of high-priority\n             // transactions:\n             if (!fSortedByFee &&\n                 ((nBlockSize + nTxSize >= nBlockPrioritySize) || !AllowFree(dPriority)))\n@@ -286,8 +266,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n                 continue;\n \n             CTxUndo txundo;\n-            uint256 hash = tx.GetHash();\n-            UpdateCoins(tx, state, view, txundo, pindexPrev->nHeight+1, hash);\n+            UpdateCoins(tx, state, view, txundo, pindexPrev->nHeight+1);\n \n             // Added\n             pblock->vtx.push_back(tx);\n@@ -301,7 +280,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n             if (fPrintPriority)\n             {\n                 LogPrintf(\"priority %.1f fee %s txid %s\\n\",\n-                          dPriority, feeRate.ToString(), tx.GetHash().ToString());\n+                    dPriority, feeRate.ToString(), tx.GetHash().ToString());\n             }\n \n             // Add transactions that depend on this one to the priority queue\n@@ -326,15 +305,17 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n         nLastBlockSize = nBlockSize;\n         LogPrintf(\"CreateNewBlock(): total size %u\\n\", nBlockSize);\n \n-        pblock->vtx[0].vout[0].nValue = GetBlockValue(pindexPrev->nHeight+1, nFees);\n+        // Compute final coinbase transaction.\n+        txNew.vout[0].nValue = GetBlockValue(pindexPrev->nHeight+1, nFees);\n+        txNew.vin[0].scriptSig = CScript() << OP_0 << OP_0;\n+        pblock->vtx[0] = txNew;\n         pblocktemplate->vTxFees[0] = -nFees;\n \n         // Fill in header\n         pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n         UpdateTime(*pblock, pindexPrev);\n         pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock);\n         pblock->nNonce         = 0;\n-        pblock->vtx[0].vin[0].scriptSig = CScript() << OP_0 << OP_0;\n         pblocktemplate->vTxSigOps[0] = GetLegacySigOpCount(pblock->vtx[0]);\n \n         CBlockIndex indexDummy(*pblock);\n@@ -360,58 +341,14 @@ void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int&\n     }\n     ++nExtraNonce;\n     unsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2\n-    pblock->vtx[0].vin[0].scriptSig = (CScript() << nHeight << CScriptNum(nExtraNonce)) + COINBASE_FLAGS;\n-    assert(pblock->vtx[0].vin[0].scriptSig.size() <= 100);\n+    CMutableTransaction txCoinbase(pblock->vtx[0]);\n+    txCoinbase.vin[0].scriptSig = (CScript() << nHeight << CScriptNum(nExtraNonce)) + COINBASE_FLAGS;\n+    assert(txCoinbase.vin[0].scriptSig.size() <= 100);\n \n+    pblock->vtx[0] = txCoinbase;\n     pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n }\n \n-\n-void FormatHashBuffers(CBlock* pblock, char* pmidstate, char* pdata, char* phash1)\n-{\n-    //\n-    // Pre-build hash buffers\n-    //\n-    struct\n-    {\n-        struct unnamed2\n-        {\n-            int nVersion;\n-            uint256 hashPrevBlock;\n-            uint256 hashMerkleRoot;\n-            unsigned int nTime;\n-            unsigned int nBits;\n-            unsigned int nNonce;\n-        }\n-        block;\n-        unsigned char pchPadding0[64];\n-        uint256 hash1;\n-        unsigned char pchPadding1[64];\n-    }\n-    tmp;\n-    memset(&tmp, 0, sizeof(tmp));\n-\n-    tmp.block.nVersion       = pblock->nVersion;\n-    tmp.block.hashPrevBlock  = pblock->hashPrevBlock;\n-    tmp.block.hashMerkleRoot = pblock->hashMerkleRoot;\n-    tmp.block.nTime          = pblock->nTime;\n-    tmp.block.nBits          = pblock->nBits;\n-    tmp.block.nNonce         = pblock->nNonce;\n-\n-    FormatHashBlocks(&tmp.block, sizeof(tmp.block));\n-    FormatHashBlocks(&tmp.hash1, sizeof(tmp.hash1));\n-\n-    // Byte swap all the input buffer\n-    for (unsigned int i = 0; i < sizeof(tmp)/4; i++)\n-        ((unsigned int*)&tmp)[i] = ByteReverse(((unsigned int*)&tmp)[i]);\n-\n-    // Precalc the first half of the first hash, which stays constant\n-    SHA256Transform(pmidstate, &tmp.block, pSHA256InitState);\n-\n-    memcpy(pdata, &tmp.block, 128);\n-    memcpy(phash1, &tmp.hash1, 64);\n-}\n-\n #ifdef ENABLE_WALLET\n //////////////////////////////////////////////////////////////////////////////\n //\n@@ -422,34 +359,34 @@ int64_t nHPSTimerStart = 0;\n \n //\n // ScanHash scans nonces looking for a hash with at least some zero bits.\n-// It operates on big endian data.  Caller does the byte reversing.\n-// All input buffers are 16-byte aligned.  nNonce is usually preserved\n-// between calls, but periodically or if nNonce is 0xffff0000 or above,\n-// the block is rebuilt and nNonce starts over at zero.\n+// The nonce is usually preserved between calls, but periodically or if the\n+// nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at\n+// zero.\n //\n-unsigned int static ScanHash_CryptoPP(char* pmidstate, char* pdata, char* phash1, char* phash, unsigned int& nHashesDone)\n+bool static ScanHash(const CBlockHeader *pblock, uint32_t& nNonce, uint256 *phash)\n {\n-    unsigned int& nNonce = *(unsigned int*)(pdata + 12);\n-    for (;;)\n-    {\n-        // Crypto++ SHA256\n-        // Hash pdata using pmidstate as the starting state into\n-        // pre-formatted buffer phash1, then hash phash1 into phash\n+    // Write the first 76 bytes of the block header to a double-SHA256 state.\n+    CHash256 hasher;\n+    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n+    ss << *pblock;\n+    assert(ss.size() == 80);\n+    hasher.Write((unsigned char*)&ss[0], 76);\n+\n+    while (true) {\n         nNonce++;\n-        SHA256Transform(phash1, pdata, pmidstate);\n-        SHA256Transform(phash, phash1, pSHA256InitState);\n+\n+        // Write the last 4 bytes of the block header (the nonce) to a copy of\n+        // the double-SHA256 state, and compute the result.\n+        CHash256(hasher).Write((unsigned char*)&nNonce, 4).Finalize((unsigned char*)phash);\n \n         // Return the nonce if the hash has at least some zero bits,\n         // caller will check if it has enough to reach the target\n-        if (((unsigned short*)phash)[14] == 0)\n-            return nNonce;\n+        if (((uint16_t*)phash)[15] == 0)\n+            return true;\n \n         // If nothing found after trying for a while, return -1\n         if ((nNonce & 0xffff) == 0)\n-        {\n-            nHashesDone = 0xffff+1;\n-            return (unsigned int) -1;\n-        }\n+            return false;\n         if ((nNonce & 0xfff) == 0)\n             boost::this_thread::interruption_point();\n     }\n@@ -513,135 +450,118 @@ void static BitcoinMiner(CWallet *pwallet)\n     CReserveKey reservekey(pwallet);\n     unsigned int nExtraNonce = 0;\n \n-    try { while (true) {\n-        if (Params().MiningRequiresPeers()) {\n-            // Busy-wait for the network to come online so we don't waste time mining\n-            // on an obsolete chain. In regtest mode we expect to fly solo.\n-            while (vNodes.empty())\n-                MilliSleep(1000);\n-        }\n-\n-        //\n-        // Create new block\n-        //\n-        unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n-        CBlockIndex* pindexPrev = chainActive.Tip();\n-\n-        auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey));\n-        if (!pblocktemplate.get())\n-            return;\n-        CBlock *pblock = &pblocktemplate->block;\n-        IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);\n-\n-        LogPrintf(\"Running BitcoinMiner with %u transactions in block (%u bytes)\\n\", pblock->vtx.size(),\n-               ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION));\n-\n-        //\n-        // Pre-build hash buffers\n-        //\n-        char pmidstatebuf[32+16]; char* pmidstate = alignup<16>(pmidstatebuf);\n-        char pdatabuf[128+16];    char* pdata     = alignup<16>(pdatabuf);\n-        char phash1buf[64+16];    char* phash1    = alignup<16>(phash1buf);\n-\n-        FormatHashBuffers(pblock, pmidstate, pdata, phash1);\n-\n-        unsigned int& nBlockTime = *(unsigned int*)(pdata + 64 + 4);\n-        unsigned int& nBlockBits = *(unsigned int*)(pdata + 64 + 8);\n-        unsigned int& nBlockNonce = *(unsigned int*)(pdata + 64 + 12);\n-\n-\n-        //\n-        // Search\n-        //\n-        int64_t nStart = GetTime();\n-        uint256 hashTarget = uint256().SetCompact(pblock->nBits);\n-        uint256 hashbuf[2];\n-        uint256& hash = *alignup<16>(hashbuf);\n-        while (true)\n-        {\n-            unsigned int nHashesDone = 0;\n-            unsigned int nNonceFound;\n+    try {\n+        while (true) {\n+            if (Params().MiningRequiresPeers()) {\n+                // Busy-wait for the network to come online so we don't waste time mining\n+                // on an obsolete chain. In regtest mode we expect to fly solo.\n+                while (vNodes.empty())\n+                    MilliSleep(1000);\n+            }\n \n-            // Crypto++ SHA256\n-            nNonceFound = ScanHash_CryptoPP(pmidstate, pdata + 64, phash1,\n-                                            (char*)&hash, nHashesDone);\n+            //\n+            // Create new block\n+            //\n+            unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n+            CBlockIndex* pindexPrev = chainActive.Tip();\n \n-            // Check if something found\n-            if (nNonceFound != (unsigned int) -1)\n+            auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey));\n+            if (!pblocktemplate.get())\n             {\n-                for (unsigned int i = 0; i < sizeof(hash)/4; i++)\n-                    ((unsigned int*)&hash)[i] = ByteReverse(((unsigned int*)&hash)[i]);\n-\n-                if (hash <= hashTarget)\n+                LogPrintf(\"Error in BitcoinMiner: Keypool ran out, please call keypoolrefill before restarting the mining thread\\n\");\n+                return;\n+            }\n+            CBlock *pblock = &pblocktemplate->block;\n+            IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);\n+\n+            LogPrintf(\"Running BitcoinMiner with %u transactions in block (%u bytes)\\n\", pblock->vtx.size(),\n+                ::GetSerializeSize(*pblock, SER_NETWORK, PROTOCOL_VERSION));\n+\n+            //\n+            // Search\n+            //\n+            int64_t nStart = GetTime();\n+            uint256 hashTarget = uint256().SetCompact(pblock->nBits);\n+            uint256 hash;\n+            uint32_t nNonce = 0;\n+            uint32_t nOldNonce = 0;\n+            while (true) {\n+                bool fFound = ScanHash(pblock, nNonce, &hash);\n+                uint32_t nHashesDone = nNonce - nOldNonce;\n+                nOldNonce = nNonce;\n+\n+                // Check if something found\n+                if (fFound)\n                 {\n-                    // Found a solution\n-                    pblock->nNonce = ByteReverse(nNonceFound);\n-                    assert(hash == pblock->GetHash());\n+                    if (hash <= hashTarget)\n+                    {\n+                        // Found a solution\n+                        pblock->nNonce = nNonce;\n+                        assert(hash == pblock->GetHash());\n \n-                    SetThreadPriority(THREAD_PRIORITY_NORMAL);\n-                    CheckWork(pblock, *pwallet, reservekey);\n-                    SetThreadPriority(THREAD_PRIORITY_LOWEST);\n+                        SetThreadPriority(THREAD_PRIORITY_NORMAL);\n+                        CheckWork(pblock, *pwallet, reservekey);\n+                        SetThreadPriority(THREAD_PRIORITY_LOWEST);\n \n-                    // In regression test mode, stop mining after a block is found.\n-                    if (Params().MineBlocksOnDemand())\n-                        throw boost::thread_interrupted();\n+                        // In regression test mode, stop mining after a block is found.\n+                        if (Params().MineBlocksOnDemand())\n+                            throw boost::thread_interrupted();\n \n-                    break;\n+                        break;\n+                    }\n                 }\n-            }\n \n-            // Meter hashes/sec\n-            static int64_t nHashCounter;\n-            if (nHPSTimerStart == 0)\n-            {\n-                nHPSTimerStart = GetTimeMillis();\n-                nHashCounter = 0;\n-            }\n-            else\n-                nHashCounter += nHashesDone;\n-            if (GetTimeMillis() - nHPSTimerStart > 4000)\n-            {\n-                static CCriticalSection cs;\n+                // Meter hashes/sec\n+                static int64_t nHashCounter;\n+                if (nHPSTimerStart == 0)\n+                {\n+                    nHPSTimerStart = GetTimeMillis();\n+                    nHashCounter = 0;\n+                }\n+                else\n+                    nHashCounter += nHashesDone;\n+                if (GetTimeMillis() - nHPSTimerStart > 4000)\n                 {\n-                    LOCK(cs);\n-                    if (GetTimeMillis() - nHPSTimerStart > 4000)\n+                    static CCriticalSection cs;\n                     {\n-                        dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);\n-                        nHPSTimerStart = GetTimeMillis();\n-                        nHashCounter = 0;\n-                        static int64_t nLogTime;\n-                        if (GetTime() - nLogTime > 30 * 60)\n+                        LOCK(cs);\n+                        if (GetTimeMillis() - nHPSTimerStart > 4000)\n                         {\n-                            nLogTime = GetTime();\n-                            LogPrintf(\"hashmeter %6.0f khash/s\\n\", dHashesPerSec/1000.0);\n+                            dHashesPerSec = 1000.0 * nHashCounter / (GetTimeMillis() - nHPSTimerStart);\n+                            nHPSTimerStart = GetTimeMillis();\n+                            nHashCounter = 0;\n+                            static int64_t nLogTime;\n+                            if (GetTime() - nLogTime > 30 * 60)\n+                            {\n+                                nLogTime = GetTime();\n+                                LogPrintf(\"hashmeter %6.0f khash/s\\n\", dHashesPerSec/1000.0);\n+                            }\n                         }\n                     }\n                 }\n-            }\n \n-            // Check for stop or if block needs to be rebuilt\n-            boost::this_thread::interruption_point();\n-            // Regtest mode doesn't require peers\n-            if (vNodes.empty() && Params().MiningRequiresPeers())\n-                break;\n-            if (nBlockNonce >= 0xffff0000)\n-                break;\n-            if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n-                break;\n-            if (pindexPrev != chainActive.Tip())\n-                break;\n-\n-            // Update nTime every few seconds\n-            UpdateTime(*pblock, pindexPrev);\n-            nBlockTime = ByteReverse(pblock->nTime);\n-            if (Params().AllowMinDifficultyBlocks())\n-            {\n-                // Changing pblock->nTime can change work required on testnet:\n-                nBlockBits = ByteReverse(pblock->nBits);\n-                hashTarget.SetCompact(pblock->nBits);\n+                // Check for stop or if block needs to be rebuilt\n+                boost::this_thread::interruption_point();\n+                // Regtest mode doesn't require peers\n+                if (vNodes.empty() && Params().MiningRequiresPeers())\n+                    break;\n+                if (nNonce >= 0xffff0000)\n+                    break;\n+                if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n+                    break;\n+                if (pindexPrev != chainActive.Tip())\n+                    break;\n+\n+                // Update nTime every few seconds\n+                UpdateTime(*pblock, pindexPrev);\n+                if (Params().AllowMinDifficultyBlocks())\n+                {\n+                    // Changing pblock->nTime can change work required on testnet:\n+                    hashTarget.SetCompact(pblock->nBits);\n+                }\n             }\n         }\n-    } }\n+    }\n     catch (boost::thread_interrupted)\n     {\n         LogPrintf(\"BitcoinMiner terminated\\n\");\n@@ -676,4 +596,4 @@ void GenerateBitcoins(bool fGenerate, CWallet* pwallet, int nThreads)\n         minerThreads->create_thread(boost::bind(&BitcoinMiner, pwallet));\n }\n \n-#endif\n+#endif // ENABLE_WALLET"
      },
      {
        "sha": "1fa499dc5b9fa484f5fd2f95ebf607e0cc951ae8",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -23,12 +23,8 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn);\n CBlockTemplate* CreateNewBlockWithKey(CReserveKey& reservekey);\n /** Modify the extranonce in a block */\n void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce);\n-/** Do mining precalculation */\n-void FormatHashBuffers(CBlock* pblock, char* pmidstate, char* pdata, char* phash1);\n /** Check mined block */\n bool CheckWork(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey);\n-/** Base sha256 mining transform */\n-void SHA256Transform(void* pstate, void* pinput, const void* pinit);\n \n extern double dHashesPerSec;\n extern int64_t nHPSTimerStart;"
      },
      {
        "sha": "6c636d16b4ecf24025bbfd2193726e63aa7df440",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 131,
        "deletions": 88,
        "changes": 219,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -4,7 +4,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #if defined(HAVE_CONFIG_H)\n-#include \"bitcoin-config.h\"\n+#include \"config/bitcoin-config.h\"\n #endif\n \n #include \"net.h\"\n@@ -36,10 +36,30 @@\n #define MSG_NOSIGNAL 0\n #endif\n \n+// Fix for ancient MinGW versions, that don't have defined these in ws2tcpip.h.\n+// Todo: Can be removed when our pull-tester is upgraded to a modern MinGW version.\n+#ifdef WIN32\n+#ifndef PROTECTION_LEVEL_UNRESTRICTED\n+#define PROTECTION_LEVEL_UNRESTRICTED 10\n+#endif\n+#ifndef IPV6_PROTECTION_LEVEL\n+#define IPV6_PROTECTION_LEVEL 23\n+#endif\n+#endif\n+\n using namespace std;\n using namespace boost;\n \n-static const int MAX_OUTBOUND_CONNECTIONS = 8;\n+namespace {\n+    const int MAX_OUTBOUND_CONNECTIONS = 8;\n+\n+    struct ListenSocket {\n+        SOCKET socket;\n+        bool whitelisted;\n+\n+        ListenSocket(SOCKET socket, bool whitelisted) : socket(socket), whitelisted(whitelisted) {}\n+    };\n+}\n \n //\n // Global state variables\n@@ -54,7 +74,7 @@ static bool vfLimited[NET_MAX] = {};\n static CNode* pnodeLocalHost = NULL;\n static CNode* pnodeSync = NULL;\n uint64_t nLocalHostNonce = 0;\n-static std::vector<SOCKET> vhListenSocket;\n+static std::vector<ListenSocket> vhListenSocket;\n CAddrMan addrman;\n int nMaxConnections = 125;\n \n@@ -312,7 +332,7 @@ bool GetMyExternalIP2(const CService& addrConnect, const char* pszGet, const cha\n             {\n                 if (!RecvLine(hSocket, strLine))\n                 {\n-                    closesocket(hSocket);\n+                    CloseSocket(hSocket);\n                     return false;\n                 }\n                 if (pszKeyword == NULL)\n@@ -323,7 +343,7 @@ bool GetMyExternalIP2(const CService& addrConnect, const char* pszGet, const cha\n                     break;\n                 }\n             }\n-            closesocket(hSocket);\n+            CloseSocket(hSocket);\n             if (strLine.find(\"<\") != string::npos)\n                 strLine = strLine.substr(0, strLine.find(\"<\"));\n             strLine = strLine.substr(strspn(strLine.c_str(), \" \\t\\n\\r\"));\n@@ -337,7 +357,7 @@ bool GetMyExternalIP2(const CService& addrConnect, const char* pszGet, const cha\n             return true;\n         }\n     }\n-    closesocket(hSocket);\n+    CloseSocket(hSocket);\n     return error(\"GetMyExternalIP() : connection closed\");\n }\n \n@@ -436,7 +456,7 @@ CNode* FindNode(const CNetAddr& ip)\n     return NULL;\n }\n \n-CNode* FindNode(std::string addrName)\n+CNode* FindNode(const std::string& addrName)\n {\n     LOCK(cs_vNodes);\n     BOOST_FOREACH(CNode* pnode, vNodes)\n@@ -480,8 +500,6 @@ CNode* ConnectNode(CAddress addrConnect, const char *pszDest)\n     {\n         addrman.Attempt(addrConnect);\n \n-        LogPrint(\"net\", \"connected %s\\n\", pszDest ? pszDest : addrConnect.ToString());\n-\n         // Set to non-blocking\n #ifdef WIN32\n         u_long nOne = 1;\n@@ -502,6 +520,7 @@ CNode* ConnectNode(CAddress addrConnect, const char *pszDest)\n         }\n \n         pnode->nTimeConnected = GetTime();\n+\n         return pnode;\n     }\n \n@@ -513,9 +532,8 @@ void CNode::CloseSocketDisconnect()\n     fDisconnect = true;\n     if (hSocket != INVALID_SOCKET)\n     {\n-        LogPrint(\"net\", \"disconnecting node %s\\n\", addrName);\n-        closesocket(hSocket);\n-        hSocket = INVALID_SOCKET;\n+        LogPrint(\"net\", \"disconnecting peer=%d\\n\", id);\n+        CloseSocket(hSocket);\n     }\n \n     // in case this fails, we'll empty the recv buffer when the CNode is deleted\n@@ -528,10 +546,6 @@ void CNode::CloseSocketDisconnect()\n         pnodeSync = NULL;\n }\n \n-void CNode::Cleanup()\n-{\n-}\n-\n void CNode::PushVersion()\n {\n     int nBestHeight = g_signals.GetHeight().get_value_or(0);\n@@ -540,8 +554,11 @@ void CNode::PushVersion()\n     int64_t nTime = (fInbound ? GetAdjustedTime() : GetTime());\n     CAddress addrYou = (addr.IsRoutable() && !IsProxy(addr) ? addr : CAddress(CService(\"0.0.0.0\",0)));\n     CAddress addrMe = GetLocalAddress(&addr);\n-    RAND_bytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n-    LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%s\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString(), addrYou.ToString(), addr.ToString());\n+    GetRandBytes((unsigned char*)&nLocalHostNonce, sizeof(nLocalHostNonce));\n+    if (fLogIPs)\n+        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString(), addrYou.ToString(), id);\n+    else\n+        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, peer=%d\\n\", PROTOCOL_VERSION, nBestHeight, addrMe.ToString(), id);\n     PushMessage(\"version\", PROTOCOL_VERSION, nLocalServices, nTime, addrYou, addrMe,\n                 nLocalHostNonce, FormatSubVersion(CLIENT_NAME, CLIENT_VERSION, std::vector<string>()), nBestHeight, true);\n }\n@@ -584,6 +601,24 @@ bool CNode::Ban(const CNetAddr &addr) {\n     return true;\n }\n \n+\n+std::vector<CSubNet> CNode::vWhitelistedRange;\n+CCriticalSection CNode::cs_vWhitelistedRange;\n+\n+bool CNode::IsWhitelistedRange(const CNetAddr &addr) {\n+    LOCK(cs_vWhitelistedRange);\n+    BOOST_FOREACH(const CSubNet& subnet, vWhitelistedRange) {\n+        if (subnet.Match(addr))\n+            return true;\n+    }\n+    return false;\n+}\n+\n+void CNode::AddWhitelistedRange(const CSubNet &subnet) {\n+    LOCK(cs_vWhitelistedRange);\n+    vWhitelistedRange.push_back(subnet);\n+}\n+\n #undef X\n #define X(name) stats.name = name\n void CNode::copyStats(CNodeStats &stats)\n@@ -600,6 +635,7 @@ void CNode::copyStats(CNodeStats &stats)\n     X(nStartingHeight);\n     X(nSendBytes);\n     X(nRecvBytes);\n+    X(fWhitelisted);\n     stats.fSyncNode = (this == pnodeSync);\n \n     // It is common for nodes with good ping times to suddenly become lagged,\n@@ -646,6 +682,9 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes)\n \n         pch += handled;\n         nBytes -= handled;\n+\n+        if (msg.complete())\n+            msg.nTime = GetTimeMicros();\n     }\n \n     return true;\n@@ -678,7 +717,6 @@ int CNetMessage::readHeader(const char *pch, unsigned int nBytes)\n \n     // switch state to reading message data\n     in_data = true;\n-    vRecv.resize(hdr.nMessageSize);\n \n     return nCopy;\n }\n@@ -688,6 +726,11 @@ int CNetMessage::readData(const char *pch, unsigned int nBytes)\n     unsigned int nRemaining = hdr.nMessageSize - nDataPos;\n     unsigned int nCopy = std::min(nRemaining, nBytes);\n \n+    if (vRecv.size() < nDataPos + nCopy) {\n+        // Allocate up to 256 KiB ahead, but never more than the total message size.\n+        vRecv.resize(std::min(hdr.nMessageSize, nDataPos + nCopy + 256 * 1024));\n+    }\n+\n     memcpy(&vRecv[nDataPos], pch, nCopy);\n     nDataPos += nCopy;\n \n@@ -773,7 +816,6 @@ void ThreadSocketHandler()\n \n                     // close socket and cleanup\n                     pnode->CloseSocketDisconnect();\n-                    pnode->Cleanup();\n \n                     // hold in disconnected pool until all refs are released\n                     if (pnode->fNetworkNode || pnode->fInbound)\n@@ -817,7 +859,6 @@ void ThreadSocketHandler()\n             uiInterface.NotifyNumConnectionsChanged(nPrevNodeCount);\n         }\n \n-\n         //\n         // Find which sockets have data to receive\n         //\n@@ -834,11 +875,12 @@ void ThreadSocketHandler()\n         SOCKET hSocketMax = 0;\n         bool have_fds = false;\n \n-        BOOST_FOREACH(SOCKET hListenSocket, vhListenSocket) {\n-            FD_SET(hListenSocket, &fdsetRecv);\n-            hSocketMax = max(hSocketMax, hListenSocket);\n+        BOOST_FOREACH(const ListenSocket& hListenSocket, vhListenSocket) {\n+            FD_SET(hListenSocket.socket, &fdsetRecv);\n+            hSocketMax = max(hSocketMax, hListenSocket.socket);\n             have_fds = true;\n         }\n+\n         {\n             LOCK(cs_vNodes);\n             BOOST_FOREACH(CNode* pnode, vNodes)\n@@ -899,58 +941,60 @@ void ThreadSocketHandler()\n             MilliSleep(timeout.tv_usec/1000);\n         }\n \n-\n         //\n         // Accept new connections\n         //\n-        BOOST_FOREACH(SOCKET hListenSocket, vhListenSocket)\n-        if (hListenSocket != INVALID_SOCKET && FD_ISSET(hListenSocket, &fdsetRecv))\n+        BOOST_FOREACH(const ListenSocket& hListenSocket, vhListenSocket)\n         {\n-            struct sockaddr_storage sockaddr;\n-            socklen_t len = sizeof(sockaddr);\n-            SOCKET hSocket = accept(hListenSocket, (struct sockaddr*)&sockaddr, &len);\n-            CAddress addr;\n-            int nInbound = 0;\n-\n-            if (hSocket != INVALID_SOCKET)\n-                if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr))\n-                    LogPrintf(\"Warning: Unknown socket family\\n\");\n-\n+            if (hListenSocket.socket != INVALID_SOCKET && FD_ISSET(hListenSocket.socket, &fdsetRecv))\n             {\n-                LOCK(cs_vNodes);\n-                BOOST_FOREACH(CNode* pnode, vNodes)\n-                    if (pnode->fInbound)\n-                        nInbound++;\n-            }\n+                struct sockaddr_storage sockaddr;\n+                socklen_t len = sizeof(sockaddr);\n+                SOCKET hSocket = accept(hListenSocket.socket, (struct sockaddr*)&sockaddr, &len);\n+                CAddress addr;\n+                int nInbound = 0;\n \n-            if (hSocket == INVALID_SOCKET)\n-            {\n-                int nErr = WSAGetLastError();\n-                if (nErr != WSAEWOULDBLOCK)\n-                    LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n-            }\n-            else if (nInbound >= nMaxConnections - MAX_OUTBOUND_CONNECTIONS)\n-            {\n-                closesocket(hSocket);\n-            }\n-            else if (CNode::IsBanned(addr))\n-            {\n-                LogPrintf(\"connection from %s dropped (banned)\\n\", addr.ToString());\n-                closesocket(hSocket);\n-            }\n-            else\n-            {\n-                LogPrint(\"net\", \"accepted connection %s\\n\", addr.ToString());\n-                CNode* pnode = new CNode(hSocket, addr, \"\", true);\n-                pnode->AddRef();\n+                if (hSocket != INVALID_SOCKET)\n+                    if (!addr.SetSockAddr((const struct sockaddr*)&sockaddr))\n+                        LogPrintf(\"Warning: Unknown socket family\\n\");\n+\n+                bool whitelisted = hListenSocket.whitelisted || CNode::IsWhitelistedRange(addr);\n                 {\n                     LOCK(cs_vNodes);\n-                    vNodes.push_back(pnode);\n+                    BOOST_FOREACH(CNode* pnode, vNodes)\n+                        if (pnode->fInbound)\n+                            nInbound++;\n+                }\n+\n+                if (hSocket == INVALID_SOCKET)\n+                {\n+                    int nErr = WSAGetLastError();\n+                    if (nErr != WSAEWOULDBLOCK)\n+                        LogPrintf(\"socket error accept failed: %s\\n\", NetworkErrorString(nErr));\n+                }\n+                else if (nInbound >= nMaxConnections - MAX_OUTBOUND_CONNECTIONS)\n+                {\n+                    CloseSocket(hSocket);\n+                }\n+                else if (CNode::IsBanned(addr) && !whitelisted)\n+                {\n+                    LogPrintf(\"connection from %s dropped (banned)\\n\", addr.ToString());\n+                    CloseSocket(hSocket);\n+                }\n+                else\n+                {\n+                    CNode* pnode = new CNode(hSocket, addr, \"\", true);\n+                    pnode->AddRef();\n+                    pnode->fWhitelisted = whitelisted;\n+\n+                    {\n+                        LOCK(cs_vNodes);\n+                        vNodes.push_back(pnode);\n+                    }\n                 }\n             }\n         }\n \n-\n         //\n         // Service each socket\n         //\n@@ -1029,7 +1073,7 @@ void ThreadSocketHandler()\n             {\n                 if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n                 {\n-                    LogPrint(\"net\", \"socket no message in first 60 seconds, %d %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0);\n+                    LogPrint(\"net\", \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->id);\n                     pnode->fDisconnect = true;\n                 }\n                 else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL)\n@@ -1434,7 +1478,7 @@ bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOu\n     if (!pszDest) {\n         if (IsLocal(addrConnect) ||\n             FindNode((CNetAddr)addrConnect) || CNode::IsBanned(addrConnect) ||\n-            FindNode(addrConnect.ToStringIPPort().c_str()))\n+            FindNode(addrConnect.ToStringIPPort()))\n             return false;\n     } else if (FindNode(pszDest))\n         return false;\n@@ -1565,7 +1609,7 @@ void ThreadMessageHandler()\n \n \n \n-bool BindListenPort(const CService &addrBind, string& strError)\n+bool BindListenPort(const CService &addrBind, string& strError, bool fWhitelisted)\n {\n     strError = \"\";\n     int nOne = 1;\n@@ -1588,18 +1632,16 @@ bool BindListenPort(const CService &addrBind, string& strError)\n         return false;\n     }\n \n+#ifndef WIN32\n #ifdef SO_NOSIGPIPE\n     // Different way of disabling SIGPIPE on BSD\n     setsockopt(hListenSocket, SOL_SOCKET, SO_NOSIGPIPE, (void*)&nOne, sizeof(int));\n #endif\n-\n-#ifndef WIN32\n     // Allow binding if the port is still in TIME_WAIT state after\n-    // the program was closed and restarted.  Not an issue on windows.\n+    // the program was closed and restarted. Not an issue on windows!\n     setsockopt(hListenSocket, SOL_SOCKET, SO_REUSEADDR, (void*)&nOne, sizeof(int));\n #endif\n \n-\n #ifdef WIN32\n     // Set to non-blocking, incoming connections will also inherit this\n     if (ioctlsocket(hListenSocket, FIONBIO, (u_long*)&nOne) == SOCKET_ERROR)\n@@ -1623,10 +1665,8 @@ bool BindListenPort(const CService &addrBind, string& strError)\n #endif\n #endif\n #ifdef WIN32\n-        int nProtLevel = 10 /* PROTECTION_LEVEL_UNRESTRICTED */;\n-        int nParameterId = 23 /* IPV6_PROTECTION_LEVEl */;\n-        // this call is allowed to fail\n-        setsockopt(hListenSocket, IPPROTO_IPV6, nParameterId, (const char*)&nProtLevel, sizeof(int));\n+        int nProtLevel = PROTECTION_LEVEL_UNRESTRICTED;\n+        setsockopt(hListenSocket, IPPROTO_IPV6, IPV6_PROTECTION_LEVEL, (const char*)&nProtLevel, sizeof(int));\n #endif\n     }\n \n@@ -1638,6 +1678,7 @@ bool BindListenPort(const CService &addrBind, string& strError)\n         else\n             strError = strprintf(_(\"Unable to bind to %s on this computer (bind returned error %s)\"), addrBind.ToString(), NetworkErrorString(nErr));\n         LogPrintf(\"%s\\n\", strError);\n+        CloseSocket(hListenSocket);\n         return false;\n     }\n     LogPrintf(\"Bound to %s\\n\", addrBind.ToString());\n@@ -1647,12 +1688,13 @@ bool BindListenPort(const CService &addrBind, string& strError)\n     {\n         strError = strprintf(_(\"Error: Listening for incoming connections failed (listen returned error %s)\"), NetworkErrorString(WSAGetLastError()));\n         LogPrintf(\"%s\\n\", strError);\n+        CloseSocket(hListenSocket);\n         return false;\n     }\n \n-    vhListenSocket.push_back(hListenSocket);\n+    vhListenSocket.push_back(ListenSocket(hListenSocket, fWhitelisted));\n \n-    if (addrBind.IsRoutable() && fDiscover)\n+    if (addrBind.IsRoutable() && fDiscover && !fWhitelisted)\n         AddLocal(addrBind, LOCAL_BIND);\n \n     return true;\n@@ -1776,11 +1818,11 @@ class CNetCleanup\n         // Close sockets\n         BOOST_FOREACH(CNode* pnode, vNodes)\n             if (pnode->hSocket != INVALID_SOCKET)\n-                closesocket(pnode->hSocket);\n-        BOOST_FOREACH(SOCKET hListenSocket, vhListenSocket)\n-            if (hListenSocket != INVALID_SOCKET)\n-                if (closesocket(hListenSocket) == SOCKET_ERROR)\n-                    LogPrintf(\"closesocket(hListenSocket) failed with error %s\\n\", NetworkErrorString(WSAGetLastError()));\n+                CloseSocket(pnode->hSocket);\n+        BOOST_FOREACH(ListenSocket& hListenSocket, vhListenSocket)\n+            if (hListenSocket.socket != INVALID_SOCKET)\n+                if (!CloseSocket(hListenSocket.socket))\n+                    LogPrintf(\"CloseSocket(hListenSocket) failed with error %s\\n\", NetworkErrorString(WSAGetLastError()));\n \n         // clean up some globals (to help leak detection)\n         BOOST_FOREACH(CNode *pnode, vNodes)\n@@ -1789,6 +1831,7 @@ class CNetCleanup\n             delete pnode;\n         vNodes.clear();\n         vNodesDisconnected.clear();\n+        vhListenSocket.clear();\n         delete semOutbound;\n         semOutbound = NULL;\n         delete pnodeLocalHost;\n@@ -1808,17 +1851,17 @@ instance_of_cnetcleanup;\n \n \n \n-void RelayTransaction(const CTransaction& tx, const uint256& hash)\n+void RelayTransaction(const CTransaction& tx)\n {\n     CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n     ss.reserve(10000);\n     ss << tx;\n-    RelayTransaction(tx, hash, ss);\n+    RelayTransaction(tx, ss);\n }\n \n-void RelayTransaction(const CTransaction& tx, const uint256& hash, const CDataStream& ss)\n+void RelayTransaction(const CTransaction& tx, const CDataStream& ss)\n {\n-    CInv inv(MSG_TX, hash);\n+    CInv inv(MSG_TX, tx.GetHash());\n     {\n         LOCK(cs_mapRelay);\n         // Expire old relay messages\n@@ -1840,7 +1883,7 @@ void RelayTransaction(const CTransaction& tx, const uint256& hash, const CDataSt\n         LOCK(pnode->cs_filter);\n         if (pnode->pfilter)\n         {\n-            if (pnode->pfilter->IsRelevantAndUpdate(tx, hash))\n+            if (pnode->pfilter->IsRelevantAndUpdate(tx))\n                 pnode->PushInventory(inv);\n         } else\n             pnode->PushInventory(inv);\n@@ -1919,7 +1962,7 @@ bool CAddrDB::Write(const CAddrMan& addr)\n {\n     // Generate random temporary filename\n     unsigned short randv = 0;\n-    RAND_bytes((unsigned char *)&randv, sizeof(randv));\n+    GetRandBytes((unsigned char*)&randv, sizeof(randv));\n     std::string tmpfn = strprintf(\"peers.dat.%04x\", randv);\n \n     // serialize addresses, checksum data up to that point, then append csum"
      },
      {
        "sha": "2d9325abf98a65cb54e2a8e7346b3a6cafc2ee48",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 28,
        "deletions": 12,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -13,6 +13,7 @@\n #include \"mruset.h\"\n #include \"netbase.h\"\n #include \"protocol.h\"\n+#include \"random.h\"\n #include \"sync.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n@@ -26,16 +27,14 @@\n \n #include <boost/foreach.hpp>\n #include <boost/signals2/signal.hpp>\n-#include <openssl/rand.h>\n-\n \n class CAddrMan;\n class CBlockIndex;\n class CNode;\n \n namespace boost {\n     class thread_group;\n-}\n+} // namespace boost\n \n /** Time between pings automatically sent out for latency probing and keepalive (in seconds). */\n static const int PING_INTERVAL = 2 * 60;\n@@ -60,12 +59,13 @@ bool RecvLine(SOCKET hSocket, std::string& strLine);\n bool GetMyExternalIP(CNetAddr& ipRet);\n void AddressCurrentlyConnected(const CService& addr);\n CNode* FindNode(const CNetAddr& ip);\n+CNode* FindNode(const std::string& addrName);\n CNode* FindNode(const CService& ip);\n CNode* ConnectNode(CAddress addrConnect, const char *pszDest = NULL);\n bool OpenNetworkConnection(const CAddress& addrConnect, CSemaphoreGrant *grantOutbound = NULL, const char *strDest = NULL, bool fOneShot = false);\n void MapPort(bool fUseUPnP);\n unsigned short GetListenPort();\n-bool BindListenPort(const CService &bindAddr, std::string& strError);\n+bool BindListenPort(const CService &bindAddr, std::string& strError, bool fWhitelisted = false);\n void StartNode(boost::thread_group& threadGroup);\n bool StopNode();\n void SocketSendData(CNode *pnode);\n@@ -155,6 +155,7 @@ class CNodeStats\n     uint64_t nSendBytes;\n     uint64_t nRecvBytes;\n     bool fSyncNode;\n+    bool fWhitelisted;\n     double dPingTime;\n     double dPingWait;\n     std::string addrLocal;\n@@ -174,11 +175,14 @@ class CNetMessage {\n     CDataStream vRecv;              // received message data\n     unsigned int nDataPos;\n \n+    int64_t nTime;                  // time (in microseconds) of message receipt.\n+\n     CNetMessage(int nTypeIn, int nVersionIn) : hdrbuf(nTypeIn, nVersionIn), vRecv(nTypeIn, nVersionIn) {\n         hdrbuf.resize(24);\n         in_data = false;\n         nHdrPos = 0;\n         nDataPos = 0;\n+        nTime = 0;\n     }\n \n     bool complete() const\n@@ -234,6 +238,7 @@ class CNode\n     // store the sanitized version in cleanSubVer. The original should be used when dealing with\n     // the network or wire types and the cleaned string used when displayed or logged.\n     std::string strSubVer, cleanSubVer;\n+    bool fWhitelisted; // This peer can bypass DoS banning.\n     bool fOneShot;\n     bool fClient;\n     bool fInbound;\n@@ -257,6 +262,11 @@ class CNode\n     static std::map<CNetAddr, int64_t> setBanned;\n     static CCriticalSection cs_setBanned;\n \n+    // Whitelisted ranges. Any node connecting from these is automatically\n+    // whitelisted (as well as those connecting to whitelisted binds).\n+    static std::vector<CSubNet> vWhitelistedRange;\n+    static CCriticalSection cs_vWhitelistedRange;\n+\n     // Basic fuzz-testing\n     void Fuzz(int nChance); // modifies ssSend\n \n@@ -303,6 +313,7 @@ class CNode\n         addrName = addrNameIn == \"\" ? addr.ToStringIPPort() : addrNameIn;\n         nVersion = 0;\n         strSubVer = \"\";\n+        fWhitelisted = false;\n         fOneShot = false;\n         fClient = false; // set by version message\n         fInbound = fInboundIn;\n@@ -331,6 +342,11 @@ class CNode\n             id = nLastNodeId++;\n         }\n \n+        if (fLogIPs)\n+            LogPrint(\"net\", \"Added connection to %s peer=%d\\n\", addrName, id);\n+        else\n+            LogPrint(\"net\", \"Added connection peer=%d\\n\", id);\n+\n         // Be shy and don't send version until we hear\n         if (hSocket != INVALID_SOCKET && !fInbound)\n             PushVersion();\n@@ -342,8 +358,7 @@ class CNode\n     {\n         if (hSocket != INVALID_SOCKET)\n         {\n-            closesocket(hSocket);\n-            hSocket = INVALID_SOCKET;\n+            CloseSocket(hSocket);\n         }\n         if (pfilter)\n             delete pfilter;\n@@ -447,7 +462,7 @@ class CNode\n             nRequestTime = it->second;\n         else\n             nRequestTime = 0;\n-        LogPrint(\"net\", \"askfor %s   %d (%s)\\n\", inv.ToString(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000).c_str());\n+        LogPrint(\"net\", \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000).c_str(), id);\n \n         // Make sure not to reuse time indexes to keep things in the same order\n         int64_t nNow = GetTimeMicros() - 1000000;\n@@ -515,7 +530,7 @@ class CNode\n         assert(ssSend.size () >= CMessageHeader::CHECKSUM_OFFSET + sizeof(nChecksum));\n         memcpy((char*)&ssSend[CMessageHeader::CHECKSUM_OFFSET], &nChecksum, sizeof(nChecksum));\n \n-        LogPrint(\"net\", \"(%d bytes)\\n\", nSize);\n+        LogPrint(\"net\", \"(%d bytes) peer=%d\\n\", nSize, id);\n \n         std::deque<CSerializeData>::iterator it = vSendMsg.insert(vSendMsg.end(), CSerializeData());\n         ssSend.GetAndClear(*it);\n@@ -693,8 +708,6 @@ class CNode\n     void Subscribe(unsigned int nChannel, unsigned int nHops=0);\n     void CancelSubscribe(unsigned int nChannel);\n     void CloseSocketDisconnect();\n-    void Cleanup();\n-\n \n     // Denial-of-service detection/prevention\n     // The idea is to detect peers that are behaving\n@@ -715,6 +728,9 @@ class CNode\n     static bool Ban(const CNetAddr &ip);\n     void copyStats(CNodeStats &stats);\n \n+    static bool IsWhitelistedRange(const CNetAddr &ip);\n+    static void AddWhitelistedRange(const CSubNet &subnet);\n+\n     // Network stats\n     static void RecordBytesRecv(uint64_t bytes);\n     static void RecordBytesSent(uint64_t bytes);\n@@ -726,8 +742,8 @@ class CNode\n \n \n class CTransaction;\n-void RelayTransaction(const CTransaction& tx, const uint256& hash);\n-void RelayTransaction(const CTransaction& tx, const uint256& hash, const CDataStream& ss);\n+void RelayTransaction(const CTransaction& tx);\n+void RelayTransaction(const CTransaction& tx, const CDataStream& ss);\n \n /** Access to the (IP) address database (peers.dat) */\n class CAddrDB"
      },
      {
        "sha": "e9f3515456fc59fb480bf2e69430b4e0bb61b3d2",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 122,
        "deletions": 116,
        "changes": 238,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -3,6 +3,14 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#ifdef HAVE_CONFIG_H\n+#include \"bitcoin-config.h\"\n+#endif\n+\n+#ifdef HAVE_GETADDRINFO_A\n+#include <netdb.h>\n+#endif\n+\n #include \"netbase.h\"\n \n #include \"hash.h\"\n@@ -11,6 +19,9 @@\n #include \"util.h\"\n \n #ifndef WIN32\n+#if HAVE_INET_PTON\n+#include <arpa/inet.h>\n+#endif\n #include <fcntl.h>\n #endif\n \n@@ -25,7 +36,7 @@ using namespace std;\n \n // Settings\n static proxyType proxyInfo[NET_MAX];\n-static proxyType nameproxyInfo;\n+static CService nameProxy;\n static CCriticalSection cs_proxyInfos;\n int nConnectTimeout = 5000;\n bool fNameLookup = false;\n@@ -71,9 +82,30 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n         }\n     }\n \n+#ifdef HAVE_GETADDRINFO_A\n+    struct in_addr ipv4_addr;\n+#ifdef HAVE_INET_PTON\n+    if (inet_pton(AF_INET, pszName, &ipv4_addr) > 0) {\n+        vIP.push_back(CNetAddr(ipv4_addr));\n+        return true;\n+    }\n+\n+    struct in6_addr ipv6_addr;\n+    if (inet_pton(AF_INET6, pszName, &ipv6_addr) > 0) {\n+        vIP.push_back(CNetAddr(ipv6_addr));\n+        return true;\n+    }\n+#else\n+    ipv4_addr.s_addr = inet_addr(pszName);\n+    if (ipv4_addr.s_addr != INADDR_NONE) {\n+        vIP.push_back(CNetAddr(ipv4_addr));\n+        return true;\n+    }\n+#endif\n+#endif\n+\n     struct addrinfo aiHint;\n     memset(&aiHint, 0, sizeof(struct addrinfo));\n-\n     aiHint.ai_socktype = SOCK_STREAM;\n     aiHint.ai_protocol = IPPROTO_TCP;\n     aiHint.ai_family = AF_UNSPEC;\n@@ -82,8 +114,33 @@ bool static LookupIntern(const char *pszName, std::vector<CNetAddr>& vIP, unsign\n #else\n     aiHint.ai_flags = fAllowLookup ? AI_ADDRCONFIG : AI_NUMERICHOST;\n #endif\n+\n     struct addrinfo *aiRes = NULL;\n+#ifdef HAVE_GETADDRINFO_A\n+    struct gaicb gcb, *query = &gcb;\n+    memset(query, 0, sizeof(struct gaicb));\n+    gcb.ar_name = pszName;\n+    gcb.ar_request = &aiHint;\n+    int nErr = getaddrinfo_a(GAI_NOWAIT, &query, 1, NULL);\n+    if (nErr)\n+        return false;\n+\n+    do {\n+        // Should set the timeout limit to a resonable value to avoid\n+        // generating unnecessary checking call during the polling loop,\n+        // while it can still response to stop request quick enough.\n+        // 2 seconds looks fine in our situation.\n+        struct timespec ts = { 2, 0 };\n+        gai_suspend(&query, 1, &ts);\n+        boost::this_thread::interruption_point();\n+\n+        nErr = gai_error(query);\n+        if (0 == nErr)\n+            aiRes = query->ar_result;\n+    } while (nErr == EAI_INPROGRESS);\n+#else\n     int nErr = getaddrinfo(pszName, NULL, &aiHint, &aiRes);\n+#endif\n     if (nErr)\n         return false;\n \n@@ -156,56 +213,12 @@ bool LookupNumeric(const char *pszName, CService& addr, int portDefault)\n     return Lookup(pszName, addr, portDefault, false);\n }\n \n-bool static Socks4(const CService &addrDest, SOCKET& hSocket)\n-{\n-    LogPrintf(\"SOCKS4 connecting %s\\n\", addrDest.ToString());\n-    if (!addrDest.IsIPv4())\n-    {\n-        closesocket(hSocket);\n-        return error(\"Proxy destination is not IPv4\");\n-    }\n-    char pszSocks4IP[] = \"\\4\\1\\0\\0\\0\\0\\0\\0user\";\n-    struct sockaddr_in addr;\n-    socklen_t len = sizeof(addr);\n-    if (!addrDest.GetSockAddr((struct sockaddr*)&addr, &len) || addr.sin_family != AF_INET)\n-    {\n-        closesocket(hSocket);\n-        return error(\"Cannot get proxy destination address\");\n-    }\n-    memcpy(pszSocks4IP + 2, &addr.sin_port, 2);\n-    memcpy(pszSocks4IP + 4, &addr.sin_addr, 4);\n-    char* pszSocks4 = pszSocks4IP;\n-    int nSize = sizeof(pszSocks4IP);\n-\n-    int ret = send(hSocket, pszSocks4, nSize, MSG_NOSIGNAL);\n-    if (ret != nSize)\n-    {\n-        closesocket(hSocket);\n-        return error(\"Error sending to proxy\");\n-    }\n-    char pchRet[8];\n-    if (recv(hSocket, pchRet, 8, 0) != 8)\n-    {\n-        closesocket(hSocket);\n-        return error(\"Error reading proxy response\");\n-    }\n-    if (pchRet[1] != 0x5a)\n-    {\n-        closesocket(hSocket);\n-        if (pchRet[1] != 0x5b)\n-            LogPrintf(\"ERROR: Proxy returned error %d\\n\", pchRet[1]);\n-        return false;\n-    }\n-    LogPrintf(\"SOCKS4 connected %s\\n\", addrDest.ToString());\n-    return true;\n-}\n-\n bool static Socks5(string strDest, int port, SOCKET& hSocket)\n {\n     LogPrintf(\"SOCKS5 connecting %s\\n\", strDest);\n     if (strDest.size() > 255)\n     {\n-        closesocket(hSocket);\n+        CloseSocket(hSocket);\n         return error(\"Hostname too long\");\n     }\n     char pszSocks5Init[] = \"\\5\\1\\0\";\n@@ -214,18 +227,18 @@ bool static Socks5(string strDest, int port, SOCKET& hSocket)\n     ssize_t ret = send(hSocket, pszSocks5Init, nSize, MSG_NOSIGNAL);\n     if (ret != nSize)\n     {\n-        closesocket(hSocket);\n+        CloseSocket(hSocket);\n         return error(\"Error sending to proxy\");\n     }\n     char pchRet1[2];\n     if (recv(hSocket, pchRet1, 2, 0) != 2)\n     {\n-        closesocket(hSocket);\n+        CloseSocket(hSocket);\n         return error(\"Error reading proxy response\");\n     }\n     if (pchRet1[0] != 0x05 || pchRet1[1] != 0x00)\n     {\n-        closesocket(hSocket);\n+        CloseSocket(hSocket);\n         return error(\"Proxy failed to initialize\");\n     }\n     string strSocks5(\"\\5\\1\");\n@@ -237,23 +250,23 @@ bool static Socks5(string strDest, int port, SOCKET& hSocket)\n     ret = send(hSocket, strSocks5.c_str(), strSocks5.size(), MSG_NOSIGNAL);\n     if (ret != (ssize_t)strSocks5.size())\n     {\n-        closesocket(hSocket);\n+        CloseSocket(hSocket);\n         return error(\"Error sending to proxy\");\n     }\n     char pchRet2[4];\n     if (recv(hSocket, pchRet2, 4, 0) != 4)\n     {\n-        closesocket(hSocket);\n+        CloseSocket(hSocket);\n         return error(\"Error reading proxy response\");\n     }\n     if (pchRet2[0] != 0x05)\n     {\n-        closesocket(hSocket);\n+        CloseSocket(hSocket);\n         return error(\"Proxy failed to accept request\");\n     }\n     if (pchRet2[1] != 0x00)\n     {\n-        closesocket(hSocket);\n+        CloseSocket(hSocket);\n         switch (pchRet2[1])\n         {\n             case 0x01: return error(\"Proxy error: general failure\");\n@@ -269,7 +282,7 @@ bool static Socks5(string strDest, int port, SOCKET& hSocket)\n     }\n     if (pchRet2[2] != 0x00)\n     {\n-        closesocket(hSocket);\n+        CloseSocket(hSocket);\n         return error(\"Error: malformed proxy response\");\n     }\n     char pchRet3[256];\n@@ -281,23 +294,23 @@ bool static Socks5(string strDest, int port, SOCKET& hSocket)\n         {\n             ret = recv(hSocket, pchRet3, 1, 0) != 1;\n             if (ret) {\n-                closesocket(hSocket);\n+                CloseSocket(hSocket);\n                 return error(\"Error reading from proxy\");\n             }\n             int nRecv = pchRet3[0];\n             ret = recv(hSocket, pchRet3, nRecv, 0) != nRecv;\n             break;\n         }\n-        default: closesocket(hSocket); return error(\"Error: malformed proxy response\");\n+        default: CloseSocket(hSocket); return error(\"Error: malformed proxy response\");\n     }\n     if (ret)\n     {\n-        closesocket(hSocket);\n+        CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }\n     if (recv(hSocket, pchRet3, 2, 0) != 2)\n     {\n-        closesocket(hSocket);\n+        CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }\n     LogPrintf(\"SOCKS5 connected %s\\n\", strDest);\n@@ -331,14 +344,15 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     if (fcntl(hSocket, F_SETFL, fFlags | O_NONBLOCK) == -1)\n #endif\n     {\n-        closesocket(hSocket);\n+        CloseSocket(hSocket);\n         return false;\n     }\n \n     if (connect(hSocket, (struct sockaddr*)&sockaddr, len) == SOCKET_ERROR)\n     {\n+        int nErr = WSAGetLastError();\n         // WSAEINVAL is here because some legacy version of winsock uses it\n-        if (WSAGetLastError() == WSAEINPROGRESS || WSAGetLastError() == WSAEWOULDBLOCK || WSAGetLastError() == WSAEINVAL)\n+        if (nErr == WSAEINPROGRESS || nErr == WSAEWOULDBLOCK || nErr == WSAEINVAL)\n         {\n             struct timeval timeout;\n             timeout.tv_sec  = nTimeout / 1000;\n@@ -351,13 +365,13 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n             if (nRet == 0)\n             {\n                 LogPrint(\"net\", \"connection to %s timeout\\n\", addrConnect.ToString());\n-                closesocket(hSocket);\n+                CloseSocket(hSocket);\n                 return false;\n             }\n             if (nRet == SOCKET_ERROR)\n             {\n                 LogPrintf(\"select() for %s failed: %s\\n\", addrConnect.ToString(), NetworkErrorString(WSAGetLastError()));\n-                closesocket(hSocket);\n+                CloseSocket(hSocket);\n                 return false;\n             }\n             socklen_t nRetSize = sizeof(nRet);\n@@ -368,13 +382,13 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n #endif\n             {\n                 LogPrintf(\"getsockopt() for %s failed: %s\\n\", addrConnect.ToString(), NetworkErrorString(WSAGetLastError()));\n-                closesocket(hSocket);\n+                CloseSocket(hSocket);\n                 return false;\n             }\n             if (nRet != 0)\n             {\n                 LogPrintf(\"connect() to %s failed after select(): %s\\n\", addrConnect.ToString(), NetworkErrorString(nRet));\n-                closesocket(hSocket);\n+                CloseSocket(hSocket);\n                 return false;\n             }\n         }\n@@ -385,7 +399,7 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n #endif\n         {\n             LogPrintf(\"connect() to %s failed: %s\\n\", addrConnect.ToString(), NetworkErrorString(WSAGetLastError()));\n-            closesocket(hSocket);\n+            CloseSocket(hSocket);\n             return false;\n         }\n     }\n@@ -401,61 +415,57 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n     if (fcntl(hSocket, F_SETFL, fFlags & ~O_NONBLOCK) == SOCKET_ERROR)\n #endif\n     {\n-        closesocket(hSocket);\n+        CloseSocket(hSocket);\n         return false;\n     }\n \n     hSocketRet = hSocket;\n     return true;\n }\n \n-bool SetProxy(enum Network net, CService addrProxy, int nSocksVersion) {\n+bool SetProxy(enum Network net, CService addrProxy) {\n     assert(net >= 0 && net < NET_MAX);\n-    if (nSocksVersion != 0 && nSocksVersion != 4 && nSocksVersion != 5)\n-        return false;\n-    if (nSocksVersion != 0 && !addrProxy.IsValid())\n+    if (!addrProxy.IsValid())\n         return false;\n     LOCK(cs_proxyInfos);\n-    proxyInfo[net] = std::make_pair(addrProxy, nSocksVersion);\n+    proxyInfo[net] = addrProxy;\n     return true;\n }\n \n bool GetProxy(enum Network net, proxyType &proxyInfoOut) {\n     assert(net >= 0 && net < NET_MAX);\n     LOCK(cs_proxyInfos);\n-    if (!proxyInfo[net].second)\n+    if (!proxyInfo[net].IsValid())\n         return false;\n     proxyInfoOut = proxyInfo[net];\n     return true;\n }\n \n-bool SetNameProxy(CService addrProxy, int nSocksVersion) {\n-    if (nSocksVersion != 0 && nSocksVersion != 5)\n-        return false;\n-    if (nSocksVersion != 0 && !addrProxy.IsValid())\n+bool SetNameProxy(CService addrProxy) {\n+    if (!addrProxy.IsValid())\n         return false;\n     LOCK(cs_proxyInfos);\n-    nameproxyInfo = std::make_pair(addrProxy, nSocksVersion);\n+    nameProxy = addrProxy;\n     return true;\n }\n \n-bool GetNameProxy(proxyType &nameproxyInfoOut) {\n+bool GetNameProxy(CService &nameProxyOut) {\n     LOCK(cs_proxyInfos);\n-    if (!nameproxyInfo.second)\n+    if(!nameProxy.IsValid())\n         return false;\n-    nameproxyInfoOut = nameproxyInfo;\n+    nameProxyOut = nameProxy;\n     return true;\n }\n \n bool HaveNameProxy() {\n     LOCK(cs_proxyInfos);\n-    return nameproxyInfo.second != 0;\n+    return nameProxy.IsValid();\n }\n \n bool IsProxy(const CNetAddr &addr) {\n     LOCK(cs_proxyInfos);\n     for (int i = 0; i < NET_MAX; i++) {\n-        if (proxyInfo[i].second && (addr == (CNetAddr)proxyInfo[i].first))\n+        if (addr == (CNetAddr)proxyInfo[i])\n             return true;\n     }\n     return false;\n@@ -464,31 +474,18 @@ bool IsProxy(const CNetAddr &addr) {\n bool ConnectSocket(const CService &addrDest, SOCKET& hSocketRet, int nTimeout)\n {\n     proxyType proxy;\n-\n-    // no proxy needed\n+    // no proxy needed (none set for target network)\n     if (!GetProxy(addrDest.GetNetwork(), proxy))\n         return ConnectSocketDirectly(addrDest, hSocketRet, nTimeout);\n \n     SOCKET hSocket = INVALID_SOCKET;\n \n     // first connect to proxy server\n-    if (!ConnectSocketDirectly(proxy.first, hSocket, nTimeout))\n+    if (!ConnectSocketDirectly(proxy, hSocket, nTimeout))\n         return false;\n-\n     // do socks negotiation\n-    switch (proxy.second) {\n-    case 4:\n-        if (!Socks4(addrDest, hSocket))\n-            return false;\n-        break;\n-    case 5:\n-        if (!Socks5(addrDest.ToStringIP(), addrDest.GetPort(), hSocket))\n-            return false;\n-        break;\n-    default:\n-        closesocket(hSocket);\n+    if (!Socks5(addrDest.ToStringIP(), addrDest.GetPort(), hSocket))\n         return false;\n-    }\n \n     hSocketRet = hSocket;\n     return true;\n@@ -502,30 +499,25 @@ bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest\n \n     SOCKET hSocket = INVALID_SOCKET;\n \n-    proxyType nameproxy;\n-    GetNameProxy(nameproxy);\n+    CService nameProxy;\n+    GetNameProxy(nameProxy);\n \n-    CService addrResolved(CNetAddr(strDest, fNameLookup && !nameproxy.second), port);\n+    CService addrResolved(CNetAddr(strDest, fNameLookup && !HaveNameProxy()), port);\n     if (addrResolved.IsValid()) {\n         addr = addrResolved;\n         return ConnectSocket(addr, hSocketRet, nTimeout);\n     }\n+\n     addr = CService(\"0.0.0.0:0\");\n-    if (!nameproxy.second)\n+\n+    if (!HaveNameProxy())\n         return false;\n-    if (!ConnectSocketDirectly(nameproxy.first, hSocket, nTimeout))\n+    // first connect to name proxy server\n+    if (!ConnectSocketDirectly(nameProxy, hSocket, nTimeout))\n+        return false;\n+    // do socks negotiation\n+    if (!Socks5(strDest, (unsigned short)port, hSocket))\n         return false;\n-\n-    switch(nameproxy.second) {\n-        default:\n-        case 4:\n-            closesocket(hSocket);\n-            return false;\n-        case 5:\n-            if (!Socks5(strDest, port, hSocket))\n-                return false;\n-            break;\n-    }\n \n     hSocketRet = hSocket;\n     return true;\n@@ -1260,8 +1252,22 @@ std::string NetworkErrorString(int err)\n #ifdef STRERROR_R_CHAR_P /* GNU variant can return a pointer outside the passed buffer */\n     s = strerror_r(err, buf, sizeof(buf));\n #else /* POSIX variant always returns message in buffer */\n-    (void) strerror_r(err, buf, sizeof(buf));\n+    if (strerror_r(err, buf, sizeof(buf)))\n+        buf[0] = 0;\n #endif\n     return strprintf(\"%s (%d)\", s, err);\n }\n #endif\n+\n+bool CloseSocket(SOCKET& hSocket)\n+{\n+    if (hSocket == INVALID_SOCKET)\n+        return false;\n+#ifdef WIN32\n+    int ret = closesocket(hSocket);\n+#else\n+    int ret = close(hSocket);\n+#endif\n+    hSocket = INVALID_SOCKET;\n+    return ret != SOCKET_ERROR;\n+}"
      },
      {
        "sha": "05221a5fde842ebdcdaf52b6b0b0b9272a4d6b5a",
        "filename": "src/netbase.h",
        "status": "modified",
        "additions": 6,
        "deletions": 4,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/netbase.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/netbase.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -6,7 +6,7 @@\n #define BITCOIN_NETBASE_H\n \n #if defined(HAVE_CONFIG_H)\n-#include \"bitcoin-config.h\"\n+#include \"config/bitcoin-config.h\"\n #endif\n \n #include \"compat.h\"\n@@ -161,14 +161,14 @@ class CService : public CNetAddr\n             )\n };\n \n-typedef std::pair<CService, int> proxyType;\n+typedef CService proxyType;\n \n enum Network ParseNetwork(std::string net);\n void SplitHostPort(std::string in, int &portOut, std::string &hostOut);\n-bool SetProxy(enum Network net, CService addrProxy, int nSocksVersion = 5);\n+bool SetProxy(enum Network net, CService addrProxy);\n bool GetProxy(enum Network net, proxyType &proxyInfoOut);\n bool IsProxy(const CNetAddr &addr);\n-bool SetNameProxy(CService addrProxy, int nSocksVersion = 5);\n+bool SetNameProxy(CService addrProxy);\n bool HaveNameProxy();\n bool LookupHost(const char *pszName, std::vector<CNetAddr>& vIP, unsigned int nMaxSolutions = 0, bool fAllowLookup = true);\n bool Lookup(const char *pszName, CService& addr, int portDefault = 0, bool fAllowLookup = true);\n@@ -178,5 +178,7 @@ bool ConnectSocket(const CService &addr, SOCKET& hSocketRet, int nTimeout = nCon\n bool ConnectSocketByName(CService &addr, SOCKET& hSocketRet, const char *pszDest, int portDefault = 0, int nTimeout = nConnectTimeout);\n /** Return readable error string for a network error code */\n std::string NetworkErrorString(int err);\n+/** Close socket and set hSocket to INVALID_SOCKET */\n+bool CloseSocket(SOCKET& hSocket);\n \n #endif"
      },
      {
        "sha": "c0d0a7ca20f26cc1ec5214c0b64e0557b4602c1e",
        "filename": "src/pow.cpp",
        "status": "added",
        "additions": 119,
        "deletions": 0,
        "changes": 119,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/pow.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/pow.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,119 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"pow.h\"\n+\n+#include \"chainparams.h\"\n+#include \"core.h\"\n+#include \"main.h\"\n+#include \"uint256.h\"\n+\n+unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock)\n+{\n+    unsigned int nProofOfWorkLimit = Params().ProofOfWorkLimit().GetCompact();\n+\n+    // Genesis block\n+    if (pindexLast == NULL)\n+        return nProofOfWorkLimit;\n+\n+    // Only change once per interval\n+    if ((pindexLast->nHeight+1) % Params().Interval() != 0)\n+    {\n+        if (Params().AllowMinDifficultyBlocks())\n+        {\n+            // Special difficulty rule for testnet:\n+            // If the new block's timestamp is more than 2* 10 minutes\n+            // then allow mining of a min-difficulty block.\n+            if (pblock->GetBlockTime() > pindexLast->GetBlockTime() + Params().TargetSpacing()*2)\n+                return nProofOfWorkLimit;\n+            else\n+            {\n+                // Return the last non-special-min-difficulty-rules-block\n+                const CBlockIndex* pindex = pindexLast;\n+                while (pindex->pprev && pindex->nHeight % Params().Interval() != 0 && pindex->nBits == nProofOfWorkLimit)\n+                    pindex = pindex->pprev;\n+                return pindex->nBits;\n+            }\n+        }\n+        return pindexLast->nBits;\n+    }\n+\n+    // Go back by what we want to be 14 days worth of blocks\n+    const CBlockIndex* pindexFirst = pindexLast;\n+    for (int i = 0; pindexFirst && i < Params().Interval()-1; i++)\n+        pindexFirst = pindexFirst->pprev;\n+    assert(pindexFirst);\n+\n+    // Limit adjustment step\n+    int64_t nActualTimespan = pindexLast->GetBlockTime() - pindexFirst->GetBlockTime();\n+    LogPrintf(\"  nActualTimespan = %d  before bounds\\n\", nActualTimespan);\n+    if (nActualTimespan < Params().TargetTimespan()/4)\n+        nActualTimespan = Params().TargetTimespan()/4;\n+    if (nActualTimespan > Params().TargetTimespan()*4)\n+        nActualTimespan = Params().TargetTimespan()*4;\n+\n+    // Retarget\n+    uint256 bnNew;\n+    uint256 bnOld;\n+    bnNew.SetCompact(pindexLast->nBits);\n+    bnOld = bnNew;\n+    bnNew *= nActualTimespan;\n+    bnNew /= Params().TargetTimespan();\n+\n+    if (bnNew > Params().ProofOfWorkLimit())\n+        bnNew = Params().ProofOfWorkLimit();\n+\n+    /// debug print\n+    LogPrintf(\"GetNextWorkRequired RETARGET\\n\");\n+    LogPrintf(\"Params().TargetTimespan() = %d    nActualTimespan = %d\\n\", Params().TargetTimespan(), nActualTimespan);\n+    LogPrintf(\"Before: %08x  %s\\n\", pindexLast->nBits, bnOld.ToString());\n+    LogPrintf(\"After:  %08x  %s\\n\", bnNew.GetCompact(), bnNew.ToString());\n+\n+    return bnNew.GetCompact();\n+}\n+\n+bool CheckProofOfWork(uint256 hash, unsigned int nBits)\n+{\n+    bool fNegative;\n+    bool fOverflow;\n+    uint256 bnTarget;\n+    bnTarget.SetCompact(nBits, &fNegative, &fOverflow);\n+\n+    // Check range\n+    if (fNegative || bnTarget == 0 || fOverflow || bnTarget > Params().ProofOfWorkLimit())\n+        return error(\"CheckProofOfWork() : nBits below minimum work\");\n+\n+    // Check proof of work matches claimed amount\n+    if (hash > bnTarget)\n+        return error(\"CheckProofOfWork() : hash doesn't match nBits\");\n+\n+    return true;\n+}\n+\n+//\n+// minimum amount of work that could possibly be required nTime after\n+// minimum work required was nBase\n+//\n+unsigned int ComputeMinWork(unsigned int nBase, int64_t nTime)\n+{\n+    const uint256 &bnLimit = Params().ProofOfWorkLimit();\n+    // Testnet has min-difficulty blocks\n+    // after Params().TargetSpacing()*2 time between blocks:\n+    if (Params().AllowMinDifficultyBlocks() && nTime > Params().TargetSpacing()*2)\n+        return bnLimit.GetCompact();\n+\n+    uint256 bnResult;\n+    bnResult.SetCompact(nBase);\n+    while (nTime > 0 && bnResult < bnLimit)\n+    {\n+        // Maximum 400% adjustment...\n+        bnResult *= 4;\n+        // ... in best-case exactly 4-times-normal target time\n+        nTime -= Params().TargetTimespan()*4;\n+    }\n+    if (bnResult > bnLimit)\n+        bnResult = bnLimit;\n+    return bnResult.GetCompact();\n+}"
      },
      {
        "sha": "0ce5b48766a8d5018fb4b968398332f6d4301f0a",
        "filename": "src/pow.h",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/pow.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/pow.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,23 @@\n+\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_POW_H\n+#define BITCOIN_POW_H\n+\n+#include <stdint.h>\n+\n+class CBlockIndex;\n+class CBlockHeader;\n+class uint256;\n+\n+unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock);\n+\n+/** Check whether a block hash satisfies the proof-of-work requirement specified by nBits */\n+bool CheckProofOfWork(uint256 hash, unsigned int nBits);\n+/** Calculate the minimum amount of work a received block needs, without knowing its direct parent */\n+unsigned int ComputeMinWork(unsigned int nBase, int64_t nTime);\n+\n+#endif"
      },
      {
        "sha": "1f23274299b7f35832b7dc9a7fe8723aec3d5d86",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -64,6 +64,14 @@ class CMessageHeader\n enum\n {\n     NODE_NETWORK = (1 << 0),\n+\n+    // Bits 24-31 are reserved for temporary experiments. Just pick a bit that\n+    // isn't getting used, or one not being used much, and notify the\n+    // bitcoin-development mailing list. Remember that service bits are just\n+    // unauthenticated advertisements, so your code must be robust against\n+    // collisions and other cases where nodes may be advertising a service they\n+    // do not actually support. Other service bits should be allocated via the\n+    // BIP process.\n };\n \n /** A CService with information about it as peer */"
      },
      {
        "sha": "f336d47e83eca81aababc4881270eb23d4e6ca90",
        "filename": "src/qt/addressbookpage.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/addressbookpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/addressbookpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #if defined(HAVE_CONFIG_H)\n-#include \"bitcoin-config.h\"\n+#include \"config/bitcoin-config.h\"\n #endif\n \n #include \"addressbookpage.h\"\n@@ -282,7 +282,7 @@ void AddressBookPage::on_exportButton_clicked()\n \n     if(!writer.write()) {\n         QMessageBox::critical(this, tr(\"Exporting Failed\"),\n-            tr(\"There was an error trying to save the address list to %1.\").arg(filename));\n+            tr(\"There was an error trying to save the address list to %1. Please try again.\").arg(filename));\n     }\n }\n "
      },
      {
        "sha": "8d5284d5e9ff8d9264d5edc6f5cc2f92da0b6d7e",
        "filename": "src/qt/addresstablemodel.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/addresstablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/addresstablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addresstablemodel.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -114,7 +114,7 @@ class AddressTablePriv\n         case CT_NEW:\n             if(inModel)\n             {\n-                qDebug() << \"AddressTablePriv::updateEntry : Warning: Got CT_NEW, but entry is already in model\";\n+                qWarning() << \"AddressTablePriv::updateEntry : Warning: Got CT_NEW, but entry is already in model\";\n                 break;\n             }\n             parent->beginInsertRows(QModelIndex(), lowerIndex, lowerIndex);\n@@ -124,7 +124,7 @@ class AddressTablePriv\n         case CT_UPDATED:\n             if(!inModel)\n             {\n-                qDebug() << \"AddressTablePriv::updateEntry : Warning: Got CT_UPDATED, but entry is not in model\";\n+                qWarning() << \"AddressTablePriv::updateEntry : Warning: Got CT_UPDATED, but entry is not in model\";\n                 break;\n             }\n             lower->type = newEntryType;\n@@ -134,7 +134,7 @@ class AddressTablePriv\n         case CT_DELETED:\n             if(!inModel)\n             {\n-                qDebug() << \"AddressTablePriv::updateEntry : Warning: Got CT_DELETED, but entry is not in model\";\n+                qWarning() << \"AddressTablePriv::updateEntry : Warning: Got CT_DELETED, but entry is not in model\";\n                 break;\n             }\n             parent->beginRemoveRows(QModelIndex(), lowerIndex, upperIndex-1);"
      },
      {
        "sha": "a448d5a9a051311993c2f1be0b42b2f3f2f90d5c",
        "filename": "src/qt/askpassphrasedialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/askpassphrasedialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/askpassphrasedialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/askpassphrasedialog.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -37,7 +37,7 @@ AskPassphraseDialog::AskPassphraseDialog(Mode mode, QWidget *parent) :\n         case Encrypt: // Ask passphrase x2\n             ui->passLabel1->hide();\n             ui->passEdit1->hide();\n-            ui->warningLabel->setText(tr(\"Enter the new passphrase to the wallet.<br/>Please use a passphrase of <b>10 or more random characters</b>, or <b>eight or more words</b>.\"));\n+            ui->warningLabel->setText(tr(\"Enter the new passphrase to the wallet.<br/>Please use a passphrase of <b>ten or more random characters</b>, or <b>eight or more words</b>.\"));\n             setWindowTitle(tr(\"Encrypt wallet\"));\n             break;\n         case Unlock: // Ask passphrase"
      },
      {
        "sha": "7bf531f53805832f38fc8d19d46ea570243af040",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 20,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #if defined(HAVE_CONFIG_H)\n-#include \"bitcoin-config.h\"\n+#include \"config/bitcoin-config.h\"\n #endif\n \n #include \"bitcoingui.h\"\n@@ -34,6 +34,7 @@\n \n #include <boost/filesystem/operations.hpp>\n #include <QApplication>\n+#include <QDebug>\n #include <QLibraryInfo>\n #include <QLocale>\n #include <QMessageBox>\n@@ -52,7 +53,13 @@ Q_IMPORT_PLUGIN(qkrcodecs)\n Q_IMPORT_PLUGIN(qtaccessiblewidgets)\n #else\n Q_IMPORT_PLUGIN(AccessibleFactory)\n+#if defined(QT_QPA_PLATFORM_XCB)\n+Q_IMPORT_PLUGIN(QXcbIntegrationPlugin);\n+#elif defined(QT_QPA_PLATFORM_WINDOWS)\n Q_IMPORT_PLUGIN(QWindowsIntegrationPlugin);\n+#elif defined(QT_QPA_PLATFORM_COCOA)\n+Q_IMPORT_PLUGIN(QCocoaIntegrationPlugin);\n+#endif\n #endif\n #endif\n \n@@ -126,15 +133,15 @@ static void initTranslations(QTranslator &qtTranslatorBase, QTranslator &qtTrans\n #if QT_VERSION < 0x050000\n void DebugMessageHandler(QtMsgType type, const char *msg)\n {\n-    Q_UNUSED(type);\n-    LogPrint(\"qt\", \"GUI: %s\\n\", msg);\n+    const char *category = (type == QtDebugMsg) ? \"qt\" : NULL;\n+    LogPrint(category, \"GUI: %s\\n\", msg);\n }\n #else\n void DebugMessageHandler(QtMsgType type, const QMessageLogContext& context, const QString &msg)\n {\n-    Q_UNUSED(type);\n     Q_UNUSED(context);\n-    LogPrint(\"qt\", \"GUI: %s\\n\", qPrintable(msg));\n+    const char *category = (type == QtDebugMsg) ? \"qt\" : NULL;\n+    LogPrint(category, \"GUI: %s\\n\", msg.toStdString());\n }\n #endif\n \n@@ -237,7 +244,7 @@ void BitcoinCore::initialize()\n {\n     try\n     {\n-        LogPrintf(\"Running AppInit2 in thread\\n\");\n+        qDebug() << __func__ << \": Running AppInit2 in thread\";\n         int rv = AppInit2(threadGroup);\n         if(rv)\n         {\n@@ -258,11 +265,11 @@ void BitcoinCore::shutdown()\n {\n     try\n     {\n-        LogPrintf(\"Running Shutdown in thread\\n\");\n+        qDebug() << __func__ << \": Running Shutdown in thread\";\n         threadGroup.interrupt_all();\n         threadGroup.join_all();\n         Shutdown();\n-        LogPrintf(\"Shutdown finished\\n\");\n+        qDebug() << __func__ << \": Shutdown finished\";\n         emit shutdownResult(1);\n     } catch (std::exception& e) {\n         handleRunawayException(&e);\n@@ -285,15 +292,17 @@ BitcoinApplication::BitcoinApplication(int &argc, char **argv):\n     returnValue(0)\n {\n     setQuitOnLastWindowClosed(false);\n-    startThread();\n }\n \n BitcoinApplication::~BitcoinApplication()\n {\n-    LogPrintf(\"Stopping thread\\n\");\n-    emit stopThread();\n-    coreThread->wait();\n-    LogPrintf(\"Stopped thread\\n\");\n+    if(coreThread)\n+    {\n+        qDebug() << __func__ << \": Stopping thread\";\n+        emit stopThread();\n+        coreThread->wait();\n+        qDebug() << __func__ << \": Stopped thread\";\n+    }\n \n     delete window;\n     window = 0;\n@@ -336,6 +345,8 @@ void BitcoinApplication::createSplashScreen(bool isaTestNet)\n \n void BitcoinApplication::startThread()\n {\n+    if(coreThread)\n+        return;\n     coreThread = new QThread(this);\n     BitcoinCore *executor = new BitcoinCore();\n     executor->moveToThread(coreThread);\n@@ -355,13 +366,15 @@ void BitcoinApplication::startThread()\n \n void BitcoinApplication::requestInitialize()\n {\n-    LogPrintf(\"Requesting initialize\\n\");\n+    qDebug() << __func__ << \": Requesting initialize\";\n+    startThread();\n     emit requestedInitialize();\n }\n \n void BitcoinApplication::requestShutdown()\n {\n-    LogPrintf(\"Requesting shutdown\\n\");\n+    qDebug() << __func__ << \": Requesting shutdown\";\n+    startThread();\n     window->hide();\n     window->setClientModel(0);\n     pollShutdownTimer->stop();\n@@ -383,7 +396,7 @@ void BitcoinApplication::requestShutdown()\n \n void BitcoinApplication::initializeResult(int retval)\n {\n-    LogPrintf(\"Initialization result: %i\\n\", retval);\n+    qDebug() << __func__ << \": Initialization result: \" << retval;\n     // Set exit result: 0 if successful, 1 if failure\n     returnValue = retval ? 0 : 1;\n     if(retval)\n@@ -393,8 +406,6 @@ void BitcoinApplication::initializeResult(int retval)\n         paymentServer->setOptionsModel(optionsModel);\n #endif\n \n-        emit splashFinished(window);\n-\n         clientModel = new ClientModel(optionsModel);\n         window->setClientModel(clientModel);\n \n@@ -411,6 +422,8 @@ void BitcoinApplication::initializeResult(int retval)\n         }\n #endif\n \n+        emit splashFinished(window);\n+\n         // If -min option passed, start window minimized.\n         if(GetBoolArg(\"-min\", false))\n         {\n@@ -438,7 +451,7 @@ void BitcoinApplication::initializeResult(int retval)\n \n void BitcoinApplication::shutdownResult(int retval)\n {\n-    LogPrintf(\"Shutdown result: %i\\n\", retval);\n+    qDebug() << __func__ << \": Shutdown result: \" << retval;\n     quit(); // Exit main loop after shutdown finished\n }\n \n@@ -546,7 +559,7 @@ int main(int argc, char *argv[])\n     if (!PaymentServer::ipcParseCommandLine(argc, argv))\n         exit(0);\n #endif\n-    bool isaTestNet = Params().NetworkID() != CChainParams::MAIN;\n+    bool isaTestNet = Params().NetworkID() != CBaseChainParams::MAIN;\n     // Allow for separate UI settings for testnets\n     if (isaTestNet)\n         QApplication::setApplicationName(QAPP_APP_NAME_TESTNET);"
      },
      {
        "sha": "357c6470d3b53bd436ee6d2be09c87796b8c126c",
        "filename": "src/qt/bitcoin.qrc",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoin.qrc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoin.qrc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.qrc?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -35,6 +35,9 @@\n         <file alias=\"tx_input\">res/icons/tx_input.png</file>\n         <file alias=\"tx_output\">res/icons/tx_output.png</file>\n         <file alias=\"tx_inout\">res/icons/tx_inout.png</file>\n+        <file alias=\"unit_btc\">res/icons/unit_btc.png</file>\n+        <file alias=\"unit_mbtc\">res/icons/unit_mbtc.png</file>\n+        <file alias=\"unit_ubtc\">res/icons/unit_ubtc.png</file>\n         <file alias=\"lock_closed\">res/icons/lock_closed.png</file>\n         <file alias=\"lock_open\">res/icons/lock_open.png</file>\n         <file alias=\"key\">res/icons/key.png</file>"
      },
      {
        "sha": "64660390132e43a5da6a47dd1f6c12d9eb10256d",
        "filename": "src/qt/bitcoinamountfield.cpp",
        "status": "modified",
        "additions": 181,
        "deletions": 76,
        "changes": 257,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoinamountfield.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoinamountfield.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinamountfield.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -9,19 +9,186 @@\n #include \"qvaluecombobox.h\"\n \n #include <QApplication>\n-#include <QDoubleSpinBox>\n+#include <QAbstractSpinBox>\n #include <QHBoxLayout>\n #include <QKeyEvent>\n-#include <qmath.h> // for qPow()\n+#include <QLineEdit>\n+\n+/** QSpinBox that uses fixed-point numbers internally and uses our own\n+ * formatting/parsing functions.\n+ */\n+class AmountSpinBox: public QAbstractSpinBox\n+{\n+    Q_OBJECT\n+public:\n+    explicit AmountSpinBox(QWidget *parent):\n+        QAbstractSpinBox(parent),\n+        currentUnit(BitcoinUnits::BTC),\n+        singleStep(100000) // satoshis\n+    {\n+        setAlignment(Qt::AlignRight);\n+\n+        connect(lineEdit(), SIGNAL(textEdited(QString)), this, SIGNAL(valueChanged()));\n+    }\n+\n+    QValidator::State validate(QString &text, int &pos) const\n+    {\n+        if(text.isEmpty())\n+            return QValidator::Intermediate;\n+        bool valid = false;\n+        parse(text, &valid);\n+        /* Make sure we return Intermediate so that fixup() is called on defocus */\n+        return valid ? QValidator::Intermediate : QValidator::Invalid;\n+    }\n+\n+    void fixup(QString &input) const\n+    {\n+        bool valid = false;\n+        qint64 val = parse(input, &valid);\n+        if(valid)\n+        {\n+            input = BitcoinUnits::format(currentUnit, val, false, BitcoinUnits::separatorAlways);\n+            lineEdit()->setText(input);\n+        }\n+    }\n+\n+    qint64 value(bool *valid_out=0) const\n+    {\n+        return parse(text(), valid_out);\n+    }\n+\n+    void setValue(qint64 value)\n+    {\n+        lineEdit()->setText(BitcoinUnits::format(currentUnit, value, false, BitcoinUnits::separatorAlways));\n+        emit valueChanged();\n+    }\n+\n+    void stepBy(int steps)\n+    {\n+        bool valid = false;\n+        qint64 val = value(&valid);\n+        val = val + steps * singleStep;\n+        val = qMin(qMax(val, Q_INT64_C(0)), BitcoinUnits::maxMoney());\n+        setValue(val);\n+    }\n+\n+    StepEnabled stepEnabled() const\n+    {\n+        StepEnabled rv = 0;\n+        if(text().isEmpty()) // Allow step-up with empty field\n+            return StepUpEnabled;\n+        bool valid = false;\n+        qint64 val = value(&valid);\n+        if(valid)\n+        {\n+            if(val > 0)\n+                rv |= StepDownEnabled;\n+            if(val < BitcoinUnits::maxMoney())\n+                rv |= StepUpEnabled;\n+        }\n+        return rv;\n+    }\n+\n+    void setDisplayUnit(int unit)\n+    {\n+        bool valid = false;\n+        qint64 val = value(&valid);\n+\n+        currentUnit = unit;\n+\n+        if(valid)\n+            setValue(val);\n+        else\n+            clear();\n+    }\n+\n+    void setSingleStep(qint64 step)\n+    {\n+        singleStep = step;\n+    }\n+\n+    QSize minimumSizeHint() const\n+    {\n+        if(cachedMinimumSizeHint.isEmpty())\n+        {\n+            ensurePolished();\n+\n+            const QFontMetrics fm(fontMetrics());\n+            int h = lineEdit()->minimumSizeHint().height();\n+            int w = fm.width(BitcoinUnits::format(BitcoinUnits::BTC, BitcoinUnits::maxMoney(), false, BitcoinUnits::separatorAlways));\n+            w += 2; // cursor blinking space\n+\n+            QStyleOptionSpinBox opt;\n+            initStyleOption(&opt);\n+            QSize hint(w, h);\n+            QSize extra(35, 6);\n+            opt.rect.setSize(hint + extra);\n+            extra += hint - style()->subControlRect(QStyle::CC_SpinBox, &opt,\n+                                                    QStyle::SC_SpinBoxEditField, this).size();\n+            // get closer to final result by repeating the calculation\n+            opt.rect.setSize(hint + extra);\n+            extra += hint - style()->subControlRect(QStyle::CC_SpinBox, &opt,\n+                                                    QStyle::SC_SpinBoxEditField, this).size();\n+            hint += extra;\n+\n+            opt.rect = rect();\n+\n+            cachedMinimumSizeHint = style()->sizeFromContents(QStyle::CT_SpinBox, &opt, hint, this)\n+                                    .expandedTo(QApplication::globalStrut());\n+        }\n+        return cachedMinimumSizeHint;\n+    }\n+private:\n+    int currentUnit;\n+    qint64 singleStep;\n+    mutable QSize cachedMinimumSizeHint;\n+\n+    /**\n+     * Parse a string into a number of base monetary units and\n+     * return validity.\n+     * @note Must return 0 if !valid.\n+     */\n+    qint64 parse(const QString &text, bool *valid_out=0) const\n+    {\n+        qint64 val = 0;\n+        bool valid = BitcoinUnits::parse(currentUnit, text, &val);\n+        if(valid)\n+        {\n+            if(val < 0 || val > BitcoinUnits::maxMoney())\n+                valid = false;\n+        }\n+        if(valid_out)\n+            *valid_out = valid;\n+        return valid ? val : 0;\n+    }\n+\n+protected:\n+    bool event(QEvent *event)\n+    {\n+        if (event->type() == QEvent::KeyPress || event->type() == QEvent::KeyRelease)\n+        {\n+            QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event);\n+            if (keyEvent->key() == Qt::Key_Comma)\n+            {\n+                // Translate a comma into a period\n+                QKeyEvent periodKeyEvent(event->type(), Qt::Key_Period, keyEvent->modifiers(), \".\", keyEvent->isAutoRepeat(), keyEvent->count());\n+                return QAbstractSpinBox::event(&periodKeyEvent);\n+            }\n+        }\n+        return QAbstractSpinBox::event(event);\n+    }\n+\n+signals:\n+    void valueChanged();\n+};\n+\n+#include \"bitcoinamountfield.moc\"\n \n BitcoinAmountField::BitcoinAmountField(QWidget *parent) :\n     QWidget(parent),\n-    amount(0),\n-    currentUnit(-1)\n+    amount(0)\n {\n-    nSingleStep = 100000; // satoshis\n-\n-    amount = new QDoubleSpinBox(this);\n+    amount = new AmountSpinBox(this);\n     amount->setLocale(QLocale::c());\n     amount->installEventFilter(this);\n     amount->setMaximumWidth(170);\n@@ -40,21 +207,13 @@ BitcoinAmountField::BitcoinAmountField(QWidget *parent) :\n     setFocusProxy(amount);\n \n     // If one if the widgets changes, the combined content changes as well\n-    connect(amount, SIGNAL(valueChanged(QString)), this, SIGNAL(textChanged()));\n+    connect(amount, SIGNAL(valueChanged()), this, SIGNAL(valueChanged()));\n     connect(unit, SIGNAL(currentIndexChanged(int)), this, SLOT(unitChanged(int)));\n \n     // Set default based on configuration\n     unitChanged(unit->currentIndex());\n }\n \n-void BitcoinAmountField::setText(const QString &text)\n-{\n-    if (text.isEmpty())\n-        amount->clear();\n-    else\n-        amount->setValue(text.toDouble());\n-}\n-\n void BitcoinAmountField::clear()\n {\n     amount->clear();\n@@ -63,16 +222,9 @@ void BitcoinAmountField::clear()\n \n bool BitcoinAmountField::validate()\n {\n-    bool valid = true;\n-    if (amount->value() == 0.0)\n-        valid = false;\n-    else if (!BitcoinUnits::parse(currentUnit, text(), 0))\n-        valid = false;\n-    else if (amount->value() > BitcoinUnits::maxAmount(currentUnit))\n-        valid = false;\n-\n+    bool valid = false;\n+    value(&valid);\n     setValid(valid);\n-\n     return valid;\n }\n \n@@ -84,32 +236,13 @@ void BitcoinAmountField::setValid(bool valid)\n         amount->setStyleSheet(STYLE_INVALID);\n }\n \n-QString BitcoinAmountField::text() const\n-{\n-    if (amount->text().isEmpty())\n-        return QString();\n-    else\n-        return amount->text();\n-}\n-\n bool BitcoinAmountField::eventFilter(QObject *object, QEvent *event)\n {\n     if (event->type() == QEvent::FocusIn)\n     {\n         // Clear invalid flag on focus\n         setValid(true);\n     }\n-    else if (event->type() == QEvent::KeyPress || event->type() == QEvent::KeyRelease)\n-    {\n-        QKeyEvent *keyEvent = static_cast<QKeyEvent *>(event);\n-        if (keyEvent->key() == Qt::Key_Comma)\n-        {\n-            // Translate a comma into a period\n-            QKeyEvent periodKeyEvent(event->type(), Qt::Key_Period, keyEvent->modifiers(), \".\", keyEvent->isAutoRepeat(), keyEvent->count());\n-            QApplication::sendEvent(object, &periodKeyEvent);\n-            return true;\n-        }\n-    }\n     return QWidget::eventFilter(object, event);\n }\n \n@@ -122,18 +255,12 @@ QWidget *BitcoinAmountField::setupTabChain(QWidget *prev)\n \n qint64 BitcoinAmountField::value(bool *valid_out) const\n {\n-    qint64 val_out = 0;\n-    bool valid = BitcoinUnits::parse(currentUnit, text(), &val_out);\n-    if (valid_out)\n-    {\n-        *valid_out = valid;\n-    }\n-    return val_out;\n+    return amount->value(valid_out);\n }\n \n void BitcoinAmountField::setValue(qint64 value)\n {\n-    setText(BitcoinUnits::format(currentUnit, value));\n+    amount->setValue(value);\n }\n \n void BitcoinAmountField::setReadOnly(bool fReadOnly)\n@@ -150,28 +277,7 @@ void BitcoinAmountField::unitChanged(int idx)\n     // Determine new unit ID\n     int newUnit = unit->itemData(idx, BitcoinUnits::UnitRole).toInt();\n \n-    // Parse current value and convert to new unit\n-    bool valid = false;\n-    qint64 currentValue = value(&valid);\n-\n-    currentUnit = newUnit;\n-\n-    // Set max length after retrieving the value, to prevent truncation\n-    amount->setDecimals(BitcoinUnits::decimals(currentUnit));\n-    amount->setMaximum(qPow(10, BitcoinUnits::amountDigits(currentUnit)) - qPow(10, -amount->decimals()));\n-    amount->setSingleStep((double)nSingleStep / (double)BitcoinUnits::factor(currentUnit));\n-\n-    if (valid)\n-    {\n-        // If value was valid, re-place it in the widget with the new unit\n-        setValue(currentValue);\n-    }\n-    else\n-    {\n-        // If current value is invalid, just clear field\n-        setText(\"\");\n-    }\n-    setValid(true);\n+    amount->setDisplayUnit(newUnit);\n }\n \n void BitcoinAmountField::setDisplayUnit(int newUnit)\n@@ -181,6 +287,5 @@ void BitcoinAmountField::setDisplayUnit(int newUnit)\n \n void BitcoinAmountField::setSingleStep(qint64 step)\n {\n-    nSingleStep = step;\n-    unitChanged(unit->currentIndex());\n+    amount->setSingleStep(step);\n }"
      },
      {
        "sha": "c713f5d68736f0e8dc96b6837ba3b20beac65133",
        "filename": "src/qt/bitcoinamountfield.h",
        "status": "modified",
        "additions": 5,
        "deletions": 9,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoinamountfield.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoinamountfield.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinamountfield.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -8,17 +8,18 @@\n #include <QWidget>\n \n QT_BEGIN_NAMESPACE\n-class QDoubleSpinBox;\n class QValueComboBox;\n QT_END_NAMESPACE\n \n+class AmountSpinBox;\n+\n /** Widget for entering bitcoin amounts.\n   */\n class BitcoinAmountField: public QWidget\n {\n     Q_OBJECT\n \n-    Q_PROPERTY(qint64 value READ value WRITE setValue NOTIFY textChanged USER true)\n+    Q_PROPERTY(qint64 value READ value WRITE setValue NOTIFY valueChanged USER true)\n \n public:\n     explicit BitcoinAmountField(QWidget *parent = 0);\n@@ -49,20 +50,15 @@ class BitcoinAmountField: public QWidget\n     QWidget *setupTabChain(QWidget *prev);\n \n signals:\n-    void textChanged();\n+    void valueChanged();\n \n protected:\n     /** Intercept focus-in event and ',' key presses */\n     bool eventFilter(QObject *object, QEvent *event);\n \n private:\n-    QDoubleSpinBox *amount;\n+    AmountSpinBox *amount;\n     QValueComboBox *unit;\n-    int currentUnit;\n-    qint64 nSingleStep;\n-\n-    void setText(const QString &text);\n-    QString text() const;\n \n private slots:\n     void unitChanged(int idx);"
      },
      {
        "sha": "5fc2f500b5e194e3cb06b3a72ad61eeab85bac7f",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 78,
        "deletions": 9,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -28,14 +28,13 @@\n \n #include <iostream>\n \n+#include <QAction>\n #include <QApplication>\n #include <QDateTime>\n #include <QDesktopWidget>\n #include <QDragEnterEvent>\n #include <QIcon>\n-#include <QLabel>\n #include <QListWidget>\n-#include <QMenu>\n #include <QMenuBar>\n #include <QMessageBox>\n #include <QMimeData>\n@@ -156,11 +155,17 @@ BitcoinGUI::BitcoinGUI(bool fIsTestnet, QWidget *parent) :\n     QHBoxLayout *frameBlocksLayout = new QHBoxLayout(frameBlocks);\n     frameBlocksLayout->setContentsMargins(3,0,3,0);\n     frameBlocksLayout->setSpacing(3);\n+    unitDisplayControl = new UnitDisplayStatusBarControl();\n     labelEncryptionIcon = new QLabel();\n     labelConnectionsIcon = new QLabel();\n     labelBlocksIcon = new QLabel();\n-    frameBlocksLayout->addStretch();\n-    frameBlocksLayout->addWidget(labelEncryptionIcon);\n+    if(enableWallet)\n+    {\n+        frameBlocksLayout->addStretch();\n+        frameBlocksLayout->addWidget(unitDisplayControl);\n+        frameBlocksLayout->addStretch();\n+        frameBlocksLayout->addWidget(labelEncryptionIcon);\n+    }\n     frameBlocksLayout->addStretch();\n     frameBlocksLayout->addWidget(labelConnectionsIcon);\n     frameBlocksLayout->addStretch();\n@@ -420,6 +425,8 @@ void BitcoinGUI::setClientModel(ClientModel *clientModel)\n             walletFrame->setClientModel(clientModel);\n         }\n #endif\n+\n+        this->unitDisplayControl->setOptionsModel(clientModel->getOptionsModel());\n     }\n }\n \n@@ -776,11 +783,7 @@ void BitcoinGUI::message(const QString &title, const QString &message, unsigned\n         if (!(buttons = (QMessageBox::StandardButton)(style & CClientUIInterface::BTN_MASK)))\n             buttons = QMessageBox::Ok;\n \n-        // Ensure we get users attention, but only if main window is visible\n-        // as we don't want to pop up the main window for messages that happen before\n-        // initialization is finished.\n-        if(!(style & CClientUIInterface::NOSHOWGUI))\n-            showNormalIfMinimized();\n+        showNormalIfMinimized();\n         QMessageBox mBox((QMessageBox::Icon)nMBoxIcon, strTitle, message, buttons, this);\n         int r = mBox.exec();\n         if (ret != NULL)\n@@ -917,6 +920,8 @@ void BitcoinGUI::setEncryptionStatus(int status)\n \n void BitcoinGUI::showNormalIfMinimized(bool fToggleHidden)\n {\n+    if(!clientModel)\n+        return;\n     // activateWindow() (sometimes) helps with keyboard focus on Windows\n     if (isHidden())\n     {\n@@ -1000,3 +1005,67 @@ void BitcoinGUI::unsubscribeFromCoreSignals()\n     // Disconnect signals from client\n     uiInterface.ThreadSafeMessageBox.disconnect(boost::bind(ThreadSafeMessageBox, this, _1, _2, _3));\n }\n+\n+UnitDisplayStatusBarControl::UnitDisplayStatusBarControl():QLabel()\n+{\n+    optionsModel = 0;\n+    createContextMenu();\n+    setToolTip(tr(\"Unit to show amounts in. Click to select another unit.\"));\n+}\n+\n+/** So that it responds to button clicks */\n+void UnitDisplayStatusBarControl::mousePressEvent(QMouseEvent *event)\n+{\n+    onDisplayUnitsClicked(event->pos());\n+}\n+\n+/** Creates context menu, its actions, and wires up all the relevant signals for mouse events. */\n+void UnitDisplayStatusBarControl::createContextMenu()\n+{\n+    menu = new QMenu();\n+    foreach(BitcoinUnits::Unit u, BitcoinUnits::availableUnits())\n+    {\n+        QAction *menuAction = new QAction(QString(BitcoinUnits::name(u)), this);\n+        menuAction->setData(QVariant(u));\n+        menu->addAction(menuAction);\n+    }\n+    connect(menu,SIGNAL(triggered(QAction*)),this,SLOT(onMenuSelection(QAction*)));\n+}\n+\n+/** Lets the control know about the Options Model (and its signals) */\n+void UnitDisplayStatusBarControl::setOptionsModel(OptionsModel *optionsModel)\n+{\n+    if (optionsModel)\n+    {\n+        this->optionsModel = optionsModel;\n+\n+        // be aware of a display unit change reported by the OptionsModel object.\n+        connect(optionsModel,SIGNAL(displayUnitChanged(int)),this,SLOT(updateDisplayUnit(int)));\n+\n+        // initialize the display units label with the current value in the model.\n+        updateDisplayUnit(optionsModel->getDisplayUnit());\n+    }\n+}\n+\n+/** When Display Units are changed on OptionsModel it will refresh the display text of the control on the status bar */\n+void UnitDisplayStatusBarControl::updateDisplayUnit(int newUnits)\n+{\n+    setPixmap(QIcon(\":/icons/unit_\" + BitcoinUnits::id(newUnits)).pixmap(31,STATUSBAR_ICONSIZE));\n+}\n+\n+/** Shows context menu with Display Unit options by the mouse coordinates */\n+void UnitDisplayStatusBarControl::onDisplayUnitsClicked(const QPoint& point)\n+{\n+    QPoint globalPos = mapToGlobal(point);\n+    menu->exec(globalPos);\n+}\n+\n+/** Tells underlying optionsModel to update its current display unit. */\n+void UnitDisplayStatusBarControl::onMenuSelection(QAction* action)\n+{\n+    if (action)\n+    {\n+        optionsModel->setDisplayUnit(action->data());\n+    }\n+}\n+"
      },
      {
        "sha": "30dd7ae317021a7bee36856a7fa44823c1d9df13",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 35,
        "deletions": 2,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -6,25 +6,29 @@\n #define BITCOINGUI_H\n \n #if defined(HAVE_CONFIG_H)\n-#include \"bitcoin-config.h\"\n+#include \"config/bitcoin-config.h\"\n #endif\n \n+#include <QLabel>\n #include <QMainWindow>\n #include <QMap>\n+#include <QMenu>\n+#include <QPoint>\n #include <QSystemTrayIcon>\n \n class ClientModel;\n class Notificator;\n+class OptionsModel;\n class RPCConsole;\n class SendCoinsRecipient;\n+class UnitDisplayStatusBarControl;\n class WalletFrame;\n class WalletModel;\n \n class CWallet;\n \n QT_BEGIN_NAMESPACE\n class QAction;\n-class QLabel;\n class QProgressBar;\n class QProgressDialog;\n QT_END_NAMESPACE\n@@ -69,6 +73,7 @@ class BitcoinGUI : public QMainWindow\n     ClientModel *clientModel;\n     WalletFrame *walletFrame;\n \n+    UnitDisplayStatusBarControl *unitDisplayControl;\n     QLabel *labelEncryptionIcon;\n     QLabel *labelConnectionsIcon;\n     QLabel *labelBlocksIcon;\n@@ -198,4 +203,32 @@ private slots:\n     void showProgress(const QString &title, int nProgress);\n };\n \n+class UnitDisplayStatusBarControl : public QLabel\n+{\n+    Q_OBJECT\n+\n+public:\n+    explicit UnitDisplayStatusBarControl();\n+    /** Lets the control know about the Options Model (and its signals) */\n+    void setOptionsModel(OptionsModel *optionsModel);\n+\n+protected:\n+    /** So that it responds to left-button clicks */\n+    void mousePressEvent(QMouseEvent *event);\n+\n+private:\n+    OptionsModel *optionsModel;\n+    QMenu* menu;\n+    /** Shows context menu with Display Unit options by the mouse coordinates */\n+    void onDisplayUnitsClicked(const QPoint& point);\n+    /** Creates context menu, its actions, and wires up all the relevant signals for mouse events. */\n+    void createContextMenu();\n+\n+private slots:\n+    /** When Display Units are changed on OptionsModel it will refresh the display text of the control on the status bar */\n+    void updateDisplayUnit(int newUnits);\n+    /** Tells underlying optionsModel to update its current display unit. */\n+    void onMenuSelection(QAction* action);\n+};\n+\n #endif // BITCOINGUI_H"
      },
      {
        "sha": "e852c468a88db5bf3c5d68d817db7bb969488427",
        "filename": "src/qt/bitcoinstrings.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 33,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoinstrings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoinstrings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinstrings.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -22,31 +22,42 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"It is also recommended to set alertnotify so you are notified of problems;\\n\"\n \"for example: alertnotify=echo %%s | mail -s \\\"Bitcoin Alert\\\" admin@foo.com\\n\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"(default: 1, 1 = keep tx meta data e.g. account owner and payment request \"\n+\"information, 2 = drop tx meta data)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Acceptable ciphers (default: TLSv1.2+HIGH:TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!\"\n \"3DES:@STRENGTH)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"An error occurred while setting up the RPC port %u for listening on IPv4: %s\"),\n+\"Allow JSON-RPC connections from specified source. Valid for <ip> are a \"\n+\"single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or \"\n+\"a network/CIDR (e.g. 1.2.3.4/24). This option can be specified multiple times\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"An error occurred while setting up the RPC port %u for listening on IPv6, \"\n-\"falling back to IPv4: %s\"),\n+\"An error occurred while setting up the RPC address %s port %u for listening: \"\n+\"%s\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Bind to given address and always listen on it. Use [host]:port notation for \"\n \"IPv6\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Bind to given address to listen for JSON-RPC connections. Use [host]:port \"\n+\"notation for IPv6. This option can be specified multiple times (default: \"\n+\"bind to all interfaces)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Cannot obtain a lock on data directory %s. Bitcoin Core is probably already \"\n \"running.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Continuously rate-limit free transactions to <n>*1000 bytes per minute \"\n \"(default:15)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Enter regression test mode, which uses a special chain in which blocks can \"\n-\"be solved instantly. This is intended for regression testing tools and app \"\n-\"development.\"),\n+\"Delete all wallet transactions and only recover those part of the blockchain \"\n+\"through -rescan on startup\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Distributed under the MIT/X11 software license, see the accompanying file \"\n+\"COPYING or <http://www.opensource.org/licenses/mit-license.php>.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Enter regression test mode, which uses a special chain in which blocks can \"\n \"be solved instantly.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Error: Listening for incoming connections failed (listen returned error %d)\"),\n+\"Error: Listening for incoming connections failed (listen returned error %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Error: The transaction was rejected! This might happen if some of the coins \"\n \"in your wallet were already spent, such as if you used a copy of wallet.dat \"\n@@ -55,6 +66,9 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Error: This transaction requires a transaction fee of at least %s because of \"\n \"its amount, complexity, or use of recently received funds!\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Execute command when a network tx respends wallet tx input (%s=respend TxID, \"\n+\"%t=wallet TxID)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Execute command when a relevant alert is received or we see a really long \"\n \"fork (%s in cmd is replaced by message)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -64,14 +78,20 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Execute command when the best block changes (%s in cmd is replaced by block \"\n \"hash)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"Fees smaller than this are considered zero fee (for transaction creation) \"\n-\"(default:\"),\n+\"Fees (in BTC/Kb) smaller than this are considered zero fee for relaying \"\n+\"(default: %s)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"Fees (in BTC/Kb) smaller than this are considered zero fee for transaction \"\n+\"creation (default: %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Flush database activity from memory pool to disk log every <n> megabytes \"\n \"(default: 100)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"How thorough the block verification of -checkblocks is (0-4, default: 3)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"If paytxfee is not set, include enough fee so transactions are confirmed on \"\n+\"average within n blocks (default: 1)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"In this mode -genproclimit controls how many blocks are generated \"\n \"immediately.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -93,6 +113,10 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"This is a pre-release test build - use at your own risk - do not use for \"\n \"mining or merchant applications\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n+\"This product includes software developed by the OpenSSL Project for use in \"\n+\"the OpenSSL Toolkit <https://www.openssl.org/> and cryptographic software \"\n+\"written by Eric Young and UPnP software written by Thomas Bernard.\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Unable to bind to %s on this computer. Bitcoin Core is probably already \"\n \"running.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n@@ -117,34 +141,26 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n \"Warning: wallet.dat corrupt, data salvaged! Original wallet.dat saved as \"\n \"wallet.{timestamp}.bak in %s; if your balance or transactions are incorrect \"\n \"you should restore from a backup.\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"\"\n-\"You must set rpcpassword=<password> in the configuration file:\\n\"\n-\"%s\\n\"\n-\"If the file does not exist, create it with owner-readable-only file \"\n-\"permissions.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"(default: 1)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"(default: wallet.dat)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"<category> can be:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Accept command line and JSON-RPC commands\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Accept connections from outside (default: 1 if no -proxy or -connect)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Add a node to connect to and attempt to keep the connection open\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Allow DNS lookups for -addnode, -seednode and -connect\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Allow JSON-RPC connections from specified IP address\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Attempt to recover private keys from a corrupt wallet.dat\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Bitcoin Core Daemon\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Bitcoin Core RPC client version\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Block creation options:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Cannot downgrade wallet\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Cannot resolve -bind address: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Cannot resolve -externalip address: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Cannot write default address\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Clear list of wallet transactions (diagnostic tool; implies -rescan)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Connect only to the specified node(s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Connect through SOCKS proxy\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Connect to JSON-RPC on <port> (default: 8332 or testnet: 18332)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Connect to a node to retrieve peer addresses, and disconnect\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Connection options:\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Copyright (C) 2009-%i The Bitcoin Core Developers\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Corrupted block database detected\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Could not parse -rpcbind value %s as network address\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Debugging/Testing options:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Disable safemode, override a real safe mode event (default: 0)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Discover own IP address (default: 1 when listening and no -externalip)\"),\n@@ -160,6 +176,7 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error loading wallet.dat: Wallet requires new\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error opening block database\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Disk space is low!\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Unsupported argument -tor found, use -onion.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: Wallet locked, unable to create transaction!\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Error: system error: \"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Failed to listen on any port. Use -listen=0 if you want this.\"),\n@@ -173,27 +190,28 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Failed to write file info\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Failed to write to coin database\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Failed to write transaction index\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Failed to write undo data\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Fee per kB to add to transactions you send\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Fees smaller than this are considered zero fee (for relaying) (default:\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Fee (in BTC/kB) to add to transactions you send (default: %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Find peers using DNS lookup (default: 1 unless -connect)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Force safe mode (default: 0)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Generate coins (default: 0)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Get help for a command\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"How many blocks to check at startup (default: 288, 0 = all)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"If <category> is not supplied, output all debugging information.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Importing...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Imports blocks from external blk000??.dat file\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Include IP addresses in debug output (default: 0)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Incorrect or no genesis block found. Wrong datadir for network?\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Information\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Initialization sanity check failed. Bitcoin Core is shutting down.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Insufficient funds\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid -onion address: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid -proxy address: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -minrelaytxfee=<amount>: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -mintxfee=<amount>: '%s'\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount for -paytxfee=<amount>: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Invalid amount\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Keep at most <n> unconnectable blocks in memory (default: %u)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Limit size of signature cache to <n> entries (default: 50000)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"List commands\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Listen for connections on <port> (default: 8333 or testnet: 18333)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Loading addresses...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Loading block index...\"),\n@@ -203,6 +221,7 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Maintain a full transaction index (default: 0\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Maintain at most <n> connections to peers (default: 125)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Maximum per-connection receive buffer, <n>*1000 bytes (default: 5000)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Maximum per-connection send buffer, <n>*1000 bytes (default: 1000)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Node relay options:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Not enough file descriptors available.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Only accept block chain matching built-in checkpoints (default: 1)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Only connect to nodes in network <net> (IPv4, IPv6 or Tor)\"),\n@@ -212,19 +231,16 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Prepend debug output with timestamp (default:\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Print block on startup, if found in block index\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Print block tree on startup (default: 0)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"RPC SSL options: (see the Bitcoin Wiki for SSL setup instructions)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"RPC client options:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"RPC server options:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Randomly drop 1 of every <n> network messages\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Randomly fuzz 1 of every <n> network messages\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rebuild block chain index from current blk000??.dat files\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Relay and mine data carrier transactions (default: 1)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rescan the block chain for missing wallet transactions\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Rescanning...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Run a thread to flush wallet periodically (default: 1)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Run in the background as a daemon and accept commands\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Select SOCKS version for -proxy (4 or 5, default: 5)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Send command to Bitcoin Core\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Send commands to node running on <ip> (default: 127.0.0.1)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Send trace/debug info to console instead of debug.log file\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Server certificate file (default: server.cert)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Server private key (default: server.pem)\"),\n@@ -245,29 +261,27 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Specify pid file (default: bitcoind.pid)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Specify wallet file (within data directory)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Specify your own public address\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Spend unconfirmed change when sending transactions (default: 1)\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Start Bitcoin Core Daemon\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Stop running after importing blocks from disk (default: 0)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"System error: \"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"This help message\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"This is experimental software.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"This is intended for regression testing tools and app development.\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Threshold for disconnecting misbehaving peers (default: 100)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"To use the %s option\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Transaction amount too small\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Transaction amounts must be positive\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Transaction too large\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unable to bind to %s on this computer (bind returned error %d, %s)\"),\n+QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unable to bind to %s on this computer (bind returned error %s)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unknown -socks proxy version requested: %i\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Unknown network specified in -onlynet: '%s'\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Upgrade wallet to latest format\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Usage (deprecated, use bitcoin-cli):\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Usage:\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Use OpenSSL (https) for JSON-RPC connections\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Use UPnP to map the listening port (default: 0)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Use UPnP to map the listening port (default: 1 when listening)\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Use the test network\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Username for JSON-RPC connections\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Verifying blocks...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Verifying wallet...\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Wait for RPC server to start\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Wallet %s resides outside data directory %s\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Wallet needed to be rewritten: restart Bitcoin to complete\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Wallet options:\"),\n@@ -277,6 +291,5 @@ QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Warning: This version is obsolete, upgrade re\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"You need to rebuild the database using -reindex to change -txindex\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"Zapping all transactions from wallet...\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"on startup\"),\n-QT_TRANSLATE_NOOP(\"bitcoin-core\", \"version\"),\n QT_TRANSLATE_NOOP(\"bitcoin-core\", \"wallet.dat corrupt, salvage failed\"),\n };"
      },
      {
        "sha": "6f506d3f2559108a751d45a4f6ed49849abf7cc0",
        "filename": "src/qt/bitcoinunits.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 33,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoinunits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoinunits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinunits.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -4,6 +4,8 @@\n \n #include \"bitcoinunits.h\"\n \n+#include \"core.h\"\n+\n #include <QStringList>\n \n BitcoinUnits::BitcoinUnits(QObject *parent):\n@@ -34,6 +36,17 @@ bool BitcoinUnits::valid(int unit)\n     }\n }\n \n+QString BitcoinUnits::id(int unit)\n+{\n+    switch(unit)\n+    {\n+    case BTC: return QString(\"btc\");\n+    case mBTC: return QString(\"mbtc\");\n+    case uBTC: return QString(\"ubtc\");\n+    default: return QString(\"???\");\n+    }\n+}\n+\n QString BitcoinUnits::name(int unit)\n {\n     switch(unit)\n@@ -50,8 +63,8 @@ QString BitcoinUnits::description(int unit)\n     switch(unit)\n     {\n     case BTC: return QString(\"Bitcoins\");\n-    case mBTC: return QString(\"Milli-Bitcoins (1 / 1,000)\");\n-    case uBTC: return QString(\"Micro-Bitcoins (1 / 1,000,000)\");\n+    case mBTC: return QString(\"Milli-Bitcoins (1 / 1\" THIN_SP_UTF8 \"000)\");\n+    case uBTC: return QString(\"Micro-Bitcoins (1 / 1\" THIN_SP_UTF8 \"000\" THIN_SP_UTF8 \"000)\");\n     default: return QString(\"???\");\n     }\n }\n@@ -67,28 +80,6 @@ qint64 BitcoinUnits::factor(int unit)\n     }\n }\n \n-qint64 BitcoinUnits::maxAmount(int unit)\n-{\n-    switch(unit)\n-    {\n-    case BTC:  return Q_INT64_C(21000000);\n-    case mBTC: return Q_INT64_C(21000000000);\n-    case uBTC: return Q_INT64_C(21000000000000);\n-    default:   return 0;\n-    }\n-}\n-\n-int BitcoinUnits::amountDigits(int unit)\n-{\n-    switch(unit)\n-    {\n-    case BTC: return 8; // 21,000,000 (# digits, without commas)\n-    case mBTC: return 11; // 21,000,000,000\n-    case uBTC: return 14; // 21,000,000,000,000\n-    default: return 0;\n-    }\n-}\n-\n int BitcoinUnits::decimals(int unit)\n {\n     switch(unit)\n@@ -100,7 +91,7 @@ int BitcoinUnits::decimals(int unit)\n     }\n }\n \n-QString BitcoinUnits::format(int unit, qint64 n, bool fPlus)\n+QString BitcoinUnits::format(int unit, qint64 n, bool fPlus, SeparatorStyle separators)\n {\n     // Note: not using straight sprintf here because we do NOT want\n     // localized number formatting.\n@@ -114,11 +105,20 @@ QString BitcoinUnits::format(int unit, qint64 n, bool fPlus)\n     QString quotient_str = QString::number(quotient);\n     QString remainder_str = QString::number(remainder).rightJustified(num_decimals, '0');\n \n-    // Right-trim excess zeros after the decimal point\n-    int nTrim = 0;\n-    for (int i = remainder_str.size()-1; i>=2 && (remainder_str.at(i) == '0'); --i)\n-        ++nTrim;\n-    remainder_str.chop(nTrim);\n+    // Use SI-stule separators as these are locale indendent and can't be\n+    // confused with the decimal marker.  Rule is to use a thin space every\n+    // three digits on *both* sides of the decimal point - but only if there\n+    // are five or more digits\n+    QChar thin_sp(THIN_SP_CP);\n+    int q_size = quotient_str.size();\n+    if (separators == separatorAlways || (separators == separatorStandard && q_size > 4))\n+        for (int i = 3; i < q_size; i += 3)\n+            quotient_str.insert(q_size - i, thin_sp);\n+\n+    int r_size = remainder_str.size();\n+    if (separators == separatorAlways || (separators == separatorStandard && r_size > 4))\n+        for (int i = 3, adj = 0; i < r_size ; i += 3, adj++)\n+            remainder_str.insert(i + adj, thin_sp);\n \n     if (n < 0)\n         quotient_str.insert(0, '-');\n@@ -127,17 +127,43 @@ QString BitcoinUnits::format(int unit, qint64 n, bool fPlus)\n     return quotient_str + QString(\".\") + remainder_str;\n }\n \n-QString BitcoinUnits::formatWithUnit(int unit, qint64 amount, bool plussign)\n+\n+// TODO: Review all remaining calls to BitcoinUnits::formatWithUnit to\n+// TODO: determine whether the output is used in a plain text context\n+// TODO: or an HTML context (and replace with\n+// TODO: BtcoinUnits::formatHtmlWithUnit in the latter case). Hopefully\n+// TODO: there aren't instances where the result could be used in\n+// TODO: either context.\n+\n+// NOTE: Using formatWithUnit in an HTML context risks wrapping\n+// quantities at the thousands separator. More subtly, it also results\n+// in a standard space rather than a thin space, due to a bug in Qt's\n+// XML whitespace canonicalisation\n+//\n+// Please take care to use formatHtmlWithUnit instead, when\n+// appropriate.\n+\n+QString BitcoinUnits::formatWithUnit(int unit, qint64 amount, bool plussign, SeparatorStyle separators)\n {\n-    return format(unit, amount, plussign) + QString(\" \") + name(unit);\n+    return format(unit, amount, plussign, separators) + QString(\" \") + name(unit);\n }\n \n+QString BitcoinUnits::formatHtmlWithUnit(int unit, qint64 amount, bool plussign, SeparatorStyle separators)\n+{\n+    QString str(formatWithUnit(unit, amount, plussign, separators));\n+    str.replace(QChar(THIN_SP_CP), QString(THIN_SP_HTML));\n+    return QString(\"<span style='white-space: nowrap;'>%1</span>\").arg(str);\n+}\n+\n+\n bool BitcoinUnits::parse(int unit, const QString &value, qint64 *val_out)\n {\n     if(!valid(unit) || value.isEmpty())\n         return false; // Refuse to parse invalid unit or empty string\n     int num_decimals = decimals(unit);\n-    QStringList parts = value.split(\".\");\n+\n+    // Ignore spaces and thin spaces when parsing\n+    QStringList parts = removeSpaces(value).split(\".\");\n \n     if(parts.size() > 2)\n     {\n@@ -169,6 +195,16 @@ bool BitcoinUnits::parse(int unit, const QString &value, qint64 *val_out)\n     return ok;\n }\n \n+QString BitcoinUnits::getAmountColumnTitle(int unit)\n+{\n+    QString amountTitle = QObject::tr(\"Amount\");\n+    if (BitcoinUnits::valid(unit))\n+    {\n+        amountTitle += \" (\"+BitcoinUnits::name(unit) + \")\";\n+    }\n+    return amountTitle;\n+}\n+\n int BitcoinUnits::rowCount(const QModelIndex &parent) const\n {\n     Q_UNUSED(parent);\n@@ -194,3 +230,8 @@ QVariant BitcoinUnits::data(const QModelIndex &index, int role) const\n     }\n     return QVariant();\n }\n+\n+qint64 BitcoinUnits::maxMoney()\n+{\n+    return MAX_MONEY;\n+}"
      },
      {
        "sha": "be9dca601235fe1abebeca8243431e7e897412d8",
        "filename": "src/qt/bitcoinunits.h",
        "status": "modified",
        "additions": 58,
        "deletions": 6,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoinunits.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/bitcoinunits.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoinunits.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -8,6 +8,37 @@\n #include <QAbstractListModel>\n #include <QString>\n \n+// U+2009 THIN SPACE = UTF-8 E2 80 89\n+#define REAL_THIN_SP_CP 0x2009\n+#define REAL_THIN_SP_UTF8 \"\\xE2\\x80\\x89\"\n+#define REAL_THIN_SP_HTML \"&thinsp;\"\n+\n+// U+200A HAIR SPACE = UTF-8 E2 80 8A\n+#define HAIR_SP_CP 0x200A\n+#define HAIR_SP_UTF8 \"\\xE2\\x80\\x8A\"\n+#define HAIR_SP_HTML \"&#8202;\"\n+\n+// U+2006 SIX-PER-EM SPACE = UTF-8 E2 80 86\n+#define SIXPEREM_SP_CP 0x2006\n+#define SIXPEREM_SP_UTF8 \"\\xE2\\x80\\x86\"\n+#define SIXPEREM_SP_HTML \"&#8198;\"\n+\n+// U+2007 FIGURE SPACE = UTF-8 E2 80 87\n+#define FIGURE_SP_CP 0x2007\n+#define FIGURE_SP_UTF8 \"\\xE2\\x80\\x87\"\n+#define FIGURE_SP_HTML \"&#8199;\"\n+\n+// QMessageBox seems to have a bug whereby it doesn't display thin/hair spaces\n+// correctly.  Workaround is to display a space in a small font.  If you\n+// change this, please test that it doesn't cause the parent span to start\n+// wrapping.\n+#define HTML_HACK_SP \"<span style='white-space: nowrap; font-size: 6pt'> </span>\"\n+\n+// Define THIN_SP_* variables to be our preferred type of thin space\n+#define THIN_SP_CP   REAL_THIN_SP_CP\n+#define THIN_SP_UTF8 REAL_THIN_SP_UTF8\n+#define THIN_SP_HTML HTML_HACK_SP\n+\n /** Bitcoin unit definitions. Encapsulates parsing and formatting\n    and serves as list model for drop-down selection boxes.\n */\n@@ -28,6 +59,13 @@ class BitcoinUnits: public QAbstractListModel\n         uBTC\n     };\n \n+    enum SeparatorStyle\n+    {\n+        separatorNever,\n+        separatorStandard,\n+        separatorAlways\n+    };\n+\n     //! @name Static API\n     //! Unit conversion and formatting\n     ///@{\n@@ -36,24 +74,25 @@ class BitcoinUnits: public QAbstractListModel\n     static QList<Unit> availableUnits();\n     //! Is unit ID valid?\n     static bool valid(int unit);\n+    //! Identifier, e.g. for image names\n+    static QString id(int unit);\n     //! Short name\n     static QString name(int unit);\n     //! Longer description\n     static QString description(int unit);\n     //! Number of Satoshis (1e-8) per unit\n     static qint64 factor(int unit);\n-    //! Max amount per unit\n-    static qint64 maxAmount(int unit);\n-    //! Number of amount digits (to represent max number of coins)\n-    static int amountDigits(int unit);\n     //! Number of decimals left\n     static int decimals(int unit);\n     //! Format as string\n-    static QString format(int unit, qint64 amount, bool plussign=false);\n+    static QString format(int unit, qint64 amount, bool plussign=false, SeparatorStyle separators=separatorStandard);\n     //! Format as string (with unit)\n-    static QString formatWithUnit(int unit, qint64 amount, bool plussign=false);\n+    static QString formatWithUnit(int unit, qint64 amount, bool plussign=false, SeparatorStyle separators=separatorStandard);\n+    static QString formatHtmlWithUnit(int unit, qint64 amount, bool plussign=false, SeparatorStyle separators=separatorStandard);\n     //! Parse string to coin amount\n     static bool parse(int unit, const QString &value, qint64 *val_out);\n+    //! Gets title for amount column including current display unit if optionsModel reference available */\n+    static QString getAmountColumnTitle(int unit);\n     ///@}\n \n     //! @name AbstractListModel implementation\n@@ -67,6 +106,19 @@ class BitcoinUnits: public QAbstractListModel\n     QVariant data(const QModelIndex &index, int role) const;\n     ///@}\n \n+    static QString removeSpaces(QString text)\n+    {\n+        text.remove(' ');\n+        text.remove(QChar(THIN_SP_CP));\n+#if (THIN_SP_CP != REAL_THIN_SP_CP)\n+        text.remove(QChar(REAL_THIN_SP_CP));\n+#endif\n+        return text;\n+    }\n+\n+    //! Return maximum number of base units (Satoshis)\n+    static qint64 maxMoney();\n+\n private:\n     QList<BitcoinUnits::Unit> unitlist;\n };"
      },
      {
        "sha": "4c21eb5594e19796feaf4f162c08247c0a3ba12c",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 9,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -85,7 +85,7 @@ QDateTime ClientModel::getLastBlockDate() const\n     if (chainActive.Tip())\n         return QDateTime::fromTime_t(chainActive.Tip()->GetBlockTime());\n     else\n-        return QDateTime::fromTime_t(Params().GenesisBlock().nTime); // Genesis block's time of current network\n+        return QDateTime::fromTime_t(Params().GenesisBlock().GetBlockTime()); // Genesis block's time of current network\n }\n \n double ClientModel::getVerificationProgress() const\n@@ -142,14 +142,6 @@ void ClientModel::updateAlert(const QString &hash, int status)\n     emit alertsChanged(getStatusBarWarnings());\n }\n \n-QString ClientModel::getNetworkName() const\n-{\n-    QString netname(QString::fromStdString(Params().DataDir()));\n-    if(netname.isEmpty())\n-        netname = \"main\";\n-    return netname;\n-}\n-\n bool ClientModel::inInitialBlockDownload() const\n {\n     return IsInitialBlockDownload();"
      },
      {
        "sha": "c7bd60bd4131c6539485375fed51bbc2d25827f4",
        "filename": "src/qt/clientmodel.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/clientmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/clientmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -56,8 +56,6 @@ class ClientModel : public QObject\n     double getVerificationProgress() const;\n     QDateTime getLastBlockDate() const;\n \n-    //! Return network (main, testnet3, regtest)\n-    QString getNetworkName() const;\n     //! Return true if core is doing initial block download\n     bool inInitialBlockDownload() const;\n     //! Return true if core is importing blocks"
      },
      {
        "sha": "7b30f8de090adb60a79e292fb3c80ac6bdddcde2",
        "filename": "src/qt/coincontroldialog.cpp",
        "status": "modified",
        "additions": 59,
        "deletions": 29,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/coincontroldialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/coincontroldialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -16,6 +16,8 @@\n #include \"main.h\"\n #include \"wallet.h\"\n \n+#include <boost/assign/list_of.hpp> // for 'map_list_of()'\n+\n #include <QApplication>\n #include <QCheckBox>\n #include <QCursor>\n@@ -223,7 +225,7 @@ void CoinControlDialog::showMenu(const QPoint &point)\n // context menu action: copy amount\n void CoinControlDialog::copyAmount()\n {\n-    GUIUtil::setClipboard(contextMenuItem->text(COLUMN_AMOUNT));\n+    GUIUtil::setClipboard(BitcoinUnits::removeSpaces(contextMenuItem->text(COLUMN_AMOUNT)));\n }\n \n // context menu action: copy label\n@@ -400,23 +402,26 @@ void CoinControlDialog::viewItemChanged(QTreeWidgetItem* item, int column)\n }\n \n // return human readable label for priority number\n-QString CoinControlDialog::getPriorityLabel(double dPriority)\n+QString CoinControlDialog::getPriorityLabel(const CTxMemPool& pool, double dPriority)\n {\n-    if (AllowFree(dPriority)) // at least medium\n+    // confirmations -> textual description\n+    typedef std::map<unsigned int, QString> PriorityDescription;\n+    const static PriorityDescription priorityDescriptions = boost::assign::map_list_of\n+        (1, tr(\"highest\"))(2, tr(\"higher\"))(3, tr(\"high\"))\n+        (5, tr(\"medium-high\"))(6, tr(\"medium\"))\n+        (10, tr(\"low-medium\"))(15, tr(\"low\"))\n+        (20, tr(\"lower\"));\n+\n+    BOOST_FOREACH(const PriorityDescription::value_type& i, priorityDescriptions)\n     {\n-        if      (AllowFree(dPriority / 1000000))  return tr(\"highest\");\n-        else if (AllowFree(dPriority / 100000))   return tr(\"higher\");\n-        else if (AllowFree(dPriority / 10000))    return tr(\"high\");\n-        else if (AllowFree(dPriority / 1000))     return tr(\"medium-high\");\n-        else                                      return tr(\"medium\");\n-    }\n-    else\n-    {\n-        if      (AllowFree(dPriority * 10))   return tr(\"low-medium\");\n-        else if (AllowFree(dPriority * 100))  return tr(\"low\");\n-        else if (AllowFree(dPriority * 1000)) return tr(\"lower\");\n-        else                                  return tr(\"lowest\");\n+        double p = mempool.estimatePriority(i.first);\n+        if (p > 0 && dPriority >= p) return i.second;\n     }\n+    // Note: if mempool hasn't accumulated enough history (estimatePriority\n+    // returns -1) we're conservative and classify as \"lowest\"\n+    if (mempool.estimatePriority(nTxConfirmTarget) <= 0 && AllowFree(dPriority))\n+        return \">=\" + tr(\"medium\");\n+    return tr(\"lowest\");\n }\n \n // shows count of locked unspent outputs\n@@ -440,7 +445,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n     // nPayAmount\n     qint64 nPayAmount = 0;\n     bool fDust = false;\n-    CTransaction txDummy;\n+    CMutableTransaction txDummy;\n     foreach(const qint64 &amount, CoinControlDialog::payAmounts)\n     {\n         nPayAmount += amount;\n@@ -449,7 +454,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n         {\n             CTxOut txout(amount, (CScript)vector<unsigned char>(24, 0));\n             txDummy.vout.push_back(txout);\n-            if (txout.IsDust(CTransaction::minRelayTxFee))\n+            if (txout.IsDust(::minRelayTxFee))\n                fDust = true;\n         }\n     }\n@@ -518,15 +523,23 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n \n         // Priority\n         dPriority = dPriorityInputs / (nBytes - nBytesInputs + (nQuantityUncompressed * 29)); // 29 = 180 - 151 (uncompressed public keys are over the limit. max 151 bytes of the input are ignored for priority)\n-        sPriorityLabel = CoinControlDialog::getPriorityLabel(dPriority);\n+        sPriorityLabel = CoinControlDialog::getPriorityLabel(mempool, dPriority);\n \n-        // Fee\n-        int64_t nFee = payTxFee.GetFee(nBytes);\n+        // Voluntary Fee\n+        nPayFee = payTxFee.GetFee(max((unsigned int)1000, nBytes));\n \n         // Min Fee\n-        int64_t nMinFee = GetMinFee(txDummy, nBytes, AllowFree(dPriority), GMF_SEND);\n+        if (nPayFee == 0)\n+        {\n+            nPayFee = CWallet::GetMinimumFee(nBytes, nTxConfirmTarget, mempool);\n \n-        nPayFee = max(nFee, nMinFee);\n+            double dPriorityNeeded = mempool.estimatePriority(nTxConfirmTarget);\n+            if (dPriorityNeeded <= 0 && !AllowFree(dPriority)) // not enough mempool history: never send free\n+                dPriorityNeeded = std::numeric_limits<double>::max();\n+\n+            if (nBytes <= MAX_FREE_TRANSACTION_CREATE_SIZE && dPriority >= dPriorityNeeded)\n+                nPayFee = 0;\n+        }\n \n         if (nPayAmount > 0)\n         {\n@@ -536,7 +549,7 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n             if (nChange > 0 && nChange < CENT)\n             {\n                 CTxOut txout(nChange, (CScript)vector<unsigned char>(24, 0));\n-                if (txout.IsDust(CTransaction::minRelayTxFee))\n+                if (txout.IsDust(::minRelayTxFee))\n                 {\n                     nPayFee += nChange;\n                     nChange = 0;\n@@ -582,29 +595,46 @@ void CoinControlDialog::updateLabels(WalletModel *model, QDialog* dialog)\n     l6->setText(sPriorityLabel);                                             // Priority\n     l7->setText(fDust ? tr(\"yes\") : tr(\"no\"));                               // Dust\n     l8->setText(BitcoinUnits::formatWithUnit(nDisplayUnit, nChange));        // Change\n+    if (nPayFee > 0)\n+    {\n+        l3->setText(\"~\" + l3->text());\n+        l4->setText(\"~\" + l4->text());\n+        if (nChange > 0)\n+            l8->setText(\"~\" + l8->text());\n+    }\n \n     // turn labels \"red\"\n-    l5->setStyleSheet((nBytes >= 1000) ? \"color:red;\" : \"\");                            // Bytes >= 1000\n+    l5->setStyleSheet((nBytes >= MAX_FREE_TRANSACTION_CREATE_SIZE) ? \"color:red;\" : \"\");// Bytes >= 1000\n     l6->setStyleSheet((dPriority > 0 && !AllowFree(dPriority)) ? \"color:red;\" : \"\");    // Priority < \"medium\"\n     l7->setStyleSheet((fDust) ? \"color:red;\" : \"\");                                     // Dust = \"yes\"\n \n     // tool tips\n     QString toolTip1 = tr(\"This label turns red, if the transaction size is greater than 1000 bytes.\") + \"<br /><br />\";\n-    toolTip1 += tr(\"This means a fee of at least %1 per kB is required.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CTransaction::minTxFee.GetFeePerK())) + \"<br /><br />\";\n+    toolTip1 += tr(\"This means a fee of at least %1 per kB is required.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CWallet::minTxFee.GetFeePerK())) + \"<br /><br />\";\n     toolTip1 += tr(\"Can vary +/- 1 byte per input.\");\n \n     QString toolTip2 = tr(\"Transactions with higher priority are more likely to get included into a block.\") + \"<br /><br />\";\n     toolTip2 += tr(\"This label turns red, if the priority is smaller than \\\"medium\\\".\") + \"<br /><br />\";\n-    toolTip2 += tr(\"This means a fee of at least %1 per kB is required.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CTransaction::minTxFee.GetFeePerK()));\n+    toolTip2 += tr(\"This means a fee of at least %1 per kB is required.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CWallet::minTxFee.GetFeePerK()));\n+\n+    QString toolTip3 = tr(\"This label turns red, if any recipient receives an amount smaller than %1.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, ::minRelayTxFee.GetFee(546)));\n \n-    QString toolTip3 = tr(\"This label turns red, if any recipient receives an amount smaller than %1.\").arg(BitcoinUnits::formatWithUnit(nDisplayUnit, CTransaction::minRelayTxFee.GetFee(546)));\n+    // how many satoshis the estimated fee can vary per byte we guess wrong\n+    double dFeeVary = (double)std::max(CWallet::minTxFee.GetFeePerK(), std::max(payTxFee.GetFeePerK(), mempool.estimateFee(nTxConfirmTarget).GetFeePerK())) / 1000;\n+    QString toolTip4 = tr(\"Can vary +/- %1 satoshi(s) per input.\").arg(dFeeVary);\n \n+    l3->setToolTip(toolTip4);\n+    l4->setToolTip(toolTip4);\n     l5->setToolTip(toolTip1);\n     l6->setToolTip(toolTip2);\n     l7->setToolTip(toolTip3);\n+    l8->setToolTip(toolTip4);\n+    dialog->findChild<QLabel *>(\"labelCoinControlFeeText\")      ->setToolTip(l3->toolTip());\n+    dialog->findChild<QLabel *>(\"labelCoinControlAfterFeeText\") ->setToolTip(l4->toolTip());\n     dialog->findChild<QLabel *>(\"labelCoinControlBytesText\")    ->setToolTip(l5->toolTip());\n     dialog->findChild<QLabel *>(\"labelCoinControlPriorityText\") ->setToolTip(l6->toolTip());\n     dialog->findChild<QLabel *>(\"labelCoinControlLowOutputText\")->setToolTip(l7->toolTip());\n+    dialog->findChild<QLabel *>(\"labelCoinControlChangeText\")   ->setToolTip(l8->toolTip());\n \n     // Insufficient funds\n     QLabel *label = dialog->findChild<QLabel *>(\"labelCoinControlInsuffFunds\");\n@@ -715,7 +745,7 @@ void CoinControlDialog::updateView()\n \n             // priority\n             double dPriority = ((double)out.tx->vout[out.i].nValue  / (nInputSize + 78)) * (out.nDepth+1); // 78 = 2 * 34 + 10\n-            itemOutput->setText(COLUMN_PRIORITY, CoinControlDialog::getPriorityLabel(dPriority));\n+            itemOutput->setText(COLUMN_PRIORITY, CoinControlDialog::getPriorityLabel(mempool, dPriority));\n             itemOutput->setText(COLUMN_PRIORITY_INT64, strPad(QString::number((int64_t)dPriority), 20, \" \"));\n             dPrioritySum += (double)out.tx->vout[out.i].nValue  * (out.nDepth+1);\n             nInputSum    += nInputSize;\n@@ -748,7 +778,7 @@ void CoinControlDialog::updateView()\n             itemWalletAddress->setText(COLUMN_CHECKBOX, \"(\" + QString::number(nChildren) + \")\");\n             itemWalletAddress->setText(COLUMN_AMOUNT, BitcoinUnits::format(nDisplayUnit, nSum));\n             itemWalletAddress->setText(COLUMN_AMOUNT_INT64, strPad(QString::number(nSum), 15, \" \"));\n-            itemWalletAddress->setText(COLUMN_PRIORITY, CoinControlDialog::getPriorityLabel(dPrioritySum));\n+            itemWalletAddress->setText(COLUMN_PRIORITY, CoinControlDialog::getPriorityLabel(mempool, dPrioritySum));\n             itemWalletAddress->setText(COLUMN_PRIORITY_INT64, strPad(QString::number((int64_t)dPrioritySum), 20, \" \"));\n         }\n     }"
      },
      {
        "sha": "4f7422642fd19196d858d95ca25fa71ee57b1076",
        "filename": "src/qt/coincontroldialog.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/coincontroldialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/coincontroldialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/coincontroldialog.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -19,6 +19,7 @@ namespace Ui {\n }\n class WalletModel;\n class CCoinControl;\n+class CTxMemPool;\n \n class CoinControlDialog : public QDialog\n {\n@@ -32,7 +33,7 @@ class CoinControlDialog : public QDialog\n \n     // static because also called from sendcoinsdialog\n     static void updateLabels(WalletModel*, QDialog*);\n-    static QString getPriorityLabel(double);\n+    static QString getPriorityLabel(const CTxMemPool& pool, double);\n \n     static QList<qint64> payAmounts;\n     static CCoinControl *coinControl;"
      },
      {
        "sha": "81dbd90b12d7f3b52b172b022946781c195415ef",
        "filename": "src/qt/forms/helpmessagedialog.ui",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/forms/helpmessagedialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/forms/helpmessagedialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/helpmessagedialog.ui?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -60,6 +60,9 @@\n            <property name=\"textFormat\">\n             <enum>Qt::PlainText</enum>\n            </property>\n+           <property name=\"openExternalLinks\">\n+            <bool>true</bool>\n+           </property>\n            <property name=\"textInteractionFlags\">\n             <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>\n            </property>"
      },
      {
        "sha": "1f535a4a629fe862b28d98764889fbf67075621e",
        "filename": "src/qt/forms/optionsdialog.ui",
        "status": "modified",
        "additions": 0,
        "deletions": 20,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/forms/optionsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/forms/optionsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/optionsdialog.ui?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -328,26 +328,6 @@\n            </property>\n           </widget>\n          </item>\n-         <item>\n-          <widget class=\"QLabel\" name=\"socksVersionLabel\">\n-           <property name=\"text\">\n-            <string>SOCKS &amp;Version:</string>\n-           </property>\n-           <property name=\"textFormat\">\n-            <enum>Qt::PlainText</enum>\n-           </property>\n-           <property name=\"buddy\">\n-            <cstring>socksVersion</cstring>\n-           </property>\n-          </widget>\n-         </item>\n-         <item>\n-          <widget class=\"QValueComboBox\" name=\"socksVersion\">\n-           <property name=\"toolTip\">\n-            <string>SOCKS version of the proxy (e.g. 5)</string>\n-           </property>\n-          </widget>\n-         </item>\n          <item>\n           <spacer name=\"horizontalSpacer_1_Network\">\n            <property name=\"orientation\">"
      },
      {
        "sha": "8784da5f3e6f7471f85040d9fad21c52861a9056",
        "filename": "src/qt/forms/overviewpage.ui",
        "status": "modified",
        "additions": 349,
        "deletions": 184,
        "changes": 533,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/forms/overviewpage.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/forms/overviewpage.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/overviewpage.ui?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -6,7 +6,7 @@\n    <rect>\n     <x>0</x>\n     <y>0</y>\n-    <width>573</width>\n+    <width>596</width>\n     <height>342</height>\n    </rect>\n   </property>\n@@ -46,204 +46,369 @@\n           <item>\n            <layout class=\"QHBoxLayout\" name=\"horizontalLayout_4\">\n             <item>\n-             <widget class=\"QLabel\" name=\"label_5\">\n-              <property name=\"font\">\n-               <font>\n-                <weight>75</weight>\n-                <bold>true</bold>\n-               </font>\n-              </property>\n-              <property name=\"text\">\n-               <string>Wallet</string>\n-              </property>\n-             </widget>\n-            </item>\n-            <item>\n-             <widget class=\"QLabel\" name=\"labelWalletStatus\">\n-              <property name=\"toolTip\">\n-               <string>The displayed information may be out of date. Your wallet automatically synchronizes with the Bitcoin network after a connection is established, but this process has not completed yet.</string>\n-              </property>\n-              <property name=\"styleSheet\">\n-               <string notr=\"true\">QLabel { color: red; }</string>\n-              </property>\n-              <property name=\"text\">\n-               <string notr=\"true\">(out of sync)</string>\n-              </property>\n-              <property name=\"alignment\">\n-               <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>\n-              </property>\n-             </widget>\n+             <layout class=\"QHBoxLayout\" name=\"horizontalLayout_7\">\n+              <item>\n+               <widget class=\"QLabel\" name=\"label_5\">\n+                <property name=\"font\">\n+                 <font>\n+                  <weight>75</weight>\n+                  <bold>true</bold>\n+                 </font>\n+                </property>\n+                <property name=\"text\">\n+                 <string>Wallet</string>\n+                </property>\n+               </widget>\n+              </item>\n+              <item>\n+               <widget class=\"QLabel\" name=\"labelWalletStatus\">\n+                <property name=\"toolTip\">\n+                 <string>The displayed information may be out of date. Your wallet automatically synchronizes with the Bitcoin network after a connection is established, but this process has not completed yet.</string>\n+                </property>\n+                <property name=\"styleSheet\">\n+                 <string notr=\"true\">QLabel { color: red; }</string>\n+                </property>\n+                <property name=\"text\">\n+                 <string notr=\"true\">(out of sync)</string>\n+                </property>\n+                <property name=\"alignment\">\n+                 <set>Qt::AlignLeading|Qt::AlignLeft|Qt::AlignVCenter</set>\n+                </property>\n+               </widget>\n+              </item>\n+             </layout>\n             </item>\n             <item>\n-             <spacer name=\"horizontalSpacer_2\">\n-              <property name=\"orientation\">\n-               <enum>Qt::Horizontal</enum>\n-              </property>\n-              <property name=\"sizeHint\" stdset=\"0\">\n-               <size>\n-                <width>40</width>\n-                <height>20</height>\n-               </size>\n-              </property>\n-             </spacer>\n+             <layout class=\"QHBoxLayout\" name=\"horizontalLayout_8\">\n+              <item>\n+               <widget class=\"QLabel\" name=\"labelWatchonly\">\n+                <property name=\"font\">\n+                 <font>\n+                  <weight>75</weight>\n+                  <bold>true</bold>\n+                 </font>\n+                </property>\n+                <property name=\"text\">\n+                 <string>Watchonly:</string>\n+                </property>\n+                <property name=\"alignment\">\n+                 <set>Qt::AlignCenter</set>\n+                </property>\n+               </widget>\n+              </item>\n+              <item>\n+               <spacer name=\"horizontalSpacer_2\">\n+                <property name=\"orientation\">\n+                 <enum>Qt::Horizontal</enum>\n+                </property>\n+                <property name=\"sizeType\">\n+                 <enum>QSizePolicy::Preferred</enum>\n+                </property>\n+                <property name=\"sizeHint\" stdset=\"0\">\n+                 <size>\n+                  <width>40</width>\n+                  <height>20</height>\n+                 </size>\n+                </property>\n+               </spacer>\n+              </item>\n+             </layout>\n             </item>\n            </layout>\n           </item>\n           <item>\n-          <layout class=\"QHBoxLayout\" name=\"horizontalLayout_3\">\n-           <item>\n-           <layout class=\"QFormLayout\" name=\"formLayout_2\">\n-            <property name=\"fieldGrowthPolicy\">\n-             <enum>QFormLayout::AllNonFixedFieldsGrow</enum>\n-            </property>\n-            <property name=\"horizontalSpacing\">\n-             <number>12</number>\n-            </property>\n-            <property name=\"verticalSpacing\">\n-             <number>12</number>\n-            </property>\n-            <item row=\"0\" column=\"0\">\n-             <widget class=\"QLabel\" name=\"label\">\n-              <property name=\"text\">\n-               <string>Available:</string>\n-              </property>\n-             </widget>\n-            </item>\n-            <item row=\"0\" column=\"1\">\n-             <widget class=\"QLabel\" name=\"labelBalance\">\n-              <property name=\"font\">\n-               <font>\n-                <weight>75</weight>\n-                <bold>true</bold>\n-               </font>\n-              </property>\n-              <property name=\"cursor\">\n-               <cursorShape>IBeamCursor</cursorShape>\n-              </property>\n-              <property name=\"toolTip\">\n-               <string>Your current spendable balance</string>\n-              </property>\n-              <property name=\"text\">\n-               <string notr=\"true\">0 BTC</string>\n-              </property>\n-              <property name=\"alignment\">\n-               <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>\n-              </property>\n-              <property name=\"textInteractionFlags\">\n-               <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>\n-              </property>\n-             </widget>\n-            </item>\n-            <item row=\"1\" column=\"0\">\n-             <widget class=\"QLabel\" name=\"label_3\">\n-              <property name=\"text\">\n-               <string>Pending:</string>\n-              </property>\n-             </widget>\n-            </item>\n-            <item row=\"1\" column=\"1\">\n-             <widget class=\"QLabel\" name=\"labelUnconfirmed\">\n-              <property name=\"font\">\n-               <font>\n-                <weight>75</weight>\n-                <bold>true</bold>\n-               </font>\n-              </property>\n-              <property name=\"cursor\">\n-               <cursorShape>IBeamCursor</cursorShape>\n-              </property>\n-              <property name=\"toolTip\">\n-               <string>Total of transactions that have yet to be confirmed, and do not yet count toward the spendable balance</string>\n-              </property>\n-              <property name=\"text\">\n-               <string notr=\"true\">0 BTC</string>\n-              </property>\n-              <property name=\"alignment\">\n-               <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>\n-              </property>\n-              <property name=\"textInteractionFlags\">\n-               <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>\n-              </property>\n-             </widget>\n-            </item>\n-            <item row=\"2\" column=\"0\">\n-             <widget class=\"QLabel\" name=\"labelImmatureText\">\n-              <property name=\"text\">\n-               <string>Immature:</string>\n-              </property>\n-             </widget>\n-            </item>\n-            <item row=\"2\" column=\"1\">\n-             <widget class=\"QLabel\" name=\"labelImmature\">\n-              <property name=\"font\">\n-               <font>\n-                <weight>75</weight>\n-                <bold>true</bold>\n-               </font>\n-              </property>\n-              <property name=\"toolTip\">\n-               <string>Mined balance that has not yet matured</string>\n-              </property>\n-              <property name=\"text\">\n-               <string notr=\"true\">0 BTC</string>\n-              </property>\n-              <property name=\"alignment\">\n-               <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>\n-              </property>\n-              <property name=\"textInteractionFlags\">\n-               <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>\n-              </property>\n-             </widget>\n-            </item>\n-            <item row=\"4\" column=\"0\">\n-             <widget class=\"QLabel\" name=\"labelTotalText\">\n-              <property name=\"text\">\n-               <string>Total:</string>\n-              </property>\n-             </widget>\n-            </item>\n-            <item row=\"4\" column=\"1\">\n-             <widget class=\"QLabel\" name=\"labelTotal\">\n-              <property name=\"font\">\n-               <font>\n-                <weight>75</weight>\n-                <bold>true</bold>\n-               </font>\n-              </property>\n-              <property name=\"cursor\">\n-               <cursorShape>IBeamCursor</cursorShape>\n-              </property>\n-              <property name=\"toolTip\">\n-               <string>Your current total balance</string>\n-              </property>\n-              <property name=\"text\">\n-               <string notr=\"true\">0 BTC</string>\n-              </property>\n-              <property name=\"alignment\">\n-               <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>\n-              </property>\n-              <property name=\"textInteractionFlags\">\n-               <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>\n-              </property>\n-             </widget>\n+           <layout class=\"QHBoxLayout\" name=\"horizontalLayout_3\">\n+            <item>\n+             <layout class=\"QFormLayout\" name=\"formLayout_2\">\n+              <property name=\"fieldGrowthPolicy\">\n+               <enum>QFormLayout::AllNonFixedFieldsGrow</enum>\n+              </property>\n+              <property name=\"horizontalSpacing\">\n+               <number>12</number>\n+              </property>\n+              <property name=\"verticalSpacing\">\n+               <number>12</number>\n+              </property>\n+              <item row=\"0\" column=\"0\">\n+               <widget class=\"QLabel\" name=\"label\">\n+                <property name=\"text\">\n+                 <string>Available:</string>\n+                </property>\n+               </widget>\n+              </item>\n+              <item row=\"0\" column=\"1\">\n+               <widget class=\"QLabel\" name=\"labelBalance\">\n+                <property name=\"font\">\n+                 <font>\n+                  <weight>75</weight>\n+                  <bold>true</bold>\n+                 </font>\n+                </property>\n+                <property name=\"cursor\">\n+                 <cursorShape>IBeamCursor</cursorShape>\n+                </property>\n+                <property name=\"toolTip\">\n+                 <string>Your current spendable balance</string>\n+                </property>\n+                <property name=\"text\">\n+                 <string notr=\"true\">0 BTC</string>\n+                </property>\n+                <property name=\"alignment\">\n+                 <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>\n+                </property>\n+                <property name=\"textInteractionFlags\">\n+                 <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>\n+                </property>\n+               </widget>\n+              </item>\n+              <item row=\"1\" column=\"0\">\n+               <widget class=\"QLabel\" name=\"label_3\">\n+                <property name=\"text\">\n+                 <string>Pending:</string>\n+                </property>\n+               </widget>\n+              </item>\n+              <item row=\"1\" column=\"1\">\n+               <widget class=\"QLabel\" name=\"labelUnconfirmed\">\n+                <property name=\"font\">\n+                 <font>\n+                  <weight>75</weight>\n+                  <bold>true</bold>\n+                 </font>\n+                </property>\n+                <property name=\"cursor\">\n+                 <cursorShape>IBeamCursor</cursorShape>\n+                </property>\n+                <property name=\"toolTip\">\n+                 <string>Total of transactions that have yet to be confirmed, and do not yet count toward the spendable balance</string>\n+                </property>\n+                <property name=\"text\">\n+                 <string notr=\"true\">0 BTC</string>\n+                </property>\n+                <property name=\"alignment\">\n+                 <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>\n+                </property>\n+                <property name=\"textInteractionFlags\">\n+                 <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>\n+                </property>\n+               </widget>\n+              </item>\n+              <item row=\"2\" column=\"0\">\n+               <widget class=\"QLabel\" name=\"labelImmatureText\">\n+                <property name=\"text\">\n+                 <string>Immature:</string>\n+                </property>\n+               </widget>\n+              </item>\n+              <item row=\"2\" column=\"1\">\n+               <widget class=\"QLabel\" name=\"labelImmature\">\n+                <property name=\"font\">\n+                 <font>\n+                  <weight>75</weight>\n+                  <bold>true</bold>\n+                 </font>\n+                </property>\n+                <property name=\"cursor\">\n+                 <cursorShape>IBeamCursor</cursorShape>\n+                </property>\n+                <property name=\"toolTip\">\n+                 <string>Mined balance that has not yet matured</string>\n+                </property>\n+                <property name=\"text\">\n+                 <string notr=\"true\">0 BTC</string>\n+                </property>\n+                <property name=\"alignment\">\n+                 <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>\n+                </property>\n+                <property name=\"textInteractionFlags\">\n+                 <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>\n+                </property>\n+               </widget>\n+              </item>\n+              <item row=\"3\" column=\"0\" colspan=\"2\">\n+               <widget class=\"Line\" name=\"line\">\n+                <property name=\"orientation\">\n+                 <enum>Qt::Horizontal</enum>\n+                </property>\n+               </widget>\n+              </item>\n+              <item row=\"4\" column=\"0\">\n+               <widget class=\"QLabel\" name=\"labelTotalText\">\n+                <property name=\"text\">\n+                 <string>Total:</string>\n+                </property>\n+               </widget>\n+              </item>\n+              <item row=\"4\" column=\"1\">\n+               <widget class=\"QLabel\" name=\"labelTotal\">\n+                <property name=\"font\">\n+                 <font>\n+                  <weight>75</weight>\n+                  <bold>true</bold>\n+                 </font>\n+                </property>\n+                <property name=\"cursor\">\n+                 <cursorShape>IBeamCursor</cursorShape>\n+                </property>\n+                <property name=\"toolTip\">\n+                 <string>Your current total balance</string>\n+                </property>\n+                <property name=\"text\">\n+                 <string notr=\"true\">0 BTC</string>\n+                </property>\n+                <property name=\"alignment\">\n+                 <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>\n+                </property>\n+                <property name=\"textInteractionFlags\">\n+                 <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>\n+                </property>\n+               </widget>\n+              </item>\n+             </layout>\n             </item>\n-            <item row=\"3\" column=\"0\" colspan=\"2\">\n-             <widget class=\"Line\" name=\"line\">\n-              <property name=\"orientation\">\n-               <enum>Qt::Horizontal</enum>\n-              </property>\n-             </widget>\n+            <item>\n+             <layout class=\"QFormLayout\" name=\"formLayout\">\n+              <property name=\"fieldGrowthPolicy\">\n+               <enum>QFormLayout::AllNonFixedFieldsGrow</enum>\n+              </property>\n+              <property name=\"horizontalSpacing\">\n+               <number>12</number>\n+              </property>\n+              <property name=\"verticalSpacing\">\n+               <number>12</number>\n+              </property>\n+              <item row=\"0\" column=\"1\">\n+               <widget class=\"QLabel\" name=\"labelWatchAvailable\">\n+                <property name=\"font\">\n+                 <font>\n+                  <weight>75</weight>\n+                  <bold>true</bold>\n+                 </font>\n+                </property>\n+                <property name=\"cursor\">\n+                 <cursorShape>IBeamCursor</cursorShape>\n+                </property>\n+                <property name=\"toolTip\">\n+                 <string>Your current balance in watchonly addresses</string>\n+                </property>\n+                <property name=\"text\">\n+                 <string>0 BTC</string>\n+                </property>\n+                <property name=\"alignment\">\n+                 <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>\n+                </property>\n+                <property name=\"textInteractionFlags\">\n+                 <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>\n+                </property>\n+               </widget>\n+              </item>\n+              <item row=\"1\" column=\"1\">\n+               <widget class=\"QLabel\" name=\"labelWatchPending\">\n+                <property name=\"font\">\n+                 <font>\n+                  <weight>75</weight>\n+                  <bold>true</bold>\n+                 </font>\n+                </property>\n+                <property name=\"cursor\">\n+                 <cursorShape>IBeamCursor</cursorShape>\n+                </property>\n+                <property name=\"toolTip\">\n+                 <string>Unconfirmed transactions to watchonly addresses</string>\n+                </property>\n+                <property name=\"text\">\n+                 <string>0 BTC</string>\n+                </property>\n+                <property name=\"alignment\">\n+                 <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>\n+                </property>\n+                <property name=\"textInteractionFlags\">\n+                 <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>\n+                </property>\n+               </widget>\n+              </item>\n+              <item row=\"2\" column=\"1\">\n+               <widget class=\"QLabel\" name=\"labelWatchImmature\">\n+                <property name=\"font\">\n+                 <font>\n+                  <weight>75</weight>\n+                  <bold>true</bold>\n+                 </font>\n+                </property>\n+                <property name=\"cursor\">\n+                 <cursorShape>IBeamCursor</cursorShape>\n+                </property>\n+                <property name=\"toolTip\">\n+                 <string>Mined balance in watchonly addresses that has not yet matured</string>\n+                </property>\n+                <property name=\"text\">\n+                 <string>0 BTC</string>\n+                </property>\n+                <property name=\"alignment\">\n+                 <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>\n+                </property>\n+                <property name=\"textInteractionFlags\">\n+                 <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>\n+                </property>\n+               </widget>\n+              </item>\n+              <item row=\"3\" column=\"0\" colspan=\"2\">\n+               <widget class=\"Line\" name=\"lineWatchBalance\">\n+                <property name=\"sizePolicy\">\n+                 <sizepolicy hsizetype=\"Preferred\" vsizetype=\"Fixed\">\n+                  <horstretch>0</horstretch>\n+                  <verstretch>0</verstretch>\n+                 </sizepolicy>\n+                </property>\n+                <property name=\"minimumSize\">\n+                 <size>\n+                  <width>140</width>\n+                  <height>0</height>\n+                 </size>\n+                </property>\n+                <property name=\"orientation\">\n+                 <enum>Qt::Horizontal</enum>\n+                </property>\n+               </widget>\n+              </item>\n+              <item row=\"4\" column=\"1\">\n+               <widget class=\"QLabel\" name=\"labelWatchTotal\">\n+                <property name=\"font\">\n+                 <font>\n+                  <weight>75</weight>\n+                  <bold>true</bold>\n+                 </font>\n+                </property>\n+                <property name=\"cursor\">\n+                 <cursorShape>IBeamCursor</cursorShape>\n+                </property>\n+                <property name=\"toolTip\">\n+                 <string>Current total balance in watchonly addresses</string>\n+                </property>\n+                <property name=\"text\">\n+                 <string>0 BTC</string>\n+                </property>\n+                <property name=\"alignment\">\n+                 <set>Qt::AlignRight|Qt::AlignTrailing|Qt::AlignVCenter</set>\n+                </property>\n+                <property name=\"textInteractionFlags\">\n+                 <set>Qt::LinksAccessibleByMouse|Qt::TextSelectableByKeyboard|Qt::TextSelectableByMouse</set>\n+                </property>\n+               </widget>\n+              </item>\n+             </layout>\n             </item>\n-           </layout>\n-          </item>\n             <item>\n              <spacer name=\"horizontalSpacer_3\">\n               <property name=\"orientation\">\n                <enum>Qt::Horizontal</enum>\n               </property>\n+              <property name=\"sizeType\">\n+               <enum>QSizePolicy::Expanding</enum>\n+              </property>\n               <property name=\"sizeHint\" stdset=\"0\">\n                <size>\n-                <width>40</width>\n+                <width>20</width>\n                 <height>20</height>\n                </size>\n               </property>"
      },
      {
        "sha": "7158b65c2d30b8afe4b74f9917a5af27be851a38",
        "filename": "src/qt/forms/rpcconsole.ui",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/forms/rpcconsole.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/forms/rpcconsole.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/rpcconsole.ui?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -559,7 +559,7 @@\n               <item>\n                <widget class=\"QLabel\" name=\"label_16\">\n                 <property name=\"text\">\n-                 <string>In:</string>\n+                 <string>Received</string>\n                 </property>\n                </widget>\n               </item>\n@@ -639,7 +639,7 @@\n               <item>\n                <widget class=\"QLabel\" name=\"label_17\">\n                 <property name=\"text\">\n-                 <string>Out:</string>\n+                 <string>Sent</string>\n                 </property>\n                </widget>\n               </item>"
      },
      {
        "sha": "9d829970f0f29af9e8b5587cabb2008ab8009f85",
        "filename": "src/qt/forms/sendcoinsentry.ui",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/forms/sendcoinsentry.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/forms/sendcoinsentry.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/sendcoinsentry.ui?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -51,7 +51,7 @@\n       <item>\n        <widget class=\"QValidatedLineEdit\" name=\"payTo\">\n         <property name=\"toolTip\">\n-         <string>The address to send the payment to (e.g. 1NS17iag9jJgTHD1VXjvLCEnZuQ3rJDE9L)</string>\n+         <string>The Bitcoin address to send the payment to</string>\n         </property>\n        </widget>\n       </item>"
      },
      {
        "sha": "53573ec821c6629ab780cba3041265100253037b",
        "filename": "src/qt/forms/signverifymessagedialog.ui",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/forms/signverifymessagedialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/forms/signverifymessagedialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/signverifymessagedialog.ui?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -45,7 +45,7 @@\n          <item>\n           <widget class=\"QValidatedLineEdit\" name=\"addressIn_SM\">\n            <property name=\"toolTip\">\n-            <string>The address to sign the message with (e.g. 1NS17iag9jJgTHD1VXjvLCEnZuQ3rJDE9L)</string>\n+            <string>The Bitcoin address to sign the message with</string>\n            </property>\n           </widget>\n          </item>\n@@ -255,7 +255,7 @@\n          <item>\n           <widget class=\"QValidatedLineEdit\" name=\"addressIn_VM\">\n            <property name=\"toolTip\">\n-            <string>The address the message was signed with (e.g. 1NS17iag9jJgTHD1VXjvLCEnZuQ3rJDE9L)</string>\n+            <string>The Bitcoin address the message was signed with</string>\n            </property>\n           </widget>\n          </item>"
      },
      {
        "sha": "33a50a078dad5475ab3212730496b46ce454808b",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -11,6 +11,7 @@\n \n #include \"core.h\"\n #include \"init.h\"\n+#include \"main.h\"\n #include \"protocol.h\"\n #include \"util.h\"\n \n@@ -91,7 +92,9 @@ void setupAddressWidget(QValidatedLineEdit *widget, QWidget *parent)\n \n     widget->setFont(bitcoinAddressFont());\n #if QT_VERSION >= 0x040700\n-    widget->setPlaceholderText(QObject::tr(\"Enter a Bitcoin address (e.g. 1NS17iag9jJgTHD1VXjvLCEnZuQ3rJDE9L)\"));\n+    // We don't want translators to use own addresses in translations\n+    // and this is the only place, where this address is supplied.\n+    widget->setPlaceholderText(QObject::tr(\"Enter a Bitcoin address (e.g. %1)\").arg(\"1NS17iag9jJgTHD1VXjvLCEnZuQ3rJDE9L\"));\n #endif\n     widget->setValidator(new BitcoinAddressEntryValidator(parent));\n     widget->setCheckValidator(new BitcoinAddressCheckValidator(parent));\n@@ -184,7 +187,7 @@ QString formatBitcoinURI(const SendCoinsRecipient &info)\n \n     if (info.amount)\n     {\n-        ret += QString(\"?amount=%1\").arg(BitcoinUnits::format(BitcoinUnits::BTC, info.amount));\n+        ret += QString(\"?amount=%1\").arg(BitcoinUnits::format(BitcoinUnits::BTC, info.amount, false, BitcoinUnits::separatorNever));\n         paramCount++;\n     }\n \n@@ -210,7 +213,7 @@ bool isDust(const QString& address, qint64 amount)\n     CTxDestination dest = CBitcoinAddress(address.toStdString()).Get();\n     CScript script; script.SetDestination(dest);\n     CTxOut txOut(amount, script);\n-    return txOut.IsDust(CTransaction::minRelayTxFee);\n+    return txOut.IsDust(::minRelayTxFee);\n }\n \n QString HtmlEscape(const QString& str, bool fMultiLine)"
      },
      {
        "sha": "3395e6435098f0d97d18047e369cd2703852ded2",
        "filename": "src/qt/notificator.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/notificator.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/notificator.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/notificator.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -6,7 +6,7 @@\n #define NOTIFICATOR_H\n \n #if defined(HAVE_CONFIG_H)\n-#include \"bitcoin-config.h\"\n+#include \"config/bitcoin-config.h\"\n #endif\n \n #include <QIcon>"
      },
      {
        "sha": "597be40abdf6124cb6b84b42e13a093668186a80",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 11,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #if defined(HAVE_CONFIG_H)\n-#include \"bitcoin-config.h\"\n+#include \"config/bitcoin-config.h\"\n #endif\n \n #include \"optionsdialog.h\"\n@@ -14,7 +14,10 @@\n #include \"monitoreddatamapper.h\"\n #include \"optionsmodel.h\"\n \n-#include \"main.h\" // for CTransaction::minTxFee and MAX_SCRIPTCHECK_THREADS\n+#include \"main.h\" // for MAX_SCRIPTCHECK_THREADS\n+#ifdef ENABLE_WALLET\n+#include \"wallet.h\" // for CWallet::minTxFee\n+#endif\n #include \"netbase.h\"\n #include \"txdb.h\" // for -dbcache defaults\n \n@@ -49,15 +52,8 @@ OptionsDialog::OptionsDialog(QWidget *parent) :\n     ui->proxyPort->setEnabled(false);\n     ui->proxyPort->setValidator(new QIntValidator(1, 65535, this));\n \n-    /** SOCKS version is only selectable for default proxy and is always 5 for IPv6 and Tor */\n-    ui->socksVersion->setEnabled(false);\n-    ui->socksVersion->addItem(\"5\", 5);\n-    ui->socksVersion->addItem(\"4\", 4);\n-    ui->socksVersion->setCurrentIndex(0);\n-\n     connect(ui->connectSocks, SIGNAL(toggled(bool)), ui->proxyIp, SLOT(setEnabled(bool)));\n     connect(ui->connectSocks, SIGNAL(toggled(bool)), ui->proxyPort, SLOT(setEnabled(bool)));\n-    connect(ui->connectSocks, SIGNAL(toggled(bool)), ui->socksVersion, SLOT(setEnabled(bool)));\n \n     ui->proxyIp->installEventFilter(this);\n \n@@ -101,7 +97,9 @@ OptionsDialog::OptionsDialog(QWidget *parent) :\n #endif\n \n     ui->unit->setModel(new BitcoinUnits(this));\n-    ui->transactionFee->setSingleStep(CTransaction::minTxFee.GetFeePerK());\n+#ifdef ENABLE_WALLET\n+    ui->transactionFee->setSingleStep(CWallet::minTxFee.GetFeePerK());\n+#endif\n \n     /* Widget-to-option mapper */\n     mapper = new MonitoredDataMapper(this);\n@@ -177,7 +175,6 @@ void OptionsDialog::setMapper()\n     mapper->addMapping(ui->connectSocks, OptionsModel::ProxyUse);\n     mapper->addMapping(ui->proxyIp, OptionsModel::ProxyIP);\n     mapper->addMapping(ui->proxyPort, OptionsModel::ProxyPort);\n-    mapper->addMapping(ui->socksVersion, OptionsModel::ProxySocksVersion);\n \n     /* Window */\n #ifndef Q_OS_MAC"
      },
      {
        "sha": "f07e66bf04d8266b743e7d22852eba6da79dfdec",
        "filename": "src/qt/optionsmodel.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 27,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/optionsmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/optionsmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -3,7 +3,7 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #if defined(HAVE_CONFIG_H)\n-#include \"bitcoin-config.h\"\n+#include \"config/bitcoin-config.h\"\n #endif\n \n #include \"optionsmodel.h\"\n@@ -122,11 +122,6 @@ void OptionsModel::Init()\n     // Only try to set -proxy, if user has enabled fUseProxy\n     if (settings.value(\"fUseProxy\").toBool() && !SoftSetArg(\"-proxy\", settings.value(\"addrProxy\").toString().toStdString()))\n         addOverriddenOption(\"-proxy\");\n-    if (!settings.contains(\"nSocksVersion\"))\n-        settings.setValue(\"nSocksVersion\", 5);\n-    // Only try to set -socks, if user has enabled fUseProxy\n-    if (settings.value(\"fUseProxy\").toBool() && !SoftSetArg(\"-socks\", settings.value(\"nSocksVersion\").toString().toStdString()))\n-        addOverriddenOption(\"-socks\");\n \n     // Display\n     if (!settings.contains(\"language\"))\n@@ -188,8 +183,6 @@ QVariant OptionsModel::data(const QModelIndex & index, int role) const\n             QStringList strlIpPort = settings.value(\"addrProxy\").toString().split(\":\", QString::SkipEmptyParts);\n             return strlIpPort.at(1);\n         }\n-        case ProxySocksVersion:\n-            return settings.value(\"nSocksVersion\", 5);\n \n #ifdef ENABLE_WALLET\n         case Fee: {\n@@ -284,13 +277,6 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n             }\n         }\n         break;\n-        case ProxySocksVersion: {\n-            if (settings.value(\"nSocksVersion\") != value) {\n-                settings.setValue(\"nSocksVersion\", value.toInt());\n-                setRestartRequired(true);\n-            }\n-        }\n-        break;\n #ifdef ENABLE_WALLET\n         case Fee: { // core option - can be changed on-the-fly\n             // Todo: Add is valid check  and warn via message, if not\n@@ -308,9 +294,7 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n             break;\n #endif\n         case DisplayUnit:\n-            nDisplayUnit = value.toInt();\n-            settings.setValue(\"nDisplayUnit\", nDisplayUnit);\n-            emit displayUnitChanged(nDisplayUnit);\n+            setDisplayUnit(value);\n             break;\n         case DisplayAddresses:\n             bDisplayAddresses = value.toBool();\n@@ -356,31 +340,40 @@ bool OptionsModel::setData(const QModelIndex & index, const QVariant & value, in\n             break;\n         }\n     }\n+\n     emit dataChanged(index, index);\n \n     return successful;\n }\n \n+/** Updates current unit in memory, settings and emits displayUnitChanged(newUnit) signal */\n+void OptionsModel::setDisplayUnit(const QVariant &value)\n+{\n+    if (!value.isNull())\n+    {\n+        QSettings settings;\n+        nDisplayUnit = value.toInt();\n+        settings.setValue(\"nDisplayUnit\", nDisplayUnit);\n+        emit displayUnitChanged(nDisplayUnit);\n+    }\n+}\n+\n bool OptionsModel::getProxySettings(QNetworkProxy& proxy) const\n {\n     // Directly query current base proxy, because\n     // GUI settings can be overridden with -proxy.\n     proxyType curProxy;\n     if (GetProxy(NET_IPV4, curProxy)) {\n-        if (curProxy.second == 5) {\n-            proxy.setType(QNetworkProxy::Socks5Proxy);\n-            proxy.setHostName(QString::fromStdString(curProxy.first.ToStringIP()));\n-            proxy.setPort(curProxy.first.GetPort());\n+        proxy.setType(QNetworkProxy::Socks5Proxy);\n+        proxy.setHostName(QString::fromStdString(curProxy.ToStringIP()));\n+        proxy.setPort(curProxy.GetPort());\n \n-            return true;\n-        }\n-        else\n-            return false;\n+        return true;\n     }\n     else\n         proxy.setType(QNetworkProxy::NoProxy);\n \n-    return true;\n+    return false;\n }\n \n void OptionsModel::setRestartRequired(bool fRequired)"
      },
      {
        "sha": "89c2ec745305b371976dca08141e7b6b757663d7",
        "filename": "src/qt/optionsmodel.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/optionsmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/optionsmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsmodel.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -52,6 +52,8 @@ class OptionsModel : public QAbstractListModel\n     int rowCount(const QModelIndex & parent = QModelIndex()) const;\n     QVariant data(const QModelIndex & index, int role = Qt::DisplayRole) const;\n     bool setData(const QModelIndex & index, const QVariant & value, int role = Qt::EditRole);\n+    /** Updates current unit in memory, settings and emits displayUnitChanged(newUnit) signal */\n+    void setDisplayUnit(const QVariant &value);\n \n     /* Explicit getters */\n     bool getMinimizeToTray() { return fMinimizeToTray; }"
      },
      {
        "sha": "1c700b37ffe5dd9d40a734210015c4b81d97b8f5",
        "filename": "src/qt/overviewpage.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 11,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/overviewpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/overviewpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/overviewpage.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -72,7 +72,7 @@ class TxViewDelegate : public QAbstractItemDelegate\n             foreground = option.palette.color(QPalette::Text);\n         }\n         painter->setPen(foreground);\n-        QString amountText = BitcoinUnits::formatWithUnit(unit, amount, true);\n+        QString amountText = BitcoinUnits::formatWithUnit(unit, amount, true, BitcoinUnits::separatorAlways);\n         if(!confirmed)\n         {\n             amountText = QString(\"[\") + amountText + QString(\"]\");\n@@ -103,6 +103,9 @@ OverviewPage::OverviewPage(QWidget *parent) :\n     currentBalance(-1),\n     currentUnconfirmedBalance(-1),\n     currentImmatureBalance(-1),\n+    currentWatchOnlyBalance(-1),\n+    currentWatchUnconfBalance(-1),\n+    currentWatchImmatureBalance(-1),\n     txdelegate(new TxViewDelegate()),\n     filter(0)\n {\n@@ -135,22 +138,39 @@ OverviewPage::~OverviewPage()\n     delete ui;\n }\n \n-void OverviewPage::setBalance(qint64 balance, qint64 unconfirmedBalance, qint64 immatureBalance)\n+void OverviewPage::setBalance(qint64 balance, qint64 unconfirmedBalance, qint64 immatureBalance, qint64 watchOnlyBalance, qint64 watchUnconfBalance, qint64 watchImmatureBalance)\n {\n     int unit = walletModel->getOptionsModel()->getDisplayUnit();\n     currentBalance = balance;\n     currentUnconfirmedBalance = unconfirmedBalance;\n     currentImmatureBalance = immatureBalance;\n-    ui->labelBalance->setText(BitcoinUnits::formatWithUnit(unit, balance));\n-    ui->labelUnconfirmed->setText(BitcoinUnits::formatWithUnit(unit, unconfirmedBalance));\n-    ui->labelImmature->setText(BitcoinUnits::formatWithUnit(unit, immatureBalance));\n-    ui->labelTotal->setText(BitcoinUnits::formatWithUnit(unit, balance + unconfirmedBalance + immatureBalance));\n+    currentWatchOnlyBalance = watchOnlyBalance;\n+    currentWatchUnconfBalance = watchUnconfBalance;\n+    currentWatchImmatureBalance = watchImmatureBalance;\n+    ui->labelBalance->setText(BitcoinUnits::formatWithUnit(unit, balance, false, BitcoinUnits::separatorAlways));\n+    ui->labelUnconfirmed->setText(BitcoinUnits::formatWithUnit(unit, unconfirmedBalance, false, BitcoinUnits::separatorAlways));\n+    ui->labelImmature->setText(BitcoinUnits::formatWithUnit(unit, immatureBalance, false, BitcoinUnits::separatorAlways));\n+    ui->labelTotal->setText(BitcoinUnits::formatWithUnit(unit, balance + unconfirmedBalance + immatureBalance, false, BitcoinUnits::separatorAlways));\n+    ui->labelWatchAvailable->setText(BitcoinUnits::formatWithUnit(unit, watchOnlyBalance, false, BitcoinUnits::separatorAlways));\n+    ui->labelWatchPending->setText(BitcoinUnits::formatWithUnit(unit, watchUnconfBalance, false, BitcoinUnits::separatorAlways));\n+    ui->labelWatchImmature->setText(BitcoinUnits::formatWithUnit(unit, watchImmatureBalance, false, BitcoinUnits::separatorAlways));\n+    ui->labelWatchTotal->setText(BitcoinUnits::formatWithUnit(unit, watchOnlyBalance + watchUnconfBalance + watchImmatureBalance, false, BitcoinUnits::separatorAlways));\n \n     // only show immature (newly mined) balance if it's non-zero, so as not to complicate things\n     // for the non-mining users\n     bool showImmature = immatureBalance != 0;\n-    ui->labelImmature->setVisible(showImmature);\n-    ui->labelImmatureText->setVisible(showImmature);\n+    bool showWatchOnlyImmature = watchImmatureBalance != 0;\n+    bool showWatchOnly = (watchOnlyBalance != 0 || watchUnconfBalance != 0 || showWatchOnlyImmature);\n+\n+    // for symmetry reasons also show immature label when the watchonly one is shown\n+    ui->labelImmature->setVisible(showImmature || showWatchOnlyImmature);\n+    ui->labelImmatureText->setVisible(showImmature || showWatchOnlyImmature);\n+    ui->labelWatchonly->setVisible(showWatchOnly);              // show Watchonly label\n+    ui->lineWatchBalance->setVisible(showWatchOnly);            // show watchonly balance separator line\n+    ui->labelWatchAvailable->setVisible(showWatchOnly);         // show watchonly available balance\n+    ui->labelWatchImmature->setVisible(showWatchOnlyImmature);  // show watchonly immature balance\n+    ui->labelWatchPending->setVisible(showWatchOnly);           // show watchonly pending balance\n+    ui->labelWatchTotal->setVisible(showWatchOnly);             // show watchonly total balance\n }\n \n void OverviewPage::setClientModel(ClientModel *model)\n@@ -182,8 +202,9 @@ void OverviewPage::setWalletModel(WalletModel *model)\n         ui->listTransactions->setModelColumn(TransactionTableModel::ToAddress);\n \n         // Keep up to date with wallet\n-        setBalance(model->getBalance(), model->getUnconfirmedBalance(), model->getImmatureBalance());\n-        connect(model, SIGNAL(balanceChanged(qint64, qint64, qint64)), this, SLOT(setBalance(qint64, qint64, qint64)));\n+        setBalance(model->getBalance(), model->getUnconfirmedBalance(), model->getImmatureBalance(),\n+                   model->getWatchBalance(), model->getWatchUnconfirmedBalance(), model->getWatchImmatureBalance());\n+        connect(model, SIGNAL(balanceChanged(qint64, qint64, qint64, qint64, qint64, qint64)), this, SLOT(setBalance(qint64, qint64, qint64, qint64, qint64, qint64)));\n \n         connect(model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n     }\n@@ -197,7 +218,8 @@ void OverviewPage::updateDisplayUnit()\n     if(walletModel && walletModel->getOptionsModel())\n     {\n         if(currentBalance != -1)\n-            setBalance(currentBalance, currentUnconfirmedBalance, currentImmatureBalance);\n+            setBalance(currentBalance, currentUnconfirmedBalance, currentImmatureBalance,\n+                       currentWatchOnlyBalance, currentWatchUnconfBalance, currentWatchImmatureBalance);\n \n         // Update txdelegate->unit with the current unit\n         txdelegate->unit = walletModel->getOptionsModel()->getDisplayUnit();"
      },
      {
        "sha": "fe00106770edafa79a28e3ab472d749560cffbc6",
        "filename": "src/qt/overviewpage.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/overviewpage.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/overviewpage.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/overviewpage.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -34,7 +34,8 @@ class OverviewPage : public QWidget\n     void showOutOfSyncWarning(bool fShow);\n \n public slots:\n-    void setBalance(qint64 balance, qint64 unconfirmedBalance, qint64 immatureBalance);\n+    void setBalance(qint64 balance, qint64 unconfirmedBalance, qint64 immatureBalance,\n+                    qint64 watchOnlyBalance, qint64 watchUnconfBalance, qint64 watchImmatureBalance);\n \n signals:\n     void transactionClicked(const QModelIndex &index);\n@@ -46,6 +47,9 @@ public slots:\n     qint64 currentBalance;\n     qint64 currentUnconfirmedBalance;\n     qint64 currentImmatureBalance;\n+    qint64 currentWatchOnlyBalance;\n+    qint64 currentWatchUnconfBalance;\n+    qint64 currentWatchImmatureBalance;\n \n     TxViewDelegate *txdelegate;\n     TransactionFilterProxy *filter;"
      },
      {
        "sha": "acce42e20376874d3688761384d143141698a23e",
        "filename": "src/qt/paymentrequestplus.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 11,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/paymentrequestplus.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/paymentrequestplus.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentrequestplus.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -17,6 +17,7 @@\n #include <QDebug>\n #include <QSslCertificate>\n \n+using namespace std;\n \n class SSLVerifyError : public std::runtime_error\n {\n@@ -28,18 +29,18 @@ bool PaymentRequestPlus::parse(const QByteArray& data)\n {\n     bool parseOK = paymentRequest.ParseFromArray(data.data(), data.size());\n     if (!parseOK) {\n-        qDebug() << \"PaymentRequestPlus::parse : Error parsing payment request\";\n+        qWarning() << \"PaymentRequestPlus::parse : Error parsing payment request\";\n         return false;\n     }\n     if (paymentRequest.payment_details_version() > 1) {\n-        qDebug() << \"PaymentRequestPlus::parse : Received up-version payment details, version=\" << paymentRequest.payment_details_version();\n+        qWarning() << \"PaymentRequestPlus::parse : Received up-version payment details, version=\" << paymentRequest.payment_details_version();\n         return false;\n     }\n \n     parseOK = details.ParseFromString(paymentRequest.serialized_payment_details());\n     if (!parseOK)\n     {\n-        qDebug() << \"PaymentRequestPlus::parse : Error parsing payment details\";\n+        qWarning() << \"PaymentRequestPlus::parse : Error parsing payment details\";\n         paymentRequest.Clear();\n         return false;\n     }\n@@ -79,17 +80,17 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n         digestAlgorithm = EVP_sha1();\n     }\n     else if (paymentRequest.pki_type() == \"none\") {\n-        qDebug() << \"PaymentRequestPlus::getMerchant : Payment request: pki_type == none\";\n+        qWarning() << \"PaymentRequestPlus::getMerchant : Payment request: pki_type == none\";\n         return false;\n     }\n     else {\n-        qDebug() << \"PaymentRequestPlus::getMerchant : Payment request: unknown pki_type \" << QString::fromStdString(paymentRequest.pki_type());\n+        qWarning() << \"PaymentRequestPlus::getMerchant : Payment request: unknown pki_type \" << QString::fromStdString(paymentRequest.pki_type());\n         return false;\n     }\n \n     payments::X509Certificates certChain;\n     if (!certChain.ParseFromString(paymentRequest.pki_data())) {\n-        qDebug() << \"PaymentRequestPlus::getMerchant : Payment request: error parsing pki_data\";\n+        qWarning() << \"PaymentRequestPlus::getMerchant : Payment request: error parsing pki_data\";\n         return false;\n     }\n \n@@ -99,12 +100,12 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n         QByteArray certData(certChain.certificate(i).data(), certChain.certificate(i).size());\n         QSslCertificate qCert(certData, QSsl::Der);\n         if (currentTime < qCert.effectiveDate() || currentTime > qCert.expiryDate()) {\n-            qDebug() << \"PaymentRequestPlus::getMerchant : Payment request: certificate expired or not yet active: \" << qCert;\n+            qWarning() << \"PaymentRequestPlus::getMerchant : Payment request: certificate expired or not yet active: \" << qCert;\n             return false;\n         }\n #if QT_VERSION >= 0x050000\n         if (qCert.isBlacklisted()) {\n-            qDebug() << \"PaymentRequestPlus::getMerchant : Payment request: certificate blacklisted: \" << qCert;\n+            qWarning() << \"PaymentRequestPlus::getMerchant : Payment request: certificate blacklisted: \" << qCert;\n             return false;\n         }\n #endif\n@@ -114,7 +115,7 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n             certs.push_back(cert);\n     }\n     if (certs.empty()) {\n-        qDebug() << \"PaymentRequestPlus::getMerchant : Payment request: empty certificate chain\";\n+        qWarning() << \"PaymentRequestPlus::getMerchant : Payment request: empty certificate chain\";\n         return false;\n     }\n \n@@ -130,7 +131,7 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n     // load the signing cert into it and verify.\n     X509_STORE_CTX *store_ctx = X509_STORE_CTX_new();\n     if (!store_ctx) {\n-        qDebug() << \"PaymentRequestPlus::getMerchant : Payment request: error creating X509_STORE_CTX\";\n+        qWarning() << \"PaymentRequestPlus::getMerchant : Payment request: error creating X509_STORE_CTX\";\n         return false;\n     }\n \n@@ -182,7 +183,7 @@ bool PaymentRequestPlus::getMerchant(X509_STORE* certStore, QString& merchant) c\n     catch (SSLVerifyError& err)\n     {\n         fResult = false;\n-        qDebug() << \"PaymentRequestPlus::getMerchant : SSL error: \" << err.what();\n+        qWarning() << \"PaymentRequestPlus::getMerchant : SSL error: \" << err.what();\n     }\n \n     if (website)"
      },
      {
        "sha": "3c4861a4d4bdb81ccdb1c82a637e4e68d7a39b94",
        "filename": "src/qt/paymentrequestplus.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/paymentrequestplus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/paymentrequestplus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentrequestplus.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -24,7 +24,7 @@ class PaymentRequestPlus\n     PaymentRequestPlus() { }\n \n     bool parse(const QByteArray& data);\n-    bool SerializeToString(string* output) const;\n+    bool SerializeToString(std::string* output) const;\n \n     bool IsInitialized() const;\n     QString getPKIType() const;"
      },
      {
        "sha": "7c0c95c459326c077d0d9c57eb9df739bbdb11d1",
        "filename": "src/qt/paymentserver.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 41,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/paymentserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/paymentserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -44,6 +44,7 @@\n #include <QUrlQuery>\n #endif\n \n+using namespace std;\n using namespace boost;\n \n const int BITCOIN_IPC_CONNECT_TIMEOUT = 1000; // milliseconds\n@@ -89,7 +90,7 @@ static QList<QString> savedPaymentRequests;\n \n static void ReportInvalidCertificate(const QSslCertificate& cert)\n {\n-    qDebug() << \"ReportInvalidCertificate : Payment server found an invalid certificate: \" << cert.subjectInfo(QSslCertificate::CommonName);\n+    qWarning() << \"ReportInvalidCertificate : Payment server found an invalid certificate: \" << cert.subjectInfo(QSslCertificate::CommonName);\n }\n \n //\n@@ -160,7 +161,7 @@ void PaymentServer::LoadRootCAs(X509_STORE* _store)\n             continue;\n         }\n     }\n-    qDebug() << \"PaymentServer::LoadRootCAs : Loaded \" << nRootCerts << \" root certificates\";\n+    qWarning() << \"PaymentServer::LoadRootCAs : Loaded \" << nRootCerts << \" root certificates\";\n \n     // Project for another day:\n     // Fetch certificate revocation lists, and add them to certStore.\n@@ -194,14 +195,14 @@ bool PaymentServer::ipcParseCommandLine(int argc, char* argv[])\n             savedPaymentRequests.append(arg);\n \n             SendCoinsRecipient r;\n-            if (GUIUtil::parseBitcoinURI(arg, &r))\n+            if (GUIUtil::parseBitcoinURI(arg, &r) && !r.address.isEmpty())\n             {\n                 CBitcoinAddress address(r.address.toStdString());\n \n-                SelectParams(CChainParams::MAIN);\n+                SelectParams(CBaseChainParams::MAIN);\n                 if (!address.IsValid())\n                 {\n-                    SelectParams(CChainParams::TESTNET);\n+                    SelectParams(CBaseChainParams::TESTNET);\n                 }\n             }\n         }\n@@ -213,16 +214,20 @@ bool PaymentServer::ipcParseCommandLine(int argc, char* argv[])\n             if (readPaymentRequest(arg, request))\n             {\n                 if (request.getDetails().network() == \"main\")\n-                    SelectParams(CChainParams::MAIN);\n-                else\n-                    SelectParams(CChainParams::TESTNET);\n+                {\n+                    SelectParams(CBaseChainParams::MAIN);\n+                }\n+                else if (request.getDetails().network() == \"test\")\n+                {\n+                    SelectParams(CBaseChainParams::TESTNET);\n+                }\n             }\n         }\n         else\n         {\n             // Printing to debug.log is about the best we can do here, the\n             // GUI hasn't started yet so we can't pop up a message box.\n-            qDebug() << \"PaymentServer::ipcSendCommandLine : Payment request file does not exist: \" << arg;\n+            qWarning() << \"PaymentServer::ipcSendCommandLine : Payment request file does not exist: \" << arg;\n         }\n     }\n     return true;\n@@ -340,20 +345,14 @@ void PaymentServer::initNetManager()\n \n     QNetworkProxy proxy;\n \n-    // Query active proxy (fails if no SOCKS5 proxy)\n+    // Query active SOCKS5 proxy\n     if (optionsModel->getProxySettings(proxy)) {\n-        if (proxy.type() == QNetworkProxy::Socks5Proxy) {\n-            netManager->setProxy(proxy);\n+        netManager->setProxy(proxy);\n \n-            qDebug() << \"PaymentServer::initNetManager : Using SOCKS5 proxy\" << proxy.hostName() << \":\" << proxy.port();\n-        }\n-        else\n-            qDebug() << \"PaymentServer::initNetManager : No active proxy server found.\";\n+        qDebug() << \"PaymentServer::initNetManager : Using SOCKS5 proxy\" << proxy.hostName() << \":\" << proxy.port();\n     }\n     else\n-        emit message(tr(\"Net manager warning\"),\n-            tr(\"Your active proxy doesn't support SOCKS5, which is required for payment requests via proxy.\"),\n-            CClientUIInterface::MSG_WARNING);\n+        qDebug() << \"PaymentServer::initNetManager : No active proxy server found.\";\n \n     connect(netManager, SIGNAL(finished(QNetworkReply*)),\n             this, SLOT(netRequestFinished(QNetworkReply*)));\n@@ -402,7 +401,7 @@ void PaymentServer::handleURIOrFile(const QString& s)\n             }\n             else\n             {\n-                qDebug() << \"PaymentServer::handleURIOrFile : Invalid URL: \" << fetchUrl;\n+                qWarning() << \"PaymentServer::handleURIOrFile : Invalid URL: \" << fetchUrl;\n                 emit message(tr(\"URI handling\"),\n                     tr(\"Payment request fetch URL is invalid: %1\").arg(fetchUrl.toString()),\n                     CClientUIInterface::ICON_WARNING);\n@@ -475,13 +474,13 @@ bool PaymentServer::readPaymentRequest(const QString& filename, PaymentRequestPl\n     QFile f(filename);\n     if (!f.open(QIODevice::ReadOnly))\n     {\n-        qDebug() << \"PaymentServer::readPaymentRequest : Failed to open \" << filename;\n+        qWarning() << \"PaymentServer::readPaymentRequest : Failed to open \" << filename;\n         return false;\n     }\n \n     if (f.size() > MAX_PAYMENT_REQUEST_SIZE)\n     {\n-        qDebug() << \"PaymentServer::readPaymentRequest : \" << filename << \" too large\";\n+        qWarning() << \"PaymentServer::readPaymentRequest : \" << filename << \" too large\";\n         return false;\n     }\n \n@@ -490,17 +489,6 @@ bool PaymentServer::readPaymentRequest(const QString& filename, PaymentRequestPl\n     return request.parse(data);\n }\n \n-std::string PaymentServer::mapNetworkIdToName(CChainParams::Network networkId)\n-{\n-    if (networkId == CChainParams::MAIN)\n-        return \"main\";\n-    if (networkId == CChainParams::TESTNET)\n-        return \"test\";\n-    if (networkId == CChainParams::REGTEST)\n-        return \"regtest\";\n-    return \"\";\n-}\n-\n bool PaymentServer::processPaymentRequest(PaymentRequestPlus& request, SendCoinsRecipient& recipient)\n {\n     if (!optionsModel)\n@@ -510,7 +498,7 @@ bool PaymentServer::processPaymentRequest(PaymentRequestPlus& request, SendCoins\n         const payments::PaymentDetails& details = request.getDetails();\n \n         // Payment request network matches client network?\n-        if (details.network() != mapNetworkIdToName(Params().NetworkID()))\n+        if (details.network() != Params().NetworkIDString())\n         {\n             emit message(tr(\"Payment request rejected\"), tr(\"Payment request network doesn't match client network.\"),\n                 CClientUIInterface::MSG_ERROR);\n@@ -561,7 +549,7 @@ bool PaymentServer::processPaymentRequest(PaymentRequestPlus& request, SendCoins\n \n         // Extract and check amounts\n         CTxOut txOut(sendingTo.second, sendingTo.first);\n-        if (txOut.IsDust(CTransaction::minRelayTxFee)) {\n+        if (txOut.IsDust(::minRelayTxFee)) {\n             emit message(tr(\"Payment request error\"), tr(\"Requested payment amount of %1 is too small (considered dust).\")\n                 .arg(BitcoinUnits::formatWithUnit(optionsModel->getDisplayUnit(), sendingTo.second)),\n                 CClientUIInterface::MSG_ERROR);\n@@ -634,7 +622,7 @@ void PaymentServer::fetchPaymentACK(CWallet* wallet, SendCoinsRecipient recipien\n         else {\n             // This should never happen, because sending coins should have\n             // just unlocked the wallet and refilled the keypool.\n-            qDebug() << \"PaymentServer::fetchPaymentACK : Error getting refund key, refund_to not set\";\n+            qWarning() << \"PaymentServer::fetchPaymentACK : Error getting refund key, refund_to not set\";\n         }\n     }\n \n@@ -646,7 +634,7 @@ void PaymentServer::fetchPaymentACK(CWallet* wallet, SendCoinsRecipient recipien\n     }\n     else {\n         // This should never happen, either.\n-        qDebug() << \"PaymentServer::fetchPaymentACK : Error serializing payment message\";\n+        qWarning() << \"PaymentServer::fetchPaymentACK : Error serializing payment message\";\n     }\n }\n \n@@ -659,7 +647,7 @@ void PaymentServer::netRequestFinished(QNetworkReply* reply)\n             .arg(reply->request().url().toString())\n             .arg(reply->errorString());\n \n-        qDebug() << \"PaymentServer::netRequestFinished : \" << msg;\n+        qWarning() << \"PaymentServer::netRequestFinished : \" << msg;\n         emit message(tr(\"Payment request error\"), msg, CClientUIInterface::MSG_ERROR);\n         return;\n     }\n@@ -673,7 +661,7 @@ void PaymentServer::netRequestFinished(QNetworkReply* reply)\n         SendCoinsRecipient recipient;\n         if (!request.parse(data))\n         {\n-            qDebug() << \"PaymentServer::netRequestFinished : Error parsing payment request\";\n+            qWarning() << \"PaymentServer::netRequestFinished : Error parsing payment request\";\n             emit message(tr(\"Payment request error\"),\n                 tr(\"Payment request can not be parsed!\"),\n                 CClientUIInterface::MSG_ERROR);\n@@ -691,7 +679,7 @@ void PaymentServer::netRequestFinished(QNetworkReply* reply)\n             QString msg = tr(\"Bad response from server %1\")\n                 .arg(reply->request().url().toString());\n \n-            qDebug() << \"PaymentServer::netRequestFinished : \" << msg;\n+            qWarning() << \"PaymentServer::netRequestFinished : \" << msg;\n             emit message(tr(\"Payment request error\"), msg, CClientUIInterface::MSG_ERROR);\n         }\n         else\n@@ -707,7 +695,7 @@ void PaymentServer::reportSslErrors(QNetworkReply* reply, const QList<QSslError>\n \n     QString errString;\n     foreach (const QSslError& err, errs) {\n-        qDebug() << \"PaymentServer::reportSslErrors : \" << err;\n+        qWarning() << \"PaymentServer::reportSslErrors : \" << err;\n         errString += err.errorString() + \"\\n\";\n     }\n     emit message(tr(\"Network request error\"), errString, CClientUIInterface::MSG_ERROR);"
      },
      {
        "sha": "d84d09c57d6c8039f532baf8b52b0e8eef44b22e",
        "filename": "src/qt/paymentserver.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/paymentserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/paymentserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/paymentserver.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -118,7 +118,6 @@ private slots:\n \n private:\n     static bool readPaymentRequest(const QString& filename, PaymentRequestPlus& request);\n-    std::string mapNetworkIdToName(CChainParams::Network networkId);\n     bool processPaymentRequest(PaymentRequestPlus& request, SendCoinsRecipient& recipient);\n     void fetchRequest(const QUrl& url);\n "
      },
      {
        "sha": "cc2f00916f2bb966272b03ac5dde0838ff51e3a7",
        "filename": "src/qt/receiverequestdialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/receiverequestdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/receiverequestdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/receiverequestdialog.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -22,7 +22,7 @@\n #endif\n \n #if defined(HAVE_CONFIG_H)\n-#include \"bitcoin-config.h\" /* for USE_QRCODE */\n+#include \"config/bitcoin-config.h\" /* for USE_QRCODE */\n #endif\n \n #ifdef USE_QRCODE"
      },
      {
        "sha": "9e3976644ede55b2e5991dec2029816dad8a5e15",
        "filename": "src/qt/recentrequeststablemodel.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 1,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/recentrequeststablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/recentrequeststablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/recentrequeststablemodel.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -21,7 +21,9 @@ RecentRequestsTableModel::RecentRequestsTableModel(CWallet *wallet, WalletModel\n         addNewRequest(request);\n \n     /* These columns must match the indices in the ColumnIndex enumeration */\n-    columns << tr(\"Date\") << tr(\"Label\") << tr(\"Message\") << tr(\"Amount\");\n+    columns << tr(\"Date\") << tr(\"Label\") << tr(\"Message\") << getAmountTitle();\n+\n+    connect(walletModel->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n }\n \n RecentRequestsTableModel::~RecentRequestsTableModel()\n@@ -77,10 +79,17 @@ QVariant RecentRequestsTableModel::data(const QModelIndex &index, int role) cons\n         case Amount:\n             if (rec->recipient.amount == 0 && role == Qt::DisplayRole)\n                 return tr(\"(no amount)\");\n+            else if (role == Qt::EditRole)\n+                return BitcoinUnits::format(walletModel->getOptionsModel()->getDisplayUnit(), rec->recipient.amount, false, BitcoinUnits::separatorNever);\n             else\n                 return BitcoinUnits::format(walletModel->getOptionsModel()->getDisplayUnit(), rec->recipient.amount);\n         }\n     }\n+    else if (role == Qt::TextAlignmentRole)\n+    {\n+        if (index.column() == Amount)\n+            return (int)(Qt::AlignRight|Qt::AlignVCenter);\n+    }\n     return QVariant();\n }\n \n@@ -101,6 +110,24 @@ QVariant RecentRequestsTableModel::headerData(int section, Qt::Orientation orien\n     return QVariant();\n }\n \n+/** Updates the column title to \"Amount (DisplayUnit)\" and emits headerDataChanged() signal for table headers to react. */\n+void RecentRequestsTableModel::updateAmountColumnTitle()\n+{\n+    columns[Amount] = getAmountTitle();\n+    emit headerDataChanged(Qt::Horizontal,Amount,Amount);\n+}\n+\n+/** Gets title for amount column including current display unit if optionsModel reference available. */\n+QString RecentRequestsTableModel::getAmountTitle()\n+{\n+    QString amountTitle = tr(\"Amount\");\n+    if (this->walletModel->getOptionsModel() != NULL)\n+    {\n+        amountTitle += \" (\"+BitcoinUnits::name(this->walletModel->getOptionsModel()->getDisplayUnit()) + \")\";\n+    }\n+    return amountTitle;\n+}\n+\n QModelIndex RecentRequestsTableModel::index(int row, int column, const QModelIndex &parent) const\n {\n     Q_UNUSED(parent);\n@@ -185,6 +212,11 @@ void RecentRequestsTableModel::sort(int column, Qt::SortOrder order)\n     emit dataChanged(index(0, 0, QModelIndex()), index(list.size() - 1, NUMBER_OF_COLUMNS - 1, QModelIndex()));\n }\n \n+void RecentRequestsTableModel::updateDisplayUnit()\n+{\n+    updateAmountColumnTitle();\n+}\n+\n bool RecentRequestEntryLessThan::operator()(RecentRequestEntry &left, RecentRequestEntry &right) const\n {\n     RecentRequestEntry *pLeft = &left;"
      },
      {
        "sha": "4f0b241259de92783097a33cbab7cfa58c431555",
        "filename": "src/qt/recentrequeststablemodel.h",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/recentrequeststablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/recentrequeststablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/recentrequeststablemodel.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -91,12 +91,18 @@ class RecentRequestsTableModel: public QAbstractTableModel\n \n public slots:\n     void sort(int column, Qt::SortOrder order = Qt::AscendingOrder);\n+    void updateDisplayUnit();\n \n private:\n     WalletModel *walletModel;\n     QStringList columns;\n     QList<RecentRequestEntry> list;\n     int64_t nReceiveRequestsMaxId;\n+\n+    /** Updates the column title to \"Amount (DisplayUnit)\" and emits headerDataChanged() signal for table headers to react. */\n+    void updateAmountColumnTitle();\n+    /** Gets title for amount column including current display unit if optionsModel reference available. */\n+    QString getAmountTitle();\n };\n \n #endif"
      },
      {
        "sha": "809235be5f9c5aa3e35b70ca30e8fe9f1b979a66",
        "filename": "src/qt/res/bitcoin-qt-res.rc",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/res/bitcoin-qt-res.rc",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/res/bitcoin-qt-res.rc",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/bitcoin-qt-res.rc?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -8,7 +8,6 @@ IDI_ICON2 ICON DISCARDABLE \"icons/bitcoin_testnet.ico\"\n #define VER_PRODUCTVERSION_STR STRINGIZE(CLIENT_VERSION_MAJOR) \".\" STRINGIZE(CLIENT_VERSION_MINOR) \".\" STRINGIZE(CLIENT_VERSION_REVISION) \".\" STRINGIZE(CLIENT_VERSION_BUILD)\n #define VER_FILEVERSION        VER_PRODUCTVERSION\n #define VER_FILEVERSION_STR    VER_PRODUCTVERSION_STR\n-#define COPYRIGHT_STR          \"2009-\" STRINGIZE(COPYRIGHT_YEAR) \" The Bitcoin developers\"\n \n VS_VERSION_INFO VERSIONINFO\n FILEVERSION     VER_FILEVERSION"
      },
      {
        "sha": "ec3497435c9bd96caa594d5fa007a80efda05a04",
        "filename": "src/qt/res/icons/unit_btc.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/res/icons/unit_btc.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/res/icons/unit_btc.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/icons/unit_btc.png?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5"
      },
      {
        "sha": "32bf2f2ca05a4768fc8e280a1e4620e3daf42538",
        "filename": "src/qt/res/icons/unit_mbtc.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/res/icons/unit_mbtc.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/res/icons/unit_mbtc.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/icons/unit_mbtc.png?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5"
      },
      {
        "sha": "d5a154882b66ec85df4e7fa6a05d5e074bbdb4ff",
        "filename": "src/qt/res/icons/unit_ubtc.png",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/res/icons/unit_ubtc.png",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/res/icons/unit_ubtc.png",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/res/icons/unit_ubtc.png?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5"
      },
      {
        "sha": "9b67f8125f173d48efde15471a39bfb2657ed457",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 7,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -231,6 +231,7 @@ RPCConsole::RPCConsole(QWidget *parent) :\n \n     startExecutor();\n     setTrafficGraphRange(INITIAL_TRAFFIC_GRAPH_MINS);\n+\n     ui->detailWidget->hide();\n \n     clear();\n@@ -316,7 +317,7 @@ void RPCConsole::setClientModel(ClientModel *model)\n         ui->buildDate->setText(model->formatBuildDate());\n         ui->startupTime->setText(model->formatClientStartupTime());\n \n-        ui->networkName->setText(model->getNetworkName());\n+        ui->networkName->setText(QString::fromStdString(Params().NetworkIDString()));\n     }\n }\n \n@@ -472,6 +473,10 @@ void RPCConsole::on_tabWidget_currentChanged(int index)\n     {\n         ui->lineEdit->setFocus();\n     }\n+    else if(ui->tabWidget->widget(index) == ui->tab_peers)\n+    {\n+        initPeerTable();\n+    }\n }\n \n void RPCConsole::on_openDebugLogfileButton_clicked()\n@@ -581,7 +586,7 @@ void RPCConsole::peerLayoutChanged()\n     if (fUnselect && selectedRow >= 0)\n     {\n         ui->peerWidget->selectionModel()->select(QItemSelection(selectedModelIndex.first(), selectedModelIndex.last()),\n-                                                 QItemSelectionModel::Deselect);\n+            QItemSelectionModel::Deselect);\n     }\n \n     if (fReselect)\n@@ -647,29 +652,44 @@ void RPCConsole::updateNodeDetail(const CNodeCombinedStats *combinedStats)\n         ui->peerBanScore->setText(tr(\"Fetching...\"));\n }\n \n+void RPCConsole::initPeerTable()\n+{\n+    if (!clientModel)\n+        return;\n+\n+    // peerWidget needs a resize in case the dialog has non-default geometry\n+    columnResizingFixer->stretchColumnWidth(PeerTableModel::Address);\n+\n+    // start PeerTableModel auto refresh\n+    clientModel->getPeerTableModel()->startAutoRefresh(1000);\n+}\n+\n // We override the virtual resizeEvent of the QWidget to adjust tables column\n // sizes as the tables width is proportional to the dialogs width.\n void RPCConsole::resizeEvent(QResizeEvent *event)\n {\n     QWidget::resizeEvent(event);\n+\n+    if (!clientModel)\n+        return;\n+\n     columnResizingFixer->stretchColumnWidth(PeerTableModel::Address);\n }\n \n void RPCConsole::showEvent(QShowEvent *event)\n {\n     QWidget::showEvent(event);\n \n-    // peerWidget needs a resize in case the dialog has non-default geometry\n-    columnResizingFixer->stretchColumnWidth(PeerTableModel::Address);\n-\n-    // start PeerTableModel auto refresh\n-    clientModel->getPeerTableModel()->startAutoRefresh(1000);\n+    initPeerTable();\n }\n \n void RPCConsole::hideEvent(QHideEvent *event)\n {\n     QWidget::hideEvent(event);\n \n+    if (!clientModel)\n+        return;\n+\n     // stop PeerTableModel auto refresh\n     clientModel->getPeerTableModel()->stopAutoRefresh();\n }"
      },
      {
        "sha": "94672b30cc0901c42ceb9c538617a7f0006b5827",
        "filename": "src/qt/rpcconsole.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/rpcconsole.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/rpcconsole.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -13,7 +13,6 @@\n #include <QDialog>\n \n class ClientModel;\n-class CNodeCombinedStats;\n \n QT_BEGIN_NAMESPACE\n class QItemSelection;\n@@ -48,6 +47,8 @@ class RPCConsole: public QDialog\n private:\n     /** show detailed information on ui about selected node */\n     void updateNodeDetail(const CNodeCombinedStats *combinedStats);\n+    /** initialize peer table */\n+    void initPeerTable();\n \n     enum ColumnWidths\n     {"
      },
      {
        "sha": "25e3d2a0dc1f838dc7130c12a3a6b2d9c7ba288d",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 8,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -90,8 +90,9 @@ void SendCoinsDialog::setModel(WalletModel *model)\n             }\n         }\n \n-        setBalance(model->getBalance(), model->getUnconfirmedBalance(), model->getImmatureBalance());\n-        connect(model, SIGNAL(balanceChanged(qint64, qint64, qint64)), this, SLOT(setBalance(qint64, qint64, qint64)));\n+        setBalance(model->getBalance(), model->getUnconfirmedBalance(), model->getImmatureBalance(),\n+                   model->getWatchBalance(), model->getWatchUnconfirmedBalance(), model->getWatchImmatureBalance());\n+        connect(model, SIGNAL(balanceChanged(qint64, qint64, qint64, qint64, qint64, qint64)), this, SLOT(setBalance(qint64, qint64, qint64, qint64, qint64, qint64)));\n         connect(model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n \n         // Coin Control\n@@ -142,7 +143,7 @@ void SendCoinsDialog::on_sendButton_clicked()\n     foreach(const SendCoinsRecipient &rcp, recipients)\n     {\n         // generate bold amount string\n-        QString amount = \"<b>\" + BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), rcp.amount);\n+        QString amount = \"<b>\" + BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), rcp.amount);\n         amount.append(\"</b>\");\n         // generate monospace address string\n         QString address = \"<span style='font-family: monospace;'>\" + rcp.address;\n@@ -210,7 +211,7 @@ void SendCoinsDialog::on_sendButton_clicked()\n     {\n         // append fee string if a fee is required\n         questionString.append(\"<hr /><span style='color:#aa0000;'>\");\n-        questionString.append(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), txFee));\n+        questionString.append(BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), txFee));\n         questionString.append(\"</span> \");\n         questionString.append(tr(\"added as transaction fee\"));\n     }\n@@ -222,10 +223,10 @@ void SendCoinsDialog::on_sendButton_clicked()\n     foreach(BitcoinUnits::Unit u, BitcoinUnits::availableUnits())\n     {\n         if(u != model->getOptionsModel()->getDisplayUnit())\n-            alternativeUnits.append(BitcoinUnits::formatWithUnit(u, totalAmount));\n+            alternativeUnits.append(BitcoinUnits::formatHtmlWithUnit(u, totalAmount));\n     }\n     questionString.append(tr(\"Total Amount %1 (= %2)\")\n-        .arg(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), totalAmount))\n+        .arg(BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), totalAmount))\n         .arg(alternativeUnits.join(\" \" + tr(\"or\") + \" \")));\n \n     QMessageBox::StandardButton retval = QMessageBox::question(this, tr(\"Confirm send coins\"),\n@@ -383,10 +384,14 @@ bool SendCoinsDialog::handlePaymentRequest(const SendCoinsRecipient &rv)\n     return true;\n }\n \n-void SendCoinsDialog::setBalance(qint64 balance, qint64 unconfirmedBalance, qint64 immatureBalance)\n+void SendCoinsDialog::setBalance(qint64 balance, qint64 unconfirmedBalance, qint64 immatureBalance, \n+                                 qint64 watchBalance, qint64 watchUnconfirmedBalance, qint64 watchImmatureBalance)\n {\n     Q_UNUSED(unconfirmedBalance);\n     Q_UNUSED(immatureBalance);\n+    Q_UNUSED(watchBalance);\n+    Q_UNUSED(watchUnconfirmedBalance);\n+    Q_UNUSED(watchImmatureBalance);\n \n     if(model && model->getOptionsModel())\n     {\n@@ -396,7 +401,7 @@ void SendCoinsDialog::setBalance(qint64 balance, qint64 unconfirmedBalance, qint\n \n void SendCoinsDialog::updateDisplayUnit()\n {\n-    setBalance(model->getBalance(), 0, 0);\n+    setBalance(model->getBalance(), 0, 0, 0, 0, 0);\n }\n \n void SendCoinsDialog::processSendCoinsReturn(const WalletModel::SendCoinsReturn &sendCoinsReturn, const QString &msgArg)"
      },
      {
        "sha": "6cdf4a00c8dd1ae31caf027679ee5cf68b16f745",
        "filename": "src/qt/sendcoinsdialog.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/sendcoinsdialog.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/sendcoinsdialog.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -47,7 +47,8 @@ public slots:\n     void accept();\n     SendCoinsEntry *addEntry();\n     void updateTabsAndLabels();\n-    void setBalance(qint64 balance, qint64 unconfirmedBalance, qint64 immatureBalance);\n+    void setBalance(qint64 balance, qint64 unconfirmedBalance, qint64 immatureBalance,\n+                    qint64 watchOnlyBalance, qint64 watchUnconfBalance, qint64 watchImmatureBalance);\n \n private:\n     Ui::SendCoinsDialog *ui;"
      },
      {
        "sha": "52545c3857bcd5b1034f2e260e4a17a4bf8d37ab",
        "filename": "src/qt/sendcoinsentry.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 5,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/sendcoinsentry.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/sendcoinsentry.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsentry.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -34,6 +34,12 @@ SendCoinsEntry::SendCoinsEntry(QWidget *parent) :\n     GUIUtil::setupAddressWidget(ui->payTo, this);\n     // just a label for displaying bitcoin address(es)\n     ui->payTo_is->setFont(GUIUtil::bitcoinAddressFont());\n+\n+    // Connect signals\n+    connect(ui->payAmount, SIGNAL(valueChanged()), this, SIGNAL(payAmountChanged()));\n+    connect(ui->deleteButton, SIGNAL(clicked()), this, SLOT(deleteClicked()));\n+    connect(ui->deleteButton_is, SIGNAL(clicked()), this, SLOT(deleteClicked()));\n+    connect(ui->deleteButton_s, SIGNAL(clicked()), this, SLOT(deleteClicked()));\n }\n \n SendCoinsEntry::~SendCoinsEntry()\n@@ -72,11 +78,6 @@ void SendCoinsEntry::setModel(WalletModel *model)\n     if (model && model->getOptionsModel())\n         connect(model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n \n-    connect(ui->payAmount, SIGNAL(textChanged()), this, SIGNAL(payAmountChanged()));\n-    connect(ui->deleteButton, SIGNAL(clicked()), this, SLOT(deleteClicked()));\n-    connect(ui->deleteButton_is, SIGNAL(clicked()), this, SLOT(deleteClicked()));\n-    connect(ui->deleteButton_s, SIGNAL(clicked()), this, SLOT(deleteClicked()));\n-\n     clear();\n }\n \n@@ -130,6 +131,13 @@ bool SendCoinsEntry::validate()\n         retval = false;\n     }\n \n+    // Sending a zero amount is invalid\n+    if (ui->payAmount->value(0) <= 0)\n+    {\n+        ui->payAmount->setValid(false);\n+        retval = false;\n+    }\n+\n     // Reject dust outputs:\n     if (retval && GUIUtil::isDust(ui->payTo->text(), ui->payAmount->value())) {\n         ui->payAmount->setValid(false);"
      },
      {
        "sha": "d4d021e21c1cceb93186e4feea04631329adc196",
        "filename": "src/qt/signverifymessagedialog.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/signverifymessagedialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/signverifymessagedialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/signverifymessagedialog.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -27,7 +27,6 @@ SignVerifyMessageDialog::SignVerifyMessageDialog(QWidget *parent) :\n \n #if QT_VERSION >= 0x040700\n     ui->signatureOut_SM->setPlaceholderText(tr(\"Click \\\"Sign Message\\\" to generate signature\"));\n-    ui->addressIn_VM->setPlaceholderText(tr(\"Enter a Bitcoin address (e.g. 1NS17iag9jJgTHD1VXjvLCEnZuQ3rJDE9L)\"));\n #endif\n \n     GUIUtil::setupAddressWidget(ui->addressIn_SM, this);"
      },
      {
        "sha": "e92a7d2b1a4d06e826b43bc11bfc0dd4ef1aadc4",
        "filename": "src/qt/test/paymentservertests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/test/paymentservertests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/test/paymentservertests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/paymentservertests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -56,6 +56,7 @@ static SendCoinsRecipient handleRequest(PaymentServer* server, std::vector<unsig\n \n void PaymentServerTests::paymentServerTests()\n {\n+    SelectParams(CBaseChainParams::MAIN);\n     OptionsModel optionsModel;\n     PaymentServer* server = new PaymentServer(NULL, false);\n     X509_STORE* caStore = X509_STORE_new();"
      },
      {
        "sha": "03a2381c0665f6f17c1859f6e634855941f86298",
        "filename": "src/qt/test/test_main.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/test/test_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/test/test_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/test_main.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -1,5 +1,5 @@\n #if defined(HAVE_CONFIG_H)\n-#include \"bitcoin-config.h\"\n+#include \"config/bitcoin-config.h\"\n #endif\n \n #ifdef ENABLE_WALLET"
      },
      {
        "sha": "ac1614efd03e54e9d5aaee576a8738be37784657",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 46,
        "deletions": 23,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -12,12 +12,16 @@\n #include \"main.h\"\n #include \"paymentserver.h\"\n #include \"transactionrecord.h\"\n+#include \"timedata.h\"\n #include \"ui_interface.h\"\n #include \"wallet.h\"\n+#include \"script.h\"\n \n #include <stdint.h>\n #include <string>\n \n+using namespace std;\n+\n QString TransactionDesc::FormatTxStatus(const CWalletTx& wtx)\n {\n     AssertLockHeld(cs_main);\n@@ -51,8 +55,8 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n     strHTML += \"<html><font face='verdana, arial, helvetica, sans-serif'>\";\n \n     int64_t nTime = wtx.GetTxTime();\n-    int64_t nCredit = wtx.GetCredit();\n-    int64_t nDebit = wtx.GetDebit();\n+    int64_t nCredit = wtx.GetCredit(ISMINE_ALL);\n+    int64_t nDebit = wtx.GetDebit(ISMINE_ALL);\n     int64_t nNet = nCredit - nDebit;\n \n     strHTML += \"<b>\" + tr(\"Status\") + \":</b> \" + FormatTxStatus(wtx);\n@@ -94,10 +98,11 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n                     strHTML += \"<b>\" + tr(\"From\") + \":</b> \" + tr(\"unknown\") + \"<br>\";\n                     strHTML += \"<b>\" + tr(\"To\") + \":</b> \";\n                     strHTML += GUIUtil::HtmlEscape(rec->address);\n+                    QString addressOwned = (::IsMine(*wallet, address) == ISMINE_SPENDABLE) ? tr(\"own address\") : tr(\"watch-only\");\n                     if (!wallet->mapAddressBook[address].name.empty())\n-                        strHTML += \" (\" + tr(\"own address\") + \", \" + tr(\"label\") + \": \" + GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \")\";\n+                        strHTML += \" (\" + addressOwned + \", \" + tr(\"label\") + \": \" + GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \")\";\n                     else\n-                        strHTML += \" (\" + tr(\"own address\") + \")\";\n+                        strHTML += \" (\" + addressOwned + \")\";\n                     strHTML += \"<br>\";\n                 }\n             }\n@@ -128,10 +133,10 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n         //\n         int64_t nUnmatured = 0;\n         BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-            nUnmatured += wallet->GetCredit(txout);\n+            nUnmatured += wallet->GetCredit(txout, ISMINE_ALL);\n         strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \";\n         if (wtx.IsInMainChain())\n-            strHTML += BitcoinUnits::formatWithUnit(unit, nUnmatured)+ \" (\" + tr(\"matures in %n more block(s)\", \"\", wtx.GetBlocksToMaturity()) + \")\";\n+            strHTML += BitcoinUnits::formatHtmlWithUnit(unit, nUnmatured)+ \" (\" + tr(\"matures in %n more block(s)\", \"\", wtx.GetBlocksToMaturity()) + \")\";\n         else\n             strHTML += \"(\" + tr(\"not accepted\") + \")\";\n         strHTML += \"<br>\";\n@@ -141,26 +146,37 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n         //\n         // Credit\n         //\n-        strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, nNet) + \"<br>\";\n+        strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, nNet) + \"<br>\";\n     }\n     else\n     {\n-        bool fAllFromMe = true;\n+        isminetype fAllFromMe = ISMINE_SPENDABLE;\n         BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n-            fAllFromMe = fAllFromMe && wallet->IsMine(txin);\n+        {\n+            isminetype mine = wallet->IsMine(txin);\n+            if(fAllFromMe > mine) fAllFromMe = mine;\n+        }\n \n-        bool fAllToMe = true;\n+        isminetype fAllToMe = ISMINE_SPENDABLE;\n         BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-            fAllToMe = fAllToMe && wallet->IsMine(txout);\n+        {\n+            isminetype mine = wallet->IsMine(txout);\n+            if(fAllToMe > mine) fAllToMe = mine;\n+        }\n \n         if (fAllFromMe)\n         {\n+            if(fAllFromMe == ISMINE_WATCH_ONLY)\n+                strHTML += \"<b>\" + tr(\"From\") + \":</b> \" + tr(\"watch-only\") + \"<br>\";\n+\n             //\n             // Debit\n             //\n             BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n             {\n-                if (wallet->IsMine(txout))\n+                // Ignore change\n+                isminetype toSelf = wallet->IsMine(txout);\n+                if ((toSelf == ISMINE_SPENDABLE) && (fAllFromMe == ISMINE_SPENDABLE))\n                     continue;\n \n                 if (!wtx.mapValue.count(\"to\") || wtx.mapValue[\"to\"].empty())\n@@ -173,25 +189,31 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n                         if (wallet->mapAddressBook.count(address) && !wallet->mapAddressBook[address].name.empty())\n                             strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \" \";\n                         strHTML += GUIUtil::HtmlEscape(CBitcoinAddress(address).ToString());\n+                        if(toSelf == ISMINE_SPENDABLE)\n+                            strHTML += \" (own address)\";\n+                        else if(toSelf == ISMINE_WATCH_ONLY)\n+                            strHTML += \" (watch-only)\";\n                         strHTML += \"<br>\";\n                     }\n                 }\n \n-                strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, -txout.nValue) + \"<br>\";\n+                strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, -txout.nValue) + \"<br>\";\n+                if(toSelf)\n+                    strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, txout.nValue) + \"<br>\";\n             }\n \n             if (fAllToMe)\n             {\n                 // Payment to self\n                 int64_t nChange = wtx.GetChange();\n                 int64_t nValue = nCredit - nChange;\n-                strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, -nValue) + \"<br>\";\n-                strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, nValue) + \"<br>\";\n+                strHTML += \"<b>\" + tr(\"Total debit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, -nValue) + \"<br>\";\n+                strHTML += \"<b>\" + tr(\"Total credit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, nValue) + \"<br>\";\n             }\n \n             int64_t nTxFee = nDebit - wtx.GetValueOut();\n             if (nTxFee > 0)\n-                strHTML += \"<b>\" + tr(\"Transaction fee\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, -nTxFee) + \"<br>\";\n+                strHTML += \"<b>\" + tr(\"Transaction fee\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, -nTxFee) + \"<br>\";\n         }\n         else\n         {\n@@ -200,14 +222,14 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n             //\n             BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n                 if (wallet->IsMine(txin))\n-                    strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, -wallet->GetDebit(txin)) + \"<br>\";\n+                    strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, -wallet->GetDebit(txin, ISMINE_ALL)) + \"<br>\";\n             BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n                 if (wallet->IsMine(txout))\n-                    strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, wallet->GetCredit(txout)) + \"<br>\";\n+                    strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, wallet->GetCredit(txout, ISMINE_ALL)) + \"<br>\";\n         }\n     }\n \n-    strHTML += \"<b>\" + tr(\"Net amount\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, nNet, true) + \"<br>\";\n+    strHTML += \"<b>\" + tr(\"Net amount\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, nNet, true) + \"<br>\";\n \n     //\n     // Message\n@@ -253,10 +275,10 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n         strHTML += \"<hr><br>\" + tr(\"Debug information\") + \"<br><br>\";\n         BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n             if(wallet->IsMine(txin))\n-                strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, -wallet->GetDebit(txin)) + \"<br>\";\n+                strHTML += \"<b>\" + tr(\"Debit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, -wallet->GetDebit(txin, ISMINE_ALL)) + \"<br>\";\n         BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n             if(wallet->IsMine(txout))\n-                strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatWithUnit(unit, wallet->GetCredit(txout)) + \"<br>\";\n+                strHTML += \"<b>\" + tr(\"Credit\") + \":</b> \" + BitcoinUnits::formatHtmlWithUnit(unit, wallet->GetCredit(txout, ISMINE_ALL)) + \"<br>\";\n \n         strHTML += \"<br><b>\" + tr(\"Transaction\") + \":</b><br>\";\n         strHTML += GUIUtil::HtmlEscape(wtx.ToString(), true);\n@@ -282,8 +304,9 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n                             strHTML += GUIUtil::HtmlEscape(wallet->mapAddressBook[address].name) + \" \";\n                         strHTML += QString::fromStdString(CBitcoinAddress(address).ToString());\n                     }\n-                    strHTML = strHTML + \" \" + tr(\"Amount\") + \"=\" + BitcoinUnits::formatWithUnit(unit, vout.nValue);\n-                    strHTML = strHTML + \" IsMine=\" + (wallet->IsMine(vout) ? tr(\"true\") : tr(\"false\")) + \"</li>\";\n+                    strHTML = strHTML + \" \" + tr(\"Amount\") + \"=\" + BitcoinUnits::formatHtmlWithUnit(unit, vout.nValue);\n+                    strHTML = strHTML + \" IsMine=\" + (wallet->IsMine(vout) & ISMINE_SPENDABLE ? tr(\"true\") : tr(\"false\")) + \"</li>\";\n+                    strHTML = strHTML + \" IsWatchOnly=\" + (wallet->IsMine(vout) & ISMINE_WATCH_ONLY ? tr(\"true\") : tr(\"false\")) + \"</li>\";\n                 }\n             }\n         }"
      },
      {
        "sha": "d7bd25e08b4c831b6b4cd7078751c4e3d40c59b9",
        "filename": "src/qt/transactionrecord.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 6,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/transactionrecord.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/transactionrecord.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -5,6 +5,7 @@\n #include \"transactionrecord.h\"\n \n #include \"base58.h\"\n+#include \"timedata.h\"\n #include \"wallet.h\"\n \n #include <stdint.h>\n@@ -32,7 +33,7 @@ QList<TransactionRecord> TransactionRecord::decomposeTransaction(const CWallet *\n     QList<TransactionRecord> parts;\n     int64_t nTime = wtx.GetTxTime();\n     int64_t nCredit = wtx.GetCredit(true);\n-    int64_t nDebit = wtx.GetDebit();\n+    int64_t nDebit = wtx.GetDebit(ISMINE_ALL);\n     int64_t nNet = nCredit - nDebit;\n     uint256 hash = wtx.GetHash();\n     std::map<std::string, std::string> mapValue = wtx.mapValue;\n@@ -44,12 +45,14 @@ QList<TransactionRecord> TransactionRecord::decomposeTransaction(const CWallet *\n         //\n         BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n         {\n-            if(wallet->IsMine(txout))\n+            isminetype mine = wallet->IsMine(txout);\n+            if(mine)\n             {\n                 TransactionRecord sub(hash, nTime);\n                 CTxDestination address;\n                 sub.idx = parts.size(); // sequence number\n                 sub.credit = txout.nValue;\n+                sub.involvesWatchAddress = mine == ISMINE_WATCH_ONLY;\n                 if (ExtractDestination(txout.scriptPubKey, address) && IsMine(*wallet, address))\n                 {\n                     // Received by Bitcoin Address\n@@ -74,13 +77,22 @@ QList<TransactionRecord> TransactionRecord::decomposeTransaction(const CWallet *\n     }\n     else\n     {\n-        bool fAllFromMe = true;\n+        bool involvesWatchAddress = false;\n+        isminetype fAllFromMe = ISMINE_SPENDABLE;\n         BOOST_FOREACH(const CTxIn& txin, wtx.vin)\n-            fAllFromMe = fAllFromMe && wallet->IsMine(txin);\n+        {\n+            isminetype mine = wallet->IsMine(txin);\n+            if(mine == ISMINE_WATCH_ONLY) involvesWatchAddress = true;\n+            if(fAllFromMe > mine) fAllFromMe = mine;\n+        }\n \n-        bool fAllToMe = true;\n+        isminetype fAllToMe = ISMINE_SPENDABLE;\n         BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n-            fAllToMe = fAllToMe && wallet->IsMine(txout);\n+        {\n+            isminetype mine = wallet->IsMine(txout);\n+            if(mine == ISMINE_WATCH_ONLY) involvesWatchAddress = true;\n+            if(fAllToMe > mine) fAllToMe = mine;\n+        }\n \n         if (fAllFromMe && fAllToMe)\n         {\n@@ -89,6 +101,7 @@ QList<TransactionRecord> TransactionRecord::decomposeTransaction(const CWallet *\n \n             parts.append(TransactionRecord(hash, nTime, TransactionRecord::SendToSelf, \"\",\n                             -(nDebit - nChange), nCredit - nChange));\n+            parts.last().involvesWatchAddress = involvesWatchAddress;   // maybe pass to TransactionRecord as constructor argument\n         }\n         else if (fAllFromMe)\n         {\n@@ -102,6 +115,7 @@ QList<TransactionRecord> TransactionRecord::decomposeTransaction(const CWallet *\n                 const CTxOut& txout = wtx.vout[nOut];\n                 TransactionRecord sub(hash, nTime);\n                 sub.idx = parts.size();\n+                sub.involvesWatchAddress = involvesWatchAddress;\n \n                 if(wallet->IsMine(txout))\n                 {\n@@ -142,6 +156,7 @@ QList<TransactionRecord> TransactionRecord::decomposeTransaction(const CWallet *\n             // Mixed debit transaction, can't break down payees\n             //\n             parts.append(TransactionRecord(hash, nTime, TransactionRecord::Other, \"\", nNet, 0));\n+            parts.last().involvesWatchAddress = involvesWatchAddress;\n         }\n     }\n "
      },
      {
        "sha": "626b7654c62267c8c1c070c727b5c8778ae7730e",
        "filename": "src/qt/transactionrecord.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/transactionrecord.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/transactionrecord.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionrecord.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -121,6 +121,9 @@ class TransactionRecord\n     /** Status: can change with block chain update */\n     TransactionStatus status;\n \n+    /** Whether the transaction was sent/received with a watch-only address */\n+    bool involvesWatchAddress;\n+\n     /** Return the unique identifier for this transaction (part) */\n     QString getTxID() const;\n "
      },
      {
        "sha": "4825713b69b2649085bef109535f7c01f59ac7a7",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 14,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -5,7 +5,6 @@\n #include \"transactiontablemodel.h\"\n \n #include \"addresstablemodel.h\"\n-#include \"bitcoinunits.h\"\n #include \"guiconstants.h\"\n #include \"guiutil.h\"\n #include \"optionsmodel.h\"\n@@ -130,12 +129,12 @@ class TransactionTablePriv\n             case CT_NEW:\n                 if(inModel)\n                 {\n-                    qDebug() << \"TransactionTablePriv::updateWallet : Warning: Got CT_NEW, but transaction is already in model\";\n+                    qWarning() << \"TransactionTablePriv::updateWallet : Warning: Got CT_NEW, but transaction is already in model\";\n                     break;\n                 }\n                 if(!inWallet)\n                 {\n-                    qDebug() << \"TransactionTablePriv::updateWallet : Warning: Got CT_NEW, but transaction is not in wallet\";\n+                    qWarning() << \"TransactionTablePriv::updateWallet : Warning: Got CT_NEW, but transaction is not in wallet\";\n                     break;\n                 }\n                 if(showTransaction)\n@@ -159,7 +158,7 @@ class TransactionTablePriv\n             case CT_DELETED:\n                 if(!inModel)\n                 {\n-                    qDebug() << \"TransactionTablePriv::updateWallet : Warning: Got CT_DELETED, but transaction is not in model\";\n+                    qWarning() << \"TransactionTablePriv::updateWallet : Warning: Got CT_DELETED, but transaction is not in model\";\n                     break;\n                 }\n                 // Removed -- remove entire transaction from table\n@@ -235,8 +234,7 @@ TransactionTableModel::TransactionTableModel(CWallet* wallet, WalletModel *paren\n         walletModel(parent),\n         priv(new TransactionTablePriv(wallet, this))\n {\n-    columns << QString() << tr(\"Date\") << tr(\"Type\") << tr(\"Address\") << tr(\"Amount\");\n-\n+    columns << QString() << tr(\"Date\") << tr(\"Type\") << tr(\"Address\") << BitcoinUnits::getAmountColumnTitle(walletModel->getOptionsModel()->getDisplayUnit());\n     priv->refreshWallet();\n \n     connect(walletModel->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n@@ -247,6 +245,13 @@ TransactionTableModel::~TransactionTableModel()\n     delete priv;\n }\n \n+/** Updates the column title to \"Amount (DisplayUnit)\" and emits headerDataChanged() signal for table headers to react. */\n+void TransactionTableModel::updateAmountColumnTitle()\n+{\n+    columns[Amount] = BitcoinUnits::getAmountColumnTitle(walletModel->getOptionsModel()->getDisplayUnit());\n+    emit headerDataChanged(Qt::Horizontal,Amount,Amount);\n+}\n+\n void TransactionTableModel::updateTransaction(const QString &hash, int status)\n {\n     uint256 updated;\n@@ -388,19 +393,22 @@ QVariant TransactionTableModel::txAddressDecoration(const TransactionRecord *wtx\n \n QString TransactionTableModel::formatTxToAddress(const TransactionRecord *wtx, bool tooltip) const\n {\n+    // mark transactions involving watch-only addresses:\n+    QString watchAddress = wtx->involvesWatchAddress ? \" (w) \" : \"\";\n+\n     switch(wtx->type)\n     {\n     case TransactionRecord::RecvFromOther:\n-        return QString::fromStdString(wtx->address);\n+        return QString::fromStdString(wtx->address) + watchAddress;\n     case TransactionRecord::RecvWithAddress:\n     case TransactionRecord::SendToAddress:\n     case TransactionRecord::Generated:\n-        return lookupAddress(wtx->address, tooltip);\n+        return lookupAddress(wtx->address, tooltip) + watchAddress;\n     case TransactionRecord::SendToOther:\n-        return QString::fromStdString(wtx->address);\n+        return QString::fromStdString(wtx->address) + watchAddress;\n     case TransactionRecord::SendToSelf:\n     default:\n-        return tr(\"(n/a)\");\n+        return tr(\"(n/a)\") + watchAddress;\n     }\n }\n \n@@ -425,9 +433,9 @@ QVariant TransactionTableModel::addressColor(const TransactionRecord *wtx) const\n     return QVariant();\n }\n \n-QString TransactionTableModel::formatTxAmount(const TransactionRecord *wtx, bool showUnconfirmed) const\n+QString TransactionTableModel::formatTxAmount(const TransactionRecord *wtx, bool showUnconfirmed, BitcoinUnits::SeparatorStyle separators) const\n {\n-    QString str = BitcoinUnits::format(walletModel->getOptionsModel()->getDisplayUnit(), wtx->credit + wtx->debit);\n+    QString str = BitcoinUnits::format(walletModel->getOptionsModel()->getDisplayUnit(), wtx->credit + wtx->debit, false, separators);\n     if(showUnconfirmed)\n     {\n         if(!wtx->status.countsForBalance)\n@@ -512,7 +520,7 @@ QVariant TransactionTableModel::data(const QModelIndex &index, int role) const\n         case ToAddress:\n             return formatTxToAddress(rec, false);\n         case Amount:\n-            return formatTxAmount(rec);\n+            return formatTxAmount(rec, true, BitcoinUnits::separatorAlways);\n         }\n         break;\n     case Qt::EditRole:\n@@ -569,7 +577,8 @@ QVariant TransactionTableModel::data(const QModelIndex &index, int role) const\n     case ConfirmedRole:\n         return rec->status.countsForBalance;\n     case FormattedAmountRole:\n-        return formatTxAmount(rec, false);\n+\t// Used for copy/export, so don't include separators\n+        return formatTxAmount(rec, false, BitcoinUnits::separatorNever);\n     case StatusRole:\n         return rec->status.status;\n     }\n@@ -624,5 +633,6 @@ QModelIndex TransactionTableModel::index(int row, int column, const QModelIndex\n void TransactionTableModel::updateDisplayUnit()\n {\n     // emit dataChanged to update Amount column with the current unit\n+    updateAmountColumnTitle();\n     emit dataChanged(index(0, Amount), index(priv->size()-1, Amount));\n }"
      },
      {
        "sha": "ad88d14a90399c6e2a005248bc445e9454a13c76",
        "filename": "src/qt/transactiontablemodel.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/transactiontablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/transactiontablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -8,6 +8,8 @@\n #include <QAbstractTableModel>\n #include <QStringList>\n \n+#include \"bitcoinunits.h\"\n+\n class TransactionRecord;\n class TransactionTablePriv;\n class WalletModel;\n@@ -78,7 +80,7 @@ class TransactionTableModel : public QAbstractTableModel\n     QString formatTxDate(const TransactionRecord *wtx) const;\n     QString formatTxType(const TransactionRecord *wtx) const;\n     QString formatTxToAddress(const TransactionRecord *wtx, bool tooltip) const;\n-    QString formatTxAmount(const TransactionRecord *wtx, bool showUnconfirmed=true) const;\n+    QString formatTxAmount(const TransactionRecord *wtx, bool showUnconfirmed=true, BitcoinUnits::SeparatorStyle separators=BitcoinUnits::separatorStandard) const;\n     QString formatTooltip(const TransactionRecord *rec) const;\n     QVariant txStatusDecoration(const TransactionRecord *wtx) const;\n     QVariant txAddressDecoration(const TransactionRecord *wtx) const;\n@@ -87,6 +89,8 @@ public slots:\n     void updateTransaction(const QString &hash, int status);\n     void updateConfirmations();\n     void updateDisplayUnit();\n+    /** Updates the column title to \"Amount (DisplayUnit)\" and emits headerDataChanged() signal for table headers to react. */\n+    void updateAmountColumnTitle();\n \n     friend class TransactionTablePriv;\n };"
      },
      {
        "sha": "7e8b71d8ea9cc0add378eb175027230e55ed580b",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 1,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -123,6 +123,8 @@ TransactionView::TransactionView(QWidget *parent) :\n     view->setTabKeyNavigation(false);\n     view->setContextMenuPolicy(Qt::CustomContextMenu);\n \n+    view->installEventFilter(this);\n+\n     transactionView = view;\n \n     // Actions\n@@ -309,7 +311,7 @@ void TransactionView::exportClicked()\n     writer.addColumn(tr(\"Type\"), TransactionTableModel::Type, Qt::EditRole);\n     writer.addColumn(tr(\"Label\"), 0, TransactionTableModel::LabelRole);\n     writer.addColumn(tr(\"Address\"), 0, TransactionTableModel::AddressRole);\n-    writer.addColumn(tr(\"Amount\"), 0, TransactionTableModel::FormattedAmountRole);\n+    writer.addColumn(BitcoinUnits::getAmountColumnTitle(model->getOptionsModel()->getDisplayUnit()), 0, TransactionTableModel::FormattedAmountRole);\n     writer.addColumn(tr(\"ID\"), 0, TransactionTableModel::TxIDRole);\n \n     if(!writer.write()) {\n@@ -480,3 +482,22 @@ void TransactionView::resizeEvent(QResizeEvent* event)\n     QWidget::resizeEvent(event);\n     columnResizingFixer->stretchColumnWidth(TransactionTableModel::ToAddress);\n }\n+\n+// Need to override default Ctrl+C action for amount as default behaviour is just to copy DisplayRole text\n+bool TransactionView::eventFilter(QObject *obj, QEvent *event)\n+{\n+    if (event->type() == QEvent::KeyPress)\n+    {\n+        QKeyEvent *ke = static_cast<QKeyEvent *>(event);\n+        if (ke->key() == Qt::Key_C && ke->modifiers().testFlag(Qt::ControlModifier))\n+        {\n+            QModelIndex i = this->transactionView->currentIndex();\n+            if (i.isValid() && i.column() == TransactionTableModel::Amount)\n+            {\n+                 GUIUtil::setClipboard(i.data(TransactionTableModel::FormattedAmountRole).toString());\n+                 return true;\n+            }\n+        }\n+    }\n+    return QWidget::eventFilter(obj, event);\n+}"
      },
      {
        "sha": "618efbc5658a14e17e25d2326fa3dd59500724b1",
        "filename": "src/qt/transactionview.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/transactionview.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/transactionview.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -8,6 +8,7 @@\n #include \"guiutil.h\"\n \n #include <QWidget>\n+#include <QKeyEvent>\n \n class TransactionFilterProxy;\n class WalletModel;\n@@ -78,6 +79,8 @@ class TransactionView : public QWidget\n \n     virtual void resizeEvent(QResizeEvent* event);\n \n+    bool eventFilter(QObject *obj, QEvent *event);\n+\n private slots:\n     void contextualMenu(const QPoint &);\n     void dateRangeChanged();"
      },
      {
        "sha": "5fb0da145dea2d7268018029700a905454a32e94",
        "filename": "src/qt/utilitydialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/utilitydialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/utilitydialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/utilitydialog.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -117,6 +117,7 @@ void ShutdownWindow::showShutdownWindow(BitcoinGUI *window)\n         tr(\"Bitcoin Core is shutting down...\") + \"<br /><br />\" +\n         tr(\"Do not shut down the computer until this window disappears.\")));\n     shutdownWindow->setLayout(layout);\n+    shutdownWindow->setWindowTitle(window->windowTitle());\n \n     // Center shutdown window at where main window was\n     const QPoint global = window->mapToGlobal(window->rect().center());"
      },
      {
        "sha": "0ad123f39d4dcad2af4fcf410db706404cbbd1a3",
        "filename": "src/qt/walletmodel.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 9,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/walletmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/walletmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -24,6 +24,8 @@\n #include <QSet>\n #include <QTimer>\n \n+using namespace std;\n+\n WalletModel::WalletModel(CWallet *wallet, OptionsModel *optionsModel, QObject *parent) :\n     QObject(parent), wallet(wallet), optionsModel(optionsModel), addressTableModel(0),\n     transactionTableModel(0),\n@@ -33,6 +35,8 @@ WalletModel::WalletModel(CWallet *wallet, OptionsModel *optionsModel, QObject *p\n     cachedEncryptionStatus(Unencrypted),\n     cachedNumBlocks(0)\n {\n+    fProcessingQueuedTransactions = false;\n+\n     addressTableModel = new AddressTableModel(wallet, this);\n     transactionTableModel = new TransactionTableModel(wallet, this);\n     recentRequestsTableModel = new RecentRequestsTableModel(wallet, this);\n@@ -58,7 +62,8 @@ qint64 WalletModel::getBalance(const CCoinControl *coinControl) const\n         std::vector<COutput> vCoins;\n         wallet->AvailableCoins(vCoins, true, coinControl);\n         BOOST_FOREACH(const COutput& out, vCoins)\n-            nBalance += out.tx->vout[out.i].nValue;\n+            if(out.fSpendable)\n+                nBalance += out.tx->vout[out.i].nValue;\n \n         return nBalance;\n     }\n@@ -76,6 +81,21 @@ qint64 WalletModel::getImmatureBalance() const\n     return wallet->GetImmatureBalance();\n }\n \n+qint64 WalletModel::getWatchBalance() const\n+{\n+    return wallet->GetWatchOnlyBalance();\n+}\n+\n+qint64 WalletModel::getWatchUnconfirmedBalance() const\n+{\n+    return wallet->GetUnconfirmedWatchOnlyBalance();\n+}\n+\n+qint64 WalletModel::getWatchImmatureBalance() const\n+{\n+    return wallet->GetImmatureWatchOnlyBalance();\n+}\n+\n int WalletModel::getNumTransactions() const\n {\n     int numTransactions = 0;\n@@ -124,13 +144,21 @@ void WalletModel::checkBalanceChanged()\n     qint64 newBalance = getBalance();\n     qint64 newUnconfirmedBalance = getUnconfirmedBalance();\n     qint64 newImmatureBalance = getImmatureBalance();\n+    qint64 newWatchOnlyBalance = getWatchBalance();\n+    qint64 newWatchUnconfBalance = getWatchUnconfirmedBalance();\n+    qint64 newWatchImmatureBalance = getWatchImmatureBalance();\n \n-    if(cachedBalance != newBalance || cachedUnconfirmedBalance != newUnconfirmedBalance || cachedImmatureBalance != newImmatureBalance)\n+    if(cachedBalance != newBalance || cachedUnconfirmedBalance != newUnconfirmedBalance || cachedImmatureBalance != newImmatureBalance ||\n+        cachedWatchOnlyBalance != newWatchOnlyBalance || cachedWatchUnconfBalance != newWatchUnconfBalance || cachedWatchImmatureBalance != newWatchImmatureBalance)\n     {\n         cachedBalance = newBalance;\n         cachedUnconfirmedBalance = newUnconfirmedBalance;\n         cachedImmatureBalance = newImmatureBalance;\n-        emit balanceChanged(newBalance, newUnconfirmedBalance, newImmatureBalance);\n+        cachedWatchOnlyBalance = newWatchOnlyBalance;\n+        cachedWatchUnconfBalance = newWatchUnconfBalance;\n+        cachedWatchImmatureBalance = newWatchImmatureBalance;\n+        emit balanceChanged(newBalance, newUnconfirmedBalance, newImmatureBalance,\n+                            newWatchOnlyBalance, newWatchUnconfBalance, newWatchImmatureBalance);\n     }\n }\n \n@@ -458,8 +486,15 @@ static void ShowProgress(WalletModel *walletmodel, const std::string &title, int\n     if (nProgress == 100)\n     {\n         fQueueNotifications = false;\n-        BOOST_FOREACH(const PAIRTYPE(uint256, ChangeType)& notification, vQueueNotifications)\n-            NotifyTransactionChanged(walletmodel, NULL, notification.first, notification.second);\n+        if (vQueueNotifications.size() > 10) // prevent balloon spam, show maximum 10 balloons\n+            QMetaObject::invokeMethod(walletmodel, \"setProcessingQueuedTransactions\", Qt::QueuedConnection, Q_ARG(bool, true));\n+        for (unsigned int i = 0; i < vQueueNotifications.size(); ++i)\n+        {\n+            if (vQueueNotifications.size() - i <= 10)\n+                QMetaObject::invokeMethod(walletmodel, \"setProcessingQueuedTransactions\", Qt::QueuedConnection, Q_ARG(bool, false));\n+\n+            NotifyTransactionChanged(walletmodel, NULL, vQueueNotifications[i].first, vQueueNotifications[i].second);\n+        }\n         std::vector<std::pair<uint256, ChangeType> >().swap(vQueueNotifications); // clear\n     }\n }\n@@ -533,7 +568,7 @@ void WalletModel::getOutputs(const std::vector<COutPoint>& vOutpoints, std::vect\n         if (!wallet->mapWallet.count(outpoint.hash)) continue;\n         int nDepth = wallet->mapWallet[outpoint.hash].GetDepthInMainChain();\n         if (nDepth < 0) continue;\n-        COutput out(&wallet->mapWallet[outpoint.hash], outpoint.n, nDepth);\n+        COutput out(&wallet->mapWallet[outpoint.hash], outpoint.n, nDepth, true);\n         vOutputs.push_back(out);\n     }\n }\n@@ -560,7 +595,7 @@ void WalletModel::listCoins(std::map<QString, std::vector<COutput> >& mapCoins)\n         if (!wallet->mapWallet.count(outpoint.hash)) continue;\n         int nDepth = wallet->mapWallet[outpoint.hash].GetDepthInMainChain();\n         if (nDepth < 0) continue;\n-        COutput out(&wallet->mapWallet[outpoint.hash], outpoint.n, nDepth);\n+        COutput out(&wallet->mapWallet[outpoint.hash], outpoint.n, nDepth, true);\n         vCoins.push_back(out);\n     }\n \n@@ -571,11 +606,12 @@ void WalletModel::listCoins(std::map<QString, std::vector<COutput> >& mapCoins)\n         while (wallet->IsChange(cout.tx->vout[cout.i]) && cout.tx->vin.size() > 0 && wallet->IsMine(cout.tx->vin[0]))\n         {\n             if (!wallet->mapWallet.count(cout.tx->vin[0].prevout.hash)) break;\n-            cout = COutput(&wallet->mapWallet[cout.tx->vin[0].prevout.hash], cout.tx->vin[0].prevout.n, 0);\n+            cout = COutput(&wallet->mapWallet[cout.tx->vin[0].prevout.hash], cout.tx->vin[0].prevout.n, 0, true);\n         }\n \n         CTxDestination address;\n-        if(!ExtractDestination(cout.tx->vout[cout.i].scriptPubKey, address)) continue;\n+        if(!out.fSpendable || !ExtractDestination(cout.tx->vout[cout.i].scriptPubKey, address))\n+            continue;\n         mapCoins[CBitcoinAddress(address).ToString().c_str()].push_back(out);\n     }\n }"
      },
      {
        "sha": "2bb91d85a928a6beba05ada255b07d4b5136cd7e",
        "filename": "src/qt/walletmodel.h",
        "status": "modified",
        "additions": 12,
        "deletions": 1,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/walletmodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/walletmodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletmodel.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -128,8 +128,12 @@ class WalletModel : public QObject\n     qint64 getBalance(const CCoinControl *coinControl = NULL) const;\n     qint64 getUnconfirmedBalance() const;\n     qint64 getImmatureBalance() const;\n+    qint64 getWatchBalance() const;\n+    qint64 getWatchUnconfirmedBalance() const;\n+    qint64 getWatchImmatureBalance() const;\n     int getNumTransactions() const;\n     EncryptionStatus getEncryptionStatus() const;\n+    bool processingQueuedTransactions() { return fProcessingQueuedTransactions; }\n \n     // Check address for validity\n     bool validateAddress(const QString &address);\n@@ -193,6 +197,7 @@ class WalletModel : public QObject\n \n private:\n     CWallet *wallet;\n+    bool fProcessingQueuedTransactions;\n \n     // Wallet has an options model for wallet-specific options\n     // (transaction fee, for example)\n@@ -206,6 +211,9 @@ class WalletModel : public QObject\n     qint64 cachedBalance;\n     qint64 cachedUnconfirmedBalance;\n     qint64 cachedImmatureBalance;\n+    qint64 cachedWatchOnlyBalance;\n+    qint64 cachedWatchUnconfBalance;\n+    qint64 cachedWatchImmatureBalance;\n     qint64 cachedNumTransactions;\n     EncryptionStatus cachedEncryptionStatus;\n     int cachedNumBlocks;\n@@ -218,7 +226,8 @@ class WalletModel : public QObject\n \n signals:\n     // Signal that balance in wallet changed\n-    void balanceChanged(qint64 balance, qint64 unconfirmedBalance, qint64 immatureBalance);\n+    void balanceChanged(qint64 balance, qint64 unconfirmedBalance, qint64 immatureBalance,\n+                        qint64 watchOnlyBalance, qint64 watchUnconfBalance, qint64 watchImmatureBalance);\n \n     // Number of transactions in wallet changed\n     void numTransactionsChanged(int count);\n@@ -249,6 +258,8 @@ public slots:\n     void updateAddressBook(const QString &address, const QString &label, bool isMine, const QString &purpose, int status);\n     /* Current, immature or unconfirmed balance might have changed - emit 'balanceChanged' if so */\n     void pollBalanceChanged();\n+    /* Needed to update fProcessingQueuedTransactions through a QueuedConnection */\n+    void setProcessingQueuedTransactions(bool value) { fProcessingQueuedTransactions = value; }\n };\n \n #endif // WALLETMODEL_H"
      },
      {
        "sha": "b40ddc0a2f253c5bcfae9f04ebc0ba37a5f4095c",
        "filename": "src/qt/walletview.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/walletview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/walletview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -137,7 +137,7 @@ void WalletView::setWalletModel(WalletModel *walletModel)\n void WalletView::processNewTransaction(const QModelIndex& parent, int start, int /*end*/)\n {\n     // Prevent balloon-spam when initial block download is in progress\n-    if (!walletModel || !clientModel || clientModel->inInitialBlockDownload())\n+    if (!walletModel || walletModel->processingQueuedTransactions() || !clientModel || clientModel->inInitialBlockDownload())\n         return;\n \n     TransactionTableModel *ttm = walletModel->getTransactionTableModel();"
      },
      {
        "sha": "a06f42f66eb772a3bb4913b4439472cc315e7a99",
        "filename": "src/qt/winshutdownmonitor.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 3,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/winshutdownmonitor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/qt/winshutdownmonitor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/winshutdownmonitor.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -6,11 +6,14 @@\n \n #if defined(Q_OS_WIN) && QT_VERSION >= 0x050000\n #include \"init.h\"\n+#include \"util.h\"\n \n #include <windows.h>\n \n #include <QDebug>\n \n+#include <openssl/rand.h>\n+\n // If we don't want a message to be processed by Qt, return true and set result to\n // the value that the window procedure should return. Otherwise return false.\n bool WinShutdownMonitor::nativeEventFilter(const QByteArray &eventType, void *pMessage, long *pnResult)\n@@ -19,6 +22,16 @@ bool WinShutdownMonitor::nativeEventFilter(const QByteArray &eventType, void *pM\n \n        MSG *pMsg = static_cast<MSG *>(pMessage);\n \n+       // Seed OpenSSL PRNG with Windows event data (e.g.  mouse movements and other user interactions)\n+       if (RAND_event(pMsg->message, pMsg->wParam, pMsg->lParam) == 0) {\n+            // Warn only once as this is performance-critical\n+            static bool warned = false;\n+            if (!warned) {\n+                LogPrint(\"%s: OpenSSL RAND_event() failed to seed OpenSSL PRNG with enough data.\\n\", __func__);\n+                warned = true;\n+            }\n+       }\n+\n        switch(pMsg->message)\n        {\n            case WM_QUERYENDSESSION:\n@@ -45,13 +58,13 @@ void WinShutdownMonitor::registerShutdownBlockReason(const QString& strReason, c\n     typedef BOOL (WINAPI *PSHUTDOWNBRCREATE)(HWND, LPCWSTR);\n     PSHUTDOWNBRCREATE shutdownBRCreate = (PSHUTDOWNBRCREATE)GetProcAddress(GetModuleHandleA(\"User32.dll\"), \"ShutdownBlockReasonCreate\");\n     if (shutdownBRCreate == NULL) {\n-        qDebug() << \"registerShutdownBlockReason : GetProcAddress for ShutdownBlockReasonCreate failed\";\n+        qWarning() << \"registerShutdownBlockReason: GetProcAddress for ShutdownBlockReasonCreate failed\";\n         return;\n     }\n \n     if (shutdownBRCreate(mainWinId, strReason.toStdWString().c_str()))\n-        qDebug() << \"registerShutdownBlockReason : Successfully registered: \" + strReason;\n+        qWarning() << \"registerShutdownBlockReason: Successfully registered: \" + strReason;\n     else\n-        qDebug() << \"registerShutdownBlockReason : Failed to register: \" + strReason;\n+        qWarning() << \"registerShutdownBlockReason: Failed to register: \" + strReason;\n }\n #endif"
      },
      {
        "sha": "0d20d205ac645f4ba097ad45e79da4d3b566c6f7",
        "filename": "src/random.cpp",
        "status": "added",
        "additions": 139,
        "deletions": 0,
        "changes": 139,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,139 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"random.h\"\n+\n+#ifdef WIN32\n+#include \"compat.h\" // for Windows API\n+#endif\n+#include \"util.h\" // for LogPrint()\n+\n+#ifndef WIN32\n+#include <sys/time.h>\n+#endif\n+\n+#include <openssl/crypto.h>\n+#include <openssl/err.h>\n+#include <openssl/rand.h>\n+\n+static inline int64_t GetPerformanceCounter()\n+{\n+    int64_t nCounter = 0;\n+#ifdef WIN32\n+    QueryPerformanceCounter((LARGE_INTEGER*)&nCounter);\n+#else\n+    timeval t;\n+    gettimeofday(&t, NULL);\n+    nCounter = (int64_t)(t.tv_sec * 1000000 + t.tv_usec);\n+#endif\n+    return nCounter;\n+}\n+\n+void RandAddSeed()\n+{\n+    // Seed with CPU performance counter\n+    int64_t nCounter = GetPerformanceCounter();\n+    RAND_add(&nCounter, sizeof(nCounter), 1.5);\n+    OPENSSL_cleanse((void*)&nCounter, sizeof(nCounter));\n+}\n+\n+void RandAddSeedPerfmon()\n+{\n+    RandAddSeed();\n+\n+    // This can take up to 2 seconds, so only do it every 10 minutes\n+    static int64_t nLastPerfmon;\n+    if (GetTime() < nLastPerfmon + 10 * 60)\n+        return;\n+    nLastPerfmon = GetTime();\n+\n+#ifdef WIN32\n+    // Don't need this on Linux, OpenSSL automatically uses /dev/urandom\n+    // Seed with the entire set of perfmon data\n+    std::vector <unsigned char> vData(250000,0);\n+    long ret = 0;\n+    unsigned long nSize = 0;\n+    const size_t nMaxSize = 10000000; // Bail out at more than 10MB of performance data\n+    while (true)\n+    {\n+        nSize = vData.size();\n+        ret = RegQueryValueExA(HKEY_PERFORMANCE_DATA, \"Global\", NULL, NULL, begin_ptr(vData), &nSize);\n+        if (ret != ERROR_MORE_DATA || vData.size() >= nMaxSize)\n+            break;\n+        vData.resize(std::max((vData.size()*3)/2, nMaxSize)); // Grow size of buffer exponentially\n+    }\n+    RegCloseKey(HKEY_PERFORMANCE_DATA);\n+    if (ret == ERROR_SUCCESS)\n+    {\n+        RAND_add(begin_ptr(vData), nSize, nSize/100.0);\n+        OPENSSL_cleanse(begin_ptr(vData), nSize);\n+        LogPrint(\"rand\", \"%s: %lu bytes\\n\", __func__, nSize);\n+    } else {\n+        static bool warned = false; // Warn only once\n+        if (!warned)\n+        {\n+            LogPrintf(\"%s: Warning: RegQueryValueExA(HKEY_PERFORMANCE_DATA) failed with code %i\\n\", __func__, ret);\n+            warned = true;\n+        }\n+    }\n+#endif\n+}\n+\n+bool GetRandBytes(unsigned char *buf, int num)\n+{\n+    if (RAND_bytes(buf, num) != 1) {\n+        LogPrintf(\"%s: OpenSSL RAND_bytes() failed with error: %s\\n\", __func__, ERR_error_string(ERR_get_error(), NULL));\n+        return false;\n+    }\n+    return true;\n+}\n+\n+uint64_t GetRand(uint64_t nMax)\n+{\n+    if (nMax == 0)\n+        return 0;\n+\n+    // The range of the random source must be a multiple of the modulus\n+    // to give every possible output value an equal possibility\n+    uint64_t nRange = (std::numeric_limits<uint64_t>::max() / nMax) * nMax;\n+    uint64_t nRand = 0;\n+    do {\n+        GetRandBytes((unsigned char*)&nRand, sizeof(nRand));\n+    } while (nRand >= nRange);\n+    return (nRand % nMax);\n+}\n+\n+int GetRandInt(int nMax)\n+{\n+    return GetRand(nMax);\n+}\n+\n+uint256 GetRandHash()\n+{\n+    uint256 hash;\n+    GetRandBytes((unsigned char*)&hash, sizeof(hash));\n+    return hash;\n+}\n+\n+uint32_t insecure_rand_Rz = 11;\n+uint32_t insecure_rand_Rw = 11;\n+void seed_insecure_rand(bool fDeterministic)\n+{\n+    // The seed values have some unlikely fixed points which we avoid.\n+    if(fDeterministic)\n+    {\n+        insecure_rand_Rz = insecure_rand_Rw = 11;\n+    } else {\n+        uint32_t tmp;\n+        do {\n+            GetRandBytes((unsigned char*)&tmp, 4);\n+        } while(tmp == 0 || tmp == 0x9068ffffU);\n+        insecure_rand_Rz = tmp;\n+        do {\n+            GetRandBytes((unsigned char*)&tmp, 4);\n+        } while(tmp == 0 || tmp == 0x464fffffU);\n+        insecure_rand_Rw = tmp;\n+    }\n+}"
      },
      {
        "sha": "a599b08478584c92c793c58214e8e1dfbd39026b",
        "filename": "src/random.h",
        "status": "added",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/random.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/random.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,49 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RANDOM_H\n+#define BITCOIN_RANDOM_H\n+\n+#include \"uint256.h\"\n+\n+#include <stdint.h>\n+\n+/**\n+ * Seed OpenSSL PRNG with additional entropy data\n+ */\n+void RandAddSeed();\n+void RandAddSeedPerfmon();\n+\n+/**\n+ * Functions to gather random data via the OpenSSL PRNG\n+ */\n+bool GetRandBytes(unsigned char *buf, int num);\n+uint64_t GetRand(uint64_t nMax);\n+int GetRandInt(int nMax);\n+uint256 GetRandHash();\n+\n+/**\n+ * Seed insecure_rand using the random pool.\n+ * @param Deterministic Use a determinstic seed\n+ */\n+void seed_insecure_rand(bool fDeterministic = false);\n+\n+/**\n+ * MWC RNG of George Marsaglia\n+ * This is intended to be fast. It has a period of 2^59.3, though the\n+ * least significant 16 bits only have a period of about 2^30.1.\n+ *\n+ * @return random value\n+ */\n+extern uint32_t insecure_rand_Rz;\n+extern uint32_t insecure_rand_Rw;\n+static inline uint32_t insecure_rand(void)\n+{\n+    insecure_rand_Rz = 36969 * (insecure_rand_Rz & 65535) + (insecure_rand_Rz >> 16);\n+    insecure_rand_Rw = 18000 * (insecure_rand_Rw & 65535) + (insecure_rand_Rw >> 16);\n+    return (insecure_rand_Rw << 16) + insecure_rand_Rz;\n+}\n+\n+#endif // BITCOIN_RANDOM_H"
      },
      {
        "sha": "253693e6248a9f7fb853f17263875093210a2e1f",
        "filename": "src/rpcblockchain.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 12,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcblockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcblockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcblockchain.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -66,7 +66,7 @@ Object blockToJSON(const CBlock& block, const CBlockIndex* blockindex)\n     result.push_back(Pair(\"tx\", txs));\n     result.push_back(Pair(\"time\", block.GetBlockTime()));\n     result.push_back(Pair(\"nonce\", (uint64_t)block.nNonce));\n-    result.push_back(Pair(\"bits\", HexBits(block.nBits)));\n+    result.push_back(Pair(\"bits\", strprintf(\"%08x\", block.nBits)));\n     result.push_back(Pair(\"difficulty\", GetDifficulty(blockindex)));\n     result.push_back(Pair(\"chainwork\", blockindex->nChainWork.GetHex()));\n \n@@ -276,7 +276,9 @@ Value getblock(const Array& params, bool fHelp)\n \n     CBlock block;\n     CBlockIndex* pblockindex = mapBlockIndex[hash];\n-    ReadBlockFromDisk(block, pblockindex);\n+\n+    if(!ReadBlockFromDisk(block, pblockindex))\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Can't read block from disk\");\n \n     if (!fVerbose)\n     {\n@@ -438,7 +440,7 @@ Value getblockchaininfo(const Array& params, bool fHelp)\n             \"Returns an object containing various state info regarding block chain processing.\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n-            \"  \\\"chain\\\": \\\"xxxx\\\",        (string) current chain (main, testnet3, regtest)\\n\"\n+            \"  \\\"chain\\\": \\\"xxxx\\\",        (string) current network name as defined in BIP70 (main, test, regtest)\\n\"\n             \"  \\\"blocks\\\": xxxxxx,         (numeric) the current number of blocks processed in the server\\n\"\n             \"  \\\"bestblockhash\\\": \\\"...\\\", (string) the hash of the currently best block\\n\"\n             \"  \\\"difficulty\\\": xxxxxx,     (numeric) the current difficulty\\n\"\n@@ -451,14 +453,11 @@ Value getblockchaininfo(const Array& params, bool fHelp)\n         );\n \n     Object obj;\n-    std::string chain = Params().DataDir();\n-    if(chain.empty())\n-        chain = \"main\";\n-    obj.push_back(Pair(\"chain\",         chain));\n-    obj.push_back(Pair(\"blocks\",        (int)chainActive.Height()));\n-    obj.push_back(Pair(\"bestblockhash\", chainActive.Tip()->GetBlockHash().GetHex()));\n-    obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n-    obj.push_back(Pair(\"verificationprogress\", Checkpoints::GuessVerificationProgress(chainActive.Tip())));\n-    obj.push_back(Pair(\"chainwork\",     chainActive.Tip()->nChainWork.GetHex()));\n+    obj.push_back(Pair(\"chain\",                 Params().NetworkIDString()));\n+    obj.push_back(Pair(\"blocks\",                (int)chainActive.Height()));\n+    obj.push_back(Pair(\"bestblockhash\",         chainActive.Tip()->GetBlockHash().GetHex()));\n+    obj.push_back(Pair(\"difficulty\",            (double)GetDifficulty()));\n+    obj.push_back(Pair(\"verificationprogress\",  Checkpoints::GuessVerificationProgress(chainActive.Tip())));\n+    obj.push_back(Pair(\"chainwork\",             chainActive.Tip()->nChainWork.GetHex()));\n     return obj;\n }"
      },
      {
        "sha": "5edeecf93309d5aea8762f0c1bcd0790cfa22311",
        "filename": "src/rpcclient.cpp",
        "status": "modified",
        "additions": 101,
        "deletions": 243,
        "changes": 344,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcclient.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcclient.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcclient.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -3,6 +3,7 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <set>\n #include \"rpcclient.h\"\n \n #include \"rpcprotocol.h\"\n@@ -12,271 +13,128 @@\n \n #include <stdint.h>\n \n-#include <boost/algorithm/string.hpp>\n-#include <boost/asio.hpp>\n-#include <boost/asio/ssl.hpp>\n-#include <boost/bind.hpp>\n-#include <boost/filesystem.hpp>\n-#include <boost/foreach.hpp>\n-#include <boost/iostreams/concepts.hpp>\n-#include <boost/iostreams/stream.hpp>\n-#include <boost/shared_ptr.hpp>\n-#include \"json/json_spirit_writer_template.h\"\n-\n using namespace std;\n-using namespace boost;\n-using namespace boost::asio;\n using namespace json_spirit;\n \n-Object CallRPC(const string& strMethod, const Array& params)\n+class CRPCConvertParam\n {\n-    if (mapArgs[\"-rpcuser\"] == \"\" && mapArgs[\"-rpcpassword\"] == \"\")\n-        throw runtime_error(strprintf(\n-            _(\"You must set rpcpassword=<password> in the configuration file:\\n%s\\n\"\n-              \"If the file does not exist, create it with owner-readable-only file permissions.\"),\n-                GetConfigFile().string().c_str()));\n-\n-    // Connect to localhost\n-    bool fUseSSL = GetBoolArg(\"-rpcssl\", false);\n-    asio::io_service io_service;\n-    ssl::context context(io_service, ssl::context::sslv23);\n-    context.set_options(ssl::context::no_sslv2);\n-    asio::ssl::stream<asio::ip::tcp::socket> sslStream(io_service, context);\n-    SSLIOStreamDevice<asio::ip::tcp> d(sslStream, fUseSSL);\n-    iostreams::stream< SSLIOStreamDevice<asio::ip::tcp> > stream(d);\n-\n-    bool fWait = GetBoolArg(\"-rpcwait\", false); // -rpcwait means try until server has started\n-    do {\n-        bool fConnected = d.connect(GetArg(\"-rpcconnect\", \"127.0.0.1\"), GetArg(\"-rpcport\", itostr(Params().RPCPort())));\n-        if (fConnected) break;\n-        if (fWait)\n-            MilliSleep(1000);\n-        else\n-            throw runtime_error(\"couldn't connect to server\");\n-    } while (fWait);\n-\n-    // HTTP basic authentication\n-    string strUserPass64 = EncodeBase64(mapArgs[\"-rpcuser\"] + \":\" + mapArgs[\"-rpcpassword\"]);\n-    map<string, string> mapRequestHeaders;\n-    mapRequestHeaders[\"Authorization\"] = string(\"Basic \") + strUserPass64;\n-\n-    // Send request\n-    string strRequest = JSONRPCRequest(strMethod, params, 1);\n-    string strPost = HTTPPost(strRequest, mapRequestHeaders);\n-    stream << strPost << std::flush;\n+public:\n+    std::string methodName;            // method whose params want conversion\n+    int paramIdx;                      // 0-based idx of param to convert\n+};\n \n-    // Receive HTTP reply status\n-    int nProto = 0;\n-    int nStatus = ReadHTTPStatus(stream, nProto);\n-\n-    // Receive HTTP reply message headers and body\n-    map<string, string> mapHeaders;\n-    string strReply;\n-    ReadHTTPMessage(stream, mapHeaders, strReply, nProto);\n-\n-    if (nStatus == HTTP_UNAUTHORIZED)\n-        throw runtime_error(\"incorrect rpcuser or rpcpassword (authorization failed)\");\n-    else if (nStatus >= 400 && nStatus != HTTP_BAD_REQUEST && nStatus != HTTP_NOT_FOUND && nStatus != HTTP_INTERNAL_SERVER_ERROR)\n-        throw runtime_error(strprintf(\"server returned HTTP error %d\", nStatus));\n-    else if (strReply.empty())\n-        throw runtime_error(\"no response from server\");\n+static const CRPCConvertParam vRPCConvertParams[] =\n+{\n+    { \"stop\", 0 },\n+    { \"getaddednodeinfo\", 0 },\n+    { \"setgenerate\", 0 },\n+    { \"setgenerate\", 1 },\n+    { \"getnetworkhashps\", 0 },\n+    { \"getnetworkhashps\", 1 },\n+    { \"sendtoaddress\", 1 },\n+    { \"settxfee\", 0 },\n+    { \"getreceivedbyaddress\", 1 },\n+    { \"getreceivedbyaccount\", 1 },\n+    { \"listreceivedbyaddress\", 0 },\n+    { \"listreceivedbyaddress\", 1 },\n+    { \"listreceivedbyaddress\", 2 },\n+    { \"listreceivedbyaccount\", 0 },\n+    { \"listreceivedbyaccount\", 1 },\n+    { \"listreceivedbyaccount\", 2 },\n+    { \"getbalance\", 1 },\n+    { \"getbalance\", 2 },\n+    { \"getblockhash\", 0 },\n+    { \"move\", 2 },\n+    { \"move\", 3 },\n+    { \"sendfrom\", 2 },\n+    { \"sendfrom\", 3 },\n+    { \"listtransactions\", 1 },\n+    { \"listtransactions\", 2 },\n+    { \"listtransactions\", 3 },\n+    { \"listaccounts\", 0 },\n+    { \"listaccounts\", 1 },\n+    { \"walletpassphrase\", 1 },\n+    { \"getblocktemplate\", 0 },\n+    { \"listsinceblock\", 1 },\n+    { \"listsinceblock\", 2 },\n+    { \"sendmany\", 1 },\n+    { \"sendmany\", 2 },\n+    { \"addmultisigaddress\", 0 },\n+    { \"addmultisigaddress\", 1 },\n+    { \"createmultisig\", 0 },\n+    { \"createmultisig\", 1 },\n+    { \"listunspent\", 0 },\n+    { \"listunspent\", 1 },\n+    { \"listunspent\", 2 },\n+    { \"getblock\", 1 },\n+    { \"getrawtransaction\", 1 },\n+    { \"createrawtransaction\", 0 },\n+    { \"createrawtransaction\", 1 },\n+    { \"signrawtransaction\", 1 },\n+    { \"signrawtransaction\", 2 },\n+    { \"sendrawtransaction\", 1 },\n+    { \"gettxout\", 1 },\n+    { \"gettxout\", 2 },\n+    { \"lockunspent\", 0 },\n+    { \"lockunspent\", 1 },\n+    { \"importprivkey\", 2 },\n+    { \"importaddress\", 2 },\n+    { \"verifychain\", 0 },\n+    { \"verifychain\", 1 },\n+    { \"keypoolrefill\", 0 },\n+    { \"getrawmempool\", 0 },\n+    { \"estimatefee\", 0 },\n+    { \"estimatepriority\", 0 },\n+};\n+\n+class CRPCConvertTable\n+{\n+private:\n+    std::set<std::pair<std::string, int> > members;\n \n-    // Parse reply\n-    Value valReply;\n-    if (!read_string(strReply, valReply))\n-        throw runtime_error(\"couldn't parse reply from server\");\n-    const Object& reply = valReply.get_obj();\n-    if (reply.empty())\n-        throw runtime_error(\"expected reply to have result, error and id properties\");\n+public:\n+    CRPCConvertTable();\n \n-    return reply;\n-}\n+    bool convert(const std::string& method, int idx) {\n+        return (members.count(std::make_pair(method, idx)) > 0);\n+    }\n+};\n \n-template<typename T>\n-void ConvertTo(Value& value, bool fAllowNull=false)\n+CRPCConvertTable::CRPCConvertTable()\n {\n-    if (fAllowNull && value.type() == null_type)\n-        return;\n-    if (value.type() == str_type)\n-    {\n-        // reinterpret string as unquoted json value\n-        Value value2;\n-        string strJSON = value.get_str();\n-        if (!read_string(strJSON, value2))\n-            throw runtime_error(string(\"Error parsing JSON:\")+strJSON);\n-        ConvertTo<T>(value2, fAllowNull);\n-        value = value2;\n-    }\n-    else\n-    {\n-        value = value.get_value<T>();\n+    const unsigned int n_elem =\n+        (sizeof(vRPCConvertParams) / sizeof(vRPCConvertParams[0]));\n+\n+    for (unsigned int i = 0; i < n_elem; i++) {\n+        members.insert(std::make_pair(vRPCConvertParams[i].methodName,\n+                                      vRPCConvertParams[i].paramIdx));\n     }\n }\n \n+static CRPCConvertTable rpcCvtTable;\n+\n // Convert strings to command-specific RPC representation\n Array RPCConvertValues(const std::string &strMethod, const std::vector<std::string> &strParams)\n {\n     Array params;\n-    BOOST_FOREACH(const std::string &param, strParams)\n-        params.push_back(param);\n-\n-    int n = params.size();\n \n-    //\n-    // Special case non-string parameter types\n-    //\n-    if (strMethod == \"stop\"                   && n > 0) ConvertTo<bool>(params[0]);\n-    if (strMethod == \"getaddednodeinfo\"       && n > 0) ConvertTo<bool>(params[0]);\n-    if (strMethod == \"setgenerate\"            && n > 0) ConvertTo<bool>(params[0]);\n-    if (strMethod == \"setgenerate\"            && n > 1) ConvertTo<int64_t>(params[1]);\n-    if (strMethod == \"getnetworkhashps\"       && n > 0) ConvertTo<int64_t>(params[0]);\n-    if (strMethod == \"getnetworkhashps\"       && n > 1) ConvertTo<int64_t>(params[1]);\n-    if (strMethod == \"sendtoaddress\"          && n > 1) ConvertTo<double>(params[1]);\n-    if (strMethod == \"settxfee\"               && n > 0) ConvertTo<double>(params[0]);\n-    if (strMethod == \"getreceivedbyaddress\"   && n > 1) ConvertTo<int64_t>(params[1]);\n-    if (strMethod == \"getreceivedbyaccount\"   && n > 1) ConvertTo<int64_t>(params[1]);\n-    if (strMethod == \"listreceivedbyaddress\"  && n > 0) ConvertTo<int64_t>(params[0]);\n-    if (strMethod == \"listreceivedbyaddress\"  && n > 1) ConvertTo<bool>(params[1]);\n-    if (strMethod == \"listreceivedbyaccount\"  && n > 0) ConvertTo<int64_t>(params[0]);\n-    if (strMethod == \"listreceivedbyaccount\"  && n > 1) ConvertTo<bool>(params[1]);\n-    if (strMethod == \"getbalance\"             && n > 1) ConvertTo<int64_t>(params[1]);\n-    if (strMethod == \"getblockhash\"           && n > 0) ConvertTo<int64_t>(params[0]);\n-    if (strMethod == \"move\"                   && n > 2) ConvertTo<double>(params[2]);\n-    if (strMethod == \"move\"                   && n > 3) ConvertTo<int64_t>(params[3]);\n-    if (strMethod == \"sendfrom\"               && n > 2) ConvertTo<double>(params[2]);\n-    if (strMethod == \"sendfrom\"               && n > 3) ConvertTo<int64_t>(params[3]);\n-    if (strMethod == \"listtransactions\"       && n > 1) ConvertTo<int64_t>(params[1]);\n-    if (strMethod == \"listtransactions\"       && n > 2) ConvertTo<int64_t>(params[2]);\n-    if (strMethod == \"listaccounts\"           && n > 0) ConvertTo<int64_t>(params[0]);\n-    if (strMethod == \"walletpassphrase\"       && n > 1) ConvertTo<int64_t>(params[1]);\n-    if (strMethod == \"getblocktemplate\"       && n > 0) ConvertTo<Object>(params[0]);\n-    if (strMethod == \"listsinceblock\"         && n > 1) ConvertTo<int64_t>(params[1]);\n-    if (strMethod == \"sendmany\"               && n > 1) ConvertTo<Object>(params[1]);\n-    if (strMethod == \"sendmany\"               && n > 2) ConvertTo<int64_t>(params[2]);\n-    if (strMethod == \"addmultisigaddress\"     && n > 0) ConvertTo<int64_t>(params[0]);\n-    if (strMethod == \"addmultisigaddress\"     && n > 1) ConvertTo<Array>(params[1]);\n-    if (strMethod == \"createmultisig\"         && n > 0) ConvertTo<int64_t>(params[0]);\n-    if (strMethod == \"createmultisig\"         && n > 1) ConvertTo<Array>(params[1]);\n-    if (strMethod == \"listunspent\"            && n > 0) ConvertTo<int64_t>(params[0]);\n-    if (strMethod == \"listunspent\"            && n > 1) ConvertTo<int64_t>(params[1]);\n-    if (strMethod == \"listunspent\"            && n > 2) ConvertTo<Array>(params[2]);\n-    if (strMethod == \"getblock\"               && n > 1) ConvertTo<bool>(params[1]);\n-    if (strMethod == \"getrawtransaction\"      && n > 1) ConvertTo<int64_t>(params[1]);\n-    if (strMethod == \"createrawtransaction\"   && n > 0) ConvertTo<Array>(params[0]);\n-    if (strMethod == \"createrawtransaction\"   && n > 1) ConvertTo<Object>(params[1]);\n-    if (strMethod == \"signrawtransaction\"     && n > 1) ConvertTo<Array>(params[1], true);\n-    if (strMethod == \"signrawtransaction\"     && n > 2) ConvertTo<Array>(params[2], true);\n-    if (strMethod == \"sendrawtransaction\"     && n > 1) ConvertTo<bool>(params[1], true);\n-    if (strMethod == \"gettxout\"               && n > 1) ConvertTo<int64_t>(params[1]);\n-    if (strMethod == \"gettxout\"               && n > 2) ConvertTo<bool>(params[2]);\n-    if (strMethod == \"lockunspent\"            && n > 0) ConvertTo<bool>(params[0]);\n-    if (strMethod == \"lockunspent\"            && n > 1) ConvertTo<Array>(params[1]);\n-    if (strMethod == \"importprivkey\"          && n > 2) ConvertTo<bool>(params[2]);\n-    if (strMethod == \"verifychain\"            && n > 0) ConvertTo<int64_t>(params[0]);\n-    if (strMethod == \"verifychain\"            && n > 1) ConvertTo<int64_t>(params[1]);\n-    if (strMethod == \"keypoolrefill\"          && n > 0) ConvertTo<int64_t>(params[0]);\n-    if (strMethod == \"getrawmempool\"          && n > 0) ConvertTo<bool>(params[0]);\n-    if (strMethod == \"estimatefee\"            && n > 0) ConvertTo<boost::int64_t>(params[0]);\n-    if (strMethod == \"estimatepriority\"       && n > 0) ConvertTo<boost::int64_t>(params[0]);\n+    for (unsigned int idx = 0; idx < strParams.size(); idx++) {\n+        const std::string& strVal = strParams[idx];\n \n-    return params;\n-}\n-\n-int CommandLineRPC(int argc, char *argv[])\n-{\n-    string strPrint;\n-    int nRet = 0;\n-    try\n-    {\n-        // Skip switches\n-        while (argc > 1 && IsSwitchChar(argv[1][0]))\n-        {\n-            argc--;\n-            argv++;\n+        // insert string value directly\n+        if (!rpcCvtTable.convert(strMethod, idx)) {\n+            params.push_back(strVal);\n         }\n \n-        // Method\n-        if (argc < 2)\n-            throw runtime_error(\"too few parameters\");\n-        string strMethod = argv[1];\n-\n-        // Parameters default to strings\n-        std::vector<std::string> strParams(&argv[2], &argv[argc]);\n-        Array params = RPCConvertValues(strMethod, strParams);\n-\n-        // Execute\n-        Object reply = CallRPC(strMethod, params);\n-\n-        // Parse reply\n-        const Value& result = find_value(reply, \"result\");\n-        const Value& error  = find_value(reply, \"error\");\n-\n-        if (error.type() != null_type)\n-        {\n-            // Error\n-            strPrint = \"error: \" + write_string(error, false);\n-            int code = find_value(error.get_obj(), \"code\").get_int();\n-            nRet = abs(code);\n-        }\n-        else\n-        {\n-            // Result\n-            if (result.type() == null_type)\n-                strPrint = \"\";\n-            else if (result.type() == str_type)\n-                strPrint = result.get_str();\n-            else\n-                strPrint = write_string(result, true);\n+        // parse string as JSON, insert bool/number/object/etc. value\n+        else {\n+            Value jVal;\n+            if (!read_string(strVal, jVal))\n+                throw runtime_error(string(\"Error parsing JSON:\")+strVal);\n+            params.push_back(jVal);\n         }\n     }\n-    catch (boost::thread_interrupted) {\n-        throw;\n-    }\n-    catch (std::exception& e) {\n-        strPrint = string(\"error: \") + e.what();\n-        nRet = abs(RPC_MISC_ERROR);\n-    }\n-    catch (...) {\n-        PrintExceptionContinue(NULL, \"CommandLineRPC()\");\n-        throw;\n-    }\n \n-    if (strPrint != \"\")\n-    {\n-        fprintf((nRet == 0 ? stdout : stderr), \"%s\\n\", strPrint.c_str());\n-    }\n-    return nRet;\n-}\n-\n-std::string HelpMessageCli(bool mainProgram)\n-{\n-    string strUsage;\n-    if(mainProgram)\n-    {\n-        strUsage += _(\"Options:\") + \"\\n\";\n-        strUsage += \"  -?                     \" + _(\"This help message\") + \"\\n\";\n-        strUsage += \"  -conf=<file>           \" + _(\"Specify configuration file (default: bitcoin.conf)\") + \"\\n\";\n-        strUsage += \"  -datadir=<dir>         \" + _(\"Specify data directory\") + \"\\n\";\n-        strUsage += \"  -testnet               \" + _(\"Use the test network\") + \"\\n\";\n-        strUsage += \"  -regtest               \" + _(\"Enter regression test mode, which uses a special chain in which blocks can be \"\n-                                                    \"solved instantly. This is intended for regression testing tools and app development.\") + \"\\n\";\n-    } else {\n-        strUsage += _(\"RPC client options:\") + \"\\n\";\n-    }\n-\n-    strUsage += \"  -rpcconnect=<ip>       \" + _(\"Send commands to node running on <ip> (default: 127.0.0.1)\") + \"\\n\";\n-    strUsage += \"  -rpcport=<port>        \" + _(\"Connect to JSON-RPC on <port> (default: 8332 or testnet: 18332)\") + \"\\n\";\n-    strUsage += \"  -rpcwait               \" + _(\"Wait for RPC server to start\") + \"\\n\";\n-\n-    if(mainProgram)\n-    {\n-        strUsage += \"  -rpcuser=<user>        \" + _(\"Username for JSON-RPC connections\") + \"\\n\";\n-        strUsage += \"  -rpcpassword=<pw>      \" + _(\"Password for JSON-RPC connections\") + \"\\n\";\n-\n-        strUsage += \"\\n\" + _(\"SSL options: (see the Bitcoin Wiki for SSL setup instructions)\") + \"\\n\";\n-        strUsage += \"  -rpcssl                \" + _(\"Use OpenSSL (https) for JSON-RPC connections\") + \"\\n\";\n-    }\n-\n-    return strUsage;\n+    return params;\n }\n "
      },
      {
        "sha": "840890e34b404364afbab1dbf5ee12b0acfbe194",
        "filename": "src/rpcclient.h",
        "status": "modified",
        "additions": 0,
        "deletions": 10,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcclient.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcclient.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcclient.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -10,16 +10,6 @@\n #include \"json/json_spirit_utils.h\"\n #include \"json/json_spirit_writer_template.h\"\n \n-int CommandLineRPC(int argc, char *argv[]);\n-\n json_spirit::Array RPCConvertValues(const std::string &strMethod, const std::vector<std::string> &strParams);\n \n-/** Show help message for bitcoin-cli.\n- * The mainProgram argument is used to determine whether to show this message as main program\n- * (and include some common options) or as sub-header of another help message.\n- *\n- * @note the argument can be removed once bitcoin-cli functionality is removed from bitcoind\n- */\n-std::string HelpMessageCli(bool mainProgram);\n-\n #endif"
      },
      {
        "sha": "ff2361482b9ff44654b9dda7a006a816689023db",
        "filename": "src/rpcdump.cpp",
        "status": "modified",
        "additions": 75,
        "deletions": 7,
        "changes": 82,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcdump.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -72,16 +72,17 @@ Value importprivkey(const Array& params, bool fHelp)\n             \"\\nAdds a private key (as returned by dumpprivkey) to your wallet.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"bitcoinprivkey\\\"   (string, required) The private key (see dumpprivkey)\\n\"\n-            \"2. \\\"label\\\"            (string, optional) an optional label\\n\"\n+            \"2. \\\"label\\\"            (string, optional, default=\\\"\\\") An optional label\\n\"\n             \"3. rescan               (boolean, optional, default=true) Rescan the wallet for transactions\\n\"\n+            \"\\nNote: This call can take minutes to complete if rescan is true.\\n\"\n             \"\\nExamples:\\n\"\n             \"\\nDump a private key\\n\"\n             + HelpExampleCli(\"dumpprivkey\", \"\\\"myaddress\\\"\") +\n-            \"\\nImport the private key\\n\"\n+            \"\\nImport the private key with rescan\\n\"\n             + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\"\") +\n-            \"\\nImport using a label\\n\"\n+            \"\\nImport using a label and without rescan\\n\"\n             + HelpExampleCli(\"importprivkey\", \"\\\"mykey\\\" \\\"testing\\\" false\") +\n-            \"\\nAs a json rpc call\\n\"\n+            \"\\nAs a JSON-RPC call\\n\"\n             + HelpExampleRpc(\"importprivkey\", \"\\\"mykey\\\", \\\"testing\\\", false\")\n         );\n \n@@ -133,6 +134,73 @@ Value importprivkey(const Array& params, bool fHelp)\n     return Value::null;\n }\n \n+Value importaddress(const Array& params, bool fHelp)\n+{\n+    if (fHelp || params.size() < 1 || params.size() > 3)\n+        throw runtime_error(\n+            \"importaddress \\\"address\\\" ( \\\"label\\\" rescan )\\n\"\n+            \"\\nAdds an address or script (in hex) that can be watched as if it were in your wallet but cannot be used to spend.\\n\"\n+            \"\\nArguments:\\n\"\n+            \"1. \\\"address\\\"          (string, required) The address\\n\"\n+            \"2. \\\"label\\\"            (string, optional, default=\\\"\\\") An optional label\\n\"\n+            \"3. rescan               (boolean, optional, default=true) Rescan the wallet for transactions\\n\"\n+            \"\\nNote: This call can take minutes to complete if rescan is true.\\n\"\n+            \"\\nExamples:\\n\"\n+            \"\\nImport an address with rescan\\n\"\n+            + HelpExampleCli(\"importaddress\", \"\\\"myaddress\\\"\") +\n+            \"\\nImport using a label without rescan\\n\"\n+            + HelpExampleCli(\"importaddress\", \"\\\"myaddress\\\" \\\"testing\\\" false\") +\n+            \"\\nAs a JSON-RPC call\\n\"\n+            + HelpExampleRpc(\"importaddress\", \"\\\"myaddress\\\", \\\"testing\\\", false\")\n+        );\n+\n+    CScript script;\n+\n+    CBitcoinAddress address(params[0].get_str());\n+    if (address.IsValid()) {\n+        script.SetDestination(address.Get());\n+    } else if (IsHex(params[0].get_str())) {\n+        std::vector<unsigned char> data(ParseHex(params[0].get_str()));\n+        script = CScript(data.begin(), data.end());\n+    } else {\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid\u00a0Bitcoin\u00a0address or script\");\n+    }\n+\n+    string strLabel = \"\";\n+    if (params.size() > 1)\n+        strLabel = params[1].get_str();\n+\n+    //\u00a0Whether\u00a0to\u00a0perform\u00a0rescan\u00a0after\u00a0import\n+    bool fRescan = true;\n+    if (params.size() > 2)\n+        fRescan = params[2].get_bool();\n+\n+    {\n+        LOCK2(cs_main, pwalletMain->cs_wallet);\n+\n+        // add to address book or update label\n+        if (address.IsValid())\n+            pwalletMain->SetAddressBook(address.Get(), strLabel, \"receive\");\n+\n+        // Don't throw error in case an address is already there\n+        if (pwalletMain->HaveWatchOnly(script))\n+            return Value::null;\n+\n+        pwalletMain->MarkDirty();\n+\n+        if (!pwalletMain->AddWatchOnly(script))\n+            throw JSONRPCError(RPC_WALLET_ERROR, \"Error\u00a0adding\u00a0address\u00a0to\u00a0wallet\");\n+\n+        if (fRescan)\n+        {\n+            pwalletMain->ScanForWalletTransactions(chainActive.Genesis(), true);\n+            pwalletMain->ReacceptWalletTransactions();\n+        }\n+    }\n+\n+    return Value::null;\n+}\n+\n Value importwallet(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() != 1)\n@@ -157,7 +225,7 @@ Value importwallet(const Array& params, bool fHelp)\n     if (!file.is_open())\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n \n-    int64_t nTimeBegin = chainActive.Tip()->nTime;\n+    int64_t nTimeBegin = chainActive.Tip()->GetBlockTime();\n \n     bool fGood = true;\n \n@@ -215,7 +283,7 @@ Value importwallet(const Array& params, bool fHelp)\n     pwalletMain->ShowProgress(\"\", 100); // hide progress dialog in GUI\n \n     CBlockIndex *pindex = chainActive.Tip();\n-    while (pindex && pindex->pprev && pindex->nTime > nTimeBegin - 7200)\n+    while (pindex && pindex->pprev && pindex->GetBlockTime() > nTimeBegin - 7200)\n         pindex = pindex->pprev;\n \n     if (!pwalletMain->nTimeFirstKey || nTimeBegin < pwalletMain->nTimeFirstKey)\n@@ -301,7 +369,7 @@ Value dumpwallet(const Array& params, bool fHelp)\n     file << strprintf(\"# Wallet dump created by Bitcoin %s (%s)\\n\", CLIENT_BUILD, CLIENT_DATE);\n     file << strprintf(\"# * Created on %s\\n\", EncodeDumpTime(GetTime()));\n     file << strprintf(\"# * Best block at time of backup was %i (%s),\\n\", chainActive.Height(), chainActive.Tip()->GetBlockHash().ToString());\n-    file << strprintf(\"#   mined on %s\\n\", EncodeDumpTime(chainActive.Tip()->nTime));\n+    file << strprintf(\"#   mined on %s\\n\", EncodeDumpTime(chainActive.Tip()->GetBlockTime()));\n     file << \"\\n\";\n     for (std::vector<std::pair<int64_t, CKeyID> >::const_iterator it = vKeyBirth.begin(); it != vKeyBirth.end(); it++) {\n         const CKeyID &keyid = it->second;"
      },
      {
        "sha": "6f72ea7404034618fbfca803f8cfb15ff3c12564",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 158,
        "changes": 232,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -9,6 +9,7 @@\n #include \"net.h\"\n #include \"main.h\"\n #include \"miner.h\"\n+#include \"pow.h\"\n #ifdef ENABLE_WALLET\n #include \"db.h\"\n #include \"wallet.h\"\n@@ -24,36 +25,6 @@\n using namespace json_spirit;\n using namespace std;\n \n-#ifdef ENABLE_WALLET\n-// Key used by getwork miners.\n-// Allocated in InitRPCMining, free'd in ShutdownRPCMining\n-static CReserveKey* pMiningKey = NULL;\n-\n-void InitRPCMining()\n-{\n-    if (!pwalletMain)\n-        return;\n-\n-    // getwork/getblocktemplate mining rewards paid here:\n-    pMiningKey = new CReserveKey(pwalletMain);\n-}\n-\n-void ShutdownRPCMining()\n-{\n-    if (!pMiningKey)\n-        return;\n-\n-    delete pMiningKey; pMiningKey = NULL;\n-}\n-#else\n-void InitRPCMining()\n-{\n-}\n-void ShutdownRPCMining()\n-{\n-}\n-#endif\n-\n // Return average network hashes per second based on the last 'lookup' blocks,\n // or from the last difficulty change if 'lookup' is nonpositive.\n // If 'height' is nonnegative, compute the estimate at the time when a given block was found.\n@@ -131,9 +102,6 @@ Value getgenerate(const Array& params, bool fHelp)\n             + HelpExampleRpc(\"getgenerate\", \"\")\n         );\n \n-    if (!pMiningKey)\n-        return false;\n-\n     return GetBoolArg(\"-gen\", false);\n }\n \n@@ -253,6 +221,7 @@ Value getmininginfo(const Array& params, bool fHelp)\n             \"  \\\"hashespersec\\\": n          (numeric) The hashes per second of the generation, or 0 if no generation.\\n\"\n             \"  \\\"pooledtx\\\": n              (numeric) The size of the mem pool\\n\"\n             \"  \\\"testnet\\\": true|false      (boolean) If using testnet or not\\n\"\n+            \"  \\\"chain\\\": \\\"xxxx\\\",         (string) current network name as defined in BIP70 (main, test, regtest)\\n\"\n             \"}\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"getmininginfo\", \"\")\n@@ -268,7 +237,8 @@ Value getmininginfo(const Array& params, bool fHelp)\n     obj.push_back(Pair(\"genproclimit\",     (int)GetArg(\"-genproclimit\", -1)));\n     obj.push_back(Pair(\"networkhashps\",    getnetworkhashps(params, false)));\n     obj.push_back(Pair(\"pooledtx\",         (uint64_t)mempool.size()));\n-    obj.push_back(Pair(\"testnet\",          Params().RPCisTestNet()));\n+    obj.push_back(Pair(\"testnet\",          Params().NetworkID() == CBaseChainParams::TESTNET));\n+    obj.push_back(Pair(\"chain\",            Params().NetworkIDString()));\n #ifdef ENABLE_WALLET\n     obj.push_back(Pair(\"generate\",         getgenerate(params, false)));\n     obj.push_back(Pair(\"hashespersec\",     gethashespersec(params, false)));\n@@ -277,131 +247,19 @@ Value getmininginfo(const Array& params, bool fHelp)\n }\n \n \n-#ifdef ENABLE_WALLET\n-Value getwork(const Array& params, bool fHelp)\n+Value prioritisetransaction(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() > 1)\n+    if (fHelp || params.size() != 3)\n         throw runtime_error(\n-            \"getwork ( \\\"data\\\" )\\n\"\n-            \"\\nIf 'data' is not specified, it returns the formatted hash data to work on.\\n\"\n-            \"If 'data' is specified, tries to solve the block and returns true if it was successful.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"data\\\"       (string, optional) The hex encoded data to solve\\n\"\n-            \"\\nResult (when 'data' is not specified):\\n\"\n-            \"{\\n\"\n-            \"  \\\"midstate\\\" : \\\"xxxx\\\",   (string) The precomputed hash state after hashing the first half of the data (DEPRECATED)\\n\" // deprecated\n-            \"  \\\"data\\\" : \\\"xxxxx\\\",      (string) The block data\\n\"\n-            \"  \\\"hash1\\\" : \\\"xxxxx\\\",     (string) The formatted hash buffer for second hash (DEPRECATED)\\n\" // deprecated\n-            \"  \\\"target\\\" : \\\"xxxx\\\"      (string) The little endian hash target\\n\"\n-            \"}\\n\"\n-            \"\\nResult (when 'data' is specified):\\n\"\n-            \"true|false       (boolean) If solving the block specified in the 'data' was successfull\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getwork\", \"\")\n-            + HelpExampleRpc(\"getwork\", \"\")\n-        );\n-\n-    if (vNodes.empty())\n-        throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, \"Bitcoin is not connected!\");\n-\n-    if (IsInitialBlockDownload())\n-        throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, \"Bitcoin is downloading blocks...\");\n-\n-    typedef map<uint256, pair<CBlock*, CScript> > mapNewBlock_t;\n-    static mapNewBlock_t mapNewBlock;    // FIXME: thread safety\n-    static vector<CBlockTemplate*> vNewBlockTemplate;\n-\n-    if (params.size() == 0)\n-    {\n-        // Update block\n-        static unsigned int nTransactionsUpdatedLast;\n-        static CBlockIndex* pindexPrev;\n-        static int64_t nStart;\n-        static CBlockTemplate* pblocktemplate;\n-        if (pindexPrev != chainActive.Tip() ||\n-            (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 60))\n-        {\n-            if (pindexPrev != chainActive.Tip())\n-            {\n-                // Deallocate old blocks since they're obsolete now\n-                mapNewBlock.clear();\n-                BOOST_FOREACH(CBlockTemplate* pblocktemplate, vNewBlockTemplate)\n-                    delete pblocktemplate;\n-                vNewBlockTemplate.clear();\n-            }\n-\n-            // Clear pindexPrev so future getworks make a new block, despite any failures from here on\n-            pindexPrev = NULL;\n-\n-            // Store the pindexBest used before CreateNewBlock, to avoid races\n-            nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n-            CBlockIndex* pindexPrevNew = chainActive.Tip();\n-            nStart = GetTime();\n+            \"prioritisetransaction <txid> <priority delta> <fee delta>\\n\"\n+            \"Accepts the transaction into mined blocks at a higher (or lower) priority\");\n \n-            // Create new block\n-            pblocktemplate = CreateNewBlockWithKey(*pMiningKey);\n-            if (!pblocktemplate)\n-                throw JSONRPCError(RPC_OUT_OF_MEMORY, \"Out of memory\");\n-            vNewBlockTemplate.push_back(pblocktemplate);\n-\n-            // Need to update only after we know CreateNewBlock succeeded\n-            pindexPrev = pindexPrevNew;\n-        }\n-        CBlock* pblock = &pblocktemplate->block; // pointer for convenience\n-\n-        // Update nTime\n-        UpdateTime(*pblock, pindexPrev);\n-        pblock->nNonce = 0;\n-\n-        // Update nExtraNonce\n-        static unsigned int nExtraNonce = 0;\n-        IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);\n-\n-        // Save\n-        mapNewBlock[pblock->hashMerkleRoot] = make_pair(pblock, pblock->vtx[0].vin[0].scriptSig);\n-\n-        // Pre-build hash buffers\n-        char pmidstate[32];\n-        char pdata[128];\n-        char phash1[64];\n-        FormatHashBuffers(pblock, pmidstate, pdata, phash1);\n-\n-        uint256 hashTarget = uint256().SetCompact(pblock->nBits);\n-\n-        Object result;\n-        result.push_back(Pair(\"midstate\", HexStr(BEGIN(pmidstate), END(pmidstate)))); // deprecated\n-        result.push_back(Pair(\"data\",     HexStr(BEGIN(pdata), END(pdata))));\n-        result.push_back(Pair(\"hash1\",    HexStr(BEGIN(phash1), END(phash1)))); // deprecated\n-        result.push_back(Pair(\"target\",   HexStr(BEGIN(hashTarget), END(hashTarget))));\n-        return result;\n-    }\n-    else\n-    {\n-        // Parse parameters\n-        vector<unsigned char> vchData = ParseHex(params[0].get_str());\n-        if (vchData.size() != 128)\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter\");\n-        CBlock* pdata = (CBlock*)&vchData[0];\n-\n-        // Byte reverse\n-        for (int i = 0; i < 128/4; i++)\n-            ((unsigned int*)pdata)[i] = ByteReverse(((unsigned int*)pdata)[i]);\n-\n-        // Get saved block\n-        if (!mapNewBlock.count(pdata->hashMerkleRoot))\n-            return false;\n-        CBlock* pblock = mapNewBlock[pdata->hashMerkleRoot].first;\n-\n-        pblock->nTime = pdata->nTime;\n-        pblock->nNonce = pdata->nNonce;\n-        pblock->vtx[0].vin[0].scriptSig = mapNewBlock[pdata->hashMerkleRoot].second;\n-        pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n-\n-        assert(pwalletMain != NULL);\n-        return CheckWork(pblock, *pwalletMain, *pMiningKey);\n-    }\n+    uint256 hash;\n+    hash.SetHex(params[0].get_str());\n+    mempool.PrioritiseTransaction(hash, params[0].get_str(), params[1].get_real(), params[2].get_int64());\n+    return true;\n }\n-#endif\n+\n \n Value getblocktemplate(const Array& params, bool fHelp)\n {\n@@ -466,6 +324,7 @@ Value getblocktemplate(const Array& params, bool fHelp)\n          );\n \n     std::string strMode = \"template\";\n+    Value lpval = Value::null;\n     if (params.size() > 0)\n     {\n         const Object& oparam = params[0].get_obj();\n@@ -478,6 +337,7 @@ Value getblocktemplate(const Array& params, bool fHelp)\n         }\n         else\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid mode\");\n+        lpval = find_value(oparam, \"longpollid\");\n     }\n \n     if (strMode != \"template\")\n@@ -489,8 +349,63 @@ Value getblocktemplate(const Array& params, bool fHelp)\n     if (IsInitialBlockDownload())\n         throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, \"Bitcoin is downloading blocks...\");\n \n-    // Update block\n     static unsigned int nTransactionsUpdatedLast;\n+\n+    if (lpval.type() != null_type)\n+    {\n+        // Wait to respond until either the best block changes, OR a minute has passed and there are more transactions\n+        uint256 hashWatchedChain;\n+        boost::system_time checktxtime;\n+        unsigned int nTransactionsUpdatedLastLP;\n+\n+        if (lpval.type() == str_type)\n+        {\n+            // Format: <hashBestChain><nTransactionsUpdatedLast>\n+            std::string lpstr = lpval.get_str();\n+\n+            hashWatchedChain.SetHex(lpstr.substr(0, 64));\n+            nTransactionsUpdatedLastLP = atoi64(lpstr.substr(64));\n+        }\n+        else\n+        {\n+            // NOTE: Spec does not specify behaviour for non-string longpollid, but this makes testing easier\n+            hashWatchedChain = chainActive.Tip()->GetBlockHash();\n+            nTransactionsUpdatedLastLP = nTransactionsUpdatedLast;\n+        }\n+\n+        // Release the wallet and main lock while waiting\n+#ifdef ENABLE_WALLET\n+        if(pwalletMain)\n+            LEAVE_CRITICAL_SECTION(pwalletMain->cs_wallet);\n+#endif\n+        LEAVE_CRITICAL_SECTION(cs_main);\n+        {\n+            checktxtime = boost::get_system_time() + boost::posix_time::minutes(1);\n+\n+            boost::unique_lock<boost::mutex> lock(csBestBlock);\n+            while (chainActive.Tip()->GetBlockHash() == hashWatchedChain && IsRPCRunning())\n+            {\n+                if (!cvBlockChange.timed_wait(lock, checktxtime))\n+                {\n+                    // Timeout: Check transactions for update\n+                    if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLastLP)\n+                        break;\n+                    checktxtime += boost::posix_time::seconds(10);\n+                }\n+            }\n+        }\n+        ENTER_CRITICAL_SECTION(cs_main);\n+#ifdef ENABLE_WALLET\n+        if(pwalletMain)\n+            ENTER_CRITICAL_SECTION(pwalletMain->cs_wallet);\n+#endif\n+\n+        if (!IsRPCRunning())\n+            throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, \"Shutting down\");\n+        // TODO: Maybe recheck connections/IBD and (if something wrong) send an expires-immediately template to stop miners?\n+    }\n+\n+    // Update block\n     static CBlockIndex* pindexPrev;\n     static int64_t nStart;\n     static CBlockTemplate* pblocktemplate;\n@@ -578,14 +493,15 @@ Value getblocktemplate(const Array& params, bool fHelp)\n     result.push_back(Pair(\"transactions\", transactions));\n     result.push_back(Pair(\"coinbaseaux\", aux));\n     result.push_back(Pair(\"coinbasevalue\", (int64_t)pblock->vtx[0].vout[0].nValue));\n+    result.push_back(Pair(\"longpollid\", chainActive.Tip()->GetBlockHash().GetHex() + i64tostr(nTransactionsUpdatedLast)));\n     result.push_back(Pair(\"target\", hashTarget.GetHex()));\n     result.push_back(Pair(\"mintime\", (int64_t)pindexPrev->GetMedianTimePast()+1));\n     result.push_back(Pair(\"mutable\", aMutable));\n     result.push_back(Pair(\"noncerange\", \"00000000ffffffff\"));\n     result.push_back(Pair(\"sigoplimit\", (int64_t)MAX_BLOCK_SIGOPS));\n     result.push_back(Pair(\"sizelimit\", (int64_t)MAX_BLOCK_SIZE));\n-    result.push_back(Pair(\"curtime\", (int64_t)pblock->nTime));\n-    result.push_back(Pair(\"bits\", HexBits(pblock->nBits)));\n+    result.push_back(Pair(\"curtime\", pblock->GetBlockTime()));\n+    result.push_back(Pair(\"bits\", strprintf(\"%08x\", pblock->nBits)));\n     result.push_back(Pair(\"height\", (int64_t)(pindexPrev->nHeight+1)));\n \n     return result;"
      },
      {
        "sha": "cff795bdf4979a92d40e59e2e7643480c4f0c072",
        "filename": "src/rpcmisc.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 25,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcmisc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcmisc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmisc.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -9,6 +9,7 @@\n #include \"net.h\"\n #include \"netbase.h\"\n #include \"rpcserver.h\"\n+#include \"timedata.h\"\n #include \"util.h\"\n #ifdef ENABLE_WALLET\n #include \"wallet.h\"\n@@ -21,10 +22,10 @@\n #include \"json/json_spirit_utils.h\"\n #include \"json/json_spirit_value.h\"\n \n-using namespace std;\n using namespace boost;\n using namespace boost::assign;\n using namespace json_spirit;\n+using namespace std;\n \n Value getinfo(const Array& params, bool fHelp)\n {\n@@ -71,9 +72,9 @@ Value getinfo(const Array& params, bool fHelp)\n     obj.push_back(Pair(\"blocks\",        (int)chainActive.Height()));\n     obj.push_back(Pair(\"timeoffset\",    GetTimeOffset()));\n     obj.push_back(Pair(\"connections\",   (int)vNodes.size()));\n-    obj.push_back(Pair(\"proxy\",         (proxy.first.IsValid() ? proxy.first.ToStringIPPort() : string())));\n+    obj.push_back(Pair(\"proxy\",         (proxy.IsValid() ? proxy.ToStringIPPort() : string())));\n     obj.push_back(Pair(\"difficulty\",    (double)GetDifficulty()));\n-    obj.push_back(Pair(\"testnet\",       Params().RPCisTestNet()));\n+    obj.push_back(Pair(\"testnet\",       Params().NetworkID() == CBaseChainParams::TESTNET));\n #ifdef ENABLE_WALLET\n     if (pwalletMain) {\n         obj.push_back(Pair(\"keypoololdest\", pwalletMain->GetOldestKeyPoolTime()));\n@@ -83,44 +84,53 @@ Value getinfo(const Array& params, bool fHelp)\n         obj.push_back(Pair(\"unlocked_until\", nWalletUnlockTime));\n     obj.push_back(Pair(\"paytxfee\",      ValueFromAmount(payTxFee.GetFeePerK())));\n #endif\n-    obj.push_back(Pair(\"relayfee\",      ValueFromAmount(CTransaction::minRelayTxFee.GetFeePerK())));\n+    obj.push_back(Pair(\"relayfee\",      ValueFromAmount(::minRelayTxFee.GetFeePerK())));\n     obj.push_back(Pair(\"errors\",        GetWarnings(\"statusbar\")));\n     return obj;\n }\n \n #ifdef ENABLE_WALLET\n class DescribeAddressVisitor : public boost::static_visitor<Object>\n {\n+private:\n+    isminetype mine;\n+\n public:\n+    DescribeAddressVisitor(isminetype mineIn) : mine(mineIn) {}\n+\n     Object operator()(const CNoDestination &dest) const { return Object(); }\n \n     Object operator()(const CKeyID &keyID) const {\n         Object obj;\n         CPubKey vchPubKey;\n-        pwalletMain->GetPubKey(keyID, vchPubKey);\n         obj.push_back(Pair(\"isscript\", false));\n-        obj.push_back(Pair(\"pubkey\", HexStr(vchPubKey)));\n-        obj.push_back(Pair(\"iscompressed\", vchPubKey.IsCompressed()));\n+        if (mine == ISMINE_SPENDABLE) {\n+            pwalletMain->GetPubKey(keyID, vchPubKey);\n+            obj.push_back(Pair(\"pubkey\", HexStr(vchPubKey)));\n+            obj.push_back(Pair(\"iscompressed\", vchPubKey.IsCompressed()));\n+        }\n         return obj;\n     }\n \n     Object operator()(const CScriptID &scriptID) const {\n         Object obj;\n         obj.push_back(Pair(\"isscript\", true));\n-        CScript subscript;\n-        pwalletMain->GetCScript(scriptID, subscript);\n-        std::vector<CTxDestination> addresses;\n-        txnouttype whichType;\n-        int nRequired;\n-        ExtractDestinations(subscript, whichType, addresses, nRequired);\n-        obj.push_back(Pair(\"script\", GetTxnOutputType(whichType)));\n-        obj.push_back(Pair(\"hex\", HexStr(subscript.begin(), subscript.end())));\n-        Array a;\n-        BOOST_FOREACH(const CTxDestination& addr, addresses)\n-            a.push_back(CBitcoinAddress(addr).ToString());\n-        obj.push_back(Pair(\"addresses\", a));\n-        if (whichType == TX_MULTISIG)\n-            obj.push_back(Pair(\"sigsrequired\", nRequired));\n+        if (mine != ISMINE_NO) {\n+            CScript subscript;\n+            pwalletMain->GetCScript(scriptID, subscript);\n+            std::vector<CTxDestination> addresses;\n+            txnouttype whichType;\n+            int nRequired;\n+            ExtractDestinations(subscript, whichType, addresses, nRequired);\n+            obj.push_back(Pair(\"script\", GetTxnOutputType(whichType)));\n+            obj.push_back(Pair(\"hex\", HexStr(subscript.begin(), subscript.end())));\n+            Array a;\n+            BOOST_FOREACH(const CTxDestination& addr, addresses)\n+                a.push_back(CBitcoinAddress(addr).ToString());\n+            obj.push_back(Pair(\"addresses\", a));\n+            if (whichType == TX_MULTISIG)\n+                obj.push_back(Pair(\"sigsrequired\", nRequired));\n+        }\n         return obj;\n     }\n };\n@@ -160,10 +170,11 @@ Value validateaddress(const Array& params, bool fHelp)\n         string currentAddress = address.ToString();\n         ret.push_back(Pair(\"address\", currentAddress));\n #ifdef ENABLE_WALLET\n-        bool fMine = pwalletMain ? IsMine(*pwalletMain, dest) : false;\n-        ret.push_back(Pair(\"ismine\", fMine));\n-        if (fMine) {\n-            Object detail = boost::apply_visitor(DescribeAddressVisitor(), dest);\n+        isminetype mine = pwalletMain ? IsMine(*pwalletMain, dest) : ISMINE_NO;\n+        ret.push_back(Pair(\"ismine\", (mine & ISMINE_SPENDABLE) ? true : false));\n+        if (mine != ISMINE_NO) {\n+            ret.push_back(Pair(\"iswatchonly\", (mine & ISMINE_WATCH_ONLY) ? true: false));\n+            Object detail = boost::apply_visitor(DescribeAddressVisitor(mine), dest);\n             ret.insert(ret.end(), detail.begin(), detail.end());\n         }\n         if (pwalletMain && pwalletMain->mapAddressBook.count(dest))"
      },
      {
        "sha": "88e7c4ab07f75c3cfd46739e8fb0fa0617a090d3",
        "filename": "src/rpcnet.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 6,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcnet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcnet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcnet.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -9,6 +9,7 @@\n #include \"netbase.h\"\n #include \"protocol.h\"\n #include \"sync.h\"\n+#include \"timedata.h\"\n #include \"util.h\"\n \n #include <boost/foreach.hpp>\n@@ -78,9 +79,10 @@ Value getpeerinfo(const Array& params, bool fHelp)\n             \"\\nbResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n+            \"    \\\"id\\\": n,                   (numeric) Peer index\\n\"\n             \"    \\\"addr\\\":\\\"host:port\\\",      (string) The ip address and port of the peer\\n\"\n             \"    \\\"addrlocal\\\":\\\"ip:port\\\",   (string) local address\\n\"\n-            \"    \\\"services\\\":\\\"00000001\\\",   (string) The services\\n\"\n+            \"    \\\"services\\\":\\\"xxxxxxxxxxxxxxxx\\\",   (string) The services offered\\n\"\n             \"    \\\"lastsend\\\": ttt,           (numeric) The time in seconds since epoch (Jan 1 1970 GMT) of the last send\\n\"\n             \"    \\\"lastrecv\\\": ttt,           (numeric) The time in seconds since epoch (Jan 1 1970 GMT) of the last receive\\n\"\n             \"    \\\"bytessent\\\": n,            (numeric) The total bytes sent\\n\"\n@@ -96,8 +98,7 @@ Value getpeerinfo(const Array& params, bool fHelp)\n             \"    \\\"syncnode\\\" : true|false     (booleamn) if sync node\\n\"\n             \"  }\\n\"\n             \"  ,...\\n\"\n-            \"}\\n\"\n-\n+            \"]\\n\"\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"getpeerinfo\", \"\")\n             + HelpExampleRpc(\"getpeerinfo\", \"\")\n@@ -112,10 +113,11 @@ Value getpeerinfo(const Array& params, bool fHelp)\n         Object obj;\n         CNodeStateStats statestats;\n         bool fStateStats = GetNodeStateStats(stats.nodeid, statestats);\n+        obj.push_back(Pair(\"id\", stats.nodeid));\n         obj.push_back(Pair(\"addr\", stats.addrName));\n         if (!(stats.addrLocal.empty()))\n             obj.push_back(Pair(\"addrlocal\", stats.addrLocal));\n-        obj.push_back(Pair(\"services\", strprintf(\"%08x\", stats.nServices)));\n+        obj.push_back(Pair(\"services\", strprintf(\"%016x\", stats.nServices)));\n         obj.push_back(Pair(\"lastsend\", stats.nLastSend));\n         obj.push_back(Pair(\"lastrecv\", stats.nLastRecv));\n         obj.push_back(Pair(\"bytessent\", stats.nSendBytes));\n@@ -133,8 +135,10 @@ Value getpeerinfo(const Array& params, bool fHelp)\n         obj.push_back(Pair(\"startingheight\", stats.nStartingHeight));\n         if (fStateStats) {\n             obj.push_back(Pair(\"banscore\", statestats.nMisbehavior));\n+            obj.push_back(Pair(\"syncheight\", statestats.nSyncHeight));\n         }\n         obj.push_back(Pair(\"syncnode\", stats.fSyncNode));\n+        obj.push_back(Pair(\"whitelisted\", stats.fWhitelisted));\n \n         ret.push_back(obj);\n     }\n@@ -344,6 +348,7 @@ Value getnetworkinfo(const Array& params, bool fHelp)\n             \"{\\n\"\n             \"  \\\"version\\\": xxxxx,           (numeric) the server version\\n\"\n             \"  \\\"protocolversion\\\": xxxxx,   (numeric) the protocol version\\n\"\n+            \"  \\\"localservices\\\": \\\"xxxxxxxxxxxxxxxx\\\",   (string) the services we offer to the network\\n\"\n             \"  \\\"timeoffset\\\": xxxxx,        (numeric) the time offset\\n\"\n             \"  \\\"connections\\\": xxxxx,       (numeric) the number of connections\\n\"\n             \"  \\\"proxy\\\": \\\"host:port\\\",     (string, optional) the proxy used by the server\\n\"\n@@ -365,10 +370,11 @@ Value getnetworkinfo(const Array& params, bool fHelp)\n     Object obj;\n     obj.push_back(Pair(\"version\",       (int)CLIENT_VERSION));\n     obj.push_back(Pair(\"protocolversion\",(int)PROTOCOL_VERSION));\n+    obj.push_back(Pair(\"localservices\",       strprintf(\"%016x\", nLocalServices)));\n     obj.push_back(Pair(\"timeoffset\",    GetTimeOffset()));\n     obj.push_back(Pair(\"connections\",   (int)vNodes.size()));\n-    obj.push_back(Pair(\"proxy\",         (proxy.first.IsValid() ? proxy.first.ToStringIPPort() : string())));\n-    obj.push_back(Pair(\"relayfee\",      ValueFromAmount(CTransaction::minRelayTxFee.GetFeePerK())));\n+    obj.push_back(Pair(\"proxy\",         (proxy.IsValid() ? proxy.ToStringIPPort() : string())));\n+    obj.push_back(Pair(\"relayfee\",      ValueFromAmount(::minRelayTxFee.GetFeePerK())));\n     Array localAddresses;\n     {\n         LOCK(cs_mapLocalHost);"
      },
      {
        "sha": "9e18ca847e4ed60901974ddff26abb3056ab0c62",
        "filename": "src/rpcprotocol.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 14,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcprotocol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcprotocol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcprotocol.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -25,6 +25,9 @@ using namespace boost;\n using namespace boost::asio;\n using namespace json_spirit;\n \n+// Number of bytes to allocate and read at most at once in post data\n+const size_t POST_READ_SIZE = 256 * 1024;\n+\n //\n // HTTP protocol\n //\n@@ -54,7 +57,19 @@ static string rfc1123Time()\n     return DateTimeStrFormat(\"%a, %d %b %Y %H:%M:%S +0000\", GetTime());\n }\n \n-string HTTPReply(int nStatus, const string& strMsg, bool keepalive)\n+static const char *httpStatusDescription(int nStatus)\n+{\n+    switch (nStatus) {\n+        case HTTP_OK: return \"OK\";\n+        case HTTP_BAD_REQUEST: return \"Bad Request\";\n+        case HTTP_FORBIDDEN: return \"Forbidden\";\n+        case HTTP_NOT_FOUND: return \"Not Found\";\n+        case HTTP_INTERNAL_SERVER_ERROR: return \"Internal Server Error\";\n+        default: return \"\";\n+    }\n+}\n+\n+string HTTPError(int nStatus, bool keepalive, bool headersOnly)\n {\n     if (nStatus == HTTP_UNAUTHORIZED)\n         return strprintf(\"HTTP/1.0 401 Authorization Required\\r\\n\"\n@@ -73,29 +88,32 @@ string HTTPReply(int nStatus, const string& strMsg, bool keepalive)\n             \"</HEAD>\\r\\n\"\n             \"<BODY><H1>401 Unauthorized.</H1></BODY>\\r\\n\"\n             \"</HTML>\\r\\n\", rfc1123Time(), FormatFullVersion());\n-    const char *cStatus;\n-         if (nStatus == HTTP_OK) cStatus = \"OK\";\n-    else if (nStatus == HTTP_BAD_REQUEST) cStatus = \"Bad Request\";\n-    else if (nStatus == HTTP_FORBIDDEN) cStatus = \"Forbidden\";\n-    else if (nStatus == HTTP_NOT_FOUND) cStatus = \"Not Found\";\n-    else if (nStatus == HTTP_INTERNAL_SERVER_ERROR) cStatus = \"Internal Server Error\";\n-    else cStatus = \"\";\n+\n+    return HTTPReply(nStatus, httpStatusDescription(nStatus), keepalive,\n+                     headersOnly, \"text/plain\");\n+}\n+\n+string HTTPReply(int nStatus, const string& strMsg, bool keepalive,\n+                 bool headersOnly, const char *contentType)\n+{\n     return strprintf(\n             \"HTTP/1.1 %d %s\\r\\n\"\n             \"Date: %s\\r\\n\"\n             \"Connection: %s\\r\\n\"\n             \"Content-Length: %u\\r\\n\"\n-            \"Content-Type: application/json\\r\\n\"\n+            \"Content-Type: %s\\r\\n\"\n             \"Server: bitcoin-json-rpc/%s\\r\\n\"\n             \"\\r\\n\"\n             \"%s\",\n         nStatus,\n-        cStatus,\n+        httpStatusDescription(nStatus),\n         rfc1123Time(),\n         keepalive ? \"keep-alive\" : \"close\",\n-        strMsg.size(),\n+        (headersOnly ? 0 : strMsg.size()),\n+        contentType,\n         FormatFullVersion(),\n-        strMsg);\n+        (headersOnly ? \"\" : strMsg.c_str())\n+        );\n }\n \n bool ReadHTTPRequestLine(std::basic_istream<char>& stream, int &proto,\n@@ -189,8 +207,17 @@ int ReadHTTPMessage(std::basic_istream<char>& stream, map<string,\n     // Read message\n     if (nLen > 0)\n     {\n-        vector<char> vch(nLen);\n-        stream.read(&vch[0], nLen);\n+        vector<char> vch;\n+        size_t ptr = 0;\n+        while (ptr < (size_t)nLen)\n+        {\n+            size_t bytes_to_read = std::min((size_t)nLen - ptr, POST_READ_SIZE);\n+            vch.resize(ptr + bytes_to_read);\n+            stream.read(&vch[ptr], bytes_to_read);\n+            if (!stream) // Connection lost while reading\n+                return HTTP_INTERNAL_SERVER_ERROR;\n+            ptr += bytes_to_read;\n+        }\n         strMessageRet = string(vch.begin(), vch.end());\n     }\n "
      },
      {
        "sha": "5627077bfbf4333db305d9f9d6c80e78587f1079",
        "filename": "src/rpcprotocol.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcprotocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcprotocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcprotocol.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -141,7 +141,11 @@ class SSLIOStreamDevice : public boost::iostreams::device<boost::iostreams::bidi\n };\n \n std::string HTTPPost(const std::string& strMsg, const std::map<std::string,std::string>& mapRequestHeaders);\n-std::string HTTPReply(int nStatus, const std::string& strMsg, bool keepalive);\n+std::string HTTPError(int nStatus, bool keepalive,\n+                      bool headerOnly = false);\n+std::string HTTPReply(int nStatus, const std::string& strMsg, bool keepalive,\n+                      bool headerOnly = false,\n+                      const char *contentType = \"application/json\");\n bool ReadHTTPRequestLine(std::basic_istream<char>& stream, int &proto,\n                          std::string& http_method, std::string& http_uri);\n int ReadHTTPStatus(std::basic_istream<char>& stream, int &proto);"
      },
      {
        "sha": "1efe38e830afbc5da03807416dbdb669fe698896",
        "filename": "src/rpcrawtransaction.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 11,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcrawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcrawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcrawtransaction.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -99,8 +99,8 @@ void TxToJSON(const CTransaction& tx, const uint256 hashBlock, Object& entry)\n             if (chainActive.Contains(pindex))\n             {\n                 entry.push_back(Pair(\"confirmations\", 1 + chainActive.Height() - pindex->nHeight));\n-                entry.push_back(Pair(\"time\", (int64_t)pindex->nTime));\n-                entry.push_back(Pair(\"blocktime\", (int64_t)pindex->nTime));\n+                entry.push_back(Pair(\"time\", pindex->GetBlockTime()));\n+                entry.push_back(Pair(\"blocktime\", pindex->GetBlockTime()));\n             }\n             else\n                 entry.push_back(Pair(\"confirmations\", 0));\n@@ -304,6 +304,7 @@ Value listunspent(const Array& params, bool fHelp)\n         }\n         entry.push_back(Pair(\"amount\",ValueFromAmount(nValue)));\n         entry.push_back(Pair(\"confirmations\",out.nDepth));\n+        entry.push_back(Pair(\"spendable\", out.fSpendable));\n         results.push_back(entry);\n     }\n \n@@ -349,7 +350,7 @@ Value createrawtransaction(const Array& params, bool fHelp)\n     Array inputs = params[0].get_array();\n     Object sendTo = params[1].get_obj();\n \n-    CTransaction rawTx;\n+    CMutableTransaction rawTx;\n \n     BOOST_FOREACH(const Value& input, inputs)\n     {\n@@ -522,7 +523,7 @@ Value signrawtransaction(const Array& params, bool fHelp)\n             \"         \\\"txid\\\":\\\"id\\\",             (string, required) The transaction id\\n\"\n             \"         \\\"vout\\\":n,                  (numeric, required) The output number\\n\"\n             \"         \\\"scriptPubKey\\\": \\\"hex\\\",   (string, required) script key\\n\"\n-            \"         \\\"redeemScript\\\": \\\"hex\\\"    (string, required) redeem script\\n\"\n+            \"         \\\"redeemScript\\\": \\\"hex\\\"    (string, required for P2SH) redeem script\\n\"\n             \"       }\\n\"\n             \"       ,...\\n\"\n             \"    ]\\n\"\n@@ -554,11 +555,11 @@ Value signrawtransaction(const Array& params, bool fHelp)\n \n     vector<unsigned char> txData(ParseHexV(params[0], \"argument 1\"));\n     CDataStream ssData(txData, SER_NETWORK, PROTOCOL_VERSION);\n-    vector<CTransaction> txVariants;\n+    vector<CMutableTransaction> txVariants;\n     while (!ssData.empty())\n     {\n         try {\n-            CTransaction tx;\n+            CMutableTransaction tx;\n             ssData >> tx;\n             txVariants.push_back(tx);\n         }\n@@ -572,7 +573,7 @@ Value signrawtransaction(const Array& params, bool fHelp)\n \n     // mergedTx will end up with all the signatures; it\n     // starts as a clone of the rawtx:\n-    CTransaction mergedTx(txVariants[0]);\n+    CMutableTransaction mergedTx(txVariants[0]);\n     bool fComplete = true;\n \n     // Fetch previous transactions (inputs):\n@@ -713,7 +714,7 @@ Value signrawtransaction(const Array& params, bool fHelp)\n             SignSignature(keystore, prevPubKey, mergedTx, i, nHashType);\n \n         // ... and merge in other signatures:\n-        BOOST_FOREACH(const CTransaction& txv, txVariants)\n+        BOOST_FOREACH(const CMutableTransaction& txv, txVariants)\n         {\n             txin.scriptSig = CombineSignatures(prevPubKey, mergedTx, i, txin.scriptSig, txv.vin[i].scriptSig);\n         }\n@@ -770,7 +771,7 @@ Value sendrawtransaction(const Array& params, bool fHelp)\n     catch (std::exception &e) {\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n     }\n-    uint256 hashTx = tx.GetHash();\n+    const uint256 &hashTx = tx.GetHash();\n \n     CCoinsViewCache &view = *pcoinsTip;\n     CCoins existingCoins;\n@@ -780,7 +781,7 @@ Value sendrawtransaction(const Array& params, bool fHelp)\n         // push to local node and sync with wallets\n         CValidationState state;\n         if (AcceptToMemoryPool(mempool, state, tx, false, NULL, !fOverrideFees))\n-            SyncWithWallets(hashTx, tx, NULL);\n+            SyncWithWallets(tx, NULL);\n         else {\n             if(state.IsInvalid())\n                 throw JSONRPCError(RPC_TRANSACTION_REJECTED, strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason()));\n@@ -790,7 +791,7 @@ Value sendrawtransaction(const Array& params, bool fHelp)\n     } else if (fHaveChain) {\n         throw JSONRPCError(RPC_TRANSACTION_ALREADY_IN_CHAIN, \"transaction already in block chain\");\n     }\n-    RelayTransaction(tx, hashTx);\n+    RelayTransaction(tx);\n \n     return hashTx.GetHex();\n }"
      },
      {
        "sha": "5deb6a4e08ba60626b47a2630f7ece5e0e7dea56",
        "filename": "src/rpcserver.cpp",
        "status": "modified",
        "additions": 120,
        "deletions": 106,
        "changes": 226,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -25,13 +25,14 @@\n #include <boost/shared_ptr.hpp>\n #include \"json/json_spirit_writer_template.h\"\n \n-using namespace std;\n using namespace boost;\n using namespace boost::asio;\n using namespace json_spirit;\n+using namespace std;\n \n static std::string strRPCUserColonPass;\n \n+static bool fRPCRunning = false;\n // These are created by StartRPCThreads, destroyed in StopRPCThreads\n static asio::io_service* rpc_io_service = NULL;\n static map<string, boost::shared_ptr<deadline_timer> > deadlineTimers;\n@@ -97,16 +98,6 @@ Value ValueFromAmount(int64_t amount)\n     return (double)amount / (double)COIN;\n }\n \n-std::string HexBits(unsigned int nBits)\n-{\n-    union {\n-        int32_t nBits;\n-        char cBits[4];\n-    } uBits;\n-    uBits.nBits = htonl((int32_t)nBits);\n-    return HexStr(BEGIN(uBits.cBits), END(uBits.cBits));\n-}\n-\n uint256 ParseHashV(const Value& v, string strName)\n {\n     string strHex;\n@@ -242,8 +233,8 @@ static const CRPCCommand vRPCCommands[] =\n     { \"getblockchaininfo\",      &getblockchaininfo,      true,      false,      false },\n     { \"getbestblockhash\",       &getbestblockhash,       true,      false,      false },\n     { \"getblockcount\",          &getblockcount,          true,      false,      false },\n-    { \"getblock\",               &getblock,               false,     false,      false },\n-    { \"getblockhash\",           &getblockhash,           false,     false,      false },\n+    { \"getblock\",               &getblock,               true,      false,      false },\n+    { \"getblockhash\",           &getblockhash,           true,      false,      false },\n     { \"getdifficulty\",          &getdifficulty,          true,      false,      false },\n     { \"getrawmempool\",          &getrawmempool,          true,      false,      false },\n     { \"gettxout\",               &gettxout,               true,      false,      false },\n@@ -254,32 +245,33 @@ static const CRPCCommand vRPCCommands[] =\n     { \"getblocktemplate\",       &getblocktemplate,       true,      false,      false },\n     { \"getmininginfo\",          &getmininginfo,          true,      false,      false },\n     { \"getnetworkhashps\",       &getnetworkhashps,       true,      false,      false },\n-    { \"submitblock\",            &submitblock,            false,     true,       false },\n+    { \"prioritisetransaction\",  &prioritisetransaction,  true,      false,      false },\n+    { \"submitblock\",            &submitblock,            true,      true,       false },\n \n     /* Raw transactions */\n-    { \"createrawtransaction\",   &createrawtransaction,   false,     false,      false },\n-    { \"decoderawtransaction\",   &decoderawtransaction,   false,     false,      false },\n-    { \"decodescript\",           &decodescript,           false,     false,      false },\n-    { \"getrawtransaction\",      &getrawtransaction,      false,     false,      false },\n+    { \"createrawtransaction\",   &createrawtransaction,   true,      false,      false },\n+    { \"decoderawtransaction\",   &decoderawtransaction,   true,      false,      false },\n+    { \"decodescript\",           &decodescript,           true,      false,      false },\n+    { \"getrawtransaction\",      &getrawtransaction,      true,      false,      false },\n     { \"sendrawtransaction\",     &sendrawtransaction,     false,     false,      false },\n     { \"signrawtransaction\",     &signrawtransaction,     false,     false,      false }, /* uses wallet if enabled */\n \n     /* Utility functions */\n     { \"createmultisig\",         &createmultisig,         true,      true ,      false },\n     { \"validateaddress\",        &validateaddress,        true,      false,      false }, /* uses wallet if enabled */\n-    { \"verifymessage\",          &verifymessage,          false,     false,      false },\n+    { \"verifymessage\",          &verifymessage,          true,      false,      false },\n     { \"estimatefee\",            &estimatefee,            true,      true,       false },\n     { \"estimatepriority\",       &estimatepriority,       true,      true,       false },\n \n #ifdef ENABLE_WALLET\n     /* Wallet */\n-    { \"addmultisigaddress\",     &addmultisigaddress,     false,     false,      true },\n+    { \"addmultisigaddress\",     &addmultisigaddress,     true,      false,      true },\n     { \"backupwallet\",           &backupwallet,           true,      false,      true },\n     { \"dumpprivkey\",            &dumpprivkey,            true,      false,      true },\n     { \"dumpwallet\",             &dumpwallet,             true,      false,      true },\n-    { \"encryptwallet\",          &encryptwallet,          false,     false,      true },\n+    { \"encryptwallet\",          &encryptwallet,          true,      false,      true },\n     { \"getaccountaddress\",      &getaccountaddress,      true,      false,      true },\n-    { \"getaccount\",             &getaccount,             false,     false,      true },\n+    { \"getaccount\",             &getaccount,             true,      false,      true },\n     { \"getaddressesbyaccount\",  &getaddressesbyaccount,  true,      false,      true },\n     { \"getbalance\",             &getbalance,             false,     false,      true },\n     { \"getnewaddress\",          &getnewaddress,          true,      false,      true },\n@@ -288,9 +280,10 @@ static const CRPCCommand vRPCCommands[] =\n     { \"getreceivedbyaddress\",   &getreceivedbyaddress,   false,     false,      true },\n     { \"gettransaction\",         &gettransaction,         false,     false,      true },\n     { \"getunconfirmedbalance\",  &getunconfirmedbalance,  false,     false,      true },\n-    { \"getwalletinfo\",          &getwalletinfo,          true,      false,      true },\n-    { \"importprivkey\",          &importprivkey,          false,     false,      true },\n-    { \"importwallet\",           &importwallet,           false,     false,      true },\n+    { \"getwalletinfo\",          &getwalletinfo,          false,     false,      true },\n+    { \"importprivkey\",          &importprivkey,          true,      false,      true },\n+    { \"importwallet\",           &importwallet,           true,      false,      true },\n+    { \"importaddress\",          &importaddress,          true,      false,      true },\n     { \"keypoolrefill\",          &keypoolrefill,          true,      false,      true },\n     { \"listaccounts\",           &listaccounts,           false,     false,      true },\n     { \"listaddressgroupings\",   &listaddressgroupings,   false,     false,      true },\n@@ -300,22 +293,21 @@ static const CRPCCommand vRPCCommands[] =\n     { \"listsinceblock\",         &listsinceblock,         false,     false,      true },\n     { \"listtransactions\",       &listtransactions,       false,     false,      true },\n     { \"listunspent\",            &listunspent,            false,     false,      true },\n-    { \"lockunspent\",            &lockunspent,            false,     false,      true },\n+    { \"lockunspent\",            &lockunspent,            true,      false,      true },\n     { \"move\",                   &movecmd,                false,     false,      true },\n     { \"sendfrom\",               &sendfrom,               false,     false,      true },\n     { \"sendmany\",               &sendmany,               false,     false,      true },\n     { \"sendtoaddress\",          &sendtoaddress,          false,     false,      true },\n     { \"setaccount\",             &setaccount,             true,      false,      true },\n-    { \"settxfee\",               &settxfee,               false,     false,      true },\n-    { \"signmessage\",            &signmessage,            false,     false,      true },\n+    { \"settxfee\",               &settxfee,               true,      false,      true },\n+    { \"signmessage\",            &signmessage,            true,      false,      true },\n     { \"walletlock\",             &walletlock,             true,      false,      true },\n-    { \"walletpassphrasechange\", &walletpassphrasechange, false,     false,      true },\n+    { \"walletpassphrasechange\", &walletpassphrasechange, true,      false,      true },\n     { \"walletpassphrase\",       &walletpassphrase,       true,      false,      true },\n \n     /* Wallet-enabled mining */\n     { \"getgenerate\",            &getgenerate,            true,      false,      false },\n     { \"gethashespersec\",        &gethashespersec,        true,      false,      false },\n-    { \"getwork\",                &getwork,                true,      false,      true  },\n     { \"setgenerate\",            &setgenerate,            true,      true,       false },\n #endif // ENABLE_WALLET\n };\n@@ -393,16 +385,6 @@ bool ClientAllowed(const boost::asio::ip::address& address)\n     return false;\n }\n \n-class AcceptedConnection\n-{\n-public:\n-    virtual ~AcceptedConnection() {}\n-\n-    virtual std::iostream& stream() = 0;\n-    virtual std::string peer_address_to_string() const = 0;\n-    virtual void close() = 0;\n-};\n-\n template <typename Protocol>\n class AcceptedConnectionImpl : public AcceptedConnection\n {\n@@ -501,7 +483,7 @@ static void RPCAcceptHandler(boost::shared_ptr< basic_socket_acceptor<Protocol,\n     {\n         // Only send a 403 if we're not using SSL to prevent a DoS during the SSL handshake.\n         if (!fUseSSL)\n-            conn->stream() << HTTPReply(HTTP_FORBIDDEN, \"\", false) << std::flush;\n+            conn->stream() << HTTPError(HTTP_FORBIDDEN, false) << std::flush;\n         conn->close();\n     }\n     else {\n@@ -532,7 +514,7 @@ void StartRPCThreads()\n             if(!subnet.IsValid())\n             {\n                 uiInterface.ThreadSafeMessageBox(\n-                    strprintf(\"Invalid -rpcallowip subnet specification: %s\", strAllow),\n+                    strprintf(\"Invalid -rpcallowip subnet specification: %s. Valid are a single IP (e.g. 1.2.3.4), a network/netmask (e.g. 1.2.3.4/255.255.255.0) or a network/CIDR (e.g. 1.2.3.4/24).\", strAllow),\n                     \"\", CClientUIInterface::MSG_ERROR);\n                 StartShutdown();\n                 return;\n@@ -550,7 +532,7 @@ void StartRPCThreads()\n          (mapArgs[\"-rpcuser\"] == mapArgs[\"-rpcpassword\"])) && Params().RequireRPCPassword())\n     {\n         unsigned char rand_pwd[32];\n-        RAND_bytes(rand_pwd, 32);\n+        GetRandBytes(rand_pwd, 32);\n         string strWhatAmI = \"To use bitcoind\";\n         if (mapArgs.count(\"-server\"))\n             strWhatAmI = strprintf(_(\"To use the %s option\"), \"\\\"-server\\\"\");\n@@ -601,7 +583,7 @@ void StartRPCThreads()\n \n     std::vector<ip::tcp::endpoint> vEndpoints;\n     bool bBindAny = false;\n-    int defaultPort = GetArg(\"-rpcport\", Params().RPCPort());\n+    int defaultPort = GetArg(\"-rpcport\", BaseParams().RPCPort());\n     if (!mapArgs.count(\"-rpcallowip\")) // Default to loopback if not allowing external IPs\n     {\n         vEndpoints.push_back(ip::tcp::endpoint(asio::ip::address_v6::loopback(), defaultPort));\n@@ -642,7 +624,6 @@ void StartRPCThreads()\n         LogPrintf(\"Binding RPC on address %s port %i (IPv4+IPv6 bind any: %i)\\n\", bindAddress.to_string(), endpoint.port(), bBindAny);\n         boost::system::error_code v6_only_error;\n         boost::shared_ptr<ip::tcp::acceptor> acceptor(new ip::tcp::acceptor(*rpc_io_service));\n-        rpc_acceptors.push_back(acceptor);\n \n         try {\n             acceptor->open(endpoint.protocol());\n@@ -658,6 +639,7 @@ void StartRPCThreads()\n             RPCListen(acceptor, *rpc_ssl_context, fUseSSL);\n \n             fListening = true;\n+            rpc_acceptors.push_back(acceptor);\n             // If dual IPv6/IPv4 bind succesful, skip binding to IPv4 separately\n             if(bBindAny && bindAddress == asio::ip::address_v6::any() && !v6_only_error)\n                 break;\n@@ -678,6 +660,7 @@ void StartRPCThreads()\n     rpc_worker_group = new boost::thread_group();\n     for (int i = 0; i < GetArg(\"-rpcthreads\", 4); i++)\n         rpc_worker_group->create_thread(boost::bind(&asio::io_service::run, rpc_io_service));\n+    fRPCRunning = true;\n }\n \n void StartDummyRPCThread()\n@@ -690,24 +673,37 @@ void StartDummyRPCThread()\n         rpc_dummy_work = new asio::io_service::work(*rpc_io_service);\n         rpc_worker_group = new boost::thread_group();\n         rpc_worker_group->create_thread(boost::bind(&asio::io_service::run, rpc_io_service));\n+        fRPCRunning = true;\n     }\n }\n \n void StopRPCThreads()\n {\n     if (rpc_io_service == NULL) return;\n+    // Set this to false first, so that longpolling loops will exit when woken up\n+    fRPCRunning = false;\n \n     // First, cancel all timers and acceptors\n     // This is not done automatically by ->stop(), and in some cases the destructor of\n     // asio::io_service can hang if this is skipped.\n+    boost::system::error_code ec;\n     BOOST_FOREACH(const boost::shared_ptr<ip::tcp::acceptor> &acceptor, rpc_acceptors)\n-        acceptor->cancel();\n+    {\n+        acceptor->cancel(ec);\n+        if (ec)\n+            LogPrintf(\"%s: Warning: %s when cancelling acceptor\", __func__, ec.message());\n+    }\n     rpc_acceptors.clear();\n     BOOST_FOREACH(const PAIRTYPE(std::string, boost::shared_ptr<deadline_timer>) &timer, deadlineTimers)\n-        timer.second->cancel();\n+    {\n+        timer.second->cancel(ec);\n+        if (ec)\n+            LogPrintf(\"%s: Warning: %s when cancelling timer\", __func__, ec.message());\n+    }\n     deadlineTimers.clear();\n \n     rpc_io_service->stop();\n+    cvBlockChange.notify_all();\n     if (rpc_worker_group != NULL)\n         rpc_worker_group->join_all();\n     delete rpc_dummy_work; rpc_dummy_work = NULL;\n@@ -716,6 +712,11 @@ void StopRPCThreads()\n     delete rpc_io_service; rpc_io_service = NULL;\n }\n \n+bool IsRPCRunning()\n+{\n+    return fRPCRunning;\n+}\n+\n void RPCRunHandler(const boost::system::error_code& err, boost::function<void(void)> func)\n {\n     if (!err)\n@@ -763,7 +764,7 @@ void JSONRequest::parse(const Value& valRequest)\n     if (valMethod.type() != str_type)\n         throw JSONRPCError(RPC_INVALID_REQUEST, \"Method must be a string\");\n     strMethod = valMethod.get_str();\n-    if (strMethod != \"getwork\" && strMethod != \"getblocktemplate\")\n+    if (strMethod != \"getblocktemplate\")\n         LogPrint(\"rpc\", \"ThreadRPCServer method=%s\\n\", strMethod);\n \n     // Parse params\n@@ -810,6 +811,71 @@ static string JSONRPCExecBatch(const Array& vReq)\n     return write_string(Value(ret), false) + \"\\n\";\n }\n \n+static bool HTTPReq_JSONRPC(AcceptedConnection *conn,\n+                            string& strRequest,\n+                            map<string, string>& mapHeaders,\n+                            bool fRun)\n+{\n+    // Check authorization\n+    if (mapHeaders.count(\"authorization\") == 0)\n+    {\n+        conn->stream() << HTTPError(HTTP_UNAUTHORIZED, false) << std::flush;\n+        return false;\n+    }\n+\n+    if (!HTTPAuthorized(mapHeaders))\n+    {\n+        LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", conn->peer_address_to_string());\n+        /* Deter brute-forcing short passwords.\n+           If this results in a DoS the user really\n+           shouldn't have their RPC port exposed. */\n+        if (mapArgs[\"-rpcpassword\"].size() < 20)\n+            MilliSleep(250);\n+\n+        conn->stream() << HTTPError(HTTP_UNAUTHORIZED, false) << std::flush;\n+        return false;\n+    }\n+\n+    JSONRequest jreq;\n+    try\n+    {\n+        // Parse request\n+        Value valRequest;\n+        if (!read_string(strRequest, valRequest))\n+            throw JSONRPCError(RPC_PARSE_ERROR, \"Parse error\");\n+\n+        string strReply;\n+\n+        // singleton request\n+        if (valRequest.type() == obj_type) {\n+            jreq.parse(valRequest);\n+\n+            Value result = tableRPC.execute(jreq.strMethod, jreq.params);\n+\n+            // Send reply\n+            strReply = JSONRPCReply(result, Value::null, jreq.id);\n+\n+        // array of requests\n+        } else if (valRequest.type() == array_type)\n+            strReply = JSONRPCExecBatch(valRequest.get_array());\n+        else\n+            throw JSONRPCError(RPC_PARSE_ERROR, \"Top-level object parse error\");\n+\n+        conn->stream() << HTTPReply(HTTP_OK, strReply, fRun) << std::flush;\n+    }\n+    catch (Object& objError)\n+    {\n+        ErrorReply(conn->stream(), objError, jreq.id);\n+        return false;\n+    }\n+    catch (std::exception& e)\n+    {\n+        ErrorReply(conn->stream(), JSONRPCError(RPC_PARSE_ERROR, e.what()), jreq.id);\n+        return false;\n+    }\n+    return true;\n+}\n+\n void ServiceConnection(AcceptedConnection *conn)\n {\n     bool fRun = true;\n@@ -826,67 +892,15 @@ void ServiceConnection(AcceptedConnection *conn)\n         // Read HTTP message headers and body\n         ReadHTTPMessage(conn->stream(), mapHeaders, strRequest, nProto);\n \n-        if (strURI != \"/\") {\n-            conn->stream() << HTTPReply(HTTP_NOT_FOUND, \"\", false) << std::flush;\n-            break;\n-        }\n-\n-        // Check authorization\n-        if (mapHeaders.count(\"authorization\") == 0)\n-        {\n-            conn->stream() << HTTPReply(HTTP_UNAUTHORIZED, \"\", false) << std::flush;\n-            break;\n-        }\n-        if (!HTTPAuthorized(mapHeaders))\n-        {\n-            LogPrintf(\"ThreadRPCServer incorrect password attempt from %s\\n\", conn->peer_address_to_string());\n-            /* Deter brute-forcing short passwords.\n-               If this results in a DoS the user really\n-               shouldn't have their RPC port exposed. */\n-            if (mapArgs[\"-rpcpassword\"].size() < 20)\n-                MilliSleep(250);\n-\n-            conn->stream() << HTTPReply(HTTP_UNAUTHORIZED, \"\", false) << std::flush;\n-            break;\n-        }\n+        // HTTP Keep-Alive is false; close connection immediately\n         if (mapHeaders[\"connection\"] == \"close\")\n             fRun = false;\n \n-        JSONRequest jreq;\n-        try\n-        {\n-            // Parse request\n-            Value valRequest;\n-            if (!read_string(strRequest, valRequest))\n-                throw JSONRPCError(RPC_PARSE_ERROR, \"Parse error\");\n-\n-            string strReply;\n-\n-            // singleton request\n-            if (valRequest.type() == obj_type) {\n-                jreq.parse(valRequest);\n-\n-                Value result = tableRPC.execute(jreq.strMethod, jreq.params);\n-\n-                // Send reply\n-                strReply = JSONRPCReply(result, Value::null, jreq.id);\n-\n-            // array of requests\n-            } else if (valRequest.type() == array_type)\n-                strReply = JSONRPCExecBatch(valRequest.get_array());\n-            else\n-                throw JSONRPCError(RPC_PARSE_ERROR, \"Top-level object parse error\");\n-\n-            conn->stream() << HTTPReply(HTTP_OK, strReply, fRun) << std::flush;\n-        }\n-        catch (Object& objError)\n-        {\n-            ErrorReply(conn->stream(), objError, jreq.id);\n-            break;\n-        }\n-        catch (std::exception& e)\n-        {\n-            ErrorReply(conn->stream(), JSONRPCError(RPC_PARSE_ERROR, e.what()), jreq.id);\n+        if (strURI == \"/\") {\n+            if (!HTTPReq_JSONRPC(conn, strRequest, mapHeaders, fRun))\n+                break;\n+        } else {\n+            conn->stream() << HTTPError(HTTP_NOT_FOUND, false) << std::flush;\n             break;\n         }\n     }"
      },
      {
        "sha": "31badadd6d714cf564171e4b81b8488044a213a6",
        "filename": "src/rpcserver.h",
        "status": "modified",
        "additions": 14,
        "deletions": 2,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcserver.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcserver.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcserver.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -21,6 +21,16 @@\n class CBlockIndex;\n class CNetAddr;\n \n+class AcceptedConnection\n+{\n+public:\n+    virtual ~AcceptedConnection() {}\n+\n+    virtual std::iostream& stream() = 0;\n+    virtual std::string peer_address_to_string() const = 0;\n+    virtual void close() = 0;\n+};\n+\n /* Start RPC threads */\n void StartRPCThreads();\n /* Alternative to StartRPCThreads for the GUI, when no server is\n@@ -30,6 +40,8 @@ void StartRPCThreads();\n void StartDummyRPCThread();\n /* Stop RPC threads */\n void StopRPCThreads();\n+/* Query whether RPC is running */\n+bool IsRPCRunning();\n \n /*\n   Type-check arguments; throws JSONRPCError if wrong type given. Does not check that\n@@ -106,7 +118,6 @@ extern int64_t nWalletUnlockTime;\n extern int64_t AmountFromValue(const json_spirit::Value& value);\n extern json_spirit::Value ValueFromAmount(int64_t amount);\n extern double GetDifficulty(const CBlockIndex* blockindex = NULL);\n-extern std::string HexBits(unsigned int nBits);\n extern std::string HelpRequiringPassphrase();\n extern std::string HelpExampleCli(std::string methodname, std::string args);\n extern std::string HelpExampleRpc(std::string methodname, std::string args);\n@@ -122,6 +133,7 @@ extern json_spirit::Value getnettotals(const json_spirit::Array& params, bool fH\n \n extern json_spirit::Value dumpprivkey(const json_spirit::Array& params, bool fHelp); // in rpcdump.cpp\n extern json_spirit::Value importprivkey(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value importaddress(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value dumpwallet(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value importwallet(const json_spirit::Array& params, bool fHelp);\n \n@@ -130,7 +142,7 @@ extern json_spirit::Value setgenerate(const json_spirit::Array& params, bool fHe\n extern json_spirit::Value getnetworkhashps(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value gethashespersec(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value getmininginfo(const json_spirit::Array& params, bool fHelp);\n-extern json_spirit::Value getwork(const json_spirit::Array& params, bool fHelp);\n+extern json_spirit::Value prioritisetransaction(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value getblocktemplate(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value submitblock(const json_spirit::Array& params, bool fHelp);\n extern json_spirit::Value estimatefee(const json_spirit::Array& params, bool fHelp);"
      },
      {
        "sha": "5b83fe900ecdbacc60abbda3c5133415e99fc014",
        "filename": "src/rpcwallet.cpp",
        "status": "modified",
        "additions": 125,
        "deletions": 64,
        "changes": 189,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcwallet.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -8,6 +8,7 @@\n #include \"init.h\"\n #include \"net.h\"\n #include \"netbase.h\"\n+#include \"timedata.h\"\n #include \"util.h\"\n #include \"wallet.h\"\n #include \"walletdb.h\"\n@@ -49,7 +50,7 @@ void WalletTxToJSON(const CWalletTx& wtx, Object& entry)\n     {\n         entry.push_back(Pair(\"blockhash\", wtx.hashBlock.GetHex()));\n         entry.push_back(Pair(\"blockindex\", wtx.nIndex));\n-        entry.push_back(Pair(\"blocktime\", (int64_t)(mapBlockIndex[wtx.hashBlock]->nTime)));\n+        entry.push_back(Pair(\"blocktime\", mapBlockIndex[wtx.hashBlock]->GetBlockTime()));\n     }\n     uint256 hash = wtx.GetHash();\n     entry.push_back(Pair(\"txid\", hash.GetHex()));\n@@ -196,7 +197,7 @@ Value getrawchangeaddress(const Array& params, bool fHelp)\n     CReserveKey reservekey(pwalletMain);\n     CPubKey vchPubKey;\n     if (!reservekey.GetReservedKey(vchPubKey))\n-        throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Unable to obtain key for change\");\n+        throw JSONRPCError(RPC_WALLET_KEYPOOL_RAN_OUT, \"Error: Keypool ran out, please call keypoolrefill first\");\n \n     reservekey.KeepKey();\n \n@@ -341,7 +342,7 @@ Value sendtoaddress(const Array& params, bool fHelp)\n \n     EnsureWalletIsUnlocked();\n \n-    string strError = pwalletMain->SendMoneyToDestination(address.Get(), nAmount, wtx);\n+    string strError = pwalletMain->SendMoney(address.Get(), nAmount, wtx);\n     if (strError != \"\")\n         throw JSONRPCError(RPC_WALLET_ERROR, strError);\n \n@@ -552,7 +553,7 @@ Value getreceivedbyaccount(const Array& params, bool fHelp)\n }\n \n \n-int64_t GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMinDepth)\n+int64_t GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMinDepth, const isminefilter& filter)\n {\n     int64_t nBalance = 0;\n \n@@ -564,7 +565,7 @@ int64_t GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMi\n             continue;\n \n         int64_t nReceived, nSent, nFee;\n-        wtx.GetAccountAmounts(strAccount, nReceived, nSent, nFee);\n+        wtx.GetAccountAmounts(strAccount, nReceived, nSent, nFee, filter);\n \n         if (nReceived != 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n             nBalance += nReceived;\n@@ -577,25 +578,26 @@ int64_t GetAccountBalance(CWalletDB& walletdb, const string& strAccount, int nMi\n     return nBalance;\n }\n \n-int64_t GetAccountBalance(const string& strAccount, int nMinDepth)\n+int64_t GetAccountBalance(const string& strAccount, int nMinDepth, const isminefilter& filter)\n {\n     CWalletDB walletdb(pwalletMain->strWalletFile);\n-    return GetAccountBalance(walletdb, strAccount, nMinDepth);\n+    return GetAccountBalance(walletdb, strAccount, nMinDepth, filter);\n }\n \n \n Value getbalance(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() > 2)\n+    if (fHelp || params.size() > 3)\n         throw runtime_error(\n-            \"getbalance ( \\\"account\\\" minconf )\\n\"\n+            \"getbalance ( \\\"account\\\" minconf includeWatchonly )\\n\"\n             \"\\nIf account is not specified, returns the server's total available balance.\\n\"\n             \"If account is specified, returns the balance in the account.\\n\"\n             \"Note that the account \\\"\\\" is not the same as leaving the parameter out.\\n\"\n             \"The server total may be different to the balance in the default \\\"\\\" account.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"account\\\"      (string, optional) The selected account, or \\\"*\\\" for entire wallet. It may be the default account using \\\"\\\".\\n\"\n             \"2. minconf          (numeric, optional, default=1) Only include transactions confirmed at least this many times.\\n\"\n+            \"3. includeWatchonly (bool, optional, default=false) Also include balance in watchonly addresses (see 'importaddress')\\n\"\n             \"\\nResult:\\n\"\n             \"amount              (numeric) The total amount in btc received for this account.\\n\"\n             \"\\nExamples:\\n\"\n@@ -617,6 +619,10 @@ Value getbalance(const Array& params, bool fHelp)\n     int nMinDepth = 1;\n     if (params.size() > 1)\n         nMinDepth = params[1].get_int();\n+    isminefilter filter = ISMINE_SPENDABLE;\n+    if(params.size() > 2)\n+        if(params[2].get_bool())\n+            filter = filter | ISMINE_WATCH_ONLY;\n \n     if (params[0].get_str() == \"*\") {\n         // Calculate total balance a different way from GetBalance()\n@@ -631,24 +637,24 @@ Value getbalance(const Array& params, bool fHelp)\n \n             int64_t allFee;\n             string strSentAccount;\n-            list<pair<CTxDestination, int64_t> > listReceived;\n-            list<pair<CTxDestination, int64_t> > listSent;\n-            wtx.GetAmounts(listReceived, listSent, allFee, strSentAccount);\n+            list<COutputEntry> listReceived;\n+            list<COutputEntry> listSent;\n+            wtx.GetAmounts(listReceived, listSent, allFee, strSentAccount, filter);\n             if (wtx.GetDepthInMainChain() >= nMinDepth)\n             {\n-                BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64_t)& r, listReceived)\n-                    nBalance += r.second;\n+                BOOST_FOREACH(const COutputEntry& r, listReceived)\n+                    nBalance += r.amount;\n             }\n-            BOOST_FOREACH(const PAIRTYPE(CTxDestination,int64_t)& r, listSent)\n-                nBalance -= r.second;\n+            BOOST_FOREACH(const COutputEntry& s, listSent)\n+                nBalance -= s.amount;\n             nBalance -= allFee;\n         }\n         return  ValueFromAmount(nBalance);\n     }\n \n     string strAccount = AccountFromValue(params[0]);\n \n-    int64_t nBalance = GetAccountBalance(strAccount, nMinDepth);\n+    int64_t nBalance = GetAccountBalance(strAccount, nMinDepth, filter);\n \n     return ValueFromAmount(nBalance);\n }\n@@ -776,12 +782,12 @@ Value sendfrom(const Array& params, bool fHelp)\n     EnsureWalletIsUnlocked();\n \n     // Check funds\n-    int64_t nBalance = GetAccountBalance(strAccount, nMinDepth);\n+    int64_t nBalance = GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);\n     if (nAmount > nBalance)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n \n     // Send\n-    string strError = pwalletMain->SendMoneyToDestination(address.Get(), nAmount, wtx);\n+    string strError = pwalletMain->SendMoney(address.Get(), nAmount, wtx);\n     if (strError != \"\")\n         throw JSONRPCError(RPC_WALLET_ERROR, strError);\n \n@@ -853,7 +859,7 @@ Value sendmany(const Array& params, bool fHelp)\n     EnsureWalletIsUnlocked();\n \n     // Check funds\n-    int64_t nBalance = GetAccountBalance(strAccount, nMinDepth);\n+    int64_t nBalance = GetAccountBalance(strAccount, nMinDepth, ISMINE_SPENDABLE);\n     if (totalAmount > nBalance)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, \"Account has insufficient funds\");\n \n@@ -922,10 +928,12 @@ struct tallyitem\n     int64_t nAmount;\n     int nConf;\n     vector<uint256> txids;\n+    bool fIsWatchonly;\n     tallyitem()\n     {\n         nAmount = 0;\n         nConf = std::numeric_limits<int>::max();\n+        fIsWatchonly = false;\n     }\n };\n \n@@ -941,6 +949,11 @@ Value ListReceived(const Array& params, bool fByAccounts)\n     if (params.size() > 1)\n         fIncludeEmpty = params[1].get_bool();\n \n+    isminefilter filter = ISMINE_SPENDABLE;\n+    if(params.size() > 2)\n+        if(params[2].get_bool())\n+            filter = filter | ISMINE_WATCH_ONLY;\n+\n     // Tally\n     map<CBitcoinAddress, tallyitem> mapTally;\n     for (map<uint256, CWalletTx>::iterator it = pwalletMain->mapWallet.begin(); it != pwalletMain->mapWallet.end(); ++it)\n@@ -957,13 +970,19 @@ Value ListReceived(const Array& params, bool fByAccounts)\n         BOOST_FOREACH(const CTxOut& txout, wtx.vout)\n         {\n             CTxDestination address;\n-            if (!ExtractDestination(txout.scriptPubKey, address) || !IsMine(*pwalletMain, address))\n+            if (!ExtractDestination(txout.scriptPubKey, address))\n+                continue;\n+\n+            isminefilter mine = IsMine(*pwalletMain, address);\n+            if(!(mine & filter))\n                 continue;\n \n             tallyitem& item = mapTally[address];\n             item.nAmount += txout.nValue;\n             item.nConf = min(item.nConf, nDepth);\n             item.txids.push_back(wtx.GetHash());\n+            if (mine & ISMINE_WATCH_ONLY)\n+                item.fIsWatchonly = true;\n         }\n     }\n \n@@ -980,21 +999,26 @@ Value ListReceived(const Array& params, bool fByAccounts)\n \n         int64_t nAmount = 0;\n         int nConf = std::numeric_limits<int>::max();\n+        bool fIsWatchonly = false;\n         if (it != mapTally.end())\n         {\n             nAmount = (*it).second.nAmount;\n             nConf = (*it).second.nConf;\n+            fIsWatchonly = (*it).second.fIsWatchonly;\n         }\n \n         if (fByAccounts)\n         {\n             tallyitem& item = mapAccountTally[strAccount];\n             item.nAmount += nAmount;\n             item.nConf = min(item.nConf, nConf);\n+            item.fIsWatchonly = fIsWatchonly;\n         }\n         else\n         {\n             Object obj;\n+            if(fIsWatchonly)\n+                obj.push_back(Pair(\"involvesWatchonly\", true));\n             obj.push_back(Pair(\"address\",       address.ToString()));\n             obj.push_back(Pair(\"account\",       strAccount));\n             obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n@@ -1019,6 +1043,8 @@ Value ListReceived(const Array& params, bool fByAccounts)\n             int64_t nAmount = (*it).second.nAmount;\n             int nConf = (*it).second.nConf;\n             Object obj;\n+            if((*it).second.fIsWatchonly)\n+                obj.push_back(Pair(\"involvesWatchonly\", true));\n             obj.push_back(Pair(\"account\",       (*it).first));\n             obj.push_back(Pair(\"amount\",        ValueFromAmount(nAmount)));\n             obj.push_back(Pair(\"confirmations\", (nConf == std::numeric_limits<int>::max() ? 0 : nConf)));\n@@ -1031,17 +1057,19 @@ Value ListReceived(const Array& params, bool fByAccounts)\n \n Value listreceivedbyaddress(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() > 2)\n+    if (fHelp || params.size() > 3)\n         throw runtime_error(\n-            \"listreceivedbyaddress ( minconf includeempty )\\n\"\n+            \"listreceivedbyaddress ( minconf includeempty includeWatchonly)\\n\"\n             \"\\nList balances by receiving address.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. minconf       (numeric, optional, default=1) The minimum number of confirmations before payments are included.\\n\"\n             \"2. includeempty  (numeric, optional, dafault=false) Whether to include addresses that haven't received any payments.\\n\"\n+            \"3. includeWatchonly (bool, optional, default=false) Whether to include watchonly addresses (see 'importaddress').\\n\"\n \n             \"\\nResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n+            \"    \\\"involvesWatchonly\\\" : \\\"true\\\",    (bool) Only returned if imported addresses were involved in transaction\\n\"\n             \"    \\\"address\\\" : \\\"receivingaddress\\\",  (string) The receiving address\\n\"\n             \"    \\\"account\\\" : \\\"accountname\\\",       (string) The account of the receiving address. The default account is \\\"\\\".\\n\"\n             \"    \\\"amount\\\" : x.xxx,                  (numeric) The total amount in btc received by the address\\n\"\n@@ -1053,25 +1081,27 @@ Value listreceivedbyaddress(const Array& params, bool fHelp)\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"listreceivedbyaddress\", \"\")\n             + HelpExampleCli(\"listreceivedbyaddress\", \"6 true\")\n-            + HelpExampleRpc(\"listreceivedbyaddress\", \"6, true\")\n+            + HelpExampleRpc(\"listreceivedbyaddress\", \"6, true, true\")\n         );\n \n     return ListReceived(params, false);\n }\n \n Value listreceivedbyaccount(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() > 2)\n+    if (fHelp || params.size() > 3)\n         throw runtime_error(\n-            \"listreceivedbyaccount ( minconf includeempty )\\n\"\n+            \"listreceivedbyaccount ( minconf includeempty includeWatchonly)\\n\"\n             \"\\nList balances by account.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. minconf      (numeric, optional, default=1) The minimum number of confirmations before payments are included.\\n\"\n             \"2. includeempty (boolean, optional, default=false) Whether to include accounts that haven't received any payments.\\n\"\n+            \"3. includeWatchonly (bool, optional, default=false) Whether to include watchonly addresses (see 'importaddress').\\n\"\n \n             \"\\nResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n+            \"    \\\"involvesWatchonly\\\" : \\\"true\\\",    (bool) Only returned if imported addresses were involved in transaction\\n\"\n             \"    \\\"account\\\" : \\\"accountname\\\",  (string) The account name of the receiving account\\n\"\n             \"    \\\"amount\\\" : x.xxx,             (numeric) The total amount received by addresses with this account\\n\"\n             \"    \\\"confirmations\\\" : n           (numeric) The number of confirmations of the most recent transaction included\\n\"\n@@ -1082,7 +1112,7 @@ Value listreceivedbyaccount(const Array& params, bool fHelp)\n             \"\\nExamples:\\n\"\n             + HelpExampleCli(\"listreceivedbyaccount\", \"\")\n             + HelpExampleCli(\"listreceivedbyaccount\", \"6 true\")\n-            + HelpExampleRpc(\"listreceivedbyaccount\", \"6, true\")\n+            + HelpExampleRpc(\"listreceivedbyaccount\", \"6, true, true\")\n         );\n \n     return ListReceived(params, true);\n@@ -1095,27 +1125,31 @@ static void MaybePushAddress(Object & entry, const CTxDestination &dest)\n         entry.push_back(Pair(\"address\", addr.ToString()));\n }\n \n-void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDepth, bool fLong, Array& ret)\n+void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDepth, bool fLong, Array& ret, const isminefilter& filter)\n {\n     int64_t nFee;\n     string strSentAccount;\n-    list<pair<CTxDestination, int64_t> > listReceived;\n-    list<pair<CTxDestination, int64_t> > listSent;\n+    list<COutputEntry> listReceived;\n+    list<COutputEntry> listSent;\n \n-    wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount);\n+    wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount, filter);\n \n     bool fAllAccounts = (strAccount == string(\"*\"));\n+    bool involvesWatchonly = wtx.IsFromMe(ISMINE_WATCH_ONLY);\n \n     // Sent\n     if ((!listSent.empty() || nFee != 0) && (fAllAccounts || strAccount == strSentAccount))\n     {\n-        BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64_t)& s, listSent)\n+        BOOST_FOREACH(const COutputEntry& s, listSent)\n         {\n             Object entry;\n+            if(involvesWatchonly || (::IsMine(*pwalletMain, s.destination) & ISMINE_WATCH_ONLY))\n+                entry.push_back(Pair(\"involvesWatchonly\", true));\n             entry.push_back(Pair(\"account\", strSentAccount));\n-            MaybePushAddress(entry, s.first);\n+            MaybePushAddress(entry, s.destination);\n             entry.push_back(Pair(\"category\", \"send\"));\n-            entry.push_back(Pair(\"amount\", ValueFromAmount(-s.second)));\n+            entry.push_back(Pair(\"amount\", ValueFromAmount(-s.amount)));\n+            entry.push_back(Pair(\"vout\", s.vout));\n             entry.push_back(Pair(\"fee\", ValueFromAmount(-nFee)));\n             if (fLong)\n                 WalletTxToJSON(wtx, entry);\n@@ -1126,16 +1160,18 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n     // Received\n     if (listReceived.size() > 0 && wtx.GetDepthInMainChain() >= nMinDepth)\n     {\n-        BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64_t)& r, listReceived)\n+        BOOST_FOREACH(const COutputEntry& r, listReceived)\n         {\n             string account;\n-            if (pwalletMain->mapAddressBook.count(r.first))\n-                account = pwalletMain->mapAddressBook[r.first].name;\n+            if (pwalletMain->mapAddressBook.count(r.destination))\n+                account = pwalletMain->mapAddressBook[r.destination].name;\n             if (fAllAccounts || (account == strAccount))\n             {\n                 Object entry;\n+                if(involvesWatchonly || (::IsMine(*pwalletMain, r.destination) & ISMINE_WATCH_ONLY))\n+                    entry.push_back(Pair(\"involvesWatchonly\", true));\n                 entry.push_back(Pair(\"account\", account));\n-                MaybePushAddress(entry, r.first);\n+                MaybePushAddress(entry, r.destination);\n                 if (wtx.IsCoinBase())\n                 {\n                     if (wtx.GetDepthInMainChain() < 1)\n@@ -1149,7 +1185,8 @@ void ListTransactions(const CWalletTx& wtx, const string& strAccount, int nMinDe\n                 {\n                     entry.push_back(Pair(\"category\", \"receive\"));\n                 }\n-                entry.push_back(Pair(\"amount\", ValueFromAmount(r.second)));\n+                entry.push_back(Pair(\"amount\", ValueFromAmount(r.amount)));\n+                entry.push_back(Pair(\"vout\", r.vout));\n                 if (fLong)\n                     WalletTxToJSON(wtx, entry);\n                 ret.push_back(entry);\n@@ -1177,16 +1214,16 @@ void AcentryToJSON(const CAccountingEntry& acentry, const string& strAccount, Ar\n \n Value listtransactions(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() > 3)\n+    if (fHelp || params.size() > 4)\n         throw runtime_error(\n-            \"listtransactions ( \\\"account\\\" count from )\\n\"\n+            \"listtransactions ( \\\"account\\\" count from includeWatchonly)\\n\"\n             \"\\nReturns up to 'count' most recent transactions skipping the first 'from' transactions for account 'account'.\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"account\\\"    (string, optional) The account name. If not included, it will list all transactions for all accounts.\\n\"\n             \"                                     If \\\"\\\" is set, it will list transactions for the default account.\\n\"\n             \"2. count          (numeric, optional, default=10) The number of transactions to return\\n\"\n             \"3. from           (numeric, optional, default=0) The number of transactions to skip\\n\"\n-\n+            \"4. includeWatchonly (bool, optional, default=false) Include transactions to watchonly addresses (see 'importaddress')\\n\"\n             \"\\nResult:\\n\"\n             \"[\\n\"\n             \"  {\\n\"\n@@ -1201,6 +1238,7 @@ Value listtransactions(const Array& params, bool fHelp)\n             \"    \\\"amount\\\": x.xxx,          (numeric) The amount in btc. This is negative for the 'send' category, and for the\\n\"\n             \"                                         'move' category for moves outbound. It is positive for the 'receive' category,\\n\"\n             \"                                         and for the 'move' category for inbound funds.\\n\"\n+            \"    \\\"vout\\\" : n,               (numeric) the vout value\\n\"\n             \"    \\\"fee\\\": x.xxx,             (numeric) The amount of the fee in btc. This is negative and only available for the \\n\"\n             \"                                         'send' category of transactions.\\n\"\n             \"    \\\"confirmations\\\": n,       (numeric) The number of confirmations for the transaction. Available for 'send' and \\n\"\n@@ -1240,6 +1278,10 @@ Value listtransactions(const Array& params, bool fHelp)\n     int nFrom = 0;\n     if (params.size() > 2)\n         nFrom = params[2].get_int();\n+    isminefilter filter = ISMINE_SPENDABLE;\n+    if(params.size() > 3)\n+        if(params[3].get_bool())\n+            filter = filter | ISMINE_WATCH_ONLY;\n \n     if (nCount < 0)\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Negative count\");\n@@ -1256,7 +1298,7 @@ Value listtransactions(const Array& params, bool fHelp)\n     {\n         CWalletTx *const pwtx = (*it).second.first;\n         if (pwtx != 0)\n-            ListTransactions(*pwtx, strAccount, 0, true, ret);\n+            ListTransactions(*pwtx, strAccount, 0, true, ret, filter);\n         CAccountingEntry *const pacentry = (*it).second.second;\n         if (pacentry != 0)\n             AcentryToJSON(*pacentry, strAccount, ret);\n@@ -1284,12 +1326,13 @@ Value listtransactions(const Array& params, bool fHelp)\n \n Value listaccounts(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() > 1)\n+    if (fHelp || params.size() > 2)\n         throw runtime_error(\n-            \"listaccounts ( minconf )\\n\"\n+            \"listaccounts ( minconf includeWatchonly)\\n\"\n             \"\\nReturns Object that has account names as keys, account balances as values.\\n\"\n             \"\\nArguments:\\n\"\n-            \"1. minconf     (numeric, optional, default=1) Only onclude transactions with at least this many confirmations\\n\"\n+            \"1. minconf          (numeric, optional, default=1) Only onclude transactions with at least this many confirmations\\n\"\n+            \"2. includeWatchonly (bool, optional, default=false) Include balances in watchonly addresses (see 'importaddress')\\n\"\n             \"\\nResult:\\n\"\n             \"{                      (json object where keys are account names, and values are numeric balances\\n\"\n             \"  \\\"account\\\": x.xxx,  (numeric) The property name is the account name, and the value is the total balance for the account.\\n\"\n@@ -1309,10 +1352,14 @@ Value listaccounts(const Array& params, bool fHelp)\n     int nMinDepth = 1;\n     if (params.size() > 0)\n         nMinDepth = params[0].get_int();\n+    isminefilter includeWatchonly = ISMINE_SPENDABLE;\n+    if(params.size() > 1)\n+        if(params[1].get_bool())\n+            includeWatchonly = includeWatchonly | ISMINE_WATCH_ONLY;\n \n     map<string, int64_t> mapAccountBalances;\n     BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& entry, pwalletMain->mapAddressBook) {\n-        if (IsMine(*pwalletMain, entry.first)) // This address belongs to me\n+        if (IsMine(*pwalletMain, entry.first) & includeWatchonly) // This address belongs to me\n             mapAccountBalances[entry.second.name] = 0;\n     }\n \n@@ -1321,22 +1368,22 @@ Value listaccounts(const Array& params, bool fHelp)\n         const CWalletTx& wtx = (*it).second;\n         int64_t nFee;\n         string strSentAccount;\n-        list<pair<CTxDestination, int64_t> > listReceived;\n-        list<pair<CTxDestination, int64_t> > listSent;\n+        list<COutputEntry> listReceived;\n+        list<COutputEntry> listSent;\n         int nDepth = wtx.GetDepthInMainChain();\n         if (wtx.GetBlocksToMaturity() > 0 || nDepth < 0)\n             continue;\n-        wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount);\n+        wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount, includeWatchonly);\n         mapAccountBalances[strSentAccount] -= nFee;\n-        BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64_t)& s, listSent)\n-            mapAccountBalances[strSentAccount] -= s.second;\n+        BOOST_FOREACH(const COutputEntry& s, listSent)\n+            mapAccountBalances[strSentAccount] -= s.amount;\n         if (nDepth >= nMinDepth)\n         {\n-            BOOST_FOREACH(const PAIRTYPE(CTxDestination, int64_t)& r, listReceived)\n-                if (pwalletMain->mapAddressBook.count(r.first))\n-                    mapAccountBalances[pwalletMain->mapAddressBook[r.first].name] += r.second;\n+            BOOST_FOREACH(const COutputEntry& r, listReceived)\n+                if (pwalletMain->mapAddressBook.count(r.destination))\n+                    mapAccountBalances[pwalletMain->mapAddressBook[r.destination].name] += r.amount;\n                 else\n-                    mapAccountBalances[\"\"] += r.second;\n+                    mapAccountBalances[\"\"] += r.amount;\n         }\n     }\n \n@@ -1356,11 +1403,12 @@ Value listsinceblock(const Array& params, bool fHelp)\n {\n     if (fHelp)\n         throw runtime_error(\n-            \"listsinceblock ( \\\"blockhash\\\" target-confirmations )\\n\"\n+            \"listsinceblock ( \\\"blockhash\\\" target-confirmations includeWatchonly)\\n\"\n             \"\\nGet all transactions in blocks since block [blockhash], or all transactions if omitted\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"blockhash\\\"   (string, optional) The block hash to list transactions since\\n\"\n             \"2. target-confirmations:    (numeric, optional) The confirmations required, must be 1 or more\\n\"\n+            \"3. includeWatchonly:        (bool, optional, default=false) Include transactions to watchonly addresses (see 'importaddress')\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"transactions\\\": [\\n\"\n@@ -1369,6 +1417,7 @@ Value listsinceblock(const Array& params, bool fHelp)\n             \"    \\\"category\\\":\\\"send|receive\\\",     (string) The transaction category. 'send' has negative amounts, 'receive' has positive amounts.\\n\"\n             \"    \\\"amount\\\": x.xxx,          (numeric) The amount in btc. This is negative for the 'send' category, and for the 'move' category for moves \\n\"\n             \"                                          outbound. It is positive for the 'receive' category, and for the 'move' category for inbound funds.\\n\"\n+            \"    \\\"vout\\\" : n,               (numeric) the vout value\\n\"\n             \"    \\\"fee\\\": x.xxx,             (numeric) The amount of the fee in btc. This is negative and only available for the 'send' category of transactions.\\n\"\n             \"    \\\"confirmations\\\": n,       (numeric) The number of confirmations for the transaction. Available for 'send' and 'receive' category of transactions.\\n\"\n             \"    \\\"blockhash\\\": \\\"hashvalue\\\",     (string) The block hash containing the transaction. Available for 'send' and 'receive' category of transactions.\\n\"\n@@ -1390,6 +1439,7 @@ Value listsinceblock(const Array& params, bool fHelp)\n \n     CBlockIndex *pindex = NULL;\n     int target_confirms = 1;\n+    isminefilter filter = ISMINE_SPENDABLE;\n \n     if (params.size() > 0)\n     {\n@@ -1409,6 +1459,10 @@ Value listsinceblock(const Array& params, bool fHelp)\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter\");\n     }\n \n+    if(params.size() > 2)\n+        if(params[2].get_bool())\n+            filter = filter | ISMINE_WATCH_ONLY;\n+\n     int depth = pindex ? (1 + chainActive.Height() - pindex->nHeight) : -1;\n \n     Array transactions;\n@@ -1418,7 +1472,7 @@ Value listsinceblock(const Array& params, bool fHelp)\n         CWalletTx tx = (*it).second;\n \n         if (depth == -1 || tx.GetDepthInMainChain() < depth)\n-            ListTransactions(tx, \"*\", 0, true, transactions);\n+            ListTransactions(tx, \"*\", 0, true, transactions, filter);\n     }\n \n     CBlockIndex *pblockLast = chainActive[chainActive.Height() + 1 - target_confirms];\n@@ -1433,12 +1487,13 @@ Value listsinceblock(const Array& params, bool fHelp)\n \n Value gettransaction(const Array& params, bool fHelp)\n {\n-    if (fHelp || params.size() != 1)\n+    if (fHelp || params.size() < 1 || params.size() > 2)\n         throw runtime_error(\n             \"gettransaction \\\"txid\\\"\\n\"\n             \"\\nGet detailed information about in-wallet transaction <txid>\\n\"\n             \"\\nArguments:\\n\"\n             \"1. \\\"txid\\\"    (string, required) The transaction id\\n\"\n+            \"2. \\\"includeWatchonly\\\"    (bool, optional, default=false) Whether to include watchonly addresses in balance calculation and details[]\\n\"\n             \"\\nResult:\\n\"\n             \"{\\n\"\n             \"  \\\"amount\\\" : x.xxx,        (numeric) The transaction amount in btc\\n\"\n@@ -1455,6 +1510,7 @@ Value gettransaction(const Array& params, bool fHelp)\n             \"      \\\"address\\\" : \\\"bitcoinaddress\\\",   (string) The bitcoin address involved in the transaction\\n\"\n             \"      \\\"category\\\" : \\\"send|receive\\\",    (string) The category, either 'send' or 'receive'\\n\"\n             \"      \\\"amount\\\" : x.xxx                  (numeric) The amount in btc\\n\"\n+            \"      \\\"vout\\\" : n,                       (numeric) the vout value\\n\"\n             \"    }\\n\"\n             \"    ,...\\n\"\n             \"  ],\\n\"\n@@ -1469,24 +1525,29 @@ Value gettransaction(const Array& params, bool fHelp)\n     uint256 hash;\n     hash.SetHex(params[0].get_str());\n \n+    isminefilter filter = ISMINE_SPENDABLE;\n+    if(params.size() > 1)\n+        if(params[1].get_bool())\n+            filter = filter | ISMINE_WATCH_ONLY;\n+\n     Object entry;\n     if (!pwalletMain->mapWallet.count(hash))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid or non-wallet transaction id\");\n     const CWalletTx& wtx = pwalletMain->mapWallet[hash];\n \n-    int64_t nCredit = wtx.GetCredit();\n-    int64_t nDebit = wtx.GetDebit();\n+    int64_t nCredit = wtx.GetCredit(filter);\n+    int64_t nDebit = wtx.GetDebit(filter);\n     int64_t nNet = nCredit - nDebit;\n-    int64_t nFee = (wtx.IsFromMe() ? wtx.GetValueOut() - nDebit : 0);\n+    int64_t nFee = (wtx.IsFromMe(filter) ? wtx.GetValueOut() - nDebit : 0);\n \n     entry.push_back(Pair(\"amount\", ValueFromAmount(nNet - nFee)));\n-    if (wtx.IsFromMe())\n+    if (wtx.IsFromMe(filter))\n         entry.push_back(Pair(\"fee\", ValueFromAmount(nFee)));\n \n     WalletTxToJSON(wtx, entry);\n \n     Array details;\n-    ListTransactions(wtx, \"*\", 0, false, details);\n+    ListTransactions(wtx, \"*\", 0, false, details, filter);\n     entry.push_back(Pair(\"details\", details));\n \n     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);"
      },
      {
        "sha": "39ae001db8daa6e1e882ab20f25de7601632b73b",
        "filename": "src/script.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 31,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/script.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/script.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -5,10 +5,14 @@\n \n #include \"script.h\"\n \n+#include \"crypto/ripemd160.h\"\n+#include \"crypto/sha1.h\"\n+#include \"crypto/sha2.h\"\n #include \"core.h\"\n #include \"hash.h\"\n #include \"key.h\"\n #include \"keystore.h\"\n+#include \"random.h\"\n #include \"sync.h\"\n #include \"uint256.h\"\n #include \"util.h\"\n@@ -801,21 +805,15 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n                     valtype& vch = stacktop(-1);\n                     valtype vchHash((opcode == OP_RIPEMD160 || opcode == OP_SHA1 || opcode == OP_HASH160) ? 20 : 32);\n                     if (opcode == OP_RIPEMD160)\n-                        RIPEMD160(&vch[0], vch.size(), &vchHash[0]);\n+                        CRIPEMD160().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n                     else if (opcode == OP_SHA1)\n-                        SHA1(&vch[0], vch.size(), &vchHash[0]);\n+                        CSHA1().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n                     else if (opcode == OP_SHA256)\n-                        SHA256(&vch[0], vch.size(), &vchHash[0]);\n+                        CSHA256().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n                     else if (opcode == OP_HASH160)\n-                    {\n-                        uint160 hash160 = Hash160(vch);\n-                        memcpy(&vchHash[0], &hash160, sizeof(hash160));\n-                    }\n+                        CHash160().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n                     else if (opcode == OP_HASH256)\n-                    {\n-                        uint256 hash = Hash(vch.begin(), vch.end());\n-                        memcpy(&vchHash[0], &hash, sizeof(hash));\n-                    }\n+                        CHash256().Write(&vch[0], vch.size()).Finalize(&vchHash[0]);\n                     popstack(stack);\n                     stack.push_back(vchHash);\n                 }\n@@ -977,6 +975,7 @@ bool EvalScript(vector<vector<unsigned char> >& stack, const CScript& script, co\n \n \n namespace {\n+\n /** Wrapper that serializes like CTransaction, but with the modifications\n  *  required for the signature hash done in-place\n  */\n@@ -1069,7 +1068,8 @@ class CTransactionSignatureSerializer {\n         ::Serialize(s, txTo.nLockTime, nType, nVersion);\n     }\n };\n-}\n+\n+} // anon namespace\n \n uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsigned int nIn, int nHashType)\n {\n@@ -1095,11 +1095,9 @@ uint256 SignatureHash(const CScript &scriptCode, const CTransaction& txTo, unsig\n     return ss.GetHash();\n }\n \n-\n // Valid signature cache, to avoid doing expensive ECDSA signature checking\n // twice for every transaction (once when accepted into memory pool, and\n // again when accepted into the block chain)\n-\n class CSignatureCache\n {\n private:\n@@ -1211,7 +1209,8 @@ bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, vector<vector<unsi\n         mTemplates.insert(make_pair(TX_MULTISIG, CScript() << OP_SMALLINTEGER << OP_PUBKEYS << OP_SMALLINTEGER << OP_CHECKMULTISIG));\n \n         // Empty, provably prunable, data-carrying output\n-        mTemplates.insert(make_pair(TX_NULL_DATA, CScript() << OP_RETURN << OP_SMALLDATA));\n+        if (GetBoolArg(\"-datacarrier\", true))\n+            mTemplates.insert(make_pair(TX_NULL_DATA, CScript() << OP_RETURN << OP_SMALLDATA));\n         mTemplates.insert(make_pair(TX_NULL_DATA, CScript() << OP_RETURN));\n     }\n \n@@ -1457,36 +1456,49 @@ class CKeyStoreIsMineVisitor : public boost::static_visitor<bool>\n     bool operator()(const CScriptID &scriptID) const { return keystore->HaveCScript(scriptID); }\n };\n \n-bool IsMine(const CKeyStore &keystore, const CTxDestination &dest)\n+isminetype IsMine(const CKeyStore &keystore, const CTxDestination& dest)\n {\n-    return boost::apply_visitor(CKeyStoreIsMineVisitor(&keystore), dest);\n+    CScript script;\n+    script.SetDestination(dest);\n+    return IsMine(keystore, script);\n }\n \n-bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n+isminetype IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n {\n     vector<valtype> vSolutions;\n     txnouttype whichType;\n-    if (!Solver(scriptPubKey, whichType, vSolutions))\n-        return false;\n+    if (!Solver(scriptPubKey, whichType, vSolutions)) {\n+        if (keystore.HaveWatchOnly(scriptPubKey))\n+            return ISMINE_WATCH_ONLY;\n+        return ISMINE_NO;\n+    }\n \n     CKeyID keyID;\n     switch (whichType)\n     {\n     case TX_NONSTANDARD:\n     case TX_NULL_DATA:\n-        return false;\n+        break;\n     case TX_PUBKEY:\n         keyID = CPubKey(vSolutions[0]).GetID();\n-        return keystore.HaveKey(keyID);\n+        if (keystore.HaveKey(keyID))\n+            return ISMINE_SPENDABLE;\n+        break;\n     case TX_PUBKEYHASH:\n         keyID = CKeyID(uint160(vSolutions[0]));\n-        return keystore.HaveKey(keyID);\n+        if (keystore.HaveKey(keyID))\n+            return ISMINE_SPENDABLE;\n+        break;\n     case TX_SCRIPTHASH:\n     {\n+        CScriptID scriptID = CScriptID(uint160(vSolutions[0]));\n         CScript subscript;\n-        if (!keystore.GetCScript(CScriptID(uint160(vSolutions[0])), subscript))\n-            return false;\n-        return IsMine(keystore, subscript);\n+        if (keystore.GetCScript(scriptID, subscript)) {\n+            isminetype ret = IsMine(keystore, subscript);\n+            if (ret == ISMINE_SPENDABLE)\n+                return ret;\n+        }\n+        break;\n     }\n     case TX_MULTISIG:\n     {\n@@ -1496,10 +1508,15 @@ bool IsMine(const CKeyStore &keystore, const CScript& scriptPubKey)\n         // them) enable spend-out-from-under-you attacks, especially\n         // in shared-wallet situations.\n         vector<valtype> keys(vSolutions.begin()+1, vSolutions.begin()+vSolutions.size()-1);\n-        return HaveKeys(keys, keystore) == keys.size();\n+        if (HaveKeys(keys, keystore) == keys.size())\n+            return ISMINE_SPENDABLE;\n+        break;\n     }\n     }\n-    return false;\n+\n+    if (keystore.HaveWatchOnly(scriptPubKey))\n+        return ISMINE_WATCH_ONLY;\n+    return ISMINE_NO;\n }\n \n bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet)\n@@ -1639,7 +1656,7 @@ bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const C\n }\n \n \n-bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CTransaction& txTo, unsigned int nIn, int nHashType)\n+bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n     CTxIn& txin = txTo.vin[nIn];\n@@ -1674,7 +1691,7 @@ bool SignSignature(const CKeyStore &keystore, const CScript& fromPubKey, CTransa\n     return VerifyScript(txin.scriptSig, fromPubKey, txTo, nIn, STANDARD_SCRIPT_VERIFY_FLAGS, 0);\n }\n \n-bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType)\n+bool SignSignature(const CKeyStore &keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType)\n {\n     assert(nIn < txTo.vin.size());\n     CTxIn& txin = txTo.vin[nIn];\n@@ -1692,7 +1709,7 @@ static CScript PushAll(const vector<valtype>& values)\n     return result;\n }\n \n-static CScript CombineMultisig(CScript scriptPubKey, const CTransaction& txTo, unsigned int nIn,\n+static CScript CombineMultisig(CScript scriptPubKey, const CMutableTransaction& txTo, unsigned int nIn,\n                                const vector<valtype>& vSolutions,\n                                vector<valtype>& sigs1, vector<valtype>& sigs2)\n {"
      },
      {
        "sha": "e36be2db9e33957e98a760adc724f2bad3f16757",
        "filename": "src/script.h",
        "status": "modified",
        "additions": 20,
        "deletions": 8,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -20,6 +20,7 @@\n class CCoins;\n class CKeyStore;\n class CTransaction;\n+struct CMutableTransaction;\n \n static const unsigned int MAX_SCRIPT_ELEMENT_SIZE = 520; // bytes\n static const unsigned int MAX_OP_RETURN_RELAY = 40;      // bytes\n@@ -193,6 +194,17 @@ enum\n     SCRIPT_VERIFY_NULLDUMMY = (1U << 4), // verify dummy stack item consumed by CHECKMULTISIG is of zero-length\n };\n \n+/** IsMine() return codes */\n+enum isminetype\n+{\n+    ISMINE_NO = 0,\n+    ISMINE_WATCH_ONLY = 1,\n+    ISMINE_SPENDABLE = 2,\n+    ISMINE_ALL = ISMINE_WATCH_ONLY | ISMINE_SPENDABLE\n+};\n+/** used for bitflags of isminetype */\n+typedef uint8_t isminefilter;\n+\n // Mandatory script verification flags that all new blocks must comply with for\n // them to be valid. (but old blocks may not comply with) Currently just P2SH,\n // but in the future other flags may be added, such as a soft-fork to enforce\n@@ -769,12 +781,12 @@ class CScriptCompressor\n     void Serialize(Stream &s, int nType, int nVersion) const {\n         std::vector<unsigned char> compr;\n         if (Compress(compr)) {\n-            s << CFlatData(&compr[0], &compr[compr.size()]);\n+            s << CFlatData(compr);\n             return;\n         }\n         unsigned int nSize = script.size() + nSpecialScripts;\n         s << VARINT(nSize);\n-        s << CFlatData(&script[0], &script[script.size()]);\n+        s << CFlatData(script);\n     }\n \n     template<typename Stream>\n@@ -783,13 +795,13 @@ class CScriptCompressor\n         s >> VARINT(nSize);\n         if (nSize < nSpecialScripts) {\n             std::vector<unsigned char> vch(GetSpecialSize(nSize), 0x00);\n-            s >> REF(CFlatData(&vch[0], &vch[vch.size()]));\n+            s >> REF(CFlatData(vch));\n             Decompress(nSize, vch);\n             return;\n         }\n         nSize -= nSpecialScripts;\n         script.resize(nSize);\n-        s >> REF(CFlatData(&script[0], &script[script.size()]));\n+        s >> REF(CFlatData(script));\n     }\n };\n \n@@ -800,13 +812,13 @@ bool EvalScript(std::vector<std::vector<unsigned char> >& stack, const CScript&\n bool Solver(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<std::vector<unsigned char> >& vSolutionsRet);\n int ScriptSigArgsExpected(txnouttype t, const std::vector<std::vector<unsigned char> >& vSolutions);\n bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType);\n-bool IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n-bool IsMine(const CKeyStore& keystore, const CTxDestination &dest);\n+isminetype IsMine(const CKeyStore& keystore, const CScript& scriptPubKey);\n+isminetype IsMine(const CKeyStore& keystore, const CTxDestination& dest);\n void ExtractAffectedKeys(const CKeyStore &keystore, const CScript& scriptPubKey, std::vector<CKeyID> &vKeys);\n bool ExtractDestination(const CScript& scriptPubKey, CTxDestination& addressRet);\n bool ExtractDestinations(const CScript& scriptPubKey, txnouttype& typeRet, std::vector<CTxDestination>& addressRet, int& nRequiredRet);\n-bool SignSignature(const CKeyStore& keystore, const CScript& fromPubKey, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n-bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n+bool SignSignature(const CKeyStore& keystore, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n+bool SignSignature(const CKeyStore& keystore, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType=SIGHASH_ALL);\n bool VerifyScript(const CScript& scriptSig, const CScript& scriptPubKey, const CTransaction& txTo, unsigned int nIn, unsigned int flags, int nHashType);\n \n // Given two sets of signatures for scriptPubKey, possibly with OP_0 placeholders,"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "src/secp256k1/.empty",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/secp256k1/.empty",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/secp256k1/.empty",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.empty?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5"
      },
      {
        "sha": "f876efd9b5a417ff5b28940a30e0d1a86c8f4a89",
        "filename": "src/serialize.h",
        "status": "modified",
        "additions": 63,
        "deletions": 0,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/serialize.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/serialize.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/serialize.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -37,6 +37,34 @@ inline T& REF(const T& val)\n     return const_cast<T&>(val);\n }\n \n+/** Get begin pointer of vector (non-const version).\n+ * @note These functions avoid the undefined case of indexing into an empty\n+ * vector, as well as that of indexing after the end of the vector.\n+ */\n+template <class T, class TAl>\n+inline T* begin_ptr(std::vector<T,TAl>& v)\n+{\n+    return v.empty() ? NULL : &v[0];\n+}\n+/** Get begin pointer of vector (const version) */\n+template <class T, class TAl>\n+inline const T* begin_ptr(const std::vector<T,TAl>& v)\n+{\n+    return v.empty() ? NULL : &v[0];\n+}\n+/** Get end pointer of vector (non-const version) */\n+template <class T, class TAl>\n+inline T* end_ptr(std::vector<T,TAl>& v)\n+{\n+    return v.empty() ? NULL : (&v[0] + v.size());\n+}\n+/** Get end pointer of vector (const version) */\n+template <class T, class TAl>\n+inline const T* end_ptr(const std::vector<T,TAl>& v)\n+{\n+    return v.empty() ? NULL : (&v[0] + v.size());\n+}\n+\n /////////////////////////////////////////////////////////////////\n //\n // Templates for serializing to anything that looks like a stream,\n@@ -318,6 +346,12 @@ class CFlatData\n     char* pend;\n public:\n     CFlatData(void* pbeginIn, void* pendIn) : pbegin((char*)pbeginIn), pend((char*)pendIn) { }\n+    template <class T, class TAl>\n+    explicit CFlatData(std::vector<T,TAl> &v)\n+    {\n+        pbegin = (char*)begin_ptr(v);\n+        pend = (char*)end_ptr(v);\n+    }\n     char* begin() { return pbegin; }\n     const char* begin() const { return pbegin; }\n     char* end() { return pend; }\n@@ -796,6 +830,35 @@ struct ser_streamplaceholder\n \n typedef std::vector<char, zero_after_free_allocator<char> > CSerializeData;\n \n+class CSizeComputer\n+{\n+protected:\n+    size_t nSize;\n+\n+public:\n+    int nType;\n+    int nVersion;\n+\n+    CSizeComputer(int nTypeIn, int nVersionIn) : nSize(0), nType(nTypeIn), nVersion(nVersionIn) {}\n+\n+    CSizeComputer& write(const char *psz, int nSize)\n+    {\n+        this->nSize += nSize;\n+        return *this;\n+    }\n+\n+    template<typename T>\n+    CSizeComputer& operator<<(const T& obj)\n+    {\n+        ::Serialize(*this, obj, nType, nVersion);\n+        return (*this);\n+    }\n+\n+    size_t size() const {\n+        return nSize;\n+    }\n+};\n+\n /** Double ended buffer combining vector and stream-like interfaces.\n  *\n  * >> and << read and write unformatted data using the above serialization templates."
      },
      {
        "sha": "cd319e017157ae833d94020069835e01863913a6",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -84,6 +84,9 @@ typedef AnnotatedMixin<boost::recursive_mutex> CCriticalSection;\n /** Wrapped boost mutex: supports waiting but not recursive locking */\n typedef AnnotatedMixin<boost::mutex> CWaitableCriticalSection;\n \n+/** Just a typedef for boost::condition_variable, can be wrapped later if desired */\n+typedef boost::condition_variable CConditionVariable;\n+\n #ifdef DEBUG_LOCKORDER\n void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);\n void LeaveCritical();"
      },
      {
        "sha": "5e17555e7a8fc05e812527ae60882078b29789a0",
        "filename": "src/test/DoS_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 90,
        "changes": 94,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/DoS_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/DoS_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/DoS_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -11,6 +11,7 @@\n #include \"keystore.h\"\n #include \"main.h\"\n #include \"net.h\"\n+#include \"pow.h\"\n #include \"script.h\"\n #include \"serialize.h\"\n \n@@ -167,7 +168,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     // 50 orphan transactions:\n     for (int i = 0; i < 50; i++)\n     {\n-        CTransaction tx;\n+        CMutableTransaction tx;\n         tx.vin.resize(1);\n         tx.vin[0].prevout.n = 0;\n         tx.vin[0].prevout.hash = GetRandHash();\n@@ -184,7 +185,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     {\n         CTransaction txPrev = RandomOrphan();\n \n-        CTransaction tx;\n+        CMutableTransaction tx;\n         tx.vin.resize(1);\n         tx.vin[0].prevout.n = 0;\n         tx.vin[0].prevout.hash = txPrev.GetHash();\n@@ -201,7 +202,7 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     {\n         CTransaction txPrev = RandomOrphan();\n \n-        CTransaction tx;\n+        CMutableTransaction tx;\n         tx.vout.resize(1);\n         tx.vout[0].nValue = 1*CENT;\n         tx.vout[0].scriptPubKey.SetDestination(key.GetPubKey().GetID());\n@@ -230,91 +231,4 @@ BOOST_AUTO_TEST_CASE(DoS_mapOrphans)\n     BOOST_CHECK(mapOrphanTransactionsByPrev.empty());\n }\n \n-BOOST_AUTO_TEST_CASE(DoS_checkSig)\n-{\n-    // Test signature caching code (see key.cpp Verify() methods)\n-\n-    CKey key;\n-    key.MakeNewKey(true);\n-    CBasicKeyStore keystore;\n-    keystore.AddKey(key);\n-    unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC;\n-\n-    // 100 orphan transactions:\n-    static const int NPREV=100;\n-    CTransaction orphans[NPREV];\n-    for (int i = 0; i < NPREV; i++)\n-    {\n-        CTransaction& tx = orphans[i];\n-        tx.vin.resize(1);\n-        tx.vin[0].prevout.n = 0;\n-        tx.vin[0].prevout.hash = GetRandHash();\n-        tx.vin[0].scriptSig << OP_1;\n-        tx.vout.resize(1);\n-        tx.vout[0].nValue = 1*CENT;\n-        tx.vout[0].scriptPubKey.SetDestination(key.GetPubKey().GetID());\n-\n-        AddOrphanTx(tx);\n-    }\n-\n-    // Create a transaction that depends on orphans:\n-    CTransaction tx;\n-    tx.vout.resize(1);\n-    tx.vout[0].nValue = 1*CENT;\n-    tx.vout[0].scriptPubKey.SetDestination(key.GetPubKey().GetID());\n-    tx.vin.resize(NPREV);\n-    for (unsigned int j = 0; j < tx.vin.size(); j++)\n-    {\n-        tx.vin[j].prevout.n = 0;\n-        tx.vin[j].prevout.hash = orphans[j].GetHash();\n-    }\n-    // Creating signatures primes the cache:\n-    boost::posix_time::ptime mst1 = boost::posix_time::microsec_clock::local_time();\n-    for (unsigned int j = 0; j < tx.vin.size(); j++)\n-        BOOST_CHECK(SignSignature(keystore, orphans[j], tx, j));\n-    boost::posix_time::ptime mst2 = boost::posix_time::microsec_clock::local_time();\n-    boost::posix_time::time_duration msdiff = mst2 - mst1;\n-    long nOneValidate = msdiff.total_milliseconds();\n-    if (fDebug) printf(\"DoS_Checksig sign: %ld\\n\", nOneValidate);\n-\n-    // ... now validating repeatedly should be quick:\n-    // 2.8GHz machine, -g build: Sign takes ~760ms,\n-    // uncached Verify takes ~250ms, cached Verify takes ~50ms\n-    // (for 100 single-signature inputs)\n-    mst1 = boost::posix_time::microsec_clock::local_time();\n-    for (unsigned int i = 0; i < 5; i++)\n-        for (unsigned int j = 0; j < tx.vin.size(); j++)\n-            BOOST_CHECK(VerifySignature(CCoins(orphans[j], MEMPOOL_HEIGHT), tx, j, flags, SIGHASH_ALL));\n-    mst2 = boost::posix_time::microsec_clock::local_time();\n-    msdiff = mst2 - mst1;\n-    long nManyValidate = msdiff.total_milliseconds();\n-    if (fDebug) printf(\"DoS_Checksig five: %ld\\n\", nManyValidate);\n-\n-    BOOST_CHECK_MESSAGE(nManyValidate < nOneValidate, \"Signature cache timing failed\");\n-\n-    // Empty a signature, validation should fail:\n-    CScript save = tx.vin[0].scriptSig;\n-    tx.vin[0].scriptSig = CScript();\n-    BOOST_CHECK(!VerifySignature(CCoins(orphans[0], MEMPOOL_HEIGHT), tx, 0, flags, SIGHASH_ALL));\n-    tx.vin[0].scriptSig = save;\n-\n-    // Swap signatures, validation should fail:\n-    std::swap(tx.vin[0].scriptSig, tx.vin[1].scriptSig);\n-    BOOST_CHECK(!VerifySignature(CCoins(orphans[0], MEMPOOL_HEIGHT), tx, 0, flags, SIGHASH_ALL));\n-    BOOST_CHECK(!VerifySignature(CCoins(orphans[1], MEMPOOL_HEIGHT), tx, 1, flags, SIGHASH_ALL));\n-    std::swap(tx.vin[0].scriptSig, tx.vin[1].scriptSig);\n-\n-    // Exercise -maxsigcachesize code:\n-    mapArgs[\"-maxsigcachesize\"] = \"10\";\n-    // Generate a new, different signature for vin[0] to trigger cache clear:\n-    CScript oldSig = tx.vin[0].scriptSig;\n-    BOOST_CHECK(SignSignature(keystore, orphans[0], tx, 0));\n-    BOOST_CHECK(tx.vin[0].scriptSig != oldSig);\n-    for (unsigned int j = 0; j < tx.vin.size(); j++)\n-        BOOST_CHECK(VerifySignature(CCoins(orphans[j], MEMPOOL_HEIGHT), tx, j, flags, SIGHASH_ALL));\n-    mapArgs.erase(\"-maxsigcachesize\");\n-\n-    LimitOrphanTxSize(0);\n-}\n-\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "4bee0f6b6e2611936dd5224e6ed71d2fea64ad97",
        "filename": "src/test/accounting_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/accounting_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/accounting_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/accounting_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -83,13 +83,21 @@ BOOST_AUTO_TEST_CASE(acc_orderupgrade)\n \n \n     wtx.mapValue[\"comment\"] = \"y\";\n-    --wtx.nLockTime;  // Just to change the hash :)\n+    {\n+        CMutableTransaction tx(wtx);\n+        --tx.nLockTime;  // Just to change the hash :)\n+        *static_cast<CTransaction*>(&wtx) = CTransaction(tx);\n+    }\n     pwalletMain->AddToWallet(wtx);\n     vpwtx.push_back(&pwalletMain->mapWallet[wtx.GetHash()]);\n     vpwtx[1]->nTimeReceived = (unsigned int)1333333336;\n \n     wtx.mapValue[\"comment\"] = \"x\";\n-    --wtx.nLockTime;  // Just to change the hash :)\n+    {\n+        CMutableTransaction tx(wtx);\n+        --tx.nLockTime;  // Just to change the hash :)\n+        *static_cast<CTransaction*>(&wtx) = CTransaction(tx);\n+    }\n     pwalletMain->AddToWallet(wtx);\n     vpwtx.push_back(&pwalletMain->mapWallet[wtx.GetHash()]);\n     vpwtx[2]->nTimeReceived = (unsigned int)1333333329;"
      },
      {
        "sha": "0ac3e9a36353c26d44fa81e4a2c18142e02bf390",
        "filename": "src/test/base58_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/base58_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/base58_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/base58_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -142,9 +142,9 @@ BOOST_AUTO_TEST_CASE(base58_keys_valid_parse)\n         bool isPrivkey = find_value(metadata, \"isPrivkey\").get_bool();\n         bool isTestnet = find_value(metadata, \"isTestnet\").get_bool();\n         if (isTestnet)\n-            SelectParams(CChainParams::TESTNET);\n+            SelectParams(CBaseChainParams::TESTNET);\n         else\n-            SelectParams(CChainParams::MAIN);\n+            SelectParams(CBaseChainParams::MAIN);\n         if(isPrivkey)\n         {\n             bool isCompressed = find_value(metadata, \"isCompressed\").get_bool();\n@@ -175,7 +175,7 @@ BOOST_AUTO_TEST_CASE(base58_keys_valid_parse)\n             BOOST_CHECK_MESSAGE(!secret.IsValid(), \"IsValid pubkey as privkey:\" + strTest);\n         }\n     }\n-    SelectParams(CChainParams::MAIN);\n+    SelectParams(CBaseChainParams::MAIN);\n }\n \n // Goal: check that generated keys match test vectors\n@@ -198,9 +198,9 @@ BOOST_AUTO_TEST_CASE(base58_keys_valid_gen)\n         bool isPrivkey = find_value(metadata, \"isPrivkey\").get_bool();\n         bool isTestnet = find_value(metadata, \"isTestnet\").get_bool();\n         if (isTestnet)\n-            SelectParams(CChainParams::TESTNET);\n+            SelectParams(CBaseChainParams::TESTNET);\n         else\n-            SelectParams(CChainParams::MAIN);\n+            SelectParams(CBaseChainParams::MAIN);\n         if(isPrivkey)\n         {\n             bool isCompressed = find_value(metadata, \"isCompressed\").get_bool();\n@@ -243,7 +243,7 @@ BOOST_AUTO_TEST_CASE(base58_keys_valid_gen)\n     CTxDestination nodest = CNoDestination();\n     BOOST_CHECK(!dummyAddr.Set(nodest));\n \n-    SelectParams(CChainParams::MAIN);\n+    SelectParams(CBaseChainParams::MAIN);\n }\n \n // Goal: check that base58 parsing code is robust against a variety of corrupted data"
      },
      {
        "sha": "69de3b5bb192d5a44c58ba1312b6c2c4ca58e88d",
        "filename": "src/test/bloom_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 14,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/bloom_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/bloom_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bloom_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -50,7 +50,7 @@ BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize)\n BOOST_AUTO_TEST_CASE(bloom_create_insert_serialize_with_tweak)\n {\n     // Same test as bloom_create_insert_serialize, but we add a nTweak of 100\n-    CBloomFilter filter(3, 0.01, 2147483649, BLOOM_UPDATE_ALL);\n+    CBloomFilter filter(3, 0.01, 2147483649UL, BLOOM_UPDATE_ALL);\n \n     filter.insert(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\"));\n     BOOST_CHECK_MESSAGE( filter.contains(ParseHex(\"99108ad8ed9bb6274d3980bab5a85c048f0950c8\")), \"BloomFilter doesn't contain just-inserted object!\");\n@@ -118,33 +118,33 @@ BOOST_AUTO_TEST_CASE(bloom_match)\n \n     CBloomFilter filter(10, 0.000001, 0, BLOOM_UPDATE_ALL);\n     filter.insert(uint256(\"0xb4749f017444b051c44dfd2720e88f314ff94f3dd6d56d40ef65854fcd7fff6b\"));\n-    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx, tx.GetHash()), \"Simple Bloom filter didn't match tx hash\");\n+    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx), \"Simple Bloom filter didn't match tx hash\");\n \n     filter = CBloomFilter(10, 0.000001, 0, BLOOM_UPDATE_ALL);\n     // byte-reversed tx hash\n     filter.insert(ParseHex(\"6bff7fcd4f8565ef406dd5d63d4ff94f318fe82027fd4dc451b04474019f74b4\"));\n-    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx, tx.GetHash()), \"Simple Bloom filter didn't match manually serialized tx hash\");\n+    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx), \"Simple Bloom filter didn't match manually serialized tx hash\");\n \n     filter = CBloomFilter(10, 0.000001, 0, BLOOM_UPDATE_ALL);\n     filter.insert(ParseHex(\"30450220070aca44506c5cef3a16ed519d7c3c39f8aab192c4e1c90d065f37b8a4af6141022100a8e160b856c2d43d27d8fba71e5aef6405b8643ac4cb7cb3c462aced7f14711a01\"));\n-    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx, tx.GetHash()), \"Simple Bloom filter didn't match input signature\");\n+    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx), \"Simple Bloom filter didn't match input signature\");\n \n     filter = CBloomFilter(10, 0.000001, 0, BLOOM_UPDATE_ALL);\n     filter.insert(ParseHex(\"046d11fee51b0e60666d5049a9101a72741df480b96ee26488a4d3466b95c9a40ac5eeef87e10a5cd336c19a84565f80fa6c547957b7700ff4dfbdefe76036c339\"));\n-    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx, tx.GetHash()), \"Simple Bloom filter didn't match input pub key\");\n+    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx), \"Simple Bloom filter didn't match input pub key\");\n \n     filter = CBloomFilter(10, 0.000001, 0, BLOOM_UPDATE_ALL);\n     filter.insert(ParseHex(\"04943fdd508053c75000106d3bc6e2754dbcff19\"));\n-    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx, tx.GetHash()), \"Simple Bloom filter didn't match output address\");\n-    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(spendingTx, spendingTx.GetHash()), \"Simple Bloom filter didn't add output\");\n+    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx), \"Simple Bloom filter didn't match output address\");\n+    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(spendingTx), \"Simple Bloom filter didn't add output\");\n \n     filter = CBloomFilter(10, 0.000001, 0, BLOOM_UPDATE_ALL);\n     filter.insert(ParseHex(\"a266436d2965547608b9e15d9032a7b9d64fa431\"));\n-    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx, tx.GetHash()), \"Simple Bloom filter didn't match output address\");\n+    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx), \"Simple Bloom filter didn't match output address\");\n \n     filter = CBloomFilter(10, 0.000001, 0, BLOOM_UPDATE_ALL);\n     filter.insert(COutPoint(uint256(\"0x90c122d70786e899529d71dbeba91ba216982fb6ba58f3bdaab65e73b7e9260b\"), 0));\n-    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx, tx.GetHash()), \"Simple Bloom filter didn't match COutPoint\");\n+    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx), \"Simple Bloom filter didn't match COutPoint\");\n \n     filter = CBloomFilter(10, 0.000001, 0, BLOOM_UPDATE_ALL);\n     COutPoint prevOutPoint(uint256(\"0x90c122d70786e899529d71dbeba91ba216982fb6ba58f3bdaab65e73b7e9260b\"), 0);\n@@ -154,23 +154,23 @@ BOOST_AUTO_TEST_CASE(bloom_match)\n         memcpy(&data[32], &prevOutPoint.n, sizeof(unsigned int));\n         filter.insert(data);\n     }\n-    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx, tx.GetHash()), \"Simple Bloom filter didn't match manually serialized COutPoint\");\n+    BOOST_CHECK_MESSAGE(filter.IsRelevantAndUpdate(tx), \"Simple Bloom filter didn't match manually serialized COutPoint\");\n \n     filter = CBloomFilter(10, 0.000001, 0, BLOOM_UPDATE_ALL);\n     filter.insert(uint256(\"00000009e784f32f62ef849763d4f45b98e07ba658647343b915ff832b110436\"));\n-    BOOST_CHECK_MESSAGE(!filter.IsRelevantAndUpdate(tx, tx.GetHash()), \"Simple Bloom filter matched random tx hash\");\n+    BOOST_CHECK_MESSAGE(!filter.IsRelevantAndUpdate(tx), \"Simple Bloom filter matched random tx hash\");\n \n     filter = CBloomFilter(10, 0.000001, 0, BLOOM_UPDATE_ALL);\n     filter.insert(ParseHex(\"0000006d2965547608b9e15d9032a7b9d64fa431\"));\n-    BOOST_CHECK_MESSAGE(!filter.IsRelevantAndUpdate(tx, tx.GetHash()), \"Simple Bloom filter matched random address\");\n+    BOOST_CHECK_MESSAGE(!filter.IsRelevantAndUpdate(tx), \"Simple Bloom filter matched random address\");\n \n     filter = CBloomFilter(10, 0.000001, 0, BLOOM_UPDATE_ALL);\n     filter.insert(COutPoint(uint256(\"0x90c122d70786e899529d71dbeba91ba216982fb6ba58f3bdaab65e73b7e9260b\"), 1));\n-    BOOST_CHECK_MESSAGE(!filter.IsRelevantAndUpdate(tx, tx.GetHash()), \"Simple Bloom filter matched COutPoint for an output we didn't care about\");\n+    BOOST_CHECK_MESSAGE(!filter.IsRelevantAndUpdate(tx), \"Simple Bloom filter matched COutPoint for an output we didn't care about\");\n \n     filter = CBloomFilter(10, 0.000001, 0, BLOOM_UPDATE_ALL);\n     filter.insert(COutPoint(uint256(\"0x000000d70786e899529d71dbeba91ba216982fb6ba58f3bdaab65e73b7e9260b\"), 0));\n-    BOOST_CHECK_MESSAGE(!filter.IsRelevantAndUpdate(tx, tx.GetHash()), \"Simple Bloom filter matched COutPoint for an output we didn't care about\");\n+    BOOST_CHECK_MESSAGE(!filter.IsRelevantAndUpdate(tx), \"Simple Bloom filter matched COutPoint for an output we didn't care about\");\n }\n \n BOOST_AUTO_TEST_CASE(merkle_block_1)"
      },
      {
        "sha": "a9798623ea810d1061843c80fe891ebbdf8a20d3",
        "filename": "src/test/canonical_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/canonical_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/canonical_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/canonical_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -6,12 +6,11 @@\n // Unit tests for canonical signatures\n //\n \n-\n-\n-#include \"script.h\"\n-#include \"util.h\"\n #include \"data/sig_noncanonical.json.h\"\n #include \"data/sig_canonical.json.h\"\n+#include \"random.h\"\n+#include \"script.h\"\n+#include \"util.h\"\n \n #include <boost/foreach.hpp>\n #include <boost/test/unit_test.hpp>\n@@ -21,7 +20,6 @@\n using namespace std;\n using namespace json_spirit;\n \n-\n // In script_tests.cpp\n extern Array read_json(const std::string& jsondata);\n "
      },
      {
        "sha": "a17278b80396f479d3a85f8ecb38b01474737eb1",
        "filename": "src/test/crypto_tests.cpp",
        "status": "added",
        "additions": 204,
        "deletions": 0,
        "changes": 204,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,204 @@\n+// Copyright (c) 2014 The Bitcoin Core developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"crypto/ripemd160.h\"\n+#include \"crypto/sha1.h\"\n+#include \"crypto/sha2.h\"\n+#include \"random.h\"\n+#include \"util.h\"\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_AUTO_TEST_SUITE(crypto_tests)\n+\n+template<typename Hasher, typename In, typename Out>\n+void TestVector(const Hasher &h, const In &in, const Out &out) {\n+    Out hash;\n+    BOOST_CHECK(out.size() == h.OUTPUT_SIZE);\n+    hash.resize(out.size());\n+    {\n+        // Test that writing the whole input string at once works.\n+        Hasher(h).Write((unsigned char*)&in[0], in.size()).Finalize(&hash[0]);\n+        BOOST_CHECK(hash == out);\n+    }\n+    for (int i=0; i<32; i++) {\n+        // Test that writing the string broken up in random pieces works.\n+        Hasher hasher(h);\n+        size_t pos = 0;\n+        while (pos < in.size()) {\n+            size_t len = insecure_rand() % ((in.size() - pos + 1) / 2 + 1);\n+            hasher.Write((unsigned char*)&in[pos], len);\n+            pos += len;\n+            if (pos > 0 && pos + 2 * out.size() > in.size()) {\n+                // Test that writing the rest at once to a copy of a hasher works.\n+                Hasher(hasher).Write((unsigned char*)&in[pos], in.size() - pos).Finalize(&hash[0]);\n+                BOOST_CHECK(hash == out);\n+            }\n+        }\n+        hasher.Finalize(&hash[0]);\n+        BOOST_CHECK(hash == out);\n+    }\n+}\n+\n+void TestSHA1(const std::string &in, const std::string &hexout) { TestVector(CSHA1(), in, ParseHex(hexout));}\n+void TestSHA256(const std::string &in, const std::string &hexout) { TestVector(CSHA256(), in, ParseHex(hexout));}\n+void TestSHA512(const std::string &in, const std::string &hexout) { TestVector(CSHA512(), in, ParseHex(hexout));}\n+void TestRIPEMD160(const std::string &in, const std::string &hexout) { TestVector(CRIPEMD160(), in, ParseHex(hexout));}\n+\n+void TestHMACSHA512(const std::string &hexkey, const std::string &hexin, const std::string &hexout) {\n+    std::vector<unsigned char> key = ParseHex(hexkey);\n+    TestVector(CHMAC_SHA512(&key[0], key.size()), ParseHex(hexin), ParseHex(hexout));\n+}\n+\n+std::string LongTestString(void) {\n+    std::string ret;\n+    for (int i=0; i<200000; i++) {\n+        ret += (unsigned char)(i);\n+        ret += (unsigned char)(i >> 4);\n+        ret += (unsigned char)(i >> 8);\n+        ret += (unsigned char)(i >> 12);\n+        ret += (unsigned char)(i >> 16);\n+    }\n+    return ret;\n+}\n+\n+const std::string test1 = LongTestString();\n+\n+BOOST_AUTO_TEST_CASE(ripemd160_testvectors) {\n+    TestRIPEMD160(\"\", \"9c1185a5c5e9fc54612808977ee8f548b2258d31\");\n+    TestRIPEMD160(\"abc\", \"8eb208f7e05d987a9b044a8e98c6b087f15a0bfc\");\n+    TestRIPEMD160(\"message digest\", \"5d0689ef49d2fae572b881b123a85ffa21595f36\");\n+    TestRIPEMD160(\"secure hash algorithm\", \"20397528223b6a5f4cbc2808aba0464e645544f9\");\n+    TestRIPEMD160(\"RIPEMD160 is considered to be safe\", \"a7d78608c7af8a8e728778e81576870734122b66\");\n+    TestRIPEMD160(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\",\n+                  \"12a053384a9c0c88e405a06c27dcf49ada62eb2b\");\n+    TestRIPEMD160(\"For this sample, this 63-byte string will be used as input data\",\n+                  \"de90dbfee14b63fb5abf27c2ad4a82aaa5f27a11\");\n+    TestRIPEMD160(\"This is exactly 64 bytes long, not counting the terminating byte\",\n+                  \"eda31d51d3a623b81e19eb02e24ff65d27d67b37\");\n+    TestRIPEMD160(std::string(1000000, 'a'), \"52783243c1697bdbe16d37f97f68f08325dc1528\");\n+    TestRIPEMD160(test1, \"464243587bd146ea835cdf57bdae582f25ec45f1\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(sha1_testvectors) {\n+    TestSHA1(\"\", \"da39a3ee5e6b4b0d3255bfef95601890afd80709\");\n+    TestSHA1(\"abc\", \"a9993e364706816aba3e25717850c26c9cd0d89d\");\n+    TestSHA1(\"message digest\", \"c12252ceda8be8994d5fa0290a47231c1d16aae3\");\n+    TestSHA1(\"secure hash algorithm\", \"d4d6d2f0ebe317513bbd8d967d89bac5819c2f60\");\n+    TestSHA1(\"SHA1 is considered to be safe\", \"f2b6650569ad3a8720348dd6ea6c497dee3a842a\");\n+    TestSHA1(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\",\n+             \"84983e441c3bd26ebaae4aa1f95129e5e54670f1\");\n+    TestSHA1(\"For this sample, this 63-byte string will be used as input data\",\n+             \"4f0ea5cd0585a23d028abdc1a6684e5a8094dc49\");\n+    TestSHA1(\"This is exactly 64 bytes long, not counting the terminating byte\",\n+             \"fb679f23e7d1ce053313e66e127ab1b444397057\");\n+    TestSHA1(std::string(1000000, 'a'), \"34aa973cd4c4daa4f61eeb2bdbad27316534016f\");\n+    TestSHA1(test1, \"b7755760681cbfd971451668f32af5774f4656b5\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(sha256_testvectors) {\n+    TestSHA256(\"\", \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\");\n+    TestSHA256(\"abc\", \"ba7816bf8f01cfea414140de5dae2223b00361a396177a9cb410ff61f20015ad\");\n+    TestSHA256(\"message digest\",\n+               \"f7846f55cf23e14eebeab5b4e1550cad5b509e3348fbc4efa3a1413d393cb650\");\n+    TestSHA256(\"secure hash algorithm\",\n+               \"f30ceb2bb2829e79e4ca9753d35a8ecc00262d164cc077080295381cbd643f0d\");\n+    TestSHA256(\"SHA256 is considered to be safe\",\n+               \"6819d915c73f4d1e77e4e1b52d1fa0f9cf9beaead3939f15874bd988e2a23630\");\n+    TestSHA256(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\",\n+               \"248d6a61d20638b8e5c026930c3e6039a33ce45964ff2167f6ecedd419db06c1\");\n+    TestSHA256(\"For this sample, this 63-byte string will be used as input data\",\n+               \"f08a78cbbaee082b052ae0708f32fa1e50c5c421aa772ba5dbb406a2ea6be342\");\n+    TestSHA256(\"This is exactly 64 bytes long, not counting the terminating byte\",\n+               \"ab64eff7e88e2e46165e29f2bce41826bd4c7b3552f6b382a9e7d3af47c245f8\");\n+    TestSHA256(\"As Bitcoin relies on 80 byte header hashes, we want to have an example for that.\",\n+               \"7406e8de7d6e4fffc573daef05aefb8806e7790f55eab5576f31349743cca743\");\n+    TestSHA256(std::string(1000000, 'a'),\n+               \"cdc76e5c9914fb9281a1c7e284d73e67f1809a48a497200e046d39ccc7112cd0\");\n+    TestSHA256(test1, \"a316d55510b49662420f49d145d42fb83f31ef8dc016aa4e32df049991a91e26\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(sha512_testvectors) {\n+    TestSHA512(\"\",\n+               \"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\"\n+               \"47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\");\n+    TestSHA512(\"abc\",\n+               \"ddaf35a193617abacc417349ae20413112e6fa4e89a97ea20a9eeee64b55d39a\"\n+               \"2192992a274fc1a836ba3c23a3feebbd454d4423643ce80e2a9ac94fa54ca49f\");\n+    TestSHA512(\"message digest\",\n+               \"107dbf389d9e9f71a3a95f6c055b9251bc5268c2be16d6c13492ea45b0199f33\"\n+               \"09e16455ab1e96118e8a905d5597b72038ddb372a89826046de66687bb420e7c\");\n+    TestSHA512(\"secure hash algorithm\",\n+               \"7746d91f3de30c68cec0dd693120a7e8b04d8073cb699bdce1a3f64127bca7a3\"\n+               \"d5db502e814bb63c063a7a5043b2df87c61133395f4ad1edca7fcf4b30c3236e\");\n+    TestSHA512(\"SHA512 is considered to be safe\",\n+               \"099e6468d889e1c79092a89ae925a9499b5408e01b66cb5b0a3bd0dfa51a9964\"\n+               \"6b4a3901caab1318189f74cd8cf2e941829012f2449df52067d3dd5b978456c2\");\n+    TestSHA512(\"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\",\n+               \"204a8fc6dda82f0a0ced7beb8e08a41657c16ef468b228a8279be331a703c335\"\n+               \"96fd15c13b1b07f9aa1d3bea57789ca031ad85c7a71dd70354ec631238ca3445\");\n+    TestSHA512(\"For this sample, this 63-byte string will be used as input data\",\n+               \"b3de4afbc516d2478fe9b518d063bda6c8dd65fc38402dd81d1eb7364e72fb6e\"\n+               \"6663cf6d2771c8f5a6da09601712fb3d2a36c6ffea3e28b0818b05b0a8660766\");\n+    TestSHA512(\"This is exactly 64 bytes long, not counting the terminating byte\",\n+               \"70aefeaa0e7ac4f8fe17532d7185a289bee3b428d950c14fa8b713ca09814a38\"\n+               \"7d245870e007a80ad97c369d193e41701aa07f3221d15f0e65a1ff970cedf030\");\n+    TestSHA512(\"abcdefghbcdefghicdefghijdefghijkefghijklfghijklmghijklmnhijklmno\"\n+               \"ijklmnopjklmnopqklmnopqrlmnopqrsmnopqrstnopqrstu\",\n+               \"8e959b75dae313da8cf4f72814fc143f8f7779c6eb9f7fa17299aeadb6889018\"\n+               \"501d289e4900f7e4331b99dec4b5433ac7d329eeb6dd26545e96e55b874be909\");\n+    TestSHA512(std::string(1000000, 'a'),\n+               \"e718483d0ce769644e2e42c7bc15b4638e1f98b13b2044285632a803afa973eb\"\n+               \"de0ff244877ea60a4cb0432ce577c31beb009c5c2c49aa2e4eadb217ad8cc09b\");\n+    TestSHA512(test1,\n+               \"40cac46c147e6131c5193dd5f34e9d8bb4951395f27b08c558c65ff4ba2de594\"\n+               \"37de8c3ef5459d76a52cedc02dc499a3c9ed9dedbfb3281afd9653b8a112fafc\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(hmac_sha512_testvectors) {\n+    // test cases 1, 2, 3, 4, 6 and 7 of RFC 4231\n+    TestHMACSHA512(\"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\",\n+                   \"4869205468657265\",\n+                   \"87aa7cdea5ef619d4ff0b4241a1d6cb02379f4e2ce4ec2787ad0b30545e17cde\"\n+                   \"daa833b7d6b8a702038b274eaea3f4e4be9d914eeb61f1702e696c203a126854\");\n+    TestHMACSHA512(\"4a656665\",\n+                   \"7768617420646f2079612077616e7420666f72206e6f7468696e673f\",\n+                   \"164b7a7bfcf819e2e395fbe73b56e0a387bd64222e831fd610270cd7ea250554\"\n+                   \"9758bf75c05a994a6d034f65f8f0e6fdcaeab1a34d4a6b4b636e070a38bce737\");\n+    TestHMACSHA512(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\",\n+                   \"dddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddddd\"\n+                   \"dddddddddddddddddddddddddddddddddddd\",\n+                   \"fa73b0089d56a284efb0f0756c890be9b1b5dbdd8ee81a3655f83e33b2279d39\"\n+                   \"bf3e848279a722c806b485a47e67c807b946a337bee8942674278859e13292fb\");\n+    TestHMACSHA512(\"0102030405060708090a0b0c0d0e0f10111213141516171819\",\n+                   \"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n+                   \"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\",\n+                   \"b0ba465637458c6990e5a8c5f61d4af7e576d97ff94b872de76f8050361ee3db\"\n+                   \"a91ca5c11aa25eb4d679275cc5788063a5f19741120c4f2de2adebeb10a298dd\");\n+    TestHMACSHA512(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaa\",\n+                   \"54657374205573696e67204c6172676572205468616e20426c6f636b2d53697a\"\n+                   \"65204b6579202d2048617368204b6579204669727374\",\n+                   \"80b24263c7c1a3ebb71493c1dd7be8b49b46d1f41b4aeec1121b013783f8f352\"\n+                   \"6b56d037e05f2598bd0fd2215d6a1e5295e64f73f63f0aec8b915a985d786598\");\n+    TestHMACSHA512(\"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n+                   \"aaaaaa\",\n+                   \"5468697320697320612074657374207573696e672061206c6172676572207468\"\n+                   \"616e20626c6f636b2d73697a65206b657920616e642061206c61726765722074\"\n+                   \"68616e20626c6f636b2d73697a6520646174612e20546865206b6579206e6565\"\n+                   \"647320746f20626520686173686564206265666f7265206265696e6720757365\"\n+                   \"642062792074686520484d414320616c676f726974686d2e\",\n+                   \"e37b6a775dc87dbaa4dfa9f96e5e3ffddebd71f8867289865df5a32d20cdc944\"\n+                   \"b6022cac3c4982b10d5eeb55c3e4de15134676fb6de0446065c97440fa8c6a58\");\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "780ce480cea507913fcfc0303b1780d1fbbfb598",
        "filename": "src/test/hmac_tests.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 129,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ff3047c56406f61af18e69eb16c9404b01b45f8d/src/test/hmac_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ff3047c56406f61af18e69eb16c9404b01b45f8d/src/test/hmac_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/hmac_tests.cpp?ref=ff3047c56406f61af18e69eb16c9404b01b45f8d",
        "patch": "@@ -1,129 +0,0 @@\n-// Copyright (c) 2013 The Bitcoin Core developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include \"hash.h\"\n-#include \"util.h\"\n-\n-#include <boost/test/unit_test.hpp>\n-\n-using namespace std;\n-\n-BOOST_AUTO_TEST_SUITE(hmac_tests)\n-\n-typedef struct {\n-    const char *pszKey;\n-    const char *pszData;\n-    const char *pszMAC;\n-} testvec_t;\n-\n-// test cases 1, 2, 3, 4, 6 and 7 of RFC 4231\n-static const testvec_t vtest[] = {\n-    {\n-        \"0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b0b\"\n-        \"0b0b0b0b\",\n-        \"4869205468657265\",\n-        \"87aa7cdea5ef619d4ff0b4241a1d6cb0\"\n-        \"2379f4e2ce4ec2787ad0b30545e17cde\"\n-        \"daa833b7d6b8a702038b274eaea3f4e4\"\n-        \"be9d914eeb61f1702e696c203a126854\"\n-    },\n-    {\n-        \"4a656665\",\n-        \"7768617420646f2079612077616e7420\"\n-        \"666f72206e6f7468696e673f\",\n-        \"164b7a7bfcf819e2e395fbe73b56e0a3\"\n-        \"87bd64222e831fd610270cd7ea250554\"\n-        \"9758bf75c05a994a6d034f65f8f0e6fd\"\n-        \"caeab1a34d4a6b4b636e070a38bce737\"\n-    },\n-    {\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaaaa\",\n-        \"dddddddddddddddddddddddddddddddd\"\n-        \"dddddddddddddddddddddddddddddddd\"\n-        \"dddddddddddddddddddddddddddddddd\"\n-        \"dddd\",\n-        \"fa73b0089d56a284efb0f0756c890be9\"\n-        \"b1b5dbdd8ee81a3655f83e33b2279d39\"\n-        \"bf3e848279a722c806b485a47e67c807\"\n-        \"b946a337bee8942674278859e13292fb\"\n-    },\n-    {\n-        \"0102030405060708090a0b0c0d0e0f10\"\n-        \"111213141516171819\",\n-        \"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n-        \"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n-        \"cdcdcdcdcdcdcdcdcdcdcdcdcdcdcdcd\"\n-        \"cdcd\",\n-        \"b0ba465637458c6990e5a8c5f61d4af7\"\n-        \"e576d97ff94b872de76f8050361ee3db\"\n-        \"a91ca5c11aa25eb4d679275cc5788063\"\n-        \"a5f19741120c4f2de2adebeb10a298dd\"\n-    },\n-    {\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaa\",\n-        \"54657374205573696e67204c61726765\"\n-        \"72205468616e20426c6f636b2d53697a\"\n-        \"65204b6579202d2048617368204b6579\"\n-        \"204669727374\",\n-        \"80b24263c7c1a3ebb71493c1dd7be8b4\"\n-        \"9b46d1f41b4aeec1121b013783f8f352\"\n-        \"6b56d037e05f2598bd0fd2215d6a1e52\"\n-        \"95e64f73f63f0aec8b915a985d786598\"\n-    },\n-    {\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaaaaaaaaaaaaaaaaaaaaaaaaaaaa\"\n-        \"aaaaaa\",\n-        \"54686973206973206120746573742075\"\n-        \"73696e672061206c6172676572207468\"\n-        \"616e20626c6f636b2d73697a65206b65\"\n-        \"7920616e642061206c61726765722074\"\n-        \"68616e20626c6f636b2d73697a652064\"\n-        \"6174612e20546865206b6579206e6565\"\n-        \"647320746f2062652068617368656420\"\n-        \"6265666f7265206265696e6720757365\"\n-        \"642062792074686520484d414320616c\"\n-        \"676f726974686d2e\",\n-        \"e37b6a775dc87dbaa4dfa9f96e5e3ffd\"\n-        \"debd71f8867289865df5a32d20cdc944\"\n-        \"b6022cac3c4982b10d5eeb55c3e4de15\"\n-        \"134676fb6de0446065c97440fa8c6a58\"\n-    }\n-};\n-\n-BOOST_AUTO_TEST_CASE(hmacsha512_testvectors)\n-{\n-    for (unsigned int n=0; n<sizeof(vtest)/sizeof(vtest[0]); n++)\n-    {\n-        vector<unsigned char> vchKey  = ParseHex(vtest[n].pszKey);\n-        vector<unsigned char> vchData = ParseHex(vtest[n].pszData);\n-        vector<unsigned char> vchMAC  = ParseHex(vtest[n].pszMAC);\n-        unsigned char vchTemp[64];\n-\n-        HMAC_SHA512_CTX ctx;\n-        HMAC_SHA512_Init(&ctx, &vchKey[0], vchKey.size());\n-        HMAC_SHA512_Update(&ctx, &vchData[0], vchData.size());\n-        HMAC_SHA512_Final(&vchTemp[0], &ctx);\n-\n-        BOOST_CHECK(memcmp(&vchTemp[0], &vchMAC[0], 64) == 0);\n-\n-    }\n-}\n-\n-BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "47977cf29540d0998637d960b03969db32665b33",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 33,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -9,8 +9,6 @@\n \n #include <boost/test/unit_test.hpp>\n \n-extern void SHA256Transform(void* pstate, void* pinput, const void* pinit);\n-\n BOOST_AUTO_TEST_SUITE(miner_tests)\n \n static\n@@ -53,7 +51,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n {\n     CScript scriptPubKey = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n     CBlockTemplate *pblocktemplate;\n-    CTransaction tx,tx2;\n+    CMutableTransaction tx,tx2;\n     CScript script;\n     uint256 hash;\n \n@@ -70,10 +68,12 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         CBlock *pblock = &pblocktemplate->block; // pointer for convenience\n         pblock->nVersion = 1;\n         pblock->nTime = chainActive.Tip()->GetMedianTimePast()+1;\n-        pblock->vtx[0].vin[0].scriptSig = CScript();\n-        pblock->vtx[0].vin[0].scriptSig.push_back(blockinfo[i].extranonce);\n-        pblock->vtx[0].vin[0].scriptSig.push_back(chainActive.Height());\n-        pblock->vtx[0].vout[0].scriptPubKey = CScript();\n+        CMutableTransaction txCoinbase(pblock->vtx[0]);\n+        txCoinbase.vin[0].scriptSig = CScript();\n+        txCoinbase.vin[0].scriptSig.push_back(blockinfo[i].extranonce);\n+        txCoinbase.vin[0].scriptSig.push_back(chainActive.Height());\n+        txCoinbase.vout[0].scriptPubKey = CScript();\n+        pblock->vtx[0] = CTransaction(txCoinbase);\n         if (txFirst.size() < 2)\n             txFirst.push_back(new CTransaction(pblock->vtx[0]));\n         pblock->hashMerkleRoot = pblock->BuildMerkleTree();\n@@ -259,30 +259,4 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n \n }\n \n-BOOST_AUTO_TEST_CASE(sha256transform_equality)\n-{\n-    unsigned int pSHA256InitState[8] = {0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19};\n-\n-\n-    // unsigned char pstate[32];\n-    unsigned char pinput[64];\n-\n-    int i;\n-\n-    for (i = 0; i < 32; i++) {\n-        pinput[i] = i;\n-        pinput[i+32] = 0;\n-    }\n-\n-    uint256 hash;\n-\n-    SHA256Transform(&hash, pinput, pSHA256InitState);\n-\n-    BOOST_TEST_MESSAGE(hash.GetHex());\n-\n-    uint256 hash_reference(\"0x2df5e1c65ef9f8cde240d23cae2ec036d31a15ec64bc68f64be242b1da6631f3\");\n-\n-    BOOST_CHECK(hash == hash_reference);\n-}\n-\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "547cd1090c5818feb7bca0b3f121122fadd3c558",
        "filename": "src/test/mruset_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/mruset_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/mruset_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/mruset_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -4,6 +4,7 @@\n \n #include \"mruset.h\"\n \n+#include \"random.h\"\n #include \"util.h\"\n \n #include <set>"
      },
      {
        "sha": "452cf084a74425e503b02a24f996708aa9c75b77",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -55,13 +55,13 @@ BOOST_AUTO_TEST_CASE(multisig_verify)\n     CScript escrow;\n     escrow << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << key[2].GetPubKey() << OP_3 << OP_CHECKMULTISIG;\n \n-    CTransaction txFrom;  // Funding transaction\n+    CMutableTransaction txFrom;  // Funding transaction\n     txFrom.vout.resize(3);\n     txFrom.vout[0].scriptPubKey = a_and_b;\n     txFrom.vout[1].scriptPubKey = a_or_b;\n     txFrom.vout[2].scriptPubKey = escrow;\n \n-    CTransaction txTo[3]; // Spending transaction\n+    CMutableTransaction txTo[3]; // Spending transaction\n     for (int i = 0; i < 3; i++)\n     {\n         txTo[i].vin.resize(1);\n@@ -270,13 +270,13 @@ BOOST_AUTO_TEST_CASE(multisig_Sign)\n     CScript escrow;\n     escrow << OP_2 << key[0].GetPubKey() << key[1].GetPubKey() << key[2].GetPubKey() << OP_3 << OP_CHECKMULTISIG;\n \n-    CTransaction txFrom;  // Funding transaction\n+    CMutableTransaction txFrom;  // Funding transaction\n     txFrom.vout.resize(3);\n     txFrom.vout[0].scriptPubKey = a_and_b;\n     txFrom.vout[1].scriptPubKey = a_or_b;\n     txFrom.vout[2].scriptPubKey = escrow;\n \n-    CTransaction txTo[3]; // Spending transaction\n+    CMutableTransaction txTo[3]; // Spending transaction\n     for (int i = 0; i < 3; i++)\n     {\n         txTo[i].vin.resize(1);"
      },
      {
        "sha": "9dce4daac6c905ddca3b22c5ec829f1d23c092c2",
        "filename": "src/test/pmt_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/pmt_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/pmt_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pmt_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -36,9 +36,9 @@ BOOST_AUTO_TEST_CASE(pmt_test1)\n         // build a block with some dummy transactions\n         CBlock block;\n         for (unsigned int j=0; j<nTx; j++) {\n-            CTransaction tx;\n+            CMutableTransaction tx;\n             tx.nLockTime = rand(); // actual transaction data doesn't matter; just make the nLockTime's unique\n-            block.vtx.push_back(tx);\n+            block.vtx.push_back(CTransaction(tx));\n         }\n \n         // calculate actual merkle root and height"
      },
      {
        "sha": "a1dc17ba36e91c4f0219838cc5a576dde1b88d6f",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 80,
        "deletions": 54,
        "changes": 134,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -30,11 +30,11 @@ static bool\n Verify(const CScript& scriptSig, const CScript& scriptPubKey, bool fStrict)\n {\n     // Create dummy to/from transactions:\n-    CTransaction txFrom;\n+    CMutableTransaction txFrom;\n     txFrom.vout.resize(1);\n     txFrom.vout[0].scriptPubKey = scriptPubKey;\n \n-    CTransaction txTo;\n+    CMutableTransaction txTo;\n     txTo.vin.resize(1);\n     txTo.vout.resize(1);\n     txTo.vin[0].prevout.n = 0;\n@@ -78,7 +78,7 @@ BOOST_AUTO_TEST_CASE(sign)\n         evalScripts[i].SetDestination(standardScripts[i].GetID());\n     }\n \n-    CTransaction txFrom;  // Funding transaction:\n+    CMutableTransaction txFrom;  // Funding transaction:\n     string reason;\n     txFrom.vout.resize(8);\n     for (int i = 0; i < 4; i++)\n@@ -90,7 +90,7 @@ BOOST_AUTO_TEST_CASE(sign)\n     }\n     BOOST_CHECK(IsStandardTx(txFrom, reason));\n \n-    CTransaction txTo[8]; // Spending transactions\n+    CMutableTransaction txTo[8]; // Spending transactions\n     for (int i = 0; i < 8; i++)\n     {\n         txTo[i].vin.resize(1);\n@@ -173,7 +173,7 @@ BOOST_AUTO_TEST_CASE(set)\n         keystore.AddCScript(inner[i]);\n     }\n \n-    CTransaction txFrom;  // Funding transaction:\n+    CMutableTransaction txFrom;  // Funding transaction:\n     string reason;\n     txFrom.vout.resize(4);\n     for (int i = 0; i < 4; i++)\n@@ -183,7 +183,7 @@ BOOST_AUTO_TEST_CASE(set)\n     }\n     BOOST_CHECK(IsStandardTx(txFrom, reason));\n \n-    CTransaction txTo[4]; // Spending transactions\n+    CMutableTransaction txTo[4]; // Spending transactions\n     for (int i = 0; i < 4; i++)\n     {\n         txTo[i].vin.resize(1);\n@@ -256,66 +256,86 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     CCoinsView coinsDummy;\n     CCoinsViewCache coins(coinsDummy);\n     CBasicKeyStore keystore;\n-    CKey key[3];\n+    CKey key[6];\n     vector<CPubKey> keys;\n-    for (int i = 0; i < 3; i++)\n+    for (int i = 0; i < 6; i++)\n     {\n         key[i].MakeNewKey(true);\n         keystore.AddKey(key[i]);\n-        keys.push_back(key[i].GetPubKey());\n     }\n+    for (int i = 0; i < 3; i++)\n+        keys.push_back(key[i].GetPubKey());\n \n-    CTransaction txFrom;\n-    txFrom.vout.resize(6);\n+    CMutableTransaction txFrom;\n+    txFrom.vout.resize(7);\n \n     // First three are standard:\n     CScript pay1; pay1.SetDestination(key[0].GetPubKey().GetID());\n     keystore.AddCScript(pay1);\n-    CScript payScriptHash1; payScriptHash1.SetDestination(pay1.GetID());\n     CScript pay1of3; pay1of3.SetMultisig(1, keys);\n \n-    txFrom.vout[0].scriptPubKey = payScriptHash1;\n+    txFrom.vout[0].scriptPubKey.SetDestination(pay1.GetID()); // P2SH (OP_CHECKSIG)\n     txFrom.vout[0].nValue = 1000;\n-    txFrom.vout[1].scriptPubKey = pay1;\n+    txFrom.vout[1].scriptPubKey = pay1; // ordinary OP_CHECKSIG\n     txFrom.vout[1].nValue = 2000;\n-    txFrom.vout[2].scriptPubKey = pay1of3;\n+    txFrom.vout[2].scriptPubKey = pay1of3; // ordinary OP_CHECKMULTISIG\n     txFrom.vout[2].nValue = 3000;\n \n-    // Last three non-standard:\n-    CScript empty;\n-    keystore.AddCScript(empty);\n-    txFrom.vout[3].scriptPubKey = empty;\n+    // vout[3] is complicated 1-of-3 AND 2-of-3\n+    // ... that is OK if wrapped in P2SH:\n+    CScript oneAndTwo;\n+    oneAndTwo << OP_1 << key[0].GetPubKey() << key[1].GetPubKey() << key[2].GetPubKey();\n+    oneAndTwo << OP_3 << OP_CHECKMULTISIGVERIFY;\n+    oneAndTwo << OP_2 << key[3].GetPubKey() << key[4].GetPubKey() << key[5].GetPubKey();\n+    oneAndTwo << OP_3 << OP_CHECKMULTISIG;\n+    keystore.AddCScript(oneAndTwo);\n+    txFrom.vout[3].scriptPubKey.SetDestination(oneAndTwo.GetID());\n     txFrom.vout[3].nValue = 4000;\n-    // Can't use SetPayToScriptHash, it checks for the empty Script. So:\n-    txFrom.vout[4].scriptPubKey << OP_HASH160 << Hash160(empty) << OP_EQUAL;\n+\n+    // vout[4] is max sigops:\n+    CScript fifteenSigops; fifteenSigops << OP_1;\n+    for (unsigned i = 0; i < MAX_P2SH_SIGOPS; i++)\n+        fifteenSigops << key[i%3].GetPubKey();\n+    fifteenSigops << OP_15 << OP_CHECKMULTISIG;\n+    keystore.AddCScript(fifteenSigops);\n+    txFrom.vout[4].scriptPubKey.SetDestination(fifteenSigops.GetID());\n     txFrom.vout[4].nValue = 5000;\n-    CScript oneOfEleven;\n-    oneOfEleven << OP_1;\n-    for (int i = 0; i < 11; i++)\n-        oneOfEleven << key[0].GetPubKey();\n-    oneOfEleven << OP_11 << OP_CHECKMULTISIG;\n-    txFrom.vout[5].scriptPubKey.SetDestination(oneOfEleven.GetID());\n-    txFrom.vout[5].nValue = 6000;\n+\n+    // vout[5/6] are non-standard because they exceed MAX_P2SH_SIGOPS\n+    CScript sixteenSigops; sixteenSigops << OP_16 << OP_CHECKMULTISIG;\n+    keystore.AddCScript(sixteenSigops);\n+    txFrom.vout[5].scriptPubKey.SetDestination(fifteenSigops.GetID());\n+    txFrom.vout[5].nValue = 5000;\n+    CScript twentySigops; twentySigops << OP_CHECKMULTISIG;\n+    keystore.AddCScript(twentySigops);\n+    txFrom.vout[6].scriptPubKey.SetDestination(twentySigops.GetID());\n+    txFrom.vout[6].nValue = 6000;\n+\n \n     coins.SetCoins(txFrom.GetHash(), CCoins(txFrom, 0));\n \n-    CTransaction txTo;\n+    CMutableTransaction txTo;\n     txTo.vout.resize(1);\n     txTo.vout[0].scriptPubKey.SetDestination(key[1].GetPubKey().GetID());\n \n-    txTo.vin.resize(3);\n-    txTo.vin[0].prevout.n = 0;\n-    txTo.vin[0].prevout.hash = txFrom.GetHash();\n+    txTo.vin.resize(5);\n+    for (int i = 0; i < 5; i++)\n+    {\n+        txTo.vin[i].prevout.n = i;\n+        txTo.vin[i].prevout.hash = txFrom.GetHash();\n+    }\n     BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 0));\n-    txTo.vin[1].prevout.n = 1;\n-    txTo.vin[1].prevout.hash = txFrom.GetHash();\n     BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 1));\n-    txTo.vin[2].prevout.n = 2;\n-    txTo.vin[2].prevout.hash = txFrom.GetHash();\n     BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 2));\n+    // SignSignature doesn't know how to sign these. We're\n+    // not testing validating signatures, so just create\n+    // dummy signatures that DO include the correct P2SH scripts:\n+    txTo.vin[3].scriptSig << OP_11 << OP_11 << static_cast<vector<unsigned char> >(oneAndTwo);\n+    txTo.vin[4].scriptSig << static_cast<vector<unsigned char> >(fifteenSigops);\n \n     BOOST_CHECK(::AreInputsStandard(txTo, coins));\n-    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txTo, coins), 1U);\n+    // 22 P2SH sigops for all inputs (1 for vin[0], 6 for vin[3], 15 for vin[4]\n+    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txTo, coins), 22U);\n \n     // Make sure adding crap to the scriptSigs makes them non-standard:\n     for (int i = 0; i < 3; i++)\n@@ -326,23 +346,29 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n         txTo.vin[i].scriptSig = t;\n     }\n \n-    CTransaction txToNonStd;\n-    txToNonStd.vout.resize(1);\n-    txToNonStd.vout[0].scriptPubKey.SetDestination(key[1].GetPubKey().GetID());\n-    txToNonStd.vout[0].nValue = 1000;\n-    txToNonStd.vin.resize(2);\n-    txToNonStd.vin[0].prevout.n = 4;\n-    txToNonStd.vin[0].prevout.hash = txFrom.GetHash();\n-    txToNonStd.vin[0].scriptSig << Serialize(empty);\n-    txToNonStd.vin[1].prevout.n = 5;\n-    txToNonStd.vin[1].prevout.hash = txFrom.GetHash();\n-    txToNonStd.vin[1].scriptSig << OP_0 << Serialize(oneOfEleven);\n-\n-    BOOST_CHECK(!::AreInputsStandard(txToNonStd, coins));\n-    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd, coins), 11U);\n-\n-    txToNonStd.vin[0].scriptSig.clear();\n-    BOOST_CHECK(!::AreInputsStandard(txToNonStd, coins));\n+    CMutableTransaction txToNonStd1;\n+    txToNonStd1.vout.resize(1);\n+    txToNonStd1.vout[0].scriptPubKey.SetDestination(key[1].GetPubKey().GetID());\n+    txToNonStd1.vout[0].nValue = 1000;\n+    txToNonStd1.vin.resize(1);\n+    txToNonStd1.vin[0].prevout.n = 5;\n+    txToNonStd1.vin[0].prevout.hash = txFrom.GetHash();\n+    txToNonStd1.vin[0].scriptSig << static_cast<vector<unsigned char> >(sixteenSigops);\n+\n+    BOOST_CHECK(!::AreInputsStandard(txToNonStd1, coins));\n+    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd1, coins), 16U);\n+\n+    CMutableTransaction txToNonStd2;\n+    txToNonStd2.vout.resize(1);\n+    txToNonStd2.vout[0].scriptPubKey.SetDestination(key[1].GetPubKey().GetID());\n+    txToNonStd2.vout[0].nValue = 1000;\n+    txToNonStd2.vin.resize(1);\n+    txToNonStd2.vin[0].prevout.n = 6;\n+    txToNonStd2.vin[0].prevout.hash = txFrom.GetHash();\n+    txToNonStd2.vin[0].scriptSig << static_cast<vector<unsigned char> >(twentySigops);\n+\n+    BOOST_CHECK(!::AreInputsStandard(txToNonStd2, coins));\n+    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd2, coins), 20U);\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "cba582e941a73ccc366e21bbf90a3ea07f794269",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -240,11 +240,11 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG12)\n     CScript scriptPubKey12;\n     scriptPubKey12 << OP_1 << key1.GetPubKey() << key2.GetPubKey() << OP_2 << OP_CHECKMULTISIG;\n \n-    CTransaction txFrom12;\n+    CMutableTransaction txFrom12;\n     txFrom12.vout.resize(1);\n     txFrom12.vout[0].scriptPubKey = scriptPubKey12;\n \n-    CTransaction txTo12;\n+    CMutableTransaction txTo12;\n     txTo12.vin.resize(1);\n     txTo12.vout.resize(1);\n     txTo12.vin[0].prevout.n = 0;\n@@ -274,11 +274,11 @@ BOOST_AUTO_TEST_CASE(script_CHECKMULTISIG23)\n     CScript scriptPubKey23;\n     scriptPubKey23 << OP_2 << key1.GetPubKey() << key2.GetPubKey() << key3.GetPubKey() << OP_3 << OP_CHECKMULTISIG;\n \n-    CTransaction txFrom23;\n+    CMutableTransaction txFrom23;\n     txFrom23.vout.resize(1);\n     txFrom23.vout[0].scriptPubKey = scriptPubKey23;\n \n-    CTransaction txTo23;\n+    CMutableTransaction txTo23;\n     txTo23.vin.resize(1);\n     txTo23.vout.resize(1);\n     txTo23.vin[0].prevout.n = 0;\n@@ -345,11 +345,11 @@ BOOST_AUTO_TEST_CASE(script_combineSigs)\n         keystore.AddKey(key);\n     }\n \n-    CTransaction txFrom;\n+    CMutableTransaction txFrom;\n     txFrom.vout.resize(1);\n     txFrom.vout[0].scriptPubKey.SetDestination(keys[0].GetPubKey().GetID());\n     CScript& scriptPubKey = txFrom.vout[0].scriptPubKey;\n-    CTransaction txTo;\n+    CMutableTransaction txTo;\n     txTo.vin.resize(1);\n     txTo.vout.resize(1);\n     txTo.vin[0].prevout.n = 0;"
      },
      {
        "sha": "b99797fccb11197b790155a9b106c2083e7479ce",
        "filename": "src/test/sighash_tests.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 11,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/sighash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/sighash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sighash_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -2,15 +2,16 @@\n // Distributed under the MIT/X11 software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <boost/test/unit_test.hpp>\n-#include <iostream>\n-\n+#include \"data/sighash.json.h\"\n #include \"main.h\"\n-#include \"util.h\"\n+#include \"random.h\"\n #include \"serialize.h\"\n+#include \"util.h\"\n #include \"version.h\"\n-#include \"data/sighash.json.h\"\n \n+#include <iostream>\n+\n+#include <boost/test/unit_test.hpp>\n #include \"json/json_spirit_reader_template.h\"\n #include \"json/json_spirit_utils.h\"\n #include \"json/json_spirit_writer_template.h\"\n@@ -28,7 +29,7 @@ uint256 static SignatureHashOld(CScript scriptCode, const CTransaction& txTo, un\n         printf(\"ERROR: SignatureHash() : nIn=%d out of range\\n\", nIn);\n         return 1;\n     }\n-    CTransaction txTmp(txTo);\n+    CMutableTransaction txTmp(txTo);\n \n     // In case concatenating two scripts ends up with two codeseparators,\n     // or an extra one at the end, this prevents all those possible incompatibilities.\n@@ -90,7 +91,7 @@ void static RandomScript(CScript &script) {\n         script << oplist[insecure_rand() % (sizeof(oplist)/sizeof(oplist[0]))];\n }\n \n-void static RandomTransaction(CTransaction &tx, bool fSingle) {\n+void static RandomTransaction(CMutableTransaction &tx, bool fSingle) {\n     tx.nVersion = insecure_rand();\n     tx.vin.clear();\n     tx.vout.clear();\n@@ -118,7 +119,7 @@ BOOST_AUTO_TEST_SUITE(sighash_tests)\n BOOST_AUTO_TEST_CASE(sighash_test)\n {\n     seed_insecure_rand(false);\n-  \n+\n     #if defined(PRINT_SIGHASH_JSON)\n     std::cout << \"[\\n\";\n     std::cout << \"\\t[\\\"raw_transaction, script, input_index, hashType, signature_hash (result)\\\"],\\n\";\n@@ -130,7 +131,7 @@ BOOST_AUTO_TEST_CASE(sighash_test)\n     #endif\n     for (int i=0; i<nRandomTests; i++) {\n         int nHashType = insecure_rand();\n-        CTransaction txTo;\n+        CMutableTransaction txTo;\n         RandomTransaction(txTo, (nHashType & 0x1f) == SIGHASH_SINGLE);\n         CScript scriptCode;\n         RandomScript(scriptCode);\n@@ -205,10 +206,9 @@ BOOST_AUTO_TEST_CASE(sighash_from_data)\n           BOOST_ERROR(\"Bad test, couldn't deserialize data: \" << strTest);\n           continue;\n         }\n-        \n+\n         sh = SignatureHash(scriptCode, tx, nIn, nHashType);\n         BOOST_CHECK_MESSAGE(sh.GetHex() == sigHashHex, strTest);\n     }\n }\n BOOST_AUTO_TEST_SUITE_END()\n-"
      },
      {
        "sha": "a123f1d197fdb0330ab72ac256f65cc4c269ded5",
        "filename": "src/test/skiplist_tests.cpp",
        "status": "added",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/skiplist_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/skiplist_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/skiplist_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,102 @@\n+// Copyright (c) 2014 The Bitcoin Core developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"main.h\"\n+#include \"random.h\"\n+#include \"util.h\"\n+\n+#include <vector>\n+\n+#include <boost/test/unit_test.hpp>\n+\n+#define SKIPLIST_LENGTH 300000\n+\n+BOOST_AUTO_TEST_SUITE(skiplist_tests)\n+\n+BOOST_AUTO_TEST_CASE(skiplist_test)\n+{\n+    std::vector<CBlockIndex> vIndex(SKIPLIST_LENGTH);\n+\n+    for (int i=0; i<SKIPLIST_LENGTH; i++) {\n+        vIndex[i].nHeight = i;\n+        vIndex[i].pprev = (i == 0) ? NULL : &vIndex[i - 1];\n+        vIndex[i].BuildSkip();\n+    }\n+\n+    for (int i=0; i<SKIPLIST_LENGTH; i++) {\n+        if (i > 0) {\n+            BOOST_CHECK(vIndex[i].pskip == &vIndex[vIndex[i].pskip->nHeight]);\n+            BOOST_CHECK(vIndex[i].pskip->nHeight < i);\n+        } else {\n+            BOOST_CHECK(vIndex[i].pskip == NULL);\n+        }\n+    }\n+\n+    for (int i=0; i < 1000; i++) {\n+        int from = insecure_rand() % (SKIPLIST_LENGTH - 1);\n+        int to = insecure_rand() % (from + 1);\n+\n+        BOOST_CHECK(vIndex[SKIPLIST_LENGTH - 1].GetAncestor(from) == &vIndex[from]);\n+        BOOST_CHECK(vIndex[from].GetAncestor(to) == &vIndex[to]);\n+        BOOST_CHECK(vIndex[from].GetAncestor(0) == &vIndex[0]);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_CASE(getlocator_test)\n+{\n+    // Build a main chain 100000 blocks long.\n+    std::vector<uint256> vHashMain(100000);\n+    std::vector<CBlockIndex> vBlocksMain(100000);\n+    for (unsigned int i=0; i<vBlocksMain.size(); i++) {\n+        vHashMain[i] = i; // Set the hash equal to the height, so we can quickly check the distances.\n+        vBlocksMain[i].nHeight = i;\n+        vBlocksMain[i].pprev = i ? &vBlocksMain[i - 1] : NULL;\n+        vBlocksMain[i].phashBlock = &vHashMain[i];\n+        vBlocksMain[i].BuildSkip();\n+        BOOST_CHECK_EQUAL((int)vBlocksMain[i].GetBlockHash().GetLow64(), vBlocksMain[i].nHeight);\n+        BOOST_CHECK(vBlocksMain[i].pprev == NULL || vBlocksMain[i].nHeight == vBlocksMain[i].pprev->nHeight + 1);\n+    }\n+\n+    // Build a branch that splits off at block 49999, 50000 blocks long.\n+    std::vector<uint256> vHashSide(50000);\n+    std::vector<CBlockIndex> vBlocksSide(50000);\n+    for (unsigned int i=0; i<vBlocksSide.size(); i++) {\n+        vHashSide[i] = i + 50000 + (uint256(1) << 128); // Add 1<<128 to the hashes, so GetLow64() still returns the height.\n+        vBlocksSide[i].nHeight = i + 50000;\n+        vBlocksSide[i].pprev = i ? &vBlocksSide[i - 1] : &vBlocksMain[49999];\n+        vBlocksSide[i].phashBlock = &vHashSide[i];\n+        vBlocksSide[i].BuildSkip();\n+        BOOST_CHECK_EQUAL((int)vBlocksSide[i].GetBlockHash().GetLow64(), vBlocksSide[i].nHeight);\n+        BOOST_CHECK(vBlocksSide[i].pprev == NULL || vBlocksSide[i].nHeight == vBlocksSide[i].pprev->nHeight + 1);\n+    }\n+\n+    // Build a CChain for the main branch.\n+    CChain chain;\n+    chain.SetTip(&vBlocksMain.back());\n+\n+    // Test 100 random starting points for locators.\n+    for (int n=0; n<100; n++) {\n+        int r = insecure_rand() % 150000;\n+        CBlockIndex* tip = (r < 100000) ? &vBlocksMain[r] : &vBlocksSide[r - 100000];\n+        CBlockLocator locator = chain.GetLocator(tip);\n+\n+        // The first result must be the block itself, the last one must be genesis.\n+        BOOST_CHECK(locator.vHave.front() == tip->GetBlockHash());\n+        BOOST_CHECK(locator.vHave.back() == vBlocksMain[0].GetBlockHash());\n+\n+        // Entries 1 through 11 (inclusive) go back one step each.\n+        for (unsigned int i = 1; i < 12 && i < locator.vHave.size() - 1; i++) {\n+            BOOST_CHECK_EQUAL(locator.vHave[i].GetLow64(), tip->nHeight - i);\n+        }\n+\n+        // The further ones (excluding the last one) go back with exponential steps.\n+        unsigned int dist = 2;\n+        for (unsigned int i = 12; i < locator.vHave.size() - 1; i++) {\n+            BOOST_CHECK_EQUAL(locator.vHave[i - 1].GetLow64() - locator.vHave[i].GetLow64(), dist);\n+            dist *= 2;\n+        }\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "443b5853b20560964867314731896598f3bf4d59",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -4,9 +4,8 @@\n \n #define BOOST_TEST_MODULE Bitcoin Test Suite\n \n-\n-\n #include \"main.h\"\n+#include \"random.h\"\n #include \"txdb.h\"\n #include \"ui_interface.h\"\n #include \"util.h\"\n@@ -18,7 +17,7 @@\n #include <boost/filesystem.hpp>\n #include <boost/test/unit_test.hpp>\n \n-\n+CClientUIInterface uiInterface;\n CWallet* pwalletMain;\n \n extern bool fPrintToConsole;\n@@ -31,6 +30,7 @@ struct TestingSetup {\n \n     TestingSetup() {\n         fPrintToDebugLog = false; // don't want to write to debug.log file\n+        SelectParams(CBaseChainParams::MAIN);\n         noui_connect();\n #ifdef ENABLE_WALLET\n         bitdb.MakeMock();\n@@ -88,4 +88,3 @@ bool ShutdownRequested()\n {\n   return false;\n }\n-"
      },
      {
        "sha": "238033f407b05bc8704d281109f70b1e3abe63bf",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -208,7 +208,7 @@ BOOST_AUTO_TEST_CASE(basic_transaction_tests)\n     unsigned char ch[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x6b, 0xff, 0x7f, 0xcd, 0x4f, 0x85, 0x65, 0xef, 0x40, 0x6d, 0xd5, 0xd6, 0x3d, 0x4f, 0xf9, 0x4f, 0x31, 0x8f, 0xe8, 0x20, 0x27, 0xfd, 0x4d, 0xc4, 0x51, 0xb0, 0x44, 0x74, 0x01, 0x9f, 0x74, 0xb4, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x49, 0x30, 0x46, 0x02, 0x21, 0x00, 0xda, 0x0d, 0xc6, 0xae, 0xce, 0xfe, 0x1e, 0x06, 0xef, 0xdf, 0x05, 0x77, 0x37, 0x57, 0xde, 0xb1, 0x68, 0x82, 0x09, 0x30, 0xe3, 0xb0, 0xd0, 0x3f, 0x46, 0xf5, 0xfc, 0xf1, 0x50, 0xbf, 0x99, 0x0c, 0x02, 0x21, 0x00, 0xd2, 0x5b, 0x5c, 0x87, 0x04, 0x00, 0x76, 0xe4, 0xf2, 0x53, 0xf8, 0x26, 0x2e, 0x76, 0x3e, 0x2d, 0xd5, 0x1e, 0x7f, 0xf0, 0xbe, 0x15, 0x77, 0x27, 0xc4, 0xbc, 0x42, 0x80, 0x7f, 0x17, 0xbd, 0x39, 0x01, 0x41, 0x04, 0xe6, 0xc2, 0x6e, 0xf6, 0x7d, 0xc6, 0x10, 0xd2, 0xcd, 0x19, 0x24, 0x84, 0x78, 0x9a, 0x6c, 0xf9, 0xae, 0xa9, 0x93, 0x0b, 0x94, 0x4b, 0x7e, 0x2d, 0xb5, 0x34, 0x2b, 0x9d, 0x9e, 0x5b, 0x9f, 0xf7, 0x9a, 0xff, 0x9a, 0x2e, 0xe1, 0x97, 0x8d, 0xd7, 0xfd, 0x01, 0xdf, 0xc5, 0x22, 0xee, 0x02, 0x28, 0x3d, 0x3b, 0x06, 0xa9, 0xd0, 0x3a, 0xcf, 0x80, 0x96, 0x96, 0x8d, 0x7d, 0xbb, 0x0f, 0x91, 0x78, 0xff, 0xff, 0xff, 0xff, 0x02, 0x8b, 0xa7, 0x94, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xba, 0xde, 0xec, 0xfd, 0xef, 0x05, 0x07, 0x24, 0x7f, 0xc8, 0xf7, 0x42, 0x41, 0xd7, 0x3b, 0xc0, 0x39, 0x97, 0x2d, 0x7b, 0x88, 0xac, 0x40, 0x94, 0xa8, 0x02, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xc1, 0x09, 0x32, 0x48, 0x3f, 0xec, 0x93, 0xed, 0x51, 0xf5, 0xfe, 0x95, 0xe7, 0x25, 0x59, 0xf2, 0xcc, 0x70, 0x43, 0xf9, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00};\n     vector<unsigned char> vch(ch, ch + sizeof(ch) -1);\n     CDataStream stream(vch, SER_DISK, CLIENT_VERSION);\n-    CTransaction tx;\n+    CMutableTransaction tx;\n     stream >> tx;\n     CValidationState state;\n     BOOST_CHECK_MESSAGE(CheckTransaction(tx, state) && state.IsValid(), \"Simple deserialized transaction should be valid.\");\n@@ -224,10 +224,10 @@ BOOST_AUTO_TEST_CASE(basic_transaction_tests)\n // paid to a TX_PUBKEY, the second 21 and 22 CENT outputs\n // paid to a TX_PUBKEYHASH.\n //\n-static std::vector<CTransaction>\n+static std::vector<CMutableTransaction>\n SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsView & coinsRet)\n {\n-    std::vector<CTransaction> dummyTransactions;\n+    std::vector<CMutableTransaction> dummyTransactions;\n     dummyTransactions.resize(2);\n \n     // Add some keys to the keystore:\n@@ -261,9 +261,9 @@ BOOST_AUTO_TEST_CASE(test_Get)\n     CBasicKeyStore keystore;\n     CCoinsView coinsDummy;\n     CCoinsViewCache coins(coinsDummy);\n-    std::vector<CTransaction> dummyTransactions = SetupDummyInputs(keystore, coins);\n+    std::vector<CMutableTransaction> dummyTransactions = SetupDummyInputs(keystore, coins);\n \n-    CTransaction t1;\n+    CMutableTransaction t1;\n     t1.vin.resize(3);\n     t1.vin[0].prevout.hash = dummyTransactions[0].GetHash();\n     t1.vin[0].prevout.n = 1;\n@@ -296,9 +296,9 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)\n     CBasicKeyStore keystore;\n     CCoinsView coinsDummy;\n     CCoinsViewCache coins(coinsDummy);\n-    std::vector<CTransaction> dummyTransactions = SetupDummyInputs(keystore, coins);\n+    std::vector<CMutableTransaction> dummyTransactions = SetupDummyInputs(keystore, coins);\n \n-    CTransaction t;\n+    CMutableTransaction t;\n     t.vin.resize(1);\n     t.vin[0].prevout.hash = dummyTransactions[0].GetHash();\n     t.vin[0].prevout.n = 1;"
      },
      {
        "sha": "068b9f29c8118163dee28d50443de19cbf02df1b",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -4,6 +4,7 @@\n \n #include \"util.h\"\n \n+#include \"random.h\"\n #include \"sync.h\"\n \n #include <stdint.h>"
      },
      {
        "sha": "3887efbd0d98f33456d65875c389f2cb9eca44b7",
        "filename": "src/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/wallet_tests.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -31,20 +31,22 @@ static vector<COutput> vCoins;\n static void add_coin(int64_t nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0)\n {\n     static int nextLockTime = 0;\n-    CTransaction tx;\n+    CMutableTransaction tx;\n     tx.nLockTime = nextLockTime++;        // so all transactions get different hashes\n     tx.vout.resize(nInput+1);\n     tx.vout[nInput].nValue = nValue;\n+    if (fIsFromMe) {\n+        // IsFromMe() returns (GetDebit() > 0), and GetDebit() is 0 if vin.empty(),\n+        // so stop vin being empty, and cache a non-zero Debit to fake out IsFromMe()\n+        tx.vin.resize(1);\n+    }\n     CWalletTx* wtx = new CWalletTx(&wallet, tx);\n     if (fIsFromMe)\n     {\n-        // IsFromMe() returns (GetDebit() > 0), and GetDebit() is 0 if vin.empty(),\n-        // so stop vin being empty, and cache a non-zero Debit to fake out IsFromMe()\n-        wtx->vin.resize(1);\n         wtx->fDebitCached = true;\n         wtx->nDebitCached = 1;\n     }\n-    COutput output(wtx, nInput, nAge);\n+    COutput output(wtx, nInput, nAge, true);\n     vCoins.push_back(output);\n }\n "
      },
      {
        "sha": "6c3bd9a48dc95348421127476cf5c3715cc787bf",
        "filename": "src/timedata.cpp",
        "status": "added",
        "additions": 109,
        "deletions": 0,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,109 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"timedata.h\"\n+\n+#include \"netbase.h\"\n+#include \"sync.h\"\n+#include \"ui_interface.h\"\n+#include \"util.h\"\n+\n+#include <boost/foreach.hpp>\n+\n+using namespace std;\n+\n+static CCriticalSection cs_nTimeOffset;\n+static int64_t nTimeOffset = 0;\n+\n+//\n+// \"Never go to sea with two chronometers; take one or three.\"\n+// Our three time sources are:\n+//  - System clock\n+//  - Median of other nodes clocks\n+//  - The user (asking the user to fix the system clock if the first two disagree)\n+//\n+//\n+int64_t GetTimeOffset()\n+{\n+    LOCK(cs_nTimeOffset);\n+    return nTimeOffset;\n+}\n+\n+int64_t GetAdjustedTime()\n+{\n+    return GetTime() + GetTimeOffset();\n+}\n+\n+void AddTimeData(const CNetAddr& ip, int64_t nTime)\n+{\n+    int64_t nOffsetSample = nTime - GetTime();\n+\n+    LOCK(cs_nTimeOffset);\n+    // Ignore duplicates\n+    static set<CNetAddr> setKnown;\n+    if (!setKnown.insert(ip).second)\n+        return;\n+\n+    // Add data\n+    static CMedianFilter<int64_t> vTimeOffsets(200,0);\n+    vTimeOffsets.input(nOffsetSample);\n+    LogPrintf(\"Added time data, samples %d, offset %+d (%+d minutes)\\n\", vTimeOffsets.size(), nOffsetSample, nOffsetSample/60);\n+\n+    // There is a known issue here (see issue #4521):\n+    //\n+    // - The structure vTimeOffsets contains up to 200 elements, after which\n+    // any new element added to it will not increase its size, replacing the\n+    // oldest element.\n+    //\n+    // - The condition to update nTimeOffset includes checking whether the\n+    // number of elements in vTimeOffsets is odd, which will never happen after\n+    // there are 200 elements.\n+    //\n+    // But in this case the 'bug' is protective against some attacks, and may\n+    // actually explain why we've never seen attacks which manipulate the\n+    // clock offset.\n+    //\n+    // So we should hold off on fixing this and clean it up as part of\n+    // a timing cleanup that strengthens it in a number of other ways.\n+    //\n+    if (vTimeOffsets.size() >= 5 && vTimeOffsets.size() % 2 == 1)\n+    {\n+        int64_t nMedian = vTimeOffsets.median();\n+        std::vector<int64_t> vSorted = vTimeOffsets.sorted();\n+        // Only let other nodes change our time by so much\n+        if (abs64(nMedian) < 70 * 60)\n+        {\n+            nTimeOffset = nMedian;\n+        }\n+        else\n+        {\n+            nTimeOffset = 0;\n+\n+            static bool fDone;\n+            if (!fDone)\n+            {\n+                // If nobody has a time different than ours but within 5 minutes of ours, give a warning\n+                bool fMatch = false;\n+                BOOST_FOREACH(int64_t nOffset, vSorted)\n+                    if (nOffset != 0 && abs64(nOffset) < 5 * 60)\n+                        fMatch = true;\n+\n+                if (!fMatch)\n+                {\n+                    fDone = true;\n+                    string strMessage = _(\"Warning: Please check that your computer's date and time are correct! If your clock is wrong Bitcoin will not work properly.\");\n+                    strMiscWarning = strMessage;\n+                    LogPrintf(\"*** %s\\n\", strMessage);\n+                    uiInterface.ThreadSafeMessageBox(strMessage, \"\", CClientUIInterface::MSG_WARNING);\n+                }\n+            }\n+        }\n+        if (fDebug) {\n+            BOOST_FOREACH(int64_t n, vSorted)\n+                LogPrintf(\"%+d  \", n);\n+            LogPrintf(\"|  \");\n+        }\n+        LogPrintf(\"nTimeOffset = %+d  (%+d minutes)\\n\", nTimeOffset, nTimeOffset/60);\n+    }\n+}"
      },
      {
        "sha": "0e7bdc2c1f0647ed6208cf0db5a1382e80f8abe4",
        "filename": "src/timedata.h",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/timedata.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/timedata.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,17 @@\n+// Copyright (c) 2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_TIMEDATA_H\n+#define BITCOIN_TIMEDATA_H\n+\n+#include <stdint.h>\n+\n+class CNetAddr;\n+\n+/* Functions to keep track of adjusted P2P time */\n+int64_t GetTimeOffset();\n+int64_t GetAdjustedTime();\n+void AddTimeData(const CNetAddr& ip, int64_t nTime);\n+\n+#endif"
      },
      {
        "sha": "52cd96283e2d1fbcea8dc58dd037046fe7d0d3c4",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -6,6 +6,7 @@\n #include \"txdb.h\"\n \n #include \"core.h\"\n+#include \"pow.h\"\n #include \"uint256.h\"\n \n #include <stdint.h>\n@@ -53,11 +54,11 @@ bool CCoinsViewDB::SetBestBlock(const uint256 &hashBlock) {\n     return db.WriteBatch(batch);\n }\n \n-bool CCoinsViewDB::BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock) {\n+bool CCoinsViewDB::BatchWrite(const CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     LogPrint(\"coindb\", \"Committing %u changed transactions to coin database...\\n\", (unsigned int)mapCoins.size());\n \n     CLevelDBBatch batch;\n-    for (std::map<uint256, CCoins>::const_iterator it = mapCoins.begin(); it != mapCoins.end(); it++)\n+    for (CCoinsMap::const_iterator it = mapCoins.begin(); it != mapCoins.end(); it++)\n         BatchWriteCoins(batch, it->first, it->second);\n     if (hashBlock != uint256(0))\n         BatchWriteHashBestChain(batch, hashBlock);\n@@ -212,8 +213,8 @@ bool CBlockTreeDB::LoadBlockIndexGuts()\n                 pindexNew->nStatus        = diskindex.nStatus;\n                 pindexNew->nTx            = diskindex.nTx;\n \n-                if (!pindexNew->CheckIndex())\n-                    return error(\"LoadBlockIndex() : CheckIndex failed: %s\", pindexNew->ToString());\n+                if (!CheckProofOfWork(pindexNew->GetBlockHash(), pindexNew->nBits))\n+                    return error(\"LoadBlockIndex() : CheckProofOfWork failed: %s\", pindexNew->ToString());\n \n                 pcursor->Next();\n             } else {"
      },
      {
        "sha": "7d670c25423f69e0bc10c83887682344be18f229",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -37,7 +37,7 @@ class CCoinsViewDB : public CCoinsView\n     bool HaveCoins(const uint256 &txid);\n     uint256 GetBestBlock();\n     bool SetBestBlock(const uint256 &hashBlock);\n-    bool BatchWrite(const std::map<uint256, CCoins> &mapCoins, const uint256 &hashBlock);\n+    bool BatchWrite(const CCoinsMap &mapCoins, const uint256 &hashBlock);\n     bool GetStats(CCoinsStats &stats);\n };\n "
      },
      {
        "sha": "164e2741a29c223ef80923d92e4fbfd517a5d1b8",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 53,
        "deletions": 18,
        "changes": 71,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -80,13 +80,13 @@ class CBlockAverage\n \n     // Used as belt-and-suspenders check when reading to detect\n     // file corruption\n-    bool AreSane(const std::vector<CFeeRate>& vecFee)\n+    bool AreSane(const std::vector<CFeeRate>& vecFee, const CFeeRate& minRelayFee)\n     {\n         BOOST_FOREACH(CFeeRate fee, vecFee)\n         {\n             if (fee < CFeeRate(0))\n                 return false;\n-            if (fee.GetFee(1000) > CTransaction::minRelayTxFee.GetFee(1000) * 10000)\n+            if (fee.GetFeePerK() > minRelayFee.GetFeePerK() * 10000)\n                 return false;\n         }\n         return true;\n@@ -109,10 +109,10 @@ class CBlockAverage\n         fileout << vecPriority;\n     }\n \n-    void Read(CAutoFile& filein) {\n+    void Read(CAutoFile& filein, const CFeeRate& minRelayFee) {\n         std::vector<CFeeRate> vecFee;\n         filein >> vecFee;\n-        if (AreSane(vecFee))\n+        if (AreSane(vecFee, minRelayFee))\n             feeSamples.insert(feeSamples.end(), vecFee.begin(), vecFee.end());\n         else\n             throw runtime_error(\"Corrupt fee value in estimates file.\");\n@@ -141,15 +141,15 @@ class CMinerPolicyEstimator\n \n     // nBlocksAgo is 0 based, i.e. transactions that confirmed in the highest seen block are\n     // nBlocksAgo == 0, transactions in the block before that are nBlocksAgo == 1 etc.\n-    void seenTxConfirm(CFeeRate feeRate, double dPriority, int nBlocksAgo)\n+    void seenTxConfirm(const CFeeRate& feeRate, const CFeeRate& minRelayFee, double dPriority, int nBlocksAgo)\n     {\n         // Last entry records \"everything else\".\n         int nBlocksTruncated = min(nBlocksAgo, (int) history.size() - 1);\n         assert(nBlocksTruncated >= 0);\n \n         // We need to guess why the transaction was included in a block-- either\n         // because it is high-priority or because it has sufficient fees.\n-        bool sufficientFee = (feeRate > CTransaction::minRelayTxFee);\n+        bool sufficientFee = (feeRate > minRelayFee);\n         bool sufficientPriority = AllowFree(dPriority);\n         const char* assignedTo = \"unassigned\";\n         if (sufficientFee && !sufficientPriority)\n@@ -177,7 +177,7 @@ class CMinerPolicyEstimator\n         history.resize(nEntries);\n     }\n \n-    void seenBlock(const std::vector<CTxMemPoolEntry>& entries, int nBlockHeight)\n+    void seenBlock(const std::vector<CTxMemPoolEntry>& entries, int nBlockHeight, const CFeeRate minRelayFee)\n     {\n         if (nBlockHeight <= nBestSeenHeight)\n         {\n@@ -222,7 +222,7 @@ class CMinerPolicyEstimator\n                 // Fees are stored and reported as BTC-per-kb:\n                 CFeeRate feeRate(entry->GetFee(), entry->GetTxSize());\n                 double dPriority = entry->GetPriority(entry->GetHeight()); // Want priority when it went IN\n-                seenTxConfirm(feeRate, dPriority, i);\n+                seenTxConfirm(feeRate, minRelayFee, dPriority, i);\n             }\n         }\n         for (size_t i = 0; i < history.size(); i++) {\n@@ -251,8 +251,13 @@ class CMinerPolicyEstimator\n             std::sort(sortedFeeSamples.begin(), sortedFeeSamples.end(),\n                       std::greater<CFeeRate>());\n         }\n-        if (sortedFeeSamples.size() == 0)\n+        if (sortedFeeSamples.size() < 11)\n+        {\n+            // Eleven is Gavin's Favorite Number\n+            // ... but we also take a maximum of 10 samples per block so eleven means\n+            // we're getting samples from at least two different blocks\n             return CFeeRate(0);\n+        }\n \n         int nBucketSize = history.at(nBlocksToConfirm).FeeSamples();\n \n@@ -281,7 +286,7 @@ class CMinerPolicyEstimator\n             std::sort(sortedPrioritySamples.begin(), sortedPrioritySamples.end(),\n                       std::greater<double>());\n         }\n-        if (sortedPrioritySamples.size() == 0)\n+        if (sortedPrioritySamples.size() < 11)\n             return -1.0;\n \n         int nBucketSize = history.at(nBlocksToConfirm).PrioritySamples();\n@@ -308,7 +313,7 @@ class CMinerPolicyEstimator\n         }\n     }\n \n-    void Read(CAutoFile& filein)\n+    void Read(CAutoFile& filein, const CFeeRate& minRelayFee)\n     {\n         filein >> nBestSeenHeight;\n         size_t numEntries;\n@@ -317,14 +322,14 @@ class CMinerPolicyEstimator\n         for (size_t i = 0; i < numEntries; i++)\n         {\n             CBlockAverage entry;\n-            entry.Read(filein);\n+            entry.Read(filein, minRelayFee);\n             history.push_back(entry);\n         }\n     }\n };\n \n \n-CTxMemPool::CTxMemPool()\n+CTxMemPool::CTxMemPool(const CFeeRate& _minRelayFee) : minRelayFee(_minRelayFee)\n {\n     // Sanity checks off by default for performance, because otherwise\n     // accepting transactions becomes O(N^2) where N is the number\n@@ -441,12 +446,13 @@ void CTxMemPool::removeForBlock(const std::vector<CTransaction>& vtx, unsigned i\n         if (mapTx.count(hash))\n             entries.push_back(mapTx[hash]);\n     }\n-    minerPolicyEstimator->seenBlock(entries, nBlockHeight);\n+    minerPolicyEstimator->seenBlock(entries, nBlockHeight, minRelayFee);\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n     {\n         std::list<CTransaction> dummy;\n         remove(tx, dummy, false);\n         removeConflicts(tx, conflicts);\n+        ClearPrioritisation(tx.GetHash());\n     }\n }\n \n@@ -555,7 +561,7 @@ CTxMemPool::ReadFeeEstimates(CAutoFile& filein)\n             return error(\"CTxMemPool::ReadFeeEstimates() : up-version (%d) fee estimate file\", nVersionRequired);\n \n         LOCK(cs);\n-        minerPolicyEstimator->Read(filein);\n+        minerPolicyEstimator->Read(filein, minRelayFee);\n     }\n     catch (std::exception &e) {\n         LogPrintf(\"CTxMemPool::ReadFeeEstimates() : unable to read policy estimator data (non-fatal)\");\n@@ -564,18 +570,47 @@ CTxMemPool::ReadFeeEstimates(CAutoFile& filein)\n     return true;\n }\n \n+void CTxMemPool::PrioritiseTransaction(const uint256 hash, const string strHash, double dPriorityDelta, int64_t nFeeDelta)\n+{\n+    {\n+        LOCK(cs);\n+        std::pair<double, int64_t> &deltas = mapDeltas[hash];\n+        deltas.first += dPriorityDelta;\n+        deltas.second += nFeeDelta;\n+    }\n+    LogPrintf(\"PrioritiseTransaction: %s priority += %f, fee += %d\\n\", strHash.c_str(), dPriorityDelta, nFeeDelta);\n+}\n+\n+void CTxMemPool::ApplyDeltas(const uint256 hash, double &dPriorityDelta, int64_t &nFeeDelta)\n+{\n+    LOCK(cs);\n+    std::map<uint256, std::pair<double, int64_t> >::iterator pos = mapDeltas.find(hash);\n+    if (pos == mapDeltas.end())\n+        return;\n+    const std::pair<double, int64_t> &deltas = pos->second;\n+    dPriorityDelta += deltas.first;\n+    nFeeDelta += deltas.second;\n+}\n+\n+void CTxMemPool::ClearPrioritisation(const uint256 hash)\n+{\n+    LOCK(cs);\n+    mapDeltas.erase(hash);\n+}\n+\n \n CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView &baseIn, CTxMemPool &mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) { }\n \n bool CCoinsViewMemPool::GetCoins(const uint256 &txid, CCoins &coins) {\n-    if (base->GetCoins(txid, coins))\n-        return true;\n+    // If an entry in the mempool exists, always return that one, as it's guaranteed to never\n+    // conflict with the underlying cache, and it cannot have pruned entries (as it contains full)\n+    // transactions. First checking the underlying cache risks returning a pruned entry instead.\n     CTransaction tx;\n     if (mempool.lookup(txid, tx)) {\n         coins = CCoins(tx, MEMPOOL_HEIGHT);\n         return true;\n     }\n-    return false;\n+    return (base->GetCoins(txid, coins) && !coins.IsPruned());\n }\n \n bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) {"
      },
      {
        "sha": "41b2c52f39c70922f0403ca706c48d178ab552d7",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -67,12 +67,15 @@ class CTxMemPool\n     unsigned int nTransactionsUpdated;\n     CMinerPolicyEstimator* minerPolicyEstimator;\n \n+    CFeeRate minRelayFee; // Passed to constructor to avoid dependency on main\n+\n public:\n     mutable CCriticalSection cs;\n     std::map<uint256, CTxMemPoolEntry> mapTx;\n     std::map<COutPoint, CInPoint> mapNextTx;\n+    std::map<uint256, std::pair<double, int64_t> > mapDeltas;\n \n-    CTxMemPool();\n+    CTxMemPool(const CFeeRate& _minRelayFee);\n     ~CTxMemPool();\n \n     /*\n@@ -95,6 +98,11 @@ class CTxMemPool\n     unsigned int GetTransactionsUpdated() const;\n     void AddTransactionsUpdated(unsigned int n);\n \n+    /** Affect CreateNewBlock prioritisation of transactions */\n+    void PrioritiseTransaction(const uint256 hash, const std::string strHash, double dPriorityDelta, int64_t nFeeDelta);\n+    void ApplyDeltas(const uint256 hash, double &dPriorityDelta, int64_t &nFeeDelta);\n+    void ClearPrioritisation(const uint256 hash);\n+\n     unsigned long size()\n     {\n         LOCK(cs);"
      },
      {
        "sha": "b3df2b5a8591ba1d1b05df5363f610bb2e7a635e",
        "filename": "src/ui_interface.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/ui_interface.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/ui_interface.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/ui_interface.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -62,8 +62,6 @@ class CClientUIInterface\n \n         /** Force blocking, modal message box dialog (not just OS notification) */\n         MODAL               = 0x10000000U,\n-        /** Don't bring GUI to foreground. Use for messages during initialization */\n-        NOSHOWGUI           = 0x20000000U,\n \n         /** Predefined combinations for certain default usage cases */\n         MSG_INFORMATION = ICON_INFORMATION,"
      },
      {
        "sha": "08c05594fd974eca049944ffc44675b1c24bbdba",
        "filename": "src/uint256.cpp",
        "status": "added",
        "additions": 335,
        "deletions": 0,
        "changes": 335,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/uint256.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/uint256.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "patch": "@@ -0,0 +1,335 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2014 The Bitcoin developers\n+// Distributed under the MIT/X11 software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"uint256.h\"\n+#include \"util.h\"\n+\n+#include <stdio.h>\n+#include <string.h>\n+\n+template<unsigned int BITS>\n+base_uint<BITS>::base_uint(const std::string& str)\n+{\n+    SetHex(str);\n+}\n+\n+template<unsigned int BITS>\n+base_uint<BITS>::base_uint(const std::vector<unsigned char>& vch)\n+{\n+    if (vch.size() != sizeof(pn))\n+        throw uint_error(\"Converting vector of wrong size to base_uint\");\n+    memcpy(pn, &vch[0], sizeof(pn));\n+}\n+\n+template<unsigned int BITS>\n+base_uint<BITS>& base_uint<BITS>::operator<<=(unsigned int shift)\n+{\n+    base_uint<BITS> a(*this);\n+    for (int i = 0; i < WIDTH; i++)\n+        pn[i] = 0;\n+    int k = shift / 32;\n+    shift = shift % 32;\n+    for (int i = 0; i < WIDTH; i++) {\n+        if (i+k+1 < WIDTH && shift != 0)\n+            pn[i+k+1] |= (a.pn[i] >> (32-shift));\n+        if (i+k < WIDTH)\n+            pn[i+k] |= (a.pn[i] << shift);\n+    }\n+    return *this;\n+}\n+\n+template<unsigned int BITS>\n+base_uint<BITS>& base_uint<BITS>::operator>>=(unsigned int shift)\n+{\n+    base_uint<BITS> a(*this);\n+    for (int i = 0; i < WIDTH; i++)\n+        pn[i] = 0;\n+    int k = shift / 32;\n+    shift = shift % 32;\n+    for (int i = 0; i < WIDTH; i++) {\n+        if (i-k-1 >= 0 && shift != 0)\n+            pn[i-k-1] |= (a.pn[i] << (32-shift));\n+        if (i-k >= 0)\n+            pn[i-k] |= (a.pn[i] >> shift);\n+    }\n+    return *this;\n+}\n+\n+template<unsigned int BITS>\n+base_uint<BITS>& base_uint<BITS>::operator*=(uint32_t b32)\n+{\n+    uint64_t carry = 0;\n+    for (int i = 0; i < WIDTH; i++) {\n+        uint64_t n = carry + (uint64_t)b32 * pn[i];\n+        pn[i] = n & 0xffffffff;\n+        carry = n >> 32;\n+    }\n+    return *this;\n+}\n+\n+template<unsigned int BITS>\n+base_uint<BITS>& base_uint<BITS>::operator*=(const base_uint& b)\n+{\n+    base_uint<BITS> a = *this;\n+    *this = 0;\n+    for (int j = 0; j < WIDTH; j++) {\n+        uint64_t carry = 0;\n+        for (int i = 0; i + j < WIDTH; i++) {\n+            uint64_t n = carry + pn[i + j] + (uint64_t)a.pn[j] * b.pn[i];\n+            pn[i + j] = n & 0xffffffff;\n+            carry = n >> 32;\n+        }\n+    }\n+    return *this;\n+}\n+\n+template<unsigned int BITS>\n+base_uint<BITS>& base_uint<BITS>::operator/=(const base_uint& b)\n+{\n+    base_uint<BITS> div = b; // make a copy, so we can shift.\n+    base_uint<BITS> num = *this; // make a copy, so we can subtract.\n+    *this = 0; // the quotient.\n+    int num_bits = num.bits();\n+    int div_bits = div.bits();\n+    if (div_bits == 0)\n+        throw uint_error(\"Division by zero\");\n+    if (div_bits > num_bits) // the result is certainly 0.\n+        return *this;\n+    int shift = num_bits - div_bits;\n+    div <<= shift; // shift so that div and nun align.\n+    while (shift >= 0) {\n+        if (num >= div) {\n+            num -= div;\n+            pn[shift / 32] |= (1 << (shift & 31)); // set a bit of the result.\n+        }\n+        div >>= 1; // shift back.\n+        shift--;\n+    }\n+    // num now contains the remainder of the division.\n+    return *this;\n+}\n+\n+template<unsigned int BITS>\n+int base_uint<BITS>::CompareTo(const base_uint<BITS>& b) const {\n+    for (int i = WIDTH-1; i >= 0; i--) {\n+        if (pn[i] < b.pn[i])\n+            return -1;\n+        if (pn[i] > b.pn[i])\n+            return 1;\n+    }\n+    return 0;\n+}\n+\n+template<unsigned int BITS>\n+bool base_uint<BITS>::EqualTo(uint64_t b) const {\n+    for (int i = WIDTH-1; i >= 2; i--) {\n+        if (pn[i])\n+            return false;\n+    }\n+    if (pn[1] != (b >> 32))\n+        return false;\n+    if (pn[0] != (b & 0xfffffffful))\n+        return false;\n+    return true;\n+}\n+\n+template<unsigned int BITS>\n+double base_uint<BITS>::getdouble() const\n+{\n+    double ret = 0.0;\n+    double fact = 1.0;\n+    for (int i = 0; i < WIDTH; i++) {\n+        ret += fact * pn[i];\n+        fact *= 4294967296.0;\n+    }\n+    return ret;\n+}\n+\n+template<unsigned int BITS>\n+std::string base_uint<BITS>::GetHex() const\n+{\n+    char psz[sizeof(pn)*2 + 1];\n+    for (unsigned int i = 0; i < sizeof(pn); i++)\n+        sprintf(psz + i*2, \"%02x\", ((unsigned char*)pn)[sizeof(pn) - i - 1]);\n+    return std::string(psz, psz + sizeof(pn)*2);\n+}\n+\n+template<unsigned int BITS>\n+void base_uint<BITS>::SetHex(const char* psz)\n+{\n+    memset(pn,0,sizeof(pn));\n+\n+    // skip leading spaces\n+    while (isspace(*psz))\n+        psz++;\n+\n+    // skip 0x\n+    if (psz[0] == '0' && tolower(psz[1]) == 'x')\n+        psz += 2;\n+\n+    // hex string to uint\n+    const char* pbegin = psz;\n+    while (::HexDigit(*psz) != -1)\n+        psz++;\n+    psz--;\n+    unsigned char* p1 = (unsigned char*)pn;\n+    unsigned char* pend = p1 + WIDTH * 4;\n+    while (psz >= pbegin && p1 < pend) {\n+        *p1 = ::HexDigit(*psz--);\n+        if (psz >= pbegin) {\n+            *p1 |= ((unsigned char)::HexDigit(*psz--) << 4);\n+            p1++;\n+        }\n+    }\n+}\n+\n+template<unsigned int BITS>\n+void base_uint<BITS>::SetHex(const std::string& str)\n+{\n+    SetHex(str.c_str());\n+}\n+\n+template<unsigned int BITS>\n+std::string base_uint<BITS>::ToString() const\n+{\n+    return (GetHex());\n+}\n+\n+template<unsigned int BITS>\n+unsigned int base_uint<BITS>::bits() const\n+{\n+    for (int pos = WIDTH-1; pos >= 0; pos--) {\n+        if (pn[pos]) {\n+            for (int bits = 31; bits > 0; bits--) {\n+                if (pn[pos] & 1<<bits)\n+                    return 32*pos + bits + 1;\n+            }\n+            return 32*pos + 1;\n+        }\n+    }\n+    return 0;\n+}\n+\n+// Explicit instantiations for base_uint<160>\n+template base_uint<160>::base_uint(const std::string&);\n+template base_uint<160>::base_uint(const std::vector<unsigned char>&);\n+template base_uint<160>& base_uint<160>::operator<<=(unsigned int);\n+template base_uint<160>& base_uint<160>::operator>>=(unsigned int);\n+template base_uint<160>& base_uint<160>::operator*=(uint32_t b32);\n+template base_uint<160>& base_uint<160>::operator*=(const base_uint<160>& b);\n+template base_uint<160>& base_uint<160>::operator/=(const base_uint<160>& b);\n+template int base_uint<160>::CompareTo(const base_uint<160>&) const;\n+template bool base_uint<160>::EqualTo(uint64_t) const;\n+template double base_uint<160>::getdouble() const;\n+template std::string base_uint<160>::GetHex() const;\n+template std::string base_uint<160>::ToString() const;\n+template void base_uint<160>::SetHex(const char*);\n+template void base_uint<160>::SetHex(const std::string&);\n+template unsigned int base_uint<160>::bits() const;\n+\n+// Explicit instantiations for base_uint<256>\n+template base_uint<256>::base_uint(const std::string&);\n+template base_uint<256>::base_uint(const std::vector<unsigned char>&);\n+template base_uint<256>& base_uint<256>::operator<<=(unsigned int);\n+template base_uint<256>& base_uint<256>::operator>>=(unsigned int);\n+template base_uint<256>& base_uint<256>::operator*=(uint32_t b32);\n+template base_uint<256>& base_uint<256>::operator*=(const base_uint<256>& b);\n+template base_uint<256>& base_uint<256>::operator/=(const base_uint<256>& b);\n+template int base_uint<256>::CompareTo(const base_uint<256>&) const;\n+template bool base_uint<256>::EqualTo(uint64_t) const;\n+template double base_uint<256>::getdouble() const;\n+template std::string base_uint<256>::GetHex() const;\n+template std::string base_uint<256>::ToString() const;\n+template void base_uint<256>::SetHex(const char*);\n+template void base_uint<256>::SetHex(const std::string&);\n+template unsigned int base_uint<256>::bits() const;\n+\n+// This implementation directly uses shifts instead of going\n+// through an intermediate MPI representation.\n+uint256& uint256::SetCompact(uint32_t nCompact, bool *pfNegative, bool *pfOverflow)\n+{\n+    int nSize = nCompact >> 24;\n+    uint32_t nWord = nCompact & 0x007fffff;\n+    if (nSize <= 3) {\n+        nWord >>= 8*(3-nSize);\n+        *this = nWord;\n+    } else {\n+        *this = nWord;\n+        *this <<= 8*(nSize-3);\n+    }\n+    if (pfNegative)\n+        *pfNegative = nWord != 0 && (nCompact & 0x00800000) != 0;\n+    if (pfOverflow)\n+        *pfOverflow = nWord != 0 && ((nSize > 34) ||\n+                                     (nWord > 0xff && nSize > 33) ||\n+                                     (nWord > 0xffff && nSize > 32));\n+    return *this;\n+}\n+\n+uint32_t uint256::GetCompact(bool fNegative) const\n+{\n+    int nSize = (bits() + 7) / 8;\n+    uint32_t nCompact = 0;\n+    if (nSize <= 3) {\n+        nCompact = GetLow64() << 8*(3-nSize);\n+    } else {\n+        uint256 bn = *this >> 8*(nSize-3);\n+        nCompact = bn.GetLow64();\n+    }\n+    // The 0x00800000 bit denotes the sign.\n+    // Thus, if it is already set, divide the mantissa by 256 and increase the exponent.\n+    if (nCompact & 0x00800000) {\n+        nCompact >>= 8;\n+        nSize++;\n+    }\n+    assert((nCompact & ~0x007fffff) == 0);\n+    assert(nSize < 256);\n+    nCompact |= nSize << 24;\n+    nCompact |= (fNegative && (nCompact & 0x007fffff) ? 0x00800000 : 0);\n+    return nCompact;\n+}\n+\n+static void inline HashMix(uint32_t& a, uint32_t& b, uint32_t& c)\n+{\n+    // Taken from lookup3, by Bob Jenkins.\n+    a -= c; a ^= ((c <<  4) | (c >> 28)); c += b;\n+    b -= a; b ^= ((a <<  6) | (a >> 26)); a += c;\n+    c -= b; c ^= ((b <<  8) | (b >> 24)); b += a;\n+    a -= c; a ^= ((c << 16) | (c >> 16)); c += b;\n+    b -= a; b ^= ((a << 19) | (a >> 13)); a += c;\n+    c -= b; c ^= ((b <<  4) | (b >> 28)); b += a;\n+}\n+\n+static void inline HashFinal(uint32_t& a, uint32_t& b, uint32_t& c)\n+{\n+    // Taken from lookup3, by Bob Jenkins.\n+    c ^= b; c -= ((b << 14) | (b >> 18));\n+    a ^= c; a -= ((c << 11) | (c >> 21));\n+    b ^= a; b -= ((a << 25) | (a >>  7));\n+    c ^= b; c -= ((b << 16) | (b >> 16));\n+    a ^= c; a -= ((c <<  4) | (c >> 28));\n+    b ^= a; b -= ((a << 14) | (a >> 18));\n+    c ^= b; c -= ((b << 24) | (b >>  8));\n+}\n+\n+uint64_t uint256::GetHash(const uint256 &salt) const\n+{\n+    uint32_t a, b, c;\n+    a = b = c = 0xdeadbeef + (WIDTH << 2);\n+\n+    a += pn[0] ^ salt.pn[0];\n+    b += pn[1] ^ salt.pn[1];\n+    c += pn[2] ^ salt.pn[2];\n+    HashMix(a, b, c);\n+    a += pn[3] ^ salt.pn[3];\n+    b += pn[4] ^ salt.pn[4];\n+    c += pn[5] ^ salt.pn[5];\n+    HashMix(a, b, c);\n+    a += pn[6] ^ salt.pn[6];\n+    b += pn[7] ^ salt.pn[7];\n+    HashFinal(a, b, c);\n+\n+    return ((((uint64_t)b) << 32) | c);\n+}"
      },
      {
        "sha": "ad0a56f447d1a51579a5606a0790cc4e08fc600c",
        "filename": "src/uint256.h",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/uint256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/uint256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/uint256.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5"
      },
      {
        "sha": "d3fa5182f37aaeb7066250e1f780af38763a3185",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 183,
        "changes": 207,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5"
      },
      {
        "sha": "db2005337b20d2b68c6945d420d83856346f1a30",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 3,
        "deletions": 55,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5"
      },
      {
        "sha": "85c5dbf8d7bac04dc26b7eec32d4716fea6f843e",
        "filename": "src/version.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/version.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/version.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/version.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5"
      },
      {
        "sha": "7c04743c0f0b5f98593407c14c60b6788492227a",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 209,
        "deletions": 97,
        "changes": 306,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5"
      },
      {
        "sha": "73fcfa24e081868dd55621a5f2b113abf2e48c52",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 138,
        "deletions": 35,
        "changes": 173,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5"
      },
      {
        "sha": "a95baf83d0dd5f93e4b9a0ced789e585c95ed3ea",
        "filename": "src/walletdb.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 3,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.cpp?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5"
      },
      {
        "sha": "58b4571b16f2bed61a18151ad2b1f2fe9c6edb03",
        "filename": "src/walletdb.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/walletdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/468d4a22956961130124dcc8b42b4c8c5e657cc5/src/walletdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/walletdb.h?ref=468d4a22956961130124dcc8b42b4c8c5e657cc5"
      }
    ]
  },
  {
    "sha": "92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MmRlMGRlNzc3MDRiOTZmMmIxZmMxYTczYjBkZmQ5MmZiODgyODFl",
    "commit": {
      "author": {
        "name": "whitj00",
        "email": "whitj00@ymail.com",
        "date": "2014-07-26T17:58:27Z"
      },
      "committer": {
        "name": "whitj00",
        "email": "whitj00@ymail.com",
        "date": "2014-07-26T17:58:27Z"
      },
      "message": "use https",
      "tree": {
        "sha": "c15f25983569750c6dd63df7e12a0e7b15386de1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/c15f25983569750c6dd63df7e12a0e7b15386de1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/comments",
    "author": {
      "login": "whitj00",
      "id": 6721742,
      "node_id": "MDQ6VXNlcjY3MjE3NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6721742?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitj00",
      "html_url": "https://github.com/whitj00",
      "followers_url": "https://api.github.com/users/whitj00/followers",
      "following_url": "https://api.github.com/users/whitj00/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitj00/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitj00/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitj00/subscriptions",
      "organizations_url": "https://api.github.com/users/whitj00/orgs",
      "repos_url": "https://api.github.com/users/whitj00/repos",
      "events_url": "https://api.github.com/users/whitj00/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitj00/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "whitj00",
      "id": 6721742,
      "node_id": "MDQ6VXNlcjY3MjE3NDI=",
      "avatar_url": "https://avatars.githubusercontent.com/u/6721742?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/whitj00",
      "html_url": "https://github.com/whitj00",
      "followers_url": "https://api.github.com/users/whitj00/followers",
      "following_url": "https://api.github.com/users/whitj00/following{/other_user}",
      "gists_url": "https://api.github.com/users/whitj00/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/whitj00/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/whitj00/subscriptions",
      "organizations_url": "https://api.github.com/users/whitj00/orgs",
      "repos_url": "https://api.github.com/users/whitj00/repos",
      "events_url": "https://api.github.com/users/whitj00/events{/privacy}",
      "received_events_url": "https://api.github.com/users/whitj00/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/468d4a22956961130124dcc8b42b4c8c5e657cc5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/468d4a22956961130124dcc8b42b4c8c5e657cc5"
      }
    ],
    "stats": {
      "total": 220,
      "additions": 110,
      "deletions": 110
    },
    "files": [
      {
        "sha": "ac6162fc5fd6bd80ee9500f09140416cdb1dfa91",
        "filename": "doc/build-msw.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/doc/build-msw.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/doc/build-msw.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-msw.md?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -14,7 +14,7 @@ Libraries you need to download separately and build:\n \n \tname            default path               download\n \t--------------------------------------------------------------------------------------------------------------------\n-\tOpenSSL         \\openssl-1.0.1h-mgw        http://www.openssl.org/source/\n+\tOpenSSL         \\openssl-1.0.1h-mgw        https://www.openssl.org/source/\n \tBerkeley DB     \\db-4.8.30.NC-mgw          http://www.oracle.com/technology/software/products/berkeley-db/index.html\n \tBoost           \\boost-1.50.0-mgw          http://www.boost.org/users/download/\n \tminiupnpc       \\miniupnpc-1.6-mgw         http://miniupnp.tuxfamily.org/files/"
      },
      {
        "sha": "85d9faf1b3812d90573f72db830edd9e29c9f788",
        "filename": "src/qt/locale/bitcoin_ach.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ach.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ach.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ach.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "ee4575d6d39ceee555a0c4c8aefae7460ceef202",
        "filename": "src/qt/locale/bitcoin_af_ZA.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_af_ZA.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_af_ZA.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_af_ZA.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "3217044218f24e34529dad9f09e72e067d565814",
        "filename": "src/qt/locale/bitcoin_ar.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ar.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ar.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ar.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "5b9762e99b5d0f56867ed45d9d2e2e01d4366a68",
        "filename": "src/qt/locale/bitcoin_be_BY.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_be_BY.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_be_BY.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_be_BY.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "3cc34df68689348d99975c5ed1988f57a3f7e391",
        "filename": "src/qt/locale/bitcoin_bg.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_bg.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_bg.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_bg.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n \u0422\u043e\u0432\u0430 \u0435 \u0435\u043a\u0441\u043f\u0435\u0440\u0438\u043c\u0435\u043d\u0442\u0430\u043b\u0435\u043d \u0441\u043e\u0444\u0442\u0443\u0435\u0440.\n \n \u0420\u0430\u0437\u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u044f\u0432\u0430 \u0441\u0435 \u043f\u043e\u0434 MIT/X11 \u0441\u043e\u0444\u0442\u0443\u0435\u0440\u0435\u043d \u043b\u0438\u0446\u0435\u043d\u0437, \u0432\u0438\u0436 COPYING \u0438\u043b\u0438 http://www.opensource.org/licenses/mit-license.php.\n \n-\u0418\u0437\u043f\u043e\u043b\u0437\u0432\u0430\u043d \u0435 \u0441\u043e\u0444\u0442\u0443\u0435\u0440, \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0435\u043d \u043e\u0442 OpenSSL Project \u0437\u0430 \u0443\u043f\u043e\u0442\u0440\u0435\u0431\u0430 \u0432 OpenSSL Toolkit (http://www.openssl.org/), \u043a\u0440\u0438\u043f\u0442\u043e\u0433\u0440\u0430\u0444\u0441\u043a\u0438 \u0441\u043e\u0444\u0442\u0443\u0435\u0440 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0435\u043d \u043e\u0442 Eric Young (eay@cryptsoft.com) \u0438 UPnP \u0441\u043e\u0444\u0442\u0443\u0435\u0440 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0435\u043d \u043e\u0442 Thomas Bernard.</translation>\n+\u0418\u0437\u043f\u043e\u043b\u0437\u0432\u0430\u043d \u0435 \u0441\u043e\u0444\u0442\u0443\u0435\u0440, \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0435\u043d \u043e\u0442 OpenSSL Project \u0437\u0430 \u0443\u043f\u043e\u0442\u0440\u0435\u0431\u0430 \u0432 OpenSSL Toolkit (https://www.openssl.org/), \u043a\u0440\u0438\u043f\u0442\u043e\u0433\u0440\u0430\u0444\u0441\u043a\u0438 \u0441\u043e\u0444\u0442\u0443\u0435\u0440 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0435\u043d \u043e\u0442 Eric Young (eay@cryptsoft.com) \u0438 UPnP \u0441\u043e\u0444\u0442\u0443\u0435\u0440 \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0435\u043d \u043e\u0442 Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "2d9f4d6c3cb82a681ecf289541552bb503be4c33",
        "filename": "src/qt/locale/bitcoin_bs.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_bs.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_bs.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_bs.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "19a2070c52b3f28da9c0e1f1290b084fa8947df7",
        "filename": "src/qt/locale/bitcoin_ca.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ca.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ca.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ca.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "f335c5640e07653122851947bf73bb49c3277cea",
        "filename": "src/qt/locale/bitcoin_ca@valencia.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ca@valencia.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ca@valencia.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ca@valencia.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "1c6bc4cdbf03c9e264b98963084c94e7b26fe40c",
        "filename": "src/qt/locale/bitcoin_ca_ES.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ca_ES.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ca_ES.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ca_ES.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,8 +15,8 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n-        <translation>\\n Aquest \u00e9s software experimental.\\n\\n Distribu\u00eft sota llic\u00e8ncia de software MIT/11, veure l&apos;arxiu COPYING o http://www.opensource.org/licenses/mit-license.php.\\n\\nAquest producte inclou software desarrollat pel projecte OpenSSL per a l&apos;\u00fas de OppenSSL Toolkit (http://www.openssl.org/) i de softwqre criptogr\u00e0fic escrit per l&apos;Eric Young (eay@cryptsoft.com) i software UPnP escrit per en Thomas Bernard.</translation>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+        <translation>\\n Aquest \u00e9s software experimental.\\n\\n Distribu\u00eft sota llic\u00e8ncia de software MIT/11, veure l&apos;arxiu COPYING o http://www.opensource.org/licenses/mit-license.php.\\n\\nAquest producte inclou software desarrollat pel projecte OpenSSL per a l&apos;\u00fas de OppenSSL Toolkit (https://www.openssl.org/) i de softwqre criptogr\u00e0fic escrit per l&apos;Eric Young (eay@cryptsoft.com) i software UPnP escrit per en Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "75934f1e14a9267da85f6c74dbc067f1f2853ff6",
        "filename": "src/qt/locale/bitcoin_cmn.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_cmn.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_cmn.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_cmn.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "50ce61d213c70d9037464b68851bd65cf8d3de26",
        "filename": "src/qt/locale/bitcoin_cs.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_cs.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_cs.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_cs.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Tohle je experiment\u00e1ln\u00ed program.\n \n \u0160\u00ed\u0159en pod licenc\u00ed MIT/X11, viz p\u0159ilo\u017een\u00fd soubor COPYING nebo http://www.opensource.org/licenses/mit-license.php.\n \n-Tento produkt zahrnuje programy vyvinut\u00e9 OpenSSL Projektem pro pou\u017eit\u00ed v OpenSSL Toolkitu (http://www.openssl.org/) a kryptografick\u00fd program od Erika Younga (eay@cryptsoft.com) a program UPnP od Thomase Bernarda.</translation>\n+Tento produkt zahrnuje programy vyvinut\u00e9 OpenSSL Projektem pro pou\u017eit\u00ed v OpenSSL Toolkitu (https://www.openssl.org/) a kryptografick\u00fd program od Erika Younga (eay@cryptsoft.com) a program UPnP od Thomase Bernarda.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "0ec33ad742af2753eb071723c6250a8274a42d91",
        "filename": "src/qt/locale/bitcoin_cy.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_cy.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_cy.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_cy.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "4eb1125f37ef4ff3fd1ec016c891e90b72b6dee9",
        "filename": "src/qt/locale/bitcoin_da.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_da.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_da.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_da.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Dette program er eksperimentelt.\n \n Det er gjort tilg\u00e6ngeligt under MIT/X11-softwarelicensen. Se den medf\u00f8lgende fil &quot;COPYING&quot; eller http://www.opensource.org/licenses/mit-license.php.\n \n-Produktet indeholder software som er udviklet af OpenSSL Project til brug i OpenSSL Toolkit (http://www.openssl.org/), kryptografisk software skrevet af Eric Young (eay@cryptsoft.com) og UPnP-software skrevet af Thomas Bernard.</translation>\n+Produktet indeholder software som er udviklet af OpenSSL Project til brug i OpenSSL Toolkit (https://www.openssl.org/), kryptografisk software skrevet af Eric Young (eay@cryptsoft.com) og UPnP-software skrevet af Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "f3a773dc31fa4683463df98356d6d1d5f5daa6eb",
        "filename": "src/qt/locale/bitcoin_de.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_de.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_de.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_de.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Dies ist experimentelle Software.\n "
      },
      {
        "sha": "73a106dd0e987f3e33137012be9917d06a698c4b",
        "filename": "src/qt/locale/bitcoin_en.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_en.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_en.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_en.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -20,13 +20,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</translation>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</translation>\n     </message>\n     <message>\n         <location filename=\"../utilitydialog.cpp\" line=\"+29\"/>"
      },
      {
        "sha": "65ef493b6adb879b295835496f338057275145f9",
        "filename": "src/qt/locale/bitcoin_eo.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_eo.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_eo.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_eo.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Tio \u0109i estas eksperimenta programo.\n \n Eldonita la\u016d la permesilo MIT/X11. Vidu la kunan dosieron COPYING a\u016d http://www.opensource.org/licenses/mit-license.php.\n \n-Tiu \u0109i produkto enhavas erojn kreitajn de la &quot;OpenSSL Project&quot; por uzo en la &quot;OpenSSL Toolkit&quot; (http://www.openssl.org/) kaj \u0109ifrajn erojn kreitajn de Eric Young (eay@cryptsoft.com) kaj UPnP-erojn kreitajn de Thomas Bernard.</translation>\n+Tiu \u0109i produkto enhavas erojn kreitajn de la &quot;OpenSSL Project&quot; por uzo en la &quot;OpenSSL Toolkit&quot; (https://www.openssl.org/) kaj \u0109ifrajn erojn kreitajn de Eric Young (eay@cryptsoft.com) kaj UPnP-erojn kreitajn de Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "e4eca44e4d0c0680be85bdfd88786ca8b5e12cb3",
        "filename": "src/qt/locale/bitcoin_es.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_es.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_es.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_es.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,15 +15,15 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Este es un software experimental.\n \n Distribuido bajo la licencia MIT/X11, vea el archivo adjunto\n COPYING o http://www.opensource.org/licenses/mit-license.php.\n \n Este producto incluye software desarrollado por OpenSSL Project para su uso en\n-el OpenSSL Toolkit (http://www.openssl.org/) y software criptogr\u00e1fico escrito por\n+el OpenSSL Toolkit (https://www.openssl.org/) y software criptogr\u00e1fico escrito por\n Eric Young (eay@cryptsoft.com) y el software UPnP escrito por Thomas Bernard.</translation>\n     </message>\n     <message>"
      },
      {
        "sha": "96b37e6fd0d02d5ca9c583fc8c580fc2059a28c2",
        "filename": "src/qt/locale/bitcoin_es_CL.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_es_CL.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_es_CL.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_es_CL.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,15 +15,15 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Este es un software experimental.\n \n Distribuido bajo la licencia MIT/X11, vea el archivo adjunto\n COPYING o http://www.opensource.org/licenses/mit-license.php.\n \n Este producto incluye software desarrollado por OpenSSL Project para su uso en\n-el OpenSSL Toolkit (http://www.openssl.org/), software criptogr\u00e1fico escrito por\n+el OpenSSL Toolkit (https://www.openssl.org/), software criptogr\u00e1fico escrito por\n Eric Young (eay@cryptsoft.com) y UPnP software escrito por Thomas Bernard.</translation>\n     </message>\n     <message>"
      },
      {
        "sha": "d369955c4c37a1b267fb8b7a7c6f03a3d1a46a62",
        "filename": "src/qt/locale/bitcoin_es_DO.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_es_DO.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_es_DO.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_es_DO.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,15 +15,15 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Este es un software experimental.\n \n Distribuido bajo la licencia MIT/X11, vea el archivo adjunto\n COPYING o http://www.opensource.org/licenses/mit-license.php.\n \n Este producto incluye software desarrollado por OpenSSL Project para su uso en\n-el OpenSSL Toolkit (http://www.openssl.org/) y software criptogr\u00e1fico escrito por\n+el OpenSSL Toolkit (https://www.openssl.org/) y software criptogr\u00e1fico escrito por\n Eric Young (eay@cryptsoft.com) y el software UPnP escrito por Thomas Bernard.</translation>\n     </message>\n     <message>"
      },
      {
        "sha": "ad1fcc1b7346c29971c8676e42b605dc33a7f967",
        "filename": "src/qt/locale/bitcoin_es_MX.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_es_MX.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_es_MX.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_es_MX.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "b8e60cc86d83895e4dd532913a0b4360709c0c27",
        "filename": "src/qt/locale/bitcoin_es_UY.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_es_UY.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_es_UY.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_es_UY.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "52c0cef705e01fba754213eedcc17e15bd929684",
        "filename": "src/qt/locale/bitcoin_et.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_et.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_et.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_et.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\u23ce\n See on eksperimentaalne tarkvara.\u23ce\n \u23ce\n Levitatud MIT/X11 tarkvara litsentsi all, vaata kaasasolevat faili COPYING v\u00f5i http://www.opensource.org/licenses/mit-license.php\u23ce\n \u23ce\n-Toode sisaldab OpenSSL Projekti all toodetud tarkvara, mis on kasutamiseks OpenSSL Toolkitis (http://www.openssl.org/) ja Eric Young&apos;i poolt loodud kr\u00fcptograafilist tarkvara (eay@cryptsoft.com) ning Thomas Bernard&apos;i loodud UPnP tarkvara.</translation>\n+Toode sisaldab OpenSSL Projekti all toodetud tarkvara, mis on kasutamiseks OpenSSL Toolkitis (https://www.openssl.org/) ja Eric Young&apos;i poolt loodud kr\u00fcptograafilist tarkvara (eay@cryptsoft.com) ning Thomas Bernard&apos;i loodud UPnP tarkvara.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "6eb9aca3d7b0c5118c1584a1b67b471d9703360e",
        "filename": "src/qt/locale/bitcoin_eu_ES.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_eu_ES.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_eu_ES.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_eu_ES.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "43b5f5f263ad7959fff1c5af4395e58edec507e6",
        "filename": "src/qt/locale/bitcoin_fa.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_fa.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_fa.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fa.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,8 +15,8 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n-        <translation>\u23ce \u23ce \u0627\u06cc\u0646 \u06cc\u06a9 \u0646\u0631\u0645\u200c\u0627\u0641\u0632\u0627\u0631 \u0622\u0632\u0645\u0627\u06cc\u0634\u06cc \u0627\u0633\u062a\u23ce \u23ce \u0646\u0631\u0645 \u0627\u0641\u0632\u0627\u0631 \u062a\u062d\u062a \u0645\u062c\u0648\u0632 MIT/X11 \u0645\u0646\u062a\u0634\u0631 \u0634\u062f\u0647 \u0627\u0633\u062a. \u067e\u0631\u0648\u0646\u062f\u0647\u0654 COPYING \u06cc\u0627 \u0646\u0634\u0627\u0646\u06cc http://www.opensource.org/licenses/mit-license.php. \u0631\u0627 \u0628\u0628\u06cc\u0646\u06cc\u062f\u23ce \u23ce \u0627\u06cc\u0646 \u0645\u062d\u0635\u0648\u0644 \u0634\u0627\u0645\u0644 \u0646\u0631\u0645\u200c\u0627\u0641\u0632\u0627\u0631  \u062a\u0648\u0633\u0639\u0647 \u062f\u0627\u062f\u0647\u200c\u0634\u062f\u0647 \u062f\u0631 \u067e\u0631\u0648\u0698\u0647\u0654 OpenSSL \u0627\u0633\u062a. \u062f\u0631 \u0627\u06cc\u0646 \u0646\u0631\u0645\u200c\u0627\u0641\u0632\u0627\u0631 \u0627\u0632 OpenSSL Toolkit (http://www.openssl.org/) \u0648 \u0646\u0631\u0645\u200c\u0627\u0641\u0632\u0627\u0631 \u0631\u0645\u0632\u0646\u06af\u0627\u0631\u06cc \u0646\u0648\u0634\u062a\u0647 \u0634\u062f\u0647 \u062a\u0648\u0633\u0637 \u0627\u0631\u06cc\u06a9 \u06cc\u0627\u0646\u06af (eay@cryptsoft.com) \u0648 UPnP \u062a\u0648\u0633\u0637 \u062a\u0648\u0645\u0627\u0633 \u0628\u0631\u0646\u0627\u0631\u062f \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u0634\u062f\u0647 \u0627\u0633\u062a.</translation>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+        <translation>\u23ce \u23ce \u0627\u06cc\u0646 \u06cc\u06a9 \u0646\u0631\u0645\u200c\u0627\u0641\u0632\u0627\u0631 \u0622\u0632\u0645\u0627\u06cc\u0634\u06cc \u0627\u0633\u062a\u23ce \u23ce \u0646\u0631\u0645 \u0627\u0641\u0632\u0627\u0631 \u062a\u062d\u062a \u0645\u062c\u0648\u0632 MIT/X11 \u0645\u0646\u062a\u0634\u0631 \u0634\u062f\u0647 \u0627\u0633\u062a. \u067e\u0631\u0648\u0646\u062f\u0647\u0654 COPYING \u06cc\u0627 \u0646\u0634\u0627\u0646\u06cc http://www.opensource.org/licenses/mit-license.php. \u0631\u0627 \u0628\u0628\u06cc\u0646\u06cc\u062f\u23ce \u23ce \u0627\u06cc\u0646 \u0645\u062d\u0635\u0648\u0644 \u0634\u0627\u0645\u0644 \u0646\u0631\u0645\u200c\u0627\u0641\u0632\u0627\u0631  \u062a\u0648\u0633\u0639\u0647 \u062f\u0627\u062f\u0647\u200c\u0634\u062f\u0647 \u062f\u0631 \u067e\u0631\u0648\u0698\u0647\u0654 OpenSSL \u0627\u0633\u062a. \u062f\u0631 \u0627\u06cc\u0646 \u0646\u0631\u0645\u200c\u0627\u0641\u0632\u0627\u0631 \u0627\u0632 OpenSSL Toolkit (https://www.openssl.org/) \u0648 \u0646\u0631\u0645\u200c\u0627\u0641\u0632\u0627\u0631 \u0631\u0645\u0632\u0646\u06af\u0627\u0631\u06cc \u0646\u0648\u0634\u062a\u0647 \u0634\u062f\u0647 \u062a\u0648\u0633\u0637 \u0627\u0631\u06cc\u06a9 \u06cc\u0627\u0646\u06af (eay@cryptsoft.com) \u0648 UPnP \u062a\u0648\u0633\u0637 \u062a\u0648\u0645\u0627\u0633 \u0628\u0631\u0646\u0627\u0631\u062f \u0627\u0633\u062a\u0641\u0627\u062f\u0647 \u0634\u062f\u0647 \u0627\u0633\u062a.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "8b08948bee4986d04b34ebfae76a51bf7572729c",
        "filename": "src/qt/locale/bitcoin_fa_IR.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_fa_IR.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_fa_IR.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fa_IR.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "f42081f8c7d58d5d0ef0c8f7b3125d85ad765337",
        "filename": "src/qt/locale/bitcoin_fi.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_fi.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_fi.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fi.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n T\u00e4m\u00e4 on kokeellinen ohjelmisto.\n \n Levitet\u00e4\u00e4n MIT/X11 ohjelmistolisenssin alaisuudessa. Tarkemmat tiedot l\u00f6ytyv\u00e4t tiedostosta COPYING tai osoitteesta http://www.opensource.org/licenses/mit-license.php.\n \n-T\u00e4m\u00e4 ohjelma sis\u00e4lt\u00e4\u00e4 OpenSSL projektin OpenSSL ty\u00f6kalupakin (http://www.openssl.org/), Eric Youngin (eay@cryptsoft.com) kehitt\u00e4m\u00e4n salausohjelmiston sek\u00e4 Thomas Bernardin UPnP ohjelmiston.\n+T\u00e4m\u00e4 ohjelma sis\u00e4lt\u00e4\u00e4 OpenSSL projektin OpenSSL ty\u00f6kalupakin (https://www.openssl.org/), Eric Youngin (eay@cryptsoft.com) kehitt\u00e4m\u00e4n salausohjelmiston sek\u00e4 Thomas Bernardin UPnP ohjelmiston.\n </translation>\n     </message>\n     <message>"
      },
      {
        "sha": "c24e3ff6095d6db4e9cdeba2ffd4d63abe66d0c1",
        "filename": "src/qt/locale/bitcoin_fr.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_fr.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_fr.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fr.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n  Ce logiciel est exp\u00e9rimental.\n \n  Distribu\u00e9 sous licence logicielle MIT/X11, voir le fichier COPYING joint ou http://www.opensource.org/licenses/mit-license.php.\n \n- Ce produit comprend des logiciels d\u00e9velopp\u00e9s par le projet OpenSSL afin d&apos;\u00eatre utilis\u00e9s dans la bo\u00eete \u00e0 outils OpenSSL (http://www.openssl.org/), un logiciel de chiffrement \u00e9crit par Eric Young (eay@cryptsoft.com), et un logiciel UPnP d\u00e9velopp\u00e9 par Thomas Bernard.</translation>\n+ Ce produit comprend des logiciels d\u00e9velopp\u00e9s par le projet OpenSSL afin d&apos;\u00eatre utilis\u00e9s dans la bo\u00eete \u00e0 outils OpenSSL (https://www.openssl.org/), un logiciel de chiffrement \u00e9crit par Eric Young (eay@cryptsoft.com), et un logiciel UPnP d\u00e9velopp\u00e9 par Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "609eb497e52d9cf178e79c70d74c80af6e2c8d68",
        "filename": "src/qt/locale/bitcoin_fr_CA.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_fr_CA.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_fr_CA.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_fr_CA.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Ce logiciel est en phase exp\u00e9rimentale.\n \n Distribu\u00e9 sous licence MIT/X11, voir le fichier COPYING ou http://www.opensource.org/licenses/mit-license.php.\n \n-Ce produit comprend des logiciels d\u00e9velopp\u00e9s par le projet OpenSSL pour \u00eatre utilis\u00e9s dans la bo\u00eete \u00e0 outils OpenSSL (http://www.openssl.org/), un logiciel cryptographique \u00e9crit par Eric Young (eay@cryptsoft.com) et un logiciel UPnP \u00e9crit par Thomas Bernard.</translation>\n+Ce produit comprend des logiciels d\u00e9velopp\u00e9s par le projet OpenSSL pour \u00eatre utilis\u00e9s dans la bo\u00eete \u00e0 outils OpenSSL (https://www.openssl.org/), un logiciel cryptographique \u00e9crit par Eric Young (eay@cryptsoft.com) et un logiciel UPnP \u00e9crit par Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "0139fa6865aabc34d1ed40e2dcd154e4aaed3278",
        "filename": "src/qt/locale/bitcoin_gl.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_gl.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_gl.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_gl.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Isto \u00e9 software experimental.\n \n Distribu\u00eddo baixo a licencia de software MIT/X11, v\u00e9xase o arquivo que acompa\u00f1a COPYING ou http://www.opensource.org/licenses/mit-license.php.\n \n-Este produto incl\u00fae software desenvolvido polo OpenSSL Project para o uso no OpenSSL Toolkit (http://www.openssl.org/) e software criptogr\u00e1fico escrito por Eric Young (eay@cryptsoft.com) e software UPnP escrito por Thomas Bernard.</translation>\n+Este produto incl\u00fae software desenvolvido polo OpenSSL Project para o uso no OpenSSL Toolkit (https://www.openssl.org/) e software criptogr\u00e1fico escrito por Eric Young (eay@cryptsoft.com) e software UPnP escrito por Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "98b1db4c4395e4373b7cbb026e5852cb40fdb654",
        "filename": "src/qt/locale/bitcoin_gu_IN.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_gu_IN.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_gu_IN.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_gu_IN.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "72ef25c8b3780156a7a9d11d52147bbfceaa5245",
        "filename": "src/qt/locale/bitcoin_he.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_he.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_he.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_he.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n \u05d6\u05d5\u05d4\u05d9 \u05ea\u05d5\u05db\u05e0\u05d4 \u05e0\u05d9\u05e1\u05d9\u05d5\u05e0\u05d9\u05ea.\n \n \u05de\u05d5\u05e4\u05e6\u05ea \u05ea\u05d7\u05ea \u05e8\u05d9\u05e9\u05d9\u05d5\u05df \u05d4\u05ea\u05d5\u05db\u05e0\u05d4 MIT/X11, \u05e8\u05d0\u05d4 \u05d0\u05ea \u05d4\u05e7\u05d5\u05d1\u05e5 \u05d4\u05de\u05e6\u05d5\u05e8\u05e3 COPYING \u05d0\u05d5 http://www.opensource.org/licenses/mit-license.php.\n \n-\u05d4\u05de\u05d5\u05e6\u05e8 \u05d4\u05d6\u05d4 \u05db\u05d5\u05dc\u05dc \u05ea\u05d5\u05db\u05e0\u05d4 \u05e9\u05e4\u05d5\u05ea\u05d7\u05d4 \u05e2&quot;\u05d9 \u05e4\u05e8\u05d5\u05d9\u05e7\u05d8 OpenSSL \u05dc\u05e9\u05d9\u05de\u05d5\u05e9 \u05d1\u05ea\u05d9\u05d1\u05ea \u05d4\u05db\u05dc\u05d9\u05dd OpenSSL (http://www.openssl.org/) \u05d5\u05ea\u05d5\u05db\u05e0\u05d4 \u05e7\u05e8\u05d9\u05e4\u05d8\u05d5\u05d2\u05e8\u05e4\u05d9\u05ea \u05e9\u05e0\u05db\u05ea\u05d1\u05d4 \u05e2&quot;\u05d9 \u05d0\u05e8\u05d9\u05e7 \u05d9\u05d0\u05e0\u05d2 (eay@cryptsoft.com) \u05d5\u05ea\u05d5\u05db\u05e0\u05ea UPnP \u05e9\u05e0\u05db\u05ea\u05d1\u05d4 \u05e2&quot;\u05d9 \u05ea\u05d5\u05de\u05e1 \u05d1\u05e8\u05e0\u05e8\u05d3.</translation>\n+\u05d4\u05de\u05d5\u05e6\u05e8 \u05d4\u05d6\u05d4 \u05db\u05d5\u05dc\u05dc \u05ea\u05d5\u05db\u05e0\u05d4 \u05e9\u05e4\u05d5\u05ea\u05d7\u05d4 \u05e2&quot;\u05d9 \u05e4\u05e8\u05d5\u05d9\u05e7\u05d8 OpenSSL \u05dc\u05e9\u05d9\u05de\u05d5\u05e9 \u05d1\u05ea\u05d9\u05d1\u05ea \u05d4\u05db\u05dc\u05d9\u05dd OpenSSL (https://www.openssl.org/) \u05d5\u05ea\u05d5\u05db\u05e0\u05d4 \u05e7\u05e8\u05d9\u05e4\u05d8\u05d5\u05d2\u05e8\u05e4\u05d9\u05ea \u05e9\u05e0\u05db\u05ea\u05d1\u05d4 \u05e2&quot;\u05d9 \u05d0\u05e8\u05d9\u05e7 \u05d9\u05d0\u05e0\u05d2 (eay@cryptsoft.com) \u05d5\u05ea\u05d5\u05db\u05e0\u05ea UPnP \u05e9\u05e0\u05db\u05ea\u05d1\u05d4 \u05e2&quot;\u05d9 \u05ea\u05d5\u05de\u05e1 \u05d1\u05e8\u05e0\u05e8\u05d3.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "13f3c5fbfe9d769ad294b3d16760291645861ff9",
        "filename": "src/qt/locale/bitcoin_hi_IN.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_hi_IN.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_hi_IN.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_hi_IN.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "8621c4be4031107f26fdd1d2605aa1f320d58a68",
        "filename": "src/qt/locale/bitcoin_hr.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_hr.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_hr.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_hr.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "5b80135a4542dab5bed13bc1ac634503e76391cb",
        "filename": "src/qt/locale/bitcoin_hu.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_hu.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_hu.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_hu.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,12 +15,12 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Ez egy k\u00eds\u00e9rleti program.\n MIT/X11 szoftverlicenc alatt kiadva, l\u00e1sd a mell\u00e9kelt f\u00e1jlt COPYING vagy http://www.opensource.org/licenses/mit-license.php.\n \n-Ez a term\u00e9k az OpenSSL Project \u00e1ltal lett kifejlesztve az OpenSSL Toolkit (http://www.openssl.org/) \u00e9s kriptogr\u00e1fiai szoftvertben val\u00f3 felhaszn\u00e1l\u00e1sra,  \u00edrta Eric Young (eay@cryptsoft.com) \u00e9s UPnP szoftver, \u00edrta Thomas Bernard.</translation>\n+Ez a term\u00e9k az OpenSSL Project \u00e1ltal lett kifejlesztve az OpenSSL Toolkit (https://www.openssl.org/) \u00e9s kriptogr\u00e1fiai szoftvertben val\u00f3 felhaszn\u00e1l\u00e1sra,  \u00edrta Eric Young (eay@cryptsoft.com) \u00e9s UPnP szoftver, \u00edrta Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "a2a71e97f550a85a63508c5928d980bf4c3ab756",
        "filename": "src/qt/locale/bitcoin_id_ID.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_id_ID.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_id_ID.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_id_ID.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Software ini adalah yang bersifat percobaan.\n \n Dibagikan dengan izin software MIT/X11, bacalah arsip COPYING atau  http://www.opensource.org/licenses/mit-license.php.\n \n-Produk ini termasuk software yang dibangun oleh Proyek OpenSSL untuk Toolkit OpenSSL (http://www.openssl.org/) dan software kriptografi dibangun oleh Eric Young (eay@cryptsoft.com) dan software UPnP dibangun oleh Thomas Bernard.</translation>\n+Produk ini termasuk software yang dibangun oleh Proyek OpenSSL untuk Toolkit OpenSSL (https://www.openssl.org/) dan software kriptografi dibangun oleh Eric Young (eay@cryptsoft.com) dan software UPnP dibangun oleh Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "a7faa9cfeaab8af834bd8047619395fb156e24ee",
        "filename": "src/qt/locale/bitcoin_it.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_it.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_it.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_it.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Questo \u00e8 un software sperimentale.\n \n Distribuito sotto la licenza software MIT/X11, vedi il file COPYING incluso oppure su http://www.opensource.org/licenses/mit-license.php.\n \n-Questo prodotto include software sviluppato dal progetto OpenSSL per l&apos;uso del Toolkit OpenSSL (http://www.openssl.org/), software crittografico scritto da Eric Young (eay@cryptsoft.com) e software UPnP scritto da Thomas Bernard.</translation>\n+Questo prodotto include software sviluppato dal progetto OpenSSL per l&apos;uso del Toolkit OpenSSL (https://www.openssl.org/), software crittografico scritto da Eric Young (eay@cryptsoft.com) e software UPnP scritto da Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "ecff3ab9dade4a938e93ff1019cb69760f1e3e4a",
        "filename": "src/qt/locale/bitcoin_ja.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ja.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ja.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ja.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n \u3053\u308c\u306f\u5b9f\u9a13\u7684\u306a\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u3067\u3059\u3002\n \n MIT/X11 \u30bd\u30d5\u30c8\u30a6\u30a7\u30a2 \u30e9\u30a4\u30bb\u30f3\u30b9\u306e\u4e0b\u3067\u914d\u5e03\u3055\u308c\u3066\u3044\u307e\u3059\u3002\u8a73\u3057\u304f\u306f\u6dfb\u4ed8\u306e COPYING \u30d5\u30a1\u30a4\u30eb\u3084http://www.opensource.org/licenses/mit-license.php \u3092\u53c2\u7167\u3057\u3066\u304f\u3060\u3055\u3044\u3002\n \n-\u3053\u306e\u88fd\u54c1\u306f OpenSSL Toolkit (http://www.openssl.org/) \u306b\u7528\u3044\u3089\u308c\u308b  Eric Young (eay@cryptsoft.com)  \u304c\u958b\u767a\u3057\u305f\u6697\u53f7\u5316\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u3068 Thomas Bernard \u304c\u958b\u767a\u3057\u305f UPnP \u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u3092\u542b\u3093\u3067\u3044\u307e\u3059\u3002</translation>\n+\u3053\u306e\u88fd\u54c1\u306f OpenSSL Toolkit (https://www.openssl.org/) \u306b\u7528\u3044\u3089\u308c\u308b  Eric Young (eay@cryptsoft.com)  \u304c\u958b\u767a\u3057\u305f\u6697\u53f7\u5316\u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u3068 Thomas Bernard \u304c\u958b\u767a\u3057\u305f UPnP \u30bd\u30d5\u30c8\u30a6\u30a7\u30a2\u3092\u542b\u3093\u3067\u3044\u307e\u3059\u3002</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "4b1ca3fad0354a7bef25bb32860d8388d2cccf46",
        "filename": "src/qt/locale/bitcoin_ka.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ka.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ka.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ka.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n \u10de\u10e0\u10dd\u10d2\u10e0\u10d0\u10db\u10d0 \u10d4\u10e5\u10e1\u10de\u10d4\u10e0\u10d8\u10db\u10d4\u10dc\u10e2\u10e3\u10da\u10d8\u10d0.\n \n \u10d5\u10e0\u10ea\u10d4\u10da\u10d3\u10d4\u10d1\u10d0 MIT/X11 \u10da\u10d8\u10ea\u10d4\u10dc\u10d6\u10d8\u10d8\u10d7, \u10d8\u10ee\u10d8\u10da\u10d4 \u10d7\u10d0\u10dc\u10d3\u10d0\u10e0\u10d7\u10e3\u10da\u10d8 \u10e4\u10d0\u10d8\u10da\u10d8 COPYING \u10d0\u10dc http://www.opensource.org/licenses/mit-license.php.\n \n-\u10de\u10e0\u10dd\u10d3\u10e3\u10e5\u10e2\u10d8 \u10e8\u10d4\u10d8\u10ea\u10d0\u10d5\u10e1 OpenSSL \u10de\u10e0\u10dd\u10d4\u10e5\u10e2\u10d8\u10e1 \u10e4\u10d0\u10e0\u10d2\u10da\u10d4\u10d1\u10e8\u10d8 \u10e8\u10d4\u10db\u10e3\u10e8\u10d0\u10d5\u10d4\u10d1\u10e3\u10da \u10de\u10e0\u10dd\u10d2\u10e0\u10d0\u10db\u10e3\u10da \u10e3\u10d6\u10e0\u10e3\u10dc\u10d5\u10d4\u10da\u10e7\u10dd\u10e4\u10d0\u10e1 OpenSSL Toolkit-\u10e8\u10d8 \u10d2\u10d0\u10db\u10dd\u10e7\u10d4\u10dc\u10d4\u10d1\u10d8\u10e1\u10d0\u10d7\u10d5\u10d8\u10e1 (http://www.openssl.org/), \u10d9\u10e0\u10d8\u10de\u10e2\u10dd\u10d2\u10e0\u10d0\u10e4\u10d8\u10e3\u10da \u10de\u10e0\u10dd\u10d2\u10e0\u10d0\u10db\u10d0\u10e1, \u10d0\u10d5\u10e2\u10dd\u10e0\u10d8 \u10d4\u10e0\u10d8\u10e5 \u10d8\u10d0\u10dc\u10d2\u10d8 (Eric Young, eay@cryptsoft.com) \u10d3\u10d0 UPnP-\u10de\u10e0\u10dd\u10d2\u10e0\u10d0\u10db\u10d0\u10e1, \u10d0\u10d5\u10e2\u10dd\u10e0\u10d8 \u10d7\u10dd\u10db\u10d0\u10e1 \u10d1\u10d4\u10e0\u10dc\u10d0\u10e0\u10d3\u10d8 (Thomas Bernard).</translation>\n+\u10de\u10e0\u10dd\u10d3\u10e3\u10e5\u10e2\u10d8 \u10e8\u10d4\u10d8\u10ea\u10d0\u10d5\u10e1 OpenSSL \u10de\u10e0\u10dd\u10d4\u10e5\u10e2\u10d8\u10e1 \u10e4\u10d0\u10e0\u10d2\u10da\u10d4\u10d1\u10e8\u10d8 \u10e8\u10d4\u10db\u10e3\u10e8\u10d0\u10d5\u10d4\u10d1\u10e3\u10da \u10de\u10e0\u10dd\u10d2\u10e0\u10d0\u10db\u10e3\u10da \u10e3\u10d6\u10e0\u10e3\u10dc\u10d5\u10d4\u10da\u10e7\u10dd\u10e4\u10d0\u10e1 OpenSSL Toolkit-\u10e8\u10d8 \u10d2\u10d0\u10db\u10dd\u10e7\u10d4\u10dc\u10d4\u10d1\u10d8\u10e1\u10d0\u10d7\u10d5\u10d8\u10e1 (https://www.openssl.org/), \u10d9\u10e0\u10d8\u10de\u10e2\u10dd\u10d2\u10e0\u10d0\u10e4\u10d8\u10e3\u10da \u10de\u10e0\u10dd\u10d2\u10e0\u10d0\u10db\u10d0\u10e1, \u10d0\u10d5\u10e2\u10dd\u10e0\u10d8 \u10d4\u10e0\u10d8\u10e5 \u10d8\u10d0\u10dc\u10d2\u10d8 (Eric Young, eay@cryptsoft.com) \u10d3\u10d0 UPnP-\u10de\u10e0\u10dd\u10d2\u10e0\u10d0\u10db\u10d0\u10e1, \u10d0\u10d5\u10e2\u10dd\u10e0\u10d8 \u10d7\u10dd\u10db\u10d0\u10e1 \u10d1\u10d4\u10e0\u10dc\u10d0\u10e0\u10d3\u10d8 (Thomas Bernard).</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "7daf2f4e6f821abee12a517a4879db3e4ca61a0a",
        "filename": "src/qt/locale/bitcoin_kk_KZ.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_kk_KZ.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_kk_KZ.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_kk_KZ.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "803a93203e61526c1aeee7b3cfc4607bcdc30725",
        "filename": "src/qt/locale/bitcoin_ko_KR.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ko_KR.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ko_KR.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ko_KR.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n \uc774 \ud504\ub85c\uadf8\ub7a8\uc740 \uc2dc\ud5d8\uc6a9\uc785\ub2c8\ub2e4.\n \n MIT/X11 \ud504\ub85c\uadf8\ub7a8 \ub77c\uc774\uc120\uc2a4\uc5d0 \ub530\ub77c \ubc30\ud3ec\ud569\ub2c8\ub2e4. COPYING \ub610\ub294 http://www.opensource.org/licenses/mit-license.php\ub97c \ucc38\uc870\ud558\uc2ed\uc2dc\uc624.\n \n-\uc774 \ud504\ub85c\uadf8\ub7a8\uc5d0\ub294 OpenSSL \ud234\ud0b7(http://www.openssl.org) \uc0ac\uc6a9 \ubaa9\uc801\uc73c\ub85c \uac1c\ubc1c\ud55c OpenSSL \ud504\ub85c\uc81d\ud2b8\ub97c \ud3ec\ud568\ud558\uace0 \uc788\uc73c\uba70, \uc554\ud638\ud654 \ud504\ub85c\uadf8\ub7a8\uc740 Eric Young(eay@cryptsoft.com)\uc774, UPnP \ud504\ub85c\uadf8\ub7a8\uc740 Thomas Bernard\uac00 \uc791\uc131\ud588\uc2b5\ub2c8\ub2e4.</translation>\n+\uc774 \ud504\ub85c\uadf8\ub7a8\uc5d0\ub294 OpenSSL \ud234\ud0b7(https://www.openssl.org) \uc0ac\uc6a9 \ubaa9\uc801\uc73c\ub85c \uac1c\ubc1c\ud55c OpenSSL \ud504\ub85c\uc81d\ud2b8\ub97c \ud3ec\ud568\ud558\uace0 \uc788\uc73c\uba70, \uc554\ud638\ud654 \ud504\ub85c\uadf8\ub7a8\uc740 Eric Young(eay@cryptsoft.com)\uc774, UPnP \ud504\ub85c\uadf8\ub7a8\uc740 Thomas Bernard\uac00 \uc791\uc131\ud588\uc2b5\ub2c8\ub2e4.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "bcf42b1b61d42c6914cfd674421f1f0d9ca336d5",
        "filename": "src/qt/locale/bitcoin_ky.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ky.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ky.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ky.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "1337b2492277b88887900380d0762791223eaf79",
        "filename": "src/qt/locale/bitcoin_la.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_la.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_la.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_la.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,12 +15,12 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>Hoc est experimentale programma.\n \n Distributum sub MIT/X11 licentia programmatum, vide comitantem plicam COPYING vel http://www.opensource.org/licenses/mit-license.php.\n \n-Hoc productum continet programmata composita ab OpenSSL Project pro utendo in OpenSSL Toolkit (http://www.openssl.org/) et programmata cifrarum scripta ab Eric Young (eay@cryptsoft.com) et UPnP programmata scripta ab Thomas Bernard.</translation>\n+Hoc productum continet programmata composita ab OpenSSL Project pro utendo in OpenSSL Toolkit (https://www.openssl.org/) et programmata cifrarum scripta ab Eric Young (eay@cryptsoft.com) et UPnP programmata scripta ab Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "2ce2a439c8bfdeee6cdfd8620edb9e48742c29ac",
        "filename": "src/qt/locale/bitcoin_lt.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_lt.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_lt.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_lt.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,12 +15,12 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>Tai eksperimentin\u0117 programa.\n \n Platinama pagal MIT/X11 licencij\u0105, kuri\u0105 rasite faile COPYING arba http://www.opensource.org/licenses/mit-license.php.\n \n-\u0160iame produkte yra OpenSSL projekto kuriamas OpenSSL Toolkit (http://www.openssl.org/), Eric Young para\u0161yta kriptografin\u0117 programin\u0117 \u012franga bei Thomas Bernard sukurta UPnP programin\u0117 \u012franga.</translation>\n+\u0160iame produkte yra OpenSSL projekto kuriamas OpenSSL Toolkit (https://www.openssl.org/), Eric Young para\u0161yta kriptografin\u0117 programin\u0117 \u012franga bei Thomas Bernard sukurta UPnP programin\u0117 \u012franga.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "e6fefb56294f5f3d836135643e4991ca2dd46a49",
        "filename": "src/qt/locale/bitcoin_lv_LV.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_lv_LV.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_lv_LV.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_lv_LV.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n \u0160\u012b ir eksperiment\u0101l\u0101 programmat\u016bra.\n \n Izplat\u012bta saska\u0146\u0101 ar MIT/X11 programmat\u016bras licenci, skat\u012bt pievienoto datni COPYING vai http://www.opensource.org/licenses/mit-license.php.\n \n-\u0160is produkts ietver programmat\u016bru, ko izstr\u0101d\u0101jis OpenSSL Project izmanto\u0161anai OpenSSL Toolkit (http://www.openssl.org/) un \u0161ifr\u0113\u0161anas programmat\u016bru no Eric Young (eay@cryptsoft.com) un UPnP programmat\u016bru no Thomas Bernard.</translation>\n+\u0160is produkts ietver programmat\u016bru, ko izstr\u0101d\u0101jis OpenSSL Project izmanto\u0161anai OpenSSL Toolkit (https://www.openssl.org/) un \u0161ifr\u0113\u0161anas programmat\u016bru no Eric Young (eay@cryptsoft.com) un UPnP programmat\u016bru no Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "c94510756e50bf236206d299b4104a8127d2a0ef",
        "filename": "src/qt/locale/bitcoin_mn.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_mn.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_mn.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_mn.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "08d7593b529516c63f29da057f0275e4857b7585",
        "filename": "src/qt/locale/bitcoin_ms_MY.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ms_MY.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ms_MY.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ms_MY.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "55aa6d9cf764eaddf1b539a8121faad85e77a79a",
        "filename": "src/qt/locale/bitcoin_nb.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_nb.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_nb.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_nb.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Dette er eksperimentell programvare.\n \n Distribuert under MIT/X11 programvarelisensen, se medf\u00f8lgende fil COPYING eller http://www.opensource.org/licenses/mit-license.php.\n \n-Dette produktet inneholder programvare utviklet av OpenSSL Project for bruk i OpenSSL Toolkit (http://www.openssl.org/), kryptografisk programvare skrevet av Eric Young (eay@cryptsoft.com) og UPnP programvare skrevet av Thomas Bernard.</translation>\n+Dette produktet inneholder programvare utviklet av OpenSSL Project for bruk i OpenSSL Toolkit (https://www.openssl.org/), kryptografisk programvare skrevet av Eric Young (eay@cryptsoft.com) og UPnP programvare skrevet av Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "d6b6b8a3ce31235478ce480d04a591f49560a290",
        "filename": "src/qt/locale/bitcoin_nl.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_nl.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_nl.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_nl.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Dit is experimentele software.\n \n Gedistribueerd onder de MIT/X11 software licentie, zie het bijgevoegde bestand COPYING of http://www.opensource.org/licenses/mit-license.php.\n \n-Dit product bevat software ontwikkeld door het OpenSSL Project voor gebruik in de OpenSSL Toolkit (http://www.openssl.org/) en cryptografische software gemaakt door Eric Young (eay@cryptsoft.com) en UPnP software geschreven door Thomas Bernard.</translation>\n+Dit product bevat software ontwikkeld door het OpenSSL Project voor gebruik in de OpenSSL Toolkit (https://www.openssl.org/) en cryptografische software gemaakt door Eric Young (eay@cryptsoft.com) en UPnP software geschreven door Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "3e71782c1c186e707b5258b1cb43f8887ce11dc5",
        "filename": "src/qt/locale/bitcoin_pam.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_pam.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_pam.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_pam.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,11 +15,11 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Metung ya ining experimental software.\n Me-distribute ya lalam na ning lisensya na ning MIT/X11 software, lawan ye ing makayabeng file COPYING o http://www.opensource.org/licenses/mit-license.php.\n-Ing produktung ini atin yang makayabeng software a gewa dareng OpenSSL Project para gamit king OpenSSL Toolkit(http://www.openssl.org/) at cryptographic software a sinulat ng Eric Young (eay@cryptsoft.com) at UPnp software a sinulat ng Thomas Bernard.</translation>\n+Ing produktung ini atin yang makayabeng software a gewa dareng OpenSSL Project para gamit king OpenSSL Toolkit(https://www.openssl.org/) at cryptographic software a sinulat ng Eric Young (eay@cryptsoft.com) at UPnp software a sinulat ng Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "66075874bc5725444538c46e58b271f0e99be8a3",
        "filename": "src/qt/locale/bitcoin_pl.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_pl.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_pl.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_pl.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Oprogramowanie eksperymentalne.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</translation>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "862f4479051e8b5e32e70dadbf63068d6308aab9",
        "filename": "src/qt/locale/bitcoin_pt_BR.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_pt_BR.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_pt_BR.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_pt_BR.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\u23ce\n Este \u00e9 um software experimental.\u23ce\n \u23ce\n Distribuido sob a licen\u00e7a de software MIT/X11, veja o arquivo anexo COPYING ou http://www.opensource.org/licenses/mit-license.php.\u23ce\n \u23ce\n-Este produto inclui software desenvolvido pelo Projeto OpenSSL para uso no OpenSSL Toolkit (http://www.openssl.org/), software de criptografia escrito por Eric Young (eay@cryptsoft.com) e sofware UPnP escrito por Thomas Bernard.</translation>\n+Este produto inclui software desenvolvido pelo Projeto OpenSSL para uso no OpenSSL Toolkit (https://www.openssl.org/), software de criptografia escrito por Eric Young (eay@cryptsoft.com) e sofware UPnP escrito por Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "aa3b7078d377bc8ad304bbd17795bcf2273f9502",
        "filename": "src/qt/locale/bitcoin_pt_PT.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_pt_PT.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_pt_PT.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_pt_PT.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Este \u00e9 um programa experimental.\n \n Distribu\u00eddo sob uma licen\u00e7a de software MIT/X11, por favor verifique o ficheiro anexo license.txt ou http://www.opensource.org/licenses/mit-license.php.\n \n-Este produto inclui software desenvolvido pelo Projecto OpenSSL para uso no OpenSSL Toolkit (http://www.openssl.org/), software criptogr\u00e1fico escrito por Eric Young (eay@cryptsoft.com) e software UPnP escrito por Thomas Bernard.</translation>\n+Este produto inclui software desenvolvido pelo Projecto OpenSSL para uso no OpenSSL Toolkit (https://www.openssl.org/), software criptogr\u00e1fico escrito por Eric Young (eay@cryptsoft.com) e software UPnP escrito por Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "8fde291d2b571382a78ac92455b95903d1c88c51",
        "filename": "src/qt/locale/bitcoin_ro_RO.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ro_RO.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ro_RO.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ro_RO.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Acesta este un program experimental.\n \n Distribuit sub licen\u021ba de programe MIT/X11, vezi fi\u0219ierul \u00eenso\u021bitor COPYING sau http://www.opensource.org/licenses/mit-license.php.\n \n-Acest produs include programe dezvoltate de c\u0103tre OpenSSL Project pentru a fi folosite \u00een OpenSSL Toolkit (http://www.openssl.org/) \u0219i programe criptografice scrise de c\u0103tre Eric Young (eay@cryptsoft.com) \u0219i programe UPnP scrise de c\u0103tre Thomas Bernard.</translation>\n+Acest produs include programe dezvoltate de c\u0103tre OpenSSL Project pentru a fi folosite \u00een OpenSSL Toolkit (https://www.openssl.org/) \u0219i programe criptografice scrise de c\u0103tre Eric Young (eay@cryptsoft.com) \u0219i programe UPnP scrise de c\u0103tre Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "01040bf882d9e14c40cec12a8f22d3688cda282a",
        "filename": "src/qt/locale/bitcoin_ru.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ru.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ru.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ru.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n \u042d\u0442\u043e \u044d\u043a\u0441\u043f\u0435\u0440\u0438\u043c\u0435\u043d\u0442\u0430\u043b\u044c\u043d\u0430\u044f \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043c\u0430.\n \n \u0420\u0430\u0441\u043f\u0440\u043e\u0441\u0442\u0440\u0430\u043d\u044f\u0435\u0442\u0441\u044f \u043d\u0430 \u043f\u0440\u0430\u0432\u0430\u0445 \u043b\u0438\u0446\u0435\u043d\u0437\u0438\u0438 MIT/X11, \u0441\u043c. \u0444\u0430\u0439\u043b license.txt \u0438\u043b\u0438 http://www.opensource.org/licenses/mit-license.php.\n \n-\u042d\u0442\u043e\u0442 \u043f\u0440\u043e\u0434\u0443\u043a\u0442 \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u041f\u041e, \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u043d\u043e\u0435 OpenSSL Project \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432 OpenSSL Toolkit (http://www.openssl.org/) \u0438 \u043a\u0440\u0438\u043f\u0442\u043e\u0433\u0440\u0430\u0444\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u041f\u041e, \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u043d\u043e\u0435 Eric Young (eay@cryptsoft.com) \u0438 \u041f\u041e \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 UPnP, \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u043d\u043e\u0435 Thomas Bernard.</translation>\n+\u042d\u0442\u043e\u0442 \u043f\u0440\u043e\u0434\u0443\u043a\u0442 \u0432\u043a\u043b\u044e\u0447\u0430\u0435\u0442 \u041f\u041e, \u0440\u0430\u0437\u0440\u0430\u0431\u043e\u0442\u0430\u043d\u043d\u043e\u0435 OpenSSL Project \u0434\u043b\u044f \u0438\u0441\u043f\u043e\u043b\u044c\u0437\u043e\u0432\u0430\u043d\u0438\u044f \u0432 OpenSSL Toolkit (https://www.openssl.org/) \u0438 \u043a\u0440\u0438\u043f\u0442\u043e\u0433\u0440\u0430\u0444\u0438\u0447\u0435\u0441\u043a\u043e\u0435 \u041f\u041e, \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u043d\u043e\u0435 Eric Young (eay@cryptsoft.com) \u0438 \u041f\u041e \u0434\u043b\u044f \u0440\u0430\u0431\u043e\u0442\u044b \u0441 UPnP, \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u043d\u043e\u0435 Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "3ba49ced626bd46e7c62886f30756c9714fe4afc",
        "filename": "src/qt/locale/bitcoin_sah.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_sah.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_sah.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_sah.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "158fc7a75ee1e958d3830fc4ba9b32aa08fa19d4",
        "filename": "src/qt/locale/bitcoin_sk.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_sk.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_sk.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_sk.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Toto je experiment\u00e1lny softv\u00e9r.\n \n Distribuovan\u00fd pod MIT/X11 softv\u00e9rovou licenciou, vi\u010f sprev\u00e1dzaj\u00faci s\u00fabor COPYING alebo http://www.opensource.org/licenses/mit-license.php.\n \n-Tento v\u00fdrobok obsahuje sofv\u00e9r, ktor\u00fd vyvynul OpenSSL Project pre pou\u017eitie v OpenSSL Toolkit (http://www.openssl.org/) a kryptografick\u00fd softv\u00e9r nap\u00edsan\u00fd Ericom Youngom (eay@cryptsoft.com) a UPnP softv\u00e9r nap\u00edsan\u00fd Thomasom Bernardom.</translation>\n+Tento v\u00fdrobok obsahuje sofv\u00e9r, ktor\u00fd vyvynul OpenSSL Project pre pou\u017eitie v OpenSSL Toolkit (https://www.openssl.org/) a kryptografick\u00fd softv\u00e9r nap\u00edsan\u00fd Ericom Youngom (eay@cryptsoft.com) a UPnP softv\u00e9r nap\u00edsan\u00fd Thomasom Bernardom.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "d7adda351940c865203045754aa96a7c45a31058",
        "filename": "src/qt/locale/bitcoin_sl_SI.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_sl_SI.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_sl_SI.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_sl_SI.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "c8daeac7fbb0a8f196dc03a8f45969d2892de16e",
        "filename": "src/qt/locale/bitcoin_sq.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_sq.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_sq.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_sq.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "8d7e93c289e17e428c64e2ed5d60f14035e5b4fb",
        "filename": "src/qt/locale/bitcoin_sr.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_sr.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_sr.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_sr.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "de063a7af9d01b07fc300be607f57f1461937ea2",
        "filename": "src/qt/locale/bitcoin_sv.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_sv.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_sv.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_sv.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,14 +15,14 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n Detta \u00e4r experimentell mjukvara.\n \n \n Distribuerad under mjukvarulicensen MIT/X11, se den medf\u00f6ljande filen COPYING eller http://www.opensource.org/licenses/mit-license.php.\n \n-Denna produkten inneh\u00e5ller mjukvara utvecklad av OpenSSL Project f\u00f6r anv\u00e4ndning i OpenSSL Toolkit (http://www.openssl.org/) och kryptografisk mjukvara utvecklad av Eric Young (eay@cryptsoft.com) samt UPnP-mjukvara skriven av Thomas Bernard.</translation>\n+Denna produkten inneh\u00e5ller mjukvara utvecklad av OpenSSL Project f\u00f6r anv\u00e4ndning i OpenSSL Toolkit (https://www.openssl.org/) och kryptografisk mjukvara utvecklad av Eric Young (eay@cryptsoft.com) samt UPnP-mjukvara skriven av Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "3b11bf120bffa7ae5920021b9de884a379fbcaf1",
        "filename": "src/qt/locale/bitcoin_th_TH.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_th_TH.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_th_TH.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_th_TH.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "5b2abb71cb63d5facaaba01c4d3a6b2d3d7cfdd4",
        "filename": "src/qt/locale/bitcoin_tr.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_tr.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_tr.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_tr.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n  Bu yaz\u0131l\u0131m deneme safhas\u0131ndad\u0131r.\n \n  MIT/X11 yaz\u0131l\u0131m lisans\u0131 kapsam\u0131nda yay\u0131nlanm\u0131\u015ft\u0131r, COPYING dosyas\u0131na ya da http://www.opensource.org/licenses/mit-license.php sayfas\u0131na bak\u0131n\u0131z.\n \n- Bu \u00fcr\u00fcn OpenSSL projesi taraf\u0131ndan OpenSSL ara\u00e7 tak\u0131m\u0131 (http://www.openssl.org/) i\u00e7in geli\u015ftirilen yaz\u0131l\u0131mlar, Eric Young (eay@cryptsoft.com) taraf\u0131ndan haz\u0131rlanm\u0131\u015f \u015fifreleme yaz\u0131l\u0131mlar\u0131 ve Thomas Bernard taraf\u0131ndan programlanm\u0131\u015f UPnP yaz\u0131l\u0131m\u0131 i\u00e7erir.</translation>\n+ Bu \u00fcr\u00fcn OpenSSL projesi taraf\u0131ndan OpenSSL ara\u00e7 tak\u0131m\u0131 (https://www.openssl.org/) i\u00e7in geli\u015ftirilen yaz\u0131l\u0131mlar, Eric Young (eay@cryptsoft.com) taraf\u0131ndan haz\u0131rlanm\u0131\u015f \u015fifreleme yaz\u0131l\u0131mlar\u0131 ve Thomas Bernard taraf\u0131ndan programlanm\u0131\u015f UPnP yaz\u0131l\u0131m\u0131 i\u00e7erir.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "4440b6be039e6459f0e39a92f971933b9ebcb923",
        "filename": "src/qt/locale/bitcoin_uk.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_uk.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_uk.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_uk.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n \u0426\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043d\u0435 \u0437\u0430\u0431\u0435\u0437\u043f\u0435\u0447\u0435\u043d\u043d\u044f \u0454 \u0435\u043a\u0441\u043f\u0435\u0440\u0438\u043c\u0435\u043d\u0442\u0430\u043b\u044c\u043d\u0438\u043c.\n \n \u041f\u043e\u0448\u0438\u0440\u044e\u0454\u0442\u044c\u0441\u044f \u0437\u0430 \u043b\u0456\u0446\u0435\u043d\u0437\u0456\u0454\u044e MIT/X11, \u0434\u043e\u0434\u0430\u0442\u043a\u043e\u0432\u0430 \u0456\u043d\u0444\u043e\u0440\u043c\u0430\u0446\u0456\u044f \u043c\u0456\u0441\u0442\u0438\u0442\u044c\u0441\u044f \u0443 \u0444\u0430\u0439\u043b\u0456 COPYING, \u0430 \u0442\u0430\u043a\u043e\u0436 \u0437\u0430 \u0430\u0434\u0440\u0435\u0441\u043e\u044e http://www.opensource.org/licenses/mit-license.php.\n \n-\u0426\u0435\u0439 \u043f\u0440\u043e\u0434\u0443\u043a\u0442 \u0432\u043a\u043b\u044e\u0447\u0430\u0454 \u0432 \u0441\u0435\u0431\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043d\u0435 \u0437\u0430\u0431\u0435\u0437\u043f\u0435\u0447\u0435\u043d\u043d\u044f, \u0440\u043e\u0437\u0440\u043e\u0431\u043b\u0435\u043d\u0435 \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043f\u0440\u043e\u0435\u043a\u0442\u0443 OpenSSL (http://www.openssl.org/), \u043a\u0440\u0438\u043f\u0442\u043e\u0433\u0440\u0430\u0444\u0456\u0447\u043d\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043d\u0435 \u0437\u0430\u0431\u0435\u0437\u043f\u0435\u0447\u0435\u043d\u043d\u044f, \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0435 \u0415\u0440\u0456\u043a\u043e\u043c \u042f\u043d\u0433\u043e\u043c (eay@cryptsoft.com), \u0442\u0430 \u0444\u0443\u043d\u043a\u0446\u0456\u0457 \u0434\u043b\u044f \u0440\u043e\u0431\u043e\u0442\u0438 \u0437 UPnP, \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0456 \u0422\u043e\u043c\u0430\u0441\u043e\u043c \u0411\u0435\u0440\u043d\u0430\u0440\u0434\u043e\u043c.</translation>\n+\u0426\u0435\u0439 \u043f\u0440\u043e\u0434\u0443\u043a\u0442 \u0432\u043a\u043b\u044e\u0447\u0430\u0454 \u0432 \u0441\u0435\u0431\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043d\u0435 \u0437\u0430\u0431\u0435\u0437\u043f\u0435\u0447\u0435\u043d\u043d\u044f, \u0440\u043e\u0437\u0440\u043e\u0431\u043b\u0435\u043d\u0435 \u0432 \u0440\u0430\u043c\u043a\u0430\u0445 \u043f\u0440\u043e\u0435\u043a\u0442\u0443 OpenSSL (https://www.openssl.org/), \u043a\u0440\u0438\u043f\u0442\u043e\u0433\u0440\u0430\u0444\u0456\u0447\u043d\u0435 \u043f\u0440\u043e\u0433\u0440\u0430\u043c\u043d\u0435 \u0437\u0430\u0431\u0435\u0437\u043f\u0435\u0447\u0435\u043d\u043d\u044f, \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0435 \u0415\u0440\u0456\u043a\u043e\u043c \u042f\u043d\u0433\u043e\u043c (eay@cryptsoft.com), \u0442\u0430 \u0444\u0443\u043d\u043a\u0446\u0456\u0457 \u0434\u043b\u044f \u0440\u043e\u0431\u043e\u0442\u0438 \u0437 UPnP, \u043d\u0430\u043f\u0438\u0441\u0430\u043d\u0456 \u0422\u043e\u043c\u0430\u0441\u043e\u043c \u0411\u0435\u0440\u043d\u0430\u0440\u0434\u043e\u043c.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "cb711b8466883ae82bdd56b6b12ec58cfa9f1791",
        "filename": "src/qt/locale/bitcoin_ur_PK.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ur_PK.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_ur_PK.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_ur_PK.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "bed9886c7204e3ce98f6e683377759af4dce20b7",
        "filename": "src/qt/locale/bitcoin_uz@Cyrl.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_uz@Cyrl.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_uz@Cyrl.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_uz@Cyrl.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "a2ad8dcbba059a654c9822330b33bc456c005f60",
        "filename": "src/qt/locale/bitcoin_vi.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_vi.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_vi.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_vi.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "808228b9ec2fd6592295725abfab66fae18defcb",
        "filename": "src/qt/locale/bitcoin_vi_VN.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_vi_VN.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_vi_VN.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_vi_VN.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "1424ea723015fd11cde74945bdfe44417fd9af3e",
        "filename": "src/qt/locale/bitcoin_zh_CN.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_zh_CN.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_zh_CN.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_zh_CN.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,13 +15,13 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</translation>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      },
      {
        "sha": "e745ff841efe4c38dcb507efebb963ccd2159836",
        "filename": "src/qt/locale/bitcoin_zh_HK.ts",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_zh_HK.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_zh_HK.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_zh_HK.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,7 +15,7 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation type=\"unfinished\"/>\n     </message>\n     <message>"
      },
      {
        "sha": "4d1b604fa271c1a0a2184358ebcecdaf9f8688e9",
        "filename": "src/qt/locale/bitcoin_zh_TW.ts",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_zh_TW.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/92de0de77704b96f2b1fc1a73b0dfd92fb88281e/src/qt/locale/bitcoin_zh_TW.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_zh_TW.ts?ref=92de0de77704b96f2b1fc1a73b0dfd92fb88281e",
        "patch": "@@ -15,15 +15,15 @@ This is experimental software.\n \n Distributed under the MIT/X11 software license, see the accompanying file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (http://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n+This product includes software developed by the OpenSSL Project for use in the OpenSSL Toolkit (https://www.openssl.org/) and cryptographic software written by Eric Young (eay@cryptsoft.com) and UPnP software written by Thomas Bernard.</source>\n         <translation>\n \u4f4d\u5143\u5e63\uff0c\u539f\u540d\u662f Bitcoin, \u53c8\u53eb\u505a\u6bd4\u7279\u5e63\u3002\n \n \u9019\u662f\u4e00\u5957\u5be6\u9a57\u6027\u7684\u8edf\u9ad4\u3002\n \n \u9019\u5957\u8edf\u9ad4\u662f\u4f9d\u64da MIT/X11 \u8edf\u9ad4\u6388\u6b0a\u689d\u6b3e\u6563\u5e03\uff0c\u8a73\u60c5\u8acb\u898b\u9644\u5e36\u7684 COPYING \u6a94\u6848\uff0c\u6216\u662f\u4ee5\u4e0b\u7db2\u7ad9: http://www.opensource.org/licenses/mit-license.php.\n \n-\u6b64\u7522\u54c1\u4e5f\u5305\u542b\u4e86\u7531 OpenSSL Project \u6240\u958b\u767c\u7684 OpenSSL Toolkit (http://www.openssl.org/) \u8edf\u9ad4\uff0c\u548c\u7531 Eric Young (eay@cryptsoft.com) \u64b0\u5beb\u7684\u52a0\u89e3\u5bc6\u8edf\u9ad4\uff0c\u4ee5\u53ca\u7531 Thomas Bernard \u6240\u64b0\u5beb\u7684 UPnP \u8edf\u9ad4\u3002</translation>\n+\u6b64\u7522\u54c1\u4e5f\u5305\u542b\u4e86\u7531 OpenSSL Project \u6240\u958b\u767c\u7684 OpenSSL Toolkit (https://www.openssl.org/) \u8edf\u9ad4\uff0c\u548c\u7531 Eric Young (eay@cryptsoft.com) \u64b0\u5beb\u7684\u52a0\u89e3\u5bc6\u8edf\u9ad4\uff0c\u4ee5\u53ca\u7531 Thomas Bernard \u6240\u64b0\u5beb\u7684 UPnP \u8edf\u9ad4\u3002</translation>\n     </message>\n     <message>\n         <source>Copyright</source>"
      }
    ]
  }
]