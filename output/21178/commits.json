[
  {
    "sha": "a3f0cbf82ddae2dd83001a9cc3a7948dcfb6fa47",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphM2YwY2JmODJkZGFlMmRkODMwMDFhOWNjM2E3OTQ4ZGNmYjZmYTQ3",
    "commit": {
      "author": {
        "name": "Darius Parvin",
        "email": "darius@berkeley.edu",
        "date": "2021-05-31T16:28:10Z"
      },
      "committer": {
        "name": "Darius Parvin",
        "email": "darius@berkeley.edu",
        "date": "2021-05-31T16:28:10Z"
      },
      "message": "test: run mempool_reorg.py even with wallet disabled\n\n- run mempool_reorg.py even when the wallet is not compiled\n- add `locktime` argument to `create_self_transfer` and `send_self_transfer`\n- use more logs instead of comments",
      "tree": {
        "sha": "12c1364499670b21968974ed33020c9559ea6dd7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/12c1364499670b21968974ed33020c9559ea6dd7"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a3f0cbf82ddae2dd83001a9cc3a7948dcfb6fa47",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a3f0cbf82ddae2dd83001a9cc3a7948dcfb6fa47",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a3f0cbf82ddae2dd83001a9cc3a7948dcfb6fa47",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a3f0cbf82ddae2dd83001a9cc3a7948dcfb6fa47/comments",
    "author": {
      "login": "DariusParvin",
      "id": 41220998,
      "node_id": "MDQ6VXNlcjQxMjIwOTk4",
      "avatar_url": "https://avatars.githubusercontent.com/u/41220998?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DariusParvin",
      "html_url": "https://github.com/DariusParvin",
      "followers_url": "https://api.github.com/users/DariusParvin/followers",
      "following_url": "https://api.github.com/users/DariusParvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/DariusParvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DariusParvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DariusParvin/subscriptions",
      "organizations_url": "https://api.github.com/users/DariusParvin/orgs",
      "repos_url": "https://api.github.com/users/DariusParvin/repos",
      "events_url": "https://api.github.com/users/DariusParvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DariusParvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "DariusParvin",
      "id": 41220998,
      "node_id": "MDQ6VXNlcjQxMjIwOTk4",
      "avatar_url": "https://avatars.githubusercontent.com/u/41220998?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/DariusParvin",
      "html_url": "https://github.com/DariusParvin",
      "followers_url": "https://api.github.com/users/DariusParvin/followers",
      "following_url": "https://api.github.com/users/DariusParvin/following{/other_user}",
      "gists_url": "https://api.github.com/users/DariusParvin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/DariusParvin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/DariusParvin/subscriptions",
      "organizations_url": "https://api.github.com/users/DariusParvin/orgs",
      "repos_url": "https://api.github.com/users/DariusParvin/repos",
      "events_url": "https://api.github.com/users/DariusParvin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/DariusParvin/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8462cd56010a8beadf95d4f3cb1357ca9d88493b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8462cd56010a8beadf95d4f3cb1357ca9d88493b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8462cd56010a8beadf95d4f3cb1357ca9d88493b"
      }
    ],
    "stats": {
      "total": 117,
      "additions": 59,
      "deletions": 58
    },
    "files": [
      {
        "sha": "bcc6aa7bccf1d6b4ae4580dfda55384da296995a",
        "filename": "test/functional/mempool_reorg.py",
        "status": "modified",
        "additions": 56,
        "deletions": 56,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a3f0cbf82ddae2dd83001a9cc3a7948dcfb6fa47/test/functional/mempool_reorg.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a3f0cbf82ddae2dd83001a9cc3a7948dcfb6fa47/test/functional/mempool_reorg.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_reorg.py?ref=a3f0cbf82ddae2dd83001a9cc3a7948dcfb6fa47",
        "patch": "@@ -8,13 +8,9 @@\n that spend (directly or indirectly) coinbase transactions.\n \"\"\"\n \n-from test_framework.blocktools import (\n-    COINBASE_MATURITY,\n-    create_raw_transaction,\n-)\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal, assert_raises_rpc_error\n-\n+from test_framework.wallet import MiniWallet\n \n class MempoolCoinbaseTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -26,86 +22,90 @@ def set_test_params(self):\n             []\n         ]\n \n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n-\n     def run_test(self):\n+        wallet = MiniWallet(self.nodes[0])\n+\n         # Start with a 200 block chain\n         assert_equal(self.nodes[0].getblockcount(), 200)\n \n-        # Mine four blocks. After this, nodes[0] blocks\n-        # 101, 102, and 103 are spend-able.\n-        new_blocks = self.nodes[1].generate(4)\n-        self.sync_all()\n-\n-        node0_address = self.nodes[0].getnewaddress()\n-        node1_address = self.nodes[1].getnewaddress()\n+        self.log.info(\"Add 4 coinbase utxos to the miniwallet\")\n+        # Block 76 contains the first spendable coinbase txs.\n+        first_block = 76\n+        wallet.scan_blocks(start=first_block, num=4)\n \n         # Three scenarios for re-orging coinbase spends in the memory pool:\n-        # 1. Direct coinbase spend  :  spend_101\n-        # 2. Indirect (coinbase spend in chain, child in mempool) : spend_102 and spend_102_1\n-        # 3. Indirect (coinbase and child both in chain) : spend_103 and spend_103_1\n-        # Use invalidatblock to make all of the above coinbase spends invalid (immature coinbase),\n+        # 1. Direct coinbase spend  :  spend_1\n+        # 2. Indirect (coinbase spend in chain, child in mempool) : spend_2 and spend_2_1\n+        # 3. Indirect (coinbase and child both in chain) : spend_3 and spend_3_1\n+        # Use invalidateblock to make all of the above coinbase spends invalid (immature coinbase),\n         # and make sure the mempool code behaves correctly.\n-        b = [self.nodes[0].getblockhash(n) for n in range(COINBASE_MATURITY + 1, COINBASE_MATURITY + 5)]\n+        b = [self.nodes[0].getblockhash(n) for n in range(first_block, first_block+4)]\n         coinbase_txids = [self.nodes[0].getblock(h)['tx'][0] for h in b]\n-        spend_101_raw = create_raw_transaction(self.nodes[0], coinbase_txids[1], node1_address, amount=49.99)\n-        spend_102_raw = create_raw_transaction(self.nodes[0], coinbase_txids[2], node0_address, amount=49.99)\n-        spend_103_raw = create_raw_transaction(self.nodes[0], coinbase_txids[3], node0_address, amount=49.99)\n-\n-        # Create a transaction which is time-locked to two blocks in the future\n-        timelock_tx = self.nodes[0].createrawtransaction(\n-            inputs=[{\n-                \"txid\": coinbase_txids[0],\n-                \"vout\": 0,\n-            }],\n-            outputs={node0_address: 49.99},\n-            locktime=self.nodes[0].getblockcount() + 2,\n-        )\n-        timelock_tx = self.nodes[0].signrawtransactionwithwallet(timelock_tx)[\"hex\"]\n-        # This will raise an exception because the timelock transaction is too immature to spend\n+        utxo_1 = wallet.get_utxo(txid=coinbase_txids[1])\n+        utxo_2 = wallet.get_utxo(txid=coinbase_txids[2])\n+        utxo_3 = wallet.get_utxo(txid=coinbase_txids[3])\n+        self.log.info(\"Create three transactions spending from coinbase utxos: spend_1, spend_2, spend_3\")\n+        spend_1 = wallet.create_self_transfer(from_node=self.nodes[0], utxo_to_spend=utxo_1)\n+        spend_2 = wallet.create_self_transfer(from_node=self.nodes[0], utxo_to_spend=utxo_2)\n+        spend_3 = wallet.create_self_transfer(from_node=self.nodes[0], utxo_to_spend=utxo_3)\n+\n+        self.log.info(\"Create another transaction which is time-locked to two blocks in the future\")\n+        utxo = wallet.get_utxo(txid=coinbase_txids[0])\n+        timelock_tx = wallet.create_self_transfer(\n+            from_node=self.nodes[0],\n+            utxo_to_spend=utxo,\n+            mempool_valid=False,\n+            locktime=self.nodes[0].getblockcount() + 2\n+        )['hex']\n+\n+        self.log.info(\"Check that the time-locked transaction is too immature to spend\")\n         assert_raises_rpc_error(-26, \"non-final\", self.nodes[0].sendrawtransaction, timelock_tx)\n \n-        # Broadcast and mine spend_102 and 103:\n-        spend_102_id = self.nodes[0].sendrawtransaction(spend_102_raw)\n-        spend_103_id = self.nodes[0].sendrawtransaction(spend_103_raw)\n+        self.log.info(\"Broadcast and mine spend_2 and spend_3\")\n+        wallet.sendrawtransaction(from_node=self.nodes[0], tx_hex=spend_2['hex'])\n+        wallet.sendrawtransaction(from_node=self.nodes[0], tx_hex=spend_3['hex'])\n+        self.log.info(\"Generate a block\")\n         self.nodes[0].generate(1)\n-        # Time-locked transaction is still too immature to spend\n+        self.log.info(\"Check that time-locked transaction is still too immature to spend\")\n         assert_raises_rpc_error(-26, 'non-final', self.nodes[0].sendrawtransaction, timelock_tx)\n \n-        # Create 102_1 and 103_1:\n-        spend_102_1_raw = create_raw_transaction(self.nodes[0], spend_102_id, node1_address, amount=49.98)\n-        spend_103_1_raw = create_raw_transaction(self.nodes[0], spend_103_id, node1_address, amount=49.98)\n+        self.log.info(\"Create spend_2_1 and spend_3_1\")\n+        spend_2_utxo = wallet.get_utxo(txid=spend_2['txid'])\n+        spend_2_1 = wallet.create_self_transfer(from_node=self.nodes[0], utxo_to_spend=spend_2_utxo)\n+        spend_3_utxo = wallet.get_utxo(txid=spend_3['txid'])\n+        spend_3_1 = wallet.create_self_transfer(from_node=self.nodes[0], utxo_to_spend=spend_3_utxo)\n \n-        # Broadcast and mine 103_1:\n-        spend_103_1_id = self.nodes[0].sendrawtransaction(spend_103_1_raw)\n+        self.log.info(\"Broadcast and mine spend_3_1\")\n+        spend_3_1_id = self.nodes[0].sendrawtransaction(spend_3_1['hex'])\n+        self.log.info(\"Generate a block\")\n         last_block = self.nodes[0].generate(1)\n         # Sync blocks, so that peer 1 gets the block before timelock_tx\n         # Otherwise, peer 1 would put the timelock_tx in recentRejects\n         self.sync_all()\n \n-        # Time-locked transaction can now be spent\n+        self.log.info(\"The time-locked transaction can now be spent\")\n         timelock_tx_id = self.nodes[0].sendrawtransaction(timelock_tx)\n \n-        # ... now put spend_101 and spend_102_1 in memory pools:\n-        spend_101_id = self.nodes[0].sendrawtransaction(spend_101_raw)\n-        spend_102_1_id = self.nodes[0].sendrawtransaction(spend_102_1_raw)\n+        self.log.info(\"Add spend_1 and spend_2_1 to the mempool\")\n+        spend_1_id = self.nodes[0].sendrawtransaction(spend_1['hex'])\n+        spend_2_1_id = self.nodes[0].sendrawtransaction(spend_2_1['hex'])\n \n-        assert_equal(set(self.nodes[0].getrawmempool()), {spend_101_id, spend_102_1_id, timelock_tx_id})\n+        assert_equal(set(self.nodes[0].getrawmempool()), {spend_1_id, spend_2_1_id, timelock_tx_id})\n         self.sync_all()\n \n+        self.log.info(\"invalidate the last block\")\n         for node in self.nodes:\n             node.invalidateblock(last_block[0])\n-        # Time-locked transaction is now too immature and has been removed from the mempool\n-        # spend_103_1 has been re-orged out of the chain and is back in the mempool\n-        assert_equal(set(self.nodes[0].getrawmempool()), {spend_101_id, spend_102_1_id, spend_103_1_id})\n+        self.log.info(\"The time-locked transaction is now too immature and has been removed from the mempool\")\n+        self.log.info(\"spend_3_1 has been re-orged out of the chain and is back in the mempool\")\n+        assert_equal(set(self.nodes[0].getrawmempool()), {spend_1_id, spend_2_1_id, spend_3_1_id})\n \n-        # Use invalidateblock to re-org back and make all those coinbase spends\n-        # immature/invalid:\n+        self.log.info(\"Use invalidateblock to re-org back and make all those coinbase spends immature/invalid\")\n+        b = self.nodes[0].getblockhash(first_block + 100)\n         for node in self.nodes:\n-            node.invalidateblock(new_blocks[0])\n+            node.invalidateblock(b)\n \n-        # mempool should be empty.\n+        self.log.info(\"Check that the mempool is empty\")\n         assert_equal(set(self.nodes[0].getrawmempool()), set())\n         self.sync_all()\n "
      },
      {
        "sha": "bfb5916c37f9dac7086626156bc33d875d65e7e1",
        "filename": "test/functional/test_framework/wallet.py",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a3f0cbf82ddae2dd83001a9cc3a7948dcfb6fa47/test/functional/test_framework/wallet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a3f0cbf82ddae2dd83001a9cc3a7948dcfb6fa47/test/functional/test_framework/wallet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/wallet.py?ref=a3f0cbf82ddae2dd83001a9cc3a7948dcfb6fa47",
        "patch": "@@ -123,13 +123,13 @@ def get_utxo(self, *, txid='', mark_as_spent=True):\n         else:\n             return self._utxos[index]\n \n-    def send_self_transfer(self, *, fee_rate=Decimal(\"0.003\"), from_node, utxo_to_spend=None):\n+    def send_self_transfer(self, *, fee_rate=Decimal(\"0.003\"), from_node, utxo_to_spend=None, locktime=0):\n         \"\"\"Create and send a tx with the specified fee_rate. Fee may be exact or at most one satoshi higher than needed.\"\"\"\n         tx = self.create_self_transfer(fee_rate=fee_rate, from_node=from_node, utxo_to_spend=utxo_to_spend)\n         self.sendrawtransaction(from_node=from_node, tx_hex=tx['hex'])\n         return tx\n \n-    def create_self_transfer(self, *, fee_rate=Decimal(\"0.003\"), from_node, utxo_to_spend=None, mempool_valid=True):\n+    def create_self_transfer(self, *, fee_rate=Decimal(\"0.003\"), from_node, utxo_to_spend=None, mempool_valid=True, locktime=0):\n         \"\"\"Create and return a tx with the specified fee_rate. Fee may be exact or at most one satoshi higher than needed.\"\"\"\n         self._utxos = sorted(self._utxos, key=lambda k: k['value'])\n         utxo_to_spend = utxo_to_spend or self._utxos.pop()  # Pick the largest utxo (if none provided) and hope it covers the fee\n@@ -141,6 +141,7 @@ def create_self_transfer(self, *, fee_rate=Decimal(\"0.003\"), from_node, utxo_to_\n         tx = CTransaction()\n         tx.vin = [CTxIn(COutPoint(int(utxo_to_spend['txid'], 16), utxo_to_spend['vout']))]\n         tx.vout = [CTxOut(int(send_value * COIN), self._scriptPubKey)]\n+        tx.nLockTime = locktime\n         if not self._address:\n             # raw script\n             if self._priv_key is not None:"
      }
    ]
  }
]