[
  {
    "sha": "48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ODI2NWYzY2Y0ZTYyYjZjNjI2N2IzZTY3YzcxYTg3ODBmMmUyY2Mx",
    "commit": {
      "author": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-04-10T05:33:06Z"
      },
      "committer": {
        "name": "Wladimir J. van der Laan",
        "email": "laanwj@gmail.com",
        "date": "2015-04-10T05:51:27Z"
      },
      "message": "Revert mining changes in #5957\n\nThis reverts commit e2edf95cd3f43331843676e49a82830128a95050 6b04508e37c5dd18cec1cd61cc4356bd208aa991 0df67f1f7ab4adfe9f0b3ba6276e737b37826464,\nexcept the changes to the RPC tests.\n\nA `generate` RPC call is introduced based on the old code.",
      "tree": {
        "sha": "daa0570926fca8f4eeedb9dc0f1f2fbddd4146b1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/daa0570926fca8f4eeedb9dc0f1f2fbddd4146b1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1/comments",
    "author": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "laanwj",
      "id": 126646,
      "node_id": "MDQ6VXNlcjEyNjY0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/126646?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/laanwj",
      "html_url": "https://github.com/laanwj",
      "followers_url": "https://api.github.com/users/laanwj/followers",
      "following_url": "https://api.github.com/users/laanwj/following{/other_user}",
      "gists_url": "https://api.github.com/users/laanwj/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/laanwj/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/laanwj/subscriptions",
      "organizations_url": "https://api.github.com/users/laanwj/orgs",
      "repos_url": "https://api.github.com/users/laanwj/repos",
      "events_url": "https://api.github.com/users/laanwj/events{/privacy}",
      "received_events_url": "https://api.github.com/users/laanwj/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4ac79f99b02e1d288dda353c15f4183180e538df",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ac79f99b02e1d288dda353c15f4183180e538df",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4ac79f99b02e1d288dda353c15f4183180e538df"
      }
    ],
    "stats": {
      "total": 188,
      "additions": 97,
      "deletions": 91
    },
    "files": [
      {
        "sha": "cf08b782296cfbcb39e9183ac361c0e3e645874b",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 66,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1",
        "patch": "@@ -87,7 +87,7 @@ void UpdateTime(CBlockHeader* pblock, const CBlockIndex* pindexPrev)\n         pblock->nBits = GetNextWorkRequired(pindexPrev, pblock, Params().GetConsensus());\n }\n \n-CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn, CBlockIndex*& pindexPrev)\n+CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn)\n {\n     // Create new block\n     auto_ptr<CBlockTemplate> pblocktemplate(new CBlockTemplate());\n@@ -132,7 +132,7 @@ CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn, CBlockIndex*& pind\n \n     {\n         LOCK2(cs_main, mempool.cs);\n-        pindexPrev = chainActive.Tip();\n+        CBlockIndex* pindexPrev = chainActive.Tip();\n         const int nHeight = pindexPrev->nHeight + 1;\n         CCoinsViewCache view(pcoinsTip);\n \n@@ -365,34 +365,45 @@ void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int&\n \n //\n // ScanHash scans nonces looking for a hash with at least some zero bits.\n-// The nonce is usually preserved between calls, but periodically the block is\n-// rebuilt and nNonce starts over at zero.\n+// The nonce is usually preserved between calls, but periodically or if the\n+// nonce is 0xffff0000 or above, the block is rebuilt and nNonce starts over at\n+// zero.\n //\n-bool static ScanHash(CBlockHeader *pblock, uint256 *phash)\n+bool static ScanHash(const CBlockHeader *pblock, uint32_t& nNonce, uint256 *phash)\n {\n+    // Write the first 76 bytes of the block header to a double-SHA256 state.\n+    CHash256 hasher;\n+    CDataStream ss(SER_NETWORK, PROTOCOL_VERSION);\n+    ss << *pblock;\n+    assert(ss.size() == 80);\n+    hasher.Write((unsigned char*)&ss[0], 76);\n+\n     while (true) {\n-        pblock->nNonce++;\n-        *phash = pblock->GetHash();\n+        nNonce++;\n+\n+        // Write the last 4 bytes of the block header (the nonce) to a copy of\n+        // the double-SHA256 state, and compute the result.\n+        CHash256(hasher).Write((unsigned char*)&nNonce, 4).Finalize((unsigned char*)phash);\n \n         // Return the nonce if the hash has at least some zero bits,\n         // caller will check if it has enough to reach the target\n         if (((uint16_t*)phash)[15] == 0)\n             return true;\n \n-        // If nothing found after trying for a while, return false.\n-        if ((pblock->nNonce & 0xfff) == 0)\n+        // If nothing found after trying for a while, return -1\n+        if ((nNonce & 0xfff) == 0)\n             return false;\n     }\n }\n \n-CBlockTemplate* CreateNewBlockWithKey(CReserveKey& reservekey, CBlockIndex*& pindexPrev)\n+CBlockTemplate* CreateNewBlockWithKey(CReserveKey& reservekey)\n {\n     CPubKey pubkey;\n     if (!reservekey.GetReservedKey(pubkey))\n         return NULL;\n \n     CScript scriptPubKey = CScript() << ToByteVector(pubkey) << OP_CHECKSIG;\n-    return CreateNewBlock(scriptPubKey, pindexPrev);\n+    return CreateNewBlock(scriptPubKey);\n }\n \n static bool ProcessBlockFound(CBlock* pblock, CWallet& wallet, CReserveKey& reservekey)\n@@ -424,56 +435,6 @@ static bool ProcessBlockFound(CBlock* pblock, CWallet& wallet, CReserveKey& rese\n     return true;\n }\n \n-bool static ScanLoop(CBlock *pblock, CBlockIndex *pindexPrev, CWallet *pwallet, CReserveKey& reservekey)\n-{\n-    UpdateTime(pblock, pindexPrev);\n-    arith_uint256 hashTarget = arith_uint256().SetCompact(pblock->nBits);\n-\n-    uint256 hash;\n-    if (ScanHash(pblock, &hash)) {\n-        if (UintToArith256(hash) <= hashTarget) {\n-            // Found a solution\n-            SetThreadPriority(THREAD_PRIORITY_NORMAL);\n-            LogPrintf(\"BitcoinMiner:\\n\");\n-            LogPrintf(\"proof-of-work found  \\n  hash: %s  \\ntarget: %s\\n\", hash.GetHex(), hashTarget.GetHex());\n-            ProcessBlockFound(pblock, *pwallet, reservekey);\n-            SetThreadPriority(THREAD_PRIORITY_LOWEST);\n-\n-            return true;\n-        }\n-    }\n-\n-    return false;\n-}\n-\n-bool MineBlock(CWallet *pwallet, uint256& hash)\n-{\n-    CReserveKey reservekey(pwallet);\n-    unsigned int nExtraNonce = 0;\n-\n-    while (true) {\n-        CBlockIndex *pindexPrev;\n-\n-        auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey, pindexPrev));\n-        if (!pblocktemplate.get()) {\n-            return false;\n-        }\n-\n-        CBlock *pblock = &pblocktemplate->block;\n-        IncrementExtraNonce(pblock, pindexPrev, nExtraNonce);\n-\n-        while (true) {\n-            if (ScanLoop(pblock, pindexPrev, pwallet, reservekey)) {\n-                hash = pblock->GetHash();\n-                return true;\n-            }\n-            boost::this_thread::interruption_point();\n-            if (pblock->nNonce >= 0xffff0000)\n-                break;\n-        }\n-    }\n-}\n-\n void static BitcoinMiner(CWallet *pwallet)\n {\n     LogPrintf(\"BitcoinMiner started\\n\");\n@@ -497,9 +458,9 @@ void static BitcoinMiner(CWallet *pwallet)\n             // Create new block\n             //\n             unsigned int nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n-            CBlockIndex* pindexPrev;\n+            CBlockIndex* pindexPrev = chainActive.Tip();\n \n-            auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey, pindexPrev));\n+            auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey));\n             if (!pblocktemplate.get())\n             {\n                 LogPrintf(\"Error in BitcoinMiner: Keypool ran out, please call keypoolrefill before restarting the mining thread\\n\");\n@@ -515,23 +476,52 @@ void static BitcoinMiner(CWallet *pwallet)\n             // Search\n             //\n             int64_t nStart = GetTime();\n+            arith_uint256 hashTarget = arith_uint256().SetCompact(pblock->nBits);\n+            uint256 hash;\n+            uint32_t nNonce = 0;\n             while (true) {\n                 // Check if something found\n-                if (ScanLoop(pblock, pindexPrev, pwallet, reservekey))\n-                    break;\n+                if (ScanHash(pblock, nNonce, &hash))\n+                {\n+                    if (UintToArith256(hash) <= hashTarget)\n+                    {\n+                        // Found a solution\n+                        pblock->nNonce = nNonce;\n+                        assert(hash == pblock->GetHash());\n+\n+                        SetThreadPriority(THREAD_PRIORITY_NORMAL);\n+                        LogPrintf(\"BitcoinMiner:\\n\");\n+                        LogPrintf(\"proof-of-work found  \\n  hash: %s  \\ntarget: %s\\n\", hash.GetHex(), hashTarget.GetHex());\n+                        ProcessBlockFound(pblock, *pwallet, reservekey);\n+                        SetThreadPriority(THREAD_PRIORITY_LOWEST);\n+\n+                        // In regression test mode, stop mining after a block is found.\n+                        if (Params().MineBlocksOnDemand())\n+                            throw boost::thread_interrupted();\n+\n+                        break;\n+                    }\n+                }\n \n                 // Check for stop or if block needs to be rebuilt\n                 boost::this_thread::interruption_point();\n                 // Regtest mode doesn't require peers\n                 if (vNodes.empty() && Params().MiningRequiresPeers())\n                     break;\n-                if (pblock->nNonce >= 0xffff0000)\n+                if (nNonce >= 0xffff0000)\n                     break;\n                 if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 60)\n                     break;\n                 if (pindexPrev != chainActive.Tip())\n                     break;\n \n+                // Update nTime every few seconds\n+                UpdateTime(pblock, pindexPrev);\n+                if (Params().AllowMinDifficultyBlocks())\n+                {\n+                    // Changing pblock->nTime can change work required on testnet:\n+                    hashTarget.SetCompact(pblock->nBits);\n+                }\n             }\n         }\n     }"
      },
      {
        "sha": "5d5c9c86c7cc5022512745709cf925045cbfbab2",
        "filename": "src/miner.h",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1/src/miner.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1/src/miner.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.h?ref=48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1",
        "patch": "@@ -24,11 +24,9 @@ struct CBlockTemplate\n \n /** Run the miner threads */\n void GenerateBitcoins(bool fGenerate, CWallet* pwallet, int nThreads);\n-/** Create a single block */\n-bool MineBlock(CWallet *pwallet, uint256& hash);\n /** Generate a new block, without valid proof-of-work */\n-CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn, CBlockIndex*& pindexPrev);\n-CBlockTemplate* CreateNewBlockWithKey(CReserveKey& reservekey, CBlockIndex*& pindexPrev);\n+CBlockTemplate* CreateNewBlock(const CScript& scriptPubKeyIn);\n+CBlockTemplate* CreateNewBlockWithKey(CReserveKey& reservekey);\n /** Modify the extranonce in a block */\n void IncrementExtraNonce(CBlock* pblock, CBlockIndex* pindexPrev, unsigned int& nExtraNonce);\n void UpdateTime(CBlockHeader* block, const CBlockIndex* pindexPrev);"
      },
      {
        "sha": "1e6531f68a82fbcd3067cec5bb63e2cf980451d3",
        "filename": "src/rpcmining.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 7,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1/src/rpcmining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1/src/rpcmining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpcmining.cpp?ref=48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1",
        "patch": "@@ -119,6 +119,7 @@ Value generate(const Array& params, bool fHelp)\n         throw runtime_error(\n             \"generate numblocks\\n\"\n             \"\\nMine blocks immediately (before the RPC call returns)\\n\"\n+            \"\\nNote: this function can only be used on the regtest network\\n\"\n             \"1. numblocks    (numeric) How many blocks are generated immediately.\\n\"\n             \"\\nResult\\n\"\n             \"[ blockhashes ]     (array) hashes of blocks generated\\n\"\n@@ -129,30 +130,48 @@ Value generate(const Array& params, bool fHelp)\n \n     if (pwalletMain == NULL)\n         throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"Method not found (disabled)\");\n+    if (!Params().MineBlocksOnDemand())\n+        throw JSONRPCError(RPC_METHOD_NOT_FOUND, \"This method can only be used on regtest\");\n \n     int nHeightStart = 0;\n     int nHeightEnd = 0;\n     int nHeight = 0;\n     int nGenerate = params[0].get_int();\n+    CReserveKey reservekey(pwalletMain);\n \n     {   // Don't keep cs_main locked\n         LOCK(cs_main);\n         nHeightStart = chainActive.Height();\n         nHeight = nHeightStart;\n         nHeightEnd = nHeightStart+nGenerate;\n     }\n+    unsigned int nExtraNonce = 0;\n     Array blockHashes;\n-    while (nHeight < nHeightEnd) {\n-        uint256 hash;\n-        if (!MineBlock(pwalletMain, hash))\n+    while (nHeight < nHeightEnd)\n+    {\n+        auto_ptr<CBlockTemplate> pblocktemplate(CreateNewBlockWithKey(reservekey));\n+        if (!pblocktemplate.get())\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"Wallet keypool empty\");\n-\n+        CBlock *pblock = &pblocktemplate->block;\n+        {\n+            LOCK(cs_main);\n+            IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);\n+        }\n+        while (!CheckProofOfWork(pblock->GetHash(), pblock->nBits, Params().GetConsensus())) {\n+            // Yes, there is a chance every nonce could fail to satisfy the -regtest\n+            // target -- 1 in 2^(2^32). That ain't gonna happen.\n+            ++pblock->nNonce;\n+        }\n+        CValidationState state;\n+        if (!ProcessNewBlock(state, NULL, pblock))\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n         ++nHeight;\n-        blockHashes.push_back(hash.GetHex());\n+        blockHashes.push_back(pblock->GetHash().GetHex());\n     }\n     return blockHashes;\n }\n \n+\n Value setgenerate(const Array& params, bool fHelp)\n {\n     if (fHelp || params.size() < 1 || params.size() > 2)\n@@ -475,7 +494,7 @@ Value getblocktemplate(const Array& params, bool fHelp)\n \n         // Store the pindexBest used before CreateNewBlock, to avoid races\n         nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n-        CBlockIndex* pindexPrevNew;\n+        CBlockIndex* pindexPrevNew = chainActive.Tip();\n         nStart = GetTime();\n \n         // Create new block\n@@ -485,7 +504,7 @@ Value getblocktemplate(const Array& params, bool fHelp)\n             pblocktemplate = NULL;\n         }\n         CScript scriptDummy = CScript() << OP_TRUE;\n-        pblocktemplate = CreateNewBlock(scriptDummy, pindexPrevNew);\n+        pblocktemplate = CreateNewBlock(scriptDummy);\n         if (!pblocktemplate)\n             throw JSONRPCError(RPC_OUT_OF_MEMORY, \"Out of memory\");\n "
      },
      {
        "sha": "6ab9cb8a440b3c779a28979deab2c53d2ab6a936",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 14,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=48265f3cf4e62b6c6267b3e67c71a8780f2e2cc1",
        "patch": "@@ -62,8 +62,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     Checkpoints::fEnabled = false;\n \n     // Simple block creation, nothing special yet:\n-    CBlockIndex* pindexPrev;\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n \n     // We can't make transactions until we have inputs\n     // Therefore, load 100 blocks :)\n@@ -91,7 +90,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     delete pblocktemplate;\n \n     // Just to make sure we can still make simple blocks\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n \n     // block sigops > limit: 1000 CHECKMULTISIG + 1\n@@ -109,7 +108,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n     mempool.clear();\n \n@@ -129,14 +128,14 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n         mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n         tx.vin[0].prevout.hash = hash;\n     }\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n     mempool.clear();\n \n     // orphan in mempool\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n     mempool.clear();\n \n@@ -154,7 +153,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].nValue = 5900000000LL;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n     mempool.clear();\n \n@@ -165,7 +164,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].nValue = 0;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n     mempool.clear();\n \n@@ -183,7 +182,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].nValue -= 1000000;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n     mempool.clear();\n \n@@ -197,17 +196,17 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     tx.vout[0].scriptPubKey = CScript() << OP_2;\n     hash = tx.GetHash();\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx, 11, GetTime(), 111.0, 11));\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n     mempool.clear();\n \n     // subsidy changing\n     int nHeight = chainActive.Height();\n     chainActive.Tip()->nHeight = 209999;\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n     chainActive.Tip()->nHeight = 210000;\n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n     delete pblocktemplate;\n     chainActive.Tip()->nHeight = nHeight;\n \n@@ -239,7 +238,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     mempool.addUnchecked(hash, CTxMemPoolEntry(tx2, 11, GetTime(), 111.0, 11));\n     BOOST_CHECK(!IsFinalTx(tx2));\n \n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n \n     // Neither tx should have make it into the template.\n     BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 1);\n@@ -252,7 +251,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n     BOOST_CHECK(IsFinalTx(tx, chainActive.Tip()->nHeight + 1));\n     BOOST_CHECK(IsFinalTx(tx2));\n \n-    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey, pindexPrev));\n+    BOOST_CHECK(pblocktemplate = CreateNewBlock(scriptPubKey));\n     BOOST_CHECK_EQUAL(pblocktemplate->block.vtx.size(), 3);\n     delete pblocktemplate;\n "
      }
    ]
  }
]