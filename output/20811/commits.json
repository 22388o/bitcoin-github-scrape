[
  {
    "sha": "0d246a59b606c51728d10cb70004a6eedb951bca",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZDI0NmE1OWI2MDZjNTE3MjhkMTBjYjcwMDA0YTZlZWRiOTUxYmNh",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-07T02:27:22Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-09T13:27:45Z"
      },
      "message": "net, net_processing: move NetEventsInterface method docs to net.h",
      "tree": {
        "sha": "0400ab70ade009473022283d994d7b1e4b1edfb5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0400ab70ade009473022283d994d7b1e4b1edfb5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0d246a59b606c51728d10cb70004a6eedb951bca",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d246a59b606c51728d10cb70004a6eedb951bca",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0d246a59b606c51728d10cb70004a6eedb951bca",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d246a59b606c51728d10cb70004a6eedb951bca/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9158d6f34153dc937e109d0e7486e956a26f20aa",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9158d6f34153dc937e109d0e7486e956a26f20aa",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9158d6f34153dc937e109d0e7486e956a26f20aa"
      }
    ],
    "stats": {
      "total": 37,
      "additions": 21,
      "deletions": 16
    },
    "files": [
      {
        "sha": "63214e062b847b7e46212d38d3640ed6b655f55d",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 21,
        "deletions": 2,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0d246a59b606c51728d10cb70004a6eedb951bca/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0d246a59b606c51728d10cb70004a6eedb951bca/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=0d246a59b606c51728d10cb70004a6eedb951bca",
        "patch": "@@ -769,11 +769,30 @@ class CNode\n class NetEventsInterface\n {\n public:\n-    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n-    virtual bool SendMessages(CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(pnode->cs_sendProcessing) = 0;\n+    /** Initialize a peer (setup state, queue any initial messages) */\n     virtual void InitializeNode(CNode* pnode) = 0;\n+\n+    /** Handle removal of a peer (clear state) */\n     virtual void FinalizeNode(const CNode& node, bool& update_connection_time) = 0;\n \n+    /**\n+    * Process protocol messages received from a given node\n+    *\n+    * @param[in]   pnode           The node which we have received messages from.\n+    * @param[in]   interrupt       Interrupt condition for processing threads\n+    * @return                      True if there is more work to be done\n+    */\n+    virtual bool ProcessMessages(CNode* pnode, std::atomic<bool>& interrupt) = 0;\n+\n+    /**\n+    * Send queued protocol messages to a given node.\n+    *\n+    * @param[in]   pnode           The node which we are sending messages to.\n+    * @return                      True if there is more work to be done\n+    */\n+    virtual bool SendMessages(CNode* pnode) EXCLUSIVE_LOCKS_REQUIRED(pnode->cs_sendProcessing) = 0;\n+\n+\n protected:\n     /**\n      * Protected destructor so that instances can only be deleted by derived classes."
      },
      {
        "sha": "076dce17131b98f7c9e7da798f2c89d493fc433c",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 0,
        "deletions": 14,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0d246a59b606c51728d10cb70004a6eedb951bca/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0d246a59b606c51728d10cb70004a6eedb951bca/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=0d246a59b606c51728d10cb70004a6eedb951bca",
        "patch": "@@ -118,23 +118,9 @@ class PeerManager final : public CValidationInterface, public NetEventsInterface\n      */\n     void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n \n-    /** Initialize a peer by adding it to mapNodeState and pushing a message requesting its version */\n     void InitializeNode(CNode* pnode) override;\n-    /** Handle removal of a peer by updating various state and removing it from mapNodeState */\n     void FinalizeNode(const CNode& node, bool& fUpdateConnectionTime) override;\n-    /**\n-    * Process protocol messages received from a given node\n-    *\n-    * @param[in]   pfrom           The node which we have received messages from.\n-    * @param[in]   interrupt       Interrupt condition for processing threads\n-    */\n     bool ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt) override;\n-    /**\n-    * Send queued protocol messages to be sent to a give node.\n-    *\n-    * @param[in]   pto             The node which we are sending messages to.\n-    * @return                      True if there is more work to be done\n-    */\n     bool SendMessages(CNode* pto) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n \n     /** Consider evicting an outbound peer based on the amount of time they've been behind our tip */"
      }
    ]
  },
  {
    "sha": "0df3d3fd6bbbd0e06116797177ba797580553250",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZGYzZDNmZDZiYmJkMGUwNjExNjc5NzE3N2JhNzk3NTgwNTUzMjUw",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T07:14:08Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-09T13:27:45Z"
      },
      "message": "net_processing: make more of PeerManager private",
      "tree": {
        "sha": "b5cf0e8df62688cd214b44cd71294cb1f8aa05ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b5cf0e8df62688cd214b44cd71294cb1f8aa05ea"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0df3d3fd6bbbd0e06116797177ba797580553250",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0df3d3fd6bbbd0e06116797177ba797580553250",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0df3d3fd6bbbd0e06116797177ba797580553250",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0df3d3fd6bbbd0e06116797177ba797580553250/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0d246a59b606c51728d10cb70004a6eedb951bca",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d246a59b606c51728d10cb70004a6eedb951bca",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0d246a59b606c51728d10cb70004a6eedb951bca"
      }
    ],
    "stats": {
      "total": 56,
      "additions": 26,
      "deletions": 30
    },
    "files": [
      {
        "sha": "28d0c34d78cadfbff26cfe0a9d832f9d919e2f39",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 26,
        "deletions": 30,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0df3d3fd6bbbd0e06116797177ba797580553250/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0df3d3fd6bbbd0e06116797177ba797580553250/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=0df3d3fd6bbbd0e06116797177ba797580553250",
        "patch": "@@ -100,41 +100,27 @@ class PeerManager final : public CValidationInterface, public NetEventsInterface\n                 CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n                 bool ignore_incoming_txs);\n \n-    /**\n-     * Overridden from CValidationInterface.\n-     */\n+    /** Overridden from CValidationInterface. */\n     void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected) override;\n     void BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex* pindex) override;\n-    /**\n-     * Overridden from CValidationInterface.\n-     */\n     void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n-    /**\n-     * Overridden from CValidationInterface.\n-     */\n     void BlockChecked(const CBlock& block, const BlockValidationState& state) override;\n-    /**\n-     * Overridden from CValidationInterface.\n-     */\n     void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n \n+    /** Implement NetEventsInterface */\n     void InitializeNode(CNode* pnode) override;\n     void FinalizeNode(const CNode& node, bool& fUpdateConnectionTime) override;\n     bool ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt) override;\n     bool SendMessages(CNode* pto) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n \n-    /** Consider evicting an outbound peer based on the amount of time they've been behind our tip */\n-    void ConsiderEviction(CNode& pto, int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    /** Evict extra outbound peers. If we think our tip may be stale, connect to an extra outbound */\n-    void CheckForStaleTipAndEvictPeers();\n-    /** If we have extra outbound peers, try to disconnect the one with the oldest block announcement */\n-    void EvictExtraOutboundPeers(int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-    /** Retrieve unbroadcast transactions from the mempool and reattempt sending to peers */\n-    void ReattemptInitialBroadcast(CScheduler& scheduler) const;\n+    /** Get statistics from node state */\n+    bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats);\n \n-    /** Process a single message from a peer. Public for fuzz testing */\n-    void ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n-                        const std::chrono::microseconds time_received, const std::atomic<bool>& interruptMsgProc);\n+    /** Whether this node ignores txs received over p2p. */\n+    bool IgnoresIncomingTxs() { return m_ignore_incoming_txs; };\n+\n+    /** Set the best height */\n+    void SetBestHeight(int height) { m_best_height = height; };\n \n     /**\n      * Increment peer's misbehavior score. If the new value >= DISCOURAGEMENT_THRESHOLD, mark the node\n@@ -143,16 +129,26 @@ class PeerManager final : public CValidationInterface, public NetEventsInterface\n      */\n     void Misbehaving(const NodeId pnode, const int howmuch, const std::string& message);\n \n-    /** Get statistics from node state */\n-    bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats);\n-\n-    /** Set the best height */\n-    void SetBestHeight(int height) { m_best_height = height; };\n+    /**\n+     * Evict extra outbound peers. If we think our tip may be stale, connect to an extra outbound.\n+     * Public for unit testing.\n+     */\n+    void CheckForStaleTipAndEvictPeers();\n \n-    /** Whether this node ignores txs received over p2p. */\n-    bool IgnoresIncomingTxs() { return m_ignore_incoming_txs; };\n+    /** Process a single message from a peer. Public for fuzz testing */\n+    void ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n+                        const std::chrono::microseconds time_received, const std::atomic<bool>& interruptMsgProc);\n \n private:\n+    /** Consider evicting an outbound peer based on the amount of time they've been behind our tip */\n+    void ConsiderEviction(CNode& pto, int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /** If we have extra outbound peers, try to disconnect the one with the oldest block announcement */\n+    void EvictExtraOutboundPeers(int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /** Retrieve unbroadcast transactions from the mempool and reattempt sending to peers */\n+    void ReattemptInitialBroadcast(CScheduler& scheduler) const;\n+\n     /** Get a shared pointer to the Peer object.\n      *  May return an empty shared_ptr if the Peer object can't be found. */\n     PeerRef GetPeerRef(NodeId id) const;"
      }
    ]
  },
  {
    "sha": "a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNTY4YjgyZmViYjNlY2JkNWViYjdjM2Y5ZGEyN2U3NjJiMGM2OGY2",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T07:35:33Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-09T13:27:45Z"
      },
      "message": "net_processing: split PeerManager into interface and implementation classes",
      "tree": {
        "sha": "6c7ad758ba58cc09978c415ebe951b5bf0317e5c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6c7ad758ba58cc09978c415ebe951b5bf0317e5c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0df3d3fd6bbbd0e06116797177ba797580553250",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0df3d3fd6bbbd0e06116797177ba797580553250",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0df3d3fd6bbbd0e06116797177ba797580553250"
      }
    ],
    "stats": {
      "total": 176,
      "additions": 104,
      "deletions": 72
    },
    "files": [
      {
        "sha": "09eb76eaeeb634793520667e260c962375d40311",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6",
        "patch": "@@ -1410,8 +1410,8 @@ bool AppInitMain(const util::Ref& context, NodeContext& node, interfaces::BlockA\n     ChainstateManager& chainman = *Assert(node.chainman);\n \n     assert(!node.peerman);\n-    node.peerman = std::make_unique<PeerManager>(chainparams, *node.connman, node.banman.get(),\n-                                                 *node.scheduler, chainman, *node.mempool, ignores_incoming_txs);\n+    node.peerman = PeerManager::make(chainparams, *node.connman, node.banman.get(),\n+                                     *node.scheduler, chainman, *node.mempool, ignores_incoming_txs);\n     RegisterValidationInterface(node.peerman.get());\n \n     // sanitize comments per BIP-0014, format user agent and check total size"
      },
      {
        "sha": "bfa654af11ea07b241f5dff5de9e315c4f679775",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 48,
        "deletions": 35,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6",
        "patch": "@@ -683,7 +683,7 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n \n } // namespace\n \n-void PeerManager::PushNodeVersion(CNode& pnode, int64_t nTime)\n+void PeerManagerImpl::PushNodeVersion(CNode& pnode, int64_t nTime)\n {\n     // Note that pnode->GetLocalServices() is a reflection of the local\n     // services we were offering when the CNode object was created for this\n@@ -709,7 +709,7 @@ void PeerManager::PushNodeVersion(CNode& pnode, int64_t nTime)\n     }\n }\n \n-void PeerManager::AddTxAnnouncement(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n+void PeerManagerImpl::AddTxAnnouncement(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n {\n     AssertLockHeld(::cs_main); // For m_txrequest\n     NodeId nodeid = node.GetId();\n@@ -745,7 +745,8 @@ void UpdateLastBlockAnnounceTime(NodeId node, int64_t time_in_seconds)\n     if (state) state->m_last_block_announcement = time_in_seconds;\n }\n \n-void PeerManager::InitializeNode(CNode *pnode) {\n+void PeerManagerImpl::InitializeNode(CNode *pnode)\n+{\n     CAddress addr = pnode->addr;\n     std::string addrName = pnode->GetAddrName();\n     NodeId nodeid = pnode->GetId();\n@@ -764,7 +765,7 @@ void PeerManager::InitializeNode(CNode *pnode) {\n     }\n }\n \n-void PeerManager::ReattemptInitialBroadcast(CScheduler& scheduler) const\n+void PeerManagerImpl::ReattemptInitialBroadcast(CScheduler& scheduler) const\n {\n     std::set<uint256> unbroadcast_txids = m_mempool.GetUnbroadcastTxs();\n \n@@ -785,7 +786,8 @@ void PeerManager::ReattemptInitialBroadcast(CScheduler& scheduler) const\n     scheduler.scheduleFromNow([&] { ReattemptInitialBroadcast(scheduler); }, delta);\n }\n \n-void PeerManager::FinalizeNode(const CNode& node, bool& fUpdateConnectionTime) {\n+void PeerManagerImpl::FinalizeNode(const CNode& node, bool& fUpdateConnectionTime)\n+{\n     NodeId nodeid = node.GetId();\n     fUpdateConnectionTime = false;\n     LOCK(cs_main);\n@@ -839,14 +841,14 @@ void PeerManager::FinalizeNode(const CNode& node, bool& fUpdateConnectionTime) {\n     LogPrint(BCLog::NET, \"Cleared nodestate for peer=%d\\n\", nodeid);\n }\n \n-PeerRef PeerManager::GetPeerRef(NodeId id) const\n+PeerRef PeerManagerImpl::GetPeerRef(NodeId id) const\n {\n     LOCK(m_peer_mutex);\n     auto it = m_peer_map.find(id);\n     return it != m_peer_map.end() ? it->second : nullptr;\n }\n \n-PeerRef PeerManager::RemovePeer(NodeId id)\n+PeerRef PeerManagerImpl::RemovePeer(NodeId id)\n {\n     PeerRef ret;\n     LOCK(m_peer_mutex);\n@@ -858,7 +860,8 @@ PeerRef PeerManager::RemovePeer(NodeId id)\n     return ret;\n }\n \n-bool PeerManager::GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n+bool PeerManagerImpl::GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats)\n+{\n     {\n         LOCK(cs_main);\n         CNodeState* state = State(nodeid);\n@@ -1015,7 +1018,7 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans)\n     return nEvicted;\n }\n \n-void PeerManager::Misbehaving(const NodeId pnode, const int howmuch, const std::string& message)\n+void PeerManagerImpl::Misbehaving(const NodeId pnode, const int howmuch, const std::string& message)\n {\n     assert(howmuch > 0);\n \n@@ -1033,8 +1036,8 @@ void PeerManager::Misbehaving(const NodeId pnode, const int howmuch, const std::\n     }\n }\n \n-bool PeerManager::MaybePunishNodeForBlock(NodeId nodeid, const BlockValidationState& state,\n-                                          bool via_compact_block, const std::string& message)\n+bool PeerManagerImpl::MaybePunishNodeForBlock(NodeId nodeid, const BlockValidationState& state,\n+                                              bool via_compact_block, const std::string& message)\n {\n     switch (state.GetResult()) {\n     case BlockValidationResult::BLOCK_RESULT_UNSET:\n@@ -1083,7 +1086,7 @@ bool PeerManager::MaybePunishNodeForBlock(NodeId nodeid, const BlockValidationSt\n     return false;\n }\n \n-bool PeerManager::MaybePunishNodeForTx(NodeId nodeid, const TxValidationState& state, const std::string& message)\n+bool PeerManagerImpl::MaybePunishNodeForTx(NodeId nodeid, const TxValidationState& state, const std::string& message)\n {\n     switch (state.GetResult()) {\n     case TxValidationResult::TX_RESULT_UNSET:\n@@ -1129,9 +1132,16 @@ static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Para\n         (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);\n }\n \n-PeerManager::PeerManager(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n-                         CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n-                         bool ignore_incoming_txs)\n+std::unique_ptr<PeerManager> PeerManager::make(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n+                                               CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n+                                               bool ignore_incoming_txs)\n+{\n+    return std::make_unique<PeerManagerImpl>(chainparams, connman, banman, scheduler, chainman, pool, ignore_incoming_txs);\n+}\n+\n+PeerManagerImpl::PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n+                                 CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n+                                 bool ignore_incoming_txs)\n     : m_chainparams(chainparams),\n       m_connman(connman),\n       m_banman(banman),\n@@ -1171,7 +1181,7 @@ PeerManager::PeerManager(const CChainParams& chainparams, CConnman& connman, Ban\n  * block, remember the recently confirmed transactions, and delete tracked\n  * announcements for them. Also save the time of the last tip update.\n  */\n-void PeerManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindex)\n+void PeerManagerImpl::BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindex)\n {\n     {\n         LOCK(g_cs_orphans);\n@@ -1222,7 +1232,7 @@ void PeerManager::BlockConnected(const std::shared_ptr<const CBlock>& pblock, co\n     }\n }\n \n-void PeerManager::BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex* pindex)\n+void PeerManagerImpl::BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex* pindex)\n {\n     // To avoid relay problems with transactions that were previously\n     // confirmed, clear our filter of recently confirmed transactions whenever\n@@ -1247,7 +1257,8 @@ static bool fWitnessesPresentInMostRecentCompactBlock GUARDED_BY(cs_most_recent_\n  * Maintain state about the best-seen block and fast-announce a compact block\n  * to compatible peers.\n  */\n-void PeerManager::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) {\n+void PeerManagerImpl::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock)\n+{\n     std::shared_ptr<const CBlockHeaderAndShortTxIDs> pcmpctblock = std::make_shared<const CBlockHeaderAndShortTxIDs> (*pblock, true);\n     const CNetMsgMaker msgMaker(PROTOCOL_VERSION);\n \n@@ -1294,9 +1305,9 @@ void PeerManager::NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_\n  * Update our best height and announce any block hashes which weren't previously\n  * in ::ChainActive() to our peers.\n  */\n-void PeerManager::UpdatedBlockTip(const CBlockIndex* pindexNew, const CBlockIndex* pindexFork, bool fInitialDownload)\n+void PeerManagerImpl::UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload)\n {\n-    m_best_height = pindexNew->nHeight;\n+    SetBestHeight(pindexNew->nHeight);\n     SetServiceFlagsIBDCache(!fInitialDownload);\n \n     // Don't relay inventory during initial block download.\n@@ -1333,7 +1344,8 @@ void PeerManager::UpdatedBlockTip(const CBlockIndex* pindexNew, const CBlockInde\n  * Handle invalid block rejection and consequent peer discouragement, maintain which\n  * peers announce compact blocks.\n  */\n-void PeerManager::BlockChecked(const CBlock& block, const BlockValidationState& state) {\n+void PeerManagerImpl::BlockChecked(const CBlock& block, const BlockValidationState& state)\n+{\n     LOCK(cs_main);\n \n     const uint256 hash(block.GetHash());\n@@ -1761,7 +1773,8 @@ static uint32_t GetFetchFlags(const CNode& pfrom) EXCLUSIVE_LOCKS_REQUIRED(cs_ma\n     return nFetchFlags;\n }\n \n-void PeerManager::SendBlockTransactions(CNode& pfrom, const CBlock& block, const BlockTransactionsRequest& req) {\n+void PeerManagerImpl::SendBlockTransactions(CNode& pfrom, const CBlock& block, const BlockTransactionsRequest& req)\n+{\n     BlockTransactions resp(req);\n     for (size_t i = 0; i < req.indexes.size(); i++) {\n         if (req.indexes[i] >= block.vtx.size()) {\n@@ -1776,9 +1789,9 @@ void PeerManager::SendBlockTransactions(CNode& pfrom, const CBlock& block, const\n     m_connman.PushMessage(&pfrom, msgMaker.Make(nSendFlags, NetMsgType::BLOCKTXN, resp));\n }\n \n-void PeerManager::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n-                                        const std::vector<CBlockHeader>& headers,\n-                                        bool via_compact_block)\n+void PeerManagerImpl::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n+                                            const std::vector<CBlockHeader>& headers,\n+                                            bool via_compact_block)\n {\n     const CNetMsgMaker msgMaker(pfrom.GetCommonVersion());\n     size_t nCount = headers.size();\n@@ -1970,7 +1983,7 @@ void PeerManager::ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n  *                                  may be added to if accepting an orphan causes its children to be\n  *                                  reconsidered.\n  */\n-void PeerManager::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n+void PeerManagerImpl::ProcessOrphanTx(std::set<uint256>& orphan_work_set)\n {\n     AssertLockHeld(cs_main);\n     AssertLockHeld(g_cs_orphans);\n@@ -2267,9 +2280,9 @@ static void ProcessGetCFCheckPt(CNode& peer, CDataStream& vRecv, const CChainPar\n     connman.PushMessage(&peer, std::move(msg));\n }\n \n-void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n-                                         const std::chrono::microseconds time_received,\n-                                         const std::atomic<bool>& interruptMsgProc)\n+void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n+                                     const std::chrono::microseconds time_received,\n+                                     const std::atomic<bool>& interruptMsgProc)\n {\n     LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(msg_type), vRecv.size(), pfrom.GetId());\n \n@@ -3756,7 +3769,7 @@ void PeerManager::ProcessMessage(CNode& pfrom, const std::string& msg_type, CDat\n     return;\n }\n \n-bool PeerManager::MaybeDiscourageAndDisconnect(CNode& pnode)\n+bool PeerManagerImpl::MaybeDiscourageAndDisconnect(CNode& pnode)\n {\n     const NodeId peer_id{pnode.GetId()};\n     PeerRef peer = GetPeerRef(peer_id);\n@@ -3798,7 +3811,7 @@ bool PeerManager::MaybeDiscourageAndDisconnect(CNode& pnode)\n     return true;\n }\n \n-bool PeerManager::ProcessMessages(CNode* pfrom, std::atomic<bool>& interruptMsgProc)\n+bool PeerManagerImpl::ProcessMessages(CNode* pfrom, std::atomic<bool>& interruptMsgProc)\n {\n     bool fMoreWork = false;\n \n@@ -3873,7 +3886,7 @@ bool PeerManager::ProcessMessages(CNode* pfrom, std::atomic<bool>& interruptMsgP\n     return fMoreWork;\n }\n \n-void PeerManager::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n+void PeerManagerImpl::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n {\n     AssertLockHeld(cs_main);\n \n@@ -3926,7 +3939,7 @@ void PeerManager::ConsiderEviction(CNode& pto, int64_t time_in_seconds)\n     }\n }\n \n-void PeerManager::EvictExtraOutboundPeers(int64_t time_in_seconds)\n+void PeerManagerImpl::EvictExtraOutboundPeers(int64_t time_in_seconds)\n {\n     // If we have any extra block-relay-only peers, disconnect the youngest unless\n     // it's given us a block -- in which case, compare with the second-youngest, and\n@@ -4027,7 +4040,7 @@ void PeerManager::EvictExtraOutboundPeers(int64_t time_in_seconds)\n     }\n }\n \n-void PeerManager::CheckForStaleTipAndEvictPeers()\n+void PeerManagerImpl::CheckForStaleTipAndEvictPeers()\n {\n     LOCK(cs_main);\n \n@@ -4074,7 +4087,7 @@ class CompareInvMempoolOrder\n };\n }\n \n-bool PeerManager::SendMessages(CNode* pto)\n+bool PeerManagerImpl::SendMessages(CNode* pto)\n {\n     PeerRef peer = GetPeerRef(pto->GetId());\n     const Consensus::Params& consensusParams = m_chainparams.GetConsensus();"
      },
      {
        "sha": "7c9923d8e41f14d99d33bc2f7ccc248223477274",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 42,
        "deletions": 23,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6",
        "patch": "@@ -94,50 +94,69 @@ struct Peer {\n \n using PeerRef = std::shared_ptr<Peer>;\n \n-class PeerManager final : public CValidationInterface, public NetEventsInterface {\n+class PeerManager : public CValidationInterface, public NetEventsInterface\n+{\n public:\n-    PeerManager(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n-                CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n-                bool ignore_incoming_txs);\n-\n-    /** Overridden from CValidationInterface. */\n-    void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected) override;\n-    void BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex* pindex) override;\n-    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n-    void BlockChecked(const CBlock& block, const BlockValidationState& state) override;\n-    void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n-\n-    /** Implement NetEventsInterface */\n-    void InitializeNode(CNode* pnode) override;\n-    void FinalizeNode(const CNode& node, bool& fUpdateConnectionTime) override;\n-    bool ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt) override;\n-    bool SendMessages(CNode* pto) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n+    static std::unique_ptr<PeerManager> make(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n+                                             CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n+                                             bool ignore_incoming_txs);\n+    virtual ~PeerManager() { }\n \n     /** Get statistics from node state */\n-    bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats);\n+    virtual bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) = 0;\n \n     /** Whether this node ignores txs received over p2p. */\n-    bool IgnoresIncomingTxs() { return m_ignore_incoming_txs; };\n+    virtual bool IgnoresIncomingTxs() = 0;\n \n     /** Set the best height */\n-    void SetBestHeight(int height) { m_best_height = height; };\n+    virtual void SetBestHeight(int height) = 0;\n \n     /**\n      * Increment peer's misbehavior score. If the new value >= DISCOURAGEMENT_THRESHOLD, mark the node\n      * to be discouraged, meaning the peer might be disconnected and added to the discouragement filter.\n      * Public for unit testing.\n      */\n-    void Misbehaving(const NodeId pnode, const int howmuch, const std::string& message);\n+    virtual void Misbehaving(const NodeId pnode, const int howmuch, const std::string& message) = 0;\n \n     /**\n      * Evict extra outbound peers. If we think our tip may be stale, connect to an extra outbound.\n      * Public for unit testing.\n      */\n-    void CheckForStaleTipAndEvictPeers();\n+    virtual void CheckForStaleTipAndEvictPeers() = 0;\n \n     /** Process a single message from a peer. Public for fuzz testing */\n+    virtual void ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n+                                const std::chrono::microseconds time_received, const std::atomic<bool>& interruptMsgProc) = 0;\n+};\n+\n+class PeerManagerImpl final : public PeerManager\n+{\n+public:\n+    PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n+                    CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n+                    bool ignore_incoming_txs);\n+\n+    /** Overridden from CValidationInterface. */\n+    void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected) override;\n+    void BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex* pindex) override;\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n+    void BlockChecked(const CBlock& block, const BlockValidationState& state) override;\n+    void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n+\n+    /** Implement NetEventsInterface */\n+    void InitializeNode(CNode* pnode) override;\n+    void FinalizeNode(const CNode& node, bool& fUpdateConnectionTime) override;\n+    bool ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt) override;\n+    bool SendMessages(CNode* pto) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n+\n+    /** Implement PeerManager */\n+    void CheckForStaleTipAndEvictPeers() override;\n+    bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) override;\n+    bool IgnoresIncomingTxs() override { return m_ignore_incoming_txs; }\n+    void SetBestHeight(int height) override { m_best_height = height; };\n+    void Misbehaving(const NodeId pnode, const int howmuch, const std::string& message) override;\n     void ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n-                        const std::chrono::microseconds time_received, const std::atomic<bool>& interruptMsgProc);\n+                        const std::chrono::microseconds time_received, const std::atomic<bool>& interruptMsgProc) override;\n \n private:\n     /** Consider evicting an outbound peer based on the amount of time they've been behind our tip */"
      },
      {
        "sha": "cf6009d59186b5d27b8d49e5bd11cd7887b6e3b3",
        "filename": "src/test/denialofservice_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6/src/test/denialofservice_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6/src/test/denialofservice_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/denialofservice_tests.cpp?ref=a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6",
        "patch": "@@ -80,8 +80,8 @@ BOOST_AUTO_TEST_CASE(outbound_slow_chain_eviction)\n {\n     const CChainParams& chainparams = Params();\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = std::make_unique<PeerManager>(chainparams, *connman, nullptr, *m_node.scheduler,\n-                                                   *m_node.chainman, *m_node.mempool, false);\n+    auto peerLogic = PeerManager::make(chainparams, *connman, nullptr, *m_node.scheduler,\n+                                       *m_node.chainman, *m_node.mempool, false);\n \n     // Mock an outbound peer\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n@@ -150,8 +150,8 @@ BOOST_AUTO_TEST_CASE(stale_tip_peer_management)\n {\n     const CChainParams& chainparams = Params();\n     auto connman = MakeUnique<CConnmanTest>(0x1337, 0x1337);\n-    auto peerLogic = std::make_unique<PeerManager>(chainparams, *connman, nullptr, *m_node.scheduler,\n-                                                   *m_node.chainman, *m_node.mempool, false);\n+    auto peerLogic = PeerManager::make(chainparams, *connman, nullptr, *m_node.scheduler,\n+                                       *m_node.chainman, *m_node.mempool, false);\n \n     constexpr int max_outbound_full_relay = MAX_OUTBOUND_FULL_RELAY_CONNECTIONS;\n     CConnman::Options options;\n@@ -224,8 +224,8 @@ BOOST_AUTO_TEST_CASE(peer_discouragement)\n     const CChainParams& chainparams = Params();\n     auto banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = std::make_unique<PeerManager>(chainparams, *connman, banman.get(), *m_node.scheduler,\n-                                                   *m_node.chainman, *m_node.mempool, false);\n+    auto peerLogic = PeerManager::make(chainparams, *connman, banman.get(), *m_node.scheduler,\n+                                       *m_node.chainman, *m_node.mempool, false);\n \n     banman->ClearBanned();\n     CAddress addr1(ip(0xa0b0c001), NODE_NONE);\n@@ -271,8 +271,8 @@ BOOST_AUTO_TEST_CASE(DoS_bantime)\n     const CChainParams& chainparams = Params();\n     auto banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     auto connman = MakeUnique<CConnman>(0x1337, 0x1337);\n-    auto peerLogic = std::make_unique<PeerManager>(chainparams, *connman, banman.get(), *m_node.scheduler,\n-                                                   *m_node.chainman, *m_node.mempool, false);\n+    auto peerLogic = PeerManager::make(chainparams, *connman, banman.get(), *m_node.scheduler,\n+                                       *m_node.chainman, *m_node.mempool, false);\n \n     banman->ClearBanned();\n     int64_t nStartTime = GetTime();"
      },
      {
        "sha": "738f414cd0355101d2ca4aa58bb9270b7afb898c",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6",
        "patch": "@@ -192,9 +192,9 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n \n     m_node.banman = MakeUnique<BanMan>(GetDataDir() / \"banlist.dat\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     m_node.connman = MakeUnique<CConnman>(0x1337, 0x1337); // Deterministic randomness for tests.\n-    m_node.peerman = std::make_unique<PeerManager>(chainparams, *m_node.connman, m_node.banman.get(),\n-                                                   *m_node.scheduler, *m_node.chainman, *m_node.mempool,\n-                                                   false);\n+    m_node.peerman = PeerManager::make(chainparams, *m_node.connman, m_node.banman.get(),\n+                                       *m_node.scheduler, *m_node.chainman, *m_node.mempool,\n+                                       false);\n     {\n         CConnman::Options options;\n         options.m_msgproc = m_node.peerman.get();"
      },
      {
        "sha": "3a04418e8bc5eb94998aef30d821741c7d2d8c76",
        "filename": "test/sanitizer_suppressions/tsan",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6/test/sanitizer_suppressions/tsan",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6/test/sanitizer_suppressions/tsan",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/sanitizer_suppressions/tsan?ref=a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6",
        "patch": "@@ -13,7 +13,7 @@ mutex:CConnman::ThreadOpenConnections\n mutex:CConnman::ThreadOpenAddedConnections\n mutex:CConnman::SocketHandler\n mutex:UpdateTip\n-mutex:PeerManager::UpdatedBlockTip\n+mutex:PeerManagerImpl::UpdatedBlockTip\n mutex:g_best_block_mutex\n \n # race (TODO fix)"
      }
    ]
  },
  {
    "sha": "e0f2e6d2df7117a8dbf17c63c5149fc53a6fe2b2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMGYyZTZkMmRmNzExN2E4ZGJmMTdjNjNjNTE0OWZjNTNhNmZlMmIy",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-23T07:40:41Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-09T13:27:45Z"
      },
      "message": "net_processing: move PeerManagerImpl into cpp file",
      "tree": {
        "sha": "d1a2cdc026ac055675ad05ca8ac788445d371c8f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d1a2cdc026ac055675ad05ca8ac788445d371c8f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e0f2e6d2df7117a8dbf17c63c5149fc53a6fe2b2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e0f2e6d2df7117a8dbf17c63c5149fc53a6fe2b2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e0f2e6d2df7117a8dbf17c63c5149fc53a6fe2b2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e0f2e6d2df7117a8dbf17c63c5149fc53a6fe2b2/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a568b82febb3ecbd5ebb7c3f9da27e762b0c68f6"
      }
    ],
    "stats": {
      "total": 255,
      "additions": 126,
      "deletions": 129
    },
    "files": [
      {
        "sha": "94e092592b0295d274cd1d06fdb225539c476319",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 126,
        "deletions": 0,
        "changes": 126,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e0f2e6d2df7117a8dbf17c63c5149fc53a6fe2b2/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e0f2e6d2df7117a8dbf17c63c5149fc53a6fe2b2/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=e0f2e6d2df7117a8dbf17c63c5149fc53a6fe2b2",
        "patch": "@@ -26,6 +26,7 @@\n #include <streams.h>\n #include <tinyformat.h>\n #include <txmempool.h>\n+#include <txrequest.h>\n #include <util/check.h> // For NDEBUG compile time check\n #include <util/strencodings.h>\n #include <util/system.h>\n@@ -167,6 +168,131 @@ std::map<uint256, std::map<uint256, COrphanTx>::iterator> g_orphans_by_wtxid GUA\n void EraseOrphansFor(NodeId peer);\n \n // Internal stuff\n+namespace {\n+class PeerManagerImpl final : public PeerManager\n+{\n+public:\n+    PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n+                    CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n+                    bool ignore_incoming_txs);\n+\n+    /** Overridden from CValidationInterface. */\n+    void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected) override;\n+    void BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex* pindex) override;\n+    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n+    void BlockChecked(const CBlock& block, const BlockValidationState& state) override;\n+    void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n+\n+    /** Implement NetEventsInterface */\n+    void InitializeNode(CNode* pnode) override;\n+    void FinalizeNode(const CNode& node, bool& fUpdateConnectionTime) override;\n+    bool ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt) override;\n+    bool SendMessages(CNode* pto) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n+\n+    /** Implement PeerManager */\n+    void CheckForStaleTipAndEvictPeers() override;\n+    bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) override;\n+    bool IgnoresIncomingTxs() override { return m_ignore_incoming_txs; }\n+    void SetBestHeight(int height) override { m_best_height = height; };\n+    void Misbehaving(const NodeId pnode, const int howmuch, const std::string& message) override;\n+    void ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n+                        const std::chrono::microseconds time_received, const std::atomic<bool>& interruptMsgProc) override;\n+\n+private:\n+    /** Consider evicting an outbound peer based on the amount of time they've been behind our tip */\n+    void ConsiderEviction(CNode& pto, int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /** If we have extra outbound peers, try to disconnect the one with the oldest block announcement */\n+    void EvictExtraOutboundPeers(int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n+    /** Retrieve unbroadcast transactions from the mempool and reattempt sending to peers */\n+    void ReattemptInitialBroadcast(CScheduler& scheduler) const;\n+\n+    /** Get a shared pointer to the Peer object.\n+     *  May return an empty shared_ptr if the Peer object can't be found. */\n+    PeerRef GetPeerRef(NodeId id) const;\n+\n+    /** Get a shared pointer to the Peer object and remove it from m_peer_map.\n+     *  May return an empty shared_ptr if the Peer object can't be found. */\n+    PeerRef RemovePeer(NodeId id);\n+\n+    /**\n+     * Potentially mark a node discouraged based on the contents of a BlockValidationState object\n+     *\n+     * @param[in] via_compact_block this bool is passed in because net_processing should\n+     * punish peers differently depending on whether the data was provided in a compact\n+     * block message or not. If the compact block had a valid header, but contained invalid\n+     * txs, the peer should not be punished. See BIP 152.\n+     *\n+     * @return Returns true if the peer was punished (probably disconnected)\n+     */\n+    bool MaybePunishNodeForBlock(NodeId nodeid, const BlockValidationState& state,\n+                                 bool via_compact_block, const std::string& message = \"\");\n+\n+    /**\n+     * Potentially disconnect and discourage a node based on the contents of a TxValidationState object\n+     *\n+     * @return Returns true if the peer was punished (probably disconnected)\n+     */\n+    bool MaybePunishNodeForTx(NodeId nodeid, const TxValidationState& state, const std::string& message = \"\");\n+\n+    /** Maybe disconnect a peer and discourage future connections from its address.\n+     *\n+     * @param[in]   pnode     The node to check.\n+     * @return                True if the peer was marked for disconnection in this function\n+     */\n+    bool MaybeDiscourageAndDisconnect(CNode& pnode);\n+\n+    void ProcessOrphanTx(std::set<uint256>& orphan_work_set) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans);\n+    /** Process a single headers message from a peer. */\n+    void ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n+                               const std::vector<CBlockHeader>& headers,\n+                               bool via_compact_block);\n+\n+    void SendBlockTransactions(CNode& pfrom, const CBlock& block, const BlockTransactionsRequest& req);\n+\n+    /** Register with TxRequestTracker that an INV has been received from a\n+     *  peer. The announcement parameters are decided in PeerManager and then\n+     *  passed to TxRequestTracker. */\n+    void AddTxAnnouncement(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n+        EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n+\n+    /** Send a version message to a peer */\n+    void PushNodeVersion(CNode& pnode, int64_t nTime);\n+\n+    const CChainParams& m_chainparams;\n+    CConnman& m_connman;\n+    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n+    BanMan* const m_banman;\n+    ChainstateManager& m_chainman;\n+    CTxMemPool& m_mempool;\n+    TxRequestTracker m_txrequest GUARDED_BY(::cs_main);\n+\n+    /** The height of the best chain */\n+    std::atomic<int> m_best_height{-1};\n+\n+    int64_t m_stale_tip_check_time; //!< Next time to check for stale tip\n+\n+    /** Whether this node is running in blocks only mode */\n+    const bool m_ignore_incoming_txs;\n+\n+    /** Whether we've completed initial sync yet, for determining when to turn\n+      * on extra block-relay-only peers. */\n+    bool m_initial_sync_finished{false};\n+\n+    /** Protects m_peer_map. This mutex must not be locked while holding a lock\n+     *  on any of the mutexes inside a Peer object. */\n+    mutable Mutex m_peer_mutex;\n+    /**\n+     * Map of all Peer objects, keyed by peer id. This map is protected\n+     * by the m_peer_mutex. Once a shared pointer reference is\n+     * taken, the lock may be released. Individual fields are protected by\n+     * their own locks.\n+     */\n+    std::map<NodeId, PeerRef> m_peer_map GUARDED_BY(m_peer_mutex);\n+};\n+} // namespace\n+\n namespace {\n     /** Number of nodes with fSyncStarted. */\n     int nSyncStarted GUARDED_BY(cs_main) = 0;"
      },
      {
        "sha": "e86997190a849da9df1783db103b0ce324ee7f55",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 0,
        "deletions": 129,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e0f2e6d2df7117a8dbf17c63c5149fc53a6fe2b2/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e0f2e6d2df7117a8dbf17c63c5149fc53a6fe2b2/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=e0f2e6d2df7117a8dbf17c63c5149fc53a6fe2b2",
        "patch": "@@ -6,19 +6,13 @@\n #ifndef BITCOIN_NET_PROCESSING_H\n #define BITCOIN_NET_PROCESSING_H\n \n-#include <consensus/params.h>\n #include <net.h>\n #include <sync.h>\n-#include <txrequest.h>\n #include <validationinterface.h>\n \n-class BlockTransactionsRequest;\n-class BlockValidationState;\n-class CBlockHeader;\n class CChainParams;\n class CTxMemPool;\n class ChainstateManager;\n-class TxValidationState;\n \n extern RecursiveMutex cs_main;\n extern RecursiveMutex g_cs_orphans;\n@@ -129,129 +123,6 @@ class PeerManager : public CValidationInterface, public NetEventsInterface\n                                 const std::chrono::microseconds time_received, const std::atomic<bool>& interruptMsgProc) = 0;\n };\n \n-class PeerManagerImpl final : public PeerManager\n-{\n-public:\n-    PeerManagerImpl(const CChainParams& chainparams, CConnman& connman, BanMan* banman,\n-                    CScheduler& scheduler, ChainstateManager& chainman, CTxMemPool& pool,\n-                    bool ignore_incoming_txs);\n-\n-    /** Overridden from CValidationInterface. */\n-    void BlockConnected(const std::shared_ptr<const CBlock>& pblock, const CBlockIndex* pindexConnected) override;\n-    void BlockDisconnected(const std::shared_ptr<const CBlock> &block, const CBlockIndex* pindex) override;\n-    void UpdatedBlockTip(const CBlockIndex *pindexNew, const CBlockIndex *pindexFork, bool fInitialDownload) override;\n-    void BlockChecked(const CBlock& block, const BlockValidationState& state) override;\n-    void NewPoWValidBlock(const CBlockIndex *pindex, const std::shared_ptr<const CBlock>& pblock) override;\n-\n-    /** Implement NetEventsInterface */\n-    void InitializeNode(CNode* pnode) override;\n-    void FinalizeNode(const CNode& node, bool& fUpdateConnectionTime) override;\n-    bool ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt) override;\n-    bool SendMessages(CNode* pto) override EXCLUSIVE_LOCKS_REQUIRED(pto->cs_sendProcessing);\n-\n-    /** Implement PeerManager */\n-    void CheckForStaleTipAndEvictPeers() override;\n-    bool GetNodeStateStats(NodeId nodeid, CNodeStateStats& stats) override;\n-    bool IgnoresIncomingTxs() override { return m_ignore_incoming_txs; }\n-    void SetBestHeight(int height) override { m_best_height = height; };\n-    void Misbehaving(const NodeId pnode, const int howmuch, const std::string& message) override;\n-    void ProcessMessage(CNode& pfrom, const std::string& msg_type, CDataStream& vRecv,\n-                        const std::chrono::microseconds time_received, const std::atomic<bool>& interruptMsgProc) override;\n-\n-private:\n-    /** Consider evicting an outbound peer based on the amount of time they've been behind our tip */\n-    void ConsiderEviction(CNode& pto, int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n-    /** If we have extra outbound peers, try to disconnect the one with the oldest block announcement */\n-    void EvictExtraOutboundPeers(int64_t time_in_seconds) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-\n-    /** Retrieve unbroadcast transactions from the mempool and reattempt sending to peers */\n-    void ReattemptInitialBroadcast(CScheduler& scheduler) const;\n-\n-    /** Get a shared pointer to the Peer object.\n-     *  May return an empty shared_ptr if the Peer object can't be found. */\n-    PeerRef GetPeerRef(NodeId id) const;\n-\n-    /** Get a shared pointer to the Peer object and remove it from m_peer_map.\n-     *  May return an empty shared_ptr if the Peer object can't be found. */\n-    PeerRef RemovePeer(NodeId id);\n-\n-    /**\n-     * Potentially mark a node discouraged based on the contents of a BlockValidationState object\n-     *\n-     * @param[in] via_compact_block this bool is passed in because net_processing should\n-     * punish peers differently depending on whether the data was provided in a compact\n-     * block message or not. If the compact block had a valid header, but contained invalid\n-     * txs, the peer should not be punished. See BIP 152.\n-     *\n-     * @return Returns true if the peer was punished (probably disconnected)\n-     */\n-    bool MaybePunishNodeForBlock(NodeId nodeid, const BlockValidationState& state,\n-                                 bool via_compact_block, const std::string& message = \"\");\n-\n-    /**\n-     * Potentially disconnect and discourage a node based on the contents of a TxValidationState object\n-     *\n-     * @return Returns true if the peer was punished (probably disconnected)\n-     */\n-    bool MaybePunishNodeForTx(NodeId nodeid, const TxValidationState& state, const std::string& message = \"\");\n-\n-    /** Maybe disconnect a peer and discourage future connections from its address.\n-     *\n-     * @param[in]   pnode     The node to check.\n-     * @return                True if the peer was marked for disconnection in this function\n-     */\n-    bool MaybeDiscourageAndDisconnect(CNode& pnode);\n-\n-    void ProcessOrphanTx(std::set<uint256>& orphan_work_set) EXCLUSIVE_LOCKS_REQUIRED(cs_main, g_cs_orphans);\n-    /** Process a single headers message from a peer. */\n-    void ProcessHeadersMessage(CNode& pfrom, const Peer& peer,\n-                               const std::vector<CBlockHeader>& headers,\n-                               bool via_compact_block);\n-\n-    void SendBlockTransactions(CNode& pfrom, const CBlock& block, const BlockTransactionsRequest& req);\n-\n-    /** Register with TxRequestTracker that an INV has been received from a\n-     *  peer. The announcement parameters are decided in PeerManager and then\n-     *  passed to TxRequestTracker. */\n-    void AddTxAnnouncement(const CNode& node, const GenTxid& gtxid, std::chrono::microseconds current_time)\n-        EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n-\n-    /** Send a version message to a peer */\n-    void PushNodeVersion(CNode& pnode, int64_t nTime);\n-\n-    const CChainParams& m_chainparams;\n-    CConnman& m_connman;\n-    /** Pointer to this node's banman. May be nullptr - check existence before dereferencing. */\n-    BanMan* const m_banman;\n-    ChainstateManager& m_chainman;\n-    CTxMemPool& m_mempool;\n-    TxRequestTracker m_txrequest GUARDED_BY(::cs_main);\n-\n-    /** The height of the best chain */\n-    std::atomic<int> m_best_height{-1};\n-\n-    int64_t m_stale_tip_check_time; //!< Next time to check for stale tip\n-\n-    /** Whether this node is running in blocks only mode */\n-    const bool m_ignore_incoming_txs;\n-\n-    /** Whether we've completed initial sync yet, for determining when to turn\n-      * on extra block-relay-only peers. */\n-    bool m_initial_sync_finished{false};\n-\n-    /** Protects m_peer_map. This mutex must not be locked while holding a lock\n-     *  on any of the mutexes inside a Peer object. */\n-    mutable Mutex m_peer_mutex;\n-    /**\n-     * Map of all Peer objects, keyed by peer id. This map is protected\n-     * by the m_peer_mutex. Once a shared pointer reference is\n-     * taken, the lock may be released. Individual fields are protected by\n-     * their own locks.\n-     */\n-    std::map<NodeId, PeerRef> m_peer_map GUARDED_BY(m_peer_mutex);\n-};\n-\n /** Relay transaction to every node */\n void RelayTransaction(const uint256& txid, const uint256& wtxid, const CConnman& connman) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n "
      }
    ]
  },
  {
    "sha": "c97f70c861ac6959b8116a9bca3031edeb2b2aaa",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjOTdmNzBjODYxYWM2OTU5YjgxMTZhOWJjYTMwMzFlZGViMmIyYWFh",
    "commit": {
      "author": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2020-12-30T08:41:45Z"
      },
      "committer": {
        "name": "Anthony Towns",
        "email": "aj@erisian.com.au",
        "date": "2021-01-09T13:27:45Z"
      },
      "message": "net_processing: move Peer definition to .cpp",
      "tree": {
        "sha": "70af0a75d2d5bdde1030051f64e9401eddb15301",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/70af0a75d2d5bdde1030051f64e9401eddb15301"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c97f70c861ac6959b8116a9bca3031edeb2b2aaa",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c97f70c861ac6959b8116a9bca3031edeb2b2aaa",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c97f70c861ac6959b8116a9bca3031edeb2b2aaa",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c97f70c861ac6959b8116a9bca3031edeb2b2aaa/comments",
    "author": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "ajtowns",
      "id": 127186,
      "node_id": "MDQ6VXNlcjEyNzE4Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/127186?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/ajtowns",
      "html_url": "https://github.com/ajtowns",
      "followers_url": "https://api.github.com/users/ajtowns/followers",
      "following_url": "https://api.github.com/users/ajtowns/following{/other_user}",
      "gists_url": "https://api.github.com/users/ajtowns/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/ajtowns/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/ajtowns/subscriptions",
      "organizations_url": "https://api.github.com/users/ajtowns/orgs",
      "repos_url": "https://api.github.com/users/ajtowns/repos",
      "events_url": "https://api.github.com/users/ajtowns/events{/privacy}",
      "received_events_url": "https://api.github.com/users/ajtowns/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e0f2e6d2df7117a8dbf17c63c5149fc53a6fe2b2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e0f2e6d2df7117a8dbf17c63c5149fc53a6fe2b2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e0f2e6d2df7117a8dbf17c63c5149fc53a6fe2b2"
      }
    ],
    "stats": {
      "total": 110,
      "additions": 55,
      "deletions": 55
    },
    "files": [
      {
        "sha": "3faff5dd49851940a37f6c2e0243254b58e6c08a",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 0,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c97f70c861ac6959b8116a9bca3031edeb2b2aaa/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c97f70c861ac6959b8116a9bca3031edeb2b2aaa/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=c97f70c861ac6959b8116a9bca3031edeb2b2aaa",
        "patch": "@@ -169,6 +169,61 @@ void EraseOrphansFor(NodeId peer);\n \n // Internal stuff\n namespace {\n+/**\n+ * Data structure for an individual peer. This struct is not protected by\n+ * cs_main since it does not contain validation-critical data.\n+ *\n+ * Memory is owned by shared pointers and this object is destructed when\n+ * the refcount drops to zero.\n+ *\n+ * Mutexes inside this struct must not be held when locking m_peer_mutex.\n+ *\n+ * TODO: move most members from CNodeState to this structure.\n+ * TODO: move remaining application-layer data members from CNode to this structure.\n+ */\n+struct Peer {\n+    /** Same id as the CNode object for this peer */\n+    const NodeId m_id{0};\n+\n+    /** Protects misbehavior data members */\n+    Mutex m_misbehavior_mutex;\n+    /** Accumulated misbehavior score for this peer */\n+    int m_misbehavior_score GUARDED_BY(m_misbehavior_mutex){0};\n+    /** Whether this peer should be disconnected and marked as discouraged (unless it has the noban permission). */\n+    bool m_should_discourage GUARDED_BY(m_misbehavior_mutex){false};\n+\n+    /** Protects block inventory data members */\n+    Mutex m_block_inv_mutex;\n+    /** List of blocks that we'll announce via an `inv` message.\n+     * There is no final sorting before sending, as they are always sent\n+     * immediately and in the order requested. */\n+    std::vector<uint256> m_blocks_for_inv_relay GUARDED_BY(m_block_inv_mutex);\n+    /** Unfiltered list of blocks that we'd like to announce via a `headers`\n+     * message. If we can't announce via a `headers` message, we'll fall back to\n+     * announcing via `inv`. */\n+    std::vector<uint256> m_blocks_for_headers_relay GUARDED_BY(m_block_inv_mutex);\n+    /** The final block hash that we sent in an `inv` message to this peer.\n+     * When the peer requests this block, we send an `inv` message to trigger\n+     * the peer to request the next sequence of block hashes.\n+     * Most peers use headers-first syncing, which doesn't use this mechanism */\n+    uint256 m_continuation_block GUARDED_BY(m_block_inv_mutex) {};\n+\n+    /** This peer's reported block height when we connected */\n+    std::atomic<int> m_starting_height{-1};\n+\n+    /** Set of txids to reconsider once their parent transactions have been accepted **/\n+    std::set<uint256> m_orphan_work_set GUARDED_BY(g_cs_orphans);\n+\n+    /** Protects m_getdata_requests **/\n+    Mutex m_getdata_requests_mutex;\n+    /** Work queue of items requested by this peer **/\n+    std::deque<CInv> m_getdata_requests GUARDED_BY(m_getdata_requests_mutex);\n+\n+    explicit Peer(NodeId id) : m_id(id) {}\n+};\n+\n+using PeerRef = std::shared_ptr<Peer>;\n+\n class PeerManagerImpl final : public PeerManager\n {\n public:"
      },
      {
        "sha": "eaa3b142a84f13eeadb10101b3eebb6c4d7c15dc",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 0,
        "deletions": 55,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c97f70c861ac6959b8116a9bca3031edeb2b2aaa/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c97f70c861ac6959b8116a9bca3031edeb2b2aaa/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=c97f70c861ac6959b8116a9bca3031edeb2b2aaa",
        "patch": "@@ -33,61 +33,6 @@ struct CNodeStateStats {\n     std::vector<int> vHeightInFlight;\n };\n \n-/**\n- * Data structure for an individual peer. This struct is not protected by\n- * cs_main since it does not contain validation-critical data.\n- *\n- * Memory is owned by shared pointers and this object is destructed when\n- * the refcount drops to zero.\n- *\n- * Mutexes inside this struct must not be held when locking m_peer_mutex.\n- *\n- * TODO: move most members from CNodeState to this structure.\n- * TODO: move remaining application-layer data members from CNode to this structure.\n- */\n-struct Peer {\n-    /** Same id as the CNode object for this peer */\n-    const NodeId m_id{0};\n-\n-    /** Protects misbehavior data members */\n-    Mutex m_misbehavior_mutex;\n-    /** Accumulated misbehavior score for this peer */\n-    int m_misbehavior_score GUARDED_BY(m_misbehavior_mutex){0};\n-    /** Whether this peer should be disconnected and marked as discouraged (unless it has the noban permission). */\n-    bool m_should_discourage GUARDED_BY(m_misbehavior_mutex){false};\n-\n-    /** Protects block inventory data members */\n-    Mutex m_block_inv_mutex;\n-    /** List of blocks that we'll announce via an `inv` message.\n-     * There is no final sorting before sending, as they are always sent\n-     * immediately and in the order requested. */\n-    std::vector<uint256> m_blocks_for_inv_relay GUARDED_BY(m_block_inv_mutex);\n-    /** Unfiltered list of blocks that we'd like to announce via a `headers`\n-     * message. If we can't announce via a `headers` message, we'll fall back to\n-     * announcing via `inv`. */\n-    std::vector<uint256> m_blocks_for_headers_relay GUARDED_BY(m_block_inv_mutex);\n-    /** The final block hash that we sent in an `inv` message to this peer.\n-     * When the peer requests this block, we send an `inv` message to trigger\n-     * the peer to request the next sequence of block hashes.\n-     * Most peers use headers-first syncing, which doesn't use this mechanism */\n-    uint256 m_continuation_block GUARDED_BY(m_block_inv_mutex) {};\n-\n-    /** This peer's reported block height when we connected */\n-    std::atomic<int> m_starting_height{-1};\n-\n-    /** Set of txids to reconsider once their parent transactions have been accepted **/\n-    std::set<uint256> m_orphan_work_set GUARDED_BY(g_cs_orphans);\n-\n-    /** Protects m_getdata_requests **/\n-    Mutex m_getdata_requests_mutex;\n-    /** Work queue of items requested by this peer **/\n-    std::deque<CInv> m_getdata_requests GUARDED_BY(m_getdata_requests_mutex);\n-\n-    explicit Peer(NodeId id) : m_id(id) {}\n-};\n-\n-using PeerRef = std::shared_ptr<Peer>;\n-\n class PeerManager : public CValidationInterface, public NetEventsInterface\n {\n public:"
      }
    ]
  }
]