[
  {
    "sha": "ed73f8cee0d7b7facbd2e8dde24a237f20c48c0c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZDczZjhjZWUwZDdiN2ZhY2JkMmU4ZGRlMjRhMjM3ZjIwYzQ4YzBj",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2020-09-18T12:47:08Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2020-12-16T12:00:15Z"
      },
      "message": "net: Move eviction node selection logic to SelectNodeToEvict(...)",
      "tree": {
        "sha": "b669f32eeaf503305d4dd78a1d6e497cfa82fe61",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b669f32eeaf503305d4dd78a1d6e497cfa82fe61"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ed73f8cee0d7b7facbd2e8dde24a237f20c48c0c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ed73f8cee0d7b7facbd2e8dde24a237f20c48c0c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ed73f8cee0d7b7facbd2e8dde24a237f20c48c0c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ed73f8cee0d7b7facbd2e8dde24a237f20c48c0c/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "00f4dcd5520e14529b5c3fa8e14feb3a023ffb4c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/00f4dcd5520e14529b5c3fa8e14feb3a023ffb4c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/00f4dcd5520e14529b5c3fa8e14feb3a023ffb4c"
      }
    ],
    "stats": {
      "total": 119,
      "additions": 65,
      "deletions": 54
    },
    "files": [
      {
        "sha": "3bc34acc38f6e71ca665f106a0c5acae5a54f7ed",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 47,
        "deletions": 54,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed73f8cee0d7b7facbd2e8dde24a237f20c48c0c/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed73f8cee0d7b7facbd2e8dde24a237f20c48c0c/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=ed73f8cee0d7b7facbd2e8dde24a237f20c48c0c",
        "patch": "@@ -16,6 +16,7 @@\n #include <net_permissions.h>\n #include <netbase.h>\n #include <node/ui_interface.h>\n+#include <optional.h>\n #include <protocol.h>\n #include <random.h>\n #include <scheduler.h>\n@@ -840,21 +841,6 @@ size_t CConnman::SocketSendData(CNode *pnode) const EXCLUSIVE_LOCKS_REQUIRED(pno\n     return nSentSize;\n }\n \n-struct NodeEvictionCandidate\n-{\n-    NodeId id;\n-    int64_t nTimeConnected;\n-    int64_t nMinPingUsecTime;\n-    int64_t nLastBlockTime;\n-    int64_t nLastTXTime;\n-    bool fRelevantServices;\n-    bool fRelayTxes;\n-    bool fBloomFilter;\n-    uint64_t nKeyedNetGroup;\n-    bool prefer_evict;\n-    bool m_is_local;\n-};\n-\n static bool ReverseCompareNodeMinPingTime(const NodeEvictionCandidate &a, const NodeEvictionCandidate &b)\n {\n     return a.nMinPingUsecTime > b.nMinPingUsecTime;\n@@ -910,43 +896,8 @@ static void EraseLastKElements(std::vector<T> &elements, Comparator comparator,\n     elements.erase(elements.end() - eraseSize, elements.end());\n }\n \n-/** Try to find a connection to evict when the node is full.\n- *  Extreme care must be taken to avoid opening the node to attacker\n- *   triggered network partitioning.\n- *  The strategy used here is to protect a small number of peers\n- *   for each of several distinct characteristics which are difficult\n- *   to forge.  In order to partition a node the attacker must be\n- *   simultaneously better at all of them than honest peers.\n- */\n-bool CConnman::AttemptToEvictConnection()\n+[[nodiscard]] Optional<NodeId> SelectNodeToEvict(std::vector<NodeEvictionCandidate>&& vEvictionCandidates)\n {\n-    std::vector<NodeEvictionCandidate> vEvictionCandidates;\n-    {\n-        LOCK(cs_vNodes);\n-\n-        for (const CNode* node : vNodes) {\n-            if (node->HasPermission(PF_NOBAN))\n-                continue;\n-            if (!node->IsInboundConn())\n-                continue;\n-            if (node->fDisconnect)\n-                continue;\n-            bool peer_relay_txes = false;\n-            bool peer_filter_not_null = false;\n-            if (node->m_tx_relay != nullptr) {\n-                LOCK(node->m_tx_relay->cs_filter);\n-                peer_relay_txes = node->m_tx_relay->fRelayTxes;\n-                peer_filter_not_null = node->m_tx_relay->pfilter != nullptr;\n-            }\n-            NodeEvictionCandidate candidate = {node->GetId(), node->nTimeConnected, node->nMinPingUsecTime,\n-                                               node->nLastBlockTime, node->nLastTXTime,\n-                                               HasAllDesirableServiceFlags(node->nServices),\n-                                               peer_relay_txes, peer_filter_not_null, node->nKeyedNetGroup,\n-                                               node->m_prefer_evict, node->addr.IsLocal()};\n-            vEvictionCandidates.push_back(candidate);\n-        }\n-    }\n-\n     // Protect connections with certain characteristics\n \n     // Deterministically select 4 peers to protect by netgroup.\n@@ -984,7 +935,7 @@ bool CConnman::AttemptToEvictConnection()\n     total_protect_size -= initial_size - vEvictionCandidates.size();\n     EraseLastKElements(vEvictionCandidates, ReverseCompareNodeTimeConnected, total_protect_size);\n \n-    if (vEvictionCandidates.empty()) return false;\n+    if (vEvictionCandidates.empty()) return nullopt;\n \n     // If any remaining peers are preferred for eviction consider only them.\n     // This happens after the other preferences since if a peer is really the best by other criteria (esp relaying blocks)\n@@ -1016,10 +967,52 @@ bool CConnman::AttemptToEvictConnection()\n     vEvictionCandidates = std::move(mapNetGroupNodes[naMostConnections]);\n \n     // Disconnect from the network group with the most connections\n-    NodeId evicted = vEvictionCandidates.front().id;\n+    return vEvictionCandidates.front().id;\n+}\n+\n+/** Try to find a connection to evict when the node is full.\n+ *  Extreme care must be taken to avoid opening the node to attacker\n+ *   triggered network partitioning.\n+ *  The strategy used here is to protect a small number of peers\n+ *   for each of several distinct characteristics which are difficult\n+ *   to forge.  In order to partition a node the attacker must be\n+ *   simultaneously better at all of them than honest peers.\n+ */\n+bool CConnman::AttemptToEvictConnection()\n+{\n+    std::vector<NodeEvictionCandidate> vEvictionCandidates;\n+    {\n+\n+        LOCK(cs_vNodes);\n+        for (const CNode* node : vNodes) {\n+            if (node->HasPermission(PF_NOBAN))\n+                continue;\n+            if (!node->IsInboundConn())\n+                continue;\n+            if (node->fDisconnect)\n+                continue;\n+            bool peer_relay_txes = false;\n+            bool peer_filter_not_null = false;\n+            if (node->m_tx_relay != nullptr) {\n+                LOCK(node->m_tx_relay->cs_filter);\n+                peer_relay_txes = node->m_tx_relay->fRelayTxes;\n+                peer_filter_not_null = node->m_tx_relay->pfilter != nullptr;\n+            }\n+            NodeEvictionCandidate candidate = {node->GetId(), node->nTimeConnected, node->nMinPingUsecTime,\n+                                               node->nLastBlockTime, node->nLastTXTime,\n+                                               HasAllDesirableServiceFlags(node->nServices),\n+                                               peer_relay_txes, peer_filter_not_null, node->nKeyedNetGroup,\n+                                               node->m_prefer_evict, node->addr.IsLocal()};\n+            vEvictionCandidates.push_back(candidate);\n+        }\n+    }\n+    const Optional<NodeId> node_id_to_evict = SelectNodeToEvict(std::move(vEvictionCandidates));\n+    if (!node_id_to_evict) {\n+        return false;\n+    }\n     LOCK(cs_vNodes);\n     for (CNode* pnode : vNodes) {\n-        if (pnode->GetId() == evicted) {\n+        if (pnode->GetId() == *node_id_to_evict) {\n             pnode->fDisconnect = true;\n             return true;\n         }"
      },
      {
        "sha": "291f3887dd011f8e4c690915d3c678dc7ed16cd8",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed73f8cee0d7b7facbd2e8dde24a237f20c48c0c/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed73f8cee0d7b7facbd2e8dde24a237f20c48c0c/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=ed73f8cee0d7b7facbd2e8dde24a237f20c48c0c",
        "patch": "@@ -33,6 +33,7 @@\n #include <map>\n #include <memory>\n #include <thread>\n+#include <vector>\n \n class CScheduler;\n class CNode;\n@@ -1226,4 +1227,21 @@ inline std::chrono::microseconds PoissonNextSend(std::chrono::microseconds now,\n     return std::chrono::microseconds{PoissonNextSend(now.count(), average_interval.count())};\n }\n \n+struct NodeEvictionCandidate\n+{\n+    NodeId id;\n+    int64_t nTimeConnected;\n+    int64_t nMinPingUsecTime;\n+    int64_t nLastBlockTime;\n+    int64_t nLastTXTime;\n+    bool fRelevantServices;\n+    bool fRelayTxes;\n+    bool fBloomFilter;\n+    uint64_t nKeyedNetGroup;\n+    bool prefer_evict;\n+    bool m_is_local;\n+};\n+\n+[[nodiscard]] Optional<NodeId> SelectNodeToEvict(std::vector<NodeEvictionCandidate>&& vEvictionCandidates);\n+\n #endif // BITCOIN_NET_H"
      }
    ]
  },
  {
    "sha": "685c428de0fb63ca6ec1419bb112f07d27bcdf14",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2ODVjNDI4ZGUwZmI2M2NhNmVjMTQxOWJiMTEyZjA3ZDI3YmNkZjE0",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2020-11-06T11:40:09Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2020-12-16T12:00:15Z"
      },
      "message": "test: Add unit testing of node eviction logic",
      "tree": {
        "sha": "47b1b372d24be0361d768f0f66b0f7a2273b549d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/47b1b372d24be0361d768f0f66b0f7a2273b549d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/685c428de0fb63ca6ec1419bb112f07d27bcdf14",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/685c428de0fb63ca6ec1419bb112f07d27bcdf14",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/685c428de0fb63ca6ec1419bb112f07d27bcdf14",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/685c428de0fb63ca6ec1419bb112f07d27bcdf14/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ed73f8cee0d7b7facbd2e8dde24a237f20c48c0c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ed73f8cee0d7b7facbd2e8dde24a237f20c48c0c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ed73f8cee0d7b7facbd2e8dde24a237f20c48c0c"
      }
    ],
    "stats": {
      "total": 131,
      "additions": 131,
      "deletions": 0
    },
    "files": [
      {
        "sha": "282f5ea5bf99e27cef745ac15d657aa9e21ee0b4",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 131,
        "deletions": 0,
        "changes": 131,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/685c428de0fb63ca6ec1419bb112f07d27bcdf14/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/685c428de0fb63ca6ec1419bb112f07d27bcdf14/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=685c428de0fb63ca6ec1419bb112f07d27bcdf14",
        "patch": "@@ -9,6 +9,7 @@\n #include <cstdint>\n #include <net.h>\n #include <netbase.h>\n+#include <optional.h>\n #include <serialize.h>\n #include <span.h>\n #include <streams.h>\n@@ -21,6 +22,7 @@\n \n #include <boost/test/unit_test.hpp>\n \n+#include <algorithm>\n #include <ios>\n #include <memory>\n #include <string>\n@@ -771,4 +773,133 @@ BOOST_AUTO_TEST_CASE(PoissonNextSend)\n     g_mock_deterministic_tests = false;\n }\n \n+std::vector<NodeEvictionCandidate> GetRandomNodeEvictionCandidates(const int n_candidates, FastRandomContext& random_context)\n+{\n+    std::vector<NodeEvictionCandidate> candidates;\n+    for (int id = 0; id < n_candidates; ++id) {\n+        candidates.push_back({\n+            /* id */ id,\n+            /* nTimeConnected */ static_cast<int64_t>(random_context.randrange(100)),\n+            /* nMinPingUsecTime */ static_cast<int64_t>(random_context.randrange(100)),\n+            /* nLastBlockTime */ static_cast<int64_t>(random_context.randrange(100)),\n+            /* nLastTXTime */ static_cast<int64_t>(random_context.randrange(100)),\n+            /* fRelevantServices */ random_context.randbool(),\n+            /* fRelayTxes */ random_context.randbool(),\n+            /* fBloomFilter */ random_context.randbool(),\n+            /* nKeyedNetGroup */ random_context.randrange(100),\n+            /* prefer_evict */ random_context.randbool(),\n+            /* m_is_local */ random_context.randbool(),\n+        });\n+    }\n+    return candidates;\n+}\n+\n+// Returns true if any of the node ids in node_ids are selected for eviction.\n+bool IsEvicted(std::vector<NodeEvictionCandidate> candidates, const std::vector<NodeId>& node_ids, FastRandomContext& random_context)\n+{\n+    Shuffle(candidates.begin(), candidates.end(), random_context);\n+    const Optional<NodeId> evicted_node_id = SelectNodeToEvict(std::move(candidates));\n+    if (!evicted_node_id) {\n+        return false;\n+    }\n+    return std::find(node_ids.begin(), node_ids.end(), *evicted_node_id) != node_ids.end();\n+}\n+\n+// Create number_of_nodes random nodes, apply setup function candidate_setup_fn,\n+// apply eviction logic and then return true if any of the node ids in node_ids\n+// are selected for eviction.\n+bool IsEvicted(const int number_of_nodes, std::function<void(NodeEvictionCandidate&)> candidate_setup_fn, const std::vector<NodeId>& node_ids, FastRandomContext& random_context)\n+{\n+    std::vector<NodeEvictionCandidate> candidates = GetRandomNodeEvictionCandidates(number_of_nodes, random_context);\n+    for (NodeEvictionCandidate& candidate : candidates) {\n+        candidate_setup_fn(candidate);\n+    }\n+    return IsEvicted(candidates, node_ids, random_context);\n+}\n+\n+namespace {\n+constexpr int NODE_EVICTION_TEST_ROUNDS{10};\n+constexpr int NODE_EVICTION_TEST_UP_TO_N_NODES{200};\n+} // namespace\n+\n+BOOST_AUTO_TEST_CASE(node_eviction_test)\n+{\n+    FastRandomContext random_context{true};\n+\n+    for (int i = 0; i < NODE_EVICTION_TEST_ROUNDS; ++i) {\n+        for (int number_of_nodes = 0; number_of_nodes < NODE_EVICTION_TEST_UP_TO_N_NODES; ++number_of_nodes) {\n+            // Four nodes with the highest keyed netgroup values should be\n+            // protected from eviction.\n+            BOOST_CHECK(!IsEvicted(\n+                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n+                    candidate.nKeyedNetGroup = number_of_nodes - candidate.id;\n+                },\n+                {0, 1, 2, 3}, random_context));\n+\n+            // Eight nodes with the lowest minimum ping time should be protected\n+            // from eviction.\n+            BOOST_CHECK(!IsEvicted(\n+                number_of_nodes, [](NodeEvictionCandidate& candidate) {\n+                    candidate.nMinPingUsecTime = candidate.id;\n+                },\n+                {0, 1, 2, 3, 4, 5, 6, 7}, random_context));\n+\n+            // Four nodes that most recently sent us novel transactions accepted\n+            // into our mempool should be protected from eviction.\n+            BOOST_CHECK(!IsEvicted(\n+                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n+                    candidate.nLastTXTime = number_of_nodes - candidate.id;\n+                },\n+                {0, 1, 2, 3}, random_context));\n+\n+            // Up to eight non-tx-relay peers that most recently sent us novel\n+            // blocks should be protected from eviction.\n+            BOOST_CHECK(!IsEvicted(\n+                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n+                    candidate.nLastBlockTime = number_of_nodes - candidate.id;\n+                    if (candidate.id <= 7) {\n+                        candidate.fRelayTxes = false;\n+                        candidate.fRelevantServices = true;\n+                    }\n+                },\n+                {0, 1, 2, 3, 4, 5, 6, 7}, random_context));\n+\n+            // Four peers that most recently sent us novel blocks should be\n+            // protected from eviction.\n+            BOOST_CHECK(!IsEvicted(\n+                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n+                    candidate.nLastBlockTime = number_of_nodes - candidate.id;\n+                },\n+                {0, 1, 2, 3}, random_context));\n+\n+            // Combination of the previous two tests.\n+            BOOST_CHECK(!IsEvicted(\n+                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n+                    candidate.nLastBlockTime = number_of_nodes - candidate.id;\n+                    if (candidate.id <= 7) {\n+                        candidate.fRelayTxes = false;\n+                        candidate.fRelevantServices = true;\n+                    }\n+                },\n+                {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}, random_context));\n+\n+            // Combination of all tests above.\n+            BOOST_CHECK(!IsEvicted(\n+                number_of_nodes, [number_of_nodes](NodeEvictionCandidate& candidate) {\n+                    candidate.nKeyedNetGroup = number_of_nodes - candidate.id; // 4 protected\n+                    candidate.nMinPingUsecTime = candidate.id;                 // 8 protected\n+                    candidate.nLastTXTime = number_of_nodes - candidate.id;    // 4 protected\n+                    candidate.nLastBlockTime = number_of_nodes - candidate.id; // 4 protected\n+                },\n+                {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}, random_context));\n+\n+            // Cases left to test:\n+            // * \"Protect the half of the remaining nodes which have been connected the longest. [...]\"\n+            // * \"Pick out up to 1/4 peers that are localhost, sorted by longest uptime. [...]\"\n+            // * \"If any remaining peers are preferred for eviction consider only them. [...]\"\n+            // * \"Identify the network group with the most connections and youngest member. [...]\"\n+        }\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "fee88237e03c21bf81f21098e6b89ecfa5327cee",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZWU4ODIzN2UwM2MyMWJmODFmMjEwOThlNmI4OWVjZmE1MzI3Y2Vl",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2020-12-15T15:23:44Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2020-12-16T12:00:15Z"
      },
      "message": "Assert eviction at >= 29 candidates. Assert non-eviction at <= 20 candidates.",
      "tree": {
        "sha": "16299238e6b798babf4074706bc59d161798f1a0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/16299238e6b798babf4074706bc59d161798f1a0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/fee88237e03c21bf81f21098e6b89ecfa5327cee",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fee88237e03c21bf81f21098e6b89ecfa5327cee",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/fee88237e03c21bf81f21098e6b89ecfa5327cee",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/fee88237e03c21bf81f21098e6b89ecfa5327cee/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "685c428de0fb63ca6ec1419bb112f07d27bcdf14",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/685c428de0fb63ca6ec1419bb112f07d27bcdf14",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/685c428de0fb63ca6ec1419bb112f07d27bcdf14"
      }
    ],
    "stats": {
      "total": 14,
      "additions": 14,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8281921dceddc6d12cd4ac46acfdfed1c1c651dd",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/fee88237e03c21bf81f21098e6b89ecfa5327cee/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/fee88237e03c21bf81f21098e6b89ecfa5327cee/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=fee88237e03c21bf81f21098e6b89ecfa5327cee",
        "patch": "@@ -893,6 +893,20 @@ BOOST_AUTO_TEST_CASE(node_eviction_test)\n                 },\n                 {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19}, random_context));\n \n+            // An eviction is expected given >= 29 random eviction candidates. The eviction logic protects at most\n+            // four peers by net group, eight by lowest ping time, four by last time of novel tx, up to eight non-tx-relay\n+            // peers by last novel block time, and four more peers by last novel block time.\n+            if (number_of_nodes >= 29) {\n+                BOOST_CHECK(SelectNodeToEvict(GetRandomNodeEvictionCandidates(number_of_nodes, random_context)));\n+            }\n+\n+            // No eviction is expected given <= 20 random eviction candidates. The eviction logic protects at least\n+            // four peers by net group, eight by lowest ping time, four by last time of novel tx and four peers by last\n+            // novel block time.\n+            if (number_of_nodes <= 20) {\n+                BOOST_CHECK(!SelectNodeToEvict(GetRandomNodeEvictionCandidates(number_of_nodes, random_context)));\n+            }\n+\n             // Cases left to test:\n             // * \"Protect the half of the remaining nodes which have been connected the longest. [...]\"\n             // * \"Pick out up to 1/4 peers that are localhost, sorted by longest uptime. [...]\""
      }
    ]
  }
]