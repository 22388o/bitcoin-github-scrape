[
  {
    "sha": "848e8aa5b2dcf36d474a9046018b1caca2118ef0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NDhlOGFhNWIyZGNmMzZkNDc0YTkwNDYwMThiMWNhY2EyMTE4ZWYw",
    "commit": {
      "author": {
        "name": "Edson T\u00e9gila",
        "email": "etegila@gmail.com",
        "date": "2021-08-21T00:39:53Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-08-21T00:39:53Z"
      },
      "message": "Create Dockerfile\n\nAutomatic deployment to docker.hub using alpine as base image and musl as the libc",
      "tree": {
        "sha": "5dd0b95329093eaa844a41531c1c378eccf814db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5dd0b95329093eaa844a41531c1c378eccf814db"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/848e8aa5b2dcf36d474a9046018b1caca2118ef0",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhIEtZCRBK7hj4Ov3rIwAAcTIIAE5b5Rcf/BoWkEpo+xurNxaR\nbQUzXbxhaUrzd7TwCIfWE90ks4CET8rmHKeQlPUPV9DHTWr8mYtxdXn9OGRN1A8h\n2CcgTRCxu7un4FUR1EGjF+nWnUz+IPws4P2X1nwnI8YPsvjbmBxdCRNhQWSmFwLK\n4/39JgXvLYMF6d8eiLBTXYg/OVfGXAgruOGh1b8DwVgipCQ8/yk5GN1N+kKJpaKM\nNiA4dinwEfDY93QNtLGZzsoEr6cjQbA3mx2AqVvrgWOsdHB3qlEfHbnm2mi3bG8P\nPnBUwfYTjncRt4D+6OXp7etI/1vS8cB+voff+RUrvLluAlUKmY6IsJS7Y5a9qd0=\n=m5jh\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 5dd0b95329093eaa844a41531c1c378eccf814db\nparent 4fc15d15667d9d9c4fb5515ce73c05b4596298ec\nauthor Edson T\u00e9gila <etegila@gmail.com> 1629506393 -0300\ncommitter GitHub <noreply@github.com> 1629506393 -0300\n\nCreate Dockerfile\n\nAutomatic deployment to docker.hub using alpine as base image and musl as the libc"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/848e8aa5b2dcf36d474a9046018b1caca2118ef0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/848e8aa5b2dcf36d474a9046018b1caca2118ef0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/848e8aa5b2dcf36d474a9046018b1caca2118ef0/comments",
    "author": {
      "login": "tegila",
      "id": 105643,
      "node_id": "MDQ6VXNlcjEwNTY0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/105643?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tegila",
      "html_url": "https://github.com/tegila",
      "followers_url": "https://api.github.com/users/tegila/followers",
      "following_url": "https://api.github.com/users/tegila/following{/other_user}",
      "gists_url": "https://api.github.com/users/tegila/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tegila/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tegila/subscriptions",
      "organizations_url": "https://api.github.com/users/tegila/orgs",
      "repos_url": "https://api.github.com/users/tegila/repos",
      "events_url": "https://api.github.com/users/tegila/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tegila/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4fc15d15667d9d9c4fb5515ce73c05b4596298ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4fc15d15667d9d9c4fb5515ce73c05b4596298ec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4fc15d15667d9d9c4fb5515ce73c05b4596298ec"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "8b137891791fe96927ad78e64b0aad7bded08bdc",
        "filename": "Dockerfile",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/848e8aa5b2dcf36d474a9046018b1caca2118ef0/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/848e8aa5b2dcf36d474a9046018b1caca2118ef0/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Dockerfile?ref=848e8aa5b2dcf36d474a9046018b1caca2118ef0",
        "patch": "@@ -0,0 +1 @@\n+"
      }
    ]
  },
  {
    "sha": "002485cb19697d1aa360e15fbb5b87c8701f2a45",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMDI0ODVjYjE5Njk3ZDFhYTM2MGUxNWZiYjViODdjODcwMWYyYTQ1",
    "commit": {
      "author": {
        "name": "Edson T\u00e9gila",
        "email": "etegila@gmail.com",
        "date": "2021-08-21T00:42:22Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-08-21T00:42:22Z"
      },
      "message": "Update Dockerfile",
      "tree": {
        "sha": "64945545182ebcdabdcf7ce4c98d2cc8c47ad92a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/64945545182ebcdabdcf7ce4c98d2cc8c47ad92a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/002485cb19697d1aa360e15fbb5b87c8701f2a45",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhIEvuCRBK7hj4Ov3rIwAA51gIABvlE/IZzznz7iVJEgMSM2EZ\nXhfPNEDgwNHiilHwDziPN5Kg6J9CL5Yl++WBxzBppV6+DiERzZun2zLb1lcXhqsI\ns6fdNpPyndNV5C8iG5jNSYRFezajKryx+HC4eSdf5bhnLJuq8RMG3K6fs7KdQ7Vm\nKDs3KFBxlfp5ePVcd22Tlw9HRnsigd8forTjqOxoS23BIdnBsAfOFhAgSg5PO28f\nVCQ5ANVpc7L/6UpY667eGjWv1Pz2v+jaGhbKm4qJKITDOp/VqzEBhVrD59h8R95N\ne7aD1GZECRC8JFir44h3DOui/bwHBL0lmzmMaPwhEbSlwRBViGLTySUbgOyllc8=\n=4rrT\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 64945545182ebcdabdcf7ce4c98d2cc8c47ad92a\nparent 848e8aa5b2dcf36d474a9046018b1caca2118ef0\nauthor Edson T\u00e9gila <etegila@gmail.com> 1629506542 -0300\ncommitter GitHub <noreply@github.com> 1629506542 -0300\n\nUpdate Dockerfile"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/002485cb19697d1aa360e15fbb5b87c8701f2a45",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/002485cb19697d1aa360e15fbb5b87c8701f2a45",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/002485cb19697d1aa360e15fbb5b87c8701f2a45/comments",
    "author": {
      "login": "tegila",
      "id": 105643,
      "node_id": "MDQ6VXNlcjEwNTY0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/105643?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tegila",
      "html_url": "https://github.com/tegila",
      "followers_url": "https://api.github.com/users/tegila/followers",
      "following_url": "https://api.github.com/users/tegila/following{/other_user}",
      "gists_url": "https://api.github.com/users/tegila/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tegila/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tegila/subscriptions",
      "organizations_url": "https://api.github.com/users/tegila/orgs",
      "repos_url": "https://api.github.com/users/tegila/repos",
      "events_url": "https://api.github.com/users/tegila/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tegila/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "848e8aa5b2dcf36d474a9046018b1caca2118ef0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/848e8aa5b2dcf36d474a9046018b1caca2118ef0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/848e8aa5b2dcf36d474a9046018b1caca2118ef0"
      }
    ],
    "stats": {
      "total": 51,
      "additions": 51,
      "deletions": 0
    },
    "files": [
      {
        "sha": "dfa01367c19d211123ef4618bd17ee6208613548",
        "filename": "Dockerfile",
        "status": "modified",
        "additions": 51,
        "deletions": 0,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/002485cb19697d1aa360e15fbb5b87c8701f2a45/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/002485cb19697d1aa360e15fbb5b87c8701f2a45/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Dockerfile?ref=002485cb19697d1aa360e15fbb5b87c8701f2a45",
        "patch": "@@ -1 +1,52 @@\n+FROM alpine AS build\n \n+WORKDIR /bitcoin\n+COPY . . \n+\n+RUN apk --no-cache add libffi-dev openssl-dev bash coreutils\n+RUN apk --no-cache add --update alpine-sdk\n+RUN apk --no-cache add --update build-base\n+RUN apk --no-cache add autoconf automake libtool\n+RUN apk --no-cache add boost-dev libevent-dev \n+\n+RUN cd /bitcoin/depends; make NO_QT=1\n+\n+RUN wget https://zlib.net/zlib-1.2.11.tar.gz\n+RUN mkdir -p /usr/src/zlib; tar zxvf zlib-1.2.11.tar.gz -C /usr/src\n+RUN cd /usr/src/zlib-1.2.11; ./configure; make; make install\n+\n+ENV CONFIG_SITE=/bitcoin/depends/x86_64-pc-linux-musl/share/config.site\n+RUN cd /bitcoin; ./autogen.sh\n+RUN ./configure --disable-ccache \\\n+    --disable-maintainer-mode \\\n+    --disable-dependency-tracking \\\n+    --enable-reduce-exports --disable-bench \\\n+    --disable-tests \\\n+    --disable-gui-tests \\\n+    --without-gui \\\n+    --without-miniupnpc \\\n+    CFLAGS=\"-O2 -g0 --static -static -fPIC\" \\\n+    CXXFLAGS=\"-O2 -g0 --static -static -fPIC\" \\\n+    LDFLAGS=\"-s -static-libgcc -static-libstdc++ -Wl,-O2\"\n+RUN make\n+RUN make install\n+\n+FROM alpine\n+COPY --from=build /usr/local /usr/local\n+RUN apk --no-cache add bash coreutils shadow\n+\n+ARG UNAME=bitcoin\n+ARG UID=1000\n+ARG GID=1000\n+RUN groupadd -g $GID -o $UNAME\n+RUN useradd -m -u $UID -g $GID -o -s /bin/bash $UNAME\n+USER $UNAME\n+\n+USER bitcoin\n+COPY --chown=bitcoin:bitcoin --from=build /bitcoin/share/examples/bitcoin.conf /home/bitcoin/.bitcoin/bitcoin.conf\n+\n+VOLUME [\"/home/bitcoin/.bitcoin\"]\n+\n+EXPOSE 8332 8333 18332 18333 18444\n+\n+CMD [\"bitcoind\", \"-datadir=/home/bitcoin/.bitcoin\", \"-printtoconsole\"]"
      }
    ]
  },
  {
    "sha": "129805b114a8a14d4e29076b972b50070fbee079",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMjk4MDViMTE0YThhMTRkNGUyOTA3NmI5NzJiNTAwNzBmYmVlMDc5",
    "commit": {
      "author": {
        "name": "Edson T\u00e9gila",
        "email": "etegila@gmail.com",
        "date": "2021-08-21T16:48:35Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-08-21T16:48:35Z"
      },
      "message": "Merge branch 'bitcoin:master' into master",
      "tree": {
        "sha": "8dcd027f67e45633a22c06435e1cfa22a00b9e75",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8dcd027f67e45633a22c06435e1cfa22a00b9e75"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/129805b114a8a14d4e29076b972b50070fbee079",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhIS5jCRBK7hj4Ov3rIwAAQPEIAAiPHq/y3IhfduA6hM3BQuCQ\nzKv/XMJ6tHHZySwf83JqJ1JYm1nGKSglCRo0O+EXBDjhtEmCvXfi+ni2vPtnAEbM\nP3CyYyVX1lWkzBXkZtwwpaZYdCaxRXjt7tMPd+TjUAekO/lj1jrewvlnexIZiRbV\npdOWX7uAHoaPXM9AOSNYiIA1by7h2vVLupPnb6Vb2LFMAvgA3+AXW+GM8QzPaQVc\nfsMr2FeYJ7xXKJOMltS3+7KvOy9RU+7ZOabp7c/e7scmt8iuxG36jaClOLlvSAfx\nprjWI4vHOFNdK9EHmDVWwBAx+78vKX44VGOvKpfNGiXuf/qUu7HwJhjxfg2zliw=\n=XFpU\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 8dcd027f67e45633a22c06435e1cfa22a00b9e75\nparent 002485cb19697d1aa360e15fbb5b87c8701f2a45\nparent f5a406f003a060325128db47552089b3254044e3\nauthor Edson T\u00e9gila <etegila@gmail.com> 1629564515 -0300\ncommitter GitHub <noreply@github.com> 1629564515 -0300\n\nMerge branch 'bitcoin:master' into master\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/129805b114a8a14d4e29076b972b50070fbee079",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/129805b114a8a14d4e29076b972b50070fbee079",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/129805b114a8a14d4e29076b972b50070fbee079/comments",
    "author": {
      "login": "tegila",
      "id": 105643,
      "node_id": "MDQ6VXNlcjEwNTY0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/105643?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tegila",
      "html_url": "https://github.com/tegila",
      "followers_url": "https://api.github.com/users/tegila/followers",
      "following_url": "https://api.github.com/users/tegila/following{/other_user}",
      "gists_url": "https://api.github.com/users/tegila/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tegila/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tegila/subscriptions",
      "organizations_url": "https://api.github.com/users/tegila/orgs",
      "repos_url": "https://api.github.com/users/tegila/repos",
      "events_url": "https://api.github.com/users/tegila/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tegila/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "002485cb19697d1aa360e15fbb5b87c8701f2a45",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/002485cb19697d1aa360e15fbb5b87c8701f2a45",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/002485cb19697d1aa360e15fbb5b87c8701f2a45"
      },
      {
        "sha": "f5a406f003a060325128db47552089b3254044e3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f5a406f003a060325128db47552089b3254044e3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f5a406f003a060325128db47552089b3254044e3"
      }
    ],
    "stats": {
      "total": 33,
      "additions": 14,
      "deletions": 19
    },
    "files": [
      {
        "sha": "9a8bcc57a59383e610c63e5a585b5253ea30c9f0",
        "filename": "contrib/linearize/linearize-data.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/129805b114a8a14d4e29076b972b50070fbee079/contrib/linearize/linearize-data.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/129805b114a8a14d4e29076b972b50070fbee079/contrib/linearize/linearize-data.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/linearize/linearize-data.py?ref=129805b114a8a14d4e29076b972b50070fbee079",
        "patch": "@@ -17,7 +17,6 @@\n import time\n import glob\n from collections import namedtuple\n-from binascii import unhexlify\n \n settings = {}\n \n@@ -332,7 +331,7 @@ def run(self):\n     settings['max_out_sz'] = int(settings['max_out_sz'])\n     settings['split_timestamp'] = int(settings['split_timestamp'])\n     settings['file_timestamp'] = int(settings['file_timestamp'])\n-    settings['netmagic'] = unhexlify(settings['netmagic'].encode('utf-8'))\n+    settings['netmagic'] = bytes.fromhex(settings['netmagic'])\n     settings['out_of_order_cache_sz'] = int(settings['out_of_order_cache_sz'])\n     settings['debug_output'] = settings['debug_output'].lower()\n "
      },
      {
        "sha": "012bd6cc3149075d56c2de338e05f40527a42fea",
        "filename": "contrib/signet/miner",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/129805b114a8a14d4e29076b972b50070fbee079/contrib/signet/miner",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/129805b114a8a14d4e29076b972b50070fbee079/contrib/signet/miner",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/signet/miner?ref=129805b114a8a14d4e29076b972b50070fbee079",
        "patch": "@@ -15,7 +15,6 @@ import sys\n import time\n import subprocess\n \n-from binascii import unhexlify\n from io import BytesIO\n \n PATH_BASE_CONTRIB_SIGNET = os.path.abspath(os.path.dirname(os.path.realpath(__file__)))\n@@ -202,7 +201,7 @@ def finish_block(block, signet_solution, grind_cmd):\n \n def generate_psbt(tmpl, reward_spk, *, blocktime=None):\n     signet_spk = tmpl[\"signet_challenge\"]\n-    signet_spk_bin = unhexlify(signet_spk)\n+    signet_spk_bin = bytes.fromhex(signet_spk)\n \n     cbtx = create_coinbase(height=tmpl[\"height\"], value=tmpl[\"coinbasevalue\"], spk=reward_spk)\n     cbtx.vin[0].nSequence = 2**32-2\n@@ -258,7 +257,7 @@ def get_reward_addr_spk(args, height):\n         return args.address, args.reward_spk\n \n     reward_addr = get_reward_address(args, height)\n-    reward_spk = unhexlify(json.loads(args.bcli(\"getaddressinfo\", reward_addr))[\"scriptPubKey\"])\n+    reward_spk = bytes.fromhex(json.loads(args.bcli(\"getaddressinfo\", reward_addr))[\"scriptPubKey\"])\n     if args.address is not None:\n         # will always be the same, so cache\n         args.reward_spk = reward_spk"
      },
      {
        "sha": "6269269d377ef2098b1134de058ceca42b76569f",
        "filename": "contrib/zmq/zmq_sub.py",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/129805b114a8a14d4e29076b972b50070fbee079/contrib/zmq/zmq_sub.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/129805b114a8a14d4e29076b972b50070fbee079/contrib/zmq/zmq_sub.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/zmq/zmq_sub.py?ref=129805b114a8a14d4e29076b972b50070fbee079",
        "patch": "@@ -23,7 +23,6 @@\n     https://github.com/bitcoin/bitcoin/blob/37a7fe9e440b83e2364d5498931253937abe9294/contrib/zmq/zmq_sub.py\n \"\"\"\n \n-import binascii\n import asyncio\n import zmq\n import zmq.asyncio\n@@ -58,18 +57,18 @@ async def handle(self) :\n             sequence = str(struct.unpack('<I', seq)[-1])\n         if topic == b\"hashblock\":\n             print('- HASH BLOCK ('+sequence+') -')\n-            print(binascii.hexlify(body))\n+            print(body.hex())\n         elif topic == b\"hashtx\":\n             print('- HASH TX  ('+sequence+') -')\n-            print(binascii.hexlify(body))\n+            print(body.hex())\n         elif topic == b\"rawblock\":\n             print('- RAW BLOCK HEADER ('+sequence+') -')\n-            print(binascii.hexlify(body[:80]))\n+            print(body[:80].hex())\n         elif topic == b\"rawtx\":\n             print('- RAW TX ('+sequence+') -')\n-            print(binascii.hexlify(body))\n+            print(body.hex())\n         elif topic == b\"sequence\":\n-            hash = binascii.hexlify(body[:32])\n+            hash = body[:32].hex()\n             label = chr(body[32])\n             mempool_sequence = None if len(body) != 32+1+8 else struct.unpack(\"<Q\", body[32+1:])[0]\n             print('- SEQUENCE ('+sequence+') -')"
      },
      {
        "sha": "c6d9b652b8b914da2f528bae962b9e8c22edb6c5",
        "filename": "share/rpcauth/rpcauth.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/129805b114a8a14d4e29076b972b50070fbee079/share/rpcauth/rpcauth.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/129805b114a8a14d4e29076b972b50070fbee079/share/rpcauth/rpcauth.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/rpcauth/rpcauth.py?ref=129805b114a8a14d4e29076b972b50070fbee079",
        "patch": "@@ -5,15 +5,14 @@\n \n from argparse import ArgumentParser\n from base64 import urlsafe_b64encode\n-from binascii import hexlify\n from getpass import getpass\n from os import urandom\n \n import hmac\n \n def generate_salt(size):\n     \"\"\"Create size byte hex salt\"\"\"\n-    return hexlify(urandom(size)).decode()\n+    return urandom(size).hex()\n \n def generate_password():\n     \"\"\"Create 32 byte b64 password\"\"\""
      },
      {
        "sha": "15612e2950fcdd0ded045af82d048dd29401c287",
        "filename": "src/test/serfloat_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/129805b114a8a14d4e29076b972b50070fbee079/src/test/serfloat_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/129805b114a8a14d4e29076b972b50070fbee079/src/test/serfloat_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/serfloat_tests.cpp?ref=129805b114a8a14d4e29076b972b50070fbee079",
        "patch": "@@ -102,11 +102,12 @@ BOOST_AUTO_TEST_CASE(double_serfloat_tests) {\n Python code to generate the below hashes:\n \n     def reversed_hex(x):\n-        return binascii.hexlify(''.join(reversed(x)))\n+        return bytes(reversed(x)).hex()\n+\n     def dsha256(x):\n         return hashlib.sha256(hashlib.sha256(x).digest()).digest()\n \n-    reversed_hex(dsha256(''.join(struct.pack('<d', x) for x in range(0,1000)))) == '43d0c82591953c4eafe114590d392676a01585d25b25d433557f0d7878b23f96'\n+    reversed_hex(dsha256(b''.join(struct.pack('<d', x) for x in range(0,1000)))) == '43d0c82591953c4eafe114590d392676a01585d25b25d433557f0d7878b23f96'\n */\n BOOST_AUTO_TEST_CASE(doubles)\n {"
      },
      {
        "sha": "65d90f84487fe9cdaf8275afee88fc13ca403ea9",
        "filename": "test/functional/test_framework/messages.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/129805b114a8a14d4e29076b972b50070fbee079/test/functional/test_framework/messages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/129805b114a8a14d4e29076b972b50070fbee079/test/functional/test_framework/messages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/messages.py?ref=129805b114a8a14d4e29076b972b50070fbee079",
        "patch": "@@ -19,7 +19,6 @@\n by tests, compromising their intended effect.\n \"\"\"\n from base64 import b32decode, b32encode\n-from codecs import encode\n import copy\n import hashlib\n from io import BytesIO\n@@ -681,7 +680,7 @@ def calc_sha256(self):\n             r += struct.pack(\"<I\", self.nBits)\n             r += struct.pack(\"<I\", self.nNonce)\n             self.sha256 = uint256_from_str(hash256(r))\n-            self.hash = encode(hash256(r)[::-1], 'hex_codec').decode('ascii')\n+            self.hash = hash256(r)[::-1].hex()\n \n     def rehash(self):\n         self.sha256 = None"
      },
      {
        "sha": "aa8fd6eee5982074ae8b7aee596c6314ce5ebc4b",
        "filename": "test/util/bitcoin-util-test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/129805b114a8a14d4e29076b972b50070fbee079/test/util/bitcoin-util-test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/129805b114a8a14d4e29076b972b50070fbee079/test/util/bitcoin-util-test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/util/bitcoin-util-test.py?ref=129805b114a8a14d4e29076b972b50070fbee079",
        "patch": "@@ -10,7 +10,6 @@\n Can also be run manually.\"\"\"\n \n import argparse\n-import binascii\n import configparser\n import difflib\n import json\n@@ -167,7 +166,7 @@ def parse_output(a, fmt):\n     if fmt == 'json':  # json: compare parsed data\n         return json.loads(a)\n     elif fmt == 'hex':  # hex: parse and compare binary data\n-        return binascii.a2b_hex(a.strip())\n+        return bytes.fromhex(a.strip())\n     else:\n         raise NotImplementedError(\"Don't know how to compare %s\" % fmt)\n "
      }
    ]
  },
  {
    "sha": "c5aa8c2fb8364306f33259eef9490dcc64adff13",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNWFhOGMyZmI4MzY0MzA2ZjMzMjU5ZWVmOTQ5MGRjYzY0YWRmZjEz",
    "commit": {
      "author": {
        "name": "Edson T\u00e9gila",
        "email": "etegila@gmail.com",
        "date": "2021-08-21T16:59:05Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-08-21T16:59:05Z"
      },
      "message": "Update Dockerfile\n\nNow using scratch as the main image to remove completely any dependencies related to the final image.\r\nStill have some way to get better size and less requirements but need some time to evolve.",
      "tree": {
        "sha": "57d5ba8da3d0ba8490d002d7bb711f110ebbf07c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/57d5ba8da3d0ba8490d002d7bb711f110ebbf07c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c5aa8c2fb8364306f33259eef9490dcc64adff13",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhITDZCRBK7hj4Ov3rIwAA+5gIAIcmuWCv0AQ/of96zbgsgjp5\ncuHMhzp2HX8smS4ru0jgGD6E9tYLwn2o6tZJwkwxR+4i9HQMqfqhqXeHa+IBXFQF\ns8GXqxbTLsR+jDGS1m5qWUKwUzFxVmRlXxgTUXvARVHANY6Qzig+jvBuFJ0cvhwW\ncj0iSbLN/dY46WAWnL4uoZzoATcZ9EZxeR9Pr90/6Or8+8uOaXkgdKpMsAGP1aSk\nQOmRy1l2H9pGikTcMk6GG4/ZovHeM23Jhks3z52k2AWI/9MHBObyH8aZ7J2z2bZ+\nX7/t+gE2INzcBFw6iPekmI/Tx5bgs/9DPuw6i6PF7/7boPw2dz/nVJKeTR5/6NA=\n=WuMc\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 57d5ba8da3d0ba8490d002d7bb711f110ebbf07c\nparent 129805b114a8a14d4e29076b972b50070fbee079\nauthor Edson T\u00e9gila <etegila@gmail.com> 1629565145 -0300\ncommitter GitHub <noreply@github.com> 1629565145 -0300\n\nUpdate Dockerfile\n\nNow using scratch as the main image to remove completely any dependencies related to the final image.\r\nStill have some way to get better size and less requirements but need some time to evolve."
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c5aa8c2fb8364306f33259eef9490dcc64adff13",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c5aa8c2fb8364306f33259eef9490dcc64adff13",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c5aa8c2fb8364306f33259eef9490dcc64adff13/comments",
    "author": {
      "login": "tegila",
      "id": 105643,
      "node_id": "MDQ6VXNlcjEwNTY0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/105643?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tegila",
      "html_url": "https://github.com/tegila",
      "followers_url": "https://api.github.com/users/tegila/followers",
      "following_url": "https://api.github.com/users/tegila/following{/other_user}",
      "gists_url": "https://api.github.com/users/tegila/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tegila/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tegila/subscriptions",
      "organizations_url": "https://api.github.com/users/tegila/orgs",
      "repos_url": "https://api.github.com/users/tegila/repos",
      "events_url": "https://api.github.com/users/tegila/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tegila/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "129805b114a8a14d4e29076b972b50070fbee079",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/129805b114a8a14d4e29076b972b50070fbee079",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/129805b114a8a14d4e29076b972b50070fbee079"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 5,
      "deletions": 14
    },
    "files": [
      {
        "sha": "0a34149708450a0cc2396d411d157af8fcd70925",
        "filename": "Dockerfile",
        "status": "modified",
        "additions": 5,
        "deletions": 14,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c5aa8c2fb8364306f33259eef9490dcc64adff13/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c5aa8c2fb8364306f33259eef9490dcc64adff13/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Dockerfile?ref=c5aa8c2fb8364306f33259eef9490dcc64adff13",
        "patch": "@@ -31,22 +31,13 @@ RUN ./configure --disable-ccache \\\n RUN make\n RUN make install\n \n-FROM alpine\n+FROM scratch\n COPY --from=build /usr/local /usr/local\n-RUN apk --no-cache add bash coreutils shadow\n+COPY --from=build /bitcoin/share/examples/bitcoin.conf /.bitcoin/bitcoin.conf\n \n-ARG UNAME=bitcoin\n-ARG UID=1000\n-ARG GID=1000\n-RUN groupadd -g $GID -o $UNAME\n-RUN useradd -m -u $UID -g $GID -o -s /bin/bash $UNAME\n-USER $UNAME\n-\n-USER bitcoin\n-COPY --chown=bitcoin:bitcoin --from=build /bitcoin/share/examples/bitcoin.conf /home/bitcoin/.bitcoin/bitcoin.conf\n-\n-VOLUME [\"/home/bitcoin/.bitcoin\"]\n+VOLUME [\"/.bitcoin\"]\n \n EXPOSE 8332 8333 18332 18333 18444\n \n-CMD [\"bitcoind\", \"-datadir=/home/bitcoin/.bitcoin\", \"-printtoconsole\"]\n+CMD [\"/usr/local/bin/bitcoind\", \"-printtoconsole\"]\n+"
      }
    ]
  },
  {
    "sha": "921841338ed955d18df1ea5630b88480298a4f02",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5MjE4NDEzMzhlZDk1NWQxOGRmMWVhNTYzMGI4ODQ4MDI5OGE0ZjAy",
    "commit": {
      "author": {
        "name": "Edson T\u00e9gila",
        "email": "etegila@gmail.com",
        "date": "2021-08-22T21:38:23Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-08-22T21:38:23Z"
      },
      "message": "Merge branch 'bitcoin:master' into master",
      "tree": {
        "sha": "38604d143e5265f14ff21fe22331b7709100a416",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/38604d143e5265f14ff21fe22331b7709100a416"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/921841338ed955d18df1ea5630b88480298a4f02",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhIsPPCRBK7hj4Ov3rIwAARqsIAGrym67FjKnoUvIGQsJJdtSu\nDsJLsuSaXpt1u6L9n3BUIlPLO5wAyF6aiQ4CYFWJNRxZAhLqzoNhTXB1xrPnJlTp\nSQicRrNqFFMMXrbXEkR0G0ZHyutgvfpQOanIqgoXe2aOELywTy3wktuiEX0cpfVi\nBuIZJoG+1kifrD42ZPu32SyxUoOHPdR5+3e0Od8UNQVVzX91gKXuRyjvpZnPgyE8\nZui0VlcoF4oxV5Ho63OzX4zl15PLa0rHlzkIXhaFYb2FuRBY20sx/prAUZxESeFo\nC97pCfJaSmBsiBc2EZHwnsZ+MeKzWcvdXfukn89J/QxufgPxaFICPGndvjwEuQ8=\n=LDiM\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 38604d143e5265f14ff21fe22331b7709100a416\nparent c5aa8c2fb8364306f33259eef9490dcc64adff13\nparent e9d6eb1b8071805cec1cc4e1352a13a7adc55ca8\nauthor Edson T\u00e9gila <etegila@gmail.com> 1629668303 -0300\ncommitter GitHub <noreply@github.com> 1629668303 -0300\n\nMerge branch 'bitcoin:master' into master\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/921841338ed955d18df1ea5630b88480298a4f02",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/921841338ed955d18df1ea5630b88480298a4f02",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/921841338ed955d18df1ea5630b88480298a4f02/comments",
    "author": {
      "login": "tegila",
      "id": 105643,
      "node_id": "MDQ6VXNlcjEwNTY0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/105643?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tegila",
      "html_url": "https://github.com/tegila",
      "followers_url": "https://api.github.com/users/tegila/followers",
      "following_url": "https://api.github.com/users/tegila/following{/other_user}",
      "gists_url": "https://api.github.com/users/tegila/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tegila/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tegila/subscriptions",
      "organizations_url": "https://api.github.com/users/tegila/orgs",
      "repos_url": "https://api.github.com/users/tegila/repos",
      "events_url": "https://api.github.com/users/tegila/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tegila/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c5aa8c2fb8364306f33259eef9490dcc64adff13",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c5aa8c2fb8364306f33259eef9490dcc64adff13",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c5aa8c2fb8364306f33259eef9490dcc64adff13"
      },
      {
        "sha": "e9d6eb1b8071805cec1cc4e1352a13a7adc55ca8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e9d6eb1b8071805cec1cc4e1352a13a7adc55ca8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e9d6eb1b8071805cec1cc4e1352a13a7adc55ca8"
      }
    ],
    "stats": {
      "total": 42,
      "additions": 30,
      "deletions": 12
    },
    "files": [
      {
        "sha": "eceede3c8f19a7e5ce278656572e0a31078aca12",
        "filename": "src/interfaces/chain.h",
        "status": "modified",
        "additions": 9,
        "deletions": 2,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/921841338ed955d18df1ea5630b88480298a4f02/src/interfaces/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/921841338ed955d18df1ea5630b88480298a4f02/src/interfaces/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/chain.h?ref=921841338ed955d18df1ea5630b88480298a4f02",
        "patch": "@@ -265,11 +265,18 @@ class Chain\n     //! Current RPC serialization flags.\n     virtual int rpcSerializationFlags() = 0;\n \n+    //! Get settings value.\n+    virtual util::SettingsValue getSetting(const std::string& arg) = 0;\n+\n+    //! Get list of settings values.\n+    virtual std::vector<util::SettingsValue> getSettingsList(const std::string& arg) = 0;\n+\n     //! Return <datadir>/settings.json setting value.\n     virtual util::SettingsValue getRwSetting(const std::string& name) = 0;\n \n-    //! Write a setting to <datadir>/settings.json.\n-    virtual bool updateRwSetting(const std::string& name, const util::SettingsValue& value) = 0;\n+    //! Write a setting to <datadir>/settings.json. Optionally just update the\n+    //! setting in memory and do not write the file.\n+    virtual bool updateRwSetting(const std::string& name, const util::SettingsValue& value, bool write=true) = 0;\n \n     //! Synchronously send transactionAddedToMempool notifications about all\n     //! current mempool transactions to the specified handler and return after"
      },
      {
        "sha": "b46ad0333e53dc60ebeab346215a23fbc04c5335",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/921841338ed955d18df1ea5630b88480298a4f02/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/921841338ed955d18df1ea5630b88480298a4f02/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=921841338ed955d18df1ea5630b88480298a4f02",
        "patch": "@@ -661,6 +661,14 @@ class ChainImpl : public Chain\n         RPCRunLater(name, std::move(fn), seconds);\n     }\n     int rpcSerializationFlags() override { return RPCSerializationFlags(); }\n+    util::SettingsValue getSetting(const std::string& name) override\n+    {\n+        return gArgs.GetSetting(name);\n+    }\n+    std::vector<util::SettingsValue> getSettingsList(const std::string& name) override\n+    {\n+        return gArgs.GetSettingsList(name);\n+    }\n     util::SettingsValue getRwSetting(const std::string& name) override\n     {\n         util::SettingsValue result;\n@@ -671,7 +679,7 @@ class ChainImpl : public Chain\n         });\n         return result;\n     }\n-    bool updateRwSetting(const std::string& name, const util::SettingsValue& value) override\n+    bool updateRwSetting(const std::string& name, const util::SettingsValue& value, bool write) override\n     {\n         gArgs.LockSettings([&](util::Settings& settings) {\n             if (value.isNull()) {\n@@ -680,7 +688,7 @@ class ChainImpl : public Chain\n                 settings.rw_settings[name] = value;\n             }\n         });\n-        return gArgs.WriteSettingsFile();\n+        return !write || gArgs.WriteSettingsFile();\n     }\n     void requestMempoolTransactions(Notifications& notifications) override\n     {"
      },
      {
        "sha": "3c1399629c1083c288b2b25c13acc8e7c8a97f2f",
        "filename": "src/util/system.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/921841338ed955d18df1ea5630b88480298a4f02/src/util/system.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/921841338ed955d18df1ea5630b88480298a4f02/src/util/system.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/system.h?ref=921841338ed955d18df1ea5630b88480298a4f02",
        "patch": "@@ -205,6 +205,7 @@ class ArgsManager\n      */\n     bool UseDefaultSection(const std::string& arg) const EXCLUSIVE_LOCKS_REQUIRED(cs_args);\n \n+ public:\n     /**\n      * Get setting value.\n      *\n@@ -219,7 +220,6 @@ class ArgsManager\n      */\n     std::vector<util::SettingsValue> GetSettingsList(const std::string& arg) const;\n \n-public:\n     ArgsManager();\n     ~ArgsManager();\n "
      },
      {
        "sha": "88e9b9c78f032944bc7b32d677daf805c510281f",
        "filename": "src/wallet/load.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/921841338ed955d18df1ea5630b88480298a4f02/src/wallet/load.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/921841338ed955d18df1ea5630b88480298a4f02/src/wallet/load.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/load.cpp?ref=921841338ed955d18df1ea5630b88480298a4f02",
        "patch": "@@ -52,18 +52,20 @@ bool VerifyWallets(WalletContext& context)\n         options.require_existing = true;\n         options.verify = false;\n         if (MakeWalletDatabase(\"\", options, status, error_string)) {\n-            gArgs.LockSettings([&](util::Settings& settings) {\n-                util::SettingsValue wallets(util::SettingsValue::VARR);\n-                wallets.push_back(\"\"); // Default wallet name is \"\"\n-                settings.rw_settings[\"wallet\"] = wallets;\n-            });\n+            util::SettingsValue wallets(util::SettingsValue::VARR);\n+            wallets.push_back(\"\"); // Default wallet name is \"\"\n+            // Pass write=false because no need to write file and probably\n+            // better not to. If unnamed wallet needs to be added next startup\n+            // and the setting is empty, this code will just run again.\n+            chain.updateRwSetting(\"wallet\", wallets, /* write= */ false);\n         }\n     }\n \n     // Keep track of each wallet absolute path to detect duplicates.\n     std::set<fs::path> wallet_paths;\n \n-    for (const auto& wallet_file : gArgs.GetArgs(\"-wallet\")) {\n+    for (const auto& wallet : chain.getSettingsList(\"wallet\")) {\n+        const auto& wallet_file = wallet.get_str();\n         const fs::path path = fsbridge::AbsPathJoin(GetWalletDir(), wallet_file);\n \n         if (!wallet_paths.insert(path).second) {\n@@ -94,7 +96,8 @@ bool LoadWallets(WalletContext& context)\n     interfaces::Chain& chain = *context.chain;\n     try {\n         std::set<fs::path> wallet_paths;\n-        for (const std::string& name : gArgs.GetArgs(\"-wallet\")) {\n+        for (const auto& wallet : chain.getSettingsList(\"wallet\")) {\n+            const auto& name = wallet.get_str();\n             if (!wallet_paths.insert(name).second) {\n                 continue;\n             }"
      }
    ]
  },
  {
    "sha": "243a352d63078b8eacba0c64f991bc359c9ff1f7",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNDNhMzUyZDYzMDc4YjhlYWNiYTBjNjRmOTkxYmMzNTljOWZmMWY3",
    "commit": {
      "author": {
        "name": "Edson T\u00e9gila",
        "email": "etegila@gmail.com",
        "date": "2021-08-22T21:42:26Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-08-22T21:42:26Z"
      },
      "message": "Update Dockerfile\n\nenable tests on deployment",
      "tree": {
        "sha": "61123a346ba9a960831826f4f083f6219c0ec490",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/61123a346ba9a960831826f4f083f6219c0ec490"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/243a352d63078b8eacba0c64f991bc359c9ff1f7",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhIsTCCRBK7hj4Ov3rIwAA7WsIAI6E5z+/YptZ+4XddzZ/5wiV\no/GPyxftSfoO+qq7LAmX6Gv+OdiBSxkE6d24fXxacF3sI8igkbdAH0Fu3mYiRJDy\nM4DPbD6gLtda0LLMNSFw6ol3YiTKKcRnpacDSLfKPfvFC4GV9myHJO9HDsq3YSsz\nDGAfzykgnjuCEKV+S/41SRbD+k0H6psH778aAwk/rFWrz7KRY7sjR/TPC1A7u0Y6\nUkAL/rBelo2mxWdlWlf8XaKqLlbVSZ3RGZLvaGVOel2fdcs/MlYW6D8G+9AbJ3nC\npUWcPk+9F68aEEPrBot1Shr//gf0xtNMYLcNV2juIjYhQAVKs2WiwpebDr122No=\n=kmyU\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 61123a346ba9a960831826f4f083f6219c0ec490\nparent 921841338ed955d18df1ea5630b88480298a4f02\nauthor Edson T\u00e9gila <etegila@gmail.com> 1629668546 -0300\ncommitter GitHub <noreply@github.com> 1629668546 -0300\n\nUpdate Dockerfile\n\nenable tests on deployment"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/243a352d63078b8eacba0c64f991bc359c9ff1f7",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/243a352d63078b8eacba0c64f991bc359c9ff1f7",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/243a352d63078b8eacba0c64f991bc359c9ff1f7/comments",
    "author": {
      "login": "tegila",
      "id": 105643,
      "node_id": "MDQ6VXNlcjEwNTY0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/105643?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tegila",
      "html_url": "https://github.com/tegila",
      "followers_url": "https://api.github.com/users/tegila/followers",
      "following_url": "https://api.github.com/users/tegila/following{/other_user}",
      "gists_url": "https://api.github.com/users/tegila/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tegila/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tegila/subscriptions",
      "organizations_url": "https://api.github.com/users/tegila/orgs",
      "repos_url": "https://api.github.com/users/tegila/repos",
      "events_url": "https://api.github.com/users/tegila/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tegila/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "921841338ed955d18df1ea5630b88480298a4f02",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/921841338ed955d18df1ea5630b88480298a4f02",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/921841338ed955d18df1ea5630b88480298a4f02"
      }
    ],
    "stats": {
      "total": 3,
      "additions": 2,
      "deletions": 1
    },
    "files": [
      {
        "sha": "6a2ffd866304d679cf12768cc63ccfb8cefece50",
        "filename": "Dockerfile",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/243a352d63078b8eacba0c64f991bc359c9ff1f7/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/243a352d63078b8eacba0c64f991bc359c9ff1f7/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Dockerfile?ref=243a352d63078b8eacba0c64f991bc359c9ff1f7",
        "patch": "@@ -21,14 +21,15 @@ RUN ./configure --disable-ccache \\\n     --disable-maintainer-mode \\\n     --disable-dependency-tracking \\\n     --enable-reduce-exports --disable-bench \\\n-    --disable-tests \\\n+#    --disable-tests \\\n     --disable-gui-tests \\\n     --without-gui \\\n     --without-miniupnpc \\\n     CFLAGS=\"-O2 -g0 --static -static -fPIC\" \\\n     CXXFLAGS=\"-O2 -g0 --static -static -fPIC\" \\\n     LDFLAGS=\"-s -static-libgcc -static-libstdc++ -Wl,-O2\"\n RUN make\n+RUN make check\n RUN make install\n \n FROM scratch"
      }
    ]
  },
  {
    "sha": "f5786ed44f8531379cf4908a0867321db430cb57",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNTc4NmVkNDRmODUzMTM3OWNmNDkwOGEwODY3MzIxZGI0MzBjYjU3",
    "commit": {
      "author": {
        "name": "Edson T\u00e9gila",
        "email": "etegila@gmail.com",
        "date": "2021-09-18T23:30:18Z"
      },
      "committer": {
        "name": "GitHub",
        "email": "noreply@github.com",
        "date": "2021-09-18T23:30:18Z"
      },
      "message": "Merge branch 'bitcoin:master' into master",
      "tree": {
        "sha": "163b353df1f96d4a4e8ec783350f74d5d0f1ac31",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/163b353df1f96d4a4e8ec783350f74d5d0f1ac31"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f5786ed44f8531379cf4908a0867321db430cb57",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\nwsBcBAABCAAQBQJhRnaLCRBK7hj4Ov3rIwAAcrUIAFIe+cwgG/ybjseFZblRlCkw\nNOVkTtardPyk5BzRahN93avzYeDAj5lnjasz0tpBLf/7z7WWfjDMKu6rrIUy7qD0\nJAGPProS7UZtg6ZzAKQtrQxcWHXbwfH5evFrnl1ZH6dv+hjPY1kw5FTGGZ9FgLv5\nAVzBNp8pHVi0ZVQtzBJLJIfXjzZ9m8nJm0qbdhKqhQoSVCvbkhx8o+dtdXvhQIbi\nWhW2N8vXfCvYOW2Ivff4vgH8qfHFGemuTHO82/j+x0Y+erehxTOlczTqAzANzUOv\n+40FhvJrrpqqWczJMwrOkB1SNs2l2KC+MCfN5QIe49l3nN8q5ICL2KZT5J7kYQw=\n=Lpqu\n-----END PGP SIGNATURE-----\n",
        "payload": "tree 163b353df1f96d4a4e8ec783350f74d5d0f1ac31\nparent 243a352d63078b8eacba0c64f991bc359c9ff1f7\nparent de2af19dc8e8c848afbc4b43b9b4092fe263364f\nauthor Edson T\u00e9gila <etegila@gmail.com> 1632007818 -0300\ncommitter GitHub <noreply@github.com> 1632007818 -0300\n\nMerge branch 'bitcoin:master' into master\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f5786ed44f8531379cf4908a0867321db430cb57",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f5786ed44f8531379cf4908a0867321db430cb57",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f5786ed44f8531379cf4908a0867321db430cb57/comments",
    "author": {
      "login": "tegila",
      "id": 105643,
      "node_id": "MDQ6VXNlcjEwNTY0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/105643?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/tegila",
      "html_url": "https://github.com/tegila",
      "followers_url": "https://api.github.com/users/tegila/followers",
      "following_url": "https://api.github.com/users/tegila/following{/other_user}",
      "gists_url": "https://api.github.com/users/tegila/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/tegila/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/tegila/subscriptions",
      "organizations_url": "https://api.github.com/users/tegila/orgs",
      "repos_url": "https://api.github.com/users/tegila/repos",
      "events_url": "https://api.github.com/users/tegila/events{/privacy}",
      "received_events_url": "https://api.github.com/users/tegila/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "web-flow",
      "id": 19864447,
      "node_id": "MDQ6VXNlcjE5ODY0NDQ3",
      "avatar_url": "https://avatars.githubusercontent.com/u/19864447?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/web-flow",
      "html_url": "https://github.com/web-flow",
      "followers_url": "https://api.github.com/users/web-flow/followers",
      "following_url": "https://api.github.com/users/web-flow/following{/other_user}",
      "gists_url": "https://api.github.com/users/web-flow/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/web-flow/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/web-flow/subscriptions",
      "organizations_url": "https://api.github.com/users/web-flow/orgs",
      "repos_url": "https://api.github.com/users/web-flow/repos",
      "events_url": "https://api.github.com/users/web-flow/events{/privacy}",
      "received_events_url": "https://api.github.com/users/web-flow/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "243a352d63078b8eacba0c64f991bc359c9ff1f7",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/243a352d63078b8eacba0c64f991bc359c9ff1f7",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/243a352d63078b8eacba0c64f991bc359c9ff1f7"
      },
      {
        "sha": "de2af19dc8e8c848afbc4b43b9b4092fe263364f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/de2af19dc8e8c848afbc4b43b9b4092fe263364f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/de2af19dc8e8c848afbc4b43b9b4092fe263364f"
      }
    ],
    "stats": {
      "total": 9901,
      "additions": 5266,
      "deletions": 4635
    },
    "files": [
      {
        "sha": "3ca7818ecad24cdb4937763142a5ff746aa92605",
        "filename": ".appveyor.yml",
        "status": "removed",
        "additions": 0,
        "deletions": 63,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/243a352d63078b8eacba0c64f991bc359c9ff1f7/.appveyor.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/243a352d63078b8eacba0c64f991bc359c9ff1f7/.appveyor.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.appveyor.yml?ref=243a352d63078b8eacba0c64f991bc359c9ff1f7",
        "patch": "@@ -1,63 +0,0 @@\n-version: '{branch}.{build}'\n-skip_tags: true\n-image: Visual Studio 2019\n-configuration: Release\n-platform: x64\n-clone_depth: 5\n-environment:\n-  PATH: 'C:\\Python37-x64;C:\\Python37-x64\\Scripts;%PATH%'\n-  PYTHONUTF8: 1\n-  QT_DOWNLOAD_URL: 'https://github.com/sipsorcery/qt_win_binary/releases/download/qt51211x64_static_vs2019_16101/Qt5.12.11_x64_static_vs2019_16101.zip'\n-  QT_DOWNLOAD_HASH: 'cf1b58107fadbf0d9a957d14dab16cde6b6eb6936a1908472da1f967dda34a3a'\n-  QT_LOCAL_PATH: 'C:\\Qt5.12.11_x64_static_vs2019_16101'\n-  VCPKG_TAG: '75522bb1f2e7d863078bcd06322348f053a9e33f'\n-install:\n-# Disable zmq test for now since python zmq library on Windows would cause Access violation sometimes.\n-# - cmd: pip install zmq\n-# The powershell block below is to set up vcpkg to install the c++ dependencies. The pseudo code is:\n-#    a. Checkout the vcpkg source (including port files) for the specific checkout and build the vcpkg binary,\n-#    b. Append a setting to the vcpkg cmake config file to only do release builds of dependencies (skipping deubg builds saves ~5 mins).\n-# Note originally this block also installed the dependencies using 'vcpkg install'. Dependencies are now installed\n-# as part of the msbuild command using vcpkg mainfests.\n-- ps: |\n-      cd c:\\tools\\vcpkg\n-      $env:GIT_REDIRECT_STDERR = '2>&1' # git is writing non-errors to STDERR when doing git pull. Send to STDOUT instead.\n-      git -c advice.detachedHead=false checkout $env:VCPKG_TAG\n-      .\\bootstrap-vcpkg.bat > $null\n-      Add-Content \"C:\\tools\\vcpkg\\triplets\\$env:PLATFORM-windows-static.cmake\" \"set(VCPKG_BUILD_TYPE release)\"\n-      cd \"$env:APPVEYOR_BUILD_FOLDER\"\n-before_build:\n-# Powershell block below is to download and extract the Qt static libraries. The pseudo code is:\n-#    a. Download the zip file with the prebuilt Qt static libraries.\n-#    b. Check that the downloaded file matches the expected hash.\n-#    c. Extract the zip file to the specific destination path expected by the msbuild projects.\n-- ps: |\n-      Write-Host \"Downloading Qt binaries.\";\n-      Invoke-WebRequest -Uri $env:QT_DOWNLOAD_URL -Out qtdownload.zip;\n-      Write-Host \"Qt binaries successfully downloaded, checking hash against $env:QT_DOWNLOAD_HASH...\";\n-      if((Get-FileHash qtdownload.zip).Hash -eq $env:QT_DOWNLOAD_HASH) {\n-        Expand-Archive qtdownload.zip -DestinationPath $env:QT_LOCAL_PATH;\n-        Write-Host \"Qt binary download matched the expected hash.\";\n-      }\n-      else {\n-        Write-Host \"ERROR: Qt binary download did not match the expected hash.\";\n-        Exit-AppveyorBuild;\n-      }\n-- cmd: python build_msvc\\msvc-autogen.py\n-build_script:\n-- cmd: msbuild /p:TrackFileAccess=false build_msvc\\bitcoin.sln /m /v:q /nologo\n-after_build:\n-#- 7z a bitcoin-%APPVEYOR_BUILD_VERSION%.zip %APPVEYOR_BUILD_FOLDER%\\build_msvc\\%platform%\\%configuration%\\*.exe\n-test_script:\n-- cmd: src\\test_bitcoin.exe -l test_suite\n-- cmd: src\\bench_bitcoin.exe > NUL\n-- ps:  python test\\util\\bitcoin-util-test.py\n-- cmd: python test\\util\\rpcauth-test.py\n-# Fee estimation test failing on appveyor with: WinError 10048] Only one usage of each socket address (protocol/network address/port) is normally permitted.\n-# functional tests disabled for now. See\n-# https://github.com/bitcoin/bitcoin/pull/18626#issuecomment-613396202\n-# https://github.com/bitcoin/bitcoin/issues/18623\n-# - cmd: python test\\functional\\test_runner.py --ci --quiet --combinedlogslen=4000 --failfast --exclude feature_fee_estimation\n-artifacts:\n-#- path: bitcoin-%APPVEYOR_BUILD_VERSION%.zip\n-deploy: off"
      },
      {
        "sha": "398f463ecc5ad821b35843c42b02ee9cdeebec2a",
        "filename": ".cirrus.yml",
        "status": "modified",
        "additions": 90,
        "deletions": 27,
        "changes": 117,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/.cirrus.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/.cirrus.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.cirrus.yml?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -1,6 +1,4 @@\n-### Global defaults\n-\n-env:\n+env:  # Global defaults\n   PACKAGE_MANAGER_INSTALL: \"apt-get update && apt-get install -y\"\n   MAKEJOBS: \"-j4\"\n   TEST_RUNNER_PORT_MIN: \"14000\"  # Must be larger than 12321, which is used for the http cache. See https://cirrus-ci.org/guide/writing-tasks/#http-cache\n@@ -18,16 +16,21 @@ persistent_worker_template: &PERSISTENT_WORKER_TEMPLATE\n   persistent_worker: {}  # https://cirrus-ci.org/guide/persistent-workers/\n \n # https://cirrus-ci.org/guide/tips-and-tricks/#sharing-configuration-between-tasks\n-base_template: &BASE_TEMPLATE\n+filter_template: &FILTER_TEMPLATE\n   skip: $CIRRUS_REPO_FULL_NAME == \"bitcoin-core/gui\" && $CIRRUS_PR == \"\"  # No need to run on the read-only mirror, unless it is a PR. https://cirrus-ci.org/guide/writing-tasks/#conditional-task-execution\n+  stateful: false  # https://cirrus-ci.org/guide/writing-tasks/#stateful-tasks\n+\n+base_template: &BASE_TEMPLATE\n+  << : *FILTER_TEMPLATE\n   merge_base_script:\n+    # Unconditionally install git (used in fingerprint_script) and set the\n+    # default git author name (used in verify-commits.py)\n     - bash -c \"$PACKAGE_MANAGER_INSTALL git\"\n-    - if [ \"$CIRRUS_PR\" = \"\" ]; then exit 0; fi\n-    - git fetch $CIRRUS_REPO_CLONE_URL $CIRRUS_BASE_BRANCH\n     - git config --global user.email \"ci@ci.ci\"\n     - git config --global user.name \"ci\"\n+    - if [ \"$CIRRUS_PR\" = \"\" ]; then exit 0; fi\n+    - git fetch $CIRRUS_REPO_CLONE_URL $CIRRUS_BASE_BRANCH\n     - git merge FETCH_HEAD  # Merge base to detect silent merge conflicts\n-  stateful: false  # https://cirrus-ci.org/guide/writing-tasks/#stateful-tasks\n \n main_template: &MAIN_TEMPLATE\n   timeout_in: 120m  # https://cirrus-ci.org/faq/#instance-timed-out\n@@ -57,22 +60,6 @@ compute_credits_template: &CREDITS_TEMPLATE\n   # Only use credits for pull requests to the main repo\n   use_compute_credits: $CIRRUS_REPO_FULL_NAME == 'bitcoin/bitcoin' && $CIRRUS_PR != \"\"\n \n-#task:\n-#  name: \"Windows\"\n-#  windows_container:\n-#    image: cirrusci/windowsservercore:2019\n-#  env:\n-#    CIRRUS_SHELL: powershell\n-#    PATH: 'C:\\Python37;C:\\Python37\\Scripts;%PATH%'\n-#    PYTHONUTF8: 1\n-#    QT_DOWNLOAD_URL: 'https://github.com/sipsorcery/qt_win_binary/releases/download/v1.6/Qt5.9.8_x64_static_vs2019.zip'\n-#    QT_DOWNLOAD_HASH: '9a8c6eb20967873785057fdcd329a657c7f922b0af08c5fde105cc597dd37e21'\n-#    QT_LOCAL_PATH: 'C:\\Qt5.9.8_x64_static_vs2019'\n-#    VCPKG_INSTALL_PATH: 'C:\\tools\\vcpkg\\installed'\n-#    VCPKG_COMMIT_ID: 'ed0df8ecc4ed7e755ea03e18aaf285fd9b4b4a74'\n-#  install_script:\n-#    - choco install python --version=3.7.7 -y\n-\n task:\n   name: 'lint [bionic]'\n   << : *BASE_TEMPLATE\n@@ -88,10 +75,86 @@ task:\n     << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n \n task:\n-  name: 'ARM [unit tests, no functional tests] [buster]'\n+  name: \"Win64 native [msvc]\"\n+  << : *FILTER_TEMPLATE\n+  windows_container:\n+    cpu: 4\n+    memory: 16G\n+    image: cirrusci/windowsservercore:visualstudio2019\n+  timeout_in: 120m\n+  env:\n+    PATH: 'C:\\jom;C:\\Python39;C:\\Python39\\Scripts;C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\BuildTools\\MSBuild\\Current\\Bin;%PATH%'\n+    PYTHONUTF8: 1\n+    VCPKG_TAG: '75522bb1f2e7d863078bcd06322348f053a9e33f'\n+    VCPKG_FEATURE_FLAGS: 'manifests'\n+    QT_DOWNLOAD_URL: 'https://download.qt.io/official_releases/qt/5.12/5.12.11/single/qt-everywhere-src-5.12.11.zip'\n+    QT_LOCAL_PATH: 'C:\\qt-everywhere-src-5.12.11.zip'\n+    QT_SOURCE_DIR: 'C:\\qt-everywhere-src-5.12.11'\n+    QTBASEDIR: 'C:\\Qt5.12.11_x64_static_vs2019_160900'\n+    x64_NATIVE_TOOLS: '\"C:\\Program Files (x86)\\Microsoft Visual Studio\\2019\\BuildTools\\VC\\Auxiliary\\Build\\vcvars64.bat\"'\n+    IgnoreWarnIntDirInTempDetected: 'true'\n+    EXCLUDE_TESTS: 'feature_addrman.py,feature_bip68_sequence.py,feature_fee_estimation.py,mining_prioritisetransaction.py,p2p_getaddr_caching.py,p2p_invalid_locator.py,p2p_invalid_tx.py,rpc_misc.py,rpc_net.py,wallet_avoidreuse.py,wallet_descriptor.py,wallet_groups.py,wallet_keypool.py'\n+  merge_script:\n+    - git config --global user.email \"ci@ci.ci\"\n+    - git config --global user.name \"ci\"\n+    # Windows filesystem loses the executable bit, and all of the executable\n+    # files are considered \"modified\" now. It will break the following `git merge`\n+    # command. The next two commands make git ignore this issue.\n+    - git config core.filemode false\n+    - git reset --hard\n+    - PowerShell -NoLogo -Command if ($env:CIRRUS_PR -ne $null) { git fetch $env:CIRRUS_REPO_CLONE_URL $env:CIRRUS_BASE_BRANCH; git merge FETCH_HEAD; }\n+  msvc_qt_built_cache:\n+    folder: \"%QTBASEDIR%\"\n+    reupload_on_changes: false\n+    fingerprint_script:\n+      - echo %QT_DOWNLOAD_URL%\n+      - msbuild -version\n+    populate_script:\n+      - curl -L -o C:\\jom.zip http://download.qt.io/official_releases/jom/jom.zip\n+      - mkdir C:\\jom\n+      - tar -xf C:\\jom.zip -C C:\\jom\n+      - curl -L -o %QT_LOCAL_PATH% %QT_DOWNLOAD_URL%\n+      - tar -xf %QT_LOCAL_PATH% -C C:\\\n+      - '%x64_NATIVE_TOOLS%'\n+      - cd %QT_SOURCE_DIR%\n+      - mkdir build\n+      - cd build\n+      - ..\\configure -release -silent -opensource -confirm-license -opengl desktop -no-shared -static -static-runtime -mp -qt-zlib -qt-pcre -qt-libpng -no-libjpeg -nomake examples -nomake tests -nomake tools -no-dbus -no-libudev -no-icu -no-gtk -no-opengles3 -no-angle -no-sql-sqlite -no-sql-odbc -no-sqlite -no-libudev -no-vulkan -skip qt3d -skip qtactiveqt -skip qtandroidextras -skip qtcanvas3d -skip qtcharts -skip qtconnectivity -skip qtdatavis3d -skip qtdeclarative -skip qtdoc -skip qtgamepad -skip qtgraphicaleffects -skip qtimageformats -skip qtlocation -skip qtmacextras -skip qtmultimedia -skip qtnetworkauth -skip qtpurchasing -skip qtquickcontrols -skip qtquickcontrols2 -skip qtscript -skip qtscxml -skip qtsensors -skip qtserialbus -skip qtserialport -skip qtspeech -skip qtvirtualkeyboard -skip qtwayland -skip qtwebchannel -skip qtwebengine -skip qtwebsockets -skip qtwebview -skip qtx11extras -skip qtxmlpatterns -no-openssl -no-feature-sql -no-feature-sqlmodel -prefix %QTBASEDIR%\n+      - jom\n+      - jom install\n+  vcpkg_cache:\n+    folder: 'C:\\Users\\ContainerAdministrator\\AppData\\Local\\vcpkg\\archives'\n+  install_python_script:\n+    - choco install --yes --no-progress python3 --version=3.9.6\n+    - pip install zmq\n+    - python -VV\n+  install_vcpkg_script:\n+    - cd ..\n+    - git clone --quiet https://github.com/microsoft/vcpkg.git\n+    - cd vcpkg\n+    - git -c advice.detachedHead=false checkout %VCPKG_TAG%\n+    - .\\bootstrap-vcpkg -disableMetrics\n+    - echo set(VCPKG_BUILD_TYPE release) >> triplets\\x64-windows-static.cmake\n+    - .\\vcpkg integrate install\n+    - .\\vcpkg version\n+  build_script:\n+    - cd %CIRRUS_WORKING_DIR%\n+    - python build_msvc\\msvc-autogen.py\n+    - msbuild build_msvc\\bitcoin.sln -property:Configuration=Release -maxCpuCount -verbosity:minimal -noLogo\n+  unit_tests_script:\n+    - src\\test_bitcoin.exe -l test_suite\n+    - src\\bench_bitcoin.exe > NUL\n+    - python test\\util\\test_runner.py\n+    - python test\\util\\rpcauth-test.py\n+  functional_tests_script:\n+    # TODO enable '--extended' and drop '--exclude'.\n+    - python test\\functional\\test_runner.py --ci --quiet --combinedlogslen=4000 --jobs=4 --timeout-factor=8 --exclude %EXCLUDE_TESTS% --failfast\n+\n+task:\n+  name: 'ARM [unit tests, no functional tests] [bullseye]'\n   << : *GLOBAL_TASK_TEMPLATE\n   arm_container:\n-    image: debian:buster\n+    image: debian:bullseye\n     cpu: 2\n     memory: 8G\n   env:\n@@ -172,7 +235,7 @@ task:\n     FILE_ENV: \"./ci/test/00_setup_env_native_fuzz.sh\"\n \n task:\n-  name: '[multiprocess, DEBUG] [focal]'\n+  name: '[multiprocess, i686, DEBUG] [focal]'\n   << : *GLOBAL_TASK_TEMPLATE\n   container:\n     image: ubuntu:focal\n@@ -181,7 +244,7 @@ task:\n   env:\n     << : *CIRRUS_EPHEMERAL_WORKER_TEMPLATE_ENV\n     MAKEJOBS: \"-j8\"\n-    FILE_ENV: \"./ci/test/00_setup_env_native_multiprocess.sh\"\n+    FILE_ENV: \"./ci/test/00_setup_env_i686_multiprocess.sh\"\n \n task:\n   name: '[no wallet] [bionic]'"
      },
      {
        "sha": "ae7e92d1c8a82be207df3edd31d18ad37a99822c",
        "filename": ".editorconfig",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/.editorconfig",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/.editorconfig",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.editorconfig?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -13,7 +13,7 @@ trim_trailing_whitespace = true\n [*.{h,cpp,py,sh}]\n indent_size = 4\n \n-# .cirrus.yml, .appveyor.yml, .fuzzbuzz.yml, etc.\n+# .cirrus.yml, .fuzzbuzz.yml, etc.\n [*.yml]\n indent_size = 2\n "
      },
      {
        "sha": "4cead0303612f95828d392c137435947faced697",
        "filename": "INSTALL.md",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/INSTALL.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/INSTALL.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/INSTALL.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -1,5 +1 @@\n-Building Bitcoin\n-================\n-\n-See doc/build-*.md for instructions on building the various\n-elements of the Bitcoin Core reference implementation of Bitcoin.\n+See [doc/build-\\*.md](/doc)\n\\ No newline at end of file"
      },
      {
        "sha": "ce663319102d2a81c05e70dea7bfa37b59ab6ced",
        "filename": "Makefile.am",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/Makefile.am?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -286,7 +286,7 @@ EXTRA_DIST += \\\n     test/fuzz\n \n EXTRA_DIST += \\\n-    test/util/bitcoin-util-test.py \\\n+    test/util/test_runner.py \\\n     test/util/data/bitcoin-util-test.json \\\n     test/util/data/blanktxv1.hex \\\n     test/util/data/blanktxv1.json \\"
      },
      {
        "sha": "0caacec440f4cce72200c2f42b58e58d10a2219e",
        "filename": "REVIEWERS",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/REVIEWERS",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/REVIEWERS",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/REVIEWERS?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -41,7 +41,6 @@\n /doc/dependencies.md                        @fanquake\n /doc/developer-notes.md                     @laanwj\n /doc/files.md                               @hebasto\n-/doc/gitian-building.md                     @laanwj\n /doc/reduce-memory.md                       @fanquake\n /doc/reduce-traffic.md                      @jonasschnelli\n /doc/release-process.md                     @laanwj\n@@ -77,8 +76,7 @@\n /contrib/devtools/test-security-check.py    @fanquake\n /contrib/devtools/symbol-check.py           @fanquake\n \n-# Gitian/Guix\n-/contrib/gitian-build.py                    @hebasto\n+# Guix\n /contrib/guix/                              @dongcarl\n \n # Compatibility"
      },
      {
        "sha": "1e979edf0fc0e35c24afff203aed9b76429c61d9",
        "filename": "build-aux/m4/bitcoin_qt.m4",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/build-aux/m4/bitcoin_qt.m4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/build-aux/m4/bitcoin_qt.m4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build-aux/m4/bitcoin_qt.m4?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -350,7 +350,7 @@ AC_DEFUN([_BITCOIN_QT_CHECK_STATIC_LIBS], [\n   PKG_CHECK_MODULES([QT_FONTDATABASE], [${qt_lib_prefix}FontDatabaseSupport${qt_lib_suffix}], [QT_LIBS=\"$QT_FONTDATABASE_LIBS $QT_LIBS\"])\n   PKG_CHECK_MODULES([QT_THEME], [${qt_lib_prefix}ThemeSupport${qt_lib_suffix}], [QT_LIBS=\"$QT_THEME_LIBS $QT_LIBS\"])\n   if test \"x$TARGET_OS\" = xlinux; then\n-    PKG_CHECK_MODULES([QT_INPUT], [${qt_lib_prefix}XcbQpa], [QT_LIBS=\"$QT_INPUT_LIBS $QT_LIBS\"])\n+    PKG_CHECK_MODULES([QT_INPUT], [${qt_lib_prefix}InputSupport], [QT_LIBS=\"$QT_INPUT_LIBS $QT_LIBS\"])\n     PKG_CHECK_MODULES([QT_SERVICE], [${qt_lib_prefix}ServiceSupport], [QT_LIBS=\"$QT_SERVICE_LIBS $QT_LIBS\"])\n     PKG_CHECK_MODULES([QT_XCBQPA], [${qt_lib_prefix}XcbQpa], [QT_LIBS=\"$QT_XCBQPA_LIBS $QT_LIBS\"])\n   elif test \"x$TARGET_OS\" = xdarwin; then"
      },
      {
        "sha": "c3705f6b03757da40f299c278d614807b34602a3",
        "filename": "build_msvc/README.md",
        "status": "modified",
        "additions": 1,
        "deletions": 12,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/README.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -39,7 +39,7 @@ In order to build Bitcoin Core a static build of Qt is required. The runtime lib\n \n Some prebuilt x64 versions of Qt can be downloaded from [here](https://github.com/sipsorcery/qt_win_binary/releases). Please be aware these downloads are NOT officially sanctioned by Bitcoin Core and are provided for developer convenience only. They should NOT be used for builds that will be used in a production environment or with real funds.\n \n-To determine which Qt prebuilt version to download open the `.appveyor.yml` file and note the `QT_DOWNLOAD_URL`. When extracting the zip file the destination path must be set to `C:\\`. This is due to the way that Qt includes, libraries and tools use internal paths.\n+To determine which Qt prebuilt version to download open the `.cirrus.yml` file and note the `QT_DOWNLOAD_URL`. When extracting the zip file the destination path must be set to `C:\\`. This is due to the way that Qt includes, libraries and tools use internal paths.\n \n To build Bitcoin Core without Qt unload or disable the `bitcoin-qt`, `libbitcoin_qt` and `test_bitcoin-qt` projects.\n \n@@ -65,17 +65,6 @@ msbuild /m bitcoin.sln /p:Platform=x64 /p:Configuration=Release /t:build\n \n - Alternatively, open the `build_msvc/bitcoin.sln` file in Visual Studio 2019.\n \n-AppVeyor\n----------------------\n-The .appveyor.yml in the root directory is suitable to perform builds on [AppVeyor](https://www.appveyor.com/) Continuous Integration servers. The simplest way to perform an AppVeyor build is to fork Bitcoin Core and then configure a new AppVeyor Project pointing to the forked repository.\n-\n-For safety reasons the Bitcoin Core .appveyor.yml file has the artifact options disabled. The build will be performed but no executable files will be available. To enable artifacts on a forked repository uncomment the lines shown below:\n-\n-```\n-    #- 7z a bitcoin-%APPVEYOR_BUILD_VERSION%.zip %APPVEYOR_BUILD_FOLDER%\\build_msvc\\%platform%\\%configuration%\\*.exe\n-    #- path: bitcoin-%APPVEYOR_BUILD_VERSION%.zip\n-```\n-\n Security\n ---------------------\n [Base address randomization](https://docs.microsoft.com/en-us/cpp/build/reference/dynamicbase-use-address-space-layout-randomization?view=msvc-160) is used to make Bitcoin Core more secure. When building Bitcoin using the `build_msvc` process base address randomization can be disabled by editing `common.init.vcproj` to change `RandomizedBaseAddress` from `true` to `false` and then rebuilding the project."
      },
      {
        "sha": "724dae19698c525e39faec226ae4fa487e04077c",
        "filename": "build_msvc/bitcoin-qt/bitcoin-qt.vcxproj",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/bitcoin-qt/bitcoin-qt.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/bitcoin-qt/bitcoin-qt.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/bitcoin-qt/bitcoin-qt.vcxproj?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -9,6 +9,7 @@\n   </PropertyGroup>\n   <ItemGroup>\n     <ClCompile Include=\"..\\..\\src\\qt\\main.cpp\" />\n+    <ClCompile Include=\"..\\..\\src\\init\\bitcoind.cpp\" />\n     <ResourceCompile Include=\"..\\..\\src\\qt\\res\\bitcoin-qt-res.rc\" />\n   </ItemGroup>\n   <ItemGroup>"
      },
      {
        "sha": "8a0964824bcd8ebb4faffaf330768fc8892b6345",
        "filename": "build_msvc/bitcoin-util/bitcoin-util.vcxproj",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/bitcoin-util/bitcoin-util.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/bitcoin-util/bitcoin-util.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/bitcoin-util/bitcoin-util.vcxproj?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -2,7 +2,7 @@\n <Project DefaultTargets=\"Build\" xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n   <Import Project=\"..\\common.init.vcxproj\" />\n   <PropertyGroup Label=\"Globals\">\n-    <ProjectGuid>{D3022AF6-AD33-4CE3-B358-87CB6A1B29CF}</ProjectGuid>\n+    <ProjectGuid>{57A04EC9-542A-4E40-83D0-AC3BE1F36805}</ProjectGuid>\n   </PropertyGroup>\n   <PropertyGroup Label=\"Configuration\">\n     <ConfigurationType>Application</ConfigurationType>"
      },
      {
        "sha": "1b1f27a8a9ec64cc189817cd6e145cd546f8263d",
        "filename": "build_msvc/bitcoin.sln",
        "status": "modified",
        "additions": 5,
        "deletions": 95,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/bitcoin.sln",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/bitcoin.sln",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/bitcoin.sln?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -32,7 +32,7 @@ Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"bench_bitcoin\", \"bench_bitc\n EndProject\n Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"bitcoin-tx\", \"bitcoin-tx\\bitcoin-tx.vcxproj\", \"{D3022AF6-AD33-4CE3-B358-87CB6A1B29CF}\"\n EndProject\n-Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"bitcoin-util\", \"bitcoin-util\\bitcoin-util.vcxproj\", \"{D3022AF6-AD33-4CE3-B358-87CB6A1B29CF}\"\n+Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"bitcoin-util\", \"bitcoin-util\\bitcoin-util.vcxproj\", \"{57A04EC9-542A-4E40-83D0-AC3BE1F36805}\"\n EndProject\n Project(\"{8BC9CEB8-8B4A-11D0-8D11-00A0C91BC942}\") = \"bitcoin-wallet\", \"bitcoin-wallet\\bitcoin-wallet.vcxproj\", \"{84DE8790-EDE3-4483-81AC-C32F15E861F4}\"\n EndProject\n@@ -53,195 +53,105 @@ EndProject\n Global\n     GlobalSection(SolutionConfigurationPlatforms) = preSolution\n         Debug|x64 = Debug|x64\n-        Debug|x86 = Debug|x86\n         Release|x64 = Release|x64\n-        Release|x86 = Release|x86\n     EndGlobalSection\n     GlobalSection(ProjectConfigurationPlatforms) = postSolution\n         {2B384FA8-9EE1-4544-93CB-0D733C25E8CE}.Debug|x64.ActiveCfg = Debug|x64\n         {2B384FA8-9EE1-4544-93CB-0D733C25E8CE}.Debug|x64.Build.0 = Debug|x64\n-        {2B384FA8-9EE1-4544-93CB-0D733C25E8CE}.Debug|x86.ActiveCfg = Debug|Win32\n-        {2B384FA8-9EE1-4544-93CB-0D733C25E8CE}.Debug|x86.Build.0 = Debug|Win32\n         {2B384FA8-9EE1-4544-93CB-0D733C25E8CE}.Release|x64.ActiveCfg = Release|x64\n         {2B384FA8-9EE1-4544-93CB-0D733C25E8CE}.Release|x64.Build.0 = Release|x64\n-        {2B384FA8-9EE1-4544-93CB-0D733C25E8CE}.Release|x86.ActiveCfg = Release|Win32\n-        {2B384FA8-9EE1-4544-93CB-0D733C25E8CE}.Release|x86.Build.0 = Release|Win32\n         {E78473E9-B850-456C-9120-276301E04C06}.Debug|x64.ActiveCfg = Debug|x64\n         {E78473E9-B850-456C-9120-276301E04C06}.Debug|x64.Build.0 = Debug|x64\n-        {E78473E9-B850-456C-9120-276301E04C06}.Debug|x86.ActiveCfg = Debug|Win32\n-        {E78473E9-B850-456C-9120-276301E04C06}.Debug|x86.Build.0 = Debug|Win32\n         {E78473E9-B850-456C-9120-276301E04C06}.Release|x64.ActiveCfg = Release|x64\n         {E78473E9-B850-456C-9120-276301E04C06}.Release|x64.Build.0 = Release|x64\n-        {E78473E9-B850-456C-9120-276301E04C06}.Release|x86.ActiveCfg = Release|Win32\n-        {E78473E9-B850-456C-9120-276301E04C06}.Release|x86.Build.0 = Release|Win32\n         {D4513DDF-6013-44DC-ADCC-12EAF6D1F038}.Debug|x64.ActiveCfg = Debug|x64\n         {D4513DDF-6013-44DC-ADCC-12EAF6D1F038}.Debug|x64.Build.0 = Debug|x64\n-        {D4513DDF-6013-44DC-ADCC-12EAF6D1F038}.Debug|x86.ActiveCfg = Debug|Win32\n-        {D4513DDF-6013-44DC-ADCC-12EAF6D1F038}.Debug|x86.Build.0 = Debug|Win32\n         {D4513DDF-6013-44DC-ADCC-12EAF6D1F038}.Release|x64.ActiveCfg = Release|x64\n         {D4513DDF-6013-44DC-ADCC-12EAF6D1F038}.Release|x64.Build.0 = Release|x64\n-        {D4513DDF-6013-44DC-ADCC-12EAF6D1F038}.Release|x86.ActiveCfg = Release|Win32\n-        {D4513DDF-6013-44DC-ADCC-12EAF6D1F038}.Release|x86.Build.0 = Release|Win32\n         {B53A5535-EE9D-4C6F-9A26-F79EE3BC3754}.Debug|x64.ActiveCfg = Debug|x64\n         {B53A5535-EE9D-4C6F-9A26-F79EE3BC3754}.Debug|x64.Build.0 = Debug|x64\n-        {B53A5535-EE9D-4C6F-9A26-F79EE3BC3754}.Debug|x86.ActiveCfg = Debug|Win32\n-        {B53A5535-EE9D-4C6F-9A26-F79EE3BC3754}.Debug|x86.Build.0 = Debug|Win32\n         {B53A5535-EE9D-4C6F-9A26-F79EE3BC3754}.Release|x64.ActiveCfg = Release|x64\n         {B53A5535-EE9D-4C6F-9A26-F79EE3BC3754}.Release|x64.Build.0 = Release|x64\n-        {B53A5535-EE9D-4C6F-9A26-F79EE3BC3754}.Release|x86.ActiveCfg = Release|Win32\n-        {B53A5535-EE9D-4C6F-9A26-F79EE3BC3754}.Release|x86.Build.0 = Release|Win32\n         {7C87E378-DF58-482E-AA2F-1BC129BC19CE}.Debug|x64.ActiveCfg = Debug|x64\n         {7C87E378-DF58-482E-AA2F-1BC129BC19CE}.Debug|x64.Build.0 = Debug|x64\n-        {7C87E378-DF58-482E-AA2F-1BC129BC19CE}.Debug|x86.ActiveCfg = Debug|Win32\n-        {7C87E378-DF58-482E-AA2F-1BC129BC19CE}.Debug|x86.Build.0 = Debug|Win32\n         {7C87E378-DF58-482E-AA2F-1BC129BC19CE}.Release|x64.ActiveCfg = Release|x64\n         {7C87E378-DF58-482E-AA2F-1BC129BC19CE}.Release|x64.Build.0 = Release|x64\n-        {7C87E378-DF58-482E-AA2F-1BC129BC19CE}.Release|x86.ActiveCfg = Release|Win32\n-        {7C87E378-DF58-482E-AA2F-1BC129BC19CE}.Release|x86.Build.0 = Release|Win32\n         {6190199C-6CF4-4DAD-BFBD-93FA72A760C1}.Debug|x64.ActiveCfg = Debug|x64\n         {6190199C-6CF4-4DAD-BFBD-93FA72A760C1}.Debug|x64.Build.0 = Debug|x64\n-        {6190199C-6CF4-4DAD-BFBD-93FA72A760C1}.Debug|x86.ActiveCfg = Debug|Win32\n-        {6190199C-6CF4-4DAD-BFBD-93FA72A760C1}.Debug|x86.Build.0 = Debug|Win32\n         {6190199C-6CF4-4DAD-BFBD-93FA72A760C1}.Release|x64.ActiveCfg = Release|x64\n         {6190199C-6CF4-4DAD-BFBD-93FA72A760C1}.Release|x64.Build.0 = Release|x64\n-        {6190199C-6CF4-4DAD-BFBD-93FA72A760C1}.Release|x86.ActiveCfg = Release|Win32\n-        {6190199C-6CF4-4DAD-BFBD-93FA72A760C1}.Release|x86.Build.0 = Release|Win32\n         {460FEE33-1FE1-483F-B3BF-931FF8E969A5}.Debug|x64.ActiveCfg = Debug|x64\n         {460FEE33-1FE1-483F-B3BF-931FF8E969A5}.Debug|x64.Build.0 = Debug|x64\n-        {460FEE33-1FE1-483F-B3BF-931FF8E969A5}.Debug|x86.ActiveCfg = Debug|Win32\n-        {460FEE33-1FE1-483F-B3BF-931FF8E969A5}.Debug|x86.Build.0 = Debug|Win32\n         {460FEE33-1FE1-483F-B3BF-931FF8E969A5}.Release|x64.ActiveCfg = Release|x64\n         {460FEE33-1FE1-483F-B3BF-931FF8E969A5}.Release|x64.Build.0 = Release|x64\n-        {460FEE33-1FE1-483F-B3BF-931FF8E969A5}.Release|x86.ActiveCfg = Release|Win32\n-        {460FEE33-1FE1-483F-B3BF-931FF8E969A5}.Release|x86.Build.0 = Release|Win32\n         {5724BA7D-A09A-4BA8-800B-C4C1561B3D69}.Debug|x64.ActiveCfg = Debug|x64\n         {5724BA7D-A09A-4BA8-800B-C4C1561B3D69}.Debug|x64.Build.0 = Debug|x64\n-        {5724BA7D-A09A-4BA8-800B-C4C1561B3D69}.Debug|x86.ActiveCfg = Debug|Win32\n-        {5724BA7D-A09A-4BA8-800B-C4C1561B3D69}.Debug|x86.Build.0 = Debug|Win32\n         {5724BA7D-A09A-4BA8-800B-C4C1561B3D69}.Release|x64.ActiveCfg = Release|x64\n         {5724BA7D-A09A-4BA8-800B-C4C1561B3D69}.Release|x64.Build.0 = Release|x64\n-        {5724BA7D-A09A-4BA8-800B-C4C1561B3D69}.Release|x86.ActiveCfg = Release|Win32\n-        {5724BA7D-A09A-4BA8-800B-C4C1561B3D69}.Release|x86.Build.0 = Release|Win32\n         {93B86837-B543-48A5-A89B-7C87ABB77DF2}.Debug|x64.ActiveCfg = Debug|x64\n         {93B86837-B543-48A5-A89B-7C87ABB77DF2}.Debug|x64.Build.0 = Debug|x64\n-        {93B86837-B543-48A5-A89B-7C87ABB77DF2}.Debug|x86.ActiveCfg = Debug|Win32\n-        {93B86837-B543-48A5-A89B-7C87ABB77DF2}.Debug|x86.Build.0 = Debug|Win32\n         {93B86837-B543-48A5-A89B-7C87ABB77DF2}.Release|x64.ActiveCfg = Release|x64\n         {93B86837-B543-48A5-A89B-7C87ABB77DF2}.Release|x64.Build.0 = Release|x64\n-        {93B86837-B543-48A5-A89B-7C87ABB77DF2}.Release|x86.ActiveCfg = Release|Win32\n-        {93B86837-B543-48A5-A89B-7C87ABB77DF2}.Release|x86.Build.0 = Release|Win32\n         {792D487F-F14C-49FC-A9DE-3FC150F31C3F}.Debug|x64.ActiveCfg = Debug|x64\n         {792D487F-F14C-49FC-A9DE-3FC150F31C3F}.Debug|x64.Build.0 = Debug|x64\n-        {792D487F-F14C-49FC-A9DE-3FC150F31C3F}.Debug|x86.ActiveCfg = Debug|Win32\n-        {792D487F-F14C-49FC-A9DE-3FC150F31C3F}.Debug|x86.Build.0 = Debug|Win32\n         {792D487F-F14C-49FC-A9DE-3FC150F31C3F}.Release|x64.ActiveCfg = Release|x64\n         {792D487F-F14C-49FC-A9DE-3FC150F31C3F}.Release|x64.Build.0 = Release|x64\n-        {792D487F-F14C-49FC-A9DE-3FC150F31C3F}.Release|x86.ActiveCfg = Release|Win32\n-        {792D487F-F14C-49FC-A9DE-3FC150F31C3F}.Release|x86.Build.0 = Release|Win32\n         {A56B73DB-D46D-4882-8374-1FE3FFA08F07}.Debug|x64.ActiveCfg = Debug|x64\n         {A56B73DB-D46D-4882-8374-1FE3FFA08F07}.Debug|x64.Build.0 = Debug|x64\n-        {A56B73DB-D46D-4882-8374-1FE3FFA08F07}.Debug|x86.ActiveCfg = Debug|Win32\n-        {A56B73DB-D46D-4882-8374-1FE3FFA08F07}.Debug|x86.Build.0 = Debug|Win32\n         {A56B73DB-D46D-4882-8374-1FE3FFA08F07}.Release|x64.ActiveCfg = Release|x64\n         {A56B73DB-D46D-4882-8374-1FE3FFA08F07}.Release|x64.Build.0 = Release|x64\n-        {A56B73DB-D46D-4882-8374-1FE3FFA08F07}.Release|x86.ActiveCfg = Release|Win32\n-        {A56B73DB-D46D-4882-8374-1FE3FFA08F07}.Release|x86.Build.0 = Release|Win32\n         {0667528C-D734-4009-ADF9-C0D6C4A5A5A6}.Debug|x64.ActiveCfg = Debug|x64\n         {0667528C-D734-4009-ADF9-C0D6C4A5A5A6}.Debug|x64.Build.0 = Debug|x64\n-        {0667528C-D734-4009-ADF9-C0D6C4A5A5A6}.Debug|x86.ActiveCfg = Debug|Win32\n-        {0667528C-D734-4009-ADF9-C0D6C4A5A5A6}.Debug|x86.Build.0 = Debug|Win32\n         {0667528C-D734-4009-ADF9-C0D6C4A5A5A6}.Release|x64.ActiveCfg = Release|x64\n         {0667528C-D734-4009-ADF9-C0D6C4A5A5A6}.Release|x64.Build.0 = Release|x64\n-        {0667528C-D734-4009-ADF9-C0D6C4A5A5A6}.Release|x86.ActiveCfg = Release|Win32\n-        {0667528C-D734-4009-ADF9-C0D6C4A5A5A6}.Release|x86.Build.0 = Release|Win32\n         {0B2D7431-F876-4A58-87BF-F748338CD3BF}.Debug|x64.ActiveCfg = Debug|x64\n         {0B2D7431-F876-4A58-87BF-F748338CD3BF}.Debug|x64.Build.0 = Debug|x64\n-        {0B2D7431-F876-4A58-87BF-F748338CD3BF}.Debug|x86.ActiveCfg = Debug|Win32\n-        {0B2D7431-F876-4A58-87BF-F748338CD3BF}.Debug|x86.Build.0 = Debug|Win32\n         {0B2D7431-F876-4A58-87BF-F748338CD3BF}.Release|x64.ActiveCfg = Release|x64\n         {0B2D7431-F876-4A58-87BF-F748338CD3BF}.Release|x64.Build.0 = Release|x64\n-        {0B2D7431-F876-4A58-87BF-F748338CD3BF}.Release|x86.ActiveCfg = Release|Win32\n-        {0B2D7431-F876-4A58-87BF-F748338CD3BF}.Release|x86.Build.0 = Release|Win32\n         {1125654E-E1B2-4431-8B5C-62EA9A2FEECB}.Debug|x64.ActiveCfg = Debug|x64\n         {1125654E-E1B2-4431-8B5C-62EA9A2FEECB}.Debug|x64.Build.0 = Debug|x64\n-        {1125654E-E1B2-4431-8B5C-62EA9A2FEECB}.Debug|x86.ActiveCfg = Debug|Win32\n-        {1125654E-E1B2-4431-8B5C-62EA9A2FEECB}.Debug|x86.Build.0 = Debug|Win32\n         {1125654E-E1B2-4431-8B5C-62EA9A2FEECB}.Release|x64.ActiveCfg = Release|x64\n         {1125654E-E1B2-4431-8B5C-62EA9A2FEECB}.Release|x64.Build.0 = Release|x64\n-        {1125654E-E1B2-4431-8B5C-62EA9A2FEECB}.Release|x86.ActiveCfg = Release|Win32\n-        {1125654E-E1B2-4431-8B5C-62EA9A2FEECB}.Release|x86.Build.0 = Release|Win32\n         {D3022AF6-AD33-4CE3-B358-87CB6A1B29CF}.Debug|x64.ActiveCfg = Debug|x64\n         {D3022AF6-AD33-4CE3-B358-87CB6A1B29CF}.Debug|x64.Build.0 = Debug|x64\n-        {D3022AF6-AD33-4CE3-B358-87CB6A1B29CF}.Debug|x86.ActiveCfg = Debug|Win32\n-        {D3022AF6-AD33-4CE3-B358-87CB6A1B29CF}.Debug|x86.Build.0 = Debug|Win32\n         {D3022AF6-AD33-4CE3-B358-87CB6A1B29CF}.Release|x64.ActiveCfg = Release|x64\n         {D3022AF6-AD33-4CE3-B358-87CB6A1B29CF}.Release|x64.Build.0 = Release|x64\n-        {D3022AF6-AD33-4CE3-B358-87CB6A1B29CF}.Release|x86.ActiveCfg = Release|Win32\n-        {D3022AF6-AD33-4CE3-B358-87CB6A1B29CF}.Release|x86.Build.0 = Release|Win32\n+        {57A04EC9-542A-4E40-83D0-AC3BE1F36805}.Debug|x64.ActiveCfg = Debug|x64\n+        {57A04EC9-542A-4E40-83D0-AC3BE1F36805}.Debug|x64.Build.0 = Debug|x64\n+        {57A04EC9-542A-4E40-83D0-AC3BE1F36805}.Release|x64.ActiveCfg = Release|x64\n+        {57A04EC9-542A-4E40-83D0-AC3BE1F36805}.Release|x64.Build.0 = Release|x64\n         {84DE8790-EDE3-4483-81AC-C32F15E861F4}.Debug|x64.ActiveCfg = Debug|x64\n         {84DE8790-EDE3-4483-81AC-C32F15E861F4}.Debug|x64.Build.0 = Debug|x64\n-        {84DE8790-EDE3-4483-81AC-C32F15E861F4}.Debug|x86.ActiveCfg = Debug|Win32\n-        {84DE8790-EDE3-4483-81AC-C32F15E861F4}.Debug|x86.Build.0 = Debug|Win32\n         {84DE8790-EDE3-4483-81AC-C32F15E861F4}.Release|x64.ActiveCfg = Release|x64\n         {84DE8790-EDE3-4483-81AC-C32F15E861F4}.Release|x64.Build.0 = Release|x64\n-        {84DE8790-EDE3-4483-81AC-C32F15E861F4}.Release|x86.ActiveCfg = Release|Win32\n-        {84DE8790-EDE3-4483-81AC-C32F15E861F4}.Release|x86.Build.0 = Release|Win32\n         {F91AC55E-6F5E-4C58-9AC5-B40DB7DEEF93}.Debug|x64.ActiveCfg = Debug|x64\n         {F91AC55E-6F5E-4C58-9AC5-B40DB7DEEF93}.Debug|x64.Build.0 = Debug|x64\n-        {F91AC55E-6F5E-4C58-9AC5-B40DB7DEEF93}.Debug|x86.ActiveCfg = Debug|Win32\n-        {F91AC55E-6F5E-4C58-9AC5-B40DB7DEEF93}.Debug|x86.Build.0 = Debug|Win32\n         {F91AC55E-6F5E-4C58-9AC5-B40DB7DEEF93}.Release|x64.ActiveCfg = Release|x64\n         {F91AC55E-6F5E-4C58-9AC5-B40DB7DEEF93}.Release|x64.Build.0 = Release|x64\n-        {F91AC55E-6F5E-4C58-9AC5-B40DB7DEEF93}.Release|x86.ActiveCfg = Release|Win32\n-        {F91AC55E-6F5E-4C58-9AC5-B40DB7DEEF93}.Release|x86.Build.0 = Release|Win32\n         {BB493552-3B8C-4A8C-BF69-A6E7A51D2EA6}.Debug|x64.ActiveCfg = Debug|x64\n         {BB493552-3B8C-4A8C-BF69-A6E7A51D2EA6}.Debug|x64.Build.0 = Debug|x64\n-        {BB493552-3B8C-4A8C-BF69-A6E7A51D2EA6}.Debug|x86.ActiveCfg = Debug|Win32\n-        {BB493552-3B8C-4A8C-BF69-A6E7A51D2EA6}.Debug|x86.Build.0 = Debug|Win32\n         {BB493552-3B8C-4A8C-BF69-A6E7A51D2EA6}.Release|x64.ActiveCfg = Release|x64\n         {BB493552-3B8C-4A8C-BF69-A6E7A51D2EA6}.Release|x64.Build.0 = Release|x64\n-        {BB493552-3B8C-4A8C-BF69-A6E7A51D2EA6}.Release|x86.ActiveCfg = Release|Win32\n-        {BB493552-3B8C-4A8C-BF69-A6E7A51D2EA6}.Release|x86.Build.0 = Release|Win32\n         {18430FEF-6B61-4C53-B396-718E02850F1B}.Debug|x64.ActiveCfg = Debug|x64\n         {18430FEF-6B61-4C53-B396-718E02850F1B}.Debug|x64.Build.0 = Debug|x64\n-        {18430FEF-6B61-4C53-B396-718E02850F1B}.Debug|x86.ActiveCfg = Debug|Win32\n-        {18430FEF-6B61-4C53-B396-718E02850F1B}.Debug|x86.Build.0 = Debug|Win32\n         {18430FEF-6B61-4C53-B396-718E02850F1B}.Release|x64.ActiveCfg = Release|x64\n         {18430FEF-6B61-4C53-B396-718E02850F1B}.Release|x64.Build.0 = Release|x64\n-        {18430FEF-6B61-4C53-B396-718E02850F1B}.Release|x86.ActiveCfg = Release|Win32\n-        {18430FEF-6B61-4C53-B396-718E02850F1B}.Release|x86.Build.0 = Release|Win32\n         {2B4ABFF8-D1FD-4845-88C9-1F3C0A6512BF}.Debug|x64.ActiveCfg = Debug|x64\n         {2B4ABFF8-D1FD-4845-88C9-1F3C0A6512BF}.Debug|x64.Build.0 = Debug|x64\n-        {2B4ABFF8-D1FD-4845-88C9-1F3C0A6512BF}.Debug|x86.ActiveCfg = Debug|Win32\n-        {2B4ABFF8-D1FD-4845-88C9-1F3C0A6512BF}.Debug|x86.Build.0 = Debug|Win32\n         {2B4ABFF8-D1FD-4845-88C9-1F3C0A6512BF}.Release|x64.ActiveCfg = Release|x64\n         {2B4ABFF8-D1FD-4845-88C9-1F3C0A6512BF}.Release|x64.Build.0 = Release|x64\n-        {2B4ABFF8-D1FD-4845-88C9-1F3C0A6512BF}.Release|x86.ActiveCfg = Release|Win32\n-        {2B4ABFF8-D1FD-4845-88C9-1F3C0A6512BF}.Release|x86.Build.0 = Release|Win32\n         {7E99172D-7FF2-4CB6-B736-AC9B76ED412A}.Debug|x64.ActiveCfg = Debug|x64\n         {7E99172D-7FF2-4CB6-B736-AC9B76ED412A}.Debug|x64.Build.0 = Debug|x64\n-        {7E99172D-7FF2-4CB6-B736-AC9B76ED412A}.Debug|x86.ActiveCfg = Debug|Win32\n-        {7E99172D-7FF2-4CB6-B736-AC9B76ED412A}.Debug|x86.Build.0 = Debug|Win32\n         {7E99172D-7FF2-4CB6-B736-AC9B76ED412A}.Release|x64.ActiveCfg = Release|x64\n         {7E99172D-7FF2-4CB6-B736-AC9B76ED412A}.Release|x64.Build.0 = Release|x64\n-        {7E99172D-7FF2-4CB6-B736-AC9B76ED412A}.Release|x86.ActiveCfg = Release|Win32\n-        {7E99172D-7FF2-4CB6-B736-AC9B76ED412A}.Release|x86.Build.0 = Release|Win32\n         {868474FD-35F6-4400-8EED-30A33E7521D4}.Debug|x64.ActiveCfg = Debug|x64\n         {868474FD-35F6-4400-8EED-30A33E7521D4}.Debug|x64.Build.0 = Debug|x64\n-        {868474FD-35F6-4400-8EED-30A33E7521D4}.Debug|x86.ActiveCfg = Debug|Win32\n-        {868474FD-35F6-4400-8EED-30A33E7521D4}.Debug|x86.Build.0 = Debug|Win32\n         {868474FD-35F6-4400-8EED-30A33E7521D4}.Release|x64.ActiveCfg = Release|x64\n         {868474FD-35F6-4400-8EED-30A33E7521D4}.Release|x64.Build.0 = Release|x64\n-        {868474FD-35F6-4400-8EED-30A33E7521D4}.Release|x86.ActiveCfg = Release|Win32\n-        {868474FD-35F6-4400-8EED-30A33E7521D4}.Release|x86.Build.0 = Release|Win32\n         {51201D5E-D939-4854-AE9D-008F03FF518E}.Debug|x64.ActiveCfg = Debug|x64\n         {51201D5E-D939-4854-AE9D-008F03FF518E}.Debug|x64.Build.0 = Debug|x64\n-        {51201D5E-D939-4854-AE9D-008F03FF518E}.Debug|x86.ActiveCfg = Debug|Win32\n-        {51201D5E-D939-4854-AE9D-008F03FF518E}.Debug|x86.Build.0 = Debug|Win32\n         {51201D5E-D939-4854-AE9D-008F03FF518E}.Release|x64.ActiveCfg = Release|x64\n         {51201D5E-D939-4854-AE9D-008F03FF518E}.Release|x64.Build.0 = Release|x64\n-        {51201D5E-D939-4854-AE9D-008F03FF518E}.Release|x86.ActiveCfg = Release|Win32\n-        {51201D5E-D939-4854-AE9D-008F03FF518E}.Release|x86.Build.0 = Release|Win32\n     EndGlobalSection\n     GlobalSection(SolutionProperties) = preSolution\n         HideSolutionNode = FALSE"
      },
      {
        "sha": "e2930f3ea916d3336fc70f9934d22eacb8fb5d4a",
        "filename": "build_msvc/bitcoin_config.h",
        "status": "modified",
        "additions": 4,
        "deletions": 129,
        "changes": 133,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/bitcoin_config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/bitcoin_config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/bitcoin_config.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -5,9 +5,6 @@\n #ifndef BITCOIN_BITCOIN_CONFIG_H\n #define BITCOIN_BITCOIN_CONFIG_H\n \n-/* Define if building universal (internal helper macro) */\n-/* #undef AC_APPLE_UNIVERSAL_BUILD */\n-\n /* Version Build */\n #define CLIENT_VERSION_BUILD 0\n \n@@ -59,14 +56,11 @@\n /* define if the Boost::Unit_Test_Framework library is available */\n #define HAVE_BOOST_UNIT_TEST_FRAMEWORK /**/\n \n-/* Define to 1 if you have the <byteswap.h> header file. */\n-/* #undef HAVE_BYTESWAP_H */\n-\n /* Define this symbol if the consensus lib has been built */\n #define HAVE_CONSENSUS_LIB 1\n \n-/* define if the compiler supports basic C++11 syntax */\n-#define HAVE_CXX11 1\n+/* define if the compiler supports basic C++17 syntax */\n+#define HAVE_CXX17 1\n \n /* Define to 1 if you have the declaration of `be16toh', and to 0 if you\n    don't. */\n@@ -144,37 +138,12 @@\n    don't. */\n #define HAVE_DECL_STRNLEN 1\n \n-/* Define to 1 if you have the <dlfcn.h> header file. */\n-/* #undef HAVE_DLFCN_H */\n-\n-/* Define to 1 if you have the <endian.h> header file. */\n-/* #undef HAVE_ENDIAN_H */\n-\n-/* Define to 1 if the system has the `dllexport' function attribute */\n-#define HAVE_FUNC_ATTRIBUTE_DLLEXPORT 1\n-\n-/* Define to 1 if the system has the `dllimport' function attribute */\n-#define HAVE_FUNC_ATTRIBUTE_DLLIMPORT 1\n-\n-/* Define to 1 if the system has the `visibility' function attribute */\n-#define HAVE_FUNC_ATTRIBUTE_VISIBILITY 1\n-\n-/* Define this symbol if the BSD getentropy system call is available */\n-/* #undef HAVE_GETENTROPY */\n-\n-/* Define this symbol if the BSD getentropy system call is available with\n-   sys/random.h */\n-/* #undef HAVE_GETENTROPY_RAND */\n+/* Define if the dllexport attribute is supported. */\n+#define HAVE_DLLEXPORT_ATTRIBUTE 1\n \n /* Define to 1 if you have the <inttypes.h> header file. */\n #define HAVE_INTTYPES_H 1\n \n-/* Define this symbol if you have malloc_info */\n-/* #undef HAVE_MALLOC_INFO */\n-\n-/* Define this symbol if you have mallopt with M_ARENA_MAX */\n-/* #undef HAVE_MALLOPT_ARENA_MAX */\n-\n /* Define to 1 if you have the <memory.h> header file. */\n #define HAVE_MEMORY_H 1\n \n@@ -187,18 +156,6 @@\n /* Define to 1 if you have the <miniupnpc/upnperrors.h> header file. */\n #define HAVE_MINIUPNPC_UPNPERRORS_H 1\n \n-/* Define this symbol if you have MSG_DONTWAIT */\n-/* #undef HAVE_MSG_DONTWAIT */\n-\n-/* Define this symbol if you have MSG_NOSIGNAL */\n-/* #undef HAVE_MSG_NOSIGNAL */\n-\n-/* Define if you have POSIX threads libraries and header files. */\n-//#define HAVE_PTHREAD 1\n-\n-/* Have PTHREAD_PRIO_INHERIT. */\n-//#define HAVE_PTHREAD_PRIO_INHERIT 1\n-\n /* Define to 1 if you have the <stdint.h> header file. */\n #define HAVE_STDINT_H 1\n \n@@ -208,45 +165,18 @@\n /* Define to 1 if you have the <stdlib.h> header file. */\n #define HAVE_STDLIB_H 1\n \n-/* Define to 1 if you have the `strerror_r' function. */\n-/* #undef HAVE_STRERROR_R */\n-\n /* Define to 1 if you have the <strings.h> header file. */\n #define HAVE_STRINGS_H 1\n \n /* Define to 1 if you have the <string.h> header file. */\n #define HAVE_STRING_H 1\n \n-/* Define this symbol if the BSD sysctl(KERN_ARND) is available */\n-/* #undef HAVE_SYSCTL_ARND */\n-\n-/* Define to 1 if you have the <sys/endian.h> header file. */\n-/* #undef HAVE_SYS_ENDIAN_H */\n-\n-/* Define this symbol if the Linux getrandom system call is available */\n-/* #undef HAVE_SYS_GETRANDOM */\n-\n-/* Define to 1 if you have the <sys/prctl.h> header file. */\n-/* #undef HAVE_SYS_PRCTL_H */\n-\n-/* Define to 1 if you have the <sys/select.h> header file. */\n-/* #undef HAVE_SYS_SELECT_H */\n-\n /* Define to 1 if you have the <sys/stat.h> header file. */\n #define HAVE_SYS_STAT_H 1\n \n /* Define to 1 if you have the <sys/types.h> header file. */\n #define HAVE_SYS_TYPES_H 1\n \n-/* Define to 1 if you have the <unistd.h> header file. */\n-//#define HAVE_UNISTD_H 1\n-\n-/* Define if the visibility attribute is supported. */\n-#define HAVE_VISIBILITY_ATTRIBUTE 1\n-\n-/* Define to the sub-directory where libtool stores uninstalled libraries. */\n-#define LT_OBJDIR \".libs/\"\n-\n /* Define to the address where bug reports for this package should be sent. */\n #define PACKAGE_BUGREPORT \"https://github.com/bitcoin/bitcoin/issues\"\n \n@@ -256,76 +186,21 @@\n /* Define to the full name and version of this package. */\n #define PACKAGE_STRING \"Bitcoin Core 22.99.0\"\n \n-/* Define to the one symbol short name of this package. */\n-#define PACKAGE_TARNAME \"bitcoin\"\n-\n /* Define to the home page for this package. */\n #define PACKAGE_URL \"https://bitcoincore.org/\"\n \n /* Define to the version of this package. */\n #define PACKAGE_VERSION \"22.99.0\"\n \n-/* Define to necessary symbol if this constant uses a non-standard name on\n-   your system. */\n-/* #undef PTHREAD_CREATE_JOINABLE */\n-\n-/* Define this symbol if the qt platform is cocoa */\n-/* #undef QT_QPA_PLATFORM_COCOA */\n-\n /* Define this symbol if the minimal qt platform exists */\n #define QT_QPA_PLATFORM_MINIMAL 1\n \n /* Define this symbol if the qt platform is windows */\n #define QT_QPA_PLATFORM_WINDOWS 1\n \n-/* Define this symbol if the qt platform is xcb */\n-/* #undef QT_QPA_PLATFORM_XCB */\n-\n /* Define this symbol if qt plugins are static */\n #define QT_STATICPLUGIN 1\n \n-/* Define to 1 if you have the ANSI C header files. */\n-#define STDC_HEADERS 1\n-\n-/* Define to 1 if strerror_r returns char *. */\n-/* #undef STRERROR_R_CHAR_P */\n-\n-/* Define this symbol to build in assembly routines */\n-//#define USE_ASM 1\n-\n-/* Define if dbus support should be compiled in */\n-/* #undef USE_DBUS */\n-\n-/* Define if QR support should be compiled in */\n-//#define USE_QRCODE 1\n-\n-/* UPnP support not compiled if undefined, otherwise value (0 or 1) determines\n-   default state */\n-//#define USE_UPNP 0\n-\n-/* Define WORDS_BIGENDIAN to 1 if your processor stores words with the most\n-   significant byte first (like Motorola and SPARC, unlike Intel). */\n-#if defined AC_APPLE_UNIVERSAL_BUILD\n-# if defined __BIG_ENDIAN__\n-#  define WORDS_BIGENDIAN 1\n-# endif\n-#else\n-# ifndef WORDS_BIGENDIAN\n-/* #  undef WORDS_BIGENDIAN */\n-# endif\n-#endif\n-\n-/* Enable large inode numbers on Mac OS X 10.5.  */\n-#ifndef _DARWIN_USE_64_BIT_INODE\n-# define _DARWIN_USE_64_BIT_INODE 1\n-#endif\n-\n-/* Number of bits in a file offset, on hosts where this is settable. */\n-#define _FILE_OFFSET_BITS 64\n-\n-/* Define for large files, on AIX-style hosts. */\n-/* #undef _LARGE_FILES */\n-\n /* Windows Universal Platform constraints */\n #if !defined(WINAPI_FAMILY) || (WINAPI_FAMILY == WINAPI_FAMILY_DESKTOP_APP)\n /* Either a desktop application without API restrictions, or and older system"
      },
      {
        "sha": "d56c359fe0c649d12bce86d87ee3c170f1f6c6d5",
        "filename": "build_msvc/bitcoind/bitcoind.vcxproj",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/bitcoind/bitcoind.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/bitcoind/bitcoind.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/bitcoind/bitcoind.vcxproj?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -57,6 +57,8 @@\n     <Copy SourceFiles=\"$(ConfigIniIn)\" DestinationFiles=\"$(ConfigIniOut)\" ></Copy>\n     <ReplaceInFile FilePath=\"$(ConfigIniOut)\"\n                    Replace=\"@PACKAGE_NAME@\" By=\"Bitcoin Core\"></ReplaceInFile>\n+    <ReplaceInFile FilePath=\"$(ConfigIniOut)\"\n+                   Replace=\"@PACKAGE_BUGREPORT@\" By=\"https://github.com/bitcoin/bitcoin/issues\"></ReplaceInFile>\n     <ReplaceInFile FilePath=\"$(ConfigIniOut)\"\n                    Replace=\"@abs_top_srcdir@\" By=\"..\\..\" ToFullPath=\"true\"></ReplaceInFile>\n     <ReplaceInFile FilePath=\"$(ConfigIniOut)\"\n@@ -71,12 +73,16 @@\n                   Replace=\"@USE_SQLITE_TRUE@\" By=\"\"></ReplaceInFile>\n     <ReplaceInFile FilePath=\"$(ConfigIniOut)\"\n                   Replace=\"@BUILD_BITCOIN_CLI_TRUE@\" By=\"\"></ReplaceInFile>\n+    <ReplaceInFile FilePath=\"$(ConfigIniOut)\"\n+                  Replace=\"@BUILD_BITCOIN_WALLET_TRUE@\" By=\"\"></ReplaceInFile>\n     <ReplaceInFile FilePath=\"$(ConfigIniOut)\"\n                   Replace=\"@BUILD_BITCOIND_TRUE@\" By=\"\"></ReplaceInFile>\n     <ReplaceInFile FilePath=\"$(ConfigIniOut)\"\n                   Replace=\"@ENABLE_FUZZ_TRUE@\" By=\"\"></ReplaceInFile>\n     <ReplaceInFile FilePath=\"$(ConfigIniOut)\"\n                   Replace=\"@ENABLE_ZMQ_TRUE@\" By=\"\"></ReplaceInFile>\n+    <ReplaceInFile FilePath=\"$(ConfigIniOut)\"\n+                  Replace=\"@ENABLE_EXTERNAL_SIGNER_TRUE@\" By=\"\"></ReplaceInFile>\n   </Target>\n   <Import Project=\"..\\common.vcxproj\" />\n </Project>"
      },
      {
        "sha": "fb4d70cc7802f8b2c75624f4792dd790ba652041",
        "filename": "build_msvc/common.init.vcxproj",
        "status": "modified",
        "additions": 0,
        "deletions": 9,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/common.init.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/common.init.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/common.init.vcxproj?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -14,7 +14,6 @@\n     <VcpkgUseStatic>true</VcpkgUseStatic>\n     <VcpkgAutoLink>true</VcpkgAutoLink>\n     <VcpkgConfiguration>$(Configuration)</VcpkgConfiguration>\n-    <VcpkgTriplet Condition=\"'$(Platform)'=='Win32'\">x86-windows-static</VcpkgTriplet>\n     <VcpkgTriplet Condition=\"'$(Platform)'=='x64'\">x64-windows-static</VcpkgTriplet>\n   </PropertyGroup>\n \n@@ -35,14 +34,6 @@\n       <Configuration>Debug</Configuration>\n       <Platform>x64</Platform>\n     </ProjectConfiguration>\n-    <ProjectConfiguration Include=\"Release|Win32\">\n-      <Configuration>Release</Configuration>\n-      <Platform>Win32</Platform>\n-    </ProjectConfiguration>\n-    <ProjectConfiguration Include=\"Debug|Win32\">\n-      <Configuration>Debug</Configuration>\n-      <Platform>Win32</Platform>\n-    </ProjectConfiguration>\n   </ItemGroup>\n \n   <PropertyGroup Condition=\"'$(Configuration)'=='Release'\" Label=\"Configuration\">"
      },
      {
        "sha": "df2fd2fb49e3ec4c4fb0ef7ac3526551120ab1b0",
        "filename": "build_msvc/common.qt.init.vcxproj",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/common.qt.init.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/common.qt.init.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/common.qt.init.vcxproj?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -2,7 +2,7 @@\n <Project xmlns=\"http://schemas.microsoft.com/developer/msbuild/2003\">\n \n   <PropertyGroup Label=\"QtGlobals\">\n-    <QtBaseDir>C:\\Qt5.12.11_x64_static_vs2019_16101</QtBaseDir>\n+    <QtBaseDir>C:\\Qt5.12.11_x64_static_vs2019_160900</QtBaseDir>\n     <QtPluginsLibraryDir>$(QtBaseDir)\\plugins</QtPluginsLibraryDir>\n     <QtLibraryDir>$(QtBaseDir)\\lib</QtLibraryDir>\n     <QtIncludeDir>$(QtBaseDir)\\include</QtIncludeDir>"
      },
      {
        "sha": "a64ae881f25663357e42cb71f0df18066f4e78f6",
        "filename": "build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj",
        "status": "modified",
        "additions": 0,
        "deletions": 14,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/libbitcoin_qt/libbitcoin_qt.vcxproj?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -140,20 +140,6 @@\n     </ClCompile>\n   </ItemDefinitionGroup>\n \n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Release|Win32'\">\n-    <ClCompile>\n-      <PreprocessorDefinitions>_X86_;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-      <AdditionalIncludeDirectories>$(QtIncludes);$(GeneratedFilesOutDir)\\..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n-    </ClCompile>\n-  </ItemDefinitionGroup>\n-\n-  <ItemDefinitionGroup Condition=\"'$(Configuration)|$(Platform)'=='Debug|Win32'\">\n-    <ClCompile>\n-      <PreprocessorDefinitions>_X86_;%(PreprocessorDefinitions)</PreprocessorDefinitions>\n-      <AdditionalIncludeDirectories>$(QtIncludes);$(GeneratedFilesOutDir)\\..;%(AdditionalIncludeDirectories)</AdditionalIncludeDirectories>\n-    </ClCompile>\n-  </ItemDefinitionGroup>\n-\n   <ItemGroup>\n     <QT_MOC Include=\"..\\..\\src\\qt\\bitcoinamountfield.cpp\" />\n     <QT_MOC Include=\"..\\..\\src\\qt\\intro.cpp\" />"
      },
      {
        "sha": "a1ed935996c296ed948089948da2bd254a9dd8b2",
        "filename": "build_msvc/msvc-autogen.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/msvc-autogen.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/msvc-autogen.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/msvc-autogen.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -9,7 +9,7 @@\n from shutil import copyfile\n \n SOURCE_DIR = os.path.abspath(os.path.join(os.path.dirname(__file__), '..', 'src'))\n-DEFAULT_PLATFORM_TOOLSET = R'v141'\n+DEFAULT_PLATFORM_TOOLSET = R'v142'\n \n libs = [\n     'libbitcoin_cli',"
      },
      {
        "sha": "08b12bdd852c90b2f00d9bcda148c91d9bd9dbe2",
        "filename": "build_msvc/test_bitcoin-qt/test_bitcoin-qt.vcxproj",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/test_bitcoin-qt/test_bitcoin-qt.vcxproj",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/build_msvc/test_bitcoin-qt/test_bitcoin-qt.vcxproj",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/build_msvc/test_bitcoin-qt/test_bitcoin-qt.vcxproj?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -8,6 +8,7 @@\n     <OutDir>$(SolutionDir)$(Platform)\\$(Configuration)\\</OutDir>\n   </PropertyGroup>\n   <ItemGroup>\n+    <ClCompile Include=\"..\\..\\src\\init\\bitcoind.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\test\\util\\setup_common.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\test\\addressbooktests.cpp\" />\n     <ClCompile Include=\"..\\..\\src\\qt\\test\\apptests.cpp\" />"
      },
      {
        "sha": "5587618f2dfdc36d5d749cb9283e39e271b16326",
        "filename": "ci/lint/04_install.sh",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/ci/lint/04_install.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/ci/lint/04_install.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/lint/04_install.sh?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -13,7 +13,6 @@ update-alternatives --install /usr/bin/clang-format-diff clang-format-diff $(whi\n \n ${CI_RETRY_EXE} pip3 install codespell==2.0.0\n ${CI_RETRY_EXE} pip3 install flake8==3.8.3\n-${CI_RETRY_EXE} pip3 install yq\n ${CI_RETRY_EXE} pip3 install mypy==0.781\n ${CI_RETRY_EXE} pip3 install vulture==2.3\n "
      },
      {
        "sha": "f7dacd8512f8e1668b012428a48ddee916602254",
        "filename": "ci/lint/06_script.sh",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/ci/lint/06_script.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/ci/lint/06_script.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/lint/06_script.sh?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -23,10 +23,15 @@ test/lint/git-subtree-check.sh src/crc32c\n test/lint/check-doc.py\n test/lint/lint-all.sh\n \n-if [ \"$CIRRUS_REPO_FULL_NAME\" = \"bitcoin/bitcoin\" ] && [ -n \"$CIRRUS_CRON\" ]; then\n-    git log --merges --before=\"2 days ago\" -1 --format='%H' > ./contrib/verify-commits/trusted-sha512-root-commit\n+if [ \"$CIRRUS_REPO_FULL_NAME\" = \"bitcoin/bitcoin\" ] && [ \"$CIRRUS_PR\" = \"\" ] ; then\n+    # Sanity check only the last few commits to get notified of missing sigs,\n+    # missing keys, or expired keys. Usually there is only one new merge commit\n+    # per push on the master branch and a few commits on release branches, so\n+    # sanity checking only a few (10) commits seems sufficient and cheap.\n+    git log HEAD~10 -1 --format='%H' > ./contrib/verify-commits/trusted-sha512-root-commit\n+    git log HEAD~10 -1 --format='%H' > ./contrib/verify-commits/trusted-git-root\n     ${CI_RETRY_EXE}  gpg --keyserver hkps://keys.openpgp.org --recv-keys $(<contrib/verify-commits/trusted-keys) &&\n-    ./contrib/verify-commits/verify-commits.py --clean-merge=2;\n+    ./contrib/verify-commits/verify-commits.py;\n fi\n \n echo"
      },
      {
        "sha": "f18052fe37c233a9ab8a354e614dd7f5bdbbcad0",
        "filename": "ci/test/00_setup_env_arm.sh",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/ci/test/00_setup_env_arm.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/ci/test/00_setup_env_arm.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_arm.sh?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -18,11 +18,11 @@ if [ -n \"$QEMU_USER_CMD\" ]; then\n fi\n export CONTAINER_NAME=ci_arm_linux\n # Use debian to avoid 404 apt errors when cross compiling\n-export DOCKER_NAME_TAG=\"debian:buster\"\n+export DOCKER_NAME_TAG=\"debian:bullseye\"\n export USE_BUSY_BOX=true\n export RUN_UNIT_TESTS=true\n export RUN_FUNCTIONAL_TESTS=false\n export GOAL=\"install\"\n # -Wno-psabi is to disable ABI warnings: \"note: parameter passing for argument of type ... changed in GCC 7.1\"\n # This could be removed once the ABI change warning does not show up by default\n-export BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports CXXFLAGS=-Wno-psabi\"\n+export BITCOIN_CONFIG=\"--enable-reduce-exports CXXFLAGS=-Wno-psabi\""
      },
      {
        "sha": "f7f65f6e3a71ead83a6be3175b3700e64b9f9988",
        "filename": "ci/test/00_setup_env_i686_multiprocess.sh",
        "status": "renamed",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/ci/test/00_setup_env_i686_multiprocess.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/ci/test/00_setup_env_i686_multiprocess.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_i686_multiprocess.sh?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -6,11 +6,12 @@\n \n export LC_ALL=C.UTF-8\n \n-export CONTAINER_NAME=ci_native_multiprocess\n+export HOST=i686-pc-linux-gnu\n+export CONTAINER_NAME=ci_i686_multiprocess\n export DOCKER_NAME_TAG=ubuntu:20.04\n-export PACKAGES=\"cmake python3 python3-pip llvm clang\"\n+export PACKAGES=\"cmake python3 python3-pip llvm clang g++-multilib\"\n export DEP_OPTS=\"DEBUG=1 MULTIPROCESS=1\"\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--enable-debug CC=clang CXX=clang++\"  # Use clang to avoid OOM\n+export BITCOIN_CONFIG=\"--enable-debug CC='clang -m32' CXX='clang++ -m32' LDFLAGS='--rtlib=compiler-rt -lgcc_s'\"\n export TEST_RUNNER_ENV=\"BITCOIND=bitcoin-node\"\n export PIP_PACKAGES=\"lief\"",
        "previous_filename": "ci/test/00_setup_env_native_multiprocess.sh"
      },
      {
        "sha": "310e96497389622210f65a79bdb7691b780a6def",
        "filename": "ci/test/00_setup_env_mac.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/ci/test/00_setup_env_mac.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/ci/test/00_setup_env_mac.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_mac.sh?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -7,7 +7,7 @@\n export LC_ALL=C.UTF-8\n \n export CONTAINER_NAME=ci_macos_cross\n-export DOCKER_NAME_TAG=ubuntu:20.04  # Check that Focal can cross-compile to macos (Focal is used in the gitian build as well)\n+export DOCKER_NAME_TAG=ubuntu:20.04  # Check that Focal can cross-compile to macos\n export HOST=x86_64-apple-darwin18\n export PACKAGES=\"cmake imagemagick librsvg2-bin libz-dev libtiff-tools libtinfo5 python3-setuptools xorriso\"\n export XCODE_VERSION=12.1"
      },
      {
        "sha": "b8ac6913468b65b7d30e521c27db31e8df32d5fc",
        "filename": "ci/test/00_setup_env_native_fuzz.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/ci/test/00_setup_env_native_fuzz.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/ci/test/00_setup_env_native_fuzz.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_native_fuzz.sh?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -14,5 +14,5 @@ export RUN_UNIT_TESTS=false\n export RUN_FUNCTIONAL_TESTS=false\n export RUN_FUZZ_TESTS=true\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--enable-fuzz --with-sanitizers=fuzzer,address,undefined,integer CC=clang CXX=clang++\"\n+export BITCOIN_CONFIG=\"--enable-fuzz --with-sanitizers=fuzzer,address,undefined,integer CC='clang -ftrivial-auto-var-init=pattern' CXX='clang++ -ftrivial-auto-var-init=pattern'\"\n export CCACHE_SIZE=200M"
      },
      {
        "sha": "5edc6ae2dadc0bd9e6846ff2214bd1de195ba5c0",
        "filename": "ci/test/00_setup_env_native_nowallet.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/ci/test/00_setup_env_native_nowallet.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/ci/test/00_setup_env_native_nowallet.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_native_nowallet.sh?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -11,4 +11,4 @@ export DOCKER_NAME_TAG=ubuntu:18.04  # Use bionic to have one config run the tes\n export PACKAGES=\"python3-zmq clang-5.0 llvm-5.0\"  # Use clang-5 to test C++17 compatibility, see doc/dependencies.md\n export DEP_OPTS=\"NO_WALLET=1\"\n export GOAL=\"install\"\n-export BITCOIN_CONFIG=\"--enable-glibc-back-compat --enable-reduce-exports CC=clang-5.0 CXX=clang++-5.0\"\n+export BITCOIN_CONFIG=\"--enable-reduce-exports CC=clang-5.0 CXX=clang++-5.0\""
      },
      {
        "sha": "7d73f2d0b250e59e3978185427c88c2b82339f4a",
        "filename": "ci/test/00_setup_env_native_qt5.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/ci/test/00_setup_env_native_qt5.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/ci/test/00_setup_env_native_qt5.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_native_qt5.sh?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -15,5 +15,5 @@ export RUN_UNIT_TESTS_SEQUENTIAL=\"true\"\n export RUN_UNIT_TESTS=\"false\"\n export GOAL=\"install\"\n export PREVIOUS_RELEASES_TO_DOWNLOAD=\"v0.15.2 v0.16.3 v0.17.2 v0.18.1 v0.19.1 v0.20.1\"\n-export BITCOIN_CONFIG=\"--enable-zmq --with-libs=no --with-gui=qt5 --enable-glibc-back-compat --enable-reduce-exports\n+export BITCOIN_CONFIG=\"--enable-zmq --with-libs=no --with-gui=qt5 --enable-reduce-exports\n --enable-debug --disable-fuzz-binary  CFLAGS=\\\"-g0 -O2 -funsigned-char\\\" CXXFLAGS=\\\"-g0 -O2 -funsigned-char\\\"\""
      },
      {
        "sha": "4dff335e4e51e75a6ec68fceb19790e3677db23d",
        "filename": "ci/test/00_setup_env_win64.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/ci/test/00_setup_env_win64.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/ci/test/00_setup_env_win64.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_win64.sh?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -7,14 +7,10 @@\n export LC_ALL=C.UTF-8\n \n export CONTAINER_NAME=ci_win64\n-export DOCKER_NAME_TAG=ubuntu:20.04  # Check that Focal can cross-compile to win64 (Focal is used in the gitian build as well)\n+export DOCKER_NAME_TAG=ubuntu:20.04  # Check that Focal can cross-compile to win64\n export HOST=x86_64-w64-mingw32\n export DPKG_ADD_ARCH=\"i386\"\n export PACKAGES=\"python3 nsis g++-mingw-w64-x86-64 wine-binfmt wine64 wine32 file\"\n export RUN_FUNCTIONAL_TESTS=false\n export GOAL=\"deploy\"\n export BITCOIN_CONFIG=\"--enable-reduce-exports --disable-gui-tests --disable-external-signer\"\n-\n-# Compiler for MinGW-w64 causes false -Wreturn-type warning.\n-# See https://sourceforge.net/p/mingw-w64/bugs/306/\n-export NO_WERROR=1"
      },
      {
        "sha": "0dc480e6c1cce2f3f5fd0ec0cc6a229126d89c13",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 44,
        "deletions": 26,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -240,15 +240,9 @@ AC_ARG_ENABLE([lcov-branch-coverage],\n   [use_lcov_branch=yes],\n   [use_lcov_branch=no])\n \n-AC_ARG_ENABLE([glibc-back-compat],\n-  [AS_HELP_STRING([--enable-glibc-back-compat],\n-  [enable backwards compatibility with glibc])],\n-  [use_glibc_compat=$enableval],\n-  [use_glibc_compat=no])\n-\n AC_ARG_ENABLE([threadlocal],\n   [AS_HELP_STRING([--enable-threadlocal],\n-  [enable features that depend on the c++ thread_local keyword (currently just thread names in debug logs). (default is to enabled if there is platform support and glibc-back-compat is not enabled)])],\n+  [enable features that depend on the c++ thread_local keyword (currently just thread names in debug logs). (default is to enable if there is platform support)])],\n   [use_thread_local=$enableval],\n   [use_thread_local=auto])\n \n@@ -417,7 +411,13 @@ if test \"x$enable_werror\" = \"xyes\"; then\n   AX_CHECK_COMPILE_FLAG([-Werror=range-loop-analysis],[ERROR_CXXFLAGS=\"$ERROR_CXXFLAGS -Werror=range-loop-analysis\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Werror=unused-variable],[ERROR_CXXFLAGS=\"$ERROR_CXXFLAGS -Werror=unused-variable\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Werror=date-time],[ERROR_CXXFLAGS=\"$ERROR_CXXFLAGS -Werror=date-time\"],,[[$CXXFLAG_WERROR]])\n-  AX_CHECK_COMPILE_FLAG([-Werror=return-type],[ERROR_CXXFLAGS=\"$ERROR_CXXFLAGS -Werror=return-type\"],,[[$CXXFLAG_WERROR]])\n+\n+  dnl -Wreturn-type is broken in GCC for MinGW-w64.\n+  dnl https://sourceforge.net/p/mingw-w64/bugs/306/\n+  AX_CHECK_COMPILE_FLAG([-Werror=return-type], [ERROR_CXXFLAGS=\"$ERROR_CXXFLAGS -Werror=return-type\"], [], [$CXXFLAG_WERROR],\n+                        [AC_LANG_SOURCE([[#include <cassert>\n+                                          int f(){ assert(false); }]])])\n+\n   AX_CHECK_COMPILE_FLAG([-Werror=conditional-uninitialized],[ERROR_CXXFLAGS=\"$ERROR_CXXFLAGS -Werror=conditional-uninitialized\"],,[[$CXXFLAG_WERROR]])\n   AX_CHECK_COMPILE_FLAG([-Werror=sign-compare],[ERROR_CXXFLAGS=\"$ERROR_CXXFLAGS -Werror=sign-compare\"],,[[$CXXFLAG_WERROR]])\n   dnl -Wsuggest-override is broken with GCC before 9.2\n@@ -699,6 +699,33 @@ case $host in\n          if $BREW list --versions qt5 >/dev/null; then\n            export PKG_CONFIG_PATH=\"$($BREW --prefix qt5 2>/dev/null)/lib/pkgconfig:$PKG_CONFIG_PATH\"\n          fi\n+\n+         case $host in\n+           *aarch64*)\n+             dnl The preferred Homebrew prefix for Apple Silicon is /opt/homebrew.\n+             dnl Therefore, as we do not use pkg-config to detect miniupnpc and libnatpmp\n+             dnl packages, we should set the CPPFLAGS and LDFLAGS variables for them\n+             dnl explicitly.\n+             if test \"x$use_upnp\" != xno && $BREW list --versions miniupnpc >/dev/null; then\n+               miniupnpc_prefix=$($BREW --prefix miniupnpc 2>/dev/null)\n+               if test \"x$suppress_external_warnings\" != xno; then\n+                 CPPFLAGS=\"$CPPFLAGS -isystem $miniupnpc_prefix/include\"\n+               else\n+                 CPPFLAGS=\"$CPPFLAGS -I$miniupnpc_prefix/include\"\n+               fi\n+               LDFLAGS=\"$LDFLAGS -L$miniupnpc_prefix/lib\"\n+             fi\n+             if test \"x$use_natpmp\" != xno && $BREW list --versions libnatpmp >/dev/null; then\n+               libnatpmp_prefix=$($BREW --prefix libnatpmp 2>/dev/null)\n+               if test \"x$suppress_external_warnings\" != xno; then\n+                 CPPFLAGS=\"$CPPFLAGS -isystem $libnatpmp_prefix/include\"\n+               else\n+                 CPPFLAGS=\"$CPPFLAGS -I$libnatpmp_prefix/include\"\n+               fi\n+               LDFLAGS=\"$LDFLAGS -L$libnatpmp_prefix/lib\"\n+             fi\n+             ;;\n+         esac\n        fi\n      else\n        case $build_os in\n@@ -830,17 +857,7 @@ if test x$ac_cv_sys_large_files != x &&\n   CPPFLAGS=\"$CPPFLAGS -D_LARGE_FILES=$ac_cv_sys_large_files\"\n fi\n \n-if test x$use_glibc_compat != xno; then\n-  AX_CHECK_LINK_FLAG([[-Wl,--wrap=__divmoddi4]], [COMPAT_LDFLAGS=\"$COMPAT_LDFLAGS -Wl,--wrap=__divmoddi4\"])\n-  AX_CHECK_LINK_FLAG([[-Wl,--wrap=log2f]], [COMPAT_LDFLAGS=\"$COMPAT_LDFLAGS -Wl,--wrap=log2f\"])\n-  case $host in\n-    powerpc64* | ppc64*)\n-      AX_CHECK_LINK_FLAG([[-Wl,--no-tls-get-addr-optimize]], [COMPAT_LDFLAGS=\"$COMPAT_LDFLAGS -Wl,--no-tls-get-addr-optimize\"])\n-    ;;\n-  esac\n-else\n-  AC_SEARCH_LIBS([clock_gettime],[rt])\n-fi\n+AC_SEARCH_LIBS([clock_gettime],[rt])\n \n if test \"x$enable_gprof\" = xyes; then\n     dnl -pg is incompatible with -pie. Since hardening and profiling together doesn't make sense,\n@@ -1032,7 +1049,7 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([\n dnl thread_local is currently disabled when building with glibc back compat.\n dnl Our minimum supported glibc is 2.17, however support for thread_local\n dnl did not arrive in glibc until 2.18.\n-if test \"x$use_thread_local\" = xyes || { test \"x$use_thread_local\" = xauto && test \"x$use_glibc_compat\" = xno; }; then\n+if test \"x$use_thread_local\" = xyes || test \"x$use_thread_local\" = xauto; then\n   TEMP_LDFLAGS=\"$LDFLAGS\"\n   LDFLAGS=\"$TEMP_LDFLAGS $PTHREAD_CFLAGS\"\n   AC_MSG_CHECKING([for thread_local support])\n@@ -1212,13 +1229,14 @@ AC_COMPILE_IFELSE([AC_LANG_PROGRAM([[\n  [ AC_MSG_RESULT(no); HAVE_WEAK_GETAUXVAL=0 ]\n )\n \n+have_any_system=no\n AC_MSG_CHECKING([for std::system])\n AC_LINK_IFELSE(\n     [ AC_LANG_PROGRAM(\n         [[ #include <cstdlib> ]],\n         [[ int nErr = std::system(\"\"); ]]\n     )],\n-    [ AC_MSG_RESULT(yes); AC_DEFINE(HAVE_STD__SYSTEM, 1, Define to 1 if std::system is available.)],\n+    [ AC_MSG_RESULT(yes); have_any_system=yes],\n     [ AC_MSG_RESULT(no) ]\n )\n \n@@ -1228,11 +1246,13 @@ AC_LINK_IFELSE(\n         [[ ]],\n         [[ int nErr = ::_wsystem(\"\"); ]]\n     )],\n-    [ AC_MSG_RESULT(yes); AC_DEFINE(HAVE_WSYSTEM, 1, Define to 1 if ::wsystem is available.)],\n+    [ AC_MSG_RESULT(yes); have_any_system=yes],\n     [ AC_MSG_RESULT(no) ]\n )\n \n-AC_DEFINE([HAVE_SYSTEM], [HAVE_STD__SYSTEM || HAVE_WSYSTEM], [std::system or ::wsystem])\n+if test \"x$have_any_system\" != \"xno\"; then\n+  AC_DEFINE(HAVE_SYSTEM, 1, Define to 1 if std::system or ::wsystem is available.)\n+fi\n \n LEVELDB_CPPFLAGS=\n LIBLEVELDB=\n@@ -1773,7 +1793,6 @@ AM_CONDITIONAL([ENABLE_BENCH],[test x$use_bench = xyes])\n AM_CONDITIONAL([USE_QRCODE], [test x$use_qr = xyes])\n AM_CONDITIONAL([USE_LCOV],[test x$use_lcov = xyes])\n AM_CONDITIONAL([USE_LIBEVENT],[test x$use_libevent = xyes])\n-AM_CONDITIONAL([GLIBC_BACK_COMPAT],[test x$use_glibc_compat = xyes])\n AM_CONDITIONAL([HARDEN],[test x$use_hardening = xyes])\n AM_CONDITIONAL([ENABLE_SSE42],[test x$enable_sse42 = xyes])\n AM_CONDITIONAL([ENABLE_SSE41],[test x$enable_sse41 = xyes])\n@@ -1816,7 +1835,6 @@ AC_SUBST(DEBUG_CPPFLAGS)\n AC_SUBST(WARN_CXXFLAGS)\n AC_SUBST(NOWARN_CXXFLAGS)\n AC_SUBST(DEBUG_CXXFLAGS)\n-AC_SUBST(COMPAT_LDFLAGS)\n AC_SUBST(ERROR_CXXFLAGS)\n AC_SUBST(GPROF_CXXFLAGS)\n AC_SUBST(GPROF_LDFLAGS)\n@@ -1868,7 +1886,7 @@ AC_CONFIG_LINKS([contrib/devtools/test-symbol-check.py:contrib/devtools/test-sym\n AC_CONFIG_LINKS([contrib/filter-lcov.py:contrib/filter-lcov.py])\n AC_CONFIG_LINKS([test/functional/test_runner.py:test/functional/test_runner.py])\n AC_CONFIG_LINKS([test/fuzz/test_runner.py:test/fuzz/test_runner.py])\n-AC_CONFIG_LINKS([test/util/bitcoin-util-test.py:test/util/bitcoin-util-test.py])\n+AC_CONFIG_LINKS([test/util/test_runner.py:test/util/test_runner.py])\n AC_CONFIG_LINKS([test/util/rpcauth-test.py:test/util/rpcauth-test.py])\n \n dnl boost's m4 checks do something really nasty: they export these vars. As a"
      },
      {
        "sha": "ae1372e95def350c530c0d6e9ffed05e13f5404c",
        "filename": "contrib/README.md",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/contrib/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/contrib/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/README.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -26,18 +26,12 @@ The [Debian](/contrib/debian) subfolder contains the copyright file.\n \n All other packaging related files can be found in the [bitcoin-core/packaging](https://github.com/bitcoin-core/packaging) repository.\n \n-### [Gitian-descriptors](/contrib/gitian-descriptors) ###\n-Files used during the gitian build process. For more information about gitian, see the [the Bitcoin Core documentation repository](https://github.com/bitcoin-core/docs).\n-\n ### [Builder keys](/contrib/builder-keys)\n PGP keys used for signing Bitcoin Core [release](/doc/release-process.md) results.\n \n ### [MacDeploy](/contrib/macdeploy) ###\n Scripts and notes for Mac builds.\n \n-### [Gitian-build](/contrib/gitian-build.py) ###\n-Script for running full Gitian builds.\n-\n Test and Verify Tools\n ---------------------\n "
      },
      {
        "sha": "e8032f66eeb73ce8e2e2fee47c52c3df8473dcda",
        "filename": "contrib/builder-keys/keys.txt",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/contrib/builder-keys/keys.txt",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/contrib/builder-keys/keys.txt",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/builder-keys/keys.txt?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -28,6 +28,7 @@ D3CC177286005BB8FF673294C5242A1AB3936517 jl2012 (jl2012)\n 32EE5C4C3FA15CCADB46ABE529D4BCB6416F53EC Jonas Schnelli (jonasschnelli)\n 4B4E840451149DD7FB0D633477DFAB5C3108B9A8 Jorge Timon (jtimon)\n C42AFF7C61B3E44A1454CD3557AF762DB3353322 Karl-Johan Alm (kallewoof)\n+70A1D47DD44F59DF8B22244333E472FE870C7E5D Kristaps Kaupe (kristapsk)\n 30DE693AE0DE9E37B3E7EB6BBFF0F67810C1EED1 Lisa Neigut (niftynei)\n E463A93F5F3117EEDE6C7316BD02942421F4889F Luke Dashjr (luke-jr)\n B8B3F1C0E58C15DB6A81D30C3648A882F4316B9B Marco Falke (marco)"
      },
      {
        "sha": "afbad096c4b97c9648acbd899fce9ec7f81a7bc6",
        "filename": "contrib/devtools/README.md",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/contrib/devtools/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/contrib/devtools/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/devtools/README.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -98,17 +98,17 @@ Perform basic security checks on a series of executables.\n symbol-check.py\n ===============\n \n-A script to check that the executables produced by gitian only contain\n+A script to check that release executables only contain\n certain symbols and are only linked against allowed libraries.\n \n For Linux this means checking for allowed gcc, glibc and libstdc++ version symbols.\n This makes sure they are still compatible with the minimum supported distribution versions.\n \n For macOS and Windows we check that the executables are only linked against libraries we allow.\n \n-Example usage after a gitian build:\n+Example usage:\n \n-    find ../gitian-builder/build -type f -executable | xargs python3 contrib/devtools/symbol-check.py\n+    find ../path/to/executables -type f -executable | xargs python3 contrib/devtools/symbol-check.py\n \n If no errors occur the return value will be 0 and the output will be empty.\n "
      },
      {
        "sha": "5df87d9e70cb79ae65f4d13a492a95fac71980cf",
        "filename": "contrib/gitian-build.py",
        "status": "removed",
        "additions": 0,
        "deletions": 263,
        "changes": 263,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/243a352d63078b8eacba0c64f991bc359c9ff1f7/contrib/gitian-build.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/243a352d63078b8eacba0c64f991bc359c9ff1f7/contrib/gitian-build.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-build.py?ref=243a352d63078b8eacba0c64f991bc359c9ff1f7",
        "patch": "@@ -1,263 +0,0 @@\n-#!/usr/bin/env python3\n-# Copyright (c) 2018-2020 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-import argparse\n-import os\n-import subprocess\n-import sys\n-\n-def setup():\n-    global args, workdir\n-    programs = ['ruby', 'git', 'make', 'wget', 'curl']\n-    if args.kvm:\n-        programs += ['apt-cacher-ng', 'python-vm-builder', 'qemu-kvm', 'qemu-utils']\n-    elif args.docker:\n-        if not os.path.isfile('/lib/systemd/system/docker.service'):\n-            dockers = ['docker.io', 'docker-ce']\n-            for i in dockers:\n-                return_code = subprocess.call(['sudo', 'apt-get', 'install', '-qq', i])\n-                if return_code == 0:\n-                    break\n-            if return_code != 0:\n-                print('Cannot find any way to install Docker.', file=sys.stderr)\n-                sys.exit(1)\n-    else:\n-        programs += ['apt-cacher-ng', 'lxc', 'debootstrap']\n-    subprocess.check_call(['sudo', 'apt-get', 'install', '-qq'] + programs)\n-    if not os.path.isdir('gitian.sigs'):\n-        subprocess.check_call(['git', 'clone', 'https://github.com/bitcoin-core/gitian.sigs.git'])\n-    if not os.path.isdir('bitcoin-detached-sigs'):\n-        subprocess.check_call(['git', 'clone', 'https://github.com/bitcoin-core/bitcoin-detached-sigs.git'])\n-    if not os.path.isdir('gitian-builder'):\n-        subprocess.check_call(['git', 'clone', 'https://github.com/devrandom/gitian-builder.git'])\n-    if not os.path.isdir('bitcoin'):\n-        subprocess.check_call(['git', 'clone', 'https://github.com/bitcoin/bitcoin.git'])\n-    os.chdir('gitian-builder')\n-    make_image_prog = ['bin/make-base-vm', '--suite', 'focal', '--arch', 'amd64']\n-    if args.docker:\n-        make_image_prog += ['--docker']\n-    elif not args.kvm:\n-        make_image_prog += ['--lxc', '--disksize', '13000']\n-    subprocess.check_call(make_image_prog)\n-    os.chdir(workdir)\n-    if args.is_focal and not args.kvm and not args.docker:\n-        subprocess.check_call(['sudo', 'sed', '-i', 's/lxcbr0/br0/', '/etc/default/lxc-net'])\n-        print('Reboot is required')\n-        sys.exit(0)\n-\n-def build():\n-    global args, workdir\n-\n-    os.makedirs('bitcoin-binaries/' + args.version, exist_ok=True)\n-    print('\\nBuilding Dependencies\\n')\n-    os.chdir('gitian-builder')\n-    os.makedirs('inputs', exist_ok=True)\n-\n-    subprocess.check_call(['wget', '-O', 'inputs/osslsigncode-2.0.tar.gz', 'https://github.com/mtrojnar/osslsigncode/archive/2.0.tar.gz'])\n-    subprocess.check_call([\"echo '5a60e0a4b3e0b4d655317b2f12a810211c50242138322b16e7e01c6fbb89d92f inputs/osslsigncode-2.0.tar.gz' | sha256sum -c\"], shell=True)\n-    subprocess.check_call(['make', '-C', '../bitcoin/depends', 'download', 'SOURCES_PATH=' + os.getcwd() + '/cache/common'])\n-\n-    if args.linux:\n-        print('\\nCompiling ' + args.version + ' Linux')\n-        subprocess.check_call(['bin/gbuild', '-j', args.jobs, '-m', args.memory, '--commit', 'bitcoin='+args.commit, '--url', 'bitcoin='+args.url, '../bitcoin/contrib/gitian-descriptors/gitian-linux.yml'])\n-        subprocess.check_call(['bin/gsign', '-p', args.sign_prog, '--signer', args.signer, '--release', args.version+'-linux', '--destination', '../gitian.sigs/', '../bitcoin/contrib/gitian-descriptors/gitian-linux.yml'])\n-        subprocess.check_call('mv build/out/bitcoin-*.tar.gz build/out/src/bitcoin-*.tar.gz ../bitcoin-binaries/'+args.version, shell=True)\n-\n-    if args.windows:\n-        print('\\nCompiling ' + args.version + ' Windows')\n-        subprocess.check_call(['bin/gbuild', '-j', args.jobs, '-m', args.memory, '--commit', 'bitcoin='+args.commit, '--url', 'bitcoin='+args.url, '../bitcoin/contrib/gitian-descriptors/gitian-win.yml'])\n-        subprocess.check_call(['bin/gsign', '-p', args.sign_prog, '--signer', args.signer, '--release', args.version+'-win-unsigned', '--destination', '../gitian.sigs/', '../bitcoin/contrib/gitian-descriptors/gitian-win.yml'])\n-        subprocess.check_call('mv build/out/bitcoin-*-win-unsigned.tar.gz inputs/', shell=True)\n-        subprocess.check_call('mv build/out/bitcoin-*.zip build/out/bitcoin-*.exe build/out/src/bitcoin-*.tar.gz ../bitcoin-binaries/'+args.version, shell=True)\n-\n-    if args.macos:\n-        print('\\nCompiling ' + args.version + ' MacOS')\n-        subprocess.check_call(['bin/gbuild', '-j', args.jobs, '-m', args.memory, '--commit', 'bitcoin='+args.commit, '--url', 'bitcoin='+args.url, '../bitcoin/contrib/gitian-descriptors/gitian-osx.yml'])\n-        subprocess.check_call(['bin/gsign', '-p', args.sign_prog, '--signer', args.signer, '--release', args.version+'-osx-unsigned', '--destination', '../gitian.sigs/', '../bitcoin/contrib/gitian-descriptors/gitian-osx.yml'])\n-        subprocess.check_call('mv build/out/bitcoin-*-osx-unsigned.tar.gz inputs/', shell=True)\n-        subprocess.check_call('mv build/out/bitcoin-*.tar.gz build/out/bitcoin-*.dmg build/out/src/bitcoin-*.tar.gz ../bitcoin-binaries/'+args.version, shell=True)\n-\n-    os.chdir(workdir)\n-\n-    if args.commit_files:\n-        print('\\nCommitting '+args.version+' Unsigned Sigs\\n')\n-        os.chdir('gitian.sigs')\n-        subprocess.check_call(['git', 'add', args.version+'-linux/'+args.signer])\n-        subprocess.check_call(['git', 'add', args.version+'-win-unsigned/'+args.signer])\n-        subprocess.check_call(['git', 'add', args.version+'-osx-unsigned/'+args.signer])\n-        subprocess.check_call(['git', 'commit', '-m', 'Add '+args.version+' unsigned sigs for '+args.signer])\n-        os.chdir(workdir)\n-\n-def sign():\n-    global args, workdir\n-    os.chdir('gitian-builder')\n-\n-    if args.windows:\n-        print('\\nSigning ' + args.version + ' Windows')\n-        subprocess.check_call('cp inputs/bitcoin-' + args.version + '-win-unsigned.tar.gz inputs/bitcoin-win-unsigned.tar.gz', shell=True)\n-        subprocess.check_call(['bin/gbuild', '--skip-image', '--upgrade', '--commit', 'signature='+args.commit, '../bitcoin/contrib/gitian-descriptors/gitian-win-signer.yml'])\n-        subprocess.check_call(['bin/gsign', '-p', args.sign_prog, '--signer', args.signer, '--release', args.version+'-win-signed', '--destination', '../gitian.sigs/', '../bitcoin/contrib/gitian-descriptors/gitian-win-signer.yml'])\n-        subprocess.check_call('mv build/out/bitcoin-*win64-setup.exe ../bitcoin-binaries/'+args.version, shell=True)\n-\n-    if args.macos:\n-        print('\\nSigning ' + args.version + ' MacOS')\n-        subprocess.check_call('cp inputs/bitcoin-' + args.version + '-osx-unsigned.tar.gz inputs/bitcoin-osx-unsigned.tar.gz', shell=True)\n-        subprocess.check_call(['bin/gbuild', '--skip-image', '--upgrade', '--commit', 'signature='+args.commit, '../bitcoin/contrib/gitian-descriptors/gitian-osx-signer.yml'])\n-        subprocess.check_call(['bin/gsign', '-p', args.sign_prog, '--signer', args.signer, '--release', args.version+'-osx-signed', '--destination', '../gitian.sigs/', '../bitcoin/contrib/gitian-descriptors/gitian-osx-signer.yml'])\n-        subprocess.check_call('mv build/out/bitcoin-osx-signed.dmg ../bitcoin-binaries/'+args.version+'/bitcoin-'+args.version+'-osx.dmg', shell=True)\n-\n-    os.chdir(workdir)\n-\n-    if args.commit_files:\n-        print('\\nCommitting '+args.version+' Signed Sigs\\n')\n-        os.chdir('gitian.sigs')\n-        subprocess.check_call(['git', 'add', args.version+'-win-signed/'+args.signer])\n-        subprocess.check_call(['git', 'add', args.version+'-osx-signed/'+args.signer])\n-        subprocess.check_call(['git', 'commit', '-a', '-m', 'Add '+args.version+' signed binary sigs for '+args.signer])\n-        os.chdir(workdir)\n-\n-def verify():\n-    global args, workdir\n-    rc = 0\n-    os.chdir('gitian-builder')\n-\n-    print('\\nVerifying v'+args.version+' Linux\\n')\n-    if subprocess.call(['bin/gverify', '-v', '-d', '../gitian.sigs/', '-r', args.version+'-linux', '../bitcoin/contrib/gitian-descriptors/gitian-linux.yml']):\n-        print('Verifying v'+args.version+' Linux FAILED\\n')\n-        rc = 1\n-\n-    print('\\nVerifying v'+args.version+' Windows\\n')\n-    if subprocess.call(['bin/gverify', '-v', '-d', '../gitian.sigs/', '-r', args.version+'-win-unsigned', '../bitcoin/contrib/gitian-descriptors/gitian-win.yml']):\n-        print('Verifying v'+args.version+' Windows FAILED\\n')\n-        rc = 1\n-\n-    print('\\nVerifying v'+args.version+' MacOS\\n')\n-    if subprocess.call(['bin/gverify', '-v', '-d', '../gitian.sigs/', '-r', args.version+'-osx-unsigned', '../bitcoin/contrib/gitian-descriptors/gitian-osx.yml']):\n-        print('Verifying v'+args.version+' MacOS FAILED\\n')\n-        rc = 1\n-\n-    print('\\nVerifying v'+args.version+' Signed Windows\\n')\n-    if subprocess.call(['bin/gverify', '-v', '-d', '../gitian.sigs/', '-r', args.version+'-win-signed', '../bitcoin/contrib/gitian-descriptors/gitian-win-signer.yml']):\n-        print('Verifying v'+args.version+' Signed Windows FAILED\\n')\n-        rc = 1\n-\n-    print('\\nVerifying v'+args.version+' Signed MacOS\\n')\n-    if subprocess.call(['bin/gverify', '-v', '-d', '../gitian.sigs/', '-r', args.version+'-osx-signed', '../bitcoin/contrib/gitian-descriptors/gitian-osx-signer.yml']):\n-        print('Verifying v'+args.version+' Signed MacOS FAILED\\n')\n-        rc = 1\n-\n-    os.chdir(workdir)\n-    return rc\n-\n-def main():\n-    global args, workdir\n-\n-    parser = argparse.ArgumentParser(description='Script for running full Gitian builds.')\n-    parser.add_argument('-c', '--commit', action='store_true', dest='commit', help='Indicate that the version argument is for a commit or branch')\n-    parser.add_argument('-p', '--pull', action='store_true', dest='pull', help='Indicate that the version argument is the number of a github repository pull request')\n-    parser.add_argument('-u', '--url', dest='url', default='https://github.com/bitcoin/bitcoin', help='Specify the URL of the repository. Default is %(default)s')\n-    parser.add_argument('-v', '--verify', action='store_true', dest='verify', help='Verify the Gitian build')\n-    parser.add_argument('-b', '--build', action='store_true', dest='build', help='Do a Gitian build')\n-    parser.add_argument('-s', '--sign', action='store_true', dest='sign', help='Make signed binaries for Windows and MacOS')\n-    parser.add_argument('-B', '--buildsign', action='store_true', dest='buildsign', help='Build both signed and unsigned binaries')\n-    parser.add_argument('-o', '--os', dest='os', default='lwm', help='Specify which Operating Systems the build is for. Default is %(default)s. l for Linux, w for Windows, m for MacOS')\n-    parser.add_argument('-j', '--jobs', dest='jobs', default='2', help='Number of processes to use. Default %(default)s')\n-    parser.add_argument('-m', '--memory', dest='memory', default='2000', help='Memory to allocate in MiB. Default %(default)s')\n-    parser.add_argument('-k', '--kvm', action='store_true', dest='kvm', help='Use KVM instead of LXC')\n-    parser.add_argument('-d', '--docker', action='store_true', dest='docker', help='Use Docker instead of LXC')\n-    parser.add_argument('-S', '--setup', action='store_true', dest='setup', help='Set up the Gitian building environment. Only works on Debian-based systems (Ubuntu, Debian)')\n-    parser.add_argument('-D', '--detach-sign', action='store_true', dest='detach_sign', help='Create the assert file for detached signing. Will not commit anything.')\n-    parser.add_argument('-n', '--no-commit', action='store_false', dest='commit_files', help='Do not commit anything to git')\n-    parser.add_argument('signer', nargs='?', help='GPG signer to sign each build assert file')\n-    parser.add_argument('version', nargs='?', help='Version number, commit, or branch to build. If building a commit or branch, the -c option must be specified')\n-\n-    args = parser.parse_args()\n-    workdir = os.getcwd()\n-\n-    args.is_focal = b'focal' in subprocess.check_output(['lsb_release', '-cs'])\n-\n-    if args.kvm and args.docker:\n-        raise Exception('Error: cannot have both kvm and docker')\n-\n-    # Ensure no more than one environment variable for gitian-builder (USE_LXC, USE_VBOX, USE_DOCKER) is set as they\n-    # can interfere (e.g., USE_LXC being set shadows USE_DOCKER; for details see gitian-builder/libexec/make-clean-vm).\n-    os.environ['USE_LXC'] = ''\n-    os.environ['USE_VBOX'] = ''\n-    os.environ['USE_DOCKER'] = ''\n-    if args.docker:\n-        os.environ['USE_DOCKER'] = '1'\n-    elif not args.kvm:\n-        os.environ['USE_LXC'] = '1'\n-        if 'GITIAN_HOST_IP' not in os.environ.keys():\n-            os.environ['GITIAN_HOST_IP'] = '10.0.3.1'\n-        if 'LXC_GUEST_IP' not in os.environ.keys():\n-            os.environ['LXC_GUEST_IP'] = '10.0.3.5'\n-\n-    if args.setup:\n-        setup()\n-\n-    if args.buildsign:\n-        args.build = True\n-        args.sign = True\n-\n-    if not args.build and not args.sign and not args.verify:\n-        sys.exit(0)\n-\n-    args.linux = 'l' in args.os\n-    args.windows = 'w' in args.os\n-    args.macos = 'm' in args.os\n-\n-    # Disable for MacOS if no SDK found\n-    if args.macos and not os.path.isfile('gitian-builder/inputs/Xcode-12.1-12A7403-extracted-SDK-with-libcxx-headers.tar.gz'):\n-        print('Cannot build for MacOS, SDK does not exist. Will build for other OSes')\n-        args.macos = False\n-\n-    args.sign_prog = 'true' if args.detach_sign else 'gpg --detach-sign'\n-\n-    script_name = os.path.basename(sys.argv[0])\n-    if not args.signer:\n-        print(script_name+': Missing signer')\n-        print('Try '+script_name+' --help for more information')\n-        sys.exit(1)\n-    if not args.version:\n-        print(script_name+': Missing version')\n-        print('Try '+script_name+' --help for more information')\n-        sys.exit(1)\n-\n-    # Add leading 'v' for tags\n-    if args.commit and args.pull:\n-        raise Exception('Cannot have both commit and pull')\n-    args.commit = ('' if args.commit else 'v') + args.version\n-\n-    os.chdir('bitcoin')\n-    if args.pull:\n-        subprocess.check_call(['git', 'fetch', args.url, 'refs/pull/'+args.version+'/merge'])\n-        os.chdir('../gitian-builder/inputs/bitcoin')\n-        subprocess.check_call(['git', 'fetch', args.url, 'refs/pull/'+args.version+'/merge'])\n-        args.commit = subprocess.check_output(['git', 'show', '-s', '--format=%H', 'FETCH_HEAD'], universal_newlines=True, encoding='utf8').strip()\n-        args.version = 'pull-' + args.version\n-    print(args.commit)\n-    subprocess.check_call(['git', 'fetch'])\n-    subprocess.check_call(['git', 'checkout', args.commit])\n-    os.chdir(workdir)\n-\n-    os.chdir('gitian-builder')\n-    subprocess.check_call(['git', 'pull'])\n-    os.chdir(workdir)\n-\n-    if args.build:\n-        build()\n-\n-    if args.sign:\n-        sign()\n-\n-    if args.verify:\n-        os.chdir('gitian.sigs')\n-        subprocess.check_call(['git', 'pull'])\n-        os.chdir(workdir)\n-        sys.exit(verify())\n-\n-if __name__ == '__main__':\n-    main()"
      },
      {
        "sha": "330fbc041b31ac8f1a828f7eccca76f866cc51b7",
        "filename": "contrib/gitian-descriptors/assign_DISTNAME",
        "status": "removed",
        "additions": 0,
        "deletions": 12,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/243a352d63078b8eacba0c64f991bc359c9ff1f7/contrib/gitian-descriptors/assign_DISTNAME",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/243a352d63078b8eacba0c64f991bc359c9ff1f7/contrib/gitian-descriptors/assign_DISTNAME",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/assign_DISTNAME?ref=243a352d63078b8eacba0c64f991bc359c9ff1f7",
        "patch": "@@ -1,12 +0,0 @@\n-# Copyright (c) 2020 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-#\n-# A helper script to be sourced into the gitian descriptors\n-\n-if RECENT_TAG=\"$(git describe --exact-match HEAD 2> /dev/null)\"; then\n-    VERSION=\"${RECENT_TAG#v}\"\n-else\n-    VERSION=\"$(git rev-parse --short=12 HEAD)\"\n-fi\n-DISTNAME=\"bitcoin-${VERSION}\""
      },
      {
        "sha": "e6dce7a8c664fc102b06f281eb1fc33a75670992",
        "filename": "contrib/gitian-descriptors/gitian-linux.yml",
        "status": "removed",
        "additions": 0,
        "deletions": 167,
        "changes": 167,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/243a352d63078b8eacba0c64f991bc359c9ff1f7/contrib/gitian-descriptors/gitian-linux.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/243a352d63078b8eacba0c64f991bc359c9ff1f7/contrib/gitian-descriptors/gitian-linux.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-linux.yml?ref=243a352d63078b8eacba0c64f991bc359c9ff1f7",
        "patch": "@@ -1,167 +0,0 @@\n----\n-name: \"bitcoin-core-linux-22\"\n-enable_cache: true\n-distro: \"ubuntu\"\n-suites:\n-- \"focal\"\n-architectures:\n-- \"amd64\"\n-packages:\n-# Common dependencies.\n-- \"autoconf\"\n-- \"automake\"\n-- \"binutils\"\n-- \"bison\"\n-- \"bsdmainutils\"\n-- \"ca-certificates\"\n-- \"curl\"\n-- \"faketime\"\n-- \"g++-8\"\n-- \"gcc-8\"\n-- \"git\"\n-- \"libtool\"\n-- \"patch\"\n-- \"pkg-config\"\n-- \"python3\"\n-- \"python3-pip\"\n-# Cross compilation HOSTS:\n-#  - arm-linux-gnueabihf\n-- \"binutils-arm-linux-gnueabihf\"\n-- \"g++-8-arm-linux-gnueabihf\"\n-#  - aarch64-linux-gnu\n-- \"binutils-aarch64-linux-gnu\"\n-- \"g++-8-aarch64-linux-gnu\"\n-#  - powerpc64-linux-gnu\n-- \"binutils-powerpc64-linux-gnu\"\n-- \"g++-8-powerpc64-linux-gnu\"\n-#  - powerpc64le-linux-gnu\n-- \"binutils-powerpc64le-linux-gnu\"\n-- \"g++-8-powerpc64le-linux-gnu\"\n-#  - riscv64-linux-gnu\n-- \"binutils-riscv64-linux-gnu\"\n-- \"g++-8-riscv64-linux-gnu\"\n-remotes:\n-- \"url\": \"https://github.com/bitcoin/bitcoin.git\"\n-  \"dir\": \"bitcoin\"\n-files: []\n-script: |\n-  set -e -o pipefail\n-\n-  WRAP_DIR=$HOME/wrapped\n-  HOSTS=\"x86_64-linux-gnu arm-linux-gnueabihf aarch64-linux-gnu powerpc64-linux-gnu powerpc64le-linux-gnu riscv64-linux-gnu\"\n-  CONFIGFLAGS=\"--enable-glibc-back-compat --enable-reduce-exports --disable-bench --disable-gui-tests --disable-fuzz-binary\"\n-  FAKETIME_HOST_PROGS=\"gcc g++\"\n-  FAKETIME_PROGS=\"date ar ranlib nm\"\n-  HOST_CFLAGS=\"-O2 -g\"\n-  HOST_CXXFLAGS=\"-O2 -g\"\n-  HOST_LDFLAGS_BASE=\"-static-libstdc++ -Wl,-O2\"\n-\n-  export TZ=\"UTC\"\n-  export BUILD_DIR=\"$PWD\"\n-  mkdir -p ${WRAP_DIR}\n-  if test -n \"$GBUILD_CACHE_ENABLED\"; then\n-    export SOURCES_PATH=${GBUILD_COMMON_CACHE}\n-    export BASE_CACHE=${GBUILD_PACKAGE_CACHE}\n-    mkdir -p ${BASE_CACHE} ${SOURCES_PATH}\n-  fi\n-\n-  # Use $LIB in LD_PRELOAD to avoid hardcoding the dir (See `man ld.so`)\n-  function create_global_faketime_wrappers {\n-  for prog in ${FAKETIME_PROGS}; do\n-    echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${prog}\n-    echo \"REAL=\\`which -a ${prog} | grep -v ${WRAP_DIR}/${prog} | head -1\\`\" >> ${WRAP_DIR}/${prog}\n-    echo \"export LD_PRELOAD='/usr/\\$LIB/faketime/libfaketime.so.1'\" >> ${WRAP_DIR}/${prog}\n-    echo \"export FAKETIME=\\\"$1\\\"\" >> ${WRAP_DIR}/${prog}\n-    echo \"exec \\\"\\$REAL\\\" \\\"\\$@\\\"\" >> $WRAP_DIR/${prog}\n-    chmod +x ${WRAP_DIR}/${prog}\n-  done\n-  }\n-\n-  function create_per-host_faketime_wrappers {\n-  for i in $HOSTS; do\n-    for prog in ${FAKETIME_HOST_PROGS}; do\n-        if which ${i}-${prog}-8\n-        then\n-            echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${i}-${prog}\n-            echo \"REAL=\\`which -a ${i}-${prog}-8 | grep -v ${WRAP_DIR}/${i}-${prog} | head -1\\`\" >> ${WRAP_DIR}/${i}-${prog}\n-            echo \"export LD_PRELOAD='/usr/\\$LIB/faketime/libfaketime.so.1'\" >> ${WRAP_DIR}/${i}-${prog}\n-            echo \"export FAKETIME=\\\"$1\\\"\" >> ${WRAP_DIR}/${i}-${prog}\n-            if [ \"${i:0:11}\" = \"powerpc64le\" ]; then\n-                echo \"exec \\\"\\$REAL\\\" -mcpu=power8 -mtune=power9 \\\"\\$@\\\"\" >> $WRAP_DIR/${i}-${prog}\n-            elif [ \"${i:0:9}\" = \"powerpc64\" ]; then\n-                echo \"exec \\\"\\$REAL\\\" -mcpu=970 -mtune=power9 \\\"\\$@\\\"\" >> $WRAP_DIR/${i}-${prog}\n-            else\n-                echo \"exec \\\"\\$REAL\\\" \\\"\\$@\\\"\" >> $WRAP_DIR/${i}-${prog}\n-            fi\n-            chmod +x ${WRAP_DIR}/${i}-${prog}\n-        fi\n-    done\n-  done\n-  }\n-\n-  pip3 install lief==0.11.5\n-\n-  # Faketime for depends so intermediate results are comparable\n-  export PATH_orig=${PATH}\n-  create_global_faketime_wrappers \"2000-01-01 12:00:00\"\n-  create_per-host_faketime_wrappers \"2000-01-01 12:00:00\"\n-  export PATH=${WRAP_DIR}:${PATH}\n-\n-  cd bitcoin\n-  BASEPREFIX=\"${PWD}/depends\"\n-  # Build dependencies for each host\n-  for i in $HOSTS; do\n-    make ${MAKEOPTS} -C ${BASEPREFIX} HOST=\"${i}\" CC=${i}-gcc-8 CXX=${i}-g++-8\n-  done\n-\n-  # Faketime for binaries\n-  export PATH=${PATH_orig}\n-  create_global_faketime_wrappers \"${REFERENCE_DATETIME}\"\n-  create_per-host_faketime_wrappers \"${REFERENCE_DATETIME}\"\n-  export PATH=${WRAP_DIR}:${PATH}\n-\n-  # Define DISTNAME variable.\n-  # shellcheck source=contrib/gitian-descriptors/assign_DISTNAME\n-  source contrib/gitian-descriptors/assign_DISTNAME\n-\n-  GIT_ARCHIVE=\"${OUTDIR}/src/${DISTNAME}.tar.gz\"\n-\n-  # Create the source tarball\n-  mkdir -p \"$(dirname \"$GIT_ARCHIVE\")\"\n-  git archive --prefix=\"${DISTNAME}/\" --output=\"$GIT_ARCHIVE\" HEAD\n-\n-  ORIGPATH=\"$PATH\"\n-  # Extract the git archive into a dir for each host and build\n-  for i in ${HOSTS}; do\n-    export PATH=${BASEPREFIX}/${i}/native/bin:${ORIGPATH}\n-    if [ \"${i}\" = \"powerpc64-linux-gnu\" ]; then\n-      # Workaround for https://bugs.launchpad.net/ubuntu/+source/gcc-8-cross-ports/+bug/1853740\n-      # TODO: remove this when no longer needed\n-      HOST_LDFLAGS=\"${HOST_LDFLAGS_BASE} -Wl,-z,noexecstack\"\n-    else\n-      HOST_LDFLAGS=\"${HOST_LDFLAGS_BASE}\"\n-    fi\n-    mkdir -p distsrc-${i}\n-    cd distsrc-${i}\n-    INSTALLPATH=\"${PWD}/installed/${DISTNAME}\"\n-    mkdir -p ${INSTALLPATH}\n-    tar --strip-components=1 -xf \"${GIT_ARCHIVE}\"\n-\n-    ./autogen.sh\n-    CONFIG_SITE=${BASEPREFIX}/${i}/share/config.site ./configure --prefix=/ --disable-ccache --disable-maintainer-mode --disable-dependency-tracking ${CONFIGFLAGS} CFLAGS=\"${HOST_CFLAGS}\" CXXFLAGS=\"${HOST_CXXFLAGS}\" LDFLAGS=\"${HOST_LDFLAGS}\" CC=${i}-gcc-8 CXX=${i}-g++-8\n-    make ${MAKEOPTS}\n-    make ${MAKEOPTS} -C src check-security\n-    make ${MAKEOPTS} -C src check-symbols\n-    make install DESTDIR=${INSTALLPATH}\n-    cd installed\n-    find . -name \"lib*.la\" -delete\n-    find . -name \"lib*.a\" -delete\n-    rm -rf ${DISTNAME}/lib/pkgconfig\n-    find ${DISTNAME}/bin -type f -executable -print0 | xargs -0 -n1 -I{} ../contrib/devtools/split-debug.sh {} {} {}.dbg\n-    find ${DISTNAME}/lib -type f -print0 | xargs -0 -n1 -I{} ../contrib/devtools/split-debug.sh {} {} {}.dbg\n-    cp ../README.md ${DISTNAME}/\n-    find ${DISTNAME} -not -name \"*.dbg\" | sort | tar --mtime=\"$REFERENCE_DATETIME\" --no-recursion --mode='u+rw,go+r-w,a+X' --owner=0 --group=0 -c -T - | gzip -9n > ${OUTDIR}/${DISTNAME}-${i}.tar.gz\n-    find ${DISTNAME} -name \"*.dbg\" | sort | tar --mtime=\"$REFERENCE_DATETIME\" --no-recursion --mode='u+rw,go+r-w,a+X' --owner=0 --group=0 -c -T - | gzip -9n > ${OUTDIR}/${DISTNAME}-${i}-debug.tar.gz\n-    cd ../../\n-    rm -rf distsrc-${i}\n-  done"
      },
      {
        "sha": "addad0a5d27a0320a5384894e9a7f09aa97c8e1c",
        "filename": "contrib/gitian-descriptors/gitian-osx-signer.yml",
        "status": "removed",
        "additions": 0,
        "deletions": 53,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/243a352d63078b8eacba0c64f991bc359c9ff1f7/contrib/gitian-descriptors/gitian-osx-signer.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/243a352d63078b8eacba0c64f991bc359c9ff1f7/contrib/gitian-descriptors/gitian-osx-signer.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx-signer.yml?ref=243a352d63078b8eacba0c64f991bc359c9ff1f7",
        "patch": "@@ -1,53 +0,0 @@\n----\n-name: \"bitcoin-dmg-signer\"\n-distro: \"ubuntu\"\n-suites:\n-- \"focal\"\n-architectures:\n-- \"amd64\"\n-packages:\n-- \"faketime\"\n-- \"xorriso\"\n-- \"python3-pip\"\n-remotes:\n-- \"url\": \"https://github.com/bitcoin-core/bitcoin-detached-sigs.git\"\n-  \"dir\": \"signature\"\n-- \"url\": \"https://github.com/achow101/signapple.git\"\n-  \"dir\": \"signapple\"\n-  \"commit\": \"b084cbbf44d5330448ffce0c7d118f75781b64bd\"\n-files:\n-- \"bitcoin-osx-unsigned.tar.gz\"\n-script: |\n-  set -e -o pipefail\n-\n-  WRAP_DIR=$HOME/wrapped\n-  mkdir -p ${WRAP_DIR}\n-  export PATH=\"$PWD\":$PATH\n-  FAKETIME_PROGS=\"dmg xorrisofs\"\n-\n-  # Create global faketime wrappers\n-  for prog in ${FAKETIME_PROGS}; do\n-    echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${prog}\n-    echo \"REAL=\\`which -a ${prog} | grep -v ${WRAP_DIR}/${prog} | head -1\\`\" >> ${WRAP_DIR}/${prog}\n-    echo \"export LD_PRELOAD='/usr/\\$LIB/faketime/libfaketime.so.1'\" >> ${WRAP_DIR}/${prog}\n-    echo \"export FAKETIME=\\\"${REFERENCE_DATETIME}\\\"\" >> ${WRAP_DIR}/${prog}\n-    echo \"exec \\\"\\$REAL\\\" \\\"\\$@\\\"\" >> $WRAP_DIR/${prog}\n-    chmod +x ${WRAP_DIR}/${prog}\n-  done\n-\n-  # Install signapple\n-  cd signapple\n-  python3 -m pip install -U pip setuptools\n-  python3 -m pip install .\n-  export PATH=\"$HOME/.local/bin\":$PATH\n-  cd ..\n-\n-  UNSIGNED_TARBALL=bitcoin-osx-unsigned.tar.gz\n-  UNSIGNED_APP=dist/Bitcoin-Qt.app\n-  SIGNED=bitcoin-osx-signed.dmg\n-\n-  tar -xf ${UNSIGNED_TARBALL}\n-  OSX_VOLNAME=\"$(cat osx_volname)\"\n-  ./detached-sig-apply.sh ${UNSIGNED_APP} signature/osx/dist\n-  ${WRAP_DIR}/xorrisofs -D -l -V \"${OSX_VOLNAME}\" -no-pad -r -dir-mode 0755 -o uncompressed.dmg signed-app\n-  ${WRAP_DIR}/dmg dmg uncompressed.dmg ${OUTDIR}/${SIGNED}"
      },
      {
        "sha": "a39618adb78d5c3403c9f47e0b58111a6811bbec",
        "filename": "contrib/gitian-descriptors/gitian-osx.yml",
        "status": "removed",
        "additions": 0,
        "deletions": 155,
        "changes": 155,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/243a352d63078b8eacba0c64f991bc359c9ff1f7/contrib/gitian-descriptors/gitian-osx.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/243a352d63078b8eacba0c64f991bc359c9ff1f7/contrib/gitian-descriptors/gitian-osx.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-osx.yml?ref=243a352d63078b8eacba0c64f991bc359c9ff1f7",
        "patch": "@@ -1,155 +0,0 @@\n----\n-name: \"bitcoin-core-osx-22\"\n-enable_cache: true\n-distro: \"ubuntu\"\n-suites:\n-- \"focal\"\n-architectures:\n-- \"amd64\"\n-packages:\n-- \"ca-certificates\"\n-- \"curl\"\n-- \"g++\"\n-- \"git\"\n-- \"pkg-config\"\n-- \"autoconf\"\n-- \"librsvg2-bin\"\n-- \"libtiff-tools\"\n-- \"libtool\"\n-- \"automake\"\n-- \"faketime\"\n-- \"bsdmainutils\"\n-- \"cmake\"\n-- \"imagemagick\"\n-- \"libz-dev\"\n-- \"python3\"\n-- \"python3-pip\"\n-- \"python3-setuptools\"\n-- \"fonts-tuffy\"\n-- \"xorriso\"\n-- \"libtinfo5\"\n-remotes:\n-- \"url\": \"https://github.com/bitcoin/bitcoin.git\"\n-  \"dir\": \"bitcoin\"\n-files:\n-- \"Xcode-12.1-12A7403-extracted-SDK-with-libcxx-headers.tar.gz\"\n-script: |\n-  set -e -o pipefail\n-\n-  WRAP_DIR=$HOME/wrapped\n-  HOSTS=\"x86_64-apple-darwin18\"\n-  CONFIGFLAGS=\"--enable-reduce-exports --disable-bench --disable-gui-tests --disable-fuzz-binary XORRISOFS=${WRAP_DIR}/xorrisofs DMG=${WRAP_DIR}/dmg\"\n-  FAKETIME_HOST_PROGS=\"\"\n-  FAKETIME_PROGS=\"ar ranlib date dmg xorrisofs\"\n-\n-  export TZ=\"UTC\"\n-  export BUILD_DIR=\"$PWD\"\n-  mkdir -p ${WRAP_DIR}\n-  if test -n \"$GBUILD_CACHE_ENABLED\"; then\n-    export SOURCES_PATH=${GBUILD_COMMON_CACHE}\n-    export BASE_CACHE=${GBUILD_PACKAGE_CACHE}\n-    mkdir -p ${BASE_CACHE} ${SOURCES_PATH}\n-  fi\n-\n-  export ZERO_AR_DATE=1\n-\n-  # Use $LIB in LD_PRELOAD to avoid hardcoding the dir (See `man ld.so`)\n-  function create_global_faketime_wrappers {\n-  for prog in ${FAKETIME_PROGS}; do\n-    echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${prog}\n-    echo \"REAL=\\`which -a ${prog} | grep -v ${WRAP_DIR}/${prog} | head -1\\`\" >> ${WRAP_DIR}/${prog}\n-    echo \"export LD_PRELOAD='/usr/\\$LIB/faketime/libfaketime.so.1'\" >> ${WRAP_DIR}/${prog}\n-    echo \"export FAKETIME=\\\"$1\\\"\" >> ${WRAP_DIR}/${prog}\n-    echo \"exec \\\"\\$REAL\\\" \\\"\\$@\\\"\" >> $WRAP_DIR/${prog}\n-    chmod +x ${WRAP_DIR}/${prog}\n-  done\n-  }\n-\n-  function create_per-host_faketime_wrappers {\n-  for i in $HOSTS; do\n-    for prog in ${FAKETIME_HOST_PROGS}; do\n-        echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${i}-${prog}\n-        echo \"REAL=\\`which -a ${i}-${prog} | grep -v ${WRAP_DIR}/${i}-${prog} | head -1\\`\" >> ${WRAP_DIR}/${i}-${prog}\n-        echo \"export LD_PRELOAD='/usr/\\$LIB/faketime/libfaketime.so.1'\" >> ${WRAP_DIR}/${i}-${prog}\n-        echo \"export FAKETIME=\\\"$1\\\"\" >> ${WRAP_DIR}/${i}-${prog}\n-        echo \"exec \\\"\\$REAL\\\" \\\"\\$@\\\"\" >> $WRAP_DIR/${i}-${prog}\n-        chmod +x ${WRAP_DIR}/${i}-${prog}\n-    done\n-  done\n-  }\n-\n-  pip3 install lief==0.11.5\n-\n-  # Faketime for depends so intermediate results are comparable\n-  export PATH_orig=${PATH}\n-  create_global_faketime_wrappers \"2000-01-01 12:00:00\"\n-  create_per-host_faketime_wrappers \"2000-01-01 12:00:00\"\n-  export PATH=${WRAP_DIR}:${PATH}\n-\n-  cd bitcoin\n-  BASEPREFIX=\"${PWD}/depends\"\n-\n-  mkdir -p ${BASEPREFIX}/SDKs\n-  tar -C ${BASEPREFIX}/SDKs -xf ${BUILD_DIR}/Xcode-12.1-12A7403-extracted-SDK-with-libcxx-headers.tar.gz\n-\n-  # Build dependencies for each host\n-  for i in $HOSTS; do\n-    make ${MAKEOPTS} -C ${BASEPREFIX} HOST=\"${i}\"\n-  done\n-\n-  # Faketime for binaries\n-  export PATH=${PATH_orig}\n-  create_global_faketime_wrappers \"${REFERENCE_DATETIME}\"\n-  create_per-host_faketime_wrappers \"${REFERENCE_DATETIME}\"\n-  export PATH=${WRAP_DIR}:${PATH}\n-\n-  # Define DISTNAME variable.\n-  # shellcheck source=contrib/gitian-descriptors/assign_DISTNAME\n-  source contrib/gitian-descriptors/assign_DISTNAME\n-\n-  GIT_ARCHIVE=\"${OUTDIR}/src/${DISTNAME}.tar.gz\"\n-\n-  # Create the source tarball\n-  mkdir -p \"$(dirname \"$GIT_ARCHIVE\")\"\n-  git archive --prefix=\"${DISTNAME}/\" --output=\"$GIT_ARCHIVE\" HEAD\n-\n-  ORIGPATH=\"$PATH\"\n-  # Extract the git archive into a dir for each host and build\n-  for i in ${HOSTS}; do\n-    export PATH=${BASEPREFIX}/${i}/native/bin:${ORIGPATH}\n-    mkdir -p distsrc-${i}\n-    cd distsrc-${i}\n-    INSTALLPATH=\"${PWD}/installed/${DISTNAME}\"\n-    mkdir -p ${INSTALLPATH}\n-    tar --strip-components=1 -xf \"${GIT_ARCHIVE}\"\n-\n-    ./autogen.sh\n-    CONFIG_SITE=${BASEPREFIX}/${i}/share/config.site ./configure --prefix=/ --disable-ccache --disable-maintainer-mode --disable-dependency-tracking ${CONFIGFLAGS}\n-    make ${MAKEOPTS}\n-    make ${MAKEOPTS} -C src check-security\n-    make ${MAKEOPTS} -C src check-symbols\n-    make install-strip DESTDIR=${INSTALLPATH}\n-\n-    make osx_volname\n-    make deploydir\n-    mkdir -p unsigned-app-${i}\n-    cp osx_volname unsigned-app-${i}/\n-    cp contrib/macdeploy/detached-sig-apply.sh unsigned-app-${i}\n-    cp contrib/macdeploy/detached-sig-create.sh unsigned-app-${i}\n-    cp ${BASEPREFIX}/${i}/native/bin/dmg unsigned-app-${i}\n-    mv dist unsigned-app-${i}\n-    pushd unsigned-app-${i}\n-    find . | sort | tar --mtime=\"$REFERENCE_DATETIME\" --no-recursion --mode='u+rw,go+r-w,a+X' --owner=0 --group=0 -c -T - | gzip -9n > ${OUTDIR}/${DISTNAME}-osx-unsigned.tar.gz\n-    popd\n-\n-    make deploy OSX_DMG=\"${OUTDIR}/${DISTNAME}-osx-unsigned.dmg\"\n-\n-    cd installed\n-    find . -name \"lib*.la\" -delete\n-    find . -name \"lib*.a\" -delete\n-    rm -rf ${DISTNAME}/lib/pkgconfig\n-    find ${DISTNAME} | sort | tar --mtime=\"$REFERENCE_DATETIME\" --no-recursion --mode='u+rw,go+r-w,a+X' --owner=0 --group=0 -c -T - | gzip -9n > ${OUTDIR}/${DISTNAME}-${i}.tar.gz\n-    cd ../../\n-  done\n-\n-  mv ${OUTDIR}/${DISTNAME}-x86_64-*.tar.gz ${OUTDIR}/${DISTNAME}-osx64.tar.gz"
      },
      {
        "sha": "c13c24c3cc332316c044fcf3a1a41227894fa1b2",
        "filename": "contrib/gitian-descriptors/gitian-win-signer.yml",
        "status": "removed",
        "additions": 0,
        "deletions": 42,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/243a352d63078b8eacba0c64f991bc359c9ff1f7/contrib/gitian-descriptors/gitian-win-signer.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/243a352d63078b8eacba0c64f991bc359c9ff1f7/contrib/gitian-descriptors/gitian-win-signer.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-win-signer.yml?ref=243a352d63078b8eacba0c64f991bc359c9ff1f7",
        "patch": "@@ -1,42 +0,0 @@\n----\n-name: \"bitcoin-win-signer\"\n-distro: \"ubuntu\"\n-suites:\n-- \"focal\"\n-architectures:\n-- \"amd64\"\n-packages:\n-- \"libssl-dev\"\n-- \"autoconf\"\n-- \"automake\"\n-- \"libtool\"\n-- \"pkg-config\"\n-remotes:\n-- \"url\": \"https://github.com/bitcoin-core/bitcoin-detached-sigs.git\"\n-  \"dir\": \"signature\"\n-files:\n-- \"osslsigncode-2.0.tar.gz\"\n-- \"bitcoin-win-unsigned.tar.gz\"\n-script: |\n-  set -e -o pipefail\n-\n-  BUILD_DIR=\"$PWD\"\n-  SIGDIR=${BUILD_DIR}/signature/win\n-  UNSIGNED_DIR=${BUILD_DIR}/unsigned\n-\n-  echo \"5a60e0a4b3e0b4d655317b2f12a810211c50242138322b16e7e01c6fbb89d92f  osslsigncode-2.0.tar.gz\" | sha256sum -c\n-\n-  mkdir -p ${UNSIGNED_DIR}\n-  tar -C ${UNSIGNED_DIR} -xf bitcoin-win-unsigned.tar.gz\n-\n-  tar xf osslsigncode-2.0.tar.gz\n-  cd osslsigncode-2.0\n-\n-  ./autogen.sh\n-  ./configure --without-gsf --without-curl --disable-dependency-tracking\n-  make\n-  find ${UNSIGNED_DIR} -name \"*-unsigned.exe\" | while read i; do\n-    INFILE=\"$(basename \"${i}\")\"\n-    OUTFILE=\"${INFILE/-unsigned}\"\n-    ./osslsigncode attach-signature -in \"${i}\" -out \"${OUTDIR}/${OUTFILE}\" -sigin \"${SIGDIR}/${INFILE}.pem\"\n-  done"
      },
      {
        "sha": "ffe228a032e6dd72af86ea2187c3737f3783e1f8",
        "filename": "contrib/gitian-descriptors/gitian-win.yml",
        "status": "removed",
        "additions": 0,
        "deletions": 157,
        "changes": 157,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/243a352d63078b8eacba0c64f991bc359c9ff1f7/contrib/gitian-descriptors/gitian-win.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/243a352d63078b8eacba0c64f991bc359c9ff1f7/contrib/gitian-descriptors/gitian-win.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/gitian-descriptors/gitian-win.yml?ref=243a352d63078b8eacba0c64f991bc359c9ff1f7",
        "patch": "@@ -1,157 +0,0 @@\n----\n-name: \"bitcoin-core-win-22\"\n-enable_cache: true\n-distro: \"ubuntu\"\n-suites:\n-- \"focal\"\n-architectures:\n-- \"amd64\"\n-packages:\n-- \"curl\"\n-- \"g++\"\n-- \"git\"\n-- \"pkg-config\"\n-- \"autoconf\"\n-- \"libtool\"\n-- \"automake\"\n-- \"faketime\"\n-- \"bsdmainutils\"\n-- \"mingw-w64\"\n-- \"g++-mingw-w64\"\n-- \"nsis\"\n-- \"zip\"\n-- \"ca-certificates\"\n-- \"python3\"\n-- \"python3-pip\"\n-remotes:\n-- \"url\": \"https://github.com/bitcoin/bitcoin.git\"\n-  \"dir\": \"bitcoin\"\n-files: []\n-script: |\n-  set -e -o pipefail\n-\n-  WRAP_DIR=$HOME/wrapped\n-  HOSTS=\"x86_64-w64-mingw32\"\n-  CONFIGFLAGS=\"--enable-reduce-exports --disable-bench --disable-gui-tests --disable-fuzz-binary\"\n-  FAKETIME_HOST_PROGS=\"ar ranlib nm windres strip objcopy\"\n-  FAKETIME_PROGS=\"date makensis zip\"\n-  HOST_CFLAGS=\"-O2 -g -fno-ident\"\n-  HOST_CXXFLAGS=\"-O2 -g -fno-ident\"\n-\n-  export TZ=\"UTC\"\n-  export BUILD_DIR=\"$PWD\"\n-  mkdir -p ${WRAP_DIR}\n-  if test -n \"$GBUILD_CACHE_ENABLED\"; then\n-    export SOURCES_PATH=${GBUILD_COMMON_CACHE}\n-    export BASE_CACHE=${GBUILD_PACKAGE_CACHE}\n-    mkdir -p ${BASE_CACHE} ${SOURCES_PATH}\n-  fi\n-\n-  # Use $LIB in LD_PRELOAD to avoid hardcoding the dir (See `man ld.so`)\n-  function create_global_faketime_wrappers {\n-  for prog in ${FAKETIME_PROGS}; do\n-    echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${prog}\n-    echo \"REAL=\\`which -a ${prog} | grep -v ${WRAP_DIR}/${prog} | head -1\\`\" >> ${WRAP_DIR}/${prog}\n-    echo \"export LD_PRELOAD='/usr/\\$LIB/faketime/libfaketime.so.1'\" >> ${WRAP_DIR}/${prog}\n-    echo \"export FAKETIME=\\\"$1\\\"\" >> ${WRAP_DIR}/${prog}\n-    echo \"exec \\\"\\$REAL\\\" \\\"\\$@\\\"\" >> $WRAP_DIR/${prog}\n-    chmod +x ${WRAP_DIR}/${prog}\n-  done\n-  }\n-\n-  function create_per-host_faketime_wrappers {\n-  for i in $HOSTS; do\n-    for prog in ${FAKETIME_HOST_PROGS}; do\n-        echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${i}-${prog}\n-        echo \"REAL=\\`which -a ${i}-${prog} | grep -v ${WRAP_DIR}/${i}-${prog} | head -1\\`\" >> ${WRAP_DIR}/${i}-${prog}\n-        echo \"export LD_PRELOAD='/usr/\\$LIB/faketime/libfaketime.so.1'\" >> ${WRAP_DIR}/${i}-${prog}\n-        echo \"export FAKETIME=\\\"$1\\\"\" >> ${WRAP_DIR}/${i}-${prog}\n-        echo \"exec \\\"\\$REAL\\\" \\\"\\$@\\\"\" >> $WRAP_DIR/${i}-${prog}\n-        chmod +x ${WRAP_DIR}/${i}-${prog}\n-    done\n-  done\n-  }\n-\n-  function create_per-host_compiler_wrapper {\n-  # -posix variant is required for c++11 threading.\n-  for i in $HOSTS; do\n-    for prog in gcc g++; do\n-        echo '#!/usr/bin/env bash' > ${WRAP_DIR}/${i}-${prog}\n-        echo \"REAL=\\`which -a ${i}-${prog}-posix | grep -v ${WRAP_DIR}/${i}-${prog} | head -1\\`\" >> ${WRAP_DIR}/${i}-${prog}\n-        echo \"export LD_PRELOAD='/usr/\\$LIB/faketime/libfaketime.so.1'\" >> ${WRAP_DIR}/${i}-${prog}\n-        echo \"export FAKETIME=\\\"$1\\\"\" >> ${WRAP_DIR}/${i}-${prog}\n-        echo \"exec \\\"\\$REAL\\\" \\\"\\$@\\\"\" >> $WRAP_DIR/${i}-${prog}\n-        chmod +x ${WRAP_DIR}/${i}-${prog}\n-    done\n-  done\n-  }\n-\n-  pip3 install lief==0.11.5\n-\n-  # Faketime for depends so intermediate results are comparable\n-  export PATH_orig=${PATH}\n-  create_global_faketime_wrappers \"2000-01-01 12:00:00\"\n-  create_per-host_faketime_wrappers \"2000-01-01 12:00:00\"\n-  create_per-host_compiler_wrapper \"2000-01-01 12:00:00\"\n-  export PATH=${WRAP_DIR}:${PATH}\n-\n-  cd bitcoin\n-  BASEPREFIX=\"${PWD}/depends\"\n-  # Build dependencies for each host\n-  for i in $HOSTS; do\n-    make ${MAKEOPTS} -C ${BASEPREFIX} HOST=\"${i}\"\n-  done\n-\n-  # Faketime for binaries\n-  export PATH=${PATH_orig}\n-  create_global_faketime_wrappers \"${REFERENCE_DATETIME}\"\n-  create_per-host_faketime_wrappers \"${REFERENCE_DATETIME}\"\n-  create_per-host_compiler_wrapper \"${REFERENCE_DATETIME}\"\n-  export PATH=${WRAP_DIR}:${PATH}\n-\n-  # Define DISTNAME variable.\n-  # shellcheck source=contrib/gitian-descriptors/assign_DISTNAME\n-  source contrib/gitian-descriptors/assign_DISTNAME\n-\n-  GIT_ARCHIVE=\"${OUTDIR}/src/${DISTNAME}.tar.gz\"\n-\n-  # Create the source tarball\n-  mkdir -p \"$(dirname \"$GIT_ARCHIVE\")\"\n-  git archive --prefix=\"${DISTNAME}/\" --output=\"$GIT_ARCHIVE\" HEAD\n-\n-  ORIGPATH=\"$PATH\"\n-  # Extract the git archive into a dir for each host and build\n-  for i in ${HOSTS}; do\n-    export PATH=${BASEPREFIX}/${i}/native/bin:${ORIGPATH}\n-    mkdir -p distsrc-${i}\n-    cd distsrc-${i}\n-    INSTALLPATH=\"${PWD}/installed/${DISTNAME}\"\n-    mkdir -p ${INSTALLPATH}\n-    tar --strip-components=1 -xf \"${GIT_ARCHIVE}\"\n-\n-    ./autogen.sh\n-    CONFIG_SITE=${BASEPREFIX}/${i}/share/config.site ./configure --prefix=/ --disable-ccache --disable-maintainer-mode --disable-dependency-tracking ${CONFIGFLAGS} CFLAGS=\"${HOST_CFLAGS}\" CXXFLAGS=\"${HOST_CXXFLAGS}\"\n-    make ${MAKEOPTS}\n-    make ${MAKEOPTS} -C src check-security\n-    make ${MAKEOPTS} -C src check-symbols\n-    make deploy BITCOIN_WIN_INSTALLER=\"${OUTDIR}/${DISTNAME}-win64-setup-unsigned.exe\"\n-    make install DESTDIR=${INSTALLPATH}\n-    cd installed\n-    mv ${DISTNAME}/bin/*.dll ${DISTNAME}/lib/\n-    find . -name \"lib*.la\" -delete\n-    find . -name \"lib*.a\" -delete\n-    rm -rf ${DISTNAME}/lib/pkgconfig\n-    find ${DISTNAME}/bin -type f -executable -print0 | xargs -0 -n1 -I{} ../contrib/devtools/split-debug.sh {} {} {}.dbg\n-    find ${DISTNAME}/lib -type f -print0 | xargs -0 -n1 -I{} ../contrib/devtools/split-debug.sh {} {} {}.dbg\n-    cp ../doc/README_windows.txt ${DISTNAME}/readme.txt\n-    find ${DISTNAME} -not -name \"*.dbg\"  -type f | sort | zip -X@ ${OUTDIR}/${DISTNAME}-${i//x86_64-w64-mingw32/win64}.zip\n-    find ${DISTNAME} -name \"*.dbg\"  -type f | sort | zip -X@ ${OUTDIR}/${DISTNAME}-${i//x86_64-w64-mingw32/win64}-debug.zip\n-    cd ../../\n-    rm -rf distsrc-${i}\n-  done\n-\n-  cp -rf contrib/windeploy $BUILD_DIR\n-  cd $BUILD_DIR/windeploy\n-  mkdir unsigned\n-  cp ${OUTDIR}/${DISTNAME}-win64-setup-unsigned.exe unsigned/\n-  find . | sort | tar --mtime=\"$REFERENCE_DATETIME\" --no-recursion --mode='u+rw,go+r-w,a+X' --owner=0 --group=0 -c -T - | gzip -9n > ${OUTDIR}/${DISTNAME}-win-unsigned.tar.gz"
      },
      {
        "sha": "40ae4b52084ef2235f12318b7ce1b2090a52bf1b",
        "filename": "contrib/guix/libexec/prelude.bash",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/contrib/guix/libexec/prelude.bash",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/contrib/guix/libexec/prelude.bash",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/guix/libexec/prelude.bash?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -49,7 +49,7 @@ fi\n # Set common variables\n ################\n \n-VERSION=\"${VERSION:-$(git_head_version)}\"\n+VERSION=\"${FORCE_VERSION:-$(git_head_version)}\"\n DISTNAME=\"${DISTNAME:-bitcoin-${VERSION}}\"\n \n version_base_prefix=\"${PWD}/guix-build-\""
      },
      {
        "sha": "a685aac1c04577a274a25a3285a9e5673b8dbaa1",
        "filename": "contrib/macdeploy/README.md",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/contrib/macdeploy/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/contrib/macdeploy/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/macdeploy/README.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -90,9 +90,9 @@ Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX.sdk\n \n See the SDK Extraction notes above for how to obtain it.\n \n-The Gitian descriptors build 2 sets of files: Linux tools, then Apple binaries which are\n+The Guix process build 2 sets of files: Linux tools, then Apple binaries which are\n created using these tools. The build process has been designed to avoid including the\n-SDK's files in Gitian's outputs. All interim tarballs are fully deterministic and may be freely\n+SDK's files in Guix's outputs. All interim tarballs are fully deterministic and may be freely\n redistributed.\n \n [`xorrisofs`](https://www.gnu.org/software/xorriso/) is used to create the DMG.\n@@ -113,11 +113,11 @@ order to satisfy the new Gatekeeper requirements. Because this private key canno\n shared, we'll have to be a bit creative in order for the build process to remain somewhat\n deterministic. Here's how it works:\n \n-- Builders use Gitian to create an unsigned release. This outputs an unsigned DMG which\n+- Builders use Guix to create an unsigned release. This outputs an unsigned DMG which\n   users may choose to bless and run. It also outputs an unsigned app structure in the form\n   of a tarball, which also contains all of the tools that have been previously (deterministically)\n   built in order to create a final DMG.\n - The Apple keyholder uses this unsigned app to create a detached signature, using the\n   script that is also included there. Detached signatures are available from this [repository](https://github.com/bitcoin-core/bitcoin-detached-sigs).\n-- Builders feed the unsigned app + detached signature back into Gitian. It uses the\n+- Builders feed the unsigned app + detached signature back into Guix. It uses the\n   pre-built tools to recombine the pieces into a deterministic DMG."
      },
      {
        "sha": "dc203f12549659ab03a23d24f0d054c24feae6ee",
        "filename": "contrib/signet/getcoins.py",
        "status": "modified",
        "additions": 42,
        "deletions": 10,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/contrib/signet/getcoins.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/contrib/signet/getcoins.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/contrib/signet/getcoins.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -5,32 +5,64 @@\n \n import argparse\n import subprocess\n-import requests\n import sys\n+import requests\n+\n+DEFAULT_GLOBAL_FAUCET = 'https://signetfaucet.com/claim'\n+GLOBAL_FIRST_BLOCK_HASH = '00000086d6b2636cb2a392d45edc4ec544a10024d30141c9adf4bfd9de533b53'\n \n parser = argparse.ArgumentParser(description='Script to get coins from a faucet.', epilog='You may need to start with double-dash (--) when providing bitcoin-cli arguments.')\n parser.add_argument('-c', '--cmd', dest='cmd', default='bitcoin-cli', help='bitcoin-cli command to use')\n-parser.add_argument('-f', '--faucet', dest='faucet', default='https://signetfaucet.com/claim', help='URL of the faucet')\n+parser.add_argument('-f', '--faucet', dest='faucet', default=DEFAULT_GLOBAL_FAUCET, help='URL of the faucet')\n parser.add_argument('-a', '--addr', dest='addr', default='', help='Bitcoin address to which the faucet should send')\n parser.add_argument('-p', '--password', dest='password', default='', help='Faucet password, if any')\n parser.add_argument('bitcoin_cli_args', nargs='*', help='Arguments to pass on to bitcoin-cli (default: -signet)')\n \n args = parser.parse_args()\n \n-if args.addr == '':\n-    if args.bitcoin_cli_args == []:\n-        args.bitcoin_cli_args = ['-signet']\n-    # get address for receiving coins\n+if args.bitcoin_cli_args == []:\n+    args.bitcoin_cli_args = ['-signet']\n+\n+\n+def bitcoin_cli(rpc_command_and_params):\n+    argv = [args.cmd] + args.bitcoin_cli_args + rpc_command_and_params\n     try:\n-        args.addr = subprocess.check_output([args.cmd] + args.bitcoin_cli_args + ['getnewaddress', 'faucet', 'bech32']).strip()\n+        return subprocess.check_output(argv).strip().decode()\n     except FileNotFoundError:\n         print('The binary', args.cmd, 'could not be found.')\n-        exit()\n+        exit(1)\n+    except subprocess.CalledProcessError:\n+        cmdline = ' '.join(argv)\n+        print(f'-----\\nError while calling \"{cmdline}\" (see output above).')\n+        exit(1)\n+\n+\n+if args.faucet.lower() == DEFAULT_GLOBAL_FAUCET:\n+    # Get the hash of the block at height 1 of the currently active signet chain\n+    curr_signet_hash = bitcoin_cli(['getblockhash', '1'])\n+    if curr_signet_hash != GLOBAL_FIRST_BLOCK_HASH:\n+        print('The global faucet cannot be used with a custom Signet network. Please use the global signet or setup your custom faucet to use this functionality.\\n')\n+        exit(1)\n+\n+if args.addr == '':\n+    # get address for receiving coins\n+    args.addr = bitcoin_cli(['getnewaddress', 'faucet', 'bech32'])\n \n data = {'address': args.addr, 'password': args.password}\n try:\n     res = requests.post(args.faucet, data=data)\n except:\n     print('Unexpected error when contacting faucet:', sys.exc_info()[0])\n-    exit()\n-print(res.text)\n+    exit(1)\n+\n+# Display the output as per the returned status code\n+if res:\n+    # When the return code is in between 200 and 400 i.e. successful\n+    print(res.text)\n+elif res.status_code == 404:\n+    print('The specified faucet URL does not exist. Please check for any server issues/typo.')\n+elif res.status_code == 429:\n+    print('The script does not allow for repeated transactions as the global faucet is rate-limitied to 1 request/IP/day. You can access the faucet website to get more coins manually')\n+else:\n+    print(f'Returned Error Code {res.status_code}\\n{res.text}\\n')\n+    print('Please check the provided arguments for their validity and/or any possible typo.')"
      },
      {
        "sha": "8a3116bb3bf47b9964e16923bed4830810159a36",
        "filename": "depends/packages/bdb.mk",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/depends/packages/bdb.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/depends/packages/bdb.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/bdb.mk?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -12,7 +12,7 @@ $(package)_config_opts_mingw32=--enable-mingw\n $(package)_config_opts_linux=--with-pic\n $(package)_config_opts_android=--with-pic\n $(package)_cflags+=-Wno-error=implicit-function-declaration\n-$(package)_cxxflags=-std=c++17\n+$(package)_cxxflags+=-std=c++17\n $(package)_cppflags_mingw32=-DUNICODE -D_UNICODE\n endef\n "
      },
      {
        "sha": "21df50b040156c3755be5503ab8e823d080a8eb2",
        "filename": "depends/packages/boost.mk",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/depends/packages/boost.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/depends/packages/boost.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/boost.mk?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -23,7 +23,7 @@ else\n $(package)_toolset_$(host_os)=gcc\n endif\n $(package)_config_libraries=filesystem,system,test\n-$(package)_cxxflags=-std=c++17 -fvisibility=hidden\n+$(package)_cxxflags+=-std=c++17 -fvisibility=hidden\n $(package)_cxxflags_linux=-fPIC\n $(package)_cxxflags_android=-fPIC\n $(package)_cxxflags_x86_64_darwin=-fcf-protection=full"
      },
      {
        "sha": "9798248c6174230e6b141446a099d36c0a597635",
        "filename": "depends/packages/zeromq.mk",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/depends/packages/zeromq.mk",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/depends/packages/zeromq.mk",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/depends/packages/zeromq.mk?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -12,7 +12,7 @@ define $(package)_set_vars\n   $(package)_config_opts += --disable-Werror --disable-drafts --enable-option-checking\n   $(package)_config_opts_linux=--with-pic\n   $(package)_config_opts_android=--with-pic\n-  $(package)_cxxflags=-std=c++17\n+  $(package)_cxxflags+=-std=c++17\n endef\n \n define $(package)_preprocess_cmds"
      },
      {
        "sha": "aabfe220bcfdf6bd46a73ad0d8acf3de25835990",
        "filename": "doc/README.md",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/doc/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/doc/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/README.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -46,7 +46,6 @@ The following are developer notes on how to build Bitcoin Core on your native pl\n - [OpenBSD Build Notes](build-openbsd.md)\n - [NetBSD Build Notes](build-netbsd.md)\n - [Android Build Notes](build-android.md)\n-- [Gitian Building Guide (External Link)](https://github.com/bitcoin-core/docs/blob/master/gitian-building.md)\n \n Development\n ---------------------"
      },
      {
        "sha": "02c36eea7c13d5d584d94ad97188d930e4e2718e",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 9,
        "deletions": 1,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -122,6 +122,10 @@ To build with Qt 5 you need the following:\n \n     sudo apt-get install libqt5gui5 libqt5core5a libqt5dbus5 qttools5-dev qttools5-dev-tools\n \n+Additionally, to support Wayland protocol for modern desktop environments:\n+\n+    sudo apt install qtwayland5\n+\n libqrencode (optional) can be installed with:\n \n     sudo apt-get install libqrencode-dev\n@@ -181,6 +185,10 @@ To build with Qt 5 you need the following:\n \n     sudo dnf install qt5-qttools-devel qt5-qtbase-devel\n \n+Additionally, to support Wayland protocol for modern desktop environments:\n+\n+    sudo dnf install qt5-qtwayland\n+\n libqrencode (optional) can be installed with:\n \n     sudo dnf install qrencode-devel\n@@ -340,7 +348,7 @@ To build executables for ARM:\n     make HOST=arm-linux-gnueabihf NO_QT=1\n     cd ..\n     ./autogen.sh\n-    CONFIG_SITE=$PWD/depends/arm-linux-gnueabihf/share/config.site ./configure --enable-glibc-back-compat --enable-reduce-exports LDFLAGS=-static-libstdc++\n+    CONFIG_SITE=$PWD/depends/arm-linux-gnueabihf/share/config.site ./configure --enable-reduce-exports LDFLAGS=-static-libstdc++\n     make\n \n "
      },
      {
        "sha": "abdbeee3ce9004face14453303d09bc020a790c3",
        "filename": "doc/dependencies.md",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/doc/dependencies.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/doc/dependencies.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/dependencies.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -12,6 +12,7 @@ These are the dependencies currently used by Bitcoin Core. You can find instruct\n | fontconfig | [2.12.1](https://www.freedesktop.org/software/fontconfig/release/) |  | No | Yes |  |\n | FreeType | [2.7.1](https://download.savannah.gnu.org/releases/freetype) |  | No |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk) (Android only) |\n | GCC |  | [7+](https://gcc.gnu.org/) (C++17 support) |  |  |  |\n+| glibc | | [2.17](https://www.gnu.org/software/libc/) |  |  |  |  |\n | HarfBuzz-NG |  |  |  |  | [Yes](https://github.com/bitcoin/bitcoin/blob/master/depends/packages/qt.mk) |\n | libevent | [2.1.12-stable](https://github.com/libevent/libevent/releases) | [2.0.21](https://github.com/bitcoin/bitcoin/pull/18676) | No |  |  |\n | libnatpmp | git commit [4536032...](https://github.com/miniupnp/libnatpmp/tree/4536032ae32268a45c073a4d5e91bbab4534773a) |  | No |  |  |"
      },
      {
        "sha": "3bbb626a422ed1e0f96d315d75331421fd153ede",
        "filename": "doc/descriptors.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/doc/descriptors.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/doc/descriptors.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/descriptors.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -99,7 +99,7 @@ Descriptors consist of several types of expressions. The top level expression is\n `ADDR` expressions are any type of supported address:\n - P2PKH addresses (base58, of the form `1...` for mainnet or `[nm]...` for testnet). Note that P2PKH addresses in descriptors cannot be used for P2PK outputs (use the `pk` function instead).\n - P2SH addresses (base58, of the form `3...` for mainnet or `2...` for testnet, defined in [BIP 13](https://github.com/bitcoin/bips/blob/master/bip-0013.mediawiki)).\n-- Segwit addresses (bech32, of the form `bc1...` for mainnet or `tb1...` for testnet, defined in [BIP 173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki)).\n+- Segwit addresses (bech32 and bech32m, of the form `bc1...` for mainnet or `tb1...` for testnet, defined in [BIP 173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki) and [BIP 350](https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki)).\n \n ## Explanation\n "
      },
      {
        "sha": "3e13adeec09799e7b64db2d40a846b7565a44d5d",
        "filename": "doc/developer-notes.md",
        "status": "modified",
        "additions": 12,
        "deletions": 8,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/doc/developer-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/doc/developer-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/developer-notes.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -89,6 +89,10 @@ code.\n     - Class member variables have a `m_` prefix.\n     - Global variables have a `g_` prefix.\n   - Constant names are all uppercase, and use `_` to separate words.\n+  - Enumerator constants may be `snake_case`, `PascalCase` or `ALL_CAPS`.\n+    This is a more tolerant policy than the [C++ Core\n+    Guidelines](https://isocpp.github.io/CppCoreGuidelines/CppCoreGuidelines#Renum-caps),\n+    which recommend using `snake_case`.  Please use what seems appropriate.\n   - Class names, function names, and method names are UpperCamelCase\n     (PascalCase). Do not prefix class names with `C`.\n   - Test suite naming convention: The Boost test suite in file\n@@ -669,19 +673,19 @@ Foo(vec);\n \n ```cpp\n enum class Tabs {\n-    INFO,\n-    CONSOLE,\n-    GRAPH,\n-    PEERS\n+    info,\n+    console,\n+    network_graph,\n+    peers\n };\n \n int GetInt(Tabs tab)\n {\n     switch (tab) {\n-    case Tabs::INFO: return 0;\n-    case Tabs::CONSOLE: return 1;\n-    case Tabs::GRAPH: return 2;\n-    case Tabs::PEERS: return 3;\n+    case Tabs::info: return 0;\n+    case Tabs::console: return 1;\n+    case Tabs::network_graph: return 2;\n+    case Tabs::peers: return 3;\n     } // no default case, so the compiler can warn about missing cases\n     assert(false);\n }"
      },
      {
        "sha": "ee9c65d4d498d00c374b1d1cad95f6712c12636c",
        "filename": "doc/fuzzing.md",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/doc/fuzzing.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/doc/fuzzing.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/fuzzing.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -16,6 +16,9 @@ $ FUZZ=process_message src/test/fuzz/fuzz\n # abort fuzzing using ctrl-c\n ```\n \n+There is also a runner script to execute all fuzz targets. Refer to\n+`./test/fuzz/test_runner.py --help` for more details.\n+\n ## Fuzzing harnesses and output\n \n [`process_message`](https://github.com/bitcoin/bitcoin/blob/master/src/test/fuzz/process_message.cpp) is a fuzzing harness for the [`ProcessMessage(...)` function (`net_processing`)](https://github.com/bitcoin/bitcoin/blob/master/src/net_processing.cpp). The available fuzzing harnesses are found in [`src/test/fuzz/`](https://github.com/bitcoin/bitcoin/tree/master/src/test/fuzz)."
      },
      {
        "sha": "3a48f4a0b397770e44f51477df854f8298ce1b75",
        "filename": "doc/gitian-building.md",
        "status": "removed",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/243a352d63078b8eacba0c64f991bc359c9ff1f7/doc/gitian-building.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/243a352d63078b8eacba0c64f991bc359c9ff1f7/doc/gitian-building.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/gitian-building.md?ref=243a352d63078b8eacba0c64f991bc359c9ff1f7",
        "patch": "@@ -1,4 +0,0 @@\n-Gitian building\n-================\n-\n-This file was moved to [the Bitcoin Core documentation repository](https://github.com/bitcoin-core/docs/blob/master/gitian-building.md) at [https://github.com/bitcoin-core/docs](https://github.com/bitcoin-core/docs)."
      },
      {
        "sha": "5f631c11ca2409a11e2445b793a149fba6eed2a2",
        "filename": "doc/i2p.md",
        "status": "modified",
        "additions": 39,
        "deletions": 13,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/doc/i2p.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/doc/i2p.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/i2p.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -10,11 +10,22 @@ started with I2P terminology.\n ## Run Bitcoin Core with an I2P router (proxy)\n \n A running I2P router (proxy) with [SAM](https://geti2p.net/en/docs/api/samv3)\n-enabled is required (there is an [official one](https://geti2p.net) and\n-[a few alternatives](https://en.wikipedia.org/wiki/I2P#Routers)). Notice the IP\n-address and port the SAM proxy is listening to; usually, it is\n-`127.0.0.1:7656`. Once it is up and running with SAM enabled, use the following\n-Bitcoin Core options:\n+enabled is required. Options include:\n+\n+- [i2prouter (I2P Router)](https://geti2p.net), the official implementation in\n+  Java\n+- [i2pd (I2P Daemon)](https://github.com/PurpleI2P/i2pd)\n+  ([documentation](https://i2pd.readthedocs.io/en/latest)), a lighter\n+  alternative in C++ (successfully tested with version 2.23 and up; version 2.36\n+  or later recommended)\n+- [i2p-zero](https://github.com/i2p-zero/i2p-zero)\n+- [other alternatives](https://en.wikipedia.org/wiki/I2P#Routers)\n+\n+Note the IP address and port the SAM proxy is listening to; usually, it is\n+`127.0.0.1:7656`.\n+\n+Once an I2P router with SAM enabled is up and running, use the following Bitcoin\n+Core configuration options:\n \n ```\n -i2psam=<ip:port>\n@@ -42,15 +53,30 @@ named `i2p_private_key` in the Bitcoin Core data directory.\n \n ## Additional configuration options related to I2P\n \n-You may set the `debug=i2p` config logging option to have additional\n-information in the debug log about your I2P configuration and connections. Run\n-`bitcoin-cli help logging` for more information.\n+```\n+-debug=i2p\n+```\n+\n+Set the `debug=i2p` config logging option to see additional information in the\n+debug log about your I2P configuration and connections. Run `bitcoin-cli help\n+logging` for more information.\n+\n+```\n+-onlynet=i2p\n+```\n+\n+Make outgoing connections only to I2P addresses. Incoming connections are not\n+affected by this option. It can be specified multiple times to allow multiple\n+network types, e.g. onlynet=ipv4, onlynet=ipv6, onlynet=onion, onlynet=i2p.\n+\n+Warning: if you use -onlynet with values other than onion, and the -onion or\n+-proxy option is set, then outgoing onion connections will still be made; use\n+-noonion or -onion=0 to disable outbound onion connections in this case.\n \n-It is possible to restrict outgoing connections in the usual way with\n-`onlynet=i2p`. I2P support was added to Bitcoin Core in version 22.0 (mid-2021)\n-and there may be fewer I2P peers than Tor or IP ones. Therefore, using\n-`onlynet=i2p` alone (without other `onlynet=`) may make a node more susceptible\n-to [Sybil attacks](https://en.bitcoin.it/wiki/Weaknesses#Sybil_attack). Use\n+I2P support was added to Bitcoin Core in version 22.0 and there may be fewer I2P\n+peers than Tor or IP ones. Therefore, using I2P alone without other networks may\n+make a node more susceptible to [Sybil\n+attacks](https://en.bitcoin.it/wiki/Weaknesses#Sybil_attack). You can use\n `bitcoin-cli -addrinfo` to see the number of I2P addresses known to your node.\n \n Another consideration with `onlynet=i2p` is that the initial blocks download"
      },
      {
        "sha": "a8de76c0786b1926bab29dfa8f99d56db7c4976b",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -91,6 +91,10 @@ Tools and Utilities\n \n - Update `-getinfo` to return data in a user-friendly format that also reduces vertical space. (#21832)\n \n+- CLI `-addrinfo` now returns a single field for the number of `onion` addresses\n+  known to the node instead of separate `torv2` and `torv3` fields, as support\n+  for Tor V2 addresses was removed from Bitcoin Core in 22.0. (#22544)\n+\n Wallet\n ------\n \n@@ -112,6 +116,7 @@ Tests\n   changed.\n   * BIP 34 (blockheight in coinbase) from 500 to 2 (#16333)\n   * BIP 66 (DERSIG) from 1251 to 102 (#22632)\n+  * BIP 65 (CLTV) from 1351 to 111 (#21862)\n \n Credits\n ======="
      },
      {
        "sha": "972c91aa6fafad60b1f6125aae58cadc32307cfb",
        "filename": "doc/release-notes/release-notes-22.0.md",
        "status": "added",
        "additions": 1163,
        "deletions": 0,
        "changes": 1163,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/doc/release-notes/release-notes-22.0.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/doc/release-notes/release-notes-22.0.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes/release-notes-22.0.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -0,0 +1,1163 @@\n+22.0 Release Notes\n+==================\n+\n+Bitcoin Core version 22.0 is now available from:\n+\n+  <https://bitcoincore.org/bin/bitcoin-core-22.0/>\n+\n+This release includes new features, various bug fixes and performance\n+improvements, as well as updated translations.\n+\n+Please report bugs using the issue tracker at GitHub:\n+\n+  <https://github.com/bitcoin/bitcoin/issues>\n+\n+To receive security and update notifications, please subscribe to:\n+\n+  <https://bitcoincore.org/en/list/announcements/join/>\n+\n+How to Upgrade\n+==============\n+\n+If you are running an older version, shut it down. Wait until it has completely\n+shut down (which might take a few minutes in some cases), then run the\n+installer (on Windows) or just copy over `/Applications/Bitcoin-Qt` (on Mac)\n+or `bitcoind`/`bitcoin-qt` (on Linux).\n+\n+Upgrading directly from a version of Bitcoin Core that has reached its EOL is\n+possible, but it might take some time if the data directory needs to be migrated. Old\n+wallet versions of Bitcoin Core are generally supported.\n+\n+Compatibility\n+==============\n+\n+Bitcoin Core is supported and extensively tested on operating systems\n+using the Linux kernel, macOS 10.14+, and Windows 7 and newer.  Bitcoin\n+Core should also work on most other Unix-like systems but is not as\n+frequently tested on them.  It is not recommended to use Bitcoin Core on\n+unsupported systems.\n+\n+From Bitcoin Core 22.0 onwards, macOS versions earlier than 10.14 are no longer supported.\n+\n+Notable changes\n+===============\n+\n+P2P and network changes\n+-----------------------\n+- Added support for running Bitcoin Core as an\n+  [I2P (Invisible Internet Project)](https://en.wikipedia.org/wiki/I2P) service\n+  and connect to such services. See [i2p.md](https://github.com/bitcoin/bitcoin/blob/22.x/doc/i2p.md) for details. (#20685)\n+- This release removes support for Tor version 2 hidden services in favor of Tor\n+  v3 only, as the Tor network [dropped support for Tor\n+  v2](https://blog.torproject.org/v2-deprecation-timeline) with the release of\n+  Tor version 0.4.6.  Henceforth, Bitcoin Core ignores Tor v2 addresses; it\n+  neither rumors them over the network to other peers, nor stores them in memory\n+  or to `peers.dat`.  (#22050)\n+\n+- Added NAT-PMP port mapping support via\n+  [`libnatpmp`](https://miniupnp.tuxfamily.org/libnatpmp.html). (#18077)\n+\n+New and Updated RPCs\n+--------------------\n+\n+- Due to [BIP 350](https://github.com/bitcoin/bips/blob/master/bip-0350.mediawiki)\n+  being implemented, behavior for all RPCs that accept addresses is changed when\n+  a native witness version 1 (or higher) is passed. These now require a Bech32m\n+  encoding instead of a Bech32 one, and Bech32m encoding will be used for such\n+  addresses in RPC output as well. No version 1 addresses should be created\n+  for mainnet until consensus rules are adopted that give them meaning\n+  (as will happen through [BIP 341](https://github.com/bitcoin/bips/blob/master/bip-0341.mediawiki)).\n+  Once that happens, Bech32m is expected to be used for them, so this shouldn't\n+  affect any production systems, but may be observed on other networks where such\n+  addresses already have meaning (like signet). (#20861)\n+\n+- The `getpeerinfo` RPC returns two new boolean fields, `bip152_hb_to` and\n+  `bip152_hb_from`, that respectively indicate whether we selected a peer to be\n+  in compact blocks high-bandwidth mode or whether a peer selected us as a\n+  compact blocks high-bandwidth peer. High-bandwidth peers send new block\n+  announcements via a `cmpctblock` message rather than the usual inv/headers\n+  announcements. See BIP 152 for more details. (#19776)\n+\n+- `getpeerinfo` no longer returns the following fields: `addnode`, `banscore`,\n+  and `whitelisted`, which were previously deprecated in 0.21. Instead of\n+  `addnode`, the `connection_type` field returns manual. Instead of\n+  `whitelisted`, the `permissions` field indicates if the peer has special\n+  privileges. The `banscore` field has simply been removed. (#20755)\n+\n+- The following RPCs:  `gettxout`, `getrawtransaction`, `decoderawtransaction`,\n+  `decodescript`, `gettransaction`, and REST endpoints: `/rest/tx`,\n+  `/rest/getutxos`, `/rest/block` deprecated the following fields (which are no\n+  longer returned in the responses by default): `addresses`, `reqSigs`.\n+  The `-deprecatedrpc=addresses` flag must be passed for these fields to be\n+  included in the RPC response. This flag/option will be available only for this major release, after which\n+  the deprecation will be removed entirely. Note that these fields are attributes of\n+  the `scriptPubKey` object returned in the RPC response. However, in the response\n+  of `decodescript` these fields are top-level attributes, and included again as attributes\n+  of the `scriptPubKey` object. (#20286)\n+\n+- When creating a hex-encoded bitcoin transaction using the `bitcoin-tx` utility\n+  with the `-json` option set, the following fields: `addresses`, `reqSigs` are no longer\n+  returned in the tx output of the response. (#20286)\n+\n+- The `listbanned` RPC now returns two new numeric fields: `ban_duration` and `time_remaining`.\n+  Respectively, these new fields indicate the duration of a ban and the time remaining until a ban expires,\n+  both in seconds. Additionally, the `ban_created` field is repositioned to come before `banned_until`. (#21602)\n+\n+- The `setban` RPC can ban onion addresses again. This fixes a regression introduced in version 0.21.0. (#20852)\n+\n+- The `getnodeaddresses` RPC now returns a \"network\" field indicating the\n+  network type (ipv4, ipv6, onion, or i2p) for each address.  (#21594)\n+\n+- `getnodeaddresses` now also accepts a \"network\" argument (ipv4, ipv6, onion,\n+  or i2p) to return only addresses of the specified network.  (#21843)\n+\n+- The `testmempoolaccept` RPC now accepts multiple transactions (still experimental at the moment,\n+  API may be unstable). This is intended for testing transaction packages with dependency\n+  relationships; it is not recommended for batch-validating independent transactions. In addition to\n+  mempool policy, package policies apply: the list cannot contain more than 25 transactions or have a\n+  total size exceeding 101K virtual bytes, and cannot conflict with (spend the same inputs as) each other or\n+  the mempool, even if it would be a valid BIP125 replace-by-fee. There are some known limitations to\n+  the accuracy of the test accept: it's possible for `testmempoolaccept` to return \"allowed\"=True for a\n+  group of transactions, but \"too-long-mempool-chain\" if they are actually submitted. (#20833)\n+\n+- `addmultisigaddress` and `createmultisig` now support up to 20 keys for\n+  Segwit addresses. (#20867)\n+\n+Changes to Wallet or GUI related RPCs can be found in the GUI or Wallet section below.\n+\n+Build System\n+------------\n+\n+- Release binaries are now produced using the new `guix`-based build system.\n+  The [/doc/release-process.md](/doc/release-process.md) document has been updated accordingly.\n+\n+Files\n+-----\n+\n+- The list of banned hosts and networks (via `setban` RPC) is now saved on disk\n+  in JSON format in `banlist.json` instead of `banlist.dat`. `banlist.dat` is\n+  only read on startup if `banlist.json` is not present. Changes are only written to the new\n+  `banlist.json`. A future version of Bitcoin Core may completely ignore\n+  `banlist.dat`. (#20966)\n+\n+New settings\n+------------\n+\n+- The `-natpmp` option has been added to use NAT-PMP to map the listening port.\n+  If both UPnP and NAT-PMP are enabled, a successful allocation from UPnP\n+  prevails over one from NAT-PMP. (#18077)\n+\n+Updated settings\n+----------------\n+\n+Changes to Wallet or GUI related settings can be found in the GUI or Wallet section below.\n+\n+- Passing an invalid `-rpcauth` argument now cause bitcoind to fail to start.  (#20461)\n+\n+Tools and Utilities\n+-------------------\n+\n+- A new CLI `-addrinfo` command returns the number of addresses known to the\n+  node per network type (including Tor v2 versus v3) and total. This can be\n+  useful to see if the node knows enough addresses in a network to use options\n+  like `-onlynet=<network>` or to upgrade to this release of Bitcoin Core 22.0\n+  that supports Tor v3 only.  (#21595)\n+\n+- A new `-rpcwaittimeout` argument to `bitcoin-cli` sets the timeout\n+  in seconds to use with `-rpcwait`. If the timeout expires,\n+  `bitcoin-cli` will report a failure. (#21056)\n+\n+Wallet\n+------\n+\n+- External signers such as hardware wallets can now be used through the new RPC methods `enumeratesigners` and `displayaddress`. Support is also added to the `send` RPC call. This feature is experimental. See [external-signer.md](https://github.com/bitcoin/bitcoin/blob/22.x/doc/external-signer.md) for details. (#16546)\n+\n+- A new `listdescriptors` RPC is available to inspect the contents of descriptor-enabled wallets.\n+  The RPC returns public versions of all imported descriptors, including their timestamp and flags.\n+  For ranged descriptors, it also returns the range boundaries and the next index to generate addresses from. (#20226)\n+\n+- The `bumpfee` RPC is not available with wallets that have private keys\n+  disabled. `psbtbumpfee` can be used instead. (#20891)\n+\n+- The `fundrawtransaction`, `send` and `walletcreatefundedpsbt` RPCs now support an `include_unsafe` option\n+  that when `true` allows using unsafe inputs to fund the transaction.\n+  Note that the resulting transaction may become invalid if one of the unsafe inputs disappears.\n+  If that happens, the transaction must be funded with different inputs and republished. (#21359)\n+\n+- We now support up to 20 keys in `multi()` and `sortedmulti()` descriptors\n+  under `wsh()`. (#20867)\n+\n+- Taproot descriptors can be imported into the wallet only after activation has occurred on the network (e.g. mainnet, testnet, signet) in use. See [descriptors.md](https://github.com/bitcoin/bitcoin/blob/22.x/doc/descriptors.md) for supported descriptors.\n+\n+GUI changes\n+-----------\n+\n+- External signers such as hardware wallets can now be used. These require an external tool such as [HWI](https://github.com/bitcoin-core/HWI) to be installed and configured under Options -> Wallet. When creating a new wallet a new option \"External signer\" will appear in the dialog. If the device is detected, its name is suggested as the wallet name. The watch-only keys are then automatically imported. Receive addresses can be verified on the device. The send dialog will automatically use the connected device. This feature is experimental and the UI may freeze for a few seconds when performing these actions.\n+\n+Low-level changes\n+=================\n+\n+RPC\n+---\n+\n+- The RPC server can process a limited number of simultaneous RPC requests.\n+  Previously, if this limit was exceeded, the RPC server would respond with\n+  [status code 500 (`HTTP_INTERNAL_SERVER_ERROR`)](https://en.wikipedia.org/wiki/List_of_HTTP_status_codes#5xx_server_errors).\n+  Now it returns status code 503 (`HTTP_SERVICE_UNAVAILABLE`). (#18335)\n+\n+- Error codes have been updated to be more accurate for the following error cases (#18466):\n+  - `signmessage` now returns RPC_INVALID_ADDRESS_OR_KEY (-5) if the\n+    passed address is invalid. Previously returned RPC_TYPE_ERROR (-3).\n+  - `verifymessage` now returns RPC_INVALID_ADDRESS_OR_KEY (-5) if the\n+    passed address is invalid. Previously returned RPC_TYPE_ERROR (-3).\n+  - `verifymessage` now returns RPC_TYPE_ERROR (-3) if the passed signature\n+    is malformed. Previously returned RPC_INVALID_ADDRESS_OR_KEY (-5).\n+\n+Tests\n+-----\n+\n+22.0 change log\n+===============\n+\n+A detailed list of changes in this version follows. To keep the list to a manageable length, small refactors and typo fixes are not included, and similar changes are sometimes condensed into one line.\n+\n+### Consensus\n+- bitcoin/bitcoin#19438 Introduce deploymentstatus (ajtowns)\n+- bitcoin/bitcoin#20207 Follow-up extra comments on taproot code and tests (sipa)\n+- bitcoin/bitcoin#21330 Deal with missing data in signature hashes more consistently (sipa)\n+\n+### Policy\n+- bitcoin/bitcoin#18766 Disable fee estimation in blocksonly mode (by removing the fee estimates global) (darosior)\n+- bitcoin/bitcoin#20497 Add `MAX_STANDARD_SCRIPTSIG_SIZE` to policy (sanket1729)\n+- bitcoin/bitcoin#20611 Move `TX_MAX_STANDARD_VERSION` to policy (MarcoFalke)\n+\n+### Mining\n+- bitcoin/bitcoin#19937, bitcoin/bitcoin#20923 Signet mining utility (ajtowns)\n+\n+### Block and transaction handling\n+- bitcoin/bitcoin#14501 Fix possible data race when committing block files (luke-jr)\n+- bitcoin/bitcoin#15946 Allow maintaining the blockfilterindex when using prune (jonasschnelli)\n+- bitcoin/bitcoin#18710 Add local thread pool to CCheckQueue (hebasto)\n+- bitcoin/bitcoin#19521 Coinstats Index (fjahr)\n+- bitcoin/bitcoin#19806 UTXO snapshot activation (jamesob)\n+- bitcoin/bitcoin#19905 Remove dead CheckForkWarningConditionsOnNewFork (MarcoFalke)\n+- bitcoin/bitcoin#19935 Move SaltedHashers to separate file and add some new ones (achow101)\n+- bitcoin/bitcoin#20054 Remove confusing and useless \"unexpected version\" warning (MarcoFalke)\n+- bitcoin/bitcoin#20519 Handle rename failure in `DumpMempool(\u2026)` by using the `RenameOver(\u2026)` return value (practicalswift)\n+- bitcoin/bitcoin#20749, bitcoin/bitcoin#20750, bitcoin/bitcoin#21055, bitcoin/bitcoin#21270, bitcoin/bitcoin#21525, bitcoin/bitcoin#21391, bitcoin/bitcoin#21767, bitcoin/bitcoin#21866 Prune `g_chainman` usage (dongcarl)\n+- bitcoin/bitcoin#20833 rpc/validation: enable packages through testmempoolaccept (glozow)\n+- bitcoin/bitcoin#20834 Locks and docs in ATMP and CheckInputsFromMempoolAndCache (glozow)\n+- bitcoin/bitcoin#20854 Remove unnecessary try-block (amitiuttarwar)\n+- bitcoin/bitcoin#20868 Remove redundant check on pindex (jarolrod)\n+- bitcoin/bitcoin#20921 Don't try to invalidate genesis block in CChainState::InvalidateBlock (theStack)\n+- bitcoin/bitcoin#20972 Locks: Annotate CTxMemPool::check to require `cs_main` (dongcarl)\n+- bitcoin/bitcoin#21009 Remove RewindBlockIndex logic (dhruv)\n+- bitcoin/bitcoin#21025 Guard chainman chainstates with `cs_main` (dongcarl)\n+- bitcoin/bitcoin#21202 Two small clang lock annotation improvements (amitiuttarwar)\n+- bitcoin/bitcoin#21523 Run VerifyDB on all chainstates (jamesob)\n+- bitcoin/bitcoin#21573 Update libsecp256k1 subtree to latest master (sipa)\n+- bitcoin/bitcoin#21582, bitcoin/bitcoin#21584, bitcoin/bitcoin#21585 Fix assumeutxo crashes (MarcoFalke)\n+- bitcoin/bitcoin#21681 Fix ActivateSnapshot to use hardcoded nChainTx (jamesob)\n+- bitcoin/bitcoin#21796 index: Avoid async shutdown on init error (MarcoFalke)\n+- bitcoin/bitcoin#21946 Document and test lack of inherited signaling in RBF policy (ariard)\n+- bitcoin/bitcoin#22084 Package testmempoolaccept followups (glozow)\n+- bitcoin/bitcoin#22102 Remove `Warning:` from warning message printed for unknown new rules (prayank23)\n+- bitcoin/bitcoin#22112 Force port 0 in I2P (vasild)\n+- bitcoin/bitcoin#22135 CRegTestParams: Use `args` instead of `gArgs` (kiminuo)\n+- bitcoin/bitcoin#22146 Reject invalid coin height and output index when loading assumeutxo (MarcoFalke)\n+- bitcoin/bitcoin#22253 Distinguish between same tx and same-nonwitness-data tx in mempool (glozow)\n+- bitcoin/bitcoin#22261 Two small fixes to node broadcast logic (jnewbery)\n+- bitcoin/bitcoin#22415 Make `m_mempool` optional in CChainState (jamesob)\n+- bitcoin/bitcoin#22499 Update assumed chain params (sriramdvt)\n+- bitcoin/bitcoin#22589 net, doc: update I2P hardcoded seeds and docs for 22.0 (jonatack)\n+\n+### P2P protocol and network code\n+- bitcoin/bitcoin#18077 Add NAT-PMP port forwarding support (hebasto)\n+- bitcoin/bitcoin#18722 addrman: improve performance by using more suitable containers (vasild)\n+- bitcoin/bitcoin#18819 Replace `cs_feeFilter` with simple std::atomic (MarcoFalke)\n+- bitcoin/bitcoin#19203 Add regression fuzz harness for CVE-2017-18350. Add FuzzedSocket (practicalswift)\n+- bitcoin/bitcoin#19288 fuzz: Add fuzzing harness for TorController (practicalswift)\n+- bitcoin/bitcoin#19415 Make DNS lookup mockable, add fuzzing harness (practicalswift)\n+- bitcoin/bitcoin#19509 Per-Peer Message Capture (troygiorshev)\n+- bitcoin/bitcoin#19763 Don't try to relay to the address' originator (vasild)\n+- bitcoin/bitcoin#19771 Replace enum CConnMan::NumConnections with enum class ConnectionDirection (luke-jr)\n+- bitcoin/bitcoin#19776 net, rpc: expose high bandwidth mode state via getpeerinfo (theStack)\n+- bitcoin/bitcoin#19832 Put disconnecting logs into BCLog::NET category (hebasto)\n+- bitcoin/bitcoin#19858 Periodically make block-relay connections and sync headers (sdaftuar)\n+- bitcoin/bitcoin#19884 No delay in adding fixed seeds if -dnsseed=0 and peers.dat is empty (dhruv)\n+- bitcoin/bitcoin#20079 Treat handshake misbehavior like unknown message (MarcoFalke)\n+- bitcoin/bitcoin#20138 Assume that SetCommonVersion is called at most once per peer (MarcoFalke)\n+- bitcoin/bitcoin#20162 p2p: declare Announcement::m_state as uint8_t, add getter/setter (jonatack)\n+- bitcoin/bitcoin#20197 Protect onions in AttemptToEvictConnection(), add eviction protection test coverage (jonatack)\n+- bitcoin/bitcoin#20210 assert `CNode::m_inbound_onion` is inbound in ctor, add getter, unit tests (jonatack)\n+- bitcoin/bitcoin#20228 addrman: Make addrman a top-level component (jnewbery)\n+- bitcoin/bitcoin#20234 Don't bind on 0.0.0.0 if binds are restricted to Tor (vasild)\n+- bitcoin/bitcoin#20477 Add unit testing of node eviction logic (practicalswift)\n+- bitcoin/bitcoin#20516 Well-defined CAddress disk serialization, and addrv2 anchors.dat (sipa)\n+- bitcoin/bitcoin#20557 addrman: Fix new table bucketing during unserialization (jnewbery)\n+- bitcoin/bitcoin#20561 Periodically clear `m_addr_known` (sdaftuar)\n+- bitcoin/bitcoin#20599 net processing: Tolerate sendheaders and sendcmpct messages before verack (jnewbery)\n+- bitcoin/bitcoin#20616 Check CJDNS address is valid (lontivero)\n+- bitcoin/bitcoin#20617 Remove `m_is_manual_connection` from CNodeState (ariard)\n+- bitcoin/bitcoin#20624 net processing: Remove nStartingHeight check from block relay (jnewbery)\n+- bitcoin/bitcoin#20651 Make p2p recv buffer timeout 20 minutes for all peers (jnewbery)\n+- bitcoin/bitcoin#20661 Only select from addrv2-capable peers for torv3 address relay (sipa)\n+- bitcoin/bitcoin#20685 Add I2P support using I2P SAM (vasild)\n+- bitcoin/bitcoin#20690 Clean up logging of outbound connection type (sdaftuar)\n+- bitcoin/bitcoin#20721 Move ping data to `net_processing` (jnewbery)\n+- bitcoin/bitcoin#20724 Cleanup of -debug=net log messages (ajtowns)\n+- bitcoin/bitcoin#20747 net processing: Remove dropmessagestest (jnewbery)\n+- bitcoin/bitcoin#20764 cli -netinfo peer connections dashboard updates \ud83c\udf84 \u2728 (jonatack)\n+- bitcoin/bitcoin#20788 add RAII socket and use it instead of bare SOCKET (vasild)\n+- bitcoin/bitcoin#20791 remove unused legacyWhitelisted in AcceptConnection() (jonatack)\n+- bitcoin/bitcoin#20816 Move RecordBytesSent() call out of `cs_vSend` lock (jnewbery)\n+- bitcoin/bitcoin#20845 Log to net debug in MaybeDiscourageAndDisconnect except for noban and manual peers (MarcoFalke)\n+- bitcoin/bitcoin#20864 Move SocketSendData lock annotation to header (MarcoFalke)\n+- bitcoin/bitcoin#20965 net, rpc:  return `NET_UNROUTABLE` as `not_publicly_routable`, automate helps (jonatack)\n+- bitcoin/bitcoin#20966 banman: save the banlist in a JSON format on disk (vasild)\n+- bitcoin/bitcoin#21015 Make all of `net_processing` (and some of net) use std::chrono types (dhruv)\n+- bitcoin/bitcoin#21029 bitcoin-cli: Correct docs (no \"generatenewaddress\" exists) (luke-jr)\n+- bitcoin/bitcoin#21148 Split orphan handling from `net_processing` into txorphanage (ajtowns)\n+- bitcoin/bitcoin#21162 Net Processing: Move RelayTransaction() into PeerManager (jnewbery)\n+- bitcoin/bitcoin#21167 make `CNode::m_inbound_onion` public, initialize explicitly (jonatack)\n+- bitcoin/bitcoin#21186 net/net processing: Move addr data into `net_processing` (jnewbery)\n+- bitcoin/bitcoin#21187 Net processing: Only call PushAddress() from `net_processing` (jnewbery)\n+- bitcoin/bitcoin#21198 Address outstanding review comments from PR20721 (jnewbery)\n+- bitcoin/bitcoin#21222 log: Clarify log message when file does not exist (MarcoFalke)\n+- bitcoin/bitcoin#21235 Clarify disconnect log message in ProcessGetBlockData, remove send bool (MarcoFalke)\n+- bitcoin/bitcoin#21236 Net processing: Extract `addr` send functionality into MaybeSendAddr() (jnewbery)\n+- bitcoin/bitcoin#21261 update inbound eviction protection for multiple networks, add I2P peers (jonatack)\n+- bitcoin/bitcoin#21328 net, refactor: pass uint16 CService::port as uint16 (jonatack)\n+- bitcoin/bitcoin#21387 Refactor sock to add I2P fuzz and unit tests (vasild)\n+- bitcoin/bitcoin#21395 Net processing: Remove unused CNodeState.address member (jnewbery)\n+- bitcoin/bitcoin#21407 i2p: limit the size of incoming messages (vasild)\n+- bitcoin/bitcoin#21506 p2p, refactor: make NetPermissionFlags an enum class (jonatack)\n+- bitcoin/bitcoin#21509 Don't send FEEFILTER in blocksonly mode (mzumsande)\n+- bitcoin/bitcoin#21560 Add Tor v3 hardcoded seeds (laanwj)\n+- bitcoin/bitcoin#21563 Restrict period when `cs_vNodes` mutex is locked (hebasto)\n+- bitcoin/bitcoin#21564 Avoid calling getnameinfo when formatting IPv4 addresses in CNetAddr::ToStringIP (practicalswift)\n+- bitcoin/bitcoin#21631 i2p: always check the return value of Sock::Wait() (vasild)\n+- bitcoin/bitcoin#21644 p2p, bugfix: use NetPermissions::HasFlag() in CConnman::Bind() (jonatack)\n+- bitcoin/bitcoin#21659 flag relevant Sock methods with [[nodiscard]] (vasild)\n+- bitcoin/bitcoin#21750 remove unnecessary check of `CNode::cs_vSend` (vasild)\n+- bitcoin/bitcoin#21756 Avoid calling `getnameinfo` when formatting IPv6 addresses in `CNetAddr::ToStringIP` (practicalswift)\n+- bitcoin/bitcoin#21775 Limit `m_block_inv_mutex` (MarcoFalke)\n+- bitcoin/bitcoin#21825 Add I2P hardcoded seeds (jonatack)\n+- bitcoin/bitcoin#21843 p2p, rpc: enable GetAddr, GetAddresses, and getnodeaddresses by network (jonatack)\n+- bitcoin/bitcoin#21845 net processing: Don't require locking `cs_main` before calling RelayTransactions() (jnewbery)\n+- bitcoin/bitcoin#21872 Sanitize message type for logging (laanwj)\n+- bitcoin/bitcoin#21914 Use stronger AddLocal() for our I2P address (vasild)\n+- bitcoin/bitcoin#21985 Return IPv6 scope id in `CNetAddr::ToStringIP()` (laanwj)\n+- bitcoin/bitcoin#21992 Remove -feefilter option (amadeuszpawlik)\n+- bitcoin/bitcoin#21996 Pass strings to NetPermissions::TryParse functions by const ref (jonatack)\n+- bitcoin/bitcoin#22013 ignore block-relay-only peers when skipping DNS seed (ajtowns)\n+- bitcoin/bitcoin#22050 Remove tor v2 support (jonatack)\n+- bitcoin/bitcoin#22096 AddrFetch - don't disconnect on self-announcements (mzumsande)\n+- bitcoin/bitcoin#22141 net processing: Remove hash and fValidatedHeaders from QueuedBlock (jnewbery)\n+- bitcoin/bitcoin#22144 Randomize message processing peer order (sipa)\n+- bitcoin/bitcoin#22147 Protect last outbound HB compact block peer (sdaftuar)\n+- bitcoin/bitcoin#22179 Torv2 removal followups (vasild)\n+- bitcoin/bitcoin#22211 Relay I2P addresses even if not reachable (by us) (vasild)\n+- bitcoin/bitcoin#22284 Performance improvements to ProtectEvictionCandidatesByRatio() (jonatack)\n+- bitcoin/bitcoin#22387 Rate limit the processing of rumoured addresses (sipa)\n+- bitcoin/bitcoin#22455 addrman: detect on-disk corrupted nNew and nTried during unserialization (vasild)\n+\n+### Wallet\n+- bitcoin/bitcoin#15710 Catch `ios_base::failure` specifically (Bushstar)\n+- bitcoin/bitcoin#16546 External signer support - Wallet Box edition (Sjors)\n+- bitcoin/bitcoin#17331 Use effective values throughout coin selection (achow101)\n+- bitcoin/bitcoin#18418 Increase `OUTPUT_GROUP_MAX_ENTRIES` to 100 (fjahr)\n+- bitcoin/bitcoin#18842 Mark replaced tx to not be in the mempool anymore (MarcoFalke)\n+- bitcoin/bitcoin#19136 Add `parent_desc` to `getaddressinfo` (achow101)\n+- bitcoin/bitcoin#19137 wallettool: Add dump and createfromdump commands (achow101)\n+- bitcoin/bitcoin#19651 `importdescriptor`s update existing (S3RK)\n+- bitcoin/bitcoin#20040 Refactor OutputGroups to handle fees and spending eligibility on grouping (achow101)\n+- bitcoin/bitcoin#20202 Make BDB support optional (achow101)\n+- bitcoin/bitcoin#20226, bitcoin/bitcoin#21277, - bitcoin/bitcoin#21063 Add `listdescriptors` command (S3RK)\n+- bitcoin/bitcoin#20267 Disable and fix tests for when BDB is not compiled (achow101)\n+- bitcoin/bitcoin#20275 List all wallets in non-SQLite and non-BDB builds (ryanofsky)\n+- bitcoin/bitcoin#20365 wallettool: Add parameter to create descriptors wallet (S3RK)\n+- bitcoin/bitcoin#20403 `upgradewallet` fixes, improvements, test coverage (jonatack)\n+- bitcoin/bitcoin#20448 `unloadwallet`: Allow specifying `wallet_name` param matching RPC endpoint wallet (luke-jr)\n+- bitcoin/bitcoin#20536 Error with \"Transaction too large\" if the funded tx will end up being too large after signing (achow101)\n+- bitcoin/bitcoin#20687 Add missing check for -descriptors wallet tool option (MarcoFalke)\n+- bitcoin/bitcoin#20952 Add BerkeleyDB version sanity check at init time (laanwj)\n+- bitcoin/bitcoin#21127 Load flags before everything else (Sjors)\n+- bitcoin/bitcoin#21141 Add new format string placeholders for walletnotify (maayank)\n+- bitcoin/bitcoin#21238 A few descriptor improvements to prepare for Taproot support (sipa)\n+- bitcoin/bitcoin#21302 `createwallet` examples for descriptor wallets (S3RK)\n+- bitcoin/bitcoin#21329 descriptor wallet: Cache last hardened xpub and use in normalized descriptors (achow101)\n+- bitcoin/bitcoin#21365 Basic Taproot signing support for descriptor wallets (sipa)\n+- bitcoin/bitcoin#21417 Misc external signer improvement and HWI 2 support (Sjors)\n+- bitcoin/bitcoin#21467 Move external signer out of wallet module (Sjors)\n+- bitcoin/bitcoin#21572 Fix wrong wallet RPC context set after #21366 (ryanofsky)\n+- bitcoin/bitcoin#21574 Drop JSONRPCRequest constructors after #21366 (ryanofsky)\n+- bitcoin/bitcoin#21666 Miscellaneous external signer changes (fanquake)\n+- bitcoin/bitcoin#21759 Document coin selection code (glozow)\n+- bitcoin/bitcoin#21786 Ensure sat/vB feerates are in range (mantissa of 3) (jonatack)\n+- bitcoin/bitcoin#21944 Fix issues when `walletdir` is root directory (prayank23)\n+- bitcoin/bitcoin#22042 Replace size/weight estimate tuple with struct for named fields (instagibbs)\n+- bitcoin/bitcoin#22051 Basic Taproot derivation support for descriptors (sipa)\n+- bitcoin/bitcoin#22154 Add OutputType::BECH32M and related wallet support for fetching bech32m addresses (achow101)\n+- bitcoin/bitcoin#22156 Allow tr() import only when Taproot is active (achow101)\n+- bitcoin/bitcoin#22166 Add support for inferring tr() descriptors (sipa)\n+- bitcoin/bitcoin#22173 Do not load external signers wallets when unsupported (achow101)\n+- bitcoin/bitcoin#22308 Add missing BlockUntilSyncedToCurrentChain (MarcoFalke)\n+- bitcoin/bitcoin#22334 Do not spam about non-existent spk managers (S3RK)\n+- bitcoin/bitcoin#22379 Erase spkmans rather than setting to nullptr (achow101)\n+- bitcoin/bitcoin#22421 Make IsSegWitOutput return true for taproot outputs (sipa)\n+- bitcoin/bitcoin#22461 Change ScriptPubKeyMan::Upgrade default to True (achow101)\n+- bitcoin/bitcoin#22492 Reorder locks in dumpwallet to avoid lock order assertion (achow101)\n+- bitcoin/bitcoin#22686 Use GetSelectionAmount in ApproximateBestSubset (achow101)\n+\n+### RPC and other APIs\n+- bitcoin/bitcoin#18335, bitcoin/bitcoin#21484 cli: Print useful error if bitcoind rpc work queue exceeded (LarryRuane)\n+- bitcoin/bitcoin#18466 Fix invalid parameter error codes for `{sign,verify}message` RPCs (theStack)\n+- bitcoin/bitcoin#18772 Calculate fees in `getblock` using BlockUndo data (robot-visions)\n+- bitcoin/bitcoin#19033 http: Release work queue after event base finish (promag)\n+- bitcoin/bitcoin#19055 Add MuHash3072 implementation (fjahr)\n+- bitcoin/bitcoin#19145 Add `hash_type` MUHASH for gettxoutsetinfo (fjahr)\n+- bitcoin/bitcoin#19847 Avoid duplicate set lookup in `gettxoutproof` (promag)\n+- bitcoin/bitcoin#20286 Deprecate `addresses` and `reqSigs` from RPC outputs (mjdietzx)\n+- bitcoin/bitcoin#20459 Fail to return undocumented return values (MarcoFalke)\n+- bitcoin/bitcoin#20461 Validate `-rpcauth` arguments (promag)\n+- bitcoin/bitcoin#20556 Properly document return values (`submitblock`, `gettxout`, `getblocktemplate`, `scantxoutset`) (MarcoFalke)\n+- bitcoin/bitcoin#20755 Remove deprecated fields from `getpeerinfo` (amitiuttarwar)\n+- bitcoin/bitcoin#20832 Better error messages for invalid addresses (eilx2)\n+- bitcoin/bitcoin#20867 Support up to 20 keys for multisig under Segwit context (darosior)\n+- bitcoin/bitcoin#20877 cli: `-netinfo` user help and argument parsing improvements (jonatack)\n+- bitcoin/bitcoin#20891 Remove deprecated bumpfee behavior (achow101)\n+- bitcoin/bitcoin#20916 Return wtxid from `testmempoolaccept` (MarcoFalke)\n+- bitcoin/bitcoin#20917 Add missing signet mentions in network name lists (theStack)\n+- bitcoin/bitcoin#20941 Document `RPC_TRANSACTION_ALREADY_IN_CHAIN` exception (jarolrod)\n+- bitcoin/bitcoin#20944 Return total fee in `getmempoolinfo` (MarcoFalke)\n+- bitcoin/bitcoin#20964 Add specific error code for \"wallet already loaded\" (laanwj)\n+- bitcoin/bitcoin#21053 Document {previous,next}blockhash as optional (theStack)\n+- bitcoin/bitcoin#21056 Add a `-rpcwaittimeout` parameter to limit time spent waiting (cdecker)\n+- bitcoin/bitcoin#21192 cli: Treat high detail levels as maximum in `-netinfo` (laanwj)\n+- bitcoin/bitcoin#21311 Document optional fields for `getchaintxstats` result (theStack)\n+- bitcoin/bitcoin#21359 `include_unsafe` option for fundrawtransaction (t-bast)\n+- bitcoin/bitcoin#21426 Remove `scantxoutset` EXPERIMENTAL warning (jonatack)\n+- bitcoin/bitcoin#21544 Missing doc updates for bumpfee psbt update (MarcoFalke)\n+- bitcoin/bitcoin#21594 Add `network` field to `getnodeaddresses` (jonatack)\n+- bitcoin/bitcoin#21595, bitcoin/bitcoin#21753 cli: Create `-addrinfo` (jonatack)\n+- bitcoin/bitcoin#21602 Add additional ban time fields to `listbanned` (jarolrod)\n+- bitcoin/bitcoin#21679 Keep default argument value in correct type (promag)\n+- bitcoin/bitcoin#21718 Improve error message for `getblock` invalid datatype (klementtan)\n+- bitcoin/bitcoin#21913 RPCHelpMan fixes (kallewoof)\n+- bitcoin/bitcoin#22021 `bumpfee`/`psbtbumpfee` fixes and updates (jonatack)\n+- bitcoin/bitcoin#22043 `addpeeraddress` test coverage, code simplify/constness (jonatack)\n+- bitcoin/bitcoin#22327 cli: Avoid truncating `-rpcwaittimeout` (MarcoFalke)\n+\n+### GUI\n+- bitcoin/bitcoin#18948 Call setParent() in the parent's context (hebasto)\n+- bitcoin/bitcoin#20482 Add depends qt fix for ARM macs (jonasschnelli)\n+- bitcoin/bitcoin#21836 scripted-diff: Replace three dots with ellipsis in the ui strings (hebasto)\n+- bitcoin/bitcoin#21935 Enable external signer support for GUI builds (Sjors)\n+- bitcoin/bitcoin#22133 Make QWindowsVistaStylePlugin available again (regression) (hebasto)\n+- bitcoin-core/gui#4 UI external signer support (e.g. hardware wallet) (Sjors)\n+- bitcoin-core/gui#13 Hide peer detail view if multiple are selected (promag)\n+- bitcoin-core/gui#18 Add peertablesortproxy module (hebasto)\n+- bitcoin-core/gui#21 Improve pruning tooltip (fluffypony, BitcoinErrorLog)\n+- bitcoin-core/gui#72 Log static plugins meta data and used style (hebasto)\n+- bitcoin-core/gui#79 Embed monospaced font (hebasto)\n+- bitcoin-core/gui#85 Remove unused \"What's This\" button in dialogs on Windows OS (hebasto)\n+- bitcoin-core/gui#115 Replace \"Hide tray icon\" option with positive \"Show tray icon\" one (hebasto)\n+- bitcoin-core/gui#118 Remove BDB version from the Information tab (hebasto)\n+- bitcoin-core/gui#121 Early subscribe core signals in transaction table model (promag)\n+- bitcoin-core/gui#123 Do not accept command while executing another one (hebasto)\n+- bitcoin-core/gui#125 Enable changing the autoprune block space size in intro dialog (luke-jr)\n+- bitcoin-core/gui#138 Unlock encrypted wallet \"OK\" button bugfix (mjdietzx)\n+- bitcoin-core/gui#139 doc: Improve gui/src/qt README.md (jarolrod)\n+- bitcoin-core/gui#154 Support macOS Dark mode (goums, Uplab)\n+- bitcoin-core/gui#162 Add network to peers window and peer details (jonatack)\n+- bitcoin-core/gui#163, bitcoin-core/gui#180 Peer details: replace Direction with Connection Type (jonatack)\n+- bitcoin-core/gui#164 Handle peer addition/removal in a right way (hebasto)\n+- bitcoin-core/gui#165 Save QSplitter state in QSettings (hebasto)\n+- bitcoin-core/gui#173 Follow Qt docs when implementing rowCount and columnCount (hebasto)\n+- bitcoin-core/gui#179 Add Type column to peers window, update peer details name/tooltip (jonatack)\n+- bitcoin-core/gui#186 Add information to \"Confirm fee bump\" window (prayank23)\n+- bitcoin-core/gui#189 Drop workaround for QTBUG-42503 which was fixed in Qt 5.5.0 (prusnak)\n+- bitcoin-core/gui#194 Save/restore RPCConsole geometry only for window (hebasto)\n+- bitcoin-core/gui#202 Fix right panel toggle in peers tab (RandyMcMillan)\n+- bitcoin-core/gui#203 Display plain \"Inbound\" in peer details (jonatack)\n+- bitcoin-core/gui#204 Drop buggy TableViewLastColumnResizingFixer class (hebasto)\n+- bitcoin-core/gui#205, bitcoin-core/gui#229 Save/restore TransactionView and recentRequestsView tables column sizes (hebasto)\n+- bitcoin-core/gui#206 Display fRelayTxes and `bip152_highbandwidth_{to, from}` in peer details (jonatack)\n+- bitcoin-core/gui#213 Add Copy Address Action to Payment Requests (jarolrod)\n+- bitcoin-core/gui#214 Disable requests context menu actions when appropriate (jarolrod)\n+- bitcoin-core/gui#217 Make warning label look clickable (jarolrod)\n+- bitcoin-core/gui#219 Prevent the main window popup menu (hebasto)\n+- bitcoin-core/gui#220 Do not translate file extensions (hebasto)\n+- bitcoin-core/gui#221 RPCConsole translatable string fixes and improvements (jonatack)\n+- bitcoin-core/gui#226 Add \"Last Block\" and \"Last Tx\" rows to peer details area (jonatack)\n+- bitcoin-core/gui#233 qt test: Don't bind to regtest port (achow101)\n+- bitcoin-core/gui#243 Fix issue when disabling the auto-enabled blank wallet checkbox (jarolrod)\n+- bitcoin-core/gui#246 Revert \"qt: Use \"fusion\" style on macOS Big Sur with old Qt\" (hebasto)\n+- bitcoin-core/gui#248 For values of \"Bytes transferred\" and \"Bytes/s\" with 1000-based prefix names use 1000-based divisor instead of 1024-based (wodry)\n+- bitcoin-core/gui#251 Improve URI/file handling message (hebasto)\n+- bitcoin-core/gui#256 Save/restore column sizes of the tables in the Peers tab (hebasto)\n+- bitcoin-core/gui#260 Handle exceptions isntead of crash (hebasto)\n+- bitcoin-core/gui#263 Revamp context menus (hebasto)\n+- bitcoin-core/gui#271 Don't clear console prompt when font resizing (jarolrod)\n+- bitcoin-core/gui#275 Support runtime appearance adjustment on macOS (hebasto)\n+- bitcoin-core/gui#276 Elide long strings in their middle in the Peers tab (hebasto)\n+- bitcoin-core/gui#281 Set shortcuts for console's resize buttons (jarolrod)\n+- bitcoin-core/gui#293 Enable wordWrap for Services (RandyMcMillan)\n+- bitcoin-core/gui#296 Do not use QObject::tr plural syntax for numbers with a unit symbol (hebasto)\n+- bitcoin-core/gui#297 Avoid unnecessary translations (hebasto)\n+- bitcoin-core/gui#298 Peertableview alternating row colors (RandyMcMillan)\n+- bitcoin-core/gui#300 Remove progress bar on modal overlay (brunoerg)\n+- bitcoin-core/gui#309 Add access to the Peers tab from the network icon (hebasto)\n+- bitcoin-core/gui#311 Peers Window rename 'Peer id' to 'Peer' (jarolrod)\n+- bitcoin-core/gui#313 Optimize string concatenation by default (hebasto)\n+- bitcoin-core/gui#325 Align numbers in the \"Peer Id\" column to the right (hebasto)\n+- bitcoin-core/gui#329 Make console buttons look clickable (jarolrod)\n+- bitcoin-core/gui#330 Allow prompt icon to be colorized (jarolrod)\n+- bitcoin-core/gui#331 Make RPC console welcome message translation-friendly (hebasto)\n+- bitcoin-core/gui#332 Replace disambiguation strings with translator comments (hebasto)\n+- bitcoin-core/gui#335 test: Use QSignalSpy instead of QEventLoop (jarolrod)\n+- bitcoin-core/gui#343 Improve the GUI responsiveness when progress dialogs are used (hebasto)\n+- bitcoin-core/gui#361 Fix GUI segfault caused by bitcoin/bitcoin#22216 (ryanofsky)\n+- bitcoin-core/gui#362 Add keyboard shortcuts to context menus (luke-jr)\n+- bitcoin-core/gui#366 Dark Mode fixes/portability (luke-jr)\n+- bitcoin-core/gui#375 Emit dataChanged signal to dynamically re-sort Peers table (hebasto)\n+- bitcoin-core/gui#393 Fix regression in \"Encrypt Wallet\" menu item (hebasto)\n+- bitcoin-core/gui#396 Ensure external signer option remains disabled without signers (achow101)\n+- bitcoin-core/gui#406 Handle new added plurals in `bitcoin_en.ts` (hebasto)\n+\n+### Build system\n+- bitcoin/bitcoin#17227 Add Android packaging support (icota)\n+- bitcoin/bitcoin#17920 guix: Build support for macOS (dongcarl)\n+- bitcoin/bitcoin#18298 Fix Qt processing of configure script for depends with DEBUG=1 (hebasto)\n+- bitcoin/bitcoin#19160 multiprocess: Add basic spawn and IPC support (ryanofsky)\n+- bitcoin/bitcoin#19504 Bump minimum python version to 3.6 (ajtowns)\n+- bitcoin/bitcoin#19522 fix building libconsensus with reduced exports for Darwin targets (fanquake)\n+- bitcoin/bitcoin#19683 Pin clang search paths for darwin host (dongcarl)\n+- bitcoin/bitcoin#19764 Split boost into build/host packages + bump + cleanup (dongcarl)\n+- bitcoin/bitcoin#19817 libtapi 1100.0.11 (fanquake)\n+- bitcoin/bitcoin#19846 enable unused member function diagnostic (Zero-1729)\n+- bitcoin/bitcoin#19867 Document and cleanup Qt hacks (fanquake)\n+- bitcoin/bitcoin#20046 Set `CMAKE_INSTALL_RPATH` for native packages (ryanofsky)\n+- bitcoin/bitcoin#20223 Drop the leading 0 from the version number (achow101)\n+- bitcoin/bitcoin#20333 Remove `native_biplist` dependency (fanquake)\n+- bitcoin/bitcoin#20353 configure: Support -fdebug-prefix-map and -fmacro-prefix-map (ajtowns)\n+- bitcoin/bitcoin#20359 Various config.site.in improvements and linting (dongcarl)\n+- bitcoin/bitcoin#20413 Require C++17 compiler (MarcoFalke)\n+- bitcoin/bitcoin#20419 Set minimum supported macOS to 10.14 (fanquake)\n+- bitcoin/bitcoin#20421 miniupnpc 2.2.2 (fanquake)\n+- bitcoin/bitcoin#20422 Mac deployment unification (fanquake)\n+- bitcoin/bitcoin#20424 Update univalue subtree (MarcoFalke)\n+- bitcoin/bitcoin#20449 Fix Windows installer build (achow101)\n+- bitcoin/bitcoin#20468 Warn when generating man pages for binaries built from a dirty branch (tylerchambers)\n+- bitcoin/bitcoin#20469 Avoid secp256k1.h include from system (dergoegge)\n+- bitcoin/bitcoin#20470 Replace genisoimage with xorriso (dongcarl)\n+- bitcoin/bitcoin#20471 Use C++17 in depends (fanquake)\n+- bitcoin/bitcoin#20496 Drop unneeded macOS framework dependencies (hebasto)\n+- bitcoin/bitcoin#20520 Do not force Precompiled Headers (PCH) for building Qt on Linux (hebasto)\n+- bitcoin/bitcoin#20549 Support make src/bitcoin-node and src/bitcoin-gui (promag)\n+- bitcoin/bitcoin#20565 Ensure PIC build for bdb on Android (BlockMechanic)\n+- bitcoin/bitcoin#20594 Fix getauxval calls in randomenv.cpp (jonasschnelli)\n+- bitcoin/bitcoin#20603 Update crc32c subtree (MarcoFalke)\n+- bitcoin/bitcoin#20609 configure: output notice that test binary is disabled by fuzzing (apoelstra)\n+- bitcoin/bitcoin#20619 guix: Quality of life improvements (dongcarl)\n+- bitcoin/bitcoin#20629 Improve id string robustness (dongcarl)\n+- bitcoin/bitcoin#20641 Use Qt top-level build facilities (hebasto)\n+- bitcoin/bitcoin#20650 Drop workaround for a fixed bug in Qt build system (hebasto)\n+- bitcoin/bitcoin#20673 Use more legible qmake commands in qt package (hebasto)\n+- bitcoin/bitcoin#20684 Define .INTERMEDIATE target once only (hebasto)\n+- bitcoin/bitcoin#20720 more robustly check for fcf-protection support (fanquake)\n+- bitcoin/bitcoin#20734 Make platform-specific targets available for proper platform builds only (hebasto)\n+- bitcoin/bitcoin#20936 build fuzz tests by default (danben)\n+- bitcoin/bitcoin#20937 guix: Make nsis reproducible by respecting SOURCE-DATE-EPOCH (dongcarl)\n+- bitcoin/bitcoin#20938 fix linking against -latomic when building for riscv (fanquake)\n+- bitcoin/bitcoin#20939 fix `RELOC_SECTION` security check for bitcoin-util (fanquake)\n+- bitcoin/bitcoin#20963 gitian-linux: Build binaries for 64-bit POWER (continued) (laanwj)\n+- bitcoin/bitcoin#21036 gitian: Bump descriptors to focal for 22.0 (fanquake)\n+- bitcoin/bitcoin#21045 Adds switch to enable/disable randomized base address in MSVC builds (EthanHeilman)\n+- bitcoin/bitcoin#21065 make macOS HOST in download-osx generic (fanquake)\n+- bitcoin/bitcoin#21078 guix: only download sources for hosts being built (fanquake)\n+- bitcoin/bitcoin#21116 Disable --disable-fuzz-binary for gitian/guix builds (hebasto)\n+- bitcoin/bitcoin#21182 remove mostly pointless `BOOST_PROCESS` macro (fanquake)\n+- bitcoin/bitcoin#21205 actually fail when Boost is missing (fanquake)\n+- bitcoin/bitcoin#21209 use newer source for libnatpmp (fanquake)\n+- bitcoin/bitcoin#21226 Fix fuzz binary compilation under windows (danben)\n+- bitcoin/bitcoin#21231 Add /opt/homebrew to path to look for boost libraries (fyquah)\n+- bitcoin/bitcoin#21239 guix: Add codesignature attachment support for osx+win (dongcarl)\n+- bitcoin/bitcoin#21250 Make `HAVE_O_CLOEXEC` available outside LevelDB (bugfix) (theStack)\n+- bitcoin/bitcoin#21272 guix: Passthrough `SDK_PATH` into container (dongcarl)\n+- bitcoin/bitcoin#21274 assumptions:  Assume C++17 (fanquake)\n+- bitcoin/bitcoin#21286 Bump minimum Qt version to 5.9.5 (hebasto)\n+- bitcoin/bitcoin#21298 guix: Bump time-machine, glibc, and linux-headers (dongcarl)\n+- bitcoin/bitcoin#21304 guix: Add guix-clean script + establish gc-root for container profiles (dongcarl)\n+- bitcoin/bitcoin#21320 fix libnatpmp macos cross compile (fanquake)\n+- bitcoin/bitcoin#21321 guix: Add curl to required tool list (hebasto)\n+- bitcoin/bitcoin#21333 set Unicode true for NSIS installer (fanquake)\n+- bitcoin/bitcoin#21339 Make `AM_CONDITIONAL([ENABLE_EXTERNAL_SIGNER])` unconditional (hebasto)\n+- bitcoin/bitcoin#21349 Fix fuzz-cuckoocache cross-compiling with DEBUG=1 (hebasto)\n+- bitcoin/bitcoin#21354 build, doc: Drop no longer required packages from macOS cross-compiling dependencies (hebasto)\n+- bitcoin/bitcoin#21363 build, qt: Improve Qt static plugins/libs check code (hebasto)\n+- bitcoin/bitcoin#21375 guix: Misc feedback-based fixes + hier restructuring (dongcarl)\n+- bitcoin/bitcoin#21376 Qt 5.12.10 (fanquake)\n+- bitcoin/bitcoin#21382 Clean remnants of QTBUG-34748 fix (hebasto)\n+- bitcoin/bitcoin#21400 Fix regression introduced in #21363 (hebasto)\n+- bitcoin/bitcoin#21403 set --build when configuring packages in depends (fanquake)\n+- bitcoin/bitcoin#21421 don't try and use -fstack-clash-protection on Windows (fanquake)\n+- bitcoin/bitcoin#21423 Cleanups and follow ups after bumping Qt to 5.12.10 (hebasto)\n+- bitcoin/bitcoin#21427 Fix `id_string` invocations (dongcarl)\n+- bitcoin/bitcoin#21430 Add -Werror=implicit-fallthrough compile flag (hebasto)\n+- bitcoin/bitcoin#21457 Split libtapi and clang out of `native_cctools` (fanquake)\n+- bitcoin/bitcoin#21462 guix: Add guix-{attest,verify} scripts (dongcarl)\n+- bitcoin/bitcoin#21495 build, qt: Fix static builds on macOS Big Sur (hebasto)\n+- bitcoin/bitcoin#21497 Do not opt-in unused CoreWLAN stuff in depends for macOS (hebasto)\n+- bitcoin/bitcoin#21543 Enable safe warnings for msvc builds (hebasto)\n+- bitcoin/bitcoin#21565 Make `bitcoin_qt.m4` more generic (fanquake)\n+- bitcoin/bitcoin#21610 remove -Wdeprecated-register from NOWARN flags (fanquake)\n+- bitcoin/bitcoin#21613 enable -Wdocumentation (fanquake)\n+- bitcoin/bitcoin#21629 Fix configuring when building depends with `NO_BDB=1` (fanquake)\n+- bitcoin/bitcoin#21654 build, qt: Make Qt rcc output always deterministic (hebasto)\n+- bitcoin/bitcoin#21655 build, qt: No longer need to set `QT_RCC_TEST=1` for determinism (hebasto)\n+- bitcoin/bitcoin#21658 fix make deploy for arm64-darwin (sgulls)\n+- bitcoin/bitcoin#21694 Use XLIFF file to provide more context to Transifex translators (hebasto)\n+- bitcoin/bitcoin#21708, bitcoin/bitcoin#21593 Drop pointless sed commands (hebasto)\n+- bitcoin/bitcoin#21731 Update msvc build to use Qt5.12.10 binaries (sipsorcery)\n+- bitcoin/bitcoin#21733 Re-add command to install vcpkg (dplusplus1024)\n+- bitcoin/bitcoin#21793 Use `-isysroot` over `--sysroot` on macOS (fanquake)\n+- bitcoin/bitcoin#21869 Add missing `-D_LIBCPP_DEBUG=1` to debug flags (MarcoFalke)\n+- bitcoin/bitcoin#21889 macho: check for control flow instrumentation (fanquake)\n+- bitcoin/bitcoin#21920 Improve macro for testing -latomic requirement (MarcoFalke)\n+- bitcoin/bitcoin#21991 libevent 2.1.12-stable (fanquake)\n+- bitcoin/bitcoin#22054 Bump Qt version to 5.12.11 (hebasto)\n+- bitcoin/bitcoin#22063 Use Qt archive of the same version as the compiled binaries (hebasto)\n+- bitcoin/bitcoin#22070 Don't use cf-protection when targeting arm-apple-darwin (fanquake)\n+- bitcoin/bitcoin#22071 Latest config.guess and config.sub (fanquake)\n+- bitcoin/bitcoin#22075 guix: Misc leftover usability improvements (dongcarl)\n+- bitcoin/bitcoin#22123 Fix qt.mk for mac arm64 (promag)\n+- bitcoin/bitcoin#22174 build, qt: Fix libraries linking order for Linux hosts (hebasto)\n+- bitcoin/bitcoin#22182 guix: Overhaul how guix-{attest,verify} works and hierarchy (dongcarl)\n+- bitcoin/bitcoin#22186 build, qt: Fix compiling qt package in depends with GCC 11 (hebasto)\n+- bitcoin/bitcoin#22199 macdeploy: minor fixups and simplifications (fanquake)\n+- bitcoin/bitcoin#22230 Fix MSVC linker /SubSystem option for bitcoin-qt.exe (hebasto)\n+- bitcoin/bitcoin#22234 Mark print-% target as phony (dgoncharov)\n+- bitcoin/bitcoin#22238 improve detection of eBPF support (fanquake)\n+- bitcoin/bitcoin#22258 Disable deprecated-copy warning only when external warnings are enabled (MarcoFalke)\n+- bitcoin/bitcoin#22320 set minimum required Boost to 1.64.0 (fanquake)\n+- bitcoin/bitcoin#22348 Fix cross build for Windows with Boost Process (hebasto)\n+- bitcoin/bitcoin#22365 guix: Avoid relying on newer symbols by rebasing our cross toolchains on older glibcs (dongcarl)\n+- bitcoin/bitcoin#22381 guix: Test security-check sanity before performing them (with macOS) (fanquake)\n+- bitcoin/bitcoin#22405 Remove --enable-glibc-back-compat from Guix build (fanquake)\n+- bitcoin/bitcoin#22406 Remove --enable-determinism configure option (fanquake)\n+- bitcoin/bitcoin#22410 Avoid GCC 7.1 ABI change warning in guix build (sipa)\n+- bitcoin/bitcoin#22436 use aarch64 Clang if cross-compiling for darwin on aarch64 (fanquake)\n+- bitcoin/bitcoin#22465 guix: Pin kernel-header version, time-machine to upstream 1.3.0 commit (dongcarl)\n+- bitcoin/bitcoin#22511 guix: Silence `getent(1)` invocation, doc fixups (dongcarl)\n+- bitcoin/bitcoin#22531 guix: Fixes to guix-{attest,verify} (achow101)\n+- bitcoin/bitcoin#22642 release: Release with separate sha256sums and sig files (dongcarl)\n+- bitcoin/bitcoin#22685 clientversion: No suffix `#if CLIENT_VERSION_IS_RELEASE` (dongcarl)\n+- bitcoin/bitcoin#22713 Fix build with Boost 1.77.0 (sizeofvoid)\n+\n+### Tests and QA\n+- bitcoin/bitcoin#14604 Add test and refactor `feature_block.py` (sanket1729)\n+- bitcoin/bitcoin#17556 Change `feature_config_args.py` not to rely on strange regtest=0 behavior (ryanofsky)\n+- bitcoin/bitcoin#18795 wallet issue with orphaned rewards (domob1812)\n+- bitcoin/bitcoin#18847 compressor: Use a prevector in CompressScript serialization (jb55)\n+- bitcoin/bitcoin#19259 fuzz: Add fuzzing harness for LoadMempool(\u2026) and DumpMempool(\u2026) (practicalswift)\n+- bitcoin/bitcoin#19315 Allow outbound & block-relay-only connections in functional tests. (amitiuttarwar)\n+- bitcoin/bitcoin#19698 Apply strict verification flags for transaction tests and assert backwards compatibility (glozow)\n+- bitcoin/bitcoin#19801 Check for all possible `OP_CLTV` fail reasons in `feature_cltv.py` (BIP 65) (theStack)\n+- bitcoin/bitcoin#19893 Remove or explain syncwithvalidationinterfacequeue (MarcoFalke)\n+- bitcoin/bitcoin#19972 fuzz: Add fuzzing harness for node eviction logic (practicalswift)\n+- bitcoin/bitcoin#19982 Fix inconsistent lock order in `wallet_tests/CreateWallet` (hebasto)\n+- bitcoin/bitcoin#20000 Fix creation of \"std::string\"s with \\0s (vasild)\n+- bitcoin/bitcoin#20047 Use `wait_for_{block,header}` helpers in `p2p_fingerprint.py` (theStack)\n+- bitcoin/bitcoin#20171 Add functional test `test_txid_inv_delay` (ariard)\n+- bitcoin/bitcoin#20189 Switch to BIP341's suggested scheme for outputs without script (sipa)\n+- bitcoin/bitcoin#20248 Fix length of R check in `key_signature_tests` (dgpv)\n+- bitcoin/bitcoin#20276, bitcoin/bitcoin#20385, bitcoin/bitcoin#20688, bitcoin/bitcoin#20692 Run various mempool tests even with wallet disabled (mjdietzx)\n+- bitcoin/bitcoin#20323 Create or use existing properly initialized NodeContexts (dongcarl)\n+- bitcoin/bitcoin#20354 Add `feature_taproot.py --previous_release` (MarcoFalke)\n+- bitcoin/bitcoin#20370 fuzz: Version handshake (MarcoFalke)\n+- bitcoin/bitcoin#20377 fuzz: Fill various small fuzzing gaps (practicalswift)\n+- bitcoin/bitcoin#20425 fuzz: Make CAddrMan fuzzing harness deterministic (practicalswift)\n+- bitcoin/bitcoin#20430 Sanitizers: Add suppression for unsigned-integer-overflow in libstdc++ (jonasschnelli)\n+- bitcoin/bitcoin#20437 fuzz: Avoid time-based \"non-determinism\" in fuzzing harnesses by using mocked GetTime() (practicalswift)\n+- bitcoin/bitcoin#20458 Add `is_bdb_compiled` helper (Sjors)\n+- bitcoin/bitcoin#20466 Fix intermittent `p2p_fingerprint` issue (MarcoFalke)\n+- bitcoin/bitcoin#20472 Add testing of ParseInt/ParseUInt edge cases with leading +/-/0:s (practicalswift)\n+- bitcoin/bitcoin#20507 sync: print proper lock order location when double lock is detected (vasild)\n+- bitcoin/bitcoin#20522 Fix sync issue in `disconnect_p2ps` (amitiuttarwar)\n+- bitcoin/bitcoin#20524 Move `MIN_VERSION_SUPPORTED` to p2p.py (jnewbery)\n+- bitcoin/bitcoin#20540 Fix `wallet_multiwallet` issue on windows (MarcoFalke)\n+- bitcoin/bitcoin#20560 fuzz: Link all targets once (MarcoFalke)\n+- bitcoin/bitcoin#20567 Add option to git-subtree-check to do full check, add help (laanwj)\n+- bitcoin/bitcoin#20569 Fix intermittent `wallet_multiwallet` issue with `got_loading_error` (MarcoFalke)\n+- bitcoin/bitcoin#20613 Use Popen.wait instead of RPC in `assert_start_raises_init_error` (MarcoFalke)\n+- bitcoin/bitcoin#20663 fuzz: Hide `script_assets_test_minimizer` (MarcoFalke)\n+- bitcoin/bitcoin#20674 fuzz: Call SendMessages after ProcessMessage to increase coverage (MarcoFalke)\n+- bitcoin/bitcoin#20683 Fix restart node race (MarcoFalke)\n+- bitcoin/bitcoin#20686 fuzz: replace CNode code with fuzz/util.h::ConsumeNode() (jonatack)\n+- bitcoin/bitcoin#20733 Inline non-member functions with body in fuzzing headers (pstratem)\n+- bitcoin/bitcoin#20737 Add missing assignment in `mempool_resurrect.py` (MarcoFalke)\n+- bitcoin/bitcoin#20745 Correct `epoll_ctl` data race suppression (hebasto)\n+- bitcoin/bitcoin#20748 Add race:SendZmqMessage tsan suppression (MarcoFalke)\n+- bitcoin/bitcoin#20760 Set correct nValue for multi-op-return policy check (MarcoFalke)\n+- bitcoin/bitcoin#20761 fuzz: Check that `NULL_DATA` is unspendable (MarcoFalke)\n+- bitcoin/bitcoin#20765 fuzz: Check that certain script TxoutType are nonstandard (mjdietzx)\n+- bitcoin/bitcoin#20772 fuzz: Bolster ExtractDestination(s) checks (mjdietzx)\n+- bitcoin/bitcoin#20789 fuzz: Rework strong and weak net enum fuzzing (MarcoFalke)\n+- bitcoin/bitcoin#20828 fuzz: Introduce CallOneOf helper to replace switch-case (MarcoFalke)\n+- bitcoin/bitcoin#20839 fuzz: Avoid extraneous copy of input data, using Span<> (MarcoFalke)\n+- bitcoin/bitcoin#20844 Add sanitizer suppressions for AMD EPYC CPUs (MarcoFalke)\n+- bitcoin/bitcoin#20857 Update documentation in `feature_csv_activation.py` (PiRK)\n+- bitcoin/bitcoin#20876 Replace getmempoolentry with testmempoolaccept in MiniWallet (MarcoFalke)\n+- bitcoin/bitcoin#20881 fuzz: net permission flags in net processing (MarcoFalke)\n+- bitcoin/bitcoin#20882 fuzz: Add missing muhash registration (MarcoFalke)\n+- bitcoin/bitcoin#20908 fuzz: Use mocktime in `process_message*` fuzz targets (MarcoFalke)\n+- bitcoin/bitcoin#20915 fuzz: Fail if message type is not fuzzed (MarcoFalke)\n+- bitcoin/bitcoin#20946 fuzz: Consolidate fuzzing TestingSetup initialization (dongcarl)\n+- bitcoin/bitcoin#20954 Declare `nodes` type `in test_framework.py` (kiminuo)\n+- bitcoin/bitcoin#20955 Fix `get_previous_releases.py` for aarch64 (MarcoFalke)\n+- bitcoin/bitcoin#20969 check that getblockfilter RPC fails without block filter index (theStack)\n+- bitcoin/bitcoin#20971 Work around libFuzzer deadlock (MarcoFalke)\n+- bitcoin/bitcoin#20993 Store subversion (user agent) as string in `msg_version` (theStack)\n+- bitcoin/bitcoin#20995 fuzz: Avoid initializing version to less than `MIN_PEER_PROTO_VERSION` (MarcoFalke)\n+- bitcoin/bitcoin#20998 Fix BlockToJsonVerbose benchmark (martinus)\n+- bitcoin/bitcoin#21003 Move MakeNoLogFileContext to `libtest_util`, and use it in bench (MarcoFalke)\n+- bitcoin/bitcoin#21008 Fix zmq test flakiness, improve speed (theStack)\n+- bitcoin/bitcoin#21023 fuzz: Disable shuffle when merge=1 (MarcoFalke)\n+- bitcoin/bitcoin#21037 fuzz: Avoid designated initialization (C++20) in fuzz tests (practicalswift)\n+- bitcoin/bitcoin#21042 doc, test: Improve `setup_clean_chain` documentation (fjahr)\n+- bitcoin/bitcoin#21080 fuzz: Configure check for main function (take 2) (MarcoFalke)\n+- bitcoin/bitcoin#21084 Fix timeout decrease in `feature_assumevalid` (brunoerg)\n+- bitcoin/bitcoin#21096 Re-add dead code detection (flack)\n+- bitcoin/bitcoin#21100 Remove unused function `xor_bytes` (theStack)\n+- bitcoin/bitcoin#21115 Fix Windows cross build (hebasto)\n+- bitcoin/bitcoin#21117 Remove `assert_blockchain_height` (MarcoFalke)\n+- bitcoin/bitcoin#21121 Small unit test improvements, including helper to make mempool transaction (amitiuttarwar)\n+- bitcoin/bitcoin#21124 Remove unnecessary assignment in bdb (brunoerg)\n+- bitcoin/bitcoin#21125 Change `BOOST_CHECK` to `BOOST_CHECK_EQUAL` for paths (kiminuo)\n+- bitcoin/bitcoin#21142, bitcoin/bitcoin#21512 fuzz: Add `tx_pool` fuzz target (MarcoFalke)\n+- bitcoin/bitcoin#21165 Use mocktime in `test_seed_peers` (dhruv)\n+- bitcoin/bitcoin#21169 fuzz: Add RPC interface fuzzing. Increase fuzzing coverage from 65% to 70% (practicalswift)\n+- bitcoin/bitcoin#21170 bench: Add benchmark to write json into a string (martinus)\n+- bitcoin/bitcoin#21178 Run `mempool_reorg.py` even with wallet disabled (DariusParvin)\n+- bitcoin/bitcoin#21185 fuzz: Remove expensive and redundant muhash from crypto fuzz target (MarcoFalke)\n+- bitcoin/bitcoin#21200 Speed up `rpc_blockchain.py` by removing miniwallet.generate() (MarcoFalke)\n+- bitcoin/bitcoin#21211 Move `P2WSH_OP_TRUE` to shared test library (MarcoFalke)\n+- bitcoin/bitcoin#21228 Avoid comparision of integers with different signs (jonasschnelli)\n+- bitcoin/bitcoin#21230 Fix `NODE_NETWORK_LIMITED_MIN_BLOCKS` disconnection (MarcoFalke)\n+- bitcoin/bitcoin#21252 Add missing wait for sync to `feature_blockfilterindex_prune` (MarcoFalke)\n+- bitcoin/bitcoin#21254 Avoid connecting to real network when running tests (MarcoFalke)\n+- bitcoin/bitcoin#21264 fuzz: Two scripted diff renames (MarcoFalke)\n+- bitcoin/bitcoin#21280 Bug fix in `transaction_tests` (glozow)\n+- bitcoin/bitcoin#21293 Replace accidentally placed bit-OR with logical-OR (hebasto)\n+- bitcoin/bitcoin#21297 `feature_blockfilterindex_prune.py` improvements (jonatack)\n+- bitcoin/bitcoin#21310 zmq test: fix sync-up by matching notification to generated block (theStack)\n+- bitcoin/bitcoin#21334 Additional BIP9 tests (Sjors)\n+- bitcoin/bitcoin#21338 Add functional test for anchors.dat (brunoerg)\n+- bitcoin/bitcoin#21345 Bring `p2p_leak.py` up to date (mzumsande)\n+- bitcoin/bitcoin#21357 Unconditionally check for fRelay field in test framework (jarolrod)\n+- bitcoin/bitcoin#21358 fuzz: Add missing include (`test/util/setup_common.h`) (MarcoFalke)\n+- bitcoin/bitcoin#21371 fuzz: fix gcc Woverloaded-virtual build warnings (jonatack)\n+- bitcoin/bitcoin#21373 Generate fewer blocks in `feature_nulldummy` to fix timeouts, speed up (jonatack)\n+- bitcoin/bitcoin#21390 Test improvements for UTXO set hash tests (fjahr)\n+- bitcoin/bitcoin#21410 increase `rpc_timeout` for fundrawtx `test_transaction_too_large` (jonatack)\n+- bitcoin/bitcoin#21411 add logging, reduce blocks, move `sync_all` in `wallet_` groups (jonatack)\n+- bitcoin/bitcoin#21438 Add ParseUInt8() test coverage (jonatack)\n+- bitcoin/bitcoin#21443 fuzz: Implement `fuzzed_dns_lookup_function` as a lambda (practicalswift)\n+- bitcoin/bitcoin#21445 cirrus: Use SSD cluster for speedup (MarcoFalke)\n+- bitcoin/bitcoin#21477 Add test for CNetAddr::ToString IPv6 address formatting (RFC 5952) (practicalswift)\n+- bitcoin/bitcoin#21487 fuzz: Use ConsumeWeakEnum in addrman for service flags (MarcoFalke)\n+- bitcoin/bitcoin#21488 Add ParseUInt16() unit test and fuzz coverage (jonatack)\n+- bitcoin/bitcoin#21491 test: remove duplicate assertions in util_tests (jonatack)\n+- bitcoin/bitcoin#21522 fuzz: Use PickValue where possible (MarcoFalke)\n+- bitcoin/bitcoin#21531 remove qt byteswap compattests (fanquake)\n+- bitcoin/bitcoin#21557 small cleanup in RPCNestedTests tests (fanquake)\n+- bitcoin/bitcoin#21586 Add missing suppression for signed-integer-overflow:txmempool.cpp (MarcoFalke)\n+- bitcoin/bitcoin#21592 Remove option to make TestChain100Setup non-deterministic (MarcoFalke)\n+- bitcoin/bitcoin#21597 Document `race:validation_chainstatemanager_tests` suppression (MarcoFalke)\n+- bitcoin/bitcoin#21599 Replace file level integer overflow suppression with function level suppression (practicalswift)\n+- bitcoin/bitcoin#21604 Document why no symbol names can be used for suppressions (MarcoFalke)\n+- bitcoin/bitcoin#21606 fuzz: Extend psbt fuzz target a bit (MarcoFalke)\n+- bitcoin/bitcoin#21617 fuzz: Fix uninitialized read in i2p test (MarcoFalke)\n+- bitcoin/bitcoin#21630 fuzz: split FuzzedSock interface and implementation (vasild)\n+- bitcoin/bitcoin#21634 Skip SQLite fsyncs while testing (achow101)\n+- bitcoin/bitcoin#21669 Remove spurious double lock tsan suppressions by bumping to clang-12 (MarcoFalke)\n+- bitcoin/bitcoin#21676 Use mocktime to avoid intermittent failure in `rpc_tests` (MarcoFalke)\n+- bitcoin/bitcoin#21677 fuzz: Avoid use of low file descriptor ids (which may be in use) in FuzzedSock (practicalswift)\n+- bitcoin/bitcoin#21678 Fix TestPotentialDeadLockDetected suppression (hebasto)\n+- bitcoin/bitcoin#21689 Remove intermittently failing and not very meaningful `BOOST_CHECK` in `cnetaddr_basic` (practicalswift)\n+- bitcoin/bitcoin#21691 Check that no versionbits are re-used (MarcoFalke)\n+- bitcoin/bitcoin#21707 Extend functional tests for addr relay (mzumsande)\n+- bitcoin/bitcoin#21712 Test default `include_mempool` value of gettxout (promag)\n+- bitcoin/bitcoin#21738 Use clang-12 for ASAN, Add missing suppression (MarcoFalke)\n+- bitcoin/bitcoin#21740 add new python linter to check file names and permissions (windsok)\n+- bitcoin/bitcoin#21749 Bump shellcheck version (hebasto)\n+- bitcoin/bitcoin#21754 Run `feature_cltv` with MiniWallet (MarcoFalke)\n+- bitcoin/bitcoin#21762 Speed up `mempool_spend_coinbase.py` (MarcoFalke)\n+- bitcoin/bitcoin#21773 fuzz: Ensure prevout is consensus-valid (MarcoFalke)\n+- bitcoin/bitcoin#21777 Fix `feature_notifications.py` intermittent issue (MarcoFalke)\n+- bitcoin/bitcoin#21785 Fix intermittent issue in `p2p_addr_relay.py` (MarcoFalke)\n+- bitcoin/bitcoin#21787 Fix off-by-ones in `rpc_fundrawtransaction` assertions (jonatack)\n+- bitcoin/bitcoin#21792 Fix intermittent issue in `p2p_segwit.py` (MarcoFalke)\n+- bitcoin/bitcoin#21795 fuzz: Terminate immediately if a fuzzing harness tries to perform a DNS lookup (belt and suspenders) (practicalswift)\n+- bitcoin/bitcoin#21798 fuzz: Create a block template in `tx_pool` targets (MarcoFalke)\n+- bitcoin/bitcoin#21804 Speed up `p2p_segwit.py` (jnewbery)\n+- bitcoin/bitcoin#21810 fuzz: Various RPC fuzzer follow-ups (practicalswift)\n+- bitcoin/bitcoin#21814 Fix `feature_config_args.py` intermittent issue (MarcoFalke)\n+- bitcoin/bitcoin#21821 Add missing test for empty P2WSH redeem (MarcoFalke)\n+- bitcoin/bitcoin#21822 Resolve bug in `interface_bitcoin_cli.py` (klementtan)\n+- bitcoin/bitcoin#21846 fuzz: Add `-fsanitize=integer` suppression needed for RPC fuzzer (`generateblock`) (practicalswift)\n+- bitcoin/bitcoin#21849 fuzz: Limit toxic test globals to their respective scope (MarcoFalke)\n+- bitcoin/bitcoin#21867 use MiniWallet for `p2p_blocksonly.py` (theStack)\n+- bitcoin/bitcoin#21873 minor fixes & improvements for files linter test (windsok)\n+- bitcoin/bitcoin#21874 fuzz: Add `WRITE_ALL_FUZZ_TARGETS_AND_ABORT` (MarcoFalke)\n+- bitcoin/bitcoin#21884 fuzz: Remove unused --enable-danger-fuzz-link-all option (MarcoFalke)\n+- bitcoin/bitcoin#21890 fuzz: Limit ParseISO8601DateTime fuzzing to 32-bit (MarcoFalke)\n+- bitcoin/bitcoin#21891 fuzz: Remove strprintf test cases that are known to fail (MarcoFalke)\n+- bitcoin/bitcoin#21892 fuzz: Avoid excessively large min fee rate in `tx_pool` (MarcoFalke)\n+- bitcoin/bitcoin#21895 Add TSA annotations to the WorkQueue class members (hebasto)\n+- bitcoin/bitcoin#21900 use MiniWallet for `feature_csv_activation.py` (theStack)\n+- bitcoin/bitcoin#21909 fuzz: Limit max insertions in timedata fuzz test (MarcoFalke)\n+- bitcoin/bitcoin#21922 fuzz: Avoid timeout in EncodeBase58 (MarcoFalke)\n+- bitcoin/bitcoin#21927 fuzz: Run const CScript member functions only once (MarcoFalke)\n+- bitcoin/bitcoin#21929 fuzz: Remove incorrect float round-trip serialization test (MarcoFalke)\n+- bitcoin/bitcoin#21936 fuzz: Terminate immediately if a fuzzing harness tries to create a TCP socket (belt and suspenders) (practicalswift)\n+- bitcoin/bitcoin#21941 fuzz: Call const member functions in addrman fuzz test only once (MarcoFalke)\n+- bitcoin/bitcoin#21945 add P2PK support to MiniWallet (theStack)\n+- bitcoin/bitcoin#21948 Fix off-by-one in mockscheduler test RPC (MarcoFalke)\n+- bitcoin/bitcoin#21953 fuzz: Add `utxo_snapshot` target (MarcoFalke)\n+- bitcoin/bitcoin#21970 fuzz: Add missing CheckTransaction before CheckTxInputs (MarcoFalke)\n+- bitcoin/bitcoin#21989 Use `COINBASE_MATURITY` in functional tests (kiminuo)\n+- bitcoin/bitcoin#22003 Add thread safety annotations (ajtowns)\n+- bitcoin/bitcoin#22004 fuzz: Speed up transaction fuzz target (MarcoFalke)\n+- bitcoin/bitcoin#22005 fuzz: Speed up banman fuzz target (MarcoFalke)\n+- bitcoin/bitcoin#22029 [fuzz] Improve transport deserialization fuzz test coverage (dhruv)\n+- bitcoin/bitcoin#22048 MiniWallet: introduce enum type for output mode (theStack)\n+- bitcoin/bitcoin#22057 use MiniWallet (P2PK mode) for `feature_dersig.py` (theStack)\n+- bitcoin/bitcoin#22065 Mark `CheckTxInputs` `[[nodiscard]]`. Avoid UUM in fuzzing harness `coins_view` (practicalswift)\n+- bitcoin/bitcoin#22069 fuzz: don't try and use fopencookie() when building for Android (fanquake)\n+- bitcoin/bitcoin#22082 update nanobench from release 4.0.0 to 4.3.4 (martinus)\n+- bitcoin/bitcoin#22086 remove BasicTestingSetup from unit tests that don't need it (fanquake)\n+- bitcoin/bitcoin#22089 MiniWallet: fix fee calculation for P2PK and check tx vsize (theStack)\n+- bitcoin/bitcoin#21107, bitcoin/bitcoin#22092 Convert documentation into type annotations (fanquake)\n+- bitcoin/bitcoin#22095 Additional BIP32 test vector for hardened derivation with leading zeros (kristapsk)\n+- bitcoin/bitcoin#22103 Fix IPv6 check on BSD systems (n-thumann)\n+- bitcoin/bitcoin#22118 check anchors.dat when node starts for the first time (brunoerg)\n+- bitcoin/bitcoin#22120 `p2p_invalid_block`: Check that a block rejected due to too-new tim\u2026 (willcl-ark)\n+- bitcoin/bitcoin#22153 Fix `p2p_leak.py` intermittent failure (mzumsande)\n+- bitcoin/bitcoin#22169 p2p, rpc, fuzz: various tiny follow-ups (jonatack)\n+- bitcoin/bitcoin#22176 Correct outstanding -Werror=sign-compare errors (Empact)\n+- bitcoin/bitcoin#22180 fuzz: Increase branch coverage of the float fuzz target (MarcoFalke)\n+- bitcoin/bitcoin#22187 Add `sync_blocks` in `wallet_orphanedreward.py` (domob1812)\n+- bitcoin/bitcoin#22201 Fix TestShell to allow running in Jupyter Notebook (josibake)\n+- bitcoin/bitcoin#22202 Add temporary coinstats suppressions (MarcoFalke)\n+- bitcoin/bitcoin#22203 Use ConnmanTestMsg from test lib in `denialofservice_tests` (MarcoFalke)\n+- bitcoin/bitcoin#22210 Use MiniWallet in `test_no_inherited_signaling` RBF test (MarcoFalke)\n+- bitcoin/bitcoin#22224 Update msvc and appveyor builds to use Qt5.12.11 binaries (sipsorcery)\n+- bitcoin/bitcoin#22249 Kill process group to avoid dangling processes when using `--failfast` (S3RK)\n+- bitcoin/bitcoin#22267 fuzz: Speed up crypto fuzz target (MarcoFalke)\n+- bitcoin/bitcoin#22270 Add bitcoin-util tests (+refactors) (MarcoFalke)\n+- bitcoin/bitcoin#22271 fuzz: Assert roundtrip equality for `CPubKey` (theStack)\n+- bitcoin/bitcoin#22279 fuzz: add missing ECCVerifyHandle to `base_encode_decode` (apoelstra)\n+- bitcoin/bitcoin#22292 bench, doc: benchmarking updates and fixups (jonatack)\n+- bitcoin/bitcoin#22306 Improvements to `p2p_addr_relay.py` (amitiuttarwar)\n+- bitcoin/bitcoin#22310 Add functional test for replacement relay fee check (ariard)\n+- bitcoin/bitcoin#22311 Add missing syncwithvalidationinterfacequeue in `p2p_blockfilters` (MarcoFalke)\n+- bitcoin/bitcoin#22313 Add missing `sync_all` to `feature_coinstatsindex` (MarcoFalke)\n+- bitcoin/bitcoin#22322 fuzz: Check banman roundtrip (MarcoFalke)\n+- bitcoin/bitcoin#22363 Use `script_util` helpers for creating P2{PKH,SH,WPKH,WSH} scripts (theStack)\n+- bitcoin/bitcoin#22399 fuzz: Rework CTxDestination fuzzing (MarcoFalke)\n+- bitcoin/bitcoin#22408 add tests for `bad-txns-prevout-null` reject reason (theStack)\n+- bitcoin/bitcoin#22445 fuzz: Move implementations of non-template fuzz helpers from util.h to util.cpp (sriramdvt)\n+- bitcoin/bitcoin#22446 Fix `wallet_listdescriptors.py` if bdb is not compiled (hebasto)\n+- bitcoin/bitcoin#22447 Whitelist `rpc_rawtransaction` peers to speed up tests (jonatack)\n+- bitcoin/bitcoin#22742 Use proper target in `do_fund_send` (S3RK)\n+\n+### Miscellaneous\n+- bitcoin/bitcoin#19337 sync: Detect double lock from the same thread (vasild)\n+- bitcoin/bitcoin#19809 log: Prefix log messages with function name and source code location if -logsourcelocations is set (practicalswift)\n+- bitcoin/bitcoin#19866 eBPF Linux tracepoints (jb55)\n+- bitcoin/bitcoin#20024 init: Fix incorrect warning \"Reducing -maxconnections from N to N-1, because of system limitations\" (practicalswift)\n+- bitcoin/bitcoin#20145 contrib: Add getcoins.py script to get coins from (signet) faucet (kallewoof)\n+- bitcoin/bitcoin#20255 util: Add assume() identity function (MarcoFalke)\n+- bitcoin/bitcoin#20288 script, doc: Contrib/seeds updates (jonatack)\n+- bitcoin/bitcoin#20358 src/randomenv.cpp: Fix build on uclibc (ffontaine)\n+- bitcoin/bitcoin#20406 util: Avoid invalid integer negation in formatmoney and valuefromamount (practicalswift)\n+- bitcoin/bitcoin#20434 contrib: Parse elf directly for symbol and security checks (laanwj)\n+- bitcoin/bitcoin#20451 lint: Run mypy over contrib/devtools (fanquake)\n+- bitcoin/bitcoin#20476 contrib: Add test for elf symbol-check (laanwj)\n+- bitcoin/bitcoin#20530 lint: Update cppcheck linter to c++17 and improve explicit usage (fjahr)\n+- bitcoin/bitcoin#20589 log: Clarify that failure to read/write `fee_estimates.dat` is non-fatal (MarcoFalke)\n+- bitcoin/bitcoin#20602 util: Allow use of c++14 chrono literals (MarcoFalke)\n+- bitcoin/bitcoin#20605 init: Signal-safe instant shutdown (laanwj)\n+- bitcoin/bitcoin#20608 contrib: Add symbol check test for PE binaries (fanquake)\n+- bitcoin/bitcoin#20689 contrib: Replace binary verification script verify.sh with python rewrite (theStack)\n+- bitcoin/bitcoin#20715 util: Add argsmanager::getcommand() and use it in bitcoin-wallet (MarcoFalke)\n+- bitcoin/bitcoin#20735 script: Remove outdated extract-osx-sdk.sh (hebasto)\n+- bitcoin/bitcoin#20817 lint: Update list of spelling linter false positives, bump to codespell 2.0.0 (theStack)\n+- bitcoin/bitcoin#20884 script: Improve robustness of bitcoind.service on startup (hebasto)\n+- bitcoin/bitcoin#20906 contrib: Embed c++11 patch in `install_db4.sh` (gruve-p)\n+- bitcoin/bitcoin#21004 contrib: Fix docker args conditional in gitian-build (setpill)\n+- bitcoin/bitcoin#21007 bitcoind: Add -daemonwait option to wait for initialization (laanwj)\n+- bitcoin/bitcoin#21041 log: Move \"Pre-allocating up to position 0x[\u2026] in [\u2026].dat\" log message to debug category (practicalswift)\n+- bitcoin/bitcoin#21059 Drop boost/preprocessor dependencies (hebasto)\n+- bitcoin/bitcoin#21087 guix: Passthrough `BASE_CACHE` into container (dongcarl)\n+- bitcoin/bitcoin#21088 guix: Jump forwards in time-machine and adapt (dongcarl)\n+- bitcoin/bitcoin#21089 guix: Add support for powerpc64{,le} (dongcarl)\n+- bitcoin/bitcoin#21110 util: Remove boost `posix_time` usage from `gettime*` (fanquake)\n+- bitcoin/bitcoin#21111 Improve OpenRC initscript (parazyd)\n+- bitcoin/bitcoin#21123 code style: Add EditorConfig file (kiminuo)\n+- bitcoin/bitcoin#21173 util: Faster hexstr => 13% faster blocktojson (martinus)\n+- bitcoin/bitcoin#21221 tools: Allow argument/parameter bin packing in clang-format (jnewbery)\n+- bitcoin/bitcoin#21244 Move GetDataDir to ArgsManager (kiminuo)\n+- bitcoin/bitcoin#21255 contrib: Run test-symbol-check for risc-v (fanquake)\n+- bitcoin/bitcoin#21271 guix: Explicitly set umask in build container (dongcarl)\n+- bitcoin/bitcoin#21300 script: Add explanatory comment to tc.sh (dscotese)\n+- bitcoin/bitcoin#21317 util: Make assume() usable as unary expression (MarcoFalke)\n+- bitcoin/bitcoin#21336 Make .gitignore ignore src/test/fuzz/fuzz.exe (hebasto)\n+- bitcoin/bitcoin#21337 guix: Update darwin native packages dependencies (hebasto)\n+- bitcoin/bitcoin#21405 compat: remove memcpy -> memmove backwards compatibility alias (fanquake)\n+- bitcoin/bitcoin#21418 contrib: Make systemd invoke dependencies only when ready (laanwj)\n+- bitcoin/bitcoin#21447 Always add -daemonwait to known command line arguments (hebasto)\n+- bitcoin/bitcoin#21471 bugfix: Fix `bech32_encode` calls in `gen_key_io_test_vectors.py` (sipa)\n+- bitcoin/bitcoin#21615 script: Add trusted key for hebasto (hebasto)\n+- bitcoin/bitcoin#21664 contrib: Use lief for macos and windows symbol & security checks (fanquake)\n+- bitcoin/bitcoin#21695 contrib: Remove no longer used contrib/bitcoin-qt.pro (hebasto)\n+- bitcoin/bitcoin#21711 guix: Add full installation and usage documentation (dongcarl)\n+- bitcoin/bitcoin#21799 guix: Use `gcc-8` across the board (dongcarl)\n+- bitcoin/bitcoin#21802 Avoid UB in util/asmap (advance a dereferenceable iterator outside its valid range) (MarcoFalke)\n+- bitcoin/bitcoin#21823 script: Update reviewers (jonatack)\n+- bitcoin/bitcoin#21850 Remove `GetDataDir(net_specific)` function (kiminuo)\n+- bitcoin/bitcoin#21871 scripts: Add checks for minimum required os versions (fanquake)\n+- bitcoin/bitcoin#21966 Remove double serialization; use software encoder for fee estimation (sipa)\n+- bitcoin/bitcoin#22060 contrib: Add torv3 seed nodes for testnet, drop v2 ones (laanwj)\n+- bitcoin/bitcoin#22244 devtools: Correctly extract symbol versions in symbol-check (laanwj)\n+- bitcoin/bitcoin#22533 guix/build: Remove vestigial SKIPATTEST.TAG (dongcarl)\n+- bitcoin/bitcoin#22643 guix-verify: Non-zero exit code when anything fails (dongcarl)\n+- bitcoin/bitcoin#22654 guix: Don't include directory name in SHA256SUMS (achow101)\n+\n+### Documentation\n+- bitcoin/bitcoin#15451 clarify getdata limit after #14897 (HashUnlimited)\n+- bitcoin/bitcoin#15545 Explain why CheckBlock() is called before AcceptBlock (Sjors)\n+- bitcoin/bitcoin#17350 Add developer documentation to isminetype (HAOYUatHZ)\n+- bitcoin/bitcoin#17934 Use `CONFIG_SITE` variable instead of --prefix option (hebasto)\n+- bitcoin/bitcoin#18030 Coin::IsSpent() can also mean never existed (Sjors)\n+- bitcoin/bitcoin#18096 IsFinalTx comment about nSequence & `OP_CLTV` (nothingmuch)\n+- bitcoin/bitcoin#18568 Clarify developer notes about constant naming (ryanofsky)\n+- bitcoin/bitcoin#19961 doc: tor.md updates (jonatack)\n+- bitcoin/bitcoin#19968 Clarify CRollingBloomFilter size estimate (robot-dreams)\n+- bitcoin/bitcoin#20200 Rename CODEOWNERS to REVIEWERS (adamjonas)\n+- bitcoin/bitcoin#20329 docs/descriptors.md: Remove hardened marker in the path after xpub (dgpv)\n+- bitcoin/bitcoin#20380 Add instructions on how to fuzz the P2P layer using Honggfuzz NetDriver (practicalswift)\n+- bitcoin/bitcoin#20414 Remove generated manual pages from master branch (laanwj)\n+- bitcoin/bitcoin#20473 Document current boost dependency as 1.71.0 (laanwj)\n+- bitcoin/bitcoin#20512 Add bash as an OpenBSD dependency (emilengler)\n+- bitcoin/bitcoin#20568 Use FeeModes doc helper in estimatesmartfee (MarcoFalke)\n+- bitcoin/bitcoin#20577 libconsensus: add missing error code description, fix NBitcoin link (theStack)\n+- bitcoin/bitcoin#20587 Tidy up Tor doc (more stringent) (wodry)\n+- bitcoin/bitcoin#20592 Update wtxidrelay documentation per BIP339 (jonatack)\n+- bitcoin/bitcoin#20601 Update for FreeBSD 12.2, add GUI Build Instructions (jarolrod)\n+- bitcoin/bitcoin#20635 fix misleading comment about call to non-existing function (pox)\n+- bitcoin/bitcoin#20646 Refer to BIPs 339/155 in feature negotiation (jonatack)\n+- bitcoin/bitcoin#20653 Move addr relay comment in net to correct place (MarcoFalke)\n+- bitcoin/bitcoin#20677 Remove shouty enums in `net_processing` comments (sdaftuar)\n+- bitcoin/bitcoin#20741 Update 'Secure string handling' (prayank23)\n+- bitcoin/bitcoin#20757 tor.md and -onlynet help updates (jonatack)\n+- bitcoin/bitcoin#20829 Add -netinfo help (jonatack)\n+- bitcoin/bitcoin#20830 Update developer notes with signet (jonatack)\n+- bitcoin/bitcoin#20890 Add explicit macdeployqtplus dependencies install step (hebasto)\n+- bitcoin/bitcoin#20913 Add manual page generation for bitcoin-util (laanwj)\n+- bitcoin/bitcoin#20985 Add xorriso to macOS depends packages (fanquake)\n+- bitcoin/bitcoin#20986 Update developer notes to discourage very long lines (jnewbery)\n+- bitcoin/bitcoin#20987 Add instructions for generating RPC docs (ben-kaufman)\n+- bitcoin/bitcoin#21026 Document use of make-tag script to make tags (laanwj)\n+- bitcoin/bitcoin#21028 doc/bips: Add BIPs 43, 44, 49, and 84 (luke-jr)\n+- bitcoin/bitcoin#21049 Add release notes for listdescriptors RPC (S3RK)\n+- bitcoin/bitcoin#21060 More precise -debug and -debugexclude doc (wodry)\n+- bitcoin/bitcoin#21077 Clarify -timeout and -peertimeout config options (glozow)\n+- bitcoin/bitcoin#21105 Correctly identify script type (niftynei)\n+- bitcoin/bitcoin#21163 Guix is shipped in Debian and Ubuntu (MarcoFalke)\n+- bitcoin/bitcoin#21210 Rework internal and external links (MarcoFalke)\n+- bitcoin/bitcoin#21246 Correction for VerifyTaprootCommitment comments (roconnor-blockstream)\n+- bitcoin/bitcoin#21263 Clarify that squashing should happen before review (MarcoFalke)\n+- bitcoin/bitcoin#21323 guix, doc: Update default HOSTS value (hebasto)\n+- bitcoin/bitcoin#21324 Update build instructions for Fedora (hebasto)\n+- bitcoin/bitcoin#21343 Revamp macOS build doc (jarolrod)\n+- bitcoin/bitcoin#21346 install qt5 when building on macOS (fanquake)\n+- bitcoin/bitcoin#21384 doc: add signet to bitcoin.conf documentation (jonatack)\n+- bitcoin/bitcoin#21394 Improve comment about protected peers (amitiuttarwar)\n+- bitcoin/bitcoin#21398 Update fuzzing docs for afl-clang-lto (MarcoFalke)\n+- bitcoin/bitcoin#21444 net, doc: Doxygen updates and fixes in netbase.{h,cpp} (jonatack)\n+- bitcoin/bitcoin#21481 Tell howto install clang-format on Debian/Ubuntu (wodry)\n+- bitcoin/bitcoin#21567 Fix various misleading comments (glozow)\n+- bitcoin/bitcoin#21661 Fix name of script guix-build (Emzy)\n+- bitcoin/bitcoin#21672 Remove boostrap info from `GUIX_COMMON_FLAGS` doc (fanquake)\n+- bitcoin/bitcoin#21688 Note on SDK for macOS depends cross-compile (jarolrod)\n+- bitcoin/bitcoin#21709 Update reduce-memory.md and bitcoin.conf -maxconnections info (jonatack)\n+- bitcoin/bitcoin#21710 update helps for addnode rpc and -addnode/-maxconnections config options (jonatack)\n+- bitcoin/bitcoin#21752 Clarify that feerates are per virtual size (MarcoFalke)\n+- bitcoin/bitcoin#21811 Remove Visual Studio 2017 reference from readme (sipsorcery)\n+- bitcoin/bitcoin#21818 Fixup -coinstatsindex help, update bitcoin.conf and files.md (jonatack)\n+- bitcoin/bitcoin#21856 add OSS-Fuzz section to fuzzing.md doc (adamjonas)\n+- bitcoin/bitcoin#21912 Remove mention of priority estimation (MarcoFalke)\n+- bitcoin/bitcoin#21925 Update bips.md for 0.21.1 (MarcoFalke)\n+- bitcoin/bitcoin#21942 improve make with parallel jobs description (klementtan)\n+- bitcoin/bitcoin#21947 Fix OSS-Fuzz links (MarcoFalke)\n+- bitcoin/bitcoin#21988 note that brew installed qt is not supported (jarolrod)\n+- bitcoin/bitcoin#22056 describe in fuzzing.md how to reproduce a CI crash (jonatack)\n+- bitcoin/bitcoin#22080 add maxuploadtarget to bitcoin.conf example (jarolrod)\n+- bitcoin/bitcoin#22088 Improve note on choosing posix mingw32 (jarolrod)\n+- bitcoin/bitcoin#22109 Fix external links (IRC, \u2026) (MarcoFalke)\n+- bitcoin/bitcoin#22121 Various validation doc fixups (MarcoFalke)\n+- bitcoin/bitcoin#22172 Update tor.md, release notes with removal of tor v2 support (jonatack)\n+- bitcoin/bitcoin#22204 Remove obsolete `okSafeMode` RPC guideline from developer notes (theStack)\n+- bitcoin/bitcoin#22208 Update `REVIEWERS` (practicalswift)\n+- bitcoin/bitcoin#22250 add basic I2P documentation (vasild)\n+- bitcoin/bitcoin#22296 Final merge of release notes snippets, mv to wiki (MarcoFalke)\n+- bitcoin/bitcoin#22335 recommend `--disable-external-signer` in OpenBSD build guide (theStack)\n+- bitcoin/bitcoin#22339 Document minimum required libc++ version (hebasto)\n+- bitcoin/bitcoin#22349 Repository IRC updates (jonatack)\n+- bitcoin/bitcoin#22360 Remove unused section from release process (MarcoFalke)\n+- bitcoin/bitcoin#22369 Add steps for Transifex to release process (jonatack)\n+- bitcoin/bitcoin#22393 Added info to bitcoin.conf doc (bliotti)\n+- bitcoin/bitcoin#22402 Install Rosetta on M1-macOS for qt in depends (hebasto)\n+- bitcoin/bitcoin#22432 Fix incorrect `testmempoolaccept` doc (glozow)\n+- bitcoin/bitcoin#22648 doc, test: improve i2p/tor docs and i2p reachable unit tests (jonatack)\n+\n+Credits\n+=======\n+\n+Thanks to everyone who directly contributed to this release:\n+\n+- Aaron Clauson\n+- Adam Jonas\n+- amadeuszpawlik\n+- Amiti Uttarwar\n+- Andrew Chow\n+- Andrew Poelstra\n+- Anthony Towns\n+- Antoine Poinsot\n+- Antoine Riard\n+- apawlik\n+- apitko\n+- Ben Carman\n+- Ben Woosley\n+- benk10\n+- Bezdrighin\n+- Block Mechanic\n+- Brian Liotti\n+- Bruno Garcia\n+- Carl Dong\n+- Christian Decker\n+- coinforensics\n+- Cory Fields\n+- Dan Benjamin\n+- Daniel Kraft\n+- Darius Parvin\n+- Dhruv Mehta\n+- Dmitry Goncharov\n+- Dmitry Petukhov\n+- dplusplus1024\n+- dscotese\n+- Duncan Dean\n+- Elle Mouton\n+- Elliott Jin\n+- Emil Engler\n+- Ethan Heilman\n+- eugene\n+- Evan Klitzke\n+- Fabian Jahr\n+- Fabrice Fontaine\n+- fanquake\n+- fdov\n+- flack\n+- Fotis Koutoupas\n+- Fu Yong Quah\n+- fyquah\n+- glozow\n+- Gregory Sanders\n+- Guido Vranken\n+- Gunar C. Gessner\n+- h\n+- HAOYUatHZ\n+- Hennadii Stepanov\n+- Igor Cota\n+- Ikko Ashimine\n+- Ivan Metlushko\n+- jackielove4u\n+- James O'Beirne\n+- Jarol Rodriguez\n+- Joel Klabo\n+- John Newbery\n+- Jon Atack\n+- Jonas Schnelli\n+- Jo\u00e3o Barbosa\n+- Josiah Baker\n+- Karl-Johan Alm\n+- Kiminuo\n+- Klement Tan\n+- Kristaps Kaupe\n+- Larry Ruane\n+- lisa neigut\n+- Lucas Ontivero\n+- Luke Dashjr\n+- Maayan Keshet\n+- MarcoFalke\n+- Martin Ankerl\n+- Martin Zumsande\n+- Michael Dietz\n+- Michael Polzer\n+- Michael Tidwell\n+- Niklas G\u00f6gge\n+- nthumann\n+- Oliver Gugger\n+- parazyd\n+- Patrick Strateman\n+- Pavol Rusnak\n+- Peter Bushnell\n+- Pierre K\n+- Pieter Wuille\n+- PiRK\n+- pox\n+- practicalswift\n+- Prayank\n+- R E Broadley\n+- Rafael Sadowski\n+- randymcmillan\n+- Raul Siles\n+- Riccardo Spagni\n+- Russell O'Connor\n+- Russell Yanofsky\n+- S3RK\n+- saibato\n+- Samuel Dobson\n+- sanket1729\n+- Sawyer Billings\n+- Sebastian Falbesoner\n+- setpill\n+- sgulls\n+- sinetek\n+- Sjors Provoost\n+- Sriram\n+- Stephan Oeste\n+- Suhas Daftuar\n+- Sylvain Goumy\n+- t-bast\n+- Troy Giorshev\n+- Tushar Singla\n+- Tyler Chambers\n+- Uplab\n+- Vasil Dimov\n+- W. J. van der Laan\n+- willcl-ark\n+- William Bright\n+- William Casarin\n+- windsok\n+- wodry\n+- Yerzhan Mazhkenov\n+- Yuval Kogman\n+- Zero\n+\n+As well as to everyone that helped with translations on\n+[Transifex](https://www.transifex.com/bitcoin/bitcoin/)."
      },
      {
        "sha": "6a5202d0f900f96acdd11839e883a769a7fa222d",
        "filename": "doc/release-process.md",
        "status": "modified",
        "additions": 1,
        "deletions": 20,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/doc/release-process.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/doc/release-process.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-process.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -271,26 +271,7 @@ cat \"$VERSION\"/*/all.SHA256SUMS.asc > SHA256SUMS.asc\n \n       - Push the flatpak to flathub, e.g. https://github.com/flathub/org.bitcoincore.bitcoin-qt/pull/2\n \n-      - Push the latest version to master (if applicable), e.g. https://github.com/bitcoin-core/packaging/pull/32\n-\n-      - Create a new branch for the major release \"0.xx\" from master (used to build the snap package) and request the\n-        track (if applicable), e.g. https://forum.snapcraft.io/t/track-request-for-bitcoin-core-snap/10112/7\n-\n-      - Notify MarcoFalke so that he can start building the snap package\n-\n-        - https://code.launchpad.net/~bitcoin-core/bitcoin-core-snap/+git/packaging (Click \"Import Now\" to fetch the branch)\n-        - https://code.launchpad.net/~bitcoin-core/bitcoin-core-snap/+git/packaging/+ref/0.xx (Click \"Create snap package\")\n-        - Name it \"bitcoin-core-snap-0.xx\"\n-        - Leave owner and series as-is\n-        - Select architectures that are compiled via guix\n-        - Leave \"automatically build when branch changes\" unticked\n-        - Tick \"automatically upload to store\"\n-        - Put \"bitcoin-core\" in the registered store package name field\n-        - Tick the \"edge\" box\n-        - Put \"0.xx\" in the track field\n-        - Click \"create snap package\"\n-        - Click \"Request builds\" for every new release on this branch (after updating the snapcraft.yml in the branch to reflect the latest guix results)\n-        - Promote release on https://snapcraft.io/bitcoin-core/releases if it passes sanity checks\n+      - Push the snap, see https://github.com/bitcoin-core/packaging/blob/master/snap/build.md\n \n   - This repo\n "
      },
      {
        "sha": "8dc82ca91e0c7da8f370cd4faacb37820f9506a4",
        "filename": "doc/tor.md",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/doc/tor.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/doc/tor.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/tor.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -23,10 +23,9 @@ There are several ways to see your local onion address in Bitcoin Core:\n You may set the `-debug=tor` config logging option to have additional\n information in the debug log about your Tor configuration.\n \n-CLI `-addrinfo` returns the number of addresses known to your node per network\n-type, including Tor v2 and v3. This is useful to see how many onion addresses\n-are known to your node for `-onlynet=onion` and how many Tor v3 addresses it\n-knows when upgrading to Bitcoin Core v22.0 and up that supports Tor v3 only.\n+CLI `-addrinfo` returns the number of addresses known to your node per\n+network. This can be useful to see how many onion peers your node knows,\n+e.g. for `-onlynet=onion`.\n \n ## 1. Run Bitcoin Core behind a Tor proxy\n \n@@ -57,11 +56,11 @@ outgoing connections, but more is possible.\n     -onlynet=onion  Make outgoing connections only to .onion addresses. Incoming\n                     connections are not affected by this option. This option can be\n                     specified multiple times to allow multiple network types, e.g.\n-                    ipv4, ipv6 or onion. If you use this option with values other\n-                    than onion you *cannot* disable onion connections; outgoing onion\n-                    connections will be enabled when you use -proxy or -onion. Use\n-                    -noonion or -onion=0 if you want to be sure there are no outbound\n-                    onion connections over the default proxy or your defined -proxy.\n+                    onlynet=ipv4, onlynet=ipv6, onlynet=onion, onlynet=i2p.\n+                    Warning: if you use -onlynet with values other than onion, and\n+                    the -onion or -proxy option is set, then outgoing onion\n+                    connections will still be made; use -noonion or -onion=0 to\n+                    disable outbound onion connections in this case.\n \n In a typical situation, this suffices to run behind a Tor proxy:\n \n@@ -134,7 +133,7 @@ You can also check the group of the cookie file. On most Linux systems, the Tor\n auth cookie will usually be `/run/tor/control.authcookie`:\n \n ```\n-stat -c '%G' /run/tor/control.authcookie\n+TORGROUP=$(stat -c '%G' /run/tor/control.authcookie)\n ```\n \n Once you have determined the `${TORGROUP}` and selected the `${USER}` that will"
      },
      {
        "sha": "87fc9603fe02a79b86442982d1f489ec5419ec4e",
        "filename": "doc/tracing.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/doc/tracing.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/doc/tracing.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/tracing.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -147,7 +147,7 @@ For example:\n ```C++\n TRACE6(net, inbound_message,\n     pnode->GetId(),\n-    pnode->GetAddrName().c_str(),\n+    pnode->m_addr_name.c_str(),\n     pnode->ConnectionTypeAsString().c_str(),\n     sanitizedType.c_str(),\n     msg.data.size(),"
      },
      {
        "sha": "0521fe08d8d1be705477db7efdf962927c62b48b",
        "filename": "doc/zmq.md",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/doc/zmq.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/doc/zmq.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/zmq.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -84,6 +84,7 @@ For instance:\n \n     $ bitcoind -zmqpubhashtx=tcp://127.0.0.1:28332 \\\n                -zmqpubhashtx=tcp://192.168.1.2:28332 \\\n+               -zmqpubhashblock=\"tcp://[::1]:28333\" \\\n                -zmqpubrawtx=ipc:///tmp/bitcoind.tx.raw \\\n                -zmqpubhashtxhwm=10000\n \n@@ -125,6 +126,9 @@ Setting the keepalive values appropriately for your operating environment may\n improve connectivity in situations where long-lived connections are silently\n dropped by network middle boxes.\n \n+Also, the socket's ZMQ_IPV6 option is enabled to accept connections from IPv6\n+hosts as well. If needed, this option has to be set on the client side too.\n+\n ## Remarks\n \n From the perspective of bitcoind, the ZeroMQ socket is write-only; PUB"
      },
      {
        "sha": "23bb244439d377256f1ce4d5a1bf6ea2ee5d856b",
        "filename": "share/qt/Info.plist.in",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/share/qt/Info.plist.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/share/qt/Info.plist.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/share/qt/Info.plist.in?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -16,6 +16,11 @@\n   <key>CFBundlePackageType</key>\n   <string>APPL</string>\n \n+  <key>CFBundleSupportedPlatforms</key>\n+  <array>\n+\t   <string>MacOSX</string>\n+  </array>\n+\n   <key>NSHumanReadableCopyright</key>\n   <string>@CLIENT_VERSION_MAJOR@.@CLIENT_VERSION_MINOR@.@CLIENT_VERSION_BUILD@, Copyright \u00a9 2009-@COPYRIGHT_YEAR@ @COPYRIGHT_HOLDERS_FINAL@</string>\n "
      },
      {
        "sha": "27616ad072fc3f6d33f7eabdb9ba6f5c937fb4bc",
        "filename": "src/.clang-tidy",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/.clang-tidy",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/.clang-tidy",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/.clang-tidy?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -0,0 +1,2 @@\n+Checks:          '-*,bugprone-argument-comment'\n+WarningsAsErrors: bugprone-argument-comment"
      },
      {
        "sha": "52c8b85357bd86de51220487080f2946dbc64490",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 3,
        "deletions": 10,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -268,6 +268,7 @@ BITCOIN_CORE_H = \\\n   util/tokenpipe.h \\\n   util/trace.h \\\n   util/translation.h \\\n+  util/types.h \\\n   util/ui_change_type.h \\\n   util/url.h \\\n   util/vector.h \\\n@@ -548,6 +549,7 @@ libbitcoin_common_a_SOURCES = \\\n   key.cpp \\\n   key_io.cpp \\\n   merkleblock.cpp \\\n+  net_types.cpp \\\n   netaddress.cpp \\\n   netbase.cpp \\\n   net_permissions.cpp \\\n@@ -569,7 +571,7 @@ libbitcoin_common_a_SOURCES = \\\n \n # util: shared between all executables.\n # This library *must* be included to make sure that the glibc\n-# backward-compatibility objects and their sanity checks are linked.\n+# sanity checks are linked.\n libbitcoin_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_util_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n libbitcoin_util_a_SOURCES = \\\n@@ -617,11 +619,6 @@ if USE_LIBEVENT\n libbitcoin_util_a_SOURCES += util/url.cpp\n endif\n \n-if GLIBC_BACK_COMPAT\n-libbitcoin_util_a_SOURCES += compat/glibc_compat.cpp\n-AM_LDFLAGS += $(COMPAT_LDFLAGS)\n-endif\n-\n # cli: shared between bitcoin-cli and bitcoin-qt\n libbitcoin_cli_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n libbitcoin_cli_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n@@ -749,10 +746,6 @@ if BUILD_BITCOIN_LIBS\n include_HEADERS = script/bitcoinconsensus.h\n libbitcoinconsensus_la_SOURCES = support/cleanse.cpp $(crypto_libbitcoin_crypto_base_a_SOURCES) $(libbitcoin_consensus_a_SOURCES)\n \n-if GLIBC_BACK_COMPAT\n-  libbitcoinconsensus_la_SOURCES += compat/glibc_compat.cpp\n-endif\n-\n libbitcoinconsensus_la_LDFLAGS = $(AM_LDFLAGS) -no-undefined $(RELDFLAGS)\n libbitcoinconsensus_la_LIBADD = $(LIBSECP256K1)\n libbitcoinconsensus_la_CPPFLAGS = $(AM_CPPFLAGS) -I$(builddir)/obj -I$(srcdir)/secp256k1/include -DBUILD_BITCOIN_INTERNAL"
      },
      {
        "sha": "f4b0b3adbe0ce5519aed406c9490d96b995ebb0e",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -338,14 +338,14 @@ bitcoin_qt_libtoolflags = $(AM_LIBTOOLFLAGS) --tag CXX\n \n qt_bitcoin_qt_CPPFLAGS = $(bitcoin_qt_cppflags)\n qt_bitcoin_qt_CXXFLAGS = $(bitcoin_qt_cxxflags)\n-qt_bitcoin_qt_SOURCES = $(bitcoin_qt_sources)\n+qt_bitcoin_qt_SOURCES = $(bitcoin_qt_sources) init/bitcoind.cpp\n qt_bitcoin_qt_LDADD = $(bitcoin_qt_ldadd)\n qt_bitcoin_qt_LDFLAGS = $(bitcoin_qt_ldflags)\n qt_bitcoin_qt_LIBTOOLFLAGS = $(bitcoin_qt_libtoolflags)\n \n bitcoin_gui_CPPFLAGS = $(bitcoin_qt_cppflags)\n bitcoin_gui_CXXFLAGS = $(bitcoin_qt_cxxflags)\n-bitcoin_gui_SOURCES = $(bitcoin_qt_sources)\n+bitcoin_gui_SOURCES = $(bitcoin_qt_sources) init/bitcoind.cpp\n bitcoin_gui_LDADD = $(bitcoin_qt_ldadd)\n bitcoin_gui_LDFLAGS = $(bitcoin_qt_ldflags)\n bitcoin_gui_LIBTOOLFLAGS = $(bitcoin_qt_libtoolflags)"
      },
      {
        "sha": "8a5521eeb546f2822633bde7d6caf1bb95a9f4d4",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -28,6 +28,7 @@ qt_test_test_bitcoin_qt_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(BITCOIN_\n   $(QT_INCLUDES) $(QT_TEST_INCLUDES)\n \n qt_test_test_bitcoin_qt_SOURCES = \\\n+  init/bitcoind.cpp \\\n   qt/test/apptests.cpp \\\n   qt/test/rpcnestedtests.cpp \\\n   qt/test/test_main.cpp \\"
      },
      {
        "sha": "a85a3599601c81af7fa56ca750b915391e35969c",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -207,7 +207,6 @@ test_fuzz_fuzz_LDADD = $(FUZZ_SUITE_LD_COMMON)\n test_fuzz_fuzz_LDFLAGS = $(FUZZ_SUITE_LDFLAGS_COMMON) $(RUNTIME_LDFLAGS)\n test_fuzz_fuzz_SOURCES = \\\n  test/fuzz/addition_overflow.cpp \\\n- test/fuzz/addrdb.cpp \\\n  test/fuzz/addrman.cpp \\\n  test/fuzz/asmap.cpp \\\n  test/fuzz/asmap_direct.cpp \\\n@@ -338,8 +337,8 @@ bitcoin_test_clean : FORCE\n \n check-local: $(BITCOIN_TESTS:.cpp=.cpp.test)\n if BUILD_BITCOIN_TX\n-\t@echo \"Running test/util/bitcoin-util-test.py...\"\n-\t$(PYTHON) $(top_builddir)/test/util/bitcoin-util-test.py\n+\t@echo \"Running test/util/test_runner.py...\"\n+\t$(PYTHON) $(top_builddir)/test/util/test_runner.py\n endif\n \t@echo \"Running test/util/rpcauth-test.py...\"\n \t$(PYTHON) $(top_builddir)/test/util/rpcauth-test.py"
      },
      {
        "sha": "1e73750ce301df4ab703b2e076b1f86bf41e466d",
        "filename": "src/addrdb.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 96,
        "changes": 150,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -18,64 +18,14 @@\n #include <univalue.h>\n #include <util/settings.h>\n #include <util/system.h>\n-\n-CBanEntry::CBanEntry(const UniValue& json)\n-    : nVersion(json[\"version\"].get_int()), nCreateTime(json[\"ban_created\"].get_int64()),\n-      nBanUntil(json[\"banned_until\"].get_int64())\n-{\n-}\n-\n-UniValue CBanEntry::ToJson() const\n-{\n-    UniValue json(UniValue::VOBJ);\n-    json.pushKV(\"version\", nVersion);\n-    json.pushKV(\"ban_created\", nCreateTime);\n-    json.pushKV(\"banned_until\", nBanUntil);\n-    return json;\n-}\n+#include <util/translation.h>\n \n namespace {\n \n-static const char* BANMAN_JSON_ADDR_KEY = \"address\";\n-\n-/**\n- * Convert a `banmap_t` object to a JSON array.\n- * @param[in] bans Bans list to convert.\n- * @return a JSON array, similar to the one returned by the `listbanned` RPC. Suitable for\n- * passing to `BanMapFromJson()`.\n- */\n-UniValue BanMapToJson(const banmap_t& bans)\n+class DbNotFoundError : public std::exception\n {\n-    UniValue bans_json(UniValue::VARR);\n-    for (const auto& it : bans) {\n-        const auto& address = it.first;\n-        const auto& ban_entry = it.second;\n-        UniValue j = ban_entry.ToJson();\n-        j.pushKV(BANMAN_JSON_ADDR_KEY, address.ToString());\n-        bans_json.push_back(j);\n-    }\n-    return bans_json;\n-}\n-\n-/**\n- * Convert a JSON array to a `banmap_t` object.\n- * @param[in] bans_json JSON to convert, must be as returned by `BanMapToJson()`.\n- * @param[out] bans Bans list to create from the JSON.\n- * @throws std::runtime_error if the JSON does not have the expected fields or they contain\n- * unparsable values.\n- */\n-void BanMapFromJson(const UniValue& bans_json, banmap_t& bans)\n-{\n-    for (const auto& ban_entry_json : bans_json.getValues()) {\n-        CSubNet subnet;\n-        const auto& subnet_str = ban_entry_json[BANMAN_JSON_ADDR_KEY].get_str();\n-        if (!LookupSubNet(subnet_str, subnet)) {\n-            throw std::runtime_error(\n-                strprintf(\"Cannot parse banned address or subnet: %s\", subnet_str));\n-        }\n-        bans.insert_or_assign(subnet, CBanEntry{ban_entry_json});\n-    }\n-}\n+    using std::exception::exception;\n+};\n \n template <typename Stream, typename Data>\n bool SerializeDB(Stream& stream, const Data& data)\n@@ -134,47 +84,40 @@ bool SerializeFileDB(const std::string& prefix, const fs::path& path, const Data\n }\n \n template <typename Stream, typename Data>\n-bool DeserializeDB(Stream& stream, Data& data, bool fCheckSum = true)\n-{\n-    try {\n-        CHashVerifier<Stream> verifier(&stream);\n-        // de-serialize file header (network specific magic number) and ..\n-        unsigned char pchMsgTmp[4];\n-        verifier >> pchMsgTmp;\n-        // ... verify the network matches ours\n-        if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp)))\n-            return error(\"%s: Invalid network magic number\", __func__);\n-\n-        // de-serialize data\n-        verifier >> data;\n-\n-        // verify checksum\n-        if (fCheckSum) {\n-            uint256 hashTmp;\n-            stream >> hashTmp;\n-            if (hashTmp != verifier.GetHash()) {\n-                return error(\"%s: Checksum mismatch, data corrupted\", __func__);\n-            }\n+void DeserializeDB(Stream& stream, Data& data, bool fCheckSum = true)\n+{\n+    CHashVerifier<Stream> verifier(&stream);\n+    // de-serialize file header (network specific magic number) and ..\n+    unsigned char pchMsgTmp[4];\n+    verifier >> pchMsgTmp;\n+    // ... verify the network matches ours\n+    if (memcmp(pchMsgTmp, Params().MessageStart(), sizeof(pchMsgTmp))) {\n+        throw std::runtime_error{\"Invalid network magic number\"};\n+    }\n+\n+    // de-serialize data\n+    verifier >> data;\n+\n+    // verify checksum\n+    if (fCheckSum) {\n+        uint256 hashTmp;\n+        stream >> hashTmp;\n+        if (hashTmp != verifier.GetHash()) {\n+            throw std::runtime_error{\"Checksum mismatch, data corrupted\"};\n         }\n     }\n-    catch (const std::exception& e) {\n-        return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n-    }\n-\n-    return true;\n }\n \n template <typename Data>\n-bool DeserializeFileDB(const fs::path& path, Data& data, int version)\n+void DeserializeFileDB(const fs::path& path, Data& data, int version)\n {\n     // open input file, and associate with CAutoFile\n     FILE* file = fsbridge::fopen(path, \"rb\");\n     CAutoFile filein(file, SER_DISK, version);\n     if (filein.IsNull()) {\n-        LogPrintf(\"Missing or invalid file %s\\n\", path.string());\n-        return false;\n+        throw DbNotFoundError{};\n     }\n-    return DeserializeDB(filein, data);\n+    DeserializeDB(filein, data);\n }\n } // namespace\n \n@@ -227,24 +170,38 @@ bool CBanDB::Read(banmap_t& banSet)\n     return true;\n }\n \n-CAddrDB::CAddrDB()\n-{\n-    pathAddr = gArgs.GetDataDirNet() / \"peers.dat\";\n-}\n-\n-bool CAddrDB::Write(const CAddrMan& addr)\n+bool DumpPeerAddresses(const ArgsManager& args, const CAddrMan& addr)\n {\n+    const auto pathAddr = args.GetDataDirNet() / \"peers.dat\";\n     return SerializeFileDB(\"peers\", pathAddr, addr, CLIENT_VERSION);\n }\n \n-bool CAddrDB::Read(CAddrMan& addr)\n+void ReadFromStream(CAddrMan& addr, CDataStream& ssPeers)\n {\n-    return DeserializeFileDB(pathAddr, addr, CLIENT_VERSION);\n+    DeserializeDB(ssPeers, addr, false);\n }\n \n-bool CAddrDB::Read(CAddrMan& addr, CDataStream& ssPeers)\n+std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<CAddrMan>& addrman)\n {\n-    return DeserializeDB(ssPeers, addr, false);\n+    auto check_addrman = std::clamp<int32_t>(args.GetArg(\"-checkaddrman\", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);\n+    addrman = std::make_unique<CAddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n+\n+    int64_t nStart = GetTimeMillis();\n+    const auto path_addr{args.GetDataDirNet() / \"peers.dat\"};\n+    try {\n+        DeserializeFileDB(path_addr, *addrman, CLIENT_VERSION);\n+        LogPrintf(\"Loaded %i addresses from peers.dat  %dms\\n\", addrman->size(), GetTimeMillis() - nStart);\n+    } catch (const DbNotFoundError&) {\n+        // Addrman can be in an inconsistent state after failure, reset it\n+        addrman = std::make_unique<CAddrMan>(asmap, /* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n+        LogPrintf(\"Creating peers.dat because the file was not found (%s)\\n\", path_addr);\n+        DumpPeerAddresses(args, *addrman);\n+    } catch (const std::exception& e) {\n+        addrman = nullptr;\n+        return strprintf(_(\"Invalid or corrupt peers.dat (%s). If you believe this is a bug, please report it to %s. As a workaround, you can move the file (%s) out of the way (rename, move, or delete) to have a new one created on the next start.\"),\n+                         e.what(), PACKAGE_BUGREPORT, path_addr);\n+    }\n+    return std::nullopt;\n }\n \n void DumpAnchors(const fs::path& anchors_db_path, const std::vector<CAddress>& anchors)\n@@ -256,9 +213,10 @@ void DumpAnchors(const fs::path& anchors_db_path, const std::vector<CAddress>& a\n std::vector<CAddress> ReadAnchors(const fs::path& anchors_db_path)\n {\n     std::vector<CAddress> anchors;\n-    if (DeserializeFileDB(anchors_db_path, anchors, CLIENT_VERSION | ADDRV2_FORMAT)) {\n+    try {\n+        DeserializeFileDB(anchors_db_path, anchors, CLIENT_VERSION | ADDRV2_FORMAT);\n         LogPrintf(\"Loaded %i addresses from %s\\n\", anchors.size(), anchors_db_path.filename());\n-    } else {\n+    } catch (const std::exception&) {\n         anchors.clear();\n     }\n "
      },
      {
        "sha": "33cc1f92040f09e8a832f2b9eaa01da079db4d56",
        "filename": "src/addrdb.h",
        "status": "modified",
        "additions": 10,
        "deletions": 60,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/addrdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/addrdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrdb.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -8,73 +8,20 @@\n \n #include <fs.h>\n #include <net_types.h> // For banmap_t\n-#include <serialize.h>\n #include <univalue.h>\n \n-#include <string>\n+#include <optional>\n #include <vector>\n \n-class CAddress;\n+class ArgsManager;\n class CAddrMan;\n+class CAddress;\n class CDataStream;\n+struct bilingual_str;\n \n-class CBanEntry\n-{\n-public:\n-    static const int CURRENT_VERSION=1;\n-    int nVersion;\n-    int64_t nCreateTime;\n-    int64_t nBanUntil;\n-\n-    CBanEntry()\n-    {\n-        SetNull();\n-    }\n-\n-    explicit CBanEntry(int64_t nCreateTimeIn)\n-    {\n-        SetNull();\n-        nCreateTime = nCreateTimeIn;\n-    }\n-\n-    /**\n-     * Create a ban entry from JSON.\n-     * @param[in] json A JSON representation of a ban entry, as created by `ToJson()`.\n-     * @throw std::runtime_error if the JSON does not have the expected fields.\n-     */\n-    explicit CBanEntry(const UniValue& json);\n-\n-    SERIALIZE_METHODS(CBanEntry, obj)\n-    {\n-        uint8_t ban_reason = 2; //! For backward compatibility\n-        READWRITE(obj.nVersion, obj.nCreateTime, obj.nBanUntil, ban_reason);\n-    }\n-\n-    void SetNull()\n-    {\n-        nVersion = CBanEntry::CURRENT_VERSION;\n-        nCreateTime = 0;\n-        nBanUntil = 0;\n-    }\n-\n-    /**\n-     * Generate a JSON representation of this ban entry.\n-     * @return JSON suitable for passing to the `CBanEntry(const UniValue&)` constructor.\n-     */\n-    UniValue ToJson() const;\n-};\n-\n-/** Access to the (IP) address database (peers.dat) */\n-class CAddrDB\n-{\n-private:\n-    fs::path pathAddr;\n-public:\n-    CAddrDB();\n-    bool Write(const CAddrMan& addr);\n-    bool Read(CAddrMan& addr);\n-    static bool Read(CAddrMan& addr, CDataStream& ssPeers);\n-};\n+bool DumpPeerAddresses(const ArgsManager& args, const CAddrMan& addr);\n+/** Only used by tests. */\n+void ReadFromStream(CAddrMan& addr, CDataStream& ssPeers);\n \n /** Access to the banlist database (banlist.json) */\n class CBanDB\n@@ -100,6 +47,9 @@ class CBanDB\n     bool Read(banmap_t& banSet);\n };\n \n+/** Returns an error string on failure */\n+std::optional<bilingual_str> LoadAddrman(const std::vector<bool>& asmap, const ArgsManager& args, std::unique_ptr<CAddrMan>& addrman);\n+\n /**\n  * Dump the anchor IP address database (anchors.dat)\n  *"
      },
      {
        "sha": "772c34ae770693203c406e39f18f07ae714f26ee",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 304,
        "deletions": 28,
        "changes": 332,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -5,16 +5,39 @@\n \n #include <addrman.h>\n \n+#include <clientversion.h>\n #include <hash.h>\n #include <logging.h>\n #include <netaddress.h>\n #include <serialize.h>\n+#include <streams.h>\n \n #include <cmath>\n #include <optional>\n #include <unordered_map>\n #include <unordered_set>\n \n+/** Over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread */\n+static constexpr uint32_t ADDRMAN_TRIED_BUCKETS_PER_GROUP{8};\n+/** Over how many buckets entries with new addresses originating from a single group are spread */\n+static constexpr uint32_t ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP{64};\n+/** Maximum number of times an address can be added to the new table */\n+static constexpr int32_t ADDRMAN_NEW_BUCKETS_PER_ADDRESS{8};\n+/** How old addresses can maximally be */\n+static constexpr int64_t ADDRMAN_HORIZON_DAYS{30};\n+/** After how many failed attempts we give up on a new node */\n+static constexpr int32_t ADDRMAN_RETRIES{3};\n+/** How many successive failures are allowed ... */\n+static constexpr int32_t ADDRMAN_MAX_FAILURES{10};\n+/** ... in at least this many days */\n+static constexpr int64_t ADDRMAN_MIN_FAIL_DAYS{7};\n+/** How recent a successful connection should be before we allow an address to be evicted from tried */\n+static constexpr int64_t ADDRMAN_REPLACEMENT_HOURS{4};\n+/** The maximum number of tried addr collisions to store */\n+static constexpr size_t ADDRMAN_SET_TRIED_COLLISION_SIZE{10};\n+/** The maximum time we'll spend trying to resolve a tried table collision, in seconds */\n+static constexpr int64_t ADDRMAN_TEST_WINDOW{40*60}; // 40 minutes\n+\n int CAddrInfo::GetTriedBucket(const uint256& nKey, const std::vector<bool> &asmap) const\n {\n     uint64_t hash1 = (CHashWriter(SER_GETHASH, 0) << nKey << GetKey()).GetCheapHash();\n@@ -77,10 +100,11 @@ double CAddrInfo::GetChance(int64_t nNow) const\n     return fChance;\n }\n \n-CAddrMan::CAddrMan(bool deterministic, int32_t consistency_check_ratio)\n+CAddrMan::CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio)\n     : insecure_rand{deterministic}\n     , nKey{deterministic ? uint256{1} : insecure_rand.rand256()}\n     , m_consistency_check_ratio{consistency_check_ratio}\n+    , m_asmap{std::move(asmap)}\n {\n     for (auto& bucket : vvNew) {\n         for (auto& entry : bucket) {\n@@ -94,6 +118,285 @@ CAddrMan::CAddrMan(bool deterministic, int32_t consistency_check_ratio)\n     }\n }\n \n+template <typename Stream>\n+void CAddrMan::Serialize(Stream& s_) const\n+{\n+    LOCK(cs);\n+\n+    /**\n+     * Serialized format.\n+     * * format version byte (@see `Format`)\n+     * * lowest compatible format version byte. This is used to help old software decide\n+     *   whether to parse the file. For example:\n+     *   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is\n+     *     introduced in version N+1 that is compatible with format=3 and it is known that\n+     *     version N will be able to parse it, then version N+1 will write\n+     *     (format=4, lowest_compatible=3) in the first two bytes of the file, and so\n+     *     version N will still try to parse it.\n+     *   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write\n+     *     (format=5, lowest_compatible=5) and so any versions that do not know how to parse\n+     *     format=5 will not try to read the file.\n+     * * nKey\n+     * * nNew\n+     * * nTried\n+     * * number of \"new\" buckets XOR 2**30\n+     * * all new addresses (total count: nNew)\n+     * * all tried addresses (total count: nTried)\n+     * * for each new bucket:\n+     *   * number of elements\n+     *   * for each element: index in the serialized \"all new addresses\"\n+     * * asmap checksum\n+     *\n+     * 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it\n+     * as incompatible. This is necessary because it did not check the version number on\n+     * deserialization.\n+     *\n+     * vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;\n+     * they are instead reconstructed from the other information.\n+     *\n+     * This format is more complex, but significantly smaller (at most 1.5 MiB), and supports\n+     * changes to the ADDRMAN_ parameters without breaking the on-disk structure.\n+     *\n+     * We don't use SERIALIZE_METHODS since the serialization and deserialization code has\n+     * very little in common.\n+     */\n+\n+    // Always serialize in the latest version (FILE_FORMAT).\n+\n+    OverrideStream<Stream> s(&s_, s_.GetType(), s_.GetVersion() | ADDRV2_FORMAT);\n+\n+    s << static_cast<uint8_t>(FILE_FORMAT);\n+\n+    // Increment `lowest_compatible` iff a newly introduced format is incompatible with\n+    // the previous one.\n+    static constexpr uint8_t lowest_compatible = Format::V3_BIP155;\n+    s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);\n+\n+    s << nKey;\n+    s << nNew;\n+    s << nTried;\n+\n+    int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);\n+    s << nUBuckets;\n+    std::unordered_map<int, int> mapUnkIds;\n+    int nIds = 0;\n+    for (const auto& entry : mapInfo) {\n+        mapUnkIds[entry.first] = nIds;\n+        const CAddrInfo &info = entry.second;\n+        if (info.nRefCount) {\n+            assert(nIds != nNew); // this means nNew was wrong, oh ow\n+            s << info;\n+            nIds++;\n+        }\n+    }\n+    nIds = 0;\n+    for (const auto& entry : mapInfo) {\n+        const CAddrInfo &info = entry.second;\n+        if (info.fInTried) {\n+            assert(nIds != nTried); // this means nTried was wrong, oh ow\n+            s << info;\n+            nIds++;\n+        }\n+    }\n+    for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n+        int nSize = 0;\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            if (vvNew[bucket][i] != -1)\n+                nSize++;\n+        }\n+        s << nSize;\n+        for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n+            if (vvNew[bucket][i] != -1) {\n+                int nIndex = mapUnkIds[vvNew[bucket][i]];\n+                s << nIndex;\n+            }\n+        }\n+    }\n+    // Store asmap checksum after bucket entries so that it\n+    // can be ignored by older clients for backward compatibility.\n+    uint256 asmap_checksum;\n+    if (m_asmap.size() != 0) {\n+        asmap_checksum = SerializeHash(m_asmap);\n+    }\n+    s << asmap_checksum;\n+}\n+\n+template <typename Stream>\n+void CAddrMan::Unserialize(Stream& s_)\n+{\n+    LOCK(cs);\n+\n+    assert(vRandom.empty());\n+\n+    Format format;\n+    s_ >> Using<CustomUintFormatter<1>>(format);\n+\n+    int stream_version = s_.GetVersion();\n+    if (format >= Format::V3_BIP155) {\n+        // Add ADDRV2_FORMAT to the version so that the CNetAddr and CAddress\n+        // unserialize methods know that an address in addrv2 format is coming.\n+        stream_version |= ADDRV2_FORMAT;\n+    }\n+\n+    OverrideStream<Stream> s(&s_, s_.GetType(), stream_version);\n+\n+    uint8_t compat;\n+    s >> compat;\n+    const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;\n+    if (lowest_compatible > FILE_FORMAT) {\n+        throw std::ios_base::failure(strprintf(\n+            \"Unsupported format of addrman database: %u. It is compatible with formats >=%u, \"\n+            \"but the maximum supported by this version of %s is %u.\",\n+            uint8_t{format}, uint8_t{lowest_compatible}, PACKAGE_NAME, uint8_t{FILE_FORMAT}));\n+    }\n+\n+    s >> nKey;\n+    s >> nNew;\n+    s >> nTried;\n+    int nUBuckets = 0;\n+    s >> nUBuckets;\n+    if (format >= Format::V1_DETERMINISTIC) {\n+        nUBuckets ^= (1 << 30);\n+    }\n+\n+    if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {\n+        throw std::ios_base::failure(\n+                strprintf(\"Corrupt CAddrMan serialization: nNew=%d, should be in [0, %d]\",\n+                    nNew,\n+                    ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n+    }\n+\n+    if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {\n+        throw std::ios_base::failure(\n+                strprintf(\"Corrupt CAddrMan serialization: nTried=%d, should be in [0, %d]\",\n+                    nTried,\n+                    ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n+    }\n+\n+    // Deserialize entries from the new table.\n+    for (int n = 0; n < nNew; n++) {\n+        CAddrInfo &info = mapInfo[n];\n+        s >> info;\n+        mapAddr[info] = n;\n+        info.nRandomPos = vRandom.size();\n+        vRandom.push_back(n);\n+    }\n+    nIdCount = nNew;\n+\n+    // Deserialize entries from the tried table.\n+    int nLost = 0;\n+    for (int n = 0; n < nTried; n++) {\n+        CAddrInfo info;\n+        s >> info;\n+        int nKBucket = info.GetTriedBucket(nKey, m_asmap);\n+        int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n+        if (info.IsValid()\n+                && vvTried[nKBucket][nKBucketPos] == -1) {\n+            info.nRandomPos = vRandom.size();\n+            info.fInTried = true;\n+            vRandom.push_back(nIdCount);\n+            mapInfo[nIdCount] = info;\n+            mapAddr[info] = nIdCount;\n+            vvTried[nKBucket][nKBucketPos] = nIdCount;\n+            nIdCount++;\n+        } else {\n+            nLost++;\n+        }\n+    }\n+    nTried -= nLost;\n+\n+    // Store positions in the new table buckets to apply later (if possible).\n+    // An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,\n+    // so we store all bucket-entry_index pairs to iterate through later.\n+    std::vector<std::pair<int, int>> bucket_entries;\n+\n+    for (int bucket = 0; bucket < nUBuckets; ++bucket) {\n+        int num_entries{0};\n+        s >> num_entries;\n+        for (int n = 0; n < num_entries; ++n) {\n+            int entry_index{0};\n+            s >> entry_index;\n+            if (entry_index >= 0 && entry_index < nNew) {\n+                bucket_entries.emplace_back(bucket, entry_index);\n+            }\n+        }\n+    }\n+\n+    // If the bucket count and asmap checksum haven't changed, then attempt\n+    // to restore the entries to the buckets/positions they were in before\n+    // serialization.\n+    uint256 supplied_asmap_checksum;\n+    if (m_asmap.size() != 0) {\n+        supplied_asmap_checksum = SerializeHash(m_asmap);\n+    }\n+    uint256 serialized_asmap_checksum;\n+    if (format >= Format::V2_ASMAP) {\n+        s >> serialized_asmap_checksum;\n+    }\n+    const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&\n+        serialized_asmap_checksum == supplied_asmap_checksum};\n+\n+    if (!restore_bucketing) {\n+        LogPrint(BCLog::ADDRMAN, \"Bucketing method was updated, re-bucketing addrman entries from disk\\n\");\n+    }\n+\n+    for (auto bucket_entry : bucket_entries) {\n+        int bucket{bucket_entry.first};\n+        const int entry_index{bucket_entry.second};\n+        CAddrInfo& info = mapInfo[entry_index];\n+\n+        // Don't store the entry in the new bucket if it's not a valid address for our addrman\n+        if (!info.IsValid()) continue;\n+\n+        // The entry shouldn't appear in more than\n+        // ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip\n+        // this bucket_entry.\n+        if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;\n+\n+        int bucket_position = info.GetBucketPosition(nKey, true, bucket);\n+        if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {\n+            // Bucketing has not changed, using existing bucket positions for the new table\n+            vvNew[bucket][bucket_position] = entry_index;\n+            ++info.nRefCount;\n+        } else {\n+            // In case the new table data cannot be used (bucket count wrong or new asmap),\n+            // try to give them a reference based on their primary source address.\n+            bucket = info.GetNewBucket(nKey, m_asmap);\n+            bucket_position = info.GetBucketPosition(nKey, true, bucket);\n+            if (vvNew[bucket][bucket_position] == -1) {\n+                vvNew[bucket][bucket_position] = entry_index;\n+                ++info.nRefCount;\n+            }\n+        }\n+    }\n+\n+    // Prune new entries with refcount 0 (as a result of collisions or invalid address).\n+    int nLostUnk = 0;\n+    for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {\n+        if (it->second.fInTried == false && it->second.nRefCount == 0) {\n+            const auto itCopy = it++;\n+            Delete(itCopy->first);\n+            ++nLostUnk;\n+        } else {\n+            ++it;\n+        }\n+    }\n+    if (nLost + nLostUnk > 0) {\n+        LogPrint(BCLog::ADDRMAN, \"addrman lost %i new and %i tried addresses due to collisions or invalid addresses\\n\", nLostUnk, nLost);\n+    }\n+\n+    Check();\n+}\n+\n+// explicit instantiation\n+template void CAddrMan::Serialize(CHashWriter& s) const;\n+template void CAddrMan::Serialize(CAutoFile& s) const;\n+template void CAddrMan::Serialize(CDataStream& s) const;\n+template void CAddrMan::Unserialize(CAutoFile& s);\n+template void CAddrMan::Unserialize(CHashVerifier<CAutoFile>& s);\n+template void CAddrMan::Unserialize(CDataStream& s);\n+template void CAddrMan::Unserialize(CHashVerifier<CDataStream>& s);\n+\n CAddrInfo* CAddrMan::Find(const CNetAddr& addr, int* pnId)\n {\n     AssertLockHeld(cs);\n@@ -706,30 +1009,3 @@ CAddrInfo CAddrMan::SelectTriedCollision_()\n \n     return mapInfo[id_old];\n }\n-\n-std::vector<bool> CAddrMan::DecodeAsmap(fs::path path)\n-{\n-    std::vector<bool> bits;\n-    FILE *filestr = fsbridge::fopen(path, \"rb\");\n-    CAutoFile file(filestr, SER_DISK, CLIENT_VERSION);\n-    if (file.IsNull()) {\n-        LogPrintf(\"Failed to open asmap file from disk\\n\");\n-        return bits;\n-    }\n-    fseek(filestr, 0, SEEK_END);\n-    int length = ftell(filestr);\n-    LogPrintf(\"Opened asmap file %s (%d bytes) from disk\\n\", path, length);\n-    fseek(filestr, 0, SEEK_SET);\n-    uint8_t cur_byte;\n-    for (int i = 0; i < length; ++i) {\n-        file >> cur_byte;\n-        for (int bit = 0; bit < 8; ++bit) {\n-            bits.push_back((cur_byte >> bit) & 1);\n-        }\n-    }\n-    if (!SanityCheckASMap(bits)) {\n-        LogPrintf(\"Sanity check of asmap file %s failed\\n\", path);\n-        return {};\n-    }\n-    return bits;\n-}"
      },
      {
        "sha": "0885231ebc45fdfd1f2c1457757d96094aa8b0a9",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 32,
        "deletions": 337,
        "changes": 369,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -6,23 +6,16 @@\n #ifndef BITCOIN_ADDRMAN_H\n #define BITCOIN_ADDRMAN_H\n \n-#include <clientversion.h>\n-#include <config/bitcoin-config.h>\n #include <fs.h>\n-#include <hash.h>\n+#include <logging.h>\n #include <netaddress.h>\n #include <protocol.h>\n-#include <random.h>\n-#include <streams.h>\n #include <sync.h>\n #include <timedata.h>\n-#include <tinyformat.h>\n-#include <util/system.h>\n \n-#include <iostream>\n+#include <cstdint>\n #include <optional>\n #include <set>\n-#include <stdint.h>\n #include <unordered_map>\n #include <vector>\n \n@@ -131,347 +124,31 @@ class CAddrInfo : public CAddress\n  *      configuration option will introduce (expensive) consistency checks for the entire data structure.\n  */\n \n-//! total number of buckets for tried addresses\n-#define ADDRMAN_TRIED_BUCKET_COUNT_LOG2 8\n+/** Total number of buckets for tried addresses */\n+static constexpr int32_t ADDRMAN_TRIED_BUCKET_COUNT_LOG2{8};\n+static constexpr int ADDRMAN_TRIED_BUCKET_COUNT{1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2};\n \n-//! total number of buckets for new addresses\n-#define ADDRMAN_NEW_BUCKET_COUNT_LOG2 10\n+/** Total number of buckets for new addresses */\n+static constexpr int32_t ADDRMAN_NEW_BUCKET_COUNT_LOG2{10};\n+static constexpr int ADDRMAN_NEW_BUCKET_COUNT{1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2};\n \n-//! maximum allowed number of entries in buckets for new and tried addresses\n-#define ADDRMAN_BUCKET_SIZE_LOG2 6\n-\n-//! over how many buckets entries with tried addresses from a single group (/16 for IPv4) are spread\n-#define ADDRMAN_TRIED_BUCKETS_PER_GROUP 8\n-\n-//! over how many buckets entries with new addresses originating from a single group are spread\n-#define ADDRMAN_NEW_BUCKETS_PER_SOURCE_GROUP 64\n-\n-//! in how many buckets for entries with new addresses a single address may occur\n-#define ADDRMAN_NEW_BUCKETS_PER_ADDRESS 8\n-\n-//! how old addresses can maximally be\n-#define ADDRMAN_HORIZON_DAYS 30\n-\n-//! after how many failed attempts we give up on a new node\n-#define ADDRMAN_RETRIES 3\n-\n-//! how many successive failures are allowed ...\n-#define ADDRMAN_MAX_FAILURES 10\n-\n-//! ... in at least this many days\n-#define ADDRMAN_MIN_FAIL_DAYS 7\n-\n-//! how recent a successful connection should be before we allow an address to be evicted from tried\n-#define ADDRMAN_REPLACEMENT_HOURS 4\n-\n-//! Convenience\n-#define ADDRMAN_TRIED_BUCKET_COUNT (1 << ADDRMAN_TRIED_BUCKET_COUNT_LOG2)\n-#define ADDRMAN_NEW_BUCKET_COUNT (1 << ADDRMAN_NEW_BUCKET_COUNT_LOG2)\n-#define ADDRMAN_BUCKET_SIZE (1 << ADDRMAN_BUCKET_SIZE_LOG2)\n-\n-//! the maximum number of tried addr collisions to store\n-#define ADDRMAN_SET_TRIED_COLLISION_SIZE 10\n-\n-//! the maximum time we'll spend trying to resolve a tried table collision, in seconds\n-static const int64_t ADDRMAN_TEST_WINDOW = 40*60; // 40 minutes\n+/** Maximum allowed number of entries in buckets for new and tried addresses */\n+static constexpr int32_t ADDRMAN_BUCKET_SIZE_LOG2{6};\n+static constexpr int ADDRMAN_BUCKET_SIZE{1 << ADDRMAN_BUCKET_SIZE_LOG2};\n \n /**\n  * Stochastical (IP) address manager\n  */\n class CAddrMan\n {\n public:\n-    // Compressed IP->ASN mapping, loaded from a file when a node starts.\n-    // Should be always empty if no file was provided.\n-    // This mapping is then used for bucketing nodes in Addrman.\n-    //\n-    // If asmap is provided, nodes will be bucketed by\n-    // AS they belong to, in order to make impossible for a node\n-    // to connect to several nodes hosted in a single AS.\n-    // This is done in response to Erebus attack, but also to generally\n-    // diversify the connections every node creates,\n-    // especially useful when a large fraction of nodes\n-    // operate under a couple of cloud providers.\n-    //\n-    // If a new asmap was provided, the existing records\n-    // would be re-bucketed accordingly.\n-    std::vector<bool> m_asmap;\n-\n-    // Read asmap from provided binary file\n-    static std::vector<bool> DecodeAsmap(fs::path path);\n-\n-    /**\n-     * Serialized format.\n-     * * format version byte (@see `Format`)\n-     * * lowest compatible format version byte. This is used to help old software decide\n-     *   whether to parse the file. For example:\n-     *   * Bitcoin Core version N knows how to parse up to format=3. If a new format=4 is\n-     *     introduced in version N+1 that is compatible with format=3 and it is known that\n-     *     version N will be able to parse it, then version N+1 will write\n-     *     (format=4, lowest_compatible=3) in the first two bytes of the file, and so\n-     *     version N will still try to parse it.\n-     *   * Bitcoin Core version N+2 introduces a new incompatible format=5. It will write\n-     *     (format=5, lowest_compatible=5) and so any versions that do not know how to parse\n-     *     format=5 will not try to read the file.\n-     * * nKey\n-     * * nNew\n-     * * nTried\n-     * * number of \"new\" buckets XOR 2**30\n-     * * all new addresses (total count: nNew)\n-     * * all tried addresses (total count: nTried)\n-     * * for each new bucket:\n-     *   * number of elements\n-     *   * for each element: index in the serialized \"all new addresses\"\n-     * * asmap checksum\n-     *\n-     * 2**30 is xorred with the number of buckets to make addrman deserializer v0 detect it\n-     * as incompatible. This is necessary because it did not check the version number on\n-     * deserialization.\n-     *\n-     * vvNew, vvTried, mapInfo, mapAddr and vRandom are never encoded explicitly;\n-     * they are instead reconstructed from the other information.\n-     *\n-     * This format is more complex, but significantly smaller (at most 1.5 MiB), and supports\n-     * changes to the ADDRMAN_ parameters without breaking the on-disk structure.\n-     *\n-     * We don't use SERIALIZE_METHODS since the serialization and deserialization code has\n-     * very little in common.\n-     */\n     template <typename Stream>\n-    void Serialize(Stream& s_) const\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-\n-        // Always serialize in the latest version (FILE_FORMAT).\n-\n-        OverrideStream<Stream> s(&s_, s_.GetType(), s_.GetVersion() | ADDRV2_FORMAT);\n-\n-        s << static_cast<uint8_t>(FILE_FORMAT);\n-\n-        // Increment `lowest_compatible` iff a newly introduced format is incompatible with\n-        // the previous one.\n-        static constexpr uint8_t lowest_compatible = Format::V3_BIP155;\n-        s << static_cast<uint8_t>(INCOMPATIBILITY_BASE + lowest_compatible);\n-\n-        s << nKey;\n-        s << nNew;\n-        s << nTried;\n-\n-        int nUBuckets = ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30);\n-        s << nUBuckets;\n-        std::unordered_map<int, int> mapUnkIds;\n-        int nIds = 0;\n-        for (const auto& entry : mapInfo) {\n-            mapUnkIds[entry.first] = nIds;\n-            const CAddrInfo &info = entry.second;\n-            if (info.nRefCount) {\n-                assert(nIds != nNew); // this means nNew was wrong, oh ow\n-                s << info;\n-                nIds++;\n-            }\n-        }\n-        nIds = 0;\n-        for (const auto& entry : mapInfo) {\n-            const CAddrInfo &info = entry.second;\n-            if (info.fInTried) {\n-                assert(nIds != nTried); // this means nTried was wrong, oh ow\n-                s << info;\n-                nIds++;\n-            }\n-        }\n-        for (int bucket = 0; bucket < ADDRMAN_NEW_BUCKET_COUNT; bucket++) {\n-            int nSize = 0;\n-            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-                if (vvNew[bucket][i] != -1)\n-                    nSize++;\n-            }\n-            s << nSize;\n-            for (int i = 0; i < ADDRMAN_BUCKET_SIZE; i++) {\n-                if (vvNew[bucket][i] != -1) {\n-                    int nIndex = mapUnkIds[vvNew[bucket][i]];\n-                    s << nIndex;\n-                }\n-            }\n-        }\n-        // Store asmap checksum after bucket entries so that it\n-        // can be ignored by older clients for backward compatibility.\n-        uint256 asmap_checksum;\n-        if (m_asmap.size() != 0) {\n-            asmap_checksum = SerializeHash(m_asmap);\n-        }\n-        s << asmap_checksum;\n-    }\n+    void Serialize(Stream& s_) const EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n     template <typename Stream>\n-    void Unserialize(Stream& s_)\n-        EXCLUSIVE_LOCKS_REQUIRED(!cs)\n-    {\n-        LOCK(cs);\n-\n-        assert(vRandom.empty());\n+    void Unserialize(Stream& s_) EXCLUSIVE_LOCKS_REQUIRED(!cs);\n \n-        Format format;\n-        s_ >> Using<CustomUintFormatter<1>>(format);\n-\n-        int stream_version = s_.GetVersion();\n-        if (format >= Format::V3_BIP155) {\n-            // Add ADDRV2_FORMAT to the version so that the CNetAddr and CAddress\n-            // unserialize methods know that an address in addrv2 format is coming.\n-            stream_version |= ADDRV2_FORMAT;\n-        }\n-\n-        OverrideStream<Stream> s(&s_, s_.GetType(), stream_version);\n-\n-        uint8_t compat;\n-        s >> compat;\n-        const uint8_t lowest_compatible = compat - INCOMPATIBILITY_BASE;\n-        if (lowest_compatible > FILE_FORMAT) {\n-            throw std::ios_base::failure(strprintf(\n-                \"Unsupported format of addrman database: %u. It is compatible with formats >=%u, \"\n-                \"but the maximum supported by this version of %s is %u.\",\n-                format, lowest_compatible, PACKAGE_NAME, static_cast<uint8_t>(FILE_FORMAT)));\n-        }\n-\n-        s >> nKey;\n-        s >> nNew;\n-        s >> nTried;\n-        int nUBuckets = 0;\n-        s >> nUBuckets;\n-        if (format >= Format::V1_DETERMINISTIC) {\n-            nUBuckets ^= (1 << 30);\n-        }\n-\n-        if (nNew > ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nNew < 0) {\n-            throw std::ios_base::failure(\n-                strprintf(\"Corrupt CAddrMan serialization: nNew=%d, should be in [0, %u]\",\n-                          nNew,\n-                          ADDRMAN_NEW_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n-        }\n-\n-        if (nTried > ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE || nTried < 0) {\n-            throw std::ios_base::failure(\n-                strprintf(\"Corrupt CAddrMan serialization: nTried=%d, should be in [0, %u]\",\n-                          nTried,\n-                          ADDRMAN_TRIED_BUCKET_COUNT * ADDRMAN_BUCKET_SIZE));\n-        }\n-\n-        // Deserialize entries from the new table.\n-        for (int n = 0; n < nNew; n++) {\n-            CAddrInfo &info = mapInfo[n];\n-            s >> info;\n-            mapAddr[info] = n;\n-            info.nRandomPos = vRandom.size();\n-            vRandom.push_back(n);\n-        }\n-        nIdCount = nNew;\n-\n-        // Deserialize entries from the tried table.\n-        int nLost = 0;\n-        for (int n = 0; n < nTried; n++) {\n-            CAddrInfo info;\n-            s >> info;\n-            int nKBucket = info.GetTriedBucket(nKey, m_asmap);\n-            int nKBucketPos = info.GetBucketPosition(nKey, false, nKBucket);\n-            if (info.IsValid()\n-                && vvTried[nKBucket][nKBucketPos] == -1) {\n-                info.nRandomPos = vRandom.size();\n-                info.fInTried = true;\n-                vRandom.push_back(nIdCount);\n-                mapInfo[nIdCount] = info;\n-                mapAddr[info] = nIdCount;\n-                vvTried[nKBucket][nKBucketPos] = nIdCount;\n-                nIdCount++;\n-            } else {\n-                nLost++;\n-            }\n-        }\n-        nTried -= nLost;\n-\n-        // Store positions in the new table buckets to apply later (if possible).\n-        // An entry may appear in up to ADDRMAN_NEW_BUCKETS_PER_ADDRESS buckets,\n-        // so we store all bucket-entry_index pairs to iterate through later.\n-        std::vector<std::pair<int, int>> bucket_entries;\n-\n-        for (int bucket = 0; bucket < nUBuckets; ++bucket) {\n-            int num_entries{0};\n-            s >> num_entries;\n-            for (int n = 0; n < num_entries; ++n) {\n-                int entry_index{0};\n-                s >> entry_index;\n-                if (entry_index >= 0 && entry_index < nNew) {\n-                    bucket_entries.emplace_back(bucket, entry_index);\n-                }\n-            }\n-        }\n-\n-        // If the bucket count and asmap checksum haven't changed, then attempt\n-        // to restore the entries to the buckets/positions they were in before\n-        // serialization.\n-        uint256 supplied_asmap_checksum;\n-        if (m_asmap.size() != 0) {\n-            supplied_asmap_checksum = SerializeHash(m_asmap);\n-        }\n-        uint256 serialized_asmap_checksum;\n-        if (format >= Format::V2_ASMAP) {\n-            s >> serialized_asmap_checksum;\n-        }\n-        const bool restore_bucketing{nUBuckets == ADDRMAN_NEW_BUCKET_COUNT &&\n-                                     serialized_asmap_checksum == supplied_asmap_checksum};\n-\n-        if (!restore_bucketing) {\n-            LogPrint(BCLog::ADDRMAN, \"Bucketing method was updated, re-bucketing addrman entries from disk\\n\");\n-        }\n-\n-        for (auto bucket_entry : bucket_entries) {\n-            int bucket{bucket_entry.first};\n-            const int entry_index{bucket_entry.second};\n-            CAddrInfo& info = mapInfo[entry_index];\n-\n-            // Don't store the entry in the new bucket if it's not a valid address for our addrman\n-            if (!info.IsValid()) continue;\n-\n-            // The entry shouldn't appear in more than\n-            // ADDRMAN_NEW_BUCKETS_PER_ADDRESS. If it has already, just skip\n-            // this bucket_entry.\n-            if (info.nRefCount >= ADDRMAN_NEW_BUCKETS_PER_ADDRESS) continue;\n-\n-            int bucket_position = info.GetBucketPosition(nKey, true, bucket);\n-            if (restore_bucketing && vvNew[bucket][bucket_position] == -1) {\n-                // Bucketing has not changed, using existing bucket positions for the new table\n-                vvNew[bucket][bucket_position] = entry_index;\n-                ++info.nRefCount;\n-            } else {\n-                // In case the new table data cannot be used (bucket count wrong or new asmap),\n-                // try to give them a reference based on their primary source address.\n-                bucket = info.GetNewBucket(nKey, m_asmap);\n-                bucket_position = info.GetBucketPosition(nKey, true, bucket);\n-                if (vvNew[bucket][bucket_position] == -1) {\n-                    vvNew[bucket][bucket_position] = entry_index;\n-                    ++info.nRefCount;\n-                }\n-            }\n-        }\n-\n-        // Prune new entries with refcount 0 (as a result of collisions or invalid address).\n-        int nLostUnk = 0;\n-        for (auto it = mapInfo.cbegin(); it != mapInfo.cend(); ) {\n-            if (it->second.fInTried == false && it->second.nRefCount == 0) {\n-                const auto itCopy = it++;\n-                Delete(itCopy->first);\n-                ++nLostUnk;\n-            } else {\n-                ++it;\n-            }\n-        }\n-        if (nLost + nLostUnk > 0) {\n-            LogPrint(BCLog::ADDRMAN, \"addrman lost %i new and %i tried addresses due to collisions or invalid addresses\\n\", nLostUnk, nLost);\n-        }\n-\n-        Check();\n-    }\n-\n-    explicit CAddrMan(bool deterministic, int32_t consistency_check_ratio);\n+    explicit CAddrMan(std::vector<bool> asmap, bool deterministic, int32_t consistency_check_ratio);\n \n     ~CAddrMan()\n     {\n@@ -593,6 +270,8 @@ class CAddrMan\n         Check();\n     }\n \n+    const std::vector<bool>& GetAsmap() const { return m_asmap; }\n+\n private:\n     //! A mutex to protect the inner data structures.\n     mutable Mutex cs;\n@@ -660,6 +339,22 @@ class CAddrMan\n     /** Perform consistency checks every m_consistency_check_ratio operations (if non-zero). */\n     const int32_t m_consistency_check_ratio;\n \n+    // Compressed IP->ASN mapping, loaded from a file when a node starts.\n+    // Should be always empty if no file was provided.\n+    // This mapping is then used for bucketing nodes in Addrman.\n+    //\n+    // If asmap is provided, nodes will be bucketed by\n+    // AS they belong to, in order to make impossible for a node\n+    // to connect to several nodes hosted in a single AS.\n+    // This is done in response to Erebus attack, but also to generally\n+    // diversify the connections every node creates,\n+    // especially useful when a large fraction of nodes\n+    // operate under a couple of cloud providers.\n+    //\n+    // If a new asmap was provided, the existing records\n+    // would be re-bucketed accordingly.\n+    const std::vector<bool> m_asmap;\n+\n     //! Find an entry.\n     CAddrInfo* Find(const CNetAddr& addr, int *pnId = nullptr) EXCLUSIVE_LOCKS_REQUIRED(cs);\n "
      },
      {
        "sha": "e5dd571a4ca8b8ea22e104651e75cf8c3f4126e8",
        "filename": "src/bench/addrman.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/bench/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/bench/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/addrman.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -5,6 +5,7 @@\n #include <addrman.h>\n #include <bench/bench.h>\n #include <random.h>\n+#include <util/check.h>\n #include <util/time.h>\n \n #include <optional>\n@@ -73,14 +74,14 @@ static void AddrManAdd(benchmark::Bench& bench)\n     CreateAddresses();\n \n     bench.run([&] {\n-        CAddrMan addrman{/* deterministic */ false, /* consistency_check_ratio */ 0};\n+        CAddrMan addrman{/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0};\n         AddAddressesToAddrMan(addrman);\n     });\n }\n \n static void AddrManSelect(benchmark::Bench& bench)\n {\n-    CAddrMan addrman(/* deterministic */ false, /* consistency_check_ratio */ 0);\n+    CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n \n     FillAddrMan(addrman);\n \n@@ -92,7 +93,7 @@ static void AddrManSelect(benchmark::Bench& bench)\n \n static void AddrManGetAddr(benchmark::Bench& bench)\n {\n-    CAddrMan addrman(/* deterministic */ false, /* consistency_check_ratio */ 0);\n+    CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n \n     FillAddrMan(addrman);\n \n@@ -110,11 +111,12 @@ static void AddrManGood(benchmark::Bench& bench)\n      * we want to do the same amount of work in every loop iteration. */\n \n     bench.epochs(5).epochIterations(1);\n-    const size_t addrman_count{bench.epochs() * bench.epochIterations()};\n+    const uint64_t addrman_count{bench.epochs() * bench.epochIterations()};\n+    Assert(addrman_count == 5U);\n \n     std::vector<std::unique_ptr<CAddrMan>> addrmans(addrman_count);\n     for (size_t i{0}; i < addrman_count; ++i) {\n-        addrmans[i] = std::make_unique<CAddrMan>(/* deterministic */ false, /* consistency_check_ratio */ 0);\n+        addrmans[i] = std::make_unique<CAddrMan>(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n         FillAddrMan(*addrmans[i]);\n     }\n "
      },
      {
        "sha": "934b574f8b39222ae92674186c16cd6f5742a82d",
        "filename": "src/bench/coin_selection.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/bench/coin_selection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/bench/coin_selection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/coin_selection.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -6,6 +6,7 @@\n #include <interfaces/chain.h>\n #include <node/context.h>\n #include <wallet/coinselection.h>\n+#include <wallet/spend.h>\n #include <wallet/wallet.h>\n \n #include <set>\n@@ -17,7 +18,7 @@ static void addCoin(const CAmount& nValue, const CWallet& wallet, std::vector<st\n     tx.nLockTime = nextLockTime++; // so all transactions get different hashes\n     tx.vout.resize(1);\n     tx.vout[0].nValue = nValue;\n-    wtxs.push_back(std::make_unique<CWalletTx>(&wallet, MakeTransactionRef(std::move(tx))));\n+    wtxs.push_back(std::make_unique<CWalletTx>(MakeTransactionRef(std::move(tx))));\n }\n \n // Simple benchmark for wallet coin selection. Note that it maybe be necessary\n@@ -45,18 +46,18 @@ static void CoinSelection(benchmark::Bench& bench)\n     // Create coins\n     std::vector<COutput> coins;\n     for (const auto& wtx : wtxs) {\n-        coins.emplace_back(wtx.get(), 0 /* iIn */, 6 * 24 /* nDepthIn */, true /* spendable */, true /* solvable */, true /* safe */);\n+        coins.emplace_back(wallet, *wtx, 0 /* iIn */, 6 * 24 /* nDepthIn */, true /* spendable */, true /* solvable */, true /* safe */);\n     }\n \n     const CoinEligibilityFilter filter_standard(1, 6, 0);\n     const CoinSelectionParams coin_selection_params(/* change_output_size= */ 34,\n                                                     /* change_spend_size= */ 148, /* effective_feerate= */ CFeeRate(0),\n                                                     /* long_term_feerate= */ CFeeRate(0), /* discard_feerate= */ CFeeRate(0),\n-                                                    /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n+                                                    /* tx_noinputs_size= */ 0, /* avoid_partial= */ false);\n     bench.run([&] {\n         std::set<CInputCoin> setCoinsRet;\n         CAmount nValueRet;\n-        bool success = wallet.AttemptSelection(1003 * COIN, filter_standard, coins, setCoinsRet, nValueRet, coin_selection_params);\n+        bool success = AttemptSelection(wallet, 1003 * COIN, filter_standard, coins, setCoinsRet, nValueRet, coin_selection_params);\n         assert(success);\n         assert(nValueRet == 1003 * COIN);\n         assert(setCoinsRet.size() == 2);\n@@ -75,9 +76,9 @@ static void add_coin(const CAmount& nValue, int nInput, std::vector<OutputGroup>\n     CMutableTransaction tx;\n     tx.vout.resize(nInput + 1);\n     tx.vout[nInput].nValue = nValue;\n-    std::unique_ptr<CWalletTx> wtx = std::make_unique<CWalletTx>(&testWallet, MakeTransactionRef(std::move(tx)));\n+    std::unique_ptr<CWalletTx> wtx = std::make_unique<CWalletTx>(MakeTransactionRef(std::move(tx)));\n     set.emplace_back();\n-    set.back().Insert(COutput(wtx.get(), nInput, 0, true, true, true).GetInputCoin(), 0, true, 0, 0, false);\n+    set.back().Insert(COutput(testWallet, *wtx, nInput, 0, true, true, true).GetInputCoin(), 0, true, 0, 0, false);\n     wtxn.emplace_back(std::move(wtx));\n }\n // Copied from src/wallet/test/coinselector_tests.cpp"
      },
      {
        "sha": "a205d8b6e76db2f01ef427d83c9729f15f45af2a",
        "filename": "src/bench/wallet_balance.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/bench/wallet_balance.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/bench/wallet_balance.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/wallet_balance.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -9,6 +9,7 @@\n #include <test/util/setup_common.h>\n #include <test/util/wallet.h>\n #include <validationinterface.h>\n+#include <wallet/receive.h>\n #include <wallet/wallet.h>\n \n #include <optional>\n@@ -35,11 +36,11 @@ static void WalletBalance(benchmark::Bench& bench, const bool set_dirty, const b\n     }\n     SyncWithValidationInterfaceQueue();\n \n-    auto bal = wallet.GetBalance(); // Cache\n+    auto bal = GetBalance(wallet); // Cache\n \n     bench.run([&] {\n         if (set_dirty) wallet.MarkDirty();\n-        bal = wallet.GetBalance();\n+        bal = GetBalance(wallet);\n         if (add_mine) assert(bal.m_mine_trusted > 0);\n         if (add_watchonly) assert(bal.m_watchonly_trusted > 0);\n     });"
      },
      {
        "sha": "4ccd1f4feea82b42b26e4be183bed56d5bfa19af",
        "filename": "src/bitcoin-cli.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 20,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/bitcoin-cli.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/bitcoin-cli.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-cli.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -93,9 +93,6 @@ static void SetupCliArgs(ArgsManager& argsman)\n /** libevent event log callback */\n static void libevent_log_cb(int severity, const char *msg)\n {\n-#ifndef EVENT_LOG_ERR // EVENT_LOG_ERR was added in 2.0.19; but before then _EVENT_LOG_ERR existed.\n-# define EVENT_LOG_ERR _EVENT_LOG_ERR\n-#endif\n     // Ignore everything other than errors\n     if (severity >= EVENT_LOG_ERR) {\n         throw std::runtime_error(strprintf(\"libevent error: %s\", msg));\n@@ -245,7 +242,7 @@ class BaseRequestHandler\n class AddrinfoRequestHandler : public BaseRequestHandler\n {\n private:\n-    static constexpr std::array m_networks{\"ipv4\", \"ipv6\", \"torv2\", \"torv3\", \"i2p\"};\n+    static constexpr std::array m_networks{\"ipv4\", \"ipv6\", \"onion\", \"i2p\"};\n     int8_t NetworkStringToId(const std::string& str) const\n     {\n         for (size_t i = 0; i < m_networks.size(); ++i) {\n@@ -271,13 +268,10 @@ class AddrinfoRequestHandler : public BaseRequestHandler\n         if (!nodes.empty() && nodes.at(0)[\"network\"].isNull()) {\n             throw std::runtime_error(\"-addrinfo requires bitcoind server to be running v22.0 and up\");\n         }\n-        // Count the number of peers we know by network, including torv2 versus torv3.\n+        // Count the number of peers known to our node, by network.\n         std::array<uint64_t, m_networks.size()> counts{{}};\n         for (const UniValue& node : nodes) {\n             std::string network_name{node[\"network\"].get_str()};\n-            if (network_name == \"onion\") {\n-                network_name = node[\"address\"].get_str().size() > 22 ? \"torv3\" : \"torv2\";\n-            }\n             const int8_t network_id{NetworkStringToId(network_name)};\n             if (network_id == UNKNOWN_NETWORK) continue;\n             ++counts.at(network_id);\n@@ -386,7 +380,9 @@ class NetinfoRequestHandler : public BaseRequestHandler\n     bool IsVersionSelected() const { return m_details_level == 3 || m_details_level == 4; }\n     bool m_is_asmap_on{false};\n     size_t m_max_addr_length{0};\n-    size_t m_max_age_length{3};\n+    size_t m_max_addr_processed_length{5};\n+    size_t m_max_addr_rate_limited_length{6};\n+    size_t m_max_age_length{5};\n     size_t m_max_id_length{2};\n     struct Peer {\n         std::string addr;\n@@ -396,13 +392,16 @@ class NetinfoRequestHandler : public BaseRequestHandler\n         std::string age;\n         double min_ping;\n         double ping;\n+        int64_t addr_processed;\n+        int64_t addr_rate_limited;\n         int64_t last_blck;\n         int64_t last_recv;\n         int64_t last_send;\n         int64_t last_trxn;\n         int id;\n         int mapped_as;\n         int version;\n+        bool is_addr_relay_enabled;\n         bool is_bip152_hb_from;\n         bool is_bip152_hb_to;\n         bool is_block_relay;\n@@ -483,6 +482,8 @@ class NetinfoRequestHandler : public BaseRequestHandler\n                 const int peer_id{peer[\"id\"].get_int()};\n                 const int mapped_as{peer[\"mapped_as\"].isNull() ? 0 : peer[\"mapped_as\"].get_int()};\n                 const int version{peer[\"version\"].get_int()};\n+                const int64_t addr_processed{peer[\"addr_processed\"].isNull() ? 0 : peer[\"addr_processed\"].get_int64()};\n+                const int64_t addr_rate_limited{peer[\"addr_rate_limited\"].isNull() ? 0 : peer[\"addr_rate_limited\"].get_int64()};\n                 const int64_t conn_time{peer[\"conntime\"].get_int64()};\n                 const int64_t last_blck{peer[\"last_block\"].get_int64()};\n                 const int64_t last_recv{peer[\"lastrecv\"].get_int64()};\n@@ -493,50 +494,60 @@ class NetinfoRequestHandler : public BaseRequestHandler\n                 const std::string addr{peer[\"addr\"].get_str()};\n                 const std::string age{conn_time == 0 ? \"\" : ToString((m_time_now - conn_time) / 60)};\n                 const std::string sub_version{peer[\"subver\"].get_str()};\n+                const bool is_addr_relay_enabled{peer[\"addr_relay_enabled\"].isNull() ? false : peer[\"addr_relay_enabled\"].get_bool()};\n                 const bool is_bip152_hb_from{peer[\"bip152_hb_from\"].get_bool()};\n                 const bool is_bip152_hb_to{peer[\"bip152_hb_to\"].get_bool()};\n-                m_peers.push_back({addr, sub_version, conn_type, network, age, min_ping, ping, last_blck, last_recv, last_send, last_trxn, peer_id, mapped_as, version, is_bip152_hb_from, is_bip152_hb_to, is_block_relay, is_outbound});\n+                m_peers.push_back({addr, sub_version, conn_type, network, age, min_ping, ping, addr_processed, addr_rate_limited, last_blck, last_recv, last_send, last_trxn, peer_id, mapped_as, version, is_addr_relay_enabled, is_bip152_hb_from, is_bip152_hb_to, is_block_relay, is_outbound});\n                 m_max_addr_length = std::max(addr.length() + 1, m_max_addr_length);\n+                m_max_addr_processed_length = std::max(ToString(addr_processed).length(), m_max_addr_processed_length);\n+                m_max_addr_rate_limited_length = std::max(ToString(addr_rate_limited).length(), m_max_addr_rate_limited_length);\n                 m_max_age_length = std::max(age.length(), m_max_age_length);\n                 m_max_id_length = std::max(ToString(peer_id).length(), m_max_id_length);\n                 m_is_asmap_on |= (mapped_as != 0);\n             }\n         }\n \n         // Generate report header.\n-        std::string result{strprintf(\"%s %s%s - %i%s\\n\\n\", PACKAGE_NAME, FormatFullVersion(), ChainToString(), networkinfo[\"protocolversion\"].get_int(), networkinfo[\"subversion\"].get_str())};\n+        std::string result{strprintf(\"%s client %s%s - server %i%s\\n\\n\", PACKAGE_NAME, FormatFullVersion(), ChainToString(), networkinfo[\"protocolversion\"].get_int(), networkinfo[\"subversion\"].get_str())};\n \n         // Report detailed peer connections list sorted by direction and minimum ping time.\n         if (DetailsRequested() && !m_peers.empty()) {\n             std::sort(m_peers.begin(), m_peers.end());\n-            result += strprintf(\"<->   type   net  mping   ping send recv  txn  blk  hb %*s \", m_max_age_length, \"age\");\n+            result += strprintf(\"<->   type   net  mping   ping send recv  txn  blk  hb %*s%*s%*s \",\n+                                m_max_addr_processed_length, \"addrp\",\n+                                m_max_addr_rate_limited_length, \"addrl\",\n+                                m_max_age_length, \"age\");\n             if (m_is_asmap_on) result += \" asmap \";\n             result += strprintf(\"%*s %-*s%s\\n\", m_max_id_length, \"id\", IsAddressSelected() ? m_max_addr_length : 0, IsAddressSelected() ? \"address\" : \"\", IsVersionSelected() ? \"version\" : \"\");\n             for (const Peer& peer : m_peers) {\n                 std::string version{ToString(peer.version) + peer.sub_version};\n                 result += strprintf(\n-                    \"%3s %6s %5s%7s%7s%5s%5s%5s%5s  %2s %*s%*i %*s %-*s%s\\n\",\n+                    \"%3s %6s %5s%7s%7s%5s%5s%5s%5s  %2s %*s%*s%*s%*i %*s %-*s%s\\n\",\n                     peer.is_outbound ? \"out\" : \"in\",\n                     ConnectionTypeForNetinfo(peer.conn_type),\n                     peer.network,\n                     PingTimeToString(peer.min_ping),\n                     PingTimeToString(peer.ping),\n-                    peer.last_send == 0 ? \"\" : ToString(m_time_now - peer.last_send),\n-                    peer.last_recv == 0 ? \"\" : ToString(m_time_now - peer.last_recv),\n-                    peer.last_trxn == 0 ? \"\" : ToString((m_time_now - peer.last_trxn) / 60),\n-                    peer.last_blck == 0 ? \"\" : ToString((m_time_now - peer.last_blck) / 60),\n+                    peer.last_send ? ToString(m_time_now - peer.last_send) : \"\",\n+                    peer.last_recv ? ToString(m_time_now - peer.last_recv) : \"\",\n+                    peer.last_trxn ? ToString((m_time_now - peer.last_trxn) / 60) : peer.is_block_relay ? \"*\" : \"\",\n+                    peer.last_blck ? ToString((m_time_now - peer.last_blck) / 60) : \"\",\n                     strprintf(\"%s%s\", peer.is_bip152_hb_to ? \".\" : \" \", peer.is_bip152_hb_from ? \"*\" : \" \"),\n+                    m_max_addr_processed_length, // variable spacing\n+                    peer.addr_processed ? ToString(peer.addr_processed) : peer.is_addr_relay_enabled ? \"\" : \".\",\n+                    m_max_addr_rate_limited_length, // variable spacing\n+                    peer.addr_rate_limited ? ToString(peer.addr_rate_limited) : \"\",\n                     m_max_age_length, // variable spacing\n                     peer.age,\n                     m_is_asmap_on ? 7 : 0, // variable spacing\n-                    m_is_asmap_on && peer.mapped_as != 0 ? ToString(peer.mapped_as) : \"\",\n+                    m_is_asmap_on && peer.mapped_as ? ToString(peer.mapped_as) : \"\",\n                     m_max_id_length, // variable spacing\n                     peer.id,\n                     IsAddressSelected() ? m_max_addr_length : 0, // variable spacing\n                     IsAddressSelected() ? peer.addr : \"\",\n                     IsVersionSelected() && version != \"0\" ? version : \"\");\n             }\n-            result += strprintf(\"                     ms     ms  sec  sec  min  min     %*s\\n\\n\", m_max_age_length, \"min\");\n+            result += strprintf(\"                     ms     ms  sec  sec  min  min                %*s\\n\\n\", m_max_age_length, \"min\");\n         }\n \n         // Report peer connection totals by type.\n@@ -610,10 +621,14 @@ class NetinfoRequestHandler : public BaseRequestHandler\n         \"  send     Time since last message sent to the peer, in seconds\\n\"\n         \"  recv     Time since last message received from the peer, in seconds\\n\"\n         \"  txn      Time since last novel transaction received from the peer and accepted into our mempool, in minutes\\n\"\n+        \"           \\\"*\\\" - the peer requested we not relay transactions to it (relaytxes is false)\\n\"\n         \"  blk      Time since last novel block passing initial validity checks received from the peer, in minutes\\n\"\n         \"  hb       High-bandwidth BIP152 compact block relay\\n\"\n         \"           \\\".\\\" (to)   - we selected the peer as a high-bandwidth peer\\n\"\n         \"           \\\"*\\\" (from) - the peer selected us as a high-bandwidth peer\\n\"\n+        \"  addrp    Total number of addresses processed, excluding those dropped due to rate limiting\\n\"\n+        \"           \\\".\\\" - we do not relay addresses to this peer (addr_relay_enabled is false)\\n\"\n+        \"  addrl    Total number of addresses dropped due to rate limiting\\n\"\n         \"  age      Duration of connection to the peer, in minutes\\n\"\n         \"  asmap    Mapped AS (Autonomous System) number in the BGP route to the peer, used for diversifying\\n\"\n         \"           peer selection (only displayed if the -asmap config option is set)\\n\"\n@@ -885,7 +900,7 @@ static void GetWalletBalances(UniValue& result)\n }\n \n /**\n- * GetProgressBar contructs a progress bar with 5% intervals.\n+ * GetProgressBar constructs a progress bar with 5% intervals.\n  *\n  * @param[in]   progress      The proportion of the progress bar to be filled between 0 and 1.\n  * @param[out]  progress_bar  String representation of the progress bar."
      },
      {
        "sha": "58c51bd8e0bc588225aca5b5553c69b40801de44",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -188,10 +188,11 @@ static void RegisterLoad(const std::string& strInput)\n \n static CAmount ExtractAndValidateValue(const std::string& strValue)\n {\n-    CAmount value;\n-    if (!ParseMoney(strValue, value))\n+    if (std::optional<CAmount> parsed = ParseMoney(strValue)) {\n+        return parsed.value();\n+    } else {\n         throw std::runtime_error(\"invalid TX output value\");\n-    return value;\n+    }\n }\n \n static void MutateTxVersion(CMutableTransaction& tx, const std::string& cmdVal)\n@@ -771,9 +772,7 @@ static std::string readStdin()\n     if (ferror(stdin))\n         throw std::runtime_error(\"error reading stdin\");\n \n-    boost::algorithm::trim_right(ret);\n-\n-    return ret;\n+    return TrimString(ret);\n }\n \n static int CommandLineRawTx(int argc, char* argv[])"
      },
      {
        "sha": "4cc37560a3d94a26131d8b14fb0432bb42036006",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -392,7 +392,7 @@ class CRegTestParams : public CChainParams {\n         consensus.BIP16Exception = uint256();\n         consensus.BIP34Height = 2; // BIP34 activated on regtest (Block at height 1 not enforced for testing purposes)\n         consensus.BIP34Hash = uint256();\n-        consensus.BIP65Height = 1351; // BIP65 activated on regtest (Used in functional tests)\n+        consensus.BIP65Height = 111; // BIP65 activated on regtest (Block at height 110 and earlier not enforced for testing purposes)\n         consensus.BIP66Height = 102; // BIP66 activated on regtest (Block at height 101 and earlier not enforced for testing purposes)\n         consensus.CSVHeight = 432; // CSV activated on regtest (Used in rpc activation tests)\n         consensus.SegwitHeight = 0; // SEGWIT is always activated on regtest unless overridden"
      },
      {
        "sha": "ff581d4a9e1866d980bdb6f8f87e6f6c3ec71f65",
        "filename": "src/compat/glibc_compat.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 62,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/243a352d63078b8eacba0c64f991bc359c9ff1f7/src/compat/glibc_compat.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/243a352d63078b8eacba0c64f991bc359c9ff1f7/src/compat/glibc_compat.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/compat/glibc_compat.cpp?ref=243a352d63078b8eacba0c64f991bc359c9ff1f7",
        "patch": "@@ -1,62 +0,0 @@\n-// Copyright (c) 2009-2020 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#if defined(HAVE_CONFIG_H)\n-#include <config/bitcoin-config.h>\n-#endif\n-\n-#include <cstddef>\n-#include <cstdint>\n-\n-#if defined(__i386__) || defined(__arm__)\n-\n-extern \"C\" int64_t __udivmoddi4(uint64_t u, uint64_t v, uint64_t* rp);\n-\n-extern \"C\" int64_t __wrap___divmoddi4(int64_t u, int64_t v, int64_t* rp)\n-{\n-    int32_t c1 = 0, c2 = 0;\n-    int64_t uu = u, vv = v;\n-    int64_t w;\n-    int64_t r;\n-\n-    if (uu < 0) {\n-        c1 = ~c1, c2 = ~c2, uu = -uu;\n-    }\n-    if (vv < 0) {\n-        c1 = ~c1, vv = -vv;\n-    }\n-\n-    w = __udivmoddi4(uu, vv, (uint64_t*)&r);\n-    if (c1)\n-        w = -w;\n-    if (c2)\n-        r = -r;\n-\n-    *rp = r;\n-    return w;\n-}\n-#endif\n-\n-extern \"C\" float log2f_old(float x);\n-#ifdef __i386__\n-__asm(\".symver log2f_old,log2f@GLIBC_2.1\");\n-#elif defined(__amd64__)\n-__asm(\".symver log2f_old,log2f@GLIBC_2.2.5\");\n-#elif defined(__arm__)\n-__asm(\".symver log2f_old,log2f@GLIBC_2.4\");\n-#elif defined(__aarch64__)\n-__asm(\".symver log2f_old,log2f@GLIBC_2.17\");\n-#elif defined(__powerpc64__)\n-#  ifdef WORDS_BIGENDIAN\n-__asm(\".symver log2f_old,log2f@GLIBC_2.3\");\n-#  else\n-__asm(\".symver log2f_old,log2f@GLIBC_2.17\");\n-#  endif\n-#elif defined(__riscv)\n-__asm(\".symver log2f_old,log2f@GLIBC_2.27\");\n-#endif\n-extern \"C\" float __wrap_log2f(float x)\n-{\n-    return log2f_old(x);\n-}"
      },
      {
        "sha": "8caeb3262788399b933d42df03abb1dffffc047b",
        "filename": "src/dummywallet.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/dummywallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/dummywallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dummywallet.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -5,12 +5,14 @@\n #include <util/system.h>\n #include <walletinitinterface.h>\n \n+class ArgsManager;\n class CWallet;\n \n namespace interfaces {\n class Chain;\n class Handler;\n class Wallet;\n+class WalletClient;\n }\n \n class DummyWalletInit : public WalletInitInterface {\n@@ -28,6 +30,7 @@ void DummyWalletInit::AddWalletOptions(ArgsManager& argsman) const\n         \"-addresstype\",\n         \"-avoidpartialspends\",\n         \"-changetype\",\n+        \"-consolidatefeerate=<amt>\",\n         \"-disablewallet\",\n         \"-discardfee=<amt>\",\n         \"-fallbackfee=<amt>\",\n@@ -63,4 +66,9 @@ std::unique_ptr<Wallet> MakeWallet(const std::shared_ptr<CWallet>& wallet)\n     throw std::logic_error(\"Wallet function called in non-wallet build.\");\n }\n \n+std::unique_ptr<WalletClient> MakeWalletClient(Chain& chain, ArgsManager& args)\n+{\n+    throw std::logic_error(\"Wallet function called in non-wallet build.\");\n+}\n+\n } // namespace interfaces"
      },
      {
        "sha": "b9b3c46d8d6255644814371a319473f1f037600f",
        "filename": "src/fs.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 1,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/fs.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/fs.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/fs.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -154,7 +154,10 @@ std::string get_filesystem_error_message(const fs::filesystem_error& e)\n #ifdef __GLIBCXX__\n \n // reference: https://github.com/gcc-mirror/gcc/blob/gcc-7_3_0-release/libstdc%2B%2B-v3/include/std/fstream#L270\n-\n+#if defined(__GNUC__) && !defined(__clang__)\n+#pragma GCC diagnostic push\n+#pragma GCC diagnostic ignored \"-Wswitch\"\n+#endif\n static std::string openmodeToStr(std::ios_base::openmode mode)\n {\n     switch (mode & ~std::ios_base::ate) {\n@@ -192,6 +195,9 @@ static std::string openmodeToStr(std::ios_base::openmode mode)\n         return std::string();\n     }\n }\n+#if defined(__GNUC__) && !defined(__clang__)\n+#pragma GCC diagnostic pop\n+#endif\n \n void ifstream::open(const fs::path& p, std::ios_base::openmode mode)\n {\n@@ -242,7 +248,11 @@ void ofstream::close()\n }\n #else // __GLIBCXX__\n \n+#if BOOST_VERSION >= 107700\n+static_assert(sizeof(*BOOST_FILESYSTEM_C_STR(fs::path())) == sizeof(wchar_t),\n+#else\n static_assert(sizeof(*fs::path().BOOST_FILESYSTEM_C_STR) == sizeof(wchar_t),\n+#endif // BOOST_VERSION >= 107700\n     \"Warning: This build is using boost::filesystem ofstream and ifstream \"\n     \"implementations which will fail to open paths containing multibyte \"\n     \"characters. You should delete this static_assert to ignore this warning, \""
      },
      {
        "sha": "9ae592be7924ee8fd0a8be6faeea62e261b244e7",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -10,6 +10,7 @@\n #include <rpc/protocol.h>\n #include <rpc/server.h>\n #include <util/strencodings.h>\n+#include <util/string.h>\n #include <util/system.h>\n #include <util/translation.h>\n #include <walletinitinterface.h>\n@@ -22,7 +23,7 @@\n #include <set>\n #include <string>\n \n-#include <boost/algorithm/string.hpp> // boost::trim\n+#include <boost/algorithm/string.hpp>\n \n /** WWW-Authenticate to present with 401 Unauthorized response */\n static const char* WWW_AUTH_HEADER_DATA = \"Basic realm=\\\"jsonrpc\\\"\";\n@@ -130,8 +131,7 @@ static bool RPCAuthorized(const std::string& strAuth, std::string& strAuthUserna\n         return false;\n     if (strAuth.substr(0, 6) != \"Basic \")\n         return false;\n-    std::string strUserPass64 = strAuth.substr(6);\n-    boost::trim(strUserPass64);\n+    std::string strUserPass64 = TrimString(strAuth.substr(6));\n     std::string strUserPass = DecodeBase64(strUserPass64);\n \n     if (strUserPass.find(':') != std::string::npos)"
      },
      {
        "sha": "fa0379f61246e762abe97285e5ae675687c25aa4",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -338,10 +338,6 @@ static void HTTPWorkQueueRun(WorkQueue<HTTPClosure>* queue, int worker_num)\n /** libevent event log callback */\n static void libevent_log_cb(int severity, const char *msg)\n {\n-#ifndef EVENT_LOG_WARN\n-// EVENT_LOG_WARN was added in 2.0.19; but before then _EVENT_LOG_WARN existed.\n-# define EVENT_LOG_WARN _EVENT_LOG_WARN\n-#endif\n     if (severity >= EVENT_LOG_WARN) // Log warn messages and higher without debug category\n         LogPrintf(\"libevent: %s\\n\", msg);\n     else"
      },
      {
        "sha": "1390e3e57075b1d2583b56498f96fdf1da5129fd",
        "filename": "src/index/base.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/index/base.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/index/base.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -6,11 +6,10 @@\n #define BITCOIN_INDEX_BASE_H\n \n #include <dbwrapper.h>\n-#include <primitives/block.h>\n-#include <primitives/transaction.h>\n #include <threadinterrupt.h>\n #include <validationinterface.h>\n \n+class CBlock;\n class CBlockIndex;\n class CChainState;\n "
      },
      {
        "sha": "209785d487c8bdfdfce5ea950291ac92dc20d853",
        "filename": "src/index/txindex.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 161,
        "changes": 163,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/index/txindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/index/txindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -2,18 +2,14 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <index/disktxpos.h>\n #include <index/txindex.h>\n+\n+#include <index/disktxpos.h>\n #include <node/blockstorage.h>\n-#include <node/ui_interface.h>\n-#include <shutdown.h>\n #include <util/system.h>\n-#include <util/translation.h>\n #include <validation.h>\n \n-constexpr uint8_t DB_BEST_BLOCK{'B'};\n constexpr uint8_t DB_TXINDEX{'t'};\n-constexpr uint8_t DB_TXINDEX_BLOCK{'T'};\n \n std::unique_ptr<TxIndex> g_txindex;\n \n@@ -30,10 +26,6 @@ class TxIndex::DB : public BaseIndex::DB\n \n     /// Write a batch of transaction positions to the DB.\n     bool WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_pos);\n-\n-    /// Migrate txindex data from the block tree DB, where it may be for older nodes that have not\n-    /// been upgraded yet to the new database.\n-    bool MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator& best_locator);\n };\n \n TxIndex::DB::DB(size_t n_cache_size, bool f_memory, bool f_wipe) :\n@@ -54,163 +46,12 @@ bool TxIndex::DB::WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_\n     return WriteBatch(batch);\n }\n \n-/*\n- * Safely persist a transfer of data from the old txindex database to the new one, and compact the\n- * range of keys updated. This is used internally by MigrateData.\n- */\n-static void WriteTxIndexMigrationBatches(CDBWrapper& newdb, CDBWrapper& olddb,\n-                                         CDBBatch& batch_newdb, CDBBatch& batch_olddb,\n-                                         const std::pair<uint8_t, uint256>& begin_key,\n-                                         const std::pair<uint8_t, uint256>& end_key)\n-{\n-    // Sync new DB changes to disk before deleting from old DB.\n-    newdb.WriteBatch(batch_newdb, /*fSync=*/ true);\n-    olddb.WriteBatch(batch_olddb);\n-    olddb.CompactRange(begin_key, end_key);\n-\n-    batch_newdb.Clear();\n-    batch_olddb.Clear();\n-}\n-\n-bool TxIndex::DB::MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator& best_locator)\n-{\n-    // The prior implementation of txindex was always in sync with block index\n-    // and presence was indicated with a boolean DB flag. If the flag is set,\n-    // this means the txindex from a previous version is valid and in sync with\n-    // the chain tip. The first step of the migration is to unset the flag and\n-    // write the chain hash to a separate key, DB_TXINDEX_BLOCK. After that, the\n-    // index entries are copied over in batches to the new database. Finally,\n-    // DB_TXINDEX_BLOCK is erased from the old database and the block hash is\n-    // written to the new database.\n-    //\n-    // Unsetting the boolean flag ensures that if the node is downgraded to a\n-    // previous version, it will not see a corrupted, partially migrated index\n-    // -- it will see that the txindex is disabled. When the node is upgraded\n-    // again, the migration will pick up where it left off and sync to the block\n-    // with hash DB_TXINDEX_BLOCK.\n-    bool f_legacy_flag = false;\n-    block_tree_db.ReadFlag(\"txindex\", f_legacy_flag);\n-    if (f_legacy_flag) {\n-        if (!block_tree_db.Write(DB_TXINDEX_BLOCK, best_locator)) {\n-            return error(\"%s: cannot write block indicator\", __func__);\n-        }\n-        if (!block_tree_db.WriteFlag(\"txindex\", false)) {\n-            return error(\"%s: cannot write block index db flag\", __func__);\n-        }\n-    }\n-\n-    CBlockLocator locator;\n-    if (!block_tree_db.Read(DB_TXINDEX_BLOCK, locator)) {\n-        return true;\n-    }\n-\n-    int64_t count = 0;\n-    LogPrintf(\"Upgrading txindex database... [0%%]\\n\");\n-    uiInterface.ShowProgress(_(\"Upgrading txindex database\").translated, 0, true);\n-    int report_done = 0;\n-    const size_t batch_size = 1 << 24; // 16 MiB\n-\n-    CDBBatch batch_newdb(*this);\n-    CDBBatch batch_olddb(block_tree_db);\n-\n-    std::pair<uint8_t, uint256> key;\n-    std::pair<uint8_t, uint256> begin_key{DB_TXINDEX, uint256()};\n-    std::pair<uint8_t, uint256> prev_key = begin_key;\n-\n-    bool interrupted = false;\n-    std::unique_ptr<CDBIterator> cursor(block_tree_db.NewIterator());\n-    for (cursor->Seek(begin_key); cursor->Valid(); cursor->Next()) {\n-        if (ShutdownRequested()) {\n-            interrupted = true;\n-            break;\n-        }\n-\n-        if (!cursor->GetKey(key)) {\n-            return error(\"%s: cannot get key from valid cursor\", __func__);\n-        }\n-        if (key.first != DB_TXINDEX) {\n-            break;\n-        }\n-\n-        // Log progress every 10%.\n-        if (++count % 256 == 0) {\n-            // Since txids are uniformly random and traversed in increasing order, the high 16 bits\n-            // of the hash can be used to estimate the current progress.\n-            const uint256& txid = key.second;\n-            uint32_t high_nibble =\n-                (static_cast<uint32_t>(*(txid.begin() + 0)) << 8) +\n-                (static_cast<uint32_t>(*(txid.begin() + 1)) << 0);\n-            int percentage_done = (int)(high_nibble * 100.0 / 65536.0 + 0.5);\n-\n-            uiInterface.ShowProgress(_(\"Upgrading txindex database\").translated, percentage_done, true);\n-            if (report_done < percentage_done/10) {\n-                LogPrintf(\"Upgrading txindex database... [%d%%]\\n\", percentage_done);\n-                report_done = percentage_done/10;\n-            }\n-        }\n-\n-        CDiskTxPos value;\n-        if (!cursor->GetValue(value)) {\n-            return error(\"%s: cannot parse txindex record\", __func__);\n-        }\n-        batch_newdb.Write(key, value);\n-        batch_olddb.Erase(key);\n-\n-        if (batch_newdb.SizeEstimate() > batch_size || batch_olddb.SizeEstimate() > batch_size) {\n-            // NOTE: it's OK to delete the key pointed at by the current DB cursor while iterating\n-            // because LevelDB iterators are guaranteed to provide a consistent view of the\n-            // underlying data, like a lightweight snapshot.\n-            WriteTxIndexMigrationBatches(*this, block_tree_db,\n-                                         batch_newdb, batch_olddb,\n-                                         prev_key, key);\n-            prev_key = key;\n-        }\n-    }\n-\n-    // If these final DB batches complete the migration, write the best block\n-    // hash marker to the new database and delete from the old one. This signals\n-    // that the former is fully caught up to that point in the blockchain and\n-    // that all txindex entries have been removed from the latter.\n-    if (!interrupted) {\n-        batch_olddb.Erase(DB_TXINDEX_BLOCK);\n-        batch_newdb.Write(DB_BEST_BLOCK, locator);\n-    }\n-\n-    WriteTxIndexMigrationBatches(*this, block_tree_db,\n-                                 batch_newdb, batch_olddb,\n-                                 begin_key, key);\n-\n-    if (interrupted) {\n-        LogPrintf(\"[CANCELLED].\\n\");\n-        return false;\n-    }\n-\n-    uiInterface.ShowProgress(\"\", 100, false);\n-\n-    LogPrintf(\"[DONE].\\n\");\n-    return true;\n-}\n-\n TxIndex::TxIndex(size_t n_cache_size, bool f_memory, bool f_wipe)\n     : m_db(std::make_unique<TxIndex::DB>(n_cache_size, f_memory, f_wipe))\n {}\n \n TxIndex::~TxIndex() {}\n \n-bool TxIndex::Init()\n-{\n-    LOCK(cs_main);\n-\n-    // Attempt to migrate txindex from the old database to the new one. Even if\n-    // chain_tip is null, the node could be reindexing and we still want to\n-    // delete txindex records in the old database.\n-    if (!m_db->MigrateData(*m_chainstate->m_blockman.m_block_tree_db, m_chainstate->m_chain.GetLocator())) {\n-        return false;\n-    }\n-\n-    return BaseIndex::Init();\n-}\n-\n bool TxIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n {\n     // Exclude genesis block transaction because outputs are not spendable."
      },
      {
        "sha": "59375bc20470da4d3505a5825eaaab488c84bfbd",
        "filename": "src/index/txindex.h",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/index/txindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/index/txindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -5,9 +5,7 @@\n #ifndef BITCOIN_INDEX_TXINDEX_H\n #define BITCOIN_INDEX_TXINDEX_H\n \n-#include <chain.h>\n #include <index/base.h>\n-#include <txdb.h>\n \n /**\n  * TxIndex is used to look up transactions included in the blockchain by hash.\n@@ -23,9 +21,6 @@ class TxIndex final : public BaseIndex\n     const std::unique_ptr<DB> m_db;\n \n protected:\n-    /// Override base class init to migrate from old database.\n-    bool Init() override;\n-\n     bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) override;\n \n     BaseIndex::DB& GetDB() const override;"
      },
      {
        "sha": "ff36ec805c83aea7aa9d376299290b0582022ec3",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 56,
        "deletions": 51,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -26,6 +26,7 @@\n #include <index/txindex.h>\n #include <init/common.h>\n #include <interfaces/chain.h>\n+#include <interfaces/init.h>\n #include <interfaces/node.h>\n #include <mapport.h>\n #include <miner.h>\n@@ -860,6 +861,11 @@ bool AppInitParameterInteraction(const ArgsManager& args)\n         return InitError(Untranslated(\"Cannot set -bind or -whitebind together with -listen=0\"));\n     }\n \n+    // if listen=0, then disallow listenonion=1\n+    if (!args.GetBoolArg(\"-listen\", DEFAULT_LISTEN) && args.GetBoolArg(\"-listenonion\", DEFAULT_LISTEN_ONION)) {\n+        return InitError(Untranslated(\"Cannot set -listen=0 together with -listenonion=1\"));\n+    }\n+\n     // Make sure enough file descriptors are available\n     int nBind = std::max(nUserBind, size_t(1));\n     nUserMaxConnections = args.GetArg(\"-maxconnections\", DEFAULT_MAX_PEER_CONNECTIONS);\n@@ -916,10 +922,11 @@ bool AppInitParameterInteraction(const ArgsManager& args)\n     // incremental relay fee sets the minimum feerate increase necessary for BIP 125 replacement in the mempool\n     // and the amount the mempool min fee increases above the feerate of txs evicted due to mempool limiting.\n     if (args.IsArgSet(\"-incrementalrelayfee\")) {\n-        CAmount n = 0;\n-        if (!ParseMoney(args.GetArg(\"-incrementalrelayfee\", \"\"), n))\n+        if (std::optional<CAmount> inc_relay_fee = ParseMoney(args.GetArg(\"-incrementalrelayfee\", \"\"))) {\n+            ::incrementalRelayFee = CFeeRate{inc_relay_fee.value()};\n+        } else {\n             return InitError(AmountErrMsg(\"incrementalrelayfee\", args.GetArg(\"-incrementalrelayfee\", \"\")));\n-        incrementalRelayFee = CFeeRate(n);\n+        }\n     }\n \n     // block pruning; get the amount of disk space (in MiB) to allot for block & undo files\n@@ -951,12 +958,12 @@ bool AppInitParameterInteraction(const ArgsManager& args)\n     }\n \n     if (args.IsArgSet(\"-minrelaytxfee\")) {\n-        CAmount n = 0;\n-        if (!ParseMoney(args.GetArg(\"-minrelaytxfee\", \"\"), n)) {\n+        if (std::optional<CAmount> min_relay_fee = ParseMoney(args.GetArg(\"-minrelaytxfee\", \"\"))) {\n+            // High fee check is done afterward in CWallet::Create()\n+            ::minRelayTxFee = CFeeRate{min_relay_fee.value()};\n+        } else {\n             return InitError(AmountErrMsg(\"minrelaytxfee\", args.GetArg(\"-minrelaytxfee\", \"\")));\n         }\n-        // High fee check is done afterward in CWallet::Create()\n-        ::minRelayTxFee = CFeeRate(n);\n     } else if (incrementalRelayFee > ::minRelayTxFee) {\n         // Allow only setting incrementalRelayFee to control both\n         ::minRelayTxFee = incrementalRelayFee;\n@@ -966,18 +973,19 @@ bool AppInitParameterInteraction(const ArgsManager& args)\n     // Sanity check argument for min fee for including tx in block\n     // TODO: Harmonize which arguments need sanity checking and where that happens\n     if (args.IsArgSet(\"-blockmintxfee\")) {\n-        CAmount n = 0;\n-        if (!ParseMoney(args.GetArg(\"-blockmintxfee\", \"\"), n))\n+        if (!ParseMoney(args.GetArg(\"-blockmintxfee\", \"\"))) {\n             return InitError(AmountErrMsg(\"blockmintxfee\", args.GetArg(\"-blockmintxfee\", \"\")));\n+        }\n     }\n \n     // Feerate used to define dust.  Shouldn't be changed lightly as old\n     // implementations may inadvertently create non-standard transactions\n     if (args.IsArgSet(\"-dustrelayfee\")) {\n-        CAmount n = 0;\n-        if (!ParseMoney(args.GetArg(\"-dustrelayfee\", \"\"), n))\n+        if (std::optional<CAmount> parsed = ParseMoney(args.GetArg(\"-dustrelayfee\", \"\"))) {\n+            dustRelayFee = CFeeRate{parsed.value()};\n+        } else {\n             return InitError(AmountErrMsg(\"dustrelayfee\", args.GetArg(\"-dustrelayfee\", \"\")));\n-        dustRelayFee = CFeeRate(n);\n+        }\n     }\n \n     fRequireStandard = !args.GetBoolArg(\"-acceptnonstdtxn\", !chainparams.RequireStandard());\n@@ -1056,7 +1064,7 @@ bool AppInitLockDataDirectory()\n \n bool AppInitInterfaces(NodeContext& node)\n {\n-    node.chain = interfaces::MakeChain(node);\n+    node.chain = node.init->makeChain();\n     // Create client interfaces for wallets that are supposed to be loaded\n     // according to -wallet and -disablewallet options. This only constructs\n     // the interfaces, it doesn't load wallet data. Wallets actually get loaded\n@@ -1164,23 +1172,41 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n     fDiscover = args.GetBoolArg(\"-discover\", true);\n     const bool ignores_incoming_txs{args.GetBoolArg(\"-blocksonly\", DEFAULT_BLOCKSONLY)};\n \n-    assert(!node.addrman);\n-    auto check_addrman = std::clamp<int32_t>(args.GetArg(\"-checkaddrman\", DEFAULT_ADDRMAN_CONSISTENCY_CHECKS), 0, 1000000);\n-    node.addrman = std::make_unique<CAddrMan>(/* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n     {\n-        // Load addresses from peers.dat\n-        uiInterface.InitMessage(_(\"Loading P2P addresses\u2026\").translated);\n-        int64_t nStart = GetTimeMillis();\n-        CAddrDB adb;\n-        if (adb.Read(*node.addrman)) {\n-            LogPrintf(\"Loaded %i addresses from peers.dat  %dms\\n\", node.addrman->size(), GetTimeMillis() - nStart);\n+        // Initialize addrman\n+        assert(!node.addrman);\n+\n+        // Read asmap file if configured\n+        std::vector<bool> asmap;\n+        if (args.IsArgSet(\"-asmap\")) {\n+            fs::path asmap_path = fs::path(args.GetArg(\"-asmap\", \"\"));\n+            if (asmap_path.empty()) {\n+                asmap_path = DEFAULT_ASMAP_FILENAME;\n+            }\n+            if (!asmap_path.is_absolute()) {\n+                asmap_path = gArgs.GetDataDirNet() / asmap_path;\n+            }\n+            if (!fs::exists(asmap_path)) {\n+                InitError(strprintf(_(\"Could not find asmap file %s\"), asmap_path));\n+                return false;\n+            }\n+            asmap = DecodeAsmap(asmap_path);\n+            if (asmap.size() == 0) {\n+                InitError(strprintf(_(\"Could not parse asmap file %s\"), asmap_path));\n+                return false;\n+            }\n+            const uint256 asmap_version = SerializeHash(asmap);\n+            LogPrintf(\"Using asmap version %s for IP bucketing\\n\", asmap_version.ToString());\n         } else {\n-            // Addrman can be in an inconsistent state after failure, reset it\n-            node.addrman = std::make_unique<CAddrMan>(/* deterministic */ false, /* consistency_check_ratio */ check_addrman);\n-            LogPrintf(\"Recreating peers.dat\\n\");\n-            adb.Write(*node.addrman);\n+            LogPrintf(\"Using /16 prefix for IP bucketing\\n\");\n+        }\n+\n+        uiInterface.InitMessage(_(\"Loading P2P addresses\u2026\").translated);\n+        if (const auto error{LoadAddrman(asmap, args, node.addrman)}) {\n+            return InitError(*error);\n         }\n     }\n+\n     assert(!node.banman);\n     node.banman = std::make_unique<BanMan>(gArgs.GetDataDirNet() / \"banlist\", &uiInterface, args.GetArg(\"-bantime\", DEFAULT_MISBEHAVING_BANTIME));\n     assert(!node.connman);\n@@ -1285,31 +1311,6 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n             return InitError(ResolveErrMsg(\"externalip\", strAddr));\n     }\n \n-    // Read asmap file if configured\n-    if (args.IsArgSet(\"-asmap\")) {\n-        fs::path asmap_path = fs::path(args.GetArg(\"-asmap\", \"\"));\n-        if (asmap_path.empty()) {\n-            asmap_path = DEFAULT_ASMAP_FILENAME;\n-        }\n-        if (!asmap_path.is_absolute()) {\n-            asmap_path = gArgs.GetDataDirNet() / asmap_path;\n-        }\n-        if (!fs::exists(asmap_path)) {\n-            InitError(strprintf(_(\"Could not find asmap file %s\"), asmap_path));\n-            return false;\n-        }\n-        std::vector<bool> asmap = CAddrMan::DecodeAsmap(asmap_path);\n-        if (asmap.size() == 0) {\n-            InitError(strprintf(_(\"Could not parse asmap file %s\"), asmap_path));\n-            return false;\n-        }\n-        const uint256 asmap_version = SerializeHash(asmap);\n-        node.connman->SetAsmap(std::move(asmap));\n-        LogPrintf(\"Using asmap version %s for IP bucketing\\n\", asmap_version.ToString());\n-    } else {\n-        LogPrintf(\"Using /16 prefix for IP bucketing\\n\");\n-    }\n-\n #if ENABLE_ZMQ\n     g_zmq_notification_interface = CZMQNotificationInterface::Create();\n \n@@ -1566,6 +1567,10 @@ bool AppInitMain(NodeContext& node, interfaces::BlockAndHeaderTipInfo* tip_info)\n \n     // ********************************************************* Step 8: start indexers\n     if (args.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)) {\n+        if (const auto error{CheckLegacyTxindex(*Assert(chainman.m_blockman.m_block_tree_db))}) {\n+            return InitError(*error);\n+        }\n+\n         g_txindex = std::make_unique<TxIndex>(nTxIndexCache, false, fReindex);\n         if (!g_txindex->Start(chainman.ActiveChainstate())) {\n             return false;"
      },
      {
        "sha": "fa56153745d8b5570a1ad11787185e8870920245",
        "filename": "src/init/bitcoin-node.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/init/bitcoin-node.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/init/bitcoin-node.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init/bitcoin-node.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -2,9 +2,12 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <interfaces/chain.h>\n #include <interfaces/echo.h>\n #include <interfaces/init.h>\n #include <interfaces/ipc.h>\n+#include <interfaces/node.h>\n+#include <interfaces/wallet.h>\n #include <node/context.h>\n #include <util/system.h>\n \n@@ -24,6 +27,12 @@ class BitcoinNodeInit : public interfaces::Init\n         m_node.args = &gArgs;\n         m_node.init = this;\n     }\n+    std::unique_ptr<interfaces::Node> makeNode() override { return interfaces::MakeNode(m_node); }\n+    std::unique_ptr<interfaces::Chain> makeChain() override { return interfaces::MakeChain(m_node); }\n+    std::unique_ptr<interfaces::WalletClient> makeWalletClient(interfaces::Chain& chain) override\n+    {\n+        return MakeWalletClient(chain, *Assert(m_node.args));\n+    }\n     std::unique_ptr<interfaces::Echo> makeEcho() override { return interfaces::MakeEcho(); }\n     interfaces::Ipc* ipc() override { return m_ipc.get(); }\n     NodeContext& m_node;"
      },
      {
        "sha": "9c8d5bd9bbe1c573725287a35940ab9d2409ef89",
        "filename": "src/init/bitcoind.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/init/bitcoind.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/init/bitcoind.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init/bitcoind.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -2,7 +2,11 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <interfaces/chain.h>\n+#include <interfaces/echo.h>\n #include <interfaces/init.h>\n+#include <interfaces/node.h>\n+#include <interfaces/wallet.h>\n #include <node/context.h>\n #include <util/system.h>\n \n@@ -18,6 +22,13 @@ class BitcoindInit : public interfaces::Init\n         m_node.args = &gArgs;\n         m_node.init = this;\n     }\n+    std::unique_ptr<interfaces::Node> makeNode() override { return interfaces::MakeNode(m_node); }\n+    std::unique_ptr<interfaces::Chain> makeChain() override { return interfaces::MakeChain(m_node); }\n+    std::unique_ptr<interfaces::WalletClient> makeWalletClient(interfaces::Chain& chain) override\n+    {\n+        return MakeWalletClient(chain, *Assert(m_node.args));\n+    }\n+    std::unique_ptr<interfaces::Echo> makeEcho() override { return interfaces::MakeEcho(); }\n     NodeContext& m_node;\n };\n } // namespace"
      },
      {
        "sha": "770b1b875325a5e375370638213593ad46647dfc",
        "filename": "src/interfaces/node.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/interfaces/node.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/interfaces/node.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/interfaces/node.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -230,7 +230,7 @@ class Node\n };\n \n //! Return implementation of Node interface.\n-std::unique_ptr<Node> MakeNode(NodeContext* context = nullptr);\n+std::unique_ptr<Node> MakeNode(NodeContext& context);\n \n //! Block tip (could be a header or not, depends on the subscribed signal).\n struct BlockTip {"
      },
      {
        "sha": "40df248e0217274f384b1363080d097b26af6b15",
        "filename": "src/key.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/key.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/key.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -357,6 +357,7 @@ void CExtKey::Decode(const unsigned char code[BIP32_EXTKEY_SIZE]) {\n     nChild = (code[5] << 24) | (code[6] << 16) | (code[7] << 8) | code[8];\n     memcpy(chaincode.begin(), code+9, 32);\n     key.Set(code+42, code+BIP32_EXTKEY_SIZE, true);\n+    if ((nDepth == 0 && (nChild != 0 || ReadLE32(vchFingerprint) != 0)) || code[41] != 0) key = CKey();\n }\n \n bool ECC_InitSanityCheck() {"
      },
      {
        "sha": "9b94baa026ace45278436efc4f831a68b5a56194",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 9,
        "deletions": 5,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -17,7 +17,6 @@\n \n \n /**\n- * secure_allocator is defined in allocators.h\n  * CPrivKey is a serialized private key, with all parameters included\n  * (SIZE bytes)\n  */\n@@ -133,10 +132,15 @@ class CKey\n      * optionally tweaked by *merkle_root. Additional nonce entropy can be provided through\n      * aux.\n      *\n-     * When merkle_root is not nullptr, this results in a signature with a modified key as\n-     * specified in BIP341:\n-     * - If merkle_root->IsNull(): key + H_TapTweak(pubkey)*G\n-     * - Otherwise:                key + H_TapTweak(pubkey || *merkle_root)\n+     * merkle_root is used to optionally perform tweaking of the private key, as specified\n+     * in BIP341:\n+     * - If merkle_root == nullptr: no tweaking is done, sign with key directly (this is\n+     *                              used for signatures in BIP342 script).\n+     * - If merkle_root->IsNull():  sign with key + H_TapTweak(pubkey) (this is used for\n+     *                              key path spending when no scripts are present).\n+     * - Otherwise:                 sign with key + H_TapTweak(pubkey || *merkle_root)\n+     *                              (this is used for key path spending, with specific\n+     *                              Merkle root of the script tree).\n      */\n     bool SignSchnorr(const uint256& hash, Span<unsigned char> sig, const uint256* merkle_root = nullptr, const uint256* aux = nullptr) const;\n "
      },
      {
        "sha": "eb2c750296dfcd655cccd7eabaabdb39ad8046b2",
        "filename": "src/logging.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -159,6 +159,7 @@ const CLogCategoryDesc LogCategories[] =\n     {BCLog::VALIDATION, \"validation\"},\n     {BCLog::I2P, \"i2p\"},\n     {BCLog::IPC, \"ipc\"},\n+    {BCLog::LOCK, \"lock\"},\n     {BCLog::ALL, \"1\"},\n     {BCLog::ALL, \"all\"},\n };"
      },
      {
        "sha": "53a89d28bd52979094b60916e60203a4fc27428e",
        "filename": "src/logging.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -59,6 +59,7 @@ namespace BCLog {\n         VALIDATION  = (1 << 21),\n         I2P         = (1 << 22),\n         IPC         = (1 << 23),\n+        LOCK        = (1 << 24),\n         ALL         = ~(uint32_t)0,\n     };\n "
      },
      {
        "sha": "79627b1fe31a2308317fb2bb366fa0845923bef6",
        "filename": "src/logging/timer.h",
        "status": "modified",
        "additions": 11,
        "deletions": 15,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/logging/timer.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/logging/timer.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging/timer.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -9,6 +9,7 @@\n #include <logging.h>\n #include <util/macros.h>\n #include <util/time.h>\n+#include <util/types.h>\n \n #include <chrono>\n #include <string>\n@@ -58,21 +59,15 @@ class Timer\n             return strprintf(\"%s: %s\", m_prefix, msg);\n         }\n \n-        std::string units = \"\";\n-        float divisor = 1;\n-\n-        if (std::is_same<TimeType, std::chrono::microseconds>::value) {\n-            units = \"\u03bcs\";\n-        } else if (std::is_same<TimeType, std::chrono::milliseconds>::value) {\n-            units = \"ms\";\n-            divisor = 1000.;\n-        } else if (std::is_same<TimeType, std::chrono::seconds>::value) {\n-            units = \"s\";\n-            divisor = 1000. * 1000.;\n+        if constexpr (std::is_same<TimeType, std::chrono::microseconds>::value) {\n+            return strprintf(\"%s: %s (%i\u03bcs)\", m_prefix, msg, end_time.count());\n+        } else if constexpr (std::is_same<TimeType, std::chrono::milliseconds>::value) {\n+            return strprintf(\"%s: %s (%.2fms)\", m_prefix, msg, end_time.count() * 0.001);\n+        } else if constexpr (std::is_same<TimeType, std::chrono::seconds>::value) {\n+            return strprintf(\"%s: %s (%.2fs)\", m_prefix, msg, end_time.count() * 0.000001);\n+        } else {\n+            static_assert(ALWAYS_FALSE<TimeType>, \"Error: unexpected time type\");\n         }\n-\n-        const float time_ms = end_time.count() / divisor;\n-        return strprintf(\"%s: %s (%.2f%s)\", m_prefix, msg, time_ms, units);\n     }\n \n private:\n@@ -87,12 +82,13 @@ class Timer\n     //! Forwarded on to LogPrint if specified - has the effect of only\n     //! outputting the timing log when a particular debug= category is specified.\n     const BCLog::LogFlags m_log_category{};\n-\n };\n \n } // namespace BCLog\n \n \n+#define LOG_TIME_MICROS_WITH_CATEGORY(end_msg, log_category) \\\n+    BCLog::Timer<std::chrono::microseconds> PASTE2(logging_timer, __COUNTER__)(__func__, end_msg, log_category)\n #define LOG_TIME_MILLIS_WITH_CATEGORY(end_msg, log_category) \\\n     BCLog::Timer<std::chrono::milliseconds> PASTE2(logging_timer, __COUNTER__)(__func__, end_msg, log_category)\n #define LOG_TIME_SECONDS(end_msg) \\"
      },
      {
        "sha": "168ade5507568e0d2f355c93e779dfcef157b006",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -73,11 +73,11 @@ static BlockAssembler::Options DefaultOptions()\n     // If -blockmaxweight is not given, limit to DEFAULT_BLOCK_MAX_WEIGHT\n     BlockAssembler::Options options;\n     options.nBlockMaxWeight = gArgs.GetArg(\"-blockmaxweight\", DEFAULT_BLOCK_MAX_WEIGHT);\n-    CAmount n = 0;\n-    if (gArgs.IsArgSet(\"-blockmintxfee\") && ParseMoney(gArgs.GetArg(\"-blockmintxfee\", \"\"), n)) {\n-        options.blockMinFeeRate = CFeeRate(n);\n+    if (gArgs.IsArgSet(\"-blockmintxfee\")) {\n+        std::optional<CAmount> parsed = ParseMoney(gArgs.GetArg(\"-blockmintxfee\", \"\"));\n+        options.blockMinFeeRate = CFeeRate{parsed.value_or(DEFAULT_BLOCK_MIN_TX_FEE)};\n     } else {\n-        options.blockMinFeeRate = CFeeRate(DEFAULT_BLOCK_MIN_TX_FEE);\n+        options.blockMinFeeRate = CFeeRate{DEFAULT_BLOCK_MIN_TX_FEE};\n     }\n     return options;\n }"
      },
      {
        "sha": "cc8f4c4316d5c285301466005e145d5989eb921e",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 46,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -9,6 +9,7 @@\n \n #include <net.h>\n \n+#include <addrdb.h>\n #include <banman.h>\n #include <clientversion.h>\n #include <compat.h>\n@@ -24,6 +25,7 @@\n #include <scheduler.h>\n #include <util/sock.h>\n #include <util/strencodings.h>\n+#include <util/system.h>\n #include <util/thread.h>\n #include <util/trace.h>\n #include <util/translation.h>\n@@ -190,8 +192,8 @@ CAddress GetLocalAddress(const CNetAddr *paddrPeer, ServiceFlags nLocalServices)\n static int GetnScore(const CService& addr)\n {\n     LOCK(cs_mapLocalHost);\n-    if (mapLocalHost.count(addr) == 0) return 0;\n-    return mapLocalHost[addr].nScore;\n+    const auto it = mapLocalHost.find(addr);\n+    return (it != mapLocalHost.end()) ? it->second.nScore : 0;\n }\n \n // Is our peer's addrLocal potentially useful as an external IP source?\n@@ -243,10 +245,10 @@ bool AddLocal(const CService& addr, int nScore)\n \n     {\n         LOCK(cs_mapLocalHost);\n-        bool fAlready = mapLocalHost.count(addr) > 0;\n-        LocalServiceInfo &info = mapLocalHost[addr];\n-        if (!fAlready || nScore >= info.nScore) {\n-            info.nScore = nScore + (fAlready ? 1 : 0);\n+        const auto [it, is_newly_added] = mapLocalHost.emplace(addr, LocalServiceInfo());\n+        LocalServiceInfo &info = it->second;\n+        if (is_newly_added || nScore >= info.nScore) {\n+            info.nScore = nScore + (is_newly_added ? 0 : 1);\n             info.nPort = addr.GetPort();\n         }\n     }\n@@ -288,12 +290,10 @@ bool IsReachable(const CNetAddr &addr)\n /** vote for a local address */\n bool SeenLocal(const CService& addr)\n {\n-    {\n-        LOCK(cs_mapLocalHost);\n-        if (mapLocalHost.count(addr) == 0)\n-            return false;\n-        mapLocalHost[addr].nScore++;\n-    }\n+    LOCK(cs_mapLocalHost);\n+    const auto it = mapLocalHost.find(addr);\n+    if (it == mapLocalHost.end()) return false;\n+    ++it->second.nScore;\n     return true;\n }\n \n@@ -331,7 +331,7 @@ CNode* CConnman::FindNode(const std::string& addrName)\n {\n     LOCK(cs_vNodes);\n     for (CNode* pnode : vNodes) {\n-        if (pnode->GetAddrName() == addrName) {\n+        if (pnode->m_addr_name == addrName) {\n             return pnode;\n         }\n     }\n@@ -414,14 +414,10 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n                 return nullptr;\n             }\n             // It is possible that we already have a connection to the IP/port pszDest resolved to.\n-            // In that case, drop the connection that was just created, and return the existing CNode instead.\n-            // Also store the name we used to connect in that CNode, so that future FindNode() calls to that\n-            // name catch this early.\n+            // In that case, drop the connection that was just created.\n             LOCK(cs_vNodes);\n             CNode* pnode = FindNode(static_cast<CService>(addrConnect));\n-            if (pnode)\n-            {\n-                pnode->MaybeSetAddrName(std::string(pszDest));\n+            if (pnode) {\n                 LogPrintf(\"Failed to open new connection, already connected\\n\");\n                 return nullptr;\n             }\n@@ -534,19 +530,8 @@ std::string ConnectionTypeAsString(ConnectionType conn_type)\n     assert(false);\n }\n \n-std::string CNode::GetAddrName() const {\n-    LOCK(cs_addrName);\n-    return addrName;\n-}\n-\n-void CNode::MaybeSetAddrName(const std::string& addrNameIn) {\n-    LOCK(cs_addrName);\n-    if (addrName.empty()) {\n-        addrName = addrNameIn;\n-    }\n-}\n-\n-CService CNode::GetAddrLocal() const {\n+CService CNode::GetAddrLocal() const\n+{\n     LOCK(cs_addrLocal);\n     return addrLocal;\n }\n@@ -567,14 +552,13 @@ Network CNode::ConnectedThroughNetwork() const\n \n #undef X\n #define X(name) stats.name = name\n-void CNode::copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap)\n+void CNode::CopyStats(CNodeStats& stats)\n {\n     stats.nodeid = this->GetId();\n     X(nServices);\n     X(addr);\n     X(addrBind);\n     stats.m_network = ConnectedThroughNetwork();\n-    stats.m_mapped_as = addr.GetMappedAS(m_asmap);\n     if (m_tx_relay != nullptr) {\n         LOCK(m_tx_relay->cs_filter);\n         stats.fRelayTxes = m_tx_relay->fRelayTxes;\n@@ -587,7 +571,7 @@ void CNode::copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap)\n     X(nLastBlockTime);\n     X(nTimeConnected);\n     X(nTimeOffset);\n-    stats.addrName = GetAddrName();\n+    X(m_addr_name);\n     X(nVersion);\n     {\n         LOCK(cs_SubVer);\n@@ -1762,8 +1746,7 @@ void CConnman::DumpAddresses()\n {\n     int64_t nStart = GetTimeMillis();\n \n-    CAddrDB adb;\n-    adb.Write(addrman);\n+    DumpPeerAddresses(::gArgs, addrman);\n \n     LogPrint(BCLog::NET, \"Flushed %d addresses to peers.dat  %dms\\n\",\n            addrman.size(), GetTimeMillis() - nStart);\n@@ -1936,7 +1919,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                     case ConnectionType::BLOCK_RELAY:\n                     case ConnectionType::ADDR_FETCH:\n                     case ConnectionType::FEELER:\n-                        setConnected.insert(pnode->addr.GetGroup(addrman.m_asmap));\n+                        setConnected.insert(pnode->addr.GetGroup(addrman.GetAsmap()));\n                 } // no default case, so the compiler can warn about missing cases\n             }\n         }\n@@ -2010,7 +1993,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n                 m_anchors.pop_back();\n                 if (!addr.IsValid() || IsLocal(addr) || !IsReachable(addr) ||\n                     !HasAllDesirableServiceFlags(addr.nServices) ||\n-                    setConnected.count(addr.GetGroup(addrman.m_asmap))) continue;\n+                    setConnected.count(addr.GetGroup(addrman.GetAsmap()))) continue;\n                 addrConnect = addr;\n                 LogPrint(BCLog::NET, \"Trying to make an anchor connection to %s\\n\", addrConnect.ToString());\n                 break;\n@@ -2050,7 +2033,7 @@ void CConnman::ThreadOpenConnections(const std::vector<std::string> connect)\n             }\n \n             // Require outbound connections, other than feelers, to be to distinct network groups\n-            if (!fFeeler && setConnected.count(addr.GetGroup(addrman.m_asmap))) {\n+            if (!fFeeler && setConnected.count(addr.GetGroup(addrman.GetAsmap()))) {\n                 break;\n             }\n \n@@ -2137,7 +2120,7 @@ std::vector<AddedNodeInfo> CConnman::GetAddedNodeInfo() const\n             if (pnode->addr.IsValid()) {\n                 mapConnected[pnode->addr] = pnode->IsInboundConn();\n             }\n-            std::string addrName = pnode->GetAddrName();\n+            std::string addrName{pnode->m_addr_name};\n             if (!addrName.empty()) {\n                 mapConnectedByName[std::move(addrName)] = std::make_pair(pnode->IsInboundConn(), static_cast<const CService&>(pnode->addr));\n             }\n@@ -2819,7 +2802,8 @@ void CConnman::GetNodeStats(std::vector<CNodeStats>& vstats) const\n     vstats.reserve(vNodes.size());\n     for (CNode* pnode : vNodes) {\n         vstats.emplace_back();\n-        pnode->copyStats(vstats.back(), addrman.m_asmap);\n+        pnode->CopyStats(vstats.back());\n+        vstats.back().m_mapped_as = pnode->addr.GetMappedAS(addrman.GetAsmap());\n     }\n }\n \n@@ -2966,6 +2950,7 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const\n     : nTimeConnected(GetTimeSeconds()),\n       addr(addrIn),\n       addrBind(addrBindIn),\n+      m_addr_name{addrNameIn.empty() ? addr.ToStringIPPort() : addrNameIn},\n       m_inbound_onion(inbound_onion),\n       nKeyedNetGroup(nKeyedNetGroupIn),\n       id(idIn),\n@@ -2975,7 +2960,6 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const\n {\n     if (inbound_onion) assert(conn_type_in == ConnectionType::INBOUND);\n     hSocket = hSocketIn;\n-    addrName = addrNameIn == \"\" ? addr.ToStringIPPort() : addrNameIn;\n     if (conn_type_in != ConnectionType::BLOCK_RELAY) {\n         m_tx_relay = std::make_unique<TxRelay>();\n     }\n@@ -2985,7 +2969,7 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, SOCKET hSocketIn, const\n     mapRecvBytesPerMsgCmd[NET_MESSAGE_COMMAND_OTHER] = 0;\n \n     if (fLogIPs) {\n-        LogPrint(BCLog::NET, \"Added connection to %s peer=%d\\n\", addrName, id);\n+        LogPrint(BCLog::NET, \"Added connection to %s peer=%d\\n\", m_addr_name, id);\n     } else {\n         LogPrint(BCLog::NET, \"Added connection peer=%d\\n\", id);\n     }\n@@ -3014,7 +2998,7 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n \n     TRACE6(net, outbound_message,\n         pnode->GetId(),\n-        pnode->GetAddrName().c_str(),\n+        pnode->m_addr_name.c_str(),\n         pnode->ConnectionTypeAsString().c_str(),\n         msg.m_type.c_str(),\n         msg.data.size(),\n@@ -3082,7 +3066,7 @@ CSipHasher CConnman::GetDeterministicRandomizer(uint64_t id) const\n \n uint64_t CConnman::CalculateKeyedNetGroup(const CAddress& ad) const\n {\n-    std::vector<unsigned char> vchNetGroup(ad.GetGroup(addrman.m_asmap));\n+    std::vector<unsigned char> vchNetGroup(ad.GetGroup(addrman.GetAsmap()));\n \n     return GetDeterministicRandomizer(RANDOMIZER_ID_NETGROUP).Write(vchNetGroup.data(), vchNetGroup.size()).Finalize();\n }"
      },
      {
        "sha": "0a72ca888db57c5235bdba38a6050d84bd445579",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 4,
        "deletions": 14,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -6,7 +6,6 @@\n #ifndef BITCOIN_NET_H\n #define BITCOIN_NET_H\n \n-#include <addrdb.h>\n #include <addrman.h>\n #include <amount.h>\n #include <bloom.h>\n@@ -248,7 +247,7 @@ class CNodeStats\n     int64_t nLastBlockTime;\n     int64_t nTimeConnected;\n     int64_t nTimeOffset;\n-    std::string addrName;\n+    std::string m_addr_name;\n     int nVersion;\n     std::string cleanSubVer;\n     bool fInbound;\n@@ -430,6 +429,7 @@ class CNode\n     const CAddress addr;\n     // Bind address of our side of the connection\n     const CAddress addrBind;\n+    const std::string m_addr_name;\n     //! Whether this peer is an inbound onion, i.e. connected via our Tor onion service.\n     const bool m_inbound_onion;\n     std::atomic<int> nVersion{0};\n@@ -651,17 +651,13 @@ class CNode\n \n     void CloseSocketDisconnect();\n \n-    void copyStats(CNodeStats &stats, const std::vector<bool> &m_asmap);\n+    void CopyStats(CNodeStats& stats);\n \n     ServiceFlags GetLocalServices() const\n     {\n         return nLocalServices;\n     }\n \n-    std::string GetAddrName() const;\n-    //! Sets the addrName only if it was not previously set\n-    void MaybeSetAddrName(const std::string& addrNameIn);\n-\n     std::string ConnectionTypeAsString() const { return ::ConnectionTypeAsString(m_conn_type); }\n \n     /** A ping-pong round trip has completed successfully. Update latest and minimum ping times. */\n@@ -693,10 +689,7 @@ class CNode\n     //! service advertisements.\n     const ServiceFlags nLocalServices;\n \n-    std::list<CNetMessage> vRecvMsg;  // Used only by SocketHandler thread\n-\n-    mutable RecursiveMutex cs_addrName;\n-    std::string addrName GUARDED_BY(cs_addrName);\n+    std::list<CNetMessage> vRecvMsg; // Used only by SocketHandler thread\n \n     // Our address, as reported by the peer\n     CService addrLocal GUARDED_BY(cs_addrLocal);\n@@ -774,7 +767,6 @@ class CConnman\n         bool m_use_addrman_outgoing = true;\n         std::vector<std::string> m_specified_outgoing;\n         std::vector<std::string> m_added_nodes;\n-        std::vector<bool> m_asmap;\n         bool m_i2p_accept_incoming;\n     };\n \n@@ -949,8 +941,6 @@ class CConnman\n     */\n     std::chrono::microseconds PoissonNextSendInbound(std::chrono::microseconds now, std::chrono::seconds average_interval);\n \n-    void SetAsmap(std::vector<bool> asmap) { addrman.m_asmap = std::move(asmap); }\n-\n     /** Return true if we should disconnect the peer for failing an inactivity check. */\n     bool ShouldRunInactivityChecks(const CNode& node, std::optional<int64_t> now=std::nullopt) const;\n "
      },
      {
        "sha": "80655c61e7989d00d8d3738ab1a2c0d166303318",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 20,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -1087,25 +1087,25 @@ void PeerManagerImpl::PushNodeVersion(CNode& pnode, int64_t nTime)\n     // Note that pnode->GetLocalServices() is a reflection of the local\n     // services we were offering when the CNode object was created for this\n     // peer.\n-    ServiceFlags nLocalNodeServices = pnode.GetLocalServices();\n+    uint64_t my_services{pnode.GetLocalServices()};\n     uint64_t nonce = pnode.GetLocalNonce();\n     const int nNodeStartingHeight{m_best_height};\n     NodeId nodeid = pnode.GetId();\n     CAddress addr = pnode.addr;\n \n-    CAddress addrYou = addr.IsRoutable() && !IsProxy(addr) && addr.IsAddrV1Compatible() ?\n-                           addr :\n-                           CAddress(CService(), addr.nServices);\n-    CAddress addrMe = CAddress(CService(), nLocalNodeServices);\n+    CService addr_you = addr.IsRoutable() && !IsProxy(addr) && addr.IsAddrV1Compatible() ? addr : CService();\n+    uint64_t your_services{addr.nServices};\n \n     const bool tx_relay = !m_ignore_incoming_txs && pnode.m_tx_relay != nullptr;\n-    m_connman.PushMessage(&pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n+    m_connman.PushMessage(&pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, my_services, nTime,\n+            your_services, addr_you, // Together the pre-version-31402 serialization of CAddress \"addrYou\" (without nTime)\n+            my_services, CService(), // Together the pre-version-31402 serialization of CAddress \"addrMe\" (without nTime)\n             nonce, strSubVersion, nNodeStartingHeight, tx_relay));\n \n     if (fLogIPs) {\n-        LogPrint(BCLog::NET, \"send version message: version %d, blocks=%d, us=%s, them=%s, txrelay=%d, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), addrYou.ToString(), tx_relay, nodeid);\n+        LogPrint(BCLog::NET, \"send version message: version %d, blocks=%d, them=%s, txrelay=%d, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addr_you.ToString(), tx_relay, nodeid);\n     } else {\n-        LogPrint(BCLog::NET, \"send version message: version %d, blocks=%d, us=%s, txrelay=%d, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), tx_relay, nodeid);\n+        LogPrint(BCLog::NET, \"send version message: version %d, blocks=%d, txrelay=%d, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, tx_relay, nodeid);\n     }\n }\n \n@@ -2487,21 +2487,20 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n         }\n \n         int64_t nTime;\n-        CAddress addrMe;\n-        CAddress addrFrom;\n+        CService addrMe;\n         uint64_t nNonce = 1;\n-        uint64_t nServiceInt;\n         ServiceFlags nServices;\n         int nVersion;\n         std::string cleanSubVer;\n         int starting_height = -1;\n         bool fRelay = true;\n \n-        vRecv >> nVersion >> nServiceInt >> nTime >> addrMe;\n+        vRecv >> nVersion >> Using<CustomUintFormatter<8>>(nServices) >> nTime;\n         if (nTime < 0) {\n             nTime = 0;\n         }\n-        nServices = ServiceFlags(nServiceInt);\n+        vRecv.ignore(8); // Ignore the addrMe service bits sent by the peer\n+        vRecv >> addrMe;\n         if (!pfrom.IsInboundConn())\n         {\n             m_addrman.SetServices(pfrom.addr, nServices);\n@@ -2520,8 +2519,14 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n-        if (!vRecv.empty())\n-            vRecv >> addrFrom >> nNonce;\n+        if (!vRecv.empty()) {\n+            // The version message includes information about the sending node which we don't use:\n+            //   - 8 bytes (service bits)\n+            //   - 16 bytes (ipv6 address)\n+            //   - 2 bytes (port)\n+            vRecv.ignore(26);\n+            vRecv >> nNonce;\n+        }\n         if (!vRecv.empty()) {\n             std::string strSubVer;\n             vRecv >> LIMITED_STRING(strSubVer, MAX_SUBVERSION_LENGTH);\n@@ -2904,13 +2909,13 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n             return;\n         }\n \n-        // We won't accept tx inv's if we're in blocks-only mode, or this is a\n+        // Reject tx INVs when the -blocksonly setting is enabled, or this is a\n         // block-relay-only peer\n-        bool fBlocksOnly = m_ignore_incoming_txs || (pfrom.m_tx_relay == nullptr);\n+        bool reject_tx_invs{m_ignore_incoming_txs || (pfrom.m_tx_relay == nullptr)};\n \n         // Allow peers with relay permission to send data other than blocks in blocks only mode\n         if (pfrom.HasPermission(NetPermissionFlags::Relay)) {\n-            fBlocksOnly = false;\n+            reject_tx_invs = false;\n         }\n \n         LOCK(cs_main);\n@@ -2949,7 +2954,7 @@ void PeerManagerImpl::ProcessMessage(CNode& pfrom, const std::string& msg_type,\n                 LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom.GetId());\n \n                 pfrom.AddKnownTx(inv.hash);\n-                if (fBlocksOnly) {\n+                if (reject_tx_invs) {\n                     LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol, disconnecting peer=%d\\n\", inv.hash.ToString(), pfrom.GetId());\n                     pfrom.fDisconnect = true;\n                     return;\n@@ -4081,7 +4086,7 @@ bool PeerManagerImpl::ProcessMessages(CNode* pfrom, std::atomic<bool>& interrupt\n \n     TRACE6(net, inbound_message,\n         pfrom->GetId(),\n-        pfrom->GetAddrName().c_str(),\n+        pfrom->m_addr_name.c_str(),\n         pfrom->ConnectionTypeAsString().c_str(),\n         msg.m_command.c_str(),\n         msg.m_recv.size(),"
      },
      {
        "sha": "c8f57fe6c644acc7ddef5f47de83486d4ae1a19e",
        "filename": "src/net_types.cpp",
        "status": "added",
        "additions": 65,
        "deletions": 0,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/net_types.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/net_types.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_types.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -0,0 +1,65 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <net_types.h>\n+\n+#include <netaddress.h>\n+#include <netbase.h>\n+#include <univalue.h>\n+\n+CBanEntry::CBanEntry(const UniValue& json)\n+    : nVersion(json[\"version\"].get_int()), nCreateTime(json[\"ban_created\"].get_int64()),\n+      nBanUntil(json[\"banned_until\"].get_int64())\n+{\n+}\n+\n+UniValue CBanEntry::ToJson() const\n+{\n+    UniValue json(UniValue::VOBJ);\n+    json.pushKV(\"version\", nVersion);\n+    json.pushKV(\"ban_created\", nCreateTime);\n+    json.pushKV(\"banned_until\", nBanUntil);\n+    return json;\n+}\n+\n+static const char* BANMAN_JSON_ADDR_KEY = \"address\";\n+\n+/**\n+ * Convert a `banmap_t` object to a JSON array.\n+ * @param[in] bans Bans list to convert.\n+ * @return a JSON array, similar to the one returned by the `listbanned` RPC. Suitable for\n+ * passing to `BanMapFromJson()`.\n+ */\n+UniValue BanMapToJson(const banmap_t& bans)\n+{\n+    UniValue bans_json(UniValue::VARR);\n+    for (const auto& it : bans) {\n+        const auto& address = it.first;\n+        const auto& ban_entry = it.second;\n+        UniValue j = ban_entry.ToJson();\n+        j.pushKV(BANMAN_JSON_ADDR_KEY, address.ToString());\n+        bans_json.push_back(j);\n+    }\n+    return bans_json;\n+}\n+\n+/**\n+ * Convert a JSON array to a `banmap_t` object.\n+ * @param[in] bans_json JSON to convert, must be as returned by `BanMapToJson()`.\n+ * @param[out] bans Bans list to create from the JSON.\n+ * @throws std::runtime_error if the JSON does not have the expected fields or they contain\n+ * unparsable values.\n+ */\n+void BanMapFromJson(const UniValue& bans_json, banmap_t& bans)\n+{\n+    for (const auto& ban_entry_json : bans_json.getValues()) {\n+        CSubNet subnet;\n+        const auto& subnet_str = ban_entry_json[BANMAN_JSON_ADDR_KEY].get_str();\n+        if (!LookupSubNet(subnet_str, subnet)) {\n+            throw std::runtime_error(\n+                strprintf(\"Cannot parse banned address or subnet: %s\", subnet_str));\n+        }\n+        bans.insert_or_assign(subnet, CBanEntry{ban_entry_json});\n+    }\n+}"
      },
      {
        "sha": "ffdc24c772959045b93f94471017bc7741af2169",
        "filename": "src/net_types.h",
        "status": "modified",
        "additions": 46,
        "deletions": 1,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/net_types.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/net_types.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_types.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -5,11 +5,56 @@\n #ifndef BITCOIN_NET_TYPES_H\n #define BITCOIN_NET_TYPES_H\n \n+#include <cstdint>\n #include <map>\n \n-class CBanEntry;\n class CSubNet;\n+class UniValue;\n+\n+class CBanEntry\n+{\n+public:\n+    static constexpr int CURRENT_VERSION{1};\n+    int nVersion{CBanEntry::CURRENT_VERSION};\n+    int64_t nCreateTime{0};\n+    int64_t nBanUntil{0};\n+\n+    CBanEntry() {}\n+\n+    explicit CBanEntry(int64_t nCreateTimeIn)\n+        : nCreateTime{nCreateTimeIn} {}\n+\n+    /**\n+     * Create a ban entry from JSON.\n+     * @param[in] json A JSON representation of a ban entry, as created by `ToJson()`.\n+     * @throw std::runtime_error if the JSON does not have the expected fields.\n+     */\n+    explicit CBanEntry(const UniValue& json);\n+\n+    /**\n+     * Generate a JSON representation of this ban entry.\n+     * @return JSON suitable for passing to the `CBanEntry(const UniValue&)` constructor.\n+     */\n+    UniValue ToJson() const;\n+};\n \n using banmap_t = std::map<CSubNet, CBanEntry>;\n \n+/**\n+ * Convert a `banmap_t` object to a JSON array.\n+ * @param[in] bans Bans list to convert.\n+ * @return a JSON array, similar to the one returned by the `listbanned` RPC. Suitable for\n+ * passing to `BanMapFromJson()`.\n+ */\n+UniValue BanMapToJson(const banmap_t& bans);\n+\n+/**\n+ * Convert a JSON array to a `banmap_t` object.\n+ * @param[in] bans_json JSON to convert, must be as returned by `BanMapToJson()`.\n+ * @param[out] bans Bans list to create from the JSON.\n+ * @throws std::runtime_error if the JSON does not have the expected fields or they contain\n+ * unparsable values.\n+ */\n+void BanMapFromJson(const UniValue& bans_json, banmap_t& bans);\n+\n #endif // BITCOIN_NET_TYPES_H"
      },
      {
        "sha": "b2f4945e3bc816d7fc60c09da84f64924fcc4e21",
        "filename": "src/netaddress.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 5,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/netaddress.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/netaddress.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -1242,8 +1242,3 @@ bool operator<(const CSubNet& a, const CSubNet& b)\n {\n     return (a.network < b.network || (a.network == b.network && memcmp(a.netmask, b.netmask, 16) < 0));\n }\n-\n-bool SanityCheckASMap(const std::vector<bool>& asmap)\n-{\n-    return SanityCheckASMap(asmap, 128); // For IP address lookups, the input is 128 bits\n-}"
      },
      {
        "sha": "cfb2edcd34b2d68155824d23dec61e8b28b8fe13",
        "filename": "src/netaddress.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/netaddress.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/netaddress.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netaddress.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -567,6 +567,4 @@ class CService : public CNetAddr\n     }\n };\n \n-bool SanityCheckASMap(const std::vector<bool>& asmap);\n-\n #endif // BITCOIN_NETADDRESS_H"
      },
      {
        "sha": "64d17189a6abe7065af94f18ad61535d60a98380",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -23,8 +23,6 @@\n \n #ifndef WIN32\n #include <fcntl.h>\n-#else\n-#include <codecvt>\n #endif\n \n #ifdef USE_POLL"
      },
      {
        "sha": "5ddcf95c8469446bd0644b67c2d2988d13d1fd21",
        "filename": "src/node/blockstorage.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 7,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/node/blockstorage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/node/blockstorage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/blockstorage.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -394,18 +394,14 @@ bool ReadBlockFromDisk(CBlock& block, const FlatFilePos& pos, const Consensus::P\n \n bool ReadBlockFromDisk(CBlock& block, const CBlockIndex* pindex, const Consensus::Params& consensusParams)\n {\n-    FlatFilePos blockPos;\n-    {\n-        LOCK(cs_main);\n-        blockPos = pindex->GetBlockPos();\n-    }\n+    const FlatFilePos block_pos{WITH_LOCK(cs_main, return pindex->GetBlockPos())};\n \n-    if (!ReadBlockFromDisk(block, blockPos, consensusParams)) {\n+    if (!ReadBlockFromDisk(block, block_pos, consensusParams)) {\n         return false;\n     }\n     if (block.GetHash() != pindex->GetBlockHash()) {\n         return error(\"ReadBlockFromDisk(CBlock&, CBlockIndex*): GetHash() doesn't match index for %s at %s\",\n-                     pindex->ToString(), pindex->GetBlockPos().ToString());\n+                     pindex->ToString(), block_pos.ToString());\n     }\n     return true;\n }"
      },
      {
        "sha": "c62d7e5d0b4536f761185a21fc5ab21338bad0e4",
        "filename": "src/node/interfaces.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/node/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/node/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/interfaces.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -72,7 +72,7 @@ class NodeImpl : public Node\n private:\n     ChainstateManager& chainman() { return *Assert(m_context->chainman); }\n public:\n-    explicit NodeImpl(NodeContext* context) { setContext(context); }\n+    explicit NodeImpl(NodeContext& context) { setContext(&context); }\n     void initLogging() override { InitLogging(*Assert(m_context->args)); }\n     void initParameterInteraction() override { InitParameterInteraction(*Assert(m_context->args)); }\n     bilingual_str getWarnings() override { return GetWarnings(true); }\n@@ -710,6 +710,6 @@ class ChainImpl : public Chain\n } // namespace node\n \n namespace interfaces {\n-std::unique_ptr<Node> MakeNode(NodeContext* context) { return std::make_unique<node::NodeImpl>(context); }\n+std::unique_ptr<Node> MakeNode(NodeContext& context) { return std::make_unique<node::NodeImpl>(context); }\n std::unique_ptr<Chain> MakeChain(NodeContext& context) { return std::make_unique<node::ChainImpl>(context); }\n } // namespace interfaces"
      },
      {
        "sha": "15527afb8ac57849cb58508f7f9f12dc89a35bc2",
        "filename": "src/policy/rbf.cpp",
        "status": "modified",
        "additions": 132,
        "deletions": 3,
        "changes": 135,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/policy/rbf.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/policy/rbf.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -3,13 +3,17 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <policy/rbf.h>\n+\n+#include <policy/settings.h>\n+#include <tinyformat.h>\n+#include <util/moneystr.h>\n #include <util/rbf.h>\n \n RBFTransactionState IsRBFOptIn(const CTransaction& tx, const CTxMemPool& pool)\n {\n     AssertLockHeld(pool.cs);\n \n-    CTxMemPool::setEntries setAncestors;\n+    CTxMemPool::setEntries ancestors;\n \n     // First check the transaction itself.\n     if (SignalsOptInRBF(tx)) {\n@@ -27,9 +31,9 @@ RBFTransactionState IsRBFOptIn(const CTransaction& tx, const CTxMemPool& pool)\n     uint64_t noLimit = std::numeric_limits<uint64_t>::max();\n     std::string dummy;\n     CTxMemPoolEntry entry = *pool.mapTx.find(tx.GetHash());\n-    pool.CalculateMemPoolAncestors(entry, setAncestors, noLimit, noLimit, noLimit, noLimit, dummy, false);\n+    pool.CalculateMemPoolAncestors(entry, ancestors, noLimit, noLimit, noLimit, noLimit, dummy, false);\n \n-    for (CTxMemPool::txiter it : setAncestors) {\n+    for (CTxMemPool::txiter it : ancestors) {\n         if (SignalsOptInRBF(it->GetTx())) {\n             return RBFTransactionState::REPLACEABLE_BIP125;\n         }\n@@ -42,3 +46,128 @@ RBFTransactionState IsRBFOptInEmptyMempool(const CTransaction& tx)\n     // If we don't have a local mempool we can only check the transaction itself.\n     return SignalsOptInRBF(tx) ? RBFTransactionState::REPLACEABLE_BIP125 : RBFTransactionState::UNKNOWN;\n }\n+\n+std::optional<std::string> GetEntriesForConflicts(const CTransaction& tx,\n+                            CTxMemPool& pool,\n+                            const CTxMemPool::setEntries& iters_conflicting,\n+                            CTxMemPool::setEntries& all_conflicts)\n+{\n+    AssertLockHeld(pool.cs);\n+    const uint256 txid = tx.GetHash();\n+    uint64_t nConflictingCount = 0;\n+    for (const auto& mi : iters_conflicting) {\n+        nConflictingCount += mi->GetCountWithDescendants();\n+        // This potentially overestimates the number of actual descendants but we just want to be\n+        // conservative to avoid doing too much work.\n+        if (nConflictingCount > MAX_BIP125_REPLACEMENT_CANDIDATES) {\n+            return strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n+                             txid.ToString(),\n+                             nConflictingCount,\n+                             MAX_BIP125_REPLACEMENT_CANDIDATES);\n+        }\n+    }\n+    // If not too many to replace, then calculate the set of\n+    // transactions that would have to be evicted\n+    for (CTxMemPool::txiter it : iters_conflicting) {\n+        pool.CalculateDescendants(it, all_conflicts);\n+    }\n+    return std::nullopt;\n+}\n+\n+std::optional<std::string> HasNoNewUnconfirmed(const CTransaction& tx,\n+                                               const CTxMemPool& pool,\n+                                               const CTxMemPool::setEntries& iters_conflicting)\n+{\n+    AssertLockHeld(pool.cs);\n+    std::set<uint256> parents_of_conflicts;\n+    for (const auto& mi : iters_conflicting) {\n+        for (const CTxIn &txin : mi->GetTx().vin) {\n+            parents_of_conflicts.insert(txin.prevout.hash);\n+        }\n+    }\n+\n+    for (unsigned int j = 0; j < tx.vin.size(); j++) {\n+        // We don't want to accept replacements that require low feerate junk to be mined first.\n+        // Ideally we'd keep track of the ancestor feerates and make the decision based on that, but\n+        // for now requiring all new inputs to be confirmed works.\n+        //\n+        // Note that if you relax this to make RBF a little more useful, this may break the\n+        // CalculateMempoolAncestors RBF relaxation, above. See the comment above the first\n+        // CalculateMempoolAncestors call for more info.\n+        if (!parents_of_conflicts.count(tx.vin[j].prevout.hash)) {\n+            // Rather than check the UTXO set - potentially expensive - it's cheaper to just check\n+            // if the new input refers to a tx that's in the mempool.\n+            if (pool.exists(tx.vin[j].prevout.hash)) {\n+                return strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n+                                 tx.GetHash().ToString(), j);\n+            }\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+std::optional<std::string> EntriesAndTxidsDisjoint(const CTxMemPool::setEntries& ancestors,\n+                                                   const std::set<uint256>& direct_conflicts,\n+                                                   const uint256& txid)\n+{\n+    for (CTxMemPool::txiter ancestorIt : ancestors) {\n+        const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n+        if (direct_conflicts.count(hashAncestor)) {\n+            return strprintf(\"%s spends conflicting transaction %s\",\n+                             txid.ToString(),\n+                             hashAncestor.ToString());\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+std::optional<std::string> PaysMoreThanConflicts(const CTxMemPool::setEntries& iters_conflicting,\n+                                                 CFeeRate replacement_feerate,\n+                                                 const uint256& txid)\n+{\n+    for (const auto& mi : iters_conflicting) {\n+        // Don't allow the replacement to reduce the feerate of the mempool.\n+        //\n+        // We usually don't want to accept replacements with lower feerates than what they replaced\n+        // as that would lower the feerate of the next block. Requiring that the feerate always be\n+        // increased is also an easy-to-reason about way to prevent DoS attacks via replacements.\n+        //\n+        // We only consider the feerates of transactions being directly replaced, not their indirect\n+        // descendants. While that does mean high feerate children are ignored when deciding whether\n+        // or not to replace, we do require the replacement to pay more overall fees too, mitigating\n+        // most cases.\n+        CFeeRate original_feerate(mi->GetModifiedFee(), mi->GetTxSize());\n+        if (replacement_feerate <= original_feerate) {\n+            return strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n+                             txid.ToString(),\n+                             replacement_feerate.ToString(),\n+                             original_feerate.ToString());\n+        }\n+    }\n+    return std::nullopt;\n+}\n+\n+std::optional<std::string> PaysForRBF(CAmount original_fees,\n+                                      CAmount replacement_fees,\n+                                      size_t replacement_vsize,\n+                                      const uint256& txid)\n+{\n+    // The replacement must pay greater fees than the transactions it\n+    // replaces - if we did the bandwidth used by those conflicting\n+    // transactions would not be paid for.\n+    if (replacement_fees < original_fees) {\n+        return strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n+                         txid.ToString(), FormatMoney(replacement_fees), FormatMoney(original_fees));\n+    }\n+\n+    // Finally in addition to paying more fees than the conflicts the\n+    // new transaction must pay for its own bandwidth.\n+    CAmount additional_fees = replacement_fees - original_fees;\n+    if (additional_fees < ::incrementalRelayFee.GetFee(replacement_vsize)) {\n+        return strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n+                         txid.ToString(),\n+                         FormatMoney(additional_fees),\n+                         FormatMoney(::incrementalRelayFee.GetFee(replacement_vsize)));\n+    }\n+    return std::nullopt;\n+}"
      },
      {
        "sha": "56468a09b2149910f0399155522403895ae27186",
        "filename": "src/policy/rbf.h",
        "status": "modified",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/policy/rbf.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/policy/rbf.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/rbf.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -7,6 +7,10 @@\n \n #include <txmempool.h>\n \n+/** Maximum number of transactions that can be replaced by BIP125 RBF (Rule #5). This includes all\n+ * mempool conflicts and their descendants. */\n+static constexpr uint32_t MAX_BIP125_REPLACEMENT_CANDIDATES{100};\n+\n /** The rbf state of unconfirmed transactions */\n enum class RBFTransactionState {\n     /** Unconfirmed tx that does not signal rbf and is not in the mempool */\n@@ -31,4 +35,61 @@ enum class RBFTransactionState {\n RBFTransactionState IsRBFOptIn(const CTransaction& tx, const CTxMemPool& pool) EXCLUSIVE_LOCKS_REQUIRED(pool.cs);\n RBFTransactionState IsRBFOptInEmptyMempool(const CTransaction& tx);\n \n+/** Get all descendants of iters_conflicting. Also enforce BIP125 Rule #5, \"The number of original\n+ * transactions to be replaced and their descendant transactions which will be evicted from the\n+ * mempool must not exceed a total of 100 transactions.\" Quit as early as possible. There cannot be\n+ * more than MAX_BIP125_REPLACEMENT_CANDIDATES potential entries.\n+ * @param[in]   iters_conflicting   The set of iterators to mempool entries.\n+ * @param[out]  all_conflicts       Populated with all the mempool entries that would be replaced,\n+ *                                  which includes descendants of iters_conflicting. Not cleared at\n+ *                                  the start; any existing mempool entries will remain in the set.\n+ * @returns an error message if Rule #5 is broken, otherwise a std::nullopt.\n+ */\n+std::optional<std::string> GetEntriesForConflicts(const CTransaction& tx, CTxMemPool& pool,\n+                                                  const CTxMemPool::setEntries& iters_conflicting,\n+                                                  CTxMemPool::setEntries& all_conflicts)\n+                                                  EXCLUSIVE_LOCKS_REQUIRED(pool.cs);\n+\n+/** BIP125 Rule #2: \"The replacement transaction may only include an unconfirmed input if that input\n+ * was included in one of the original transactions.\"\n+ * @returns error message if Rule #2 is broken, otherwise std::nullopt. */\n+std::optional<std::string> HasNoNewUnconfirmed(const CTransaction& tx, const CTxMemPool& pool,\n+                                               const CTxMemPool::setEntries& iters_conflicting)\n+                                               EXCLUSIVE_LOCKS_REQUIRED(pool.cs);\n+\n+/** Check the intersection between two sets of transactions (a set of mempool entries and a set of\n+ * txids) to make sure they are disjoint.\n+ * @param[in]   ancestors           Set of mempool entries corresponding to ancestors of the\n+ *                                  replacement transactions.\n+ * @param[in]   direct_conflicts    Set of txids corresponding to the mempool conflicts\n+ *                                  (candidates to be replaced).\n+ * @param[in]   txid                Transaction ID, included in the error message if violation occurs.\n+ * @returns error message if the sets intersect, std::nullopt if they are disjoint.\n+ */\n+std::optional<std::string> EntriesAndTxidsDisjoint(const CTxMemPool::setEntries& ancestors,\n+                                                   const std::set<uint256>& direct_conflicts,\n+                                                   const uint256& txid);\n+\n+/** Check that the feerate of the replacement transaction(s) is higher than the feerate of each\n+ * of the transactions in iters_conflicting.\n+ * @param[in]   iters_conflicting  The set of mempool entries.\n+ * @returns error message if fees insufficient, otherwise std::nullopt.\n+ */\n+std::optional<std::string> PaysMoreThanConflicts(const CTxMemPool::setEntries& iters_conflicting,\n+                                                 CFeeRate replacement_feerate, const uint256& txid);\n+\n+/** Enforce BIP125 Rule #3 \"The replacement transaction pays an absolute fee of at least the sum\n+ * paid by the original transactions.\" Enforce BIP125 Rule #4 \"The replacement transaction must also\n+ * pay for its own bandwidth at or above the rate set by the node's minimum relay fee setting.\"\n+ * @param[in]   original_fees       Total modified fees of original transaction(s).\n+ * @param[in]   replacement_fees    Total modified fees of replacement transaction(s).\n+ * @param[in]   replacement_vsize   Total virtual size of replacement transaction(s).\n+ * @param[in]   txid                Transaction ID, included in the error message if violation occurs.\n+ * @returns error string if fees are insufficient, otherwise std::nullopt.\n+ */\n+std::optional<std::string> PaysForRBF(CAmount original_fees,\n+                                      CAmount replacement_fees,\n+                                      size_t replacement_vsize,\n+                                      const uint256& txid);\n+\n #endif // BITCOIN_POLICY_RBF_H"
      },
      {
        "sha": "2149e459936410c5d4791fe16c389122aafa234c",
        "filename": "src/protocol.h",
        "status": "modified",
        "additions": 2,
        "deletions": 11,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/protocol.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/protocol.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/protocol.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -396,7 +396,6 @@ class CAddress : public CService\n         // ambiguous what that would mean. Make sure no code relying on that is introduced:\n         assert(!(s.GetType() & SER_GETHASH));\n         bool use_v2;\n-        bool store_time;\n         if (s.GetType() & SER_DISK) {\n             // In the disk serialization format, the encoding (v1 or v2) is determined by a flag version\n             // that's part of the serialization itself. ADDRV2_FORMAT in the stream version only determines\n@@ -413,24 +412,16 @@ class CAddress : public CService\n             } else {\n                 throw std::ios_base::failure(\"Unsupported CAddress disk format version\");\n             }\n-            store_time = true;\n         } else {\n             // In the network serialization format, the encoding (v1 or v2) is determined directly by\n             // the value of ADDRV2_FORMAT in the stream version, as no explicitly encoded version\n             // exists in the stream.\n             assert(s.GetType() & SER_NETWORK);\n             use_v2 = s.GetVersion() & ADDRV2_FORMAT;\n-            // The only time we serialize a CAddress object without nTime is in\n-            // the initial VERSION messages which contain two CAddress records.\n-            // At that point, the serialization version is INIT_PROTO_VERSION.\n-            // After the version handshake, serialization version is >=\n-            // MIN_PEER_PROTO_VERSION and all ADDR messages are serialized with\n-            // nTime.\n-            store_time = s.GetVersion() != INIT_PROTO_VERSION;\n         }\n \n         SER_READ(obj, obj.nTime = TIME_INIT);\n-        if (store_time) READWRITE(obj.nTime);\n+        READWRITE(obj.nTime);\n         // nServices is serialized as CompactSize in V2; as uint64_t in V1.\n         if (use_v2) {\n             uint64_t services_tmp;\n@@ -445,7 +436,7 @@ class CAddress : public CService\n         SerReadWriteMany(os, ser_action, ReadWriteAsHelper<CService>(obj));\n     }\n \n-    //! Always included in serialization, except in the network format on INIT_PROTO_VERSION.\n+    //! Always included in serialization.\n     uint32_t nTime{TIME_INIT};\n     //! Serialized as uint64_t in V1, and as CompactSize in V2.\n     ServiceFlags nServices{NODE_NONE};"
      },
      {
        "sha": "d14a20b8709bc14bebeb4c127017d23267125134",
        "filename": "src/pubkey.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/pubkey.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/pubkey.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -180,6 +180,23 @@ XOnlyPubKey::XOnlyPubKey(Span<const unsigned char> bytes)\n     std::copy(bytes.begin(), bytes.end(), m_keydata.begin());\n }\n \n+std::vector<CKeyID> XOnlyPubKey::GetKeyIDs() const\n+{\n+    std::vector<CKeyID> out;\n+    // For now, use the old full pubkey-based key derivation logic. As it is indexed by\n+    // Hash160(full pubkey), we need to return both a version prefixed with 0x02, and one\n+    // with 0x03.\n+    unsigned char b[33] = {0x02};\n+    std::copy(m_keydata.begin(), m_keydata.end(), b + 1);\n+    CPubKey fullpubkey;\n+    fullpubkey.Set(b, b + 33);\n+    out.push_back(fullpubkey.GetID());\n+    b[0] = 0x03;\n+    fullpubkey.Set(b, b + 33);\n+    out.push_back(fullpubkey.GetID());\n+    return out;\n+}\n+\n bool XOnlyPubKey::IsFullyValid() const\n {\n     secp256k1_xonly_pubkey pubkey;\n@@ -333,6 +350,7 @@ void CExtPubKey::Decode(const unsigned char code[BIP32_EXTKEY_SIZE]) {\n     nChild = (code[5] << 24) | (code[6] << 16) | (code[7] << 8) | code[8];\n     memcpy(chaincode.begin(), code+9, 32);\n     pubkey.Set(code+41, code+BIP32_EXTKEY_SIZE);\n+    if ((nDepth == 0 && (nChild != 0 || ReadLE32(vchFingerprint) != 0)) || !pubkey.IsFullyValid()) pubkey = CPubKey();\n }\n \n bool CExtPubKey::Derive(CExtPubKey &out, unsigned int _nChild) const {"
      },
      {
        "sha": "861a2cf500679657dfbbd619325fa8626c649f3d",
        "filename": "src/pubkey.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/pubkey.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/pubkey.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pubkey.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -267,6 +267,11 @@ class XOnlyPubKey\n     /** Construct a Taproot tweaked output point with this point as internal key. */\n     std::optional<std::pair<XOnlyPubKey, bool>> CreateTapTweak(const uint256* merkle_root) const;\n \n+    /** Returns a list of CKeyIDs for the CPubKeys that could have been used to create this XOnlyPubKey.\n+     * This is needed for key lookups since keys are indexed by CKeyID.\n+     */\n+    std::vector<CKeyID> GetKeyIDs() const;\n+\n     const unsigned char& operator[](int pos) const { return *(m_keydata.begin() + pos); }\n     const unsigned char* data() const { return m_keydata.begin(); }\n     static constexpr size_t size() { return decltype(m_keydata)::size(); }"
      },
      {
        "sha": "e78594390b660c5445666b320db9b77b7a60bb67",
        "filename": "src/qt/addressbookpage.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/addressbookpage.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/addressbookpage.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/addressbookpage.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -282,7 +282,7 @@ void AddressBookPage::on_exportButton_clicked()\n     QString filename = GUIUtil::getSaveFileName(this,\n         tr(\"Export Address List\"), QString(),\n         /*: Expanded name of the CSV file format.\n-            See https://en.wikipedia.org/wiki/Comma-separated_values */\n+            See: https://en.wikipedia.org/wiki/Comma-separated_values. */\n         tr(\"Comma separated file\") + QLatin1String(\" (*.csv)\"), nullptr);\n \n     if (filename.isNull())"
      },
      {
        "sha": "4b5b38e43f887e88264229f6c38c4ae22c15f155",
        "filename": "src/qt/bantablemodel.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/bantablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/bantablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bantablemodel.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -5,6 +5,7 @@\n #ifndef BITCOIN_QT_BANTABLEMODEL_H\n #define BITCOIN_QT_BANTABLEMODEL_H\n \n+#include <addrdb.h>\n #include <net.h>\n \n #include <memory>"
      },
      {
        "sha": "d4895ea6ff3925a26a89d9c2494f395d4583c4b2",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 7,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -11,6 +11,7 @@\n #include <chainparams.h>\n #include <init.h>\n #include <interfaces/handler.h>\n+#include <interfaces/init.h>\n #include <interfaces/node.h>\n #include <node/context.h>\n #include <node/ui_interface.h>\n@@ -275,10 +276,10 @@ void BitcoinApplication::createSplashScreen(const NetworkStyle *networkStyle)\n     connect(this, &BitcoinApplication::requestedShutdown, m_splash, &QWidget::close);\n }\n \n-void BitcoinApplication::setNode(interfaces::Node& node)\n+void BitcoinApplication::createNode(interfaces::Init& init)\n {\n     assert(!m_node);\n-    m_node = &node;\n+    m_node = init.makeNode();\n     if (optionsModel) optionsModel->setNode(*m_node);\n     if (m_splash) m_splash->setNode(*m_node);\n }\n@@ -460,11 +461,13 @@ int GuiMain(int argc, char* argv[])\n     util::WinCmdLineArgs winArgs;\n     std::tie(argc, argv) = winArgs.get();\n #endif\n-    SetupEnvironment();\n-    util::ThreadSetInternalName(\"main\");\n \n     NodeContext node_context;\n-    std::unique_ptr<interfaces::Node> node = interfaces::MakeNode(&node_context);\n+    int unused_exit_status;\n+    std::unique_ptr<interfaces::Init> init = interfaces::MakeNodeInit(node_context, argc, argv, unused_exit_status);\n+\n+    SetupEnvironment();\n+    util::ThreadSetInternalName(\"main\");\n \n     // Subscribe to global signals from core\n     boost::signals2::scoped_connection handler_message_box = ::uiInterface.ThreadSafeMessageBox_connect(noui_ThreadSafeMessageBox);\n@@ -492,7 +495,6 @@ int GuiMain(int argc, char* argv[])\n \n     /// 2. Parse command-line options. We do this after qt in order to show an error if there are problems parsing these\n     // Command-line options take precedence:\n-    node_context.args = &gArgs;\n     SetupServerArgs(gArgs);\n     SetupUIArgs(gArgs);\n     std::string error;\n@@ -623,7 +625,7 @@ int GuiMain(int argc, char* argv[])\n     if (gArgs.GetBoolArg(\"-splash\", DEFAULT_SPLASHSCREEN) && !gArgs.GetBoolArg(\"-min\", false))\n         app.createSplashScreen(networkStyle.data());\n \n-    app.setNode(*node);\n+    app.createNode(*init);\n \n     int rv = EXIT_SUCCESS;\n     try"
      },
      {
        "sha": "602b76052cbd06e54fcee1ba62f90c3866a60f8e",
        "filename": "src/qt/bitcoin.h",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/bitcoin.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/bitcoin.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -27,6 +27,9 @@ class PlatformStyle;\n class SplashScreen;\n class WalletController;\n class WalletModel;\n+namespace interfaces {\n+class Init;\n+} // namespace interfaces\n \n \n /** Main Bitcoin application object */\n@@ -51,6 +54,8 @@ class BitcoinApplication: public QApplication\n     void createWindow(const NetworkStyle *networkStyle);\n     /// Create splash screen\n     void createSplashScreen(const NetworkStyle *networkStyle);\n+    /// Create or spawn node\n+    void createNode(interfaces::Init& init);\n     /// Basic initialization, before starting initialization/shutdown thread. Return true on success.\n     bool baseInitialize();\n \n@@ -69,7 +74,6 @@ class BitcoinApplication: public QApplication\n     void setupPlatformStyle();\n \n     interfaces::Node& node() const { assert(m_node); return *m_node; }\n-    void setNode(interfaces::Node& node);\n \n public Q_SLOTS:\n     void initializeResult(bool success, interfaces::BlockAndHeaderTipInfo tip_info);\n@@ -103,7 +107,7 @@ public Q_SLOTS:\n     const PlatformStyle *platformStyle;\n     std::unique_ptr<QWidget> shutdownWindow;\n     SplashScreen* m_splash = nullptr;\n-    interfaces::Node* m_node = nullptr;\n+    std::unique_ptr<interfaces::Node> m_node;\n \n     void startThread();\n };"
      },
      {
        "sha": "862bdd3bfe86ab953f273aae7b85f1d91ec11225",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -113,6 +113,7 @@ BitcoinGUI::BitcoinGUI(interfaces::Node& node, const PlatformStyle *_platformSty\n         connect(walletFrame, &WalletFrame::message, [this](const QString& title, const QString& message, unsigned int style) {\n             this->message(title, message, style);\n         });\n+        connect(walletFrame, &WalletFrame::currentWalletSet, [this] { updateWalletStatus(); });\n         setCentralWidget(walletFrame);\n     } else\n #endif // ENABLE_WALLET\n@@ -329,7 +330,7 @@ void BitcoinGUI::createActions()\n     verifyMessageAction->setStatusTip(tr(\"Verify messages to ensure they were signed with specified Bitcoin addresses\"));\n     m_load_psbt_action = new QAction(tr(\"&Load PSBT from file\u2026\"), this);\n     m_load_psbt_action->setStatusTip(tr(\"Load Partially Signed Bitcoin Transaction\"));\n-    m_load_psbt_clipboard_action = new QAction(tr(\"Load PSBT from clipboard\u2026\"), this);\n+    m_load_psbt_clipboard_action = new QAction(tr(\"Load PSBT from &clipboard\u2026\"), this);\n     m_load_psbt_clipboard_action->setStatusTip(tr(\"Load Partially Signed Bitcoin Transaction from clipboard\"));\n \n     openRPCConsoleAction = new QAction(tr(\"Node window\"), this);\n@@ -486,7 +487,7 @@ void BitcoinGUI::createMenuBar()\n \n     QMenu* window_menu = appMenuBar->addMenu(tr(\"&Window\"));\n \n-    QAction* minimize_action = window_menu->addAction(tr(\"Minimize\"));\n+    QAction* minimize_action = window_menu->addAction(tr(\"&Minimize\"));\n     minimize_action->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_M));\n     connect(minimize_action, &QAction::triggered, [] {\n         QApplication::activeWindow()->showMinimized();\n@@ -594,8 +595,8 @@ void BitcoinGUI::setClientModel(ClientModel *_clientModel, interfaces::BlockAndH\n         connect(_clientModel, &ClientModel::numConnectionsChanged, this, &BitcoinGUI::setNumConnections);\n         connect(_clientModel, &ClientModel::networkActiveChanged, this, &BitcoinGUI::setNetworkActive);\n \n-        modalOverlay->setKnownBestHeight(tip_info->header_height, QDateTime::fromTime_t(tip_info->header_time));\n-        setNumBlocks(tip_info->block_height, QDateTime::fromTime_t(tip_info->block_time), tip_info->verification_progress, false, SynchronizationState::INIT_DOWNLOAD);\n+        modalOverlay->setKnownBestHeight(tip_info->header_height, QDateTime::fromSecsSinceEpoch(tip_info->header_time));\n+        setNumBlocks(tip_info->block_height, QDateTime::fromSecsSinceEpoch(tip_info->block_time), tip_info->verification_progress, false, SynchronizationState::INIT_DOWNLOAD);\n         connect(_clientModel, &ClientModel::numBlocksChanged, this, &BitcoinGUI::setNumBlocks);\n \n         // Receive and report messages from client model\n@@ -675,8 +676,8 @@ void BitcoinGUI::addWallet(WalletModel* walletModel)\n {\n     if (!walletFrame) return;\n \n-    WalletView* wallet_view = new WalletView(platformStyle, walletFrame);\n-    if (!walletFrame->addWallet(walletModel, wallet_view)) return;\n+    WalletView* wallet_view = new WalletView(walletModel, platformStyle, walletFrame);\n+    if (!walletFrame->addView(wallet_view)) return;\n \n     rpcConsole->addWallet(walletModel);\n     if (m_wallet_selector->count() == 0) {\n@@ -694,7 +695,6 @@ void BitcoinGUI::addWallet(WalletModel* walletModel)\n     });\n     connect(wallet_view, &WalletView::encryptionStatusChanged, this, &BitcoinGUI::updateWalletStatus);\n     connect(wallet_view, &WalletView::incomingTransaction, this, &BitcoinGUI::incomingTransaction);\n-    connect(wallet_view, &WalletView::hdEnabledStatusChanged, this, &BitcoinGUI::updateWalletStatus);\n     connect(this, &BitcoinGUI::setPrivacy, wallet_view, &WalletView::setPrivacy);\n     wallet_view->setPrivacy(isPrivacyModeActivated());\n     const QString display_name = walletModel->getDisplayName();\n@@ -1340,9 +1340,8 @@ void BitcoinGUI::setEncryptionStatus(int status)\n \n void BitcoinGUI::updateWalletStatus()\n {\n-    if (!walletFrame) {\n-        return;\n-    }\n+    assert(walletFrame);\n+\n     WalletView * const walletView = walletFrame->currentWalletView();\n     if (!walletView) {\n         return;"
      },
      {
        "sha": "c86cb16af66943e82d8a07eb74e2d8e114c6b2c3",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -216,7 +216,7 @@ bool ClientModel::isReleaseVersion() const\n \n QString ClientModel::formatClientStartupTime() const\n {\n-    return QDateTime::fromTime_t(GetStartupTime()).toString();\n+    return QDateTime::fromSecsSinceEpoch(GetStartupTime()).toString();\n }\n \n QString ClientModel::dataDir() const\n@@ -294,7 +294,7 @@ static void BlockTipChanged(ClientModel* clientmodel, SynchronizationState sync_\n \n     bool invoked = QMetaObject::invokeMethod(clientmodel, \"numBlocksChanged\", Qt::QueuedConnection,\n         Q_ARG(int, tip.block_height),\n-        Q_ARG(QDateTime, QDateTime::fromTime_t(tip.block_time)),\n+        Q_ARG(QDateTime, QDateTime::fromSecsSinceEpoch(tip.block_time)),\n         Q_ARG(double, verificationProgress),\n         Q_ARG(bool, fHeader),\n         Q_ARG(SynchronizationState, sync_state));"
      },
      {
        "sha": "59d220636d771b50442c879e228999980decd3ff",
        "filename": "src/qt/forms/optionsdialog.ui",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/forms/optionsdialog.ui",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/forms/optionsdialog.ui",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/forms/optionsdialog.ui?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -104,6 +104,9 @@\n         <layout class=\"QHBoxLayout\" name=\"horizontalLayout_2_Main\">\n          <item>\n           <widget class=\"QLabel\" name=\"databaseCacheLabel\">\n+           <property name=\"toolTip\">\n+            <string extracomment=\"Tooltip text for Options window setting that sets the size of the database cache. Explains the corresponding effects of increasing/decreasing this value.\">Maximum database cache size. A larger cache can contribute to faster sync, after which the benefit is less pronounced for most use cases. Lowering the cache size will reduce memory usage. Unused mempool memory is shared for this cache.</string>\n+           </property>\n            <property name=\"text\">\n             <string>Size of &amp;database cache</string>\n            </property>\n@@ -147,6 +150,9 @@\n         <layout class=\"QHBoxLayout\" name=\"horizontalLayout_Main_VerifyLabel\">\n          <item>\n           <widget class=\"QLabel\" name=\"threadsScriptVerifLabel\">\n+           <property name=\"toolTip\">\n+            <string extracomment=\"Tooltip text for Options window setting that sets the number of script verification threads. Explains that negative values mean to leave these many cores free to the system.\">Set the number of script verification threads. Negative values correspond to the number of cores you want to leave free to the system.</string>\n+           </property>\n            <property name=\"text\">\n             <string>Number of script &amp;verification threads</string>\n            </property>"
      },
      {
        "sha": "e98e50ba14819a08401aaf5ef107aaeea7b13aad",
        "filename": "src/qt/guiutil.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/guiutil.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/guiutil.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/guiutil.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -81,7 +81,7 @@ QString dateTimeStr(const QDateTime &date)\n \n QString dateTimeStr(qint64 nTime)\n {\n-    return dateTimeStr(QDateTime::fromTime_t((qint32)nTime));\n+    return dateTimeStr(QDateTime::fromSecsSinceEpoch(nTime));\n }\n \n QFont fixedPitchFont(bool use_embedded_font)"
      },
      {
        "sha": "47c002498ad343252fb3bab101eb6eb3834cda05",
        "filename": "src/qt/locale/bitcoin_en.ts",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/locale/bitcoin_en.ts",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/locale/bitcoin_en.ts",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/locale/bitcoin_en.ts?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -749,8 +749,8 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <source>%n active connection(s) to Bitcoin network.</source>\n         <extracomment>A substring of the tooltip.</extracomment>\n         <translation type=\"unfinished\">\n-            <numerusform></numerusform>\n-            <numerusform></numerusform>\n+            <numerusform>%n active connection to Bitcoin network.</numerusform>\n+            <numerusform>%n active connections to Bitcoin network.</numerusform>\n         </translation>\n     </message>\n     <message>\n@@ -1376,8 +1376,8 @@ Signing is only possible with addresses of the type &apos;legacy&apos;.</source>\n         <source>(sufficient to restore backups %n day(s) old)</source>\n         <extracomment>Explanatory text on the capability of the current prune target.</extracomment>\n         <translation type=\"unfinished\">\n-            <numerusform></numerusform>\n-            <numerusform></numerusform>\n+            <numerusform>(sufficient to restore backups %n day old)</numerusform>\n+            <numerusform>(sufficient to restore backups %n days old)</numerusform>\n         </translation>\n     </message>\n     <message>"
      },
      {
        "sha": "92644ef24b0ef9d987bd331aa354ccbfae63970e",
        "filename": "src/qt/optionsdialog.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 4,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/optionsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/optionsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/optionsdialog.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -296,10 +296,22 @@ void OptionsDialog::on_resetButton_clicked()\n \n void OptionsDialog::on_openBitcoinConfButton_clicked()\n {\n-    /* explain the purpose of the config file */\n-    QMessageBox::information(this, tr(\"Configuration options\"),\n-        tr(\"The configuration file is used to specify advanced user options which override GUI settings. \"\n-           \"Additionally, any command-line options will override this configuration file.\"));\n+    QMessageBox config_msgbox(this);\n+    config_msgbox.setIcon(QMessageBox::Information);\n+    //: Window title text of pop-up box that allows opening up of configuration file.\n+    config_msgbox.setWindowTitle(tr(\"Configuration options\"));\n+    /*: Explanatory text about the priority order of instructions considered by client.\n+        The order from high to low being: command-line, configuration file, GUI settings. */\n+    config_msgbox.setText(tr(\"The configuration file is used to specify advanced user options which override GUI settings. \"\n+                             \"Additionally, any command-line options will override this configuration file.\"));\n+\n+    QPushButton* open_button = config_msgbox.addButton(tr(\"Continue\"), QMessageBox::ActionRole);\n+    config_msgbox.addButton(tr(\"Cancel\"), QMessageBox::RejectRole);\n+    open_button->setDefault(true);\n+\n+    config_msgbox.exec();\n+\n+    if (config_msgbox.clickedButton() != open_button) return;\n \n     /* show an error if there was some problem opening the file */\n     if (!GUIUtil::openBitcoinConf())"
      },
      {
        "sha": "433a1ea934e19e210250b0b2802fa62c2e321731",
        "filename": "src/qt/peertablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/peertablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/peertablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablemodel.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -72,7 +72,7 @@ QVariant PeerTableModel::data(const QModelIndex& index, int role) const\n         case NetNodeId:\n             return (qint64)rec->nodeStats.nodeid;\n         case Address:\n-            return QString::fromStdString(rec->nodeStats.addrName);\n+            return QString::fromStdString(rec->nodeStats.m_addr_name);\n         case Direction:\n             return QString(rec->nodeStats.fInbound ?\n                                //: An Inbound Connection from a Peer."
      },
      {
        "sha": "419133bc32f2c409709ffddd85db8a836bd39a40",
        "filename": "src/qt/peertablesortproxy.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/peertablesortproxy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/peertablesortproxy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/peertablesortproxy.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -25,7 +25,7 @@ bool PeerTableSortProxy::lessThan(const QModelIndex& left_index, const QModelInd\n     case PeerTableModel::NetNodeId:\n         return left_stats.nodeid < right_stats.nodeid;\n     case PeerTableModel::Address:\n-        return left_stats.addrName.compare(right_stats.addrName) < 0;\n+        return left_stats.m_addr_name.compare(right_stats.m_addr_name) < 0;\n     case PeerTableModel::Direction:\n         return left_stats.fInbound > right_stats.fInbound; // default sort Inbound, then Outbound\n     case PeerTableModel::ConnectionType:"
      },
      {
        "sha": "0799e01aac1a0a0d9d370d1423cc1f45538d2e22",
        "filename": "src/qt/qrimagewidget.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/qrimagewidget.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/qrimagewidget.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/qrimagewidget.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -119,7 +119,7 @@ void QRImageWidget::saveImage()\n     QString fn = GUIUtil::getSaveFileName(\n         this, tr(\"Save QR Code\"), QString(),\n         /*: Expanded name of the PNG file format.\n-            See https://en.wikipedia.org/wiki/Portable_Network_Graphics */\n+            See: https://en.wikipedia.org/wiki/Portable_Network_Graphics. */\n         tr(\"PNG Image\") + QLatin1String(\" (*.png)\"), nullptr);\n     if (!fn.isEmpty())\n     {"
      },
      {
        "sha": "ab8225e19ffbbc78b585482faa40d742577b1b8c",
        "filename": "src/qt/recentrequeststablemodel.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/recentrequeststablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/recentrequeststablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/recentrequeststablemodel.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -234,7 +234,7 @@ bool RecentRequestEntryLessThan::operator()(const RecentRequestEntry& left, cons\n     switch(column)\n     {\n     case RecentRequestsTableModel::Date:\n-        return pLeft->date.toTime_t() < pRight->date.toTime_t();\n+        return pLeft->date.toSecsSinceEpoch() < pRight->date.toSecsSinceEpoch();\n     case RecentRequestsTableModel::Label:\n         return pLeft->recipient.label < pRight->recipient.label;\n     case RecentRequestsTableModel::Message:"
      },
      {
        "sha": "c489c0eaf4aa9921e7bdb68f0dafa972e521613f",
        "filename": "src/qt/recentrequeststablemodel.h",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/recentrequeststablemodel.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/recentrequeststablemodel.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/recentrequeststablemodel.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -7,6 +7,8 @@\n \n #include <qt/sendcoinsrecipient.h>\n \n+#include <string>\n+\n #include <QAbstractTableModel>\n #include <QStringList>\n #include <QDateTime>\n@@ -26,9 +28,9 @@ class RecentRequestEntry\n \n     SERIALIZE_METHODS(RecentRequestEntry, obj) {\n         unsigned int date_timet;\n-        SER_WRITE(obj, date_timet = obj.date.toTime_t());\n+        SER_WRITE(obj, date_timet = obj.date.toSecsSinceEpoch());\n         READWRITE(obj.nVersion, obj.id, date_timet, obj.recipient);\n-        SER_READ(obj, obj.date = QDateTime::fromTime_t(date_timet));\n+        SER_READ(obj, obj.date = QDateTime::fromSecsSinceEpoch(date_timet));\n     }\n };\n "
      },
      {
        "sha": "4554f11a414a7abc7e0f848730aea34ed2a4b93f",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 2,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -651,7 +651,7 @@ void RPCConsole::setClientModel(ClientModel *model, int bestblock_height, int64_\n         setNumConnections(model->getNumConnections());\n         connect(model, &ClientModel::numConnectionsChanged, this, &RPCConsole::setNumConnections);\n \n-        setNumBlocks(bestblock_height, QDateTime::fromTime_t(bestblock_date), verification_progress, false);\n+        setNumBlocks(bestblock_height, QDateTime::fromSecsSinceEpoch(bestblock_date), verification_progress, false);\n         connect(model, &ClientModel::numBlocksChanged, this, &RPCConsole::setNumBlocks);\n \n         updateNetworkState();\n@@ -680,6 +680,11 @@ void RPCConsole::setClientModel(ClientModel *model, int bestblock_height, int64_\n \n         // create peer table context menu\n         peersTableContextMenu = new QMenu(this);\n+        //: Context menu action to copy the address of a peer.\n+        peersTableContextMenu->addAction(tr(\"&Copy address\"), [this] {\n+            GUIUtil::copyEntryData(ui->peerWidget, PeerTableModel::Address, Qt::DisplayRole);\n+        });\n+        peersTableContextMenu->addSeparator();\n         peersTableContextMenu->addAction(tr(\"&Disconnect\"), this, &RPCConsole::disconnectSelectedNode);\n         peersTableContextMenu->addAction(ts.ban_for + \" \" + tr(\"1 &hour\"), [this] { banSelectedNode(60 * 60); });\n         peersTableContextMenu->addAction(ts.ban_for + \" \" + tr(\"1 d&ay\"), [this] { banSelectedNode(60 * 60 * 24); });\n@@ -706,6 +711,13 @@ void RPCConsole::setClientModel(ClientModel *model, int bestblock_height, int64_\n \n         // create ban table context menu\n         banTableContextMenu = new QMenu(this);\n+        /*: Context menu action to copy the IP/Netmask of a banned peer.\n+            IP/Netmask is the combination of a peer's IP address and its Netmask.\n+            For IP address, see: https://en.wikipedia.org/wiki/IP_address. */\n+        banTableContextMenu->addAction(tr(\"&Copy IP/Netmask\"), [this] {\n+            GUIUtil::copyEntryData(ui->banlistWidget, BanTableModel::Address, Qt::DisplayRole);\n+        });\n+        banTableContextMenu->addSeparator();\n         banTableContextMenu->addAction(tr(\"&Unban\"), this, &RPCConsole::unbanSelectedNode);\n         connect(ui->banlistWidget, &QTableView::customContextMenuRequested, this, &RPCConsole::showBanTableContextMenu);\n \n@@ -1129,7 +1141,7 @@ void RPCConsole::updateDetailWidget()\n     }\n     const auto stats = selected_peers.first().data(PeerTableModel::StatsRole).value<CNodeCombinedStats*>();\n     // update the detail ui with latest node information\n-    QString peerAddrDetails(QString::fromStdString(stats->nodeStats.addrName) + \" \");\n+    QString peerAddrDetails(QString::fromStdString(stats->nodeStats.m_addr_name) + \" \");\n     peerAddrDetails += tr(\"(peer: %1)\").arg(QString::number(stats->nodeStats.nodeid));\n     if (!stats->nodeStats.addrLocal.empty())\n         peerAddrDetails += \"<br />\" + tr(\"via %1\").arg(QString::fromStdString(stats->nodeStats.addrLocal));"
      },
      {
        "sha": "ff53d8160f614d3c9266a046f7736d83bb7d2282",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -200,7 +200,7 @@ void SendCoinsDialog::setModel(WalletModel *_model)\n         ui->optInRBF->setCheckState(Qt::Checked);\n \n         if (model->wallet().hasExternalSigner()) {\n-            //: \"device\" usually means a hardware wallet\n+            //: \"device\" usually means a hardware wallet.\n             ui->sendButton->setText(tr(\"Sign on device\"));\n             if (gArgs.GetArg(\"-signer\", \"\") != \"\") {\n                 ui->sendButton->setEnabled(true);"
      },
      {
        "sha": "0de781661ac57e71ab6fa8d0f465287b52a1db59",
        "filename": "src/qt/test/addressbooktests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/test/addressbooktests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/test/addressbooktests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/addressbooktests.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -60,6 +60,8 @@ void EditAddressAndSubmit(\n void TestAddAddressesToSendBook(interfaces::Node& node)\n {\n     TestChain100Setup test;\n+    auto wallet_client = interfaces::MakeWalletClient(*test.m_node.chain, *Assert(test.m_node.args));\n+    test.m_node.wallet_client = wallet_client.get();\n     node.setContext(&test.m_node);\n     std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(node.context()->chain.get(), \"\", CreateMockWalletDatabase());\n     wallet->SetupLegacyScriptPubKeyMan();\n@@ -112,7 +114,7 @@ void TestAddAddressesToSendBook(interfaces::Node& node)\n     WalletContext& context = *node.walletClient().context();\n     AddWallet(context, wallet);\n     WalletModel walletModel(interfaces::MakeWallet(context, wallet), clientModel, platformStyle.get());\n-    RemoveWallet(context, wallet, /* load_on_startup= */ std::nullopt);\n+    RemoveWallet(context, wallet, /* load_on_start= */ std::nullopt);\n     EditAddressDialog editAddressDialog(EditAddressDialog::NewSendingAddress);\n     editAddressDialog.setModel(walletModel.getAddressTableModel());\n "
      },
      {
        "sha": "884ed256371e9f881bffb46d303bba132c3a405a",
        "filename": "src/qt/test/test_main.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/test/test_main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/test/test_main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/test_main.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -6,6 +6,7 @@\n #include <config/bitcoin-config.h>\n #endif\n \n+#include <interfaces/init.h>\n #include <interfaces/node.h>\n #include <qt/bitcoin.h>\n #include <qt/initexecutor.h>\n@@ -53,7 +54,8 @@ int main(int argc, char* argv[])\n     }\n \n     NodeContext node_context;\n-    std::unique_ptr<interfaces::Node> node = interfaces::MakeNode(&node_context);\n+    int unused_exit_status;\n+    std::unique_ptr<interfaces::Init> init = interfaces::MakeNodeInit(node_context, argc, argv, unused_exit_status);\n     gArgs.ForceSetArg(\"-listen\", \"0\");\n     gArgs.ForceSetArg(\"-listenonion\", \"0\");\n     gArgs.ForceSetArg(\"-discover\", \"0\");\n@@ -76,10 +78,9 @@ int main(int argc, char* argv[])\n     // Don't remove this, it's needed to access\n     // QApplication:: and QCoreApplication:: in the tests\n     BitcoinApplication app;\n-    app.setNode(*node);\n     app.setApplicationName(\"Bitcoin-Qt-test\");\n+    app.createNode(*init);\n \n-    app.node().context()->args = &gArgs;     // Make gArgs available in the NodeContext\n     AppTests app_tests(app);\n     if (QTest::qExec(&app_tests) != 0) {\n         fInvalid = true;"
      },
      {
        "sha": "62b135d3f17283bf506b0ad5dfb862f249c81e71",
        "filename": "src/qt/test/wallettests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/test/wallettests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/test/wallettests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/test/wallettests.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -138,6 +138,8 @@ void TestGUI(interfaces::Node& node)\n     for (int i = 0; i < 5; ++i) {\n         test.CreateAndProcessBlock({}, GetScriptForRawPubKey(test.coinbaseKey.GetPubKey()));\n     }\n+    auto wallet_client = interfaces::MakeWalletClient(*test.m_node.chain, *Assert(test.m_node.args));\n+    test.m_node.wallet_client = wallet_client.get();\n     node.setContext(&test.m_node);\n     std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(node.context()->chain.get(), \"\", CreateMockWalletDatabase());\n     wallet->LoadWallet();\n@@ -167,7 +169,7 @@ void TestGUI(interfaces::Node& node)\n     WalletContext& context = *node.walletClient().context();\n     AddWallet(context, wallet);\n     WalletModel walletModel(interfaces::MakeWallet(context, wallet), clientModel, platformStyle.get());\n-    RemoveWallet(context, wallet, /* load_on_startup= */ std::nullopt);\n+    RemoveWallet(context, wallet, /* load_on_start= */ std::nullopt);\n     sendCoinsDialog.setModel(&walletModel);\n     transactionView.setModel(&walletModel);\n "
      },
      {
        "sha": "57c05a647ed98843a4c1417f3d9776e19133c45c",
        "filename": "src/qt/transactionfilterproxy.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/transactionfilterproxy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/transactionfilterproxy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionfilterproxy.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -7,7 +7,9 @@\n #include <qt/transactiontablemodel.h>\n #include <qt/transactionrecord.h>\n \n+#include <algorithm>\n #include <cstdlib>\n+#include <optional>\n \n TransactionFilterProxy::TransactionFilterProxy(QObject *parent) :\n     QSortFilterProxyModel(parent),"
      },
      {
        "sha": "23590ea4d2474e5ab3da496ea60357cd0687bd45",
        "filename": "src/qt/transactiontablemodel.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/transactiontablemodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/transactiontablemodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiontablemodel.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -610,7 +610,7 @@ QVariant TransactionTableModel::data(const QModelIndex &index, int role) const\n     case TypeRole:\n         return rec->type;\n     case DateRole:\n-        return QDateTime::fromTime_t(static_cast<uint>(rec->time));\n+        return QDateTime::fromSecsSinceEpoch(rec->time);\n     case WatchonlyRole:\n         return rec->involvesWatchAddress;\n     case WatchonlyDecorationRole:\n@@ -630,7 +630,7 @@ QVariant TransactionTableModel::data(const QModelIndex &index, int role) const\n     case TxPlainTextRole:\n         {\n             QString details;\n-            QDateTime date = QDateTime::fromTime_t(static_cast<uint>(rec->time));\n+            QDateTime date = QDateTime::fromSecsSinceEpoch(rec->time);\n             QString txLabel = walletModel->getAddressTableModel()->labelForAddress(QString::fromStdString(rec->address));\n \n             details.append(date.toString(\"M/d/yy HH:mm\"));"
      },
      {
        "sha": "2f16e6edb449abace8a46094f67ef25650499e16",
        "filename": "src/qt/transactionview.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/transactionview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/transactionview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactionview.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -353,7 +353,7 @@ void TransactionView::exportClicked()\n     QString filename = GUIUtil::getSaveFileName(this,\n         tr(\"Export Transaction History\"), QString(),\n         /*: Expanded name of the CSV file format.\n-            See https://en.wikipedia.org/wiki/Comma-separated_values */\n+            See: https://en.wikipedia.org/wiki/Comma-separated_values. */\n         tr(\"Comma separated file\") + QLatin1String(\" (*.csv)\"), nullptr);\n \n     if (filename.isNull())"
      },
      {
        "sha": "5eeb2d5308e20520cd52c07c07b244f61decf9d9",
        "filename": "src/qt/walletframe.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/walletframe.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/walletframe.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletframe.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -11,6 +11,7 @@\n #include <qt/psbtoperationsdialog.h>\n #include <qt/walletmodel.h>\n #include <qt/walletview.h>\n+#include <util/system.h>\n \n #include <cassert>\n \n@@ -64,14 +65,13 @@ void WalletFrame::setClientModel(ClientModel *_clientModel)\n     }\n }\n \n-bool WalletFrame::addWallet(WalletModel* walletModel, WalletView* walletView)\n+bool WalletFrame::addView(WalletView* walletView)\n {\n-    if (!clientModel || !walletModel) return false;\n+    if (!clientModel) return false;\n \n-    if (mapWalletViews.count(walletModel) > 0) return false;\n+    if (mapWalletViews.count(walletView->getWalletModel()) > 0) return false;\n \n     walletView->setClientModel(clientModel);\n-    walletView->setWalletModel(walletModel);\n     walletView->showOutOfSyncWarning(bOutOfSync);\n \n     WalletView* current_wallet_view = currentWalletView();\n@@ -82,7 +82,7 @@ bool WalletFrame::addWallet(WalletModel* walletModel, WalletView* walletView)\n     }\n \n     walletStack->addWidget(walletView);\n-    mapWalletViews[walletModel] = walletView;\n+    mapWalletViews[walletView->getWalletModel()] = walletView;\n \n     return true;\n }\n@@ -109,7 +109,8 @@ void WalletFrame::setCurrentWallet(WalletModel* wallet_model)\n     walletView->updateGeometry();\n \n     walletStack->setCurrentWidget(walletView);\n-    walletView->updateEncryptionStatus();\n+\n+    Q_EMIT currentWalletSet();\n }\n \n void WalletFrame::removeWallet(WalletModel* wallet_model)"
      },
      {
        "sha": "cfca5c4c5c9f4e3bf273346af3520591cbbff0c9",
        "filename": "src/qt/walletframe.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/walletframe.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/walletframe.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletframe.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -35,7 +35,7 @@ class WalletFrame : public QFrame\n \n     void setClientModel(ClientModel *clientModel);\n \n-    bool addWallet(WalletModel* walletModel, WalletView* walletView);\n+    bool addView(WalletView* walletView);\n     void setCurrentWallet(WalletModel* wallet_model);\n     void removeWallet(WalletModel* wallet_model);\n     void removeAllWallets();\n@@ -49,6 +49,7 @@ class WalletFrame : public QFrame\n Q_SIGNALS:\n     void createWalletButtonClicked();\n     void message(const QString& title, const QString& message, unsigned int style);\n+    void currentWalletSet();\n \n private:\n     QStackedWidget *walletStack;"
      },
      {
        "sha": "309806a1c40f73d0c355a34004850a380c382ff4",
        "filename": "src/qt/walletview.cpp",
        "status": "modified",
        "additions": 35,
        "deletions": 58,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/walletview.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/walletview.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -30,19 +30,24 @@\n #include <QPushButton>\n #include <QVBoxLayout>\n \n-WalletView::WalletView(const PlatformStyle *_platformStyle, QWidget *parent):\n-    QStackedWidget(parent),\n-    clientModel(nullptr),\n-    walletModel(nullptr),\n-    platformStyle(_platformStyle)\n+WalletView::WalletView(WalletModel* wallet_model, const PlatformStyle* _platformStyle, QWidget* parent)\n+    : QStackedWidget(parent),\n+      clientModel(nullptr),\n+      walletModel(wallet_model),\n+      platformStyle(_platformStyle)\n {\n+    assert(walletModel);\n+\n     // Create tabs\n     overviewPage = new OverviewPage(platformStyle);\n+    overviewPage->setWalletModel(walletModel);\n \n     transactionsPage = new QWidget(this);\n     QVBoxLayout *vbox = new QVBoxLayout();\n     QHBoxLayout *hbox_buttons = new QHBoxLayout();\n     transactionView = new TransactionView(platformStyle, this);\n+    transactionView->setModel(walletModel);\n+\n     vbox->addWidget(transactionView);\n     QPushButton *exportButton = new QPushButton(tr(\"&Export\"), this);\n     exportButton->setToolTip(tr(\"Export the data in the current tab to a file\"));\n@@ -55,10 +60,16 @@ WalletView::WalletView(const PlatformStyle *_platformStyle, QWidget *parent):\n     transactionsPage->setLayout(vbox);\n \n     receiveCoinsPage = new ReceiveCoinsDialog(platformStyle);\n+    receiveCoinsPage->setModel(walletModel);\n+\n     sendCoinsPage = new SendCoinsDialog(platformStyle);\n+    sendCoinsPage->setModel(walletModel);\n \n     usedSendingAddressesPage = new AddressBookPage(platformStyle, AddressBookPage::ForEditing, AddressBookPage::SendingTab, this);\n+    usedSendingAddressesPage->setModel(walletModel->getAddressTableModel());\n+\n     usedReceivingAddressesPage = new AddressBookPage(platformStyle, AddressBookPage::ForEditing, AddressBookPage::ReceivingTab, this);\n+    usedReceivingAddressesPage->setModel(walletModel->getAddressTableModel());\n \n     addWidget(overviewPage);\n     addWidget(transactionsPage);\n@@ -84,6 +95,21 @@ WalletView::WalletView(const PlatformStyle *_platformStyle, QWidget *parent):\n     connect(transactionView, &TransactionView::message, this, &WalletView::message);\n \n     connect(this, &WalletView::setPrivacy, overviewPage, &OverviewPage::setPrivacy);\n+\n+    // Receive and pass through messages from wallet model\n+    connect(walletModel, &WalletModel::message, this, &WalletView::message);\n+\n+    // Handle changes in encryption status\n+    connect(walletModel, &WalletModel::encryptionStatusChanged, this, &WalletView::encryptionStatusChanged);\n+\n+    // Balloon pop-up for new transaction\n+    connect(walletModel->getTransactionTableModel(), &TransactionTableModel::rowsInserted, this, &WalletView::processNewTransaction);\n+\n+    // Ask for passphrase if needed\n+    connect(walletModel, &WalletModel::requireUnlock, this, &WalletView::unlockWallet);\n+\n+    // Show progress dialog\n+    connect(walletModel, &WalletModel::showProgress, this, &WalletView::showProgress);\n }\n \n WalletView::~WalletView()\n@@ -96,49 +122,15 @@ void WalletView::setClientModel(ClientModel *_clientModel)\n \n     overviewPage->setClientModel(_clientModel);\n     sendCoinsPage->setClientModel(_clientModel);\n-    if (walletModel) walletModel->setClientModel(_clientModel);\n-}\n-\n-void WalletView::setWalletModel(WalletModel *_walletModel)\n-{\n-    this->walletModel = _walletModel;\n-\n-    // Put transaction list in tabs\n-    transactionView->setModel(_walletModel);\n-    overviewPage->setWalletModel(_walletModel);\n-    receiveCoinsPage->setModel(_walletModel);\n-    sendCoinsPage->setModel(_walletModel);\n-    usedReceivingAddressesPage->setModel(_walletModel ? _walletModel->getAddressTableModel() : nullptr);\n-    usedSendingAddressesPage->setModel(_walletModel ? _walletModel->getAddressTableModel() : nullptr);\n-\n-    if (_walletModel)\n-    {\n-        // Receive and pass through messages from wallet model\n-        connect(_walletModel, &WalletModel::message, this, &WalletView::message);\n-\n-        // Handle changes in encryption status\n-        connect(_walletModel, &WalletModel::encryptionStatusChanged, this, &WalletView::encryptionStatusChanged);\n-        updateEncryptionStatus();\n-\n-        // update HD status\n-        Q_EMIT hdEnabledStatusChanged();\n-\n-        // Balloon pop-up for new transaction\n-        connect(_walletModel->getTransactionTableModel(), &TransactionTableModel::rowsInserted, this, &WalletView::processNewTransaction);\n-\n-        // Ask for passphrase if needed\n-        connect(_walletModel, &WalletModel::requireUnlock, this, &WalletView::unlockWallet);\n-\n-        // Show progress dialog\n-        connect(_walletModel, &WalletModel::showProgress, this, &WalletView::showProgress);\n-    }\n+    walletModel->setClientModel(_clientModel);\n }\n \n void WalletView::processNewTransaction(const QModelIndex& parent, int start, int /*end*/)\n {\n     // Prevent balloon-spam when initial block download is in progress\n-    if (!walletModel || !clientModel || clientModel->node().isInitialBlockDownload())\n+    if (!clientModel || clientModel->node().isInitialBlockDownload()) {\n         return;\n+    }\n \n     TransactionTableModel *ttm = walletModel->getTransactionTableModel();\n     if (!ttm || ttm->processingQueuedTransactions())\n@@ -211,20 +203,13 @@ void WalletView::showOutOfSyncWarning(bool fShow)\n     overviewPage->showOutOfSyncWarning(fShow);\n }\n \n-void WalletView::updateEncryptionStatus()\n-{\n-    Q_EMIT encryptionStatusChanged();\n-}\n-\n void WalletView::encryptWallet()\n {\n-    if(!walletModel)\n-        return;\n     AskPassphraseDialog dlg(AskPassphraseDialog::Encrypt, this);\n     dlg.setModel(walletModel);\n     dlg.exec();\n \n-    updateEncryptionStatus();\n+    Q_EMIT encryptionStatusChanged();\n }\n \n void WalletView::backupWallet()\n@@ -256,8 +241,6 @@ void WalletView::changePassphrase()\n \n void WalletView::unlockWallet()\n {\n-    if(!walletModel)\n-        return;\n     // Unlock wallet when requested by wallet model\n     if (walletModel->getEncryptionStatus() == WalletModel::Locked)\n     {\n@@ -269,17 +252,11 @@ void WalletView::unlockWallet()\n \n void WalletView::usedSendingAddresses()\n {\n-    if(!walletModel)\n-        return;\n-\n     GUIUtil::bringToFront(usedSendingAddressesPage);\n }\n \n void WalletView::usedReceivingAddresses()\n {\n-    if(!walletModel)\n-        return;\n-\n     GUIUtil::bringToFront(usedReceivingAddressesPage);\n }\n "
      },
      {
        "sha": "eebc163624fe8080eb90b841b252876c3b96dddd",
        "filename": "src/qt/walletview.h",
        "status": "modified",
        "additions": 8,
        "deletions": 13,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/walletview.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/walletview.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/walletview.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -35,27 +35,27 @@ class WalletView : public QStackedWidget\n     Q_OBJECT\n \n public:\n-    explicit WalletView(const PlatformStyle *platformStyle, QWidget *parent);\n+    explicit WalletView(WalletModel* wallet_model, const PlatformStyle* platformStyle, QWidget* parent);\n     ~WalletView();\n \n     /** Set the client model.\n         The client model represents the part of the core that communicates with the P2P network, and is wallet-agnostic.\n     */\n     void setClientModel(ClientModel *clientModel);\n-    WalletModel *getWalletModel() { return walletModel; }\n-    /** Set the wallet model.\n-        The wallet model represents a bitcoin wallet, and offers access to the list of transactions, address book and sending\n-        functionality.\n-    */\n-    void setWalletModel(WalletModel *walletModel);\n+    WalletModel* getWalletModel() const noexcept { return walletModel; }\n \n     bool handlePaymentRequest(const SendCoinsRecipient& recipient);\n \n     void showOutOfSyncWarning(bool fShow);\n \n private:\n     ClientModel *clientModel;\n-    WalletModel *walletModel;\n+\n+    //!\n+    //! The wallet model represents a bitcoin wallet, and offers access to\n+    //! the list of transactions, address book and sending functionality.\n+    //!\n+    WalletModel* const walletModel;\n \n     OverviewPage *overviewPage;\n     QWidget *transactionsPage;\n@@ -103,9 +103,6 @@ public Q_SLOTS:\n     /** Show used receiving addresses */\n     void usedReceivingAddresses();\n \n-    /** Re-emit encryption status signal */\n-    void updateEncryptionStatus();\n-\n     /** Show progress dialog e.g. for rescan */\n     void showProgress(const QString &title, int nProgress);\n \n@@ -117,8 +114,6 @@ public Q_SLOTS:\n     void message(const QString &title, const QString &message, unsigned int style);\n     /** Encryption status of wallet changed */\n     void encryptionStatusChanged();\n-    /** HD-Enabled status of wallet changed (only possible during startup) */\n-    void hdEnabledStatusChanged();\n     /** Notify that a new transaction appeared */\n     void incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label, const QString& walletName);\n     /** Notify that the out of sync warning icon has been pressed */"
      },
      {
        "sha": "bf399edcf3ec9541c087be69783e8892a085dcfe",
        "filename": "src/qt/winshutdownmonitor.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/winshutdownmonitor.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/qt/winshutdownmonitor.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/winshutdownmonitor.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -17,7 +17,7 @@ class WinShutdownMonitor : public QAbstractNativeEventFilter\n {\n public:\n     /** Implements QAbstractNativeEventFilter interface for processing Windows messages */\n-    bool nativeEventFilter(const QByteArray &eventType, void *pMessage, long *pnResult);\n+    bool nativeEventFilter(const QByteArray &eventType, void *pMessage, long *pnResult) override;\n \n     /** Register the reason for blocking shutdown on Windows to allow clean client exit */\n     static void registerShutdownBlockReason(const QString& strReason, const HWND& mainWinId);"
      },
      {
        "sha": "27cbb3a7020736e5b10c95740ef5cd523b2c6850",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -1089,7 +1089,8 @@ static RPCHelpMan estimatesmartfee()\n             \"have been observed to make an estimate for any number of blocks.\"},\n                     }},\n                 RPCExamples{\n-                    HelpExampleCli(\"estimatesmartfee\", \"6\")\n+                    HelpExampleCli(\"estimatesmartfee\", \"6\") +\n+                    HelpExampleRpc(\"estimatesmartfee\", \"6\")\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {"
      },
      {
        "sha": "14b0e5a984eef33f1e5175487e80924f0435dcd3",
        "filename": "src/rpc/misc.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 5,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/rpc/misc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/rpc/misc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/misc.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -109,7 +109,7 @@ static RPCHelpMan createmultisig()\n             \"\\nCreate a multisig address from 2 public keys\\n\"\n             + HelpExampleCli(\"createmultisig\", \"2 \\\"[\\\\\\\"03789ed0bb717d88f7d321a368d905e7430207ebbd82bd342cf11ae157a7ace5fd\\\\\\\",\\\\\\\"03dbc6764b8884a92e871274b87583e6d5c2a58819473e17e107ef3f6aa5a61626\\\\\\\"]\\\"\") +\n             \"\\nAs a JSON-RPC call\\n\"\n-            + HelpExampleRpc(\"createmultisig\", \"2, \\\"[\\\\\\\"03789ed0bb717d88f7d321a368d905e7430207ebbd82bd342cf11ae157a7ace5fd\\\\\\\",\\\\\\\"03dbc6764b8884a92e871274b87583e6d5c2a58819473e17e107ef3f6aa5a61626\\\\\\\"]\\\"\")\n+            + HelpExampleRpc(\"createmultisig\", \"2, [\\\"03789ed0bb717d88f7d321a368d905e7430207ebbd82bd342cf11ae157a7ace5fd\\\",\\\"03dbc6764b8884a92e871274b87583e6d5c2a58819473e17e107ef3f6aa5a61626\\\"]\")\n                 },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n@@ -158,6 +158,8 @@ static RPCHelpMan createmultisig()\n \n static RPCHelpMan getdescriptorinfo()\n {\n+    const std::string EXAMPLE_DESCRIPTOR = \"wpkh([d34db33f/84h/0h/0h]0279be667ef9dcbbac55a06295Ce870b07029Bfcdb2dce28d959f2815b16f81798)\";\n+\n     return RPCHelpMan{\"getdescriptorinfo\",\n             {\"\\nAnalyses a descriptor.\\n\"},\n             {\n@@ -175,7 +177,8 @@ static RPCHelpMan getdescriptorinfo()\n             },\n             RPCExamples{\n                 \"Analyse a descriptor\\n\" +\n-                HelpExampleCli(\"getdescriptorinfo\", \"\\\"wpkh([d34db33f/84h/0h/0h]0279be667ef9dcbbac55a06295Ce870b07029Bfcdb2dce28d959f2815b16f81798)\\\"\")\n+                HelpExampleCli(\"getdescriptorinfo\", \"\\\"\" + EXAMPLE_DESCRIPTOR + \"\\\"\") +\n+                HelpExampleRpc(\"getdescriptorinfo\", \"\\\"\" + EXAMPLE_DESCRIPTOR + \"\\\"\")\n             },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n@@ -201,6 +204,8 @@ static RPCHelpMan getdescriptorinfo()\n \n static RPCHelpMan deriveaddresses()\n {\n+    const std::string EXAMPLE_DESCRIPTOR = \"wpkh([d34db33f/84h/0h/0h]xpub6DJ2dNUysrn5Vt36jH2KLBT2i1auw1tTSSomg8PhqNiUtx8QX2SvC9nrHu81fT41fvDUnhMjEzQgXnQjKEu3oaqMSzhSrHMxyyoEAmUHQbY/0/*)#cjjspncu\";\n+\n     return RPCHelpMan{\"deriveaddresses\",\n             {\"\\nDerives one or more addresses corresponding to an output descriptor.\\n\"\n             \"Examples of output descriptors are:\\n\"\n@@ -223,7 +228,8 @@ static RPCHelpMan deriveaddresses()\n             },\n             RPCExamples{\n                 \"First three native segwit receive addresses\\n\" +\n-                HelpExampleCli(\"deriveaddresses\", \"\\\"wpkh([d34db33f/84h/0h/0h]xpub6DJ2dNUysrn5Vt36jH2KLBT2i1auw1tTSSomg8PhqNiUtx8QX2SvC9nrHu81fT41fvDUnhMjEzQgXnQjKEu3oaqMSzhSrHMxyyoEAmUHQbY/0/*)#cjjspncu\\\" \\\"[0,2]\\\"\")\n+                HelpExampleCli(\"deriveaddresses\", \"\\\"\" + EXAMPLE_DESCRIPTOR + \"\\\" \\\"[0,2]\\\"\") +\n+                HelpExampleRpc(\"deriveaddresses\", \"\\\"\" + EXAMPLE_DESCRIPTOR + \"\\\", \\\"[0,2]\\\"\")\n             },\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue\n {\n@@ -664,8 +670,9 @@ static RPCHelpMan echoipc()\n         RPCExamples{HelpExampleCli(\"echo\", \"\\\"Hello world\\\"\") +\n                     HelpExampleRpc(\"echo\", \"\\\"Hello world\\\"\")},\n         [&](const RPCHelpMan& self, const JSONRPCRequest& request) -> UniValue {\n+            interfaces::Init& local_init = *EnsureAnyNodeContext(request.context).init;\n             std::unique_ptr<interfaces::Echo> echo;\n-            if (interfaces::Ipc* ipc = Assert(EnsureAnyNodeContext(request.context).init)->ipc()) {\n+            if (interfaces::Ipc* ipc = local_init.ipc()) {\n                 // Spawn a new bitcoin-node process and call makeEcho to get a\n                 // client pointer to a interfaces::Echo instance running in\n                 // that process. This is just for testing. A slightly more\n@@ -683,7 +690,7 @@ static RPCHelpMan echoipc()\n                 // interfaces::Echo object and return it so the `echoipc` RPC\n                 // method will work, and the python test calling `echoipc`\n                 // can expect the same result.\n-                echo = interfaces::MakeEcho();\n+                echo = local_init.makeEcho();\n             }\n             return echo->echo(request.params[0].get_str());\n         },"
      },
      {
        "sha": "0f554ec5e7067a5c53988ca5b0cb64832f76013e",
        "filename": "src/rpc/net.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/rpc/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/rpc/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/net.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -197,7 +197,7 @@ static RPCHelpMan getpeerinfo()\n         CNodeStateStats statestats;\n         bool fStateStats = peerman.GetNodeStateStats(stats.nodeid, statestats);\n         obj.pushKV(\"id\", stats.nodeid);\n-        obj.pushKV(\"addr\", stats.addrName);\n+        obj.pushKV(\"addr\", stats.m_addr_name);\n         if (stats.addrBind.IsValid()) {\n             obj.pushKV(\"addrbind\", stats.addrBind.ToString());\n         }"
      },
      {
        "sha": "621a1b9fd6ab3dbbb07dd81ee16a571402344988",
        "filename": "src/script/descriptor.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/script/descriptor.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/script/descriptor.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/descriptor.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -1242,14 +1242,8 @@ std::unique_ptr<PubkeyProvider> InferXOnlyPubkey(const XOnlyPubKey& xkey, ParseS\n     CPubKey pubkey(full_key);\n     std::unique_ptr<PubkeyProvider> key_provider = std::make_unique<ConstPubkeyProvider>(0, pubkey, true);\n     KeyOriginInfo info;\n-    if (provider.GetKeyOrigin(pubkey.GetID(), info)) {\n+    if (provider.GetKeyOriginByXOnly(xkey, info)) {\n         return std::make_unique<OriginPubkeyProvider>(0, std::move(info), std::move(key_provider));\n-    } else {\n-        full_key[0] = 0x03;\n-        pubkey = CPubKey(full_key);\n-        if (provider.GetKeyOrigin(pubkey.GetID(), info)) {\n-            return std::make_unique<OriginPubkeyProvider>(0, std::move(info), std::move(key_provider));\n-        }\n     }\n     return key_provider;\n }"
      },
      {
        "sha": "eafa9840d74f4581a06418df0e73d70c654a13be",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -1874,9 +1874,9 @@ static bool VerifyTaprootCommitment(const std::vector<unsigned char>& control, c\n     assert(control.size() >= TAPROOT_CONTROL_BASE_SIZE);\n     assert(program.size() >= uint256::size());\n     //! The internal pubkey (x-only, so no Y coordinate parity).\n-    const XOnlyPubKey p{uint256(std::vector<unsigned char>(control.begin() + 1, control.begin() + TAPROOT_CONTROL_BASE_SIZE))};\n+    const XOnlyPubKey p{Span<const unsigned char>{control.data() + 1, control.data() + TAPROOT_CONTROL_BASE_SIZE}};\n     //! The output pubkey (taken from the scriptPubKey).\n-    const XOnlyPubKey q{uint256(program)};\n+    const XOnlyPubKey q{program};\n     // Compute the Merkle root from the leaf and the provided path.\n     const uint256 merkle_root = ComputeTaprootMerkleRoot(control, tapleaf_hash);\n     // Verify that the output pubkey matches the tweaked internal pubkey, after correcting for parity."
      },
      {
        "sha": "ab49e8457782f9a2f65af30e8810cbdb183981a7",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -170,6 +170,13 @@ struct PrecomputedTransactionData\n \n     PrecomputedTransactionData() = default;\n \n+    /** Initialize this PrecomputedTransactionData with transaction data.\n+     *\n+     * @param[in]   tx             The transaction for which data is being precomputed.\n+     * @param[in]   spent_outputs  The CTxOuts being spent, one for each tx.vin, in order.\n+     * @param[in]   force          Whether to precompute data for all optional features,\n+     *                             regardless of what is in the inputs (used at signing\n+     *                             time, when the inputs aren't filled in yet). */\n     template <class T>\n     void Init(const T& tx, std::vector<CTxOut>&& spent_outputs, bool force = false);\n "
      },
      {
        "sha": "8cd1cc3855662eef658e0966931c66add90ad2a1",
        "filename": "src/script/script.h",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/script/script.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/script/script.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -6,6 +6,7 @@\n #ifndef BITCOIN_SCRIPT_SCRIPT_H\n #define BITCOIN_SCRIPT_SCRIPT_H\n \n+#include <attributes.h>\n #include <crypto/common.h>\n #include <prevector.h>\n #include <serialize.h>\n@@ -438,23 +439,23 @@ class CScript : public CScriptBase\n     /** Delete non-existent operator to defend against future introduction */\n     CScript& operator<<(const CScript& b) = delete;\n \n-    CScript& operator<<(int64_t b) { return push_int64(b); }\n+    CScript& operator<<(int64_t b) LIFETIMEBOUND { return push_int64(b); }\n \n-    CScript& operator<<(opcodetype opcode)\n+    CScript& operator<<(opcodetype opcode) LIFETIMEBOUND\n     {\n         if (opcode < 0 || opcode > 0xff)\n             throw std::runtime_error(\"CScript::operator<<(): invalid opcode\");\n         insert(end(), (unsigned char)opcode);\n         return *this;\n     }\n \n-    CScript& operator<<(const CScriptNum& b)\n+    CScript& operator<<(const CScriptNum& b) LIFETIMEBOUND\n     {\n         *this << b.getvch();\n         return *this;\n     }\n \n-    CScript& operator<<(const std::vector<unsigned char>& b)\n+    CScript& operator<<(const std::vector<unsigned char>& b) LIFETIMEBOUND\n     {\n         if (b.size() < OP_PUSHDATA1)\n         {"
      },
      {
        "sha": "b912b00365bc1d992c55b9ecbf8a58cf82d98f1f",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 25,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -60,22 +60,7 @@ bool MutableTransactionSignatureCreator::CreateSchnorrSig(const SigningProvider&\n     assert(sigversion == SigVersion::TAPROOT || sigversion == SigVersion::TAPSCRIPT);\n \n     CKey key;\n-    {\n-        // For now, use the old full pubkey-based key derivation logic. As it indexed by\n-        // Hash160(full pubkey), we need to try both a version prefixed with 0x02, and one\n-        // with 0x03.\n-        unsigned char b[33] = {0x02};\n-        std::copy(pubkey.begin(), pubkey.end(), b + 1);\n-        CPubKey fullpubkey;\n-        fullpubkey.Set(b, b + 33);\n-        CKeyID keyid = fullpubkey.GetID();\n-        if (!provider.GetKey(keyid, key)) {\n-            b[0] = 0x03;\n-            fullpubkey.Set(b, b + 33);\n-            CKeyID keyid = fullpubkey.GetID();\n-            if (!provider.GetKey(keyid, key)) return false;\n-        }\n-    }\n+    if (!provider.GetKeyByXOnly(pubkey, key)) return false;\n \n     // BIP341/BIP342 signing needs lots of precomputed transaction data. While some\n     // (non-SIGHASH_DEFAULT) sighash modes exist that can work with just some subset\n@@ -640,25 +625,22 @@ bool SignTransaction(CMutableTransaction& mtx, const SigningProvider* keystore,\n \n     PrecomputedTransactionData txdata;\n     std::vector<CTxOut> spent_outputs;\n-    spent_outputs.resize(mtx.vin.size());\n-    bool have_all_spent_outputs = true;\n-    for (unsigned int i = 0; i < mtx.vin.size(); i++) {\n+    for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n         CTxIn& txin = mtx.vin[i];\n         auto coin = coins.find(txin.prevout);\n         if (coin == coins.end() || coin->second.IsSpent()) {\n-            have_all_spent_outputs = false;\n+            txdata.Init(txConst, /* spent_outputs */ {}, /* force */ true);\n+            break;\n         } else {\n-            spent_outputs[i] = CTxOut(coin->second.out.nValue, coin->second.out.scriptPubKey);\n+            spent_outputs.emplace_back(coin->second.out.nValue, coin->second.out.scriptPubKey);\n         }\n     }\n-    if (have_all_spent_outputs) {\n+    if (spent_outputs.size() == mtx.vin.size()) {\n         txdata.Init(txConst, std::move(spent_outputs), true);\n-    } else {\n-        txdata.Init(txConst, {}, true);\n     }\n \n     // Sign what we can:\n-    for (unsigned int i = 0; i < mtx.vin.size(); i++) {\n+    for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n         CTxIn& txin = mtx.vin[i];\n         auto coin = coins.find(txin.prevout);\n         if (coin == coins.end() || coin->second.IsSpent()) {"
      },
      {
        "sha": "6d3479c1438995b378c43e82de40c6ceb050fc7a",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -45,8 +45,8 @@ class MutableTransactionSignatureCreator : public BaseSignatureCreator {\n     const PrecomputedTransactionData* m_txdata;\n \n public:\n-    MutableTransactionSignatureCreator(const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn = SIGHASH_ALL);\n-    MutableTransactionSignatureCreator(const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData* txdata, int nHashTypeIn = SIGHASH_ALL);\n+    MutableTransactionSignatureCreator(const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, int nHashTypeIn);\n+    MutableTransactionSignatureCreator(const CMutableTransaction* txToIn, unsigned int nInIn, const CAmount& amountIn, const PrecomputedTransactionData* txdata, int nHashTypeIn);\n     const BaseSignatureChecker& Checker() const override { return checker; }\n     bool CreateSig(const SigningProvider& provider, std::vector<unsigned char>& vchSig, const CKeyID& keyid, const CScript& scriptCode, SigVersion sigversion) const override;\n     bool CreateSchnorrSig(const SigningProvider& provider, std::vector<unsigned char>& sig, const XOnlyPubKey& pubkey, const uint256* leaf_hash, const uint256* merkle_root, SigVersion sigversion) const override;"
      },
      {
        "sha": "fbce61c6a962ebe718388634889bc545e938a3f9",
        "filename": "src/script/signingprovider.h",
        "status": "modified",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/script/signingprovider.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/script/signingprovider.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/signingprovider.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -26,6 +26,30 @@ class SigningProvider\n     virtual bool HaveKey(const CKeyID &address) const { return false; }\n     virtual bool GetKeyOrigin(const CKeyID& keyid, KeyOriginInfo& info) const { return false; }\n     virtual bool GetTaprootSpendData(const XOnlyPubKey& output_key, TaprootSpendData& spenddata) const { return false; }\n+\n+    bool GetKeyByXOnly(const XOnlyPubKey& pubkey, CKey& key) const\n+    {\n+        for (const auto& id : pubkey.GetKeyIDs()) {\n+            if (GetKey(id, key)) return true;\n+        }\n+        return false;\n+    }\n+\n+    bool GetPubKeyByXOnly(const XOnlyPubKey& pubkey, CPubKey& out) const\n+    {\n+        for (const auto& id : pubkey.GetKeyIDs()) {\n+            if (GetPubKey(id, out)) return true;\n+        }\n+        return false;\n+    }\n+\n+    bool GetKeyOriginByXOnly(const XOnlyPubKey& pubkey, KeyOriginInfo& info) const\n+    {\n+        for (const auto& id : pubkey.GetKeyIDs()) {\n+            if (GetKeyOrigin(id, info)) return true;\n+        }\n+        return false;\n+    }\n };\n \n extern const SigningProvider& DUMMY_SIGNING_PROVIDER;"
      },
      {
        "sha": "67a79a157cf35e4163623a550c53b8d51412ca37",
        "filename": "src/script/standard.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/script/standard.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/script/standard.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -504,6 +504,7 @@ WitnessV1Taproot TaprootBuilder::GetOutput() { return WitnessV1Taproot{m_output_\n \n TaprootSpendData TaprootBuilder::GetSpendData() const\n {\n+    assert(IsComplete());\n     TaprootSpendData spd;\n     spd.merkle_root = m_branch.size() == 0 ? uint256() : m_branch[0]->hash;\n     spd.internal_key = m_internal_key;"
      },
      {
        "sha": "78492733dbdb2890d248ab6ace6f4332c395ae6e",
        "filename": "src/script/standard.h",
        "status": "modified",
        "additions": 6,
        "deletions": 3,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/script/standard.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/script/standard.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/standard.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -227,8 +227,11 @@ struct TaprootSpendData\n     /** The Merkle root of the script tree (0 if no scripts). */\n     uint256 merkle_root;\n     /** Map from (script, leaf_version) to (sets of) control blocks.\n-     *  The control blocks are sorted by size, so that the signing logic can\n-     *  easily prefer the cheapest one. */\n+     *  More than one control block for a given script is only possible if it\n+     *  appears in multiple branches of the tree. We keep them all so that\n+     *  inference can reconstruct the full tree. Within each set, the control\n+     *  blocks are sorted by size, so that the signing logic can easily\n+     *  prefer the cheapest one. */\n     std::map<std::pair<CScript, int>, std::set<std::vector<unsigned char>, ShortestVectorFirstComparator>> scripts;\n     /** Merge other TaprootSpendData (for the same scriptPubKey) into this. */\n     void Merge(TaprootSpendData other);\n@@ -252,7 +255,7 @@ class TaprootBuilder\n         /** Merkle hash of this node. */\n         uint256 hash;\n         /** Tracked leaves underneath this node (either from the node itself, or its children).\n-         *  The merkle_branch field for each is the partners to get to *this* node. */\n+         *  The merkle_branch field of each is the partners to get to *this* node. */\n         std::vector<LeafInfo> leaves;\n     };\n     /** Whether the builder is in a valid state so far. */"
      },
      {
        "sha": "aafd1999eeb064cd5d7aac0367543b586b45ffbb",
        "filename": "src/signet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/signet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/signet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/signet.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -141,7 +141,7 @@ bool CheckSignetBlockSolution(const CBlock& block, const Consensus::Params& cons\n \n     PrecomputedTransactionData txdata;\n     txdata.Init(signet_txs->m_to_sign, {signet_txs->m_to_spend.vout[0]});\n-    TransactionSignatureChecker sigcheck(&signet_txs->m_to_sign, /*nIn=*/ 0, /*amount=*/ signet_txs->m_to_spend.vout[0].nValue, txdata, MissingDataBehavior::ASSERT_FAIL);\n+    TransactionSignatureChecker sigcheck(&signet_txs->m_to_sign, /* nInIn= */ 0, /* amountIn= */ signet_txs->m_to_spend.vout[0].nValue, txdata, MissingDataBehavior::ASSERT_FAIL);\n \n     if (!VerifyScript(scriptSig, signet_txs->m_to_spend.vout[0].scriptPubKey, &witness, BLOCK_SCRIPT_VERIFY_FLAGS, sigcheck)) {\n         LogPrint(BCLog::VALIDATION, \"CheckSignetBlockSolution: Errors in block (block solution invalid)\\n\");"
      },
      {
        "sha": "98e6d3d65d888e4f868c56153b47eebd2d280623",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -23,17 +23,6 @@\n #include <utility>\n #include <vector>\n \n-#ifdef DEBUG_LOCKCONTENTION\n-#if !defined(HAVE_THREAD_LOCAL)\n-static_assert(false, \"thread_local is not supported\");\n-#endif\n-void PrintLockContention(const char* pszName, const char* pszFile, int nLine)\n-{\n-    LogPrintf(\"LOCKCONTENTION: %s\\n\", pszName);\n-    LogPrintf(\"Locker: %s:%d\\n\", pszFile, nLine);\n-}\n-#endif /* DEBUG_LOCKCONTENTION */\n-\n #ifdef DEBUG_LOCKORDER\n //\n // Early deadlock detection."
      },
      {
        "sha": "6ba63d5e4ded9b1ca6f059a18433f4f15bb3bf15",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 7,
        "deletions": 13,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -6,6 +6,8 @@\n #ifndef BITCOIN_SYNC_H\n #define BITCOIN_SYNC_H\n \n+#include <logging.h>\n+#include <logging/timer.h>\n #include <threadsafety.h>\n #include <util/macros.h>\n \n@@ -126,10 +128,6 @@ using RecursiveMutex = AnnotatedMixin<std::recursive_mutex>;\n /** Wrapped mutex: supports waiting but not recursive locking */\n typedef AnnotatedMixin<std::mutex> Mutex;\n \n-#ifdef DEBUG_LOCKCONTENTION\n-void PrintLockContention(const char* pszName, const char* pszFile, int nLine);\n-#endif\n-\n /** Wrapper around std::unique_lock style lock for Mutex. */\n template <typename Mutex, typename Base = typename Mutex::UniqueLock>\n class SCOPED_LOCKABLE UniqueLock : public Base\n@@ -138,22 +136,18 @@ class SCOPED_LOCKABLE UniqueLock : public Base\n     void Enter(const char* pszName, const char* pszFile, int nLine)\n     {\n         EnterCritical(pszName, pszFile, nLine, Base::mutex());\n-#ifdef DEBUG_LOCKCONTENTION\n-        if (!Base::try_lock()) {\n-            PrintLockContention(pszName, pszFile, nLine);\n-#endif\n-            Base::lock();\n-#ifdef DEBUG_LOCKCONTENTION\n-        }\n-#endif\n+        if (Base::try_lock()) return;\n+        LOG_TIME_MICROS_WITH_CATEGORY(strprintf(\"lock contention %s, %s:%d\", pszName, pszFile, nLine), BCLog::LOCK);\n+        Base::lock();\n     }\n \n     bool TryEnter(const char* pszName, const char* pszFile, int nLine)\n     {\n         EnterCritical(pszName, pszFile, nLine, Base::mutex(), true);\n         Base::try_lock();\n-        if (!Base::owns_lock())\n+        if (!Base::owns_lock()) {\n             LeaveCritical();\n+        }\n         return Base::owns_lock();\n     }\n "
      },
      {
        "sha": "d03411c3eda99f29c7b110fc54c5a6d211715b57",
        "filename": "src/test/README.md",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/README.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -74,3 +74,29 @@ start debugging, just like you would with any other program:\n ```bash\n gdb src/test/test_bitcoin\n ```\n+\n+#### Segmentation faults\n+\n+If you hit a segmentation fault during a test run, you can diagnose where the fault\n+is happening by running `gdb ./src/test/test_bitcoin` and then using the `bt` command\n+within gdb.\n+\n+Another tool that can be used to resolve segmentation faults is\n+[valgrind](https://valgrind.org/).\n+\n+If for whatever reason you want to produce a core dump file for this fault, you can do\n+that as well. By default, the boost test runner will intercept system errors and not\n+produce a core file. To bypass this, add `--catch_system_errors=no` to the\n+`test_bitcoin` arguments and ensure that your ulimits are set properly (e.g. `ulimit -c\n+unlimited`).\n+\n+Running the tests and hitting a segmentation fault should now produce a file called `core`\n+(on Linux platforms, the file name will likely depend on the contents of\n+`/proc/sys/kernel/core_pattern`).\n+\n+You can then explore the core dump using\n+``` bash\n+gdb src/test/test_bitcoin core\n+\n+(gbd) bt  # produce a backtrace for where a segfault occurred\n+```"
      },
      {
        "sha": "01a492a20b8a8633bb9ed291fdee475b20a7d13a",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -5,13 +5,14 @@\n #include <addrdb.h>\n #include <addrman.h>\n #include <chainparams.h>\n+#include <clientversion.h>\n+#include <hash.h>\n+#include <netbase.h>\n+#include <random.h>\n #include <test/data/asmap.raw.h>\n #include <test/util/setup_common.h>\n #include <util/asmap.h>\n #include <util/string.h>\n-#include <hash.h>\n-#include <netbase.h>\n-#include <random.h>\n \n #include <boost/test/unit_test.hpp>\n \n@@ -26,7 +27,7 @@ class CAddrManSerializationMock : public CAddrMan\n     virtual void Serialize(CDataStream& s) const = 0;\n \n     CAddrManSerializationMock()\n-        : CAddrMan(/* deterministic */ true, /* consistency_check_ratio */ 100)\n+        : CAddrMan(/* asmap */ std::vector<bool>(), /* deterministic */ true, /* consistency_check_ratio */ 100)\n     {}\n };\n \n@@ -82,10 +83,9 @@ class CAddrManTest : public CAddrMan\n public:\n     explicit CAddrManTest(bool makeDeterministic = true,\n                           std::vector<bool> asmap = std::vector<bool>())\n-        : CAddrMan(makeDeterministic, /* consistency_check_ratio */ 100)\n+        : CAddrMan(asmap, makeDeterministic, /* consistency_check_ratio */ 100)\n     {\n         deterministic = makeDeterministic;\n-        m_asmap = asmap;\n     }\n \n     CAddrInfo* Find(const CNetAddr& addr, int* pnId = nullptr)\n@@ -1003,7 +1003,7 @@ BOOST_AUTO_TEST_CASE(addrman_evictionworks)\n     BOOST_CHECK(addrman.SelectTriedCollision().ToString() == \"[::]:0\");\n }\n \n-BOOST_AUTO_TEST_CASE(caddrdb_read)\n+BOOST_AUTO_TEST_CASE(load_addrman)\n {\n     CAddrManUncorrupted addrmanUncorrupted;\n \n@@ -1024,7 +1024,7 @@ BOOST_AUTO_TEST_CASE(caddrdb_read)\n     // Test that the de-serialization does not throw an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrmanUncorrupted);\n     bool exceptionThrown = false;\n-    CAddrMan addrman1(/* deterministic */ false, /* consistency_check_ratio */ 100);\n+    CAddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n \n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n@@ -1038,24 +1038,24 @@ BOOST_AUTO_TEST_CASE(caddrdb_read)\n     BOOST_CHECK(addrman1.size() == 3);\n     BOOST_CHECK(exceptionThrown == false);\n \n-    // Test that CAddrDB::Read creates an addrman with the correct number of addrs.\n+    // Test that ReadFromStream creates an addrman with the correct number of addrs.\n     CDataStream ssPeers2 = AddrmanToStream(addrmanUncorrupted);\n \n-    CAddrMan addrman2(/* deterministic */ false, /* consistency_check_ratio */ 100);\n+    CAddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman2.size() == 0);\n-    BOOST_CHECK(CAddrDB::Read(addrman2, ssPeers2));\n+    ReadFromStream(addrman2, ssPeers2);\n     BOOST_CHECK(addrman2.size() == 3);\n }\n \n \n-BOOST_AUTO_TEST_CASE(caddrdb_read_corrupted)\n+BOOST_AUTO_TEST_CASE(load_addrman_corrupted)\n {\n     CAddrManCorrupted addrmanCorrupted;\n \n     // Test that the de-serialization of corrupted addrman throws an exception.\n     CDataStream ssPeers1 = AddrmanToStream(addrmanCorrupted);\n     bool exceptionThrown = false;\n-    CAddrMan addrman1(/* deterministic */ false, /* consistency_check_ratio */ 100);\n+    CAddrMan addrman1(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman1.size() == 0);\n     try {\n         unsigned char pchMsgTmp[4];\n@@ -1064,16 +1064,16 @@ BOOST_AUTO_TEST_CASE(caddrdb_read_corrupted)\n     } catch (const std::exception&) {\n         exceptionThrown = true;\n     }\n-    // Even through de-serialization failed addrman is not left in a clean state.\n+    // Even though de-serialization failed addrman is not left in a clean state.\n     BOOST_CHECK(addrman1.size() == 1);\n     BOOST_CHECK(exceptionThrown);\n \n-    // Test that CAddrDB::Read fails if peers.dat is corrupt\n+    // Test that ReadFromStream fails if peers.dat is corrupt\n     CDataStream ssPeers2 = AddrmanToStream(addrmanCorrupted);\n \n-    CAddrMan addrman2(/* deterministic */ false, /* consistency_check_ratio */ 100);\n+    CAddrMan addrman2(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 100);\n     BOOST_CHECK(addrman2.size() == 0);\n-    BOOST_CHECK(!CAddrDB::Read(addrman2, ssPeers2));\n+    BOOST_CHECK_THROW(ReadFromStream(addrman2, ssPeers2), std::ios_base::failure);\n }\n \n "
      },
      {
        "sha": "a89868e1ef5f69522f193114f8d5c99853cc8c69",
        "filename": "src/test/bip32_tests.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 1,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/bip32_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/bip32_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/bip32_tests.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -14,6 +14,8 @@\n #include <string>\n #include <vector>\n \n+namespace {\n+\n struct TestDerivation {\n     std::string pub;\n     std::string prv;\n@@ -99,7 +101,26 @@ TestVector test4 =\n      \"xprv9xJocDuwtYCMNAo3Zw76WENQeAS6WGXQ55RCy7tDJ8oALr4FWkuVoHJeHVAcAqiZLE7Je3vZJHxspZdFHfnBEjHqU5hG1Jaj32dVoS6XLT1\",\n      0);\n \n-static void RunTest(const TestVector &test) {\n+const std::vector<std::string> TEST5 = {\n+    \"xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6LBpB85b3D2yc8sfvZU521AAwdZafEz7mnzBBsz4wKY5fTtTQBm\",\n+    \"xprv9s21ZrQH143K24Mfq5zL5MhWK9hUhhGbd45hLXo2Pq2oqzMMo63oStZzFGTQQD3dC4H2D5GBj7vWvSQaaBv5cxi9gafk7NF3pnBju6dwKvH\",\n+    \"xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6Txnt3siSujt9RCVYsx4qHZGc62TG4McvMGcAUjeuwZdduYEvFn\",\n+    \"xprv9s21ZrQH143K24Mfq5zL5MhWK9hUhhGbd45hLXo2Pq2oqzMMo63oStZzFGpWnsj83BHtEy5Zt8CcDr1UiRXuWCmTQLxEK9vbz5gPstX92JQ\",\n+    \"xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6N8ZMMXctdiCjxTNq964yKkwrkBJJwpzZS4HS2fxvyYUA4q2Xe4\",\n+    \"xprv9s21ZrQH143K24Mfq5zL5MhWK9hUhhGbd45hLXo2Pq2oqzMMo63oStZzFAzHGBP2UuGCqWLTAPLcMtD9y5gkZ6Eq3Rjuahrv17fEQ3Qen6J\",\n+    \"xprv9s2SPatNQ9Vc6GTbVMFPFo7jsaZySyzk7L8n2uqKXJen3KUmvQNTuLh3fhZMBoG3G4ZW1N2kZuHEPY53qmbZzCHshoQnNf4GvELZfqTUrcv\",\n+    \"xpub661no6RGEX3uJkY4bNnPcw4URcQTrSibUZ4NqJEw5eBkv7ovTwgiT91XX27VbEXGENhYRCf7hyEbWrR3FewATdCEebj6znwMfQkhRYHRLpJ\",\n+    \"xprv9s21ZrQH4r4TsiLvyLXqM9P7k1K3EYhA1kkD6xuquB5i39AU8KF42acDyL3qsDbU9NmZn6MsGSUYZEsuoePmjzsB3eFKSUEh3Gu1N3cqVUN\",\n+    \"xpub661MyMwAuDcm6CRQ5N4qiHKrJ39Xe1R1NyfouMKTTWcguwVcfrZJaNvhpebzGerh7gucBvzEQWRugZDuDXjNDRmXzSZe4c7mnTK97pTvGS8\",\n+    \"DMwo58pR1QLEFihHiXPVykYB6fJmsTeHvyTp7hRThAtCX8CvYzgPcn8XnmdfHGMQzT7ayAmfo4z3gY5KfbrZWZ6St24UVf2Qgo6oujFktLHdHY4\",\n+    \"DMwo58pR1QLEFihHiXPVykYB6fJmsTeHvyTp7hRThAtCX8CvYzgPcn8XnmdfHPmHJiEDXkTiJTVV9rHEBUem2mwVbbNfvT2MTcAqj3nesx8uBf9\",\n+    \"xprv9s21ZrQH143K24Mfq5zL5MhWK9hUhhGbd45hLXo2Pq2oqzMMo63oStZzF93Y5wvzdUayhgkkFoicQZcP3y52uPPxFnfoLZB21Teqt1VvEHx\",\n+    \"xprv9s21ZrQH143K24Mfq5zL5MhWK9hUhhGbd45hLXo2Pq2oqzMMo63oStZzFAzHGBP2UuGCqWLTAPLcMtD5SDKr24z3aiUvKr9bJpdrcLg1y3G\",\n+    \"xpub661MyMwAqRbcEYS8w7XLSVeEsBXy79zSzH1J8vCdxAZningWLdN3zgtU6Q5JXayek4PRsn35jii4veMimro1xefsM58PgBMrvdYre8QyULY\",\n+    \"xprv9s21ZrQH143K3QTDL4LXw2F7HEK3wJUD2nW2nRk4stbPy6cq3jPPqjiChkVvvNKmPGJxWUtg6LnF5kejMRNNU3TGtRBeJgk33yuGBxrMPHL\"\n+};\n+\n+void RunTest(const TestVector &test) {\n     std::vector<unsigned char> seed = ParseHex(test.strHexMaster);\n     CExtKey key;\n     CExtPubKey pubkey;\n@@ -133,6 +154,8 @@ static void RunTest(const TestVector &test) {\n     }\n }\n \n+}  // namespace\n+\n BOOST_FIXTURE_TEST_SUITE(bip32_tests, BasicTestingSetup)\n \n BOOST_AUTO_TEST_CASE(bip32_test1) {\n@@ -151,4 +174,13 @@ BOOST_AUTO_TEST_CASE(bip32_test4) {\n     RunTest(test4);\n }\n \n+BOOST_AUTO_TEST_CASE(bip32_test5) {\n+    for (const auto& str : TEST5) {\n+        auto dec_extkey = DecodeExtKey(str);\n+        auto dec_extpubkey = DecodeExtPubKey(str);\n+        BOOST_CHECK_MESSAGE(!dec_extkey.key.IsValid(), \"Decoding '\" + str + \"' as xprv should fail\");\n+        BOOST_CHECK_MESSAGE(!dec_extpubkey.pubkey.IsValid(), \"Decoding '\" + str + \"' as xpub should fail\");\n+    }\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "d15c78567331208783ada2ef2bb95dca1b737dae",
        "filename": "src/test/fuzz/addrdb.cpp",
        "status": "removed",
        "additions": 0,
        "deletions": 37,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/243a352d63078b8eacba0c64f991bc359c9ff1f7/src/test/fuzz/addrdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/243a352d63078b8eacba0c64f991bc359c9ff1f7/src/test/fuzz/addrdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/addrdb.cpp?ref=243a352d63078b8eacba0c64f991bc359c9ff1f7",
        "patch": "@@ -1,37 +0,0 @@\n-// Copyright (c) 2020 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <addrdb.h>\n-#include <test/fuzz/FuzzedDataProvider.h>\n-#include <test/fuzz/fuzz.h>\n-#include <test/fuzz/util.h>\n-\n-#include <cassert>\n-#include <cstdint>\n-#include <optional>\n-#include <string>\n-#include <vector>\n-\n-FUZZ_TARGET(addrdb)\n-{\n-    FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n-\n-    // The point of this code is to exercise all CBanEntry constructors.\n-    const CBanEntry ban_entry = [&] {\n-        switch (fuzzed_data_provider.ConsumeIntegralInRange<int>(0, 2)) {\n-        case 0:\n-            return CBanEntry{fuzzed_data_provider.ConsumeIntegral<int64_t>()};\n-            break;\n-        case 1: {\n-            const std::optional<CBanEntry> ban_entry = ConsumeDeserializable<CBanEntry>(fuzzed_data_provider);\n-            if (ban_entry) {\n-                return *ban_entry;\n-            }\n-            break;\n-        }\n-        }\n-        return CBanEntry{};\n-    }();\n-    (void)ban_entry; // currently unused\n-}"
      },
      {
        "sha": "fdbfb3b93b33ad80450a70ae2f1a8415707c23f5",
        "filename": "src/test/fuzz/addrman.cpp",
        "status": "modified",
        "additions": 15,
        "deletions": 13,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/addrman.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -28,17 +28,11 @@ class CAddrManDeterministic : public CAddrMan\n public:\n     FuzzedDataProvider& m_fuzzed_data_provider;\n \n-    explicit CAddrManDeterministic(FuzzedDataProvider& fuzzed_data_provider)\n-        : CAddrMan(/* deterministic */ true, /* consistency_check_ratio */ 0)\n+    explicit CAddrManDeterministic(std::vector<bool> asmap, FuzzedDataProvider& fuzzed_data_provider)\n+        : CAddrMan(std::move(asmap), /* deterministic */ true, /* consistency_check_ratio */ 0)\n         , m_fuzzed_data_provider(fuzzed_data_provider)\n     {\n         WITH_LOCK(cs, insecure_rand = FastRandomContext{ConsumeUInt256(fuzzed_data_provider)});\n-        if (fuzzed_data_provider.ConsumeBool()) {\n-            m_asmap = ConsumeRandomLengthBitVector(fuzzed_data_provider);\n-            if (!SanityCheckASMap(m_asmap)) {\n-                m_asmap.clear();\n-            }\n-        }\n     }\n \n     /**\n@@ -224,11 +218,19 @@ class CAddrManDeterministic : public CAddrMan\n     }\n };\n \n+[[nodiscard]] inline std::vector<bool> ConsumeAsmap(FuzzedDataProvider& fuzzed_data_provider) noexcept\n+{\n+    std::vector<bool> asmap = ConsumeRandomLengthBitVector(fuzzed_data_provider);\n+    if (!SanityCheckASMap(asmap, 128)) asmap.clear();\n+    return asmap;\n+}\n+\n FUZZ_TARGET_INIT(addrman, initialize_addrman)\n {\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n-    auto addr_man_ptr = std::make_unique<CAddrManDeterministic>(fuzzed_data_provider);\n+    std::vector<bool> asmap = ConsumeAsmap(fuzzed_data_provider);\n+    auto addr_man_ptr = std::make_unique<CAddrManDeterministic>(asmap, fuzzed_data_provider);\n     if (fuzzed_data_provider.ConsumeBool()) {\n         const std::vector<uint8_t> serialized_data{ConsumeRandomLengthByteVector(fuzzed_data_provider)};\n         CDataStream ds(serialized_data, SER_DISK, INIT_PROTO_VERSION);\n@@ -237,7 +239,7 @@ FUZZ_TARGET_INIT(addrman, initialize_addrman)\n         try {\n             ds >> *addr_man_ptr;\n         } catch (const std::ios_base::failure&) {\n-            addr_man_ptr = std::make_unique<CAddrManDeterministic>(fuzzed_data_provider);\n+            addr_man_ptr = std::make_unique<CAddrManDeterministic>(asmap, fuzzed_data_provider);\n         }\n     }\n     CAddrManDeterministic& addr_man = *addr_man_ptr;\n@@ -306,9 +308,9 @@ FUZZ_TARGET_INIT(addrman_serdeser, initialize_addrman)\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n \n-    CAddrManDeterministic addr_man1{fuzzed_data_provider};\n-    CAddrManDeterministic addr_man2{fuzzed_data_provider};\n-    addr_man2.m_asmap = addr_man1.m_asmap;\n+    std::vector<bool> asmap = ConsumeAsmap(fuzzed_data_provider);\n+    CAddrManDeterministic addr_man1{asmap, fuzzed_data_provider};\n+    CAddrManDeterministic addr_man2{asmap, fuzzed_data_provider};\n \n     CDataStream data_stream(SER_NETWORK, PROTOCOL_VERSION);\n "
      },
      {
        "sha": "d402f8632ca4d9f9eeb685058a4ef8c50963b868",
        "filename": "src/test/fuzz/asmap.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/asmap.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <netaddress.h>\n #include <test/fuzz/fuzz.h>\n+#include <util/asmap.h>\n \n #include <cstdint>\n #include <vector>\n@@ -42,7 +43,7 @@ FUZZ_TARGET(asmap)\n             asmap.push_back((buffer[1 + i] >> j) & 1);\n         }\n     }\n-    if (!SanityCheckASMap(asmap)) return;\n+    if (!SanityCheckASMap(asmap, 128)) return;\n \n     const uint8_t* addr_data = buffer.data() + 1 + asmap_size;\n     CNetAddr net_addr;"
      },
      {
        "sha": "561cc83c72c538bcafd5b3cd4f29240d70f0fb5a",
        "filename": "src/test/fuzz/banman.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/banman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/banman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/banman.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -41,10 +41,6 @@ static bool operator==(const CBanEntry& lhs, const CBanEntry& rhs)\n \n FUZZ_TARGET_INIT(banman, initialize_banman)\n {\n-    // The complexity is O(N^2), where N is the input size, because each call\n-    // might call DumpBanlist (or other methods that are at least linear\n-    // complexity of the input size).\n-    int limit_max_ops{300};\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n     fs::path banlist_file = gArgs.GetDataDirNet() / \"fuzzed_banlist\";\n@@ -63,7 +59,11 @@ FUZZ_TARGET_INIT(banman, initialize_banman)\n \n     {\n         BanMan ban_man{banlist_file, /* client_interface */ nullptr, /* default_ban_time */ ConsumeBanTimeOffset(fuzzed_data_provider)};\n-        while (--limit_max_ops >= 0 && fuzzed_data_provider.ConsumeBool()) {\n+        // The complexity is O(N^2), where N is the input size, because each call\n+        // might call DumpBanlist (or other methods that are at least linear\n+        // complexity of the input size).\n+        LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+        {\n             CallOneOf(\n                 fuzzed_data_provider,\n                 [&] {"
      },
      {
        "sha": "96f049625d5e32ec7dec9a004dcca46dee1d771a",
        "filename": "src/test/fuzz/blockfilter.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/blockfilter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/blockfilter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/blockfilter.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -36,9 +36,10 @@ FUZZ_TARGET(blockfilter)\n         (void)gcs_filter.GetEncoded();\n         (void)gcs_filter.Match(ConsumeRandomLengthByteVector(fuzzed_data_provider));\n         GCSFilter::ElementSet element_set;\n-        while (fuzzed_data_provider.ConsumeBool()) {\n+        LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 30000)\n+        {\n             element_set.insert(ConsumeRandomLengthByteVector(fuzzed_data_provider));\n-            gcs_filter.MatchAny(element_set);\n         }\n+        gcs_filter.MatchAny(element_set);\n     }\n }"
      },
      {
        "sha": "01741103e42202f91d6a6975f5d49cf9a0874962",
        "filename": "src/test/fuzz/connman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 7,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/connman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/connman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/connman.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -25,7 +25,7 @@ FUZZ_TARGET_INIT(connman, initialize_connman)\n {\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     SetMockTime(ConsumeTime(fuzzed_data_provider));\n-    CAddrMan addrman(/* deterministic */ false, /* consistency_check_ratio */ 0);\n+    CAddrMan addrman(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     CConnman connman{fuzzed_data_provider.ConsumeIntegral<uint64_t>(), fuzzed_data_provider.ConsumeIntegral<uint64_t>(), addrman, fuzzed_data_provider.ConsumeBool()};\n     CNetAddr random_netaddr;\n     CNode random_node = ConsumeNode(fuzzed_data_provider);\n@@ -103,12 +103,6 @@ FUZZ_TARGET_INIT(connman, initialize_connman)\n             [&] {\n                 connman.RemoveAddedNode(random_string);\n             },\n-            [&] {\n-                const std::vector<bool> asmap = ConsumeRandomLengthBitVector(fuzzed_data_provider);\n-                if (SanityCheckASMap(asmap)) {\n-                    connman.SetAsmap(asmap);\n-                }\n-            },\n             [&] {\n                 connman.SetNetworkActive(fuzzed_data_provider.ConsumeBool());\n             },"
      },
      {
        "sha": "84b95117e206697f70b393b25621a2f11c3367ae",
        "filename": "src/test/fuzz/crypto.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/crypto.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/crypto.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/crypto.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -19,10 +19,6 @@\n \n FUZZ_TARGET(crypto)\n {\n-    // Hashing is expensive with sanitizers enabled, so limit the number of\n-    // calls\n-    int limit_max_ops{30};\n-\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     std::vector<uint8_t> data = ConsumeRandomLengthByteVector(fuzzed_data_provider);\n     if (data.empty()) {\n@@ -40,7 +36,8 @@ FUZZ_TARGET(crypto)\n     SHA3_256 sha3;\n     CSipHasher sip_hasher{fuzzed_data_provider.ConsumeIntegral<uint64_t>(), fuzzed_data_provider.ConsumeIntegral<uint64_t>()};\n \n-    while (--limit_max_ops >= 0 && fuzzed_data_provider.ConsumeBool()) {\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 30)\n+    {\n         CallOneOf(\n             fuzzed_data_provider,\n             [&] {"
      },
      {
        "sha": "323090e04103533e3cee2542ec5102dfa3b24a72",
        "filename": "src/test/fuzz/data_stream.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 2,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/data_stream.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/data_stream.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/data_stream.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -2,6 +2,7 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <addrdb.h>\n #include <addrman.h>\n #include <net.h>\n #include <test/fuzz/FuzzedDataProvider.h>\n@@ -21,6 +22,9 @@ FUZZ_TARGET_INIT(data_stream_addr_man, initialize_data_stream_addr_man)\n {\n     FuzzedDataProvider fuzzed_data_provider{buffer.data(), buffer.size()};\n     CDataStream data_stream = ConsumeDataStream(fuzzed_data_provider);\n-    CAddrMan addr_man(/* deterministic */ false, /* consistency_check_ratio */ 0);\n-    CAddrDB::Read(addr_man, data_stream);\n+    CAddrMan addr_man(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n+    try {\n+        ReadFromStream(addr_man, data_stream);\n+    } catch (const std::exception&) {\n+    }\n }"
      },
      {
        "sha": "83ae1680e39d45b42966197528e3b6b8f0d8967a",
        "filename": "src/test/fuzz/deserialize.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 5,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/deserialize.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/deserialize.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/deserialize.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -188,17 +188,13 @@ FUZZ_TARGET_DESERIALIZE(blockmerkleroot, {\n     BlockMerkleRoot(block, &mutated);\n })\n FUZZ_TARGET_DESERIALIZE(addrman_deserialize, {\n-    CAddrMan am(/* deterministic */ false, /* consistency_check_ratio */ 0);\n+    CAddrMan am(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     DeserializeFromFuzzingInput(buffer, am);\n })\n FUZZ_TARGET_DESERIALIZE(blockheader_deserialize, {\n     CBlockHeader bh;\n     DeserializeFromFuzzingInput(buffer, bh);\n })\n-FUZZ_TARGET_DESERIALIZE(banentry_deserialize, {\n-    CBanEntry be;\n-    DeserializeFromFuzzingInput(buffer, be);\n-})\n FUZZ_TARGET_DESERIALIZE(txundo_deserialize, {\n     CTxUndo tu;\n     DeserializeFromFuzzingInput(buffer, tu);"
      },
      {
        "sha": "c91c33da670b7265a7a7853e82bd295c3607e970",
        "filename": "src/test/fuzz/fuzz.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/fuzz.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/fuzz.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/fuzz.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -11,6 +11,10 @@\n #include <functional>\n #include <string_view>\n \n+/**\n+ * Can be used to limit a theoretically unbounded loop. This caps the runtime\n+ * to avoid timeouts or OOMs.\n+ */\n #define LIMITED_WHILE(condition, limit) \\\n     for (unsigned _count{limit}; (condition) && _count; --_count)\n "
      },
      {
        "sha": "5a732aeeff09a7621041560aaa56d94fab6089bc",
        "filename": "src/test/fuzz/integer.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 6,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/integer.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/integer.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/integer.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -23,6 +23,7 @@\n #include <test/fuzz/fuzz.h>\n #include <test/fuzz/util.h>\n #include <uint256.h>\n+#include <univalue.h>\n #include <util/check.h>\n #include <util/moneystr.h>\n #include <util/strencodings.h>\n@@ -83,9 +84,8 @@ FUZZ_TARGET_INIT(integer, initialize_integer)\n     (void)FormatISO8601Date(i64);\n     (void)FormatISO8601DateTime(i64);\n     {\n-        int64_t parsed_money;\n-        if (ParseMoney(FormatMoney(i64), parsed_money)) {\n-            assert(parsed_money == i64);\n+        if (std::optional<CAmount> parsed = ParseMoney(FormatMoney(i64))) {\n+            assert(parsed.value() == i64);\n         }\n     }\n     (void)GetSizeOfCompactSize(u64);\n@@ -126,9 +126,8 @@ FUZZ_TARGET_INIT(integer, initialize_integer)\n     (void)ToLower(ch);\n     (void)ToUpper(ch);\n     {\n-        int64_t parsed_money;\n-        if (ParseMoney(ValueFromAmount(i64).getValStr(), parsed_money)) {\n-            assert(parsed_money == i64);\n+        if (std::optional<CAmount> parsed = ParseMoney(ValueFromAmount(i64).getValStr())) {\n+            assert(parsed.value() == i64);\n         }\n     }\n     if (i32 >= 0 && i32 <= 16) {"
      },
      {
        "sha": "bd1bb79d0ee39755b1dfc5df34985eed3423b89c",
        "filename": "src/test/fuzz/net.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 9,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/net.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -14,6 +14,7 @@\n #include <test/fuzz/util.h>\n #include <test/util/net.h>\n #include <test/util/setup_common.h>\n+#include <util/asmap.h>\n \n #include <cstdint>\n #include <optional>\n@@ -38,15 +39,8 @@ FUZZ_TARGET_INIT(net, initialize_net)\n                 node.CloseSocketDisconnect();\n             },\n             [&] {\n-                node.MaybeSetAddrName(fuzzed_data_provider.ConsumeRandomLengthString(32));\n-            },\n-            [&] {\n-                const std::vector<bool> asmap = ConsumeRandomLengthBitVector(fuzzed_data_provider);\n-                if (!SanityCheckASMap(asmap)) {\n-                    return;\n-                }\n                 CNodeStats stats;\n-                node.copyStats(stats, asmap);\n+                node.CopyStats(stats);\n             },\n             [&] {\n                 const CNode* add_ref_node = node.AddRef();\n@@ -82,7 +76,6 @@ FUZZ_TARGET_INIT(net, initialize_net)\n     }\n \n     (void)node.GetAddrLocal();\n-    (void)node.GetAddrName();\n     (void)node.GetId();\n     (void)node.GetLocalNonce();\n     (void)node.GetLocalServices();"
      },
      {
        "sha": "69e58c3f63c948189d6cae6f358f7ee252fb3760",
        "filename": "src/test/fuzz/parse_numbers.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/parse_numbers.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/parse_numbers.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/parse_numbers.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -12,8 +12,7 @@ FUZZ_TARGET(parse_numbers)\n {\n     const std::string random_string(buffer.begin(), buffer.end());\n \n-    CAmount amount;\n-    (void)ParseMoney(random_string, amount);\n+    (void)ParseMoney(random_string);\n \n     double d;\n     (void)ParseDouble(random_string, &d);"
      },
      {
        "sha": "d4b3ed501f58e0cd04268ac4eef189be8ea83136",
        "filename": "src/test/fuzz/prevector.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/prevector.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/prevector.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/prevector.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -206,14 +206,11 @@ class prevector_tester\n \n FUZZ_TARGET(prevector)\n {\n-    // Pick an arbitrary upper bound to limit the runtime and avoid timeouts on\n-    // inputs.\n-    int limit_max_ops{3000};\n-\n     FuzzedDataProvider prov(buffer.data(), buffer.size());\n     prevector_tester<8, int> test;\n \n-    while (--limit_max_ops >= 0 && prov.remaining_bytes()) {\n+    LIMITED_WHILE(prov.remaining_bytes(), 3000)\n+    {\n         switch (prov.ConsumeIntegralInRange<int>(0, 13 + 3 * (test.size() > 0))) {\n         case 0:\n             test.insert(prov.ConsumeIntegralInRange<size_t>(0, test.size()), prov.ConsumeIntegral<int>());"
      },
      {
        "sha": "b9ed497e68bb2c6484c453aa4d5e53a597d2c7f3",
        "filename": "src/test/fuzz/rolling_bloom_filter.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 5,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/rolling_bloom_filter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/rolling_bloom_filter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/rolling_bloom_filter.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -16,16 +16,13 @@\n \n FUZZ_TARGET(rolling_bloom_filter)\n {\n-    // Pick an arbitrary upper bound to limit the runtime and avoid timeouts on\n-    // inputs.\n-    int limit_max_ops{3000};\n-\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n \n     CRollingBloomFilter rolling_bloom_filter{\n         fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(1, 1000),\n         0.999 / fuzzed_data_provider.ConsumeIntegralInRange<unsigned int>(1, std::numeric_limits<unsigned int>::max())};\n-    while (--limit_max_ops >= 0 && fuzzed_data_provider.remaining_bytes() > 0) {\n+    LIMITED_WHILE(fuzzed_data_provider.remaining_bytes() > 0, 3000)\n+    {\n         CallOneOf(\n             fuzzed_data_provider,\n             [&] {"
      },
      {
        "sha": "6201cc813c74bb8b3b37e8868115f192281d2901",
        "filename": "src/test/fuzz/tx_pool.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 10,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/tx_pool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/tx_pool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/tx_pool.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -112,10 +112,6 @@ void MockTime(FuzzedDataProvider& fuzzed_data_provider, const CChainState& chain\n \n FUZZ_TARGET_INIT(tx_pool_standard, initialize_tx_pool)\n {\n-    // Pick an arbitrary upper bound to limit the runtime and avoid timeouts on\n-    // inputs.\n-    int limit_max_ops{300};\n-\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     const auto& node = g_setup->m_node;\n     auto& chainstate = node.chainman->ActiveChainstate();\n@@ -146,7 +142,8 @@ FUZZ_TARGET_INIT(tx_pool_standard, initialize_tx_pool)\n         return c.out.nValue;\n     };\n \n-    while (--limit_max_ops >= 0 && fuzzed_data_provider.ConsumeBool()) {\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n         {\n             // Total supply is the mempool fee + all outpoints\n             CAmount supply_now{WITH_LOCK(tx_pool.cs, return tx_pool.GetTotalFee())};\n@@ -289,10 +286,6 @@ FUZZ_TARGET_INIT(tx_pool_standard, initialize_tx_pool)\n \n FUZZ_TARGET_INIT(tx_pool, initialize_tx_pool)\n {\n-    // Pick an arbitrary upper bound to limit the runtime and avoid timeouts on\n-    // inputs.\n-    int limit_max_ops{300};\n-\n     FuzzedDataProvider fuzzed_data_provider(buffer.data(), buffer.size());\n     const auto& node = g_setup->m_node;\n     auto& chainstate = node.chainman->ActiveChainstate();\n@@ -313,7 +306,8 @@ FUZZ_TARGET_INIT(tx_pool, initialize_tx_pool)\n     CTxMemPool tx_pool_{/* estimator */ nullptr, /* check_ratio */ 1};\n     MockedTxPool& tx_pool = *static_cast<MockedTxPool*>(&tx_pool_);\n \n-    while (--limit_max_ops >= 0 && fuzzed_data_provider.ConsumeBool()) {\n+    LIMITED_WHILE(fuzzed_data_provider.ConsumeBool(), 300)\n+    {\n         const auto mut_tx = ConsumeTransaction(fuzzed_data_provider, txids);\n \n         if (fuzzed_data_provider.ConsumeBool()) {"
      },
      {
        "sha": "73a7d24971a4df1a1fd5f379f4dd06442cdfd98f",
        "filename": "src/test/fuzz/versionbits.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/versionbits.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/fuzz/versionbits.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/versionbits.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -6,6 +6,7 @@\n #include <chainparams.h>\n #include <consensus/params.h>\n #include <primitives/block.h>\n+#include <util/system.h>\n #include <versionbits.h>\n \n #include <test/fuzz/FuzzedDataProvider.h>"
      },
      {
        "sha": "84ddbc50c668b52673c97e5109c6f6664cac9367",
        "filename": "src/test/logging_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/logging_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/logging_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/logging_tests.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -15,19 +15,19 @@ BOOST_FIXTURE_TEST_SUITE(logging_tests, BasicTestingSetup)\n BOOST_AUTO_TEST_CASE(logging_timer)\n {\n     SetMockTime(1);\n-    auto sec_timer = BCLog::Timer<std::chrono::seconds>(\"tests\", \"end_msg\");\n+    auto micro_timer = BCLog::Timer<std::chrono::microseconds>(\"tests\", \"end_msg\");\n     SetMockTime(2);\n-    BOOST_CHECK_EQUAL(sec_timer.LogMsg(\"test secs\"), \"tests: test secs (1.00s)\");\n+    BOOST_CHECK_EQUAL(micro_timer.LogMsg(\"test micros\"), \"tests: test micros (1000000\u03bcs)\");\n \n     SetMockTime(1);\n     auto ms_timer = BCLog::Timer<std::chrono::milliseconds>(\"tests\", \"end_msg\");\n     SetMockTime(2);\n     BOOST_CHECK_EQUAL(ms_timer.LogMsg(\"test ms\"), \"tests: test ms (1000.00ms)\");\n \n     SetMockTime(1);\n-    auto micro_timer = BCLog::Timer<std::chrono::microseconds>(\"tests\", \"end_msg\");\n+    auto sec_timer = BCLog::Timer<std::chrono::seconds>(\"tests\", \"end_msg\");\n     SetMockTime(2);\n-    BOOST_CHECK_EQUAL(micro_timer.LogMsg(\"test micros\"), \"tests: test micros (1000000.00\u03bcs)\");\n+    BOOST_CHECK_EQUAL(sec_timer.LogMsg(\"test secs\"), \"tests: test secs (1.00s)\");\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "29938d4ede27e9537f96bac46d3e0e68c9982342",
        "filename": "src/test/net_tests.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 19,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/net_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/net_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/net_tests.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -627,37 +627,42 @@ BOOST_AUTO_TEST_CASE(ipv4_peer_with_ipv6_addrMe_test)\n \n BOOST_AUTO_TEST_CASE(LimitedAndReachable_Network)\n {\n-    BOOST_CHECK_EQUAL(IsReachable(NET_IPV4), true);\n-    BOOST_CHECK_EQUAL(IsReachable(NET_IPV6), true);\n-    BOOST_CHECK_EQUAL(IsReachable(NET_ONION), true);\n+    BOOST_CHECK(IsReachable(NET_IPV4));\n+    BOOST_CHECK(IsReachable(NET_IPV6));\n+    BOOST_CHECK(IsReachable(NET_ONION));\n+    BOOST_CHECK(IsReachable(NET_I2P));\n \n     SetReachable(NET_IPV4, false);\n     SetReachable(NET_IPV6, false);\n     SetReachable(NET_ONION, false);\n+    SetReachable(NET_I2P, false);\n \n-    BOOST_CHECK_EQUAL(IsReachable(NET_IPV4), false);\n-    BOOST_CHECK_EQUAL(IsReachable(NET_IPV6), false);\n-    BOOST_CHECK_EQUAL(IsReachable(NET_ONION), false);\n+    BOOST_CHECK(!IsReachable(NET_IPV4));\n+    BOOST_CHECK(!IsReachable(NET_IPV6));\n+    BOOST_CHECK(!IsReachable(NET_ONION));\n+    BOOST_CHECK(!IsReachable(NET_I2P));\n \n     SetReachable(NET_IPV4, true);\n     SetReachable(NET_IPV6, true);\n     SetReachable(NET_ONION, true);\n+    SetReachable(NET_I2P, true);\n \n-    BOOST_CHECK_EQUAL(IsReachable(NET_IPV4), true);\n-    BOOST_CHECK_EQUAL(IsReachable(NET_IPV6), true);\n-    BOOST_CHECK_EQUAL(IsReachable(NET_ONION), true);\n+    BOOST_CHECK(IsReachable(NET_IPV4));\n+    BOOST_CHECK(IsReachable(NET_IPV6));\n+    BOOST_CHECK(IsReachable(NET_ONION));\n+    BOOST_CHECK(IsReachable(NET_I2P));\n }\n \n BOOST_AUTO_TEST_CASE(LimitedAndReachable_NetworkCaseUnroutableAndInternal)\n {\n-    BOOST_CHECK_EQUAL(IsReachable(NET_UNROUTABLE), true);\n-    BOOST_CHECK_EQUAL(IsReachable(NET_INTERNAL), true);\n+    BOOST_CHECK(IsReachable(NET_UNROUTABLE));\n+    BOOST_CHECK(IsReachable(NET_INTERNAL));\n \n     SetReachable(NET_UNROUTABLE, false);\n     SetReachable(NET_INTERNAL, false);\n \n-    BOOST_CHECK_EQUAL(IsReachable(NET_UNROUTABLE), true); // Ignored for both networks\n-    BOOST_CHECK_EQUAL(IsReachable(NET_INTERNAL), true);\n+    BOOST_CHECK(IsReachable(NET_UNROUTABLE)); // Ignored for both networks\n+    BOOST_CHECK(IsReachable(NET_INTERNAL));\n }\n \n CNetAddr UtilBuildAddress(unsigned char p1, unsigned char p2, unsigned char p3, unsigned char p4)\n@@ -676,10 +681,10 @@ BOOST_AUTO_TEST_CASE(LimitedAndReachable_CNetAddr)\n     CNetAddr addr = UtilBuildAddress(0x001, 0x001, 0x001, 0x001); // 1.1.1.1\n \n     SetReachable(NET_IPV4, true);\n-    BOOST_CHECK_EQUAL(IsReachable(addr), true);\n+    BOOST_CHECK(IsReachable(addr));\n \n     SetReachable(NET_IPV4, false);\n-    BOOST_CHECK_EQUAL(IsReachable(addr), false);\n+    BOOST_CHECK(!IsReachable(addr));\n \n     SetReachable(NET_IPV4, true); // have to reset this, because this is stateful.\n }\n@@ -691,12 +696,12 @@ BOOST_AUTO_TEST_CASE(LocalAddress_BasicLifecycle)\n \n     SetReachable(NET_IPV4, true);\n \n-    BOOST_CHECK_EQUAL(IsLocal(addr), false);\n-    BOOST_CHECK_EQUAL(AddLocal(addr, 1000), true);\n-    BOOST_CHECK_EQUAL(IsLocal(addr), true);\n+    BOOST_CHECK(!IsLocal(addr));\n+    BOOST_CHECK(AddLocal(addr, 1000));\n+    BOOST_CHECK(IsLocal(addr));\n \n     RemoveLocal(addr);\n-    BOOST_CHECK_EQUAL(IsLocal(addr), false);\n+    BOOST_CHECK(!IsLocal(addr));\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "2c39cbffb9a3f0962275559d79c0f1d666d2f4e2",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -1160,7 +1160,7 @@ SignatureData CombineSignatures(const CTxOut& txout, const CMutableTransaction&\n     SignatureData data;\n     data.MergeSignatureData(scriptSig1);\n     data.MergeSignatureData(scriptSig2);\n-    ProduceSignature(DUMMY_SIGNING_PROVIDER, MutableTransactionSignatureCreator(&tx, 0, txout.nValue), txout.scriptPubKey, data);\n+    ProduceSignature(DUMMY_SIGNING_PROVIDER, MutableTransactionSignatureCreator(&tx, 0, txout.nValue, SIGHASH_DEFAULT), txout.scriptPubKey, data);\n     return data;\n }\n "
      },
      {
        "sha": "24029ea02eb0c021d4deb587df3fdbee54a96dd7",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 68,
        "deletions": 63,
        "changes": 131,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -561,7 +561,7 @@ SignatureData CombineSignatures(const CMutableTransaction& input1, const CMutabl\n     SignatureData sigdata;\n     sigdata = DataFromTransaction(input1, 0, tx->vout[0]);\n     sigdata.MergeSignatureData(DataFromTransaction(input2, 0, tx->vout[0]));\n-    ProduceSignature(DUMMY_SIGNING_PROVIDER, MutableTransactionSignatureCreator(&input1, 0, tx->vout[0].nValue), tx->vout[0].scriptPubKey, sigdata);\n+    ProduceSignature(DUMMY_SIGNING_PROVIDER, MutableTransactionSignatureCreator(&input1, 0, tx->vout[0].nValue, SIGHASH_ALL), tx->vout[0].scriptPubKey, sigdata);\n     return sigdata;\n }\n \n@@ -765,130 +765,116 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)\n     key.MakeNewKey(true);\n     t.vout[0].scriptPubKey = GetScriptForDestination(PKHash(key.GetPubKey()));\n \n-    std::string reason;\n-    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+    constexpr auto CheckIsStandard = [](const auto& t) {\n+        std::string reason;\n+        BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+        BOOST_CHECK(reason.empty());\n+    };\n+    constexpr auto CheckIsNotStandard = [](const auto& t, const std::string& reason_in) {\n+        std::string reason;\n+        BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n+        BOOST_CHECK_EQUAL(reason_in, reason);\n+    };\n+\n+    CheckIsStandard(t);\n \n     // Check dust with default relay fee:\n-    CAmount nDustThreshold = 182 * dustRelayFee.GetFeePerK()/1000;\n+    CAmount nDustThreshold = 182 * dustRelayFee.GetFeePerK() / 1000;\n     BOOST_CHECK_EQUAL(nDustThreshold, 546);\n     // dust:\n     t.vout[0].nValue = nDustThreshold - 1;\n-    reason.clear();\n-    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n-    BOOST_CHECK_EQUAL(reason, \"dust\");\n+    CheckIsNotStandard(t, \"dust\");\n     // not dust:\n     t.vout[0].nValue = nDustThreshold;\n-    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+    CheckIsStandard(t);\n \n     // Disallowed nVersion\n     t.nVersion = -1;\n-    reason.clear();\n-    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n-    BOOST_CHECK_EQUAL(reason, \"version\");\n+    CheckIsNotStandard(t, \"version\");\n \n     t.nVersion = 0;\n-    reason.clear();\n-    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n-    BOOST_CHECK_EQUAL(reason, \"version\");\n+    CheckIsNotStandard(t, \"version\");\n \n     t.nVersion = 3;\n-    reason.clear();\n-    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n-    BOOST_CHECK_EQUAL(reason, \"version\");\n+    CheckIsNotStandard(t, \"version\");\n \n     // Allowed nVersion\n     t.nVersion = 1;\n-    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+    CheckIsStandard(t);\n \n     t.nVersion = 2;\n-    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+    CheckIsStandard(t);\n \n     // Check dust with odd relay fee to verify rounding:\n     // nDustThreshold = 182 * 3702 / 1000\n     dustRelayFee = CFeeRate(3702);\n     // dust:\n     t.vout[0].nValue = 673 - 1;\n-    reason.clear();\n-    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n-    BOOST_CHECK_EQUAL(reason, \"dust\");\n+    CheckIsNotStandard(t, \"dust\");\n     // not dust:\n     t.vout[0].nValue = 673;\n-    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+    CheckIsStandard(t);\n     dustRelayFee = CFeeRate(DUST_RELAY_TX_FEE);\n \n     t.vout[0].scriptPubKey = CScript() << OP_1;\n-    reason.clear();\n-    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n-    BOOST_CHECK_EQUAL(reason, \"scriptpubkey\");\n+    CheckIsNotStandard(t, \"scriptpubkey\");\n \n     // MAX_OP_RETURN_RELAY-byte TxoutType::NULL_DATA (standard)\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3804678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n     BOOST_CHECK_EQUAL(MAX_OP_RETURN_RELAY, t.vout[0].scriptPubKey.size());\n-    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+    CheckIsStandard(t);\n \n     // MAX_OP_RETURN_RELAY+1-byte TxoutType::NULL_DATA (non-standard)\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3804678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3800\");\n     BOOST_CHECK_EQUAL(MAX_OP_RETURN_RELAY + 1, t.vout[0].scriptPubKey.size());\n-    reason.clear();\n-    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n-    BOOST_CHECK_EQUAL(reason, \"scriptpubkey\");\n+    CheckIsNotStandard(t, \"scriptpubkey\");\n \n     // Data payload can be encoded in any way...\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"\");\n-    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+    CheckIsStandard(t);\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"00\") << ParseHex(\"01\");\n-    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+    CheckIsStandard(t);\n     // OP_RESERVED *is* considered to be a PUSHDATA type opcode by IsPushOnly()!\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << OP_RESERVED << -1 << 0 << ParseHex(\"01\") << 2 << 3 << 4 << 5 << 6 << 7 << 8 << 9 << 10 << 11 << 12 << 13 << 14 << 15 << 16;\n-    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+    CheckIsStandard(t);\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << 0 << ParseHex(\"01\") << 2 << ParseHex(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n-    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+    CheckIsStandard(t);\n \n     // ...so long as it only contains PUSHDATA's\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << OP_RETURN;\n-    reason.clear();\n-    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n-    BOOST_CHECK_EQUAL(reason, \"scriptpubkey\");\n+    CheckIsNotStandard(t, \"scriptpubkey\");\n \n     // TxoutType::NULL_DATA w/o PUSHDATA\n     t.vout.resize(1);\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN;\n-    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+    CheckIsStandard(t);\n \n     // Only one TxoutType::NULL_DATA permitted in all cases\n     t.vout.resize(2);\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n     t.vout[0].nValue = 0;\n     t.vout[1].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n     t.vout[1].nValue = 0;\n-    reason.clear();\n-    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n-    BOOST_CHECK_EQUAL(reason, \"multi-op-return\");\n+    CheckIsNotStandard(t, \"multi-op-return\");\n \n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n     t.vout[1].scriptPubKey = CScript() << OP_RETURN;\n-    reason.clear();\n-    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n-    BOOST_CHECK_EQUAL(reason, \"multi-op-return\");\n+    CheckIsNotStandard(t, \"multi-op-return\");\n \n     t.vout[0].scriptPubKey = CScript() << OP_RETURN;\n     t.vout[1].scriptPubKey = CScript() << OP_RETURN;\n-    reason.clear();\n-    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n-    BOOST_CHECK_EQUAL(reason, \"multi-op-return\");\n+    CheckIsNotStandard(t, \"multi-op-return\");\n \n     // Check large scriptSig (non-standard if size is >1650 bytes)\n     t.vout.resize(1);\n     t.vout[0].nValue = MAX_MONEY;\n     t.vout[0].scriptPubKey = GetScriptForDestination(PKHash(key.GetPubKey()));\n     // OP_PUSHDATA2 with len (3 bytes) + data (1647 bytes) = 1650 bytes\n     t.vin[0].scriptSig = CScript() << std::vector<unsigned char>(1647, 0); // 1650\n-    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+    CheckIsStandard(t);\n \n     t.vin[0].scriptSig = CScript() << std::vector<unsigned char>(1648, 0); // 1651\n-    reason.clear();\n-    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n-    BOOST_CHECK_EQUAL(reason, \"scriptsig-size\");\n+    CheckIsNotStandard(t, \"scriptsig-size\");\n \n     // Check scriptSig format (non-standard if there are any other ops than just PUSHs)\n     t.vin[0].scriptSig = CScript()\n@@ -897,7 +883,7 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)\n         << std::vector<unsigned char>(235, 0)     // OP_PUSHDATA1 x [...x bytes...]\n         << std::vector<unsigned char>(1234, 0)    // OP_PUSHDATA2 x [...x bytes...]\n         << OP_9;\n-    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+    CheckIsStandard(t);\n \n     const std::vector<unsigned char> non_push_ops = { // arbitrary set of non-push operations\n         OP_NOP, OP_VERIFY, OP_IF, OP_ROT, OP_3DUP, OP_SIZE, OP_EQUAL, OP_ADD, OP_SUB,\n@@ -917,11 +903,10 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)\n         // replace current push-op with each non-push-op\n         for (auto op : non_push_ops) {\n             t.vin[0].scriptSig[index] = op;\n-            BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n-            BOOST_CHECK_EQUAL(reason, \"scriptsig-not-pushonly\");\n+            CheckIsNotStandard(t, \"scriptsig-not-pushonly\");\n         }\n         t.vin[0].scriptSig[index] = orig_op; // restore op\n-        BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+        CheckIsStandard(t);\n     }\n \n     // Check tx-size (non-standard if transaction weight is > MAX_STANDARD_TX_WEIGHT)\n@@ -934,27 +919,47 @@ BOOST_AUTO_TEST_CASE(test_IsStandard)\n     //                      ===============================\n     //                                total: 400000 vbytes\n     BOOST_CHECK_EQUAL(GetTransactionWeight(CTransaction(t)), 400000);\n-    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+    CheckIsStandard(t);\n \n     // increase output size by one byte, so we end up with 400004 vbytes\n     t.vout[0].scriptPubKey = CScript() << OP_RETURN << std::vector<unsigned char>(20, 0); // output size: 31 bytes\n     BOOST_CHECK_EQUAL(GetTransactionWeight(CTransaction(t)), 400004);\n-    reason.clear();\n-    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n-    BOOST_CHECK_EQUAL(reason, \"tx-size\");\n+    CheckIsNotStandard(t, \"tx-size\");\n \n     // Check bare multisig (standard if policy flag fIsBareMultisigStd is set)\n     fIsBareMultisigStd = true;\n     t.vout[0].scriptPubKey = GetScriptForMultisig(1, {key.GetPubKey()}); // simple 1-of-1\n     t.vin.resize(1);\n     t.vin[0].scriptSig = CScript() << std::vector<unsigned char>(65, 0);\n-    BOOST_CHECK(IsStandardTx(CTransaction(t), reason));\n+    CheckIsStandard(t);\n \n     fIsBareMultisigStd = false;\n-    reason.clear();\n-    BOOST_CHECK(!IsStandardTx(CTransaction(t), reason));\n-    BOOST_CHECK_EQUAL(reason, \"bare-multisig\");\n+    CheckIsNotStandard(t, \"bare-multisig\");\n     fIsBareMultisigStd = DEFAULT_PERMIT_BAREMULTISIG;\n+\n+    // Check P2WPKH outputs dust threshold\n+    t.vout[0].scriptPubKey = CScript() << OP_0 << ParseHex(\"ffffffffffffffffffffffffffffffffffffffff\");\n+    t.vout[0].nValue = 294;\n+    CheckIsStandard(t);\n+    t.vout[0].nValue = 293;\n+    CheckIsNotStandard(t, \"dust\");\n+\n+    // Check P2WSH outputs dust threshold\n+    t.vout[0].scriptPubKey = CScript() << OP_0 << ParseHex(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n+    t.vout[0].nValue = 330;\n+    CheckIsStandard(t);\n+    t.vout[0].nValue = 329;\n+    CheckIsNotStandard(t, \"dust\");\n+\n+    // Check future Witness Program versions dust threshold\n+    for (int op = OP_2; op <= OP_16; op += 1) {\n+        t.vout[0].scriptPubKey = CScript() << (opcodetype)op << ParseHex(\"ffff\");\n+        t.vout[0].nValue = 240;\n+        CheckIsStandard(t);\n+\n+        t.vout[0].nValue = 239;\n+        CheckIsNotStandard(t, \"dust\");\n+    }\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "cabc4b3b49bc10518c43e4f6152e5ada47568c97",
        "filename": "src/test/util/setup_common.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/util/setup_common.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/util/setup_common.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util/setup_common.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -114,7 +114,6 @@ BasicTestingSetup::BasicTestingSetup(const std::string& chainName, const std::ve\n     InitSignatureCache();\n     InitScriptExecutionCache();\n     m_node.chain = interfaces::MakeChain(m_node);\n-    g_wallet_init_interface.Construct(m_node);\n     fCheckBlockIndex = true;\n     static bool noui_connected = false;\n     if (!noui_connected) {\n@@ -193,7 +192,7 @@ TestingSetup::TestingSetup(const std::string& chainName, const std::vector<const\n         throw std::runtime_error(strprintf(\"ActivateBestChain failed. (%s)\", state.ToString()));\n     }\n \n-    m_node.addrman = std::make_unique<CAddrMan>(/* deterministic */ false, /* consistency_check_ratio */ 0);\n+    m_node.addrman = std::make_unique<CAddrMan>(/* asmap */ std::vector<bool>(), /* deterministic */ false, /* consistency_check_ratio */ 0);\n     m_node.banman = std::make_unique<BanMan>(m_args.GetDataDirBase() / \"banlist\", nullptr, DEFAULT_MISBEHAVING_BANTIME);\n     m_node.connman = std::make_unique<CConnman>(0x1337, 0x1337, *m_node.addrman); // Deterministic randomness for tests.\n     m_node.peerman = PeerManager::make(chainparams, *m_node.connman, *m_node.addrman,"
      },
      {
        "sha": "a62abf9b9c184273ea29fe118095be4f4f559f73",
        "filename": "src/test/util_tests.cpp",
        "status": "modified",
        "additions": 59,
        "deletions": 70,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/test/util_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/test/util_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/util_tests.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -173,6 +173,22 @@ BOOST_AUTO_TEST_CASE(util_Join)\n     BOOST_CHECK_EQUAL(Join<std::string>({\"foo\", \"bar\"}, \", \", op_upper), \"FOO, BAR\");\n }\n \n+BOOST_AUTO_TEST_CASE(util_TrimString)\n+{\n+    BOOST_CHECK_EQUAL(TrimString(\" foo bar \"), \"foo bar\");\n+    BOOST_CHECK_EQUAL(TrimString(\"\\t \\n  \\n \\f\\n\\r\\t\\v\\tfoo \\n \\f\\n\\r\\t\\v\\tbar\\t  \\n \\f\\n\\r\\t\\v\\t\\n \"), \"foo \\n \\f\\n\\r\\t\\v\\tbar\");\n+    BOOST_CHECK_EQUAL(TrimString(\"\\t \\n foo \\n\\tbar\\t \\n \"), \"foo \\n\\tbar\");\n+    BOOST_CHECK_EQUAL(TrimString(\"\\t \\n foo \\n\\tbar\\t \\n \", \"fobar\"), \"\\t \\n foo \\n\\tbar\\t \\n \");\n+    BOOST_CHECK_EQUAL(TrimString(\"foo bar\"), \"foo bar\");\n+    BOOST_CHECK_EQUAL(TrimString(\"foo bar\", \"fobar\"), \" \");\n+    BOOST_CHECK_EQUAL(TrimString(std::string(\"\\0 foo \\0 \", 8)), std::string(\"\\0 foo \\0\", 7));\n+    BOOST_CHECK_EQUAL(TrimString(std::string(\" foo \", 5)), std::string(\"foo\", 3));\n+    BOOST_CHECK_EQUAL(TrimString(std::string(\"\\t\\t\\0\\0\\n\\n\", 6)), std::string(\"\\0\\0\", 2));\n+    BOOST_CHECK_EQUAL(TrimString(std::string(\"\\x05\\x04\\x03\\x02\\x01\\x00\", 6)), std::string(\"\\x05\\x04\\x03\\x02\\x01\\x00\", 6));\n+    BOOST_CHECK_EQUAL(TrimString(std::string(\"\\x05\\x04\\x03\\x02\\x01\\x00\", 6), std::string(\"\\x05\\x04\\x03\\x02\\x01\", 5)), std::string(\"\\0\", 1));\n+    BOOST_CHECK_EQUAL(TrimString(std::string(\"\\x05\\x04\\x03\\x02\\x01\\x00\", 6), std::string(\"\\x05\\x04\\x03\\x02\\x01\\x00\", 6)), \"\");\n+}\n+\n BOOST_AUTO_TEST_CASE(util_FormatParseISO8601DateTime)\n {\n     BOOST_CHECK_EQUAL(FormatISO8601DateTime(1317425777), \"2011-09-30T23:36:17Z\");\n@@ -1222,86 +1238,59 @@ BOOST_AUTO_TEST_CASE(util_FormatMoney)\n \n BOOST_AUTO_TEST_CASE(util_ParseMoney)\n {\n-    CAmount ret = 0;\n-    BOOST_CHECK(ParseMoney(\"0.0\", ret));\n-    BOOST_CHECK_EQUAL(ret, 0);\n-\n-    BOOST_CHECK(ParseMoney(\"12345.6789\", ret));\n-    BOOST_CHECK_EQUAL(ret, (COIN/10000)*123456789);\n-\n-    BOOST_CHECK(ParseMoney(\"100000000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*100000000);\n-    BOOST_CHECK(ParseMoney(\"10000000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*10000000);\n-    BOOST_CHECK(ParseMoney(\"1000000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*1000000);\n-    BOOST_CHECK(ParseMoney(\"100000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*100000);\n-    BOOST_CHECK(ParseMoney(\"10000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*10000);\n-    BOOST_CHECK(ParseMoney(\"1000.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*1000);\n-    BOOST_CHECK(ParseMoney(\"100.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*100);\n-    BOOST_CHECK(ParseMoney(\"10.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN*10);\n-    BOOST_CHECK(ParseMoney(\"1.00\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN);\n-    BOOST_CHECK(ParseMoney(\"1\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN);\n-    BOOST_CHECK(ParseMoney(\"   1\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN);\n-    BOOST_CHECK(ParseMoney(\"1   \", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN);\n-    BOOST_CHECK(ParseMoney(\"  1 \", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN);\n-    BOOST_CHECK(ParseMoney(\"0.1\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/10);\n-    BOOST_CHECK(ParseMoney(\"0.01\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/100);\n-    BOOST_CHECK(ParseMoney(\"0.001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/1000);\n-    BOOST_CHECK(ParseMoney(\"0.0001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/10000);\n-    BOOST_CHECK(ParseMoney(\"0.00001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/100000);\n-    BOOST_CHECK(ParseMoney(\"0.000001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/1000000);\n-    BOOST_CHECK(ParseMoney(\"0.0000001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/10000000);\n-    BOOST_CHECK(ParseMoney(\"0.00000001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/100000000);\n-    BOOST_CHECK(ParseMoney(\" 0.00000001 \", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/100000000);\n-    BOOST_CHECK(ParseMoney(\"0.00000001 \", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/100000000);\n-    BOOST_CHECK(ParseMoney(\" 0.00000001\", ret));\n-    BOOST_CHECK_EQUAL(ret, COIN/100000000);\n-\n-    // Parsing amount that can not be represented in ret should fail\n-    BOOST_CHECK(!ParseMoney(\"0.000000001\", ret));\n+    BOOST_CHECK_EQUAL(ParseMoney(\"0.0\").value(), 0);\n+\n+    BOOST_CHECK_EQUAL(ParseMoney(\"12345.6789\").value(), (COIN/10000)*123456789);\n+\n+    BOOST_CHECK_EQUAL(ParseMoney(\"10000000.00\").value(), COIN*10000000);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"1000000.00\").value(), COIN*1000000);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"100000.00\").value(), COIN*100000);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"10000.00\").value(), COIN*10000);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"1000.00\").value(), COIN*1000);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"100.00\").value(), COIN*100);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"10.00\").value(), COIN*10);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"1.00\").value(), COIN);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"1\").value(), COIN);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"   1\").value(), COIN);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"1   \").value(), COIN);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"  1 \").value(), COIN);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"0.1\").value(), COIN/10);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"0.01\").value(), COIN/100);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"0.001\").value(), COIN/1000);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"0.0001\").value(), COIN/10000);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"0.00001\").value(), COIN/100000);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"0.000001\").value(), COIN/1000000);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"0.0000001\").value(), COIN/10000000);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"0.00000001\").value(), COIN/100000000);\n+    BOOST_CHECK_EQUAL(ParseMoney(\" 0.00000001 \").value(), COIN/100000000);\n+    BOOST_CHECK_EQUAL(ParseMoney(\"0.00000001 \").value(), COIN/100000000);\n+    BOOST_CHECK_EQUAL(ParseMoney(\" 0.00000001\").value(), COIN/100000000);\n+\n+    // Parsing amount that can not be represented should fail\n+    BOOST_CHECK(!ParseMoney(\"100000000.00\"));\n+    BOOST_CHECK(!ParseMoney(\"0.000000001\"));\n \n     // Parsing empty string should fail\n-    BOOST_CHECK(!ParseMoney(\"\", ret));\n-    BOOST_CHECK(!ParseMoney(\" \", ret));\n-    BOOST_CHECK(!ParseMoney(\"  \", ret));\n+    BOOST_CHECK(!ParseMoney(\"\"));\n+    BOOST_CHECK(!ParseMoney(\" \"));\n+    BOOST_CHECK(!ParseMoney(\"  \"));\n \n     // Parsing two numbers should fail\n-    BOOST_CHECK(!ParseMoney(\"1 2\", ret));\n-    BOOST_CHECK(!ParseMoney(\" 1 2 \", ret));\n-    BOOST_CHECK(!ParseMoney(\" 1.2 3 \", ret));\n-    BOOST_CHECK(!ParseMoney(\" 1 2.3 \", ret));\n+    BOOST_CHECK(!ParseMoney(\"1 2\"));\n+    BOOST_CHECK(!ParseMoney(\" 1 2 \"));\n+    BOOST_CHECK(!ParseMoney(\" 1.2 3 \"));\n+    BOOST_CHECK(!ParseMoney(\" 1 2.3 \"));\n \n     // Attempted 63 bit overflow should fail\n-    BOOST_CHECK(!ParseMoney(\"92233720368.54775808\", ret));\n+    BOOST_CHECK(!ParseMoney(\"92233720368.54775808\"));\n \n     // Parsing negative amounts must fail\n-    BOOST_CHECK(!ParseMoney(\"-1\", ret));\n+    BOOST_CHECK(!ParseMoney(\"-1\"));\n \n     // Parsing strings with embedded NUL characters should fail\n-    BOOST_CHECK(!ParseMoney(\"\\0-1\"s, ret));\n-    BOOST_CHECK(!ParseMoney(STRING_WITH_EMBEDDED_NULL_CHAR, ret));\n-    BOOST_CHECK(!ParseMoney(\"1\\0\"s, ret));\n+    BOOST_CHECK(!ParseMoney(\"\\0-1\"s));\n+    BOOST_CHECK(!ParseMoney(STRING_WITH_EMBEDDED_NULL_CHAR));\n+    BOOST_CHECK(!ParseMoney(\"1\\0\"s));\n }\n \n BOOST_AUTO_TEST_CASE(util_IsHex)"
      },
      {
        "sha": "cfa864668a47d14c3b536d06b215ba6417f1f531",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -5,6 +5,7 @@\n \n #include <txdb.h>\n \n+#include <chain.h>\n #include <node/ui_interface.h>\n #include <pow.h>\n #include <random.h>\n@@ -27,6 +28,28 @@ static constexpr uint8_t DB_FLAG{'F'};\n static constexpr uint8_t DB_REINDEX_FLAG{'R'};\n static constexpr uint8_t DB_LAST_BLOCK{'l'};\n \n+// Keys used in previous version that might still be found in the DB:\n+static constexpr uint8_t DB_TXINDEX_BLOCK{'T'};\n+//               uint8_t DB_TXINDEX{'t'}\n+\n+std::optional<bilingual_str> CheckLegacyTxindex(CBlockTreeDB& block_tree_db)\n+{\n+    CBlockLocator ignored{};\n+    if (block_tree_db.Read(DB_TXINDEX_BLOCK, ignored)) {\n+        return _(\"The -txindex upgrade started by a previous version can not be completed. Restart with the previous version or run a full -reindex.\");\n+    }\n+    bool txindex_legacy_flag{false};\n+    block_tree_db.ReadFlag(\"txindex\", txindex_legacy_flag);\n+    if (txindex_legacy_flag) {\n+        // Disable legacy txindex and warn once about occupied disk space\n+        if (!block_tree_db.WriteFlag(\"txindex\", false)) {\n+            return Untranslated(\"Failed to write block index db flag 'txindex'='0'\");\n+        }\n+        return _(\"The block index db contains a legacy 'txindex'. To clear the occupied disk space, run a full -reindex, otherwise ignore this error. This error message will not be displayed again.\");\n+    }\n+    return std::nullopt;\n+}\n+\n namespace {\n \n struct CoinEntry {"
      },
      {
        "sha": "1bdce711264a3df7541c671007b56f67948c9c25",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -8,17 +8,20 @@\n \n #include <coins.h>\n #include <dbwrapper.h>\n-#include <chain.h>\n-#include <primitives/block.h>\n \n #include <memory>\n+#include <optional>\n #include <string>\n #include <utility>\n #include <vector>\n \n+class CBlockFileInfo;\n class CBlockIndex;\n-class CCoinsViewDBCursor;\n class uint256;\n+namespace Consensus {\n+struct Params;\n+};\n+struct bilingual_str;\n \n //! -dbcache default (MiB)\n static const int64_t nDefaultDbCache = 450;\n@@ -86,4 +89,6 @@ class CBlockTreeDB : public CDBWrapper\n     bool LoadBlockIndexGuts(const Consensus::Params& consensusParams, std::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n };\n \n+std::optional<bilingual_str> CheckLegacyTxindex(CBlockTreeDB& block_tree_db);\n+\n #endif // BITCOIN_TXDB_H"
      },
      {
        "sha": "5695c620125c9a27372621176b4cc54aba8d00ca",
        "filename": "src/util/asmap.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 2,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/util/asmap.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/util/asmap.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/asmap.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -2,10 +2,16 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n+#include <util/asmap.h>\n+\n+#include <clientversion.h>\n+#include <crypto/common.h>\n+#include <logging.h>\n+#include <streams.h>\n+\n+#include <cassert>\n #include <map>\n #include <vector>\n-#include <assert.h>\n-#include <crypto/common.h>\n \n namespace {\n \n@@ -183,3 +189,31 @@ bool SanityCheckASMap(const std::vector<bool>& asmap, int bits)\n     }\n     return false; // Reached EOF without RETURN instruction\n }\n+\n+std::vector<bool> DecodeAsmap(fs::path path)\n+{\n+    std::vector<bool> bits;\n+    FILE *filestr = fsbridge::fopen(path, \"rb\");\n+    CAutoFile file(filestr, SER_DISK, CLIENT_VERSION);\n+    if (file.IsNull()) {\n+        LogPrintf(\"Failed to open asmap file from disk\\n\");\n+        return bits;\n+    }\n+    fseek(filestr, 0, SEEK_END);\n+    int length = ftell(filestr);\n+    LogPrintf(\"Opened asmap file %s (%d bytes) from disk\\n\", path, length);\n+    fseek(filestr, 0, SEEK_SET);\n+    uint8_t cur_byte;\n+    for (int i = 0; i < length; ++i) {\n+        file >> cur_byte;\n+        for (int bit = 0; bit < 8; ++bit) {\n+            bits.push_back((cur_byte >> bit) & 1);\n+        }\n+    }\n+    if (!SanityCheckASMap(bits, 128)) {\n+        LogPrintf(\"Sanity check of asmap file %s failed\\n\", path);\n+        return {};\n+    }\n+    return bits;\n+}\n+"
      },
      {
        "sha": "810d70b9a1af1389b70af3bb95042c34d6a44612",
        "filename": "src/util/asmap.h",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/util/asmap.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/util/asmap.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/asmap.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -5,11 +5,16 @@\n #ifndef BITCOIN_UTIL_ASMAP_H\n #define BITCOIN_UTIL_ASMAP_H\n \n-#include <stdint.h>\n+#include <fs.h>\n+\n+#include <cstdint>\n #include <vector>\n \n uint32_t Interpret(const std::vector<bool> &asmap, const std::vector<bool> &ip);\n \n bool SanityCheckASMap(const std::vector<bool>& asmap, int bits);\n \n+/** Read asmap from provided binary file */\n+std::vector<bool> DecodeAsmap(fs::path path);\n+\n #endif // BITCOIN_UTIL_ASMAP_H"
      },
      {
        "sha": "6776e7785b2729c10fd45798f07694f6e526d1f2",
        "filename": "src/util/getuniquepath.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/util/getuniquepath.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/util/getuniquepath.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/getuniquepath.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -1,3 +1,7 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n #include <random.h>\n #include <fs.h>\n #include <util/strencodings.h>"
      },
      {
        "sha": "9b79a1b5f1575c594429637cbd15f1bac3fd7574",
        "filename": "src/util/hasher.h",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/util/hasher.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/util/hasher.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/hasher.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -33,10 +33,6 @@ class SaltedOutpointHasher\n     SaltedOutpointHasher();\n \n     /**\n-     * This *must* return size_t. With Boost 1.46 on 32-bit systems the\n-     * unordered_map will behave unpredictably if the custom hasher returns a\n-     * uint64_t, resulting in failures when syncing the chain (#4634).\n-     *\n      * Having the hash noexcept allows libstdc++'s unordered_map to recalculate\n      * the hash during rehash, so it does not have to cache the value. This\n      * reduces node's memory by sizeof(size_t). The required recalculation has"
      },
      {
        "sha": "d3f40296079569fa02f256184e0f8010231b11a8",
        "filename": "src/util/moneystr.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 11,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/util/moneystr.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/util/moneystr.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/moneystr.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -5,10 +5,13 @@\n \n #include <util/moneystr.h>\n \n+#include <amount.h>\n #include <tinyformat.h>\n #include <util/strencodings.h>\n #include <util/string.h>\n \n+#include <optional>\n+\n std::string FormatMoney(const CAmount n)\n {\n     // Note: not using straight sprintf here because we do NOT want\n@@ -35,14 +38,14 @@ std::string FormatMoney(const CAmount n)\n }\n \n \n-bool ParseMoney(const std::string& money_string, CAmount& nRet)\n+std::optional<CAmount> ParseMoney(const std::string& money_string)\n {\n     if (!ValidAsCString(money_string)) {\n-        return false;\n+        return std::nullopt;\n     }\n     const std::string str = TrimString(money_string);\n     if (str.empty()) {\n-        return false;\n+        return std::nullopt;\n     }\n \n     std::string strWhole;\n@@ -62,21 +65,25 @@ bool ParseMoney(const std::string& money_string, CAmount& nRet)\n             break;\n         }\n         if (IsSpace(*p))\n-            return false;\n+            return std::nullopt;\n         if (!IsDigit(*p))\n-            return false;\n+            return std::nullopt;\n         strWhole.insert(strWhole.end(), *p);\n     }\n     if (*p) {\n-        return false;\n+        return std::nullopt;\n     }\n     if (strWhole.size() > 10) // guard against 63 bit overflow\n-        return false;\n+        return std::nullopt;\n     if (nUnits < 0 || nUnits > COIN)\n-        return false;\n+        return std::nullopt;\n     int64_t nWhole = atoi64(strWhole);\n-    CAmount nValue = nWhole*COIN + nUnits;\n \n-    nRet = nValue;\n-    return true;\n+    CAmount value = nWhole * COIN + nUnits;\n+\n+    if (!MoneyRange(value)) {\n+        return std::nullopt;\n+    }\n+\n+    return value;\n }"
      },
      {
        "sha": "b71dffd0db3798cee7d31bb64980667cf084c1d3",
        "filename": "src/util/moneystr.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/util/moneystr.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/util/moneystr.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/moneystr.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -12,13 +12,14 @@\n #include <amount.h>\n #include <attributes.h>\n \n+#include <optional>\n #include <string>\n \n /* Do not use these functions to represent or parse monetary amounts to or from\n  * JSON but use AmountFromValue and ValueFromAmount for that.\n  */\n std::string FormatMoney(const CAmount n);\n /** Parse an amount denoted in full coins. E.g. \"0.0034\" supplied on the command line. **/\n-[[nodiscard]] bool ParseMoney(const std::string& str, CAmount& nRet);\n+std::optional<CAmount> ParseMoney(const std::string& str);\n \n #endif // BITCOIN_UTIL_MONEYSTR_H"
      },
      {
        "sha": "6d44a2cb83c8e4e218c43ad071c4febb80b8268c",
        "filename": "src/util/rbf.h",
        "status": "modified",
        "additions": 7,
        "deletions": 2,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/util/rbf.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/util/rbf.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/rbf.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -11,8 +11,13 @@ class CTransaction;\n \n static const uint32_t MAX_BIP125_RBF_SEQUENCE = 0xfffffffd;\n \n-// Check whether the sequence numbers on this transaction are signaling\n-// opt-in to replace-by-fee, according to BIP 125\n+/** Check whether the sequence numbers on this transaction are signaling opt-in to replace-by-fee,\n+ * according to BIP 125.  Allow opt-out of transaction replacement by setting nSequence >\n+ * MAX_BIP125_RBF_SEQUENCE (SEQUENCE_FINAL-2) on all inputs.\n+*\n+* SEQUENCE_FINAL-1 is picked to still allow use of nLockTime by non-replaceable transactions. All\n+* inputs rather than just one is for the sake of multi-party protocols, where we don't want a single\n+* party to be able to disable replacement. */\n bool SignalsOptInRBF(const CTransaction &tx);\n \n #endif // BITCOIN_UTIL_RBF_H"
      },
      {
        "sha": "846b34089dd873e4f50ced6d0c7c9c2331419e57",
        "filename": "src/util/settings.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 1,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/util/settings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/util/settings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/settings.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -60,9 +60,15 @@ bool ReadSettings(const fs::path& path, std::map<std::string, SettingsValue>& va\n     values.clear();\n     errors.clear();\n \n+    // Ok for file to not exist\n+    if (!fs::exists(path)) return true;\n+\n     fsbridge::ifstream file;\n     file.open(path);\n-    if (!file.is_open()) return true; // Ok for file not to exist.\n+    if (!file.is_open()) {\n+      errors.emplace_back(strprintf(\"%s. Please check permissions.\", path.string()));\n+      return false;\n+    }\n \n     SettingsValue in;\n     if (!in.read(std::string{std::istreambuf_iterator<char>(file), std::istreambuf_iterator<char>()})) {"
      },
      {
        "sha": "1a4d67a65eeed315b4a73915022b2e82fdb74b2b",
        "filename": "src/util/sock.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 3,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/util/sock.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/util/sock.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/sock.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -10,12 +10,14 @@\n #include <util/system.h>\n #include <util/time.h>\n \n-#include <codecvt>\n-#include <cwchar>\n-#include <locale>\n #include <stdexcept>\n #include <string>\n \n+#ifdef WIN32\n+#include <codecvt>\n+#include <locale>\n+#endif\n+\n #ifdef USE_POLL\n #include <poll.h>\n #endif"
      },
      {
        "sha": "08f62f1da70eb64c6872df1ccb27d188964842f3",
        "filename": "src/util/system.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 1,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/util/system.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/util/system.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/system.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -904,6 +904,11 @@ bool ArgsManager::ReadConfigFiles(std::string& error, bool ignore_invalid_keys)\n     const std::string confPath = GetArg(\"-conf\", BITCOIN_CONF_FILENAME);\n     fsbridge::ifstream stream(GetConfigFile(confPath));\n \n+    // not ok to have a config file specified that cannot be opened\n+    if (IsArgSet(\"-conf\") && !stream.good()) {\n+        error = strprintf(\"specified config file \\\"%s\\\" could not be opened.\", confPath);\n+        return false;\n+    }\n     // ok to not have a config file\n     if (stream.good()) {\n         if (!ReadConfigStream(stream, confPath, error, ignore_invalid_keys)) {\n@@ -1301,7 +1306,7 @@ void SetupEnvironment()\n #endif\n     // On most POSIX systems (e.g. Linux, but not BSD) the environment's locale\n     // may be invalid, in which case the \"C.UTF-8\" locale is used as fallback.\n-#if !defined(WIN32) && !defined(MAC_OSX) && !defined(__FreeBSD__) && !defined(__OpenBSD__)\n+#if !defined(WIN32) && !defined(MAC_OSX) && !defined(__FreeBSD__) && !defined(__OpenBSD__) && !defined(__NetBSD__)\n     try {\n         std::locale(\"\"); // Raises a runtime error if current locale is invalid\n     } catch (const std::runtime_error&) {"
      },
      {
        "sha": "0047b00026b48443e4897c25440ac5354503cead",
        "filename": "src/util/types.h",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/util/types.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/util/types.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/types.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -0,0 +1,11 @@\n+// Copyright (c) 2021 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_UTIL_TYPES_H\n+#define BITCOIN_UTIL_TYPES_H\n+\n+template <class>\n+inline constexpr bool ALWAYS_FALSE{false};\n+\n+#endif // BITCOIN_UTIL_TYPES_H"
      },
      {
        "sha": "cc87f98913230aa475faa2d9d564bbfc2463ff31",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 135,
        "changes": 164,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -25,6 +25,7 @@\n #include <node/coinstats.h>\n #include <node/ui_interface.h>\n #include <policy/policy.h>\n+#include <policy/rbf.h>\n #include <policy/settings.h>\n #include <pow.h>\n #include <primitives/block.h>\n@@ -191,7 +192,7 @@ bool CheckFinalTx(const CBlockIndex* active_chain_tip, const CTransaction &tx, i\n \n     // CheckFinalTx() uses active_chain_tip.Height()+1 to evaluate\n     // nLockTime because when IsFinalTx() is called within\n-    // CBlock::AcceptBlock(), the height of the block *being*\n+    // AcceptBlock(), the height of the block *being*\n     // evaluated is what is used. Thus if we want to know if a\n     // transaction can be part of the *next* block, we need to call\n     // IsFinalTx() with one more than active_chain_tip.Height().\n@@ -414,7 +415,7 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, TxValidationS\n     }\n \n     // Call CheckInputScripts() to cache signature and script validity against current tip consensus rules.\n-    return CheckInputScripts(tx, state, view, flags, /* cacheSigStore = */ true, /* cacheFullSciptStore = */ true, txdata);\n+    return CheckInputScripts(tx, state, view, flags, /* cacheSigStore= */ true, /* cacheFullScriptStore= */ true, txdata);\n }\n \n namespace {\n@@ -474,8 +475,10 @@ class MemPoolAccept\n         bool m_replacement_transaction;\n         CAmount m_base_fees;\n         CAmount m_modified_fees;\n-        CAmount m_conflicting_fees;\n-        size_t m_conflicting_size;\n+        /** Total modified fees of all transactions being replaced. */\n+        CAmount m_conflicting_fees{0};\n+        /** Total virtual size of all transactions being replaced. */\n+        size_t m_conflicting_size{0};\n \n         const CTransactionRef& m_ptx;\n         const uint256& m_hash;\n@@ -602,31 +605,14 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n             }\n             if (!setConflicts.count(ptxConflicting->GetHash()))\n             {\n-                // Allow opt-out of transaction replacement by setting\n-                // nSequence > MAX_BIP125_RBF_SEQUENCE (SEQUENCE_FINAL-2) on all inputs.\n-                //\n-                // SEQUENCE_FINAL-1 is picked to still allow use of nLockTime by\n-                // non-replaceable transactions. All inputs rather than just one\n-                // is for the sake of multi-party protocols, where we don't\n-                // want a single party to be able to disable replacement.\n-                //\n                 // Transactions that don't explicitly signal replaceability are\n                 // *not* replaceable with the current logic, even if one of their\n                 // unconfirmed ancestors signals replaceability. This diverges\n                 // from BIP125's inherited signaling description (see CVE-2021-31876).\n                 // Applications relying on first-seen mempool behavior should\n                 // check all unconfirmed ancestors; otherwise an opt-in ancestor\n                 // might be replaced, causing removal of this descendant.\n-                bool fReplacementOptOut = true;\n-                for (const CTxIn &_txin : ptxConflicting->vin)\n-                {\n-                    if (_txin.nSequence <= MAX_BIP125_RBF_SEQUENCE)\n-                    {\n-                        fReplacementOptOut = false;\n-                        break;\n-                    }\n-                }\n-                if (fReplacementOptOut) {\n+                if (!SignalsOptInRBF(*ptxConflicting)) {\n                     return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"txn-mempool-conflict\");\n                 }\n \n@@ -784,23 +770,10 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     // that we have the set of all ancestors we can detect this\n     // pathological case by making sure setConflicts and setAncestors don't\n     // intersect.\n-    for (CTxMemPool::txiter ancestorIt : setAncestors)\n-    {\n-        const uint256 &hashAncestor = ancestorIt->GetTx().GetHash();\n-        if (setConflicts.count(hashAncestor))\n-        {\n-            return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-spends-conflicting-tx\",\n-                    strprintf(\"%s spends conflicting transaction %s\",\n-                        hash.ToString(),\n-                        hashAncestor.ToString()));\n-        }\n+    if (const auto err_string{EntriesAndTxidsDisjoint(setAncestors, setConflicts, hash)}) {\n+        return state.Invalid(TxValidationResult::TX_CONSENSUS, \"bad-txns-spends-conflicting-tx\", *err_string);\n     }\n \n-    // Check if it's economically rational to mine this transaction rather\n-    // than the ones it replaces.\n-    nConflictingFees = 0;\n-    nConflictingSize = 0;\n-    uint64_t nConflictingCount = 0;\n \n     // If we don't hold the lock allConflicting might be incomplete; the\n     // subsequent RemoveStaged() and addUnchecked() calls don't guarantee\n@@ -809,105 +782,29 @@ bool MemPoolAccept::PreChecks(ATMPArgs& args, Workspace& ws)\n     if (fReplacementTransaction)\n     {\n         CFeeRate newFeeRate(nModifiedFees, nSize);\n-        std::set<uint256> setConflictsParents;\n-        const int maxDescendantsToVisit = 100;\n-        for (const auto& mi : setIterConflicting) {\n-            // Don't allow the replacement to reduce the feerate of the\n-            // mempool.\n-            //\n-            // We usually don't want to accept replacements with lower\n-            // feerates than what they replaced as that would lower the\n-            // feerate of the next block. Requiring that the feerate always\n-            // be increased is also an easy-to-reason about way to prevent\n-            // DoS attacks via replacements.\n-            //\n-            // We only consider the feerates of transactions being directly\n-            // replaced, not their indirect descendants. While that does\n-            // mean high feerate children are ignored when deciding whether\n-            // or not to replace, we do require the replacement to pay more\n-            // overall fees too, mitigating most cases.\n-            CFeeRate oldFeeRate(mi->GetModifiedFee(), mi->GetTxSize());\n-            if (newFeeRate <= oldFeeRate)\n-            {\n-                return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\",\n-                        strprintf(\"rejecting replacement %s; new feerate %s <= old feerate %s\",\n-                            hash.ToString(),\n-                            newFeeRate.ToString(),\n-                            oldFeeRate.ToString()));\n-            }\n-\n-            for (const CTxIn &txin : mi->GetTx().vin)\n-            {\n-                setConflictsParents.insert(txin.prevout.hash);\n-            }\n-\n-            nConflictingCount += mi->GetCountWithDescendants();\n-        }\n-        // This potentially overestimates the number of actual descendants\n-        // but we just want to be conservative to avoid doing too much\n-        // work.\n-        if (nConflictingCount <= maxDescendantsToVisit) {\n-            // If not too many to replace, then calculate the set of\n-            // transactions that would have to be evicted\n-            for (CTxMemPool::txiter it : setIterConflicting) {\n-                m_pool.CalculateDescendants(it, allConflicting);\n-            }\n-            for (CTxMemPool::txiter it : allConflicting) {\n-                nConflictingFees += it->GetModifiedFee();\n-                nConflictingSize += it->GetTxSize();\n-            }\n-        } else {\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"too many potential replacements\",\n-                    strprintf(\"rejecting replacement %s; too many potential replacements (%d > %d)\\n\",\n-                        hash.ToString(),\n-                        nConflictingCount,\n-                        maxDescendantsToVisit));\n+        if (const auto err_string{PaysMoreThanConflicts(setIterConflicting, newFeeRate, hash)}) {\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\", *err_string);\n         }\n \n-        for (unsigned int j = 0; j < tx.vin.size(); j++)\n-        {\n-            // We don't want to accept replacements that require low\n-            // feerate junk to be mined first. Ideally we'd keep track of\n-            // the ancestor feerates and make the decision based on that,\n-            // but for now requiring all new inputs to be confirmed works.\n-            //\n-            // Note that if you relax this to make RBF a little more useful,\n-            // this may break the CalculateMempoolAncestors RBF relaxation,\n-            // above. See the comment above the first CalculateMempoolAncestors\n-            // call for more info.\n-            if (!setConflictsParents.count(tx.vin[j].prevout.hash))\n-            {\n-                // Rather than check the UTXO set - potentially expensive -\n-                // it's cheaper to just check if the new input refers to a\n-                // tx that's in the mempool.\n-                if (m_pool.exists(tx.vin[j].prevout.hash)) {\n-                    return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"replacement-adds-unconfirmed\",\n-                            strprintf(\"replacement %s adds unconfirmed input, idx %d\",\n-                                hash.ToString(), j));\n-                }\n-            }\n+        // Calculate all conflicting entries and enforce Rule #5.\n+        if (const auto err_string{GetEntriesForConflicts(tx, m_pool, setIterConflicting, allConflicting)}) {\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY,\n+                                 \"too many potential replacements\", *err_string);\n         }\n-\n-        // The replacement must pay greater fees than the transactions it\n-        // replaces - if we did the bandwidth used by those conflicting\n-        // transactions would not be paid for.\n-        if (nModifiedFees < nConflictingFees)\n-        {\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\",\n-                    strprintf(\"rejecting replacement %s, less fees than conflicting txs; %s < %s\",\n-                        hash.ToString(), FormatMoney(nModifiedFees), FormatMoney(nConflictingFees)));\n+        // Enforce Rule #2.\n+        if (const auto err_string{HasNoNewUnconfirmed(tx, m_pool, setIterConflicting)}) {\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY,\n+                                 \"replacement-adds-unconfirmed\", *err_string);\n         }\n \n-        // Finally in addition to paying more fees than the conflicts the\n-        // new transaction must pay for its own bandwidth.\n-        CAmount nDeltaFees = nModifiedFees - nConflictingFees;\n-        if (nDeltaFees < ::incrementalRelayFee.GetFee(nSize))\n-        {\n-            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\",\n-                    strprintf(\"rejecting replacement %s, not enough additional fees to relay; %s < %s\",\n-                        hash.ToString(),\n-                        FormatMoney(nDeltaFees),\n-                        FormatMoney(::incrementalRelayFee.GetFee(nSize))));\n+        // Check if it's economically rational to mine this transaction rather\n+        // than the ones it replaces. Enforce Rules #3 and #4.\n+        for (CTxMemPool::txiter it : allConflicting) {\n+            nConflictingFees += it->GetModifiedFee();\n+            nConflictingSize += it->GetTxSize();\n+        }\n+        if (const auto err_string{PaysForRBF(nConflictingFees, nModifiedFees, nSize, hash)}) {\n+            return state.Invalid(TxValidationResult::TX_MEMPOOL_POLICY, \"insufficient fee\", *err_string);\n         }\n     }\n     return true;\n@@ -2970,10 +2867,7 @@ void CChainState::ReceivedBlockTransactions(const CBlock& block, CBlockIndex* pi\n             CBlockIndex *pindex = queue.front();\n             queue.pop_front();\n             pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;\n-            {\n-                LOCK(cs_nBlockSequenceId);\n-                pindex->nSequenceId = nBlockSequenceId++;\n-            }\n+            pindex->nSequenceId = nBlockSequenceId++;\n             if (m_chain.Tip() == nullptr || !setBlockIndexCandidates.value_comp()(pindex, m_chain.Tip())) {\n                 setBlockIndexCandidates.insert(pindex);\n             }"
      },
      {
        "sha": "078b988052cbad700828c2b2fc5d8473610261bb",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -11,7 +11,9 @@\n #endif\n \n #include <amount.h>\n+#include <arith_uint256.h>\n #include <attributes.h>\n+#include <chain.h>\n #include <coins.h>\n #include <consensus/validation.h>\n #include <crypto/common.h> // for ReadLE64\n@@ -21,10 +23,11 @@\n #include <policy/packages.h>\n #include <protocol.h> // For CMessageHeader::MessageStartChars\n #include <script/script_error.h>\n+#include <serialize.h>\n #include <sync.h>\n-#include <txmempool.h> // For CTxMemPool::cs\n #include <txdb.h>\n-#include <serialize.h>\n+#include <txmempool.h> // For CTxMemPool::cs\n+#include <uint256.h>\n #include <util/check.h>\n #include <util/hasher.h>\n #include <util/translation.h>\n@@ -42,7 +45,6 @@\n \n class CChainState;\n class BlockValidationState;\n-class CBlockIndex;\n class CBlockTreeDB;\n class CBlockUndo;\n class CChainParams;\n@@ -558,9 +560,8 @@ class CChainState\n      * Every received block is assigned a unique and increasing identifier, so we\n      * know which one to give priority in case of a fork.\n      */\n-    RecursiveMutex cs_nBlockSequenceId;\n     /** Blocks loaded from disk are assigned id 0, so start the counter at 1. */\n-    int32_t nBlockSequenceId = 1;\n+    int32_t nBlockSequenceId GUARDED_BY(::cs_main) = 1;\n     /** Decreasing counter (used by subsequent preciousblock calls). */\n     int32_t nBlockReverseSequenceId = -1;\n     /** chainwork for the last block that preciousblock has been applied to. */\n@@ -749,7 +750,7 @@ class CChainState\n \n     void PruneBlockIndexCandidates();\n \n-    void UnloadBlockIndex();\n+    void UnloadBlockIndex() EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n \n     /** Check whether we are doing an initial block download (synchronizing from disk or network) */\n     bool IsInitialBlockDownload() const;\n@@ -930,7 +931,7 @@ class ChainstateManager\n     CChainState& InitializeChainstate(\n         CTxMemPool* mempool,\n         const std::optional<uint256>& snapshot_blockhash = std::nullopt)\n-        EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n+        LIFETIMEBOUND EXCLUSIVE_LOCKS_REQUIRED(::cs_main);\n \n     //! Get all chainstates currently being used.\n     std::vector<CChainState*> GetAll();"
      },
      {
        "sha": "1699424657ca2d81265e41d6a4f50fa99700572a",
        "filename": "src/wallet/coinselection.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/coinselection.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/coinselection.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -341,3 +341,30 @@ CAmount OutputGroup::GetSelectionAmount() const\n {\n     return m_subtract_fee_outputs ? m_value : effective_value;\n }\n+\n+CAmount GetSelectionWaste(const std::set<CInputCoin>& inputs, CAmount change_cost, CAmount target, bool use_effective_value)\n+{\n+    // This function should not be called with empty inputs as that would mean the selection failed\n+    assert(!inputs.empty());\n+\n+    // Always consider the cost of spending an input now vs in the future.\n+    CAmount waste = 0;\n+    CAmount selected_effective_value = 0;\n+    for (const CInputCoin& coin : inputs) {\n+        waste += coin.m_fee - coin.m_long_term_fee;\n+        selected_effective_value += use_effective_value ? coin.effective_value : coin.txout.nValue;\n+    }\n+\n+    if (change_cost) {\n+        // Consider the cost of making change and spending it in the future\n+        // If we aren't making change, the caller should've set change_cost to 0\n+        assert(change_cost > 0);\n+        waste += change_cost;\n+    } else {\n+        // When we are not making change (change_cost == 0), consider the excess we are throwing away to fees\n+        assert(selected_effective_value >= target);\n+        waste += selected_effective_value - target;\n+    }\n+\n+    return waste;\n+}"
      },
      {
        "sha": "35617d455b4b13c353914566423940ecfaeab6a4",
        "filename": "src/wallet/coinselection.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/coinselection.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/coinselection.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/coinselection.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -166,6 +166,21 @@ struct OutputGroup\n     CAmount GetSelectionAmount() const;\n };\n \n+/** Compute the waste for this result given the cost of change\n+ * and the opportunity cost of spending these inputs now vs in the future.\n+ * If change exists, waste = change_cost + inputs * (effective_feerate - long_term_feerate)\n+ * If no change, waste = excess + inputs * (effective_feerate - long_term_feerate)\n+ * where excess = selected_effective_value - target\n+ * change_cost = effective_feerate * change_output_size + long_term_feerate * change_spend_size\n+ *\n+ * @param[in] inputs The selected inputs\n+ * @param[in] change_cost The cost of creating change and spending it in the future. Only used if there is change. Must be 0 if there is no change.\n+ * @param[in] target The amount targeted by the coin selection algorithm.\n+ * @param[in] use_effective_value Whether to use the input's effective value (when true) or the real value (when false).\n+ * @return The waste\n+ */\n+[[nodiscard]] CAmount GetSelectionWaste(const std::set<CInputCoin>& inputs, CAmount change_cost, CAmount target, bool use_effective_value = true);\n+\n bool SelectCoinsBnB(std::vector<OutputGroup>& utxo_pool, const CAmount& selection_target, const CAmount& cost_of_change, std::set<CInputCoin>& out_set, CAmount& value_ret);\n \n // Original coin selection algorithm as a fallback"
      },
      {
        "sha": "f2de68295e3704b045d919d45fede6d429d563f7",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -12,6 +12,8 @@\n #include <wallet/coincontrol.h>\n #include <wallet/feebumper.h>\n #include <wallet/fees.h>\n+#include <wallet/receive.h>\n+#include <wallet/spend.h>\n #include <wallet/wallet.h>\n \n //! Check whether transaction has descendant in wallet or mempool, or has been\n@@ -30,7 +32,7 @@ static feebumper::Result PreconditionChecks(const CWallet& wallet, const CWallet\n         }\n     }\n \n-    if (wtx.GetDepthInMainChain() != 0) {\n+    if (wallet.GetTxDepthInMainChain(wtx) != 0) {\n         errors.push_back(Untranslated(\"Transaction has been mined, or is conflicted with a mined transaction\"));\n         return feebumper::Result::WALLET_ERROR;\n     }\n@@ -48,7 +50,7 @@ static feebumper::Result PreconditionChecks(const CWallet& wallet, const CWallet\n     // check that original tx consists entirely of our inputs\n     // if not, we can't bump the fee, because the wallet has no way of knowing the value of the other inputs (thus the fee)\n     isminefilter filter = wallet.GetLegacyScriptPubKeyMan() && wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) ? ISMINE_WATCH_ONLY : ISMINE_SPENDABLE;\n-    if (!wallet.IsAllFromMe(*wtx.tx, filter)) {\n+    if (!AllInputsMine(wallet, *wtx.tx, filter)) {\n         errors.push_back(Untranslated(\"Transaction contains inputs that don't belong to this wallet\"));\n         return feebumper::Result::WALLET_ERROR;\n     }\n@@ -81,7 +83,7 @@ static feebumper::Result CheckFeeRate(const CWallet& wallet, const CWalletTx& wt\n \n     // Given old total fee and transaction size, calculate the old feeRate\n     isminefilter filter = wallet.GetLegacyScriptPubKeyMan() && wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) ? ISMINE_WATCH_ONLY : ISMINE_SPENDABLE;\n-    CAmount old_fee = wtx.GetDebit(filter) - wtx.tx->GetValueOut();\n+    CAmount old_fee = CachedTxGetDebit(wallet, wtx, filter) - wtx.tx->GetValueOut();\n     const int64_t txSize = GetVirtualTransactionSize(*(wtx.tx));\n     CFeeRate nOldFeeRate(old_fee, txSize);\n     // Min total fee is old fee + relay fee\n@@ -174,7 +176,7 @@ Result CreateRateBumpTransaction(CWallet& wallet, const uint256& txid, const CCo\n     // Fill in recipients(and preserve a single change key if there is one)\n     std::vector<CRecipient> recipients;\n     for (const auto& output : wtx.tx->vout) {\n-        if (!wallet.IsChange(output)) {\n+        if (!OutputIsChange(wallet, output)) {\n             CRecipient recipient = {output.scriptPubKey, output.nValue, false};\n             recipients.push_back(recipient);\n         } else {\n@@ -185,7 +187,7 @@ Result CreateRateBumpTransaction(CWallet& wallet, const uint256& txid, const CCo\n     }\n \n     isminefilter filter = wallet.GetLegacyScriptPubKeyMan() && wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) ? ISMINE_WATCH_ONLY : ISMINE_SPENDABLE;\n-    old_fee = wtx.GetDebit(filter) - wtx.tx->GetValueOut();\n+    old_fee = CachedTxGetDebit(wallet, wtx, filter) - wtx.tx->GetValueOut();\n \n     if (coin_control.m_feerate) {\n         // The user provided a feeRate argument.\n@@ -220,7 +222,7 @@ Result CreateRateBumpTransaction(CWallet& wallet, const uint256& txid, const CCo\n     int change_pos_in_out = -1; // No requested location for change\n     bilingual_str fail_reason;\n     FeeCalculation fee_calc_out;\n-    if (!wallet.CreateTransaction(recipients, tx_new, fee_ret, change_pos_in_out, fail_reason, new_coin_control, fee_calc_out, false)) {\n+    if (!CreateTransaction(wallet, recipients, tx_new, fee_ret, change_pos_in_out, fail_reason, new_coin_control, fee_calc_out, false)) {\n         errors.push_back(Untranslated(\"Unable to create transaction.\") + Untranslated(\" \") + fail_reason);\n         return Result::WALLET_ERROR;\n     }"
      },
      {
        "sha": "7abdbb0e5551d234fe70e8bbce8b06c94c87d1f9",
        "filename": "src/wallet/init.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/init.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -5,6 +5,7 @@\n \n #include <init.h>\n #include <interfaces/chain.h>\n+#include <interfaces/init.h>\n #include <interfaces/wallet.h>\n #include <net.h>\n #include <node/context.h>\n@@ -45,6 +46,7 @@ void WalletInit::AddWalletOptions(ArgsManager& argsman) const\n     argsman.AddArg(\"-addresstype\", strprintf(\"What type of addresses to use (\\\"legacy\\\", \\\"p2sh-segwit\\\", or \\\"bech32\\\", default: \\\"%s\\\")\", FormatOutputType(DEFAULT_ADDRESS_TYPE)), ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);\n     argsman.AddArg(\"-avoidpartialspends\", strprintf(\"Group outputs by address, selecting many (possibly all) or none, instead of selecting on a per-output basis. Privacy is improved as addresses are mostly swept with fewer transactions and outputs are aggregated in clean change addresses. It may result in higher fees due to less optimal coin selection caused by this added limitation and possibly a larger-than-necessary number of inputs being used. Always enabled for wallets with \\\"avoid_reuse\\\" enabled, otherwise default: %u.\", DEFAULT_AVOIDPARTIALSPENDS), ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);\n     argsman.AddArg(\"-changetype\", \"What type of change to use (\\\"legacy\\\", \\\"p2sh-segwit\\\", or \\\"bech32\\\"). Default is same as -addresstype, except when -addresstype=p2sh-segwit a native segwit output is used when sending to a native segwit address)\", ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);\n+    argsman.AddArg(\"-consolidatefeerate=<amt>\", strprintf(\"The maximum feerate (in %s/kvB) at which transaction building may use more inputs than strictly necessary so that the wallet's UTXO pool can be reduced (default: %s).\", CURRENCY_UNIT, FormatMoney(DEFAULT_CONSOLIDATE_FEERATE)), ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);\n     argsman.AddArg(\"-disablewallet\", \"Do not load the wallet and disable wallet RPC calls\", ArgsManager::ALLOW_ANY, OptionsCategory::WALLET);\n     argsman.AddArg(\"-discardfee=<amt>\", strprintf(\"The fee rate (in %s/kvB) that indicates your tolerance for discarding change by adding it to the fee (default: %s). \"\n                                                                 \"Note: An output is discarded if it is dust at this rate, but we will always discard up to the dust relay fee and a discard fee above that is limited by the fee estimate for the longest target\",\n@@ -129,7 +131,7 @@ void WalletInit::Construct(NodeContext& node) const\n         LogPrintf(\"Wallet disabled!\\n\");\n         return;\n     }\n-    auto wallet_client = interfaces::MakeWalletClient(*node.chain, args);\n+    auto wallet_client = node.init->makeWalletClient(*node.chain);\n     node.wallet_client = wallet_client.get();\n     node.chain_clients.emplace_back(std::move(wallet_client));\n }"
      },
      {
        "sha": "9a8c1e3c02330efd12e9d572a7cfc006729139ee",
        "filename": "src/wallet/interfaces.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 16,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/interfaces.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/interfaces.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/interfaces.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -23,7 +23,9 @@\n #include <wallet/fees.h>\n #include <wallet/ismine.h>\n #include <wallet/load.h>\n+#include <wallet/receive.h>\n #include <wallet/rpcwallet.h>\n+#include <wallet/spend.h>\n #include <wallet/wallet.h>\n \n #include <memory>\n@@ -55,7 +57,7 @@ WalletTx MakeWalletTx(CWallet& wallet, const CWalletTx& wtx)\n     result.tx = wtx.tx;\n     result.txin_is_mine.reserve(wtx.tx->vin.size());\n     for (const auto& txin : wtx.tx->vin) {\n-        result.txin_is_mine.emplace_back(wallet.IsMine(txin));\n+        result.txin_is_mine.emplace_back(InputIsMine(wallet, txin));\n     }\n     result.txout_is_mine.reserve(wtx.tx->vout.size());\n     result.txout_address.reserve(wtx.tx->vout.size());\n@@ -67,9 +69,9 @@ WalletTx MakeWalletTx(CWallet& wallet, const CWalletTx& wtx)\n                                                       wallet.IsMine(result.txout_address.back()) :\n                                                       ISMINE_NO);\n     }\n-    result.credit = wtx.GetCredit(ISMINE_ALL);\n-    result.debit = wtx.GetDebit(ISMINE_ALL);\n-    result.change = wtx.GetChange();\n+    result.credit = CachedTxGetCredit(wallet, wtx, ISMINE_ALL);\n+    result.debit = CachedTxGetDebit(wallet, wtx, ISMINE_ALL);\n+    result.change = CachedTxGetChange(wallet, wtx);\n     result.time = wtx.GetTxTime();\n     result.value_map = wtx.mapValue;\n     result.is_coinbase = wtx.IsCoinBase();\n@@ -81,15 +83,15 @@ WalletTxStatus MakeWalletTxStatus(const CWallet& wallet, const CWalletTx& wtx)\n {\n     WalletTxStatus result;\n     result.block_height = wtx.m_confirm.block_height > 0 ? wtx.m_confirm.block_height : std::numeric_limits<int>::max();\n-    result.blocks_to_maturity = wtx.GetBlocksToMaturity();\n-    result.depth_in_main_chain = wtx.GetDepthInMainChain();\n+    result.blocks_to_maturity = wallet.GetTxBlocksToMaturity(wtx);\n+    result.depth_in_main_chain = wallet.GetTxDepthInMainChain(wtx);\n     result.time_received = wtx.nTimeReceived;\n     result.lock_time = wtx.tx->nLockTime;\n     result.is_final = wallet.chain().checkFinalTx(*wtx.tx);\n-    result.is_trusted = wtx.IsTrusted();\n+    result.is_trusted = CachedTxIsTrusted(wallet, wtx);\n     result.is_abandoned = wtx.isAbandoned();\n     result.is_coinbase = wtx.IsCoinBase();\n-    result.is_in_main_chain = wtx.IsInMainChain();\n+    result.is_in_main_chain = wallet.IsTxInMainChain(wtx);\n     return result;\n }\n \n@@ -242,7 +244,7 @@ class WalletImpl : public Wallet\n         LOCK(m_wallet->cs_wallet);\n         CTransactionRef tx;\n         FeeCalculation fee_calc_out;\n-        if (!m_wallet->CreateTransaction(recipients, tx, fee, change_pos,\n+        if (!CreateTransaction(*m_wallet, recipients, tx, fee, change_pos,\n                 fail_reason, coin_control, fee_calc_out, sign)) {\n             return {};\n         }\n@@ -358,7 +360,7 @@ class WalletImpl : public Wallet\n     }\n     WalletBalances getBalances() override\n     {\n-        const auto bal = m_wallet->GetBalance();\n+        const auto bal = GetBalance(*m_wallet);\n         WalletBalances result;\n         result.balance = bal.m_mine_trusted;\n         result.unconfirmed_balance = bal.m_mine_untrusted_pending;\n@@ -381,15 +383,15 @@ class WalletImpl : public Wallet\n         balances = getBalances();\n         return true;\n     }\n-    CAmount getBalance() override { return m_wallet->GetBalance().m_mine_trusted; }\n+    CAmount getBalance() override { return GetBalance(*m_wallet).m_mine_trusted; }\n     CAmount getAvailableBalance(const CCoinControl& coin_control) override\n     {\n-        return m_wallet->GetAvailableBalance(&coin_control);\n+        return GetAvailableBalance(*m_wallet, &coin_control);\n     }\n     isminetype txinIsMine(const CTxIn& txin) override\n     {\n         LOCK(m_wallet->cs_wallet);\n-        return m_wallet->IsMine(txin);\n+        return InputIsMine(*m_wallet, txin);\n     }\n     isminetype txoutIsMine(const CTxOut& txout) override\n     {\n@@ -404,13 +406,13 @@ class WalletImpl : public Wallet\n     CAmount getCredit(const CTxOut& txout, isminefilter filter) override\n     {\n         LOCK(m_wallet->cs_wallet);\n-        return m_wallet->GetCredit(txout, filter);\n+        return OutputGetCredit(*m_wallet, txout, filter);\n     }\n     CoinsList listCoins() override\n     {\n         LOCK(m_wallet->cs_wallet);\n         CoinsList result;\n-        for (const auto& entry : m_wallet->ListCoins()) {\n+        for (const auto& entry : ListCoins(*m_wallet)) {\n             auto& group = result[entry.first];\n             for (const auto& coin : entry.second) {\n                 group.emplace_back(COutPoint(coin.tx->GetHash(), coin.i),\n@@ -428,7 +430,7 @@ class WalletImpl : public Wallet\n             result.emplace_back();\n             auto it = m_wallet->mapWallet.find(output.hash);\n             if (it != m_wallet->mapWallet.end()) {\n-                int depth = it->second.GetDepthInMainChain();\n+                int depth = m_wallet->GetTxDepthInMainChain(it->second);\n                 if (depth >= 0) {\n                     result.back() = MakeWalletTxOut(*m_wallet, it->second, output.n, depth);\n                 }"
      },
      {
        "sha": "1b841026b892b9f1b2dea8ab0474270dbf61fd91",
        "filename": "src/wallet/load.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 5,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/load.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/load.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/load.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -8,10 +8,12 @@\n #include <fs.h>\n #include <interfaces/chain.h>\n #include <scheduler.h>\n+#include <util/check.h>\n #include <util/string.h>\n #include <util/system.h>\n #include <util/translation.h>\n #include <wallet/context.h>\n+#include <wallet/spend.h>\n #include <wallet/wallet.h>\n #include <wallet/walletdb.h>\n \n@@ -20,8 +22,10 @@\n bool VerifyWallets(WalletContext& context)\n {\n     interfaces::Chain& chain = *context.chain;\n-    if (gArgs.IsArgSet(\"-walletdir\")) {\n-        fs::path wallet_dir = gArgs.GetArg(\"-walletdir\", \"\");\n+    ArgsManager& args = *Assert(context.args);\n+\n+    if (args.IsArgSet(\"-walletdir\")) {\n+        fs::path wallet_dir = args.GetArg(\"-walletdir\", \"\");\n         boost::system::error_code error;\n         // The canonical path cleans the path, preventing >1 Berkeley environment instances for the same directory\n         fs::path canonical_wallet_dir = fs::canonical(wallet_dir, error);\n@@ -36,7 +40,7 @@ bool VerifyWallets(WalletContext& context)\n             chain.initError(strprintf(_(\"Specified -walletdir \\\"%s\\\" is a relative path\"), wallet_dir.string()));\n             return false;\n         }\n-        gArgs.ForceSetArg(\"-walletdir\", canonical_wallet_dir.string());\n+        args.ForceSetArg(\"-walletdir\", canonical_wallet_dir.string());\n     }\n \n     LogPrintf(\"Using wallet directory %s\\n\", GetWalletDir().string());\n@@ -45,7 +49,7 @@ bool VerifyWallets(WalletContext& context)\n \n     // For backwards compatibility if an unnamed top level wallet exists in the\n     // wallets directory, include it in the default list of wallets to load.\n-    if (!gArgs.IsArgSet(\"wallet\")) {\n+    if (!args.IsArgSet(\"wallet\")) {\n         DatabaseOptions options;\n         DatabaseStatus status;\n         bilingual_str error_string;\n@@ -161,7 +165,7 @@ void UnloadWallets(WalletContext& context)\n         auto wallet = wallets.back();\n         wallets.pop_back();\n         std::vector<bilingual_str> warnings;\n-        RemoveWallet(context, wallet, /* load_on_startup= */ std::nullopt, warnings);\n+        RemoveWallet(context, wallet, /* load_on_start= */ std::nullopt, warnings);\n         UnloadWallet(std::move(wallet));\n     }\n }"
      },
      {
        "sha": "98706dcdf8086866cfc12f98c4ea7c362197e15d",
        "filename": "src/wallet/receive.cpp",
        "status": "modified",
        "additions": 116,
        "deletions": 113,
        "changes": 229,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/receive.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/receive.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/receive.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -7,61 +7,61 @@\n #include <wallet/transaction.h>\n #include <wallet/wallet.h>\n \n-isminetype CWallet::IsMine(const CTxIn &txin) const\n+isminetype InputIsMine(const CWallet& wallet, const CTxIn &txin)\n {\n-    AssertLockHeld(cs_wallet);\n-    std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n-    if (mi != mapWallet.end())\n+    AssertLockHeld(wallet.cs_wallet);\n+    std::map<uint256, CWalletTx>::const_iterator mi = wallet.mapWallet.find(txin.prevout.hash);\n+    if (mi != wallet.mapWallet.end())\n     {\n         const CWalletTx& prev = (*mi).second;\n         if (txin.prevout.n < prev.tx->vout.size())\n-            return IsMine(prev.tx->vout[txin.prevout.n]);\n+            return wallet.IsMine(prev.tx->vout[txin.prevout.n]);\n     }\n     return ISMINE_NO;\n }\n \n-bool CWallet::IsAllFromMe(const CTransaction& tx, const isminefilter& filter) const\n+bool AllInputsMine(const CWallet& wallet, const CTransaction& tx, const isminefilter& filter)\n {\n-    LOCK(cs_wallet);\n+    LOCK(wallet.cs_wallet);\n \n     for (const CTxIn& txin : tx.vin)\n     {\n-        auto mi = mapWallet.find(txin.prevout.hash);\n-        if (mi == mapWallet.end())\n+        auto mi = wallet.mapWallet.find(txin.prevout.hash);\n+        if (mi == wallet.mapWallet.end())\n             return false; // any unknown inputs can't be from us\n \n         const CWalletTx& prev = (*mi).second;\n \n         if (txin.prevout.n >= prev.tx->vout.size())\n             return false; // invalid input!\n \n-        if (!(IsMine(prev.tx->vout[txin.prevout.n]) & filter))\n+        if (!(wallet.IsMine(prev.tx->vout[txin.prevout.n]) & filter))\n             return false;\n     }\n     return true;\n }\n \n-CAmount CWallet::GetCredit(const CTxOut& txout, const isminefilter& filter) const\n+CAmount OutputGetCredit(const CWallet& wallet, const CTxOut& txout, const isminefilter& filter)\n {\n     if (!MoneyRange(txout.nValue))\n         throw std::runtime_error(std::string(__func__) + \": value out of range\");\n-    LOCK(cs_wallet);\n-    return ((IsMine(txout) & filter) ? txout.nValue : 0);\n+    LOCK(wallet.cs_wallet);\n+    return ((wallet.IsMine(txout) & filter) ? txout.nValue : 0);\n }\n \n-CAmount CWallet::GetCredit(const CTransaction& tx, const isminefilter& filter) const\n+CAmount TxGetCredit(const CWallet& wallet, const CTransaction& tx, const isminefilter& filter)\n {\n     CAmount nCredit = 0;\n     for (const CTxOut& txout : tx.vout)\n     {\n-        nCredit += GetCredit(txout, filter);\n+        nCredit += OutputGetCredit(wallet, txout, filter);\n         if (!MoneyRange(nCredit))\n             throw std::runtime_error(std::string(__func__) + \": value out of range\");\n     }\n     return nCredit;\n }\n \n-bool CWallet::IsChange(const CScript& script) const\n+bool ScriptIsChange(const CWallet& wallet, const CScript& script)\n {\n     // TODO: fix handling of 'change' outputs. The assumption is that any\n     // payment to a script that is ours, but is not in the address book\n@@ -70,179 +70,177 @@ bool CWallet::IsChange(const CScript& script) const\n     // a better way of identifying which outputs are 'the send' and which are\n     // 'the change' will need to be implemented (maybe extend CWalletTx to remember\n     // which output, if any, was change).\n-    AssertLockHeld(cs_wallet);\n-    if (IsMine(script))\n+    AssertLockHeld(wallet.cs_wallet);\n+    if (wallet.IsMine(script))\n     {\n         CTxDestination address;\n         if (!ExtractDestination(script, address))\n             return true;\n-        if (!FindAddressBookEntry(address)) {\n+        if (!wallet.FindAddressBookEntry(address)) {\n             return true;\n         }\n     }\n     return false;\n }\n \n-bool CWallet::IsChange(const CTxOut& txout) const\n+bool OutputIsChange(const CWallet& wallet, const CTxOut& txout)\n {\n-    return IsChange(txout.scriptPubKey);\n+    return ScriptIsChange(wallet, txout.scriptPubKey);\n }\n \n-CAmount CWallet::GetChange(const CTxOut& txout) const\n+CAmount OutputGetChange(const CWallet& wallet, const CTxOut& txout)\n {\n-    AssertLockHeld(cs_wallet);\n+    AssertLockHeld(wallet.cs_wallet);\n     if (!MoneyRange(txout.nValue))\n         throw std::runtime_error(std::string(__func__) + \": value out of range\");\n-    return (IsChange(txout) ? txout.nValue : 0);\n+    return (OutputIsChange(wallet, txout) ? txout.nValue : 0);\n }\n \n-CAmount CWallet::GetChange(const CTransaction& tx) const\n+CAmount TxGetChange(const CWallet& wallet, const CTransaction& tx)\n {\n-    LOCK(cs_wallet);\n+    LOCK(wallet.cs_wallet);\n     CAmount nChange = 0;\n     for (const CTxOut& txout : tx.vout)\n     {\n-        nChange += GetChange(txout);\n+        nChange += OutputGetChange(wallet, txout);\n         if (!MoneyRange(nChange))\n             throw std::runtime_error(std::string(__func__) + \": value out of range\");\n     }\n     return nChange;\n }\n \n-CAmount CWalletTx::GetCachableAmount(AmountType type, const isminefilter& filter, bool recalculate) const\n+static CAmount GetCachableAmount(const CWallet& wallet, const CWalletTx& wtx, CWalletTx::AmountType type, const isminefilter& filter, bool recalculate = false)\n {\n-    auto& amount = m_amounts[type];\n+    auto& amount = wtx.m_amounts[type];\n     if (recalculate || !amount.m_cached[filter]) {\n-        amount.Set(filter, type == DEBIT ? pwallet->GetDebit(*tx, filter) : pwallet->GetCredit(*tx, filter));\n-        m_is_cache_empty = false;\n+        amount.Set(filter, type == CWalletTx::DEBIT ? wallet.GetDebit(*wtx.tx, filter) : TxGetCredit(wallet, *wtx.tx, filter));\n+        wtx.m_is_cache_empty = false;\n     }\n     return amount.m_value[filter];\n }\n \n-CAmount CWalletTx::GetCredit(const isminefilter& filter) const\n+CAmount CachedTxGetCredit(const CWallet& wallet, const CWalletTx& wtx, const isminefilter& filter)\n {\n     // Must wait until coinbase is safely deep enough in the chain before valuing it\n-    if (IsImmatureCoinBase())\n+    if (wallet.IsTxImmatureCoinBase(wtx))\n         return 0;\n \n     CAmount credit = 0;\n     if (filter & ISMINE_SPENDABLE) {\n         // GetBalance can assume transactions in mapWallet won't change\n-        credit += GetCachableAmount(CREDIT, ISMINE_SPENDABLE);\n+        credit += GetCachableAmount(wallet, wtx, CWalletTx::CREDIT, ISMINE_SPENDABLE);\n     }\n     if (filter & ISMINE_WATCH_ONLY) {\n-        credit += GetCachableAmount(CREDIT, ISMINE_WATCH_ONLY);\n+        credit += GetCachableAmount(wallet, wtx, CWalletTx::CREDIT, ISMINE_WATCH_ONLY);\n     }\n     return credit;\n }\n \n-CAmount CWalletTx::GetDebit(const isminefilter& filter) const\n+CAmount CachedTxGetDebit(const CWallet& wallet, const CWalletTx& wtx, const isminefilter& filter)\n {\n-    if (tx->vin.empty())\n+    if (wtx.tx->vin.empty())\n         return 0;\n \n     CAmount debit = 0;\n     if (filter & ISMINE_SPENDABLE) {\n-        debit += GetCachableAmount(DEBIT, ISMINE_SPENDABLE);\n+        debit += GetCachableAmount(wallet, wtx, CWalletTx::DEBIT, ISMINE_SPENDABLE);\n     }\n     if (filter & ISMINE_WATCH_ONLY) {\n-        debit += GetCachableAmount(DEBIT, ISMINE_WATCH_ONLY);\n+        debit += GetCachableAmount(wallet, wtx, CWalletTx::DEBIT, ISMINE_WATCH_ONLY);\n     }\n     return debit;\n }\n \n-CAmount CWalletTx::GetChange() const\n+CAmount CachedTxGetChange(const CWallet& wallet, const CWalletTx& wtx)\n {\n-    if (fChangeCached)\n-        return nChangeCached;\n-    nChangeCached = pwallet->GetChange(*tx);\n-    fChangeCached = true;\n-    return nChangeCached;\n+    if (wtx.fChangeCached)\n+        return wtx.nChangeCached;\n+    wtx.nChangeCached = TxGetChange(wallet, *wtx.tx);\n+    wtx.fChangeCached = true;\n+    return wtx.nChangeCached;\n }\n \n-CAmount CWalletTx::GetImmatureCredit(bool fUseCache) const\n+CAmount CachedTxGetImmatureCredit(const CWallet& wallet, const CWalletTx& wtx, bool fUseCache)\n {\n-    if (IsImmatureCoinBase() && IsInMainChain()) {\n-        return GetCachableAmount(IMMATURE_CREDIT, ISMINE_SPENDABLE, !fUseCache);\n+    if (wallet.IsTxImmatureCoinBase(wtx) && wallet.IsTxInMainChain(wtx)) {\n+        return GetCachableAmount(wallet, wtx, CWalletTx::IMMATURE_CREDIT, ISMINE_SPENDABLE, !fUseCache);\n     }\n \n     return 0;\n }\n \n-CAmount CWalletTx::GetImmatureWatchOnlyCredit(const bool fUseCache) const\n+CAmount CachedTxGetImmatureWatchOnlyCredit(const CWallet& wallet, const CWalletTx& wtx, const bool fUseCache)\n {\n-    if (IsImmatureCoinBase() && IsInMainChain()) {\n-        return GetCachableAmount(IMMATURE_CREDIT, ISMINE_WATCH_ONLY, !fUseCache);\n+    if (wallet.IsTxImmatureCoinBase(wtx) && wallet.IsTxInMainChain(wtx)) {\n+        return GetCachableAmount(wallet, wtx, CWalletTx::IMMATURE_CREDIT, ISMINE_WATCH_ONLY, !fUseCache);\n     }\n \n     return 0;\n }\n \n-CAmount CWalletTx::GetAvailableCredit(bool fUseCache, const isminefilter& filter) const\n+CAmount CachedTxGetAvailableCredit(const CWallet& wallet, const CWalletTx& wtx, bool fUseCache, const isminefilter& filter)\n {\n-    if (pwallet == nullptr)\n-        return 0;\n-\n     // Avoid caching ismine for NO or ALL cases (could remove this check and simplify in the future).\n     bool allow_cache = (filter & ISMINE_ALL) && (filter & ISMINE_ALL) != ISMINE_ALL;\n \n     // Must wait until coinbase is safely deep enough in the chain before valuing it\n-    if (IsImmatureCoinBase())\n+    if (wallet.IsTxImmatureCoinBase(wtx))\n         return 0;\n \n-    if (fUseCache && allow_cache && m_amounts[AVAILABLE_CREDIT].m_cached[filter]) {\n-        return m_amounts[AVAILABLE_CREDIT].m_value[filter];\n+    if (fUseCache && allow_cache && wtx.m_amounts[CWalletTx::AVAILABLE_CREDIT].m_cached[filter]) {\n+        return wtx.m_amounts[CWalletTx::AVAILABLE_CREDIT].m_value[filter];\n     }\n \n-    bool allow_used_addresses = (filter & ISMINE_USED) || !pwallet->IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE);\n+    bool allow_used_addresses = (filter & ISMINE_USED) || !wallet.IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE);\n     CAmount nCredit = 0;\n-    uint256 hashTx = GetHash();\n-    for (unsigned int i = 0; i < tx->vout.size(); i++)\n+    uint256 hashTx = wtx.GetHash();\n+    for (unsigned int i = 0; i < wtx.tx->vout.size(); i++)\n     {\n-        if (!pwallet->IsSpent(hashTx, i) && (allow_used_addresses || !pwallet->IsSpentKey(hashTx, i))) {\n-            const CTxOut &txout = tx->vout[i];\n-            nCredit += pwallet->GetCredit(txout, filter);\n+        if (!wallet.IsSpent(hashTx, i) && (allow_used_addresses || !wallet.IsSpentKey(hashTx, i))) {\n+            const CTxOut &txout = wtx.tx->vout[i];\n+            nCredit += OutputGetCredit(wallet, txout, filter);\n             if (!MoneyRange(nCredit))\n                 throw std::runtime_error(std::string(__func__) + \" : value out of range\");\n         }\n     }\n \n     if (allow_cache) {\n-        m_amounts[AVAILABLE_CREDIT].Set(filter, nCredit);\n-        m_is_cache_empty = false;\n+        wtx.m_amounts[CWalletTx::AVAILABLE_CREDIT].Set(filter, nCredit);\n+        wtx.m_is_cache_empty = false;\n     }\n \n     return nCredit;\n }\n \n-void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n-                           std::list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter) const\n+void CachedTxGetAmounts(const CWallet& wallet, const CWalletTx& wtx,\n+                  std::list<COutputEntry>& listReceived,\n+                  std::list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter)\n {\n     nFee = 0;\n     listReceived.clear();\n     listSent.clear();\n \n     // Compute fee:\n-    CAmount nDebit = GetDebit(filter);\n+    CAmount nDebit = CachedTxGetDebit(wallet, wtx, filter);\n     if (nDebit > 0) // debit>0 means we signed/sent this transaction\n     {\n-        CAmount nValueOut = tx->GetValueOut();\n+        CAmount nValueOut = wtx.tx->GetValueOut();\n         nFee = nDebit - nValueOut;\n     }\n \n-    LOCK(pwallet->cs_wallet);\n+    LOCK(wallet.cs_wallet);\n     // Sent/received.\n-    for (unsigned int i = 0; i < tx->vout.size(); ++i)\n+    for (unsigned int i = 0; i < wtx.tx->vout.size(); ++i)\n     {\n-        const CTxOut& txout = tx->vout[i];\n-        isminetype fIsMine = pwallet->IsMine(txout);\n+        const CTxOut& txout = wtx.tx->vout[i];\n+        isminetype fIsMine = wallet.IsMine(txout);\n         // Only need to handle txouts if AT LEAST one of these is true:\n         //   1) they debit from us (sent)\n         //   2) the output is to us (received)\n         if (nDebit > 0)\n         {\n             // Don't report 'change' txouts\n-            if (pwallet->IsChange(txout))\n+            if (OutputIsChange(wallet, txout))\n                 continue;\n         }\n         else if (!(fIsMine & filter))\n@@ -253,8 +251,8 @@ void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n \n         if (!ExtractDestination(txout.scriptPubKey, address) && !txout.scriptPubKey.IsUnspendable())\n         {\n-            pwallet->WalletLogPrintf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n-                                    this->GetHash().ToString());\n+            wallet.WalletLogPrintf(\"CWalletTx::GetAmounts: Unknown transaction type found, txid %s\\n\",\n+                                    wtx.GetHash().ToString());\n             address = CNoDestination();\n         }\n \n@@ -271,16 +269,21 @@ void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n \n }\n \n-bool CWallet::IsTrusted(const CWalletTx& wtx, std::set<uint256>& trusted_parents) const\n+bool CachedTxIsFromMe(const CWallet& wallet, const CWalletTx& wtx, const isminefilter& filter)\n+{\n+    return (CachedTxGetDebit(wallet, wtx, filter) > 0);\n+}\n+\n+bool CachedTxIsTrusted(const CWallet& wallet, const CWalletTx& wtx, std::set<uint256>& trusted_parents)\n {\n-    AssertLockHeld(cs_wallet);\n+    AssertLockHeld(wallet.cs_wallet);\n     // Quick answer in most cases\n-    if (!chain().checkFinalTx(*wtx.tx)) return false;\n-    int nDepth = wtx.GetDepthInMainChain();\n+    if (!wallet.chain().checkFinalTx(*wtx.tx)) return false;\n+    int nDepth = wallet.GetTxDepthInMainChain(wtx);\n     if (nDepth >= 1) return true;\n     if (nDepth < 0) return false;\n     // using wtx's cached debit\n-    if (!m_spend_zero_conf_change || !wtx.IsFromMe(ISMINE_ALL)) return false;\n+    if (!wallet.m_spend_zero_conf_change || !CachedTxIsFromMe(wallet, wtx, ISMINE_ALL)) return false;\n \n     // Don't trust unconfirmed transactions from us unless they are in the mempool.\n     if (!wtx.InMempool()) return false;\n@@ -289,41 +292,41 @@ bool CWallet::IsTrusted(const CWalletTx& wtx, std::set<uint256>& trusted_parents\n     for (const CTxIn& txin : wtx.tx->vin)\n     {\n         // Transactions not sent by us: not trusted\n-        const CWalletTx* parent = GetWalletTx(txin.prevout.hash);\n+        const CWalletTx* parent = wallet.GetWalletTx(txin.prevout.hash);\n         if (parent == nullptr) return false;\n         const CTxOut& parentOut = parent->tx->vout[txin.prevout.n];\n         // Check that this specific input being spent is trusted\n-        if (IsMine(parentOut) != ISMINE_SPENDABLE) return false;\n+        if (wallet.IsMine(parentOut) != ISMINE_SPENDABLE) return false;\n         // If we've already trusted this parent, continue\n         if (trusted_parents.count(parent->GetHash())) continue;\n         // Recurse to check that the parent is also trusted\n-        if (!IsTrusted(*parent, trusted_parents)) return false;\n+        if (!CachedTxIsTrusted(wallet, *parent, trusted_parents)) return false;\n         trusted_parents.insert(parent->GetHash());\n     }\n     return true;\n }\n \n-bool CWalletTx::IsTrusted() const\n+bool CachedTxIsTrusted(const CWallet& wallet, const CWalletTx& wtx)\n {\n     std::set<uint256> trusted_parents;\n-    LOCK(pwallet->cs_wallet);\n-    return pwallet->IsTrusted(*this, trusted_parents);\n+    LOCK(wallet.cs_wallet);\n+    return CachedTxIsTrusted(wallet, wtx, trusted_parents);\n }\n \n-CWallet::Balance CWallet::GetBalance(const int min_depth, bool avoid_reuse) const\n+Balance GetBalance(const CWallet& wallet, const int min_depth, bool avoid_reuse)\n {\n     Balance ret;\n     isminefilter reuse_filter = avoid_reuse ? ISMINE_NO : ISMINE_USED;\n     {\n-        LOCK(cs_wallet);\n+        LOCK(wallet.cs_wallet);\n         std::set<uint256> trusted_parents;\n-        for (const auto& entry : mapWallet)\n+        for (const auto& entry : wallet.mapWallet)\n         {\n             const CWalletTx& wtx = entry.second;\n-            const bool is_trusted{IsTrusted(wtx, trusted_parents)};\n-            const int tx_depth{wtx.GetDepthInMainChain()};\n-            const CAmount tx_credit_mine{wtx.GetAvailableCredit(/* fUseCache */ true, ISMINE_SPENDABLE | reuse_filter)};\n-            const CAmount tx_credit_watchonly{wtx.GetAvailableCredit(/* fUseCache */ true, ISMINE_WATCH_ONLY | reuse_filter)};\n+            const bool is_trusted{CachedTxIsTrusted(wallet, wtx, trusted_parents)};\n+            const int tx_depth{wallet.GetTxDepthInMainChain(wtx)};\n+            const CAmount tx_credit_mine{CachedTxGetAvailableCredit(wallet, wtx, /* fUseCache */ true, ISMINE_SPENDABLE | reuse_filter)};\n+            const CAmount tx_credit_watchonly{CachedTxGetAvailableCredit(wallet, wtx, /* fUseCache */ true, ISMINE_WATCH_ONLY | reuse_filter)};\n             if (is_trusted && tx_depth >= min_depth) {\n                 ret.m_mine_trusted += tx_credit_mine;\n                 ret.m_watchonly_trusted += tx_credit_watchonly;\n@@ -332,43 +335,43 @@ CWallet::Balance CWallet::GetBalance(const int min_depth, bool avoid_reuse) cons\n                 ret.m_mine_untrusted_pending += tx_credit_mine;\n                 ret.m_watchonly_untrusted_pending += tx_credit_watchonly;\n             }\n-            ret.m_mine_immature += wtx.GetImmatureCredit();\n-            ret.m_watchonly_immature += wtx.GetImmatureWatchOnlyCredit();\n+            ret.m_mine_immature += CachedTxGetImmatureCredit(wallet, wtx);\n+            ret.m_watchonly_immature += CachedTxGetImmatureWatchOnlyCredit(wallet, wtx);\n         }\n     }\n     return ret;\n }\n \n-std::map<CTxDestination, CAmount> CWallet::GetAddressBalances() const\n+std::map<CTxDestination, CAmount> GetAddressBalances(const CWallet& wallet)\n {\n     std::map<CTxDestination, CAmount> balances;\n \n     {\n-        LOCK(cs_wallet);\n+        LOCK(wallet.cs_wallet);\n         std::set<uint256> trusted_parents;\n-        for (const auto& walletEntry : mapWallet)\n+        for (const auto& walletEntry : wallet.mapWallet)\n         {\n             const CWalletTx& wtx = walletEntry.second;\n \n-            if (!IsTrusted(wtx, trusted_parents))\n+            if (!CachedTxIsTrusted(wallet, wtx, trusted_parents))\n                 continue;\n \n-            if (wtx.IsImmatureCoinBase())\n+            if (wallet.IsTxImmatureCoinBase(wtx))\n                 continue;\n \n-            int nDepth = wtx.GetDepthInMainChain();\n-            if (nDepth < (wtx.IsFromMe(ISMINE_ALL) ? 0 : 1))\n+            int nDepth = wallet.GetTxDepthInMainChain(wtx);\n+            if (nDepth < (CachedTxIsFromMe(wallet, wtx, ISMINE_ALL) ? 0 : 1))\n                 continue;\n \n             for (unsigned int i = 0; i < wtx.tx->vout.size(); i++)\n             {\n                 CTxDestination addr;\n-                if (!IsMine(wtx.tx->vout[i]))\n+                if (!wallet.IsMine(wtx.tx->vout[i]))\n                     continue;\n                 if(!ExtractDestination(wtx.tx->vout[i].scriptPubKey, addr))\n                     continue;\n \n-                CAmount n = IsSpent(walletEntry.first, i) ? 0 : wtx.tx->vout[i].nValue;\n+                CAmount n = wallet.IsSpent(walletEntry.first, i) ? 0 : wtx.tx->vout[i].nValue;\n                 balances[addr] += n;\n             }\n         }\n@@ -377,13 +380,13 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances() const\n     return balances;\n }\n \n-std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings() const\n+std::set< std::set<CTxDestination> > GetAddressGroupings(const CWallet& wallet)\n {\n-    AssertLockHeld(cs_wallet);\n+    AssertLockHeld(wallet.cs_wallet);\n     std::set< std::set<CTxDestination> > groupings;\n     std::set<CTxDestination> grouping;\n \n-    for (const auto& walletEntry : mapWallet)\n+    for (const auto& walletEntry : wallet.mapWallet)\n     {\n         const CWalletTx& wtx = walletEntry.second;\n \n@@ -394,9 +397,9 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings() const\n             for (const CTxIn& txin : wtx.tx->vin)\n             {\n                 CTxDestination address;\n-                if(!IsMine(txin)) /* If this input isn't mine, ignore it */\n+                if(!InputIsMine(wallet, txin)) /* If this input isn't mine, ignore it */\n                     continue;\n-                if(!ExtractDestination(mapWallet.at(txin.prevout.hash).tx->vout[txin.prevout.n].scriptPubKey, address))\n+                if(!ExtractDestination(wallet.mapWallet.at(txin.prevout.hash).tx->vout[txin.prevout.n].scriptPubKey, address))\n                     continue;\n                 grouping.insert(address);\n                 any_mine = true;\n@@ -406,7 +409,7 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings() const\n             if (any_mine)\n             {\n                for (const CTxOut& txout : wtx.tx->vout)\n-                   if (IsChange(txout))\n+                   if (OutputIsChange(wallet, txout))\n                    {\n                        CTxDestination txoutAddr;\n                        if(!ExtractDestination(txout.scriptPubKey, txoutAddr))\n@@ -423,7 +426,7 @@ std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings() const\n \n         // group lone addrs by themselves\n         for (const auto& txout : wtx.tx->vout)\n-            if (IsMine(txout))\n+            if (wallet.IsMine(txout))\n             {\n                 CTxDestination address;\n                 if(!ExtractDestination(txout.scriptPubKey, address))"
      },
      {
        "sha": "b4b311636b626b27e2e0fa034b1e39a155cb392f",
        "filename": "src/wallet/receive.h",
        "status": "modified",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/receive.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/receive.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/receive.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -10,11 +10,55 @@\n #include <wallet/transaction.h>\n #include <wallet/wallet.h>\n \n+isminetype InputIsMine(const CWallet& wallet, const CTxIn& txin) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+\n+/** Returns whether all of the inputs match the filter */\n+bool AllInputsMine(const CWallet& wallet, const CTransaction& tx, const isminefilter& filter);\n+\n+CAmount OutputGetCredit(const CWallet& wallet, const CTxOut& txout, const isminefilter& filter);\n+CAmount TxGetCredit(const CWallet& wallet, const CTransaction& tx, const isminefilter& filter);\n+\n+bool ScriptIsChange(const CWallet& wallet, const CScript& script) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+bool OutputIsChange(const CWallet& wallet, const CTxOut& txout) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+CAmount OutputGetChange(const CWallet& wallet, const CTxOut& txout) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+CAmount TxGetChange(const CWallet& wallet, const CTransaction& tx);\n+\n+CAmount CachedTxGetCredit(const CWallet& wallet, const CWalletTx& wtx, const isminefilter& filter);\n+//! filter decides which addresses will count towards the debit\n+CAmount CachedTxGetDebit(const CWallet& wallet, const CWalletTx& wtx, const isminefilter& filter);\n+CAmount CachedTxGetChange(const CWallet& wallet, const CWalletTx& wtx);\n+CAmount CachedTxGetImmatureCredit(const CWallet& wallet, const CWalletTx& wtx, bool fUseCache = true);\n+CAmount CachedTxGetImmatureWatchOnlyCredit(const CWallet& wallet, const CWalletTx& wtx, const bool fUseCache = true);\n+// TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n+// annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The\n+// annotation \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid\n+// having to resolve the issue of member access into incomplete type CWallet.\n+CAmount CachedTxGetAvailableCredit(const CWallet& wallet, const CWalletTx& wtx, bool fUseCache = true, const isminefilter& filter = ISMINE_SPENDABLE) NO_THREAD_SAFETY_ANALYSIS;\n struct COutputEntry\n {\n     CTxDestination destination;\n     CAmount amount;\n     int vout;\n };\n+void CachedTxGetAmounts(const CWallet& wallet, const CWalletTx& wtx,\n+                        std::list<COutputEntry>& listReceived,\n+                        std::list<COutputEntry>& listSent,\n+                        CAmount& nFee, const isminefilter& filter);\n+bool CachedTxIsFromMe(const CWallet& wallet, const CWalletTx& wtx, const isminefilter& filter);\n+bool CachedTxIsTrusted(const CWallet& wallet, const CWalletTx& wtx, std::set<uint256>& trusted_parents) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+bool CachedTxIsTrusted(const CWallet& wallet, const CWalletTx& wtx);\n+\n+struct Balance {\n+    CAmount m_mine_trusted{0};           //!< Trusted, at depth=GetBalance.min_depth or more\n+    CAmount m_mine_untrusted_pending{0}; //!< Untrusted, but in mempool (pending)\n+    CAmount m_mine_immature{0};          //!< Immature coinbases in the main chain\n+    CAmount m_watchonly_trusted{0};\n+    CAmount m_watchonly_untrusted_pending{0};\n+    CAmount m_watchonly_immature{0};\n+};\n+Balance GetBalance(const CWallet& wallet, int min_depth = 0, bool avoid_reuse = true);\n+\n+std::map<CTxDestination, CAmount> GetAddressBalances(const CWallet& wallet);\n+std::set<std::set<CTxDestination>> GetAddressGroupings(const CWallet& wallet) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n \n #endif // BITCOIN_WALLET_RECEIVE_H"
      },
      {
        "sha": "e922f4ede9e51e0b4f6c59dbc813b4b01649af9e",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 32,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -31,7 +31,9 @@\n #include <wallet/context.h>\n #include <wallet/feebumper.h>\n #include <wallet/load.h>\n+#include <wallet/receive.h>\n #include <wallet/rpcwallet.h>\n+#include <wallet/spend.h>\n #include <wallet/wallet.h>\n #include <wallet/walletdb.h>\n #include <wallet/walletutil.h>\n@@ -147,9 +149,10 @@ LegacyScriptPubKeyMan& EnsureLegacyScriptPubKeyMan(CWallet& wallet, bool also_cr\n     return *spk_man;\n }\n \n-static void WalletTxToJSON(interfaces::Chain& chain, const CWalletTx& wtx, UniValue& entry)\n+static void WalletTxToJSON(const CWallet& wallet, const CWalletTx& wtx, UniValue& entry)\n {\n-    int confirms = wtx.GetDepthInMainChain();\n+    interfaces::Chain& chain = wallet.chain();\n+    int confirms = wallet.GetTxDepthInMainChain(wtx);\n     entry.pushKV(\"confirmations\", confirms);\n     if (wtx.IsCoinBase())\n         entry.pushKV(\"generated\", true);\n@@ -162,12 +165,12 @@ static void WalletTxToJSON(interfaces::Chain& chain, const CWalletTx& wtx, UniVa\n         CHECK_NONFATAL(chain.findBlock(wtx.m_confirm.hashBlock, FoundBlock().time(block_time)));\n         entry.pushKV(\"blocktime\", block_time);\n     } else {\n-        entry.pushKV(\"trusted\", wtx.IsTrusted());\n+        entry.pushKV(\"trusted\", CachedTxIsTrusted(wallet, wtx));\n     }\n     uint256 hash = wtx.GetHash();\n     entry.pushKV(\"txid\", hash.GetHex());\n     UniValue conflicts(UniValue::VARR);\n-    for (const uint256& conflict : wtx.GetConflicts())\n+    for (const uint256& conflict : wallet.GetTxConflicts(wtx))\n         conflicts.push_back(conflict.GetHex());\n     entry.pushKV(\"walletconflicts\", conflicts);\n     entry.pushKV(\"time\", wtx.GetTxTime());\n@@ -423,7 +426,7 @@ UniValue SendMoney(CWallet& wallet, const CCoinControl &coin_control, std::vecto\n     bilingual_str error;\n     CTransactionRef tx;\n     FeeCalculation fee_calc_out;\n-    const bool fCreated = wallet.CreateTransaction(recipients, tx, nFeeRequired, nChangePosRet, error, coin_control, fee_calc_out, true);\n+    const bool fCreated = CreateTransaction(wallet, recipients, tx, nFeeRequired, nChangePosRet, error, coin_control, fee_calc_out, true);\n     if (!fCreated) {\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, error.original);\n     }\n@@ -576,8 +579,8 @@ static RPCHelpMan listaddressgroupings()\n     LOCK(pwallet->cs_wallet);\n \n     UniValue jsonGroupings(UniValue::VARR);\n-    std::map<CTxDestination, CAmount> balances = pwallet->GetAddressBalances();\n-    for (const std::set<CTxDestination>& grouping : pwallet->GetAddressGroupings()) {\n+    std::map<CTxDestination, CAmount> balances = GetAddressBalances(*pwallet);\n+    for (const std::set<CTxDestination>& grouping : GetAddressGroupings(*pwallet)) {\n         UniValue jsonGrouping(UniValue::VARR);\n         for (const CTxDestination& address : grouping)\n         {\n@@ -686,7 +689,7 @@ static CAmount GetReceived(const CWallet& wallet, const UniValue& params, bool b\n     CAmount amount = 0;\n     for (const std::pair<const uint256, CWalletTx>& wtx_pair : wallet.mapWallet) {\n         const CWalletTx& wtx = wtx_pair.second;\n-        if (wtx.IsCoinBase() || !wallet.chain().checkFinalTx(*wtx.tx) || wtx.GetDepthInMainChain() < min_depth) {\n+        if (wtx.IsCoinBase() || !wallet.chain().checkFinalTx(*wtx.tx) || wallet.GetTxDepthInMainChain(wtx) < min_depth) {\n             continue;\n         }\n \n@@ -826,7 +829,7 @@ static RPCHelpMan getbalance()\n \n     bool avoid_reuse = GetAvoidReuseFlag(*pwallet, request.params[3]);\n \n-    const auto bal = pwallet->GetBalance(min_depth, avoid_reuse);\n+    const auto bal = GetBalance(*pwallet, min_depth, avoid_reuse);\n \n     return ValueFromAmount(bal.m_mine_trusted + (include_watchonly ? bal.m_watchonly_trusted : 0));\n },\n@@ -851,7 +854,7 @@ static RPCHelpMan getunconfirmedbalance()\n \n     LOCK(pwallet->cs_wallet);\n \n-    return ValueFromAmount(pwallet->GetBalance().m_mine_untrusted_pending);\n+    return ValueFromAmount(GetBalance(*pwallet).m_mine_untrusted_pending);\n },\n     };\n }\n@@ -1085,7 +1088,7 @@ static UniValue ListReceived(const CWallet& wallet, const UniValue& params, bool\n             continue;\n         }\n \n-        int nDepth = wtx.GetDepthInMainChain();\n+        int nDepth = wallet.GetTxDepthInMainChain(wtx);\n         if (nDepth < nMinDepth)\n             continue;\n \n@@ -1310,9 +1313,9 @@ static void ListTransactions(const CWallet& wallet, const CWalletTx& wtx, int nM\n     std::list<COutputEntry> listReceived;\n     std::list<COutputEntry> listSent;\n \n-    wtx.GetAmounts(listReceived, listSent, nFee, filter_ismine);\n+    CachedTxGetAmounts(wallet, wtx, listReceived, listSent, nFee, filter_ismine);\n \n-    bool involvesWatchonly = wtx.IsFromMe(ISMINE_WATCH_ONLY);\n+    bool involvesWatchonly = CachedTxIsFromMe(wallet, wtx, ISMINE_WATCH_ONLY);\n \n     // Sent\n     if (!filter_label)\n@@ -1333,14 +1336,14 @@ static void ListTransactions(const CWallet& wallet, const CWalletTx& wtx, int nM\n             entry.pushKV(\"vout\", s.vout);\n             entry.pushKV(\"fee\", ValueFromAmount(-nFee));\n             if (fLong)\n-                WalletTxToJSON(wallet.chain(), wtx, entry);\n+                WalletTxToJSON(wallet, wtx, entry);\n             entry.pushKV(\"abandoned\", wtx.isAbandoned());\n             ret.push_back(entry);\n         }\n     }\n \n     // Received\n-    if (listReceived.size() > 0 && wtx.GetDepthInMainChain() >= nMinDepth) {\n+    if (listReceived.size() > 0 && wallet.GetTxDepthInMainChain(wtx) >= nMinDepth) {\n         for (const COutputEntry& r : listReceived)\n         {\n             std::string label;\n@@ -1358,9 +1361,9 @@ static void ListTransactions(const CWallet& wallet, const CWalletTx& wtx, int nM\n             MaybePushAddress(entry, r.destination);\n             if (wtx.IsCoinBase())\n             {\n-                if (wtx.GetDepthInMainChain() < 1)\n+                if (wallet.GetTxDepthInMainChain(wtx) < 1)\n                     entry.pushKV(\"category\", \"orphan\");\n-                else if (wtx.IsImmatureCoinBase())\n+                else if (wallet.IsTxImmatureCoinBase(wtx))\n                     entry.pushKV(\"category\", \"immature\");\n                 else\n                     entry.pushKV(\"category\", \"generate\");\n@@ -1375,7 +1378,7 @@ static void ListTransactions(const CWallet& wallet, const CWalletTx& wtx, int nM\n             }\n             entry.pushKV(\"vout\", r.vout);\n             if (fLong)\n-                WalletTxToJSON(wallet.chain(), wtx, entry);\n+                WalletTxToJSON(wallet, wtx, entry);\n             ret.push_back(entry);\n         }\n     }\n@@ -1615,7 +1618,7 @@ static RPCHelpMan listsinceblock()\n     for (const std::pair<const uint256, CWalletTx>& pairWtx : wallet.mapWallet) {\n         const CWalletTx& tx = pairWtx.second;\n \n-        if (depth == -1 || abs(tx.GetDepthInMainChain()) < depth) {\n+        if (depth == -1 || abs(wallet.GetTxDepthInMainChain(tx)) < depth) {\n             ListTransactions(wallet, tx, 0, true, transactions, filter, nullptr /* filter_label */);\n         }\n     }\n@@ -1736,16 +1739,16 @@ static RPCHelpMan gettransaction()\n     }\n     const CWalletTx& wtx = it->second;\n \n-    CAmount nCredit = wtx.GetCredit(filter);\n-    CAmount nDebit = wtx.GetDebit(filter);\n+    CAmount nCredit = CachedTxGetCredit(*pwallet, wtx, filter);\n+    CAmount nDebit = CachedTxGetDebit(*pwallet, wtx, filter);\n     CAmount nNet = nCredit - nDebit;\n-    CAmount nFee = (wtx.IsFromMe(filter) ? wtx.tx->GetValueOut() - nDebit : 0);\n+    CAmount nFee = (CachedTxIsFromMe(*pwallet, wtx, filter) ? wtx.tx->GetValueOut() - nDebit : 0);\n \n     entry.pushKV(\"amount\", ValueFromAmount(nNet - nFee));\n-    if (wtx.IsFromMe(filter))\n+    if (CachedTxIsFromMe(*pwallet, wtx, filter))\n         entry.pushKV(\"fee\", ValueFromAmount(nFee));\n \n-    WalletTxToJSON(pwallet->chain(), wtx, entry);\n+    WalletTxToJSON(*pwallet, wtx, entry);\n \n     UniValue details(UniValue::VARR);\n     ListTransactions(*pwallet, wtx, 0, false, details, filter, nullptr /* filter_label */);\n@@ -2384,7 +2387,7 @@ static RPCHelpMan getbalances()\n \n     LOCK(wallet.cs_wallet);\n \n-    const auto bal = wallet.GetBalance();\n+    const auto bal = GetBalance(wallet);\n     UniValue balances{UniValue::VOBJ};\n     {\n         UniValue balances_mine{UniValue::VOBJ};\n@@ -2394,7 +2397,7 @@ static RPCHelpMan getbalances()\n         if (wallet.IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE)) {\n             // If the AVOID_REUSE flag is set, bal has been set to just the un-reused address balance. Get\n             // the total balance, and then subtract bal to get the reused address balance.\n-            const auto full_bal = wallet.GetBalance(0, false);\n+            const auto full_bal = GetBalance(wallet, 0, false);\n             balances_mine.pushKV(\"used\", ValueFromAmount(full_bal.m_mine_trusted + full_bal.m_mine_untrusted_pending - bal.m_mine_trusted - bal.m_mine_untrusted_pending));\n         }\n         balances.pushKV(\"mine\", balances_mine);\n@@ -2462,7 +2465,7 @@ static RPCHelpMan getwalletinfo()\n     UniValue obj(UniValue::VOBJ);\n \n     size_t kpExternalSize = pwallet->KeypoolCountExternalKeys();\n-    const auto bal = pwallet->GetBalance();\n+    const auto bal = GetBalance(*pwallet);\n     int64_t kp_oldest = pwallet->GetOldestKeyPoolTime();\n     obj.pushKV(\"walletname\", pwallet->GetName());\n     obj.pushKV(\"walletversion\", pwallet->GetVersion());\n@@ -3058,7 +3061,7 @@ static RPCHelpMan listunspent()\n         cctl.m_max_depth = nMaxDepth;\n         cctl.m_include_unsafe_inputs = include_unsafe;\n         LOCK(pwallet->cs_wallet);\n-        pwallet->AvailableCoins(vecOutputs, &cctl, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount);\n+        AvailableCoins(*pwallet, vecOutputs, &cctl, nMinimumAmount, nMaximumAmount, nMinimumSumAmount, nMaximumCount);\n     }\n \n     LOCK(pwallet->cs_wallet);\n@@ -3274,7 +3277,7 @@ void FundTransaction(CWallet& wallet, CMutableTransaction& tx, CAmount& fee_out,\n \n     bilingual_str error;\n \n-    if (!wallet.FundTransaction(tx, fee_out, change_position, error, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n+    if (!FundTransaction(wallet, tx, fee_out, change_position, error, lockUnspents, setSubtractFeeFromOutputs, coinControl)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, error.original);\n     }\n }\n@@ -3959,7 +3962,7 @@ RPCHelpMan getaddressinfo()\n     UniValue detail = DescribeWalletAddress(*pwallet, dest);\n     ret.pushKVs(detail);\n \n-    ret.pushKV(\"ischange\", pwallet->IsChange(scriptPubKey));\n+    ret.pushKV(\"ischange\", ScriptIsChange(*pwallet, scriptPubKey));\n \n     ScriptPubKeyMan* spk_man = pwallet->GetScriptPubKeyMan(scriptPubKey);\n     if (spk_man) {\n@@ -4647,10 +4650,11 @@ static RPCHelpMan upgradewallet()\n #ifdef ENABLE_EXTERNAL_SIGNER\n static RPCHelpMan walletdisplayaddress()\n {\n-    return RPCHelpMan{\"walletdisplayaddress\",\n+    return RPCHelpMan{\n+        \"walletdisplayaddress\",\n         \"Display address on an external signer for verification.\",\n         {\n-            {\"address\",     RPCArg::Type::STR, RPCArg::Optional::NO, /* default_val */ \"\", \"bitcoin address to display\"},\n+            {\"address\", RPCArg::Type::STR, RPCArg::Optional::NO, \"bitcoin address to display\"},\n         },\n         RPCResult{\n             RPCResult::Type::OBJ,\"\",\"\","
      },
      {
        "sha": "ef746387513737421af0fc0dbc2096d107ea9f02",
        "filename": "src/wallet/scriptpubkeyman.h",
        "status": "modified",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/scriptpubkeyman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/scriptpubkeyman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/scriptpubkeyman.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -148,17 +148,6 @@ class CKeyPool\n     }\n };\n \n-class KeyIDHasher\n-{\n-public:\n-    KeyIDHasher() {}\n-\n-    size_t operator()(const CKeyID& id) const\n-    {\n-        return id.GetUint64(0);\n-    }\n-};\n-\n /*\n  * A class implementing ScriptPubKeyMan manages some (or all) scriptPubKeys used in a wallet.\n  * It contains the scripts and keys related to the scriptPubKeys it manages."
      },
      {
        "sha": "4a7a26898227d96e646816f124ffd1790c2c828c",
        "filename": "src/wallet/spend.cpp",
        "status": "modified",
        "additions": 131,
        "deletions": 99,
        "changes": 230,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/spend.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/spend.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -21,6 +21,11 @@ using interfaces::FoundBlock;\n \n static constexpr size_t OUTPUT_GROUP_MAX_ENTRIES{100};\n \n+int GetTxSpendSize(const CWallet& wallet, const CWalletTx& wtx, unsigned int out, bool use_max_sig)\n+{\n+    return CalculateMaximumSignedInputSize(wtx.tx->vout[out], &wallet, use_max_sig);\n+}\n+\n std::string COutput::ToString() const\n {\n     return strprintf(\"COutput(%s, %d, %d) [%s]\", tx->GetHash().ToString(), i, nDepth, FormatMoney(tx->tx->vout[i].nValue));\n@@ -64,33 +69,33 @@ TxSize CalculateMaximumSignedTxSize(const CTransaction &tx, const CWallet *walle\n     return CalculateMaximumSignedTxSize(tx, wallet, txouts, use_max_sig);\n }\n \n-void CWallet::AvailableCoins(std::vector<COutput>& vCoins, const CCoinControl* coinControl, const CAmount& nMinimumAmount, const CAmount& nMaximumAmount, const CAmount& nMinimumSumAmount, const uint64_t nMaximumCount) const\n+void AvailableCoins(const CWallet& wallet, std::vector<COutput>& vCoins, const CCoinControl* coinControl, const CAmount& nMinimumAmount, const CAmount& nMaximumAmount, const CAmount& nMinimumSumAmount, const uint64_t nMaximumCount)\n {\n-    AssertLockHeld(cs_wallet);\n+    AssertLockHeld(wallet.cs_wallet);\n \n     vCoins.clear();\n     CAmount nTotal = 0;\n     // Either the WALLET_FLAG_AVOID_REUSE flag is not set (in which case we always allow), or we default to avoiding, and only in the case where\n     // a coin control object is provided, and has the avoid address reuse flag set to false, do we allow already used addresses\n-    bool allow_used_addresses = !IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE) || (coinControl && !coinControl->m_avoid_address_reuse);\n+    bool allow_used_addresses = !wallet.IsWalletFlagSet(WALLET_FLAG_AVOID_REUSE) || (coinControl && !coinControl->m_avoid_address_reuse);\n     const int min_depth = {coinControl ? coinControl->m_min_depth : DEFAULT_MIN_DEPTH};\n     const int max_depth = {coinControl ? coinControl->m_max_depth : DEFAULT_MAX_DEPTH};\n     const bool only_safe = {coinControl ? !coinControl->m_include_unsafe_inputs : true};\n \n     std::set<uint256> trusted_parents;\n-    for (const auto& entry : mapWallet)\n+    for (const auto& entry : wallet.mapWallet)\n     {\n         const uint256& wtxid = entry.first;\n         const CWalletTx& wtx = entry.second;\n \n-        if (!chain().checkFinalTx(*wtx.tx)) {\n+        if (!wallet.chain().checkFinalTx(*wtx.tx)) {\n             continue;\n         }\n \n-        if (wtx.IsImmatureCoinBase())\n+        if (wallet.IsTxImmatureCoinBase(wtx))\n             continue;\n \n-        int nDepth = wtx.GetDepthInMainChain();\n+        int nDepth = wallet.GetTxDepthInMainChain(wtx);\n         if (nDepth < 0)\n             continue;\n \n@@ -99,7 +104,7 @@ void CWallet::AvailableCoins(std::vector<COutput>& vCoins, const CCoinControl* c\n         if (nDepth == 0 && !wtx.InMempool())\n             continue;\n \n-        bool safeTx = IsTrusted(wtx, trusted_parents);\n+        bool safeTx = CachedTxIsTrusted(wallet, wtx, trusted_parents);\n \n         // We should not consider coins from transactions that are replacing\n         // other transactions.\n@@ -152,28 +157,28 @@ void CWallet::AvailableCoins(std::vector<COutput>& vCoins, const CCoinControl* c\n             if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs && !coinControl->IsSelected(COutPoint(entry.first, i)))\n                 continue;\n \n-            if (IsLockedCoin(entry.first, i))\n+            if (wallet.IsLockedCoin(entry.first, i))\n                 continue;\n \n-            if (IsSpent(wtxid, i))\n+            if (wallet.IsSpent(wtxid, i))\n                 continue;\n \n-            isminetype mine = IsMine(wtx.tx->vout[i]);\n+            isminetype mine = wallet.IsMine(wtx.tx->vout[i]);\n \n             if (mine == ISMINE_NO) {\n                 continue;\n             }\n \n-            if (!allow_used_addresses && IsSpentKey(wtxid, i)) {\n+            if (!allow_used_addresses && wallet.IsSpentKey(wtxid, i)) {\n                 continue;\n             }\n \n-            std::unique_ptr<SigningProvider> provider = GetSolvingProvider(wtx.tx->vout[i].scriptPubKey);\n+            std::unique_ptr<SigningProvider> provider = wallet.GetSolvingProvider(wtx.tx->vout[i].scriptPubKey);\n \n             bool solvable = provider ? IsSolvable(*provider, wtx.tx->vout[i].scriptPubKey) : false;\n             bool spendable = ((mine & ISMINE_SPENDABLE) != ISMINE_NO) || (((mine & ISMINE_WATCH_ONLY) != ISMINE_NO) && (coinControl && coinControl->fAllowWatchOnly && solvable));\n \n-            vCoins.push_back(COutput(&wtx, i, nDepth, spendable, solvable, safeTx, (coinControl && coinControl->fAllowWatchOnly)));\n+            vCoins.push_back(COutput(wallet, wtx, i, nDepth, spendable, solvable, safeTx, (coinControl && coinControl->fAllowWatchOnly)));\n \n             // Checks the sum amount of all UTXO's.\n             if (nMinimumSumAmount != MAX_MONEY) {\n@@ -192,13 +197,13 @@ void CWallet::AvailableCoins(std::vector<COutput>& vCoins, const CCoinControl* c\n     }\n }\n \n-CAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n+CAmount GetAvailableBalance(const CWallet& wallet, const CCoinControl* coinControl)\n {\n-    LOCK(cs_wallet);\n+    LOCK(wallet.cs_wallet);\n \n     CAmount balance = 0;\n     std::vector<COutput> vCoins;\n-    AvailableCoins(vCoins, coinControl);\n+    AvailableCoins(wallet, vCoins, coinControl);\n     for (const COutput& out : vCoins) {\n         if (out.fSpendable) {\n             balance += out.tx->tx->vout[out.i].nValue;\n@@ -207,16 +212,16 @@ CAmount CWallet::GetAvailableBalance(const CCoinControl* coinControl) const\n     return balance;\n }\n \n-const CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int output) const\n+const CTxOut& FindNonChangeParentOutput(const CWallet& wallet, const CTransaction& tx, int output)\n {\n-    AssertLockHeld(cs_wallet);\n+    AssertLockHeld(wallet.cs_wallet);\n     const CTransaction* ptx = &tx;\n     int n = output;\n-    while (IsChange(ptx->vout[n]) && ptx->vin.size() > 0) {\n+    while (OutputIsChange(wallet, ptx->vout[n]) && ptx->vin.size() > 0) {\n         const COutPoint& prevout = ptx->vin[0].prevout;\n-        auto it = mapWallet.find(prevout.hash);\n-        if (it == mapWallet.end() || it->second.tx->vout.size() <= prevout.n ||\n-            !IsMine(it->second.tx->vout[prevout.n])) {\n+        auto it = wallet.mapWallet.find(prevout.hash);\n+        if (it == wallet.mapWallet.end() || it->second.tx->vout.size() <= prevout.n ||\n+            !wallet.IsMine(it->second.tx->vout[prevout.n])) {\n             break;\n         }\n         ptx = it->second.tx.get();\n@@ -225,39 +230,39 @@ const CTxOut& CWallet::FindNonChangeParentOutput(const CTransaction& tx, int out\n     return ptx->vout[n];\n }\n \n-std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n+std::map<CTxDestination, std::vector<COutput>> ListCoins(const CWallet& wallet)\n {\n-    AssertLockHeld(cs_wallet);\n+    AssertLockHeld(wallet.cs_wallet);\n \n     std::map<CTxDestination, std::vector<COutput>> result;\n     std::vector<COutput> availableCoins;\n \n-    AvailableCoins(availableCoins);\n+    AvailableCoins(wallet, availableCoins);\n \n     for (const COutput& coin : availableCoins) {\n         CTxDestination address;\n-        if ((coin.fSpendable || (IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && coin.fSolvable)) &&\n-            ExtractDestination(FindNonChangeParentOutput(*coin.tx->tx, coin.i).scriptPubKey, address)) {\n+        if ((coin.fSpendable || (wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS) && coin.fSolvable)) &&\n+            ExtractDestination(FindNonChangeParentOutput(wallet, *coin.tx->tx, coin.i).scriptPubKey, address)) {\n             result[address].emplace_back(std::move(coin));\n         }\n     }\n \n     std::vector<COutPoint> lockedCoins;\n-    ListLockedCoins(lockedCoins);\n+    wallet.ListLockedCoins(lockedCoins);\n     // Include watch-only for LegacyScriptPubKeyMan wallets without private keys\n-    const bool include_watch_only = GetLegacyScriptPubKeyMan() && IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS);\n+    const bool include_watch_only = wallet.GetLegacyScriptPubKeyMan() && wallet.IsWalletFlagSet(WALLET_FLAG_DISABLE_PRIVATE_KEYS);\n     const isminetype is_mine_filter = include_watch_only ? ISMINE_WATCH_ONLY : ISMINE_SPENDABLE;\n     for (const COutPoint& output : lockedCoins) {\n-        auto it = mapWallet.find(output.hash);\n-        if (it != mapWallet.end()) {\n-            int depth = it->second.GetDepthInMainChain();\n+        auto it = wallet.mapWallet.find(output.hash);\n+        if (it != wallet.mapWallet.end()) {\n+            int depth = wallet.GetTxDepthInMainChain(it->second);\n             if (depth >= 0 && output.n < it->second.tx->vout.size() &&\n-                IsMine(it->second.tx->vout[output.n]) == is_mine_filter\n+                wallet.IsMine(it->second.tx->vout[output.n]) == is_mine_filter\n             ) {\n                 CTxDestination address;\n-                if (ExtractDestination(FindNonChangeParentOutput(*it->second.tx, output.n).scriptPubKey, address)) {\n+                if (ExtractDestination(FindNonChangeParentOutput(wallet, *it->second.tx, output.n).scriptPubKey, address)) {\n                     result[address].emplace_back(\n-                        &it->second, output.n, depth, true /* spendable */, true /* solvable */, false /* safe */);\n+                        wallet, it->second, output.n, depth, true /* spendable */, true /* solvable */, false /* safe */);\n                 }\n             }\n         }\n@@ -266,7 +271,7 @@ std::map<CTxDestination, std::vector<COutput>> CWallet::ListCoins() const\n     return result;\n }\n \n-std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outputs, const CoinSelectionParams& coin_sel_params, const CoinEligibilityFilter& filter, bool positive_only) const\n+std::vector<OutputGroup> GroupOutputs(const CWallet& wallet, const std::vector<COutput>& outputs, const CoinSelectionParams& coin_sel_params, const CoinEligibilityFilter& filter, bool positive_only)\n {\n     std::vector<OutputGroup> groups_out;\n \n@@ -277,12 +282,12 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n             if (!output.fSpendable) continue;\n \n             size_t ancestors, descendants;\n-            chain().getTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n+            wallet.chain().getTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n             CInputCoin input_coin = output.GetInputCoin();\n \n             // Make an OutputGroup containing just this output\n             OutputGroup group{coin_sel_params};\n-            group.Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n+            group.Insert(input_coin, output.nDepth, CachedTxIsFromMe(wallet, *output.tx, ISMINE_ALL), ancestors, descendants, positive_only);\n \n             // Check the OutputGroup's eligibility. Only add the eligible ones.\n             if (positive_only && group.GetSelectionAmount() <= 0) continue;\n@@ -303,7 +308,7 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n         if (!output.fSpendable) continue;\n \n         size_t ancestors, descendants;\n-        chain().getTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n+        wallet.chain().getTransactionAncestry(output.tx->GetHash(), ancestors, descendants);\n         CInputCoin input_coin = output.GetInputCoin();\n         CScript spk = input_coin.txout.scriptPubKey;\n \n@@ -327,7 +332,7 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n         }\n \n         // Add the input_coin to group\n-        group->Insert(input_coin, output.nDepth, output.tx->IsFromMe(ISMINE_ALL), ancestors, descendants, positive_only);\n+        group->Insert(input_coin, output.nDepth, CachedTxIsFromMe(wallet, *output.tx, ISMINE_ALL), ancestors, descendants, positive_only);\n     }\n \n     // Now we go through the entire map and pull out the OutputGroups\n@@ -352,25 +357,52 @@ std::vector<OutputGroup> CWallet::GroupOutputs(const std::vector<COutput>& outpu\n     return groups_out;\n }\n \n-bool CWallet::AttemptSelection(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n-                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params) const\n+bool AttemptSelection(const CWallet& wallet, const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n+                                 std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params)\n {\n     setCoinsRet.clear();\n     nValueRet = 0;\n+    // Vector of results for use with waste calculation\n+    // In order: calculated waste, selected inputs, selected input value (sum of input values)\n+    // TODO: Use a struct representing the selection result\n+    std::vector<std::tuple<CAmount, std::set<CInputCoin>, CAmount>> results;\n \n     // Note that unlike KnapsackSolver, we do not include the fee for creating a change output as BnB will not create a change output.\n-    std::vector<OutputGroup> positive_groups = GroupOutputs(coins, coin_selection_params, eligibility_filter, true /* positive_only */);\n-    if (SelectCoinsBnB(positive_groups, nTargetValue, coin_selection_params.m_cost_of_change, setCoinsRet, nValueRet)) {\n-        return true;\n+    std::vector<OutputGroup> positive_groups = GroupOutputs(wallet, coins, coin_selection_params, eligibility_filter, true /* positive_only */);\n+    std::set<CInputCoin> bnb_coins;\n+    CAmount bnb_value;\n+    if (SelectCoinsBnB(positive_groups, nTargetValue, coin_selection_params.m_cost_of_change, bnb_coins, bnb_value)) {\n+        const auto waste = GetSelectionWaste(bnb_coins, /* cost of change */ CAmount(0), nTargetValue, !coin_selection_params.m_subtract_fee_outputs);\n+        results.emplace_back(std::make_tuple(waste, std::move(bnb_coins), bnb_value));\n     }\n+\n     // The knapsack solver has some legacy behavior where it will spend dust outputs. We retain this behavior, so don't filter for positive only here.\n-    std::vector<OutputGroup> all_groups = GroupOutputs(coins, coin_selection_params, eligibility_filter, false /* positive_only */);\n+    std::vector<OutputGroup> all_groups = GroupOutputs(wallet, coins, coin_selection_params, eligibility_filter, false /* positive_only */);\n     // While nTargetValue includes the transaction fees for non-input things, it does not include the fee for creating a change output.\n     // So we need to include that for KnapsackSolver as well, as we are expecting to create a change output.\n-    return KnapsackSolver(nTargetValue + coin_selection_params.m_change_fee, all_groups, setCoinsRet, nValueRet);\n+    std::set<CInputCoin> knapsack_coins;\n+    CAmount knapsack_value;\n+    if (KnapsackSolver(nTargetValue + coin_selection_params.m_change_fee, all_groups, knapsack_coins, knapsack_value)) {\n+        const auto waste = GetSelectionWaste(knapsack_coins, coin_selection_params.m_cost_of_change, nTargetValue + coin_selection_params.m_change_fee, !coin_selection_params.m_subtract_fee_outputs);\n+        results.emplace_back(std::make_tuple(waste, std::move(knapsack_coins), knapsack_value));\n+    }\n+\n+    if (results.size() == 0) {\n+        // No solution found\n+        return false;\n+    }\n+\n+    // Choose the result with the least waste\n+    // If the waste is the same, choose the one which spends more inputs.\n+    const auto& best_result = std::min_element(results.begin(), results.end(), [](const auto& a, const auto& b) {\n+        return std::get<0>(a) < std::get<0>(b) || (std::get<0>(a) == std::get<0>(b) && std::get<1>(a).size() > std::get<1>(b).size());\n+    });\n+    setCoinsRet = std::get<1>(*best_result);\n+    nValueRet = std::get<2>(*best_result);\n+    return true;\n }\n \n-bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params) const\n+bool SelectCoins(const CWallet& wallet, const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params)\n {\n     std::vector<COutput> vCoins(vAvailableCoins);\n     CAmount value_to_select = nTargetValue;\n@@ -396,16 +428,16 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n     coin_control.ListSelected(vPresetInputs);\n     for (const COutPoint& outpoint : vPresetInputs)\n     {\n-        std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n-        if (it != mapWallet.end())\n+        std::map<uint256, CWalletTx>::const_iterator it = wallet.mapWallet.find(outpoint.hash);\n+        if (it != wallet.mapWallet.end())\n         {\n             const CWalletTx& wtx = it->second;\n             // Clearly invalid input, fail\n             if (wtx.tx->vout.size() <= outpoint.n) {\n                 return false;\n             }\n             // Just to calculate the marginal byte size\n-            CInputCoin coin(wtx.tx, outpoint.n, wtx.GetSpendSize(outpoint.n, false));\n+            CInputCoin coin(wtx.tx, outpoint.n, GetTxSpendSize(wallet, wtx, outpoint.n, false));\n             nValueFromPresetInputs += coin.txout.nValue;\n             if (coin.m_input_bytes <= 0) {\n                 return false; // Not solvable, can't estimate size for fee\n@@ -433,7 +465,7 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n \n     unsigned int limit_ancestor_count = 0;\n     unsigned int limit_descendant_count = 0;\n-    chain().getPackageLimits(limit_ancestor_count, limit_descendant_count);\n+    wallet.chain().getPackageLimits(limit_ancestor_count, limit_descendant_count);\n     const size_t max_ancestors = (size_t)std::max<int64_t>(1, limit_ancestor_count);\n     const size_t max_descendants = (size_t)std::max<int64_t>(1, limit_descendant_count);\n     const bool fRejectLongChains = gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS);\n@@ -456,40 +488,40 @@ bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAm\n \n         // If possible, fund the transaction with confirmed UTXOs only. Prefer at least six\n         // confirmations on outputs received from other wallets and only spend confirmed change.\n-        if (AttemptSelection(value_to_select, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n-        if (AttemptSelection(value_to_select, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n+        if (AttemptSelection(wallet, value_to_select, CoinEligibilityFilter(1, 6, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n+        if (AttemptSelection(wallet, value_to_select, CoinEligibilityFilter(1, 1, 0), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n \n         // Fall back to using zero confirmation change (but with as few ancestors in the mempool as\n         // possible) if we cannot fund the transaction otherwise.\n-        if (m_spend_zero_conf_change) {\n-            if (AttemptSelection(value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n-            if (AttemptSelection(value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)),\n+        if (wallet.m_spend_zero_conf_change) {\n+            if (AttemptSelection(wallet, value_to_select, CoinEligibilityFilter(0, 1, 2), vCoins, setCoinsRet, nValueRet, coin_selection_params)) return true;\n+            if (AttemptSelection(wallet, value_to_select, CoinEligibilityFilter(0, 1, std::min((size_t)4, max_ancestors/3), std::min((size_t)4, max_descendants/3)),\n                                    vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n-            if (AttemptSelection(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2),\n+            if (AttemptSelection(wallet, value_to_select, CoinEligibilityFilter(0, 1, max_ancestors/2, max_descendants/2),\n                                    vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n             // If partial groups are allowed, relax the requirement of spending OutputGroups (groups\n             // of UTXOs sent to the same address, which are obviously controlled by a single wallet)\n             // in their entirety.\n-            if (AttemptSelection(value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n+            if (AttemptSelection(wallet, value_to_select, CoinEligibilityFilter(0, 1, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n                                    vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n             // Try with unsafe inputs if they are allowed. This may spend unconfirmed outputs\n             // received from other wallets.\n             if (coin_control.m_include_unsafe_inputs\n-                && AttemptSelection(value_to_select,\n+                && AttemptSelection(wallet, value_to_select,\n                     CoinEligibilityFilter(0 /* conf_mine */, 0 /* conf_theirs */, max_ancestors-1, max_descendants-1, true /* include_partial_groups */),\n                     vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n             }\n             // Try with unlimited ancestors/descendants. The transaction will still need to meet\n             // mempool ancestor/descendant policy to be accepted to mempool and broadcasted, but\n             // OutputGroups use heuristics that may overestimate ancestor/descendant counts.\n-            if (!fRejectLongChains && AttemptSelection(value_to_select,\n+            if (!fRejectLongChains && AttemptSelection(wallet, value_to_select,\n                                       CoinEligibilityFilter(0, 1, std::numeric_limits<uint64_t>::max(), std::numeric_limits<uint64_t>::max(), true /* include_partial_groups */),\n                                       vCoins, setCoinsRet, nValueRet, coin_selection_params)) {\n                 return true;\n@@ -568,27 +600,31 @@ static uint32_t GetLocktimeForNewTransaction(interfaces::Chain& chain, const uin\n     return locktime;\n }\n \n-bool CWallet::CreateTransactionInternal(\n+static bool CreateTransactionInternal(\n+        CWallet& wallet,\n         const std::vector<CRecipient>& vecSend,\n         CTransactionRef& tx,\n         CAmount& nFeeRet,\n         int& nChangePosInOut,\n         bilingual_str& error,\n         const CCoinControl& coin_control,\n         FeeCalculation& fee_calc_out,\n-        bool sign)\n+        bool sign) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet)\n {\n-    AssertLockHeld(cs_wallet);\n+    AssertLockHeld(wallet.cs_wallet);\n \n     CMutableTransaction txNew; // The resulting transaction that we make\n-    txNew.nLockTime = GetLocktimeForNewTransaction(chain(), GetLastBlockHash(), GetLastBlockHeight());\n+    txNew.nLockTime = GetLocktimeForNewTransaction(wallet.chain(), wallet.GetLastBlockHash(), wallet.GetLastBlockHeight());\n \n     CoinSelectionParams coin_selection_params; // Parameters for coin selection, init with dummy\n     coin_selection_params.m_avoid_partial_spends = coin_control.m_avoid_partial_spends;\n \n+    // Set the long term feerate estimate to the wallet's consolidate feerate\n+    coin_selection_params.m_long_term_feerate = wallet.m_consolidate_feerate;\n+\n     CAmount recipients_sum = 0;\n-    const OutputType change_type = TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : m_default_change_type, vecSend);\n-    ReserveDestination reservedest(this, change_type);\n+    const OutputType change_type = wallet.TransactionChangeType(coin_control.m_change_type ? *coin_control.m_change_type : wallet.m_default_change_type, vecSend);\n+    ReserveDestination reservedest(&wallet, change_type);\n     unsigned int outputs_to_subtract_fee_from = 0; // The number of outputs which we are subtracting the fee from\n     for (const auto& recipient : vecSend) {\n         recipients_sum += recipient.nAmount;\n@@ -632,7 +668,7 @@ bool CWallet::CreateTransactionInternal(\n     coin_selection_params.change_output_size = GetSerializeSize(change_prototype_txout);\n \n     // Get size of spending the change output\n-    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, this);\n+    int change_spend_size = CalculateMaximumSignedInputSize(change_prototype_txout, &wallet);\n     // If the wallet doesn't know how to sign change output, assume p2sh-p2wpkh\n     // as lower-bound to allow BnB to do it's thing\n     if (change_spend_size == -1) {\n@@ -642,28 +678,23 @@ bool CWallet::CreateTransactionInternal(\n     }\n \n     // Set discard feerate\n-    coin_selection_params.m_discard_feerate = GetDiscardRate(*this);\n+    coin_selection_params.m_discard_feerate = GetDiscardRate(wallet);\n \n     // Get the fee rate to use effective values in coin selection\n     FeeCalculation feeCalc;\n-    coin_selection_params.m_effective_feerate = GetMinimumFeeRate(*this, coin_control, &feeCalc);\n+    coin_selection_params.m_effective_feerate = GetMinimumFeeRate(wallet, coin_control, &feeCalc);\n     // Do not, ever, assume that it's fine to change the fee rate if the user has explicitly\n     // provided one\n     if (coin_control.m_feerate && coin_selection_params.m_effective_feerate > *coin_control.m_feerate) {\n         error = strprintf(_(\"Fee rate (%s) is lower than the minimum fee rate setting (%s)\"), coin_control.m_feerate->ToString(FeeEstimateMode::SAT_VB), coin_selection_params.m_effective_feerate.ToString(FeeEstimateMode::SAT_VB));\n         return false;\n     }\n-    if (feeCalc.reason == FeeReason::FALLBACK && !m_allow_fallback_fee) {\n+    if (feeCalc.reason == FeeReason::FALLBACK && !wallet.m_allow_fallback_fee) {\n         // eventually allow a fallback fee\n         error = _(\"Fee estimation failed. Fallbackfee is disabled. Wait a few blocks or enable -fallbackfee.\");\n         return false;\n     }\n \n-    // Get long term estimate\n-    CCoinControl cc_temp;\n-    cc_temp.m_confirm_target = chain().estimateMaxBlocks();\n-    coin_selection_params.m_long_term_feerate = GetMinimumFeeRate(*this, cc_temp, nullptr);\n-\n     // Calculate the cost of change\n     // Cost of change is the cost of creating the change output + cost of spending the change output in the future.\n     // For creating the change output now, we use the effective feerate.\n@@ -685,7 +716,7 @@ bool CWallet::CreateTransactionInternal(\n             coin_selection_params.tx_noinputs_size += ::GetSerializeSize(txout, PROTOCOL_VERSION);\n         }\n \n-        if (IsDust(txout, chain().relayDustFee()))\n+        if (IsDust(txout, wallet.chain().relayDustFee()))\n         {\n             error = _(\"Transaction amount too small\");\n             return false;\n@@ -699,12 +730,12 @@ bool CWallet::CreateTransactionInternal(\n \n     // Get available coins\n     std::vector<COutput> vAvailableCoins;\n-    AvailableCoins(vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n+    AvailableCoins(wallet, vAvailableCoins, &coin_control, 1, MAX_MONEY, MAX_MONEY, 0);\n \n     // Choose coins to use\n     CAmount inputs_sum = 0;\n     std::set<CInputCoin> setCoins;\n-    if (!SelectCoins(vAvailableCoins, /* nTargetValue */ selection_target, setCoins, inputs_sum, coin_control, coin_selection_params))\n+    if (!SelectCoins(wallet, vAvailableCoins, /* nTargetValue */ selection_target, setCoins, inputs_sum, coin_control, coin_selection_params))\n     {\n         error = _(\"Insufficient funds\");\n         return false;\n@@ -742,13 +773,13 @@ bool CWallet::CreateTransactionInternal(\n     // to avoid conflicting with other possible uses of nSequence,\n     // and in the spirit of \"smallest possible change from prior\n     // behavior.\"\n-    const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n+    const uint32_t nSequence = coin_control.m_signal_bip125_rbf.value_or(wallet.m_signal_rbf) ? MAX_BIP125_RBF_SEQUENCE : (CTxIn::SEQUENCE_FINAL - 1);\n     for (const auto& coin : selected_coins) {\n         txNew.vin.push_back(CTxIn(coin.outpoint, CScript(), nSequence));\n     }\n \n     // Calculate the transaction fee\n-    TxSize tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+    TxSize tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), &wallet, coin_control.fAllowWatchOnly);\n     int nBytes = tx_sizes.vsize;\n     if (nBytes < 0) {\n         error = _(\"Signing transaction failed\");\n@@ -773,7 +804,7 @@ bool CWallet::CreateTransactionInternal(\n         txNew.vout.erase(change_position);\n \n         // Because we have dropped this change, the tx size and required fee will be different, so let's recalculate those\n-        tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), this, coin_control.fAllowWatchOnly);\n+        tx_sizes = CalculateMaximumSignedTxSize(CTransaction(txNew), &wallet, coin_control.fAllowWatchOnly);\n         nBytes = tx_sizes.vsize;\n         fee_needed = coin_selection_params.m_effective_feerate.GetFee(nBytes);\n     }\n@@ -810,7 +841,7 @@ bool CWallet::CreateTransactionInternal(\n                 }\n \n                 // Error if this output is reduced to be below dust\n-                if (IsDust(txout, chain().relayDustFee())) {\n+                if (IsDust(txout, wallet.chain().relayDustFee())) {\n                     if (txout.nValue < 0) {\n                         error = _(\"The transaction amount is too small to pay the fee\");\n                     } else {\n@@ -829,7 +860,7 @@ bool CWallet::CreateTransactionInternal(\n         return false;\n     }\n \n-    if (sign && !SignTransaction(txNew)) {\n+    if (sign && !wallet.SignTransaction(txNew)) {\n         error = _(\"Signing transaction failed\");\n         return false;\n     }\n@@ -845,14 +876,14 @@ bool CWallet::CreateTransactionInternal(\n         return false;\n     }\n \n-    if (nFeeRet > m_default_max_tx_fee) {\n+    if (nFeeRet > wallet.m_default_max_tx_fee) {\n         error = TransactionErrorString(TransactionError::MAX_FEE_EXCEEDED);\n         return false;\n     }\n \n     if (gArgs.GetBoolArg(\"-walletrejectlongchains\", DEFAULT_WALLET_REJECT_LONG_CHAINS)) {\n         // Lastly, ensure this tx will pass the mempool's chain limits\n-        if (!chain().checkChainLimits(tx)) {\n+        if (!wallet.chain().checkChainLimits(tx)) {\n             error = _(\"Transaction has too long of a mempool chain\");\n             return false;\n         }\n@@ -863,7 +894,7 @@ bool CWallet::CreateTransactionInternal(\n     reservedest.KeepDestination();\n     fee_calc_out = feeCalc;\n \n-    WalletLogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n+    wallet.WalletLogPrintf(\"Fee Calculation: Fee:%d Bytes:%u Tgt:%d (requested %d) Reason:\\\"%s\\\" Decay %.5f: Estimation: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out) Fail: (%g - %g) %.2f%% %.1f/(%.1f %d mem %.1f out)\\n\",\n               nFeeRet, nBytes, feeCalc.returnedTarget, feeCalc.desiredTarget, StringForFeeReason(feeCalc.reason), feeCalc.est.decay,\n               feeCalc.est.pass.start, feeCalc.est.pass.end,\n               (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool) > 0.0 ? 100 * feeCalc.est.pass.withinTarget / (feeCalc.est.pass.totalConfirmed + feeCalc.est.pass.inMempool + feeCalc.est.pass.leftMempool) : 0.0,\n@@ -874,7 +905,8 @@ bool CWallet::CreateTransactionInternal(\n     return true;\n }\n \n-bool CWallet::CreateTransaction(\n+bool CreateTransaction(\n+        CWallet& wallet,\n         const std::vector<CRecipient>& vecSend,\n         CTransactionRef& tx,\n         CAmount& nFeeRet,\n@@ -894,23 +926,23 @@ bool CWallet::CreateTransaction(\n         return false;\n     }\n \n-    LOCK(cs_wallet);\n+    LOCK(wallet.cs_wallet);\n \n     int nChangePosIn = nChangePosInOut;\n     Assert(!tx); // tx is an out-param. TODO change the return type from bool to tx (or nullptr)\n-    bool res = CreateTransactionInternal(vecSend, tx, nFeeRet, nChangePosInOut, error, coin_control, fee_calc_out, sign);\n+    bool res = CreateTransactionInternal(wallet, vecSend, tx, nFeeRet, nChangePosInOut, error, coin_control, fee_calc_out, sign);\n     // try with avoidpartialspends unless it's enabled already\n-    if (res && nFeeRet > 0 /* 0 means non-functional fee rate estimation */ && m_max_aps_fee > -1 && !coin_control.m_avoid_partial_spends) {\n+    if (res && nFeeRet > 0 /* 0 means non-functional fee rate estimation */ && wallet.m_max_aps_fee > -1 && !coin_control.m_avoid_partial_spends) {\n         CCoinControl tmp_cc = coin_control;\n         tmp_cc.m_avoid_partial_spends = true;\n         CAmount nFeeRet2;\n         CTransactionRef tx2;\n         int nChangePosInOut2 = nChangePosIn;\n         bilingual_str error2; // fired and forgotten; if an error occurs, we discard the results\n-        if (CreateTransactionInternal(vecSend, tx2, nFeeRet2, nChangePosInOut2, error2, tmp_cc, fee_calc_out, sign)) {\n+        if (CreateTransactionInternal(wallet, vecSend, tx2, nFeeRet2, nChangePosInOut2, error2, tmp_cc, fee_calc_out, sign)) {\n             // if fee of this alternative one is within the range of the max fee, we use this one\n-            const bool use_aps = nFeeRet2 <= nFeeRet + m_max_aps_fee;\n-            WalletLogPrintf(\"Fee non-grouped = %lld, grouped = %lld, using %s\\n\", nFeeRet, nFeeRet2, use_aps ? \"grouped\" : \"non-grouped\");\n+            const bool use_aps = nFeeRet2 <= nFeeRet + wallet.m_max_aps_fee;\n+            wallet.WalletLogPrintf(\"Fee non-grouped = %lld, grouped = %lld, using %s\\n\", nFeeRet, nFeeRet2, use_aps ? \"grouped\" : \"non-grouped\");\n             if (use_aps) {\n                 tx = tx2;\n                 nFeeRet = nFeeRet2;\n@@ -921,7 +953,7 @@ bool CWallet::CreateTransaction(\n     return res;\n }\n \n-bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl coinControl)\n+bool FundTransaction(CWallet& wallet, CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl coinControl)\n {\n     std::vector<CRecipient> vecSend;\n \n@@ -940,11 +972,11 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC\n \n     // Acquire the locks to prevent races to the new locked unspents between the\n     // CreateTransaction call and LockCoin calls (when lockUnspents is true).\n-    LOCK(cs_wallet);\n+    LOCK(wallet.cs_wallet);\n \n     CTransactionRef tx_new;\n     FeeCalculation fee_calc_out;\n-    if (!CreateTransaction(vecSend, tx_new, nFeeRet, nChangePosInOut, error, coinControl, fee_calc_out, false)) {\n+    if (!CreateTransaction(wallet, vecSend, tx_new, nFeeRet, nChangePosInOut, error, coinControl, fee_calc_out, false)) {\n         return false;\n     }\n \n@@ -965,7 +997,7 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nC\n \n         }\n         if (lockUnspents) {\n-            LockCoin(txin.prevout);\n+            wallet.LockCoin(txin.prevout);\n         }\n \n     }"
      },
      {
        "sha": "e39f134dc3636f8cdbf3f70536bf026dff2b40a1",
        "filename": "src/wallet/spend.h",
        "status": "modified",
        "additions": 79,
        "deletions": 4,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/spend.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/spend.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/spend.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -9,6 +9,9 @@\n #include <wallet/transaction.h>\n #include <wallet/wallet.h>\n \n+/** Get the marginal bytes if spending the specified output from this transaction */\n+int GetTxSpendSize(const CWallet& wallet, const CWalletTx& wtx, unsigned int out, bool use_max_sig = false);\n+\n class COutput\n {\n public:\n@@ -43,13 +46,13 @@ class COutput\n      */\n     bool fSafe;\n \n-    COutput(const CWalletTx *txIn, int iIn, int nDepthIn, bool fSpendableIn, bool fSolvableIn, bool fSafeIn, bool use_max_sig_in = false)\n+    COutput(const CWallet& wallet, const CWalletTx& wtx, int iIn, int nDepthIn, bool fSpendableIn, bool fSolvableIn, bool fSafeIn, bool use_max_sig_in = false)\n     {\n-        tx = txIn; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn; fSolvable = fSolvableIn; fSafe = fSafeIn; nInputBytes = -1; use_max_sig = use_max_sig_in;\n+        tx = &wtx; i = iIn; nDepth = nDepthIn; fSpendable = fSpendableIn; fSolvable = fSolvableIn; fSafe = fSafeIn; nInputBytes = -1; use_max_sig = use_max_sig_in;\n         // If known and signable by the given wallet, compute nInputBytes\n         // Failure will keep this value -1\n-        if (fSpendable && tx) {\n-            nInputBytes = tx->GetSpendSize(i, use_max_sig);\n+        if (fSpendable) {\n+            nInputBytes = GetTxSpendSize(wallet, wtx, i, use_max_sig);\n         }\n     }\n \n@@ -61,4 +64,76 @@ class COutput\n     }\n };\n \n+//Get the marginal bytes of spending the specified output\n+int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* pwallet, bool use_max_sig = false);\n+\n+struct TxSize {\n+    int64_t vsize{-1};\n+    int64_t weight{-1};\n+};\n+\n+/** Calculate the size of the transaction assuming all signatures are max size\n+* Use DummySignatureCreator, which inserts 71 byte signatures everywhere.\n+* NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n+* be AllInputsMine). */\n+TxSize CalculateMaximumSignedTxSize(const CTransaction& tx, const CWallet* wallet, const std::vector<CTxOut>& txouts, bool use_max_sig = false);\n+TxSize CalculateMaximumSignedTxSize(const CTransaction& tx, const CWallet* wallet, bool use_max_sig = false) EXCLUSIVE_LOCKS_REQUIRED(wallet->cs_wallet);\n+\n+/**\n+ * populate vCoins with vector of available COutputs.\n+ */\n+void AvailableCoins(const CWallet& wallet, std::vector<COutput>& vCoins, const CCoinControl* coinControl = nullptr, const CAmount& nMinimumAmount = 1, const CAmount& nMaximumAmount = MAX_MONEY, const CAmount& nMinimumSumAmount = MAX_MONEY, const uint64_t nMaximumCount = 0) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+\n+CAmount GetAvailableBalance(const CWallet& wallet, const CCoinControl* coinControl = nullptr);\n+\n+/**\n+ * Find non-change parent output.\n+ */\n+const CTxOut& FindNonChangeParentOutput(const CWallet& wallet, const CTransaction& tx, int output) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+\n+/**\n+ * Return list of available coins and locked coins grouped by non-change output address.\n+ */\n+std::map<CTxDestination, std::vector<COutput>> ListCoins(const CWallet& wallet) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+\n+std::vector<OutputGroup> GroupOutputs(const CWallet& wallet, const std::vector<COutput>& outputs, const CoinSelectionParams& coin_sel_params, const CoinEligibilityFilter& filter, bool positive_only);\n+\n+/**\n+ * Shuffle and select coins until nTargetValue is reached while avoiding\n+ * small change; This method is stochastic for some inputs and upon\n+ * completion the coin set and corresponding actual target value is\n+ * assembled\n+ * param@[in]   coins           Set of UTXOs to consider. These will be categorized into\n+ *                              OutputGroups and filtered using eligibility_filter before\n+ *                              selecting coins.\n+ * param@[out]  setCoinsRet     Populated with the coins selected if successful.\n+ * param@[out]  nValueRet       Used to return the total value of selected coins.\n+ */\n+bool AttemptSelection(const CWallet& wallet, const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n+                        std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params);\n+\n+/**\n+ * Select a set of coins such that nValueRet >= nTargetValue and at least\n+ * all coins from coin_control are selected; never select unconfirmed coins if they are not ours\n+ * param@[out]  setCoinsRet         Populated with inputs including pre-selected inputs from\n+ *                                  coin_control and Coin Selection if successful.\n+ * param@[out]  nValueRet           Total value of selected coins including pre-selected ones\n+ *                                  from coin_control and Coin Selection if successful.\n+ */\n+bool SelectCoins(const CWallet& wallet, const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet,\n+                 const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params) EXCLUSIVE_LOCKS_REQUIRED(wallet.cs_wallet);\n+\n+/**\n+ * Create a new transaction paying the recipients with a set of coins\n+ * selected by SelectCoins(); Also create the change output, when needed\n+ * @note passing nChangePosInOut as -1 will result in setting a random position\n+ */\n+bool CreateTransaction(CWallet& wallet, const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, const CCoinControl& coin_control, FeeCalculation& fee_calc_out, bool sign = true);\n+\n+/**\n+ * Insert additional inputs into the transaction by\n+ * calling CreateTransaction();\n+ */\n+bool FundTransaction(CWallet& wallet, CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl);\n+\n #endif // BITCOIN_WALLET_SPEND_H"
      },
      {
        "sha": "5d518092413985323fe924c6a60d01f3a306af48",
        "filename": "src/wallet/test/coinselector_tests.cpp",
        "status": "modified",
        "additions": 122,
        "deletions": 41,
        "changes": 163,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/test/coinselector_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/test/coinselector_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/coinselector_tests.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -10,6 +10,7 @@\n #include <util/translation.h>\n #include <wallet/coincontrol.h>\n #include <wallet/coinselection.h>\n+#include <wallet/spend.h>\n #include <wallet/test/wallet_test_fixture.h>\n #include <wallet/wallet.h>\n \n@@ -39,7 +40,7 @@ CoinEligibilityFilter filter_standard_extra(6, 6, 0);\n CoinSelectionParams coin_selection_params(/* change_output_size= */ 0,\n                                           /* change_spend_size= */ 0, /* effective_feerate= */ CFeeRate(0),\n                                           /* long_term_feerate= */ CFeeRate(0), /* discard_feerate= */ CFeeRate(0),\n-                                          /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n+                                          /* tx_noinputs_size= */ 0, /* avoid_partial= */ false);\n \n static void add_coin(const CAmount& nValue, int nInput, std::vector<CInputCoin>& set)\n {\n@@ -49,12 +50,16 @@ static void add_coin(const CAmount& nValue, int nInput, std::vector<CInputCoin>&\n     set.emplace_back(MakeTransactionRef(tx), nInput);\n }\n \n-static void add_coin(const CAmount& nValue, int nInput, CoinSet& set)\n+static void add_coin(const CAmount& nValue, int nInput, CoinSet& set, CAmount fee = 0, CAmount long_term_fee = 0)\n {\n     CMutableTransaction tx;\n     tx.vout.resize(nInput + 1);\n     tx.vout[nInput].nValue = nValue;\n-    set.emplace(MakeTransactionRef(tx), nInput);\n+    CInputCoin coin(MakeTransactionRef(tx), nInput);\n+    coin.effective_value = nValue - fee;\n+    coin.m_fee = fee;\n+    coin.m_long_term_fee = long_term_fee;\n+    set.insert(coin);\n }\n \n static void add_coin(CWallet& wallet, const CAmount& nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0, bool spendable = false)\n@@ -83,7 +88,7 @@ static void add_coin(CWallet& wallet, const CAmount& nValue, int nAge = 6*24, bo\n         wtx->m_amounts[CWalletTx::DEBIT].Set(ISMINE_SPENDABLE, 1);\n         wtx->m_is_cache_empty = false;\n     }\n-    COutput output(wtx, nInput, nAge, true /* spendable */, true /* solvable */, true /* safe */);\n+    COutput output(wallet, *wtx, nInput, nAge, true /* spendable */, true /* solvable */, true /* safe */);\n     vCoins.push_back(output);\n }\n static void add_coin(const CAmount& nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0, bool spendable = false)\n@@ -137,6 +142,13 @@ inline std::vector<OutputGroup>& GroupCoins(const std::vector<COutput>& coins)\n     return static_groups;\n }\n \n+inline std::vector<OutputGroup>& KnapsackGroupOutputs(const CoinEligibilityFilter& filter)\n+{\n+    static std::vector<OutputGroup> static_groups;\n+    static_groups = GroupOutputs(testWallet, vCoins, coin_selection_params, filter, /* positive_only */false);\n+    return static_groups;\n+}\n+\n // Branch and bound coin selection tests\n BOOST_AUTO_TEST_CASE(bnb_search_test)\n {\n@@ -275,20 +287,20 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n     CoinSelectionParams coin_selection_params_bnb(/* change_output_size= */ 0,\n                                                   /* change_spend_size= */ 0, /* effective_feerate= */ CFeeRate(3000),\n                                                   /* long_term_feerate= */ CFeeRate(1000), /* discard_feerate= */ CFeeRate(1000),\n-                                                  /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n+                                                  /* tx_noinputs_size= */ 0, /* avoid_partial= */ false);\n     CoinSet setCoinsRet;\n     CAmount nValueRet;\n     empty_wallet();\n     add_coin(1);\n     vCoins.at(0).nInputBytes = 40; // Make sure that it has a negative effective value. The next check should assert if this somehow got through. Otherwise it will fail\n-    BOOST_CHECK(!testWallet.AttemptSelection( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb));\n+    BOOST_CHECK(!SelectCoinsBnB(GroupCoins(vCoins), 1 * CENT, coin_selection_params_bnb.m_cost_of_change, setCoinsRet, nValueRet));\n \n     // Test fees subtracted from output:\n     empty_wallet();\n     add_coin(1 * CENT);\n     vCoins.at(0).nInputBytes = 40;\n     coin_selection_params_bnb.m_subtract_fee_outputs = true;\n-    BOOST_CHECK(testWallet.AttemptSelection( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params_bnb));\n+    BOOST_CHECK(SelectCoinsBnB(GroupCoins(vCoins), 1 * CENT, coin_selection_params_bnb.m_cost_of_change, setCoinsRet, nValueRet));\n     BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n \n     // Make sure that can use BnB when there are preset inputs\n@@ -305,7 +317,7 @@ BOOST_AUTO_TEST_CASE(bnb_search_test)\n         coin_control.fAllowOtherInputs = true;\n         coin_control.Select(COutPoint(vCoins.at(0).tx->GetHash(), vCoins.at(0).i));\n         coin_selection_params_bnb.m_effective_feerate = CFeeRate(0);\n-        BOOST_CHECK(wallet->SelectCoins(vCoins, 10 * CENT, setCoinsRet, nValueRet, coin_control, coin_selection_params_bnb));\n+        BOOST_CHECK(SelectCoins(*wallet, vCoins, 10 * CENT, setCoinsRet, nValueRet, coin_control, coin_selection_params_bnb));\n     }\n }\n \n@@ -323,24 +335,24 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         empty_wallet();\n \n         // with an empty wallet we can't even pay one cent\n-        BOOST_CHECK(!testWallet.AttemptSelection( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(!KnapsackSolver(1 * CENT, KnapsackGroupOutputs(filter_standard), setCoinsRet, nValueRet));\n \n         add_coin(1*CENT, 4);        // add a new 1 cent coin\n \n         // with a new 1 cent coin, we still can't find a mature 1 cent\n-        BOOST_CHECK(!testWallet.AttemptSelection( 1 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(!KnapsackSolver(1 * CENT, KnapsackGroupOutputs(filter_standard), setCoinsRet, nValueRet));\n \n         // but we can find a new 1 cent\n-        BOOST_CHECK( testWallet.AttemptSelection( 1 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(1 * CENT, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * CENT);\n \n         add_coin(2*CENT);           // add a mature 2 cent coin\n \n         // we can't make 3 cents of mature coins\n-        BOOST_CHECK(!testWallet.AttemptSelection( 3 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(!KnapsackSolver(3 * CENT, KnapsackGroupOutputs(filter_standard), setCoinsRet, nValueRet));\n \n         // we can make 3 cents of new coins\n-        BOOST_CHECK( testWallet.AttemptSelection( 3 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(3 * CENT, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 3 * CENT);\n \n         add_coin(5*CENT);           // add a mature 5 cent coin,\n@@ -350,33 +362,33 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         // now we have new: 1+10=11 (of which 10 was self-sent), and mature: 2+5+20=27.  total = 38\n \n         // we can't make 38 cents only if we disallow new coins:\n-        BOOST_CHECK(!testWallet.AttemptSelection(38 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(!KnapsackSolver(38 * CENT, KnapsackGroupOutputs(filter_standard), setCoinsRet, nValueRet));\n         // we can't even make 37 cents if we don't allow new coins even if they're from us\n-        BOOST_CHECK(!testWallet.AttemptSelection(38 * CENT, filter_standard_extra, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(!KnapsackSolver(38 * CENT, KnapsackGroupOutputs(filter_standard_extra), setCoinsRet, nValueRet));\n         // but we can make 37 cents if we accept new coins from ourself\n-        BOOST_CHECK( testWallet.AttemptSelection(37 * CENT, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(37 * CENT, KnapsackGroupOutputs(filter_standard), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 37 * CENT);\n         // and we can make 38 cents if we accept all new coins\n-        BOOST_CHECK( testWallet.AttemptSelection(38 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(38 * CENT, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 38 * CENT);\n \n         // try making 34 cents from 1,2,5,10,20 - we can't do it exactly\n-        BOOST_CHECK( testWallet.AttemptSelection(34 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(34 * CENT, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 35 * CENT);       // but 35 cents is closest\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);     // the best should be 20+10+5.  it's incredibly unlikely the 1 or 2 got included (but possible)\n \n         // when we try making 7 cents, the smaller coins (1,2,5) are enough.  We should see just 2+5\n-        BOOST_CHECK( testWallet.AttemptSelection( 7 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(7 * CENT, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 7 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n         // when we try making 8 cents, the smaller coins (1,2,5) are exactly enough.\n-        BOOST_CHECK( testWallet.AttemptSelection( 8 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(8 * CENT, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK(nValueRet == 8 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         // when we try making 9 cents, no subset of smaller coins is enough, and we get the next bigger coin (10)\n-        BOOST_CHECK( testWallet.AttemptSelection( 9 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(9 * CENT, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 10 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -390,30 +402,30 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(30*CENT); // now we have 6+7+8+20+30 = 71 cents total\n \n         // check that we have 71 and not 72\n-        BOOST_CHECK( testWallet.AttemptSelection(71 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n-        BOOST_CHECK(!testWallet.AttemptSelection(72 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(71 * CENT, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n+        BOOST_CHECK(!KnapsackSolver(72 * CENT, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n \n         // now try making 16 cents.  the best smaller coins can do is 6+7+8 = 21; not as good at the next biggest coin, 20\n-        BOOST_CHECK( testWallet.AttemptSelection(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(16 * CENT, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 20 * CENT); // we should get 20 in one coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n         add_coin( 5*CENT); // now we have 5+6+7+8+20+30 = 75 cents total\n \n         // now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, better than the next biggest coin, 20\n-        BOOST_CHECK( testWallet.AttemptSelection(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(16 * CENT, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 18 * CENT); // we should get 18 in 3 coins\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         add_coin( 18*CENT); // now we have 5+6+7+8+18+20+30\n \n         // and now if we try making 16 cents again, the smaller coins can make 5+6+7 = 18 cents, the same as the next biggest coin, 18\n-        BOOST_CHECK( testWallet.AttemptSelection(16 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(16 * CENT, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 18 * CENT);  // we should get 18 in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U); // because in the event of a tie, the biggest coin wins\n \n         // now try making 11 cents.  we should get 5+6\n-        BOOST_CHECK( testWallet.AttemptSelection(11 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(11 * CENT, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 11 * CENT);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n@@ -422,11 +434,11 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin( 2*COIN);\n         add_coin( 3*COIN);\n         add_coin( 4*COIN); // now we have 5+6+7+8+18+20+30+100+200+300+400 = 1094 cents\n-        BOOST_CHECK( testWallet.AttemptSelection(95 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(95 * CENT, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * COIN);  // we should get 1 BTC in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n-        BOOST_CHECK( testWallet.AttemptSelection(195 * CENT, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(195 * CENT, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 2 * COIN);  // we should get 2 BTC in 1 coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -441,22 +453,22 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n         // try making 1 * MIN_CHANGE from the 1.5 * MIN_CHANGE\n         // we'll get change smaller than MIN_CHANGE whatever happens, so can expect MIN_CHANGE exactly\n-        BOOST_CHECK( testWallet.AttemptSelection(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(MIN_CHANGE, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);\n \n         // but if we add a bigger coin, small change is avoided\n         add_coin(1111*MIN_CHANGE);\n \n         // try making 1 from 0.1 + 0.2 + 0.3 + 0.4 + 0.5 + 1111 = 1112.5\n-        BOOST_CHECK( testWallet.AttemptSelection(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(1 * MIN_CHANGE, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n \n         // if we add more small coins:\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 7 / 10);\n \n         // and try again to make 1.0 * MIN_CHANGE\n-        BOOST_CHECK( testWallet.AttemptSelection(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(1 * MIN_CHANGE, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 1 * MIN_CHANGE); // we should get the exact amount\n \n         // run the 'mtgox' test (see https://blockexplorer.com/tx/29a3efd3ef04f9153d47a990bd7b048a4b2d213daaa5fb8ed670fb85f13bdbcf)\n@@ -465,7 +477,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         for (int j = 0; j < 20; j++)\n             add_coin(50000 * COIN);\n \n-        BOOST_CHECK( testWallet.AttemptSelection(500000 * COIN, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(500000 * COIN, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 500000 * COIN); // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 10U); // in ten coins\n \n@@ -478,7 +490,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 7 / 10);\n         add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.AttemptSelection(1 * MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(1 * MIN_CHANGE, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 1111 * MIN_CHANGE); // we get the bigger coin\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 1U);\n \n@@ -488,7 +500,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(MIN_CHANGE * 6 / 10);\n         add_coin(MIN_CHANGE * 8 / 10);\n         add_coin(1111 * MIN_CHANGE);\n-        BOOST_CHECK( testWallet.AttemptSelection(MIN_CHANGE, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(MIN_CHANGE, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE);   // we should get the exact amount\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U); // in two coins 0.4+0.6\n \n@@ -499,12 +511,12 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n         add_coin(MIN_CHANGE * 100);\n \n         // trying to make 100.01 from these three coins\n-        BOOST_CHECK(testWallet.AttemptSelection(MIN_CHANGE * 10001 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(MIN_CHANGE * 10001 / 100, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, MIN_CHANGE * 10105 / 100); // we should get all coins\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 3U);\n \n         // but if we try to make 99.9, we should take the bigger of the two small coins to avoid small change\n-        BOOST_CHECK(testWallet.AttemptSelection(MIN_CHANGE * 9990 / 100, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+        BOOST_CHECK(KnapsackSolver(MIN_CHANGE * 9990 / 100, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n         BOOST_CHECK_EQUAL(nValueRet, 101 * MIN_CHANGE);\n         BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n       }\n@@ -518,7 +530,7 @@ BOOST_AUTO_TEST_CASE(knapsack_solver_test)\n \n            // We only create the wallet once to save time, but we still run the coin selection RUN_TESTS times.\n            for (int i = 0; i < RUN_TESTS; i++) {\n-             BOOST_CHECK(testWallet.AttemptSelection(2000, filter_confirmed, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+             BOOST_CHECK(KnapsackSolver(2000, KnapsackGroupOutputs(filter_confirmed), setCoinsRet, nValueRet));\n \n              if (amt - 2000 < MIN_CHANGE) {\n                  // needs more than one input:\n@@ -603,7 +615,7 @@ BOOST_AUTO_TEST_CASE(ApproximateBestSubset)\n         add_coin(1000 * COIN);\n     add_coin(3 * COIN);\n \n-    BOOST_CHECK(testWallet.AttemptSelection(1003 * COIN, filter_standard, vCoins, setCoinsRet, nValueRet, coin_selection_params));\n+    BOOST_CHECK(KnapsackSolver(1003 * COIN, KnapsackGroupOutputs(filter_standard), setCoinsRet, nValueRet));\n     BOOST_CHECK_EQUAL(nValueRet, 1003 * COIN);\n     BOOST_CHECK_EQUAL(setCoinsRet.size(), 2U);\n \n@@ -642,13 +654,82 @@ BOOST_AUTO_TEST_CASE(SelectCoins_test)\n         CoinSelectionParams cs_params(/* change_output_size= */ 34,\n                                       /* change_spend_size= */ 148, /* effective_feerate= */ CFeeRate(0),\n                                       /* long_term_feerate= */ CFeeRate(0), /* discard_feerate= */ CFeeRate(0),\n-                                      /* tx_no_inputs_size= */ 0, /* avoid_partial= */ false);\n+                                      /* tx_noinputs_size= */ 0, /* avoid_partial= */ false);\n         CoinSet out_set;\n         CAmount out_value = 0;\n         CCoinControl cc;\n-        BOOST_CHECK(testWallet.SelectCoins(vCoins, target, out_set, out_value, cc, cs_params));\n+        BOOST_CHECK(SelectCoins(testWallet, vCoins, target, out_set, out_value, cc, cs_params));\n         BOOST_CHECK_GE(out_value, target);\n     }\n }\n \n+BOOST_AUTO_TEST_CASE(waste_test)\n+{\n+    CoinSet selection;\n+    const CAmount fee{100};\n+    const CAmount change_cost{125};\n+    const CAmount fee_diff{40};\n+    const CAmount in_amt{3 * COIN};\n+    const CAmount target{2 * COIN};\n+    const CAmount excess{in_amt - fee * 2 - target};\n+\n+    // Waste with change is the change cost and difference between fee and long term fee\n+    add_coin(1 * COIN, 1, selection, fee, fee - fee_diff);\n+    add_coin(2 * COIN, 2, selection, fee, fee - fee_diff);\n+    const CAmount waste1 = GetSelectionWaste(selection, change_cost, target);\n+    BOOST_CHECK_EQUAL(fee_diff * 2 + change_cost, waste1);\n+    selection.clear();\n+\n+    // Waste without change is the excess and difference between fee and long term fee\n+    add_coin(1 * COIN, 1, selection, fee, fee - fee_diff);\n+    add_coin(2 * COIN, 2, selection, fee, fee - fee_diff);\n+    const CAmount waste_nochange1 = GetSelectionWaste(selection, 0, target);\n+    BOOST_CHECK_EQUAL(fee_diff * 2 + excess, waste_nochange1);\n+    selection.clear();\n+\n+    // Waste with change and fee == long term fee is just cost of change\n+    add_coin(1 * COIN, 1, selection, fee, fee);\n+    add_coin(2 * COIN, 2, selection, fee, fee);\n+    BOOST_CHECK_EQUAL(change_cost, GetSelectionWaste(selection, change_cost, target));\n+    selection.clear();\n+\n+    // Waste without change and fee == long term fee is just the excess\n+    add_coin(1 * COIN, 1, selection, fee, fee);\n+    add_coin(2 * COIN, 2, selection, fee, fee);\n+    BOOST_CHECK_EQUAL(excess, GetSelectionWaste(selection, 0, target));\n+    selection.clear();\n+\n+    // Waste will be greater when fee is greater, but long term fee is the same\n+    add_coin(1 * COIN, 1, selection, fee * 2, fee - fee_diff);\n+    add_coin(2 * COIN, 2, selection, fee * 2, fee - fee_diff);\n+    const CAmount waste2 = GetSelectionWaste(selection, change_cost, target);\n+    BOOST_CHECK_GT(waste2, waste1);\n+    selection.clear();\n+\n+    // Waste with change is the change cost and difference between fee and long term fee\n+    // With long term fee greater than fee, waste should be less than when long term fee is less than fee\n+    add_coin(1 * COIN, 1, selection, fee, fee + fee_diff);\n+    add_coin(2 * COIN, 2, selection, fee, fee + fee_diff);\n+    const CAmount waste3 = GetSelectionWaste(selection, change_cost, target);\n+    BOOST_CHECK_EQUAL(fee_diff * -2 + change_cost, waste3);\n+    BOOST_CHECK_LT(waste3, waste1);\n+    selection.clear();\n+\n+    // Waste without change is the excess and difference between fee and long term fee\n+    // With long term fee greater than fee, waste should be less than when long term fee is less than fee\n+    add_coin(1 * COIN, 1, selection, fee, fee + fee_diff);\n+    add_coin(2 * COIN, 2, selection, fee, fee + fee_diff);\n+    const CAmount waste_nochange2 = GetSelectionWaste(selection, 0, target);\n+    BOOST_CHECK_EQUAL(fee_diff * -2 + excess, waste_nochange2);\n+    BOOST_CHECK_LT(waste_nochange2, waste_nochange1);\n+    selection.clear();\n+\n+    // 0 Waste only when fee == long term fee, no change, and no excess\n+    add_coin(1 * COIN, 1, selection, fee, fee);\n+    add_coin(2 * COIN, 2, selection, fee, fee);\n+    const CAmount exact_target = in_amt - 2 * fee;\n+    BOOST_CHECK_EQUAL(0, GetSelectionWaste(selection, 0, exact_target));\n+\n+}\n+\n BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "16cb7e0baf0caf13d552480ca48dc70a81d6c27c",
        "filename": "src/wallet/test/db_tests.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/test/db_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/test/db_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/db_tests.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -25,7 +25,11 @@ BOOST_AUTO_TEST_CASE(getwalletenv_file)\n     std::string test_name = \"test_name.dat\";\n     const fs::path datadir = gArgs.GetDataDirNet();\n     fs::path file_path = datadir / test_name;\n+#if BOOST_VERSION >= 107700\n+    std::ofstream f(BOOST_FILESYSTEM_C_STR(file_path));\n+#else\n     std::ofstream f(file_path.BOOST_FILESYSTEM_C_STR);\n+#endif // BOOST_VERSION >= 107700\n     f.close();\n \n     std::string filename;"
      },
      {
        "sha": "53c972c46d3bd232ec61b0ecb1bda0efefb45f27",
        "filename": "src/wallet/test/init_test_fixture.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/test/init_test_fixture.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/test/init_test_fixture.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/init_test_fixture.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -32,7 +32,11 @@ InitWalletDirTestingSetup::InitWalletDirTestingSetup(const std::string& chainNam\n     fs::create_directories(m_walletdir_path_cases[\"default\"]);\n     fs::create_directories(m_walletdir_path_cases[\"custom\"]);\n     fs::create_directories(m_walletdir_path_cases[\"relative\"]);\n+#if BOOST_VERSION >= 107700\n+    std::ofstream f(BOOST_FILESYSTEM_C_STR(m_walletdir_path_cases[\"file\"]));\n+#else\n     std::ofstream f(m_walletdir_path_cases[\"file\"].BOOST_FILESYSTEM_C_STR);\n+#endif // BOOST_VERSION >= 107700\n     f.close();\n }\n "
      },
      {
        "sha": "8a97f7779dfcd980ef89cc15e27f4286ee562c44",
        "filename": "src/wallet/test/psbt_wallet_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/test/psbt_wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/test/psbt_wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/psbt_wallet_tests.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -22,12 +22,12 @@ BOOST_AUTO_TEST_CASE(psbt_updater_test)\n     CDataStream s_prev_tx1(ParseHex(\"0200000000010158e87a21b56daf0c23be8e7070456c336f7cbaa5c8757924f545887bb2abdd7501000000171600145f275f436b09a8cc9a2eb2a2f528485c68a56323feffffff02d8231f1b0100000017a914aed962d6654f9a2b36608eb9d64d2b260db4f1118700c2eb0b0000000017a914b7f5faf40e3d40a5a459b1db3535f2b72fa921e88702483045022100a22edcc6e5bc511af4cc4ae0de0fcd75c7e04d8c1c3a8aa9d820ed4b967384ec02200642963597b9b1bc22c75e9f3e117284a962188bf5e8a74c895089046a20ad770121035509a48eb623e10aace8bfd0212fdb8a8e5af3c94b0b133b95e114cab89e4f7965000000\"), SER_NETWORK, PROTOCOL_VERSION);\n     CTransactionRef prev_tx1;\n     s_prev_tx1 >> prev_tx1;\n-    m_wallet.mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(prev_tx1->GetHash()), std::forward_as_tuple(&m_wallet, prev_tx1));\n+    m_wallet.mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(prev_tx1->GetHash()), std::forward_as_tuple(prev_tx1));\n \n     CDataStream s_prev_tx2(ParseHex(\"0200000001aad73931018bd25f84ae400b68848be09db706eac2ac18298babee71ab656f8b0000000048473044022058f6fc7c6a33e1b31548d481c826c015bd30135aad42cd67790dab66d2ad243b02204a1ced2604c6735b6393e5b41691dd78b00f0c5942fb9f751856faa938157dba01feffffff0280f0fa020000000017a9140fb9463421696b82c833af241c78c17ddbde493487d0f20a270100000017a91429ca74f8a08f81999428185c97b5d852e4063f618765000000\"), SER_NETWORK, PROTOCOL_VERSION);\n     CTransactionRef prev_tx2;\n     s_prev_tx2 >> prev_tx2;\n-    m_wallet.mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(prev_tx2->GetHash()), std::forward_as_tuple(&m_wallet, prev_tx2));\n+    m_wallet.mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(prev_tx2->GetHash()), std::forward_as_tuple(prev_tx2));\n \n     // Add scripts\n     CScript rs1;"
      },
      {
        "sha": "e779b2450f5327cbbbb26168b5a8b8d1e4243ba9",
        "filename": "src/wallet/test/spend_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/test/spend_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/test/spend_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/spend_tests.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -5,6 +5,7 @@\n #include <policy/fees.h>\n #include <validation.h>\n #include <wallet/coincontrol.h>\n+#include <wallet/spend.h>\n #include <wallet/test/util.h>\n #include <wallet/test/wallet_test_fixture.h>\n \n@@ -32,7 +33,7 @@ BOOST_FIXTURE_TEST_CASE(SubtractFee, TestChain100Setup)\n         coin_control.m_feerate.emplace(10000);\n         coin_control.fOverrideFeeRate = true;\n         FeeCalculation fee_calc;\n-        BOOST_CHECK(wallet->CreateTransaction({recipient}, tx, fee, change_pos, error, coin_control, fee_calc));\n+        BOOST_CHECK(CreateTransaction(*wallet, {recipient}, tx, fee, change_pos, error, coin_control, fee_calc));\n         BOOST_CHECK_EQUAL(tx->vout.size(), 1);\n         BOOST_CHECK_EQUAL(tx->vout[0].nValue, recipient.nAmount + leftover_input_amount - fee);\n         BOOST_CHECK_GT(fee, 0);"
      },
      {
        "sha": "5431a38bee807fe9bac20e4c3b5d4f4c28b11d61",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 18,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -21,6 +21,8 @@\n #include <validation.h>\n #include <wallet/coincontrol.h>\n #include <wallet/context.h>\n+#include <wallet/receive.h>\n+#include <wallet/spend.h>\n #include <wallet/test/util.h>\n #include <wallet/test/wallet_test_fixture.h>\n \n@@ -103,7 +105,7 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n         BOOST_CHECK(result.last_failed_block.IsNull());\n         BOOST_CHECK(result.last_scanned_block.IsNull());\n         BOOST_CHECK(!result.last_scanned_height);\n-        BOOST_CHECK_EQUAL(wallet.GetBalance().m_mine_immature, 0);\n+        BOOST_CHECK_EQUAL(GetBalance(wallet).m_mine_immature, 0);\n     }\n \n     // Verify ScanForWalletTransactions picks up transactions in both the old\n@@ -122,7 +124,7 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n         BOOST_CHECK(result.last_failed_block.IsNull());\n         BOOST_CHECK_EQUAL(result.last_scanned_block, newTip->GetBlockHash());\n         BOOST_CHECK_EQUAL(*result.last_scanned_height, newTip->nHeight);\n-        BOOST_CHECK_EQUAL(wallet.GetBalance().m_mine_immature, 100 * COIN);\n+        BOOST_CHECK_EQUAL(GetBalance(wallet).m_mine_immature, 100 * COIN);\n     }\n \n     // Prune the older block file.\n@@ -148,7 +150,7 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n         BOOST_CHECK_EQUAL(result.last_failed_block, oldTip->GetBlockHash());\n         BOOST_CHECK_EQUAL(result.last_scanned_block, newTip->GetBlockHash());\n         BOOST_CHECK_EQUAL(*result.last_scanned_height, newTip->nHeight);\n-        BOOST_CHECK_EQUAL(wallet.GetBalance().m_mine_immature, 50 * COIN);\n+        BOOST_CHECK_EQUAL(GetBalance(wallet).m_mine_immature, 50 * COIN);\n     }\n \n     // Prune the remaining block file.\n@@ -173,7 +175,7 @@ BOOST_FIXTURE_TEST_CASE(scan_for_wallet_transactions, TestChain100Setup)\n         BOOST_CHECK_EQUAL(result.last_failed_block, newTip->GetBlockHash());\n         BOOST_CHECK(result.last_scanned_block.IsNull());\n         BOOST_CHECK(!result.last_scanned_height);\n-        BOOST_CHECK_EQUAL(wallet.GetBalance().m_mine_immature, 0);\n+        BOOST_CHECK_EQUAL(GetBalance(wallet).m_mine_immature, 0);\n     }\n }\n \n@@ -200,6 +202,7 @@ BOOST_FIXTURE_TEST_CASE(importmulti_rescan, TestChain100Setup)\n         wallet->SetupLegacyScriptPubKeyMan();\n         WITH_LOCK(wallet->cs_wallet, wallet->SetLastBlockProcessed(newTip->nHeight, newTip->GetBlockHash()));\n         WalletContext context;\n+        context.args = &gArgs;\n         AddWallet(context, wallet);\n         UniValue keys;\n         keys.setArray();\n@@ -232,7 +235,7 @@ BOOST_FIXTURE_TEST_CASE(importmulti_rescan, TestChain100Setup)\n                       \"downloading and rescanning the relevant blocks (see -reindex and -rescan \"\n                       \"options).\\\"}},{\\\"success\\\":true}]\",\n                               0, oldTip->GetBlockTimeMax(), TIMESTAMP_WINDOW));\n-        RemoveWallet(context, wallet, /* load_on_startup= */ std::nullopt);\n+        RemoveWallet(context, wallet, /* load_on_start= */ std::nullopt);\n     }\n }\n \n@@ -260,6 +263,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n     // Import key into wallet and call dumpwallet to create backup file.\n     {\n         WalletContext context;\n+        context.args = &gArgs;\n         std::shared_ptr<CWallet> wallet = std::make_shared<CWallet>(m_node.chain.get(), \"\", CreateDummyWalletDatabase());\n         {\n             auto spk_man = wallet->GetOrCreateLegacyScriptPubKeyMan();\n@@ -276,7 +280,7 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n         request.params.push_back(backup_file);\n \n         ::dumpwallet().HandleRequest(request);\n-        RemoveWallet(context, wallet, /* load_on_startup= */ std::nullopt);\n+        RemoveWallet(context, wallet, /* load_on_start= */ std::nullopt);\n     }\n \n     // Call importwallet RPC and verify all blocks with timestamps >= BLOCK_TIME\n@@ -287,14 +291,15 @@ BOOST_FIXTURE_TEST_CASE(importwallet_rescan, TestChain100Setup)\n         wallet->SetupLegacyScriptPubKeyMan();\n \n         WalletContext context;\n+        context.args = &gArgs;\n         JSONRPCRequest request;\n         request.context = &context;\n         request.params.setArray();\n         request.params.push_back(backup_file);\n         AddWallet(context, wallet);\n         wallet->SetLastBlockProcessed(m_node.chainman->ActiveChain().Height(), m_node.chainman->ActiveChain().Tip()->GetBlockHash());\n         ::importwallet().HandleRequest(request);\n-        RemoveWallet(context, wallet, /* load_on_startup= */ std::nullopt);\n+        RemoveWallet(context, wallet, /* load_on_start= */ std::nullopt);\n \n         BOOST_CHECK_EQUAL(wallet->mapWallet.size(), 3U);\n         BOOST_CHECK_EQUAL(m_coinbase_txns.size(), 103U);\n@@ -316,7 +321,7 @@ BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n {\n     CWallet wallet(m_node.chain.get(), \"\", CreateDummyWalletDatabase());\n     auto spk_man = wallet.GetOrCreateLegacyScriptPubKeyMan();\n-    CWalletTx wtx(&wallet, m_coinbase_txns.back());\n+    CWalletTx wtx(m_coinbase_txns.back());\n \n     LOCK2(wallet.cs_wallet, spk_man->cs_KeyStore);\n     wallet.SetLastBlockProcessed(m_node.chainman->ActiveChain().Height(), m_node.chainman->ActiveChain().Tip()->GetBlockHash());\n@@ -326,13 +331,13 @@ BOOST_FIXTURE_TEST_CASE(coin_mark_dirty_immature_credit, TestChain100Setup)\n \n     // Call GetImmatureCredit() once before adding the key to the wallet to\n     // cache the current immature credit amount, which is 0.\n-    BOOST_CHECK_EQUAL(wtx.GetImmatureCredit(), 0);\n+    BOOST_CHECK_EQUAL(CachedTxGetImmatureCredit(wallet, wtx), 0);\n \n     // Invalidate the cached value, add the key, and make sure a new immature\n     // credit amount is calculated.\n     wtx.MarkDirty();\n     BOOST_CHECK(spk_man->AddKeyPubKey(coinbaseKey, coinbaseKey.GetPubKey()));\n-    BOOST_CHECK_EQUAL(wtx.GetImmatureCredit(), 50*COIN);\n+    BOOST_CHECK_EQUAL(CachedTxGetImmatureCredit(wallet, wtx), 50*COIN);\n }\n \n static int64_t AddTx(ChainstateManager& chainman, CWallet& wallet, uint32_t lockTime, int64_t mockTime, int64_t blockTime)\n@@ -503,7 +508,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n         CCoinControl dummy;\n         FeeCalculation fee_calc_out;\n         {\n-            BOOST_CHECK(wallet->CreateTransaction({recipient}, tx, fee, changePos, error, dummy, fee_calc_out));\n+            BOOST_CHECK(CreateTransaction(*wallet, {recipient}, tx, fee, changePos, error, dummy, fee_calc_out));\n         }\n         wallet->CommitTransaction(tx, {}, {});\n         CMutableTransaction blocktx;\n@@ -525,7 +530,7 @@ class ListCoinsTestingSetup : public TestChain100Setup\n     std::unique_ptr<CWallet> wallet;\n };\n \n-BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n+BOOST_FIXTURE_TEST_CASE(ListCoinsTest, ListCoinsTestingSetup)\n {\n     std::string coinbaseAddress = coinbaseKey.GetPubKey().GetID().ToString();\n \n@@ -534,14 +539,14 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     std::map<CTxDestination, std::vector<COutput>> list;\n     {\n         LOCK(wallet->cs_wallet);\n-        list = wallet->ListCoins();\n+        list = ListCoins(*wallet);\n     }\n     BOOST_CHECK_EQUAL(list.size(), 1U);\n     BOOST_CHECK_EQUAL(std::get<PKHash>(list.begin()->first).ToString(), coinbaseAddress);\n     BOOST_CHECK_EQUAL(list.begin()->second.size(), 1U);\n \n     // Check initial balance from one mature coinbase transaction.\n-    BOOST_CHECK_EQUAL(50 * COIN, wallet->GetAvailableBalance());\n+    BOOST_CHECK_EQUAL(50 * COIN, GetAvailableBalance(*wallet));\n \n     // Add a transaction creating a change address, and confirm ListCoins still\n     // returns the coin associated with the change address underneath the\n@@ -550,7 +555,7 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     AddTx(CRecipient{GetScriptForRawPubKey({}), 1 * COIN, false /* subtract fee */});\n     {\n         LOCK(wallet->cs_wallet);\n-        list = wallet->ListCoins();\n+        list = ListCoins(*wallet);\n     }\n     BOOST_CHECK_EQUAL(list.size(), 1U);\n     BOOST_CHECK_EQUAL(std::get<PKHash>(list.begin()->first).ToString(), coinbaseAddress);\n@@ -560,7 +565,7 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     {\n         LOCK(wallet->cs_wallet);\n         std::vector<COutput> available;\n-        wallet->AvailableCoins(available);\n+        AvailableCoins(*wallet, available);\n         BOOST_CHECK_EQUAL(available.size(), 2U);\n     }\n     for (const auto& group : list) {\n@@ -572,14 +577,14 @@ BOOST_FIXTURE_TEST_CASE(ListCoins, ListCoinsTestingSetup)\n     {\n         LOCK(wallet->cs_wallet);\n         std::vector<COutput> available;\n-        wallet->AvailableCoins(available);\n+        AvailableCoins(*wallet, available);\n         BOOST_CHECK_EQUAL(available.size(), 0U);\n     }\n     // Confirm ListCoins still returns same result as before, despite coins\n     // being locked.\n     {\n         LOCK(wallet->cs_wallet);\n-        list = wallet->ListCoins();\n+        list = ListCoins(*wallet);\n     }\n     BOOST_CHECK_EQUAL(list.size(), 1U);\n     BOOST_CHECK_EQUAL(std::get<PKHash>(list.begin()->first).ToString(), coinbaseAddress);\n@@ -685,6 +690,7 @@ BOOST_FIXTURE_TEST_CASE(CreateWallet, TestChain100Setup)\n     gArgs.ForceSetArg(\"-unsafesqlitesync\", \"1\");\n     // Create new wallet with known key and unload it.\n     WalletContext context;\n+    context.args = &gArgs;\n     context.chain = m_node.chain.get();\n     auto wallet = TestLoadWallet(context);\n     CKey key;\n@@ -781,6 +787,7 @@ BOOST_FIXTURE_TEST_CASE(CreateWallet, TestChain100Setup)\n BOOST_FIXTURE_TEST_CASE(CreateWalletWithoutChain, BasicTestingSetup)\n {\n     WalletContext context;\n+    context.args = &gArgs;\n     auto wallet = TestLoadWallet(context);\n     BOOST_CHECK(wallet);\n     UnloadWallet(std::move(wallet));\n@@ -790,6 +797,7 @@ BOOST_FIXTURE_TEST_CASE(ZapSelectTx, TestChain100Setup)\n {\n     gArgs.ForceSetArg(\"-unsafesqlitesync\", \"1\");\n     WalletContext context;\n+    context.args = &gArgs;\n     context.chain = m_node.chain.get();\n     auto wallet = TestLoadWallet(context);\n     CKey key;"
      },
      {
        "sha": "0cd91b9ebee6b66431d50cc9f3efc8d378a5134d",
        "filename": "src/wallet/transaction.h",
        "status": "modified",
        "additions": 9,
        "deletions": 91,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/transaction.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -17,30 +17,8 @@\n #include <list>\n #include <vector>\n \n-struct COutputEntry;\n-\n typedef std::map<std::string, std::string> mapValue_t;\n \n-//Get the marginal bytes of spending the specified output\n-int CalculateMaximumSignedInputSize(const CTxOut& txout, const CWallet* pwallet, bool use_max_sig = false);\n-\n-static inline void ReadOrderPos(int64_t& nOrderPos, mapValue_t& mapValue)\n-{\n-    if (!mapValue.count(\"n\"))\n-    {\n-        nOrderPos = -1; // TODO: calculate elsewhere\n-        return;\n-    }\n-    nOrderPos = atoi64(mapValue[\"n\"]);\n-}\n-\n-static inline void WriteOrderPos(const int64_t& nOrderPos, mapValue_t& mapValue)\n-{\n-    if (nOrderPos == -1)\n-        return;\n-    mapValue[\"n\"] = ToString(nOrderPos);\n-}\n-\n /** Legacy class used for deserializing vtxPrev for backwards compatibility.\n  * vtxPrev was removed in commit 93a18a3650292afbb441a47d1fa1b94aeb0164e3,\n  * but old wallet.dat files may still contain vtxPrev vectors of CMerkleTxs.\n@@ -68,8 +46,6 @@ class CMerkleTx\n class CWalletTx\n {\n private:\n-    const CWallet* const pwallet;\n-\n     /** Constant used in hashBlock to indicate tx has been abandoned, only used at\n      * serialization/deserialization to avoid ambiguity with conflicted.\n      */\n@@ -126,7 +102,6 @@ class CWalletTx\n \n     // memory only\n     enum AmountType { DEBIT, CREDIT, IMMATURE_CREDIT, AVAILABLE_CREDIT, AMOUNTTYPE_ENUM_ELEMENTS };\n-    CAmount GetCachableAmount(AmountType type, const isminefilter& filter, bool recalculate = false) const;\n     mutable CachableAmount m_amounts[AMOUNTTYPE_ENUM_ELEMENTS];\n     /**\n      * This flag is true if all m_amounts caches are empty. This is particularly\n@@ -139,9 +114,8 @@ class CWalletTx\n     mutable bool fInMempool;\n     mutable CAmount nChangeCached;\n \n-    CWalletTx(const CWallet* wallet, CTransactionRef arg)\n-        : pwallet(wallet),\n-          tx(std::move(arg))\n+    CWalletTx(CTransactionRef arg)\n+        : tx(std::move(arg))\n     {\n         Init();\n     }\n@@ -199,7 +173,9 @@ class CWalletTx\n         mapValue_t mapValueCopy = mapValue;\n \n         mapValueCopy[\"fromaccount\"] = \"\";\n-        WriteOrderPos(nOrderPos, mapValueCopy);\n+        if (nOrderPos != -1) {\n+            mapValueCopy[\"n\"] = ToString(nOrderPos);\n+        }\n         if (nTimeSmart) {\n             mapValueCopy[\"timesmart\"] = strprintf(\"%u\", nTimeSmart);\n         }\n@@ -239,8 +215,10 @@ class CWalletTx\n             setConfirmed();\n         }\n \n-        ReadOrderPos(nOrderPos, mapValue);\n-        nTimeSmart = mapValue.count(\"timesmart\") ? (unsigned int)atoi64(mapValue[\"timesmart\"]) : 0;\n+        const auto it_op = mapValue.find(\"n\");\n+        nOrderPos = (it_op != mapValue.end()) ? atoi64(it_op->second) : -1;\n+        const auto it_ts = mapValue.find(\"timesmart\");\n+        nTimeSmart = (it_ts != mapValue.end()) ? static_cast<unsigned int>(atoi64(it_ts->second)) : 0;\n \n         mapValue.erase(\"fromaccount\");\n         mapValue.erase(\"spent\");\n@@ -264,72 +242,13 @@ class CWalletTx\n         m_is_cache_empty = true;\n     }\n \n-    //! filter decides which addresses will count towards the debit\n-    CAmount GetDebit(const isminefilter& filter) const;\n-    CAmount GetCredit(const isminefilter& filter) const;\n-    CAmount GetImmatureCredit(bool fUseCache = true) const;\n-    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n-    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The\n-    // annotation \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid\n-    // having to resolve the issue of member access into incomplete type CWallet.\n-    CAmount GetAvailableCredit(bool fUseCache = true, const isminefilter& filter = ISMINE_SPENDABLE) const NO_THREAD_SAFETY_ANALYSIS;\n-    CAmount GetImmatureWatchOnlyCredit(const bool fUseCache = true) const;\n-    CAmount GetChange() const;\n-\n-    /** Get the marginal bytes if spending the specified output from this transaction */\n-    int GetSpendSize(unsigned int out, bool use_max_sig = false) const\n-    {\n-        return CalculateMaximumSignedInputSize(tx->vout[out], pwallet, use_max_sig);\n-    }\n-\n-    void GetAmounts(std::list<COutputEntry>& listReceived,\n-                    std::list<COutputEntry>& listSent, CAmount& nFee, const isminefilter& filter) const;\n-\n-    bool IsFromMe(const isminefilter& filter) const\n-    {\n-        return (GetDebit(filter) > 0);\n-    }\n-\n     /** True if only scriptSigs are different */\n     bool IsEquivalentTo(const CWalletTx& tx) const;\n \n     bool InMempool() const;\n-    bool IsTrusted() const;\n \n     int64_t GetTxTime() const;\n \n-    /** Pass this transaction to node for mempool insertion and relay to peers if flag set to true */\n-    bool SubmitMemoryPoolAndRelay(std::string& err_string, bool relay);\n-\n-    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n-    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The annotation\n-    // \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid having to\n-    // resolve the issue of member access into incomplete type CWallet. Note\n-    // that we still have the runtime check \"AssertLockHeld(pwallet->cs_wallet)\"\n-    // in place.\n-    std::set<uint256> GetConflicts() const NO_THREAD_SAFETY_ANALYSIS;\n-\n-    /**\n-     * Return depth of transaction in blockchain:\n-     * <0  : conflicts with a transaction this deep in the blockchain\n-     *  0  : in memory pool, waiting to be included in a block\n-     * >=1 : this many blocks deep in the main chain\n-     */\n-    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n-    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The annotation\n-    // \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid having to\n-    // resolve the issue of member access into incomplete type CWallet. Note\n-    // that we still have the runtime check \"AssertLockHeld(pwallet->cs_wallet)\"\n-    // in place.\n-    int GetDepthInMainChain() const NO_THREAD_SAFETY_ANALYSIS;\n-    bool IsInMainChain() const { return GetDepthInMainChain() > 0; }\n-\n-    /**\n-     * @return number of blocks to maturity for this transaction:\n-     *  0 : is not a coinbase transaction, or is a mature coinbase transaction\n-     * >0 : is a coinbase transaction which matures in this many blocks\n-     */\n-    int GetBlocksToMaturity() const;\n     bool isAbandoned() const { return m_confirm.status == CWalletTx::ABANDONED; }\n     void setAbandoned()\n     {\n@@ -346,7 +265,6 @@ class CWalletTx\n     void setConfirmed() { m_confirm.status = CWalletTx::CONFIRMED; }\n     const uint256& GetHash() const { return tx->GetHash(); }\n     bool IsCoinBase() const { return tx->IsCoinBase(); }\n-    bool IsImmatureCoinBase() const;\n \n     // Disable copying of CWalletTx objects to prevent bugs where instances get\n     // copied in and out of the mapWallet map, and fields are updated in the"
      },
      {
        "sha": "70349b245580d562af5254c1e1fdf1f17cc862d3",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 108,
        "deletions": 96,
        "changes": 204,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -581,7 +581,7 @@ bool CWallet::IsSpent(const uint256& hash, unsigned int n) const\n         const uint256& wtxid = it->second;\n         std::map<uint256, CWalletTx>::const_iterator mit = mapWallet.find(wtxid);\n         if (mit != mapWallet.end()) {\n-            int depth = mit->second.GetDepthInMainChain();\n+            int depth = GetTxDepthInMainChain(mit->second);\n             if (depth > 0  || (depth == 0 && !mit->second.isAbandoned()))\n                 return true; // Spent\n         }\n@@ -900,7 +900,7 @@ CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const CWalletTx::Confirmatio\n     }\n \n     // Inserts only if not already there, returns tx inserted or tx found\n-    auto ret = mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(hash), std::forward_as_tuple(this, tx));\n+    auto ret = mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(hash), std::forward_as_tuple(tx));\n     CWalletTx& wtx = (*ret.first).second;\n     bool fInsertedNew = ret.second;\n     bool fUpdated = update_wtx && update_wtx(wtx, fInsertedNew);\n@@ -984,7 +984,7 @@ CWalletTx* CWallet::AddToWallet(CTransactionRef tx, const CWalletTx::Confirmatio\n \n bool CWallet::LoadToWallet(const uint256& hash, const UpdateWalletTxFn& fill_wtx)\n {\n-    const auto& ins = mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(hash), std::forward_as_tuple(this, nullptr));\n+    const auto& ins = mapWallet.emplace(std::piecewise_construct, std::forward_as_tuple(hash), std::forward_as_tuple(nullptr));\n     CWalletTx& wtx = ins.first->second;\n     if (!fill_wtx(wtx, ins.second)) {\n         return false;\n@@ -1074,7 +1074,7 @@ bool CWallet::TransactionCanBeAbandoned(const uint256& hashTx) const\n {\n     LOCK(cs_wallet);\n     const CWalletTx* wtx = GetWalletTx(hashTx);\n-    return wtx && !wtx->isAbandoned() && wtx->GetDepthInMainChain() == 0 && !wtx->InMempool();\n+    return wtx && !wtx->isAbandoned() && GetTxDepthInMainChain(*wtx) == 0 && !wtx->InMempool();\n }\n \n void CWallet::MarkInputsDirty(const CTransactionRef& tx)\n@@ -1100,7 +1100,7 @@ bool CWallet::AbandonTransaction(const uint256& hashTx)\n     auto it = mapWallet.find(hashTx);\n     assert(it != mapWallet.end());\n     const CWalletTx& origtx = it->second;\n-    if (origtx.GetDepthInMainChain() != 0 || origtx.InMempool()) {\n+    if (GetTxDepthInMainChain(origtx) != 0 || origtx.InMempool()) {\n         return false;\n     }\n \n@@ -1113,7 +1113,7 @@ bool CWallet::AbandonTransaction(const uint256& hashTx)\n         auto it = mapWallet.find(now);\n         assert(it != mapWallet.end());\n         CWalletTx& wtx = it->second;\n-        int currentconfirm = wtx.GetDepthInMainChain();\n+        int currentconfirm = GetTxDepthInMainChain(wtx);\n         // If the orig tx was not in block, none of its spends can be\n         assert(currentconfirm <= 0);\n         // if (currentconfirm < 0) {Tx and spends are already conflicted, no need to abandon}\n@@ -1168,7 +1168,7 @@ void CWallet::MarkConflicted(const uint256& hashBlock, int conflicting_height, c\n         auto it = mapWallet.find(now);\n         assert(it != mapWallet.end());\n         CWalletTx& wtx = it->second;\n-        int currentconfirm = wtx.GetDepthInMainChain();\n+        int currentconfirm = GetTxDepthInMainChain(wtx);\n         if (conflictconfirms < currentconfirm) {\n             // Block is 'more conflicted' than current confirm; update.\n             // Mark transaction as conflicted with this block.\n@@ -1364,9 +1364,10 @@ CAmount CWallet::GetDebit(const CTransaction& tx, const isminefilter& filter) co\n bool CWallet::IsHDEnabled() const\n {\n     // All Active ScriptPubKeyMans must be HD for this to be true\n-    bool result = true;\n+    bool result = false;\n     for (const auto& spk_man : GetActiveScriptPubKeyMans()) {\n-        result &= spk_man->IsHDEnabled();\n+        if (!spk_man->IsHDEnabled()) return false;\n+        result = true;\n     }\n     return result;\n }\n@@ -1697,7 +1698,7 @@ void CWallet::ReacceptWalletTransactions()\n         CWalletTx& wtx = item.second;\n         assert(wtx.GetHash() == wtxid);\n \n-        int nDepth = wtx.GetDepthInMainChain();\n+        int nDepth = GetTxDepthInMainChain(wtx);\n \n         if (!wtx.IsCoinBase() && (nDepth == 0 && !wtx.isAbandoned())) {\n             mapSorted.insert(std::make_pair(wtx.nOrderPos, &wtx));\n@@ -1708,24 +1709,24 @@ void CWallet::ReacceptWalletTransactions()\n     for (const std::pair<const int64_t, CWalletTx*>& item : mapSorted) {\n         CWalletTx& wtx = *(item.second);\n         std::string unused_err_string;\n-        wtx.SubmitMemoryPoolAndRelay(unused_err_string, false);\n+        SubmitTxMemoryPoolAndRelay(wtx, unused_err_string, false);\n     }\n }\n \n-bool CWalletTx::SubmitMemoryPoolAndRelay(std::string& err_string, bool relay)\n+bool CWallet::SubmitTxMemoryPoolAndRelay(const CWalletTx& wtx, std::string& err_string, bool relay) const\n {\n     // Can't relay if wallet is not broadcasting\n-    if (!pwallet->GetBroadcastTransactions()) return false;\n+    if (!GetBroadcastTransactions()) return false;\n     // Don't relay abandoned transactions\n-    if (isAbandoned()) return false;\n+    if (wtx.isAbandoned()) return false;\n     // Don't try to submit coinbase transactions. These would fail anyway but would\n     // cause log spam.\n-    if (IsCoinBase()) return false;\n+    if (wtx.IsCoinBase()) return false;\n     // Don't try to submit conflicted or confirmed transactions.\n-    if (GetDepthInMainChain() != 0) return false;\n+    if (GetTxDepthInMainChain(wtx) != 0) return false;\n \n     // Submit transaction to mempool for relay\n-    pwallet->WalletLogPrintf(\"Submitting wtx %s to mempool for relay\\n\", GetHash().ToString());\n+    WalletLogPrintf(\"Submitting wtx %s to mempool for relay\\n\", wtx.GetHash().ToString());\n     // We must set fInMempool here - while it will be re-set to true by the\n     // entered-mempool callback, if we did not there would be a race where a\n     // user could call sendmoney in a loop and hit spurious out of funds errors\n@@ -1735,18 +1736,17 @@ bool CWalletTx::SubmitMemoryPoolAndRelay(std::string& err_string, bool relay)\n     // Irrespective of the failure reason, un-marking fInMempool\n     // out-of-order is incorrect - it should be unmarked when\n     // TransactionRemovedFromMempool fires.\n-    bool ret = pwallet->chain().broadcastTransaction(tx, pwallet->m_default_max_tx_fee, relay, err_string);\n-    fInMempool |= ret;\n+    bool ret = chain().broadcastTransaction(wtx.tx, m_default_max_tx_fee, relay, err_string);\n+    wtx.fInMempool |= ret;\n     return ret;\n }\n \n-std::set<uint256> CWalletTx::GetConflicts() const\n+std::set<uint256> CWallet::GetTxConflicts(const CWalletTx& wtx) const\n {\n     std::set<uint256> result;\n-    if (pwallet != nullptr)\n     {\n-        uint256 myHash = GetHash();\n-        result = pwallet->GetConflicts(myHash);\n+        uint256 myHash = wtx.GetHash();\n+        result = GetConflicts(myHash);\n         result.erase(myHash);\n     }\n     return result;\n@@ -1784,11 +1784,11 @@ void CWallet::ResendWalletTransactions()\n         for (std::pair<const uint256, CWalletTx>& item : mapWallet) {\n             CWalletTx& wtx = item.second;\n             // Attempt to rebroadcast all txes more than 5 minutes older than\n-            // the last block. SubmitMemoryPoolAndRelay() will not rebroadcast\n+            // the last block. SubmitTxMemoryPoolAndRelay() will not rebroadcast\n             // any confirmed or conflicting txs.\n             if (wtx.nTimeReceived > m_best_block_time - 5 * 60) continue;\n             std::string unused_err_string;\n-            if (wtx.SubmitMemoryPoolAndRelay(unused_err_string, true)) ++submitted_tx_count;\n+            if (SubmitTxMemoryPoolAndRelay(wtx, unused_err_string, true)) ++submitted_tx_count;\n         }\n     } // cs_wallet\n \n@@ -1976,7 +1976,7 @@ void CWallet::CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::ve\n     }\n \n     std::string err_string;\n-    if (!wtx.SubmitMemoryPoolAndRelay(err_string, true)) {\n+    if (!SubmitTxMemoryPoolAndRelay(wtx, err_string, true)) {\n         WalletLogPrintf(\"CommitTransaction(): Transaction cannot be broadcast immediately, %s\\n\", err_string);\n         // TODO: if we expect the failure to be long term or permanent, instead delete wtx from the wallet and return failure.\n     }\n@@ -2191,7 +2191,7 @@ void CWallet::MarkDestinationsDirty(const std::set<CTxDestination>& destinations\n \n std::set<CTxDestination> CWallet::GetLabelAddresses(const std::string& label) const\n {\n-    LOCK(cs_wallet);\n+    AssertLockHeld(cs_wallet);\n     std::set<CTxDestination> result;\n     for (const std::pair<const CTxDestination, CAddressBookData>& item : m_address_book)\n     {\n@@ -2509,6 +2509,7 @@ std::unique_ptr<WalletDatabase> MakeWalletDatabase(const std::string& name, cons\n std::shared_ptr<CWallet> CWallet::Create(WalletContext& context, const std::string& name, std::unique_ptr<WalletDatabase> database, uint64_t wallet_creation_flags, bilingual_str& error, std::vector<bilingual_str>& warnings)\n {\n     interfaces::Chain* chain = context.chain;\n+    ArgsManager& args = *Assert(context.args);\n     const std::string& walletFile = database->Filename();\n \n     int64_t nStart = GetTimeMillis();\n@@ -2590,123 +2591,134 @@ std::shared_ptr<CWallet> CWallet::Create(WalletContext& context, const std::stri\n         }\n     }\n \n-    if (!gArgs.GetArg(\"-addresstype\", \"\").empty()) {\n-        std::optional<OutputType> parsed = ParseOutputType(gArgs.GetArg(\"-addresstype\", \"\"));\n+    if (!args.GetArg(\"-addresstype\", \"\").empty()) {\n+        std::optional<OutputType> parsed = ParseOutputType(args.GetArg(\"-addresstype\", \"\"));\n         if (!parsed) {\n-            error = strprintf(_(\"Unknown address type '%s'\"), gArgs.GetArg(\"-addresstype\", \"\"));\n+            error = strprintf(_(\"Unknown address type '%s'\"), args.GetArg(\"-addresstype\", \"\"));\n             return nullptr;\n         }\n         walletInstance->m_default_address_type = parsed.value();\n     }\n \n-    if (!gArgs.GetArg(\"-changetype\", \"\").empty()) {\n-        std::optional<OutputType> parsed = ParseOutputType(gArgs.GetArg(\"-changetype\", \"\"));\n+    if (!args.GetArg(\"-changetype\", \"\").empty()) {\n+        std::optional<OutputType> parsed = ParseOutputType(args.GetArg(\"-changetype\", \"\"));\n         if (!parsed) {\n-            error = strprintf(_(\"Unknown change type '%s'\"), gArgs.GetArg(\"-changetype\", \"\"));\n+            error = strprintf(_(\"Unknown change type '%s'\"), args.GetArg(\"-changetype\", \"\"));\n             return nullptr;\n         }\n         walletInstance->m_default_change_type = parsed.value();\n     }\n \n-    if (gArgs.IsArgSet(\"-mintxfee\")) {\n-        CAmount n = 0;\n-        if (!ParseMoney(gArgs.GetArg(\"-mintxfee\", \"\"), n) || 0 == n) {\n-            error = AmountErrMsg(\"mintxfee\", gArgs.GetArg(\"-mintxfee\", \"\"));\n+    if (args.IsArgSet(\"-mintxfee\")) {\n+        std::optional<CAmount> min_tx_fee = ParseMoney(args.GetArg(\"-mintxfee\", \"\"));\n+        if (!min_tx_fee || min_tx_fee.value() == 0) {\n+            error = AmountErrMsg(\"mintxfee\", args.GetArg(\"-mintxfee\", \"\"));\n             return nullptr;\n-        }\n-        if (n > HIGH_TX_FEE_PER_KB) {\n+        } else if (min_tx_fee.value() > HIGH_TX_FEE_PER_KB) {\n             warnings.push_back(AmountHighWarn(\"-mintxfee\") + Untranslated(\" \") +\n                                _(\"This is the minimum transaction fee you pay on every transaction.\"));\n         }\n-        walletInstance->m_min_fee = CFeeRate(n);\n+\n+        walletInstance->m_min_fee = CFeeRate{min_tx_fee.value()};\n     }\n \n-    if (gArgs.IsArgSet(\"-maxapsfee\")) {\n-        const std::string max_aps_fee{gArgs.GetArg(\"-maxapsfee\", \"\")};\n-        CAmount n = 0;\n+    if (args.IsArgSet(\"-maxapsfee\")) {\n+        const std::string max_aps_fee{args.GetArg(\"-maxapsfee\", \"\")};\n         if (max_aps_fee == \"-1\") {\n-            n = -1;\n-        } else if (!ParseMoney(max_aps_fee, n)) {\n+            walletInstance->m_max_aps_fee = -1;\n+        } else if (std::optional<CAmount> max_fee = ParseMoney(max_aps_fee)) {\n+            if (max_fee.value() > HIGH_APS_FEE) {\n+                warnings.push_back(AmountHighWarn(\"-maxapsfee\") + Untranslated(\" \") +\n+                                  _(\"This is the maximum transaction fee you pay (in addition to the normal fee) to prioritize partial spend avoidance over regular coin selection.\"));\n+            }\n+            walletInstance->m_max_aps_fee = max_fee.value();\n+        } else {\n             error = AmountErrMsg(\"maxapsfee\", max_aps_fee);\n             return nullptr;\n         }\n-        if (n > HIGH_APS_FEE) {\n-            warnings.push_back(AmountHighWarn(\"-maxapsfee\") + Untranslated(\" \") +\n-                              _(\"This is the maximum transaction fee you pay (in addition to the normal fee) to prioritize partial spend avoidance over regular coin selection.\"));\n-        }\n-        walletInstance->m_max_aps_fee = n;\n     }\n \n-    if (gArgs.IsArgSet(\"-fallbackfee\")) {\n-        CAmount nFeePerK = 0;\n-        if (!ParseMoney(gArgs.GetArg(\"-fallbackfee\", \"\"), nFeePerK)) {\n-            error = strprintf(_(\"Invalid amount for -fallbackfee=<amount>: '%s'\"), gArgs.GetArg(\"-fallbackfee\", \"\"));\n+    if (args.IsArgSet(\"-fallbackfee\")) {\n+        std::optional<CAmount> fallback_fee = ParseMoney(args.GetArg(\"-fallbackfee\", \"\"));\n+        if (!fallback_fee) {\n+            error = strprintf(_(\"Invalid amount for -fallbackfee=<amount>: '%s'\"), args.GetArg(\"-fallbackfee\", \"\"));\n             return nullptr;\n-        }\n-        if (nFeePerK > HIGH_TX_FEE_PER_KB) {\n+        } else if (fallback_fee.value() > HIGH_TX_FEE_PER_KB) {\n             warnings.push_back(AmountHighWarn(\"-fallbackfee\") + Untranslated(\" \") +\n                                _(\"This is the transaction fee you may pay when fee estimates are not available.\"));\n         }\n-        walletInstance->m_fallback_fee = CFeeRate(nFeePerK);\n+        walletInstance->m_fallback_fee = CFeeRate{fallback_fee.value()};\n     }\n+\n     // Disable fallback fee in case value was set to 0, enable if non-null value\n     walletInstance->m_allow_fallback_fee = walletInstance->m_fallback_fee.GetFeePerK() != 0;\n \n-    if (gArgs.IsArgSet(\"-discardfee\")) {\n-        CAmount nFeePerK = 0;\n-        if (!ParseMoney(gArgs.GetArg(\"-discardfee\", \"\"), nFeePerK)) {\n-            error = strprintf(_(\"Invalid amount for -discardfee=<amount>: '%s'\"), gArgs.GetArg(\"-discardfee\", \"\"));\n+    if (args.IsArgSet(\"-discardfee\")) {\n+        std::optional<CAmount> discard_fee = ParseMoney(args.GetArg(\"-discardfee\", \"\"));\n+        if (!discard_fee) {\n+            error = strprintf(_(\"Invalid amount for -discardfee=<amount>: '%s'\"), args.GetArg(\"-discardfee\", \"\"));\n             return nullptr;\n-        }\n-        if (nFeePerK > HIGH_TX_FEE_PER_KB) {\n+        } else if (discard_fee.value() > HIGH_TX_FEE_PER_KB) {\n             warnings.push_back(AmountHighWarn(\"-discardfee\") + Untranslated(\" \") +\n                                _(\"This is the transaction fee you may discard if change is smaller than dust at this level\"));\n         }\n-        walletInstance->m_discard_rate = CFeeRate(nFeePerK);\n+        walletInstance->m_discard_rate = CFeeRate{discard_fee.value()};\n     }\n-    if (gArgs.IsArgSet(\"-paytxfee\")) {\n-        CAmount nFeePerK = 0;\n-        if (!ParseMoney(gArgs.GetArg(\"-paytxfee\", \"\"), nFeePerK)) {\n-            error = AmountErrMsg(\"paytxfee\", gArgs.GetArg(\"-paytxfee\", \"\"));\n+\n+    if (args.IsArgSet(\"-paytxfee\")) {\n+        std::optional<CAmount> pay_tx_fee = ParseMoney(args.GetArg(\"-paytxfee\", \"\"));\n+        if (!pay_tx_fee) {\n+            error = AmountErrMsg(\"paytxfee\", args.GetArg(\"-paytxfee\", \"\"));\n             return nullptr;\n-        }\n-        if (nFeePerK > HIGH_TX_FEE_PER_KB) {\n+        } else if (pay_tx_fee.value() > HIGH_TX_FEE_PER_KB) {\n             warnings.push_back(AmountHighWarn(\"-paytxfee\") + Untranslated(\" \") +\n                                _(\"This is the transaction fee you will pay if you send a transaction.\"));\n         }\n-        walletInstance->m_pay_tx_fee = CFeeRate(nFeePerK, 1000);\n+\n+        walletInstance->m_pay_tx_fee = CFeeRate{pay_tx_fee.value(), 1000};\n+\n         if (chain && walletInstance->m_pay_tx_fee < chain->relayMinFee()) {\n             error = strprintf(_(\"Invalid amount for -paytxfee=<amount>: '%s' (must be at least %s)\"),\n-                gArgs.GetArg(\"-paytxfee\", \"\"), chain->relayMinFee().ToString());\n+                args.GetArg(\"-paytxfee\", \"\"), chain->relayMinFee().ToString());\n             return nullptr;\n         }\n     }\n \n-    if (gArgs.IsArgSet(\"-maxtxfee\")) {\n-        CAmount nMaxFee = 0;\n-        if (!ParseMoney(gArgs.GetArg(\"-maxtxfee\", \"\"), nMaxFee)) {\n-            error = AmountErrMsg(\"maxtxfee\", gArgs.GetArg(\"-maxtxfee\", \"\"));\n+    if (args.IsArgSet(\"-maxtxfee\")) {\n+        std::optional<CAmount> max_fee = ParseMoney(args.GetArg(\"-maxtxfee\", \"\"));\n+        if (!max_fee) {\n+            error = AmountErrMsg(\"maxtxfee\", args.GetArg(\"-maxtxfee\", \"\"));\n             return nullptr;\n-        }\n-        if (nMaxFee > HIGH_MAX_TX_FEE) {\n+        } else if (max_fee.value() > HIGH_MAX_TX_FEE) {\n             warnings.push_back(_(\"-maxtxfee is set very high! Fees this large could be paid on a single transaction.\"));\n         }\n-        if (chain && CFeeRate(nMaxFee, 1000) < chain->relayMinFee()) {\n+\n+        if (chain && CFeeRate{max_fee.value(), 1000} < chain->relayMinFee()) {\n             error = strprintf(_(\"Invalid amount for -maxtxfee=<amount>: '%s' (must be at least the minrelay fee of %s to prevent stuck transactions)\"),\n-                gArgs.GetArg(\"-maxtxfee\", \"\"), chain->relayMinFee().ToString());\n+                args.GetArg(\"-maxtxfee\", \"\"), chain->relayMinFee().ToString());\n+            return nullptr;\n+        }\n+\n+        walletInstance->m_default_max_tx_fee = max_fee.value();\n+    }\n+\n+    if (gArgs.IsArgSet(\"-consolidatefeerate\")) {\n+        if (std::optional<CAmount> consolidate_feerate = ParseMoney(gArgs.GetArg(\"-consolidatefeerate\", \"\"))) {\n+            walletInstance->m_consolidate_feerate = CFeeRate(*consolidate_feerate);\n+        } else {\n+            error = AmountErrMsg(\"consolidatefeerate\", gArgs.GetArg(\"-consolidatefeerate\", \"\"));\n             return nullptr;\n         }\n-        walletInstance->m_default_max_tx_fee = nMaxFee;\n     }\n \n     if (chain && chain->relayMinFee().GetFeePerK() > HIGH_TX_FEE_PER_KB) {\n         warnings.push_back(AmountHighWarn(\"-minrelaytxfee\") + Untranslated(\" \") +\n                            _(\"The wallet will avoid paying less than the minimum relay fee.\"));\n     }\n \n-    walletInstance->m_confirm_target = gArgs.GetArg(\"-txconfirmtarget\", DEFAULT_TX_CONFIRM_TARGET);\n-    walletInstance->m_spend_zero_conf_change = gArgs.GetBoolArg(\"-spendzeroconfchange\", DEFAULT_SPEND_ZEROCONF_CHANGE);\n-    walletInstance->m_signal_rbf = gArgs.GetBoolArg(\"-walletrbf\", DEFAULT_WALLET_RBF);\n+    walletInstance->m_confirm_target = args.GetArg(\"-txconfirmtarget\", DEFAULT_TX_CONFIRM_TARGET);\n+    walletInstance->m_spend_zero_conf_change = args.GetBoolArg(\"-spendzeroconfchange\", DEFAULT_SPEND_ZEROCONF_CHANGE);\n+    walletInstance->m_signal_rbf = args.GetBoolArg(\"-walletrbf\", DEFAULT_WALLET_RBF);\n \n     walletInstance->WalletLogPrintf(\"Wallet completed loading in %15dms\\n\", GetTimeMillis() - nStart);\n \n@@ -2726,7 +2738,7 @@ std::shared_ptr<CWallet> CWallet::Create(WalletContext& context, const std::stri\n         }\n     }\n \n-    walletInstance->SetBroadcastTransactions(gArgs.GetBoolArg(\"-walletbroadcast\", DEFAULT_WALLETBROADCAST));\n+    walletInstance->SetBroadcastTransactions(args.GetBoolArg(\"-walletbroadcast\", DEFAULT_WALLETBROADCAST));\n \n     {\n         walletInstance->WalletLogPrintf(\"setKeyPool.size() = %u\\n\",      walletInstance->GetKeyPoolSize());\n@@ -2898,28 +2910,27 @@ CKeyPool::CKeyPool(const CPubKey& vchPubKeyIn, bool internalIn)\n     m_pre_split = false;\n }\n \n-int CWalletTx::GetDepthInMainChain() const\n+int CWallet::GetTxDepthInMainChain(const CWalletTx& wtx) const\n {\n-    assert(pwallet != nullptr);\n-    AssertLockHeld(pwallet->cs_wallet);\n-    if (isUnconfirmed() || isAbandoned()) return 0;\n+    AssertLockHeld(cs_wallet);\n+    if (wtx.isUnconfirmed() || wtx.isAbandoned()) return 0;\n \n-    return (pwallet->GetLastBlockHeight() - m_confirm.block_height + 1) * (isConflicted() ? -1 : 1);\n+    return (GetLastBlockHeight() - wtx.m_confirm.block_height + 1) * (wtx.isConflicted() ? -1 : 1);\n }\n \n-int CWalletTx::GetBlocksToMaturity() const\n+int CWallet::GetTxBlocksToMaturity(const CWalletTx& wtx) const\n {\n-    if (!IsCoinBase())\n+    if (!wtx.IsCoinBase())\n         return 0;\n-    int chain_depth = GetDepthInMainChain();\n+    int chain_depth = GetTxDepthInMainChain(wtx);\n     assert(chain_depth >= 0); // coinbase tx should not be conflicted\n     return std::max(0, (COINBASE_MATURITY+1) - chain_depth);\n }\n \n-bool CWalletTx::IsImmatureCoinBase() const\n+bool CWallet::IsTxImmatureCoinBase(const CWalletTx& wtx) const\n {\n     // note GetBlocksToMaturity is 0 for non-coinbase tx\n-    return GetBlocksToMaturity() > 0;\n+    return GetTxBlocksToMaturity(wtx) > 0;\n }\n \n bool CWallet::IsCrypted() const\n@@ -3241,12 +3252,13 @@ DescriptorScriptPubKeyMan* CWallet::GetDescriptorScriptPubKeyMan(const WalletDes\n \n ScriptPubKeyMan* CWallet::AddWalletDescriptor(WalletDescriptor& desc, const FlatSigningProvider& signing_provider, const std::string& label, bool internal)\n {\n+    AssertLockHeld(cs_wallet);\n+\n     if (!IsWalletFlagSet(WALLET_FLAG_DESCRIPTORS)) {\n         WalletLogPrintf(\"Cannot add WalletDescriptor to a non-descriptor wallet\\n\");\n         return nullptr;\n     }\n \n-    LOCK(cs_wallet);\n     auto spk_man = GetDescriptorScriptPubKeyMan(desc);\n     if (spk_man) {\n         WalletLogPrintf(\"Update existing descriptor: %s\\n\", desc.descriptor->ToString());"
      },
      {
        "sha": "2dc9eff712125fd11ba2d988d5cf4a660792e765",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 39,
        "deletions": 89,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -21,9 +21,7 @@\n #include <validationinterface.h>\n #include <wallet/coinselection.h>\n #include <wallet/crypter.h>\n-#include <wallet/receive.h>\n #include <wallet/scriptpubkeyman.h>\n-#include <wallet/spend.h>\n #include <wallet/transaction.h>\n #include <wallet/walletdb.h>\n #include <wallet/walletutil.h>\n@@ -73,6 +71,8 @@ static const CAmount DEFAULT_FALLBACK_FEE = 0;\n static const CAmount DEFAULT_DISCARD_FEE = 10000;\n //! -mintxfee default\n static const CAmount DEFAULT_TRANSACTION_MINFEE = 1000;\n+//! -consolidatefeerate default\n+static const CAmount DEFAULT_CONSOLIDATE_FEERATE{10000}; // 10 sat/vbyte\n /**\n  * maximum fee increase allowed to do partial spend avoidance, even for nodes with this feature disabled by default\n  *\n@@ -329,8 +329,6 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     // ScriptPubKeyMan::GetID. In many cases it will be the hash of an internal structure\n     std::map<uint256, std::unique_ptr<ScriptPubKeyMan>> m_spk_managers;\n \n-    bool CreateTransactionInternal(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, const CCoinControl& coin_control, FeeCalculation& fee_calc_out, bool sign) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-\n     /**\n      * Catch wallet up to current chain, scanning new blocks, updating the best\n      * block locator and m_last_block_processed, and registering for\n@@ -351,17 +349,6 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n         return *m_database;\n     }\n \n-    /**\n-     * Select a set of coins such that nValueRet >= nTargetValue and at least\n-     * all coins from coin_control are selected; never select unconfirmed coins if they are not ours\n-     * param@[out]  setCoinsRet         Populated with inputs including pre-selected inputs from\n-     *                                  coin_control and Coin Selection if successful.\n-     * param@[out]  nValueRet           Total value of selected coins including pre-selected ones\n-     *                                  from coin_control and Coin Selection if successful.\n-     */\n-    bool SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet,\n-                    const CCoinControl& coin_control, CoinSelectionParams& coin_selection_params) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-\n     /** Get a name for this wallet for logging/debugging purposes.\n      */\n     const std::string& GetName() const { return m_name; }\n@@ -417,48 +404,47 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     interfaces::Chain& chain() const { assert(m_chain); return *m_chain; }\n \n     const CWalletTx* GetWalletTx(const uint256& hash) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    bool IsTrusted(const CWalletTx& wtx, std::set<uint256>& trusted_parents) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    //! check whether we support the named feature\n-    bool CanSupportFeature(enum WalletFeature wf) const override EXCLUSIVE_LOCKS_REQUIRED(cs_wallet) { AssertLockHeld(cs_wallet); return IsFeatureSupported(nWalletVersion, wf); }\n+    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n+    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The annotation\n+    // \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid having to\n+    // resolve the issue of member access into incomplete type CWallet. Note\n+    // that we still have the runtime check \"AssertLockHeld(pwallet->cs_wallet)\"\n+    // in place.\n+    std::set<uint256> GetTxConflicts(const CWalletTx& wtx) const NO_THREAD_SAFETY_ANALYSIS;\n \n     /**\n-     * populate vCoins with vector of available COutputs.\n+     * Return depth of transaction in blockchain:\n+     * <0  : conflicts with a transaction this deep in the blockchain\n+     *  0  : in memory pool, waiting to be included in a block\n+     * >=1 : this many blocks deep in the main chain\n      */\n-    void AvailableCoins(std::vector<COutput>& vCoins, const CCoinControl* coinControl = nullptr, const CAmount& nMinimumAmount = 1, const CAmount& nMaximumAmount = MAX_MONEY, const CAmount& nMinimumSumAmount = MAX_MONEY, const uint64_t nMaximumCount = 0) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    // TODO: Remove \"NO_THREAD_SAFETY_ANALYSIS\" and replace it with the correct\n+    // annotation \"EXCLUSIVE_LOCKS_REQUIRED(pwallet->cs_wallet)\". The annotation\n+    // \"NO_THREAD_SAFETY_ANALYSIS\" was temporarily added to avoid having to\n+    // resolve the issue of member access into incomplete type CWallet. Note\n+    // that we still have the runtime check \"AssertLockHeld(pwallet->cs_wallet)\"\n+    // in place.\n+    int GetTxDepthInMainChain(const CWalletTx& wtx) const NO_THREAD_SAFETY_ANALYSIS;\n+    bool IsTxInMainChain(const CWalletTx& wtx) const { return GetTxDepthInMainChain(wtx) > 0; }\n \n     /**\n-     * Return list of available coins and locked coins grouped by non-change output address.\n+     * @return number of blocks to maturity for this transaction:\n+     *  0 : is not a coinbase transaction, or is a mature coinbase transaction\n+     * >0 : is a coinbase transaction which matures in this many blocks\n      */\n-    std::map<CTxDestination, std::vector<COutput>> ListCoins() const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n+    int GetTxBlocksToMaturity(const CWalletTx& wtx) const;\n+    bool IsTxImmatureCoinBase(const CWalletTx& wtx) const;\n \n-    /**\n-     * Find non-change parent output.\n-     */\n-    const CTxOut& FindNonChangeParentOutput(const CTransaction& tx, int output) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-\n-    /**\n-     * Shuffle and select coins until nTargetValue is reached while avoiding\n-     * small change; This method is stochastic for some inputs and upon\n-     * completion the coin set and corresponding actual target value is\n-     * assembled\n-     * param@[in]   coins           Set of UTXOs to consider. These will be categorized into\n-     *                              OutputGroups and filtered using eligibility_filter before\n-     *                              selecting coins.\n-     * param@[out]  setCoinsRet     Populated with the coins selected if successful.\n-     * param@[out]  nValueRet       Used to return the total value of selected coins.\n-     */\n-    bool AttemptSelection(const CAmount& nTargetValue, const CoinEligibilityFilter& eligibility_filter, std::vector<COutput> coins,\n-        std::set<CInputCoin>& setCoinsRet, CAmount& nValueRet, const CoinSelectionParams& coin_selection_params) const;\n+    //! check whether we support the named feature\n+    bool CanSupportFeature(enum WalletFeature wf) const override EXCLUSIVE_LOCKS_REQUIRED(cs_wallet) { AssertLockHeld(cs_wallet); return IsFeatureSupported(nWalletVersion, wf); }\n \n     bool IsSpent(const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     // Whether this or any known UTXO with the same single key has been spent.\n     bool IsSpentKey(const uint256& hash, unsigned int n) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void SetSpentKeyState(WalletBatch& batch, const uint256& hash, unsigned int n, bool used, std::set<CTxDestination>& tx_destinations) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n-    std::vector<OutputGroup> GroupOutputs(const std::vector<COutput>& outputs, const CoinSelectionParams& coin_sel_params, const CoinEligibilityFilter& filter, bool positive_only) const;\n-\n     /** Display address on an external signer. Returns false if external signer support is not compiled */\n     bool DisplayAddress(const CTxDestination& dest) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n@@ -544,24 +530,9 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     void transactionRemovedFromMempool(const CTransactionRef& tx, MemPoolRemovalReason reason, uint64_t mempool_sequence) override;\n     void ReacceptWalletTransactions() EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     void ResendWalletTransactions();\n-    struct Balance {\n-        CAmount m_mine_trusted{0};           //!< Trusted, at depth=GetBalance.min_depth or more\n-        CAmount m_mine_untrusted_pending{0}; //!< Untrusted, but in mempool (pending)\n-        CAmount m_mine_immature{0};          //!< Immature coinbases in the main chain\n-        CAmount m_watchonly_trusted{0};\n-        CAmount m_watchonly_untrusted_pending{0};\n-        CAmount m_watchonly_immature{0};\n-    };\n-    Balance GetBalance(int min_depth = 0, bool avoid_reuse = true) const;\n-    CAmount GetAvailableBalance(const CCoinControl* coinControl = nullptr) const;\n \n     OutputType TransactionChangeType(const std::optional<OutputType>& change_type, const std::vector<CRecipient>& vecSend) const;\n \n-    /**\n-     * Insert additional inputs into the transaction by\n-     * calling CreateTransaction();\n-     */\n-    bool FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, CCoinControl);\n     /** Fetch the inputs and sign with SIGHASH_ALL. */\n     bool SignTransaction(CMutableTransaction& tx) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     /** Sign the tx given the input coins and sighash. */\n@@ -588,12 +559,6 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n                   bool bip32derivs = true,\n                   size_t* n_signed = nullptr) const;\n \n-    /**\n-     * Create a new transaction paying the recipients with a set of coins\n-     * selected by SelectCoins(); Also create the change output, when needed\n-     * @note passing nChangePosInOut as -1 will result in setting a random position\n-     */\n-    bool CreateTransaction(const std::vector<CRecipient>& vecSend, CTransactionRef& tx, CAmount& nFeeRet, int& nChangePosInOut, bilingual_str& error, const CCoinControl& coin_control, FeeCalculation& fee_calc_out, bool sign = true);\n     /**\n      * Submit the transaction to the node's mempool and then relay to peers.\n      * Should be called after CreateTransaction unless you want to abort\n@@ -605,6 +570,9 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n      */\n     void CommitTransaction(CTransactionRef tx, mapValue_t mapValue, std::vector<std::pair<std::string, std::string>> orderForm);\n \n+    /** Pass this transaction to node for mempool insertion and relay to peers if flag set to true */\n+    bool SubmitTxMemoryPoolAndRelay(const CWalletTx& wtx, std::string& err_string, bool relay) const;\n+\n     bool DummySignTx(CMutableTransaction &txNew, const std::set<CTxOut> &txouts, bool use_max_sig = false) const\n     {\n         std::vector<CTxOut> v_txouts(txouts.size());\n@@ -638,6 +606,12 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n       * output itself, just drop it to fees. */\n     CFeeRate m_discard_rate{DEFAULT_DISCARD_FEE};\n \n+    /** When the actual feerate is less than the consolidate feerate, we will tend to make transactions which\n+     * consolidate inputs. When the actual feerate is greater than the consolidate feerate, we will tend to make\n+     * transactions which have the lowest fees.\n+     */\n+    CFeeRate m_consolidate_feerate{DEFAULT_CONSOLIDATE_FEERATE};\n+\n     /** The maximum fee amount we're willing to pay to prioritize partial spend avoidance. */\n     CAmount m_max_aps_fee{DEFAULT_MAX_AVOIDPARTIALSPEND_FEE}; //!< note: this is absolute fee, not fee rate\n     OutputType m_default_address_type{DEFAULT_ADDRESS_TYPE};\n@@ -656,10 +630,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n \n     int64_t GetOldestKeyPoolTime() const;\n \n-    std::set<std::set<CTxDestination>> GetAddressGroupings() const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    std::map<CTxDestination, CAmount> GetAddressBalances() const;\n-\n-    std::set<CTxDestination> GetLabelAddresses(const std::string& label) const;\n+    std::set<CTxDestination> GetLabelAddresses(const std::string& label) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n \n     /**\n      * Marks all outputs in each one of the destinations dirty, so their cache is\n@@ -672,25 +643,16 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n \n     isminetype IsMine(const CTxDestination& dest) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     isminetype IsMine(const CScript& script) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    isminetype IsMine(const CTxIn& txin) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     /**\n      * Returns amount of debit if the input matches the\n      * filter, otherwise returns 0\n      */\n     CAmount GetDebit(const CTxIn& txin, const isminefilter& filter) const;\n     isminetype IsMine(const CTxOut& txout) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    CAmount GetCredit(const CTxOut& txout, const isminefilter& filter) const;\n-    bool IsChange(const CTxOut& txout) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    bool IsChange(const CScript& script) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n-    CAmount GetChange(const CTxOut& txout) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     bool IsMine(const CTransaction& tx) const EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n     /** should probably be renamed to IsRelevantToMe */\n     bool IsFromMe(const CTransaction& tx) const;\n     CAmount GetDebit(const CTransaction& tx, const isminefilter& filter) const;\n-    /** Returns whether all of the inputs match the filter */\n-    bool IsAllFromMe(const CTransaction& tx, const isminefilter& filter) const;\n-    CAmount GetCredit(const CTransaction& tx, const isminefilter& filter) const;\n-    CAmount GetChange(const CTransaction& tx) const;\n     void chainStateFlushed(const CBlockLocator& loc) override;\n \n     DBErrors LoadWallet();\n@@ -914,7 +876,7 @@ class CWallet final : public WalletStorage, public interfaces::Chain::Notificati\n     DescriptorScriptPubKeyMan* GetDescriptorScriptPubKeyMan(const WalletDescriptor& desc) const;\n \n     //! Add a descriptor to the wallet, return a ScriptPubKeyMan & associated output type\n-    ScriptPubKeyMan* AddWalletDescriptor(WalletDescriptor& desc, const FlatSigningProvider& signing_provider, const std::string& label, bool internal);\n+    ScriptPubKeyMan* AddWalletDescriptor(WalletDescriptor& desc, const FlatSigningProvider& signing_provider, const std::string& label, bool internal) EXCLUSIVE_LOCKS_REQUIRED(cs_wallet);\n };\n \n /**\n@@ -957,18 +919,6 @@ class WalletRescanReserver\n     }\n };\n \n-struct TxSize {\n-    int64_t vsize{-1};\n-    int64_t weight{-1};\n-};\n-\n-/** Calculate the size of the transaction assuming all signatures are max size\n-* Use DummySignatureCreator, which inserts 71 byte signatures everywhere.\n-* NOTE: this requires that all inputs must be in mapWallet (eg the tx should\n-* be IsAllFromMe). */\n-TxSize CalculateMaximumSignedTxSize(const CTransaction& tx, const CWallet* wallet, bool use_max_sig = false) EXCLUSIVE_LOCKS_REQUIRED(wallet->cs_wallet);\n-TxSize CalculateMaximumSignedTxSize(const CTransaction& tx, const CWallet* wallet, const std::vector<CTxOut>& txouts, bool use_max_sig = false);\n-\n //! Add wallet name to persistent configuration so it will be loaded on startup.\n bool AddWalletSetting(interfaces::Chain& chain, const std::string& wallet_name);\n "
      },
      {
        "sha": "03464cd2c83566cc8407f667fa15add83fb03ba3",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -954,7 +954,7 @@ DBErrors WalletBatch::FindWalletTx(std::vector<uint256>& vTxHash, std::list<CWal\n                 uint256 hash;\n                 ssKey >> hash;\n                 vTxHash.push_back(hash);\n-                vWtx.emplace_back(nullptr /* wallet */, nullptr /* tx */);\n+                vWtx.emplace_back(nullptr /* tx */);\n                 ssValue >> vWtx.back();\n             }\n         }"
      },
      {
        "sha": "56f4c98317e28d3b1215156a256276b121184cfd",
        "filename": "src/zmq/zmqpublishnotifier.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/src/zmq/zmqpublishnotifier.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/src/zmq/zmqpublishnotifier.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqpublishnotifier.cpp?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -6,6 +6,7 @@\n \n #include <chain.h>\n #include <chainparams.h>\n+#include <netbase.h>\n #include <node/blockstorage.h>\n #include <rpc/server.h>\n #include <streams.h>\n@@ -73,6 +74,20 @@ static int zmq_send_multipart(void *sock, const void* data, size_t size, ...)\n     return 0;\n }\n \n+static bool IsZMQAddressIPV6(const std::string &zmq_address)\n+{\n+    const std::string tcp_prefix = \"tcp://\";\n+    const size_t tcp_index = zmq_address.rfind(tcp_prefix);\n+    const size_t colon_index = zmq_address.rfind(\":\");\n+    if (tcp_index == 0 && colon_index != std::string::npos) {\n+        const std::string ip = zmq_address.substr(tcp_prefix.length(), colon_index - tcp_prefix.length());\n+        CNetAddr addr;\n+        LookupHost(ip, addr, false);\n+        if (addr.IsIPv6()) return true;\n+    }\n+    return false;\n+}\n+\n bool CZMQAbstractPublishNotifier::Initialize(void *pcontext)\n {\n     assert(!psocket);\n@@ -107,6 +122,15 @@ bool CZMQAbstractPublishNotifier::Initialize(void *pcontext)\n             return false;\n         }\n \n+        // On some systems (e.g. OpenBSD) the ZMQ_IPV6 must not be enabled, if the address to bind isn't IPv6\n+        const int enable_ipv6 { IsZMQAddressIPV6(address) ? 1 : 0};\n+        rc = zmq_setsockopt(psocket, ZMQ_IPV6, &enable_ipv6, sizeof(enable_ipv6));\n+        if (rc != 0) {\n+            zmqError(\"Failed to set ZMQ_IPV6\");\n+            zmq_close(psocket);\n+            return false;\n+        }\n+\n         rc = zmq_bind(psocket, address.c_str());\n         if (rc != 0)\n         {"
      },
      {
        "sha": "acd68d8d8f4510f524b12441a2d53a616cdfed8a",
        "filename": "test/README.md",
        "status": "modified",
        "additions": 16,
        "deletions": 6,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/README.md?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -5,30 +5,41 @@ etc.\n \n This directory contains the following sets of tests:\n \n+- [fuzz](/test/fuzz) A runner to execute all fuzz targets from\n+  [/src/test/fuzz](/src/test/fuzz).\n - [functional](/test/functional) which test the functionality of\n bitcoind and bitcoin-qt by interacting with them through the RPC and P2P\n interfaces.\n-- [util](/test/util) which tests the bitcoin utilities, currently only\n-bitcoin-tx.\n+- [util](/test/util) which tests the utilities (bitcoin-util, bitcoin-tx, ...).\n - [lint](/test/lint/) which perform various static analysis checks.\n \n-The util tests are run as part of `make check` target. The functional\n+The util tests are run as part of `make check` target. The fuzz tests, functional\n tests and lint scripts can be run as explained in the sections below.\n \n # Running tests locally\n \n Before tests can be run locally, Bitcoin Core must be built.  See the [building instructions](/doc#building) for help.\n \n+## Fuzz tests\n+\n+See [/doc/fuzzing.md](/doc/fuzzing.md)\n \n ### Functional tests\n \n-#### Dependencies\n+#### Dependencies and prerequisites\n \n The ZMQ functional test requires a python ZMQ library. To install it:\n \n - on Unix, run `sudo apt-get install python3-zmq`\n - on mac OS, run `pip3 install pyzmq`\n \n+\n+On Windows the `PYTHONUTF8` environment variable must be set to 1:\n+\n+```cmd\n+set PYTHONUTF8=1\n+```\n+\n #### Running the tests\n \n Individual tests can be run by directly calling the test script, e.g.:\n@@ -257,7 +268,7 @@ For ways to generate more granular profiles, see the README in\n \n ### Util tests\n \n-Util tests can be run locally by running `test/util/bitcoin-util-test.py`.\n+Util tests can be run locally by running `test/util/test_runner.py`.\n Use the `-v` option for verbose output.\n \n ### Lint tests\n@@ -269,7 +280,6 @@ Use the `-v` option for verbose output.\n | [`lint-python.sh`](lint/lint-python.sh) | [flake8](https://gitlab.com/pycqa/flake8) | [3.8.3](https://github.com/bitcoin/bitcoin/pull/19348) | `pip3 install flake8==3.8.3`\n | [`lint-python.sh`](lint/lint-python.sh) | [mypy](https://github.com/python/mypy) | [0.781](https://github.com/bitcoin/bitcoin/pull/19348) | `pip3 install mypy==0.781`\n | [`lint-shell.sh`](lint/lint-shell.sh) | [ShellCheck](https://github.com/koalaman/shellcheck) | [0.7.2](https://github.com/bitcoin/bitcoin/pull/21749) | [details...](https://github.com/koalaman/shellcheck#installing)\n-| [`lint-shell.sh`](lint/lint-shell.sh) | [yq](https://github.com/kislyuk/yq) | default | `pip3 install yq`\n | [`lint-spelling.sh`](lint/lint-spelling.sh) | [codespell](https://github.com/codespell-project/codespell) | [2.0.0](https://github.com/bitcoin/bitcoin/pull/20817) | `pip3 install codespell==2.0.0`\n \n Please be aware that on Linux distributions all dependencies are usually available as packages, but could be outdated."
      },
      {
        "sha": "db80bba6f1a620640a5689a6b5ce3e58c09d01d1",
        "filename": "test/config.ini.in",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/config.ini.in",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/config.ini.in",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/config.ini.in?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -3,7 +3,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n # These environment variables are set by the build process and read by\n-# test/functional/test_runner.py and test/util/bitcoin-util-test.py\n+# test/*/test_runner.py and test/util/rpcauth-test.py\n \n [environment]\n PACKAGE_NAME=@PACKAGE_NAME@"
      },
      {
        "sha": "d6fc2d580f71bbb79ea812a0ca0bc3520159a645",
        "filename": "test/functional/example_test.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/example_test.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/example_test.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/example_test.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -141,7 +141,7 @@ def run_test(self):\n         peer_messaging = self.nodes[0].add_p2p_connection(BaseNode())\n \n         # Generating a block on one of the nodes will get us out of IBD\n-        blocks = [int(self.nodes[0].generate(nblocks=1)[0], 16)]\n+        blocks = [int(self.generate(self.nodes[0], nblocks=1)[0], 16)]\n         self.sync_all(self.nodes[0:2])\n \n         # Notice above how we called an RPC by calling a method with the same"
      },
      {
        "sha": "e3cb7725bd716eb6824a0cc9c4aa8181fd928463",
        "filename": "test/functional/feature_abortnode.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_abortnode.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_abortnode.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_abortnode.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -26,18 +26,18 @@ def setup_network(self):\n         # We'll connect the nodes later\n \n     def run_test(self):\n-        self.nodes[0].generate(3)\n+        self.generate(self.nodes[0], 3)\n         datadir = get_datadir_path(self.options.tmpdir, 0)\n \n         # Deleting the undo file will result in reorg failure\n         os.unlink(os.path.join(datadir, self.chain, 'blocks', 'rev00000.dat'))\n \n         # Connecting to a node with a more work chain will trigger a reorg\n         # attempt.\n-        self.nodes[1].generate(3)\n+        self.generate(self.nodes[1], 3)\n         with self.nodes[0].assert_debug_log([\"Failed to disconnect block\"]):\n             self.connect_nodes(0, 1)\n-            self.nodes[1].generate(1)\n+            self.generate(self.nodes[1], 1)\n \n             # Check that node0 aborted\n             self.log.info(\"Waiting for crash\")"
      },
      {
        "sha": "ee421c89b5ab7c4e60d96d37847c501fade78aad",
        "filename": "test/functional/feature_addrman.py",
        "status": "added",
        "additions": 93,
        "deletions": 0,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_addrman.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_addrman.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_addrman.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -0,0 +1,93 @@\n+#!/usr/bin/env python3\n+# Copyright (c) 2021 The Bitcoin Core developers\n+# Distributed under the MIT software license, see the accompanying\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\"\"\"Test addrman functionality\"\"\"\n+\n+import os\n+import struct\n+\n+from test_framework.messages import ser_uint256, hash256\n+from test_framework.p2p import MAGIC_BYTES\n+from test_framework.test_framework import BitcoinTestFramework\n+from test_framework.test_node import ErrorMatch\n+from test_framework.util import assert_equal\n+\n+\n+def serialize_addrman(*, format=1, lowest_compatible=3):\n+    new = []\n+    tried = []\n+    INCOMPATIBILITY_BASE = 32\n+    r = MAGIC_BYTES[\"regtest\"]\n+    r += struct.pack(\"B\", format)\n+    r += struct.pack(\"B\", INCOMPATIBILITY_BASE + lowest_compatible)\n+    r += ser_uint256(1)\n+    r += struct.pack(\"i\", len(new))\n+    r += struct.pack(\"i\", len(tried))\n+    ADDRMAN_NEW_BUCKET_COUNT = 1 << 10\n+    r += struct.pack(\"i\", ADDRMAN_NEW_BUCKET_COUNT ^ (1 << 30))\n+    for _ in range(ADDRMAN_NEW_BUCKET_COUNT):\n+        r += struct.pack(\"i\", 0)\n+    checksum = hash256(r)\n+    r += checksum\n+    return r\n+\n+\n+def write_addrman(peers_dat, **kwargs):\n+    with open(peers_dat, \"wb\") as f:\n+        f.write(serialize_addrman(**kwargs))\n+\n+\n+class AddrmanTest(BitcoinTestFramework):\n+    def set_test_params(self):\n+        self.num_nodes = 1\n+\n+    def run_test(self):\n+        peers_dat = os.path.join(self.nodes[0].datadir, self.chain, \"peers.dat\")\n+        init_error = lambda reason: (\n+            f\"Error: Invalid or corrupt peers.dat \\\\({reason}\\\\). If you believe this \"\n+            f\"is a bug, please report it to {self.config['environment']['PACKAGE_BUGREPORT']}. \"\n+            f'As a workaround, you can move the file \\\\(\"{peers_dat}\"\\\\) out of the way \\\\(rename, '\n+            \"move, or delete\\\\) to have a new one created on the next start.\"\n+        )\n+\n+        self.log.info(\"Check that mocked addrman is valid\")\n+        self.stop_node(0)\n+        write_addrman(peers_dat)\n+        with self.nodes[0].assert_debug_log([\"Loaded 0 addresses from peers.dat\"]):\n+            self.start_node(0, extra_args=[\"-checkaddrman=1\"])\n+        assert_equal(self.nodes[0].getnodeaddresses(), [])\n+\n+        self.log.info(\"Check that addrman from future cannot be read\")\n+        self.stop_node(0)\n+        write_addrman(peers_dat, lowest_compatible=111)\n+        self.nodes[0].assert_start_raises_init_error(\n+            expected_msg=init_error(\n+                \"Unsupported format of addrman database: 1. It is compatible with \"\n+                \"formats >=111, but the maximum supported by this version of \"\n+                f\"{self.config['environment']['PACKAGE_NAME']} is 3.: (.+)\"\n+            ),\n+            match=ErrorMatch.FULL_REGEX,\n+        )\n+\n+        self.log.info(\"Check that corrupt addrman cannot be read\")\n+        self.stop_node(0)\n+        with open(peers_dat, \"wb\") as f:\n+            f.write(serialize_addrman()[:-1])\n+        self.nodes[0].assert_start_raises_init_error(\n+            expected_msg=init_error(\"CAutoFile::read: end of file.*\"),\n+            match=ErrorMatch.FULL_REGEX,\n+        )\n+\n+        self.log.info(\"Check that missing addrman is recreated\")\n+        self.stop_node(0)\n+        os.remove(peers_dat)\n+        with self.nodes[0].assert_debug_log([\n+                f'Creating peers.dat because the file was not found (\"{peers_dat}\")',\n+        ]):\n+            self.start_node(0)\n+        assert_equal(self.nodes[0].getnodeaddresses(), [])\n+\n+\n+if __name__ == \"__main__\":\n+    AddrmanTest().main()"
      },
      {
        "sha": "7be393a4ea9d552d7bad1f2a32b95db34f6d64a7",
        "filename": "test/functional/feature_anchors.py",
        "status": "modified",
        "additions": 0,
        "deletions": 3,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_anchors.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_anchors.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_anchors.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -25,9 +25,6 @@ def set_test_params(self):\n         self.num_nodes = 1\n         self.disable_autoconnect = False\n \n-    def setup_network(self):\n-        self.setup_nodes()\n-\n     def run_test(self):\n         node_anchors_path = os.path.join(\n             self.nodes[0].datadir, \"regtest\", \"anchors.dat\""
      },
      {
        "sha": "e65525a0237ca7ec5cad0d2d191d19365bebe18e",
        "filename": "test/functional/feature_backwards_compatibility.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_backwards_compatibility.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_backwards_compatibility.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_backwards_compatibility.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -64,7 +64,7 @@ def setup_nodes(self):\n         self.import_deterministic_coinbase_privkeys()\n \n     def run_test(self):\n-        self.nodes[0].generatetoaddress(COINBASE_MATURITY + 1, self.nodes[0].getnewaddress())\n+        self.generatetoaddress(self.nodes[0], COINBASE_MATURITY + 1, self.nodes[0].getnewaddress())\n \n         self.sync_blocks()\n \n@@ -92,15 +92,15 @@ def run_test(self):\n         address = wallet.getnewaddress()\n         self.nodes[0].sendtoaddress(address, 10)\n         self.sync_mempools()\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n         # Create a conflicting transaction using RBF\n         return_address = self.nodes[0].getnewaddress()\n         tx1_id = self.nodes[1].sendtoaddress(return_address, 1)\n         tx2_id = self.nodes[1].bumpfee(tx1_id)[\"txid\"]\n         # Confirm the transaction\n         self.sync_mempools()\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n         # Create another conflicting transaction using RBF\n         tx3_id = self.nodes[1].sendtoaddress(return_address, 1)"
      },
      {
        "sha": "09cda8444abfec4cb336fb60b197d571023142c6",
        "filename": "test/functional/feature_bip68_sequence.py",
        "status": "modified",
        "additions": 9,
        "deletions": 12,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_bip68_sequence.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_bip68_sequence.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_bip68_sequence.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -41,10 +41,7 @@ class BIP68Test(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 2\n         self.extra_args = [\n-            [\n-                \"-acceptnonstdtxn=1\",\n-                \"-peertimeout=9999\",  # bump because mocktime might cause a disconnect otherwise\n-            ],\n+            [\"-acceptnonstdtxn=1\"],\n             [\"-acceptnonstdtxn=0\"],\n         ]\n \n@@ -55,7 +52,7 @@ def run_test(self):\n         self.relayfee = self.nodes[0].getnetworkinfo()[\"relayfee\"]\n \n         # Generate some coins\n-        self.nodes[0].generate(110)\n+        self.generate(self.nodes[0], 110)\n \n         self.log.info(\"Running test disable flag\")\n         self.test_disable_flag()\n@@ -143,7 +140,7 @@ def test_sequence_lock_confirmed_inputs(self):\n             for i in range(num_outputs):\n                 outputs[addresses[i]] = random.randint(1, 20)*0.01\n             self.nodes[0].sendmany(\"\", outputs)\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n \n         utxos = self.nodes[0].listunspent()\n \n@@ -273,7 +270,7 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         cur_time = int(time.time())\n         for _ in range(10):\n             self.nodes[0].setmocktime(cur_time + 600)\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n             cur_time += 600\n \n         assert tx2.hash in self.nodes[0].getrawmempool()\n@@ -288,15 +285,15 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         self.nodes[0].setmocktime(cur_time+600)\n         # Save block template now to use for the reorg later\n         tmpl = self.nodes[0].getblocktemplate(NORMAL_GBT_REQUEST_PARAMS)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert tx2.hash not in self.nodes[0].getrawmempool()\n \n         # Now that tx2 is not in the mempool, a sequence locked spend should\n         # succeed\n         tx3 = test_nonzero_locks(tx2, self.nodes[0], self.relayfee, use_height_lock=False)\n         assert tx3.hash in self.nodes[0].getrawmempool()\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert tx3.hash not in self.nodes[0].getrawmempool()\n \n         # One more test, this time using height locks\n@@ -349,7 +346,7 @@ def test_nonzero_locks(orig_tx, node, relayfee, use_height_lock):\n         # Reset the chain and get rid of the mocktimed-blocks\n         self.nodes[0].setmocktime(0)\n         self.nodes[0].invalidateblock(self.nodes[0].getblockhash(cur_height+1))\n-        self.nodes[0].generate(10)\n+        self.generate(self.nodes[0], 10)\n \n     # Make sure that BIP68 isn't being used to validate blocks prior to\n     # activation height.  If more blocks are mined prior to this test\n@@ -403,9 +400,9 @@ def activateCSV(self):\n         min_activation_height = 432\n         height = self.nodes[0].getblockcount()\n         assert_greater_than(min_activation_height - height, 2)\n-        self.nodes[0].generate(min_activation_height - height - 2)\n+        self.generate(self.nodes[0], min_activation_height - height - 2)\n         assert not softfork_active(self.nodes[0], 'csv')\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert softfork_active(self.nodes[0], 'csv')\n         self.sync_blocks()\n "
      },
      {
        "sha": "b740f2cc27ee60f46bb7cdaf0e7fbb91da239ce3",
        "filename": "test/functional/feature_blockfilterindex_prune.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_blockfilterindex_prune.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_blockfilterindex_prune.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_blockfilterindex_prune.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -25,9 +25,9 @@ def run_test(self):\n         self.sync_index(height=200)\n         assert_greater_than(len(self.nodes[0].getblockfilter(self.nodes[0].getbestblockhash())['filter']), 0)\n         # Mine two batches of blocks to avoid hitting NODE_NETWORK_LIMITED_MIN_BLOCKS disconnection\n-        self.nodes[0].generate(250)\n+        self.generate(self.nodes[0], 250)\n         self.sync_all()\n-        self.nodes[0].generate(250)\n+        self.generate(self.nodes[0], 250)\n         self.sync_all()\n         self.sync_index(height=700)\n \n@@ -46,7 +46,7 @@ def run_test(self):\n \n         self.log.info(\"make sure accessing the blockfilters throws an error\")\n         assert_raises_rpc_error(-1, \"Index is not enabled for filtertype basic\", self.nodes[0].getblockfilter, self.nodes[0].getblockhash(2))\n-        self.nodes[0].generate(1000)\n+        self.generate(self.nodes[0], 1000)\n \n         self.log.info(\"prune below the blockfilterindexes best block while blockfilters are disabled\")\n         pruneheight_new = self.nodes[0].pruneblockchain(1000)"
      },
      {
        "sha": "28e6d6cdf92af59d3877c129df41c8d253a316a8",
        "filename": "test/functional/feature_blocksdir.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_blocksdir.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_blocksdir.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_blocksdir.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -29,7 +29,7 @@ def run_test(self):\n         self.log.info(\"Starting with existing blocksdir ...\")\n         self.start_node(0, [f\"-blocksdir={blocksdir_path}\"])\n         self.log.info(\"mining blocks..\")\n-        self.nodes[0].generatetoaddress(10, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], 10, self.nodes[0].get_deterministic_priv_key().address)\n         assert os.path.isfile(os.path.join(blocksdir_path, self.chain, \"blocks\", \"blk00000.dat\"))\n         assert os.path.isdir(os.path.join(self.nodes[0].datadir, self.chain, \"blocks\", \"index\"))\n "
      },
      {
        "sha": "2c3ef9b88b7769146770e23d806d91dc79d751fd",
        "filename": "test/functional/feature_cltv.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_cltv.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_cltv.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_cltv.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -4,8 +4,7 @@\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \"\"\"Test BIP65 (CHECKLOCKTIMEVERIFY).\n \n-Test that the CHECKLOCKTIMEVERIFY soft-fork activates at (regtest) block height\n-1351.\n+Test that the CHECKLOCKTIMEVERIFY soft-fork activates.\n \"\"\"\n \n from test_framework.blocktools import (\n@@ -62,9 +61,9 @@ def cltv_invalidate(tx, failure_reason):\n         # +-------------------------------------------------+------------+--------------+\n         [[OP_CHECKLOCKTIMEVERIFY],                            None,       None],\n         [[OP_1NEGATE, OP_CHECKLOCKTIMEVERIFY, OP_DROP],       None,       None],\n-        [[CScriptNum(1000), OP_CHECKLOCKTIMEVERIFY, OP_DROP], 0,          1296688602],  # timestamp of genesis block\n-        [[CScriptNum(1000), OP_CHECKLOCKTIMEVERIFY, OP_DROP], 0,          500],\n-        [[CScriptNum(500),  OP_CHECKLOCKTIMEVERIFY, OP_DROP], 0xffffffff, 500],\n+        [[CScriptNum(100), OP_CHECKLOCKTIMEVERIFY, OP_DROP],  0,          1296688602],  # timestamp of genesis block\n+        [[CScriptNum(100), OP_CHECKLOCKTIMEVERIFY, OP_DROP],  0,          50],\n+        [[CScriptNum(50),  OP_CHECKLOCKTIMEVERIFY, OP_DROP],  0xffffffff, 50],\n     ][failure_reason]\n \n     cltv_modify_tx(tx, prepend_scriptsig=scheme[0], nsequence=scheme[1], nlocktime=scheme[2])\n@@ -103,8 +102,9 @@ def run_test(self):\n         self.test_cltv_info(is_active=False)\n \n         self.log.info(\"Mining %d blocks\", CLTV_HEIGHT - 2)\n-        wallet.generate(10)\n-        self.nodes[0].generate(CLTV_HEIGHT - 2 - 10)\n+        self.generate(wallet, 10)\n+        self.generate(self.nodes[0], CLTV_HEIGHT - 2 - 10)\n+        assert_equal(self.nodes[0].getblockcount(), CLTV_HEIGHT - 2)\n \n         self.log.info(\"Test that invalid-according-to-CLTV transactions can still appear in a block\")\n "
      },
      {
        "sha": "146e776b07e50c1396fdbdb2d1ce8da3f7f68cae",
        "filename": "test/functional/feature_coinstatsindex.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_coinstatsindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_coinstatsindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_coinstatsindex.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -67,10 +67,10 @@ def _test_coin_stats_index(self):\n         index_hash_options = ['none', 'muhash']\n \n         # Generate a normal transaction and mine it\n-        node.generate(COINBASE_MATURITY + 1)\n+        self.generate(node, COINBASE_MATURITY + 1)\n         address = self.nodes[0].get_deterministic_priv_key().address\n         node.sendtoaddress(address=address, amount=10, subtractfeefromamount=True)\n-        node.generate(1)\n+        self.generate(node, 1)\n \n         self.sync_blocks(timeout=120)\n \n@@ -92,7 +92,7 @@ def _test_coin_stats_index(self):\n         self.log.info(\"Test that gettxoutsetinfo() can get fetch data on specific heights with index\")\n \n         # Generate a new tip\n-        node.generate(5)\n+        self.generate(node, 5)\n \n         for hash_option in index_hash_options:\n             # Fetch old stats by height\n@@ -169,7 +169,7 @@ def _test_coin_stats_index(self):\n         self.nodes[0].sendrawtransaction(tx2_hex)\n \n         # Include both txs in a block\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         for hash_option in index_hash_options:\n@@ -228,7 +228,7 @@ def _test_coin_stats_index(self):\n         res9 = index_node.gettxoutsetinfo('muhash')\n         assert_equal(res8, res9)\n \n-        index_node.generate(1)\n+        self.generate(index_node, 1)\n         res10 = index_node.gettxoutsetinfo('muhash')\n         assert(res8['txouts'] < res10['txouts'])\n \n@@ -247,14 +247,14 @@ def _test_reorg_index(self):\n \n         # Generate two block, let the index catch up, then invalidate the blocks\n         index_node = self.nodes[1]\n-        reorg_blocks = index_node.generatetoaddress(2, index_node.getnewaddress())\n+        reorg_blocks = self.generatetoaddress(index_node, 2, index_node.getnewaddress())\n         reorg_block = reorg_blocks[1]\n         res_invalid = index_node.gettxoutsetinfo('muhash')\n         index_node.invalidateblock(reorg_blocks[0])\n         assert_equal(index_node.gettxoutsetinfo('muhash')['height'], 110)\n \n         # Add two new blocks\n-        block = index_node.generate(2)[1]\n+        block = self.generate(index_node, 2)[1]\n         res = index_node.gettxoutsetinfo(hash_type='muhash', hash_or_height=None, use_index=False)\n \n         # Test that the result of the reorged block is not returned for its old block height\n@@ -270,7 +270,7 @@ def _test_reorg_index(self):\n \n         # Add another block, so we don't depend on reconsiderblock remembering which\n         # blocks were touched by invalidateblock\n-        index_node.generate(1)\n+        self.generate(index_node, 1)\n         self.sync_all()\n \n         # Ensure that removing and re-adding blocks yields consistent results"
      },
      {
        "sha": "3d9d8b74417ea1137608898e017b7e6f0b17675f",
        "filename": "test/functional/feature_config_args.py",
        "status": "modified",
        "additions": 20,
        "deletions": 10,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_config_args.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_config_args.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_config_args.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -164,11 +164,14 @@ def test_seed_peers(self):\n         # fixed seeds\n         assert not os.path.exists(os.path.join(default_data_dir, \"peers.dat\"))\n         start = int(time.time())\n-        with self.nodes[0].assert_debug_log(expected_msgs=[\n-                \"Loaded 0 addresses from peers.dat\",\n-                \"0 addresses found from DNS seeds\",\n-                \"opencon thread start\",  # Ensure ThreadOpenConnections::start time is properly set\n-        ]):\n+        with self.nodes[0].assert_debug_log(\n+                expected_msgs=[\n+                    \"Loaded 0 addresses from peers.dat\",\n+                    \"0 addresses found from DNS seeds\",\n+                    \"opencon thread start\",  # Ensure ThreadOpenConnections::start time is properly set\n+                ],\n+                timeout=10,\n+        ):\n             self.start_node(0, extra_args=['-dnsseed=1', '-fixedseeds=1', f'-mocktime={start}'])\n         with self.nodes[0].assert_debug_log(expected_msgs=[\n                 \"Adding fixed seeds as 60 seconds have passed and addrman is empty\",\n@@ -206,11 +209,14 @@ def test_seed_peers(self):\n         # We expect the node will allow 60 seconds prior to using fixed seeds\n         assert not os.path.exists(os.path.join(default_data_dir, \"peers.dat\"))\n         start = int(time.time())\n-        with self.nodes[0].assert_debug_log(expected_msgs=[\n-                \"Loaded 0 addresses from peers.dat\",\n-                \"DNS seeding disabled\",\n-                \"opencon thread start\",  # Ensure ThreadOpenConnections::start time is properly set\n-        ]):\n+        with self.nodes[0].assert_debug_log(\n+                expected_msgs=[\n+                    \"Loaded 0 addresses from peers.dat\",\n+                    \"DNS seeding disabled\",\n+                    \"opencon thread start\",  # Ensure ThreadOpenConnections::start time is properly set\n+                ],\n+                timeout=10,\n+        ):\n             self.start_node(0, extra_args=['-dnsseed=0', '-fixedseeds=1', '-addnode=fakenodeaddr', f'-mocktime={start}'])\n         with self.nodes[0].assert_debug_log(expected_msgs=[\n                 \"Adding fixed seeds as 60 seconds have passed and addrman is empty\",\n@@ -248,6 +254,10 @@ def run_test(self):\n \n         self.nodes[0].assert_start_raises_init_error([f'-conf={conf_file}'], f'Error: Error reading configuration file: specified data directory \"{new_data_dir}\" does not exist.')\n \n+        # Check that an explicitly specified config file that cannot be opened fails\n+        none_existent_conf_file = os.path.join(default_data_dir, \"none_existent_bitcoin.conf\")\n+        self.nodes[0].assert_start_raises_init_error(['-conf=' + none_existent_conf_file], 'Error: Error reading configuration file: specified config file \"' + none_existent_conf_file + '\" could not be opened.')\n+\n         # Create the directory and ensure the config file now works\n         os.mkdir(new_data_dir)\n         self.start_node(0, [f'-conf={conf_file}'])"
      },
      {
        "sha": "d2b3fe45d1d708d3ce58bbb58e41f999a1529400",
        "filename": "test/functional/feature_csv_activation.py",
        "status": "modified",
        "additions": 8,
        "deletions": 5,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_csv_activation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_csv_activation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_csv_activation.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -69,6 +69,7 @@\n SEQ_TYPE_FLAG = 1 << 22\n SEQ_RANDOM_LOW_BIT = 1 << 18\n \n+\n def relative_locktime(sdf, srhb, stf, srlb):\n     \"\"\"Returns a locktime with certain bits set.\"\"\"\n \n@@ -83,6 +84,7 @@ def relative_locktime(sdf, srhb, stf, srlb):\n         locktime |= SEQ_RANDOM_LOW_BIT\n     return locktime\n \n+\n def all_rlt_txs(txs):\n     return [tx['tx'] for tx in txs]\n \n@@ -143,13 +145,13 @@ def create_bip112txs(self, bip112inputs, varyOP_CSV, txversion, locktime_delta=0\n         for i, (sdf, srhb, stf, srlb) in enumerate(product(*[[True, False]] * 4)):\n             locktime = relative_locktime(sdf, srhb, stf, srlb)\n             tx = self.create_self_transfer_from_utxo(bip112inputs[i])\n-            if (varyOP_CSV):  # if varying OP_CSV, nSequence is fixed\n+            if varyOP_CSV:  # if varying OP_CSV, nSequence is fixed\n                 tx.vin[0].nSequence = BASE_RELATIVE_LOCKTIME + locktime_delta\n             else:  # vary nSequence instead, OP_CSV is fixed\n                 tx.vin[0].nSequence = locktime + locktime_delta\n             tx.nVersion = txversion\n             self.miniwallet.sign_tx(tx)\n-            if (varyOP_CSV):\n+            if varyOP_CSV:\n                 tx.vin[0].scriptSig = CScript([locktime, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(tx.vin[0].scriptSig)))\n             else:\n                 tx.vin[0].scriptSig = CScript([BASE_RELATIVE_LOCKTIME, OP_CHECKSEQUENCEVERIFY, OP_DROP] + list(CScript(tx.vin[0].scriptSig)))\n@@ -189,15 +191,15 @@ def run_test(self):\n         self.log.info(\"Generate blocks in the past for coinbase outputs.\")\n         long_past_time = int(time.time()) - 600 * 1000  # enough to build up to 1000 blocks 10 minutes apart without worrying about getting into the future\n         self.nodes[0].setmocktime(long_past_time - 100)  # enough so that the generated blocks will still all be before long_past_time\n-        self.coinbase_blocks = self.miniwallet.generate(COINBASE_BLOCK_COUNT)  # blocks generated for inputs\n+        self.coinbase_blocks = self.generate(self.miniwallet, COINBASE_BLOCK_COUNT)  # blocks generated for inputs\n         self.nodes[0].setmocktime(0)  # set time back to present so yielded blocks aren't in the future as we advance last_block_time\n         self.tipheight = COINBASE_BLOCK_COUNT  # height of the next block to build\n         self.last_block_time = long_past_time\n         self.tip = int(self.nodes[0].getbestblockhash(), 16)\n \n         # Activation height is hardcoded\n         # We advance to block height five below BIP112 activation for the following tests\n-        test_blocks = self.generate_blocks(CSV_ACTIVATION_HEIGHT-5 - COINBASE_BLOCK_COUNT)\n+        test_blocks = self.generate_blocks(CSV_ACTIVATION_HEIGHT - 5 - COINBASE_BLOCK_COUNT)\n         self.send_blocks(test_blocks)\n         assert not softfork_active(self.nodes[0], 'csv')\n \n@@ -235,7 +237,7 @@ def run_test(self):\n         bip113input = self.send_generic_input_tx(self.coinbase_blocks)\n \n         self.nodes[0].setmocktime(self.last_block_time + 600)\n-        inputblockhash = self.nodes[0].generate(1)[0]  # 1 block generated for inputs to be in chain at height 431\n+        inputblockhash = self.generate(self.nodes[0], 1)[0]  # 1 block generated for inputs to be in chain at height 431\n         self.nodes[0].setmocktime(0)\n         self.tip = int(inputblockhash, 16)\n         self.tipheight += 1\n@@ -482,5 +484,6 @@ def run_test(self):\n         self.send_blocks([self.create_test_block(time_txs)])\n         self.nodes[0].invalidateblock(self.nodes[0].getbestblockhash())\n \n+\n if __name__ == '__main__':\n     BIP68_112_113Test().main()"
      },
      {
        "sha": "f0766ca7c21ee778ec66b7fd3ba968431d397c6b",
        "filename": "test/functional/feature_dbcrash.py",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_dbcrash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_dbcrash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dbcrash.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -217,7 +217,7 @@ def run_test(self):\n \n         # Start by creating a lot of utxos on node3\n         initial_height = self.nodes[3].getblockcount()\n-        utxo_list = create_confirmed_utxos(self.nodes[3].getnetworkinfo()['relayfee'], self.nodes[3], 5000)\n+        utxo_list = create_confirmed_utxos(self, self.nodes[3].getnetworkinfo()['relayfee'], self.nodes[3], 5000)\n         self.log.info(f\"Prepped {len(utxo_list)} utxo entries\")\n \n         # Sync these blocks with the other nodes\n@@ -253,7 +253,8 @@ def run_test(self):\n             self.log.debug(\"Mining longer tip\")\n             block_hashes = []\n             while current_height + 1 > self.nodes[3].getblockcount():\n-                block_hashes.extend(self.nodes[3].generatetoaddress(\n+                block_hashes.extend(self.generatetoaddress(\n+                    self.nodes[3],\n                     nblocks=min(10, current_height + 1 - self.nodes[3].getblockcount()),\n                     # new address to avoid mining a block that has just been invalidated\n                     address=self.nodes[3].getnewaddress(),"
      },
      {
        "sha": "595d26611aafcd8649c54fe94f3681d3c19f178f",
        "filename": "test/functional/feature_dersig.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_dersig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_dersig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_dersig.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -72,7 +72,7 @@ def run_test(self):\n         self.test_dersig_info(is_active=False)\n \n         self.log.info(\"Mining %d blocks\", DERSIG_HEIGHT - 2)\n-        self.coinbase_txids = [self.nodes[0].getblock(b)['tx'][0] for b in self.miniwallet.generate(DERSIG_HEIGHT - 2)]\n+        self.coinbase_txids = [self.nodes[0].getblock(b)['tx'][0] for b in self.generate(self.miniwallet, DERSIG_HEIGHT - 2)]\n \n         self.log.info(\"Test that a transaction with non-DER signature can still appear in a block\")\n "
      },
      {
        "sha": "c4610f98bd7e5f0cf3e1259cae2c60b155282476",
        "filename": "test/functional/feature_fee_estimation.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_fee_estimation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_fee_estimation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_fee_estimation.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -197,7 +197,7 @@ def transact_and_mine(self, numblocks, mining_node):\n                 tx_kbytes = (len(txhex) // 2) / 1000.0\n                 self.fees_per_kb.append(float(fee) / tx_kbytes)\n             self.sync_mempools(wait=.1)\n-            mined = mining_node.getblock(mining_node.generate(1)[0], True)[\"tx\"]\n+            mined = mining_node.getblock(self.generate(mining_node, 1)[0], True)[\"tx\"]\n             self.sync_blocks(wait=.1)\n             # update which txouts are confirmed\n             newmem = []\n@@ -221,7 +221,7 @@ def run_test(self):\n \n         # Mine\n         while len(self.nodes[0].getrawmempool()) > 0:\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n \n         # Repeatedly split those 2 outputs, doubling twice for each rep\n         # Use txouts to monitor the available utxo, since these won't be tracked in wallet\n@@ -231,12 +231,12 @@ def run_test(self):\n             while len(self.txouts) > 0:\n                 split_inputs(self.nodes[0], self.txouts, self.txouts2)\n             while len(self.nodes[0].getrawmempool()) > 0:\n-                self.nodes[0].generate(1)\n+                self.generate(self.nodes[0], 1)\n             # Double txouts2 to txouts\n             while len(self.txouts2) > 0:\n                 split_inputs(self.nodes[0], self.txouts2, self.txouts)\n             while len(self.nodes[0].getrawmempool()) > 0:\n-                self.nodes[0].generate(1)\n+                self.generate(self.nodes[0], 1)\n             reps += 1\n         self.log.info(\"Finished splitting\")\n \n@@ -269,7 +269,7 @@ def run_test(self):\n \n         # Finish by mining a normal-sized block:\n         while len(self.nodes[1].getrawmempool()) > 0:\n-            self.nodes[1].generate(1)\n+            self.generate(self.nodes[1], 1)\n \n         self.sync_blocks(self.nodes[0:3], wait=.1)\n         self.log.info(\"Final estimates after emptying mempools\")"
      },
      {
        "sha": "13e6a8d6d72b42533b2faf3caaee009373327809",
        "filename": "test/functional/feature_loadblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_loadblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_loadblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_loadblock.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -29,7 +29,7 @@ def set_test_params(self):\n \n     def run_test(self):\n         self.nodes[1].setnetworkactive(state=False)\n-        self.nodes[0].generate(COINBASE_MATURITY)\n+        self.generate(self.nodes[0], COINBASE_MATURITY)\n \n         # Parsing the url of our node to get settings for config file\n         data_dir = self.nodes[0].datadir"
      },
      {
        "sha": "ac4d40638e03e1f4cc6fdf5c848271760bf69ee5",
        "filename": "test/functional/feature_maxuploadtarget.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_maxuploadtarget.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_maxuploadtarget.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_maxuploadtarget.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -38,7 +38,6 @@ def set_test_params(self):\n         self.extra_args = [[\n             \"-maxuploadtarget=800\",\n             \"-acceptnonstdtxn=1\",\n-            \"-peertimeout=9999\",  # bump because mocktime might cause a disconnect otherwise\n         ]]\n         self.supports_cli = False\n \n@@ -56,7 +55,7 @@ def run_test(self):\n         self.nodes[0].setmocktime(old_time)\n \n         # Generate some old blocks\n-        self.nodes[0].generate(130)\n+        self.generate(self.nodes[0], 130)\n \n         # p2p_conns[0] will only request old blocks\n         # p2p_conns[1] will only request new blocks\n@@ -67,7 +66,7 @@ def run_test(self):\n             p2p_conns.append(self.nodes[0].add_p2p_connection(TestP2PConn()))\n \n         # Now mine a big block\n-        mine_large_block(self.nodes[0], self.utxo_cache)\n+        mine_large_block(self, self.nodes[0], self.utxo_cache)\n \n         # Store the hash; we'll request this later\n         big_old_block = self.nodes[0].getbestblockhash()\n@@ -78,7 +77,7 @@ def run_test(self):\n         self.nodes[0].setmocktime(int(time.time()) - 2*60*60*24)\n \n         # Mine one more block, so that the prior block looks old\n-        mine_large_block(self.nodes[0], self.utxo_cache)\n+        mine_large_block(self, self.nodes[0], self.utxo_cache)\n \n         # We'll be requesting this new block too\n         big_new_block = self.nodes[0].getbestblockhash()"
      },
      {
        "sha": "11cb4aa3cbc3fbb4585a08b6f2406f090c93b140",
        "filename": "test/functional/feature_minchainwork.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_minchainwork.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_minchainwork.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_minchainwork.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -51,7 +51,7 @@ def run_test(self):\n \n         num_blocks_to_generate = int((self.node_min_work[1] - starting_chain_work) / REGTEST_WORK_PER_BLOCK)\n         self.log.info(f\"Generating {num_blocks_to_generate} blocks on node0\")\n-        hashes = self.nodes[0].generatetoaddress(num_blocks_to_generate,\n+        hashes = self.generatetoaddress(self.nodes[0], num_blocks_to_generate,\n                                                  self.nodes[0].get_deterministic_priv_key().address)\n \n         self.log.info(f\"Node0 current chain work: {self.nodes[0].getblockheader(hashes[-1])['chainwork']}\")\n@@ -73,7 +73,7 @@ def run_test(self):\n         assert_equal(self.nodes[2].getblockcount(), starting_blockcount)\n \n         self.log.info(\"Generating one more block\")\n-        self.nodes[0].generatetoaddress(1, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], 1, self.nodes[0].get_deterministic_priv_key().address)\n \n         self.log.info(\"Verifying nodes are all synced\")\n "
      },
      {
        "sha": "5ef3860867368461153e5ecb4ff173bc659643f5",
        "filename": "test/functional/feature_notifications.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_notifications.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_notifications.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_notifications.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -76,7 +76,7 @@ def run_test(self):\n \n         self.log.info(\"test -blocknotify\")\n         block_count = 10\n-        blocks = self.nodes[1].generatetoaddress(block_count, self.nodes[1].getnewaddress() if self.is_wallet_compiled() else ADDRESS_BCRT1_UNSPENDABLE)\n+        blocks = self.generatetoaddress(self.nodes[1], block_count, self.nodes[1].getnewaddress() if self.is_wallet_compiled() else ADDRESS_BCRT1_UNSPENDABLE)\n \n         # wait at most 10 seconds for expected number of files before reading the content\n         self.wait_until(lambda: len(os.listdir(self.blocknotify_dir)) == block_count, timeout=10)\n@@ -110,7 +110,7 @@ def run_test(self):\n             # triggered by node 1\n             self.log.info(\"test -walletnotify with conflicting transactions\")\n             self.nodes[0].rescanblockchain()\n-            self.nodes[0].generatetoaddress(100, ADDRESS_BCRT1_UNSPENDABLE)\n+            self.generatetoaddress(self.nodes[0], 100, ADDRESS_BCRT1_UNSPENDABLE)\n             self.sync_blocks()\n \n             # Generate transaction on node 0, sync mempools, and check for\n@@ -131,7 +131,7 @@ def run_test(self):\n \n             # Add bump1 transaction to new block, checking for a notification\n             # and the correct number of confirmations.\n-            blockhash1 = self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+            blockhash1 = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n             blockheight1 = self.nodes[0].getblockcount()\n             self.sync_blocks()\n             self.expect_wallet_notify([(bump1, blockheight1, blockhash1)])\n@@ -148,7 +148,7 @@ def run_test(self):\n             # about newly confirmed bump2 and newly conflicted tx2.\n             self.disconnect_nodes(0, 1)\n             bump2 = self.nodes[0].bumpfee(tx2)[\"txid\"]\n-            blockhash2 = self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+            blockhash2 = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n             blockheight2 = self.nodes[0].getblockcount()\n             assert_equal(self.nodes[0].gettransaction(bump2)[\"confirmations\"], 1)\n             assert_equal(tx2 in self.nodes[1].getrawmempool(), True)"
      },
      {
        "sha": "96984e1e645e854563d836bbf79222ac48fc7823",
        "filename": "test/functional/feature_nulldummy.py",
        "status": "modified",
        "additions": 17,
        "deletions": 12,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_nulldummy.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_nulldummy.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_nulldummy.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -24,7 +24,10 @@\n from test_framework.messages import CTransaction\n from test_framework.script import CScript\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_raises_rpc_error\n+from test_framework.util import (\n+    assert_equal,\n+    assert_raises_rpc_error,\n+)\n \n NULLDUMMY_ERROR = \"non-mandatory-script-verify-flag (Dummy CHECKMULTISIG argument must be zero)\"\n \n@@ -51,6 +54,7 @@ def set_test_params(self):\n         self.extra_args = [[\n             f'-segwitheight={COINBASE_MATURITY + 5}',\n             '-addresstype=legacy',\n+            '-par=1',  # Use only one script thread to get the exact reject reason for testing\n         ]]\n \n     def skip_test_if_missing_module(self):\n@@ -70,11 +74,11 @@ def run_test(self):\n             wmulti.importaddress(self.ms_address)\n             wmulti.importaddress(self.wit_ms_address)\n \n-        self.coinbase_blocks = self.nodes[0].generate(2)  # block height = 2\n+        self.coinbase_blocks = self.generate(self.nodes[0], 2)  # block height = 2\n         coinbase_txid = []\n         for i in self.coinbase_blocks:\n             coinbase_txid.append(self.nodes[0].getblock(i)['tx'][0])\n-        self.nodes[0].generate(COINBASE_MATURITY)  # block height = COINBASE_MATURITY + 2\n+        self.generate(self.nodes[0], COINBASE_MATURITY)  # block height = COINBASE_MATURITY + 2\n         self.lastblockhash = self.nodes[0].getbestblockhash()\n         self.lastblockheight = COINBASE_MATURITY + 2\n         self.lastblocktime = int(time.time()) + self.lastblockheight\n@@ -86,36 +90,36 @@ def run_test(self):\n         txid2 = self.nodes[0].sendrawtransaction(test1txs[1].serialize_with_witness().hex(), 0)\n         test1txs.append(create_transaction(self.nodes[0], coinbase_txid[1], self.wit_ms_address, amount=49))\n         txid3 = self.nodes[0].sendrawtransaction(test1txs[2].serialize_with_witness().hex(), 0)\n-        self.block_submit(self.nodes[0], test1txs, False, True)\n+        self.block_submit(self.nodes[0], test1txs, accept=True)\n \n         self.log.info(\"Test 2: Non-NULLDUMMY base multisig transaction should not be accepted to mempool before activation\")\n         test2tx = create_transaction(self.nodes[0], txid2, self.ms_address, amount=47)\n         trueDummy(test2tx)\n         assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, test2tx.serialize_with_witness().hex(), 0)\n \n         self.log.info(f\"Test 3: Non-NULLDUMMY base transactions should be accepted in a block before activation [{COINBASE_MATURITY + 4}]\")\n-        self.block_submit(self.nodes[0], [test2tx], False, True)\n+        self.block_submit(self.nodes[0], [test2tx], accept=True)\n \n         self.log.info(\"Test 4: Non-NULLDUMMY base multisig transaction is invalid after activation\")\n         test4tx = create_transaction(self.nodes[0], test2tx.hash, self.address, amount=46)\n         test6txs = [CTransaction(test4tx)]\n         trueDummy(test4tx)\n         assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, test4tx.serialize_with_witness().hex(), 0)\n-        self.block_submit(self.nodes[0], [test4tx])\n+        self.block_submit(self.nodes[0], [test4tx], accept=False)\n \n         self.log.info(\"Test 5: Non-NULLDUMMY P2WSH multisig transaction invalid after activation\")\n         test5tx = create_transaction(self.nodes[0], txid3, self.wit_address, amount=48)\n         test6txs.append(CTransaction(test5tx))\n         test5tx.wit.vtxinwit[0].scriptWitness.stack[0] = b'\\x01'\n         assert_raises_rpc_error(-26, NULLDUMMY_ERROR, self.nodes[0].sendrawtransaction, test5tx.serialize_with_witness().hex(), 0)\n-        self.block_submit(self.nodes[0], [test5tx], True)\n+        self.block_submit(self.nodes[0], [test5tx], with_witness=True, accept=False)\n \n         self.log.info(f\"Test 6: NULLDUMMY compliant base/witness transactions should be accepted to mempool and in block after activation [{COINBASE_MATURITY + 5}]\")\n         for i in test6txs:\n             self.nodes[0].sendrawtransaction(i.serialize_with_witness().hex(), 0)\n-        self.block_submit(self.nodes[0], test6txs, True, True)\n+        self.block_submit(self.nodes[0], test6txs, with_witness=True, accept=True)\n \n-    def block_submit(self, node, txs, witness=False, accept=False):\n+    def block_submit(self, node, txs, *, with_witness=False, accept):\n         tmpl = node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS)\n         assert_equal(tmpl['previousblockhash'], self.lastblockhash)\n         assert_equal(tmpl['height'], self.lastblockheight + 1)\n@@ -124,11 +128,12 @@ def block_submit(self, node, txs, witness=False, accept=False):\n             tx.rehash()\n             block.vtx.append(tx)\n         block.hashMerkleRoot = block.calc_merkle_root()\n-        witness and add_witness_commitment(block)\n+        if with_witness:\n+            add_witness_commitment(block)\n         block.rehash()\n         block.solve()\n-        assert_equal(None if accept else 'block-validation-failed', node.submitblock(block.serialize().hex()))\n-        if (accept):\n+        assert_equal(None if accept else NULLDUMMY_ERROR, node.submitblock(block.serialize().hex()))\n+        if accept:\n             assert_equal(node.getbestblockhash(), block.hash)\n             self.lastblockhash = block.hash\n             self.lastblocktime += 1"
      },
      {
        "sha": "fd6b8620d445c1f95786fce4b75652eed880a847",
        "filename": "test/functional/feature_presegwit_node_upgrade.py",
        "status": "modified",
        "additions": 8,
        "deletions": 3,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_presegwit_node_upgrade.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_presegwit_node_upgrade.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_presegwit_node_upgrade.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -9,6 +9,8 @@\n     assert_equal,\n     softfork_active,\n )\n+import os\n+\n \n class SegwitUpgradeTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -28,15 +30,18 @@ def run_test(self):\n         assert not softfork_active(node, \"segwit\")\n \n         # Generate 8 blocks without witness data\n-        node.generate(8)\n+        self.generate(node, 8)\n         assert_equal(node.getblockcount(), 8)\n \n         self.stop_node(0)\n         # Restarting the node (with segwit activation height set to 5) should result in a shutdown\n         # because the blockchain consists of 3 insufficiently validated blocks per segwit consensus rules.\n         node.assert_start_raises_init_error(\n-                extra_args=[\"-segwitheight=5\"],\n-                expected_msg=\": Witness data for blocks after height 5 requires validation. Please restart with -reindex..\\nPlease restart with -reindex or -reindex-chainstate to recover.\")\n+            extra_args=[\"-segwitheight=5\"],\n+            expected_msg=\": Witness data for blocks after height 5 requires \"\n+            f\"validation. Please restart with -reindex..{os.linesep}\"\n+            \"Please restart with -reindex or -reindex-chainstate to recover.\",\n+        )\n \n         # As directed, the user restarts the node with -reindex\n         self.start_node(0, extra_args=[\"-reindex\", \"-segwitheight=5\"])"
      },
      {
        "sha": "c2463d0bccd260b49c6e834f42625ff3bdf85557",
        "filename": "test/functional/feature_pruning.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_pruning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_pruning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_pruning.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -118,9 +118,9 @@ def setup_nodes(self):\n \n     def create_big_chain(self):\n         # Start by creating some coinbases we can spend later\n-        self.nodes[1].generate(200)\n+        self.generate(self.nodes[1], 200)\n         self.sync_blocks(self.nodes[0:2])\n-        self.nodes[0].generate(150)\n+        self.generate(self.nodes[0], 150)\n \n         # Then mine enough full blocks to create more than 550MiB of data\n         mine_large_blocks(self.nodes[0], 645)\n@@ -211,7 +211,7 @@ def reorg_test(self):\n         self.disconnect_nodes(1, 2)\n \n         self.log.info(\"Generating new longer chain of 300 more blocks\")\n-        self.nodes[1].generate(300)\n+        self.generate(self.nodes[1], 300)\n \n         self.log.info(\"Reconnect nodes\")\n         self.connect_nodes(0, 1)\n@@ -263,7 +263,7 @@ def reorg_back(self):\n             self.nodes[0].invalidateblock(curchainhash)\n             assert_equal(self.nodes[0].getblockcount(), self.mainchainheight)\n             assert_equal(self.nodes[0].getbestblockhash(), self.mainchainhash2)\n-            goalbesthash = self.nodes[0].generate(blocks_to_mine)[-1]\n+            goalbesthash = self.generate(self.nodes[0], blocks_to_mine)[-1]\n             goalbestheight = first_reorg_height + 1\n \n         self.log.info(\"Verify node 2 reorged back to the main chain, some blocks of which it had to redownload\")\n@@ -306,7 +306,7 @@ def has_block(index):\n         assert_equal(block1_details[\"nTx\"], len(block1_details[\"tx\"]))\n \n         # mine 6 blocks so we are at height 1001 (i.e., above PruneAfterHeight)\n-        node.generate(6)\n+        self.generate(node, 6)\n         assert_equal(node.getblockchaininfo()[\"blocks\"], 1001)\n \n         # Pruned block should still know the number of transactions\n@@ -337,7 +337,7 @@ def has_block(index):\n         assert has_block(2), \"blk00002.dat is still there, should be pruned by now\"\n \n         # advance the tip so blk00002.dat and blk00003.dat can be pruned (the last 288 blocks should now be in blk00004.dat)\n-        node.generate(288)\n+        self.generate(node, 288)\n         prune(1000)\n         assert not has_block(2), \"blk00002.dat is still there, should be pruned by now\"\n         assert not has_block(3), \"blk00003.dat is still there, should be pruned by now\""
      },
      {
        "sha": "cb7556feb473d00ba4466405bfb07255c8126417",
        "filename": "test/functional/feature_rbf.py",
        "status": "modified",
        "additions": 64,
        "deletions": 56,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_rbf.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_rbf.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_rbf.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -23,49 +23,6 @@\n from test_framework.wallet import MiniWallet\n \n MAX_REPLACEMENT_LIMIT = 100\n-\n-\n-def make_utxo(node, amount, confirmed=True, scriptPubKey=DUMMY_P2WPKH_SCRIPT):\n-    \"\"\"Create a txout with a given amount and scriptPubKey\n-\n-    Mines coins as needed.\n-\n-    confirmed - txouts created will be confirmed in the blockchain;\n-                unconfirmed otherwise.\n-    \"\"\"\n-    fee = 1 * COIN\n-    while node.getbalance() < satoshi_round((amount + fee) / COIN):\n-        node.generate(COINBASE_MATURITY)\n-\n-    new_addr = node.getnewaddress()\n-    txid = node.sendtoaddress(new_addr, satoshi_round((amount + fee) / COIN))\n-    tx1 = node.getrawtransaction(txid, 1)\n-    txid = int(txid, 16)\n-    i, _ = next(filter(lambda vout: new_addr == vout[1]['scriptPubKey']['address'], enumerate(tx1['vout'])))\n-\n-    tx2 = CTransaction()\n-    tx2.vin = [CTxIn(COutPoint(txid, i))]\n-    tx2.vout = [CTxOut(amount, scriptPubKey)]\n-    tx2.rehash()\n-\n-    signed_tx = node.signrawtransactionwithwallet(tx2.serialize().hex())\n-\n-    txid = node.sendrawtransaction(signed_tx['hex'], 0)\n-\n-    # If requested, ensure txouts are confirmed.\n-    if confirmed:\n-        mempool_size = len(node.getrawmempool())\n-        while mempool_size > 0:\n-            node.generate(1)\n-            new_size = len(node.getrawmempool())\n-            # Error out if we have something stuck in the mempool, as this\n-            # would likely be a bug.\n-            assert new_size < mempool_size\n-            mempool_size = new_size\n-\n-    return COutPoint(int(txid, 16), 0)\n-\n-\n class ReplaceByFeeTest(BitcoinTestFramework):\n     def set_test_params(self):\n         self.num_nodes = 1\n@@ -129,6 +86,46 @@ def run_test(self):\n \n         self.log.info(\"Passed\")\n \n+    def make_utxo(self, node, amount, confirmed=True, scriptPubKey=DUMMY_P2WPKH_SCRIPT):\n+        \"\"\"Create a txout with a given amount and scriptPubKey\n+\n+        Mines coins as needed.\n+\n+        confirmed - txouts created will be confirmed in the blockchain;\n+                    unconfirmed otherwise.\n+        \"\"\"\n+        fee = 1 * COIN\n+        while node.getbalance() < satoshi_round((amount + fee) / COIN):\n+            self.generate(node, COINBASE_MATURITY)\n+\n+        new_addr = node.getnewaddress()\n+        txid = node.sendtoaddress(new_addr, satoshi_round((amount + fee) / COIN))\n+        tx1 = node.getrawtransaction(txid, 1)\n+        txid = int(txid, 16)\n+        i, _ = next(filter(lambda vout: new_addr == vout[1]['scriptPubKey']['address'], enumerate(tx1['vout'])))\n+\n+        tx2 = CTransaction()\n+        tx2.vin = [CTxIn(COutPoint(txid, i))]\n+        tx2.vout = [CTxOut(amount, scriptPubKey)]\n+        tx2.rehash()\n+\n+        signed_tx = node.signrawtransactionwithwallet(tx2.serialize().hex())\n+\n+        txid = node.sendrawtransaction(signed_tx['hex'], 0)\n+\n+        # If requested, ensure txouts are confirmed.\n+        if confirmed:\n+            mempool_size = len(node.getrawmempool())\n+            while mempool_size > 0:\n+                self.generate(node, 1)\n+                new_size = len(node.getrawmempool())\n+                # Error out if we have something stuck in the mempool, as this\n+                # would likely be a bug.\n+                assert new_size < mempool_size\n+                mempool_size = new_size\n+\n+        return COutPoint(int(txid, 16), 0)\n+\n     def test_simple_doublespend(self):\n         \"\"\"Simple doublespend\"\"\"\n         # we use MiniWallet to create a transaction template with inputs correctly set,\n@@ -165,7 +162,7 @@ def test_doublespend_chain(self):\n         \"\"\"Doublespend of a long chain\"\"\"\n \n         initial_nValue = 50 * COIN\n-        tx0_outpoint = make_utxo(self.nodes[0], initial_nValue)\n+        tx0_outpoint = self.make_utxo(self.nodes[0], initial_nValue)\n \n         prevout = tx0_outpoint\n         remaining_value = initial_nValue\n@@ -205,7 +202,7 @@ def test_doublespend_tree(self):\n         \"\"\"Doublespend of a big tree of transactions\"\"\"\n \n         initial_nValue = 50 * COIN\n-        tx0_outpoint = make_utxo(self.nodes[0], initial_nValue)\n+        tx0_outpoint = self.make_utxo(self.nodes[0], initial_nValue)\n \n         def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001 * COIN, _total_txs=None):\n             if _total_txs is None:\n@@ -268,7 +265,7 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001 * COIN, _to\n         # double-spent at once\" anti-DoS limit.\n         for n in (MAX_REPLACEMENT_LIMIT + 1, MAX_REPLACEMENT_LIMIT * 2):\n             fee = int(0.0001 * COIN)\n-            tx0_outpoint = make_utxo(self.nodes[0], initial_nValue)\n+            tx0_outpoint = self.make_utxo(self.nodes[0], initial_nValue)\n             tree_txs = list(branch(tx0_outpoint, initial_nValue, n, fee=fee))\n             assert_equal(len(tree_txs), n)\n \n@@ -285,7 +282,7 @@ def branch(prevout, initial_value, max_txs, tree_width=5, fee=0.0001 * COIN, _to\n \n     def test_replacement_feeperkb(self):\n         \"\"\"Replacement requires fee-per-KB to be higher\"\"\"\n-        tx0_outpoint = make_utxo(self.nodes[0], int(1.1 * COIN))\n+        tx0_outpoint = self.make_utxo(self.nodes[0], int(1.1 * COIN))\n \n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n@@ -305,8 +302,8 @@ def test_replacement_feeperkb(self):\n \n     def test_spends_of_conflicting_outputs(self):\n         \"\"\"Replacements that spend conflicting tx outputs are rejected\"\"\"\n-        utxo1 = make_utxo(self.nodes[0], int(1.2 * COIN))\n-        utxo2 = make_utxo(self.nodes[0], 3 * COIN)\n+        utxo1 = self.make_utxo(self.nodes[0], int(1.2 * COIN))\n+        utxo2 = self.make_utxo(self.nodes[0], 3 * COIN)\n \n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(utxo1, nSequence=0)]\n@@ -345,8 +342,8 @@ def test_spends_of_conflicting_outputs(self):\n \n     def test_new_unconfirmed_inputs(self):\n         \"\"\"Replacements that add new unconfirmed inputs are rejected\"\"\"\n-        confirmed_utxo = make_utxo(self.nodes[0], int(1.1 * COIN))\n-        unconfirmed_utxo = make_utxo(self.nodes[0], int(0.1 * COIN), False)\n+        confirmed_utxo = self.make_utxo(self.nodes[0], int(1.1 * COIN))\n+        unconfirmed_utxo = self.make_utxo(self.nodes[0], int(0.1 * COIN), False)\n \n         tx1 = CTransaction()\n         tx1.vin = [CTxIn(confirmed_utxo)]\n@@ -369,7 +366,7 @@ def test_too_many_replacements(self):\n \n         # Start by creating a single transaction with many outputs\n         initial_nValue = 10 * COIN\n-        utxo = make_utxo(self.nodes[0], initial_nValue)\n+        utxo = self.make_utxo(self.nodes[0], initial_nValue)\n         fee = int(0.0001 * COIN)\n         split_value = int((initial_nValue - fee) / (MAX_REPLACEMENT_LIMIT + 1))\n \n@@ -417,7 +414,7 @@ def test_too_many_replacements(self):\n \n     def test_opt_in(self):\n         \"\"\"Replacing should only work if orig tx opted in\"\"\"\n-        tx0_outpoint = make_utxo(self.nodes[0], int(1.1 * COIN))\n+        tx0_outpoint = self.make_utxo(self.nodes[0], int(1.1 * COIN))\n \n         # Create a non-opting in transaction\n         tx1a = CTransaction()\n@@ -438,7 +435,7 @@ def test_opt_in(self):\n         # This will raise an exception\n         assert_raises_rpc_error(-26, \"txn-mempool-conflict\", self.nodes[0].sendrawtransaction, tx1b_hex, 0)\n \n-        tx1_outpoint = make_utxo(self.nodes[0], int(1.1 * COIN))\n+        tx1_outpoint = self.make_utxo(self.nodes[0], int(1.1 * COIN))\n \n         # Create a different non-opting in transaction\n         tx2a = CTransaction()\n@@ -494,7 +491,7 @@ def test_prioritised_transactions(self):\n         # correctly used by replacement logic\n \n         # 1. Check that feeperkb uses modified fees\n-        tx0_outpoint = make_utxo(self.nodes[0], int(1.1 * COIN))\n+        tx0_outpoint = self.make_utxo(self.nodes[0], int(1.1 * COIN))\n \n         tx1a = CTransaction()\n         tx1a.vin = [CTxIn(tx0_outpoint, nSequence=0)]\n@@ -520,7 +517,7 @@ def test_prioritised_transactions(self):\n         assert tx1b_txid in self.nodes[0].getrawmempool()\n \n         # 2. Check that absolute fee checks use modified fee.\n-        tx1_outpoint = make_utxo(self.nodes[0], int(1.1 * COIN))\n+        tx1_outpoint = self.make_utxo(self.nodes[0], int(1.1 * COIN))\n \n         tx2a = CTransaction()\n         tx2a.vin = [CTxIn(tx1_outpoint, nSequence=0)]\n@@ -621,6 +618,17 @@ def test_no_inherited_signaling(self):\n         assert_equal(True, self.nodes[0].getmempoolentry(optin_parent_tx['txid'])['bip125-replaceable'])\n         assert_raises_rpc_error(-26, 'txn-mempool-conflict', self.nodes[0].sendrawtransaction, replacement_child_tx[\"hex\"], 0)\n \n+        self.log.info('Check that the child tx can still be replaced (via a tx that also replaces the parent)')\n+        replacement_parent_tx = self.wallet.send_self_transfer(\n+            from_node=self.nodes[0],\n+            utxo_to_spend=confirmed_utxo,\n+            sequence=0xffffffff,\n+            fee_rate=Decimal('0.03'),\n+        )\n+        # Check that child is removed and update wallet utxo state\n+        assert_raises_rpc_error(-5, 'Transaction not in mempool', self.nodes[0].getmempoolentry, optout_child_tx['txid'])\n+        self.wallet.get_utxo(txid=optout_child_tx['txid'])\n+\n     def test_replacement_relay_fee(self):\n         tx = self.wallet.send_self_transfer(from_node=self.nodes[0])['tx']\n "
      },
      {
        "sha": "f0435b21b28acf3fda13b6ef21301b3206e2590a",
        "filename": "test/functional/feature_reindex.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_reindex.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_reindex.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_reindex.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -19,7 +19,7 @@ def set_test_params(self):\n         self.num_nodes = 1\n \n     def reindex(self, justchainstate=False):\n-        self.nodes[0].generatetoaddress(3, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], 3, self.nodes[0].get_deterministic_priv_key().address)\n         blockcount = self.nodes[0].getblockcount()\n         self.stop_nodes()\n         extra_args = [[\"-reindex-chainstate\" if justchainstate else \"-reindex\"]]"
      },
      {
        "sha": "2b79b3284c6f9958d8fa05ab59d21371342044f1",
        "filename": "test/functional/feature_segwit.py",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_segwit.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -105,21 +105,21 @@ def setup_network(self):\n \n     def success_mine(self, node, txid, sign, redeem_script=\"\"):\n         send_to_witness(1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n-        block = node.generate(1)\n+        block = self.generate(node, 1)\n         assert_equal(len(node.getblock(block[0])[\"tx\"]), 2)\n         self.sync_blocks()\n \n     def skip_mine(self, node, txid, sign, redeem_script=\"\"):\n         send_to_witness(1, node, getutxo(txid), self.pubkey[0], False, Decimal(\"49.998\"), sign, redeem_script)\n-        block = node.generate(1)\n+        block = self.generate(node, 1)\n         assert_equal(len(node.getblock(block[0])[\"tx\"]), 1)\n         self.sync_blocks()\n \n     def fail_accept(self, node, error_msg, txid, sign, redeem_script=\"\"):\n         assert_raises_rpc_error(-26, error_msg, send_to_witness, use_p2wsh=1, node=node, utxo=getutxo(txid), pubkey=self.pubkey[0], encode_p2sh=False, amount=Decimal(\"49.998\"), sign=sign, insert_redeem_script=redeem_script)\n \n     def run_test(self):\n-        self.nodes[0].generate(161)  # block 161\n+        self.generate(self.nodes[0], 161)  # block 161\n \n         self.log.info(\"Verify sigops are counted in GBT with pre-BIP141 rules before the fork\")\n         txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1)\n@@ -130,7 +130,7 @@ def run_test(self):\n         assert tmpl['transactions'][0]['hash'] == txid\n         assert tmpl['transactions'][0]['sigops'] == 2\n         assert '!segwit' not in tmpl['rules']\n-        self.nodes[0].generate(1)  # block 162\n+        self.generate(self.nodes[0], 1)  # block 162\n \n         balance_presetup = self.nodes[0].getbalance()\n         self.pubkey = []\n@@ -156,15 +156,15 @@ def run_test(self):\n                     wit_ids[n][v].append(send_to_witness(v, self.nodes[0], find_spendable_utxo(self.nodes[0], 50), self.pubkey[n], False, Decimal(\"49.999\")))\n                     p2sh_ids[n][v].append(send_to_witness(v, self.nodes[0], find_spendable_utxo(self.nodes[0], 50), self.pubkey[n], True, Decimal(\"49.999\")))\n \n-        self.nodes[0].generate(1)  # block 163\n+        self.generate(self.nodes[0], 1)  # block 163\n         self.sync_blocks()\n \n         # Make sure all nodes recognize the transactions as theirs\n         assert_equal(self.nodes[0].getbalance(), balance_presetup - 60 * 50 + 20 * Decimal(\"49.999\") + 50)\n         assert_equal(self.nodes[1].getbalance(), 20 * Decimal(\"49.999\"))\n         assert_equal(self.nodes[2].getbalance(), 20 * Decimal(\"49.999\"))\n \n-        self.nodes[0].generate(260)  # block 423\n+        self.generate(self.nodes[0], 260)  # block 423\n         self.sync_blocks()\n \n         self.log.info(\"Verify witness txs are skipped for mining before the fork\")\n@@ -177,11 +177,11 @@ def run_test(self):\n         self.fail_accept(self.nodes[2], \"mandatory-script-verify-flag-failed (Operation not valid with the current stack size)\", p2sh_ids[NODE_2][P2WPKH][1], sign=False)\n         self.fail_accept(self.nodes[2], \"mandatory-script-verify-flag-failed (Operation not valid with the current stack size)\", p2sh_ids[NODE_2][P2WSH][1], sign=False)\n \n-        self.nodes[2].generate(4)  # blocks 428-431\n+        self.generate(self.nodes[2], 4)  # blocks 428-431\n \n         self.log.info(\"Verify previous witness txs skipped for mining can now be mined\")\n         assert_equal(len(self.nodes[2].getrawmempool()), 4)\n-        blockhash = self.nodes[2].generate(1)[0]  # block 432 (first block with new rules; 432 = 144 * 3)\n+        blockhash = self.generate(self.nodes[2], 1)[0]  # block 432 (first block with new rules; 432 = 144 * 3)\n         self.sync_blocks()\n         assert_equal(len(self.nodes[2].getrawmempool()), 0)\n         segwit_tx_list = self.nodes[2].getblock(blockhash)[\"tx\"]\n@@ -239,7 +239,7 @@ def run_test(self):\n         assert tmpl['transactions'][0]['sigops'] == 8\n         assert '!segwit' in tmpl['rules']\n \n-        self.nodes[0].generate(1)  # Mine a block to clear the gbt cache\n+        self.generate(self.nodes[0], 1)  # Mine a block to clear the gbt cache\n \n         self.log.info(\"Non-segwit miners are able to use GBT response after activation.\")\n         # Create a 3-tx chain: tx1 (non-segwit input, paying to a segwit output) ->\n@@ -302,7 +302,7 @@ def run_test(self):\n         assert_equal(self.nodes[0].getmempoolentry(txid3)[\"weight\"], tx.get_weight())\n \n         # Mine a block to clear the gbt cache again.\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         self.log.info(\"Verify behaviour of importaddress and listunspent\")\n \n@@ -592,7 +592,7 @@ def mine_and_test_listunspent(self, script_list, ismine):\n         tx.rehash()\n         signresults = self.nodes[0].signrawtransactionwithwallet(tx.serialize_without_witness().hex())['hex']\n         txid = self.nodes[0].sendrawtransaction(hexstring=signresults, maxfeerate=0)\n-        txs_mined[txid] = self.nodes[0].generate(1)[0]\n+        txs_mined[txid] = self.generate(self.nodes[0], 1)[0]\n         self.sync_blocks()\n         watchcount = 0\n         spendcount = 0\n@@ -642,7 +642,7 @@ def create_and_mine_tx_from_txids(self, txids, success=True):\n         tx.rehash()\n         signresults = self.nodes[0].signrawtransactionwithwallet(tx.serialize_without_witness().hex())['hex']\n         self.nodes[0].sendrawtransaction(hexstring=signresults, maxfeerate=0)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n \n "
      },
      {
        "sha": "94138b0e6d23e027a45e143a1300470310ca6bf1",
        "filename": "test/functional/feature_signet.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_signet.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_signet.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_signet.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -51,7 +51,7 @@ def run_test(self):\n         assert_equal(mining_info['networkhashps'], Decimal('0'))\n         assert_equal(mining_info['pooledtx'], 0)\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         self.log.info(\"pregenerated signet blocks check\")\n "
      },
      {
        "sha": "c44a48f15fcf858af6cbee8c2f84e46eeaa91aae",
        "filename": "test/functional/feature_taproot.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_taproot.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_taproot.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_taproot.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -1461,7 +1461,7 @@ def test_spenders(self, node, spenders, input_counts):\n     def run_test(self):\n         # Post-taproot activation tests go first (pre-taproot tests' blocks are invalid post-taproot).\n         self.log.info(\"Post-activation tests...\")\n-        self.nodes[1].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[1], COINBASE_MATURITY + 1)\n         self.test_spenders(self.nodes[1], spenders_taproot_active(), input_counts=[1, 2, 2, 2, 2, 3])\n \n         # Re-connect nodes in case they have been disconnected"
      },
      {
        "sha": "b1b4703d37a88be41d6a2ab4c8ba238194c6bf1b",
        "filename": "test/functional/feature_utxo_set_hash.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_utxo_set_hash.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_utxo_set_hash.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_utxo_set_hash.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -31,13 +31,13 @@ def test_muhash_implementation(self):\n \n         # Generate 100 blocks and remove the first since we plan to spend its\n         # coinbase\n-        block_hashes = wallet.generate(1) + node.generate(99)\n+        block_hashes = self.generate(wallet, 1) + self.generate(node, 99)\n         blocks = list(map(lambda block: from_hex(CBlock(), node.getblock(block, False)), block_hashes))\n         blocks.pop(0)\n \n         # Create a spending transaction and mine a block which includes it\n         txid = wallet.send_self_transfer(from_node=node)['txid']\n-        tx_block = node.generateblock(output=wallet.get_address(), transactions=[txid])\n+        tx_block = self.generateblock(node, output=wallet.get_address(), transactions=[txid])\n         blocks.append(from_hex(CBlock(), node.getblock(tx_block['hash'], False)))\n \n         # Serialize the outputs that should be in the UTXO set and add them to"
      },
      {
        "sha": "311d871d495526749cf9b943aeba4303624e607d",
        "filename": "test/functional/feature_versionbits_warning.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_versionbits_warning.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/feature_versionbits_warning.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/feature_versionbits_warning.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -65,34 +65,34 @@ def run_test(self):\n \n         node_deterministic_address = node.get_deterministic_priv_key().address\n         # Mine one period worth of blocks\n-        node.generatetoaddress(VB_PERIOD, node_deterministic_address)\n+        self.generatetoaddress(node, VB_PERIOD, node_deterministic_address)\n \n         self.log.info(\"Check that there is no warning if previous VB_BLOCKS have <VB_THRESHOLD blocks with unknown versionbits version.\")\n         # Build one period of blocks with < VB_THRESHOLD blocks signaling some unknown bit\n         self.send_blocks_with_version(peer, VB_THRESHOLD - 1, VB_UNKNOWN_VERSION)\n-        node.generatetoaddress(VB_PERIOD - VB_THRESHOLD + 1, node_deterministic_address)\n+        self.generatetoaddress(node, VB_PERIOD - VB_THRESHOLD + 1, node_deterministic_address)\n \n         # Check that we're not getting any versionbit-related errors in get*info()\n         assert not VB_PATTERN.match(node.getmininginfo()[\"warnings\"])\n         assert not VB_PATTERN.match(node.getnetworkinfo()[\"warnings\"])\n \n         # Build one period of blocks with VB_THRESHOLD blocks signaling some unknown bit\n         self.send_blocks_with_version(peer, VB_THRESHOLD, VB_UNKNOWN_VERSION)\n-        node.generatetoaddress(VB_PERIOD - VB_THRESHOLD, node_deterministic_address)\n+        self.generatetoaddress(node, VB_PERIOD - VB_THRESHOLD, node_deterministic_address)\n \n         self.log.info(\"Check that there is a warning if previous VB_BLOCKS have >=VB_THRESHOLD blocks with unknown versionbits version.\")\n         # Mine a period worth of expected blocks so the generic block-version warning\n         # is cleared. This will move the versionbit state to ACTIVE.\n-        node.generatetoaddress(VB_PERIOD, node_deterministic_address)\n+        self.generatetoaddress(node, VB_PERIOD, node_deterministic_address)\n \n         # Stop-start the node. This is required because bitcoind will only warn once about unknown versions or unknown rules activating.\n         self.restart_node(0)\n \n         # Generating one block guarantees that we'll get out of IBD\n-        node.generatetoaddress(1, node_deterministic_address)\n+        self.generatetoaddress(node, 1, node_deterministic_address)\n         self.wait_until(lambda: not node.getblockchaininfo()['initialblockdownload'])\n         # Generating one more block will be enough to generate an error.\n-        node.generatetoaddress(1, node_deterministic_address)\n+        self.generatetoaddress(node, 1, node_deterministic_address)\n         # Check that get*info() shows the versionbits unknown rules warning\n         assert WARN_UNKNOWN_RULES_ACTIVE in node.getmininginfo()[\"warnings\"]\n         assert WARN_UNKNOWN_RULES_ACTIVE in node.getnetworkinfo()[\"warnings\"]"
      },
      {
        "sha": "89503adda36fd8d854d9eb0a984ed721bf7f921d",
        "filename": "test/functional/interface_bitcoin_cli.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/interface_bitcoin_cli.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/interface_bitcoin_cli.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_bitcoin_cli.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -77,7 +77,7 @@ def skip_test_if_missing_module(self):\n \n     def run_test(self):\n         \"\"\"Main test logic\"\"\"\n-        self.nodes[0].generate(BLOCKS)\n+        self.generate(self.nodes[0], BLOCKS)\n \n         self.log.info(\"Compare responses from getblockchaininfo RPC and `bitcoin-cli getblockchaininfo`\")\n         cli_response = self.nodes[0].cli.getblockchaininfo()\n@@ -158,7 +158,7 @@ def run_test(self):\n             w1.sendtoaddress(w3.getnewaddress(), amounts[2])\n \n             # Mine a block to confirm; adds a block reward (50 BTC) to the default wallet.\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n \n             self.log.info(\"Test -getinfo with multiple wallets and -rpcwallet returns specified wallet balance\")\n             for i in range(len(wallets)):\n@@ -291,7 +291,7 @@ def run_test(self):\n             assert_raises_rpc_error(-19, WALLET_NOT_SPECIFIED, self.nodes[0].cli('-generate', 1, 2, 3).echo)\n         else:\n             self.log.info(\"*** Wallet not compiled; cli getwalletinfo and -getinfo wallet tests skipped\")\n-            self.nodes[0].generate(25)  # maintain block parity with the wallet_compiled conditional branch\n+            self.generate(self.nodes[0], 25)  # maintain block parity with the wallet_compiled conditional branch\n \n         self.log.info(\"Test -version with node stopped\")\n         self.stop_node(0)"
      },
      {
        "sha": "e0716fc54a37560043719bf2680d4401b48486c6",
        "filename": "test/functional/interface_rest.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/interface_rest.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/interface_rest.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_rest.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -80,9 +80,9 @@ def run_test(self):\n         # Random address so node1's balance doesn't increase\n         not_related_address = \"2MxqoHEdNQTyYeX1mHcbrrpzgojbosTpCvJ\"\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n-        self.nodes[1].generatetoaddress(100, not_related_address)\n+        self.generatetoaddress(self.nodes[1], 100, not_related_address)\n         self.sync_all()\n \n         assert_equal(self.nodes[0].getbalance(), 50)\n@@ -107,7 +107,7 @@ def run_test(self):\n \n         self.log.info(\"Query an unspent TXO using the /getutxos URI\")\n \n-        self.nodes[1].generatetoaddress(1, not_related_address)\n+        self.generatetoaddress(self.nodes[1], 1, not_related_address)\n         self.sync_all()\n         bb_hash = self.nodes[0].getbestblockhash()\n \n@@ -182,7 +182,7 @@ def run_test(self):\n         json_obj = self.test_rest_request(f\"/getutxos/checkmempool/{spent[0]}-{spent[1]}\")\n         assert_equal(len(json_obj['utxos']), 0)\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         json_obj = self.test_rest_request(f\"/getutxos/{spending[0]}-{spending[1]}\")\n@@ -203,7 +203,7 @@ def run_test(self):\n         long_uri = '/'.join([f'{txid}-{n_}' for n_ in range(15)])\n         self.test_rest_request(f\"/getutxos/checkmempool/{long_uri}\", http_method='POST', status=200)\n \n-        self.nodes[0].generate(1)  # generate block to not affect upcoming tests\n+        self.generate(self.nodes[0], 1)  # generate block to not affect upcoming tests\n         self.sync_all()\n \n         self.log.info(\"Test the /block, /blockhashbyheight and /headers URIs\")\n@@ -274,7 +274,7 @@ def run_test(self):\n             assert_equal(json_obj[0][key], rpc_block_json[key])\n \n         # See if we can get 5 headers in one response\n-        self.nodes[1].generate(5)\n+        self.generate(self.nodes[1], 5)\n         self.sync_all()\n         json_obj = self.test_rest_request(f\"/headers/5/{bb_hash}\")\n         assert_equal(len(json_obj), 5)  # now we should have 5 header objects\n@@ -302,7 +302,7 @@ def run_test(self):\n             assert_equal(json_obj[tx]['depends'], txs[i - 1:i])\n \n         # Now mine the transactions\n-        newblockhash = self.nodes[1].generate(1)\n+        newblockhash = self.generate(self.nodes[1], 1)\n         self.sync_all()\n \n         # Check if the 3 tx show up in the new block"
      },
      {
        "sha": "4313b05f8843e4581f4f2ca8d296be3bd8090c5e",
        "filename": "test/functional/interface_zmq.py",
        "status": "modified",
        "additions": 37,
        "deletions": 16,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/interface_zmq.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/interface_zmq.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/interface_zmq.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -24,6 +24,7 @@\n     assert_equal,\n     assert_raises_rpc_error,\n )\n+from test_framework.netutil import test_ipv6_local\n from io import BytesIO\n from time import sleep\n \n@@ -82,8 +83,8 @@ class ZMQTestSetupBlock:\n     raw transaction data.\n     \"\"\"\n \n-    def __init__(self, node):\n-        self.block_hash = node.generate(1)[0]\n+    def __init__(self, test_framework, node):\n+        self.block_hash = test_framework.generate(node, 1)[0]\n         coinbase = node.getblock(self.block_hash, 2)['tx'][0]\n         self.tx_hash = coinbase['txid']\n         self.raw_tx = coinbase['hex']\n@@ -119,17 +120,20 @@ def run_test(self):\n             self.test_mempool_sync()\n             self.test_reorg()\n             self.test_multiple_interfaces()\n+            self.test_ipv6()\n         finally:\n             # Destroy the ZMQ context.\n             self.log.debug(\"Destroying ZMQ context\")\n             self.ctx.destroy(linger=None)\n \n     # Restart node with the specified zmq notifications enabled, subscribe to\n     # all of them and return the corresponding ZMQSubscriber objects.\n-    def setup_zmq_test(self, services, *, recv_timeout=60, sync_blocks=True):\n+    def setup_zmq_test(self, services, *, recv_timeout=60, sync_blocks=True, ipv6=False):\n         subscribers = []\n         for topic, address in services:\n             socket = self.ctx.socket(zmq.SUB)\n+            if ipv6:\n+                socket.setsockopt(zmq.IPV6, 1)\n             subscribers.append(ZMQSubscriber(socket, topic.encode()))\n \n         self.restart_node(0, [f\"-zmqpub{topic}={address}\" for topic, address in services] +\n@@ -147,7 +151,7 @@ def setup_zmq_test(self, services, *, recv_timeout=60, sync_blocks=True):\n         for sub in subscribers:\n             sub.socket.set(zmq.RCVTIMEO, 1000)\n         while True:\n-            test_block = ZMQTestSetupBlock(self.nodes[0])\n+            test_block = ZMQTestSetupBlock(self, self.nodes[0])\n             recv_failed = False\n             for sub in subscribers:\n                 try:\n@@ -185,7 +189,7 @@ def test_basic(self):\n \n         num_blocks = 5\n         self.log.info(f\"Generate {num_blocks} blocks (and {num_blocks} coinbase txes)\")\n-        genhashes = self.nodes[0].generatetoaddress(num_blocks, ADDRESS_BCRT1_UNSPENDABLE)\n+        genhashes = self.generatetoaddress(self.nodes[0], num_blocks, ADDRESS_BCRT1_UNSPENDABLE)\n \n         self.sync_all()\n \n@@ -226,7 +230,7 @@ def test_basic(self):\n \n             # Mining the block with this tx should result in second notification\n             # after coinbase tx notification\n-            self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+            self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)\n             hashtx.receive()\n             txid = hashtx.receive()\n             assert_equal(payment_txid, txid.hex())\n@@ -257,14 +261,14 @@ def test_reorg(self):\n \n         # Generate 1 block in nodes[0] with 1 mempool tx and receive all notifications\n         payment_txid = self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(), 1.0)\n-        disconnect_block = self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        disconnect_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n         disconnect_cb = self.nodes[0].getblock(disconnect_block)[\"tx\"][0]\n         assert_equal(self.nodes[0].getbestblockhash(), hashblock.receive().hex())\n         assert_equal(hashtx.receive().hex(), payment_txid)\n         assert_equal(hashtx.receive().hex(), disconnect_cb)\n \n         # Generate 2 blocks in nodes[1] to a different address to ensure split\n-        connect_blocks = self.nodes[1].generatetoaddress(2, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n+        connect_blocks = self.generatetoaddress(self.nodes[1], 2, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n \n         # nodes[0] will reorg chain after connecting back nodes[1]\n         self.connect_nodes(0, 1)\n@@ -308,13 +312,13 @@ def test_sequence(self):\n         seq_num = 1\n \n         # Generate 1 block in nodes[0] and receive all notifications\n-        dc_block = self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+        dc_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n \n         # Note: We are not notified of any block transactions, coinbase or mined\n         assert_equal((self.nodes[0].getbestblockhash(), \"C\", None), seq.receive_sequence())\n \n         # Generate 2 blocks in nodes[1] to a different address to ensure a chain split\n-        self.nodes[1].generatetoaddress(2, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n+        self.generatetoaddress(self.nodes[1], 2, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n \n         # nodes[0] will reorg chain after connecting back nodes[1]\n         self.connect_nodes(0, 1)\n@@ -349,7 +353,7 @@ def test_sequence(self):\n             # though the mempool sequence number does go up by the number of transactions\n             # removed from the mempool by the block mining it.\n             mempool_size = len(self.nodes[0].getrawmempool())\n-            c_block = self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n+            c_block = self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)[0]\n             self.sync_all()\n             # Make sure the number of mined transactions matches the number of txs out of mempool\n             mempool_size_delta = mempool_size - len(self.nodes[0].getrawmempool())\n@@ -389,7 +393,7 @@ def test_sequence(self):\n \n             # Other things may happen but aren't wallet-deterministic so we don't test for them currently\n             self.nodes[0].reconsiderblock(best_hash)\n-            self.nodes[1].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+            self.generatetoaddress(self.nodes[1], 1, ADDRESS_BCRT1_UNSPENDABLE)\n             self.sync_all()\n \n             self.log.info(\"Evict mempool transaction by block conflict\")\n@@ -441,7 +445,7 @@ def test_sequence(self):\n             # Last tx\n             assert_equal((orig_txid_2, \"A\", mempool_seq), seq.receive_sequence())\n             mempool_seq += 1\n-            self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+            self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)\n             self.sync_all()  # want to make sure we didn't break \"consensus\" for other tests\n \n     def test_mempool_sync(self):\n@@ -493,7 +497,7 @@ def test_mempool_sync(self):\n             txids.append(self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=0.1, replaceable=True))\n         self.nodes[0].bumpfee(txids[-1])\n         self.sync_all()\n-        self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+        self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)\n         final_txid = self.nodes[0].sendtoaddress(address=self.nodes[0].getnewaddress(), amount=0.1, replaceable=True)\n \n         # 3) Consume ZMQ backlog until we get to \"now\" for the mempool snapshot\n@@ -549,7 +553,7 @@ def test_mempool_sync(self):\n \n         # 5) If you miss a zmq/mempool sequence number, go back to step (2)\n \n-        self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+        self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)\n \n     def test_multiple_interfaces(self):\n         # Set up two subscribers with different addresses\n@@ -562,11 +566,28 @@ def test_multiple_interfaces(self):\n         ], sync_blocks=False)\n \n         # Generate 1 block in nodes[0] and receive all notifications\n-        self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+        self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_UNSPENDABLE)\n \n         # Should receive the same block hash on both subscribers\n         assert_equal(self.nodes[0].getbestblockhash(), subscribers[0].receive().hex())\n         assert_equal(self.nodes[0].getbestblockhash(), subscribers[1].receive().hex())\n \n+    def test_ipv6(self):\n+        if not test_ipv6_local():\n+            self.log.info(\"Skipping IPv6 test, because IPv6 is not supported.\")\n+            return\n+        self.log.info(\"Testing IPv6\")\n+        # Set up subscriber using IPv6 loopback address\n+        subscribers = self.setup_zmq_test([\n+            (\"hashblock\", \"tcp://[::1]:28332\")\n+        ], ipv6=True)\n+\n+        # Generate 1 block in nodes[0]\n+        self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_UNSPENDABLE)\n+\n+        # Should receive the same block hash\n+        assert_equal(self.nodes[0].getbestblockhash(), subscribers[0].receive().hex())\n+\n+\n if __name__ == '__main__':\n     ZMQTest().main()"
      },
      {
        "sha": "2ee440bcb79cd67482f4cb155791384c8d32c676",
        "filename": "test/functional/mempool_accept.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_accept.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_accept.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_accept.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -78,7 +78,7 @@ def run_test(self):\n             outputs=[{node.getnewaddress(): 0.3}, {node.getnewaddress(): 49}],\n         ))['hex']\n         txid_in_block = node.sendrawtransaction(hexstring=raw_tx_in_block, maxfeerate=0)\n-        node.generate(1)\n+        self.generate(node, 1)\n         self.mempool_size = 0\n         self.check_mempool_result(\n             result_expected=[{'txid': txid_in_block, 'allowed': False, 'reject-reason': 'txn-already-known'}],\n@@ -172,7 +172,7 @@ def run_test(self):\n             outputs=[{node.getnewaddress(): 0.1}]\n         ))['hex']\n         txid_spend_both = node.sendrawtransaction(hexstring=raw_tx_spend_both, maxfeerate=0)\n-        node.generate(1)\n+        self.generate(node, 1)\n         self.mempool_size = 0\n         # Now see if we can add the coins back to the utxo set by sending the exact txs again\n         self.check_mempool_result("
      },
      {
        "sha": "4767d6db22c669de3c143f54c601205665231ebf",
        "filename": "test/functional/mempool_accept_wtxid.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_accept_wtxid.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_accept_wtxid.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_accept_wtxid.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -44,7 +44,7 @@ def run_test(self):\n \n         self.log.info('Start with empty mempool and 101 blocks')\n         # The last 100 coinbase transactions are premature\n-        blockhash = node.generate(101)[0]\n+        blockhash = self.generate(node, 101)[0]\n         txid = node.getblock(blockhash=blockhash, verbosity=2)[\"tx\"][0][\"txid\"]\n         assert_equal(node.getmempoolinfo()['size'], 0)\n \n@@ -62,7 +62,7 @@ def run_test(self):\n         privkeys = [node.get_deterministic_priv_key().key]\n         raw_parent = node.signrawtransactionwithkey(hexstring=parent.serialize().hex(), privkeys=privkeys)['hex']\n         parent_txid = node.sendrawtransaction(hexstring=raw_parent, maxfeerate=0)\n-        node.generate(1)\n+        self.generate(node, 1)\n \n         peer_wtxid_relay = node.add_p2p_connection(P2PTxInvStore())\n "
      },
      {
        "sha": "a9f09b1cf81aee33ebf88cbee4e7e6b39e1de74d",
        "filename": "test/functional/mempool_compatibility.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_compatibility.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_compatibility.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_compatibility.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -38,8 +38,8 @@ def run_test(self):\n \n         old_node, new_node = self.nodes\n         new_wallet = MiniWallet(new_node)\n-        new_wallet.generate(1)\n-        new_node.generate(COINBASE_MATURITY)\n+        self.generate(new_wallet, 1)\n+        self.generate(new_node, COINBASE_MATURITY)\n         # Sync the nodes to ensure old_node has the block that contains the coinbase that new_wallet will spend.\n         # Otherwise, because coinbases are only valid in a block and not as loose txns, if the nodes aren't synced\n         # unbroadcasted_tx won't pass old_node's `MemPoolAccept::PreChecks`."
      },
      {
        "sha": "942f79e8b0ad0f3cfb6018cf63aa28dffb5b8863",
        "filename": "test/functional/mempool_expiry.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_expiry.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_expiry.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_expiry.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -36,8 +36,8 @@ def test_transaction_expiry(self, timeout):\n         self.wallet = MiniWallet(node)\n \n         # Add enough mature utxos to the wallet so that all txs spend confirmed coins.\n-        self.wallet.generate(4)\n-        node.generate(COINBASE_MATURITY)\n+        self.generate(self.wallet, 4)\n+        self.generate(node, COINBASE_MATURITY)\n \n         # Send a parent transaction that will expire.\n         parent_txid = self.wallet.send_self_transfer(from_node=node)['txid']"
      },
      {
        "sha": "c82dbb3f3d3073cc717fb1052669320b9711bb0a",
        "filename": "test/functional/mempool_limit.py",
        "status": "modified",
        "additions": 45,
        "deletions": 38,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_limit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_limit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_limit.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -6,8 +6,11 @@\n \n from decimal import Decimal\n \n+from test_framework.blocktools import COINBASE_MATURITY\n from test_framework.test_framework import BitcoinTestFramework\n-from test_framework.util import assert_equal, assert_greater_than, assert_raises_rpc_error, create_confirmed_utxos, create_lots_of_big_transactions, gen_return_txouts\n+from test_framework.util import assert_equal, assert_greater_than, assert_raises_rpc_error, gen_return_txouts\n+from test_framework.wallet import MiniWallet\n+\n \n class MempoolLimitTest(BitcoinTestFramework):\n     def set_test_params(self):\n@@ -20,55 +23,59 @@ def set_test_params(self):\n         ]]\n         self.supports_cli = False\n \n-    def skip_test_if_missing_module(self):\n-        self.skip_if_no_wallet()\n+    def send_large_txs(self, node, miniwallet, txouts, fee_rate, tx_batch_size):\n+        for _ in range(tx_batch_size):\n+            tx = miniwallet.create_self_transfer(from_node=node, fee_rate=fee_rate)['tx']\n+            for txout in txouts:\n+                tx.vout.append(txout)\n+            miniwallet.sendrawtransaction(from_node=node, tx_hex=tx.serialize().hex())\n \n     def run_test(self):\n         txouts = gen_return_txouts()\n-        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n+        node=self.nodes[0]\n+        miniwallet = MiniWallet(node)\n+        relayfee = node.getnetworkinfo()['relayfee']\n+\n+        self.log.info('Check that mempoolminfee is minrelaytxfee')\n+        assert_equal(node.getmempoolinfo()['minrelaytxfee'], Decimal('0.00001000'))\n+        assert_equal(node.getmempoolinfo()['mempoolminfee'], Decimal('0.00001000'))\n \n-        self.log.info('Check that mempoolminfee is minrelytxfee')\n-        assert_equal(self.nodes[0].getmempoolinfo()['minrelaytxfee'], Decimal('0.00001000'))\n-        assert_equal(self.nodes[0].getmempoolinfo()['mempoolminfee'], Decimal('0.00001000'))\n+        tx_batch_size = 25\n+        num_of_batches = 3\n+        # Generate UTXOs to flood the mempool\n+        # 1 to create a tx initially that will be evicted from the mempool later\n+        # 3 batches of multiple transactions with a fee rate much higher than the previous UTXO\n+        # And 1 more to verify that this tx does not get added to the mempool with a fee rate less than the mempoolminfee\n+        self.generate(miniwallet, 1 + (num_of_batches * tx_batch_size) + 1)\n \n-        txids = []\n-        utxos = create_confirmed_utxos(relayfee, self.nodes[0], 91)\n+        # Mine 99 blocks so that the UTXOs are allowed to be spent\n+        self.generate(node, COINBASE_MATURITY - 1)\n \n         self.log.info('Create a mempool tx that will be evicted')\n-        us0 = utxos.pop()\n-        inputs = [{ \"txid\" : us0[\"txid\"], \"vout\" : us0[\"vout\"]}]\n-        outputs = {self.nodes[0].getnewaddress() : 0.0001}\n-        tx = self.nodes[0].createrawtransaction(inputs, outputs)\n-        self.nodes[0].settxfee(relayfee) # specifically fund this tx with low fee\n-        txF = self.nodes[0].fundrawtransaction(tx)\n-        self.nodes[0].settxfee(0) # return to automatic fee selection\n-        txFS = self.nodes[0].signrawtransactionwithwallet(txF['hex'])\n-        txid = self.nodes[0].sendrawtransaction(txFS['hex'])\n-\n-        relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n-        base_fee = relayfee*100\n-        for i in range (3):\n-            txids.append([])\n-            txids[i] = create_lots_of_big_transactions(self.nodes[0], txouts, utxos[30*i:30*i+30], 30, (i+1)*base_fee)\n+        tx_to_be_evicted_id = miniwallet.send_self_transfer(from_node=node, fee_rate=relayfee)[\"txid\"]\n+\n+        # Increase the tx fee rate massively to give the subsequent transactions a higher priority in the mempool\n+        base_fee = relayfee * 1000\n+\n+        self.log.info(\"Fill up the mempool with txs with higher fee rate\")\n+        for batch_of_txid in range(num_of_batches):\n+            fee_rate=(batch_of_txid + 1) * base_fee\n+            self.send_large_txs(node, miniwallet, txouts, fee_rate, tx_batch_size)\n \n         self.log.info('The tx should be evicted by now')\n-        assert txid not in self.nodes[0].getrawmempool()\n-        txdata = self.nodes[0].gettransaction(txid)\n-        assert txdata['confirmations'] ==  0  #confirmation should still be 0\n+        # The number of transactions created should be greater than the ones present in the mempool\n+        assert_greater_than(tx_batch_size * num_of_batches, len(node.getrawmempool()))\n+        # Initial tx created should not be present in the mempool anymore as it had a lower fee rate\n+        assert tx_to_be_evicted_id not in node.getrawmempool()\n \n-        self.log.info('Check that mempoolminfee is larger than minrelytxfee')\n-        assert_equal(self.nodes[0].getmempoolinfo()['minrelaytxfee'], Decimal('0.00001000'))\n-        assert_greater_than(self.nodes[0].getmempoolinfo()['mempoolminfee'], Decimal('0.00001000'))\n+        self.log.info('Check that mempoolminfee is larger than minrelaytxfee')\n+        assert_equal(node.getmempoolinfo()['minrelaytxfee'], Decimal('0.00001000'))\n+        assert_greater_than(node.getmempoolinfo()['mempoolminfee'], Decimal('0.00001000'))\n \n+        # Deliberately try to create a tx with a fee less than the minimum mempool fee to assert that it does not get added to the mempool\n         self.log.info('Create a mempool tx that will not pass mempoolminfee')\n-        us0 = utxos.pop()\n-        inputs = [{ \"txid\" : us0[\"txid\"], \"vout\" : us0[\"vout\"]}]\n-        outputs = {self.nodes[0].getnewaddress() : 0.0001}\n-        tx = self.nodes[0].createrawtransaction(inputs, outputs)\n-        # specifically fund this tx with a fee < mempoolminfee, >= than minrelaytxfee\n-        txF = self.nodes[0].fundrawtransaction(tx, {'feeRate': relayfee})\n-        txFS = self.nodes[0].signrawtransactionwithwallet(txF['hex'])\n-        assert_raises_rpc_error(-26, \"mempool min fee not met\", self.nodes[0].sendrawtransaction, txFS['hex'])\n+        assert_raises_rpc_error(-26, \"mempool min fee not met\", miniwallet.send_self_transfer, from_node=node, fee_rate=relayfee, mempool_valid=False)\n+\n \n if __name__ == '__main__':\n     MempoolLimitTest().main()"
      },
      {
        "sha": "2217628858a0411e8c7a93872a30329ea8badfb9",
        "filename": "test/functional/mempool_package_limits.py",
        "status": "modified",
        "additions": 77,
        "deletions": 7,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_package_limits.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_package_limits.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_package_limits.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -26,6 +26,7 @@\n     bulk_transaction,\n     create_child_with_parents,\n     make_chain,\n+    DEFAULT_FEE,\n )\n \n class MempoolPackageLimitsTest(BitcoinTestFramework):\n@@ -40,7 +41,7 @@ def run_test(self):\n         self.address = node.get_deterministic_priv_key().address\n         self.coins = []\n         # The last 100 coinbase transactions are premature\n-        for b in node.generatetoaddress(200, self.address)[:100]:\n+        for b in self.generatetoaddress(node, 200, self.address)[:100]:\n             coinbase = node.getblock(blockhash=b, verbosity=2)[\"tx\"][0]\n             self.coins.append({\n                 \"txid\": coinbase[\"txid\"],\n@@ -50,6 +51,7 @@ def run_test(self):\n \n         self.test_chain_limits()\n         self.test_desc_count_limits()\n+        self.test_desc_count_limits_2()\n         self.test_anc_count_limits()\n         self.test_anc_count_limits_2()\n         self.test_anc_count_limits_bushy()\n@@ -83,7 +85,7 @@ def test_chain_limits_helper(self, mempool_count, package_count):\n             assert_equal(txres[\"package-error\"], \"package-mempool-limits\")\n \n         # Clear mempool and check that the package passes now\n-        node.generate(1)\n+        self.generate(node, 1)\n         assert all([res[\"allowed\"] for res in node.testmempoolaccept(rawtxs=chain_hex)])\n \n     def test_chain_limits(self):\n@@ -173,6 +175,74 @@ def test_desc_count_limits(self):\n         for txres in testres_too_long:\n             assert_equal(txres[\"package-error\"], \"package-mempool-limits\")\n \n+        # Clear mempool and check that the package passes now\n+        self.generate(node, 1)\n+        assert all([res[\"allowed\"] for res in node.testmempoolaccept(rawtxs=package_hex)])\n+\n+    def test_desc_count_limits_2(self):\n+        \"\"\"Create a Package with 24 transaction in mempool and 2 transaction in package:\n+                      M1\n+                     ^  ^\n+                   M2    ^\n+                   .      ^\n+                  .        ^\n+                 .          ^\n+                M24          ^\n+                              ^\n+                              P1\n+                              ^\n+                              P2\n+        P1 has M1 as a mempool ancestor, P2 has no in-mempool ancestors, but when\n+        combined P2 has M1 as an ancestor and M1 exceeds descendant_limits(23 in-mempool\n+        descendants + 2 in-package descendants, a total of 26 including itself).\n+        \"\"\"\n+\n+        node = self.nodes[0]\n+        package_hex = []\n+        # M1\n+        first_coin_a = self.coins.pop()\n+        parent_value = (first_coin_a[\"amount\"] - DEFAULT_FEE) / 2 # Deduct reasonable fee and make 2 outputs\n+        inputs = [{\"txid\": first_coin_a[\"txid\"], \"vout\": 0}]\n+        outputs = [{self.address : parent_value}, {ADDRESS_BCRT1_P2WSH_OP_TRUE : parent_value}]\n+        rawtx = node.createrawtransaction(inputs, outputs)\n+\n+        parent_signed = node.signrawtransactionwithkey(hexstring=rawtx, privkeys=self.privkeys)\n+        assert parent_signed[\"complete\"]\n+        parent_tx = tx_from_hex(parent_signed[\"hex\"])\n+        parent_txid = parent_tx.rehash()\n+        node.sendrawtransaction(parent_signed[\"hex\"])\n+\n+        # Chain M2...M24\n+        spk = parent_tx.vout[0].scriptPubKey.hex()\n+        value = parent_value\n+        txid = parent_txid\n+        for i in range(23): # M2...M24\n+            (tx, txhex, value, spk) = make_chain(node, self.address, self.privkeys, txid, value, 0, spk)\n+            txid = tx.rehash()\n+            node.sendrawtransaction(txhex)\n+\n+        # P1\n+        value_p1 = (parent_value - DEFAULT_FEE)\n+        rawtx_p1 = node.createrawtransaction([{\"txid\": parent_txid, \"vout\": 1}], [{self.address : value_p1}])\n+        tx_child_p1 = tx_from_hex(rawtx_p1)\n+        tx_child_p1.wit.vtxinwit = [CTxInWitness()]\n+        tx_child_p1.wit.vtxinwit[0].scriptWitness.stack = [CScript([OP_TRUE])]\n+        tx_child_p1_hex = tx_child_p1.serialize().hex()\n+        txid_child_p1 = tx_child_p1.rehash()\n+        package_hex.append(tx_child_p1_hex)\n+        tx_child_p1_spk = tx_child_p1.vout[0].scriptPubKey.hex()\n+\n+        # P2\n+        (_, tx_child_p2_hex, _, _) = make_chain(node, self.address, self.privkeys, txid_child_p1, value_p1, 0, tx_child_p1_spk)\n+        package_hex.append(tx_child_p2_hex)\n+\n+        assert_equal(24, node.getmempoolinfo()[\"size\"])\n+        assert_equal(2, len(package_hex))\n+        testres = node.testmempoolaccept(rawtxs=package_hex)\n+        assert_equal(len(testres), len(package_hex))\n+        for txres in testres:\n+            assert_equal(txres[\"package-error\"], \"package-mempool-limits\")\n+\n         # Clear mempool and check that the package passes now\n         node.generate(1)\n         assert all([res[\"allowed\"] for res in node.testmempoolaccept(rawtxs=package_hex)])\n@@ -230,7 +300,7 @@ def test_anc_count_limits(self):\n             assert_equal(txres[\"package-error\"], \"package-mempool-limits\")\n \n         # Clear mempool and check that the package passes now\n-        node.generate(1)\n+        self.generate(node, 1)\n         assert all([res[\"allowed\"] for res in node.testmempoolaccept(rawtxs=package_hex)])\n \n     def test_anc_count_limits_2(self):\n@@ -288,7 +358,7 @@ def test_anc_count_limits_2(self):\n             assert_equal(txres[\"package-error\"], \"package-mempool-limits\")\n \n         # Clear mempool and check that the package passes now\n-        node.generate(1)\n+        self.generate(node, 1)\n         assert all([res[\"allowed\"] for res in node.testmempoolaccept(rawtxs=[pc_hex, pd_hex])])\n \n     def test_anc_count_limits_bushy(self):\n@@ -338,7 +408,7 @@ def test_anc_count_limits_bushy(self):\n             assert_equal(txres[\"package-error\"], \"package-mempool-limits\")\n \n         # Clear mempool and check that the package passes now\n-        node.generate(1)\n+        self.generate(node, 1)\n         assert all([res[\"allowed\"] for res in node.testmempoolaccept(rawtxs=package_hex)])\n \n     def test_anc_size_limits(self):\n@@ -397,7 +467,7 @@ def test_anc_size_limits(self):\n             assert_equal(txres[\"package-error\"], \"package-mempool-limits\")\n \n         # Clear mempool and check that the package passes now\n-        node.generate(1)\n+        self.generate(node, 1)\n         assert all([res[\"allowed\"] for res in node.testmempoolaccept(rawtxs=[pc_hex, pd_hex])])\n \n     def test_desc_size_limits(self):\n@@ -468,7 +538,7 @@ def test_desc_size_limits(self):\n             assert_equal(txres[\"package-error\"], \"package-mempool-limits\")\n \n         # Clear mempool and check that the package passes now\n-        node.generate(1)\n+        self.generate(node, 1)\n         assert all([res[\"allowed\"] for res in node.testmempoolaccept(rawtxs=package_hex)])\n \n if __name__ == \"__main__\":"
      },
      {
        "sha": "69c21f32bc9441c5b4477d1ac2e7a7cf976e4b44",
        "filename": "test/functional/mempool_package_onemore.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_package_onemore.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_package_onemore.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_package_onemore.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -30,7 +30,7 @@ def skip_test_if_missing_module(self):\n \n     def run_test(self):\n         # Mine some blocks and have them mature.\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n         utxo = self.nodes[0].listunspent(10)\n         txid = utxo[0]['txid']\n         vout = utxo[0]['vout']"
      },
      {
        "sha": "b9344ad6da1a6ee1570e9bbaaf4014c59e074d75",
        "filename": "test/functional/mempool_packages.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_packages.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -46,7 +46,7 @@ def skip_test_if_missing_module(self):\n     def run_test(self):\n         # Mine some blocks and have them mature.\n         peer_inv_store = self.nodes[0].add_p2p_connection(P2PTxInvStore()) # keep track of invs\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n         utxo = self.nodes[0].listunspent(10)\n         txid = utxo[0]['txid']\n         vout = utxo[0]['vout']\n@@ -179,7 +179,7 @@ def run_test(self):\n \n         # Check that prioritising a tx before it's added to the mempool works\n         # First clear the mempool by mining a block.\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n         # Prioritise a transaction that has been mined, then add it back to the\n@@ -270,7 +270,7 @@ def run_test(self):\n \n         # Test reorg handling\n         # First, the basics:\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n         self.nodes[1].invalidateblock(self.nodes[0].getbestblockhash())\n         self.nodes[1].reconsiderblock(self.nodes[0].getbestblockhash())\n@@ -317,7 +317,7 @@ def run_test(self):\n             value = sent_value\n \n         # Mine these in a block\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # Now generate tx8, with a big fee"
      },
      {
        "sha": "56f7cbe6a53099a5f4e47c7299a640df520c4cc5",
        "filename": "test/functional/mempool_persist.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_persist.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_persist.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_persist.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -160,7 +160,7 @@ def test_persist_unbroadcast(self):\n         self.start_node(0)\n \n         # clear out mempool\n-        node0.generate(1)\n+        self.generate(node0, 1)\n \n         # ensure node0 doesn't have any connections\n         # make a transaction that will remain in the unbroadcast set"
      },
      {
        "sha": "0ee6af62f61ae344344c0472c99e9c29ed069d29",
        "filename": "test/functional/mempool_reorg.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_reorg.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_reorg.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_reorg.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -65,7 +65,7 @@ def run_test(self):\n         wallet.sendrawtransaction(from_node=self.nodes[0], tx_hex=spend_2['hex'])\n         wallet.sendrawtransaction(from_node=self.nodes[0], tx_hex=spend_3['hex'])\n         self.log.info(\"Generate a block\")\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.log.info(\"Check that time-locked transaction is still too immature to spend\")\n         assert_raises_rpc_error(-26, 'non-final', self.nodes[0].sendrawtransaction, timelock_tx)\n \n@@ -78,7 +78,7 @@ def run_test(self):\n         self.log.info(\"Broadcast and mine spend_3_1\")\n         spend_3_1_id = self.nodes[0].sendrawtransaction(spend_3_1['hex'])\n         self.log.info(\"Generate a block\")\n-        last_block = self.nodes[0].generate(1)\n+        last_block = self.generate(self.nodes[0], 1)\n         # Sync blocks, so that peer 1 gets the block before timelock_tx\n         # Otherwise, peer 1 would put the timelock_tx in m_recent_rejects\n         self.sync_all()"
      },
      {
        "sha": "4fce07dad3d7dd2badbdd5e556fbb2870cea2fc9",
        "filename": "test/functional/mempool_resurrect.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_resurrect.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_resurrect.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_resurrect.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -20,8 +20,8 @@ def run_test(self):\n         wallet = MiniWallet(node)\n \n         # Add enough mature utxos to the wallet so that all txs spend confirmed coins\n-        wallet.generate(3)\n-        node.generate(COINBASE_MATURITY)\n+        self.generate(wallet, 3)\n+        self.generate(node, COINBASE_MATURITY)\n \n         # Spend block 1/2/3's coinbase transactions\n         # Mine a block\n@@ -34,9 +34,9 @@ def run_test(self):\n         # ... make sure all the transactions are confirmed again\n         blocks = []\n         spends1_ids = [wallet.send_self_transfer(from_node=node)['txid'] for _ in range(3)]\n-        blocks.extend(node.generate(1))\n+        blocks.extend(self.generate(node, 1))\n         spends2_ids = [wallet.send_self_transfer(from_node=node)['txid'] for _ in range(3)]\n-        blocks.extend(node.generate(1))\n+        blocks.extend(self.generate(node, 1))\n \n         spends_ids = set(spends1_ids + spends2_ids)\n \n@@ -53,7 +53,7 @@ def run_test(self):\n         assert_equal(set(node.getrawmempool()), spends_ids)\n \n         # Generate another block, they should all get mined\n-        blocks = node.generate(1)\n+        blocks = self.generate(node, 1)\n         # mempool should be empty, all txns confirmed\n         assert_equal(set(node.getrawmempool()), set())\n         confirmed_txns = set(node.getblock(blocks[0])['tx'])"
      },
      {
        "sha": "e97595ed867ab8379b8863890f112d8eca189713",
        "filename": "test/functional/mempool_spend_coinbase.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_spend_coinbase.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_spend_coinbase.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_spend_coinbase.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -49,7 +49,7 @@ def run_test(self):\n         assert_equal(self.nodes[0].getrawmempool(), [spend_mature_id])\n \n         # mine a block, mature one should get confirmed\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert_equal(set(self.nodes[0].getrawmempool()), set())\n \n         # ... and now previously immature can be spent:"
      },
      {
        "sha": "4d6379fe8644ff5dc325c59fe1765fd7afed7d52",
        "filename": "test/functional/mempool_unbroadcast.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_unbroadcast.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_unbroadcast.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_unbroadcast.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -32,7 +32,7 @@ def test_broadcast(self):\n         node = self.nodes[0]\n \n         min_relay_fee = node.getnetworkinfo()[\"relayfee\"]\n-        utxos = create_confirmed_utxos(min_relay_fee, node, 10)\n+        utxos = create_confirmed_utxos(self, min_relay_fee, node, 10)\n \n         self.disconnect_nodes(0, 1)\n \n@@ -109,7 +109,7 @@ def test_txn_removal(self):\n         # a block\n         removal_reason = \"Removed {} from set of unbroadcast txns before confirmation that txn was sent out\".format(txhsh)\n         with node.assert_debug_log([removal_reason]):\n-            node.generate(1)\n+            self.generate(node, 1)\n \n if __name__ == \"__main__\":\n     MempoolUnbroadcastTest().main()"
      },
      {
        "sha": "22f136d1a5c33007ea908b9cefcc6400a30a7dfa",
        "filename": "test/functional/mempool_updatefromblock.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_updatefromblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mempool_updatefromblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mempool_updatefromblock.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -91,7 +91,7 @@ def transaction_graph_test(self, size, n_tx_to_mine=None, start_input_txid='', e\n             if tx_count in n_tx_to_mine:\n                 # The created transactions are mined into blocks by batches.\n                 self.log.info('The batch of {} transactions has been accepted into the mempool.'.format(len(self.nodes[0].getrawmempool())))\n-                block_hash = self.nodes[0].generate(1)[0]\n+                block_hash = self.generate(self.nodes[0], 1)[0]\n                 if not first_block_hash:\n                     first_block_hash = block_hash\n                 assert_equal(len(self.nodes[0].getrawmempool()), 0)"
      },
      {
        "sha": "f141d201ebc74d64dfc9690d481f7c199ff68c50",
        "filename": "test/functional/mining_basic.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mining_basic.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mining_basic.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_basic.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -58,7 +58,7 @@ def mine_chain(self):\n         self.log.info('Create some old blocks')\n         for t in range(TIME_GENESIS_BLOCK, TIME_GENESIS_BLOCK + 200 * 600, 600):\n             self.nodes[0].setmocktime(t)\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n         mining_info = self.nodes[0].getmininginfo()\n         assert_equal(mining_info['blocks'], 200)\n         assert_equal(mining_info['currentblocktx'], 0)\n@@ -109,7 +109,7 @@ def assert_submitblock(block, result_str_1, result_str_2=None):\n         assert_equal(witness_commitment, script.hex())\n \n         # Mine a block to leave initial block download and clear the mempool\n-        node.generatetoaddress(1, node.get_deterministic_priv_key().address)\n+        self.generatetoaddress(node, 1, node.get_deterministic_priv_key().address)\n         tmpl = node.getblocktemplate(NORMAL_GBT_REQUEST_PARAMS)\n         self.log.info(\"getblocktemplate: Test capability advertised\")\n         assert 'proposal' in tmpl['capabilities']\n@@ -271,7 +271,7 @@ def chain_tip(b_hash, *, status='headers-only', branchlen=1):\n         assert chain_tip(block.hash, status='active', branchlen=0) in node.getchaintips()\n \n         # Building a few blocks should give the same results\n-        node.generatetoaddress(10, node.get_deterministic_priv_key().address)\n+        self.generatetoaddress(node, 10, node.get_deterministic_priv_key().address)\n         assert_raises_rpc_error(-25, 'time-too-old', lambda: node.submitheader(hexdata=CBlockHeader(bad_block_time).serialize().hex()))\n         assert_raises_rpc_error(-25, 'bad-prevblk', lambda: node.submitheader(hexdata=CBlockHeader(bad_block2).serialize().hex()))\n         node.submitheader(hexdata=CBlockHeader(block).serialize().hex())"
      },
      {
        "sha": "0879fb9f2df1e47beaaa4988092a8c0636c53402",
        "filename": "test/functional/mining_getblocktemplate_longpoll.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mining_getblocktemplate_longpoll.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mining_getblocktemplate_longpoll.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_getblocktemplate_longpoll.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -35,7 +35,7 @@ def set_test_params(self):\n     def run_test(self):\n         self.log.info(\"Warning: this test will take about 70 seconds in the best case. Be patient.\")\n         self.log.info(\"Test that longpollid doesn't change between successive getblocktemplate() invocations if nothing else happens\")\n-        self.nodes[0].generate(10)\n+        self.generate(self.nodes[0], 10)\n         template = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n         longpollid = template['longpollid']\n         template2 = self.nodes[0].getblocktemplate({'rules': ['segwit']})\n@@ -48,22 +48,22 @@ def run_test(self):\n         thr.join(5)  # wait 5 seconds or until thread exits\n         assert thr.is_alive()\n \n-        miniwallets = [ MiniWallet(node) for node in self.nodes ]\n+        miniwallets = [MiniWallet(node) for node in self.nodes]\n         self.log.info(\"Test that longpoll will terminate if another node generates a block\")\n-        miniwallets[1].generate(1)  # generate a block on another node\n+        self.generate(miniwallets[1], 1)  # generate a block on another node\n         # check that thread will exit now that new transaction entered mempool\n         thr.join(5)  # wait 5 seconds or until thread exits\n         assert not thr.is_alive()\n \n         self.log.info(\"Test that longpoll will terminate if we generate a block ourselves\")\n         thr = LongpollThread(self.nodes[0])\n         thr.start()\n-        miniwallets[0].generate(1)  # generate a block on own node\n+        self.generate(miniwallets[0], 1)  # generate a block on own node\n         thr.join(5)  # wait 5 seconds or until thread exits\n         assert not thr.is_alive()\n \n         # Add enough mature utxos to the wallets, so that all txs spend confirmed coins\n-        self.nodes[0].generate(COINBASE_MATURITY)\n+        self.generate(self.nodes[0], COINBASE_MATURITY)\n         self.sync_blocks()\n \n         self.log.info(\"Test that introducing a new transaction into the mempool will terminate the longpoll\")"
      },
      {
        "sha": "da85ee54be055f6a39d1a0ed186d5f3e6ec73ee4",
        "filename": "test/functional/mining_prioritisetransaction.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mining_prioritisetransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/mining_prioritisetransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/mining_prioritisetransaction.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -48,7 +48,7 @@ def run_test(self):\n         self.relayfee = self.nodes[0].getnetworkinfo()['relayfee']\n \n         utxo_count = 90\n-        utxos = create_confirmed_utxos(self.relayfee, self.nodes[0], utxo_count)\n+        utxos = create_confirmed_utxos(self, self.relayfee, self.nodes[0], utxo_count)\n         base_fee = self.relayfee*100 # our transactions are smaller than 100kb\n         txids = []\n \n@@ -75,7 +75,7 @@ def run_test(self):\n         # also check that a different entry in the cheapest bucket is NOT mined\n         self.nodes[0].prioritisetransaction(txid=txids[0][0], fee_delta=int(3*base_fee*COIN))\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         mempool = self.nodes[0].getrawmempool()\n         self.log.info(\"Assert that prioritised transaction was mined\")\n@@ -105,7 +105,7 @@ def run_test(self):\n         # the other high fee transactions. Keep mining until our mempool has\n         # decreased by all the high fee size that we calculated above.\n         while (self.nodes[0].getmempoolinfo()['bytes'] > sizes[0] + sizes[1]):\n-            self.nodes[0].generate(1)\n+            self.generate(self.nodes[0], 1)\n \n         # High fee transaction should not have been mined, but other high fee rate\n         # transactions should have been."
      },
      {
        "sha": "3a4fcc4549192e5a26d8a96993829bcb84b5ed98",
        "filename": "test/functional/p2p_blockfilters.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_blockfilters.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_blockfilters.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_blockfilters.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -56,17 +56,17 @@ def run_test(self):\n         peer_1 = self.nodes[1].add_p2p_connection(FiltersClient())\n \n         # Nodes 0 & 1 share the same first 999 blocks in the chain.\n-        self.nodes[0].generate(999)\n+        self.generate(self.nodes[0], 999)\n         self.sync_blocks(timeout=600)\n \n         # Stale blocks by disconnecting nodes 0 & 1, mining, then reconnecting\n         self.disconnect_nodes(0, 1)\n \n-        stale_block_hash = self.nodes[0].generate(1)[0]\n+        stale_block_hash = self.generate(self.nodes[0], 1)[0]\n         self.nodes[0].syncwithvalidationinterfacequeue()\n         assert_equal(self.nodes[0].getblockcount(), 1000)\n \n-        self.nodes[1].generate(1001)\n+        self.generate(self.nodes[1], 1001)\n         assert_equal(self.nodes[1].getblockcount(), 2000)\n \n         # Check that nodes have signalled NODE_COMPACT_FILTERS correctly."
      },
      {
        "sha": "94ae758d461d5701bd6eed8bef5f06c5d4d22a0b",
        "filename": "test/functional/p2p_blocksonly.py",
        "status": "modified",
        "additions": 14,
        "deletions": 12,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_blocksonly.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_blocksonly.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_blocksonly.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -6,8 +6,7 @@\n \n import time\n \n-from test_framework.blocktools import COINBASE_MATURITY\n-from test_framework.messages import msg_tx\n+from test_framework.messages import msg_tx, msg_inv, CInv, MSG_WTX\n from test_framework.p2p import P2PInterface, P2PTxInvStore\n from test_framework.test_framework import BitcoinTestFramework\n from test_framework.util import assert_equal\n@@ -16,15 +15,13 @@\n \n class P2PBlocksOnly(BitcoinTestFramework):\n     def set_test_params(self):\n-        self.setup_clean_chain = True\n         self.num_nodes = 1\n         self.extra_args = [[\"-blocksonly\"]]\n \n     def run_test(self):\n         self.miniwallet = MiniWallet(self.nodes[0])\n         # Add enough mature utxos to the wallet, so that all txs spend confirmed coins\n-        self.miniwallet.generate(2)\n-        self.nodes[0].generate(COINBASE_MATURITY)\n+        self.miniwallet.rescan_utxos()\n \n         self.blocksonly_mode_tests()\n         self.blocks_relay_conn_tests()\n@@ -36,12 +33,19 @@ def blocksonly_mode_tests(self):\n         self.nodes[0].add_p2p_connection(P2PInterface())\n         tx, txid, wtxid, tx_hex = self.check_p2p_tx_violation()\n \n+        self.log.info('Check that tx invs also violate the protocol')\n+        self.nodes[0].add_p2p_connection(P2PInterface())\n+        with self.nodes[0].assert_debug_log(['transaction (0000000000000000000000000000000000000000000000000000000000001234) inv sent in violation of protocol, disconnecting peer']):\n+            self.nodes[0].p2ps[0].send_message(msg_inv([CInv(t=MSG_WTX, h=0x1234)]))\n+            self.nodes[0].p2ps[0].wait_for_disconnect()\n+            del self.nodes[0].p2ps[0]\n+\n         self.log.info('Check that txs from rpc are not rejected and relayed to other peers')\n         tx_relay_peer = self.nodes[0].add_p2p_connection(P2PInterface())\n         assert_equal(self.nodes[0].getpeerinfo()[0]['relaytxes'], True)\n \n         assert_equal(self.nodes[0].testmempoolaccept([tx_hex])[0]['allowed'], True)\n-        with self.nodes[0].assert_debug_log(['received getdata for: wtx {} peer=1'.format(wtxid)]):\n+        with self.nodes[0].assert_debug_log(['received getdata for: wtx {} peer'.format(wtxid)]):\n             self.nodes[0].sendrawtransaction(tx_hex)\n             tx_relay_peer.wait_for_tx(txid)\n             assert_equal(self.nodes[0].getmempoolinfo()['size'], 1)\n@@ -73,7 +77,7 @@ def blocksonly_mode_tests(self):\n         self.log.info(\"Relay-permission peer's transaction is accepted and relayed\")\n \n         self.nodes[0].disconnect_p2ps()\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n     def blocks_relay_conn_tests(self):\n         self.log.info('Tests with node in normal mode with block-relay-only connections')\n@@ -83,7 +87,7 @@ def blocks_relay_conn_tests(self):\n         # Ensure we disconnect if a block-relay-only connection sends us a transaction\n         self.nodes[0].add_outbound_p2p_connection(P2PInterface(), p2p_idx=0, connection_type=\"block-relay-only\")\n         assert_equal(self.nodes[0].getpeerinfo()[0]['relaytxes'], False)\n-        _, txid, _, tx_hex = self.check_p2p_tx_violation(index=2)\n+        _, txid, _, tx_hex = self.check_p2p_tx_violation()\n \n         self.log.info(\"Check that txs from RPC are not sent to blockrelay connection\")\n         conn = self.nodes[0].add_outbound_p2p_connection(P2PTxInvStore(), p2p_idx=1, connection_type=\"block-relay-only\")\n@@ -96,11 +100,9 @@ def blocks_relay_conn_tests(self):\n         conn.sync_send_with_ping()\n         assert(int(txid, 16) not in conn.get_invs())\n \n-    def check_p2p_tx_violation(self, index=1):\n+    def check_p2p_tx_violation(self):\n         self.log.info('Check that txs from P2P are rejected and result in disconnect')\n-        input_txid = self.nodes[0].getblock(self.nodes[0].getblockhash(index), 2)['tx'][0]['txid']\n-        utxo_to_spend = self.miniwallet.get_utxo(txid=input_txid)\n-        spendtx = self.miniwallet.create_self_transfer(from_node=self.nodes[0], utxo_to_spend=utxo_to_spend)\n+        spendtx = self.miniwallet.create_self_transfer(from_node=self.nodes[0])\n \n         with self.nodes[0].assert_debug_log(['transaction sent in violation of protocol peer=0']):\n             self.nodes[0].p2ps[0].send_message(msg_tx(spendtx['tx']))"
      },
      {
        "sha": "3f01d552b29137251cc2a3b6aec312f0f72bb73b",
        "filename": "test/functional/p2p_compactblocks.py",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_compactblocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_compactblocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -165,7 +165,7 @@ def make_utxos(self):\n         block = self.build_block_on_tip(self.nodes[0])\n         self.segwit_node.send_and_ping(msg_no_witness_block(block))\n         assert int(self.nodes[0].getbestblockhash(), 16) == block.sha256\n-        self.nodes[0].generatetoaddress(COINBASE_MATURITY, self.nodes[0].getnewaddress(address_type=\"bech32\"))\n+        self.generatetoaddress(self.nodes[0], COINBASE_MATURITY, self.nodes[0].getnewaddress(address_type=\"bech32\"))\n \n         total_value = block.vtx[0].vout[0].nValue\n         out_value = total_value // 10\n@@ -212,7 +212,7 @@ def received_sendcmpct():\n \n         def check_announcement_of_new_block(node, peer, predicate):\n             peer.clear_block_announcement()\n-            block_hash = int(node.generate(1)[0], 16)\n+            block_hash = int(self.generate(node, 1)[0], 16)\n             peer.wait_for_block_announcement(block_hash, timeout=30)\n             assert peer.block_announced\n \n@@ -276,7 +276,7 @@ def check_announcement_of_new_block(node, peer, predicate):\n \n     # This test actually causes bitcoind to (reasonably!) disconnect us, so do this last.\n     def test_invalid_cmpctblock_message(self):\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n         block = self.build_block_on_tip(self.nodes[0])\n \n         cmpct_block = P2PHeaderAndShortIDs()\n@@ -294,7 +294,7 @@ def test_compactblock_construction(self, test_node, use_witness_address=True):\n         version = test_node.cmpct_version\n         node = self.nodes[0]\n         # Generate a bunch of transactions.\n-        node.generate(COINBASE_MATURITY + 1)\n+        self.generate(node, COINBASE_MATURITY + 1)\n         num_transactions = 25\n         address = node.getnewaddress()\n \n@@ -318,7 +318,7 @@ def test_compactblock_construction(self, test_node, use_witness_address=True):\n \n         # Now mine a block, and look at the resulting compact block.\n         test_node.clear_block_announcement()\n-        block_hash = int(node.generate(1)[0], 16)\n+        block_hash = int(self.generate(node, 1)[0], 16)\n \n         # Store the raw block in our internal format.\n         block = from_hex(CBlock(), node.getblock(\"%064x\" % block_hash, False))\n@@ -660,15 +660,15 @@ def test_compactblocks_not_at_tip(self, test_node):\n         new_blocks = []\n         for _ in range(MAX_CMPCTBLOCK_DEPTH + 1):\n             test_node.clear_block_announcement()\n-            new_blocks.append(node.generate(1)[0])\n+            new_blocks.append(self.generate(node, 1)[0])\n             test_node.wait_until(test_node.received_block_announcement, timeout=30)\n \n         test_node.clear_block_announcement()\n         test_node.send_message(msg_getdata([CInv(MSG_CMPCT_BLOCK, int(new_blocks[0], 16))]))\n         test_node.wait_until(lambda: \"cmpctblock\" in test_node.last_message, timeout=30)\n \n         test_node.clear_block_announcement()\n-        node.generate(1)\n+        self.generate(node, 1)\n         test_node.wait_until(test_node.received_block_announcement, timeout=30)\n         test_node.clear_block_announcement()\n         with p2p_lock:\n@@ -844,7 +844,7 @@ def assert_highbandwidth_states(node, hb_to, hb_from):\n \n     def run_test(self):\n         # Get the nodes out of IBD\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         # Setup the p2p connections\n         self.segwit_node = self.nodes[0].add_p2p_connection(TestP2PConn(cmpct_version=2))"
      },
      {
        "sha": "72b3897b4f81c151701251e956064d4ae5791a56",
        "filename": "test/functional/p2p_compactblocks_hb.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_compactblocks_hb.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_compactblocks_hb.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_compactblocks_hb.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -30,7 +30,7 @@ def setup_network(self):\n     def relay_block_through(self, peer):\n         \"\"\"Relay a new block through peer peer, and return HB status between 1 and [2,3,4,5].\"\"\"\n         self.connect_nodes(peer, 0)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n         self.disconnect_nodes(peer, 0)\n         status_to = [self.peer_info(1, i)['bip152_hb_to'] for i in range(2, 6)]\n@@ -44,7 +44,7 @@ def run_test(self):\n         # Connect everyone to node 0, and mine some blocks to get all nodes out of IBD.\n         for i in range(1, 6):\n             self.connect_nodes(i, 0)\n-        self.nodes[0].generate(2)\n+        self.generate(self.nodes[0], 2)\n         self.sync_blocks()\n         for i in range(1, 6):\n             self.disconnect_nodes(i, 0)"
      },
      {
        "sha": "4ccc94216427dffba515d9c71cdb5d24cba26d0d",
        "filename": "test/functional/p2p_eviction.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_eviction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_eviction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_eviction.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -53,7 +53,7 @@ def run_test(self):\n         protected_peers = set()  # peers that we expect to be protected from eviction\n         current_peer = -1\n         node = self.nodes[0]\n-        node.generatetoaddress(COINBASE_MATURITY + 1, node.get_deterministic_priv_key().address)\n+        self.generatetoaddress(node, COINBASE_MATURITY + 1, node.get_deterministic_priv_key().address)\n \n         self.log.info(\"Create 4 peers and protect them from eviction by sending us a block\")\n         for _ in range(4):"
      },
      {
        "sha": "60adc2c7fa15ccdf5a09ca42887ee9fbc89f2571",
        "filename": "test/functional/p2p_feefilter.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_feefilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_feefilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_feefilter.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -81,8 +81,8 @@ def test_feefilter(self):\n         node0 = self.nodes[0]\n         miniwallet = MiniWallet(node1)\n         # Add enough mature utxos to the wallet, so that all txs spend confirmed coins\n-        miniwallet.generate(5)\n-        node1.generate(COINBASE_MATURITY)\n+        self.generate(miniwallet, 5)\n+        self.generate(node1, COINBASE_MATURITY)\n \n         conn = self.nodes[0].add_p2p_connection(TestP2PConn())\n "
      },
      {
        "sha": "a040665fbac5bf0593dfae0f95ae64fd9a4a4764",
        "filename": "test/functional/p2p_filter.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_filter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_filter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_filter.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -149,7 +149,7 @@ def test_frelay_false(self, filter_peer):\n         assert not filter_peer.tx_received\n \n         # Clear the mempool so that this transaction does not impact subsequent tests\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n     def test_filter(self, filter_peer):\n         # Set the bloomfilter using filterload\n@@ -159,14 +159,14 @@ def test_filter(self, filter_peer):\n         filter_address = self.nodes[0].decodescript(filter_peer.watch_script_pubkey)['address']\n \n         self.log.info('Check that we receive merkleblock and tx if the filter matches a tx in a block')\n-        block_hash = self.nodes[0].generatetoaddress(1, filter_address)[0]\n+        block_hash = self.generatetoaddress(self.nodes[0], 1, filter_address)[0]\n         txid = self.nodes[0].getblock(block_hash)['tx'][0]\n         filter_peer.wait_for_merkleblock(block_hash)\n         filter_peer.wait_for_tx(txid)\n \n         self.log.info('Check that we only receive a merkleblock if the filter does not match a tx in a block')\n         filter_peer.tx_received = False\n-        block_hash = self.nodes[0].generatetoaddress(1, self.nodes[0].getnewaddress())[0]\n+        block_hash = self.generatetoaddress(self.nodes[0], 1, self.nodes[0].getnewaddress())[0]\n         filter_peer.wait_for_merkleblock(block_hash)\n         assert not filter_peer.tx_received\n \n@@ -194,7 +194,7 @@ def test_filter(self, filter_peer):\n         filter_peer.merkleblock_received = False\n         filter_peer.tx_received = False\n         with self.nodes[0].assert_debug_log(expected_msgs=['received getdata']):\n-            block_hash = self.nodes[0].generatetoaddress(1, self.nodes[0].getnewaddress())[0]\n+            block_hash = self.generatetoaddress(self.nodes[0], 1, self.nodes[0].getnewaddress())[0]\n             filter_peer.wait_for_inv([CInv(MSG_BLOCK, int(block_hash, 16))])\n             filter_peer.sync_with_ping()\n             assert not filter_peer.merkleblock_received"
      },
      {
        "sha": "2962dc8085526b1450d676de7c16a521463fb463",
        "filename": "test/functional/p2p_fingerprint.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_fingerprint.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_fingerprint.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_fingerprint.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -69,7 +69,7 @@ def run_test(self):\n         self.nodes[0].setmocktime(int(time.time()) - 60 * 24 * 60 * 60)\n \n         # Generating a chain of 10 blocks\n-        block_hashes = self.nodes[0].generatetoaddress(10, self.nodes[0].get_deterministic_priv_key().address)\n+        block_hashes = self.generatetoaddress(self.nodes[0], 10, self.nodes[0].get_deterministic_priv_key().address)\n \n         # Create longer chain starting 2 blocks before current tip\n         height = len(block_hashes) - 2\n@@ -98,7 +98,7 @@ def run_test(self):\n \n         # Longest chain is extended so stale is much older than chain tip\n         self.nodes[0].setmocktime(0)\n-        block_hash = int(self.nodes[0].generatetoaddress(1, self.nodes[0].get_deterministic_priv_key().address)[-1], 16)\n+        block_hash = int(self.generatetoaddress(self.nodes[0], 1, self.nodes[0].get_deterministic_priv_key().address)[-1], 16)\n         assert_equal(self.nodes[0].getblockcount(), 14)\n         node0.wait_for_block(block_hash, timeout=3)\n "
      },
      {
        "sha": "c35053d9d4571a70d34185c84958c980da789eb0",
        "filename": "test/functional/p2p_ibd_txrelay.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_ibd_txrelay.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_ibd_txrelay.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_ibd_txrelay.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -29,7 +29,7 @@ def run_test(self):\n             self.wait_until(lambda: all(peer['minfeefilter'] == MAX_FEE_FILTER for peer in node.getpeerinfo()))\n \n         # Come out of IBD by generating a block\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         self.log.info(\"Check that nodes reset minfilter after coming out of IBD\")"
      },
      {
        "sha": "875ab52db42b14f04e942df86cb8ba13992b1e25",
        "filename": "test/functional/p2p_invalid_block.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_invalid_block.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_invalid_block.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_block.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -51,7 +51,7 @@ def run_test(self):\n         peer.send_blocks_and_test([block1], node, success=True)\n \n         self.log.info(\"Mature the block.\")\n-        node.generatetoaddress(100, node.get_deterministic_priv_key().address)\n+        self.generatetoaddress(node, 100, node.get_deterministic_priv_key().address)\n \n         best_block = node.getblock(node.getbestblockhash())\n         tip = int(node.getbestblockhash(), 16)"
      },
      {
        "sha": "a586b48d4c00bec10137a53959510eae05631384",
        "filename": "test/functional/p2p_invalid_locator.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_invalid_locator.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_invalid_locator.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_locator.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -16,7 +16,7 @@ def set_test_params(self):\n \n     def run_test(self):\n         node = self.nodes[0]  # convenience reference to the node\n-        node.generatetoaddress(1, node.get_deterministic_priv_key().address)  # Get node out of IBD\n+        self.generatetoaddress(node, 1, node.get_deterministic_priv_key().address)  # Get node out of IBD\n \n         self.log.info('Test max locator size')\n         block_count = node.getblockcount()"
      },
      {
        "sha": "0a3ae23f5857c872e3b02c91487e5126f4a3ff5d",
        "filename": "test/functional/p2p_invalid_tx.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_invalid_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_invalid_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_invalid_tx.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -64,7 +64,7 @@ def run_test(self):\n         node.p2ps[0].send_blocks_and_test([block], node, success=True)\n \n         self.log.info(\"Mature the block.\")\n-        self.nodes[0].generatetoaddress(100, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], 100, self.nodes[0].get_deterministic_priv_key().address)\n \n         # Iterate through a list of known invalid transaction types, ensuring each is\n         # rejected. Some are consensus invalid and some just violate policy.\n@@ -141,9 +141,9 @@ def run_test(self):\n                 tx_orphan_2_valid,  # The valid transaction (with sufficient fee)\n             ]\n         }\n-        # Transactions that do not end up in the mempool\n-        # tx_orphan_no_fee, because it has too low fee (p2ps[0] is not disconnected for relaying that tx)\n-        # tx_orphan_invalid, because it has negative fee (p2ps[1] is disconnected for relaying that tx)\n+        # Transactions that do not end up in the mempool:\n+        # tx_orphan_2_no_fee, because it has too low fee (p2ps[0] is not disconnected for relaying that tx)\n+        # tx_orphan_2_invalid, because it has negative fee (p2ps[1] is disconnected for relaying that tx)\n \n         self.wait_until(lambda: 1 == len(node.getpeerinfo()), timeout=12)  # p2ps[1] is no longer connected\n         assert_equal(expected_mempool, set(node.getrawmempool()))"
      },
      {
        "sha": "de58e07aad554b22e79f2e5e6ab6e9a1cfb3d244",
        "filename": "test/functional/p2p_leak.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_leak.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_leak.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_leak.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -133,7 +133,7 @@ def run_test(self):\n         pre_wtxidrelay_peer.wait_until(lambda: pre_wtxidrelay_peer.version_received)\n \n         # Mine a block and make sure that it's not sent to the connected peers\n-        self.nodes[0].generate(nblocks=1)\n+        self.generate(self.nodes[0], nblocks=1)\n \n         # Give the node enough time to possibly leak out a message\n         time.sleep(PEER_TIMEOUT + 2)"
      },
      {
        "sha": "9b80e1b87752e6755c8a46c3291c908dc76f740b",
        "filename": "test/functional/p2p_leak_tx.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_leak_tx.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_leak_tx.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_leak_tx.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -27,8 +27,8 @@ def run_test(self):\n         gen_node = self.nodes[0]  # The block and tx generating node\n         miniwallet = MiniWallet(gen_node)\n         # Add enough mature utxos to the wallet, so that all txs spend confirmed coins\n-        miniwallet.generate(1)\n-        gen_node.generate(COINBASE_MATURITY)\n+        self.generate(miniwallet, 1)\n+        self.generate(gen_node, COINBASE_MATURITY)\n \n         inbound_peer = self.nodes[0].add_p2p_connection(P2PNode())  # An \"attacking\" inbound peer\n "
      },
      {
        "sha": "e491fe7e07324505119a79ead3881958c782becd",
        "filename": "test/functional/p2p_node_network_limited.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_node_network_limited.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_node_network_limited.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_node_network_limited.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -59,7 +59,7 @@ def run_test(self):\n \n         self.log.info(\"Mine enough blocks to reach the NODE_NETWORK_LIMITED range.\")\n         self.connect_nodes(0, 1)\n-        blocks = self.nodes[1].generatetoaddress(292, self.nodes[1].get_deterministic_priv_key().address)\n+        blocks = self.generatetoaddress(self.nodes[1], 292, self.nodes[1].get_deterministic_priv_key().address)\n         self.sync_blocks([self.nodes[0], self.nodes[1]])\n \n         self.log.info(\"Make sure we can max retrieve block at tip-288.\")\n@@ -101,7 +101,7 @@ def run_test(self):\n         self.disconnect_all()\n \n         # mine 10 blocks on node 0 (pruned node)\n-        self.nodes[0].generatetoaddress(10, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], 10, self.nodes[0].get_deterministic_priv_key().address)\n \n         # connect node1 (non pruned) with node0 (pruned) and check if the can sync\n         self.connect_nodes(0, 1)"
      },
      {
        "sha": "32f2ea14e19455746a34e34e3eec008358437ea1",
        "filename": "test/functional/p2p_permissions.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_permissions.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_permissions.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_permissions.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -93,7 +93,7 @@ def run_test(self):\n         self.nodes[1].assert_start_raises_init_error([\"-whitebind=noban@127.0.0.1/10\"], \"Cannot resolve -whitebind address\", match=ErrorMatch.PARTIAL_REGEX)\n \n     def check_tx_relay(self):\n-        block_op_true = self.nodes[0].getblock(self.nodes[0].generatetoaddress(100, ADDRESS_BCRT1_P2WSH_OP_TRUE)[0])\n+        block_op_true = self.nodes[0].getblock(self.generatetoaddress(self.nodes[0], 100, ADDRESS_BCRT1_P2WSH_OP_TRUE)[0])\n         self.sync_all()\n \n         self.log.debug(\"Create a connection from a forcerelay peer that rebroadcasts raw txs\")"
      },
      {
        "sha": "a71f736bd6063eacdcdbfe57b84e1c9b37d4a202",
        "filename": "test/functional/p2p_segwit.py",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_segwit.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_segwit.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_segwit.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -303,7 +303,7 @@ def test_non_witness_transaction(self):\n         self.test_node.send_and_ping(msg_no_witness_block(block))  # make sure the block was processed\n         txid = block.vtx[0].sha256\n \n-        self.nodes[0].generate(99)  # let the block mature\n+        self.generate(self.nodes[0], 99)  # let the block mature\n \n         # Create a transaction that spends the coinbase\n         tx = CTransaction()\n@@ -319,7 +319,7 @@ def test_non_witness_transaction(self):\n         assert tx.hash in self.nodes[0].getrawmempool()\n         # Save this transaction for later\n         self.utxo.append(UTXO(tx.sha256, 0, 49 * 100000000))\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n     @subtest  # type: ignore\n     def test_unnecessary_witness_before_segwit_activation(self):\n@@ -555,7 +555,7 @@ def test_witness_tx_relay_before_segwit_activation(self):\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=False, accepted=True)\n \n         # Cleanup: mine the first transaction and update utxo\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n \n         self.utxo.pop(0)\n@@ -580,7 +580,7 @@ def test_standardness_v0(self):\n \n         # Mine it on test_node to create the confirmed output.\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_tx, with_witness=True, accepted=True)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n \n         # Now test standardness of v0 P2WSH outputs.\n@@ -653,7 +653,7 @@ def test_standardness_v0(self):\n             )\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx3, with_witness=True, accepted=True)\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n         self.utxo.pop(0)\n         self.utxo.append(UTXO(tx3.sha256, 0, tx3.vout[0].nValue))\n@@ -664,9 +664,9 @@ def advance_to_segwit_active(self):\n         \"\"\"Mine enough blocks to activate segwit.\"\"\"\n         assert not softfork_active(self.nodes[0], 'segwit')\n         height = self.nodes[0].getblockcount()\n-        self.nodes[0].generate(SEGWIT_HEIGHT - height - 2)\n+        self.generate(self.nodes[0], SEGWIT_HEIGHT - height - 2)\n         assert not softfork_active(self.nodes[0], 'segwit')\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert softfork_active(self.nodes[0], 'segwit')\n         self.segwit_active = True\n \n@@ -1298,7 +1298,7 @@ def test_tx_relay_after_segwit_activation(self):\n         assert vsize != raw_tx[\"size\"]\n \n         # Cleanup: mine the transactions and update utxo for next test\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n \n         self.utxo.pop(0)\n@@ -1348,7 +1348,7 @@ def test_segwit_versions(self):\n             self.utxo.pop(0)\n             temp_utxo.append(UTXO(tx.sha256, 0, tx.vout[0].nValue))\n \n-        self.nodes[0].generate(1)  # Mine all the transactions\n+        self.generate(self.nodes[0], 1)  # Mine all the transactions\n         self.sync_blocks()\n         assert len(self.nodes[0].getrawmempool()) == 0\n \n@@ -1419,14 +1419,14 @@ def test_premature_coinbase_witness_spend(self):\n         spend_tx.rehash()\n \n         # Now test a premature spend.\n-        self.nodes[0].generate(98)\n+        self.generate(self.nodes[0], 98)\n         self.sync_blocks()\n         block2 = self.build_next_block()\n         self.update_witness_block_with_transactions(block2, [spend_tx])\n         test_witness_block(self.nodes[0], self.test_node, block2, accepted=False)\n \n         # Advancing one more block should allow the spend.\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         block2 = self.build_next_block()\n         self.update_witness_block_with_transactions(block2, [spend_tx])\n         test_witness_block(self.nodes[0], self.test_node, block2, accepted=True)\n@@ -1733,7 +1733,7 @@ def test_non_standard_witness_blinding(self):\n         tx.vout.append(CTxOut(self.utxo[0].nValue - 1000, script_pubkey))\n         tx.rehash()\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx, False, True)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n \n         # We'll add an unnecessary witness to this transaction that would cause\n@@ -1762,7 +1762,7 @@ def test_non_standard_witness_blinding(self):\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx2, False, True)\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx3, False, True)\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n \n         # Update our utxo list; we spent the first entry.\n@@ -1797,7 +1797,7 @@ def test_non_standard_witness(self):\n         txid = tx.sha256\n         test_transaction_acceptance(self.nodes[0], self.test_node, tx, with_witness=False, accepted=True)\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_blocks()\n \n         # Creating transactions for tests\n@@ -1860,7 +1860,7 @@ def test_non_standard_witness(self):\n         test_transaction_acceptance(self.nodes[1], self.std_node, p2sh_txs[3], True, False, 'bad-witness-nonstandard')\n         test_transaction_acceptance(self.nodes[0], self.test_node, p2sh_txs[3], True, True)\n \n-        self.nodes[0].generate(1)  # Mine and clean up the mempool of non-standard node\n+        self.generate(self.nodes[0], 1)  # Mine and clean up the mempool of non-standard node\n         # Valid but non-standard transactions in a block should be accepted by standard node\n         self.sync_blocks()\n         assert_equal(len(self.nodes[0].getrawmempool()), 0)\n@@ -1998,7 +1998,7 @@ def serialize(self):\n                 return serialize_with_bogus_witness(self.tx)\n \n         self.nodes[0].sendtoaddress(self.nodes[0].getnewaddress(address_type='bech32'), 5)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         unspent = next(u for u in self.nodes[0].listunspent() if u['spendable'] and u['address'].startswith('bcrt'))\n \n         raw = self.nodes[0].createrawtransaction([{\"txid\": unspent['txid'], \"vout\": unspent['vout']}], {self.nodes[0].getnewaddress(): 1})"
      },
      {
        "sha": "7bf1803780d8aecb8648fc6b7ab9547a367e2295",
        "filename": "test/functional/p2p_sendheaders.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_sendheaders.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_sendheaders.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_sendheaders.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -205,7 +205,7 @@ def mine_blocks(self, count):\n \n         # Clear out block announcements from each p2p listener\n         [x.clear_block_announcements() for x in self.nodes[0].p2ps]\n-        self.nodes[0].generatetoaddress(count, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], count, self.nodes[0].get_deterministic_priv_key().address)\n         return int(self.nodes[0].getbestblockhash(), 16)\n \n     def mine_reorg(self, length):\n@@ -216,7 +216,7 @@ def mine_reorg(self, length):\n         return the list of block hashes newly mined.\"\"\"\n \n         # make sure all invalidated blocks are node0's\n-        self.nodes[0].generatetoaddress(length, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], length, self.nodes[0].get_deterministic_priv_key().address)\n         self.sync_blocks(self.nodes, wait=0.1)\n         for x in self.nodes[0].p2ps:\n             x.wait_for_block_announcement(int(self.nodes[0].getbestblockhash(), 16))\n@@ -225,7 +225,7 @@ def mine_reorg(self, length):\n         tip_height = self.nodes[1].getblockcount()\n         hash_to_invalidate = self.nodes[1].getblockhash(tip_height - (length - 1))\n         self.nodes[1].invalidateblock(hash_to_invalidate)\n-        all_hashes = self.nodes[1].generatetoaddress(length + 1, self.nodes[1].get_deterministic_priv_key().address)  # Must be longer than the orig chain\n+        all_hashes = self.generatetoaddress(self.nodes[1], length + 1, self.nodes[1].get_deterministic_priv_key().address)  # Must be longer than the orig chain\n         self.sync_blocks(self.nodes, wait=0.1)\n         return [int(x, 16) for x in all_hashes]\n \n@@ -240,7 +240,7 @@ def run_test(self):\n         self.test_nonnull_locators(test_node, inv_node)\n \n     def test_null_locators(self, test_node, inv_node):\n-        tip = self.nodes[0].getblockheader(self.nodes[0].generatetoaddress(1, self.nodes[0].get_deterministic_priv_key().address)[0])\n+        tip = self.nodes[0].getblockheader(self.generatetoaddress(self.nodes[0], 1, self.nodes[0].get_deterministic_priv_key().address)[0])\n         tip_hash = int(tip[\"hash\"], 16)\n \n         inv_node.check_last_inv_announcement(inv=[tip_hash])"
      },
      {
        "sha": "a9d5ed970a9465c2d379459f177ec22293fe15de",
        "filename": "test/functional/p2p_unrequested_blocks.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_unrequested_blocks.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/p2p_unrequested_blocks.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_unrequested_blocks.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -77,7 +77,7 @@ def run_test(self):\n         min_work_node = self.nodes[1].add_p2p_connection(P2PInterface())\n \n         # 1. Have nodes mine a block (leave IBD)\n-        [n.generatetoaddress(1, n.get_deterministic_priv_key().address) for n in self.nodes]\n+        [self.generatetoaddress(n, 1, n.get_deterministic_priv_key().address) for n in self.nodes]\n         tips = [int(\"0x\" + n.getbestblockhash(), 0) for n in self.nodes]\n \n         # 2. Send one block that builds on each tip."
      },
      {
        "sha": "e566fb0aa7a512d5c67edd4b2da2557bb7dbad3e",
        "filename": "test/functional/rpc_addresses_deprecation.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_addresses_deprecation.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_addresses_deprecation.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_addresses_deprecation.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -40,7 +40,7 @@ def test_addresses_deprecation(self):\n         txid = node.sendrawtransaction(hexstring=tx_signed, maxfeerate=0)\n \n         self.log.info(\"Test RPCResult scriptPubKey no longer returns the fields addresses or reqSigs by default\")\n-        hash = node.generateblock(output=node.getnewaddress(), transactions=[txid])['hash']\n+        hash = self.generateblock(node, output=node.getnewaddress(), transactions=[txid])['hash']\n         # Ensure both nodes have the newly generated block on disk.\n         self.sync_blocks()\n         script_pub_key = node.getblock(blockhash=hash, verbose=2)['tx'][-1]['vout'][0]['scriptPubKey']"
      },
      {
        "sha": "e13de4395b63786521b2b3c2cd6cea7febe90a43",
        "filename": "test/functional/rpc_blockchain.py",
        "status": "modified",
        "additions": 6,
        "deletions": 5,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_blockchain.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -27,6 +27,7 @@\n \n from test_framework.address import ADDRESS_BCRT1_P2WSH_OP_TRUE\n from test_framework.blocktools import (\n+    CLTV_HEIGHT,\n     DERSIG_HEIGHT,\n     create_block,\n     create_coinbase,\n@@ -83,7 +84,7 @@ def mine_chain(self):\n         self.log.info(f\"Generate {HEIGHT} blocks after the genesis block in ten-minute steps\")\n         for t in range(TIME_GENESIS_BLOCK, TIME_RANGE_END, TIME_RANGE_STEP):\n             self.nodes[0].setmocktime(t)\n-            self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n+            self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n         assert_equal(self.nodes[0].getblockchaininfo()['blocks'], HEIGHT)\n \n     def _test_getblockchaininfo(self):\n@@ -143,7 +144,7 @@ def _test_getblockchaininfo(self):\n         assert_equal(res['softforks'], {\n             'bip34': {'type': 'buried', 'active': True, 'height': 2},\n             'bip66': {'type': 'buried', 'active': True, 'height': DERSIG_HEIGHT},\n-            'bip65': {'type': 'buried', 'active': False, 'height': 1351},\n+            'bip65': {'type': 'buried', 'active': True, 'height': CLTV_HEIGHT},\n             'csv': {'type': 'buried', 'active': False, 'height': 432},\n             'segwit': {'type': 'buried', 'active': True, 'height': 0},\n             'testdummy': {\n@@ -350,12 +351,12 @@ def _test_getnetworkhashps(self):\n     def _test_stopatheight(self):\n         self.log.info(\"Test stopping at height\")\n         assert_equal(self.nodes[0].getblockcount(), HEIGHT)\n-        self.nodes[0].generatetoaddress(6, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n+        self.generatetoaddress(self.nodes[0], 6, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n         assert_equal(self.nodes[0].getblockcount(), HEIGHT + 6)\n         self.log.debug('Node should not stop at this height')\n         assert_raises(subprocess.TimeoutExpired, lambda: self.nodes[0].process.wait(timeout=3))\n         try:\n-            self.nodes[0].generatetoaddress(1, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n+            self.generatetoaddress(self.nodes[0], 1, ADDRESS_BCRT1_P2WSH_OP_TRUE)\n         except (ConnectionError, http.client.BadStatusLine):\n             pass  # The node already shut down before response\n         self.log.debug('Node should stop at this height...')\n@@ -411,7 +412,7 @@ def _test_getblock(self):\n         fee_per_kb = 1000 * fee_per_byte\n \n         miniwallet.send_self_transfer(fee_rate=fee_per_kb, from_node=node)\n-        blockhash = node.generate(1)[0]\n+        blockhash = self.generate(node, 1)[0]\n \n         self.log.info(\"Test getblock with verbosity 1 doesn't include fee\")\n         block = node.getblock(blockhash, 1)"
      },
      {
        "sha": "696438ccfe3691c31e9f569d15af872208e681c2",
        "filename": "test/functional/rpc_createmultisig.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_createmultisig.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_createmultisig.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_createmultisig.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -45,7 +45,7 @@ def run_test(self):\n         self.check_addmultisigaddress_errors()\n \n         self.log.info('Generating blocks ...')\n-        node0.generate(149)\n+        self.generate(node0, 149)\n         self.sync_all()\n \n         self.moved = 0\n@@ -116,7 +116,7 @@ def check_addmultisigaddress_errors(self):\n \n     def checkbalances(self):\n         node0, node1, node2 = self.nodes\n-        node0.generate(COINBASE_MATURITY)\n+        self.generate(node0, COINBASE_MATURITY)\n         self.sync_all()\n \n         bal0 = node0.getbalance()\n@@ -179,7 +179,7 @@ def do_multisig(self):\n         value = tx[\"vout\"][vout][\"value\"]\n         prevtxs = [{\"txid\": txid, \"vout\": vout, \"scriptPubKey\": scriptPubKey, \"redeemScript\": mredeem, \"amount\": value}]\n \n-        node0.generate(1)\n+        self.generate(node0, 1)\n \n         outval = value - decimal.Decimal(\"0.00001000\")\n         rawtx = node2.createrawtransaction([{\"txid\": txid, \"vout\": vout}], [{self.final: outval}])\n@@ -215,7 +215,7 @@ def do_multisig(self):\n \n         self.moved += outval\n         tx = node0.sendrawtransaction(rawtx3[\"hex\"], 0)\n-        blk = node0.generate(1)[0]\n+        blk = self.generate(node0, 1)[0]\n         assert tx in node0.getblock(blk)[\"tx\"]\n \n         txinfo = node0.getrawtransaction(tx, True, blk)"
      },
      {
        "sha": "fdaed918a16e9e9cdca668a1dc5471ed4abed383",
        "filename": "test/functional/rpc_deprecated.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_deprecated.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_deprecated.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_deprecated.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -21,7 +21,7 @@ def run_test(self):\n         # In run_test:\n         # self.log.info(\"Test generate RPC\")\n         # assert_raises_rpc_error(-32, 'The wallet generate rpc method is deprecated', self.nodes[0].rpc.generate, 1)\n-        # self.nodes[1].generate(1)\n+        # self.generate(self.nodes[1], 1)\n \n         self.log.info(\"No tested deprecated RPC methods\")\n "
      },
      {
        "sha": "89388df5553c2f8761808f97e2798a5e7217c678",
        "filename": "test/functional/rpc_dumptxoutset.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_dumptxoutset.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_dumptxoutset.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_dumptxoutset.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -23,7 +23,7 @@ def run_test(self):\n         node = self.nodes[0]\n         mocktime = node.getblockheader(node.getblockhash(0))['time'] + 1\n         node.setmocktime(mocktime)\n-        node.generate(COINBASE_MATURITY)\n+        self.generate(node, COINBASE_MATURITY)\n \n         FILENAME = 'txoutset.dat'\n         out = node.dumptxoutset(FILENAME)"
      },
      {
        "sha": "56312dc6e56c4b1ae942fb4888f1b8a9af1d7e4e",
        "filename": "test/functional/rpc_fundrawtransaction.py",
        "status": "modified",
        "additions": 16,
        "deletions": 16,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_fundrawtransaction.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_fundrawtransaction.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_fundrawtransaction.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -63,9 +63,9 @@ def run_test(self):\n         #            = 2 bytes * minRelayTxFeePerByte\n         self.fee_tolerance = 2 * self.min_relay_tx_fee / 1000\n \n-        self.nodes[2].generate(1)\n+        self.generate(self.nodes[2], 1)\n         self.sync_all()\n-        self.nodes[0].generate(121)\n+        self.generate(self.nodes[0], 121)\n         self.sync_all()\n \n         self.test_change_position()\n@@ -126,7 +126,7 @@ def test_change_position(self):\n         self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 1.0)\n         self.nodes[0].sendtoaddress(self.nodes[2].getnewaddress(), 5.0)\n \n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         wwatch.unloadwallet()\n@@ -500,7 +500,7 @@ def test_spend_2of2(self):\n \n         # Send 1.2 BTC to msig addr.\n         self.nodes[0].sendtoaddress(mSigObj, 1.2)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         oldBalance = self.nodes[1].getbalance()\n@@ -511,7 +511,7 @@ def test_spend_2of2(self):\n         signed_psbt = w2.walletprocesspsbt(funded_psbt)\n         final_psbt = w2.finalizepsbt(signed_psbt['psbt'])\n         self.nodes[2].sendrawtransaction(final_psbt['hex'])\n-        self.nodes[2].generate(1)\n+        self.generate(self.nodes[2], 1)\n         self.sync_all()\n \n         # Make sure funds are received at node1.\n@@ -543,7 +543,7 @@ def test_locked_wallet(self):\n         self.nodes[1].getnewaddress()\n         self.nodes[1].getrawchangeaddress()\n         inputs = []\n-        outputs = {self.nodes[0].getnewaddress():1.09999500}\n+        outputs = {self.nodes[0].getnewaddress():1.19999500}\n         rawtx = self.nodes[1].createrawtransaction(inputs, outputs)\n         # fund a transaction that does not require a new key for the change output\n         self.nodes[1].fundrawtransaction(rawtx)\n@@ -572,7 +572,7 @@ def test_locked_wallet(self):\n         self.nodes[1].walletpassphrase(\"test\", 600)\n         signedTx = self.nodes[1].signrawtransactionwithwallet(fundedTx['hex'])\n         self.nodes[1].sendrawtransaction(signedTx['hex'])\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         self.sync_all()\n \n         # Make sure funds are received at node1.\n@@ -584,12 +584,12 @@ def test_many_inputs_fee(self):\n \n         # Empty node1, send some small coins from node0 to node1.\n         self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), self.nodes[1].getbalance(), \"\", \"\", True)\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         self.sync_all()\n \n         for _ in range(20):\n             self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.01)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # Fund a tx with ~20 small inputs.\n@@ -612,12 +612,12 @@ def test_many_inputs_send(self):\n \n         # Again, empty node1, send some small coins from node0 to node1.\n         self.nodes[1].sendtoaddress(self.nodes[0].getnewaddress(), self.nodes[1].getbalance(), \"\", \"\", True)\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         self.sync_all()\n \n         for _ in range(20):\n             self.nodes[0].sendtoaddress(self.nodes[1].getnewaddress(), 0.01)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         # Fund a tx with ~20 small inputs.\n@@ -629,7 +629,7 @@ def test_many_inputs_send(self):\n         fundedTx = self.nodes[1].fundrawtransaction(rawtx)\n         fundedAndSignedTx = self.nodes[1].signrawtransactionwithwallet(fundedTx['hex'])\n         self.nodes[1].sendrawtransaction(fundedAndSignedTx['hex'])\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         self.sync_all()\n         assert_equal(oldBalance+Decimal('50.19000000'), self.nodes[0].getbalance()) #0.19+block reward\n \n@@ -707,7 +707,7 @@ def test_all_watched_funds(self):\n         signedtx = self.nodes[0].signrawtransactionwithwallet(signedtx[\"hex\"])\n         assert signedtx[\"complete\"]\n         self.nodes[0].sendrawtransaction(signedtx[\"hex\"])\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         wwatch.unloadwallet()\n@@ -933,7 +933,7 @@ def test_transaction_too_large(self):\n         for _ in range(1500):\n             outputs[recipient.getnewaddress()] = 0.1\n         wallet.sendmany(\"\", outputs)\n-        self.nodes[0].generate(10)\n+        self.generate(self.nodes[0], 10)\n         assert_raises_rpc_error(-4, \"Transaction too large\", recipient.fundrawtransaction, rawtx)\n \n     def test_include_unsafe(self):\n@@ -962,7 +962,7 @@ def test_include_unsafe(self):\n         wallet.sendrawtransaction(signedtx['hex'])\n \n         # And we can also use them once they're confirmed.\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         rawtx = wallet.createrawtransaction([], [{self.nodes[2].getnewaddress(): 3}])\n         fundedtx = wallet.fundrawtransaction(rawtx, {\"include_unsafe\": True})\n         tx_dec = wallet.decoderawtransaction(fundedtx['hex'])\n@@ -993,7 +993,7 @@ def test_22670(self):\n         # than any single input available, and require more than 1 input. So we make 3 outputs\n         for i in range(0, 3):\n             funds.sendtoaddress(tester.getnewaddress(address_type=\"bech32\"), 1)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         # Create transactions in order to calculate fees for the target bounds that can trigger this bug\n         change_tx = tester.fundrawtransaction(tester.createrawtransaction([], [{funds.getnewaddress(): 1.5}]))"
      },
      {
        "sha": "3c6b3fb12562d79fede7abd6cd9f38d7145ae530",
        "filename": "test/functional/rpc_generateblock.py",
        "status": "modified",
        "additions": 13,
        "deletions": 13,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_generateblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_generateblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_generateblock.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -24,43 +24,43 @@ def run_test(self):\n \n         self.log.info('Generate an empty block to address')\n         address = node.getnewaddress()\n-        hash = node.generateblock(output=address, transactions=[])['hash']\n+        hash = self.generateblock(node, output=address, transactions=[])['hash']\n         block = node.getblock(blockhash=hash, verbose=2)\n         assert_equal(len(block['tx']), 1)\n         assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['address'], address)\n \n         self.log.info('Generate an empty block to a descriptor')\n-        hash = node.generateblock('addr(' + address + ')', [])['hash']\n+        hash = self.generateblock(node, 'addr(' + address + ')', [])['hash']\n         block = node.getblock(blockhash=hash, verbosity=2)\n         assert_equal(len(block['tx']), 1)\n         assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['address'], address)\n \n         self.log.info('Generate an empty block to a combo descriptor with compressed pubkey')\n         combo_key = '0279be667ef9dcbbac55a06295ce870b07029bfcdb2dce28d959f2815b16f81798'\n         combo_address = 'bcrt1qw508d6qejxtdg4y5r3zarvary0c5xw7kygt080'\n-        hash = node.generateblock('combo(' + combo_key + ')', [])['hash']\n+        hash = self.generateblock(node, 'combo(' + combo_key + ')', [])['hash']\n         block = node.getblock(hash, 2)\n         assert_equal(len(block['tx']), 1)\n         assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['address'], combo_address)\n \n         self.log.info('Generate an empty block to a combo descriptor with uncompressed pubkey')\n         combo_key = '0408ef68c46d20596cc3f6ddf7c8794f71913add807f1dc55949fa805d764d191c0b7ce6894c126fce0babc6663042f3dde9b0cf76467ea315514e5a6731149c67'\n         combo_address = 'mkc9STceoCcjoXEXe6cm66iJbmjM6zR9B2'\n-        hash = node.generateblock('combo(' + combo_key + ')', [])['hash']\n+        hash = self.generateblock(node, 'combo(' + combo_key + ')', [])['hash']\n         block = node.getblock(hash, 2)\n         assert_equal(len(block['tx']), 1)\n         assert_equal(block['tx'][0]['vout'][0]['scriptPubKey']['address'], combo_address)\n \n         # Generate 110 blocks to spend\n-        node.generatetoaddress(110, address)\n+        self.generatetoaddress(node, 110, address)\n \n         # Generate some extra mempool transactions to verify they don't get mined\n         for _ in range(10):\n             node.sendtoaddress(address, 0.001)\n \n         self.log.info('Generate block with txid')\n         txid = node.sendtoaddress(address, 1)\n-        hash = node.generateblock(address, [txid])['hash']\n+        hash = self.generateblock(node, address, [txid])['hash']\n         block = node.getblock(hash, 1)\n         assert_equal(len(block['tx']), 2)\n         assert_equal(block['tx'][1], txid)\n@@ -69,7 +69,7 @@ def run_test(self):\n         utxos = node.listunspent(addresses=[address])\n         raw = node.createrawtransaction([{'txid':utxos[0]['txid'], 'vout':utxos[0]['vout']}],[{address:1}])\n         signed_raw = node.signrawtransactionwithwallet(raw)['hex']\n-        hash = node.generateblock(address, [signed_raw])['hash']\n+        hash = self.generateblock(node, address, [signed_raw])['hash']\n         block = node.getblock(hash, 1)\n         assert_equal(len(block['tx']), 2)\n         txid = block['tx'][1]\n@@ -81,26 +81,26 @@ def run_test(self):\n         txid1 = node.sendrawtransaction(signed_raw1)\n         raw2 = node.createrawtransaction([{'txid':txid1, 'vout':0}],[{address:0.999}])\n         signed_raw2 = node.signrawtransactionwithwallet(raw2)['hex']\n-        assert_raises_rpc_error(-25, 'TestBlockValidity failed: bad-txns-inputs-missingorspent', node.generateblock, address, [signed_raw2, txid1])\n+        assert_raises_rpc_error(-25, 'TestBlockValidity failed: bad-txns-inputs-missingorspent', self.generateblock, node, address, [signed_raw2, txid1])\n \n         self.log.info('Fail to generate block with txid not in mempool')\n         missing_txid = '0000000000000000000000000000000000000000000000000000000000000000'\n-        assert_raises_rpc_error(-5, 'Transaction ' + missing_txid + ' not in mempool.', node.generateblock, address, [missing_txid])\n+        assert_raises_rpc_error(-5, 'Transaction ' + missing_txid + ' not in mempool.', self.generateblock, node, address, [missing_txid])\n \n         self.log.info('Fail to generate block with invalid raw tx')\n         invalid_raw_tx = '0000'\n-        assert_raises_rpc_error(-22, 'Transaction decode failed for ' + invalid_raw_tx, node.generateblock, address, [invalid_raw_tx])\n+        assert_raises_rpc_error(-22, 'Transaction decode failed for ' + invalid_raw_tx, self.generateblock, node, address, [invalid_raw_tx])\n \n         self.log.info('Fail to generate block with invalid address/descriptor')\n-        assert_raises_rpc_error(-5, 'Invalid address or descriptor', node.generateblock, '1234', [])\n+        assert_raises_rpc_error(-5, 'Invalid address or descriptor', self.generateblock, node, '1234', [])\n \n         self.log.info('Fail to generate block with a ranged descriptor')\n         ranged_descriptor = 'pkh(tpubD6NzVbkrYhZ4XgiXtGrdW5XDAPFCL9h7we1vwNCpn8tGbBcgfVYjXyhWo4E1xkh56hjod1RhGjxbaTLV3X4FyWuejifB9jusQ46QzG87VKp/0/*)'\n-        assert_raises_rpc_error(-8, 'Ranged descriptor not accepted. Maybe pass through deriveaddresses first?', node.generateblock, ranged_descriptor, [])\n+        assert_raises_rpc_error(-8, 'Ranged descriptor not accepted. Maybe pass through deriveaddresses first?', self.generateblock, node, ranged_descriptor, [])\n \n         self.log.info('Fail to generate block with a descriptor missing a private key')\n         child_descriptor = 'pkh(tpubD6NzVbkrYhZ4XgiXtGrdW5XDAPFCL9h7we1vwNCpn8tGbBcgfVYjXyhWo4E1xkh56hjod1RhGjxbaTLV3X4FyWuejifB9jusQ46QzG87VKp/0\\'/0)'\n-        assert_raises_rpc_error(-5, 'Cannot derive script without private keys', node.generateblock, child_descriptor, [])\n+        assert_raises_rpc_error(-5, 'Cannot derive script without private keys', self.generateblock, node, child_descriptor, [])\n \n if __name__ == '__main__':\n     GenerateBlockTest().main()"
      },
      {
        "sha": "4d860d0f36c33bbc52f80b9d9430efed5534636f",
        "filename": "test/functional/rpc_getblockfilter.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_getblockfilter.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_getblockfilter.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_getblockfilter.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -21,8 +21,8 @@ def run_test(self):\n         # Create two chains by disconnecting nodes 0 & 1, mining, then reconnecting\n         self.disconnect_nodes(0, 1)\n \n-        self.nodes[0].generate(3)\n-        self.nodes[1].generate(4)\n+        self.generate(self.nodes[0], 3)\n+        self.generate(self.nodes[1], 4)\n \n         assert_equal(self.nodes[0].getblockcount(), 3)\n         chain0_hashes = [self.nodes[0].getblockhash(block_height) for block_height in range(4)]"
      },
      {
        "sha": "456e2cb0ad5ec6bea3cfa3f2cb16b8bcf988c85f",
        "filename": "test/functional/rpc_getblockstats.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_getblockstats.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_getblockstats.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_getblockstats.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -43,19 +43,19 @@ def get_stats(self):\n     def generate_test_data(self, filename):\n         mocktime = 1525107225\n         self.nodes[0].setmocktime(mocktime)\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n \n         address = self.nodes[0].get_deterministic_priv_key().address\n         self.nodes[0].sendtoaddress(address=address, amount=10, subtractfeefromamount=True)\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n         self.sync_all()\n \n         self.nodes[0].sendtoaddress(address=address, amount=10, subtractfeefromamount=True)\n         self.nodes[0].sendtoaddress(address=address, amount=10, subtractfeefromamount=False)\n         self.nodes[0].settxfee(amount=0.003)\n         self.nodes[0].sendtoaddress(address=address, amount=1, subtractfeefromamount=True)\n         self.sync_all()\n-        self.nodes[0].generate(1)\n+        self.generate(self.nodes[0], 1)\n \n         self.expected_stats = self.get_stats()\n "
      },
      {
        "sha": "ab0ee9142d64a1d0b5e74140174d1a38c63fa909",
        "filename": "test/functional/rpc_getchaintips.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_getchaintips.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_getchaintips.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_getchaintips.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -26,8 +26,8 @@ def run_test(self):\n \n         # Split the network and build two chains of different lengths.\n         self.split_network()\n-        self.nodes[0].generatetoaddress(10, self.nodes[0].get_deterministic_priv_key().address)\n-        self.nodes[2].generatetoaddress(20, self.nodes[2].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], 10, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[2], 20, self.nodes[2].get_deterministic_priv_key().address)\n         self.sync_all(self.nodes[:2])\n         self.sync_all(self.nodes[2:])\n "
      },
      {
        "sha": "a91ce85855df4ed91f9f812267ff151724f63cc6",
        "filename": "test/functional/rpc_invalidateblock.py",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_invalidateblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_invalidateblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_invalidateblock.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -22,12 +22,12 @@ def setup_network(self):\n     def run_test(self):\n         self.log.info(\"Make sure we repopulate setBlockIndexCandidates after InvalidateBlock:\")\n         self.log.info(\"Mine 4 blocks on Node 0\")\n-        self.nodes[0].generatetoaddress(4, self.nodes[0].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[0], 4, self.nodes[0].get_deterministic_priv_key().address)\n         assert_equal(self.nodes[0].getblockcount(), 4)\n         besthash_n0 = self.nodes[0].getbestblockhash()\n \n         self.log.info(\"Mine competing 6 blocks on Node 1\")\n-        self.nodes[1].generatetoaddress(6, self.nodes[1].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[1], 6, self.nodes[1].get_deterministic_priv_key().address)\n         assert_equal(self.nodes[1].getblockcount(), 6)\n \n         self.log.info(\"Connect nodes to force a reorg\")\n@@ -53,14 +53,14 @@ def run_test(self):\n         self.nodes[2].invalidateblock(self.nodes[2].getblockhash(3))\n         assert_equal(self.nodes[2].getblockcount(), 2)\n         self.log.info(\"..and then mine a block\")\n-        self.nodes[2].generatetoaddress(1, self.nodes[2].get_deterministic_priv_key().address)\n+        self.generatetoaddress(self.nodes[2], 1, self.nodes[2].get_deterministic_priv_key().address)\n         self.log.info(\"Verify all nodes are at the right height\")\n         self.wait_until(lambda: self.nodes[2].getblockcount() == 3, timeout=5)\n         self.wait_until(lambda: self.nodes[0].getblockcount() == 4, timeout=5)\n         self.wait_until(lambda: self.nodes[1].getblockcount() == 4, timeout=5)\n \n         self.log.info(\"Verify that we reconsider all ancestors as well\")\n-        blocks = self.nodes[1].generatetodescriptor(10, ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR)\n+        blocks = self.generatetodescriptor(self.nodes[1], 10, ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR)\n         assert_equal(self.nodes[1].getbestblockhash(), blocks[-1])\n         # Invalidate the two blocks at the tip\n         self.nodes[1].invalidateblock(blocks[-1])\n@@ -72,7 +72,7 @@ def run_test(self):\n         assert_equal(self.nodes[1].getbestblockhash(), blocks[-1])\n \n         self.log.info(\"Verify that we reconsider all descendants\")\n-        blocks = self.nodes[1].generatetodescriptor(10, ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR)\n+        blocks = self.generatetodescriptor(self.nodes[1], 10, ADDRESS_BCRT1_UNSPENDABLE_DESCRIPTOR)\n         assert_equal(self.nodes[1].getbestblockhash(), blocks[-1])\n         # Invalidate the two blocks at the tip\n         self.nodes[1].invalidateblock(blocks[-2])"
      },
      {
        "sha": "13f33c321fc91aa274d3c223f9aa5c5d400f3660",
        "filename": "test/functional/rpc_misc.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_misc.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_misc.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_misc.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -57,7 +57,7 @@ def run_test(self):\n         self.log.info(\"test logging rpc and help\")\n \n         # Test logging RPC returns the expected number of logging categories.\n-        assert_equal(len(node.logging()), 24)\n+        assert_equal(len(node.logging()), 25)\n \n         # Test toggling a logging category on/off/on with the logging RPC.\n         assert_equal(node.logging()['qt'], True)"
      },
      {
        "sha": "aa53e354a33b7c3510dbacb0fed64b90fab82591",
        "filename": "test/functional/rpc_net.py",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_net.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_net.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_net.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -52,9 +52,9 @@ def set_test_params(self):\n     def run_test(self):\n         # We need miniwallet to make a transaction\n         self.wallet = MiniWallet(self.nodes[0])\n-        self.wallet.generate(1)\n+        self.generate(self.wallet, 1)\n         # Get out of IBD for the minfeefilter and getpeerinfo tests.\n-        self.nodes[0].generate(COINBASE_MATURITY + 1)\n+        self.generate(self.nodes[0], COINBASE_MATURITY + 1)\n \n         # By default, the test framework sets up an addnode connection from\n         # node 1 --> node0. By connecting node0 --> node 1, we're left with\n@@ -81,7 +81,7 @@ def test_getpeerinfo(self):\n         self.log.info(\"Test getpeerinfo\")\n         # Create a few getpeerinfo last_block/last_transaction values.\n         self.wallet.send_self_transfer(from_node=self.nodes[0]) # Make a transaction so we can see it in the getpeerinfo results\n-        self.nodes[1].generate(1)\n+        self.generate(self.nodes[1], 1)\n         self.sync_all()\n         time_now = int(time.time())\n         peer_info = [x.getpeerinfo() for x in self.nodes]"
      },
      {
        "sha": "63533affd0397fdb048db3ebbf9eb9800441c5d2",
        "filename": "test/functional/rpc_packages.py",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_packages.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_packages.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_packages.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -51,7 +51,7 @@ def run_test(self):\n         self.address = node.get_deterministic_priv_key().address\n         self.coins = []\n         # The last 100 coinbase transactions are premature\n-        for b in node.generatetoaddress(200, self.address)[:100]:\n+        for b in self.generatetoaddress(node, 200, self.address)[:100]:\n             coinbase = node.getblock(blockhash=b, verbosity=2)[\"tx\"][0]\n             self.coins.append({\n                 \"txid\": coinbase[\"txid\"],\n@@ -151,7 +151,7 @@ def test_chain(self):\n         assert_equal(testres_single, testres_multiple)\n \n         # Clean up by clearing the mempool\n-        node.generate(1)\n+        self.generate(node, 1)\n \n     def test_multiple_children(self):\n         node = self.nodes[0]"
      },
      {
        "sha": "3a00992ddc3ed4d2c0b251249e3d4fe6a6f5e23a",
        "filename": "test/functional/rpc_preciousblock.py",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_preciousblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_preciousblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_preciousblock.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -43,18 +43,18 @@ def setup_network(self):\n     def run_test(self):\n         self.log.info(\"Ensure submitblock can in principle reorg to a competing chain\")\n         gen_address = lambda i: self.nodes[i].get_deterministic_priv_key().address  # A non-wallet address to mine to\n-        self.nodes[0].generatetoaddress(1, gen_address(0))\n+        self.generatetoaddress(self.nodes[0], 1, gen_address(0))\n         assert_equal(self.nodes[0].getblockcount(), 1)\n-        hashZ = self.nodes[1].generatetoaddress(2, gen_address(1))[-1]\n+        hashZ = self.generatetoaddress(self.nodes[1], 2, gen_address(1))[-1]\n         assert_equal(self.nodes[1].getblockcount(), 2)\n         node_sync_via_rpc(self.nodes[0:3])\n         assert_equal(self.nodes[0].getbestblockhash(), hashZ)\n \n         self.log.info(\"Mine blocks A-B-C on Node 0\")\n-        hashC = self.nodes[0].generatetoaddress(3, gen_address(0))[-1]\n+        hashC = self.generatetoaddress(self.nodes[0], 3, gen_address(0))[-1]\n         assert_equal(self.nodes[0].getblockcount(), 5)\n         self.log.info(\"Mine competing blocks E-F-G on Node 1\")\n-        hashG = self.nodes[1].generatetoaddress(3, gen_address(1))[-1]\n+        hashG = self.generatetoaddress(self.nodes[1], 3, gen_address(1))[-1]\n         assert_equal(self.nodes[1].getblockcount(), 5)\n         assert hashC != hashG\n         self.log.info(\"Connect nodes and check no reorg occurs\")\n@@ -83,7 +83,7 @@ def run_test(self):\n         self.nodes[1].preciousblock(hashC)\n         assert_equal(self.nodes[1].getbestblockhash(), hashC)\n         self.log.info(\"Mine another block (E-F-G-)H on Node 0 and reorg Node 1\")\n-        self.nodes[0].generatetoaddress(1, gen_address(0))\n+        self.generatetoaddress(self.nodes[0], 1, gen_address(0))\n         assert_equal(self.nodes[0].getblockcount(), 6)\n         self.sync_blocks(self.nodes[0:2])\n         hashH = self.nodes[0].getbestblockhash()\n@@ -92,7 +92,7 @@ def run_test(self):\n         self.nodes[1].preciousblock(hashC)\n         assert_equal(self.nodes[1].getbestblockhash(), hashH)\n         self.log.info(\"Mine competing blocks I-J-K-L on Node 2\")\n-        self.nodes[2].generatetoaddress(4, gen_address(2))\n+        self.generatetoaddress(self.nodes[2], 4, gen_address(2))\n         assert_equal(self.nodes[2].getblockcount(), 6)\n         hashL = self.nodes[2].getbestblockhash()\n         self.log.info(\"Connect nodes and check no reorg occurs\")"
      },
      {
        "sha": "2b1892c121408d2796980dd990f715e1e1f39469",
        "filename": "test/functional/rpc_psbt.py",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f5786ed44f8531379cf4908a0867321db430cb57/test/functional/rpc_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_psbt.py?ref=f5786ed44f8531379cf4908a0867321db430cb57",
        "patch": "@@ -57,7 +57,7 @@ def test_utxo_conversion(self):\n         online_addr = w2.getnewaddress(address_type=\"p2sh-segwit\")\n         wonline.importaddress(offline_addr, \"\", False)\n         mining_node.sendtoaddress(address=offline_addr, amount=1.0)\n-        mining_node.generate(nblocks=1)\n+        self.generate(mining_node, nblocks=1)\n         self.sync_blocks([mining_node, online_node])\n \n         # Construct an unsigned PSBT on the online node (who doesn't know the output is Segwit, so will include a non-witness UTXO)\n@@ -72,7 +72,7 @@ def test_utxo_conversion(self):\n \n         # Make sure we can mine the resulting transaction\n         txid = mining_node.sendrawtransaction(mining_node.finalizepsbt(signed_psbt)[\"hex\"])\n-        mining_node.generate(1)\n+        self.generate(mining_node, 1)\n         self.sync_blocks([mining_node, online_node])\n         assert_equal(online_node.gettxout(txid,0)[\"confirmations\"], 1)\n \n@@ -148,7 +148,7 @@ def run_test(self):\n         rawtx = self.nodes[0].fundrawtransaction(rawtx, {\"changePosition\":3})\n         signed_tx = self.nodes[0].signrawtransactionwithwallet(rawtx['hex'])['hex']\n         txid = self.nodes[0].sendrawtransaction(signed_tx)\n-        self.nodes[0].generate(6)\n+        self.generate(self.nodes[0], 6)\n         self.sync_all()\n \n         # Find the output pos\n@@ -307,7 +307,7 @@ def run_test(self):\n         node2_addr = self.nodes[2].getnewaddress()\n         txid1 = self.nodes[0].sendtoaddress(node1_addr, 13)\n         txid2 = self.nodes[0].sendtoaddress(node2_addr, 13)\n-        blockhash = self.nodes[0].generate(6)[0]\n+        blockhash = self.generate(self.nodes[0], 6)[0]\n         self.sync_all()\n         vout1 = find_output(self.nodes[1], txid1, 13, blockhash=blockhash)\n         vout2 = find_output(self.nodes[2], txid2, 13, blockhash=blockhash)\n@@ -335,7 +335,7 @@ def run_test(self):\n         combined = self.nodes[0].combinepsbt([psbt1, psbt2])\n         finalized = self.nodes[0].finalizepsbt(combined)['hex']\n         self.nodes[0].sendrawtransaction(finalized)\n-        self.nodes[0].generate(6)\n+        self.generate(self.nodes[0], 6)\n         self.sync_all()\n \n         # Test additional args in walletcreatepsbt\n@@ -530,7 +530,7 @@ def test_psbt_input_keys(psbt_input, keys):\n         addr4 = self.nodes[1].getnewaddress(\"\", \"p2sh-segwit\")\n         txid4 = self.nodes[0].sendtoaddress(addr4, 5)\n         vout4 = find_output(self.nodes[0], txid4, 5)\n-        self.nodes[0].generate(6)\n+        self.generate(self.nodes[0], 6)\n         self.sync_all()\n         psbt2 = self.nodes[1].createpsbt([{\"txid\":txid4, \"vout\":vout4}], {self.nodes[0].getnewaddress():Decimal('4.999')})\n         psbt2 = self.nodes[1].walletprocesspsbt(psbt2)['psbt']\n@@ -554,7 +554,7 @@ def test_psbt_input_keys(psbt_input, keys):\n         addr = self.nodes[1].getnewaddress(\"\", \"p2sh-segwit\")\n         txid = self.nodes[0].sendtoaddress(addr, 7)\n         addrinfo = self.nodes[1].getaddressinfo(addr)\n-        blockhash = self.nodes[0].generate(6)[0]\n+        blockhash = self.generate(self.nodes[0], 6)[0]\n         self.sync_all()\n         vout = find_output(self.nodes[0], txid, 7, blockhash=blockhash)\n         psbt = self.nodes[1].createpsbt([{\"txid\":txid, \"vout\":vout}], {self.nodes[0].getnewaddress(\"\", \"p2sh-segwit\"):Decimal('6.999')})"
      }
    ]
  }
]