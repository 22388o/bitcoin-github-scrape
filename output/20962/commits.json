[
  {
    "sha": "f36558871c23087ac57fe68e46183865c5ef400f",
    "node_id": "C_kwDOABII59oAKGYzNjU1ODg3MWMyMzA4N2FjNTdmZTY4ZTQ2MTgzODY1YzVlZjQwMGY",
    "commit": {
      "author": {
        "name": "Jonas Schnelli",
        "email": "dev@jonasschnelli.ch",
        "date": "2021-01-06T08:48:08Z"
      },
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-04T19:34:10Z"
      },
      "message": "Alter the ChaCha20Poly1305@Bitcoin AEAD to the new specification\n\nCo-authored-by: Dhruv Mehta <856960+dhruv@users.noreply.github.com>",
      "tree": {
        "sha": "8727f51b31fa6bc535547928ddd221e2d312dbaf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8727f51b31fa6bc535547928ddd221e2d312dbaf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f36558871c23087ac57fe68e46183865c5ef400f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f36558871c23087ac57fe68e46183865c5ef400f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f36558871c23087ac57fe68e46183865c5ef400f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f36558871c23087ac57fe68e46183865c5ef400f/comments",
    "author": {
      "login": "jonasschnelli",
      "id": 178464,
      "node_id": "MDQ6VXNlcjE3ODQ2NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/178464?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jonasschnelli",
      "html_url": "https://github.com/jonasschnelli",
      "followers_url": "https://api.github.com/users/jonasschnelli/followers",
      "following_url": "https://api.github.com/users/jonasschnelli/following{/other_user}",
      "gists_url": "https://api.github.com/users/jonasschnelli/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jonasschnelli/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jonasschnelli/subscriptions",
      "organizations_url": "https://api.github.com/users/jonasschnelli/orgs",
      "repos_url": "https://api.github.com/users/jonasschnelli/repos",
      "events_url": "https://api.github.com/users/jonasschnelli/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jonasschnelli/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "24abd8312ec1caa04f9b3bd92cd960e28ca91e17",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/24abd8312ec1caa04f9b3bd92cd960e28ca91e17",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/24abd8312ec1caa04f9b3bd92cd960e28ca91e17"
      }
    ],
    "stats": {
      "total": 457,
      "additions": 197,
      "deletions": 260
    },
    "files": [
      {
        "sha": "8c5348f4b048a7bb6daeb682ecd05b588cd64392",
        "filename": "src/bench/chacha_poly_aead.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 29,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f36558871c23087ac57fe68e46183865c5ef400f/src/bench/chacha_poly_aead.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f36558871c23087ac57fe68e46183865c5ef400f/src/bench/chacha_poly_aead.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/chacha_poly_aead.cpp?ref=f36558871c23087ac57fe68e46183865c5ef400f",
        "patch": "@@ -9,7 +9,6 @@\n #include <hash.h>\n \n #include <assert.h>\n-#include <limits>\n \n /* Number of bytes to process per iteration */\n static constexpr uint64_t BUFFER_SIZE_TINY = 64;\n@@ -19,43 +18,28 @@ static constexpr uint64_t BUFFER_SIZE_LARGE = 1024 * 1024;\n static const unsigned char k1[32] = {0};\n static const unsigned char k2[32] = {0};\n \n-static ChaCha20Poly1305AEAD aead(k1, 32, k2, 32);\n-\n static void CHACHA20_POLY1305_AEAD(benchmark::Bench& bench, size_t buffersize, bool include_decryption)\n {\n-    std::vector<unsigned char> in(buffersize + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n-    std::vector<unsigned char> out(buffersize + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n-    uint64_t seqnr_payload = 0;\n-    uint64_t seqnr_aad = 0;\n-    int aad_pos = 0;\n-    uint32_t len = 0;\n+    ChaCha20Poly1305AEAD aead_in(k1, 32, k2, 32);\n+    ChaCha20Poly1305AEAD aead_out(k1, 32, k2, 32);\n+\n+    auto plaintext_len = buffersize + CHACHA20_POLY1305_AEAD_AAD_LEN;\n+    auto ciphertext_len = plaintext_len + POLY1305_TAGLEN;\n+\n+    std::vector<unsigned char> in(plaintext_len, 0);\n+    std::vector<unsigned char> out(ciphertext_len, 0);\n+\n     bench.batch(buffersize).unit(\"byte\").run([&] {\n         // encrypt or decrypt the buffer with a static key\n-        const bool crypt_ok_1 = aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, out.data(), out.size(), in.data(), buffersize, true);\n+        const bool crypt_ok_1 = aead_out.Crypt(out.data(), ciphertext_len, in.data(), plaintext_len, true);\n         assert(crypt_ok_1);\n \n         if (include_decryption) {\n-            // if we decrypt, include the GetLength\n-            const bool get_length_ok = aead.GetLength(&len, seqnr_aad, aad_pos, in.data());\n-            assert(get_length_ok);\n-            const bool crypt_ok_2 = aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, out.data(), out.size(), in.data(), buffersize, true);\n+            // if we decrypt, we need to decrypt the length first and advance the keystream\n+            (void)aead_in.DecryptLength(out.data());\n+            const bool crypt_ok_2 = aead_in.Crypt(in.data(), plaintext_len, out.data(), ciphertext_len, false);\n             assert(crypt_ok_2);\n         }\n-\n-        // increase main sequence number\n-        seqnr_payload++;\n-        // increase aad position (position in AAD keystream)\n-        aad_pos += CHACHA20_POLY1305_AEAD_AAD_LEN;\n-        if (aad_pos + CHACHA20_POLY1305_AEAD_AAD_LEN > CHACHA20_ROUND_OUTPUT) {\n-            aad_pos = 0;\n-            seqnr_aad++;\n-        }\n-        if (seqnr_payload + 1 == std::numeric_limits<uint64_t>::max()) {\n-            // reuse of nonce+key is okay while benchmarking.\n-            seqnr_payload = 0;\n-            seqnr_aad = 0;\n-            aad_pos = 0;\n-        }\n     });\n }\n "
      },
      {
        "sha": "11f5e396e1ffc9b4fe59bbae6ad577381a154eeb",
        "filename": "src/crypto/chacha_poly_aead.cpp",
        "status": "modified",
        "additions": 79,
        "deletions": 57,
        "changes": 136,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f36558871c23087ac57fe68e46183865c5ef400f/src/crypto/chacha_poly_aead.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f36558871c23087ac57fe68e46183865c5ef400f/src/crypto/chacha_poly_aead.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha_poly_aead.cpp?ref=f36558871c23087ac57fe68e46183865c5ef400f",
        "patch": "@@ -4,15 +4,14 @@\n \n #include <crypto/chacha_poly_aead.h>\n \n+#include <crypto/common.h>\n #include <crypto/poly1305.h>\n #include <support/cleanse.h>\n \n #include <assert.h>\n+#include <cstring>\n #include <string.h>\n \n-#include <cstdio>\n-#include <limits>\n-\n #ifndef HAVE_TIMINGSAFE_BCMP\n \n int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n@@ -27,20 +26,56 @@ int timingsafe_bcmp(const unsigned char* b1, const unsigned char* b2, size_t n)\n \n #endif // TIMINGSAFE_BCMP\n \n-ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len)\n+ChaCha20Forward4064::ChaCha20Forward4064(const unsigned char* key, size_t keylen)\n {\n-    assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n-    assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    assert(keylen == 32);\n+    m_ctx.SetKey(key, keylen);\n \n-    m_chacha_header.SetKey(K_1, CHACHA20_POLY1305_AEAD_KEY_LEN);\n-    m_chacha_main.SetKey(K_2, CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    // Set IV to the initial sequence number 0.\n+    m_ctx.SetIV(m_seqnr);\n \n-    // set the cached sequence number to uint64 max which hints for an unset cache.\n-    // we can't hit uint64 max since the rekey rule (which resets the sequence number) is 1GB\n-    m_cached_aad_seqnr = std::numeric_limits<uint64_t>::max();\n+    // precompute first chunk of keystream\n+    m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n }\n \n-bool ChaCha20Poly1305AEAD::Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int aad_pos, unsigned char* dest, size_t dest_len /* length of the output buffer for sanity checks */, const unsigned char* src, size_t src_len, bool is_encrypt)\n+void ChaCha20Forward4064::Crypt(const unsigned char* input, unsigned char* output, size_t bytes)\n+{\n+    size_t message_pos = 0;\n+\n+    // TODO: speedup with a block approach (rather then looping over every byte)\n+    while (bytes > message_pos) {\n+        output[message_pos] = input[message_pos] ^ m_keystream[m_keystream_pos];\n+        m_keystream_pos++;\n+        message_pos++;\n+        if (m_keystream_pos == KEYSTREAM_SIZE - CHACHA20_POLY1305_AEAD_KEY_LEN) {\n+            // we reached the end of the keystream\n+            // rekey with the remaining and last 32 bytes and precompute the next 4096 bytes\n+            m_ctx.SetKey(&m_keystream[m_keystream_pos], CHACHA20_POLY1305_AEAD_KEY_LEN);\n+\n+            // m_ctx.SetKey() sets both IV and counter to zero, but we need the IV to increment.\n+            m_ctx.SetIV(++m_seqnr);\n+            m_ctx.Keystream(m_keystream, KEYSTREAM_SIZE);\n+            // reset keystream position\n+            m_keystream_pos = 0;\n+        }\n+    }\n+}\n+\n+ChaCha20Forward4064::~ChaCha20Forward4064()\n+{\n+    memory_cleanse(m_keystream, KEYSTREAM_SIZE);\n+}\n+\n+ChaCha20Poly1305AEAD::ChaCha20Poly1305AEAD(const unsigned char* K_1,\n+                                           size_t K_1_len,\n+                                           const unsigned char* K_2,\n+                                           size_t K_2_len) : m_chacha_header(K_1, CHACHA20_POLY1305_AEAD_KEY_LEN), m_chacha_main(K_2, CHACHA20_POLY1305_AEAD_KEY_LEN)\n+{\n+    assert(K_1_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+    assert(K_2_len == CHACHA20_POLY1305_AEAD_KEY_LEN);\n+}\n+\n+bool ChaCha20Poly1305AEAD::Crypt(unsigned char* dest, size_t dest_len /* length of the output buffer for sanity checks */, const unsigned char* src, size_t src_len, bool is_encrypt)\n {\n     // check buffer boundaries\n     if (\n@@ -53,18 +88,24 @@ bool ChaCha20Poly1305AEAD::Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int\n \n     unsigned char expected_tag[POLY1305_TAGLEN], poly_key[POLY1305_KEYLEN];\n     memset(poly_key, 0, sizeof(poly_key));\n-    m_chacha_main.SetIV(seqnr_payload);\n \n-    // block counter 0 for the poly1305 key\n-    // use lower 32bytes for the poly1305 key\n-    // (throws away 32 unused bytes (upper 32) from this ChaCha20 round)\n-    m_chacha_main.Seek(0);\n-    m_chacha_main.Crypt(poly_key, poly_key, sizeof(poly_key));\n+    // 1. AAD (the encrypted packet length), use the header-keystream\n+    if (is_encrypt) {\n+        m_chacha_header.Crypt(src, dest, 3);\n+    } else {\n+        // we must use ChaCha20Poly1305AEAD::DecryptLength before calling ChaCha20Poly1305AEAD::Crypt\n+        // thus the length has already been decrypted, avoid doing it again and messing up the keystream position\n+        // keep the encrypted version of the AAD to not break verifying the MAC\n+        memcpy(dest, src, 3);\n+    }\n+\n+    // 2. derive the poly1305 key from the header-keystream\n+    m_chacha_header.Crypt(poly_key, poly_key, sizeof(poly_key));\n \n-    // if decrypting, verify the tag prior to decryption\n+    // 3. if decrypting, verify the MAC prior to decryption\n     if (!is_encrypt) {\n-        const unsigned char* tag = src + src_len - POLY1305_TAGLEN;\n-        poly1305_auth(expected_tag, src, src_len - POLY1305_TAGLEN, poly_key);\n+        const unsigned char* tag = src + src_len - POLY1305_TAGLEN;            //the MAC appended in the package\n+        poly1305_auth(expected_tag, src, src_len - POLY1305_TAGLEN, poly_key); //the calculated MAC\n \n         // constant time compare the calculated MAC with the provided MAC\n         if (timingsafe_bcmp(expected_tag, tag, POLY1305_TAGLEN) != 0) {\n@@ -73,54 +114,35 @@ bool ChaCha20Poly1305AEAD::Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int\n             return false;\n         }\n         memory_cleanse(expected_tag, sizeof(expected_tag));\n-        // MAC has been successfully verified, make sure we don't covert it in decryption\n+        // MAC has been successfully verified, make sure we don't decrypt it\n         src_len -= POLY1305_TAGLEN;\n     }\n \n-    // calculate and cache the next 64byte keystream block if requested sequence number is not yet the cache\n-    if (m_cached_aad_seqnr != seqnr_aad) {\n-        m_cached_aad_seqnr = seqnr_aad;\n-        m_chacha_header.SetIV(seqnr_aad);\n-        m_chacha_header.Seek(0);\n-        m_chacha_header.Keystream(m_aad_keystream_buffer, CHACHA20_ROUND_OUTPUT);\n-    }\n-    // crypt the AAD (3 bytes message length) with given position in AAD cipher instance keystream\n-    dest[0] = src[0] ^ m_aad_keystream_buffer[aad_pos];\n-    dest[1] = src[1] ^ m_aad_keystream_buffer[aad_pos + 1];\n-    dest[2] = src[2] ^ m_aad_keystream_buffer[aad_pos + 2];\n-\n-    // Set the playload ChaCha instance block counter to 1 and crypt the payload\n-    m_chacha_main.Seek(1);\n+    // 4. crypt the payload\n     m_chacha_main.Crypt(src + CHACHA20_POLY1305_AEAD_AAD_LEN, dest + CHACHA20_POLY1305_AEAD_AAD_LEN, src_len - CHACHA20_POLY1305_AEAD_AAD_LEN);\n \n-    // If encrypting, calculate and append tag\n+    // 5. If encrypting, calculate and append MAC\n     if (is_encrypt) {\n-        // the poly1305 tag expands over the AAD (3 bytes length) & encrypted payload\n+        // the poly1305 MAC expands over the AAD (3 bytes length) & encrypted payload\n         poly1305_auth(dest + src_len, dest, src_len, poly_key);\n     }\n \n-    // cleanse no longer required MAC and polykey\n+    // cleanse no longer required polykey\n     memory_cleanse(poly_key, sizeof(poly_key));\n     return true;\n }\n \n-bool ChaCha20Poly1305AEAD::GetLength(uint32_t* len24_out, uint64_t seqnr_aad, int aad_pos, const uint8_t* ciphertext)\n+uint32_t ChaCha20Poly1305AEAD::DecryptLength(const uint8_t* ciphertext)\n {\n-    // enforce valid aad position to avoid accessing outside of the 64byte keystream cache\n-    // (there is space for 21 times 3 bytes)\n-    assert(aad_pos >= 0 && aad_pos < CHACHA20_ROUND_OUTPUT - CHACHA20_POLY1305_AEAD_AAD_LEN);\n-    if (m_cached_aad_seqnr != seqnr_aad) {\n-        // we need to calculate the 64 keystream bytes since we reached a new aad sequence number\n-        m_cached_aad_seqnr = seqnr_aad;\n-        m_chacha_header.SetIV(seqnr_aad);                                         // use LE for the nonce\n-        m_chacha_header.Seek(0);                                                  // block counter 0\n-        m_chacha_header.Keystream(m_aad_keystream_buffer, CHACHA20_ROUND_OUTPUT); // write keystream to the cache\n-    }\n-\n-    // decrypt the ciphertext length by XORing the right position of the 64byte keystream cache with the ciphertext\n-    *len24_out = (ciphertext[0] ^ m_aad_keystream_buffer[aad_pos + 0]) |\n-                 (ciphertext[1] ^ m_aad_keystream_buffer[aad_pos + 1]) << 8 |\n-                 (ciphertext[2] ^ m_aad_keystream_buffer[aad_pos + 2]) << 16;\n-\n-    return true;\n+    // decrypt the length\n+    // once we hit the re-key limit in the keystream (byte 4064) we can't go back to decrypt the length again\n+    // we need to keep the decrypted and the encrypted version in memory to check the max packet length and\n+    // to have the capability to verify the MAC\n+    unsigned char length_buffer[CHACHA20_POLY1305_AEAD_AAD_LEN];\n+    m_chacha_header.Crypt(ciphertext, length_buffer, sizeof(length_buffer));\n+\n+    uint32_t len24_out = (length_buffer[0]) |\n+                         (length_buffer[1]) << 8 |\n+                         (length_buffer[2]) << 16;\n+    return len24_out;\n }"
      },
      {
        "sha": "47951e49281902a3c65d9cc08e40f3e90478c5dd",
        "filename": "src/crypto/chacha_poly_aead.h",
        "status": "modified",
        "additions": 71,
        "deletions": 71,
        "changes": 142,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f36558871c23087ac57fe68e46183865c5ef400f/src/crypto/chacha_poly_aead.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f36558871c23087ac57fe68e46183865c5ef400f/src/crypto/chacha_poly_aead.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/chacha_poly_aead.h?ref=f36558871c23087ac57fe68e46183865c5ef400f",
        "patch": "@@ -6,13 +6,11 @@\n #define BITCOIN_CRYPTO_CHACHA_POLY_AEAD_H\n \n #include <crypto/chacha20.h>\n-\n-#include <cmath>\n+#include <crypto/poly1305.h>\n \n static constexpr int CHACHA20_POLY1305_AEAD_KEY_LEN = 32;\n static constexpr int CHACHA20_POLY1305_AEAD_AAD_LEN = 3; /* 3 bytes length */\n static constexpr int CHACHA20_ROUND_OUTPUT = 64;         /* 64 bytes per round */\n-static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n \n /* A AEAD class for ChaCha20-Poly1305@bitcoin.\n  *\n@@ -40,107 +38,109 @@ static constexpr int AAD_PACKAGES_PER_ROUND = 21;        /* 64 / 3 round down*/\n  * output from the key exchange. Each key (K_1 and K_2) are used by two separate\n  * instances of chacha20.\n  *\n- * The instance keyed by K_1 is a stream cipher that is used only to encrypt the 3\n- * byte packet length field and has its own sequence number. The second instance,\n- * keyed by K_2, is used in conjunction with poly1305 to build an AEAD\n- * (Authenticated Encryption with Associated Data) that is used to encrypt and\n- * authenticate the entire packet.\n+ * The instance keyed by K_1 is a stream cipher that is used for the per-message\n+ * metadata, specifically for the poly1305 authentication key as well as for the\n+ * length encryption. The second instance, keyed by K_2, is used to encrypt the\n+ * entire payload.\n  *\n  * Two separate cipher instances are used here so as to keep the packet lengths\n- * confidential but not create an oracle for the packet payload cipher by\n- * decrypting and using the packet length prior to checking the MAC. By using an\n- * independently-keyed cipher instance to encrypt the length, an active attacker\n- * seeking to exploit the packet input handling as a decryption oracle can learn\n- * nothing about the payload contents or its MAC (assuming key derivation,\n- * ChaCha20 and Poly1305 are secure).\n- *\n- * The AEAD is constructed as follows: for each packet, generate a Poly1305 key by\n- * taking the first 256 bits of ChaCha20 stream output generated using K_2, an IV\n- * consisting of the packet sequence number encoded as an LE uint64 and a ChaCha20\n- * block counter of zero. The K_2 ChaCha20 block counter is then set to the\n- * little-endian encoding of 1 (i.e. {1, 0, 0, 0, 0, 0, 0, 0}) and this instance\n- * is used for encryption of the packet payload.\n+ * confidential (best effort; for passive observing) but not create an oracle for\n+ * the packet payload cipher by decrypting and using the packet length prior to\n+ * checking the MAC. By using an independently-keyed cipher instance to encrypt\n+ * the length, an active attacker seeking to exploit the packet input handling as\n+ * a decryption oracle can learn nothing about the payload contents or its MAC\n+ * (assuming key derivation, ChaCha20 and Poly1305 are secure). Active observers\n+ * can still obtain the message length (ex. active ciphertext bit flipping or\n+ * traffic semantics analysis)\n  *\n- * ==== Packet Handling ====\n+ * The AEAD is constructed as follows: generate two ChaCha20 streams, initially\n+ * keyed with K_1 and K_2 and sequence number 0 as IV and a block counter of 0.\n+ * After encrypting 4064 bytes, the following 32 bytes are used to\n+ * re-key the ChaCha20 context.\n  *\n- * When receiving a packet, the length must be decrypted first. When 3 bytes of\n- * ciphertext length have been received, they may be decrypted.\n+ * Byte-level forward security is possible by precomputing 4096 bytes of stream\n+ * output, caching it, resetting the key to the final 32 bytes of the output, and\n+ * then wiping the remaining 4064 bytes of cached data as it gets used.\n+ *\n+ * For each packet, use 3 bytes from the remaining ChaCha20 stream generated using\n+ * K_1 to encrypt the length. Use additional 32 bytes of the same stream to\n+ * generate a Poly1305 key.\n  *\n- * A ChaCha20 round always calculates 64bytes which is sufficient to crypt 21\n- * times a 3 bytes length field (21*3 = 63). The length field sequence number can\n- * thus be used 21 times (keystream caching).\n+ * If we reach bytes 4064 on the ChaCha20 stream, use the next 32 bytes (byte\n+ * 4065-4096) and set is as the new ChaCha20 key, reset the counter to 0 while\n+ * incrementing the sequence number + 1 and set is as IV (little endian encoding).\n  *\n- * The length field must be enc-/decrypted with the ChaCha20 keystream keyed with\n- * K_1 defined by block counter 0, the length field sequence number in little\n- * endian and a keystream position from 0 to 60.\n+ * For the payload, use the ChaCha20 stream keyed with K_2 and apply the same\n+ * re-key rules.\n+ *\n+ *\n+ * ==== Packet Handling ====\n+ *\n+ * When receiving a packet, the length must be decrypted first. When 3 bytes of\n+ * ciphertext length have been received, they MUST be decrypted.\n  *\n  * Once the entire packet has been received, the MAC MUST be checked before\n  * decryption. A per-packet Poly1305 key is generated as described above and the\n- * MAC tag calculated using Poly1305 with this key over the ciphertext of the\n+ * MAC tag is calculated using Poly1305 with this key over the ciphertext of the\n  * packet length and the payload together. The calculated MAC is then compared in\n  * constant time with the one appended to the packet and the packet decrypted\n- * using ChaCha20 as described above (with K_2, the packet sequence number as\n- * nonce and a starting block counter of 1).\n+ * using ChaCha20 as described above (using stream keyed with K_2).\n  *\n  * Detection of an invalid MAC MUST lead to immediate connection termination.\n  *\n- * To send a packet, first encode the 3 byte length and encrypt it using K_1 as\n- * described above. Encrypt the packet payload (using K_2) and append it to the\n- * encrypted length. Finally, calculate a MAC tag and append it.\n- *\n- * The initiating peer MUST use <code>K_1_A, K_2_A</code> to encrypt messages on\n- * the send channel, <code>K_1_B, K_2_B</code> MUST be used to decrypt messages on\n- * the receive channel.\n- *\n- * The responding peer MUST use <code>K_1_A, K_2_A</code> to decrypt messages on\n- * the receive channel, <code>K_1_B, K_2_B</code> MUST be used to encrypt messages\n- * on the send channel.\n- *\n- * Optimized implementations of ChaCha20-Poly1305@bitcoin are relatively fast in\n- * general, therefore it is very likely that encrypted messages require not more\n- * CPU cycles per bytes then the current unencrypted p2p message format\n- * (ChaCha20/Poly1305 versus double SHA256).\n- *\n- * The initial packet sequence numbers are 0.\n- *\n- * K_2 ChaCha20 cipher instance (payload) must never reuse a {key, nonce} for\n- * encryption nor may it be used to encrypt more than 2^70 bytes under the same\n- * {key, nonce}.\n- *\n- * K_1 ChaCha20 cipher instance (length field/AAD) must never reuse a {key, nonce,\n- * position-in-keystream} for encryption nor may it be used to encrypt more than\n- * 2^70 bytes under the same {key, nonce}.\n- *\n- * We use message sequence numbers for both communication directions.\n+ * To send a packet, first encode the 3 byte length and encrypt it using the\n+ * ChaCha20 stream keyed with K_1 as described above. Encrypt the packet payload\n+ * (using the ChaCha20 stream keyed with K_2) and append it to the encrypted\n+ * length. Finally, calculate a MAC tag (using poly1305 key from stream keyed with K_1)\n+ * and append it.\n  */\n \n+const int KEYSTREAM_SIZE = 4096;\n+\n+class ChaCha20Forward4064\n+{\n+private:\n+    ChaCha20 m_ctx;\n+    uint64_t m_seqnr{0};\n+    size_t m_keystream_pos{0};\n+    unsigned char m_keystream[KEYSTREAM_SIZE] = {0};\n+\n+public:\n+    ChaCha20Forward4064(const unsigned char* key, size_t keylen);\n+    ~ChaCha20Forward4064();\n+    void Crypt(const unsigned char* input, unsigned char* output, size_t bytes);\n+};\n+\n class ChaCha20Poly1305AEAD\n {\n private:\n-    ChaCha20 m_chacha_header;                                    // AAD cipher instance (encrypted length) and poly1305 key-derivation cipher instance\n-    ChaCha20 m_chacha_main;                                      // payload\n-    unsigned char m_aad_keystream_buffer[CHACHA20_ROUND_OUTPUT]; // aad keystream cache\n-    uint64_t m_cached_aad_seqnr;                                 // aad keystream cache hint\n+    ChaCha20Forward4064 m_chacha_header; // AAD cipher instance (encrypted length) and poly1305 key-derivation cipher instance\n+    ChaCha20Forward4064 m_chacha_main;   // payload\n \n public:\n     ChaCha20Poly1305AEAD(const unsigned char* K_1, size_t K_1_len, const unsigned char* K_2, size_t K_2_len);\n \n     explicit ChaCha20Poly1305AEAD(const ChaCha20Poly1305AEAD&) = delete;\n \n     /** Encrypts/decrypts a packet\n-        seqnr_payload, the message sequence number\n-        seqnr_aad, the messages AAD sequence number which allows reuse of the AAD keystream\n-        aad_pos, position to use in the AAD keystream to encrypt the AAD\n         dest, output buffer, must be of a size equal or larger then CHACHA20_POLY1305_AEAD_AAD_LEN + payload (+ POLY1305_TAG_LEN in encryption) bytes\n         destlen, length of the destination buffer\n         src, the AAD+payload to encrypt or the AAD+payload+MAC to decrypt\n         src_len, the length of the source buffer\n         is_encrypt, set to true if we encrypt (creates and appends the MAC instead of verifying it)\n+\n+        Returns true if encipher succeeds. Upon failure, the data at dest should not be used.\n         */\n-    bool Crypt(uint64_t seqnr_payload, uint64_t seqnr_aad, int aad_pos, unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n+    [[nodiscard]] bool Crypt(unsigned char* dest, size_t dest_len, const unsigned char* src, size_t src_len, bool is_encrypt);\n+\n+    /** Decrypts the 3 bytes AAD data (the packet length) and decodes it into a uint32_t field\n+        the ciphertext will not be manipulated but the AAD keystream will advance. As a result,\n+        DecryptLength() cannot be called multiple times to get the same result. The caller must\n+        cache the result for re-use.\n \n-    /** decrypts the 3 bytes AAD data and decodes it into a uint32_t field */\n-    bool GetLength(uint32_t* len24_out, uint64_t seqnr_aad, int aad_pos, const uint8_t* ciphertext);\n+        Ciphertext needs to stay encrypted due to the MAC check that will follow (requires encrypted length)\n+        */\n+    [[nodiscard]] uint32_t DecryptLength(const uint8_t* ciphertext);\n };\n \n #endif // BITCOIN_CRYPTO_CHACHA_POLY_AEAD_H"
      },
      {
        "sha": "2b27c1e9e2656524082f259a8d73b0c73e68a686",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 32,
        "deletions": 74,
        "changes": 106,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f36558871c23087ac57fe68e46183865c5ef400f/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f36558871c23087ac57fe68e46183865c5ef400f/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=f36558871c23087ac57fe68e46183865c5ef400f",
        "patch": "@@ -590,37 +590,24 @@ BOOST_AUTO_TEST_CASE(hkdf_hmac_sha256_l32_tests)\n                 \"8da4e775a563c18f715f802a063c5a31b8a11f5c5ee1879ec3454e5f3c738d2d\");\n }\n \n-static void TestChaCha20Poly1305AEAD(bool must_succeed, unsigned int expected_aad_length, const std::string& hex_m, const std::string& hex_k1, const std::string& hex_k2, const std::string& hex_aad_keystream, const std::string& hex_encrypted_message, const std::string& hex_encrypted_message_seq_999)\n+static void TestChaCha20Poly1305AEAD(bool must_succeed, unsigned int expected_aad_length, const std::string& hex_m, const std::string& hex_k1, const std::string& hex_k2, const std::string& hex_encrypted_message, const std::string& hex_encrypted_message_seq_999)\n {\n-    // we need two sequence numbers, one for the payload cipher instance...\n-    uint32_t seqnr_payload = 0;\n-    // ... and one for the AAD (length) cipher instance\n-    uint32_t seqnr_aad = 0;\n-    // we need to keep track of the position in the AAD cipher instance\n-    // keystream since we use the same 64byte output 21 times\n-    // (21 times 3 bytes length < 64)\n-    int aad_pos = 0;\n-\n     std::vector<unsigned char> aead_K_1 = ParseHex(hex_k1);\n     std::vector<unsigned char> aead_K_2 = ParseHex(hex_k2);\n     std::vector<unsigned char> plaintext_buf = ParseHex(hex_m);\n-    std::vector<unsigned char> expected_aad_keystream = ParseHex(hex_aad_keystream);\n     std::vector<unsigned char> expected_ciphertext_and_mac = ParseHex(hex_encrypted_message);\n     std::vector<unsigned char> expected_ciphertext_and_mac_sequence999 = ParseHex(hex_encrypted_message_seq_999);\n \n     std::vector<unsigned char> ciphertext_buf(plaintext_buf.size() + POLY1305_TAGLEN, 0);\n     std::vector<unsigned char> plaintext_buf_new(plaintext_buf.size(), 0);\n-    std::vector<unsigned char> cmp_ctx_buffer(64);\n     uint32_t out_len = 0;\n \n     // create the AEAD instance\n-    ChaCha20Poly1305AEAD aead(aead_K_1.data(), aead_K_1.size(), aead_K_2.data(), aead_K_2.size());\n-\n-    // create a chacha20 instance to compare against\n-    ChaCha20 cmp_ctx(aead_K_1.data(), 32);\n+    ChaCha20Poly1305AEAD aead_out(aead_K_1.data(), aead_K_1.size(), aead_K_2.data(), aead_K_2.size());\n+    ChaCha20Poly1305AEAD aead_in(aead_K_1.data(), aead_K_1.size(), aead_K_2.data(), aead_K_2.size());\n \n     // encipher\n-    bool res = aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, ciphertext_buf.data(), ciphertext_buf.size(), plaintext_buf.data(), plaintext_buf.size(), true);\n+    bool res = aead_out.Crypt(ciphertext_buf.data(), ciphertext_buf.size(), plaintext_buf.data(), plaintext_buf.size(), true);\n     // make sure the operation succeeded if expected to succeed\n     BOOST_CHECK_EQUAL(res, must_succeed);\n     if (!res) return;\n@@ -629,56 +616,29 @@ static void TestChaCha20Poly1305AEAD(bool must_succeed, unsigned int expected_aa\n     BOOST_CHECK_EQUAL(expected_ciphertext_and_mac.size(), ciphertext_buf.size());\n     BOOST_CHECK(memcmp(ciphertext_buf.data(), expected_ciphertext_and_mac.data(), ciphertext_buf.size()) == 0);\n \n-    // manually construct the AAD keystream\n-    cmp_ctx.SetIV(seqnr_aad);\n-    cmp_ctx.Seek(0);\n-    cmp_ctx.Keystream(cmp_ctx_buffer.data(), 64);\n-    BOOST_CHECK(memcmp(expected_aad_keystream.data(), cmp_ctx_buffer.data(), expected_aad_keystream.size()) == 0);\n-    // crypt the 3 length bytes and compare the length\n-    uint32_t len_cmp = 0;\n-    len_cmp = (ciphertext_buf[0] ^ cmp_ctx_buffer[aad_pos + 0]) |\n-              (ciphertext_buf[1] ^ cmp_ctx_buffer[aad_pos + 1]) << 8 |\n-              (ciphertext_buf[2] ^ cmp_ctx_buffer[aad_pos + 2]) << 16;\n-    BOOST_CHECK_EQUAL(len_cmp, expected_aad_length);\n-\n-    // encrypt / decrypt 1000 packets\n+    out_len = aead_in.DecryptLength(ciphertext_buf.data());\n+    BOOST_CHECK_EQUAL(out_len, expected_aad_length);\n+    res = aead_in.Crypt(plaintext_buf.data(), plaintext_buf.size(), ciphertext_buf.data(), ciphertext_buf.size(), false);\n+    BOOST_CHECK_EQUAL(res, must_succeed);\n+    WriteLE32(plaintext_buf.data(), out_len);\n+\n+    // encrypt / decrypt the packet 1000 times\n     for (size_t i = 0; i < 1000; ++i) {\n-        res = aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, ciphertext_buf.data(), ciphertext_buf.size(), plaintext_buf.data(), plaintext_buf.size(), true);\n+        res = aead_out.Crypt(ciphertext_buf.data(), ciphertext_buf.size(), plaintext_buf.data(), plaintext_buf.size(), true);\n         BOOST_CHECK(res);\n-        BOOST_CHECK(aead.GetLength(&out_len, seqnr_aad, aad_pos, ciphertext_buf.data()));\n+        out_len = aead_in.DecryptLength(ciphertext_buf.data());\n         BOOST_CHECK_EQUAL(out_len, expected_aad_length);\n-        res = aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, plaintext_buf_new.data(), plaintext_buf_new.size(), ciphertext_buf.data(), ciphertext_buf.size(), false);\n+        res = aead_in.Crypt(plaintext_buf_new.data(), plaintext_buf_new.size(), ciphertext_buf.data(), ciphertext_buf.size(), false);\n         BOOST_CHECK(res);\n \n+        // length is not decrypted, copy it over\n+        WriteLE32(plaintext_buf_new.data(), out_len);\n+\n         // make sure we repetitive get the same plaintext\n         BOOST_CHECK(memcmp(plaintext_buf.data(), plaintext_buf_new.data(), plaintext_buf.size()) == 0);\n \n-        // compare sequence number 999 against the test vector\n-        if (seqnr_payload == 999) {\n-            BOOST_CHECK(memcmp(ciphertext_buf.data(), expected_ciphertext_and_mac_sequence999.data(), expected_ciphertext_and_mac_sequence999.size()) == 0);\n-        }\n-        // set nonce and block counter, output the keystream\n-        cmp_ctx.SetIV(seqnr_aad);\n-        cmp_ctx.Seek(0);\n-        cmp_ctx.Keystream(cmp_ctx_buffer.data(), 64);\n-\n-        // crypt the 3 length bytes and compare the length\n-        len_cmp = 0;\n-        len_cmp = (ciphertext_buf[0] ^ cmp_ctx_buffer[aad_pos + 0]) |\n-                  (ciphertext_buf[1] ^ cmp_ctx_buffer[aad_pos + 1]) << 8 |\n-                  (ciphertext_buf[2] ^ cmp_ctx_buffer[aad_pos + 2]) << 16;\n-        BOOST_CHECK_EQUAL(len_cmp, expected_aad_length);\n-\n-        // increment the sequence number(s)\n-        // always increment the payload sequence number\n-        // increment the AAD keystream position by its size (3)\n-        // increment the AAD sequence number if we would hit the 64 byte limit\n-        seqnr_payload++;\n-        aad_pos += CHACHA20_POLY1305_AEAD_AAD_LEN;\n-        if (aad_pos + CHACHA20_POLY1305_AEAD_AAD_LEN > CHACHA20_ROUND_OUTPUT) {\n-            aad_pos = 0;\n-            seqnr_aad++;\n-        }\n+        // compare at iteration 999 against the test vector\n+        if (i == 999) BOOST_CHECK(memcmp(ciphertext_buf.data(), expected_ciphertext_and_mac_sequence999.data(), expected_ciphertext_and_mac_sequence999.size()) == 0);\n     }\n }\n \n@@ -688,9 +648,9 @@ BOOST_AUTO_TEST_CASE(chacha20_poly1305_aead_testvector)\n \n     // must fail with no message\n     TestChaCha20Poly1305AEAD(false, 0,\n-        \"\",\n-        \"0000000000000000000000000000000000000000000000000000000000000000\",\n-        \"0000000000000000000000000000000000000000000000000000000000000000\", \"\", \"\", \"\");\n+                             \"\",\n+                             \"0000000000000000000000000000000000000000000000000000000000000000\",\n+                             \"0000000000000000000000000000000000000000000000000000000000000000\", \"\", \"\");\n \n     TestChaCha20Poly1305AEAD(true, 0,\n         /* m  */ \"0000000000000000000000000000000000000000000000000000000000000000\",\n@@ -700,19 +660,17 @@ BOOST_AUTO_TEST_CASE(chacha20_poly1305_aead_testvector)\n         /* encrypted message & MAC */ \"76b8e09f07e7be5551387a98ba977c732d080dcb0f29a048e3656912c6533e32d2fc11829c1b6c1df1f551cd6131ff08\",\n         /* encrypted message & MAC at sequence 999 */ \"b0a03d5bd2855d60699e7d3a3133fa47be740fe4e4c1f967555e2d9271f31c3aaa7aa16ec62c5e24f040c08bb20c3598\");\n     TestChaCha20Poly1305AEAD(true, 1,\n-        \"0100000000000000000000000000000000000000000000000000000000000000\",\n-        \"0000000000000000000000000000000000000000000000000000000000000000\",\n-        \"0000000000000000000000000000000000000000000000000000000000000000\",\n-        \"76b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8b770dc7da41597c5157488d7724e03fb8d84a376a43b8f41518a11cc387b669b2ee6586\",\n-        \"77b8e09f07e7be5551387a98ba977c732d080dcb0f29a048e3656912c6533e32baf0c85b6dff8602b06cf52a6aefc62e\",\n-        \"b1a03d5bd2855d60699e7d3a3133fa47be740fe4e4c1f967555e2d9271f31c3a8bd94d54b5ecabbc41ffbb0c90924080\");\n+                             \"0100000000000000000000000000000000000000000000000000000000000000\",\n+                             \"0000000000000000000000000000000000000000000000000000000000000000\",\n+                             \"0000000000000000000000000000000000000000000000000000000000000000\",\n+                             \"77b8e076b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8bfb6cf9dcd7e2ee807d5ff981eb4a135a\",\n+                             \"c81eef105710ba88ef076f28e735cc672bde84505fbaeb0faa627ff5067a860942b2888c98e0c1003d0611e527776e88\");\n     TestChaCha20Poly1305AEAD(true, 255,\n-        \"ff0000f195e66982105ffb640bb7757f579da31602fc93ec01ac56f85ac3c134a4547b733b46413042c9440049176905d3be59ea1c53f15916155c2be8241a38008b9a26bc35941e2444177c8ade6689de95264986d95889fb60e84629c9bd9a5acb1cc118be563eb9b3a4a472f82e09a7e778492b562ef7130e88dfe031c79db9d4f7c7a899151b9a475032b63fc385245fe054e3dd5a97a5f576fe064025d3ce042c566ab2c507b138db853e3d6959660996546cc9c4a6eafdc777c040d70eaf46f76dad3979e5c5360c3317166a1c894c94a371876a94df7628fe4eaaf2ccb27d5aaae0ad7ad0f9d4b6ad3b54098746d4524d38407a6deb3ab78fab78c9\",\n-        \"ff0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\",\n-        \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\",\n-        \"c640c1711e3ee904ac35c57ab9791c8a1c408603a90b77a83b54f6c844cb4b06d94e7fc6c800e165acd66147e80ec45a567f6ce66d05ec0cae679dceeb890017\",\n-        \"3940c1e92da4582ff6f92a776aeb14d014d384eeb30f660dacf70a14a23fd31e91212701334e2ce1acf5199dc84f4d61ddbe6571bca5af874b4c9226c26e650995d157644e1848b96ed6c2102d5489a050e71d29a5a66ece11de5fb5c9558d54da28fe45b0bc4db4e5b88030bfc4a352b4b7068eccf656bae7ad6a35615315fc7c49d4200388d5eca67c2e822e069336c69b40db67e0f3c81209c50f3216a4b89fb3ae1b984b7851a2ec6f68ab12b101ab120e1ea7313bb93b5a0f71185c7fea017ddb92769861c29dba4fbc432280d5dff21b36d1c4c790128b22699950bb18bf74c448cdfe547d8ed4f657d8005fdc0cd7a050c2d46050a44c4376355858981fbe8b184288276e7a93eabc899c4a\",\n-        \"f039c6689eaeef0456685200feaab9d54bbd9acde4410a3b6f4321296f4a8ca2604b49727d8892c57e005d799b2a38e85e809f20146e08eec75169691c8d4f54a0d51a1e1c7b381e0474eb02f994be9415ef3ffcbd2343f0601e1f3b172a1d494f838824e4df570f8e3b0c04e27966e36c82abd352d07054ef7bd36b84c63f9369afe7ed79b94f953873006b920c3fa251a771de1b63da927058ade119aa898b8c97e42a606b2f6df1e2d957c22f7593c1e2002f4252f4c9ae4bf773499e5cfcfe14dfc1ede26508953f88553bf4a76a802f6a0068d59295b01503fd9a600067624203e880fdf53933b96e1f4d9eb3f4e363dd8165a278ff667a41ee42b9892b077cefff92b93441f7be74cf10e6cd\");\n+                             \"ff0000f195e66982105ffb640bb7757f579da31602fc93ec01ac56f85ac3c134a4547b733b46413042c9440049176905d3be59ea1c53f15916155c2be8241a38008b9a26bc35941e2444177c8ade6689de95264986d95889fb60e84629c9bd9a5acb1cc118be563eb9b3a4a472f82e09a7e778492b562ef7130e88dfe031c79db9d4f7c7a899151b9a475032b63fc385245fe054e3dd5a97a5f576fe064025d3ce042c566ab2c507b138db853e3d6959660996546cc9c4a6eafdc777c040d70eaf46f76dad3979e5c5360c3317166a1c894c94a371876a94df7628fe4eaaf2ccb27d5aaae0ad7ad0f9d4b6ad3b54098746d4524d38407a6deb3ab78fab78c9\",\n+                             \"ff0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\",\n+                             \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\",\n+                             \"3940c1c868cd145bd54691e9b6b402c78bd7ea9c3724fc50dfc69a4a96be8dec4e70e958188aa69222eaef3f47f8003f1bc13dcf9e661be8e1b671e9cf46ba705bca963e0477a5b3c2e2c66feb8207269ddb01b1372aad68563bb4aad135afb06fbe40b310b63bef578ff939f3a00a6da9e744d28ba070294e5746d2ca7bb8ac2c8e3a855ab4c9bcd0d5855e11b52cacaa2ddb34c0a26cd04f4bc10de6dc151d4ee7ced2c2b0de8ded33ff11f301e4027559e8938b69bceb1e5e259d4122056f6adbd48a0628b912f90d72838f2f3aaf6b88342cf5bac3cb688a9b0f7afc73a7e3cad8e71254c786ea000240ae7bd1df8bcfca07f3b885723a9d7f897364617ac8d935a41bf9546432360e1c543708\",\n+                             \"c5ab314a18d3b9eb02b7990e91adb4f005fb185d741277c066c4d002560dabea96b07009b1ae287931224e90fd70324fb02857019499f3d9ec774dd3f412a1ac13dc2f603e8b22abef71c9c7c688c1b7d835f76d32a32886f3326f70701f5b3617de21723a9d575bd572815696ad8410da643603a9a1c1a5aedc0c88ceb2c6610c685a4918e09f36f01c646f071c8ec668fd794ff4fc8bd671663a8e36a96ea8d4ea4c3d2893258237bddf7562af50785043cfb78e06cfe6d00145a46a76c9fedc450c776af4a4319ecb92ef818d2174baab3714cabb823a4c456cf51c0143a9451676db428b6b5aca7f8ff4a51fd717bc3293955aca0363ec663abdc8c8e7bd214de0e986fbb1e04de90db8dfb055\");\n }\n \n BOOST_AUTO_TEST_CASE(countbits_tests)"
      },
      {
        "sha": "c9ac69a7561e9c7e77139c61a2145c0ed07eac20",
        "filename": "src/test/fuzz/crypto_chacha20_poly1305_aead.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 29,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f36558871c23087ac57fe68e46183865c5ef400f/src/test/fuzz/crypto_chacha20_poly1305_aead.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f36558871c23087ac57fe68e46183865c5ef400f/src/test/fuzz/crypto_chacha20_poly1305_aead.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/fuzz/crypto_chacha20_poly1305_aead.cpp?ref=f36558871c23087ac57fe68e46183865c5ef400f",
        "patch": "@@ -8,9 +8,7 @@\n #include <test/fuzz/fuzz.h>\n #include <test/fuzz/util.h>\n \n-#include <cassert>\n #include <cstdint>\n-#include <limits>\n #include <vector>\n \n FUZZ_TARGET(crypto_chacha20_poly1305_aead)\n@@ -21,9 +19,6 @@ FUZZ_TARGET(crypto_chacha20_poly1305_aead)\n     const std::vector<uint8_t> k2 = ConsumeFixedLengthByteVector(fuzzed_data_provider, CHACHA20_POLY1305_AEAD_KEY_LEN);\n \n     ChaCha20Poly1305AEAD aead(k1.data(), k1.size(), k2.data(), k2.size());\n-    uint64_t seqnr_payload = 0;\n-    uint64_t seqnr_aad = 0;\n-    int aad_pos = 0;\n     size_t buffer_size = fuzzed_data_provider.ConsumeIntegralInRange<size_t>(0, 4096);\n     std::vector<uint8_t> in(buffer_size + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n     std::vector<uint8_t> out(buffer_size + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n@@ -37,32 +32,10 @@ FUZZ_TARGET(crypto_chacha20_poly1305_aead)\n                 out = std::vector<uint8_t>(buffer_size + CHACHA20_POLY1305_AEAD_AAD_LEN + POLY1305_TAGLEN, 0);\n             },\n             [&] {\n-                (void)aead.Crypt(seqnr_payload, seqnr_aad, aad_pos, out.data(), out.size(), in.data(), buffer_size, is_encrypt);\n+                (void)aead.Crypt(out.data(), out.size(), in.data(), buffer_size, is_encrypt);\n             },\n             [&] {\n-                uint32_t len = 0;\n-                const bool ok = aead.GetLength(&len, seqnr_aad, aad_pos, in.data());\n-                assert(ok);\n-            },\n-            [&] {\n-                if (AdditionOverflow(seqnr_payload, static_cast<uint64_t>(1))) {\n-                    return;\n-                }\n-                seqnr_payload += 1;\n-                aad_pos += CHACHA20_POLY1305_AEAD_AAD_LEN;\n-                if (aad_pos + CHACHA20_POLY1305_AEAD_AAD_LEN > CHACHA20_ROUND_OUTPUT) {\n-                    aad_pos = 0;\n-                    if (AdditionOverflow(seqnr_aad, static_cast<uint64_t>(1))) {\n-                        return;\n-                    }\n-                    seqnr_aad += 1;\n-                }\n-            },\n-            [&] {\n-                seqnr_payload = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n-            },\n-            [&] {\n-                seqnr_aad = fuzzed_data_provider.ConsumeIntegral<uint64_t>();\n+                (void)aead.DecryptLength(in.data());\n             },\n             [&] {\n                 is_encrypt = fuzzed_data_provider.ConsumeBool();"
      }
    ]
  },
  {
    "sha": "6a651b5352e7444ad55e04e2738d241f8ef72518",
    "node_id": "C_kwDOABII59oAKDZhNjUxYjUzNTJlNzQ0NGFkNTVlMDRlMjczOGQyNDFmOGVmNzI1MTg",
    "commit": {
      "author": {
        "name": "Dhruv Mehta",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-08-23T18:54:58Z"
      },
      "committer": {
        "name": "dhruv",
        "email": "856960+dhruv@users.noreply.github.com",
        "date": "2021-11-04T19:34:13Z"
      },
      "message": "test: clarify that encrypted length is payload length",
      "tree": {
        "sha": "e27ddb48428660da4288a4466400e4bfb113bb27",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e27ddb48428660da4288a4466400e4bfb113bb27"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6a651b5352e7444ad55e04e2738d241f8ef72518",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a651b5352e7444ad55e04e2738d241f8ef72518",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6a651b5352e7444ad55e04e2738d241f8ef72518",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6a651b5352e7444ad55e04e2738d241f8ef72518/comments",
    "author": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "dhruv",
      "id": 856960,
      "node_id": "MDQ6VXNlcjg1Njk2MA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/856960?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/dhruv",
      "html_url": "https://github.com/dhruv",
      "followers_url": "https://api.github.com/users/dhruv/followers",
      "following_url": "https://api.github.com/users/dhruv/following{/other_user}",
      "gists_url": "https://api.github.com/users/dhruv/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/dhruv/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/dhruv/subscriptions",
      "organizations_url": "https://api.github.com/users/dhruv/orgs",
      "repos_url": "https://api.github.com/users/dhruv/repos",
      "events_url": "https://api.github.com/users/dhruv/events{/privacy}",
      "received_events_url": "https://api.github.com/users/dhruv/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f36558871c23087ac57fe68e46183865c5ef400f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f36558871c23087ac57fe68e46183865c5ef400f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f36558871c23087ac57fe68e46183865c5ef400f"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 13,
      "deletions": 9
    },
    "files": [
      {
        "sha": "fe968fe5ca98025c21c66b6590043bd2e9b34290",
        "filename": "src/test/crypto_tests.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 9,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6a651b5352e7444ad55e04e2738d241f8ef72518/src/test/crypto_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6a651b5352e7444ad55e04e2738d241f8ef72518/src/test/crypto_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/crypto_tests.cpp?ref=6a651b5352e7444ad55e04e2738d241f8ef72518",
        "patch": "@@ -652,25 +652,29 @@ BOOST_AUTO_TEST_CASE(chacha20_poly1305_aead_testvector)\n                              \"0000000000000000000000000000000000000000000000000000000000000000\",\n                              \"0000000000000000000000000000000000000000000000000000000000000000\", \"\", \"\");\n \n-    TestChaCha20Poly1305AEAD(true, 0,\n-        /* m  */ \"0000000000000000000000000000000000000000000000000000000000000000\",\n+    // The expected AAD length is the length of the payload portion of the ciphertext.\n+    TestChaCha20Poly1305AEAD(true, 29,\n+        /* m  */ \"1d00000000000000000000000000000000000000000000000000000000000000\",\n         /* k1 (AAD) */ \"0000000000000000000000000000000000000000000000000000000000000000\",\n         /* k2 (payload) */ \"0000000000000000000000000000000000000000000000000000000000000000\",\n-        /* AAD keystream */ \"76b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8b770dc7da41597c5157488d7724e03fb8d84a376a43b8f41518a11cc387b669b2ee6586\",\n-        /* encrypted message & MAC */ \"76b8e09f07e7be5551387a98ba977c732d080dcb0f29a048e3656912c6533e32d2fc11829c1b6c1df1f551cd6131ff08\",\n-        /* encrypted message & MAC at sequence 999 */ \"b0a03d5bd2855d60699e7d3a3133fa47be740fe4e4c1f967555e2d9271f31c3aaa7aa16ec62c5e24f040c08bb20c3598\");\n+        /* encrypted message & MAC */ \"6bb8e076b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8babf71de83e6e27c82490bdc8615d0c9e\",\n+        /* encrypted message & MAC at encrypt/decrypt-loop 999 */ \"d41eef105710ba88ef076f28e735cc672bde84505fbaeb0faa627ff5067a8609f829400edc18e70080d082eae6a1e2f6\");\n+\n+    // If the encrypted length is wrong, the MAC will help us catch a man-in-the-middle bit flipping attack. However, if the incorrect\n+    // length was encrypted by the sender, the cipher suite cannot help.\n     TestChaCha20Poly1305AEAD(true, 1,\n                              \"0100000000000000000000000000000000000000000000000000000000000000\",\n                              \"0000000000000000000000000000000000000000000000000000000000000000\",\n                              \"0000000000000000000000000000000000000000000000000000000000000000\",\n                              \"77b8e076b8e0ada0f13d90405d6ae55386bd28bdd219b8a08ded1aa836efcc8bfb6cf9dcd7e2ee807d5ff981eb4a135a\",\n                              \"c81eef105710ba88ef076f28e735cc672bde84505fbaeb0faa627ff5067a860942b2888c98e0c1003d0611e527776e88\");\n-    TestChaCha20Poly1305AEAD(true, 255,\n-                             \"ff0000f195e66982105ffb640bb7757f579da31602fc93ec01ac56f85ac3c134a4547b733b46413042c9440049176905d3be59ea1c53f15916155c2be8241a38008b9a26bc35941e2444177c8ade6689de95264986d95889fb60e84629c9bd9a5acb1cc118be563eb9b3a4a472f82e09a7e778492b562ef7130e88dfe031c79db9d4f7c7a899151b9a475032b63fc385245fe054e3dd5a97a5f576fe064025d3ce042c566ab2c507b138db853e3d6959660996546cc9c4a6eafdc777c040d70eaf46f76dad3979e5c5360c3317166a1c894c94a371876a94df7628fe4eaaf2ccb27d5aaae0ad7ad0f9d4b6ad3b54098746d4524d38407a6deb3ab78fab78c9\",\n+\n+    TestChaCha20Poly1305AEAD(true, 252,\n+                             \"fc0000f195e66982105ffb640bb7757f579da31602fc93ec01ac56f85ac3c134a4547b733b46413042c9440049176905d3be59ea1c53f15916155c2be8241a38008b9a26bc35941e2444177c8ade6689de95264986d95889fb60e84629c9bd9a5acb1cc118be563eb9b3a4a472f82e09a7e778492b562ef7130e88dfe031c79db9d4f7c7a899151b9a475032b63fc385245fe054e3dd5a97a5f576fe064025d3ce042c566ab2c507b138db853e3d6959660996546cc9c4a6eafdc777c040d70eaf46f76dad3979e5c5360c3317166a1c894c94a371876a94df7628fe4eaaf2ccb27d5aaae0ad7ad0f9d4b6ad3b54098746d4524d38407a6deb3ab78fab78c9\",\n                              \"ff0102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\",\n                              \"000102030405060708090a0b0c0d0e0f101112131415161718191a1b1c1d1e1f\",\n-                             \"3940c1c868cd145bd54691e9b6b402c78bd7ea9c3724fc50dfc69a4a96be8dec4e70e958188aa69222eaef3f47f8003f1bc13dcf9e661be8e1b671e9cf46ba705bca963e0477a5b3c2e2c66feb8207269ddb01b1372aad68563bb4aad135afb06fbe40b310b63bef578ff939f3a00a6da9e744d28ba070294e5746d2ca7bb8ac2c8e3a855ab4c9bcd0d5855e11b52cacaa2ddb34c0a26cd04f4bc10de6dc151d4ee7ced2c2b0de8ded33ff11f301e4027559e8938b69bceb1e5e259d4122056f6adbd48a0628b912f90d72838f2f3aaf6b88342cf5bac3cb688a9b0f7afc73a7e3cad8e71254c786ea000240ae7bd1df8bcfca07f3b885723a9d7f897364617ac8d935a41bf9546432360e1c543708\",\n-                             \"c5ab314a18d3b9eb02b7990e91adb4f005fb185d741277c066c4d002560dabea96b07009b1ae287931224e90fd70324fb02857019499f3d9ec774dd3f412a1ac13dc2f603e8b22abef71c9c7c688c1b7d835f76d32a32886f3326f70701f5b3617de21723a9d575bd572815696ad8410da643603a9a1c1a5aedc0c88ceb2c6610c685a4918e09f36f01c646f071c8ec668fd794ff4fc8bd671663a8e36a96ea8d4ea4c3d2893258237bddf7562af50785043cfb78e06cfe6d00145a46a76c9fedc450c776af4a4319ecb92ef818d2174baab3714cabb823a4c456cf51c0143a9451676db428b6b5aca7f8ff4a51fd717bc3293955aca0363ec663abdc8c8e7bd214de0e986fbb1e04de90db8dfb055\");\n+                             \"3a40c1c868cd145bd54691e9b6b402c78bd7ea9c3724fc50dfc69a4a96be8dec4e70e958188aa69222eaef3f47f8003f1bc13dcf9e661be8e1b671e9cf46ba705bca963e0477a5b3c2e2c66feb8207269ddb01b1372aad68563bb4aad135afb06fbe40b310b63bef578ff939f3a00a6da9e744d28ba070294e5746d2ca7bb8ac2c8e3a855ab4c9bcd0d5855e11b52cacaa2ddb34c0a26cd04f4bc10de6dc151d4ee7ced2c2b0de8ded33ff11f301e4027559e8938b69bceb1e5e259d4122056f6adbd48a0628b912f90d72838f2f3aaf6b88342cf5bac3cb688a9b0f7afc73a7e3cad8e71254c786ea000240ae7bd1df8bcfca07f3b885723a9d7f89736461917bb2791faffbe34650c8501daaef76\",\n+                             \"c6ab314a18d3b9eb02b7990e91adb4f005fb185d741277c066c4d002560dabea96b07009b1ae287931224e90fd70324fb02857019499f3d9ec774dd3f412a1ac13dc2f603e8b22abef71c9c7c688c1b7d835f76d32a32886f3326f70701f5b3617de21723a9d575bd572815696ad8410da643603a9a1c1a5aedc0c88ceb2c6610c685a4918e09f36f01c646f071c8ec668fd794ff4fc8bd671663a8e36a96ea8d4ea4c3d2893258237bddf7562af50785043cfb78e06cfe6d00145a46a76c9fedc450c776af4a4319ecb92ef818d2174baab3714cabb823a4c456cf51c0143a9451676db428b6b5aca7f8ff4a51fd717bc3293955aca0363ec663abdc8c8e7474f2e646d37ea226eb611c315bdee8b\");\n }\n \n BOOST_AUTO_TEST_CASE(countbits_tests)"
      }
    ]
  }
]