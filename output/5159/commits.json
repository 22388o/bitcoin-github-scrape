[
  {
    "sha": "b649e0395464a659f4b3485ec71d28dc95ba48bd",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNjQ5ZTAzOTU0NjRhNjU5ZjRiMzQ4NWVjNzFkMjhkYzk1YmE0OGJk",
    "commit": {
      "author": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2014-08-26T20:28:32Z"
      },
      "committer": {
        "name": "Alex Morcos",
        "email": "morcos@chaincode.com",
        "date": "2015-05-13T14:36:24Z"
      },
      "message": "Create new BlockPolicyEstimator for fee estimates\n\nThis class groups transactions that have been confirmed in blocks into buckets, based on either their fee or their priority.  Then for each bucket, the class calculates what percentage of the transactions were confirmed within various numbers of blocks.  It does this by keeping an exponentially decaying moving history for each bucket and confirm block count of the percentage of transactions in that bucket that were confirmed within that number of blocks.\n\n-Eliminate txs which didn't have all inputs available at entry from fee/pri calcs\n\n-Add dynamic breakpoints and tracking of confirmation delays in mempool transactions\n\n-Remove old CMinerPolicyEstimator and CBlockAverage code\n\n-New smartfees.py\n\n-Pass a flag to the estimation code, using IsInitialBlockDownload as a proxy for when we are still catching up and we shouldn't be counting how many blocks it takes for transactions to be included.\n\n-Add a policyestimator unit test",
      "tree": {
        "sha": "8242b7c17c274409b0dc9e16245e4b80ae298174",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8242b7c17c274409b0dc9e16245e4b80ae298174"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b649e0395464a659f4b3485ec71d28dc95ba48bd",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b649e0395464a659f4b3485ec71d28dc95ba48bd",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b649e0395464a659f4b3485ec71d28dc95ba48bd",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b649e0395464a659f4b3485ec71d28dc95ba48bd/comments",
    "author": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "morcos",
      "id": 4360349,
      "node_id": "MDQ6VXNlcjQzNjAzNDk=",
      "avatar_url": "https://avatars.githubusercontent.com/u/4360349?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/morcos",
      "html_url": "https://github.com/morcos",
      "followers_url": "https://api.github.com/users/morcos/followers",
      "following_url": "https://api.github.com/users/morcos/following{/other_user}",
      "gists_url": "https://api.github.com/users/morcos/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/morcos/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/morcos/subscriptions",
      "organizations_url": "https://api.github.com/users/morcos/orgs",
      "repos_url": "https://api.github.com/users/morcos/repos",
      "events_url": "https://api.github.com/users/morcos/events{/privacy}",
      "received_events_url": "https://api.github.com/users/morcos/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b6ea3bcede1cbbf89486b9d67329e0110c4624ae",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b6ea3bcede1cbbf89486b9d67329e0110c4624ae",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b6ea3bcede1cbbf89486b9d67329e0110c4624ae"
      }
    ],
    "stats": {
      "total": 1691,
      "additions": 1267,
      "deletions": 424
    },
    "files": [
      {
        "sha": "69f3c22c1759027e9b53edd3e9fe62cea0716b77",
        "filename": "qa/rpc-tests/smartfees.py",
        "status": "modified",
        "additions": 224,
        "deletions": 57,
        "changes": 281,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b649e0395464a659f4b3485ec71d28dc95ba48bd/qa/rpc-tests/smartfees.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b649e0395464a659f4b3485ec71d28dc95ba48bd/qa/rpc-tests/smartfees.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/smartfees.py?ref=b649e0395464a659f4b3485ec71d28dc95ba48bd",
        "patch": "@@ -1,5 +1,5 @@\n #!/usr/bin/env python2\n-# Copyright (c) 2014 The Bitcoin Core developers\n+# Copyright (c) 2014-2015 The Bitcoin Core developers\n # Distributed under the MIT software license, see the accompanying\n # file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n@@ -11,82 +11,249 @@\n from bitcoinrpc.authproxy import AuthServiceProxy, JSONRPCException\n from util import *\n \n+# Construct 2 trivial P2SH's and the ScriptSigs that spend them\n+# So we can create many many transactions without needing to spend\n+# time signing.\n+P2SH_1 = \"2MySexEGVzZpRgNQ1JdjdP5bRETznm3roQ2\" # P2SH of \"OP_1 OP_DROP\"\n+P2SH_2 = \"2NBdpwq8Aoo1EEKEXPNrKvr5xQr3M9UfcZA\" # P2SH of \"OP_2 OP_DROP\"\n+# Associated ScriptSig's to spend satisfy P2SH_1 and P2SH_2\n+# 4 bytes of OP_TRUE and push 2-byte redeem script of \"OP_1 OP_DROP\" or \"OP_2 OP_DROP\"\n+SCRIPT_SIG = [\"0451025175\", \"0451025275\"]\n+\n+def satoshi_round(amount):\n+    return  Decimal(amount).quantize(Decimal('0.00000001'), rounding=ROUND_DOWN)\n+\n+def small_txpuzzle_randfee(from_node, conflist, unconflist, amount, min_fee, fee_increment):\n+    '''\n+    Create and send a transaction with a random fee.\n+    The transaction pays to a trival P2SH script, and assumes that its inputs\n+    are of the same form.\n+    The function takes a list of confirmed outputs and unconfirmed outputs\n+    and attempts to use the confirmed list first for its inputs.\n+    It adds the newly created outputs to the unconfirmed list.\n+    Returns (raw transaction, fee)\n+    '''\n+    # It's best to exponentially distribute our random fees\n+    # because the buckets are exponentially spaced.\n+    # Exponentially distributed from 1-128 * fee_increment\n+    rand_fee = float(fee_increment)*(1.1892**random.randint(0,28))\n+    # Total fee ranges from min_fee to min_fee + 127*fee_increment\n+    fee = min_fee - fee_increment + satoshi_round(rand_fee)\n+    inputs = []\n+    total_in = Decimal(\"0.00000000\")\n+    while total_in <= (amount + fee) and len(conflist) > 0:\n+        t = conflist.pop(0)\n+        total_in += t[\"amount\"]\n+        inputs.append({ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"]} )\n+    if total_in <= amount + fee:\n+        while total_in <= (amount + fee) and len(unconflist) > 0:\n+            t = unconflist.pop(0)\n+            total_in += t[\"amount\"]\n+            inputs.append({ \"txid\" : t[\"txid\"], \"vout\" : t[\"vout\"]} )\n+        if total_in <= amount + fee:\n+            raise RuntimeError(\"Insufficient funds: need %d, have %d\"%(amount+fee, total_in))\n+    outputs = {}\n+    outputs[P2SH_1] = total_in - amount - fee\n+    outputs[P2SH_2] = amount\n+    rawtx = from_node.createrawtransaction(inputs, outputs)\n+    # Createrawtransaction constructions a transaction that is ready to be signed\n+    # These transactions don't need to be signed, but we still have to insert the ScriptSig\n+    # that will satisfy the ScriptPubKey.\n+    completetx = rawtx[0:10]\n+    inputnum = 0\n+    for inp in inputs:\n+        completetx += rawtx[10+82*inputnum:82+82*inputnum]\n+        completetx += SCRIPT_SIG[inp[\"vout\"]]\n+        completetx += rawtx[84+82*inputnum:92+82*inputnum]\n+        inputnum += 1\n+    completetx += rawtx[10+82*inputnum:]\n+    txid = from_node.sendrawtransaction(completetx, True)\n+    unconflist.append({ \"txid\" : txid, \"vout\" : 0 , \"amount\" : total_in - amount - fee})\n+    unconflist.append({ \"txid\" : txid, \"vout\" : 1 , \"amount\" : amount})\n+\n+    return (completetx, fee)\n+\n+def split_inputs(from_node, txins, txouts, initial_split = False):\n+    '''\n+    We need to generate a lot of very small inputs so we can generate a ton of transactions\n+    and they will have low priority.\n+    This function takes an input from txins, and creates and sends a transaction\n+    which splits the value into 2 outputs which are appended to txouts.\n+    '''\n+    prevtxout = txins.pop()\n+    inputs = []\n+    outputs = {}\n+    inputs.append({ \"txid\" : prevtxout[\"txid\"], \"vout\" : prevtxout[\"vout\"] })\n+    half_change = satoshi_round(prevtxout[\"amount\"]/2)\n+    rem_change = prevtxout[\"amount\"] - half_change  - Decimal(\"0.00001000\")\n+    outputs[P2SH_1] = half_change\n+    outputs[P2SH_2] = rem_change\n+    rawtx = from_node.createrawtransaction(inputs, outputs)\n+    # If this is the initial split we actually need to sign the transaction\n+    # Otherwise we just need to insert the property ScriptSig\n+    if (initial_split) :\n+        completetx = from_node.signrawtransaction(rawtx)[\"hex\"]\n+    else :\n+        completetx = rawtx[0:82] + SCRIPT_SIG[prevtxout[\"vout\"]] + rawtx[84:]\n+    txid = from_node.sendrawtransaction(completetx, True)\n+    txouts.append({ \"txid\" : txid, \"vout\" : 0 , \"amount\" : half_change})\n+    txouts.append({ \"txid\" : txid, \"vout\" : 1 , \"amount\" : rem_change})\n+\n+def check_estimates(node, fees_seen, max_invalid, print_estimates = True):\n+    '''\n+    This function calls estimatefee and verifies that the estimates\n+    meet certain invariants.\n+    '''\n+    all_estimates = [ node.estimatefee(i) for i in range(1,26) ]\n+    if print_estimates:\n+        print([str(all_estimates[e-1]) for e in [1,2,3,6,15,25]])\n+    delta = 1.0e-6 # account for rounding error\n+    last_e = max(fees_seen)\n+    for e in filter(lambda x: x >= 0, all_estimates):\n+        # Estimates should be within the bounds of what transactions fees actually were:\n+        if float(e)+delta < min(fees_seen) or float(e)-delta > max(fees_seen):\n+            raise AssertionError(\"Estimated fee (%f) out of range (%f,%f)\"\n+                                 %(float(e), min(fees_seen), max(fees_seen)))\n+        # Estimates should be monotonically decreasing\n+        if float(e)-delta > last_e:\n+            raise AssertionError(\"Estimated fee (%f) larger than last fee (%f) for lower number of confirms\"\n+                                 %(float(e),float(last_e)))\n+        last_e = e\n+    valid_estimate = False\n+    invalid_estimates = 0\n+    for e in all_estimates:\n+        if e >= 0:\n+            valid_estimate = True\n+        else:\n+            invalid_estimates += 1\n+        # Once we're at a high enough confirmation count that we can give an estimate\n+        # We should have estimates for all higher confirmation counts\n+        if valid_estimate and e < 0:\n+            raise AssertionError(\"Invalid estimate appears at higher confirm count than valid estimate\")\n+    # Check on the expected number of different confirmation counts\n+    # that we might not have valid estimates for\n+    if invalid_estimates > max_invalid:\n+        raise AssertionError(\"More than (%d) invalid estimates\"%(max_invalid))\n+    return all_estimates\n+\n+\n class EstimateFeeTest(BitcoinTestFramework):\n \n     def setup_network(self):\n+        '''\n+        We'll setup the network to have 3 nodes that all mine with different parameters.\n+        But first we need to use one node to create a lot of small low priority outputs\n+        which we will use to generate our transactions.\n+        '''\n         self.nodes = []\n-        self.nodes.append(start_node(0, self.options.tmpdir,\n-                            [\"-debug=mempool\", \"-debug=estimatefee\", \"-relaypriority=0\"]))\n-        # Node1 mines small-but-not-tiny blocks, and allows free transactions.\n+        # Use node0 to mine blocks for input splitting\n+        self.nodes.append(start_node(0, self.options.tmpdir, [\"-maxorphantx=1000\",\n+                                                              \"-relaypriority=0\", \"-whitelist=127.0.0.1\"]))\n+\n+        print(\"This test is time consuming, please be patient\")\n+        print(\"Splitting inputs to small size so we can generate low priority tx's\")\n+        self.txouts = []\n+        self.txouts2 = []\n+        # Split a coinbase into two transaction puzzle outputs\n+        split_inputs(self.nodes[0], self.nodes[0].listunspent(0), self.txouts, True)\n+\n+        # Mine\n+        while (len(self.nodes[0].getrawmempool()) > 0):\n+            self.nodes[0].generate(1)\n+\n+        # Repeatedly split those 2 outputs, doubling twice for each rep\n+        # Use txouts to monitor the available utxo, since these won't be tracked in wallet\n+        reps = 0\n+        while (reps < 5):\n+            #Double txouts to txouts2\n+            while (len(self.txouts)>0):\n+                split_inputs(self.nodes[0], self.txouts, self.txouts2)\n+            while (len(self.nodes[0].getrawmempool()) > 0):\n+                self.nodes[0].generate(1)\n+            #Double txouts2 to txouts\n+            while (len(self.txouts2)>0):\n+                split_inputs(self.nodes[0], self.txouts2, self.txouts)\n+            while (len(self.nodes[0].getrawmempool()) > 0):\n+                self.nodes[0].generate(1)\n+            reps += 1\n+        print(\"Finished splitting\")\n+\n+        # Now we can connect the other nodes, didn't want to connect them earlier\n+        # so the estimates would not be affected by the splitting transactions\n+        # Node1 mines small blocks but that are bigger than the expected transaction rate,\n+        # and allows free transactions.\n         # NOTE: the CreateNewBlock code starts counting block size at 1,000 bytes,\n-        # so blockmaxsize of 2,000 is really just 1,000 bytes (room enough for\n-        # 6 or 7 transactions)\n+        # (17k is room enough for 110 or so transactions)\n         self.nodes.append(start_node(1, self.options.tmpdir,\n-                                [\"-blockprioritysize=1500\", \"-blockmaxsize=2000\",\n-                                 \"-debug=mempool\", \"-debug=estimatefee\", \"-relaypriority=0\"]))\n+                                     [\"-blockprioritysize=1500\", \"-blockmaxsize=18000\",\n+                                      \"-maxorphantx=1000\", \"-relaypriority=0\", \"-debug=estimatefee\"]))\n         connect_nodes(self.nodes[1], 0)\n \n         # Node2 is a stingy miner, that\n-        # produces very small blocks (room for only 3 or so transactions)\n-        node2args = [ \"-blockprioritysize=0\", \"-blockmaxsize=1500\",\n-                      \"-debug=mempool\", \"-debug=estimatefee\", \"-relaypriority=0\"]\n+        # produces too small blocks (room for only 70 or so transactions)\n+        node2args = [\"-blockprioritysize=0\", \"-blockmaxsize=12000\", \"-maxorphantx=1000\", \"-relaypriority=0\"]\n+\n         self.nodes.append(start_node(2, self.options.tmpdir, node2args))\n-        connect_nodes(self.nodes[2], 0)\n+        connect_nodes(self.nodes[0], 2)\n+        connect_nodes(self.nodes[2], 1)\n \n         self.is_network_split = False\n         self.sync_all()\n-        \n+\n+    def transact_and_mine(self, numblocks, mining_node):\n+        min_fee = Decimal(\"0.00001\")\n+        # We will now mine numblocks blocks generating on average 100 transactions between each block\n+        # We shuffle our confirmed txout set before each set of transactions\n+        # small_txpuzzle_randfee will use the transactions that have inputs already in the chain when possible\n+        # resorting to tx's that depend on the mempool when those run out\n+        for i in range(numblocks):\n+            random.shuffle(self.confutxo)\n+            for j in range(random.randrange(100-50,100+50)):\n+                from_index = random.randint(1,2)\n+                (txhex, fee) = small_txpuzzle_randfee(self.nodes[from_index], self.confutxo,\n+                                                      self.memutxo, Decimal(\"0.005\"), min_fee, min_fee)\n+                tx_kbytes = (len(txhex)/2)/1000.0\n+                self.fees_per_kb.append(float(fee)/tx_kbytes)\n+            sync_mempools(self.nodes[0:3],.1)\n+            mined = mining_node.getblock(mining_node.generate(1)[0],True)[\"tx\"]\n+            sync_blocks(self.nodes[0:3],.1)\n+            #update which txouts are confirmed\n+            newmem = []\n+            for utx in self.memutxo:\n+                if utx[\"txid\"] in mined:\n+                    self.confutxo.append(utx)\n+                else:\n+                    newmem.append(utx)\n+            self.memutxo = newmem\n \n     def run_test(self):\n-        # Prime the memory pool with pairs of transactions\n-        # (high-priority, random fee and zero-priority, random fee)\n-        min_fee = Decimal(\"0.001\")\n-        fees_per_kb = [];\n-        for i in range(12):\n-            (txid, txhex, fee) = random_zeropri_transaction(self.nodes, Decimal(\"1.1\"),\n-                                                            min_fee, min_fee, 20)\n-            tx_kbytes = (len(txhex)/2)/1000.0\n-            fees_per_kb.append(float(fee)/tx_kbytes)\n-\n-        # Mine blocks with node2 until the memory pool clears:\n-        count_start = self.nodes[2].getblockcount()\n-        while len(self.nodes[2].getrawmempool()) > 0:\n-            self.nodes[2].generate(1)\n-            self.sync_all()\n-\n-        all_estimates = [ self.nodes[0].estimatefee(i) for i in range(1,20) ]\n-        print(\"Fee estimates, super-stingy miner: \"+str([str(e) for e in all_estimates]))\n+        self.fees_per_kb = []\n+        self.memutxo = []\n+        self.confutxo = self.txouts # Start with the set of confirmed txouts after splitting\n+        print(\"Checking estimates for 1/2/3/6/15/25 blocks\")\n+        print(\"Creating transactions and mining them with a huge block size\")\n+        # Create transactions and mine 20 big blocks with node 0 such that the mempool is always emptied\n+        self.transact_and_mine(30, self.nodes[0])\n+        check_estimates(self.nodes[1], self.fees_per_kb, 1)\n \n-        # Estimates should be within the bounds of what transactions fees actually were:\n-        delta = 1.0e-6 # account for rounding error\n-        for e in filter(lambda x: x >= 0, all_estimates):\n-            if float(e)+delta < min(fees_per_kb) or float(e)-delta > max(fees_per_kb):\n-                raise AssertionError(\"Estimated fee (%f) out of range (%f,%f)\"%(float(e), min_fee_kb, max_fee_kb))\n-\n-        # Generate transactions while mining 30 more blocks, this time with node1:\n-        for i in range(30):\n-            for j in range(random.randrange(6-4,6+4)):\n-                (txid, txhex, fee) = random_transaction(self.nodes, Decimal(\"1.1\"),\n-                                                        Decimal(\"0.0\"), min_fee, 20)\n-                tx_kbytes = (len(txhex)/2)/1000.0\n-                fees_per_kb.append(float(fee)/tx_kbytes)\n-            self.nodes[1].generate(1)\n-            self.sync_all()\n+        print(\"Creating transactions and mining them with a block size that can't keep up\")\n+        # Create transactions and mine 30 small blocks with node 2, but create txs faster than we can mine\n+        self.transact_and_mine(20, self.nodes[2])\n+        check_estimates(self.nodes[1], self.fees_per_kb, 3)\n \n-        all_estimates = [ self.nodes[0].estimatefee(i) for i in range(1,20) ]\n-        print(\"Fee estimates, more generous miner: \"+str([ str(e) for e in all_estimates]))\n-        for e in filter(lambda x: x >= 0, all_estimates):\n-            if float(e)+delta < min(fees_per_kb) or float(e)-delta > max(fees_per_kb):\n-                raise AssertionError(\"Estimated fee (%f) out of range (%f,%f)\"%(float(e), min_fee_kb, max_fee_kb))\n+        print(\"Creating transactions and mining them at a block size that is just big enough\")\n+        # Generate transactions while mining 40 more blocks, this time with node1\n+        # which mines blocks with capacity just above the rate that transactions are being created\n+        self.transact_and_mine(40, self.nodes[1])\n+        check_estimates(self.nodes[1], self.fees_per_kb, 2)\n \n         # Finish by mining a normal-sized block:\n-        while len(self.nodes[0].getrawmempool()) > 0:\n-            self.nodes[0].generate(1)\n-            self.sync_all()\n-\n-        final_estimates = [ self.nodes[0].estimatefee(i) for i in range(1,20) ]\n-        print(\"Final fee estimates: \"+str([ str(e) for e in final_estimates]))\n+        while len(self.nodes[1].getrawmempool()) > 0:\n+            self.nodes[1].generate(1)\n \n+        sync_blocks(self.nodes[0:3],.1)\n+        print(\"Final estimates after emptying mempools\")\n+        check_estimates(self.nodes[1], self.fees_per_kb, 2)\n \n if __name__ == '__main__':\n     EstimateFeeTest().main()"
      },
      {
        "sha": "ee6d3ca01465e34f8d5159664847679bf78e5efe",
        "filename": "qa/rpc-tests/util.py",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b649e0395464a659f4b3485ec71d28dc95ba48bd/qa/rpc-tests/util.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b649e0395464a659f4b3485ec71d28dc95ba48bd/qa/rpc-tests/util.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/qa/rpc-tests/util.py?ref=b649e0395464a659f4b3485ec71d28dc95ba48bd",
        "patch": "@@ -33,17 +33,17 @@ def check_json_precision():\n     if satoshis != 2000000000000003:\n         raise RuntimeError(\"JSON encode/decode loses precision\")\n \n-def sync_blocks(rpc_connections):\n+def sync_blocks(rpc_connections, wait=1):\n     \"\"\"\n     Wait until everybody has the same block count\n     \"\"\"\n     while True:\n         counts = [ x.getblockcount() for x in rpc_connections ]\n         if counts == [ counts[0] ]*len(counts):\n             break\n-        time.sleep(1)\n+        time.sleep(wait)\n \n-def sync_mempools(rpc_connections):\n+def sync_mempools(rpc_connections, wait=1):\n     \"\"\"\n     Wait until everybody has the same transactions in their memory\n     pools\n@@ -56,7 +56,7 @@ def sync_mempools(rpc_connections):\n                 num_match = num_match+1\n         if num_match == len(rpc_connections):\n             break\n-        time.sleep(1)\n+        time.sleep(wait)\n \n bitcoind_processes = {}\n "
      },
      {
        "sha": "9d9934618e7152ed4f01fdb74a0d2a08928855f0",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=b649e0395464a659f4b3485ec71d28dc95ba48bd",
        "patch": "@@ -105,6 +105,7 @@ BITCOIN_CORE_H = \\\n   netbase.h \\\n   net.h \\\n   noui.h \\\n+  policy/fees.h \\\n   pow.h \\\n   primitives/block.h \\\n   primitives/transaction.h \\\n@@ -181,6 +182,7 @@ libbitcoin_server_a_SOURCES = \\\n   miner.cpp \\\n   net.cpp \\\n   noui.cpp \\\n+  policy/fees.cpp \\\n   pow.cpp \\\n   rest.cpp \\\n   rpcblockchain.cpp \\"
      },
      {
        "sha": "6c14859d3c9ecdaf68b375941f502b806b63ad88",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=b649e0395464a659f4b3485ec71d28dc95ba48bd",
        "patch": "@@ -56,6 +56,7 @@ BITCOIN_TESTS =\\\n   test/multisig_tests.cpp \\\n   test/netbase_tests.cpp \\\n   test/pmt_tests.cpp \\\n+  test/policyestimator_tests.cpp \\\n   test/pow_tests.cpp \\\n   test/rpc_tests.cpp \\\n   test/sanity_tests.cpp \\"
      },
      {
        "sha": "45e6e4d25df7266537fa79f74e4e56b830c5f213",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=b649e0395464a659f4b3485ec71d28dc95ba48bd",
        "patch": "@@ -974,7 +974,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         CAmount nFees = nValueIn-nValueOut;\n         double dPriority = view.GetPriority(tx, chainActive.Height());\n \n-        CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height());\n+        CTxMemPoolEntry entry(tx, nFees, GetTime(), dPriority, chainActive.Height(), mempool.HasNoInputsOf(tx));\n         unsigned int nSize = entry.GetTxSize();\n \n         // Don't accept it if it can't get into a block\n@@ -1040,7 +1040,7 @@ bool AcceptToMemoryPool(CTxMemPool& pool, CValidationState &state, const CTransa\n         }\n \n         // Store transaction in memory\n-        pool.addUnchecked(hash, entry);\n+        pool.addUnchecked(hash, entry, !IsInitialBlockDownload());\n     }\n \n     SyncWithWallets(tx, NULL);\n@@ -2042,7 +2042,7 @@ bool static ConnectTip(CValidationState &state, CBlockIndex *pindexNew, CBlock *\n     LogPrint(\"bench\", \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001);\n     // Remove conflicting transactions from the mempool.\n     list<CTransaction> txConflicted;\n-    mempool.removeForBlock(pblock->vtx, pindexNew->nHeight, txConflicted);\n+    mempool.removeForBlock(pblock->vtx, pindexNew->nHeight, txConflicted, !IsInitialBlockDownload());\n     mempool.check(pcoinsTip);\n     // Update chainActive & related variables.\n     UpdateTip(pindexNew);"
      },
      {
        "sha": "b1491cec018fc3e18ee591eb126b9280a37b8ee1",
        "filename": "src/policy/fees.cpp",
        "status": "added",
        "additions": 529,
        "deletions": 0,
        "changes": 529,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=b649e0395464a659f4b3485ec71d28dc95ba48bd",
        "patch": "@@ -0,0 +1,529 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"policy/fees.h\"\n+\n+#include \"amount.h\"\n+#include \"primitives/transaction.h\"\n+#include \"streams.h\"\n+#include \"txmempool.h\"\n+#include \"util.h\"\n+\n+void TxConfirmStats::Initialize(std::vector<double>& defaultBuckets,\n+                                unsigned int maxConfirms, double _decay, std::string _dataTypeString)\n+{\n+    decay = _decay;\n+    dataTypeString = _dataTypeString;\n+    for (unsigned int i = 0; i < defaultBuckets.size(); i++) {\n+        buckets.push_back(defaultBuckets[i]);\n+        bucketMap[defaultBuckets[i]] = i;\n+    }\n+    confAvg.resize(maxConfirms);\n+    curBlockConf.resize(maxConfirms);\n+    unconfTxs.resize(maxConfirms);\n+    for (unsigned int i = 0; i < maxConfirms; i++) {\n+        confAvg[i].resize(buckets.size());\n+        curBlockConf[i].resize(buckets.size());\n+        unconfTxs[i].resize(buckets.size());\n+    }\n+\n+    oldUnconfTxs.resize(buckets.size());\n+    curBlockTxCt.resize(buckets.size());\n+    txCtAvg.resize(buckets.size());\n+    curBlockVal.resize(buckets.size());\n+    avg.resize(buckets.size());\n+}\n+\n+// Zero out the data for the current block\n+void TxConfirmStats::ClearCurrent(unsigned int nBlockHeight)\n+{\n+    for (unsigned int j = 0; j < buckets.size(); j++) {\n+        oldUnconfTxs[j] += unconfTxs[nBlockHeight%unconfTxs.size()][j];\n+        unconfTxs[nBlockHeight%unconfTxs.size()][j] = 0;\n+        for (unsigned int i = 0; i < curBlockConf.size(); i++)\n+            curBlockConf[i][j] = 0;\n+        curBlockTxCt[j] = 0;\n+        curBlockVal[j] = 0;\n+    }\n+}\n+\n+\n+void TxConfirmStats::Record(int blocksToConfirm, double val)\n+{\n+    // blocksToConfirm is 1-based\n+    if (blocksToConfirm < 1)\n+        return;\n+    unsigned int bucketindex = bucketMap.lower_bound(val)->second;\n+    for (size_t i = blocksToConfirm; i <= curBlockConf.size(); i++) {\n+        curBlockConf[i - 1][bucketindex]++;\n+    }\n+    curBlockTxCt[bucketindex]++;\n+    curBlockVal[bucketindex] += val;\n+}\n+\n+void TxConfirmStats::UpdateMovingAverages()\n+{\n+    for (unsigned int j = 0; j < buckets.size(); j++) {\n+        for (unsigned int i = 0; i < confAvg.size(); i++)\n+            confAvg[i][j] = confAvg[i][j] * decay + curBlockConf[i][j];\n+        avg[j] = avg[j] * decay + curBlockVal[j];\n+        txCtAvg[j] = txCtAvg[j] * decay + curBlockTxCt[j];\n+    }\n+}\n+\n+// returns -1 on error conditions\n+double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n+                                         double successBreakPoint, bool requireGreater,\n+                                         unsigned int nBlockHeight)\n+{\n+    // Counters for a bucket (or range of buckets)\n+    double nConf = 0; // Number of tx's confirmed within the confTarget\n+    double totalNum = 0; // Total number of tx's that were ever confirmed\n+    int extraNum = 0;  // Number of tx's still in mempool for confTarget or longer\n+\n+    int maxbucketindex = buckets.size() - 1;\n+\n+    // requireGreater means we are looking for the lowest fee/priority such that all higher\n+    // values pass, so we start at maxbucketindex (highest fee) and look at succesively\n+    // smaller buckets until we reach failure.  Otherwise, we are looking for the highest\n+    // fee/priority such that all lower values fail, and we go in the opposite direction.\n+    unsigned int startbucket = requireGreater ? maxbucketindex : 0;\n+    int step = requireGreater ? -1 : 1;\n+\n+    // We'll combine buckets until we have enough samples.\n+    // The near and far variables will define the range we've combined\n+    // The best variables are the last range we saw which still had a high\n+    // enough confirmation rate to count as success.\n+    // The cur variables are the current range we're counting.\n+    unsigned int curNearBucket = startbucket;\n+    unsigned int bestNearBucket = startbucket;\n+    unsigned int curFarBucket = startbucket;\n+    unsigned int bestFarBucket = startbucket;\n+\n+    bool foundAnswer = false;\n+    unsigned int bins = unconfTxs.size();\n+\n+    // Start counting from highest(default) or lowest fee/pri transactions\n+    for (int bucket = startbucket; bucket >= 0 && bucket <= maxbucketindex; bucket += step) {\n+        curFarBucket = bucket;\n+        nConf += confAvg[confTarget - 1][bucket];\n+        totalNum += txCtAvg[bucket];\n+        for (unsigned int confct = confTarget; confct < GetMaxConfirms(); confct++)\n+            extraNum += unconfTxs[(nBlockHeight - confct)%bins][bucket];\n+        extraNum += oldUnconfTxs[bucket];\n+        // If we have enough transaction data points in this range of buckets,\n+        // we can test for success\n+        // (Only count the confirmed data points, so that each confirmation count\n+        // will be looking at the same amount of data and same bucket breaks)\n+        if (totalNum >= sufficientTxVal / (1 - decay)) {\n+            double curPct = nConf / (totalNum + extraNum);\n+\n+            // Check to see if we are no longer getting confirmed at the success rate\n+            if (requireGreater && curPct < successBreakPoint)\n+                break;\n+            if (!requireGreater && curPct > successBreakPoint)\n+                break;\n+\n+            // Otherwise update the cumulative stats, and the bucket variables\n+            // and reset the counters\n+            else {\n+                foundAnswer = true;\n+                nConf = 0;\n+                totalNum = 0;\n+                extraNum = 0;\n+                bestNearBucket = curNearBucket;\n+                bestFarBucket = curFarBucket;\n+                curNearBucket = bucket + step;\n+            }\n+        }\n+    }\n+\n+    double median = -1;\n+    double txSum = 0;\n+\n+    // Calculate the \"average\" fee of the best bucket range that met success conditions\n+    // Find the bucket with the median transaction and then report the average fee from that bucket\n+    // This is a compromise between finding the median which we can't since we don't save all tx's\n+    // and reporting the average which is less accurate\n+    unsigned int minBucket = bestNearBucket < bestFarBucket ? bestNearBucket : bestFarBucket;\n+    unsigned int maxBucket = bestNearBucket > bestFarBucket ? bestNearBucket : bestFarBucket;\n+    for (unsigned int j = minBucket; j <= maxBucket; j++) {\n+        txSum += txCtAvg[j];\n+    }\n+    if (foundAnswer && txSum != 0) {\n+        txSum = txSum / 2;\n+        for (unsigned int j = minBucket; j <= maxBucket; j++) {\n+            if (txCtAvg[j] < txSum)\n+                txSum -= txCtAvg[j];\n+            else { // we're in the right bucket\n+                median = avg[j] / txCtAvg[j];\n+                break;\n+            }\n+        }\n+    }\n+\n+    LogPrint(\"estimatefee\", \"%3d: For conf success %s %4.2f need %s %s: %12.5g from buckets %8g - %8g  Cur Bucket stats %6.2f%%  %8.1f/(%.1f+%d mempool)\\n\",\n+             confTarget, requireGreater ? \">\" : \"<\", successBreakPoint, dataTypeString,\n+             requireGreater ? \">\" : \"<\", median, buckets[minBucket], buckets[maxBucket],\n+             100 * nConf / (totalNum + extraNum), nConf, totalNum, extraNum);\n+\n+    return median;\n+}\n+\n+void TxConfirmStats::Write(CAutoFile& fileout)\n+{\n+    fileout << decay;\n+    fileout << buckets;\n+    fileout << avg;\n+    fileout << txCtAvg;\n+    fileout << confAvg;\n+}\n+\n+void TxConfirmStats::Read(CAutoFile& filein)\n+{\n+    // Read data file into temporary variables and do some very basic sanity checking\n+    std::vector<double> fileBuckets;\n+    std::vector<double> fileAvg;\n+    std::vector<std::vector<double> > fileConfAvg;\n+    std::vector<double> fileTxCtAvg;\n+    double fileDecay;\n+    size_t maxConfirms;\n+    size_t numBuckets;\n+\n+    filein >> fileDecay;\n+    if (fileDecay <= 0 || fileDecay >= 1)\n+        throw std::runtime_error(\"Corrupt estimates file. Decay must be between 0 and 1 (non-inclusive)\");\n+    filein >> fileBuckets;\n+    numBuckets = fileBuckets.size();\n+    if (numBuckets <= 1 || numBuckets > 1000)\n+        throw std::runtime_error(\"Corrupt estimates file. Must have between 2 and 1000 fee/pri buckets\");\n+    filein >> fileAvg;\n+    if (fileAvg.size() != numBuckets)\n+        throw std::runtime_error(\"Corrupt estimates file. Mismatch in fee/pri average bucket count\");\n+    filein >> fileTxCtAvg;\n+    if (fileTxCtAvg.size() != numBuckets)\n+        throw std::runtime_error(\"Corrupt estimates file. Mismatch in tx count bucket count\");\n+    filein >> fileConfAvg;\n+    maxConfirms = fileConfAvg.size();\n+    if (maxConfirms <= 0 || maxConfirms > 6 * 24 * 7) // one week\n+        throw std::runtime_error(\"Corrupt estimates file.  Must maintain estimates for between 1 and 1008 (one week) confirms\");\n+    for (unsigned int i = 0; i < maxConfirms; i++) {\n+        if (fileConfAvg[i].size() != numBuckets)\n+            throw std::runtime_error(\"Corrupt estimates file. Mismatch in fee/pri conf average bucket count\");\n+    }\n+    // Now that we've processed the entire fee estimate data file and not\n+    // thrown any errors, we can copy it to our data structures\n+    decay = fileDecay;\n+    buckets = fileBuckets;\n+    avg = fileAvg;\n+    confAvg = fileConfAvg;\n+    txCtAvg = fileTxCtAvg;\n+    bucketMap.clear();\n+\n+    // Resize the current block variables which aren't stored in the data file\n+    // to match the number of confirms and buckets\n+    curBlockConf.resize(maxConfirms);\n+    for (unsigned int i = 0; i < maxConfirms; i++) {\n+        curBlockConf[i].resize(buckets.size());\n+    }\n+    curBlockTxCt.resize(buckets.size());\n+    curBlockVal.resize(buckets.size());\n+\n+    unconfTxs.resize(maxConfirms);\n+    for (unsigned int i = 0; i < maxConfirms; i++) {\n+        unconfTxs[i].resize(buckets.size());\n+    }\n+    oldUnconfTxs.resize(buckets.size());\n+\n+    for (unsigned int i = 0; i < buckets.size(); i++)\n+        bucketMap[buckets[i]] = i;\n+\n+    LogPrint(\"estimatefee\", \"Reading estimates: %u %s buckets counting confirms up to %u blocks\\n\",\n+             numBuckets, dataTypeString, maxConfirms);\n+}\n+\n+unsigned int TxConfirmStats::NewTx(unsigned int nBlockHeight, double val)\n+{\n+    unsigned int bucketindex = bucketMap.lower_bound(val)->second;\n+    unsigned int blockIndex = nBlockHeight % unconfTxs.size();\n+    unconfTxs[blockIndex][bucketindex]++;\n+    LogPrint(\"estimatefee\", \"adding to %s\\n\", dataTypeString);\n+    return bucketindex;\n+}\n+\n+void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight, unsigned int bucketindex)\n+{\n+    //nBestSeenHeight is not updated yet for the new block\n+    int blocksAgo = nBestSeenHeight - entryHeight;\n+    if (nBestSeenHeight == 0)  // the BlockPolicyEstimator hasn't seen any blocks yet\n+        blocksAgo = 0;\n+    if (blocksAgo < 0) {\n+        LogPrint(\"estimatefee\", \"Blockpolicy error, blocks ago is negative for mempool tx\\n\");\n+        return;  //This can't happen becasue we call this with our best seen height, no entries can have higher\n+    }\n+\n+    if (blocksAgo >= (int)unconfTxs.size()) {\n+        if (oldUnconfTxs[bucketindex] > 0)\n+            oldUnconfTxs[bucketindex]--;\n+        else\n+            LogPrint(\"estimatefee\", \"Blockpolicy error, mempool tx removed from >25 blocks,bucketIndex=%u already\\n\",\n+                     bucketindex);\n+    }\n+    else {\n+        unsigned int blockIndex = entryHeight % unconfTxs.size();\n+        if (unconfTxs[blockIndex][bucketindex] > 0)\n+            unconfTxs[blockIndex][bucketindex]--;\n+        else\n+            LogPrint(\"estimatefee\", \"Blockpolicy error, mempool tx removed from blockIndex=%u,bucketIndex=%u already\\n\",\n+                     blockIndex, bucketindex);\n+    }\n+}\n+\n+void CBlockPolicyEstimator::removeTx(uint256 hash)\n+{\n+    std::map<uint256, TxStatsInfo>::iterator pos = mapMemPoolTxs.find(hash);\n+    if (pos == mapMemPoolTxs.end()) {\n+        LogPrint(\"estimatefee\", \"Blockpolicy error mempool tx %s not found for removeTx\\n\",\n+                 hash.ToString().c_str());\n+        return;\n+    }\n+    TxConfirmStats *stats = pos->second.stats;\n+    unsigned int entryHeight = pos->second.blockHeight;\n+    unsigned int bucketIndex = pos->second.bucketIndex;\n+\n+    if (stats != NULL)\n+        stats->removeTx(entryHeight, nBestSeenHeight, bucketIndex);\n+    mapMemPoolTxs.erase(hash);\n+}\n+\n+CBlockPolicyEstimator::CBlockPolicyEstimator(const CFeeRate& _minRelayFee)\n+    : nBestSeenHeight(0)\n+{\n+    minTrackedFee = _minRelayFee < CFeeRate(MIN_FEERATE) ? CFeeRate(MIN_FEERATE) : _minRelayFee;\n+    std::vector<double> vfeelist;\n+    for (double bucketBoundary = minTrackedFee.GetFeePerK(); bucketBoundary <= MAX_FEERATE; bucketBoundary *= FEE_SPACING) {\n+        vfeelist.push_back(bucketBoundary);\n+    }\n+    vfeelist.push_back(INF_FEERATE);\n+    feeStats.Initialize(vfeelist, MAX_BLOCK_CONFIRMS, DEFAULT_DECAY, \"FeeRate\");\n+\n+    minTrackedPriority = AllowFreeThreshold() < MIN_PRIORITY ? MIN_PRIORITY : AllowFreeThreshold();\n+    std::vector<double> vprilist;\n+    for (double bucketBoundary = minTrackedPriority; bucketBoundary <= MAX_PRIORITY; bucketBoundary *= PRI_SPACING) {\n+        vprilist.push_back(bucketBoundary);\n+    }\n+    vprilist.push_back(INF_PRIORITY);\n+    priStats.Initialize(vprilist, MAX_BLOCK_CONFIRMS, DEFAULT_DECAY, \"Priority\");\n+\n+    feeUnlikely = CFeeRate(0);\n+    feeLikely = CFeeRate(INF_FEERATE);\n+    priUnlikely = 0;\n+    priLikely = INF_PRIORITY;\n+}\n+\n+bool CBlockPolicyEstimator::isFeeDataPoint(const CFeeRate &fee, double pri)\n+{\n+    if ((pri < minTrackedPriority && fee >= minTrackedFee) ||\n+        (pri < priUnlikely && fee > feeLikely)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+bool CBlockPolicyEstimator::isPriDataPoint(const CFeeRate &fee, double pri)\n+{\n+    if ((fee < minTrackedFee && pri >= minTrackedPriority) ||\n+        (fee < feeUnlikely && pri > priLikely)) {\n+        return true;\n+    }\n+    return false;\n+}\n+\n+void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, bool fCurrentEstimate)\n+{\n+    unsigned int txHeight = entry.GetHeight();\n+    uint256 hash = entry.GetTx().GetHash();\n+    if (mapMemPoolTxs[hash].stats != NULL) {\n+        LogPrint(\"estimatefee\", \"Blockpolicy error mempool tx %s already being tracked\\n\",\n+                 hash.ToString().c_str());\n+\treturn;\n+    }\n+\n+    if (txHeight < nBestSeenHeight) {\n+        // Ignore side chains and re-orgs; assuming they are random they don't\n+        // affect the estimate.  We'll potentially double count transactions in 1-block reorgs.\n+        return;\n+    }\n+\n+    // Only want to be updating estimates when our blockchain is synced,\n+    // otherwise we'll miscalculate how many blocks its taking to get included.\n+    if (!fCurrentEstimate)\n+        return;\n+\n+    if (!entry.WasClearAtEntry()) {\n+        // This transaction depends on other transactions in the mempool to\n+        // be included in a block before it will be able to be included, so\n+        // we shouldn't include it in our calculations\n+        return;\n+    }\n+\n+    // Fees are stored and reported as BTC-per-kb:\n+    CFeeRate feeRate(entry.GetFee(), entry.GetTxSize());\n+\n+    // Want the priority of the tx at confirmation. However we don't know\n+    // what that will be and its too hard to continue updating it\n+    // so use starting priority as a proxy\n+    double curPri = entry.GetPriority(txHeight);\n+    mapMemPoolTxs[hash].blockHeight = txHeight;\n+\n+    LogPrint(\"estimatefee\", \"Blockpolicy mempool tx %s \", hash.ToString().substr(0,10));\n+    // Record this as a priority estimate\n+    if (entry.GetFee() == 0 || isPriDataPoint(feeRate, curPri)) {\n+        mapMemPoolTxs[hash].stats = &priStats;\n+        mapMemPoolTxs[hash].bucketIndex =  priStats.NewTx(txHeight, curPri);\n+    }\n+    // Record this as a fee estimate\n+    else if (isFeeDataPoint(feeRate, curPri)) {\n+        mapMemPoolTxs[hash].stats = &feeStats;\n+        mapMemPoolTxs[hash].bucketIndex = feeStats.NewTx(txHeight, (double)feeRate.GetFeePerK());\n+    }\n+    else {\n+        LogPrint(\"estimatefee\", \"not adding\\n\");\n+    }\n+}\n+\n+void CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry& entry)\n+{\n+    if (!entry.WasClearAtEntry()) {\n+        // This transaction depended on other transactions in the mempool to\n+        // be included in a block before it was able to be included, so\n+        // we shouldn't include it in our calculations\n+        return;\n+    }\n+\n+    // How many blocks did it take for miners to include this transaction?\n+    // blocksToConfirm is 1-based, so a transaction included in the earliest\n+    // possible block has confirmation count of 1\n+    int blocksToConfirm = nBlockHeight - entry.GetHeight();\n+    if (blocksToConfirm <= 0) {\n+        // This can't happen because we don't process transactions from a block with a height\n+        // lower than our greatest seen height\n+        LogPrint(\"estimatefee\", \"Blockpolicy error Transaction had negative blocksToConfirm\\n\");\n+        return;\n+    }\n+\n+    // Fees are stored and reported as BTC-per-kb:\n+    CFeeRate feeRate(entry.GetFee(), entry.GetTxSize());\n+\n+    // Want the priority of the tx at confirmation.  The priority when it\n+    // entered the mempool could easily be very small and change quickly\n+    double curPri = entry.GetPriority(nBlockHeight);\n+\n+    // Record this as a priority estimate\n+    if (entry.GetFee() == 0 || isPriDataPoint(feeRate, curPri)) {\n+        priStats.Record(blocksToConfirm, curPri);\n+    }\n+    // Record this as a fee estimate\n+    else if (isFeeDataPoint(feeRate, curPri)) {\n+        feeStats.Record(blocksToConfirm, (double)feeRate.GetFeePerK());\n+    }\n+}\n+\n+void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n+                                         std::vector<CTxMemPoolEntry>& entries, bool fCurrentEstimate)\n+{\n+    if (nBlockHeight <= nBestSeenHeight) {\n+        // Ignore side chains and re-orgs; assuming they are random\n+        // they don't affect the estimate.\n+        // And if an attacker can re-org the chain at will, then\n+        // you've got much bigger problems than \"attacker can influence\n+        // transaction fees.\"\n+        return;\n+    }\n+    nBestSeenHeight = nBlockHeight;\n+\n+    // Only want to be updating estimates when our blockchain is synced,\n+    // otherwise we'll miscalculate how many blocks its taking to get included.\n+    if (!fCurrentEstimate)\n+        return;\n+\n+    // Update the dynamic cutoffs\n+    // a fee/priority is \"likely\" the reason your tx was included in a block if >85% of such tx's\n+    // were confirmed in 2 blocks and is \"unlikely\" if <50% were confirmed in 10 blocks\n+    LogPrint(\"estimatefee\", \"Blockpolicy recalculating dynamic cutoffs:\\n\");\n+    priLikely = priStats.EstimateMedianVal(2, SUFFICIENT_PRITXS, MIN_SUCCESS_PCT, true, nBlockHeight);\n+    if (priLikely == -1)\n+        priLikely = INF_PRIORITY;\n+\n+    double feeLikelyEst = feeStats.EstimateMedianVal(2, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT, true, nBlockHeight);\n+    if (feeLikelyEst == -1)\n+        feeLikely = CFeeRate(INF_FEERATE);\n+    else\n+        feeLikely = CFeeRate(feeLikelyEst);\n+\n+    priUnlikely = priStats.EstimateMedianVal(10, SUFFICIENT_PRITXS, UNLIKELY_PCT, false, nBlockHeight);\n+    if (priUnlikely == -1)\n+        priUnlikely = 0;\n+\n+    double feeUnlikelyEst = feeStats.EstimateMedianVal(10, SUFFICIENT_FEETXS, UNLIKELY_PCT, false, nBlockHeight);\n+    if (feeUnlikelyEst == -1)\n+        feeUnlikely = CFeeRate(0);\n+    else\n+        feeUnlikely = CFeeRate(feeUnlikelyEst);\n+\n+    // Clear the current block states\n+    feeStats.ClearCurrent(nBlockHeight);\n+    priStats.ClearCurrent(nBlockHeight);\n+\n+    // Repopulate the current block states\n+    for (unsigned int i = 0; i < entries.size(); i++)\n+        processBlockTx(nBlockHeight, entries[i]);\n+\n+    // Update all exponential averages with the current block states\n+    feeStats.UpdateMovingAverages();\n+    priStats.UpdateMovingAverages();\n+\n+    LogPrint(\"estimatefee\", \"Blockpolicy after updating estimates for %u confirmed entries, new mempool map size %u\\n\",\n+             entries.size(), mapMemPoolTxs.size());\n+}\n+\n+CFeeRate CBlockPolicyEstimator::estimateFee(int confTarget)\n+{\n+    // Return failure if trying to analyze a target we're not tracking\n+    if (confTarget <= 0 || (unsigned int)confTarget > feeStats.GetMaxConfirms())\n+        return CFeeRate(0);\n+\n+    double median = feeStats.EstimateMedianVal(confTarget, SUFFICIENT_FEETXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);\n+\n+    if (median < 0)\n+        return CFeeRate(0);\n+\n+    return CFeeRate(median);\n+}\n+\n+double CBlockPolicyEstimator::estimatePriority(int confTarget)\n+{\n+    // Return failure if trying to analyze a target we're not tracking\n+    if (confTarget <= 0 || (unsigned int)confTarget > priStats.GetMaxConfirms())\n+        return -1;\n+\n+    return priStats.EstimateMedianVal(confTarget, SUFFICIENT_PRITXS, MIN_SUCCESS_PCT, true, nBestSeenHeight);\n+}\n+\n+void CBlockPolicyEstimator::Write(CAutoFile& fileout)\n+{\n+    fileout << nBestSeenHeight;\n+    feeStats.Write(fileout);\n+    priStats.Write(fileout);\n+}\n+\n+void CBlockPolicyEstimator::Read(CAutoFile& filein)\n+{\n+    int nFileBestSeenHeight;\n+    filein >> nFileBestSeenHeight;\n+    feeStats.Read(filein);\n+    priStats.Read(filein);\n+    nBestSeenHeight = nFileBestSeenHeight;\n+}"
      },
      {
        "sha": "ce4d7825662d68d14c0f7a7772e3e3082b225da7",
        "filename": "src/policy/fees.h",
        "status": "added",
        "additions": 276,
        "deletions": 0,
        "changes": 276,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=b649e0395464a659f4b3485ec71d28dc95ba48bd",
        "patch": "@@ -0,0 +1,276 @@\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2015 The Bitcoin developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+#ifndef BITCOIN_POLICYESTIMATOR_H\n+#define BITCOIN_POLICYESTIMATOR_H\n+\n+#include \"amount.h\"\n+#include \"uint256.h\"\n+\n+#include <map>\n+#include <string>\n+#include <vector>\n+\n+class CAutoFile;\n+class CFeeRate;\n+class CTxMemPoolEntry;\n+\n+/** \\class CBlockPolicyEstimator\n+ * The BlockPolicyEstimator is used for estimating the fee or priority needed\n+ * for a transaction to be included in a block within a certain number of\n+ * blocks.\n+ *\n+ * At a high level the algorithm works by grouping transactions into buckets\n+ * based on having similar priorities or fees and then tracking how long it\n+ * takes transactions in the various buckets to be mined.  It operates under\n+ * the assumption that in general transactions of higher fee/priority will be\n+ * included in blocks before transactions of lower fee/priority.   So for\n+ * example if you wanted to know what fee you should put on a transaction to\n+ * be included in a block within the next 5 blocks, you would start by looking\n+ * at the bucket with with the highest fee transactions and verifying that a\n+ * sufficiently high percentage of them were confirmed within 5 blocks and\n+ * then you would look at the next highest fee bucket, and so on, stopping at\n+ * the last bucket to pass the test.   The average fee of transactions in this\n+ * bucket will give you an indication of the lowest fee you can put on a\n+ * transaction and still have a sufficiently high chance of being confirmed\n+ * within your desired 5 blocks.\n+ *\n+ * When a transaction enters the mempool or is included within a block we\n+ * decide whether it can be used as a data point for fee estimation, priority\n+ * estimation or neither.  If the value of exactly one of those properties was\n+ * below the required minimum it can be used to estimate the other.  In\n+ * addition, if a priori our estimation code would indicate that the\n+ * transaction would be much more quickly included in a block because of one\n+ * of the properties compared to the other, we can also decide to use it as\n+ * an estimate for that property.\n+ *\n+ * Here is a brief description of the implementation for fee estimation.\n+ * When a transaction that counts for fee estimation enters the mempool, we\n+ * track the height of the block chain at entry.  Whenever a block comes in,\n+ * we count the number of transactions in each bucket and the total amount of fee\n+ * paid in each bucket. Then we calculate how many blocks Y it took each\n+ * transaction to be mined and we track an array of counters in each bucket\n+ * for how long it to took transactions to get confirmed from 1 to a max of 25\n+ * and we increment all the counters from Y up to 25. This is because for any\n+ * number Z>=Y the transaction was successfully mined within Z blocks.  We\n+ * want to save a history of this information, so at any time we have a\n+ * counter of the total number of transactions that happened in a given fee\n+ * bucket and the total number that were confirmed in each number 1-25 blocks\n+ * or less for any bucket.   We save this history by keeping an exponentially\n+ * decaying moving average of each one of these stats.  Furthermore we also\n+ * keep track of the number unmined (in mempool) transactions in each bucket\n+ * and for how many blocks they have been outstanding and use that to increase\n+ * the number of transactions we've seen in that fee bucket when calculating\n+ * an estimate for any number of confirmations below the number of blocks\n+ * they've been outstanding.\n+ */\n+\n+/**\n+ * We will instantiate two instances of this class, one to track transactions\n+ * that were included in a block due to fee, and one for tx's included due to\n+ * priority.  We will lump transactions into a bucket according to their approximate\n+ * fee or priority and then track how long it took for those txs to be included in a block\n+ *\n+ * The tracking of unconfirmed (mempool) transactions is completely independent of the\n+ * historical tracking of transactions that have been confirmed in a block.\n+ */\n+class TxConfirmStats\n+{\n+private:\n+    //Define the buckets we will group transactions into (both fee buckets and priority buckets)\n+    std::vector<double> buckets;              // The upper-bound of the range for the bucket (inclusive)\n+    std::map<double, unsigned int> bucketMap; // Map of bucket upper-bound to index into all vectors by bucket\n+\n+    // For each bucket X:\n+    // Count the total # of txs in each bucket\n+    // Track the historical moving average of this total over blocks\n+    std::vector<double> txCtAvg;\n+    // and calcuate the total for the current block to update the moving average\n+    std::vector<int> curBlockTxCt;\n+\n+    // Count the total # of txs confirmed within Y blocks in each bucket\n+    // Track the historical moving average of theses totals over blocks\n+    std::vector<std::vector<double> > confAvg; // confAvg[Y][X]\n+    // and calcuate the totals for the current block to update the moving averages\n+    std::vector<std::vector<int> > curBlockConf; // curBlockConf[Y][X]\n+\n+    // Sum the total priority/fee of all tx's in each bucket\n+    // Track the historical moving average of this total over blocks\n+    std::vector<double> avg;\n+    // and calculate the total for the current block to update the moving average\n+    std::vector<double> curBlockVal;\n+\n+    // Combine the conf counts with tx counts to calculate the confirmation % for each Y,X\n+    // Combine the total value with the tx counts to calculate the avg fee/priority per bucket\n+\n+    std::string dataTypeString;\n+    double decay;\n+\n+    // Mempool counts of outstanding transactions\n+    // For each bucket X, track the number of transactions in the mempool\n+    // that are unconfirmed for each possible confirmation value Y\n+    std::vector<std::vector<int> > unconfTxs;  //unconfTxs[Y][X]\n+    // transactions still unconfirmed after MAX_CONFIRMS for each bucket\n+    std::vector<int> oldUnconfTxs;\n+\n+public:\n+    /**\n+     * Initialize the data structures.  This is called by BlockPolicyEstimator's\n+     * constructor with default values.\n+     * @param defaultBuckets contains the upper limits for the bucket boundries\n+     * @param maxConfirms max number of confirms to track\n+     * @param decay how much to decay the historical moving average per block\n+     * @param dataTypeString for logging purposes\n+     */\n+    void Initialize(std::vector<double>& defaultBuckets, unsigned int maxConfirms, double decay, std::string dataTypeString);\n+\n+    /** Clear the state of the curBlock variables to start counting for the new block */\n+    void ClearCurrent(unsigned int nBlockHeight);\n+\n+    /**\n+     * Record a new transaction data point in the current block stats\n+     * @param blocksToConfirm the number of blocks it took this transaction to confirm\n+     * @param val either the fee or the priority when entered of the transaction\n+     * @warning blocksToConfirm is 1-based and has to be >= 1\n+     */\n+    void Record(int blocksToConfirm, double val);\n+\n+    /** Record a new transaction entering the mempool*/\n+    unsigned int NewTx(unsigned int nBlockHeight, double val);\n+\n+    /** Remove a transaction from mempool tracking stats*/\n+    void removeTx(unsigned int entryHeight, unsigned int nBestSeenHeight,\n+                  unsigned int bucketIndex);\n+\n+    /** Update our estimates by decaying our historical moving average and updating\n+        with the data gathered from the current block */\n+    void UpdateMovingAverages();\n+\n+    /**\n+     * Calculate a fee or priority estimate.  Find the lowest value bucket (or range of buckets\n+     * to make sure we have enough data points) whose transactions still have sufficient likelihood\n+     * of being confirmed within the target number of confirmations\n+     * @param confTarget target number of confirmations\n+     * @param sufficientTxVal required average number of transactions per block in a bucket range\n+     * @param minSuccess the success probability we require\n+     * @param requireGreater return the lowest fee/pri such that all higher values pass minSuccess OR\n+     *        return the highest fee/pri such that all lower values fail minSuccess\n+     * @param nBlockHeight the current block height\n+     */\n+    double EstimateMedianVal(int confTarget, double sufficientTxVal,\n+                             double minSuccess, bool requireGreater, unsigned int nBlockHeight);\n+\n+    /** Return the max number of confirms we're tracking */\n+    unsigned int GetMaxConfirms() { return confAvg.size(); }\n+\n+    /** Write state of estimation data to a file*/\n+    void Write(CAutoFile& fileout);\n+\n+    /**\n+     * Read saved state of estimation data from a file and replace all internal data structures and\n+     * variables with this state.\n+     */\n+    void Read(CAutoFile& filein);\n+};\n+\n+\n+\n+/** Track confirm delays up to 25 blocks, can't estimate beyond that */\n+static const unsigned int MAX_BLOCK_CONFIRMS = 25;\n+\n+/** Decay of .998 is a half-life of 346 blocks or about 2.4 days */\n+static const double DEFAULT_DECAY = .998;\n+\n+/** Require greater than 85% of X fee transactions to be confirmed within Y blocks for X to be big enough */\n+static const double MIN_SUCCESS_PCT = .85;\n+static const double UNLIKELY_PCT = .5;\n+\n+/** Require an avg of 1 tx in the combined fee bucket per block to have stat significance */\n+static const double SUFFICIENT_FEETXS = 1;\n+\n+/** Require only an avg of 1 tx every 5 blocks in the combined pri bucket (way less pri txs) */\n+static const double SUFFICIENT_PRITXS = .2;\n+\n+// Minimum and Maximum values for tracking fees and priorities\n+static const double MIN_FEERATE = 10;\n+static const double MAX_FEERATE = 1e7;\n+static const double INF_FEERATE = MAX_MONEY;\n+static const double MIN_PRIORITY = 10;\n+static const double MAX_PRIORITY = 1e16;\n+static const double INF_PRIORITY = 1e9 * MAX_MONEY;\n+\n+// We have to lump transactions into buckets based on fee or priority, but we want to be able\n+// to give accurate estimates over a large range of potential fees and priorities\n+// Therefore it makes sense to exponentially space the buckets\n+/** Spacing of FeeRate buckets */\n+static const double FEE_SPACING = 1.1;\n+\n+/** Spacing of Priority buckets */\n+static const double PRI_SPACING = 2;\n+\n+/**\n+ *  We want to be able to estimate fees or priorities that are needed on tx's to be included in\n+ * a certain number of blocks.  Every time a block is added to the best chain, this class records\n+ * stats on the transactions included in that block\n+ */\n+class CBlockPolicyEstimator\n+{\n+public:\n+    /** Create new BlockPolicyEstimator and initialize stats tracking classes with default values */\n+    CBlockPolicyEstimator(const CFeeRate& minRelayFee);\n+\n+    /** Process all the transactions that have been included in a block */\n+    void processBlock(unsigned int nBlockHeight,\n+                      std::vector<CTxMemPoolEntry>& entries, bool fCurrentEstimate);\n+\n+    /** Process a transaction confirmed in a block*/\n+    void processBlockTx(unsigned int nBlockHeight, const CTxMemPoolEntry& entry);\n+\n+    /** Process a transaction accepted to the mempool*/\n+    void processTransaction(const CTxMemPoolEntry& entry, bool fCurrentEstimate);\n+\n+    /** Remove a transaction from the mempool tracking stats*/\n+    void removeTx(uint256 hash);\n+\n+    /** Is this transaction likely included in a block because of its fee?*/\n+    bool isFeeDataPoint(const CFeeRate &fee, double pri);\n+\n+    /** Is this transaction likely included in a block because of its priority?*/\n+    bool isPriDataPoint(const CFeeRate &fee, double pri);\n+\n+    /** Return a fee estimate */\n+    CFeeRate estimateFee(int confTarget);\n+\n+    /** Return a priority estimate */\n+    double estimatePriority(int confTarget);\n+\n+    /** Write estimation data to a file */\n+    void Write(CAutoFile& fileout);\n+\n+    /** Read estimation data from a file */\n+    void Read(CAutoFile& filein);\n+\n+private:\n+    CFeeRate minTrackedFee; //! Passed to constructor to avoid dependency on main\n+    double minTrackedPriority; //! Set to AllowFreeThreshold\n+    unsigned int nBestSeenHeight;\n+    struct TxStatsInfo\n+    {\n+        TxConfirmStats *stats;\n+        unsigned int blockHeight;\n+        unsigned int bucketIndex;\n+        TxStatsInfo() : stats(NULL), blockHeight(0), bucketIndex(0) {}\n+    };\n+\n+    // map of txids to information about that transaction\n+    std::map<uint256, TxStatsInfo> mapMemPoolTxs;\n+\n+    /** Classes to track historical data on transaction confirmations */\n+    TxConfirmStats feeStats, priStats;\n+\n+    /** Breakpoints to help determine whether a transaction was confirmed by priority or Fee */\n+    CFeeRate feeLikely, feeUnlikely;\n+    double priLikely, priUnlikely;\n+};\n+#endif /*BITCOIN_POLICYESTIMATOR_H */"
      },
      {
        "sha": "cb64ee7c69dfa1444f93d6db863b13c03490870d",
        "filename": "src/test/policyestimator_tests.cpp",
        "status": "added",
        "additions": 186,
        "deletions": 0,
        "changes": 186,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/test/policyestimator_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/test/policyestimator_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/policyestimator_tests.cpp?ref=b649e0395464a659f4b3485ec71d28dc95ba48bd",
        "patch": "@@ -0,0 +1,186 @@\n+// Copyright (c) 2011-2015 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"policy/fees.h\"\n+#include \"txmempool.h\"\n+#include \"uint256.h\"\n+#include \"util.h\"\n+\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/test/unit_test.hpp>\n+\n+BOOST_FIXTURE_TEST_SUITE(policyestimator_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(BlockPolicyEstimates)\n+{\n+    CTxMemPool mpool(CFeeRate(1000));\n+    CAmount basefee(2000);\n+    double basepri = 1e6;\n+    CAmount deltaFee(100);\n+    double deltaPri=5e5;\n+    std::vector<CAmount> feeV[2];\n+    std::vector<double> priV[2];\n+\n+    // Populate vectors of increasing fees or priorities\n+    for (int j = 0; j < 10; j++) {\n+        //V[0] is for fee transactions\n+        feeV[0].push_back(basefee * (j+1));\n+        priV[0].push_back(0);\n+        //V[1] is for priority transactions\n+        feeV[1].push_back(CAmount(0));\n+        priV[1].push_back(basepri * pow(10, j+1));\n+    }\n+\n+    // Store the hashes of transactions that have been\n+    // added to the mempool by their associate fee/pri\n+    // txHashes[j] is populated with transactions either of\n+    // fee = basefee * (j+1)  OR  pri = 10^6 * 10^(j+1)\n+    std::vector<uint256> txHashes[10];\n+\n+    // Create a transaction template\n+    CScript garbage;\n+    for (unsigned int i = 0; i < 128; i++)\n+        garbage.push_back('X');\n+    CMutableTransaction tx;\n+    std::list<CTransaction> dummyConflicted;\n+    tx.vin.resize(1);\n+    tx.vin[0].scriptSig = garbage;\n+    tx.vout.resize(1);\n+    tx.vout[0].nValue=0LL;\n+    CFeeRate baseRate(basefee, ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n+\n+    // Create a fake block\n+    std::vector<CTransaction> block;\n+    int blocknum = 0;\n+\n+    // Loop through 200 blocks\n+    // At a decay .998 and 4 fee transactions per block\n+    // This makes the tx count about 1.33 per bucket, above the 1 threshold\n+    while (blocknum < 200) {\n+        for (int j = 0; j < 10; j++) { // For each fee/pri multiple\n+            for (int k = 0; k < 5; k++) { // add 4 fee txs for every priority tx\n+                tx.vin[0].prevout.n = 10000*blocknum+100*j+k; // make transaction unique\n+                uint256 hash = tx.GetHash();\n+                mpool.addUnchecked(hash, CTxMemPoolEntry(tx, feeV[k/4][j], GetTime(), priV[k/4][j], blocknum, mpool.HasNoInputsOf(tx)));\n+                txHashes[j].push_back(hash);\n+            }\n+        }\n+        //Create blocks where higher fee/pri txs are included more often\n+        for (int h = 0; h <= blocknum%10; h++) {\n+            // 10/10 blocks add highest fee/pri transactions\n+            // 9/10 blocks add 2nd highest and so on until ...\n+            // 1/10 blocks add lowest fee/pri transactions\n+            while (txHashes[9-h].size()) {\n+                CTransaction btx;\n+                if (mpool.lookup(txHashes[9-h].back(), btx))\n+                    block.push_back(btx);\n+                txHashes[9-h].pop_back();\n+            }\n+        }\n+        mpool.removeForBlock(block, ++blocknum, dummyConflicted);\n+        block.clear();\n+        if (blocknum == 30) {\n+            // At this point we should need to combine 5 buckets to get enough data points\n+            // So estimateFee(1) should fail and estimateFee(2) should return somewhere around\n+            // 8*baserate\n+            BOOST_CHECK(mpool.estimateFee(1) == CFeeRate(0));\n+            BOOST_CHECK(mpool.estimateFee(2).GetFeePerK() < 8*baseRate.GetFeePerK() + deltaFee);\n+            BOOST_CHECK(mpool.estimateFee(2).GetFeePerK() > 8*baseRate.GetFeePerK() - deltaFee);\n+        }\n+    }\n+\n+    std::vector<CAmount> origFeeEst;\n+    std::vector<double> origPriEst;\n+    // Highest feerate is 10*baseRate and gets in all blocks,\n+    // second highest feerate is 9*baseRate and gets in 9/10 blocks = 90%,\n+    // third highest feerate is 8*base rate, and gets in 8/10 blocks = 80%,\n+    // so estimateFee(1) should return 9*baseRate.\n+    // Third highest feerate has 90% chance of being included by 2 blocks,\n+    // so estimateFee(2) should return 8*baseRate etc...\n+    for (int i = 1; i < 10;i++) {\n+        origFeeEst.push_back(mpool.estimateFee(i).GetFeePerK());\n+        origPriEst.push_back(mpool.estimatePriority(i));\n+        if (i > 1) { // Fee estimates should be monotonically decreasing\n+            BOOST_CHECK(origFeeEst[i-1] <= origFeeEst[i-2]);\n+            BOOST_CHECK(origPriEst[i-1] <= origPriEst[i-2]);\n+        }\n+        BOOST_CHECK(origFeeEst[i-1] < (10-i)*baseRate.GetFeePerK() + deltaFee);\n+        BOOST_CHECK(origFeeEst[i-1] > (10-i)*baseRate.GetFeePerK() - deltaFee);\n+        BOOST_CHECK(origPriEst[i-1] < pow(10,10-i) * basepri + deltaPri);\n+        BOOST_CHECK(origPriEst[i-1] > pow(10,10-i) * basepri - deltaPri);\n+    }\n+\n+    // Mine 50 more blocks with no transactions happening, estimates shouldn't change\n+    // We haven't decayed the moving average enough so we still have enough data points in every bucket\n+    while (blocknum < 250)\n+        mpool.removeForBlock(block, ++blocknum, dummyConflicted);\n+\n+    for (int i = 1; i < 10;i++) {\n+        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() < origFeeEst[i-1] + deltaFee);\n+        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n+        BOOST_CHECK(mpool.estimatePriority(i) < origPriEst[i-1] + deltaPri);\n+        BOOST_CHECK(mpool.estimatePriority(i) > origPriEst[i-1] - deltaPri);\n+    }\n+\n+\n+    // Mine 15 more blocks with lots of transactions happening and not getting mined\n+    // Estimates should go up\n+    while (blocknum < 265) {\n+        for (int j = 0; j < 10; j++) { // For each fee/pri multiple\n+            for (int k = 0; k < 5; k++) { // add 4 fee txs for every priority tx\n+                tx.vin[0].prevout.n = 10000*blocknum+100*j+k;\n+                uint256 hash = tx.GetHash();\n+                mpool.addUnchecked(hash, CTxMemPoolEntry(tx, feeV[k/4][j], GetTime(), priV[k/4][j], blocknum, mpool.HasNoInputsOf(tx)));\n+                txHashes[j].push_back(hash);\n+            }\n+        }\n+        mpool.removeForBlock(block, ++blocknum, dummyConflicted);\n+    }\n+\n+    for (int i = 1; i < 10;i++) {\n+        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n+        BOOST_CHECK(mpool.estimatePriority(i) > origPriEst[i-1] - deltaPri);\n+    }\n+\n+    // Mine all those transactions\n+    // Estimates should still not be below original\n+    for (int j = 0; j < 10; j++) {\n+        while(txHashes[j].size()) {\n+            CTransaction btx;\n+            if (mpool.lookup(txHashes[j].back(), btx))\n+                block.push_back(btx);\n+            txHashes[j].pop_back();\n+        }\n+    }\n+    mpool.removeForBlock(block, 265, dummyConflicted);\n+    block.clear();\n+    for (int i = 1; i < 10;i++) {\n+        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() > origFeeEst[i-1] - deltaFee);\n+        BOOST_CHECK(mpool.estimatePriority(i) > origPriEst[i-1] - deltaPri);\n+    }\n+\n+    // Mine 100 more blocks where everything is mined every block\n+    // Estimates should be below original estimates (not possible for last estimate)\n+    while (blocknum < 365) {\n+        for (int j = 0; j < 10; j++) { // For each fee/pri multiple\n+            for (int k = 0; k < 5; k++) { // add 4 fee txs for every priority tx\n+                tx.vin[0].prevout.n = 10000*blocknum+100*j+k;\n+                uint256 hash = tx.GetHash();\n+                mpool.addUnchecked(hash, CTxMemPoolEntry(tx, feeV[k/4][j], GetTime(), priV[k/4][j], blocknum, mpool.HasNoInputsOf(tx)));\n+                CTransaction btx;\n+                if (mpool.lookup(hash, btx))\n+                    block.push_back(btx);\n+            }\n+        }\n+        mpool.removeForBlock(block, ++blocknum, dummyConflicted);\n+        block.clear();\n+    }\n+    for (int i = 1; i < 9; i++) {\n+        BOOST_CHECK(mpool.estimateFee(i).GetFeePerK() < origFeeEst[i-1] - deltaFee);\n+        BOOST_CHECK(mpool.estimatePriority(i) < origPriEst[i-1] - deltaPri);\n+    }\n+}\n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "53992b80dad88eae03c20415afb6249d2866d2fe",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 29,
        "deletions": 353,
        "changes": 382,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=b649e0395464a659f4b3485ec71d28dc95ba48bd",
        "patch": "@@ -7,28 +7,27 @@\n \n #include \"clientversion.h\"\n #include \"main.h\"\n+#include \"policy/fees.h\"\n #include \"streams.h\"\n #include \"util.h\"\n #include \"utilmoneystr.h\"\n #include \"version.h\"\n \n-#include <boost/circular_buffer.hpp>\n-\n using namespace std;\n \n CTxMemPoolEntry::CTxMemPoolEntry():\n-    nFee(0), nTxSize(0), nModSize(0), nTime(0), dPriority(0.0)\n+    nFee(0), nTxSize(0), nModSize(0), nTime(0), dPriority(0.0), hadNoDependencies(false)\n {\n     nHeight = MEMPOOL_HEIGHT;\n }\n \n CTxMemPoolEntry::CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n                                  int64_t _nTime, double _dPriority,\n-                                 unsigned int _nHeight):\n-    tx(_tx), nFee(_nFee), nTime(_nTime), dPriority(_dPriority), nHeight(_nHeight)\n+                                 unsigned int _nHeight, bool poolHasNoInputsOf):\n+    tx(_tx), nFee(_nFee), nTime(_nTime), dPriority(_dPriority), nHeight(_nHeight),\n+    hadNoDependencies(poolHasNoInputsOf)\n {\n     nTxSize = ::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION);\n-\n     nModSize = tx.CalculateModifiedSize(nTxSize);\n }\n \n@@ -46,346 +45,15 @@ CTxMemPoolEntry::GetPriority(unsigned int currentHeight) const\n     return dResult;\n }\n \n-/**\n- * Keep track of fee/priority for transactions confirmed within N blocks\n- */\n-class CBlockAverage\n-{\n-private:\n-    boost::circular_buffer<CFeeRate> feeSamples;\n-    boost::circular_buffer<double> prioritySamples;\n-\n-    template<typename T> std::vector<T> buf2vec(boost::circular_buffer<T> buf) const\n-    {\n-        std::vector<T> vec(buf.begin(), buf.end());\n-        return vec;\n-    }\n-\n-public:\n-    CBlockAverage() : feeSamples(100), prioritySamples(100) { }\n-\n-    void RecordFee(const CFeeRate& feeRate) {\n-        feeSamples.push_back(feeRate);\n-    }\n-\n-    void RecordPriority(double priority) {\n-        prioritySamples.push_back(priority);\n-    }\n-\n-    size_t FeeSamples() const { return feeSamples.size(); }\n-    size_t GetFeeSamples(std::vector<CFeeRate>& insertInto) const\n-    {\n-        BOOST_FOREACH(const CFeeRate& f, feeSamples)\n-            insertInto.push_back(f);\n-        return feeSamples.size();\n-    }\n-    size_t PrioritySamples() const { return prioritySamples.size(); }\n-    size_t GetPrioritySamples(std::vector<double>& insertInto) const\n-    {\n-        BOOST_FOREACH(double d, prioritySamples)\n-            insertInto.push_back(d);\n-        return prioritySamples.size();\n-    }\n-\n-    /**\n-     * Used as belt-and-suspenders check when reading to detect\n-     * file corruption\n-     */\n-    static bool AreSane(const CFeeRate fee, const CFeeRate& minRelayFee)\n-    {\n-        if (fee < CFeeRate(0))\n-            return false;\n-        if (fee.GetFeePerK() > minRelayFee.GetFeePerK() * 10000)\n-            return false;\n-        return true;\n-    }\n-    static bool AreSane(const std::vector<CFeeRate>& vecFee, const CFeeRate& minRelayFee)\n-    {\n-        BOOST_FOREACH(CFeeRate fee, vecFee)\n-        {\n-            if (!AreSane(fee, minRelayFee))\n-                return false;\n-        }\n-        return true;\n-    }\n-    static bool AreSane(const double priority)\n-    {\n-        return priority >= 0;\n-    }\n-    static bool AreSane(const std::vector<double> vecPriority)\n-    {\n-        BOOST_FOREACH(double priority, vecPriority)\n-        {\n-            if (!AreSane(priority))\n-                return false;\n-        }\n-        return true;\n-    }\n-\n-    void Write(CAutoFile& fileout) const\n-    {\n-        std::vector<CFeeRate> vecFee = buf2vec(feeSamples);\n-        fileout << vecFee;\n-        std::vector<double> vecPriority = buf2vec(prioritySamples);\n-        fileout << vecPriority;\n-    }\n-\n-    void Read(CAutoFile& filein, const CFeeRate& minRelayFee) {\n-        std::vector<CFeeRate> vecFee;\n-        filein >> vecFee;\n-        if (AreSane(vecFee, minRelayFee))\n-            feeSamples.insert(feeSamples.end(), vecFee.begin(), vecFee.end());\n-        else\n-            throw runtime_error(\"Corrupt fee value in estimates file.\");\n-        std::vector<double> vecPriority;\n-        filein >> vecPriority;\n-        if (AreSane(vecPriority))\n-            prioritySamples.insert(prioritySamples.end(), vecPriority.begin(), vecPriority.end());\n-        else\n-            throw runtime_error(\"Corrupt priority value in estimates file.\");\n-        if (feeSamples.size() + prioritySamples.size() > 0)\n-            LogPrint(\"estimatefee\", \"Read %d fee samples and %d priority samples\\n\",\n-                     feeSamples.size(), prioritySamples.size());\n-    }\n-};\n-\n-class CMinerPolicyEstimator\n-{\n-private:\n-    /**\n-     * Records observed averages transactions that confirmed within one block, two blocks,\n-     * three blocks etc.\n-     */\n-    std::vector<CBlockAverage> history;\n-    std::vector<CFeeRate> sortedFeeSamples;\n-    std::vector<double> sortedPrioritySamples;\n-\n-    int nBestSeenHeight;\n-\n-    /**\n-     * nBlocksAgo is 0 based, i.e. transactions that confirmed in the highest seen block are\n-     * nBlocksAgo == 0, transactions in the block before that are nBlocksAgo == 1 etc.\n-     */\n-    void seenTxConfirm(const CFeeRate& feeRate, const CFeeRate& minRelayFee, double dPriority, int nBlocksAgo)\n-    {\n-        // Last entry records \"everything else\".\n-        int nBlocksTruncated = min(nBlocksAgo, (int) history.size() - 1);\n-        assert(nBlocksTruncated >= 0);\n-\n-        // We need to guess why the transaction was included in a block-- either\n-        // because it is high-priority or because it has sufficient fees.\n-        bool sufficientFee = (feeRate > minRelayFee);\n-        bool sufficientPriority = AllowFree(dPriority);\n-        const char* assignedTo = \"unassigned\";\n-        if (sufficientFee && !sufficientPriority && CBlockAverage::AreSane(feeRate, minRelayFee))\n-        {\n-            history[nBlocksTruncated].RecordFee(feeRate);\n-            assignedTo = \"fee\";\n-        }\n-        else if (sufficientPriority && !sufficientFee && CBlockAverage::AreSane(dPriority))\n-        {\n-            history[nBlocksTruncated].RecordPriority(dPriority);\n-            assignedTo = \"priority\";\n-        }\n-        else\n-        {\n-            // Neither or both fee and priority sufficient to get confirmed:\n-            // don't know why they got confirmed.\n-        }\n-        LogPrint(\"estimatefee\", \"Seen TX confirm: %s: %s fee/%g priority, took %d blocks\\n\",\n-                 assignedTo, feeRate.ToString(), dPriority, nBlocksAgo);\n-    }\n-\n-public:\n-    CMinerPolicyEstimator(int nEntries) : nBestSeenHeight(0)\n-    {\n-        history.resize(nEntries);\n-    }\n-\n-    void seenBlock(const std::vector<CTxMemPoolEntry>& entries, int nBlockHeight, const CFeeRate minRelayFee)\n-    {\n-        if (nBlockHeight <= nBestSeenHeight)\n-        {\n-            // Ignore side chains and re-orgs; assuming they are random\n-            // they don't affect the estimate.\n-            // And if an attacker can re-org the chain at will, then\n-            // you've got much bigger problems than \"attacker can influence\n-            // transaction fees.\"\n-            return;\n-        }\n-        nBestSeenHeight = nBlockHeight;\n-\n-        // Fill up the history buckets based on how long transactions took\n-        // to confirm.\n-        std::vector<std::vector<const CTxMemPoolEntry*> > entriesByConfirmations;\n-        entriesByConfirmations.resize(history.size());\n-        BOOST_FOREACH(const CTxMemPoolEntry& entry, entries)\n-        {\n-            // How many blocks did it take for miners to include this transaction?\n-            int delta = nBlockHeight - entry.GetHeight();\n-            if (delta <= 0)\n-            {\n-                // Re-org made us lose height, this should only happen if we happen\n-                // to re-org on a difficulty transition point: very rare!\n-                continue;\n-            }\n-            if ((delta-1) >= (int)history.size())\n-                delta = history.size(); // Last bucket is catch-all\n-            entriesByConfirmations.at(delta-1).push_back(&entry);\n-        }\n-        for (size_t i = 0; i < entriesByConfirmations.size(); i++)\n-        {\n-            std::vector<const CTxMemPoolEntry*> &e = entriesByConfirmations.at(i);\n-            // Insert at most 10 random entries per bucket, otherwise a single block\n-            // can dominate an estimate:\n-            if (e.size() > 10) {\n-                std::random_shuffle(e.begin(), e.end());\n-                e.resize(10);\n-            }\n-            BOOST_FOREACH(const CTxMemPoolEntry* entry, e)\n-            {\n-                // Fees are stored and reported as BTC-per-kb:\n-                CFeeRate feeRate(entry->GetFee(), entry->GetTxSize());\n-                double dPriority = entry->GetPriority(entry->GetHeight()); // Want priority when it went IN\n-                seenTxConfirm(feeRate, minRelayFee, dPriority, i);\n-            }\n-        }\n-\n-        // After new samples are added, we have to clear the sorted lists,\n-        // so they'll be resorted the next time someone asks for an estimate\n-        sortedFeeSamples.clear();\n-        sortedPrioritySamples.clear();\n-\n-        for (size_t i = 0; i < history.size(); i++) {\n-            if (history[i].FeeSamples() + history[i].PrioritySamples() > 0)\n-                LogPrint(\"estimatefee\", \"estimates: for confirming within %d blocks based on %d/%d samples, fee=%s, prio=%g\\n\", \n-                         i,\n-                         history[i].FeeSamples(), history[i].PrioritySamples(),\n-                         estimateFee(i+1).ToString(), estimatePriority(i+1));\n-        }\n-    }\n-\n-    /**\n-     * Can return CFeeRate(0) if we don't have any data for that many blocks back. nBlocksToConfirm is 1 based.\n-     */\n-    CFeeRate estimateFee(int nBlocksToConfirm)\n-    {\n-        nBlocksToConfirm--;\n-\n-        if (nBlocksToConfirm < 0 || nBlocksToConfirm >= (int)history.size())\n-            return CFeeRate(0);\n-\n-        if (sortedFeeSamples.size() == 0)\n-        {\n-            for (size_t i = 0; i < history.size(); i++)\n-                history.at(i).GetFeeSamples(sortedFeeSamples);\n-            std::sort(sortedFeeSamples.begin(), sortedFeeSamples.end(),\n-                      std::greater<CFeeRate>());\n-        }\n-        if (sortedFeeSamples.size() < 11)\n-        {\n-            // Eleven is Gavin's Favorite Number\n-            // ... but we also take a maximum of 10 samples per block so eleven means\n-            // we're getting samples from at least two different blocks\n-            return CFeeRate(0);\n-        }\n-\n-        int nBucketSize = history.at(nBlocksToConfirm).FeeSamples();\n-\n-        // Estimates should not increase as number of confirmations goes up,\n-        // but the estimates are noisy because confirmations happen discretely\n-        // in blocks. To smooth out the estimates, use all samples in the history\n-        // and use the nth highest where n is (number of samples in previous bucket +\n-        // half the samples in nBlocksToConfirm bucket):\n-        size_t nPrevSize = 0;\n-        for (int i = 0; i < nBlocksToConfirm; i++)\n-            nPrevSize += history.at(i).FeeSamples();\n-        size_t index = min(nPrevSize + nBucketSize/2, sortedFeeSamples.size()-1);\n-        return sortedFeeSamples[index];\n-    }\n-    double estimatePriority(int nBlocksToConfirm)\n-    {\n-        nBlocksToConfirm--;\n-\n-        if (nBlocksToConfirm < 0 || nBlocksToConfirm >= (int)history.size())\n-            return -1;\n-\n-        if (sortedPrioritySamples.size() == 0)\n-        {\n-            for (size_t i = 0; i < history.size(); i++)\n-                history.at(i).GetPrioritySamples(sortedPrioritySamples);\n-            std::sort(sortedPrioritySamples.begin(), sortedPrioritySamples.end(),\n-                      std::greater<double>());\n-        }\n-        if (sortedPrioritySamples.size() < 11)\n-            return -1.0;\n-\n-        int nBucketSize = history.at(nBlocksToConfirm).PrioritySamples();\n-\n-        // Estimates should not increase as number of confirmations needed goes up,\n-        // but the estimates are noisy because confirmations happen discretely\n-        // in blocks. To smooth out the estimates, use all samples in the history\n-        // and use the nth highest where n is (number of samples in previous buckets +\n-        // half the samples in nBlocksToConfirm bucket).\n-        size_t nPrevSize = 0;\n-        for (int i = 0; i < nBlocksToConfirm; i++)\n-            nPrevSize += history.at(i).PrioritySamples();\n-        size_t index = min(nPrevSize + nBucketSize/2, sortedPrioritySamples.size()-1);\n-        return sortedPrioritySamples[index];\n-    }\n-\n-    void Write(CAutoFile& fileout) const\n-    {\n-        fileout << nBestSeenHeight;\n-        fileout << (uint32_t)history.size();\n-        BOOST_FOREACH(const CBlockAverage& entry, history)\n-        {\n-            entry.Write(fileout);\n-        }\n-    }\n-\n-    void Read(CAutoFile& filein, const CFeeRate& minRelayFee)\n-    {\n-        int nFileBestSeenHeight;\n-        filein >> nFileBestSeenHeight;\n-        uint32_t numEntries;\n-        filein >> numEntries;\n-        if (numEntries <= 0 || numEntries > 10000)\n-            throw runtime_error(\"Corrupt estimates file. Must have between 1 and 10k entries.\");\n-\n-        std::vector<CBlockAverage> fileHistory;\n-        \n-        for (size_t i = 0; i < numEntries; i++)\n-        {\n-            CBlockAverage entry;\n-            entry.Read(filein, minRelayFee);\n-            fileHistory.push_back(entry);\n-        }\n-\n-        // Now that we've processed the entire fee estimate data file and not\n-        // thrown any errors, we can copy it to our history\n-        nBestSeenHeight = nFileBestSeenHeight;\n-        history = fileHistory;\n-        assert(history.size() > 0);\n-    }\n-};\n-\n-\n CTxMemPool::CTxMemPool(const CFeeRate& _minRelayFee) :\n-    nTransactionsUpdated(0),\n-    minRelayFee(_minRelayFee)\n+    nTransactionsUpdated(0)\n {\n     // Sanity checks off by default for performance, because otherwise\n     // accepting transactions becomes O(N^2) where N is the number\n     // of transactions in the pool\n     fSanityCheck = false;\n \n-    // 25 blocks is a compromise between using a lot of disk/memory and\n-    // trying to give accurate estimates to people who might be willing\n-    // to wait a day or two to save a fraction of a penny in fees.\n-    // Confirmation times for very-low-fee transactions that take more\n-    // than an hour or three to confirm are highly variable.\n-    minerPolicyEstimator = new CMinerPolicyEstimator(25);\n+    minerPolicyEstimator = new CBlockPolicyEstimator(_minRelayFee);\n }\n \n CTxMemPool::~CTxMemPool()\n@@ -419,20 +87,20 @@ void CTxMemPool::AddTransactionsUpdated(unsigned int n)\n }\n \n \n-bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry)\n+bool CTxMemPool::addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, bool fCurrentEstimate)\n {\n     // Add to memory pool without checking anything.\n     // Used by main.cpp AcceptToMemoryPool(), which DOES do\n     // all the appropriate checks.\n     LOCK(cs);\n-    {\n-        mapTx[hash] = entry;\n-        const CTransaction& tx = mapTx[hash].GetTx();\n-        for (unsigned int i = 0; i < tx.vin.size(); i++)\n-            mapNextTx[tx.vin[i].prevout] = CInPoint(&tx, i);\n-        nTransactionsUpdated++;\n-        totalTxSize += entry.GetTxSize();\n-    }\n+    mapTx[hash] = entry;\n+    const CTransaction& tx = mapTx[hash].GetTx();\n+    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+        mapNextTx[tx.vin[i].prevout] = CInPoint(&tx, i);\n+    nTransactionsUpdated++;\n+    totalTxSize += entry.GetTxSize();\n+    minerPolicyEstimator->processTransaction(entry, fCurrentEstimate);\n+\n     return true;\n }\n \n@@ -478,6 +146,7 @@ void CTxMemPool::remove(const CTransaction &origTx, std::list<CTransaction>& rem\n             totalTxSize -= mapTx[hash].GetTxSize();\n             mapTx.erase(hash);\n             nTransactionsUpdated++;\n+            minerPolicyEstimator->removeTx(hash);\n         }\n     }\n }\n@@ -528,7 +197,7 @@ void CTxMemPool::removeConflicts(const CTransaction &tx, std::list<CTransaction>\n  * Called when a block is connected. Removes from mempool and updates the miner fee estimator.\n  */\n void CTxMemPool::removeForBlock(const std::vector<CTransaction>& vtx, unsigned int nBlockHeight,\n-                                std::list<CTransaction>& conflicts)\n+                                std::list<CTransaction>& conflicts, bool fCurrentEstimate)\n {\n     LOCK(cs);\n     std::vector<CTxMemPoolEntry> entries;\n@@ -538,17 +207,17 @@ void CTxMemPool::removeForBlock(const std::vector<CTransaction>& vtx, unsigned i\n         if (mapTx.count(hash))\n             entries.push_back(mapTx[hash]);\n     }\n-    minerPolicyEstimator->seenBlock(entries, nBlockHeight, minRelayFee);\n     BOOST_FOREACH(const CTransaction& tx, vtx)\n     {\n         std::list<CTransaction> dummy;\n         remove(tx, dummy, false);\n         removeConflicts(tx, conflicts);\n         ClearPrioritisation(tx.GetHash());\n     }\n+    // After the txs in the new block have been removed from the mempool, update policy estimates\n+    minerPolicyEstimator->processBlock(nBlockHeight, entries, fCurrentEstimate);\n }\n \n-\n void CTxMemPool::clear()\n {\n     LOCK(cs);\n@@ -665,7 +334,7 @@ CTxMemPool::WriteFeeEstimates(CAutoFile& fileout) const\n {\n     try {\n         LOCK(cs);\n-        fileout << 99900; // version required to read: 0.9.99 or later\n+        fileout << 109900; // version required to read: 0.10.99 or later\n         fileout << CLIENT_VERSION; // version that wrote the file\n         minerPolicyEstimator->Write(fileout);\n     }\n@@ -686,7 +355,7 @@ CTxMemPool::ReadFeeEstimates(CAutoFile& filein)\n             return error(\"CTxMemPool::ReadFeeEstimates(): up-version (%d) fee estimate file\", nVersionRequired);\n \n         LOCK(cs);\n-        minerPolicyEstimator->Read(filein, minRelayFee);\n+        minerPolicyEstimator->Read(filein);\n     }\n     catch (const std::exception&) {\n         LogPrintf(\"CTxMemPool::ReadFeeEstimates(): unable to read policy estimator data (non-fatal)\");\n@@ -723,6 +392,13 @@ void CTxMemPool::ClearPrioritisation(const uint256 hash)\n     mapDeltas.erase(hash);\n }\n \n+bool CTxMemPool::HasNoInputsOf(const CTransaction &tx) const\n+{\n+    for (unsigned int i = 0; i < tx.vin.size(); i++)\n+        if (exists(tx.vin[i].prevout.hash))\n+            return false;\n+    return true;\n+}\n \n CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView *baseIn, CTxMemPool &mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) { }\n "
      },
      {
        "sha": "7271a5f603c7554b9c090dc805c70dcd25df0f1d",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 13,
        "deletions": 7,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b649e0395464a659f4b3485ec71d28dc95ba48bd/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=b649e0395464a659f4b3485ec71d28dc95ba48bd",
        "patch": "@@ -43,10 +43,11 @@ class CTxMemPoolEntry\n     int64_t nTime; //! Local time when entering the mempool\n     double dPriority; //! Priority when entering the mempool\n     unsigned int nHeight; //! Chain height when entering the mempool\n+    bool hadNoDependencies; //! Not dependent on any other txs when it entered the mempool\n \n public:\n     CTxMemPoolEntry(const CTransaction& _tx, const CAmount& _nFee,\n-                    int64_t _nTime, double _dPriority, unsigned int _nHeight);\n+                    int64_t _nTime, double _dPriority, unsigned int _nHeight, bool poolHasNoInputsOf = false);\n     CTxMemPoolEntry();\n     CTxMemPoolEntry(const CTxMemPoolEntry& other);\n \n@@ -56,9 +57,10 @@ class CTxMemPoolEntry\n     size_t GetTxSize() const { return nTxSize; }\n     int64_t GetTime() const { return nTime; }\n     unsigned int GetHeight() const { return nHeight; }\n+    bool WasClearAtEntry() const { return hadNoDependencies; }\n };\n \n-class CMinerPolicyEstimator;\n+class CBlockPolicyEstimator;\n \n /** An inpoint - a combination of a transaction and an index n into its vin */\n class CInPoint\n@@ -88,9 +90,8 @@ class CTxMemPool\n private:\n     bool fSanityCheck; //! Normally false, true if -checkmempool or -regtest\n     unsigned int nTransactionsUpdated;\n-    CMinerPolicyEstimator* minerPolicyEstimator;\n+    CBlockPolicyEstimator* minerPolicyEstimator;\n \n-    CFeeRate minRelayFee; //! Passed to constructor to avoid dependency on main\n     uint64_t totalTxSize; //! sum of all mempool tx' byte sizes\n \n public:\n@@ -111,17 +112,22 @@ class CTxMemPool\n     void check(const CCoinsViewCache *pcoins) const;\n     void setSanityCheck(bool _fSanityCheck) { fSanityCheck = _fSanityCheck; }\n \n-    bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry);\n+    bool addUnchecked(const uint256& hash, const CTxMemPoolEntry &entry, bool fCurrentEstimate = true);\n     void remove(const CTransaction &tx, std::list<CTransaction>& removed, bool fRecursive = false);\n     void removeCoinbaseSpends(const CCoinsViewCache *pcoins, unsigned int nMemPoolHeight);\n     void removeConflicts(const CTransaction &tx, std::list<CTransaction>& removed);\n     void removeForBlock(const std::vector<CTransaction>& vtx, unsigned int nBlockHeight,\n-                        std::list<CTransaction>& conflicts);\n+                        std::list<CTransaction>& conflicts, bool fCurrentEstimate = true);\n     void clear();\n     void queryHashes(std::vector<uint256>& vtxid);\n     void pruneSpent(const uint256& hash, CCoins &coins);\n     unsigned int GetTransactionsUpdated() const;\n     void AddTransactionsUpdated(unsigned int n);\n+    /**\n+     * Check that none of this transactions inputs are in the mempool, and thus\n+     * the tx is not dependent on other mempool transactions to be included in a block.\n+     */\n+    bool HasNoInputsOf(const CTransaction& tx) const;\n \n     /** Affect CreateNewBlock prioritisation of transactions */\n     void PrioritiseTransaction(const uint256 hash, const std::string strHash, double dPriorityDelta, const CAmount& nFeeDelta);\n@@ -139,7 +145,7 @@ class CTxMemPool\n         return totalTxSize;\n     }\n \n-    bool exists(uint256 hash)\n+    bool exists(uint256 hash) const\n     {\n         LOCK(cs);\n         return (mapTx.count(hash) != 0);"
      }
    ]
  }
]