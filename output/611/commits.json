[
  {
    "sha": "d825e6a31bf980dde8afd94fba61614523e60f09",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkODI1ZTZhMzFiZjk4MGRkZThhZmQ5NGZiYTYxNjE0NTIzZTYwZjA5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-11-06T23:05:42Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2011-11-06T23:11:34Z"
      },
      "message": "Some extra comments",
      "tree": {
        "sha": "e39034b1e8bfbc103299fa84b15273a3a275719e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e39034b1e8bfbc103299fa84b15273a3a275719e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d825e6a31bf980dde8afd94fba61614523e60f09",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d825e6a31bf980dde8afd94fba61614523e60f09",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d825e6a31bf980dde8afd94fba61614523e60f09",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d825e6a31bf980dde8afd94fba61614523e60f09/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "81a28d7a6f8ab4b3642907b79106d2350a5e7d63",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/81a28d7a6f8ab4b3642907b79106d2350a5e7d63",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/81a28d7a6f8ab4b3642907b79106d2350a5e7d63"
      }
    ],
    "stats": {
      "total": 89,
      "additions": 80,
      "deletions": 9
    },
    "files": [
      {
        "sha": "cace423d6ee0c62cfbb5c934dc5b34f8eea237d7",
        "filename": "src/base58.h",
        "status": "modified",
        "additions": 19,
        "deletions": 4,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d825e6a31bf980dde8afd94fba61614523e60f09/src/base58.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d825e6a31bf980dde8afd94fba61614523e60f09/src/base58.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/base58.h?ref=d825e6a31bf980dde8afd94fba61614523e60f09",
        "patch": "@@ -21,7 +21,7 @@\n \n static const char* pszBase58 = \"123456789ABCDEFGHJKLMNPQRSTUVWXYZabcdefghijkmnopqrstuvwxyz\";\n \n-\n+// Encode a byte sequence as a base58-encoded string\n inline std::string EncodeBase58(const unsigned char* pbegin, const unsigned char* pend)\n {\n     CAutoBN_CTX pctx;\n@@ -62,11 +62,14 @@ inline std::string EncodeBase58(const unsigned char* pbegin, const unsigned char\n     return str;\n }\n \n+// Encode a byte vector as a base58-encoded string\n inline std::string EncodeBase58(const std::vector<unsigned char>& vch)\n {\n     return EncodeBase58(&vch[0], &vch[0] + vch.size());\n }\n \n+// Decode a base58-encoded string psz into byte vector vchRet\n+// returns true if decoding is succesful\n inline bool DecodeBase58(const char* psz, std::vector<unsigned char>& vchRet)\n {\n     CAutoBN_CTX pctx;\n@@ -113,6 +116,8 @@ inline bool DecodeBase58(const char* psz, std::vector<unsigned char>& vchRet)\n     return true;\n }\n \n+// Decode a base58-encoded string str into byte vector vchRet\n+// returns true if decoding is succesful\n inline bool DecodeBase58(const std::string& str, std::vector<unsigned char>& vchRet)\n {\n     return DecodeBase58(str.c_str(), vchRet);\n@@ -121,7 +126,7 @@ inline bool DecodeBase58(const std::string& str, std::vector<unsigned char>& vch\n \n \n \n-\n+// Encode a byte vector to a base58-encoded string, including checksum\n inline std::string EncodeBase58Check(const std::vector<unsigned char>& vchIn)\n {\n     // add 4-byte hash check to the end\n@@ -131,6 +136,8 @@ inline std::string EncodeBase58Check(const std::vector<unsigned char>& vchIn)\n     return EncodeBase58(vch);\n }\n \n+// Decode a base58-encoded string psz that includes a checksum, into byte vector vchRet\n+// returns true if decoding is succesful\n inline bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRet)\n {\n     if (!DecodeBase58(psz, vchRet))\n@@ -150,6 +157,8 @@ inline bool DecodeBase58Check(const char* psz, std::vector<unsigned char>& vchRe\n     return true;\n }\n \n+// Decode a base58-encoded string str that includes a checksum, into byte vector vchRet\n+// returns true if decoding is succesful\n inline bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>& vchRet)\n {\n     return DecodeBase58Check(str.c_str(), vchRet);\n@@ -159,11 +168,14 @@ inline bool DecodeBase58Check(const std::string& str, std::vector<unsigned char>\n \n \n \n-\n+// Base class for all base58-encoded data\n class CBase58Data\n {\n protected:\n+    // the version byte\n     unsigned char nVersion;\n+\n+    // the actually encoded data\n     std::vector<unsigned char> vchData;\n \n     CBase58Data()\n@@ -174,6 +186,7 @@ class CBase58Data\n \n     ~CBase58Data()\n     {\n+        // zero the memory, as it may contain sensitive data\n         if (!vchData.empty())\n             memset(&vchData[0], 0, vchData.size());\n     }\n@@ -238,7 +251,9 @@ class CBase58Data\n     bool operator> (const CBase58Data& b58) const { return CompareTo(b58) >  0; }\n };\n \n-\n+// base58-encoded bitcoin addresses\n+// Addresses have version 0 or 111 (testnet)\n+// The data vector contains RIPEMD160(SHA256(pubkey)), where pubkey is the serialized public key\n class CBitcoinAddress : public CBase58Data\n {\n public:"
      },
      {
        "sha": "e8ca30a8cc1bb4b1593496051ed607569bbf96c3",
        "filename": "src/crypter.h",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d825e6a31bf980dde8afd94fba61614523e60f09/src/crypter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d825e6a31bf980dde8afd94fba61614523e60f09/src/crypter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypter.h?ref=d825e6a31bf980dde8afd94fba61614523e60f09",
        "patch": "@@ -13,15 +13,15 @@ const unsigned int WALLET_CRYPTO_SALT_SIZE = 8;\n Private key encryption is done based on a CMasterKey,\n which holds a salt and random encryption key.\n \n-CMasterKeys is encrypted using AES-256-CBC using a key\n+CMasterKeys are encrypted using AES-256-CBC using a key\n derived using derivation method nDerivationMethod\n (0 == EVP_sha512()) and derivation iterations nDeriveIterations.\n vchOtherDerivationParameters is provided for alternative algorithms\n which may require more parameters (such as scrypt).\n \n Wallet Private Keys are then encrypted using AES-256-CBC\n-with the double-sha256 of the private key as the IV, and the\n-master key's key as the encryption key.\n+with the double-sha256 of the public key as the IV, and the\n+master key's key as the encryption key (see keystore.[ch]).\n */\n \n class CMasterKey"
      },
      {
        "sha": "df5cfeb32c78e63c3823a9a8eb936372334d3309",
        "filename": "src/key.h",
        "status": "modified",
        "additions": 15,
        "deletions": 1,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d825e6a31bf980dde8afd94fba61614523e60f09/src/key.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d825e6a31bf980dde8afd94fba61614523e60f09/src/key.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/key.h?ref=d825e6a31bf980dde8afd94fba61614523e60f09",
        "patch": "@@ -39,6 +39,7 @@\n // see www.keylength.com\n // script supports up to 75 for single byte push\n \n+// Generate a private key from just the secret parameter\n int static inline EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)\n {\n     int ok = 0;\n@@ -75,6 +76,9 @@ int static inline EC_KEY_regenerate_key(EC_KEY *eckey, BIGNUM *priv_key)\n     return(ok);\n }\n \n+// Perform ECDSA key recovery (see SEC1 4.1.6) for curves over (mod p)-fields\n+// recid selects which key is recovered\n+// if check is nonzero, additional checks are performed\n int static inline ECDSA_SIG_recover_key_GFp(EC_KEY *eckey, ECDSA_SIG *ecsig, const unsigned char *msg, int msglen, int recid, int check)\n {\n     if (!eckey) return 0;\n@@ -154,7 +158,9 @@ class key_error : public std::runtime_error\n \n \n // secure_allocator is defined in serialize.h\n+// CPrivKey is a serialized private key, with all parameters included (279 bytes)\n typedef std::vector<unsigned char, secure_allocator<unsigned char> > CPrivKey;\n+// CSecret is a serialization of just the secret parameter (32 bytes)\n typedef std::vector<unsigned char, secure_allocator<unsigned char> > CSecret;\n \n class CKey\n@@ -292,6 +298,9 @@ class CKey\n     }\n \n     // create a compact signature (65 bytes), which allows reconstructing the used public key\n+    // The format is one header byte, followed by two times 32 bytes for the serialized r and s values.\n+    // The header byte: 0x1B = first key with even y, 0x1C = first key with odd y,\n+    //                  0x1D = second key with even y, 0x1E = second key with odd y\n     bool SignCompact(uint256 hash, std::vector<unsigned char>& vchSig)\n     {\n         bool fOk = false;\n@@ -318,7 +327,7 @@ class CKey\n             }\n \n             if (nRecId == -1)\n-                throw key_error(\"CKEy::SignCompact() : unable to construct recoverable key\");\n+                throw key_error(\"CKey::SignCompact() : unable to construct recoverable key\");\n \n             vchSig[0] = nRecId+27;\n             BN_bn2bin(sig->r,&vchSig[33-(nBitsR+7)/8]);\n@@ -330,6 +339,9 @@ class CKey\n     }\n \n     // reconstruct public key from a compact signature\n+    // This is only slightly more CPU intensive than just verifying it.\n+    // If this function succeeds, the recovered public key is guaranteed to be valid\n+    // (the signature is a valid signature of the given data for that key)\n     bool SetCompactSignature(uint256 hash, const std::vector<unsigned char>& vchSig)\n     {\n         if (vchSig.size() != 65)\n@@ -359,6 +371,7 @@ class CKey\n         return true;\n     }\n \n+    // Verify a compact signature\n     bool VerifyCompact(uint256 hash, const std::vector<unsigned char>& vchSig)\n     {\n         CKey key;\n@@ -369,6 +382,7 @@ class CKey\n         return true;\n     }\n \n+    // Get the address corresponding to this key\n     CBitcoinAddress GetAddress() const\n     {\n         return CBitcoinAddress(GetPubKey());"
      },
      {
        "sha": "4d889146fc5bb75bde858f4de39e3c8f2a3fc91a",
        "filename": "src/keystore.h",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d825e6a31bf980dde8afd94fba61614523e60f09/src/keystore.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d825e6a31bf980dde8afd94fba61614523e60f09/src/keystore.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/keystore.h?ref=d825e6a31bf980dde8afd94fba61614523e60f09",
        "patch": "@@ -7,21 +7,34 @@\n \n #include \"crypter.h\"\n \n+// A virtual base class for key stores\n class CKeyStore\n {\n protected:\n     mutable CCriticalSection cs_KeyStore;\n \n public:\n+    // Add a key to the store.\n     virtual bool AddKey(const CKey& key) =0;\n+\n+    // Check whether a key corresponding to a given address is present in the store.\n     virtual bool HaveKey(const CBitcoinAddress &address) const =0;\n+\n+    // Retrieve a key corresponding to a given address from the store.\n+    // Return true if succesful.\n     virtual bool GetKey(const CBitcoinAddress &address, CKey& keyOut) const =0;\n+\n+    // Retrieve only the public key corresponding to a given address.\n+    // This may succeed even if GetKey fails (e.g., encrypted wallets)\n     virtual bool GetPubKey(const CBitcoinAddress &address, std::vector<unsigned char>& vchPubKeyOut) const;\n+\n+    // Generate a new key, and add it to the store\n     virtual std::vector<unsigned char> GenerateNewKey();\n };\n \n typedef std::map<CBitcoinAddress, CSecret> KeyMap;\n \n+// Basic key store, that keeps keys in an address->secret map\n class CBasicKeyStore : public CKeyStore\n {\n protected:\n@@ -53,6 +66,8 @@ class CBasicKeyStore : public CKeyStore\n \n typedef std::map<CBitcoinAddress, std::pair<std::vector<unsigned char>, std::vector<unsigned char> > > CryptedKeyMap;\n \n+// Keystore which keeps the private keys encrypted\n+// It derives from the basic key store, which is used if no encryption is active.\n class CCryptoKeyStore : public CBasicKeyStore\n {\n private:"
      },
      {
        "sha": "47f1090727f16d5ddbb7119ee9f5a2cb267a0b9c",
        "filename": "src/main.cpp",
        "status": "modified",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d825e6a31bf980dde8afd94fba61614523e60f09/src/main.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d825e6a31bf980dde8afd94fba61614523e60f09/src/main.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/main.cpp?ref=d825e6a31bf980dde8afd94fba61614523e60f09",
        "patch": "@@ -70,6 +70,9 @@ int fUseUPnP = false;\n // dispatching functions\n //\n \n+// These functions dispatch to one or all registered wallets\n+\n+\n void RegisterWallet(CWallet* pwalletIn)\n {\n     CRITICAL_BLOCK(cs_setpwalletRegistered)\n@@ -86,6 +89,7 @@ void UnregisterWallet(CWallet* pwalletIn)\n     }\n }\n \n+// check whether the passed transaction is from us\n bool static IsFromMe(CTransaction& tx)\n {\n     BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n@@ -94,6 +98,7 @@ bool static IsFromMe(CTransaction& tx)\n     return false;\n }\n \n+// get the wallet transaction with the given hash (if it exists)\n bool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n {\n     BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n@@ -102,42 +107,49 @@ bool static GetTransaction(const uint256& hashTx, CWalletTx& wtx)\n     return false;\n }\n \n+// erases transaction with the given hash from all wallets\n void static EraseFromWallets(uint256 hash)\n {\n     BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n         pwallet->EraseFromWallet(hash);\n }\n \n+// make sure all wallets know about the given transaction, in the given block\n void static SyncWithWallets(const CTransaction& tx, const CBlock* pblock = NULL, bool fUpdate = false)\n {\n     BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n         pwallet->AddToWalletIfInvolvingMe(tx, pblock, fUpdate);\n }\n \n+// notify wallets about a new best chain\n void static SetBestChain(const CBlockLocator& loc)\n {\n     BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n         pwallet->SetBestChain(loc);\n }\n \n+// notify wallets about an updated transaction\n void static UpdatedTransaction(const uint256& hashTx)\n {\n     BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n         pwallet->UpdatedTransaction(hashTx);\n }\n \n+// dump all wallets\n void static PrintWallets(const CBlock& block)\n {\n     BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n         pwallet->PrintWallet(block);\n }\n \n+// notify wallets about an incoming inventory (for request counts)\n void static Inventory(const uint256& hash)\n {\n     BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)\n         pwallet->Inventory(hash);\n }\n \n+// ask wallets to resend their transactions\n void static ResendWalletTransactions()\n {\n     BOOST_FOREACH(CWallet* pwallet, setpwalletRegistered)"
      },
      {
        "sha": "64ee5c3b8ca69bfd69e9d8918da7d4780e668d1a",
        "filename": "src/wallet.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d825e6a31bf980dde8afd94fba61614523e60f09/src/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d825e6a31bf980dde8afd94fba61614523e60f09/src/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.cpp?ref=d825e6a31bf980dde8afd94fba61614523e60f09",
        "patch": "@@ -289,6 +289,9 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn)\n     return true;\n }\n \n+// Add a transaction to the wallet, or update it.\n+// pblock is optional, but should be provided if the transaction is known to be in a block.\n+// If fUpdate is true, existing transactions will be updated.\n bool CWallet::AddToWalletIfInvolvingMe(const CTransaction& tx, const CBlock* pblock, bool fUpdate)\n {\n     uint256 hash = tx.GetHash();\n@@ -551,6 +554,9 @@ bool CWalletTx::WriteToDisk()\n     return CWalletDB(pwallet->strWalletFile).WriteTx(GetHash(), *this);\n }\n \n+// Scan the block chain (starting in pindexStart) for transactions\n+// from or to us. If fUpdate is true, found transactions that already\n+// exist in the wallet will be updated.\n int CWallet::ScanForWalletTransactions(CBlockIndex* pindexStart, bool fUpdate)\n {\n     int ret = 0;"
      },
      {
        "sha": "03c4703fc0ef0f29f196334ee4f631819336f8ef",
        "filename": "src/wallet.h",
        "status": "modified",
        "additions": 10,
        "deletions": 1,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d825e6a31bf980dde8afd94fba61614523e60f09/src/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d825e6a31bf980dde8afd94fba61614523e60f09/src/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet.h?ref=d825e6a31bf980dde8afd94fba61614523e60f09",
        "patch": "@@ -13,6 +13,9 @@ class CWalletTx;\n class CReserveKey;\n class CWalletDB;\n \n+// A CWallet is an extension of a keystore, which also maintains a set of\n+// transactions and balances, and provides the ability to create new\n+// transactions\n class CWallet : public CCryptoKeyStore\n {\n private:\n@@ -57,9 +60,14 @@ class CWallet : public CCryptoKeyStore\n     std::vector<unsigned char> vchDefaultKey;\n \n     // keystore implementation\n+    // Adds a key to the store, and saves it to disk.\n     bool AddKey(const CKey& key);\n+    // Adds a key to the store, without saving it to disk (used by LoadWallet)\n     bool LoadKey(const CKey& key) { return CCryptoKeyStore::AddKey(key); }\n+\n+    // Adds an encrypted key to the store, and saves it to disk.\n     bool AddCryptedKey(const std::vector<unsigned char> &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret);\n+    // Adds an encrypted key to the store, without saving it to disk (used by LoadWallet)\n     bool LoadCryptedKey(const std::vector<unsigned char> &vchPubKey, const std::vector<unsigned char> &vchCryptedSecret) { return CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret); }\n \n     bool Unlock(const std::string& strWalletPassphrase);\n@@ -244,7 +252,7 @@ class CWalletTx : public CMerkleTx\n     unsigned int nTimeReceived;  // time received by this node\n     char fFromMe;\n     std::string strFromAccount;\n-    std::vector<char> vfSpent;\n+    std::vector<char> vfSpent; // which outputs are already spent\n \n     // memory only\n     mutable char fDebitCached;\n@@ -371,6 +379,7 @@ class CWalletTx : public CMerkleTx\n         return fReturn;\n     }\n \n+    // make sure balances are recalculated\n     void MarkDirty()\n     {\n         fCreditCached = false;"
      }
    ]
  }
]