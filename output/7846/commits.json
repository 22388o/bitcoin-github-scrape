[
  {
    "sha": "5eeb913d6cff9cfe9a6769d7efe4a7b9f23de0f4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ZWViOTEzZDZjZmY5Y2ZlOWE2NzY5ZDdlZmU0YTdiOWYyM2RlMGY0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-04-08T20:14:19Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2016-04-10T12:27:10Z"
      },
      "message": "Clean up lockorder data of destroyed mutexes\n\nThe lockorder potential deadlock detection works by remembering for each\nlock A that is acquired while holding another B the pair (A,B), and\ntriggering a warning when (B,A) already exists in the table.\n\nA and B in the above text are represented by pointers to the CCriticalSection\nobject that is acquired. This does mean however that we need to clean up the\ntable entries that refer to any critical section which is destroyed, as it\nmemory address can potentially be used for another unrelated lock in the future.\n\nImplement this clean up by remembering not only the pairs in forward direction,\nbut also backward direction. This allows for fast iteration over all pairs that\nuse a deleted CCriticalSection in either the first or the second position.",
      "tree": {
        "sha": "7acd0460c216efe835e8454f0665286c5442c05a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7acd0460c216efe835e8454f0665286c5442c05a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/5eeb913d6cff9cfe9a6769d7efe4a7b9f23de0f4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5eeb913d6cff9cfe9a6769d7efe4a7b9f23de0f4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/5eeb913d6cff9cfe9a6769d7efe4a7b9f23de0f4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5eeb913d6cff9cfe9a6769d7efe4a7b9f23de0f4/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0afac87e8173dd71616e211aa08dcd59cb5cf90e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0afac87e8173dd71616e211aa08dcd59cb5cf90e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0afac87e8173dd71616e211aa08dcd59cb5cf90e"
      }
    ],
    "stats": {
      "total": 88,
      "additions": 65,
      "deletions": 23
    },
    "files": [
      {
        "sha": "641ed2c8ca036075abc3bb298dafa767ec2deba3",
        "filename": "src/sync.cpp",
        "status": "modified",
        "additions": 44,
        "deletions": 11,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5eeb913d6cff9cfe9a6769d7efe4a7b9f23de0f4/src/sync.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5eeb913d6cff9cfe9a6769d7efe4a7b9f23de0f4/src/sync.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.cpp?ref=5eeb913d6cff9cfe9a6769d7efe4a7b9f23de0f4",
        "patch": "@@ -56,11 +56,24 @@ struct CLockLocation {\n };\n \n typedef std::vector<std::pair<void*, CLockLocation> > LockStack;\n+typedef std::map<std::pair<void*, void*>, LockStack> LockOrders;\n+typedef std::set<std::pair<void*, void*> > InvLockOrders;\n \n-static boost::mutex dd_mutex;\n-static std::map<std::pair<void*, void*>, LockStack> lockorders;\n-static boost::thread_specific_ptr<LockStack> lockstack;\n+struct LockData {\n+    // Very ugly hack: as the global constructs and destructors run single\n+    // threaded, we use this boolean to know whether LockData still exists,\n+    // as DeleteLock can get called by global CCriticalSection destructors\n+    // after LockData disappears.\n+    bool available;\n+    LockData() : available(true) {}\n+    ~LockData() { available = false; }\n \n+    LockOrders lockorders;\n+    InvLockOrders invlockorders;\n+    boost::mutex dd_mutex;\n+} static lockdata;\n+\n+boost::thread_specific_ptr<LockStack> lockstack;\n \n static void potential_deadlock_detected(const std::pair<void*, void*>& mismatch, const LockStack& s1, const LockStack& s2)\n {\n@@ -117,7 +130,7 @@ static void push_lock(void* c, const CLockLocation& locklocation, bool fTry)\n     if (lockstack.get() == NULL)\n         lockstack.reset(new LockStack);\n \n-    dd_mutex.lock();\n+    boost::unique_lock<boost::mutex> lock(lockdata.dd_mutex);\n \n     (*lockstack).push_back(std::make_pair(c, locklocation));\n \n@@ -127,23 +140,21 @@ static void push_lock(void* c, const CLockLocation& locklocation, bool fTry)\n                 break;\n \n             std::pair<void*, void*> p1 = std::make_pair(i.first, c);\n-            if (lockorders.count(p1))\n+            if (lockdata.lockorders.count(p1))\n                 continue;\n-            lockorders[p1] = (*lockstack);\n+            lockdata.lockorders[p1] = (*lockstack);\n \n             std::pair<void*, void*> p2 = std::make_pair(c, i.first);\n-            if (lockorders.count(p2))\n-                potential_deadlock_detected(p1, lockorders[p2], lockorders[p1]);\n+            lockdata.invlockorders.insert(p2);\n+            if (lockdata.lockorders.count(p2))\n+                potential_deadlock_detected(p1, lockdata.lockorders[p2], lockdata.lockorders[p1]);\n         }\n     }\n-    dd_mutex.unlock();\n }\n \n static void pop_lock()\n {\n-    dd_mutex.lock();\n     (*lockstack).pop_back();\n-    dd_mutex.unlock();\n }\n \n void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry)\n@@ -173,4 +184,26 @@ void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine,\n     abort();\n }\n \n+void DeleteLock(void* cs)\n+{\n+    if (!lockdata.available) {\n+        // We're already shutting down.\n+        return;\n+    }\n+    boost::unique_lock<boost::mutex> lock(lockdata.dd_mutex);\n+    std::pair<void*, void*> item = std::make_pair(cs, (void*)0);\n+    LockOrders::iterator it = lockdata.lockorders.lower_bound(item);\n+    while (it != lockdata.lockorders.end() && it->first.first == cs) {\n+        std::pair<void*, void*> invitem = std::make_pair(it->first.second, it->first.first);\n+        lockdata.invlockorders.erase(invitem);\n+        lockdata.lockorders.erase(it++);\n+    }\n+    InvLockOrders::iterator invit = lockdata.invlockorders.lower_bound(item);\n+    while (invit != lockdata.invlockorders.end() && invit->first == cs) {\n+        std::pair<void*, void*> invinvitem = std::make_pair(invit->second, invit->first);\n+        lockdata.lockorders.erase(invinvitem);\n+        lockdata.invlockorders.erase(invit++);\n+    }\n+}\n+\n #endif /* DEBUG_LOCKORDER */"
      },
      {
        "sha": "0c58fb6b4e94cbb20081388b67da5b9984c03cba",
        "filename": "src/sync.h",
        "status": "modified",
        "additions": 21,
        "deletions": 12,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/5eeb913d6cff9cfe9a6769d7efe4a7b9f23de0f4/src/sync.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/5eeb913d6cff9cfe9a6769d7efe4a7b9f23de0f4/src/sync.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/sync.h?ref=5eeb913d6cff9cfe9a6769d7efe4a7b9f23de0f4",
        "patch": "@@ -71,30 +71,39 @@ class LOCKABLE AnnotatedMixin : public PARENT\n     }\n };\n \n-/**\n- * Wrapped boost mutex: supports recursive locking, but no waiting\n- * TODO: We should move away from using the recursive lock by default.\n- */\n-typedef AnnotatedMixin<boost::recursive_mutex> CCriticalSection;\n-\n-/** Wrapped boost mutex: supports waiting but not recursive locking */\n-typedef AnnotatedMixin<boost::mutex> CWaitableCriticalSection;\n-\n-/** Just a typedef for boost::condition_variable, can be wrapped later if desired */\n-typedef boost::condition_variable CConditionVariable;\n-\n #ifdef DEBUG_LOCKORDER\n void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false);\n void LeaveCritical();\n std::string LocksHeld();\n void AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs);\n+void DeleteLock(void* cs);\n #else\n void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs, bool fTry = false) {}\n void static inline LeaveCritical() {}\n void static inline AssertLockHeldInternal(const char* pszName, const char* pszFile, int nLine, void* cs) {}\n+void static inline DeleteLock(void* cs) {}\n #endif\n #define AssertLockHeld(cs) AssertLockHeldInternal(#cs, __FILE__, __LINE__, &cs)\n \n+/**\n+ * Wrapped boost mutex: supports recursive locking, but no waiting\n+ * TODO: We should move away from using the recursive lock by default.\n+ */\n+class CCriticalSection : public AnnotatedMixin<boost::recursive_mutex>\n+{\n+public:\n+    ~CCriticalSection() {\n+        DeleteLock((void*)this);\n+    }\n+};\n+\n+typedef CCriticalSection CDynamicCriticalSection;\n+/** Wrapped boost mutex: supports waiting but not recursive locking */\n+typedef AnnotatedMixin<boost::mutex> CWaitableCriticalSection;\n+\n+/** Just a typedef for boost::condition_variable, can be wrapped later if desired */\n+typedef boost::condition_variable CConditionVariable;\n+\n #ifdef DEBUG_LOCKCONTENTION\n void PrintLockContention(const char* pszName, const char* pszFile, int nLine);\n #endif"
      }
    ]
  }
]