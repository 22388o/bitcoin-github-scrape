[
  {
    "sha": "8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZmU5OWJkYjBlNDY2NGQxYmQ2Njc5YmNhZjBjZGRhZDA2NDUxNDcy",
    "commit": {
      "author": {
        "name": "admin",
        "email": "admin@bitvote.one",
        "date": "2018-01-23T12:04:18Z"
      },
      "committer": {
        "name": "admin",
        "email": "admin@bitvote.one",
        "date": "2018-01-23T12:04:18Z"
      },
      "message": "BitVote @ 505050 by CryptoNight",
      "tree": {
        "sha": "2ecfdd88aa0abb3b8bc7381bf175e801b75bdf25",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2ecfdd88aa0abb3b8bc7381bf175e801b75bdf25"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/comments",
    "author": {
      "login": "bitcoinvote",
      "id": 34435980,
      "node_id": "MDQ6VXNlcjM0NDM1OTgw",
      "avatar_url": "https://avatars.githubusercontent.com/u/34435980?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bitcoinvote",
      "html_url": "https://github.com/bitcoinvote",
      "followers_url": "https://api.github.com/users/bitcoinvote/followers",
      "following_url": "https://api.github.com/users/bitcoinvote/following{/other_user}",
      "gists_url": "https://api.github.com/users/bitcoinvote/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bitcoinvote/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bitcoinvote/subscriptions",
      "organizations_url": "https://api.github.com/users/bitcoinvote/orgs",
      "repos_url": "https://api.github.com/users/bitcoinvote/repos",
      "events_url": "https://api.github.com/users/bitcoinvote/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bitcoinvote/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "bitcoinvote",
      "id": 34435980,
      "node_id": "MDQ6VXNlcjM0NDM1OTgw",
      "avatar_url": "https://avatars.githubusercontent.com/u/34435980?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bitcoinvote",
      "html_url": "https://github.com/bitcoinvote",
      "followers_url": "https://api.github.com/users/bitcoinvote/followers",
      "following_url": "https://api.github.com/users/bitcoinvote/following{/other_user}",
      "gists_url": "https://api.github.com/users/bitcoinvote/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bitcoinvote/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bitcoinvote/subscriptions",
      "organizations_url": "https://api.github.com/users/bitcoinvote/orgs",
      "repos_url": "https://api.github.com/users/bitcoinvote/repos",
      "events_url": "https://api.github.com/users/bitcoinvote/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bitcoinvote/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d4991c0cbb8a5464add1b64268eccdbfd3026d6e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d4991c0cbb8a5464add1b64268eccdbfd3026d6e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d4991c0cbb8a5464add1b64268eccdbfd3026d6e"
      }
    ],
    "stats": {
      "total": 58053,
      "additions": 32034,
      "deletions": 26019
    },
    "files": [
      {
        "sha": "2dac41502664e0b55f57e95e201a0ee00aaf1472",
        "filename": "README.md",
        "status": "modified",
        "additions": 13,
        "deletions": 22,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/README.md?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,44 +1,35 @@\n-Bitcoin Core integration/staging tree\n+Bitvote integration/staging tree\n =====================================\n \n-[![Build Status](https://travis-ci.org/bitcoin/bitcoin.svg?branch=master)](https://travis-ci.org/bitcoin/bitcoin)\n+http://www.bitvote.one\n \n-https://bitcoincore.org\n-\n-What is Bitcoin?\n+What is Bitvote?\n ----------------\n \n-Bitcoin is an experimental digital currency that enables instant payments to\n-anyone, anywhere in the world. Bitcoin uses peer-to-peer technology to operate\n-with no central authority: managing transactions and issuing money are carried\n-out collectively by the network. Bitcoin Core is the name of open source\n-software which enables the use of this currency.\n+Bitvote is a fork of Bitcoin, and its abbreviation is BTV. There will be no premining and additional issuance.\n+Bitvote uses the CryptoNight algorithm, which responds to Satoshi Nakamoto's vision of one-CPU-one-vote and true decentralization.\n+Bitvote establishes a foundation and promotes a sustainable development of communities.\n+Features such as smart contract, lightning network and others will be added to Bitvote finally.\n \n For more information, as well as an immediately useable, binary version of\n-the Bitcoin Core software, see https://bitcoin.org/en/download, or read the\n-[original whitepaper](https://bitcoincore.org/bitcoin.pdf).\n+the Bitvote software, see http://www.bitvote.one, or read the\n+[whitepaper](https://www.bitvote.one/bitvote.pdf)\uff08[\u4e2d\u6587\u7248](https://www.bitvote.one/bitvote-cn.pdf)\uff09.\n \n License\n -------\n \n-Bitcoin Core is released under the terms of the MIT license. See [COPYING](COPYING) for more\n+Bitvote is released under the terms of the MIT license. See [COPYING](COPYING) for more\n information or see https://opensource.org/licenses/MIT.\n \n Development Process\n -------------------\n \n The `master` branch is regularly built and tested, but is not guaranteed to be\n-completely stable. [Tags](https://github.com/bitcoin/bitcoin/tags) are created\n-regularly to indicate new official, stable release versions of Bitcoin Core.\n+completely stable. [Tags](https://github.com/bitvote/bitcoin/tags) are created\n+regularly to indicate new official, stable release versions of Bitvote.\n \n The contribution workflow is described in [CONTRIBUTING.md](CONTRIBUTING.md).\n \n-The developer [mailing list](https://lists.linuxfoundation.org/mailman/listinfo/bitcoin-dev)\n-should be used to discuss complicated or controversial changes before working\n-on a patch set.\n-\n-Developer IRC can be found on Freenode at #bitcoin-core-dev.\n-\n Testing\n -------\n \n@@ -71,7 +62,7 @@ Translations\n ------------\n \n Changes to translations as well as new translations can be submitted to\n-[Bitcoin Core's Transifex page](https://www.transifex.com/projects/p/bitcoin/).\n+[Bitvote's Transifex page](https://www.transifex.com/projects/p/bitcoin/).\n \n Translations are periodically pulled from Transifex and merged into the git repository. See the\n [translation process](doc/translation_process.md) for details on how this works."
      },
      {
        "sha": "48442ad4d35e0b8ef2c48f0c27bb3cbefe2bea10",
        "filename": "src/btv_const.h",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/btv_const.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/btv_const.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/btv_const.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,18 @@\n+// Copyright (c) 2017 BTV Team\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#ifndef BTV_CONST_H\r\n+#define BTV_CONST_H\r\n+\r\n+#define BTV_FUND_RATIO 5\r\n+#define BTV_FUND_ADDR \"18NTmvi7FFeF8yJ1D7awMmXJYX3JVv9iUe\"\r\n+#define BTV_BRANCH_HEIGHT 505050\r\n+#define BTV_BRANCH_HEIGHT_WINDOW 506016\r\n+#define BTV_BRANCH_VERSION_MASK 0x04000000\r\n+#define BTV_BRANCH_POW_LIMIT \"0000ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\"\r\n+\r\n+const unsigned char g_btvFundCheck[] = { 0x76, 0xa9, 0x14, 0x50, 0xd7, 0xf7, 0x4a, 0xad, 0x16, 0x8a, 0xfd, 0x00, 0xd4, 0xce, 0xed, 0x49, 0xf5, 0xf6, 0x89, 0xee, 0x11, 0x9f, 0x2b, 0x88, 0xac };\r\n+\r\n+\r\n+#endif // BTV_CONST_H\r"
      },
      {
        "sha": "9d6d5c1fdbd14643f31f7d60c6e0971fb2ea6e2c",
        "filename": "src/chain.h",
        "status": "modified",
        "additions": 496,
        "deletions": 494,
        "changes": 990,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/chain.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/chain.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chain.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,494 +1,496 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_CHAIN_H\n-#define BITCOIN_CHAIN_H\n-\n-#include <arith_uint256.h>\n-#include <primitives/block.h>\n-#include <pow.h>\n-#include <tinyformat.h>\n-#include <uint256.h>\n-\n-#include <vector>\n-\n-/**\n- * Maximum amount of time that a block timestamp is allowed to exceed the\n- * current network-adjusted time before the block will be accepted.\n- */\n-static const int64_t MAX_FUTURE_BLOCK_TIME = 2 * 60 * 60;\n-\n-/**\n- * Timestamp window used as a grace period by code that compares external\n- * timestamps (such as timestamps passed to RPCs, or wallet key creation times)\n- * to block timestamps. This should be set at least as high as\n- * MAX_FUTURE_BLOCK_TIME.\n- */\n-static const int64_t TIMESTAMP_WINDOW = MAX_FUTURE_BLOCK_TIME;\n-\n-class CBlockFileInfo\n-{\n-public:\n-    unsigned int nBlocks;      //!< number of blocks stored in file\n-    unsigned int nSize;        //!< number of used bytes of block file\n-    unsigned int nUndoSize;    //!< number of used bytes in the undo file\n-    unsigned int nHeightFirst; //!< lowest height of block in file\n-    unsigned int nHeightLast;  //!< highest height of block in file\n-    uint64_t nTimeFirst;       //!< earliest time of block in file\n-    uint64_t nTimeLast;        //!< latest time of block in file\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITE(VARINT(nBlocks));\n-        READWRITE(VARINT(nSize));\n-        READWRITE(VARINT(nUndoSize));\n-        READWRITE(VARINT(nHeightFirst));\n-        READWRITE(VARINT(nHeightLast));\n-        READWRITE(VARINT(nTimeFirst));\n-        READWRITE(VARINT(nTimeLast));\n-    }\n-\n-     void SetNull() {\n-         nBlocks = 0;\n-         nSize = 0;\n-         nUndoSize = 0;\n-         nHeightFirst = 0;\n-         nHeightLast = 0;\n-         nTimeFirst = 0;\n-         nTimeLast = 0;\n-     }\n-\n-     CBlockFileInfo() {\n-         SetNull();\n-     }\n-\n-     std::string ToString() const;\n-\n-     /** update statistics (does not update nSize) */\n-     void AddBlock(unsigned int nHeightIn, uint64_t nTimeIn) {\n-         if (nBlocks==0 || nHeightFirst > nHeightIn)\n-             nHeightFirst = nHeightIn;\n-         if (nBlocks==0 || nTimeFirst > nTimeIn)\n-             nTimeFirst = nTimeIn;\n-         nBlocks++;\n-         if (nHeightIn > nHeightLast)\n-             nHeightLast = nHeightIn;\n-         if (nTimeIn > nTimeLast)\n-             nTimeLast = nTimeIn;\n-     }\n-};\n-\n-struct CDiskBlockPos\n-{\n-    int nFile;\n-    unsigned int nPos;\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITE(VARINT(nFile));\n-        READWRITE(VARINT(nPos));\n-    }\n-\n-    CDiskBlockPos() {\n-        SetNull();\n-    }\n-\n-    CDiskBlockPos(int nFileIn, unsigned int nPosIn) {\n-        nFile = nFileIn;\n-        nPos = nPosIn;\n-    }\n-\n-    friend bool operator==(const CDiskBlockPos &a, const CDiskBlockPos &b) {\n-        return (a.nFile == b.nFile && a.nPos == b.nPos);\n-    }\n-\n-    friend bool operator!=(const CDiskBlockPos &a, const CDiskBlockPos &b) {\n-        return !(a == b);\n-    }\n-\n-    void SetNull() { nFile = -1; nPos = 0; }\n-    bool IsNull() const { return (nFile == -1); }\n-\n-    std::string ToString() const\n-    {\n-        return strprintf(\"CBlockDiskPos(nFile=%i, nPos=%i)\", nFile, nPos);\n-    }\n-\n-};\n-\n-enum BlockStatus: uint32_t {\n-    //! Unused.\n-    BLOCK_VALID_UNKNOWN      =    0,\n-\n-    //! Parsed, version ok, hash satisfies claimed PoW, 1 <= vtx count <= max, timestamp not in future\n-    BLOCK_VALID_HEADER       =    1,\n-\n-    //! All parent headers found, difficulty matches, timestamp >= median previous, checkpoint. Implies all parents\n-    //! are also at least TREE.\n-    BLOCK_VALID_TREE         =    2,\n-\n-    /**\n-     * Only first tx is coinbase, 2 <= coinbase input script length <= 100, transactions valid, no duplicate txids,\n-     * sigops, size, merkle root. Implies all parents are at least TREE but not necessarily TRANSACTIONS. When all\n-     * parent blocks also have TRANSACTIONS, CBlockIndex::nChainTx will be set.\n-     */\n-    BLOCK_VALID_TRANSACTIONS =    3,\n-\n-    //! Outputs do not overspend inputs, no double spends, coinbase output ok, no immature coinbase spends, BIP30.\n-    //! Implies all parents are also at least CHAIN.\n-    BLOCK_VALID_CHAIN        =    4,\n-\n-    //! Scripts & signatures ok. Implies all parents are also at least SCRIPTS.\n-    BLOCK_VALID_SCRIPTS      =    5,\n-\n-    //! All validity bits.\n-    BLOCK_VALID_MASK         =   BLOCK_VALID_HEADER | BLOCK_VALID_TREE | BLOCK_VALID_TRANSACTIONS |\n-                                 BLOCK_VALID_CHAIN | BLOCK_VALID_SCRIPTS,\n-\n-    BLOCK_HAVE_DATA          =    8, //!< full block available in blk*.dat\n-    BLOCK_HAVE_UNDO          =   16, //!< undo data available in rev*.dat\n-    BLOCK_HAVE_MASK          =   BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO,\n-\n-    BLOCK_FAILED_VALID       =   32, //!< stage after last reached validness failed\n-    BLOCK_FAILED_CHILD       =   64, //!< descends from failed block\n-    BLOCK_FAILED_MASK        =   BLOCK_FAILED_VALID | BLOCK_FAILED_CHILD,\n-\n-    BLOCK_OPT_WITNESS       =   128, //!< block data in blk*.data was received with a witness-enforcing client\n-};\n-\n-/** The block chain is a tree shaped structure starting with the\n- * genesis block at the root, with each block potentially having multiple\n- * candidates to be the next block. A blockindex may have multiple pprev pointing\n- * to it, but at most one of them can be part of the currently active branch.\n- */\n-class CBlockIndex\n-{\n-public:\n-    //! pointer to the hash of the block, if any. Memory is owned by this CBlockIndex\n-    const uint256* phashBlock;\n-\n-    //! pointer to the index of the predecessor of this block\n-    CBlockIndex* pprev;\n-\n-    //! pointer to the index of some further predecessor of this block\n-    CBlockIndex* pskip;\n-\n-    //! height of the entry in the chain. The genesis block has height 0\n-    int nHeight;\n-\n-    //! Which # file this block is stored in (blk?????.dat)\n-    int nFile;\n-\n-    //! Byte offset within blk?????.dat where this block's data is stored\n-    unsigned int nDataPos;\n-\n-    //! Byte offset within rev?????.dat where this block's undo data is stored\n-    unsigned int nUndoPos;\n-\n-    //! (memory only) Total amount of work (expected number of hashes) in the chain up to and including this block\n-    arith_uint256 nChainWork;\n-\n-    //! Number of transactions in this block.\n-    //! Note: in a potential headers-first mode, this number cannot be relied upon\n-    unsigned int nTx;\n-\n-    //! (memory only) Number of transactions in the chain up to and including this block.\n-    //! This value will be non-zero only if and only if transactions for this block and all its parents are available.\n-    //! Change to 64-bit type when necessary; won't happen before 2030\n-    unsigned int nChainTx;\n-\n-    //! Verification status of this block. See enum BlockStatus\n-    uint32_t nStatus;\n-\n-    //! block header\n-    int32_t nVersion;\n-    uint256 hashMerkleRoot;\n-    uint32_t nTime;\n-    uint32_t nBits;\n-    uint32_t nNonce;\n-\n-    //! (memory only) Sequential id assigned to distinguish order in which blocks are received.\n-    int32_t nSequenceId;\n-\n-    //! (memory only) Maximum nTime in the chain up to and including this block.\n-    unsigned int nTimeMax;\n-\n-    void SetNull()\n-    {\n-        phashBlock = nullptr;\n-        pprev = nullptr;\n-        pskip = nullptr;\n-        nHeight = 0;\n-        nFile = 0;\n-        nDataPos = 0;\n-        nUndoPos = 0;\n-        nChainWork = arith_uint256();\n-        nTx = 0;\n-        nChainTx = 0;\n-        nStatus = 0;\n-        nSequenceId = 0;\n-        nTimeMax = 0;\n-\n-        nVersion       = 0;\n-        hashMerkleRoot = uint256();\n-        nTime          = 0;\n-        nBits          = 0;\n-        nNonce         = 0;\n-    }\n-\n-    CBlockIndex()\n-    {\n-        SetNull();\n-    }\n-\n-    explicit CBlockIndex(const CBlockHeader& block)\n-    {\n-        SetNull();\n-\n-        nVersion       = block.nVersion;\n-        hashMerkleRoot = block.hashMerkleRoot;\n-        nTime          = block.nTime;\n-        nBits          = block.nBits;\n-        nNonce         = block.nNonce;\n-    }\n-\n-    CDiskBlockPos GetBlockPos() const {\n-        CDiskBlockPos ret;\n-        if (nStatus & BLOCK_HAVE_DATA) {\n-            ret.nFile = nFile;\n-            ret.nPos  = nDataPos;\n-        }\n-        return ret;\n-    }\n-\n-    CDiskBlockPos GetUndoPos() const {\n-        CDiskBlockPos ret;\n-        if (nStatus & BLOCK_HAVE_UNDO) {\n-            ret.nFile = nFile;\n-            ret.nPos  = nUndoPos;\n-        }\n-        return ret;\n-    }\n-\n-    CBlockHeader GetBlockHeader() const\n-    {\n-        CBlockHeader block;\n-        block.nVersion       = nVersion;\n-        if (pprev)\n-            block.hashPrevBlock = pprev->GetBlockHash();\n-        block.hashMerkleRoot = hashMerkleRoot;\n-        block.nTime          = nTime;\n-        block.nBits          = nBits;\n-        block.nNonce         = nNonce;\n-        return block;\n-    }\n-\n-    uint256 GetBlockHash() const\n-    {\n-        return *phashBlock;\n-    }\n-\n-    int64_t GetBlockTime() const\n-    {\n-        return (int64_t)nTime;\n-    }\n-\n-    int64_t GetBlockTimeMax() const\n-    {\n-        return (int64_t)nTimeMax;\n-    }\n-\n-    static constexpr int nMedianTimeSpan = 11;\n-\n-    int64_t GetMedianTimePast() const\n-    {\n-        int64_t pmedian[nMedianTimeSpan];\n-        int64_t* pbegin = &pmedian[nMedianTimeSpan];\n-        int64_t* pend = &pmedian[nMedianTimeSpan];\n-\n-        const CBlockIndex* pindex = this;\n-        for (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)\n-            *(--pbegin) = pindex->GetBlockTime();\n-\n-        std::sort(pbegin, pend);\n-        return pbegin[(pend - pbegin)/2];\n-    }\n-\n-    std::string ToString() const\n-    {\n-        return strprintf(\"CBlockIndex(pprev=%p, nHeight=%d, merkle=%s, hashBlock=%s)\",\n-            pprev, nHeight,\n-            hashMerkleRoot.ToString(),\n-            GetBlockHash().ToString());\n-    }\n-\n-    //! Check whether this block index entry is valid up to the passed validity level.\n-    bool IsValid(enum BlockStatus nUpTo = BLOCK_VALID_TRANSACTIONS) const\n-    {\n-        assert(!(nUpTo & ~BLOCK_VALID_MASK)); // Only validity flags allowed.\n-        if (nStatus & BLOCK_FAILED_MASK)\n-            return false;\n-        return ((nStatus & BLOCK_VALID_MASK) >= nUpTo);\n-    }\n-\n-    //! Raise the validity level of this block index entry.\n-    //! Returns true if the validity was changed.\n-    bool RaiseValidity(enum BlockStatus nUpTo)\n-    {\n-        assert(!(nUpTo & ~BLOCK_VALID_MASK)); // Only validity flags allowed.\n-        if (nStatus & BLOCK_FAILED_MASK)\n-            return false;\n-        if ((nStatus & BLOCK_VALID_MASK) < nUpTo) {\n-            nStatus = (nStatus & ~BLOCK_VALID_MASK) | nUpTo;\n-            return true;\n-        }\n-        return false;\n-    }\n-\n-    //! Build the skiplist pointer for this entry.\n-    void BuildSkip();\n-\n-    //! Efficiently find an ancestor of this block.\n-    CBlockIndex* GetAncestor(int height);\n-    const CBlockIndex* GetAncestor(int height) const;\n-};\n-\n-arith_uint256 GetBlockProof(const CBlockIndex& block);\n-/** Return the time it would take to redo the work difference between from and to, assuming the current hashrate corresponds to the difficulty at tip, in seconds. */\n-int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& from, const CBlockIndex& tip, const Consensus::Params&);\n-/** Find the forking point between two chain tips. */\n-const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb);\n-\n-\n-/** Used to marshal pointers into hashes for db storage. */\n-class CDiskBlockIndex : public CBlockIndex\n-{\n-public:\n-    uint256 hashPrev;\n-\n-    CDiskBlockIndex() {\n-        hashPrev = uint256();\n-    }\n-\n-    explicit CDiskBlockIndex(const CBlockIndex* pindex) : CBlockIndex(*pindex) {\n-        hashPrev = (pprev ? pprev->GetBlockHash() : uint256());\n-    }\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n-        int _nVersion = s.GetVersion();\n-        if (!(s.GetType() & SER_GETHASH))\n-            READWRITE(VARINT(_nVersion));\n-\n-        READWRITE(VARINT(nHeight));\n-        READWRITE(VARINT(nStatus));\n-        READWRITE(VARINT(nTx));\n-        if (nStatus & (BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO))\n-            READWRITE(VARINT(nFile));\n-        if (nStatus & BLOCK_HAVE_DATA)\n-            READWRITE(VARINT(nDataPos));\n-        if (nStatus & BLOCK_HAVE_UNDO)\n-            READWRITE(VARINT(nUndoPos));\n-\n-        // block header\n-        READWRITE(this->nVersion);\n-        READWRITE(hashPrev);\n-        READWRITE(hashMerkleRoot);\n-        READWRITE(nTime);\n-        READWRITE(nBits);\n-        READWRITE(nNonce);\n-    }\n-\n-    uint256 GetBlockHash() const\n-    {\n-        CBlockHeader block;\n-        block.nVersion        = nVersion;\n-        block.hashPrevBlock   = hashPrev;\n-        block.hashMerkleRoot  = hashMerkleRoot;\n-        block.nTime           = nTime;\n-        block.nBits           = nBits;\n-        block.nNonce          = nNonce;\n-        return block.GetHash();\n-    }\n-\n-\n-    std::string ToString() const\n-    {\n-        std::string str = \"CDiskBlockIndex(\";\n-        str += CBlockIndex::ToString();\n-        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s)\",\n-            GetBlockHash().ToString(),\n-            hashPrev.ToString());\n-        return str;\n-    }\n-};\n-\n-/** An in-memory indexed chain of blocks. */\n-class CChain {\n-private:\n-    std::vector<CBlockIndex*> vChain;\n-\n-public:\n-    /** Returns the index entry for the genesis block of this chain, or nullptr if none. */\n-    CBlockIndex *Genesis() const {\n-        return vChain.size() > 0 ? vChain[0] : nullptr;\n-    }\n-\n-    /** Returns the index entry for the tip of this chain, or nullptr if none. */\n-    CBlockIndex *Tip() const {\n-        return vChain.size() > 0 ? vChain[vChain.size() - 1] : nullptr;\n-    }\n-\n-    /** Returns the index entry at a particular height in this chain, or nullptr if no such height exists. */\n-    CBlockIndex *operator[](int nHeight) const {\n-        if (nHeight < 0 || nHeight >= (int)vChain.size())\n-            return nullptr;\n-        return vChain[nHeight];\n-    }\n-\n-    /** Compare two chains efficiently. */\n-    friend bool operator==(const CChain &a, const CChain &b) {\n-        return a.vChain.size() == b.vChain.size() &&\n-               a.vChain[a.vChain.size() - 1] == b.vChain[b.vChain.size() - 1];\n-    }\n-\n-    /** Efficiently check whether a block is present in this chain. */\n-    bool Contains(const CBlockIndex *pindex) const {\n-        return (*this)[pindex->nHeight] == pindex;\n-    }\n-\n-    /** Find the successor of a block in this chain, or nullptr if the given index is not found or is the tip. */\n-    CBlockIndex *Next(const CBlockIndex *pindex) const {\n-        if (Contains(pindex))\n-            return (*this)[pindex->nHeight + 1];\n-        else\n-            return nullptr;\n-    }\n-\n-    /** Return the maximal height in the chain. Is equal to chain.Tip() ? chain.Tip()->nHeight : -1. */\n-    int Height() const {\n-        return vChain.size() - 1;\n-    }\n-\n-    /** Set/initialize a chain with a given tip. */\n-    void SetTip(CBlockIndex *pindex);\n-\n-    /** Return a CBlockLocator that refers to a block in this chain (by default the tip). */\n-    CBlockLocator GetLocator(const CBlockIndex *pindex = nullptr) const;\n-\n-    /** Find the last common block between this chain and a block index entry. */\n-    const CBlockIndex *FindFork(const CBlockIndex *pindex) const;\n-\n-    /** Find the earliest block with timestamp equal or greater than the given. */\n-    CBlockIndex* FindEarliestAtLeast(int64_t nTime) const;\n-};\n-\n-#endif // BITCOIN_CHAIN_H\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\r\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#ifndef BITCOIN_CHAIN_H\r\n+#define BITCOIN_CHAIN_H\r\n+\r\n+#include <arith_uint256.h>\r\n+#include <primitives/block.h>\r\n+#include <pow.h>\r\n+#include <tinyformat.h>\r\n+#include <uint256.h>\r\n+\r\n+#include <vector>\r\n+\r\n+/**\r\n+ * Maximum amount of time that a block timestamp is allowed to exceed the\r\n+ * current network-adjusted time before the block will be accepted.\r\n+ */\r\n+static const int64_t MAX_FUTURE_BLOCK_TIME = 2 * 60 * 60;\r\n+\r\n+/**\r\n+ * Timestamp window used as a grace period by code that compares external\r\n+ * timestamps (such as timestamps passed to RPCs, or wallet key creation times)\r\n+ * to block timestamps. This should be set at least as high as\r\n+ * MAX_FUTURE_BLOCK_TIME.\r\n+ */\r\n+static const int64_t TIMESTAMP_WINDOW = MAX_FUTURE_BLOCK_TIME;\r\n+\r\n+class CBlockFileInfo\r\n+{\r\n+public:\r\n+    unsigned int nBlocks;      //!< number of blocks stored in file\r\n+    unsigned int nSize;        //!< number of used bytes of block file\r\n+    unsigned int nUndoSize;    //!< number of used bytes in the undo file\r\n+    unsigned int nHeightFirst; //!< lowest height of block in file\r\n+    unsigned int nHeightLast;  //!< highest height of block in file\r\n+    uint64_t nTimeFirst;       //!< earliest time of block in file\r\n+    uint64_t nTimeLast;        //!< latest time of block in file\r\n+\r\n+    ADD_SERIALIZE_METHODS;\r\n+\r\n+    template <typename Stream, typename Operation>\r\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\r\n+        READWRITE(VARINT(nBlocks));\r\n+        READWRITE(VARINT(nSize));\r\n+        READWRITE(VARINT(nUndoSize));\r\n+        READWRITE(VARINT(nHeightFirst));\r\n+        READWRITE(VARINT(nHeightLast));\r\n+        READWRITE(VARINT(nTimeFirst));\r\n+        READWRITE(VARINT(nTimeLast));\r\n+    }\r\n+\r\n+     void SetNull() {\r\n+         nBlocks = 0;\r\n+         nSize = 0;\r\n+         nUndoSize = 0;\r\n+         nHeightFirst = 0;\r\n+         nHeightLast = 0;\r\n+         nTimeFirst = 0;\r\n+         nTimeLast = 0;\r\n+     }\r\n+\r\n+     CBlockFileInfo() {\r\n+         SetNull();\r\n+     }\r\n+\r\n+     std::string ToString() const;\r\n+\r\n+     /** update statistics (does not update nSize) */\r\n+     void AddBlock(unsigned int nHeightIn, uint64_t nTimeIn) {\r\n+         if (nBlocks==0 || nHeightFirst > nHeightIn)\r\n+             nHeightFirst = nHeightIn;\r\n+         if (nBlocks==0 || nTimeFirst > nTimeIn)\r\n+             nTimeFirst = nTimeIn;\r\n+         nBlocks++;\r\n+         if (nHeightIn > nHeightLast)\r\n+             nHeightLast = nHeightIn;\r\n+         if (nTimeIn > nTimeLast)\r\n+             nTimeLast = nTimeIn;\r\n+     }\r\n+};\r\n+\r\n+struct CDiskBlockPos\r\n+{\r\n+    int nFile;\r\n+    unsigned int nPos;\r\n+\r\n+    ADD_SERIALIZE_METHODS;\r\n+\r\n+    template <typename Stream, typename Operation>\r\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\r\n+        READWRITE(VARINT(nFile));\r\n+        READWRITE(VARINT(nPos));\r\n+    }\r\n+\r\n+    CDiskBlockPos() {\r\n+        SetNull();\r\n+    }\r\n+\r\n+    CDiskBlockPos(int nFileIn, unsigned int nPosIn) {\r\n+        nFile = nFileIn;\r\n+        nPos = nPosIn;\r\n+    }\r\n+\r\n+    friend bool operator==(const CDiskBlockPos &a, const CDiskBlockPos &b) {\r\n+        return (a.nFile == b.nFile && a.nPos == b.nPos);\r\n+    }\r\n+\r\n+    friend bool operator!=(const CDiskBlockPos &a, const CDiskBlockPos &b) {\r\n+        return !(a == b);\r\n+    }\r\n+\r\n+    void SetNull() { nFile = -1; nPos = 0; }\r\n+    bool IsNull() const { return (nFile == -1); }\r\n+\r\n+    std::string ToString() const\r\n+    {\r\n+        return strprintf(\"CBlockDiskPos(nFile=%i, nPos=%i)\", nFile, nPos);\r\n+    }\r\n+\r\n+};\r\n+\r\n+enum BlockStatus: uint32_t {\r\n+    //! Unused.\r\n+    BLOCK_VALID_UNKNOWN      =    0,\r\n+\r\n+    //! Parsed, version ok, hash satisfies claimed PoW, 1 <= vtx count <= max, timestamp not in future\r\n+    BLOCK_VALID_HEADER       =    1,\r\n+\r\n+    //! All parent headers found, difficulty matches, timestamp >= median previous, checkpoint. Implies all parents\r\n+    //! are also at least TREE.\r\n+    BLOCK_VALID_TREE         =    2,\r\n+\r\n+    /**\r\n+     * Only first tx is coinbase, 2 <= coinbase input script length <= 100, transactions valid, no duplicate txids,\r\n+     * sigops, size, merkle root. Implies all parents are at least TREE but not necessarily TRANSACTIONS. When all\r\n+     * parent blocks also have TRANSACTIONS, CBlockIndex::nChainTx will be set.\r\n+     */\r\n+    BLOCK_VALID_TRANSACTIONS =    3,\r\n+\r\n+    //! Outputs do not overspend inputs, no double spends, coinbase output ok, no immature coinbase spends, BIP30.\r\n+    //! Implies all parents are also at least CHAIN.\r\n+    BLOCK_VALID_CHAIN        =    4,\r\n+\r\n+    //! Scripts & signatures ok. Implies all parents are also at least SCRIPTS.\r\n+    BLOCK_VALID_SCRIPTS      =    5,\r\n+\r\n+    //! All validity bits.\r\n+    BLOCK_VALID_MASK         =   BLOCK_VALID_HEADER | BLOCK_VALID_TREE | BLOCK_VALID_TRANSACTIONS |\r\n+                                 BLOCK_VALID_CHAIN | BLOCK_VALID_SCRIPTS,\r\n+\r\n+    BLOCK_HAVE_DATA          =    8, //!< full block available in blk*.dat\r\n+    BLOCK_HAVE_UNDO          =   16, //!< undo data available in rev*.dat\r\n+    BLOCK_HAVE_MASK          =   BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO,\r\n+\r\n+    BLOCK_FAILED_VALID       =   32, //!< stage after last reached validness failed\r\n+    BLOCK_FAILED_CHILD       =   64, //!< descends from failed block\r\n+    BLOCK_FAILED_MASK        =   BLOCK_FAILED_VALID | BLOCK_FAILED_CHILD,\r\n+\r\n+    BLOCK_OPT_WITNESS       =   128, //!< block data in blk*.data was received with a witness-enforcing client\r\n+};\r\n+\r\n+/** The block chain is a tree shaped structure starting with the\r\n+ * genesis block at the root, with each block potentially having multiple\r\n+ * candidates to be the next block. A blockindex may have multiple pprev pointing\r\n+ * to it, but at most one of them can be part of the currently active branch.\r\n+ */\r\n+class CBlockIndex\r\n+{\r\n+public:\r\n+    //! pointer to the hash of the block, if any. Memory is owned by this CBlockIndex\r\n+    const uint256* phashBlock;\r\n+\r\n+    //! pointer to the index of the predecessor of this block\r\n+    CBlockIndex* pprev;\r\n+\r\n+    //! pointer to the index of some further predecessor of this block\r\n+    CBlockIndex* pskip;\r\n+\r\n+    //! height of the entry in the chain. The genesis block has height 0\r\n+    int nHeight;\r\n+\r\n+    //! Which # file this block is stored in (blk?????.dat)\r\n+    int nFile;\r\n+\r\n+    //! Byte offset within blk?????.dat where this block's data is stored\r\n+    unsigned int nDataPos;\r\n+\r\n+    //! Byte offset within rev?????.dat where this block's undo data is stored\r\n+    unsigned int nUndoPos;\r\n+\r\n+    //! (memory only) Total amount of work (expected number of hashes) in the chain up to and including this block\r\n+    arith_uint256 nChainWork;\r\n+\r\n+    //! Number of transactions in this block.\r\n+    //! Note: in a potential headers-first mode, this number cannot be relied upon\r\n+    unsigned int nTx;\r\n+\r\n+    //! (memory only) Number of transactions in the chain up to and including this block.\r\n+    //! This value will be non-zero only if and only if transactions for this block and all its parents are available.\r\n+    //! Change to 64-bit type when necessary; won't happen before 2030\r\n+    unsigned int nChainTx;\r\n+\r\n+    //! Verification status of this block. See enum BlockStatus\r\n+    uint32_t nStatus;\r\n+\r\n+    //! block header\r\n+    int32_t nVersion;\r\n+    uint256 hashMerkleRoot;\r\n+    uint32_t nTime;\r\n+    uint32_t nBits;\r\n+    uint32_t nNonce;\r\n+\r\n+    //! (memory only) Sequential id assigned to distinguish order in which blocks are received.\r\n+    int32_t nSequenceId;\r\n+\r\n+    //! (memory only) Maximum nTime in the chain up to and including this block.\r\n+    unsigned int nTimeMax;\r\n+\r\n+    void SetNull()\r\n+    {\r\n+        phashBlock = nullptr;\r\n+        pprev = nullptr;\r\n+        pskip = nullptr;\r\n+        nHeight = 0;\r\n+        nFile = 0;\r\n+        nDataPos = 0;\r\n+        nUndoPos = 0;\r\n+        nChainWork = arith_uint256();\r\n+        nTx = 0;\r\n+        nChainTx = 0;\r\n+        nStatus = 0;\r\n+        nSequenceId = 0;\r\n+        nTimeMax = 0;\r\n+\r\n+        nVersion       = 0;\r\n+        hashMerkleRoot = uint256();\r\n+        nTime          = 0;\r\n+        nBits          = 0;\r\n+        nNonce         = 0;\r\n+    }\r\n+\r\n+    CBlockIndex()\r\n+    {\r\n+        SetNull();\r\n+    }\r\n+\r\n+    explicit CBlockIndex(const CBlockHeader& block)\r\n+    {\r\n+        SetNull();\r\n+\r\n+        nVersion       = block.nVersion;\r\n+        hashMerkleRoot = block.hashMerkleRoot;\r\n+        nTime          = block.nTime;\r\n+        nBits          = block.nBits;\r\n+        nNonce         = block.nNonce;\r\n+    }\r\n+\r\n+    CDiskBlockPos GetBlockPos() const {\r\n+        CDiskBlockPos ret;\r\n+        if (nStatus & BLOCK_HAVE_DATA) {\r\n+            ret.nFile = nFile;\r\n+            ret.nPos  = nDataPos;\r\n+        }\r\n+        return ret;\r\n+    }\r\n+\r\n+    CDiskBlockPos GetUndoPos() const {\r\n+        CDiskBlockPos ret;\r\n+        if (nStatus & BLOCK_HAVE_UNDO) {\r\n+            ret.nFile = nFile;\r\n+            ret.nPos  = nUndoPos;\r\n+        }\r\n+        return ret;\r\n+    }\r\n+\r\n+    CBlockHeader GetBlockHeader() const\r\n+    {\r\n+        CBlockHeader block;\r\n+        block.nVersion       = nVersion;\r\n+        if (pprev)\r\n+            block.hashPrevBlock = pprev->GetBlockHash();\r\n+        block.hashMerkleRoot = hashMerkleRoot;\r\n+        block.nTime          = nTime;\r\n+        block.nBits          = nBits;\r\n+        block.nNonce         = nNonce;\r\n+        return block;\r\n+    }\r\n+\r\n+    uint256 GetBlockHash() const\r\n+    {\r\n+        return *phashBlock;\r\n+    }\r\n+\r\n+    int64_t GetBlockTime() const\r\n+    {\r\n+        return (int64_t)nTime;\r\n+    }\r\n+\r\n+    int64_t GetBlockTimeMax() const\r\n+    {\r\n+        return (int64_t)nTimeMax;\r\n+    }\r\n+\r\n+    static constexpr int nMedianTimeSpan = 11;\r\n+\r\n+    int64_t GetMedianTimePast() const\r\n+    {\r\n+        int64_t pmedian[nMedianTimeSpan];\r\n+        int64_t* pbegin = &pmedian[nMedianTimeSpan];\r\n+        int64_t* pend = &pmedian[nMedianTimeSpan];\r\n+\r\n+        const CBlockIndex* pindex = this;\r\n+        for (int i = 0; i < nMedianTimeSpan && pindex; i++, pindex = pindex->pprev)\r\n+            *(--pbegin) = pindex->GetBlockTime();\r\n+\r\n+        std::sort(pbegin, pend);\r\n+        return pbegin[(pend - pbegin)/2];\r\n+    }\r\n+\r\n+    std::string ToString() const\r\n+    {\r\n+        return strprintf(\"CBlockIndex(pprev=%p, nHeight=%d, merkle=%s, hashBlock=%s)\",\r\n+            pprev, nHeight,\r\n+            hashMerkleRoot.ToString(),\r\n+            GetBlockHash().ToString());\r\n+    }\r\n+\r\n+    //! Check whether this block index entry is valid up to the passed validity level.\r\n+    bool IsValid(enum BlockStatus nUpTo = BLOCK_VALID_TRANSACTIONS) const\r\n+    {\r\n+        assert(!(nUpTo & ~BLOCK_VALID_MASK)); // Only validity flags allowed.\r\n+        if (nStatus & BLOCK_FAILED_MASK)\r\n+            return false;\r\n+        return ((nStatus & BLOCK_VALID_MASK) >= nUpTo);\r\n+    }\r\n+\r\n+    //! Raise the validity level of this block index entry.\r\n+    //! Returns true if the validity was changed.\r\n+    bool RaiseValidity(enum BlockStatus nUpTo)\r\n+    {\r\n+        assert(!(nUpTo & ~BLOCK_VALID_MASK)); // Only validity flags allowed.\r\n+        if (nStatus & BLOCK_FAILED_MASK)\r\n+            return false;\r\n+        if ((nStatus & BLOCK_VALID_MASK) < nUpTo) {\r\n+            nStatus = (nStatus & ~BLOCK_VALID_MASK) | nUpTo;\r\n+            return true;\r\n+        }\r\n+        return false;\r\n+    }\r\n+\r\n+    //! Build the skiplist pointer for this entry.\r\n+    void BuildSkip();\r\n+\r\n+    //! Efficiently find an ancestor of this block.\r\n+    CBlockIndex* GetAncestor(int height);\r\n+    const CBlockIndex* GetAncestor(int height) const;\r\n+\r\n+    bool IsBtvBranched() const { return nVersion & BTV_BRANCH_VERSION_MASK; };\r\n+};\r\n+\r\n+arith_uint256 GetBlockProof(const CBlockIndex& block);\r\n+/** Return the time it would take to redo the work difference between from and to, assuming the current hashrate corresponds to the difficulty at tip, in seconds. */\r\n+int64_t GetBlockProofEquivalentTime(const CBlockIndex& to, const CBlockIndex& from, const CBlockIndex& tip, const Consensus::Params&);\r\n+/** Find the forking point between two chain tips. */\r\n+const CBlockIndex* LastCommonAncestor(const CBlockIndex* pa, const CBlockIndex* pb);\r\n+\r\n+\r\n+/** Used to marshal pointers into hashes for db storage. */\r\n+class CDiskBlockIndex : public CBlockIndex\r\n+{\r\n+public:\r\n+    uint256 hashPrev;\r\n+\r\n+    CDiskBlockIndex() {\r\n+        hashPrev = uint256();\r\n+    }\r\n+\r\n+    explicit CDiskBlockIndex(const CBlockIndex* pindex) : CBlockIndex(*pindex) {\r\n+        hashPrev = (pprev ? pprev->GetBlockHash() : uint256());\r\n+    }\r\n+\r\n+    ADD_SERIALIZE_METHODS;\r\n+\r\n+    template <typename Stream, typename Operation>\r\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\r\n+        int _nVersion = s.GetVersion();\r\n+        if (!(s.GetType() & SER_GETHASH))\r\n+            READWRITE(VARINT(_nVersion));\r\n+\r\n+        READWRITE(VARINT(nHeight));\r\n+        READWRITE(VARINT(nStatus));\r\n+        READWRITE(VARINT(nTx));\r\n+        if (nStatus & (BLOCK_HAVE_DATA | BLOCK_HAVE_UNDO))\r\n+            READWRITE(VARINT(nFile));\r\n+        if (nStatus & BLOCK_HAVE_DATA)\r\n+            READWRITE(VARINT(nDataPos));\r\n+        if (nStatus & BLOCK_HAVE_UNDO)\r\n+            READWRITE(VARINT(nUndoPos));\r\n+\r\n+        // block header\r\n+        READWRITE(this->nVersion);\r\n+        READWRITE(hashPrev);\r\n+        READWRITE(hashMerkleRoot);\r\n+        READWRITE(nTime);\r\n+        READWRITE(nBits);\r\n+        READWRITE(nNonce);\r\n+    }\r\n+\r\n+    uint256 GetBlockHash() const\r\n+    {\r\n+        CBlockHeader block;\r\n+        block.nVersion        = nVersion;\r\n+        block.hashPrevBlock   = hashPrev;\r\n+        block.hashMerkleRoot  = hashMerkleRoot;\r\n+        block.nTime           = nTime;\r\n+        block.nBits           = nBits;\r\n+        block.nNonce          = nNonce;\r\n+        return block.GetHash();\r\n+    }\r\n+\r\n+\r\n+    std::string ToString() const\r\n+    {\r\n+        std::string str = \"CDiskBlockIndex(\";\r\n+        str += CBlockIndex::ToString();\r\n+        str += strprintf(\"\\n                hashBlock=%s, hashPrev=%s)\",\r\n+            GetBlockHash().ToString(),\r\n+            hashPrev.ToString());\r\n+        return str;\r\n+    }\r\n+};\r\n+\r\n+/** An in-memory indexed chain of blocks. */\r\n+class CChain {\r\n+private:\r\n+    std::vector<CBlockIndex*> vChain;\r\n+\r\n+public:\r\n+    /** Returns the index entry for the genesis block of this chain, or nullptr if none. */\r\n+    CBlockIndex *Genesis() const {\r\n+        return vChain.size() > 0 ? vChain[0] : nullptr;\r\n+    }\r\n+\r\n+    /** Returns the index entry for the tip of this chain, or nullptr if none. */\r\n+    CBlockIndex *Tip() const {\r\n+        return vChain.size() > 0 ? vChain[vChain.size() - 1] : nullptr;\r\n+    }\r\n+\r\n+    /** Returns the index entry at a particular height in this chain, or nullptr if no such height exists. */\r\n+    CBlockIndex *operator[](int nHeight) const {\r\n+        if (nHeight < 0 || nHeight >= (int)vChain.size())\r\n+            return nullptr;\r\n+        return vChain[nHeight];\r\n+    }\r\n+\r\n+    /** Compare two chains efficiently. */\r\n+    friend bool operator==(const CChain &a, const CChain &b) {\r\n+        return a.vChain.size() == b.vChain.size() &&\r\n+               a.vChain[a.vChain.size() - 1] == b.vChain[b.vChain.size() - 1];\r\n+    }\r\n+\r\n+    /** Efficiently check whether a block is present in this chain. */\r\n+    bool Contains(const CBlockIndex *pindex) const {\r\n+        return (*this)[pindex->nHeight] == pindex;\r\n+    }\r\n+\r\n+    /** Find the successor of a block in this chain, or nullptr if the given index is not found or is the tip. */\r\n+    CBlockIndex *Next(const CBlockIndex *pindex) const {\r\n+        if (Contains(pindex))\r\n+            return (*this)[pindex->nHeight + 1];\r\n+        else\r\n+            return nullptr;\r\n+    }\r\n+\r\n+    /** Return the maximal height in the chain. Is equal to chain.Tip() ? chain.Tip()->nHeight : -1. */\r\n+    int Height() const {\r\n+        return vChain.size() - 1;\r\n+    }\r\n+\r\n+    /** Set/initialize a chain with a given tip. */\r\n+    void SetTip(CBlockIndex *pindex);\r\n+\r\n+    /** Return a CBlockLocator that refers to a block in this chain (by default the tip). */\r\n+    CBlockLocator GetLocator(const CBlockIndex *pindex = nullptr) const;\r\n+\r\n+    /** Find the last common block between this chain and a block index entry. */\r\n+    const CBlockIndex *FindFork(const CBlockIndex *pindex) const;\r\n+\r\n+    /** Find the earliest block with timestamp equal or greater than the given. */\r\n+    CBlockIndex* FindEarliestAtLeast(int64_t nTime) const;\r\n+};\r\n+\r\n+#endif // BITCOIN_CHAIN_H\r"
      },
      {
        "sha": "dee0cd2c4b87cadd4c6a251c44d46a92d543d444",
        "filename": "src/chainparams.cpp",
        "status": "modified",
        "additions": 379,
        "deletions": 371,
        "changes": 750,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/chainparams.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/chainparams.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/chainparams.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,371 +1,379 @@\n-// Copyright (c) 2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <chainparams.h>\n-#include <consensus/merkle.h>\n-\n-#include <tinyformat.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n-\n-#include <assert.h>\n-\n-#include <chainparamsseeds.h>\n-\n-static CBlock CreateGenesisBlock(const char* pszTimestamp, const CScript& genesisOutputScript, uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)\n-{\n-    CMutableTransaction txNew;\n-    txNew.nVersion = 1;\n-    txNew.vin.resize(1);\n-    txNew.vout.resize(1);\n-    txNew.vin[0].scriptSig = CScript() << 486604799 << CScriptNum(4) << std::vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\n-    txNew.vout[0].nValue = genesisReward;\n-    txNew.vout[0].scriptPubKey = genesisOutputScript;\n-\n-    CBlock genesis;\n-    genesis.nTime    = nTime;\n-    genesis.nBits    = nBits;\n-    genesis.nNonce   = nNonce;\n-    genesis.nVersion = nVersion;\n-    genesis.vtx.push_back(MakeTransactionRef(std::move(txNew)));\n-    genesis.hashPrevBlock.SetNull();\n-    genesis.hashMerkleRoot = BlockMerkleRoot(genesis);\n-    return genesis;\n-}\n-\n-/**\n- * Build the genesis block. Note that the output of its generation\n- * transaction cannot be spent since it did not originally exist in the\n- * database.\n- *\n- * CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1)\n- *   CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0)\n- *     CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73)\n- *     CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B)\n- *   vMerkleTree: 4a5e1e\n- */\n-static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)\n-{\n-    const char* pszTimestamp = \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\";\n-    const CScript genesisOutputScript = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\n-    return CreateGenesisBlock(pszTimestamp, genesisOutputScript, nTime, nNonce, nBits, nVersion, genesisReward);\n-}\n-\n-void CChainParams::UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n-{\n-    consensus.vDeployments[d].nStartTime = nStartTime;\n-    consensus.vDeployments[d].nTimeout = nTimeout;\n-}\n-\n-/**\n- * Main network\n- */\n-/**\n- * What makes a good checkpoint block?\n- * + Is surrounded by blocks with reasonable timestamps\n- *   (no blocks before with a timestamp after, none after with\n- *    timestamp before)\n- * + Contains no strange transactions\n- */\n-\n-class CMainParams : public CChainParams {\n-public:\n-    CMainParams() {\n-        strNetworkID = \"main\";\n-        consensus.nSubsidyHalvingInterval = 210000;\n-        consensus.BIP16Height = 173805; // 00000000000000ce80a7e057163a4db1d5ad7b20fb6f598c9597b9665c8fb0d4 - April 1, 2012\n-        consensus.BIP34Height = 227931;\n-        consensus.BIP34Hash = uint256S(\"0x000000000000024b89b42a942fe0d9fea3bb44ab7bd1b19115dd6a759c0808b8\");\n-        consensus.BIP65Height = 388381; // 000000000000000004c2b624ed5d7756c508d90fd0da2c7c679febfa6c4735f0\n-        consensus.BIP66Height = 363725; // 00000000000000000379eaa19dce8c9b722d46ae6a57c2f1a988119488b50931\n-        consensus.powLimit = uint256S(\"00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n-        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n-        consensus.nPowTargetSpacing = 10 * 60;\n-        consensus.fPowAllowMinDifficultyBlocks = false;\n-        consensus.fPowNoRetargeting = false;\n-        consensus.nRuleChangeActivationThreshold = 1916; // 95% of 2016\n-        consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n-\n-        // Deployment of BIP68, BIP112, and BIP113.\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1462060800; // May 1st, 2016\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017\n-\n-        // Deployment of SegWit (BIP141, BIP143, and BIP147)\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1479168000; // November 15th, 2016.\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1510704000; // November 15th, 2017.\n-\n-        // The best chain should have at least this much work.\n-        consensus.nMinimumChainWork = uint256S(\"0x000000000000000000000000000000000000000000723d3581fe1bd55373540a\");\n-\n-        // By default assume that the signatures in ancestors of this block are valid.\n-        consensus.defaultAssumeValid = uint256S(\"0x0000000000000000003b9ce759c2a087d52abc4266f8f4ebd6d768b89defa50a\"); //477890\n-\n-        /**\n-         * The message start string is designed to be unlikely to occur in normal data.\n-         * The characters are rarely used upper ASCII, not valid as UTF-8, and produce\n-         * a large 32-bit integer with any alignment.\n-         */\n-        pchMessageStart[0] = 0xf9;\n-        pchMessageStart[1] = 0xbe;\n-        pchMessageStart[2] = 0xb4;\n-        pchMessageStart[3] = 0xd9;\n-        nDefaultPort = 8333;\n-        nPruneAfterHeight = 100000;\n-\n-        genesis = CreateGenesisBlock(1231006505, 2083236893, 0x1d00ffff, 1, 50 * COIN);\n-        consensus.hashGenesisBlock = genesis.GetHash();\n-        assert(consensus.hashGenesisBlock == uint256S(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\"));\n-        assert(genesis.hashMerkleRoot == uint256S(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\n-\n-        // Note that of those with the service bits flag, most only support a subset of possible options\n-        vSeeds.emplace_back(\"seed.bitcoin.sipa.be\", true); // Pieter Wuille, only supports x1, x5, x9, and xd\n-        vSeeds.emplace_back(\"dnsseed.bluematt.me\", true); // Matt Corallo, only supports x9\n-        vSeeds.emplace_back(\"dnsseed.bitcoin.dashjr.org\", false); // Luke Dashjr\n-        vSeeds.emplace_back(\"seed.bitcoinstats.com\", true); // Christian Decker, supports x1 - xf\n-        vSeeds.emplace_back(\"seed.bitcoin.jonasschnelli.ch\", true); // Jonas Schnelli, only supports x1, x5, x9, and xd\n-        vSeeds.emplace_back(\"seed.btc.petertodd.org\", true); // Peter Todd, only supports x1, x5, x9, and xd\n-\n-        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);\n-        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);\n-        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,128);\n-        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x88, 0xB2, 0x1E};\n-        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x88, 0xAD, 0xE4};\n-\n-        bech32_hrp = \"bc\";\n-\n-        vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_main, pnSeed6_main + ARRAYLEN(pnSeed6_main));\n-\n-        fDefaultConsistencyChecks = false;\n-        fRequireStandard = true;\n-        fMineBlocksOnDemand = false;\n-\n-        checkpointData = {\n-            {\n-                { 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\")},\n-                { 33333, uint256S(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\")},\n-                { 74000, uint256S(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\")},\n-                {105000, uint256S(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\")},\n-                {134444, uint256S(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\")},\n-                {168000, uint256S(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\")},\n-                {193000, uint256S(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\")},\n-                {210000, uint256S(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\")},\n-                {216116, uint256S(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\")},\n-                {225430, uint256S(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\")},\n-                {250000, uint256S(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\")},\n-                {279000, uint256S(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\")},\n-                {295000, uint256S(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\")},\n-            }\n-        };\n-\n-        chainTxData = ChainTxData{\n-            // Data as of block 000000000000000000d97e53664d17967bd4ee50b23abb92e54a34eb222d15ae (height 478913).\n-            1501801925, // * UNIX timestamp of last known number of transactions\n-            243756039,  // * total number of transactions between genesis and that timestamp\n-                        //   (the tx=... number in the SetBestChain debug.log lines)\n-            3.1         // * estimated number of transactions per second after that timestamp\n-        };\n-    }\n-};\n-\n-/**\n- * Testnet (v3)\n- */\n-class CTestNetParams : public CChainParams {\n-public:\n-    CTestNetParams() {\n-        strNetworkID = \"test\";\n-        consensus.nSubsidyHalvingInterval = 210000;\n-        consensus.BIP16Height = 514; // 00000000040b4e986385315e14bee30ad876d8b47f748025b26683116d21aa65\n-        consensus.BIP34Height = 21111;\n-        consensus.BIP34Hash = uint256S(\"0x0000000023b3a96d3484e5abb3755c413e7d41500f8e2a5c3f0dd01299cd8ef8\");\n-        consensus.BIP65Height = 581885; // 00000000007f6655f22f98e72ed80d8b06dc761d5da09df0fa1dc4be4f861eb6\n-        consensus.BIP66Height = 330776; // 000000002104c8c45e99a8853285a3b592602a3ccde2b832481da85e9e4ba182\n-        consensus.powLimit = uint256S(\"00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n-        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n-        consensus.nPowTargetSpacing = 10 * 60;\n-        consensus.fPowAllowMinDifficultyBlocks = true;\n-        consensus.fPowNoRetargeting = false;\n-        consensus.nRuleChangeActivationThreshold = 1512; // 75% for testchains\n-        consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\n-\n-        // Deployment of BIP68, BIP112, and BIP113.\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1456790400; // March 1st, 2016\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017\n-\n-        // Deployment of SegWit (BIP141, BIP143, and BIP147)\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1462060800; // May 1st 2016\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1493596800; // May 1st 2017\n-\n-        // The best chain should have at least this much work.\n-        consensus.nMinimumChainWork = uint256S(\"0x00000000000000000000000000000000000000000000002830dab7f76dbb7d63\");\n-\n-        // By default assume that the signatures in ancestors of this block are valid.\n-        consensus.defaultAssumeValid = uint256S(\"0x0000000002e9e7b00e1f6dc5123a04aad68dd0f0968d8c7aa45f6640795c37b1\"); //1135275\n-\n-        pchMessageStart[0] = 0x0b;\n-        pchMessageStart[1] = 0x11;\n-        pchMessageStart[2] = 0x09;\n-        pchMessageStart[3] = 0x07;\n-        nDefaultPort = 18333;\n-        nPruneAfterHeight = 1000;\n-\n-        genesis = CreateGenesisBlock(1296688602, 414098458, 0x1d00ffff, 1, 50 * COIN);\n-        consensus.hashGenesisBlock = genesis.GetHash();\n-        assert(consensus.hashGenesisBlock == uint256S(\"0x000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943\"));\n-        assert(genesis.hashMerkleRoot == uint256S(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\n-\n-        vFixedSeeds.clear();\n-        vSeeds.clear();\n-        // nodes with support for servicebits filtering should be at the top\n-        vSeeds.emplace_back(\"testnet-seed.bitcoin.jonasschnelli.ch\", true);\n-        vSeeds.emplace_back(\"seed.tbtc.petertodd.org\", true);\n-        vSeeds.emplace_back(\"testnet-seed.bluematt.me\", false);\n-\n-        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);\n-        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);\n-        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);\n-        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x35, 0x87, 0xCF};\n-        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x35, 0x83, 0x94};\n-\n-        bech32_hrp = \"tb\";\n-\n-        vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_test, pnSeed6_test + ARRAYLEN(pnSeed6_test));\n-\n-        fDefaultConsistencyChecks = false;\n-        fRequireStandard = false;\n-        fMineBlocksOnDemand = false;\n-\n-\n-        checkpointData = {\n-            {\n-                {546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\")},\n-            }\n-        };\n-\n-        chainTxData = ChainTxData{\n-            // Data as of block 00000000000001c200b9790dc637d3bb141fe77d155b966ed775b17e109f7c6c (height 1156179)\n-            1501802953,\n-            14706531,\n-            0.15\n-        };\n-\n-    }\n-};\n-\n-/**\n- * Regression test\n- */\n-class CRegTestParams : public CChainParams {\n-public:\n-    CRegTestParams() {\n-        strNetworkID = \"regtest\";\n-        consensus.nSubsidyHalvingInterval = 150;\n-        consensus.BIP16Height = 0; // always enforce P2SH BIP16 on regtest\n-        consensus.BIP34Height = 100000000; // BIP34 has not activated on regtest (far in the future so block v1 are not rejected in tests)\n-        consensus.BIP34Hash = uint256();\n-        consensus.BIP65Height = 1351; // BIP65 activated on regtest (Used in rpc activation tests)\n-        consensus.BIP66Height = 1251; // BIP66 activated on regtest (Used in rpc activation tests)\n-        consensus.powLimit = uint256S(\"7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n-        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\n-        consensus.nPowTargetSpacing = 10 * 60;\n-        consensus.fPowAllowMinDifficultyBlocks = true;\n-        consensus.fPowNoRetargeting = true;\n-        consensus.nRuleChangeActivationThreshold = 108; // 75% for testchains\n-        consensus.nMinerConfirmationWindow = 144; // Faster than normal for regtest (144 instead of 2016)\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 0;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\n-        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\n-\n-        // The best chain should have at least this much work.\n-        consensus.nMinimumChainWork = uint256S(\"0x00\");\n-\n-        // By default assume that the signatures in ancestors of this block are valid.\n-        consensus.defaultAssumeValid = uint256S(\"0x00\");\n-\n-        pchMessageStart[0] = 0xfa;\n-        pchMessageStart[1] = 0xbf;\n-        pchMessageStart[2] = 0xb5;\n-        pchMessageStart[3] = 0xda;\n-        nDefaultPort = 18444;\n-        nPruneAfterHeight = 1000;\n-\n-        genesis = CreateGenesisBlock(1296688602, 2, 0x207fffff, 1, 50 * COIN);\n-        consensus.hashGenesisBlock = genesis.GetHash();\n-        assert(consensus.hashGenesisBlock == uint256S(\"0x0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"));\n-        assert(genesis.hashMerkleRoot == uint256S(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\n-\n-        vFixedSeeds.clear(); //!< Regtest mode doesn't have any fixed seeds.\n-        vSeeds.clear();      //!< Regtest mode doesn't have any DNS seeds.\n-\n-        fDefaultConsistencyChecks = true;\n-        fRequireStandard = false;\n-        fMineBlocksOnDemand = true;\n-\n-        checkpointData = {\n-            {\n-                {0, uint256S(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\")},\n-            }\n-        };\n-\n-        chainTxData = ChainTxData{\n-            0,\n-            0,\n-            0\n-        };\n-\n-        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);\n-        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);\n-        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);\n-        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x35, 0x87, 0xCF};\n-        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x35, 0x83, 0x94};\n-\n-        bech32_hrp = \"bcrt\";\n-    }\n-};\n-\n-static std::unique_ptr<CChainParams> globalChainParams;\n-\n-const CChainParams &Params() {\n-    assert(globalChainParams);\n-    return *globalChainParams;\n-}\n-\n-std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain)\n-{\n-    if (chain == CBaseChainParams::MAIN)\n-        return std::unique_ptr<CChainParams>(new CMainParams());\n-    else if (chain == CBaseChainParams::TESTNET)\n-        return std::unique_ptr<CChainParams>(new CTestNetParams());\n-    else if (chain == CBaseChainParams::REGTEST)\n-        return std::unique_ptr<CChainParams>(new CRegTestParams());\n-    throw std::runtime_error(strprintf(\"%s: Unknown chain %s.\", __func__, chain));\n-}\n-\n-void SelectParams(const std::string& network)\n-{\n-    SelectBaseParams(network);\n-    globalChainParams = CreateChainParams(network);\n-}\n-\n-void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\n-{\n-    globalChainParams->UpdateVersionBitsParameters(d, nStartTime, nTimeout);\n-}\n+// Copyright (c) 2010 Satoshi Nakamoto\r\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <chainparams.h>\r\n+#include <consensus/merkle.h>\r\n+\r\n+#include <tinyformat.h>\r\n+#include <util.h>\r\n+#include <utilstrencodings.h>\r\n+\r\n+#include <assert.h>\r\n+\r\n+#include <chainparamsseeds.h>\r\n+\r\n+static CBlock CreateGenesisBlock(const char* pszTimestamp, const CScript& genesisOutputScript, uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)\r\n+{\r\n+    CMutableTransaction txNew;\r\n+    txNew.nVersion = 1;\r\n+    txNew.vin.resize(1);\r\n+    txNew.vout.resize(1);\r\n+    txNew.vin[0].scriptSig = CScript() << 486604799 << CScriptNum(4) << std::vector<unsigned char>((const unsigned char*)pszTimestamp, (const unsigned char*)pszTimestamp + strlen(pszTimestamp));\r\n+    txNew.vout[0].nValue = genesisReward;\r\n+    txNew.vout[0].scriptPubKey = genesisOutputScript;\r\n+\r\n+    CBlock genesis;\r\n+    genesis.nTime    = nTime;\r\n+    genesis.nBits    = nBits;\r\n+    genesis.nNonce   = nNonce;\r\n+    genesis.nVersion = nVersion;\r\n+    genesis.vtx.push_back(MakeTransactionRef(std::move(txNew)));\r\n+    genesis.hashPrevBlock.SetNull();\r\n+    genesis.hashMerkleRoot = BlockMerkleRoot(genesis);\r\n+    return genesis;\r\n+}\r\n+\r\n+/**\r\n+ * Build the genesis block. Note that the output of its generation\r\n+ * transaction cannot be spent since it did not originally exist in the\r\n+ * database.\r\n+ *\r\n+ * CBlock(hash=000000000019d6, ver=1, hashPrevBlock=00000000000000, hashMerkleRoot=4a5e1e, nTime=1231006505, nBits=1d00ffff, nNonce=2083236893, vtx=1)\r\n+ *   CTransaction(hash=4a5e1e, ver=1, vin.size=1, vout.size=1, nLockTime=0)\r\n+ *     CTxIn(COutPoint(000000, -1), coinbase 04ffff001d0104455468652054696d65732030332f4a616e2f32303039204368616e63656c6c6f72206f6e206272696e6b206f66207365636f6e64206261696c6f757420666f722062616e6b73)\r\n+ *     CTxOut(nValue=50.00000000, scriptPubKey=0x5F1DF16B2B704C8A578D0B)\r\n+ *   vMerkleTree: 4a5e1e\r\n+ */\r\n+static CBlock CreateGenesisBlock(uint32_t nTime, uint32_t nNonce, uint32_t nBits, int32_t nVersion, const CAmount& genesisReward)\r\n+{\r\n+    const char* pszTimestamp = \"The Times 03/Jan/2009 Chancellor on brink of second bailout for banks\";\r\n+    const CScript genesisOutputScript = CScript() << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38c4f35504e51ec112de5c384df7ba0b8d578a4c702b6bf11d5f\") << OP_CHECKSIG;\r\n+    return CreateGenesisBlock(pszTimestamp, genesisOutputScript, nTime, nNonce, nBits, nVersion, genesisReward);\r\n+}\r\n+\r\n+void CChainParams::UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\r\n+{\r\n+    consensus.vDeployments[d].nStartTime = nStartTime;\r\n+    consensus.vDeployments[d].nTimeout = nTimeout;\r\n+}\r\n+\r\n+/**\r\n+ * Main network\r\n+ */\r\n+/**\r\n+ * What makes a good checkpoint block?\r\n+ * + Is surrounded by blocks with reasonable timestamps\r\n+ *   (no blocks before with a timestamp after, none after with\r\n+ *    timestamp before)\r\n+ * + Contains no strange transactions\r\n+ */\r\n+\r\n+class CMainParams : public CChainParams {\r\n+public:\r\n+    CMainParams() {\r\n+        strNetworkID = \"main\";\r\n+        consensus.nSubsidyHalvingInterval = 210000;\r\n+        consensus.BIP16Height = 173805; // 00000000000000ce80a7e057163a4db1d5ad7b20fb6f598c9597b9665c8fb0d4 - April 1, 2012\r\n+        consensus.BIP34Height = 227931;\r\n+        consensus.BIP34Hash = uint256S(\"0x000000000000024b89b42a942fe0d9fea3bb44ab7bd1b19115dd6a759c0808b8\");\r\n+        consensus.BIP65Height = 388381; // 000000000000000004c2b624ed5d7756c508d90fd0da2c7c679febfa6c4735f0\r\n+        consensus.BIP66Height = 363725; // 00000000000000000379eaa19dce8c9b722d46ae6a57c2f1a988119488b50931\r\n+        consensus.powLimit = uint256S(\"00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\r\n+        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\r\n+        consensus.nPowTargetSpacing = 10 * 60;\r\n+        consensus.nBtvPowTargetTimespan = 14 * 24 * 60 * 60 / 5; // 2016 block\r\n+        consensus.nBtvPowTargetSpacing = 2 * 60; // two minutes\r\n+        consensus.fPowAllowMinDifficultyBlocks = false;\r\n+        consensus.fPowNoRetargeting = false;\r\n+        consensus.nRuleChangeActivationThreshold = 1916; // 95% of 2016\r\n+        consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\r\n+\r\n+        // Deployment of BIP68, BIP112, and BIP113.\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1462060800; // May 1st, 2016\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017\r\n+\r\n+        // Deployment of SegWit (BIP141, BIP143, and BIP147)\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1479168000; // November 15th, 2016.\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1510704000; // November 15th, 2017.\r\n+\r\n+        // The best chain should have at least this much work.\r\n+        consensus.nMinimumChainWork = uint256S(\"0x000000000000000000000000000000000000000000723d3581fe1bd55373540a\");\r\n+\r\n+        // By default assume that the signatures in ancestors of this block are valid.\r\n+        consensus.defaultAssumeValid = uint256S(\"0x0000000000000000003b9ce759c2a087d52abc4266f8f4ebd6d768b89defa50a\"); //477890\r\n+\r\n+        /**\r\n+         * The message start string is designed to be unlikely to occur in normal data.\r\n+         * The characters are rarely used upper ASCII, not valid as UTF-8, and produce\r\n+         * a large 32-bit integer with any alignment.\r\n+         */\r\n+        pchMessageStart[0] = 0xf9;\r\n+        pchMessageStart[1] = 0xbe;\r\n+        pchMessageStart[2] = 0xb4;\r\n+        pchMessageStart[3] = 0xd9;\r\n+        nDefaultPort = 8333;\r\n+        nPruneAfterHeight = 100000;\r\n+\r\n+        genesis = CreateGenesisBlock(1231006505, 2083236893, 0x1d00ffff, 1, 50 * COIN);\r\n+        consensus.hashGenesisBlock = genesis.GetHash();\r\n+        assert(consensus.hashGenesisBlock == uint256S(\"0x000000000019d6689c085ae165831e934ff763ae46a2a6c172b3f1b60a8ce26f\"));\r\n+        assert(genesis.hashMerkleRoot == uint256S(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\r\n+\r\n+        // Note that of those with the service bits flag, most only support a subset of possible options\r\n+        vSeeds.emplace_back(\"seed.bitcoin.sipa.be\", true); // Pieter Wuille, only supports x1, x5, x9, and xd\r\n+        vSeeds.emplace_back(\"dnsseed.bluematt.me\", true); // Matt Corallo, only supports x9\r\n+        vSeeds.emplace_back(\"dnsseed.bitcoin.dashjr.org\", false); // Luke Dashjr\r\n+        vSeeds.emplace_back(\"seed.bitcoinstats.com\", true); // Christian Decker, supports x1 - xf\r\n+        vSeeds.emplace_back(\"seed.bitcoin.jonasschnelli.ch\", true); // Jonas Schnelli, only supports x1, x5, x9, and xd\r\n+        vSeeds.emplace_back(\"seed.btc.petertodd.org\", true); // Peter Todd, only supports x1, x5, x9, and xd\r\n+        vSeeds.emplace_back(\"seed1.bitvote.one\", true); // Seed1 of bitvote.one\r\n+        vSeeds.emplace_back(\"seed2.bitvote.one\", true); // Seed2 of bitvote.one\r\n+\r\n+        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,0);\r\n+        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,5);\r\n+        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,128);\r\n+        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x88, 0xB2, 0x1E};\r\n+        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x88, 0xAD, 0xE4};\r\n+\r\n+        bech32_hrp = \"bc\";\r\n+\r\n+        vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_main, pnSeed6_main + ARRAYLEN(pnSeed6_main));\r\n+\r\n+        fDefaultConsistencyChecks = false;\r\n+        fRequireStandard = true;\r\n+        fMineBlocksOnDemand = false;\r\n+\r\n+        checkpointData = {\r\n+            {\r\n+                { 11111, uint256S(\"0x0000000069e244f73d78e8fd29ba2fd2ed618bd6fa2ee92559f542fdb26e7c1d\")},\r\n+                { 33333, uint256S(\"0x000000002dd5588a74784eaa7ab0507a18ad16a236e7b1ce69f00d7ddfb5d0a6\")},\r\n+                { 74000, uint256S(\"0x0000000000573993a3c9e41ce34471c079dcf5f52a0e824a81e7f953b8661a20\")},\r\n+                {105000, uint256S(\"0x00000000000291ce28027faea320c8d2b054b2e0fe44a773f3eefb151d6bdc97\")},\r\n+                {134444, uint256S(\"0x00000000000005b12ffd4cd315cd34ffd4a594f430ac814c91184a0d42d2b0fe\")},\r\n+                {168000, uint256S(\"0x000000000000099e61ea72015e79632f216fe6cb33d7899acb35b75c8303b763\")},\r\n+                {193000, uint256S(\"0x000000000000059f452a5f7340de6682a977387c17010ff6e6c3bd83ca8b1317\")},\r\n+                {210000, uint256S(\"0x000000000000048b95347e83192f69cf0366076336c639f9b7228e9ba171342e\")},\r\n+                {216116, uint256S(\"0x00000000000001b4f4b433e81ee46494af945cf96014816a4e2370f11b23df4e\")},\r\n+                {225430, uint256S(\"0x00000000000001c108384350f74090433e7fcf79a606b8e797f065b130575932\")},\r\n+                {250000, uint256S(\"0x000000000000003887df1f29024b06fc2200b55f8af8f35453d7be294df2d214\")},\r\n+                {279000, uint256S(\"0x0000000000000001ae8c72a0b0c301f67e3afca10e819efa9041e458e9bd7e40\")},\r\n+                {295000, uint256S(\"0x00000000000000004d9b4ef50f0f9d686fd69db2e03af35a100370c64632a983\")},\r\n+            }\r\n+        };\r\n+\r\n+        chainTxData = ChainTxData{\r\n+            // Data as of block 000000000000000000d97e53664d17967bd4ee50b23abb92e54a34eb222d15ae (height 478913).\r\n+            1501801925, // * UNIX timestamp of last known number of transactions\r\n+            243756039,  // * total number of transactions between genesis and that timestamp\r\n+                        //   (the tx=... number in the SetBestChain debug.log lines)\r\n+            3.1         // * estimated number of transactions per second after that timestamp\r\n+        };\r\n+    }\r\n+};\r\n+\r\n+/**\r\n+ * Testnet (v3)\r\n+ */\r\n+class CTestNetParams : public CChainParams {\r\n+public:\r\n+    CTestNetParams() {\r\n+        strNetworkID = \"test\";\r\n+        consensus.nSubsidyHalvingInterval = 210000;\r\n+        consensus.BIP16Height = 514; // 00000000040b4e986385315e14bee30ad876d8b47f748025b26683116d21aa65\r\n+        consensus.BIP34Height = 21111;\r\n+        consensus.BIP34Hash = uint256S(\"0x0000000023b3a96d3484e5abb3755c413e7d41500f8e2a5c3f0dd01299cd8ef8\");\r\n+        consensus.BIP65Height = 581885; // 00000000007f6655f22f98e72ed80d8b06dc761d5da09df0fa1dc4be4f861eb6\r\n+        consensus.BIP66Height = 330776; // 000000002104c8c45e99a8853285a3b592602a3ccde2b832481da85e9e4ba182\r\n+        consensus.powLimit = uint256S(\"00000000ffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\r\n+        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\r\n+        consensus.nPowTargetSpacing = 10 * 60;\r\n+        consensus.nBtvPowTargetTimespan = 14 * 24 * 60 * 60 / 5; // 2016 block\r\n+        consensus.nBtvPowTargetSpacing = 2 * 60;\r\n+        consensus.fPowAllowMinDifficultyBlocks = true;\r\n+        consensus.fPowNoRetargeting = false;\r\n+        consensus.nRuleChangeActivationThreshold = 1512; // 75% for testchains\r\n+        consensus.nMinerConfirmationWindow = 2016; // nPowTargetTimespan / nPowTargetSpacing\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 1199145601; // January 1, 2008\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = 1230767999; // December 31, 2008\r\n+\r\n+        // Deployment of BIP68, BIP112, and BIP113.\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 1456790400; // March 1st, 2016\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = 1493596800; // May 1st, 2017\r\n+\r\n+        // Deployment of SegWit (BIP141, BIP143, and BIP147)\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = 1462060800; // May 1st 2016\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = 1493596800; // May 1st 2017\r\n+\r\n+        // The best chain should have at least this much work.\r\n+        consensus.nMinimumChainWork = uint256S(\"0x00000000000000000000000000000000000000000000002830dab7f76dbb7d63\");\r\n+\r\n+        // By default assume that the signatures in ancestors of this block are valid.\r\n+        consensus.defaultAssumeValid = uint256S(\"0x0000000002e9e7b00e1f6dc5123a04aad68dd0f0968d8c7aa45f6640795c37b1\"); //1135275\r\n+\r\n+        pchMessageStart[0] = 0x0b;\r\n+        pchMessageStart[1] = 0x11;\r\n+        pchMessageStart[2] = 0x09;\r\n+        pchMessageStart[3] = 0x07;\r\n+        nDefaultPort = 18333;\r\n+        nPruneAfterHeight = 1000;\r\n+\r\n+        genesis = CreateGenesisBlock(1296688602, 414098458, 0x1d00ffff, 1, 50 * COIN);\r\n+        consensus.hashGenesisBlock = genesis.GetHash();\r\n+        assert(consensus.hashGenesisBlock == uint256S(\"0x000000000933ea01ad0ee984209779baaec3ced90fa3f408719526f8d77f4943\"));\r\n+        assert(genesis.hashMerkleRoot == uint256S(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\r\n+\r\n+        vFixedSeeds.clear();\r\n+        vSeeds.clear();\r\n+        // nodes with support for servicebits filtering should be at the top\r\n+        vSeeds.emplace_back(\"testnet-seed.bitcoin.jonasschnelli.ch\", true);\r\n+        vSeeds.emplace_back(\"seed.tbtc.petertodd.org\", true);\r\n+        vSeeds.emplace_back(\"testnet-seed.bluematt.me\", false);\r\n+\r\n+        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);\r\n+        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);\r\n+        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);\r\n+        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x35, 0x87, 0xCF};\r\n+        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x35, 0x83, 0x94};\r\n+\r\n+        bech32_hrp = \"tb\";\r\n+\r\n+        vFixedSeeds = std::vector<SeedSpec6>(pnSeed6_test, pnSeed6_test + ARRAYLEN(pnSeed6_test));\r\n+\r\n+        fDefaultConsistencyChecks = false;\r\n+        fRequireStandard = false;\r\n+        fMineBlocksOnDemand = false;\r\n+\r\n+\r\n+        checkpointData = {\r\n+            {\r\n+                {546, uint256S(\"000000002a936ca763904c3c35fce2f3556c559c0214345d31b1bcebf76acb70\")},\r\n+            }\r\n+        };\r\n+\r\n+        chainTxData = ChainTxData{\r\n+            // Data as of block 00000000000001c200b9790dc637d3bb141fe77d155b966ed775b17e109f7c6c (height 1156179)\r\n+            1501802953,\r\n+            14706531,\r\n+            0.15\r\n+        };\r\n+\r\n+    }\r\n+};\r\n+\r\n+/**\r\n+ * Regression test\r\n+ */\r\n+class CRegTestParams : public CChainParams {\r\n+public:\r\n+    CRegTestParams() {\r\n+        strNetworkID = \"regtest\";\r\n+        consensus.nSubsidyHalvingInterval = 150;\r\n+        consensus.BIP16Height = 0; // always enforce P2SH BIP16 on regtest\r\n+        consensus.BIP34Height = 100000000; // BIP34 has not activated on regtest (far in the future so block v1 are not rejected in tests)\r\n+        consensus.BIP34Hash = uint256();\r\n+        consensus.BIP65Height = 1351; // BIP65 activated on regtest (Used in rpc activation tests)\r\n+        consensus.BIP66Height = 1251; // BIP66 activated on regtest (Used in rpc activation tests)\r\n+        consensus.powLimit = uint256S(\"7fffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\r\n+        consensus.nPowTargetTimespan = 14 * 24 * 60 * 60; // two weeks\r\n+        consensus.nPowTargetSpacing = 10 * 60;\r\n+        consensus.nBtvPowTargetTimespan = 14 * 24 * 60 * 60 / 5; // 2016 block\r\n+        consensus.nBtvPowTargetSpacing = 2 * 60;\r\n+        consensus.fPowAllowMinDifficultyBlocks = true;\r\n+        consensus.fPowNoRetargeting = true;\r\n+        consensus.nRuleChangeActivationThreshold = 108; // 75% for testchains\r\n+        consensus.nMinerConfirmationWindow = 144; // Faster than normal for regtest (144 instead of 2016)\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].bit = 28;\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nStartTime = 0;\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_TESTDUMMY].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].bit = 0;\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nStartTime = 0;\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_CSV].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].bit = 1;\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nStartTime = Consensus::BIP9Deployment::ALWAYS_ACTIVE;\r\n+        consensus.vDeployments[Consensus::DEPLOYMENT_SEGWIT].nTimeout = Consensus::BIP9Deployment::NO_TIMEOUT;\r\n+\r\n+        // The best chain should have at least this much work.\r\n+        consensus.nMinimumChainWork = uint256S(\"0x00\");\r\n+\r\n+        // By default assume that the signatures in ancestors of this block are valid.\r\n+        consensus.defaultAssumeValid = uint256S(\"0x00\");\r\n+\r\n+        pchMessageStart[0] = 0xfa;\r\n+        pchMessageStart[1] = 0xbf;\r\n+        pchMessageStart[2] = 0xb5;\r\n+        pchMessageStart[3] = 0xda;\r\n+        nDefaultPort = 18444;\r\n+        nPruneAfterHeight = 1000;\r\n+\r\n+        genesis = CreateGenesisBlock(1296688602, 2, 0x207fffff, 1, 50 * COIN);\r\n+        consensus.hashGenesisBlock = genesis.GetHash();\r\n+        assert(consensus.hashGenesisBlock == uint256S(\"0x0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\"));\r\n+        assert(genesis.hashMerkleRoot == uint256S(\"0x4a5e1e4baab89f3a32518a88c31bc87f618f76673e2cc77ab2127b7afdeda33b\"));\r\n+\r\n+        vFixedSeeds.clear(); //!< Regtest mode doesn't have any fixed seeds.\r\n+        vSeeds.clear();      //!< Regtest mode doesn't have any DNS seeds.\r\n+\r\n+        fDefaultConsistencyChecks = true;\r\n+        fRequireStandard = false;\r\n+        fMineBlocksOnDemand = true;\r\n+\r\n+        checkpointData = {\r\n+            {\r\n+                {0, uint256S(\"0f9188f13cb7b2c71f2a335e3a4fc328bf5beb436012afca590b1a11466e2206\")},\r\n+            }\r\n+        };\r\n+\r\n+        chainTxData = ChainTxData{\r\n+            0,\r\n+            0,\r\n+            0\r\n+        };\r\n+\r\n+        base58Prefixes[PUBKEY_ADDRESS] = std::vector<unsigned char>(1,111);\r\n+        base58Prefixes[SCRIPT_ADDRESS] = std::vector<unsigned char>(1,196);\r\n+        base58Prefixes[SECRET_KEY] =     std::vector<unsigned char>(1,239);\r\n+        base58Prefixes[EXT_PUBLIC_KEY] = {0x04, 0x35, 0x87, 0xCF};\r\n+        base58Prefixes[EXT_SECRET_KEY] = {0x04, 0x35, 0x83, 0x94};\r\n+\r\n+        bech32_hrp = \"bcrt\";\r\n+    }\r\n+};\r\n+\r\n+static std::unique_ptr<CChainParams> globalChainParams;\r\n+\r\n+const CChainParams &Params() {\r\n+    assert(globalChainParams);\r\n+    return *globalChainParams;\r\n+}\r\n+\r\n+std::unique_ptr<CChainParams> CreateChainParams(const std::string& chain)\r\n+{\r\n+    if (chain == CBaseChainParams::MAIN)\r\n+        return std::unique_ptr<CChainParams>(new CMainParams());\r\n+    else if (chain == CBaseChainParams::TESTNET)\r\n+        return std::unique_ptr<CChainParams>(new CTestNetParams());\r\n+    else if (chain == CBaseChainParams::REGTEST)\r\n+        return std::unique_ptr<CChainParams>(new CRegTestParams());\r\n+    throw std::runtime_error(strprintf(\"%s: Unknown chain %s.\", __func__, chain));\r\n+}\r\n+\r\n+void SelectParams(const std::string& network)\r\n+{\r\n+    SelectBaseParams(network);\r\n+    globalChainParams = CreateChainParams(network);\r\n+}\r\n+\r\n+void UpdateVersionBitsParameters(Consensus::DeploymentPos d, int64_t nStartTime, int64_t nTimeout)\r\n+{\r\n+    globalChainParams->UpdateVersionBitsParameters(d, nStartTime, nTimeout);\r\n+}\r"
      },
      {
        "sha": "0b5976ebab5c1059dccf7cb0fcba2cc420be72cb",
        "filename": "src/consensus/consensus.h",
        "status": "modified",
        "additions": 32,
        "deletions": 32,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/consensus/consensus.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/consensus/consensus.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/consensus.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,32 +1,32 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_CONSENSUS_CONSENSUS_H\n-#define BITCOIN_CONSENSUS_CONSENSUS_H\n-\n-#include <stdlib.h>\n-#include <stdint.h>\n-\n-/** The maximum allowed size for a serialized block, in bytes (only for buffer size limits) */\n-static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 4000000;\n-/** The maximum allowed weight for a block, see BIP 141 (network rule) */\n-static const unsigned int MAX_BLOCK_WEIGHT = 4000000;\n-/** The maximum allowed number of signature check operations in a block (network rule) */\n-static const int64_t MAX_BLOCK_SIGOPS_COST = 80000;\n-/** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */\n-static const int COINBASE_MATURITY = 100;\n-\n-static const int WITNESS_SCALE_FACTOR = 4;\n-\n-static const size_t MIN_TRANSACTION_WEIGHT = WITNESS_SCALE_FACTOR * 60; // 60 is the lower bound for the size of a valid serialized CTransaction\n-static const size_t MIN_SERIALIZABLE_TRANSACTION_WEIGHT = WITNESS_SCALE_FACTOR * 10; // 10 is the lower bound for the size of a serialized CTransaction\n-\n-/** Flags for nSequence and nLockTime locks */\n-/** Interpret sequence numbers as relative lock-time constraints. */\n-static constexpr unsigned int LOCKTIME_VERIFY_SEQUENCE = (1 << 0);\n-/** Use GetMedianTimePast() instead of nTime for end point timestamp. */\n-static constexpr unsigned int LOCKTIME_MEDIAN_TIME_PAST = (1 << 1);\n-\n-#endif // BITCOIN_CONSENSUS_CONSENSUS_H\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\r\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#ifndef BITCOIN_CONSENSUS_CONSENSUS_H\r\n+#define BITCOIN_CONSENSUS_CONSENSUS_H\r\n+\r\n+#include <stdlib.h>\r\n+#include <stdint.h>\r\n+\r\n+/** The maximum allowed size for a serialized block, in bytes (only for buffer size limits) */\r\n+static const unsigned int MAX_BLOCK_SERIALIZED_SIZE = 32000000;\r\n+/** The maximum allowed weight for a block, see BIP 141 (network rule) */\r\n+static const unsigned int MAX_BLOCK_WEIGHT = 32000000;\r\n+/** The maximum allowed number of signature check operations in a block (network rule) */\r\n+static const int64_t MAX_BLOCK_SIGOPS_COST = 80000;\r\n+/** Coinbase transaction outputs can only be spent after this number of new blocks (network rule) */\r\n+static const int COINBASE_MATURITY = 100;\r\n+\r\n+static const int WITNESS_SCALE_FACTOR = 4;\r\n+\r\n+static const size_t MIN_TRANSACTION_WEIGHT = WITNESS_SCALE_FACTOR * 60; // 60 is the lower bound for the size of a valid serialized CTransaction\r\n+static const size_t MIN_SERIALIZABLE_TRANSACTION_WEIGHT = WITNESS_SCALE_FACTOR * 10; // 10 is the lower bound for the size of a serialized CTransaction\r\n+\r\n+/** Flags for nSequence and nLockTime locks */\r\n+/** Interpret sequence numbers as relative lock-time constraints. */\r\n+static constexpr unsigned int LOCKTIME_VERIFY_SEQUENCE = (1 << 0);\r\n+/** Use GetMedianTimePast() instead of nTime for end point timestamp. */\r\n+static constexpr unsigned int LOCKTIME_MEDIAN_TIME_PAST = (1 << 1);\r\n+\r\n+#endif // BITCOIN_CONSENSUS_CONSENSUS_H\r"
      },
      {
        "sha": "a0f04e10dbe0c9746eb3d395e9a9ce87ea345620",
        "filename": "src/consensus/params.h",
        "status": "modified",
        "additions": 84,
        "deletions": 81,
        "changes": 165,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/consensus/params.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/consensus/params.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/params.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,81 +1,84 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_CONSENSUS_PARAMS_H\n-#define BITCOIN_CONSENSUS_PARAMS_H\n-\n-#include <uint256.h>\n-#include <limits>\n-#include <map>\n-#include <string>\n-\n-namespace Consensus {\n-\n-enum DeploymentPos\n-{\n-    DEPLOYMENT_TESTDUMMY,\n-    DEPLOYMENT_CSV, // Deployment of BIP68, BIP112, and BIP113.\n-    DEPLOYMENT_SEGWIT, // Deployment of BIP141, BIP143, and BIP147.\n-    // NOTE: Also add new deployments to VersionBitsDeploymentInfo in versionbits.cpp\n-    MAX_VERSION_BITS_DEPLOYMENTS\n-};\n-\n-/**\n- * Struct for each individual consensus rule change using BIP9.\n- */\n-struct BIP9Deployment {\n-    /** Bit position to select the particular bit in nVersion. */\n-    int bit;\n-    /** Start MedianTime for version bits miner confirmation. Can be a date in the past */\n-    int64_t nStartTime;\n-    /** Timeout/expiry MedianTime for the deployment attempt. */\n-    int64_t nTimeout;\n-\n-    /** Constant for nTimeout very far in the future. */\n-    static constexpr int64_t NO_TIMEOUT = std::numeric_limits<int64_t>::max();\n-\n-    /** Special value for nStartTime indicating that the deployment is always active.\n-     *  This is useful for testing, as it means tests don't need to deal with the activation\n-     *  process (which takes at least 3 BIP9 intervals). Only tests that specifically test the\n-     *  behaviour during activation cannot use this. */\n-    static constexpr int64_t ALWAYS_ACTIVE = -1;\n-};\n-\n-/**\n- * Parameters that influence chain consensus.\n- */\n-struct Params {\n-    uint256 hashGenesisBlock;\n-    int nSubsidyHalvingInterval;\n-    /** Block height at which BIP16 becomes active */\n-    int BIP16Height;\n-    /** Block height and hash at which BIP34 becomes active */\n-    int BIP34Height;\n-    uint256 BIP34Hash;\n-    /** Block height at which BIP65 becomes active */\n-    int BIP65Height;\n-    /** Block height at which BIP66 becomes active */\n-    int BIP66Height;\n-    /**\n-     * Minimum blocks including miner confirmation of the total of 2016 blocks in a retargeting period,\n-     * (nPowTargetTimespan / nPowTargetSpacing) which is also used for BIP9 deployments.\n-     * Examples: 1916 for 95%, 1512 for testchains.\n-     */\n-    uint32_t nRuleChangeActivationThreshold;\n-    uint32_t nMinerConfirmationWindow;\n-    BIP9Deployment vDeployments[MAX_VERSION_BITS_DEPLOYMENTS];\n-    /** Proof of work parameters */\n-    uint256 powLimit;\n-    bool fPowAllowMinDifficultyBlocks;\n-    bool fPowNoRetargeting;\n-    int64_t nPowTargetSpacing;\n-    int64_t nPowTargetTimespan;\n-    int64_t DifficultyAdjustmentInterval() const { return nPowTargetTimespan / nPowTargetSpacing; }\n-    uint256 nMinimumChainWork;\n-    uint256 defaultAssumeValid;\n-};\n-} // namespace Consensus\n-\n-#endif // BITCOIN_CONSENSUS_PARAMS_H\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\r\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#ifndef BITCOIN_CONSENSUS_PARAMS_H\r\n+#define BITCOIN_CONSENSUS_PARAMS_H\r\n+\r\n+#include <uint256.h>\r\n+#include <limits>\r\n+#include <map>\r\n+#include <string>\r\n+\r\n+namespace Consensus {\r\n+\r\n+enum DeploymentPos\r\n+{\r\n+    DEPLOYMENT_TESTDUMMY,\r\n+    DEPLOYMENT_CSV, // Deployment of BIP68, BIP112, and BIP113.\r\n+    DEPLOYMENT_SEGWIT, // Deployment of BIP141, BIP143, and BIP147.\r\n+    // NOTE: Also add new deployments to VersionBitsDeploymentInfo in versionbits.cpp\r\n+    MAX_VERSION_BITS_DEPLOYMENTS\r\n+};\r\n+\r\n+/**\r\n+ * Struct for each individual consensus rule change using BIP9.\r\n+ */\r\n+struct BIP9Deployment {\r\n+    /** Bit position to select the particular bit in nVersion. */\r\n+    int bit;\r\n+    /** Start MedianTime for version bits miner confirmation. Can be a date in the past */\r\n+    int64_t nStartTime;\r\n+    /** Timeout/expiry MedianTime for the deployment attempt. */\r\n+    int64_t nTimeout;\r\n+\r\n+    /** Constant for nTimeout very far in the future. */\r\n+    static constexpr int64_t NO_TIMEOUT = std::numeric_limits<int64_t>::max();\r\n+\r\n+    /** Special value for nStartTime indicating that the deployment is always active.\r\n+     *  This is useful for testing, as it means tests don't need to deal with the activation\r\n+     *  process (which takes at least 3 BIP9 intervals). Only tests that specifically test the\r\n+     *  behaviour during activation cannot use this. */\r\n+    static constexpr int64_t ALWAYS_ACTIVE = -1;\r\n+};\r\n+\r\n+/**\r\n+ * Parameters that influence chain consensus.\r\n+ */\r\n+struct Params {\r\n+    uint256 hashGenesisBlock;\r\n+    int nSubsidyHalvingInterval;\r\n+    /** Block height at which BIP16 becomes active */\r\n+    int BIP16Height;\r\n+    /** Block height and hash at which BIP34 becomes active */\r\n+    int BIP34Height;\r\n+    uint256 BIP34Hash;\r\n+    /** Block height at which BIP65 becomes active */\r\n+    int BIP65Height;\r\n+    /** Block height at which BIP66 becomes active */\r\n+    int BIP66Height;\r\n+    /**\r\n+     * Minimum blocks including miner confirmation of the total of 2016 blocks in a retargeting period,\r\n+     * (nPowTargetTimespan / nPowTargetSpacing) which is also used for BIP9 deployments.\r\n+     * Examples: 1916 for 95%, 1512 for testchains.\r\n+     */\r\n+    uint32_t nRuleChangeActivationThreshold;\r\n+    uint32_t nMinerConfirmationWindow;\r\n+    BIP9Deployment vDeployments[MAX_VERSION_BITS_DEPLOYMENTS];\r\n+    /** Proof of work parameters */\r\n+    uint256 powLimit;\r\n+    bool fPowAllowMinDifficultyBlocks;\r\n+    bool fPowNoRetargeting;\r\n+    int64_t nPowTargetSpacing;\r\n+    int64_t nPowTargetTimespan;\r\n+    int64_t nBtvPowTargetSpacing;\r\n+    int64_t nBtvPowTargetTimespan;\r\n+    int64_t DifficultyAdjustmentInterval() const { return nPowTargetTimespan / nPowTargetSpacing; }\r\n+    int64_t BtvDifficultyAdjustmentInterval() const { return nBtvPowTargetTimespan / nBtvPowTargetSpacing; }\r\n+    uint256 nMinimumChainWork;\r\n+    uint256 defaultAssumeValid;\r\n+};\r\n+} // namespace Consensus\r\n+\r\n+#endif // BITCOIN_CONSENSUS_PARAMS_H\r"
      },
      {
        "sha": "68e26027fdd870482d0bc4ab3f009d22fd297b97",
        "filename": "src/core_write.cpp",
        "status": "modified",
        "additions": 220,
        "deletions": 214,
        "changes": 434,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/core_write.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/core_write.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_write.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,214 +1,220 @@\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <core_io.h>\n-\n-#include <base58.h>\n-#include <consensus/consensus.h>\n-#include <consensus/validation.h>\n-#include <script/script.h>\n-#include <script/standard.h>\n-#include <serialize.h>\n-#include <streams.h>\n-#include <univalue.h>\n-#include <util.h>\n-#include <utilmoneystr.h>\n-#include <utilstrencodings.h>\n-\n-UniValue ValueFromAmount(const CAmount& amount)\n-{\n-    bool sign = amount < 0;\n-    int64_t n_abs = (sign ? -amount : amount);\n-    int64_t quotient = n_abs / COIN;\n-    int64_t remainder = n_abs % COIN;\n-    return UniValue(UniValue::VNUM,\n-            strprintf(\"%s%d.%08d\", sign ? \"-\" : \"\", quotient, remainder));\n-}\n-\n-std::string FormatScript(const CScript& script)\n-{\n-    std::string ret;\n-    CScript::const_iterator it = script.begin();\n-    opcodetype op;\n-    while (it != script.end()) {\n-        CScript::const_iterator it2 = it;\n-        std::vector<unsigned char> vch;\n-        if (script.GetOp2(it, op, &vch)) {\n-            if (op == OP_0) {\n-                ret += \"0 \";\n-                continue;\n-            } else if ((op >= OP_1 && op <= OP_16) || op == OP_1NEGATE) {\n-                ret += strprintf(\"%i \", op - OP_1NEGATE - 1);\n-                continue;\n-            } else if (op >= OP_NOP && op <= OP_NOP10) {\n-                std::string str(GetOpName(op));\n-                if (str.substr(0, 3) == std::string(\"OP_\")) {\n-                    ret += str.substr(3, std::string::npos) + \" \";\n-                    continue;\n-                }\n-            }\n-            if (vch.size() > 0) {\n-                ret += strprintf(\"0x%x 0x%x \", HexStr(it2, it - vch.size()), HexStr(it - vch.size(), it));\n-            } else {\n-                ret += strprintf(\"0x%x \", HexStr(it2, it));\n-            }\n-            continue;\n-        }\n-        ret += strprintf(\"0x%x \", HexStr(it2, script.end()));\n-        break;\n-    }\n-    return ret.substr(0, ret.size() - 1);\n-}\n-\n-const std::map<unsigned char, std::string> mapSigHashTypes = {\n-    {static_cast<unsigned char>(SIGHASH_ALL), std::string(\"ALL\")},\n-    {static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_ANYONECANPAY), std::string(\"ALL|ANYONECANPAY\")},\n-    {static_cast<unsigned char>(SIGHASH_NONE), std::string(\"NONE\")},\n-    {static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_ANYONECANPAY), std::string(\"NONE|ANYONECANPAY\")},\n-    {static_cast<unsigned char>(SIGHASH_SINGLE), std::string(\"SINGLE\")},\n-    {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\n-};\n-\n-/**\n- * Create the assembly string representation of a CScript object.\n- * @param[in] script    CScript object to convert into the asm string representation.\n- * @param[in] fAttemptSighashDecode    Whether to attempt to decode sighash types on data within the script that matches the format\n- *                                     of a signature. Only pass true for scripts you believe could contain signatures. For example,\n- *                                     pass false, or omit the this argument (defaults to false), for scriptPubKeys.\n- */\n-std::string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDecode)\n-{\n-    std::string str;\n-    opcodetype opcode;\n-    std::vector<unsigned char> vch;\n-    CScript::const_iterator pc = script.begin();\n-    while (pc < script.end()) {\n-        if (!str.empty()) {\n-            str += \" \";\n-        }\n-        if (!script.GetOp(pc, opcode, vch)) {\n-            str += \"[error]\";\n-            return str;\n-        }\n-        if (0 <= opcode && opcode <= OP_PUSHDATA4) {\n-            if (vch.size() <= static_cast<std::vector<unsigned char>::size_type>(4)) {\n-                str += strprintf(\"%d\", CScriptNum(vch, false).getint());\n-            } else {\n-                // the IsUnspendable check makes sure not to try to decode OP_RETURN data that may match the format of a signature\n-                if (fAttemptSighashDecode && !script.IsUnspendable()) {\n-                    std::string strSigHashDecode;\n-                    // goal: only attempt to decode a defined sighash type from data that looks like a signature within a scriptSig.\n-                    // this won't decode correctly formatted public keys in Pubkey or Multisig scripts due to\n-                    // the restrictions on the pubkey formats (see IsCompressedOrUncompressedPubKey) being incongruous with the\n-                    // checks in CheckSignatureEncoding.\n-                    if (CheckSignatureEncoding(vch, SCRIPT_VERIFY_STRICTENC, nullptr)) {\n-                        const unsigned char chSigHashType = vch.back();\n-                        if (mapSigHashTypes.count(chSigHashType)) {\n-                            strSigHashDecode = \"[\" + mapSigHashTypes.find(chSigHashType)->second + \"]\";\n-                            vch.pop_back(); // remove the sighash type byte. it will be replaced by the decode.\n-                        }\n-                    }\n-                    str += HexStr(vch) + strSigHashDecode;\n-                } else {\n-                    str += HexStr(vch);\n-                }\n-            }\n-        } else {\n-            str += GetOpName(opcode);\n-        }\n-    }\n-    return str;\n-}\n-\n-std::string EncodeHexTx(const CTransaction& tx, const int serializeFlags)\n-{\n-    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | serializeFlags);\n-    ssTx << tx;\n-    return HexStr(ssTx.begin(), ssTx.end());\n-}\n-\n-void ScriptPubKeyToUniv(const CScript& scriptPubKey,\n-                        UniValue& out, bool fIncludeHex)\n-{\n-    txnouttype type;\n-    std::vector<CTxDestination> addresses;\n-    int nRequired;\n-\n-    out.pushKV(\"asm\", ScriptToAsmStr(scriptPubKey));\n-    if (fIncludeHex)\n-        out.pushKV(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end()));\n-\n-    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired)) {\n-        out.pushKV(\"type\", GetTxnOutputType(type));\n-        return;\n-    }\n-\n-    out.pushKV(\"reqSigs\", nRequired);\n-    out.pushKV(\"type\", GetTxnOutputType(type));\n-\n-    UniValue a(UniValue::VARR);\n-    for (const CTxDestination& addr : addresses) {\n-        a.push_back(EncodeDestination(addr));\n-    }\n-    out.pushKV(\"addresses\", a);\n-}\n-\n-void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry, bool include_hex, int serialize_flags)\n-{\n-    entry.pushKV(\"txid\", tx.GetHash().GetHex());\n-    entry.pushKV(\"hash\", tx.GetWitnessHash().GetHex());\n-    entry.pushKV(\"version\", tx.nVersion);\n-    entry.pushKV(\"size\", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\n-    entry.pushKV(\"vsize\", (GetTransactionWeight(tx) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR);\n-    entry.pushKV(\"locktime\", (int64_t)tx.nLockTime);\n-\n-    UniValue vin(UniValue::VARR);\n-    for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-        const CTxIn& txin = tx.vin[i];\n-        UniValue in(UniValue::VOBJ);\n-        if (tx.IsCoinBase())\n-            in.pushKV(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end()));\n-        else {\n-            in.pushKV(\"txid\", txin.prevout.hash.GetHex());\n-            in.pushKV(\"vout\", (int64_t)txin.prevout.n);\n-            UniValue o(UniValue::VOBJ);\n-            o.pushKV(\"asm\", ScriptToAsmStr(txin.scriptSig, true));\n-            o.pushKV(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end()));\n-            in.pushKV(\"scriptSig\", o);\n-            if (!tx.vin[i].scriptWitness.IsNull()) {\n-                UniValue txinwitness(UniValue::VARR);\n-                for (const auto& item : tx.vin[i].scriptWitness.stack) {\n-                    txinwitness.push_back(HexStr(item.begin(), item.end()));\n-                }\n-                in.pushKV(\"txinwitness\", txinwitness);\n-            }\n-        }\n-        in.pushKV(\"sequence\", (int64_t)txin.nSequence);\n-        vin.push_back(in);\n-    }\n-    entry.pushKV(\"vin\", vin);\n-\n-    UniValue vout(UniValue::VARR);\n-    for (unsigned int i = 0; i < tx.vout.size(); i++) {\n-        const CTxOut& txout = tx.vout[i];\n-\n-        UniValue out(UniValue::VOBJ);\n-\n-        out.pushKV(\"value\", ValueFromAmount(txout.nValue));\n-        out.pushKV(\"n\", (int64_t)i);\n-\n-        UniValue o(UniValue::VOBJ);\n-        ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\n-        out.pushKV(\"scriptPubKey\", o);\n-        vout.push_back(out);\n-    }\n-    entry.pushKV(\"vout\", vout);\n-\n-    if (!hashBlock.IsNull())\n-        entry.pushKV(\"blockhash\", hashBlock.GetHex());\n-\n-    if (include_hex) {\n-        entry.pushKV(\"hex\", EncodeHexTx(tx, serialize_flags)); // the hex-encoded transaction. used the name \"hex\" to be consistent with the verbose output of \"getrawtransaction\".\n-    }\n-}\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <core_io.h>\r\n+\r\n+#include <base58.h>\r\n+#include <consensus/consensus.h>\r\n+#include <consensus/validation.h>\r\n+#include <script/script.h>\r\n+#include <script/standard.h>\r\n+#include <serialize.h>\r\n+#include <streams.h>\r\n+#include <univalue.h>\r\n+#include <util.h>\r\n+#include <utilmoneystr.h>\r\n+#include <utilstrencodings.h>\r\n+\r\n+UniValue ValueFromAmount(const CAmount& amount)\r\n+{\r\n+    bool sign = amount < 0;\r\n+    int64_t n_abs = (sign ? -amount : amount);\r\n+    int64_t quotient = n_abs / COIN;\r\n+    int64_t remainder = n_abs % COIN;\r\n+    return UniValue(UniValue::VNUM,\r\n+            strprintf(\"%s%d.%08d\", sign ? \"-\" : \"\", quotient, remainder));\r\n+}\r\n+\r\n+std::string FormatScript(const CScript& script)\r\n+{\r\n+    std::string ret;\r\n+    CScript::const_iterator it = script.begin();\r\n+    opcodetype op;\r\n+    while (it != script.end()) {\r\n+        CScript::const_iterator it2 = it;\r\n+        std::vector<unsigned char> vch;\r\n+        if (script.GetOp2(it, op, &vch)) {\r\n+            if (op == OP_0) {\r\n+                ret += \"0 \";\r\n+                continue;\r\n+            } else if ((op >= OP_1 && op <= OP_16) || op == OP_1NEGATE) {\r\n+                ret += strprintf(\"%i \", op - OP_1NEGATE - 1);\r\n+                continue;\r\n+            } else if (op >= OP_NOP && op <= OP_NOP10) {\r\n+                std::string str(GetOpName(op));\r\n+                if (str.substr(0, 3) == std::string(\"OP_\")) {\r\n+                    ret += str.substr(3, std::string::npos) + \" \";\r\n+                    continue;\r\n+                }\r\n+            }\r\n+            if (vch.size() > 0) {\r\n+                ret += strprintf(\"0x%x 0x%x \", HexStr(it2, it - vch.size()), HexStr(it - vch.size(), it));\r\n+            } else {\r\n+                ret += strprintf(\"0x%x \", HexStr(it2, it));\r\n+            }\r\n+            continue;\r\n+        }\r\n+        ret += strprintf(\"0x%x \", HexStr(it2, script.end()));\r\n+        break;\r\n+    }\r\n+    return ret.substr(0, ret.size() - 1);\r\n+}\r\n+\r\n+const std::map<unsigned char, std::string> mapSigHashTypes = {\r\n+    {static_cast<unsigned char>(SIGHASH_ALL), std::string(\"ALL\")},\r\n+    {static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_ANYONECANPAY), std::string(\"ALL|ANYONECANPAY\")},\r\n+    {static_cast<unsigned char>(SIGHASH_NONE), std::string(\"NONE\")},\r\n+    {static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_ANYONECANPAY), std::string(\"NONE|ANYONECANPAY\")},\r\n+    {static_cast<unsigned char>(SIGHASH_SINGLE), std::string(\"SINGLE\")},\r\n+    {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|ANYONECANPAY\")},\r\n+    {static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_FORKID), std::string(\"ALL|FORKID\")},\r\n+    {static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_FORKID), std::string(\"NONE|FORKID\")},\r\n+    {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_FORKID), std::string(\"SINGLE|FORKID\")},\r\n+    {static_cast<unsigned char>(SIGHASH_ALL|SIGHASH_FORKID|SIGHASH_ANYONECANPAY), std::string(\"ALL|FORKID|ANYONECANPAY\")},\r\n+    {static_cast<unsigned char>(SIGHASH_NONE|SIGHASH_FORKID|SIGHASH_ANYONECANPAY), std::string(\"NONE|FORKID|ANYONECANPAY\")},\r\n+    {static_cast<unsigned char>(SIGHASH_SINGLE|SIGHASH_FORKID|SIGHASH_ANYONECANPAY), std::string(\"SINGLE|FORKID|ANYONECANPAY\")},\r\n+};\r\n+\r\n+/**\r\n+ * Create the assembly string representation of a CScript object.\r\n+ * @param[in] script    CScript object to convert into the asm string representation.\r\n+ * @param[in] fAttemptSighashDecode    Whether to attempt to decode sighash types on data within the script that matches the format\r\n+ *                                     of a signature. Only pass true for scripts you believe could contain signatures. For example,\r\n+ *                                     pass false, or omit the this argument (defaults to false), for scriptPubKeys.\r\n+ */\r\n+std::string ScriptToAsmStr(const CScript& script, const bool fAttemptSighashDecode)\r\n+{\r\n+    std::string str;\r\n+    opcodetype opcode;\r\n+    std::vector<unsigned char> vch;\r\n+    CScript::const_iterator pc = script.begin();\r\n+    while (pc < script.end()) {\r\n+        if (!str.empty()) {\r\n+            str += \" \";\r\n+        }\r\n+        if (!script.GetOp(pc, opcode, vch)) {\r\n+            str += \"[error]\";\r\n+            return str;\r\n+        }\r\n+        if (0 <= opcode && opcode <= OP_PUSHDATA4) {\r\n+            if (vch.size() <= static_cast<std::vector<unsigned char>::size_type>(4)) {\r\n+                str += strprintf(\"%d\", CScriptNum(vch, false).getint());\r\n+            } else {\r\n+                // the IsUnspendable check makes sure not to try to decode OP_RETURN data that may match the format of a signature\r\n+                if (fAttemptSighashDecode && !script.IsUnspendable()) {\r\n+                    std::string strSigHashDecode;\r\n+                    // goal: only attempt to decode a defined sighash type from data that looks like a signature within a scriptSig.\r\n+                    // this won't decode correctly formatted public keys in Pubkey or Multisig scripts due to\r\n+                    // the restrictions on the pubkey formats (see IsCompressedOrUncompressedPubKey) being incongruous with the\r\n+                    // checks in CheckSignatureEncoding.\r\n+                    if (CheckSignatureEncoding(vch, SCRIPT_VERIFY_STRICTENC | SCRIPT_ENABLE_SIGHASH_FORKID, nullptr)) {\r\n+                        const unsigned char chSigHashType = vch.back();\r\n+                        if (mapSigHashTypes.count(chSigHashType)) {\r\n+                            strSigHashDecode = \"[\" + mapSigHashTypes.find(chSigHashType)->second + \"]\";\r\n+                            vch.pop_back(); // remove the sighash type byte. it will be replaced by the decode.\r\n+                        }\r\n+                    }\r\n+                    str += HexStr(vch) + strSigHashDecode;\r\n+                } else {\r\n+                    str += HexStr(vch);\r\n+                }\r\n+            }\r\n+        } else {\r\n+            str += GetOpName(opcode);\r\n+        }\r\n+    }\r\n+    return str;\r\n+}\r\n+\r\n+std::string EncodeHexTx(const CTransaction& tx, const int serializeFlags)\r\n+{\r\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION | serializeFlags);\r\n+    ssTx << tx;\r\n+    return HexStr(ssTx.begin(), ssTx.end());\r\n+}\r\n+\r\n+void ScriptPubKeyToUniv(const CScript& scriptPubKey,\r\n+                        UniValue& out, bool fIncludeHex)\r\n+{\r\n+    txnouttype type;\r\n+    std::vector<CTxDestination> addresses;\r\n+    int nRequired;\r\n+\r\n+    out.pushKV(\"asm\", ScriptToAsmStr(scriptPubKey));\r\n+    if (fIncludeHex)\r\n+        out.pushKV(\"hex\", HexStr(scriptPubKey.begin(), scriptPubKey.end()));\r\n+\r\n+    if (!ExtractDestinations(scriptPubKey, type, addresses, nRequired)) {\r\n+        out.pushKV(\"type\", GetTxnOutputType(type));\r\n+        return;\r\n+    }\r\n+\r\n+    out.pushKV(\"reqSigs\", nRequired);\r\n+    out.pushKV(\"type\", GetTxnOutputType(type));\r\n+\r\n+    UniValue a(UniValue::VARR);\r\n+    for (const CTxDestination& addr : addresses) {\r\n+        a.push_back(EncodeDestination(addr));\r\n+    }\r\n+    out.pushKV(\"addresses\", a);\r\n+}\r\n+\r\n+void TxToUniv(const CTransaction& tx, const uint256& hashBlock, UniValue& entry, bool include_hex, int serialize_flags)\r\n+{\r\n+    entry.pushKV(\"txid\", tx.GetHash().GetHex());\r\n+    entry.pushKV(\"hash\", tx.GetWitnessHash().GetHex());\r\n+    entry.pushKV(\"version\", tx.nVersion);\r\n+    entry.pushKV(\"size\", (int)::GetSerializeSize(tx, SER_NETWORK, PROTOCOL_VERSION));\r\n+    entry.pushKV(\"vsize\", (GetTransactionWeight(tx) + WITNESS_SCALE_FACTOR - 1) / WITNESS_SCALE_FACTOR);\r\n+    entry.pushKV(\"locktime\", (int64_t)tx.nLockTime);\r\n+\r\n+    UniValue vin(UniValue::VARR);\r\n+    for (unsigned int i = 0; i < tx.vin.size(); i++) {\r\n+        const CTxIn& txin = tx.vin[i];\r\n+        UniValue in(UniValue::VOBJ);\r\n+        if (tx.IsCoinBase())\r\n+            in.pushKV(\"coinbase\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end()));\r\n+        else {\r\n+            in.pushKV(\"txid\", txin.prevout.hash.GetHex());\r\n+            in.pushKV(\"vout\", (int64_t)txin.prevout.n);\r\n+            UniValue o(UniValue::VOBJ);\r\n+            o.pushKV(\"asm\", ScriptToAsmStr(txin.scriptSig, true));\r\n+            o.pushKV(\"hex\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end()));\r\n+            in.pushKV(\"scriptSig\", o);\r\n+            if (!tx.vin[i].scriptWitness.IsNull()) {\r\n+                UniValue txinwitness(UniValue::VARR);\r\n+                for (const auto& item : tx.vin[i].scriptWitness.stack) {\r\n+                    txinwitness.push_back(HexStr(item.begin(), item.end()));\r\n+                }\r\n+                in.pushKV(\"txinwitness\", txinwitness);\r\n+            }\r\n+        }\r\n+        in.pushKV(\"sequence\", (int64_t)txin.nSequence);\r\n+        vin.push_back(in);\r\n+    }\r\n+    entry.pushKV(\"vin\", vin);\r\n+\r\n+    UniValue vout(UniValue::VARR);\r\n+    for (unsigned int i = 0; i < tx.vout.size(); i++) {\r\n+        const CTxOut& txout = tx.vout[i];\r\n+\r\n+        UniValue out(UniValue::VOBJ);\r\n+\r\n+        out.pushKV(\"value\", ValueFromAmount(txout.nValue));\r\n+        out.pushKV(\"n\", (int64_t)i);\r\n+\r\n+        UniValue o(UniValue::VOBJ);\r\n+        ScriptPubKeyToUniv(txout.scriptPubKey, o, true);\r\n+        out.pushKV(\"scriptPubKey\", o);\r\n+        vout.push_back(out);\r\n+    }\r\n+    entry.pushKV(\"vout\", vout);\r\n+\r\n+    if (!hashBlock.IsNull())\r\n+        entry.pushKV(\"blockhash\", hashBlock.GetHex());\r\n+\r\n+    if (include_hex) {\r\n+        entry.pushKV(\"hex\", EncodeHexTx(tx, serialize_flags)); // the hex-encoded transaction. used the name \"hex\" to be consistent with the verbose output of \"getrawtransaction\".\r\n+    }\r\n+}\r"
      },
      {
        "sha": "662317c25db39afbbc5ad1e1cc650bc5487771ff",
        "filename": "src/crypto/aesb.c",
        "status": "added",
        "additions": 170,
        "deletions": 0,
        "changes": 170,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/aesb.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/aesb.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/aesb.c?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,170 @@\n+/*\r\n+---------------------------------------------------------------------------\r\n+Copyright (c) 1998-2013, Brian Gladman, Worcester, UK. All rights reserved.\r\n+\r\n+The redistribution and use of this software (with or without changes)\r\n+is allowed without the payment of fees or royalties provided that:\r\n+\r\n+  source code distributions include the above copyright notice, this\r\n+  list of conditions and the following disclaimer;\r\n+\r\n+  binary distributions include the above copyright notice, this list\r\n+  of conditions and the following disclaimer in their documentation.\r\n+\r\n+This software is provided 'as is' with no explicit or implied warranties\r\n+in respect of its operation, including, but not limited to, correctness\r\n+and fitness for purpose.\r\n+---------------------------------------------------------------------------\r\n+Issue Date: 20/12/2007\r\n+*/\r\n+\r\n+#include <stdint.h>\r\n+\r\n+#if defined(__cplusplus)\r\n+extern \"C\"\r\n+{\r\n+#endif\r\n+\r\n+#define TABLE_ALIGN     32\r\n+#define WPOLY           0x011b\r\n+#define N_COLS          4\r\n+#define AES_BLOCK_SIZE  16\r\n+#define RC_LENGTH       (5 * (AES_BLOCK_SIZE / 4 - 2))\r\n+\r\n+#if defined(_MSC_VER)\r\n+#define ALIGN __declspec(align(TABLE_ALIGN))\r\n+#elif defined(__GNUC__)\r\n+#define ALIGN __attribute__ ((aligned(16)))\r\n+#else\r\n+#define ALIGN\r\n+#endif\r\n+\r\n+#define rf1(r,c) (r)\r\n+#define word_in(x,c) (*((uint32_t*)(x)+(c)))\r\n+#define word_out(x,c,v) (*((uint32_t*)(x)+(c)) = (v))\r\n+\r\n+#define s(x,c) x[c]\r\n+#define si(y,x,c) (s(y,c) = word_in(x, c))\r\n+#define so(y,x,c) word_out(y, c, s(x,c))\r\n+#define state_in(y,x) si(y,x,0); si(y,x,1); si(y,x,2); si(y,x,3)\r\n+#define state_out(y,x)  so(y,x,0); so(y,x,1); so(y,x,2); so(y,x,3)\r\n+#define round(y,x,k) \\\r\n+y[0] = (k)[0]  ^ (t_fn[0][x[0] & 0xff] ^ t_fn[1][(x[1] >> 8) & 0xff] ^ t_fn[2][(x[2] >> 16) & 0xff] ^ t_fn[3][x[3] >> 24]); \\\r\n+y[1] = (k)[1]  ^ (t_fn[0][x[1] & 0xff] ^ t_fn[1][(x[2] >> 8) & 0xff] ^ t_fn[2][(x[3] >> 16) & 0xff] ^ t_fn[3][x[0] >> 24]); \\\r\n+y[2] = (k)[2]  ^ (t_fn[0][x[2] & 0xff] ^ t_fn[1][(x[3] >> 8) & 0xff] ^ t_fn[2][(x[0] >> 16) & 0xff] ^ t_fn[3][x[1] >> 24]); \\\r\n+y[3] = (k)[3]  ^ (t_fn[0][x[3] & 0xff] ^ t_fn[1][(x[0] >> 8) & 0xff] ^ t_fn[2][(x[1] >> 16) & 0xff] ^ t_fn[3][x[2] >> 24]);\r\n+#define to_byte(x) ((x) & 0xff)\r\n+#define bval(x,n) to_byte((x) >> (8 * (n)))\r\n+\r\n+#define fwd_var(x,r,c)\\\r\n+ ( r == 0 ? ( c == 0 ? s(x,0) : c == 1 ? s(x,1) : c == 2 ? s(x,2) : s(x,3))\\\r\n+ : r == 1 ? ( c == 0 ? s(x,1) : c == 1 ? s(x,2) : c == 2 ? s(x,3) : s(x,0))\\\r\n+ : r == 2 ? ( c == 0 ? s(x,2) : c == 1 ? s(x,3) : c == 2 ? s(x,0) : s(x,1))\\\r\n+ :          ( c == 0 ? s(x,3) : c == 1 ? s(x,0) : c == 2 ? s(x,1) : s(x,2)))\r\n+\r\n+#define fwd_rnd(y,x,k,c)  (s(y,c) = (k)[c] ^ four_tables(x,t_use(f,n),fwd_var,rf1,c))\r\n+\r\n+#define sb_data(w) {\\\r\n+    w(0x63), w(0x7c), w(0x77), w(0x7b), w(0xf2), w(0x6b), w(0x6f), w(0xc5),\\\r\n+    w(0x30), w(0x01), w(0x67), w(0x2b), w(0xfe), w(0xd7), w(0xab), w(0x76),\\\r\n+    w(0xca), w(0x82), w(0xc9), w(0x7d), w(0xfa), w(0x59), w(0x47), w(0xf0),\\\r\n+    w(0xad), w(0xd4), w(0xa2), w(0xaf), w(0x9c), w(0xa4), w(0x72), w(0xc0),\\\r\n+    w(0xb7), w(0xfd), w(0x93), w(0x26), w(0x36), w(0x3f), w(0xf7), w(0xcc),\\\r\n+    w(0x34), w(0xa5), w(0xe5), w(0xf1), w(0x71), w(0xd8), w(0x31), w(0x15),\\\r\n+    w(0x04), w(0xc7), w(0x23), w(0xc3), w(0x18), w(0x96), w(0x05), w(0x9a),\\\r\n+    w(0x07), w(0x12), w(0x80), w(0xe2), w(0xeb), w(0x27), w(0xb2), w(0x75),\\\r\n+    w(0x09), w(0x83), w(0x2c), w(0x1a), w(0x1b), w(0x6e), w(0x5a), w(0xa0),\\\r\n+    w(0x52), w(0x3b), w(0xd6), w(0xb3), w(0x29), w(0xe3), w(0x2f), w(0x84),\\\r\n+    w(0x53), w(0xd1), w(0x00), w(0xed), w(0x20), w(0xfc), w(0xb1), w(0x5b),\\\r\n+    w(0x6a), w(0xcb), w(0xbe), w(0x39), w(0x4a), w(0x4c), w(0x58), w(0xcf),\\\r\n+    w(0xd0), w(0xef), w(0xaa), w(0xfb), w(0x43), w(0x4d), w(0x33), w(0x85),\\\r\n+    w(0x45), w(0xf9), w(0x02), w(0x7f), w(0x50), w(0x3c), w(0x9f), w(0xa8),\\\r\n+    w(0x51), w(0xa3), w(0x40), w(0x8f), w(0x92), w(0x9d), w(0x38), w(0xf5),\\\r\n+    w(0xbc), w(0xb6), w(0xda), w(0x21), w(0x10), w(0xff), w(0xf3), w(0xd2),\\\r\n+    w(0xcd), w(0x0c), w(0x13), w(0xec), w(0x5f), w(0x97), w(0x44), w(0x17),\\\r\n+    w(0xc4), w(0xa7), w(0x7e), w(0x3d), w(0x64), w(0x5d), w(0x19), w(0x73),\\\r\n+    w(0x60), w(0x81), w(0x4f), w(0xdc), w(0x22), w(0x2a), w(0x90), w(0x88),\\\r\n+    w(0x46), w(0xee), w(0xb8), w(0x14), w(0xde), w(0x5e), w(0x0b), w(0xdb),\\\r\n+    w(0xe0), w(0x32), w(0x3a), w(0x0a), w(0x49), w(0x06), w(0x24), w(0x5c),\\\r\n+    w(0xc2), w(0xd3), w(0xac), w(0x62), w(0x91), w(0x95), w(0xe4), w(0x79),\\\r\n+    w(0xe7), w(0xc8), w(0x37), w(0x6d), w(0x8d), w(0xd5), w(0x4e), w(0xa9),\\\r\n+    w(0x6c), w(0x56), w(0xf4), w(0xea), w(0x65), w(0x7a), w(0xae), w(0x08),\\\r\n+    w(0xba), w(0x78), w(0x25), w(0x2e), w(0x1c), w(0xa6), w(0xb4), w(0xc6),\\\r\n+    w(0xe8), w(0xdd), w(0x74), w(0x1f), w(0x4b), w(0xbd), w(0x8b), w(0x8a),\\\r\n+    w(0x70), w(0x3e), w(0xb5), w(0x66), w(0x48), w(0x03), w(0xf6), w(0x0e),\\\r\n+    w(0x61), w(0x35), w(0x57), w(0xb9), w(0x86), w(0xc1), w(0x1d), w(0x9e),\\\r\n+    w(0xe1), w(0xf8), w(0x98), w(0x11), w(0x69), w(0xd9), w(0x8e), w(0x94),\\\r\n+    w(0x9b), w(0x1e), w(0x87), w(0xe9), w(0xce), w(0x55), w(0x28), w(0xdf),\\\r\n+    w(0x8c), w(0xa1), w(0x89), w(0x0d), w(0xbf), w(0xe6), w(0x42), w(0x68),\\\r\n+    w(0x41), w(0x99), w(0x2d), w(0x0f), w(0xb0), w(0x54), w(0xbb), w(0x16) }\r\n+\r\n+#define rc_data(w) {\\\r\n+    w(0x01), w(0x02), w(0x04), w(0x08), w(0x10),w(0x20), w(0x40), w(0x80),\\\r\n+    w(0x1b), w(0x36) }\r\n+\r\n+#define bytes2word(b0, b1, b2, b3) (((uint32_t)(b3) << 24) | \\\r\n+    ((uint32_t)(b2) << 16) | ((uint32_t)(b1) << 8) | (b0))\r\n+\r\n+#define h0(x)   (x)\r\n+#define w0(p)   bytes2word(p, 0, 0, 0)\r\n+#define w1(p)   bytes2word(0, p, 0, 0)\r\n+#define w2(p)   bytes2word(0, 0, p, 0)\r\n+#define w3(p)   bytes2word(0, 0, 0, p)\r\n+\r\n+#define u0(p)   bytes2word(f2(p), p, p, f3(p))\r\n+#define u1(p)   bytes2word(f3(p), f2(p), p, p)\r\n+#define u2(p)   bytes2word(p, f3(p), f2(p), p)\r\n+#define u3(p)   bytes2word(p, p, f3(p), f2(p))\r\n+\r\n+#define v0(p)   bytes2word(fe(p), f9(p), fd(p), fb(p))\r\n+#define v1(p)   bytes2word(fb(p), fe(p), f9(p), fd(p))\r\n+#define v2(p)   bytes2word(fd(p), fb(p), fe(p), f9(p))\r\n+#define v3(p)   bytes2word(f9(p), fd(p), fb(p), fe(p))\r\n+\r\n+#define f2(x)   ((x<<1) ^ (((x>>7) & 1) * WPOLY))\r\n+#define f4(x)   ((x<<2) ^ (((x>>6) & 1) * WPOLY) ^ (((x>>6) & 2) * WPOLY))\r\n+#define f8(x)   ((x<<3) ^ (((x>>5) & 1) * WPOLY) ^ (((x>>5) & 2) * WPOLY) ^ (((x>>5) & 4) * WPOLY))\r\n+#define f3(x)   (f2(x) ^ x)\r\n+#define f9(x)   (f8(x) ^ x)\r\n+#define fb(x)   (f8(x) ^ f2(x) ^ x)\r\n+#define fd(x)   (f8(x) ^ f4(x) ^ x)\r\n+#define fe(x)   (f8(x) ^ f4(x) ^ f2(x))\r\n+\r\n+#define t_dec(m,n) t_##m##n\r\n+#define t_set(m,n) t_##m##n\r\n+#define t_use(m,n) t_##m##n\r\n+\r\n+#define d_4(t,n,b,e,f,g,h) ALIGN const t n[4][256] = { b(e), b(f), b(g), b(h) }\r\n+\r\n+#define four_tables(x,tab,vf,rf,c) \\\r\n+    (tab[0][bval(vf(x,0,c),rf(0,c))] \\\r\n+    ^ tab[1][bval(vf(x,1,c),rf(1,c))] \\\r\n+    ^ tab[2][bval(vf(x,2,c),rf(2,c))] \\\r\n+    ^ tab[3][bval(vf(x,3,c),rf(3,c))])\r\n+\r\n+d_4(uint32_t, t_dec(f,n), sb_data, u0, u1, u2, u3);\r\n+\r\n+void aesb_single_round(const uint8_t *in, uint8_t *out, uint8_t *expandedKey)\r\n+{\r\n+    round(((uint32_t*) out), ((uint32_t*) in), ((uint32_t*) expandedKey));\r\n+}\r\n+\r\n+void aesb_pseudo_round_mut(uint8_t *val, uint8_t *expandedKey)\r\n+{\r\n+    uint32_t b1[4];\r\n+    round(b1, ((uint32_t*) val), ((const uint32_t *) expandedKey));\r\n+    round(((uint32_t*) val), b1, ((const uint32_t *) expandedKey) + 1 * N_COLS);\r\n+    round(b1, ((uint32_t*) val), ((const uint32_t *) expandedKey) + 2 * N_COLS);\r\n+    round(((uint32_t*) val), b1, ((const uint32_t *) expandedKey) + 3 * N_COLS);\r\n+    round(b1, ((uint32_t*) val), ((const uint32_t *) expandedKey) + 4 * N_COLS);\r\n+    round(((uint32_t*) val), b1, ((const uint32_t *) expandedKey) + 5 * N_COLS);\r\n+    round(b1, ((uint32_t*) val), ((const uint32_t *) expandedKey) + 6 * N_COLS);\r\n+    round(((uint32_t*) val), b1, ((const uint32_t *) expandedKey) + 7 * N_COLS);\r\n+    round(b1, ((uint32_t*) val), ((const uint32_t *) expandedKey) + 8 * N_COLS);\r\n+    round(((uint32_t*) val), b1, ((const uint32_t *) expandedKey) + 9 * N_COLS);\r\n+}\r\n+\r\n+\r\n+#if defined(__cplusplus)\r\n+}\r\n+#endif\r"
      },
      {
        "sha": "1475d30c5f06f78384a8df546e2c63755540ea5e",
        "filename": "src/crypto/c_blake256.c",
        "status": "added",
        "additions": 326,
        "deletions": 0,
        "changes": 326,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_blake256.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_blake256.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/c_blake256.c?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,326 @@\n+/*\r\n+ * The blake256_* and blake224_* functions are largely copied from\r\n+ * blake256_light.c and blake224_light.c from the BLAKE website:\r\n+ *\r\n+ *     http://131002.net/blake/\r\n+ *\r\n+ * The hmac_* functions implement HMAC-BLAKE-256 and HMAC-BLAKE-224.\r\n+ * HMAC is specified by RFC 2104.\r\n+ */\r\n+\r\n+#include <string.h>\r\n+#include <stdio.h>\r\n+#include <stdint.h>\r\n+#include <crypto/c_blake256.h>\r\n+\r\n+#define U8TO32(p) \\\r\n+    (((uint32_t)((p)[0]) << 24) | ((uint32_t)((p)[1]) << 16) |    \\\r\n+     ((uint32_t)((p)[2]) <<  8) | ((uint32_t)((p)[3])      ))\r\n+#define U32TO8(p, v) \\\r\n+    (p)[0] = (uint8_t)((v) >> 24); (p)[1] = (uint8_t)((v) >> 16); \\\r\n+    (p)[2] = (uint8_t)((v) >>  8); (p)[3] = (uint8_t)((v)      );\r\n+\r\n+const uint8_t sigma[][16] = {\r\n+    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15},\r\n+    {14,10, 4, 8, 9,15,13, 6, 1,12, 0, 2,11, 7, 5, 3},\r\n+    {11, 8,12, 0, 5, 2,15,13,10,14, 3, 6, 7, 1, 9, 4},\r\n+    { 7, 9, 3, 1,13,12,11,14, 2, 6, 5,10, 4, 0,15, 8},\r\n+    { 9, 0, 5, 7, 2, 4,10,15,14, 1,11,12, 6, 8, 3,13},\r\n+    { 2,12, 6,10, 0,11, 8, 3, 4,13, 7, 5,15,14, 1, 9},\r\n+    {12, 5, 1,15,14,13, 4,10, 0, 7, 6, 3, 9, 2, 8,11},\r\n+    {13,11, 7,14,12, 1, 3, 9, 5, 0,15, 4, 8, 6, 2,10},\r\n+    { 6,15,14, 9,11, 3, 0, 8,12, 2,13, 7, 1, 4,10, 5},\r\n+    {10, 2, 8, 4, 7, 6, 1, 5,15,11, 9,14, 3,12,13, 0},\r\n+    { 0, 1, 2, 3, 4, 5, 6, 7, 8, 9,10,11,12,13,14,15},\r\n+    {14,10, 4, 8, 9,15,13, 6, 1,12, 0, 2,11, 7, 5, 3},\r\n+    {11, 8,12, 0, 5, 2,15,13,10,14, 3, 6, 7, 1, 9, 4},\r\n+    { 7, 9, 3, 1,13,12,11,14, 2, 6, 5,10, 4, 0,15, 8}\r\n+};\r\n+\r\n+const uint32_t cst[16] = {\r\n+    0x243F6A88, 0x85A308D3, 0x13198A2E, 0x03707344,\r\n+    0xA4093822, 0x299F31D0, 0x082EFA98, 0xEC4E6C89,\r\n+    0x452821E6, 0x38D01377, 0xBE5466CF, 0x34E90C6C,\r\n+    0xC0AC29B7, 0xC97C50DD, 0x3F84D5B5, 0xB5470917\r\n+};\r\n+\r\n+static const uint8_t padding[] = {\r\n+    0x80,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\r\n+    0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0\r\n+};\r\n+\r\n+\r\n+void blake256_compress(state *S, const uint8_t *block) {\r\n+    uint32_t v[16], m[16], i;\r\n+\r\n+#define ROT(x,n) (((x)<<(32-n))|((x)>>(n)))\r\n+#define G(a,b,c,d,e)                                      \\\r\n+    v[a] += (m[sigma[i][e]] ^ cst[sigma[i][e+1]]) + v[b]; \\\r\n+    v[d] = ROT(v[d] ^ v[a],16);                           \\\r\n+    v[c] += v[d];                                         \\\r\n+    v[b] = ROT(v[b] ^ v[c],12);                           \\\r\n+    v[a] += (m[sigma[i][e+1]] ^ cst[sigma[i][e]])+v[b];   \\\r\n+    v[d] = ROT(v[d] ^ v[a], 8);                           \\\r\n+    v[c] += v[d];                                         \\\r\n+    v[b] = ROT(v[b] ^ v[c], 7);\r\n+\r\n+    for (i = 0; i < 16; ++i) m[i] = U8TO32(block + i * 4);\r\n+    for (i = 0; i < 8;  ++i) v[i] = S->h[i];\r\n+    v[ 8] = S->s[0] ^ 0x243F6A88;\r\n+    v[ 9] = S->s[1] ^ 0x85A308D3;\r\n+    v[10] = S->s[2] ^ 0x13198A2E;\r\n+    v[11] = S->s[3] ^ 0x03707344;\r\n+    v[12] = 0xA4093822;\r\n+    v[13] = 0x299F31D0;\r\n+    v[14] = 0x082EFA98;\r\n+    v[15] = 0xEC4E6C89;\r\n+\r\n+    if (S->nullt == 0) {\r\n+        v[12] ^= S->t[0];\r\n+        v[13] ^= S->t[0];\r\n+        v[14] ^= S->t[1];\r\n+        v[15] ^= S->t[1];\r\n+    }\r\n+\r\n+    for (i = 0; i < 14; ++i) {\r\n+        G(0, 4,  8, 12,  0);\r\n+        G(1, 5,  9, 13,  2);\r\n+        G(2, 6, 10, 14,  4);\r\n+        G(3, 7, 11, 15,  6);\r\n+        G(3, 4,  9, 14, 14);\r\n+        G(2, 7,  8, 13, 12);\r\n+        G(0, 5, 10, 15,  8);\r\n+        G(1, 6, 11, 12, 10);\r\n+    }\r\n+\r\n+    for (i = 0; i < 16; ++i) S->h[i % 8] ^= v[i];\r\n+    for (i = 0; i < 8;  ++i) S->h[i] ^= S->s[i % 4];\r\n+}\r\n+\r\n+void blake256_init(state *S) {\r\n+    S->h[0] = 0x6A09E667;\r\n+    S->h[1] = 0xBB67AE85;\r\n+    S->h[2] = 0x3C6EF372;\r\n+    S->h[3] = 0xA54FF53A;\r\n+    S->h[4] = 0x510E527F;\r\n+    S->h[5] = 0x9B05688C;\r\n+    S->h[6] = 0x1F83D9AB;\r\n+    S->h[7] = 0x5BE0CD19;\r\n+    S->t[0] = S->t[1] = S->buflen = S->nullt = 0;\r\n+    S->s[0] = S->s[1] = S->s[2] = S->s[3] = 0;\r\n+}\r\n+\r\n+void blake224_init(state *S) {\r\n+    S->h[0] = 0xC1059ED8;\r\n+    S->h[1] = 0x367CD507;\r\n+    S->h[2] = 0x3070DD17;\r\n+    S->h[3] = 0xF70E5939;\r\n+    S->h[4] = 0xFFC00B31;\r\n+    S->h[5] = 0x68581511;\r\n+    S->h[6] = 0x64F98FA7;\r\n+    S->h[7] = 0xBEFA4FA4;\r\n+    S->t[0] = S->t[1] = S->buflen = S->nullt = 0;\r\n+    S->s[0] = S->s[1] = S->s[2] = S->s[3] = 0;\r\n+}\r\n+\r\n+// datalen = number of bits\r\n+void blake256_update(state *S, const uint8_t *data, uint64_t datalen) {\r\n+    int left = S->buflen >> 3;\r\n+    int fill = 64 - left;\r\n+\r\n+    if (left && (((datalen >> 3) & 0x3F) >= (unsigned) fill)) {\r\n+        memcpy((void *) (S->buf + left), (void *) data, fill);\r\n+        S->t[0] += 512;\r\n+        if (S->t[0] == 0) S->t[1]++;\r\n+        blake256_compress(S, S->buf);\r\n+        data += fill;\r\n+        datalen -= (fill << 3);\r\n+        left = 0;\r\n+    }\r\n+\r\n+    while (datalen >= 512) {\r\n+        S->t[0] += 512;\r\n+        if (S->t[0] == 0) S->t[1]++;\r\n+        blake256_compress(S, data);\r\n+        data += 64;\r\n+        datalen -= 512;\r\n+    }\r\n+\r\n+    if (datalen > 0) {\r\n+        memcpy((void *) (S->buf + left), (void *) data, datalen >> 3);\r\n+        S->buflen = (left << 3) + datalen;\r\n+    } else {\r\n+        S->buflen = 0;\r\n+    }\r\n+}\r\n+\r\n+// datalen = number of bits\r\n+void blake224_update(state *S, const uint8_t *data, uint64_t datalen) {\r\n+    blake256_update(S, data, datalen);\r\n+}\r\n+\r\n+void blake256_final_h(state *S, uint8_t *digest, uint8_t pa, uint8_t pb) {\r\n+    uint8_t msglen[8];\r\n+    uint32_t lo = S->t[0] + S->buflen, hi = S->t[1];\r\n+    if (lo < (unsigned) S->buflen) hi++;\r\n+    U32TO8(msglen + 0, hi);\r\n+    U32TO8(msglen + 4, lo);\r\n+\r\n+    if (S->buflen == 440) { /* one padding byte */\r\n+        S->t[0] -= 8;\r\n+        blake256_update(S, &pa, 8);\r\n+    } else {\r\n+        if (S->buflen < 440) { /* enough space to fill the block  */\r\n+            if (S->buflen == 0) S->nullt = 1;\r\n+            S->t[0] -= 440 - S->buflen;\r\n+            blake256_update(S, padding, 440 - S->buflen);\r\n+        } else { /* need 2 compressions */\r\n+            S->t[0] -= 512 - S->buflen;\r\n+            blake256_update(S, padding, 512 - S->buflen);\r\n+            S->t[0] -= 440;\r\n+            blake256_update(S, padding + 1, 440);\r\n+            S->nullt = 1;\r\n+        }\r\n+        blake256_update(S, &pb, 8);\r\n+        S->t[0] -= 8;\r\n+    }\r\n+    S->t[0] -= 64;\r\n+    blake256_update(S, msglen, 64);\r\n+\r\n+    U32TO8(digest +  0, S->h[0]);\r\n+    U32TO8(digest +  4, S->h[1]);\r\n+    U32TO8(digest +  8, S->h[2]);\r\n+    U32TO8(digest + 12, S->h[3]);\r\n+    U32TO8(digest + 16, S->h[4]);\r\n+    U32TO8(digest + 20, S->h[5]);\r\n+    U32TO8(digest + 24, S->h[6]);\r\n+    U32TO8(digest + 28, S->h[7]);\r\n+}\r\n+\r\n+void blake256_final(state *S, uint8_t *digest) {\r\n+    blake256_final_h(S, digest, 0x81, 0x01);\r\n+}\r\n+\r\n+void blake224_final(state *S, uint8_t *digest) {\r\n+    blake256_final_h(S, digest, 0x80, 0x00);\r\n+}\r\n+\r\n+// inlen = number of bytes\r\n+void blake256_hash(uint8_t *out, const uint8_t *in, uint64_t inlen) {\r\n+    state S;\r\n+    blake256_init(&S);\r\n+    blake256_update(&S, in, inlen * 8);\r\n+    blake256_final(&S, out);\r\n+}\r\n+\r\n+// inlen = number of bytes\r\n+void blake224_hash(uint8_t *out, const uint8_t *in, uint64_t inlen) {\r\n+    state S;\r\n+    blake224_init(&S);\r\n+    blake224_update(&S, in, inlen * 8);\r\n+    blake224_final(&S, out);\r\n+}\r\n+\r\n+// keylen = number of bytes\r\n+void hmac_blake256_init(hmac_state *S, const uint8_t *_key, uint64_t keylen) {\r\n+    const uint8_t *key = _key;\r\n+    uint8_t keyhash[32];\r\n+    uint8_t pad[64];\r\n+    uint64_t i;\r\n+\r\n+    if (keylen > 64) {\r\n+        blake256_hash(keyhash, key, keylen);\r\n+        key = keyhash;\r\n+        keylen = 32;\r\n+    }\r\n+\r\n+    blake256_init(&S->inner);\r\n+    memset(pad, 0x36, 64);\r\n+    for (i = 0; i < keylen; ++i) {\r\n+        pad[i] ^= key[i];\r\n+    }\r\n+    blake256_update(&S->inner, pad, 512);\r\n+\r\n+    blake256_init(&S->outer);\r\n+    memset(pad, 0x5c, 64);\r\n+    for (i = 0; i < keylen; ++i) {\r\n+        pad[i] ^= key[i];\r\n+    }\r\n+    blake256_update(&S->outer, pad, 512);\r\n+\r\n+    memset(keyhash, 0, 32);\r\n+}\r\n+\r\n+// keylen = number of bytes\r\n+void hmac_blake224_init(hmac_state *S, const uint8_t *_key, uint64_t keylen) {\r\n+    const uint8_t *key = _key;\r\n+    uint8_t keyhash[32];\r\n+    uint8_t pad[64];\r\n+    uint64_t i;\r\n+\r\n+    if (keylen > 64) {\r\n+        blake256_hash(keyhash, key, keylen);\r\n+        key = keyhash;\r\n+        keylen = 28;\r\n+    }\r\n+\r\n+    blake224_init(&S->inner);\r\n+    memset(pad, 0x36, 64);\r\n+    for (i = 0; i < keylen; ++i) {\r\n+        pad[i] ^= key[i];\r\n+    }\r\n+    blake224_update(&S->inner, pad, 512);\r\n+\r\n+    blake224_init(&S->outer);\r\n+    memset(pad, 0x5c, 64);\r\n+    for (i = 0; i < keylen; ++i) {\r\n+        pad[i] ^= key[i];\r\n+    }\r\n+    blake224_update(&S->outer, pad, 512);\r\n+\r\n+    memset(keyhash, 0, 32);\r\n+}\r\n+\r\n+// datalen = number of bits\r\n+void hmac_blake256_update(hmac_state *S, const uint8_t *data, uint64_t datalen) {\r\n+  // update the inner state\r\n+  blake256_update(&S->inner, data, datalen);\r\n+}\r\n+\r\n+// datalen = number of bits\r\n+void hmac_blake224_update(hmac_state *S, const uint8_t *data, uint64_t datalen) {\r\n+  // update the inner state\r\n+  blake224_update(&S->inner, data, datalen);\r\n+}\r\n+\r\n+void hmac_blake256_final(hmac_state *S, uint8_t *digest) {\r\n+    uint8_t ihash[32];\r\n+    blake256_final(&S->inner, ihash);\r\n+    blake256_update(&S->outer, ihash, 256);\r\n+    blake256_final(&S->outer, digest);\r\n+    memset(ihash, 0, 32);\r\n+}\r\n+\r\n+void hmac_blake224_final(hmac_state *S, uint8_t *digest) {\r\n+    uint8_t ihash[32];\r\n+    blake224_final(&S->inner, ihash);\r\n+    blake224_update(&S->outer, ihash, 224);\r\n+    blake224_final(&S->outer, digest);\r\n+    memset(ihash, 0, 32);\r\n+}\r\n+\r\n+// keylen = number of bytes; inlen = number of bytes\r\n+void hmac_blake256_hash(uint8_t *out, const uint8_t *key, uint64_t keylen, const uint8_t *in, uint64_t inlen) {\r\n+    hmac_state S;\r\n+    hmac_blake256_init(&S, key, keylen);\r\n+    hmac_blake256_update(&S, in, inlen * 8);\r\n+    hmac_blake256_final(&S, out);\r\n+}\r\n+\r\n+// keylen = number of bytes; inlen = number of bytes\r\n+void hmac_blake224_hash(uint8_t *out, const uint8_t *key, uint64_t keylen, const uint8_t *in, uint64_t inlen) {\r\n+    hmac_state S;\r\n+    hmac_blake224_init(&S, key, keylen);\r\n+    hmac_blake224_update(&S, in, inlen * 8);\r\n+    hmac_blake224_final(&S, out);\r\n+}\r"
      },
      {
        "sha": "ec8be88fa16c80eec1ff587666db5d9783c62812",
        "filename": "src/crypto/c_blake256.h",
        "status": "added",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_blake256.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_blake256.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/c_blake256.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,43 @@\n+#ifndef _BLAKE256_H_\r\n+#define _BLAKE256_H_\r\n+\r\n+#include <stdint.h>\r\n+\r\n+typedef struct {\r\n+  uint32_t h[8], s[4], t[2];\r\n+  int buflen, nullt;\r\n+  uint8_t buf[64];\r\n+} state;\r\n+\r\n+typedef struct {\r\n+  state inner;\r\n+  state outer;\r\n+} hmac_state;\r\n+\r\n+void blake256_init(state *);\r\n+void blake224_init(state *);\r\n+\r\n+void blake256_update(state *, const uint8_t *, uint64_t);\r\n+void blake224_update(state *, const uint8_t *, uint64_t);\r\n+\r\n+void blake256_final(state *, uint8_t *);\r\n+void blake224_final(state *, uint8_t *);\r\n+\r\n+void blake256_hash(uint8_t *, const uint8_t *, uint64_t);\r\n+void blake224_hash(uint8_t *, const uint8_t *, uint64_t);\r\n+\r\n+/* HMAC functions: */\r\n+\r\n+void hmac_blake256_init(hmac_state *, const uint8_t *, uint64_t);\r\n+void hmac_blake224_init(hmac_state *, const uint8_t *, uint64_t);\r\n+\r\n+void hmac_blake256_update(hmac_state *, const uint8_t *, uint64_t);\r\n+void hmac_blake224_update(hmac_state *, const uint8_t *, uint64_t);\r\n+\r\n+void hmac_blake256_final(hmac_state *, uint8_t *);\r\n+void hmac_blake224_final(hmac_state *, uint8_t *);\r\n+\r\n+void hmac_blake256_hash(uint8_t *, const uint8_t *, uint64_t, const uint8_t *, uint64_t);\r\n+void hmac_blake224_hash(uint8_t *, const uint8_t *, uint64_t, const uint8_t *, uint64_t);\r\n+\r\n+#endif /* _BLAKE256_H_ */\r"
      },
      {
        "sha": "2c3888807f005887dc71d24a40e7a89961323137",
        "filename": "src/crypto/c_groestl.c",
        "status": "added",
        "additions": 360,
        "deletions": 0,
        "changes": 360,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_groestl.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_groestl.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/c_groestl.c?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,360 @@\n+/* hash.c     April 2012\r\n+ * Groestl ANSI C code optimised for 32-bit machines\r\n+ * Author: Thomas Krinninger\r\n+ *\r\n+ *  This work is based on the implementation of\r\n+ *          Soeren S. Thomsen and Krystian Matusiewicz\r\n+ *          \r\n+ *\r\n+ */\r\n+\r\n+#include <crypto/c_groestl.h>\r\n+#include <crypto/groestl_tables.h>\r\n+\r\n+#define P_TYPE 0\r\n+#define Q_TYPE 1\r\n+\r\n+const uint8_t shift_Values[2][8] = {{0,1,2,3,4,5,6,7},{1,3,5,7,0,2,4,6}};\r\n+\r\n+const uint8_t indices_cyclic[15] = {0,1,2,3,4,5,6,7,0,1,2,3,4,5,6};\r\n+\r\n+\r\n+#define ROTATE_COLUMN_DOWN(v1, v2, amount_bytes, temp_var) {temp_var = (v1<<(8*amount_bytes))|(v2>>(8*(4-amount_bytes))); \\\r\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv2 = (v2<<(8*amount_bytes))|(v1>>(8*(4-amount_bytes))); \\\r\n+\t\t\t\t\t\t\t\t\t\t\t\t\t\t\tv1 = temp_var;}\r\n+  \r\n+\r\n+#define COLUMN(x,y,i,c0,c1,c2,c3,c4,c5,c6,c7,tv1,tv2,tu,tl,t)\t\t\t\t\\\r\n+   tu = T[2*(uint32_t)x[4*c0+0]];\t\t\t    \\\r\n+   tl = T[2*(uint32_t)x[4*c0+0]+1];\t\t    \\\r\n+   tv1 = T[2*(uint32_t)x[4*c1+1]];\t\t\t\\\r\n+   tv2 = T[2*(uint32_t)x[4*c1+1]+1];\t\t\t\\\r\n+   ROTATE_COLUMN_DOWN(tv1,tv2,1,t)\t\\\r\n+   tu ^= tv1;\t\t\t\t\t\t\\\r\n+   tl ^= tv2;\t\t\t\t\t\t\\\r\n+   tv1 = T[2*(uint32_t)x[4*c2+2]];\t\t\t\\\r\n+   tv2 = T[2*(uint32_t)x[4*c2+2]+1];\t\t\t\\\r\n+   ROTATE_COLUMN_DOWN(tv1,tv2,2,t)\t\\\r\n+   tu ^= tv1;\t\t\t\t\t\t\\\r\n+   tl ^= tv2;   \t\t\t\t\t\\\r\n+   tv1 = T[2*(uint32_t)x[4*c3+3]];\t\t\t\\\r\n+   tv2 = T[2*(uint32_t)x[4*c3+3]+1];\t\t\t\\\r\n+   ROTATE_COLUMN_DOWN(tv1,tv2,3,t)\t\\\r\n+   tu ^= tv1;\t\t\t\t\t\t\\\r\n+   tl ^= tv2;\t\t\t\t\t\t\\\r\n+   tl ^= T[2*(uint32_t)x[4*c4+0]];\t\t\t\\\r\n+   tu ^= T[2*(uint32_t)x[4*c4+0]+1];\t\t\t\\\r\n+   tv1 = T[2*(uint32_t)x[4*c5+1]];\t\t\t\\\r\n+   tv2 = T[2*(uint32_t)x[4*c5+1]+1];\t\t\t\\\r\n+   ROTATE_COLUMN_DOWN(tv1,tv2,1,t)\t\\\r\n+   tl ^= tv1;\t\t\t\t\t\t\\\r\n+   tu ^= tv2;\t\t\t\t\t\t\\\r\n+   tv1 = T[2*(uint32_t)x[4*c6+2]];\t\t\t\\\r\n+   tv2 = T[2*(uint32_t)x[4*c6+2]+1];\t\t\t\\\r\n+   ROTATE_COLUMN_DOWN(tv1,tv2,2,t)\t\\\r\n+   tl ^= tv1;\t\t\t\t\t\t\\\r\n+   tu ^= tv2;   \t\t\t\t\t\\\r\n+   tv1 = T[2*(uint32_t)x[4*c7+3]];\t\t\t\\\r\n+   tv2 = T[2*(uint32_t)x[4*c7+3]+1];\t\t\t\\\r\n+   ROTATE_COLUMN_DOWN(tv1,tv2,3,t)\t\\\r\n+   tl ^= tv1;\t\t\t\t\t\t\\\r\n+   tu ^= tv2;\t\t\t\t\t\t\\\r\n+   y[i] = tu;\t\t\t\t\t\t\\\r\n+   y[i+1] = tl;\r\n+\r\n+\r\n+/* compute one round of P (short variants) */\r\n+static void RND512P(uint8_t *x, uint32_t *y, uint32_t r) {\r\n+  uint32_t temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp;\r\n+  uint32_t* x32 = (uint32_t*)x;\r\n+  x32[ 0] ^= 0x00000000^r;\r\n+  x32[ 2] ^= 0x00000010^r;\r\n+  x32[ 4] ^= 0x00000020^r;\r\n+  x32[ 6] ^= 0x00000030^r;\r\n+  x32[ 8] ^= 0x00000040^r;\r\n+  x32[10] ^= 0x00000050^r;\r\n+  x32[12] ^= 0x00000060^r;\r\n+  x32[14] ^= 0x00000070^r;\r\n+  COLUMN(x,y, 0,  0,  2,  4,  6,  9, 11, 13, 15, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+  COLUMN(x,y, 2,  2,  4,  6,  8, 11, 13, 15,  1, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+  COLUMN(x,y, 4,  4,  6,  8, 10, 13, 15,  1,  3, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+  COLUMN(x,y, 6,  6,  8, 10, 12, 15,  1,  3,  5, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+  COLUMN(x,y, 8,  8, 10, 12, 14,  1,  3,  5,  7, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+  COLUMN(x,y,10, 10, 12, 14,  0,  3,  5,  7,  9, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+  COLUMN(x,y,12, 12, 14,  0,  2,  5,  7,  9, 11, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+  COLUMN(x,y,14, 14,  0,  2,  4,  7,  9, 11, 13, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+}\r\n+\r\n+/* compute one round of Q (short variants) */\r\n+static void RND512Q(uint8_t *x, uint32_t *y, uint32_t r) {\r\n+  uint32_t temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp;\r\n+  uint32_t* x32 = (uint32_t*)x;\r\n+  x32[ 0] = ~x32[ 0];\r\n+  x32[ 1] ^= 0xffffffff^r;\r\n+  x32[ 2] = ~x32[ 2];\r\n+  x32[ 3] ^= 0xefffffff^r;\r\n+  x32[ 4] = ~x32[ 4];\r\n+  x32[ 5] ^= 0xdfffffff^r;\r\n+  x32[ 6] = ~x32[ 6];\r\n+  x32[ 7] ^= 0xcfffffff^r;\r\n+  x32[ 8] = ~x32[ 8];\r\n+  x32[ 9] ^= 0xbfffffff^r;\r\n+  x32[10] = ~x32[10];\r\n+  x32[11] ^= 0xafffffff^r;\r\n+  x32[12] = ~x32[12];\r\n+  x32[13] ^= 0x9fffffff^r;\r\n+  x32[14] = ~x32[14];\r\n+  x32[15] ^= 0x8fffffff^r;\r\n+  COLUMN(x,y, 0,  2,  6, 10, 14,  1,  5,  9, 13, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+  COLUMN(x,y, 2,  4,  8, 12,  0,  3,  7, 11, 15, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+  COLUMN(x,y, 4,  6, 10, 14,  2,  5,  9, 13,  1, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+  COLUMN(x,y, 6,  8, 12,  0,  4,  7, 11, 15,  3, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+  COLUMN(x,y, 8, 10, 14,  2,  6,  9, 13,  1,  5, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+  COLUMN(x,y,10, 12,  0,  4,  8, 11, 15,  3,  7, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+  COLUMN(x,y,12, 14,  2,  6, 10, 13,  1,  5,  9, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+  COLUMN(x,y,14,  0,  4,  8, 12, 15,  3,  7, 11, temp_v1, temp_v2, temp_upper_value, temp_lower_value, temp);\r\n+}\r\n+\r\n+/* compute compression function (short variants) */\r\n+static void F512(uint32_t *h, const uint32_t *m) {\r\n+  int i;\r\n+  uint32_t Ptmp[2*COLS512];\r\n+  uint32_t Qtmp[2*COLS512];\r\n+  uint32_t y[2*COLS512];\r\n+  uint32_t z[2*COLS512];\r\n+\r\n+  for (i = 0; i < 2*COLS512; i++) {\r\n+    z[i] = m[i];\r\n+    Ptmp[i] = h[i]^m[i];\r\n+  }\r\n+\r\n+  /* compute Q(m) */\r\n+  RND512Q((uint8_t*)z, y, 0x00000000);\r\n+  RND512Q((uint8_t*)y, z, 0x01000000);\r\n+  RND512Q((uint8_t*)z, y, 0x02000000);\r\n+  RND512Q((uint8_t*)y, z, 0x03000000);\r\n+  RND512Q((uint8_t*)z, y, 0x04000000);\r\n+  RND512Q((uint8_t*)y, z, 0x05000000);\r\n+  RND512Q((uint8_t*)z, y, 0x06000000);\r\n+  RND512Q((uint8_t*)y, z, 0x07000000);\r\n+  RND512Q((uint8_t*)z, y, 0x08000000);\r\n+  RND512Q((uint8_t*)y, Qtmp, 0x09000000);\r\n+\r\n+  /* compute P(h+m) */\r\n+  RND512P((uint8_t*)Ptmp, y, 0x00000000);\r\n+  RND512P((uint8_t*)y, z, 0x00000001);\r\n+  RND512P((uint8_t*)z, y, 0x00000002);\r\n+  RND512P((uint8_t*)y, z, 0x00000003);\r\n+  RND512P((uint8_t*)z, y, 0x00000004);\r\n+  RND512P((uint8_t*)y, z, 0x00000005);\r\n+  RND512P((uint8_t*)z, y, 0x00000006);\r\n+  RND512P((uint8_t*)y, z, 0x00000007);\r\n+  RND512P((uint8_t*)z, y, 0x00000008);\r\n+  RND512P((uint8_t*)y, Ptmp, 0x00000009);\r\n+\r\n+  /* compute P(h+m) + Q(m) + h */\r\n+  for (i = 0; i < 2*COLS512; i++) {\r\n+    h[i] ^= Ptmp[i]^Qtmp[i];\r\n+  }\r\n+}\r\n+\r\n+\r\n+/* digest up to msglen bytes of input (full blocks only) */\r\n+static void Transform(groestlHashState *ctx,\r\n+\t       const uint8_t *input, \r\n+\t       int msglen) {\r\n+\r\n+  /* digest message, one block at a time */\r\n+  for (; msglen >= SIZE512; \r\n+       msglen -= SIZE512, input += SIZE512) {\r\n+    F512(ctx->chaining,(uint32_t*)input);\r\n+\r\n+    /* increment block counter */\r\n+    ctx->block_counter1++;\r\n+    if (ctx->block_counter1 == 0) ctx->block_counter2++;\r\n+  }\r\n+}\r\n+\r\n+/* given state h, do h <- P(h)+h */\r\n+static void OutputTransformation(groestlHashState *ctx) {\r\n+  int j;\r\n+  uint32_t temp[2*COLS512];\r\n+  uint32_t y[2*COLS512];\r\n+  uint32_t z[2*COLS512];\r\n+\r\n+\r\n+\r\n+\tfor (j = 0; j < 2*COLS512; j++) {\r\n+\t  temp[j] = ctx->chaining[j];\r\n+\t}\r\n+\tRND512P((uint8_t*)temp, y, 0x00000000);\r\n+\tRND512P((uint8_t*)y, z, 0x00000001);\r\n+\tRND512P((uint8_t*)z, y, 0x00000002);\r\n+\tRND512P((uint8_t*)y, z, 0x00000003);\r\n+\tRND512P((uint8_t*)z, y, 0x00000004);\r\n+\tRND512P((uint8_t*)y, z, 0x00000005);\r\n+\tRND512P((uint8_t*)z, y, 0x00000006);\r\n+\tRND512P((uint8_t*)y, z, 0x00000007);\r\n+\tRND512P((uint8_t*)z, y, 0x00000008);\r\n+\tRND512P((uint8_t*)y, temp, 0x00000009);\r\n+\tfor (j = 0; j < 2*COLS512; j++) {\r\n+\t  ctx->chaining[j] ^= temp[j];\r\n+\t}\t\t\t\t\t\t\t\t\t  \r\n+}\r\n+\r\n+/* initialise context */\r\n+static void Init(groestlHashState* ctx) {\r\n+  int i = 0;\r\n+  /* allocate memory for state and data buffer */\r\n+\r\n+  for(;i<(SIZE512/sizeof(uint32_t));i++)\r\n+  {\r\n+\tctx->chaining[i] = 0;\r\n+  }\r\n+\r\n+  /* set initial value */\r\n+  ctx->chaining[2*COLS512-1] = u32BIG((uint32_t)HASH_BIT_LEN);\r\n+\r\n+  /* set other variables */\r\n+  ctx->buf_ptr = 0;\r\n+  ctx->block_counter1 = 0;\r\n+  ctx->block_counter2 = 0;\r\n+  ctx->bits_in_last_byte = 0;\r\n+}\r\n+\r\n+/* update state with databitlen bits of input */\r\n+static void Update(groestlHashState* ctx,\r\n+\t\t  const BitSequence* input,\r\n+\t\t  DataLength databitlen) {\r\n+  int index = 0;\r\n+  int msglen = (int)(databitlen/8);\r\n+  int rem = (int)(databitlen%8);\r\n+\r\n+  /* if the buffer contains data that has not yet been digested, first\r\n+     add data to buffer until full */\r\n+  if (ctx->buf_ptr) {\r\n+    while (ctx->buf_ptr < SIZE512 && index < msglen) {\r\n+      ctx->buffer[(int)ctx->buf_ptr++] = input[index++];\r\n+    }\r\n+    if (ctx->buf_ptr < SIZE512) {\r\n+      /* buffer still not full, return */\r\n+      if (rem) {\r\n+\tctx->bits_in_last_byte = rem;\r\n+\tctx->buffer[(int)ctx->buf_ptr++] = input[index];\r\n+      }\r\n+      return;\r\n+    }\r\n+\r\n+    /* digest buffer */\r\n+    ctx->buf_ptr = 0;\r\n+    Transform(ctx, ctx->buffer, SIZE512);\r\n+  }\r\n+\r\n+  /* digest bulk of message */\r\n+  Transform(ctx, input+index, msglen-index);\r\n+  index += ((msglen-index)/SIZE512)*SIZE512;\r\n+\r\n+  /* store remaining data in buffer */\r\n+  while (index < msglen) {\r\n+    ctx->buffer[(int)ctx->buf_ptr++] = input[index++];\r\n+  }\r\n+\r\n+  /* if non-integral number of bytes have been supplied, store\r\n+     remaining bits in last byte, together with information about\r\n+     number of bits */\r\n+  if (rem) {\r\n+    ctx->bits_in_last_byte = rem;\r\n+    ctx->buffer[(int)ctx->buf_ptr++] = input[index];\r\n+  }\r\n+}\r\n+\r\n+#define BILB ctx->bits_in_last_byte\r\n+\r\n+/* finalise: process remaining data (including padding), perform\r\n+   output transformation, and write hash result to 'output' */\r\n+static void Final(groestlHashState* ctx,\r\n+\t\t BitSequence* output) {\r\n+  int i, j = 0, hashbytelen = HASH_BIT_LEN/8;\r\n+  uint8_t *s = (BitSequence*)ctx->chaining;\r\n+\r\n+  /* pad with '1'-bit and first few '0'-bits */\r\n+  if (BILB) {\r\n+    ctx->buffer[(int)ctx->buf_ptr-1] &= ((1<<BILB)-1)<<(8-BILB);\r\n+    ctx->buffer[(int)ctx->buf_ptr-1] ^= 0x1<<(7-BILB);\r\n+    BILB = 0;\r\n+  }\r\n+  else ctx->buffer[(int)ctx->buf_ptr++] = 0x80;\r\n+\r\n+  /* pad with '0'-bits */\r\n+  if (ctx->buf_ptr > SIZE512-LENGTHFIELDLEN) {\r\n+    /* padding requires two blocks */\r\n+    while (ctx->buf_ptr < SIZE512) {\r\n+      ctx->buffer[(int)ctx->buf_ptr++] = 0;\r\n+    }\r\n+    /* digest first padding block */\r\n+    Transform(ctx, ctx->buffer, SIZE512);\r\n+    ctx->buf_ptr = 0;\r\n+  }\r\n+  while (ctx->buf_ptr < SIZE512-LENGTHFIELDLEN) {\r\n+    ctx->buffer[(int)ctx->buf_ptr++] = 0;\r\n+  }\r\n+\r\n+  /* length padding */\r\n+  ctx->block_counter1++;\r\n+  if (ctx->block_counter1 == 0) ctx->block_counter2++;\r\n+  ctx->buf_ptr = SIZE512;\r\n+\r\n+  while (ctx->buf_ptr > SIZE512-(int)sizeof(uint32_t)) {\r\n+    ctx->buffer[(int)--ctx->buf_ptr] = (uint8_t)ctx->block_counter1;\r\n+    ctx->block_counter1 >>= 8;\r\n+  }\r\n+  while (ctx->buf_ptr > SIZE512-LENGTHFIELDLEN) {\r\n+    ctx->buffer[(int)--ctx->buf_ptr] = (uint8_t)ctx->block_counter2;\r\n+    ctx->block_counter2 >>= 8;\r\n+  }\r\n+  /* digest final padding block */\r\n+  Transform(ctx, ctx->buffer, SIZE512); \r\n+  /* perform output transformation */\r\n+  OutputTransformation(ctx);\r\n+\r\n+  /* store hash result in output */\r\n+  for (i = SIZE512-hashbytelen; i < SIZE512; i++,j++) {\r\n+    output[j] = s[i];\r\n+  }\r\n+\r\n+  /* zeroise relevant variables and deallocate memory */\r\n+  for (i = 0; i < COLS512; i++) {\r\n+    ctx->chaining[i] = 0;\r\n+  }\r\n+  for (i = 0; i < SIZE512; i++) {\r\n+    ctx->buffer[i] = 0;\r\n+  }\r\n+}\r\n+\r\n+/* hash bit sequence */\r\n+void groestl(const BitSequence* data, \r\n+\t\tDataLength databitlen,\r\n+\t\tBitSequence* hashval) {\r\n+\r\n+  groestlHashState context;\r\n+\r\n+  /* initialise */\r\n+    Init(&context);\r\n+\r\n+\r\n+  /* process message */\r\n+  Update(&context, data, databitlen);\r\n+\r\n+  /* finalise */\r\n+  Final(&context, hashval);\r\n+}\r\n+/*\r\n+static int crypto_hash(unsigned char *out,\r\n+\t\tconst unsigned char *in,\r\n+\t\tunsigned long long len)\r\n+{\r\n+  groestl(in, 8*len, out);\r\n+  return 0;\r\n+}\r\n+\r\n+*/\r"
      },
      {
        "sha": "26fa048121e7a18c6e16b66d732b691eb1291bb7",
        "filename": "src/crypto/c_groestl.h",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_groestl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_groestl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/c_groestl.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,59 @@\n+#ifndef __hash_h\r\n+#define __hash_h\r\n+/*\r\n+#include \"crypto_uint8.h\"\r\n+#include \"crypto_uint32.h\"\r\n+#include \"crypto_uint64.h\"\r\n+#include \"crypto_hash.h\" \r\n+\r\n+typedef crypto_uint8 uint8_t; \r\n+typedef crypto_uint32 uint32_t; \r\n+typedef crypto_uint64 uint64_t;\r\n+*/\r\n+#include <stdint.h>\r\n+#include <crypto/types.h>\r\n+\r\n+/* some sizes (number of bytes) */\r\n+#define ROWS 8\r\n+#define LENGTHFIELDLEN ROWS\r\n+#define COLS512 8\r\n+\r\n+#define SIZE512 (ROWS*COLS512)\r\n+\r\n+#define ROUNDS512 10\r\n+#define HASH_BIT_LEN 256\r\n+\r\n+#define ROTL32(v, n) ((((v)<<(n))|((v)>>(32-(n))))&li_32(ffffffff))\r\n+\r\n+\r\n+#define li_32(h) 0x##h##u\r\n+#define EXT_BYTE(var,n) ((uint8_t)((uint32_t)(var) >> (8*n)))\r\n+#define u32BIG(a)\t\t\t\t\\\r\n+  ((ROTL32(a,8) & li_32(00FF00FF)) |\t\t\\\r\n+   (ROTL32(a,24) & li_32(FF00FF00)))\r\n+\r\n+\r\n+/* NIST API begin */\r\n+typedef struct {\r\n+  uint32_t chaining[SIZE512/sizeof(uint32_t)];            /* actual state */\r\n+  uint32_t block_counter1,\r\n+  block_counter2;         /* message block counter(s) */\r\n+  BitSequence buffer[SIZE512];      /* data buffer */\r\n+  int buf_ptr;              /* data buffer pointer */\r\n+  int bits_in_last_byte;    /* no. of message bits in last byte of\r\n+\t\t\t       data buffer */\r\n+} groestlHashState;\r\n+\r\n+/*void Init(hashState*);\r\n+void Update(hashState*, const BitSequence*, DataLength);\r\n+void Final(hashState*, BitSequence*); */\r\n+void groestl(const BitSequence*, DataLength, BitSequence*);\r\n+/* NIST API end   */\r\n+\r\n+/*\r\n+int crypto_hash(unsigned char *out,\r\n+\t\tconst unsigned char *in,\r\n+\t\tunsigned long long len);\r\n+*/\r\n+\r\n+#endif /* __hash_h */\r"
      },
      {
        "sha": "923db966375b4bf4983403a8a9e1e284807f233e",
        "filename": "src/crypto/c_jh.c",
        "status": "added",
        "additions": 367,
        "deletions": 0,
        "changes": 367,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_jh.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_jh.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/c_jh.c?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,367 @@\n+/*This program gives the 64-bit optimized bitslice implementation of JH using ANSI C\r\n+\r\n+   --------------------------------\r\n+   Performance\r\n+\r\n+   Microprocessor: Intel CORE 2 processor (Core 2 Duo Mobile T6600 2.2GHz)\r\n+   Operating System: 64-bit Ubuntu 10.04 (Linux kernel 2.6.32-22-generic)\r\n+   Speed for long message:\r\n+   1) 45.8 cycles/byte   compiler: Intel C++ Compiler 11.1   compilation option: icc -O2\r\n+   2) 56.8 cycles/byte   compiler: gcc 4.4.3                 compilation option: gcc -O3\r\n+\r\n+   --------------------------------\r\n+   Last Modified: January 16, 2011\r\n+*/\r\n+\r\n+#include <crypto/c_jh.h>\r\n+\r\n+#include <stdint.h>\r\n+#include <string.h>\r\n+\r\n+/*typedef unsigned long long uint64;*/\r\n+typedef uint64_t uint64;\r\n+\r\n+/*define data alignment for different C compilers*/\r\n+#if defined(__GNUC__)\r\n+      #define DATA_ALIGN16(x) x __attribute__ ((aligned(16)))\r\n+#else\r\n+      #define DATA_ALIGN16(x) __declspec(align(16)) x\r\n+#endif\r\n+\r\n+\r\n+typedef struct {\r\n+\tint hashbitlen;\t   \t              /*the message digest size*/\r\n+\tunsigned long long databitlen;    /*the message size in bits*/\r\n+\tunsigned long long datasize_in_buffer;      /*the size of the message remained in buffer; assumed to be multiple of 8bits except for the last partial block at the end of the message*/\r\n+\tDATA_ALIGN16(uint64 x[8][2]);     /*the 1024-bit state, ( x[i][0] || x[i][1] ) is the ith row of the state in the pseudocode*/\r\n+\tunsigned char buffer[64];         /*the 512-bit message block to be hashed;*/\r\n+} hashState;\r\n+\r\n+\r\n+/*The initial hash value H(0)*/\r\n+const unsigned char JH224_H0[128]={0x2d,0xfe,0xdd,0x62,0xf9,0x9a,0x98,0xac,0xae,0x7c,0xac,0xd6,0x19,0xd6,0x34,0xe7,0xa4,0x83,0x10,0x5,0xbc,0x30,0x12,0x16,0xb8,0x60,0x38,0xc6,0xc9,0x66,0x14,0x94,0x66,0xd9,0x89,0x9f,0x25,0x80,0x70,0x6f,0xce,0x9e,0xa3,0x1b,0x1d,0x9b,0x1a,0xdc,0x11,0xe8,0x32,0x5f,0x7b,0x36,0x6e,0x10,0xf9,0x94,0x85,0x7f,0x2,0xfa,0x6,0xc1,0x1b,0x4f,0x1b,0x5c,0xd8,0xc8,0x40,0xb3,0x97,0xf6,0xa1,0x7f,0x6e,0x73,0x80,0x99,0xdc,0xdf,0x93,0xa5,0xad,0xea,0xa3,0xd3,0xa4,0x31,0xe8,0xde,0xc9,0x53,0x9a,0x68,0x22,0xb4,0xa9,0x8a,0xec,0x86,0xa1,0xe4,0xd5,0x74,0xac,0x95,0x9c,0xe5,0x6c,0xf0,0x15,0x96,0xd,0xea,0xb5,0xab,0x2b,0xbf,0x96,0x11,0xdc,0xf0,0xdd,0x64,0xea,0x6e};\r\n+const unsigned char JH256_H0[128]={0xeb,0x98,0xa3,0x41,0x2c,0x20,0xd3,0xeb,0x92,0xcd,0xbe,0x7b,0x9c,0xb2,0x45,0xc1,0x1c,0x93,0x51,0x91,0x60,0xd4,0xc7,0xfa,0x26,0x0,0x82,0xd6,0x7e,0x50,0x8a,0x3,0xa4,0x23,0x9e,0x26,0x77,0x26,0xb9,0x45,0xe0,0xfb,0x1a,0x48,0xd4,0x1a,0x94,0x77,0xcd,0xb5,0xab,0x26,0x2,0x6b,0x17,0x7a,0x56,0xf0,0x24,0x42,0xf,0xff,0x2f,0xa8,0x71,0xa3,0x96,0x89,0x7f,0x2e,0x4d,0x75,0x1d,0x14,0x49,0x8,0xf7,0x7d,0xe2,0x62,0x27,0x76,0x95,0xf7,0x76,0x24,0x8f,0x94,0x87,0xd5,0xb6,0x57,0x47,0x80,0x29,0x6c,0x5c,0x5e,0x27,0x2d,0xac,0x8e,0xd,0x6c,0x51,0x84,0x50,0xc6,0x57,0x5,0x7a,0xf,0x7b,0xe4,0xd3,0x67,0x70,0x24,0x12,0xea,0x89,0xe3,0xab,0x13,0xd3,0x1c,0xd7,0x69};\r\n+const unsigned char JH384_H0[128]={0x48,0x1e,0x3b,0xc6,0xd8,0x13,0x39,0x8a,0x6d,0x3b,0x5e,0x89,0x4a,0xde,0x87,0x9b,0x63,0xfa,0xea,0x68,0xd4,0x80,0xad,0x2e,0x33,0x2c,0xcb,0x21,0x48,0xf,0x82,0x67,0x98,0xae,0xc8,0x4d,0x90,0x82,0xb9,0x28,0xd4,0x55,0xea,0x30,0x41,0x11,0x42,0x49,0x36,0xf5,0x55,0xb2,0x92,0x48,0x47,0xec,0xc7,0x25,0xa,0x93,0xba,0xf4,0x3c,0xe1,0x56,0x9b,0x7f,0x8a,0x27,0xdb,0x45,0x4c,0x9e,0xfc,0xbd,0x49,0x63,0x97,0xaf,0xe,0x58,0x9f,0xc2,0x7d,0x26,0xaa,0x80,0xcd,0x80,0xc0,0x8b,0x8c,0x9d,0xeb,0x2e,0xda,0x8a,0x79,0x81,0xe8,0xf8,0xd5,0x37,0x3a,0xf4,0x39,0x67,0xad,0xdd,0xd1,0x7a,0x71,0xa9,0xb4,0xd3,0xbd,0xa4,0x75,0xd3,0x94,0x97,0x6c,0x3f,0xba,0x98,0x42,0x73,0x7f};\r\n+const unsigned char JH512_H0[128]={0x6f,0xd1,0x4b,0x96,0x3e,0x0,0xaa,0x17,0x63,0x6a,0x2e,0x5,0x7a,0x15,0xd5,0x43,0x8a,0x22,0x5e,0x8d,0xc,0x97,0xef,0xb,0xe9,0x34,0x12,0x59,0xf2,0xb3,0xc3,0x61,0x89,0x1d,0xa0,0xc1,0x53,0x6f,0x80,0x1e,0x2a,0xa9,0x5,0x6b,0xea,0x2b,0x6d,0x80,0x58,0x8e,0xcc,0xdb,0x20,0x75,0xba,0xa6,0xa9,0xf,0x3a,0x76,0xba,0xf8,0x3b,0xf7,0x1,0x69,0xe6,0x5,0x41,0xe3,0x4a,0x69,0x46,0xb5,0x8a,0x8e,0x2e,0x6f,0xe6,0x5a,0x10,0x47,0xa7,0xd0,0xc1,0x84,0x3c,0x24,0x3b,0x6e,0x71,0xb1,0x2d,0x5a,0xc1,0x99,0xcf,0x57,0xf6,0xec,0x9d,0xb1,0xf8,0x56,0xa7,0x6,0x88,0x7c,0x57,0x16,0xb1,0x56,0xe3,0xc2,0xfc,0xdf,0xe6,0x85,0x17,0xfb,0x54,0x5a,0x46,0x78,0xcc,0x8c,0xdd,0x4b};\r\n+\r\n+/*42 round constants, each round constant is 32-byte (256-bit)*/\r\n+const unsigned char E8_bitslice_roundconstant[42][32]={\r\n+{0x72,0xd5,0xde,0xa2,0xdf,0x15,0xf8,0x67,0x7b,0x84,0x15,0xa,0xb7,0x23,0x15,0x57,0x81,0xab,0xd6,0x90,0x4d,0x5a,0x87,0xf6,0x4e,0x9f,0x4f,0xc5,0xc3,0xd1,0x2b,0x40},\r\n+{0xea,0x98,0x3a,0xe0,0x5c,0x45,0xfa,0x9c,0x3,0xc5,0xd2,0x99,0x66,0xb2,0x99,0x9a,0x66,0x2,0x96,0xb4,0xf2,0xbb,0x53,0x8a,0xb5,0x56,0x14,0x1a,0x88,0xdb,0xa2,0x31},\r\n+{0x3,0xa3,0x5a,0x5c,0x9a,0x19,0xe,0xdb,0x40,0x3f,0xb2,0xa,0x87,0xc1,0x44,0x10,0x1c,0x5,0x19,0x80,0x84,0x9e,0x95,0x1d,0x6f,0x33,0xeb,0xad,0x5e,0xe7,0xcd,0xdc},\r\n+{0x10,0xba,0x13,0x92,0x2,0xbf,0x6b,0x41,0xdc,0x78,0x65,0x15,0xf7,0xbb,0x27,0xd0,0xa,0x2c,0x81,0x39,0x37,0xaa,0x78,0x50,0x3f,0x1a,0xbf,0xd2,0x41,0x0,0x91,0xd3},\r\n+{0x42,0x2d,0x5a,0xd,0xf6,0xcc,0x7e,0x90,0xdd,0x62,0x9f,0x9c,0x92,0xc0,0x97,0xce,0x18,0x5c,0xa7,0xb,0xc7,0x2b,0x44,0xac,0xd1,0xdf,0x65,0xd6,0x63,0xc6,0xfc,0x23},\r\n+{0x97,0x6e,0x6c,0x3,0x9e,0xe0,0xb8,0x1a,0x21,0x5,0x45,0x7e,0x44,0x6c,0xec,0xa8,0xee,0xf1,0x3,0xbb,0x5d,0x8e,0x61,0xfa,0xfd,0x96,0x97,0xb2,0x94,0x83,0x81,0x97},\r\n+{0x4a,0x8e,0x85,0x37,0xdb,0x3,0x30,0x2f,0x2a,0x67,0x8d,0x2d,0xfb,0x9f,0x6a,0x95,0x8a,0xfe,0x73,0x81,0xf8,0xb8,0x69,0x6c,0x8a,0xc7,0x72,0x46,0xc0,0x7f,0x42,0x14},\r\n+{0xc5,0xf4,0x15,0x8f,0xbd,0xc7,0x5e,0xc4,0x75,0x44,0x6f,0xa7,0x8f,0x11,0xbb,0x80,0x52,0xde,0x75,0xb7,0xae,0xe4,0x88,0xbc,0x82,0xb8,0x0,0x1e,0x98,0xa6,0xa3,0xf4},\r\n+{0x8e,0xf4,0x8f,0x33,0xa9,0xa3,0x63,0x15,0xaa,0x5f,0x56,0x24,0xd5,0xb7,0xf9,0x89,0xb6,0xf1,0xed,0x20,0x7c,0x5a,0xe0,0xfd,0x36,0xca,0xe9,0x5a,0x6,0x42,0x2c,0x36},\r\n+{0xce,0x29,0x35,0x43,0x4e,0xfe,0x98,0x3d,0x53,0x3a,0xf9,0x74,0x73,0x9a,0x4b,0xa7,0xd0,0xf5,0x1f,0x59,0x6f,0x4e,0x81,0x86,0xe,0x9d,0xad,0x81,0xaf,0xd8,0x5a,0x9f},\r\n+{0xa7,0x5,0x6,0x67,0xee,0x34,0x62,0x6a,0x8b,0xb,0x28,0xbe,0x6e,0xb9,0x17,0x27,0x47,0x74,0x7,0x26,0xc6,0x80,0x10,0x3f,0xe0,0xa0,0x7e,0x6f,0xc6,0x7e,0x48,0x7b},\r\n+{0xd,0x55,0xa,0xa5,0x4a,0xf8,0xa4,0xc0,0x91,0xe3,0xe7,0x9f,0x97,0x8e,0xf1,0x9e,0x86,0x76,0x72,0x81,0x50,0x60,0x8d,0xd4,0x7e,0x9e,0x5a,0x41,0xf3,0xe5,0xb0,0x62},\r\n+{0xfc,0x9f,0x1f,0xec,0x40,0x54,0x20,0x7a,0xe3,0xe4,0x1a,0x0,0xce,0xf4,0xc9,0x84,0x4f,0xd7,0x94,0xf5,0x9d,0xfa,0x95,0xd8,0x55,0x2e,0x7e,0x11,0x24,0xc3,0x54,0xa5},\r\n+{0x5b,0xdf,0x72,0x28,0xbd,0xfe,0x6e,0x28,0x78,0xf5,0x7f,0xe2,0xf,0xa5,0xc4,0xb2,0x5,0x89,0x7c,0xef,0xee,0x49,0xd3,0x2e,0x44,0x7e,0x93,0x85,0xeb,0x28,0x59,0x7f},\r\n+{0x70,0x5f,0x69,0x37,0xb3,0x24,0x31,0x4a,0x5e,0x86,0x28,0xf1,0x1d,0xd6,0xe4,0x65,0xc7,0x1b,0x77,0x4,0x51,0xb9,0x20,0xe7,0x74,0xfe,0x43,0xe8,0x23,0xd4,0x87,0x8a},\r\n+{0x7d,0x29,0xe8,0xa3,0x92,0x76,0x94,0xf2,0xdd,0xcb,0x7a,0x9,0x9b,0x30,0xd9,0xc1,0x1d,0x1b,0x30,0xfb,0x5b,0xdc,0x1b,0xe0,0xda,0x24,0x49,0x4f,0xf2,0x9c,0x82,0xbf},\r\n+{0xa4,0xe7,0xba,0x31,0xb4,0x70,0xbf,0xff,0xd,0x32,0x44,0x5,0xde,0xf8,0xbc,0x48,0x3b,0xae,0xfc,0x32,0x53,0xbb,0xd3,0x39,0x45,0x9f,0xc3,0xc1,0xe0,0x29,0x8b,0xa0},\r\n+{0xe5,0xc9,0x5,0xfd,0xf7,0xae,0x9,0xf,0x94,0x70,0x34,0x12,0x42,0x90,0xf1,0x34,0xa2,0x71,0xb7,0x1,0xe3,0x44,0xed,0x95,0xe9,0x3b,0x8e,0x36,0x4f,0x2f,0x98,0x4a},\r\n+{0x88,0x40,0x1d,0x63,0xa0,0x6c,0xf6,0x15,0x47,0xc1,0x44,0x4b,0x87,0x52,0xaf,0xff,0x7e,0xbb,0x4a,0xf1,0xe2,0xa,0xc6,0x30,0x46,0x70,0xb6,0xc5,0xcc,0x6e,0x8c,0xe6},\r\n+{0xa4,0xd5,0xa4,0x56,0xbd,0x4f,0xca,0x0,0xda,0x9d,0x84,0x4b,0xc8,0x3e,0x18,0xae,0x73,0x57,0xce,0x45,0x30,0x64,0xd1,0xad,0xe8,0xa6,0xce,0x68,0x14,0x5c,0x25,0x67},\r\n+{0xa3,0xda,0x8c,0xf2,0xcb,0xe,0xe1,0x16,0x33,0xe9,0x6,0x58,0x9a,0x94,0x99,0x9a,0x1f,0x60,0xb2,0x20,0xc2,0x6f,0x84,0x7b,0xd1,0xce,0xac,0x7f,0xa0,0xd1,0x85,0x18},\r\n+{0x32,0x59,0x5b,0xa1,0x8d,0xdd,0x19,0xd3,0x50,0x9a,0x1c,0xc0,0xaa,0xa5,0xb4,0x46,0x9f,0x3d,0x63,0x67,0xe4,0x4,0x6b,0xba,0xf6,0xca,0x19,0xab,0xb,0x56,0xee,0x7e},\r\n+{0x1f,0xb1,0x79,0xea,0xa9,0x28,0x21,0x74,0xe9,0xbd,0xf7,0x35,0x3b,0x36,0x51,0xee,0x1d,0x57,0xac,0x5a,0x75,0x50,0xd3,0x76,0x3a,0x46,0xc2,0xfe,0xa3,0x7d,0x70,0x1},\r\n+{0xf7,0x35,0xc1,0xaf,0x98,0xa4,0xd8,0x42,0x78,0xed,0xec,0x20,0x9e,0x6b,0x67,0x79,0x41,0x83,0x63,0x15,0xea,0x3a,0xdb,0xa8,0xfa,0xc3,0x3b,0x4d,0x32,0x83,0x2c,0x83},\r\n+{0xa7,0x40,0x3b,0x1f,0x1c,0x27,0x47,0xf3,0x59,0x40,0xf0,0x34,0xb7,0x2d,0x76,0x9a,0xe7,0x3e,0x4e,0x6c,0xd2,0x21,0x4f,0xfd,0xb8,0xfd,0x8d,0x39,0xdc,0x57,0x59,0xef},\r\n+{0x8d,0x9b,0xc,0x49,0x2b,0x49,0xeb,0xda,0x5b,0xa2,0xd7,0x49,0x68,0xf3,0x70,0xd,0x7d,0x3b,0xae,0xd0,0x7a,0x8d,0x55,0x84,0xf5,0xa5,0xe9,0xf0,0xe4,0xf8,0x8e,0x65},\r\n+{0xa0,0xb8,0xa2,0xf4,0x36,0x10,0x3b,0x53,0xc,0xa8,0x7,0x9e,0x75,0x3e,0xec,0x5a,0x91,0x68,0x94,0x92,0x56,0xe8,0x88,0x4f,0x5b,0xb0,0x5c,0x55,0xf8,0xba,0xbc,0x4c},\r\n+{0xe3,0xbb,0x3b,0x99,0xf3,0x87,0x94,0x7b,0x75,0xda,0xf4,0xd6,0x72,0x6b,0x1c,0x5d,0x64,0xae,0xac,0x28,0xdc,0x34,0xb3,0x6d,0x6c,0x34,0xa5,0x50,0xb8,0x28,0xdb,0x71},\r\n+{0xf8,0x61,0xe2,0xf2,0x10,0x8d,0x51,0x2a,0xe3,0xdb,0x64,0x33,0x59,0xdd,0x75,0xfc,0x1c,0xac,0xbc,0xf1,0x43,0xce,0x3f,0xa2,0x67,0xbb,0xd1,0x3c,0x2,0xe8,0x43,0xb0},\r\n+{0x33,0xa,0x5b,0xca,0x88,0x29,0xa1,0x75,0x7f,0x34,0x19,0x4d,0xb4,0x16,0x53,0x5c,0x92,0x3b,0x94,0xc3,0xe,0x79,0x4d,0x1e,0x79,0x74,0x75,0xd7,0xb6,0xee,0xaf,0x3f},\r\n+{0xea,0xa8,0xd4,0xf7,0xbe,0x1a,0x39,0x21,0x5c,0xf4,0x7e,0x9,0x4c,0x23,0x27,0x51,0x26,0xa3,0x24,0x53,0xba,0x32,0x3c,0xd2,0x44,0xa3,0x17,0x4a,0x6d,0xa6,0xd5,0xad},\r\n+{0xb5,0x1d,0x3e,0xa6,0xaf,0xf2,0xc9,0x8,0x83,0x59,0x3d,0x98,0x91,0x6b,0x3c,0x56,0x4c,0xf8,0x7c,0xa1,0x72,0x86,0x60,0x4d,0x46,0xe2,0x3e,0xcc,0x8,0x6e,0xc7,0xf6},\r\n+{0x2f,0x98,0x33,0xb3,0xb1,0xbc,0x76,0x5e,0x2b,0xd6,0x66,0xa5,0xef,0xc4,0xe6,0x2a,0x6,0xf4,0xb6,0xe8,0xbe,0xc1,0xd4,0x36,0x74,0xee,0x82,0x15,0xbc,0xef,0x21,0x63},\r\n+{0xfd,0xc1,0x4e,0xd,0xf4,0x53,0xc9,0x69,0xa7,0x7d,0x5a,0xc4,0x6,0x58,0x58,0x26,0x7e,0xc1,0x14,0x16,0x6,0xe0,0xfa,0x16,0x7e,0x90,0xaf,0x3d,0x28,0x63,0x9d,0x3f},\r\n+{0xd2,0xc9,0xf2,0xe3,0x0,0x9b,0xd2,0xc,0x5f,0xaa,0xce,0x30,0xb7,0xd4,0xc,0x30,0x74,0x2a,0x51,0x16,0xf2,0xe0,0x32,0x98,0xd,0xeb,0x30,0xd8,0xe3,0xce,0xf8,0x9a},\r\n+{0x4b,0xc5,0x9e,0x7b,0xb5,0xf1,0x79,0x92,0xff,0x51,0xe6,0x6e,0x4,0x86,0x68,0xd3,0x9b,0x23,0x4d,0x57,0xe6,0x96,0x67,0x31,0xcc,0xe6,0xa6,0xf3,0x17,0xa,0x75,0x5},\r\n+{0xb1,0x76,0x81,0xd9,0x13,0x32,0x6c,0xce,0x3c,0x17,0x52,0x84,0xf8,0x5,0xa2,0x62,0xf4,0x2b,0xcb,0xb3,0x78,0x47,0x15,0x47,0xff,0x46,0x54,0x82,0x23,0x93,0x6a,0x48},\r\n+{0x38,0xdf,0x58,0x7,0x4e,0x5e,0x65,0x65,0xf2,0xfc,0x7c,0x89,0xfc,0x86,0x50,0x8e,0x31,0x70,0x2e,0x44,0xd0,0xb,0xca,0x86,0xf0,0x40,0x9,0xa2,0x30,0x78,0x47,0x4e},\r\n+{0x65,0xa0,0xee,0x39,0xd1,0xf7,0x38,0x83,0xf7,0x5e,0xe9,0x37,0xe4,0x2c,0x3a,0xbd,0x21,0x97,0xb2,0x26,0x1,0x13,0xf8,0x6f,0xa3,0x44,0xed,0xd1,0xef,0x9f,0xde,0xe7},\r\n+{0x8b,0xa0,0xdf,0x15,0x76,0x25,0x92,0xd9,0x3c,0x85,0xf7,0xf6,0x12,0xdc,0x42,0xbe,0xd8,0xa7,0xec,0x7c,0xab,0x27,0xb0,0x7e,0x53,0x8d,0x7d,0xda,0xaa,0x3e,0xa8,0xde},\r\n+{0xaa,0x25,0xce,0x93,0xbd,0x2,0x69,0xd8,0x5a,0xf6,0x43,0xfd,0x1a,0x73,0x8,0xf9,0xc0,0x5f,0xef,0xda,0x17,0x4a,0x19,0xa5,0x97,0x4d,0x66,0x33,0x4c,0xfd,0x21,0x6a},\r\n+{0x35,0xb4,0x98,0x31,0xdb,0x41,0x15,0x70,0xea,0x1e,0xf,0xbb,0xed,0xcd,0x54,0x9b,0x9a,0xd0,0x63,0xa1,0x51,0x97,0x40,0x72,0xf6,0x75,0x9d,0xbf,0x91,0x47,0x6f,0xe2}};\r\n+\r\n+\r\n+static void E8(hashState *state);  /*The bijective function E8, in bitslice form*/\r\n+static void F8(hashState *state);  /*The compression function F8 */\r\n+\r\n+/*The API functions*/\r\n+static HashReturn Init(hashState *state, int hashbitlen);\r\n+static HashReturn Update(hashState *state, const BitSequence *data, DataLength databitlen);\r\n+static HashReturn Final(hashState *state, BitSequence *hashval);\r\n+HashReturn jh_hash(int hashbitlen, const BitSequence *data,DataLength databitlen, BitSequence *hashval);\r\n+\r\n+/*swapping bit 2i with bit 2i+1 of 64-bit x*/\r\n+#define SWAP1(x)   (x) = ((((x) & 0x5555555555555555ULL) << 1) | (((x) & 0xaaaaaaaaaaaaaaaaULL) >> 1));\r\n+/*swapping bits 4i||4i+1 with bits 4i+2||4i+3 of 64-bit x*/\r\n+#define SWAP2(x)   (x) = ((((x) & 0x3333333333333333ULL) << 2) | (((x) & 0xccccccccccccccccULL) >> 2));\r\n+/*swapping bits 8i||8i+1||8i+2||8i+3 with bits 8i+4||8i+5||8i+6||8i+7 of 64-bit x*/\r\n+#define SWAP4(x)   (x) = ((((x) & 0x0f0f0f0f0f0f0f0fULL) << 4) | (((x) & 0xf0f0f0f0f0f0f0f0ULL) >> 4));\r\n+/*swapping bits 16i||16i+1||......||16i+7  with bits 16i+8||16i+9||......||16i+15 of 64-bit x*/\r\n+#define SWAP8(x)   (x) = ((((x) & 0x00ff00ff00ff00ffULL) << 8) | (((x) & 0xff00ff00ff00ff00ULL) >> 8));\r\n+/*swapping bits 32i||32i+1||......||32i+15 with bits 32i+16||32i+17||......||32i+31 of 64-bit x*/\r\n+#define SWAP16(x)  (x) = ((((x) & 0x0000ffff0000ffffULL) << 16) | (((x) & 0xffff0000ffff0000ULL) >> 16));\r\n+/*swapping bits 64i||64i+1||......||64i+31 with bits 64i+32||64i+33||......||64i+63 of 64-bit x*/\r\n+#define SWAP32(x)  (x) = (((x) << 32) | ((x) >> 32));\r\n+\r\n+/*The MDS transform*/\r\n+#define L(m0,m1,m2,m3,m4,m5,m6,m7) \\\r\n+      (m4) ^= (m1);                \\\r\n+      (m5) ^= (m2);                \\\r\n+      (m6) ^= (m0) ^ (m3);         \\\r\n+      (m7) ^= (m0);                \\\r\n+      (m0) ^= (m5);                \\\r\n+      (m1) ^= (m6);                \\\r\n+      (m2) ^= (m4) ^ (m7);         \\\r\n+      (m3) ^= (m4);\r\n+\r\n+/*Two Sboxes are computed in parallel, each Sbox implements S0 and S1, selected by a constant bit*/\r\n+/*The reason to compute two Sboxes in parallel is to try to fully utilize the parallel processing power*/\r\n+#define SS(m0,m1,m2,m3,m4,m5,m6,m7,cc0,cc1)   \\\r\n+      m3  = ~(m3);                  \\\r\n+      m7  = ~(m7);                  \\\r\n+      m0 ^= ((~(m2)) & (cc0));      \\\r\n+      m4 ^= ((~(m6)) & (cc1));      \\\r\n+      temp0 = (cc0) ^ ((m0) & (m1));\\\r\n+      temp1 = (cc1) ^ ((m4) & (m5));\\\r\n+      m0 ^= ((m2) & (m3));          \\\r\n+      m4 ^= ((m6) & (m7));          \\\r\n+      m3 ^= ((~(m1)) & (m2));       \\\r\n+      m7 ^= ((~(m5)) & (m6));       \\\r\n+      m1 ^= ((m0) & (m2));          \\\r\n+      m5 ^= ((m4) & (m6));          \\\r\n+      m2 ^= ((m0) & (~(m3)));       \\\r\n+      m6 ^= ((m4) & (~(m7)));       \\\r\n+      m0 ^= ((m1) | (m3));          \\\r\n+      m4 ^= ((m5) | (m7));          \\\r\n+      m3 ^= ((m1) & (m2));          \\\r\n+      m7 ^= ((m5) & (m6));          \\\r\n+      m1 ^= (temp0 & (m0));         \\\r\n+      m5 ^= (temp1 & (m4));         \\\r\n+      m2 ^= temp0;                  \\\r\n+      m6 ^= temp1;\r\n+\r\n+/*The bijective function E8, in bitslice form*/\r\n+static void E8(hashState *state)\r\n+{\r\n+      uint64 i,roundnumber,temp0,temp1;\r\n+\r\n+      for (roundnumber = 0; roundnumber < 42; roundnumber = roundnumber+7) {\r\n+            /*round 7*roundnumber+0: Sbox, MDS and Swapping layers*/\r\n+            for (i = 0; i < 2; i++) {\r\n+                  SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64*)E8_bitslice_roundconstant[roundnumber+0])[i],((uint64*)E8_bitslice_roundconstant[roundnumber+0])[i+2] );\r\n+                  L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);\r\n+                  SWAP1(state->x[1][i]); SWAP1(state->x[3][i]); SWAP1(state->x[5][i]); SWAP1(state->x[7][i]);\r\n+            }\r\n+\r\n+            /*round 7*roundnumber+1: Sbox, MDS and Swapping layers*/\r\n+            for (i = 0; i < 2; i++) {\r\n+                  SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64*)E8_bitslice_roundconstant[roundnumber+1])[i],((uint64*)E8_bitslice_roundconstant[roundnumber+1])[i+2] );\r\n+                  L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);\r\n+                  SWAP2(state->x[1][i]); SWAP2(state->x[3][i]); SWAP2(state->x[5][i]); SWAP2(state->x[7][i]);\r\n+            }\r\n+\r\n+            /*round 7*roundnumber+2: Sbox, MDS and Swapping layers*/\r\n+            for (i = 0; i < 2; i++) {\r\n+                  SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64*)E8_bitslice_roundconstant[roundnumber+2])[i],((uint64*)E8_bitslice_roundconstant[roundnumber+2])[i+2] );\r\n+                  L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);\r\n+                  SWAP4(state->x[1][i]); SWAP4(state->x[3][i]); SWAP4(state->x[5][i]); SWAP4(state->x[7][i]);\r\n+            }\r\n+\r\n+            /*round 7*roundnumber+3: Sbox, MDS and Swapping layers*/\r\n+            for (i = 0; i < 2; i++) {\r\n+                  SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64*)E8_bitslice_roundconstant[roundnumber+3])[i],((uint64*)E8_bitslice_roundconstant[roundnumber+3])[i+2] );\r\n+                  L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);\r\n+                  SWAP8(state->x[1][i]); SWAP8(state->x[3][i]); SWAP8(state->x[5][i]); SWAP8(state->x[7][i]);\r\n+            }\r\n+\r\n+            /*round 7*roundnumber+4: Sbox, MDS and Swapping layers*/\r\n+            for (i = 0; i < 2; i++) {\r\n+                  SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64*)E8_bitslice_roundconstant[roundnumber+4])[i],((uint64*)E8_bitslice_roundconstant[roundnumber+4])[i+2] );\r\n+                  L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);\r\n+                  SWAP16(state->x[1][i]); SWAP16(state->x[3][i]); SWAP16(state->x[5][i]); SWAP16(state->x[7][i]);\r\n+            }\r\n+\r\n+            /*round 7*roundnumber+5: Sbox, MDS and Swapping layers*/\r\n+            for (i = 0; i < 2; i++) {\r\n+                  SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64*)E8_bitslice_roundconstant[roundnumber+5])[i],((uint64*)E8_bitslice_roundconstant[roundnumber+5])[i+2] );\r\n+                  L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);\r\n+                  SWAP32(state->x[1][i]); SWAP32(state->x[3][i]); SWAP32(state->x[5][i]); SWAP32(state->x[7][i]);\r\n+            }\r\n+\r\n+            /*round 7*roundnumber+6: Sbox and MDS layers*/\r\n+            for (i = 0; i < 2; i++) {\r\n+                  SS(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i],((uint64*)E8_bitslice_roundconstant[roundnumber+6])[i],((uint64*)E8_bitslice_roundconstant[roundnumber+6])[i+2] );\r\n+                  L(state->x[0][i],state->x[2][i],state->x[4][i],state->x[6][i],state->x[1][i],state->x[3][i],state->x[5][i],state->x[7][i]);\r\n+            }\r\n+            /*round 7*roundnumber+6: swapping layer*/\r\n+            for (i = 1; i < 8; i = i+2) {\r\n+                  temp0 = state->x[i][0]; state->x[i][0] = state->x[i][1]; state->x[i][1] = temp0;\r\n+            }\r\n+      }\r\n+\r\n+}\r\n+\r\n+/*The compression function F8 */\r\n+static void F8(hashState *state)\r\n+{\r\n+      uint64  i;\r\n+\r\n+      /*xor the 512-bit message with the fist half of the 1024-bit hash state*/\r\n+      for (i = 0; i < 8; i++)  state->x[i >> 1][i & 1] ^= ((uint64*)state->buffer)[i];\r\n+\r\n+      /*the bijective function E8 */\r\n+      E8(state);\r\n+\r\n+      /*xor the 512-bit message with the second half of the 1024-bit hash state*/\r\n+      for (i = 0; i < 8; i++)  state->x[(8+i) >> 1][(8+i) & 1] ^= ((uint64*)state->buffer)[i];\r\n+}\r\n+\r\n+/*before hashing a message, initialize the hash state as H0 */\r\n+static HashReturn Init(hashState *state, int hashbitlen)\r\n+{\r\n+\t  state->databitlen = 0;\r\n+\t  state->datasize_in_buffer = 0;\r\n+\r\n+      /*initialize the initial hash value of JH*/\r\n+      state->hashbitlen = hashbitlen;\r\n+\r\n+      /*load the intital hash value into state*/\r\n+      switch (hashbitlen)\r\n+      {\r\n+            case 224: memcpy(state->x,JH224_H0,128); break;\r\n+            case 256: memcpy(state->x,JH256_H0,128); break;\r\n+            case 384: memcpy(state->x,JH384_H0,128); break;\r\n+            case 512: memcpy(state->x,JH512_H0,128); break;\r\n+      }\r\n+\r\n+      return(SUCCESS);\r\n+}\r\n+\r\n+\r\n+/*hash each 512-bit message block, except the last partial block*/\r\n+static HashReturn Update(hashState *state, const BitSequence *data, DataLength databitlen)\r\n+{\r\n+      DataLength index; /*the starting address of the data to be compressed*/\r\n+\r\n+      state->databitlen += databitlen;\r\n+      index = 0;\r\n+\r\n+      /*if there is remaining data in the buffer, fill it to a full message block first*/\r\n+      /*we assume that the size of the data in the buffer is the multiple of 8 bits if it is not at the end of a message*/\r\n+\r\n+      /*There is data in the buffer, but the incoming data is insufficient for a full block*/\r\n+      if ( (state->datasize_in_buffer > 0 ) && (( state->datasize_in_buffer + databitlen) < 512)  ) {\r\n+            if ( (databitlen & 7) == 0 ) {\r\n+                 memcpy(state->buffer + (state->datasize_in_buffer >> 3), data, 64-(state->datasize_in_buffer >> 3)) ;\r\n+\t\t    }\r\n+            else memcpy(state->buffer + (state->datasize_in_buffer >> 3), data, 64-(state->datasize_in_buffer >> 3)+1) ;\r\n+            state->datasize_in_buffer += databitlen;\r\n+            databitlen = 0;\r\n+      }\r\n+\r\n+      /*There is data in the buffer, and the incoming data is sufficient for a full block*/\r\n+      if ( (state->datasize_in_buffer > 0 ) && (( state->datasize_in_buffer + databitlen) >= 512)  ) {\r\n+\t        memcpy( state->buffer + (state->datasize_in_buffer >> 3), data, 64-(state->datasize_in_buffer >> 3) ) ;\r\n+\t        index = 64-(state->datasize_in_buffer >> 3);\r\n+\t        databitlen = databitlen - (512 - state->datasize_in_buffer);\r\n+\t        F8(state);\r\n+\t        state->datasize_in_buffer = 0;\r\n+      }\r\n+\r\n+      /*hash the remaining full message blocks*/\r\n+      for ( ; databitlen >= 512; index = index+64, databitlen = databitlen - 512) {\r\n+            memcpy(state->buffer, data+index, 64);\r\n+            F8(state);\r\n+      }\r\n+\r\n+      /*store the partial block into buffer, assume that -- if part of the last byte is not part of the message, then that part consists of 0 bits*/\r\n+      if ( databitlen > 0) {\r\n+            if ((databitlen & 7) == 0)\r\n+                  memcpy(state->buffer, data+index, (databitlen & 0x1ff) >> 3);\r\n+            else\r\n+                  memcpy(state->buffer, data+index, ((databitlen & 0x1ff) >> 3)+1);\r\n+            state->datasize_in_buffer = databitlen;\r\n+      }\r\n+\r\n+      return(SUCCESS);\r\n+}\r\n+\r\n+/*pad the message, process the padded block(s), truncate the hash value H to obtain the message digest*/\r\n+static HashReturn Final(hashState *state, BitSequence *hashval)\r\n+{\r\n+      unsigned int i;\r\n+\r\n+      if ( (state->databitlen & 0x1ff) == 0 ) {\r\n+            /*pad the message when databitlen is multiple of 512 bits, then process the padded block*/\r\n+            memset(state->buffer, 0, 64);\r\n+            state->buffer[0]  = 0x80;\r\n+            state->buffer[63] = state->databitlen & 0xff;\r\n+            state->buffer[62] = (state->databitlen >> 8)  & 0xff;\r\n+            state->buffer[61] = (state->databitlen >> 16) & 0xff;\r\n+            state->buffer[60] = (state->databitlen >> 24) & 0xff;\r\n+            state->buffer[59] = (state->databitlen >> 32) & 0xff;\r\n+            state->buffer[58] = (state->databitlen >> 40) & 0xff;\r\n+            state->buffer[57] = (state->databitlen >> 48) & 0xff;\r\n+            state->buffer[56] = (state->databitlen >> 56) & 0xff;\r\n+            F8(state);\r\n+      }\r\n+      else {\r\n+\t\t    /*set the rest of the bytes in the buffer to 0*/\r\n+            if ( (state->datasize_in_buffer & 7) == 0)\r\n+                  for (i = (state->databitlen & 0x1ff) >> 3; i < 64; i++)  state->buffer[i] = 0;\r\n+            else\r\n+                  for (i = ((state->databitlen & 0x1ff) >> 3)+1; i < 64; i++)  state->buffer[i] = 0;\r\n+\r\n+            /*pad and process the partial block when databitlen is not multiple of 512 bits, then hash the padded blocks*/\r\n+            state->buffer[((state->databitlen & 0x1ff) >> 3)] |= 1 << (7- (state->databitlen & 7));\r\n+\r\n+            F8(state);\r\n+            memset(state->buffer, 0, 64);\r\n+            state->buffer[63] = state->databitlen & 0xff;\r\n+            state->buffer[62] = (state->databitlen >> 8) & 0xff;\r\n+            state->buffer[61] = (state->databitlen >> 16) & 0xff;\r\n+            state->buffer[60] = (state->databitlen >> 24) & 0xff;\r\n+            state->buffer[59] = (state->databitlen >> 32) & 0xff;\r\n+            state->buffer[58] = (state->databitlen >> 40) & 0xff;\r\n+            state->buffer[57] = (state->databitlen >> 48) & 0xff;\r\n+            state->buffer[56] = (state->databitlen >> 56) & 0xff;\r\n+            F8(state);\r\n+      }\r\n+\r\n+      /*truncating the final hash value to generate the message digest*/\r\n+      switch(state->hashbitlen) {\r\n+            case 224: memcpy(hashval,(unsigned char*)state->x+64+36,28);  break;\r\n+            case 256: memcpy(hashval,(unsigned char*)state->x+64+32,32);  break;\r\n+            case 384: memcpy(hashval,(unsigned char*)state->x+64+16,48);  break;\r\n+            case 512: memcpy(hashval,(unsigned char*)state->x+64,64);     break;\r\n+      }\r\n+\r\n+      return(SUCCESS);\r\n+}\r\n+\r\n+/* hash a message,\r\n+   three inputs: message digest size in bits (hashbitlen); message (data); message length in bits (databitlen)\r\n+   one output:   message digest (hashval)\r\n+*/\r\n+HashReturn jh_hash(int hashbitlen, const BitSequence *data,DataLength databitlen, BitSequence *hashval)\r\n+{\r\n+      hashState state;\r\n+\r\n+      if ( hashbitlen == 224 || hashbitlen == 256 || hashbitlen == 384 || hashbitlen == 512 ) {\r\n+            Init(&state, hashbitlen);\r\n+            Update(&state, data, databitlen);\r\n+            Final(&state, hashval);\r\n+            return SUCCESS;\r\n+      }\r\n+      else\r\n+            return(BAD_HASHLEN);\r\n+}\r"
      },
      {
        "sha": "600f32228f10a23b250f24033d7b412870a37351",
        "filename": "src/crypto/c_jh.h",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_jh.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_jh.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/c_jh.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,23 @@\n+/*This program gives the 64-bit optimized bitslice implementation of JH using ANSI C\r\n+\r\n+   --------------------------------\r\n+   Performance\r\n+\r\n+   Microprocessor: Intel CORE 2 processor (Core 2 Duo Mobile T6600 2.2GHz)\r\n+   Operating System: 64-bit Ubuntu 10.04 (Linux kernel 2.6.32-22-generic)\r\n+   Speed for long message:\r\n+   1) 45.8 cycles/byte   compiler: Intel C++ Compiler 11.1   compilation option: icc -O2\r\n+   2) 56.8 cycles/byte   compiler: gcc 4.4.3                 compilation option: gcc -O3\r\n+\r\n+   --------------------------------\r\n+   Last Modified: January 16, 2011\r\n+*/\r\n+#ifndef TYPES_H_\r\n+#define TYPES_H_\r\n+\r\n+#include <crypto/types.h>\r\n+\r\n+HashReturn jh_hash(int hashbitlen, const BitSequence *data, DataLength databitlen, BitSequence *hashval);\r\n+\r\n+#endif\r\n+\r"
      },
      {
        "sha": "0ba2cd964da6b4fcf2cede181ef4bcc554a24092",
        "filename": "src/crypto/c_keccak.c",
        "status": "added",
        "additions": 122,
        "deletions": 0,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_keccak.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_keccak.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/c_keccak.c?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,122 @@\n+// keccak.c\r\n+// 19-Nov-11  Markku-Juhani O. Saarinen <mjos@iki.fi>\r\n+// A baseline Keccak (3rd round) implementation.\r\n+\r\n+#include <crypto/c_keccak.h>\r\n+\r\n+const uint64_t keccakf_rndc[24] = \r\n+{\r\n+    0x0000000000000001, 0x0000000000008082, 0x800000000000808a,\r\n+    0x8000000080008000, 0x000000000000808b, 0x0000000080000001,\r\n+    0x8000000080008081, 0x8000000000008009, 0x000000000000008a,\r\n+    0x0000000000000088, 0x0000000080008009, 0x000000008000000a,\r\n+    0x000000008000808b, 0x800000000000008b, 0x8000000000008089,\r\n+    0x8000000000008003, 0x8000000000008002, 0x8000000000000080, \r\n+    0x000000000000800a, 0x800000008000000a, 0x8000000080008081,\r\n+    0x8000000000008080, 0x0000000080000001, 0x8000000080008008\r\n+};\r\n+\r\n+const int keccakf_rotc[24] = \r\n+{\r\n+    1,  3,  6,  10, 15, 21, 28, 36, 45, 55, 2,  14, \r\n+    27, 41, 56, 8,  25, 43, 62, 18, 39, 61, 20, 44\r\n+};\r\n+\r\n+const int keccakf_piln[24] = \r\n+{\r\n+    10, 7,  11, 17, 18, 3, 5,  16, 8,  21, 24, 4, \r\n+    15, 23, 19, 13, 12, 2, 20, 14, 22, 9,  6,  1 \r\n+};\r\n+\r\n+// update the state with given number of rounds\r\n+\r\n+void keccakf(uint64_t st[25], int rounds)\r\n+{\r\n+    int i, j, round;\r\n+    uint64_t t, bc[5];\r\n+\r\n+    for (round = 0; round < rounds; ++round) {\r\n+\r\n+        // Theta\r\n+        bc[0] = st[0] ^ st[5] ^ st[10] ^ st[15] ^ st[20];\r\n+        bc[1] = st[1] ^ st[6] ^ st[11] ^ st[16] ^ st[21];\r\n+        bc[2] = st[2] ^ st[7] ^ st[12] ^ st[17] ^ st[22];\r\n+        bc[3] = st[3] ^ st[8] ^ st[13] ^ st[18] ^ st[23];\r\n+        bc[4] = st[4] ^ st[9] ^ st[14] ^ st[19] ^ st[24];\r\n+\r\n+        for (i = 0; i < 5; ++i) {\r\n+            t = bc[(i + 4) % 5] ^ ROTL64(bc[(i + 1) % 5], 1);\r\n+            st[i     ] ^= t;\r\n+            st[i +  5] ^= t;\r\n+            st[i + 10] ^= t;\r\n+            st[i + 15] ^= t;\r\n+            st[i + 20] ^= t;\r\n+        }\r\n+\r\n+        // Rho Pi\r\n+        t = st[1];\r\n+        for (i = 0; i < 24; ++i) {\r\n+            bc[0] = st[keccakf_piln[i]];\r\n+            st[keccakf_piln[i]] = ROTL64(t, keccakf_rotc[i]);\r\n+            t = bc[0];\r\n+        }\r\n+\r\n+        //  Chi\r\n+        for (j = 0; j < 25; j += 5) {\r\n+            bc[0] = st[j    ];\r\n+            bc[1] = st[j + 1];\r\n+            bc[2] = st[j + 2];\r\n+            bc[3] = st[j + 3];\r\n+            bc[4] = st[j + 4];\r\n+            st[j    ] ^= (~bc[1]) & bc[2];\r\n+            st[j + 1] ^= (~bc[2]) & bc[3];\r\n+            st[j + 2] ^= (~bc[3]) & bc[4];\r\n+            st[j + 3] ^= (~bc[4]) & bc[0];\r\n+            st[j + 4] ^= (~bc[0]) & bc[1];\r\n+        }\r\n+\r\n+        //  Iota\r\n+        st[0] ^= keccakf_rndc[round];\r\n+    }\r\n+}\r\n+\r\n+// compute a keccak hash (md) of given byte length from \"in\"\r\n+typedef uint64_t state_t[25];\r\n+\r\n+int keccak(const uint8_t *in, int inlen, uint8_t *md, int mdlen)\r\n+{\r\n+    state_t st;\r\n+    uint8_t temp[144];\r\n+    int i, rsiz, rsizw;\r\n+\r\n+    rsiz = sizeof(state_t) == mdlen ? HASH_DATA_AREA : 200 - 2 * mdlen;\r\n+    rsizw = rsiz / 8;\r\n+    \r\n+    memset(st, 0, sizeof(st));\r\n+\r\n+    for ( ; inlen >= rsiz; inlen -= rsiz, in += rsiz) {\r\n+        for (i = 0; i < rsizw; i++)\r\n+            st[i] ^= ((uint64_t *) in)[i];\r\n+        keccakf(st, KECCAK_ROUNDS);\r\n+    }\r\n+    \r\n+    // last block and padding\r\n+    memcpy(temp, in, inlen);\r\n+    temp[inlen++] = 1;\r\n+    memset(temp + inlen, 0, rsiz - inlen);\r\n+    temp[rsiz - 1] |= 0x80;\r\n+\r\n+    for (i = 0; i < rsizw; i++)\r\n+        st[i] ^= ((uint64_t *) temp)[i];\r\n+\r\n+    keccakf(st, KECCAK_ROUNDS);\r\n+\r\n+    memcpy(md, st, mdlen);\r\n+\r\n+    return 0;\r\n+}\r\n+\r\n+void keccak1600(const uint8_t *in, int inlen, uint8_t *md)\r\n+{\r\n+    keccak(in, inlen, md, sizeof(state_t));\r\n+}\r"
      },
      {
        "sha": "5ad0aff18646842570f96b6408f060f81c1074f7",
        "filename": "src/crypto/c_keccak.h",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_keccak.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_keccak.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/c_keccak.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,34 @@\n+// keccak.h\r\n+// 19-Nov-11  Markku-Juhani O. Saarinen <mjos@iki.fi>\r\n+\r\n+#ifndef KECCAK_H\r\n+#define KECCAK_H\r\n+\r\n+#include <stdint.h>\r\n+#include <string.h>\r\n+\r\n+#ifndef KECCAK_ROUNDS\r\n+#define KECCAK_ROUNDS 24\r\n+#endif\r\n+\r\n+#ifndef ROTL64\r\n+#define ROTL64(x, y) (((x) << (y)) | ((x) >> (64 - (y))))\r\n+#endif\r\n+\r\n+#ifndef HASH_SIZE\r\n+#define HASH_SIZE 32\r\n+#endif\r\n+\r\n+#ifndef HASH_DATA_AREA\r\n+#define HASH_DATA_AREA 136\r\n+#endif\r\n+\r\n+// compute a keccak hash (md) of given byte length from \"in\"\r\n+int keccak(const uint8_t *in, int inlen, uint8_t *md, int mdlen);\r\n+\r\n+// update the state\r\n+void keccakf(uint64_t st[25], int norounds);\r\n+\r\n+void keccak1600(const uint8_t *in, int inlen, uint8_t *md);\r\n+\r\n+#endif\r"
      },
      {
        "sha": "80b70a53a4f57076ed25484e16c08249378040bc",
        "filename": "src/crypto/c_skein.c",
        "status": "added",
        "additions": 2036,
        "deletions": 0,
        "changes": 2036,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_skein.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_skein.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/c_skein.c?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,2036 @@\n+/***********************************************************************\r\n+**\r\n+** Implementation of the Skein hash function.\r\n+**\r\n+** Source code author: Doug Whiting, 2008.\r\n+**\r\n+** This algorithm and source code is released to the public domain.\r\n+** \r\n+************************************************************************/\r\n+\r\n+#define  SKEIN_PORT_CODE /* instantiate any code in skein_port.h */\r\n+\r\n+#include <stddef.h>                          /* get size_t definition */\r\n+#include <string.h>      /* get the memcpy/memset functions */\r\n+#include \"c_skein.h\"       /* get the Skein API definitions   */\r\n+\r\n+#define DISABLE_UNUSED 0\r\n+\r\n+#ifndef SKEIN_256_NIST_MAX_HASHBITS\r\n+#define SKEIN_256_NIST_MAX_HASHBITS (0)\r\n+#endif\r\n+\r\n+#ifndef SKEIN_512_NIST_MAX_HASHBITS\r\n+#define SKEIN_512_NIST_MAX_HASHBITS (512)\r\n+#endif\r\n+\r\n+#define  SKEIN_MODIFIER_WORDS  ( 2)          /* number of modifier (tweak) words */\r\n+\r\n+#define  SKEIN_256_STATE_WORDS ( 4)\r\n+#define  SKEIN_512_STATE_WORDS ( 8)\r\n+#define  SKEIN1024_STATE_WORDS (16)\r\n+#define  SKEIN_MAX_STATE_WORDS (16)\r\n+\r\n+#define  SKEIN_256_STATE_BYTES ( 8*SKEIN_256_STATE_WORDS)\r\n+#define  SKEIN_512_STATE_BYTES ( 8*SKEIN_512_STATE_WORDS)\r\n+#define  SKEIN1024_STATE_BYTES ( 8*SKEIN1024_STATE_WORDS)\r\n+\r\n+#define  SKEIN_256_STATE_BITS  (64*SKEIN_256_STATE_WORDS)\r\n+#define  SKEIN_512_STATE_BITS  (64*SKEIN_512_STATE_WORDS)\r\n+#define  SKEIN1024_STATE_BITS  (64*SKEIN1024_STATE_WORDS)\r\n+\r\n+#define  SKEIN_256_BLOCK_BYTES ( 8*SKEIN_256_STATE_WORDS)\r\n+#define  SKEIN_512_BLOCK_BYTES ( 8*SKEIN_512_STATE_WORDS)\r\n+#define  SKEIN1024_BLOCK_BYTES ( 8*SKEIN1024_STATE_WORDS)\r\n+\r\n+#define SKEIN_RND_SPECIAL       (1000u)\r\n+#define SKEIN_RND_KEY_INITIAL   (SKEIN_RND_SPECIAL+0u)\r\n+#define SKEIN_RND_KEY_INJECT    (SKEIN_RND_SPECIAL+1u)\r\n+#define SKEIN_RND_FEED_FWD      (SKEIN_RND_SPECIAL+2u)\r\n+\r\n+typedef struct\r\n+{\r\n+  size_t  hashBitLen;                      /* size of hash result, in bits */\r\n+  size_t  bCnt;                            /* current byte count in buffer b[] */\r\n+  u64b_t  T[SKEIN_MODIFIER_WORDS];         /* tweak words: T[0]=byte cnt, T[1]=flags */\r\n+} Skein_Ctxt_Hdr_t;\r\n+\r\n+typedef struct                               /*  256-bit Skein hash context structure */\r\n+{\r\n+  Skein_Ctxt_Hdr_t h;                      /* common header context variables */\r\n+  u64b_t  X[SKEIN_256_STATE_WORDS];        /* chaining variables */\r\n+  u08b_t  b[SKEIN_256_BLOCK_BYTES];        /* partial block buffer (8-byte aligned) */\r\n+} Skein_256_Ctxt_t;\r\n+\r\n+typedef struct                               /*  512-bit Skein hash context structure */\r\n+{\r\n+  Skein_Ctxt_Hdr_t h;                      /* common header context variables */\r\n+  u64b_t  X[SKEIN_512_STATE_WORDS];        /* chaining variables */\r\n+  u08b_t  b[SKEIN_512_BLOCK_BYTES];        /* partial block buffer (8-byte aligned) */\r\n+} Skein_512_Ctxt_t;\r\n+\r\n+typedef struct                               /* 1024-bit Skein hash context structure */\r\n+{\r\n+  Skein_Ctxt_Hdr_t h;                      /* common header context variables */\r\n+  u64b_t  X[SKEIN1024_STATE_WORDS];        /* chaining variables */\r\n+  u08b_t  b[SKEIN1024_BLOCK_BYTES];        /* partial block buffer (8-byte aligned) */\r\n+} Skein1024_Ctxt_t;\r\n+\r\n+/*   Skein APIs for (incremental) \"straight hashing\" */\r\n+#if SKEIN_256_NIST_MAX_HASH_BITS\r\n+static int  Skein_256_Init  (Skein_256_Ctxt_t *ctx, size_t hashBitLen);\r\n+#endif\r\n+static int  Skein_512_Init  (Skein_512_Ctxt_t *ctx, size_t hashBitLen);\r\n+static int  Skein1024_Init  (Skein1024_Ctxt_t *ctx, size_t hashBitLen);\r\n+\r\n+static int  Skein_256_Update(Skein_256_Ctxt_t *ctx, const u08b_t *msg, size_t msgByteCnt);\r\n+static int  Skein_512_Update(Skein_512_Ctxt_t *ctx, const u08b_t *msg, size_t msgByteCnt);\r\n+static int  Skein1024_Update(Skein1024_Ctxt_t *ctx, const u08b_t *msg, size_t msgByteCnt);\r\n+\r\n+static int  Skein_256_Final (Skein_256_Ctxt_t *ctx, u08b_t * hashVal);\r\n+static int  Skein_512_Final (Skein_512_Ctxt_t *ctx, u08b_t * hashVal);\r\n+static int  Skein1024_Final (Skein1024_Ctxt_t *ctx, u08b_t * hashVal);\r\n+\r\n+/*\r\n+**   Skein APIs for \"extended\" initialization: MAC keys, tree hashing.\r\n+**   After an InitExt() call, just use Update/Final calls as with Init().\r\n+**\r\n+**   Notes: Same parameters as _Init() calls, plus treeInfo/key/keyBytes.\r\n+**          When keyBytes == 0 and treeInfo == SKEIN_SEQUENTIAL, \r\n+**              the results of InitExt() are identical to calling Init().\r\n+**          The function Init() may be called once to \"precompute\" the IV for\r\n+**              a given hashBitLen value, then by saving a copy of the context\r\n+**              the IV computation may be avoided in later calls.\r\n+**          Similarly, the function InitExt() may be called once per MAC key \r\n+**              to precompute the MAC IV, then a copy of the context saved and\r\n+**              reused for each new MAC computation.\r\n+**/\r\n+#if 0\r\n+static int  Skein_256_InitExt(Skein_256_Ctxt_t *ctx, size_t hashBitLen, u64b_t treeInfo, const u08b_t *key, size_t keyBytes);\r\n+static int  Skein_512_InitExt(Skein_512_Ctxt_t *ctx, size_t hashBitLen, u64b_t treeInfo, const u08b_t *key, size_t keyBytes);\r\n+static int  Skein1024_InitExt(Skein1024_Ctxt_t *ctx, size_t hashBitLen, u64b_t treeInfo, const u08b_t *key, size_t keyBytes);\r\n+#endif\r\n+\r\n+/*\r\n+**   Skein APIs for MAC and tree hash:\r\n+**      Final_Pad:  pad, do final block, but no OUTPUT type\r\n+**      Output:     do just the output stage\r\n+*/\r\n+#if 0\r\n+static int  Skein_256_Final_Pad(Skein_256_Ctxt_t *ctx, u08b_t * hashVal);\r\n+static int  Skein_512_Final_Pad(Skein_512_Ctxt_t *ctx, u08b_t * hashVal);\r\n+static int  Skein1024_Final_Pad(Skein1024_Ctxt_t *ctx, u08b_t * hashVal);\r\n+#endif\r\n+\r\n+#ifndef SKEIN_TREE_HASH\r\n+#define SKEIN_TREE_HASH (1)\r\n+#endif\r\n+#if 0\r\n+#if  SKEIN_TREE_HASH\r\n+static int  Skein_256_Output   (Skein_256_Ctxt_t *ctx, u08b_t * hashVal);\r\n+static int  Skein_512_Output   (Skein_512_Ctxt_t *ctx, u08b_t * hashVal);\r\n+static int  Skein1024_Output   (Skein1024_Ctxt_t *ctx, u08b_t * hashVal);\r\n+#endif\r\n+#endif\r\n+\r\n+/*****************************************************************\r\n+** \"Internal\" Skein definitions\r\n+**    -- not needed for sequential hashing API, but will be \r\n+**           helpful for other uses of Skein (e.g., tree hash mode).\r\n+**    -- included here so that they can be shared between\r\n+**           reference and optimized code.\r\n+******************************************************************/\r\n+\r\n+/* tweak word T[1]: bit field starting positions */\r\n+#define SKEIN_T1_BIT(BIT)       ((BIT) - 64)            /* offset 64 because it's the second word  */\r\n+\r\n+#define SKEIN_T1_POS_TREE_LVL   SKEIN_T1_BIT(112)       /* bits 112..118: level in hash tree       */\r\n+#define SKEIN_T1_POS_BIT_PAD    SKEIN_T1_BIT(119)       /* bit  119     : partial final input byte */\r\n+#define SKEIN_T1_POS_BLK_TYPE   SKEIN_T1_BIT(120)       /* bits 120..125: type field               */\r\n+#define SKEIN_T1_POS_FIRST      SKEIN_T1_BIT(126)       /* bits 126     : first block flag         */\r\n+#define SKEIN_T1_POS_FINAL      SKEIN_T1_BIT(127)       /* bit  127     : final block flag         */\r\n+\r\n+/* tweak word T[1]: flag bit definition(s) */\r\n+#define SKEIN_T1_FLAG_FIRST     (((u64b_t)  1 ) << SKEIN_T1_POS_FIRST)\r\n+#define SKEIN_T1_FLAG_FINAL     (((u64b_t)  1 ) << SKEIN_T1_POS_FINAL)\r\n+#define SKEIN_T1_FLAG_BIT_PAD   (((u64b_t)  1 ) << SKEIN_T1_POS_BIT_PAD)\r\n+\r\n+/* tweak word T[1]: tree level bit field mask */\r\n+#define SKEIN_T1_TREE_LVL_MASK  (((u64b_t)0x7F) << SKEIN_T1_POS_TREE_LVL)\r\n+#define SKEIN_T1_TREE_LEVEL(n)  (((u64b_t) (n)) << SKEIN_T1_POS_TREE_LVL)\r\n+\r\n+/* tweak word T[1]: block type field */\r\n+#define SKEIN_BLK_TYPE_KEY      ( 0)                    /* key, for MAC and KDF */\r\n+#define SKEIN_BLK_TYPE_CFG      ( 4)                    /* configuration block */\r\n+#define SKEIN_BLK_TYPE_PERS     ( 8)                    /* personalization string */\r\n+#define SKEIN_BLK_TYPE_PK       (12)                    /* public key (for digital signature hashing) */\r\n+#define SKEIN_BLK_TYPE_KDF      (16)                    /* key identifier for KDF */\r\n+#define SKEIN_BLK_TYPE_NONCE    (20)                    /* nonce for PRNG */\r\n+#define SKEIN_BLK_TYPE_MSG      (48)                    /* message processing */\r\n+#define SKEIN_BLK_TYPE_OUT      (63)                    /* output stage */\r\n+#define SKEIN_BLK_TYPE_MASK     (63)                    /* bit field mask */\r\n+\r\n+#define SKEIN_T1_BLK_TYPE(T)   (((u64b_t) (SKEIN_BLK_TYPE_##T)) << SKEIN_T1_POS_BLK_TYPE)\r\n+#define SKEIN_T1_BLK_TYPE_KEY   SKEIN_T1_BLK_TYPE(KEY)  /* key, for MAC and KDF */\r\n+#define SKEIN_T1_BLK_TYPE_CFG   SKEIN_T1_BLK_TYPE(CFG)  /* configuration block */\r\n+#define SKEIN_T1_BLK_TYPE_PERS  SKEIN_T1_BLK_TYPE(PERS) /* personalization string */\r\n+#define SKEIN_T1_BLK_TYPE_PK    SKEIN_T1_BLK_TYPE(PK)   /* public key (for digital signature hashing) */\r\n+#define SKEIN_T1_BLK_TYPE_KDF   SKEIN_T1_BLK_TYPE(KDF)  /* key identifier for KDF */\r\n+#define SKEIN_T1_BLK_TYPE_NONCE SKEIN_T1_BLK_TYPE(NONCE)/* nonce for PRNG */\r\n+#define SKEIN_T1_BLK_TYPE_MSG   SKEIN_T1_BLK_TYPE(MSG)  /* message processing */\r\n+#define SKEIN_T1_BLK_TYPE_OUT   SKEIN_T1_BLK_TYPE(OUT)  /* output stage */\r\n+#define SKEIN_T1_BLK_TYPE_MASK  SKEIN_T1_BLK_TYPE(MASK) /* field bit mask */\r\n+\r\n+#define SKEIN_T1_BLK_TYPE_CFG_FINAL       (SKEIN_T1_BLK_TYPE_CFG | SKEIN_T1_FLAG_FINAL)\r\n+#define SKEIN_T1_BLK_TYPE_OUT_FINAL       (SKEIN_T1_BLK_TYPE_OUT | SKEIN_T1_FLAG_FINAL)\r\n+\r\n+#define SKEIN_VERSION           (1)\r\n+\r\n+#ifndef SKEIN_ID_STRING_LE      /* allow compile-time personalization */\r\n+#define SKEIN_ID_STRING_LE      (0x33414853)            /* \"SHA3\" (little-endian)*/\r\n+#endif\r\n+\r\n+#define SKEIN_MK_64(hi32,lo32)  ((lo32) + (((u64b_t) (hi32)) << 32))\r\n+#define SKEIN_SCHEMA_VER        SKEIN_MK_64(SKEIN_VERSION,SKEIN_ID_STRING_LE)\r\n+#define SKEIN_KS_PARITY         SKEIN_MK_64(0x1BD11BDA,0xA9FC1A22)\r\n+\r\n+#define SKEIN_CFG_STR_LEN       (4*8)\r\n+\r\n+/* bit field definitions in config block treeInfo word */\r\n+#define SKEIN_CFG_TREE_LEAF_SIZE_POS  ( 0)\r\n+#define SKEIN_CFG_TREE_NODE_SIZE_POS  ( 8)\r\n+#define SKEIN_CFG_TREE_MAX_LEVEL_POS  (16)\r\n+\r\n+#define SKEIN_CFG_TREE_LEAF_SIZE_MSK  (((u64b_t) 0xFF) << SKEIN_CFG_TREE_LEAF_SIZE_POS)\r\n+#define SKEIN_CFG_TREE_NODE_SIZE_MSK  (((u64b_t) 0xFF) << SKEIN_CFG_TREE_NODE_SIZE_POS)\r\n+#define SKEIN_CFG_TREE_MAX_LEVEL_MSK  (((u64b_t) 0xFF) << SKEIN_CFG_TREE_MAX_LEVEL_POS)\r\n+\r\n+#define SKEIN_CFG_TREE_INFO(leaf,node,maxLvl)                   \\\r\n+  ( (((u64b_t)(leaf  )) << SKEIN_CFG_TREE_LEAF_SIZE_POS) |    \\\r\n+  (((u64b_t)(node  )) << SKEIN_CFG_TREE_NODE_SIZE_POS) |    \\\r\n+  (((u64b_t)(maxLvl)) << SKEIN_CFG_TREE_MAX_LEVEL_POS) )\r\n+\r\n+#define SKEIN_CFG_TREE_INFO_SEQUENTIAL SKEIN_CFG_TREE_INFO(0,0,0) /* use as treeInfo in InitExt() call for sequential processing */\r\n+\r\n+/*\r\n+**   Skein macros for getting/setting tweak words, etc.\r\n+**   These are useful for partial input bytes, hash tree init/update, etc.\r\n+**/\r\n+#define Skein_Get_Tweak(ctxPtr,TWK_NUM)         ((ctxPtr)->h.T[TWK_NUM])\r\n+#define Skein_Set_Tweak(ctxPtr,TWK_NUM,tVal)    {(ctxPtr)->h.T[TWK_NUM] = (tVal);}\r\n+\r\n+#define Skein_Get_T0(ctxPtr)    Skein_Get_Tweak(ctxPtr,0)\r\n+#define Skein_Get_T1(ctxPtr)    Skein_Get_Tweak(ctxPtr,1)\r\n+#define Skein_Set_T0(ctxPtr,T0) Skein_Set_Tweak(ctxPtr,0,T0)\r\n+#define Skein_Set_T1(ctxPtr,T1) Skein_Set_Tweak(ctxPtr,1,T1)\r\n+\r\n+/* set both tweak words at once */\r\n+#define Skein_Set_T0_T1(ctxPtr,T0,T1)           \\\r\n+{                                           \\\r\n+  Skein_Set_T0(ctxPtr,(T0));                  \\\r\n+  Skein_Set_T1(ctxPtr,(T1));                  \\\r\n+}\r\n+\r\n+#define Skein_Set_Type(ctxPtr,BLK_TYPE)         \\\r\n+  Skein_Set_T1(ctxPtr,SKEIN_T1_BLK_TYPE_##BLK_TYPE)\r\n+\r\n+/* set up for starting with a new type: h.T[0]=0; h.T[1] = NEW_TYPE; h.bCnt=0; */\r\n+#define Skein_Start_New_Type(ctxPtr,BLK_TYPE)   \\\r\n+{ Skein_Set_T0_T1(ctxPtr,0,SKEIN_T1_FLAG_FIRST | SKEIN_T1_BLK_TYPE_##BLK_TYPE); (ctxPtr)->h.bCnt=0; }\r\n+\r\n+#define Skein_Clear_First_Flag(hdr)      { (hdr).T[1] &= ~SKEIN_T1_FLAG_FIRST;       }\r\n+#define Skein_Set_Bit_Pad_Flag(hdr)      { (hdr).T[1] |=  SKEIN_T1_FLAG_BIT_PAD;     }\r\n+\r\n+#define Skein_Set_Tree_Level(hdr,height) { (hdr).T[1] |= SKEIN_T1_TREE_LEVEL(height);}\r\n+\r\n+/*****************************************************************\r\n+** \"Internal\" Skein definitions for debugging and error checking\r\n+******************************************************************/\r\n+#define Skein_Show_Block(bits,ctx,X,blkPtr,wPtr,ksEvenPtr,ksOddPtr)\r\n+#define Skein_Show_Round(bits,ctx,r,X)\r\n+#define Skein_Show_R_Ptr(bits,ctx,r,X_ptr)\r\n+#define Skein_Show_Final(bits,ctx,cnt,outPtr)\r\n+#define Skein_Show_Key(bits,ctx,key,keyBytes)\r\n+\r\n+\r\n+#ifndef SKEIN_ERR_CHECK        /* run-time checks (e.g., bad params, uninitialized context)? */\r\n+#define Skein_Assert(x,retCode)/* default: ignore all Asserts, for performance */\r\n+#define Skein_assert(x)\r\n+#elif   defined(SKEIN_ASSERT)\r\n+#include <assert.h>     \r\n+#define Skein_Assert(x,retCode) assert(x) \r\n+#define Skein_assert(x)         assert(x) \r\n+#else\r\n+#include <assert.h>     \r\n+#define Skein_Assert(x,retCode) { if (!(x)) return retCode; } /*  caller  error */\r\n+#define Skein_assert(x)         assert(x)                     /* internal error */\r\n+#endif\r\n+\r\n+/*****************************************************************\r\n+** Skein block function constants (shared across Ref and Opt code)\r\n+******************************************************************/\r\n+enum    \r\n+{   \r\n+  /* Skein_256 round rotation constants */\r\n+  R_256_0_0=14, R_256_0_1=16,\r\n+  R_256_1_0=52, R_256_1_1=57,\r\n+  R_256_2_0=23, R_256_2_1=40,\r\n+  R_256_3_0= 5, R_256_3_1=37,\r\n+  R_256_4_0=25, R_256_4_1=33,\r\n+  R_256_5_0=46, R_256_5_1=12,\r\n+  R_256_6_0=58, R_256_6_1=22,\r\n+  R_256_7_0=32, R_256_7_1=32,\r\n+\r\n+  /* Skein_512 round rotation constants */\r\n+  R_512_0_0=46, R_512_0_1=36, R_512_0_2=19, R_512_0_3=37,\r\n+  R_512_1_0=33, R_512_1_1=27, R_512_1_2=14, R_512_1_3=42,\r\n+  R_512_2_0=17, R_512_2_1=49, R_512_2_2=36, R_512_2_3=39,\r\n+  R_512_3_0=44, R_512_3_1= 9, R_512_3_2=54, R_512_3_3=56,\r\n+  R_512_4_0=39, R_512_4_1=30, R_512_4_2=34, R_512_4_3=24,\r\n+  R_512_5_0=13, R_512_5_1=50, R_512_5_2=10, R_512_5_3=17,\r\n+  R_512_6_0=25, R_512_6_1=29, R_512_6_2=39, R_512_6_3=43,\r\n+  R_512_7_0= 8, R_512_7_1=35, R_512_7_2=56, R_512_7_3=22,\r\n+\r\n+  /* Skein1024 round rotation constants */\r\n+  R1024_0_0=24, R1024_0_1=13, R1024_0_2= 8, R1024_0_3=47, R1024_0_4= 8, R1024_0_5=17, R1024_0_6=22, R1024_0_7=37,\r\n+  R1024_1_0=38, R1024_1_1=19, R1024_1_2=10, R1024_1_3=55, R1024_1_4=49, R1024_1_5=18, R1024_1_6=23, R1024_1_7=52,\r\n+  R1024_2_0=33, R1024_2_1= 4, R1024_2_2=51, R1024_2_3=13, R1024_2_4=34, R1024_2_5=41, R1024_2_6=59, R1024_2_7=17,\r\n+  R1024_3_0= 5, R1024_3_1=20, R1024_3_2=48, R1024_3_3=41, R1024_3_4=47, R1024_3_5=28, R1024_3_6=16, R1024_3_7=25,\r\n+  R1024_4_0=41, R1024_4_1= 9, R1024_4_2=37, R1024_4_3=31, R1024_4_4=12, R1024_4_5=47, R1024_4_6=44, R1024_4_7=30,\r\n+  R1024_5_0=16, R1024_5_1=34, R1024_5_2=56, R1024_5_3=51, R1024_5_4= 4, R1024_5_5=53, R1024_5_6=42, R1024_5_7=41,\r\n+  R1024_6_0=31, R1024_6_1=44, R1024_6_2=47, R1024_6_3=46, R1024_6_4=19, R1024_6_5=42, R1024_6_6=44, R1024_6_7=25,\r\n+  R1024_7_0= 9, R1024_7_1=48, R1024_7_2=35, R1024_7_3=52, R1024_7_4=23, R1024_7_5=31, R1024_7_6=37, R1024_7_7=20\r\n+};\r\n+\r\n+#ifndef SKEIN_ROUNDS\r\n+#define SKEIN_256_ROUNDS_TOTAL (72)          /* number of rounds for the different block sizes */\r\n+#define SKEIN_512_ROUNDS_TOTAL (72)\r\n+#define SKEIN1024_ROUNDS_TOTAL (80)\r\n+#else                                        /* allow command-line define in range 8*(5..14)   */\r\n+#define SKEIN_256_ROUNDS_TOTAL (8*((((SKEIN_ROUNDS/100) + 5) % 10) + 5))\r\n+#define SKEIN_512_ROUNDS_TOTAL (8*((((SKEIN_ROUNDS/ 10) + 5) % 10) + 5))\r\n+#define SKEIN1024_ROUNDS_TOTAL (8*((((SKEIN_ROUNDS    ) + 5) % 10) + 5))\r\n+#endif\r\n+\r\n+\r\n+/*\r\n+***************** Pre-computed Skein IVs *******************\r\n+**\r\n+** NOTE: these values are not \"magic\" constants, but\r\n+** are generated using the Threefish block function.\r\n+** They are pre-computed here only for speed; i.e., to\r\n+** avoid the need for a Threefish call during Init().\r\n+**\r\n+** The IV for any fixed hash length may be pre-computed.\r\n+** Only the most common values are included here.\r\n+**\r\n+************************************************************\r\n+**/\r\n+\r\n+#define MK_64 SKEIN_MK_64\r\n+\r\n+/* blkSize =  256 bits. hashSize =  128 bits */\r\n+const u64b_t SKEIN_256_IV_128[] =\r\n+    {\r\n+    MK_64(0xE1111906,0x964D7260),\r\n+    MK_64(0x883DAAA7,0x7C8D811C),\r\n+    MK_64(0x10080DF4,0x91960F7A),\r\n+    MK_64(0xCCF7DDE5,0xB45BC1C2)\r\n+    };\r\n+\r\n+/* blkSize =  256 bits. hashSize =  160 bits */\r\n+const u64b_t SKEIN_256_IV_160[] =\r\n+    {\r\n+    MK_64(0x14202314,0x72825E98),\r\n+    MK_64(0x2AC4E9A2,0x5A77E590),\r\n+    MK_64(0xD47A5856,0x8838D63E),\r\n+    MK_64(0x2DD2E496,0x8586AB7D)\r\n+    };\r\n+\r\n+/* blkSize =  256 bits. hashSize =  224 bits */\r\n+const u64b_t SKEIN_256_IV_224[] =\r\n+    {\r\n+    MK_64(0xC6098A8C,0x9AE5EA0B),\r\n+    MK_64(0x876D5686,0x08C5191C),\r\n+    MK_64(0x99CB88D7,0xD7F53884),\r\n+    MK_64(0x384BDDB1,0xAEDDB5DE)\r\n+    };\r\n+\r\n+/* blkSize =  256 bits. hashSize =  256 bits */\r\n+const u64b_t SKEIN_256_IV_256[] =\r\n+    {\r\n+    MK_64(0xFC9DA860,0xD048B449),\r\n+    MK_64(0x2FCA6647,0x9FA7D833),\r\n+    MK_64(0xB33BC389,0x6656840F),\r\n+    MK_64(0x6A54E920,0xFDE8DA69)\r\n+    };\r\n+\r\n+/* blkSize =  512 bits. hashSize =  128 bits */\r\n+const u64b_t SKEIN_512_IV_128[] =\r\n+    {\r\n+    MK_64(0xA8BC7BF3,0x6FBF9F52),\r\n+    MK_64(0x1E9872CE,0xBD1AF0AA),\r\n+    MK_64(0x309B1790,0xB32190D3),\r\n+    MK_64(0xBCFBB854,0x3F94805C),\r\n+    MK_64(0x0DA61BCD,0x6E31B11B),\r\n+    MK_64(0x1A18EBEA,0xD46A32E3),\r\n+    MK_64(0xA2CC5B18,0xCE84AA82),\r\n+    MK_64(0x6982AB28,0x9D46982D)\r\n+    };\r\n+\r\n+/* blkSize =  512 bits. hashSize =  160 bits */\r\n+const u64b_t SKEIN_512_IV_160[] =\r\n+    {\r\n+    MK_64(0x28B81A2A,0xE013BD91),\r\n+    MK_64(0xC2F11668,0xB5BDF78F),\r\n+    MK_64(0x1760D8F3,0xF6A56F12),\r\n+    MK_64(0x4FB74758,0x8239904F),\r\n+    MK_64(0x21EDE07F,0x7EAF5056),\r\n+    MK_64(0xD908922E,0x63ED70B8),\r\n+    MK_64(0xB8EC76FF,0xECCB52FA),\r\n+    MK_64(0x01A47BB8,0xA3F27A6E)\r\n+    };\r\n+\r\n+/* blkSize =  512 bits. hashSize =  224 bits */\r\n+const u64b_t SKEIN_512_IV_224[] =\r\n+    {\r\n+    MK_64(0xCCD06162,0x48677224),\r\n+    MK_64(0xCBA65CF3,0xA92339EF),\r\n+    MK_64(0x8CCD69D6,0x52FF4B64),\r\n+    MK_64(0x398AED7B,0x3AB890B4),\r\n+    MK_64(0x0F59D1B1,0x457D2BD0),\r\n+    MK_64(0x6776FE65,0x75D4EB3D),\r\n+    MK_64(0x99FBC70E,0x997413E9),\r\n+    MK_64(0x9E2CFCCF,0xE1C41EF7)\r\n+    };\r\n+\r\n+/* blkSize =  512 bits. hashSize =  256 bits */\r\n+const u64b_t SKEIN_512_IV_256[] =\r\n+    {\r\n+    MK_64(0xCCD044A1,0x2FDB3E13),\r\n+    MK_64(0xE8359030,0x1A79A9EB),\r\n+    MK_64(0x55AEA061,0x4F816E6F),\r\n+    MK_64(0x2A2767A4,0xAE9B94DB),\r\n+    MK_64(0xEC06025E,0x74DD7683),\r\n+    MK_64(0xE7A436CD,0xC4746251),\r\n+    MK_64(0xC36FBAF9,0x393AD185),\r\n+    MK_64(0x3EEDBA18,0x33EDFC13)\r\n+    };\r\n+\r\n+/* blkSize =  512 bits. hashSize =  384 bits */\r\n+const u64b_t SKEIN_512_IV_384[] =\r\n+    {\r\n+    MK_64(0xA3F6C6BF,0x3A75EF5F),\r\n+    MK_64(0xB0FEF9CC,0xFD84FAA4),\r\n+    MK_64(0x9D77DD66,0x3D770CFE),\r\n+    MK_64(0xD798CBF3,0xB468FDDA),\r\n+    MK_64(0x1BC4A666,0x8A0E4465),\r\n+    MK_64(0x7ED7D434,0xE5807407),\r\n+    MK_64(0x548FC1AC,0xD4EC44D6),\r\n+    MK_64(0x266E1754,0x6AA18FF8)\r\n+    };\r\n+\r\n+/* blkSize =  512 bits. hashSize =  512 bits */\r\n+const u64b_t SKEIN_512_IV_512[] =\r\n+    {\r\n+    MK_64(0x4903ADFF,0x749C51CE),\r\n+    MK_64(0x0D95DE39,0x9746DF03),\r\n+    MK_64(0x8FD19341,0x27C79BCE),\r\n+    MK_64(0x9A255629,0xFF352CB1),\r\n+    MK_64(0x5DB62599,0xDF6CA7B0),\r\n+    MK_64(0xEABE394C,0xA9D5C3F4),\r\n+    MK_64(0x991112C7,0x1A75B523),\r\n+    MK_64(0xAE18A40B,0x660FCC33)\r\n+    };\r\n+\r\n+/* blkSize = 1024 bits. hashSize =  384 bits */\r\n+const u64b_t SKEIN1024_IV_384[] =\r\n+    {\r\n+    MK_64(0x5102B6B8,0xC1894A35),\r\n+    MK_64(0xFEEBC9E3,0xFE8AF11A),\r\n+    MK_64(0x0C807F06,0xE32BED71),\r\n+    MK_64(0x60C13A52,0xB41A91F6),\r\n+    MK_64(0x9716D35D,0xD4917C38),\r\n+    MK_64(0xE780DF12,0x6FD31D3A),\r\n+    MK_64(0x797846B6,0xC898303A),\r\n+    MK_64(0xB172C2A8,0xB3572A3B),\r\n+    MK_64(0xC9BC8203,0xA6104A6C),\r\n+    MK_64(0x65909338,0xD75624F4),\r\n+    MK_64(0x94BCC568,0x4B3F81A0),\r\n+    MK_64(0x3EBBF51E,0x10ECFD46),\r\n+    MK_64(0x2DF50F0B,0xEEB08542),\r\n+    MK_64(0x3B5A6530,0x0DBC6516),\r\n+    MK_64(0x484B9CD2,0x167BBCE1),\r\n+    MK_64(0x2D136947,0xD4CBAFEA)\r\n+    };\r\n+\r\n+/* blkSize = 1024 bits. hashSize =  512 bits */\r\n+const u64b_t SKEIN1024_IV_512[] =\r\n+    {\r\n+    MK_64(0xCAEC0E5D,0x7C1B1B18),\r\n+    MK_64(0xA01B0E04,0x5F03E802),\r\n+    MK_64(0x33840451,0xED912885),\r\n+    MK_64(0x374AFB04,0xEAEC2E1C),\r\n+    MK_64(0xDF25A0E2,0x813581F7),\r\n+    MK_64(0xE4004093,0x8B12F9D2),\r\n+    MK_64(0xA662D539,0xC2ED39B6),\r\n+    MK_64(0xFA8B85CF,0x45D8C75A),\r\n+    MK_64(0x8316ED8E,0x29EDE796),\r\n+    MK_64(0x053289C0,0x2E9F91B8),\r\n+    MK_64(0xC3F8EF1D,0x6D518B73),\r\n+    MK_64(0xBDCEC3C4,0xD5EF332E),\r\n+    MK_64(0x549A7E52,0x22974487),\r\n+    MK_64(0x67070872,0x5B749816),\r\n+    MK_64(0xB9CD28FB,0xF0581BD1),\r\n+    MK_64(0x0E2940B8,0x15804974)\r\n+    };\r\n+\r\n+/* blkSize = 1024 bits. hashSize = 1024 bits */\r\n+const u64b_t SKEIN1024_IV_1024[] =\r\n+    {\r\n+    MK_64(0xD593DA07,0x41E72355),\r\n+    MK_64(0x15B5E511,0xAC73E00C),\r\n+    MK_64(0x5180E5AE,0xBAF2C4F0),\r\n+    MK_64(0x03BD41D3,0xFCBCAFAF),\r\n+    MK_64(0x1CAEC6FD,0x1983A898),\r\n+    MK_64(0x6E510B8B,0xCDD0589F),\r\n+    MK_64(0x77E2BDFD,0xC6394ADA),\r\n+    MK_64(0xC11E1DB5,0x24DCB0A3),\r\n+    MK_64(0xD6D14AF9,0xC6329AB5),\r\n+    MK_64(0x6A9B0BFC,0x6EB67E0D),\r\n+    MK_64(0x9243C60D,0xCCFF1332),\r\n+    MK_64(0x1A1F1DDE,0x743F02D4),\r\n+    MK_64(0x0996753C,0x10ED0BB8),\r\n+    MK_64(0x6572DD22,0xF2B4969A),\r\n+    MK_64(0x61FD3062,0xD00A579A),\r\n+    MK_64(0x1DE0536E,0x8682E539)\r\n+    };\r\n+\r\n+\r\n+#ifndef SKEIN_USE_ASM\r\n+#define SKEIN_USE_ASM   (0)                     /* default is all C code (no ASM) */\r\n+#endif\r\n+\r\n+#ifndef SKEIN_LOOP\r\n+#define SKEIN_LOOP 001                          /* default: unroll 256 and 512, but not 1024 */\r\n+#endif\r\n+\r\n+#define BLK_BITS        (WCNT*64)               /* some useful definitions for code here */\r\n+#define KW_TWK_BASE     (0)\r\n+#define KW_KEY_BASE     (3)\r\n+#define ks              (kw + KW_KEY_BASE)                \r\n+#define ts              (kw + KW_TWK_BASE)\r\n+\r\n+#ifdef SKEIN_DEBUG\r\n+#define DebugSaveTweak(ctx) { ctx->h.T[0] = ts[0]; ctx->h.T[1] = ts[1]; }\r\n+#else\r\n+#define DebugSaveTweak(ctx)\r\n+#endif\r\n+\r\n+/*****************************  Skein_256 ******************************/\r\n+#if !(SKEIN_USE_ASM & 256)\r\n+static void Skein_256_Process_Block(Skein_256_Ctxt_t *ctx,const u08b_t *blkPtr,size_t blkCnt,size_t byteCntAdd)\r\n+    { /* do it in C */\r\n+    enum\r\n+        {\r\n+        WCNT = SKEIN_256_STATE_WORDS\r\n+        };\r\n+#undef  RCNT\r\n+#define RCNT  (SKEIN_256_ROUNDS_TOTAL/8)\r\n+\r\n+#ifdef  SKEIN_LOOP                              /* configure how much to unroll the loop */\r\n+#define SKEIN_UNROLL_256 (((SKEIN_LOOP)/100)%10)\r\n+#else\r\n+#define SKEIN_UNROLL_256 (0)\r\n+#endif\r\n+\r\n+#if SKEIN_UNROLL_256\r\n+#if (RCNT % SKEIN_UNROLL_256)\r\n+#error \"Invalid SKEIN_UNROLL_256\"               /* sanity check on unroll count */\r\n+#endif\r\n+    size_t  r;\r\n+    u64b_t  kw[WCNT+4+RCNT*2];                  /* key schedule words : chaining vars + tweak + \"rotation\"*/\r\n+#else\r\n+    u64b_t  kw[WCNT+4];                         /* key schedule words : chaining vars + tweak */\r\n+#endif\r\n+    u64b_t  X0,X1,X2,X3;                        /* local copy of context vars, for speed */\r\n+    u64b_t  w [WCNT];                           /* local copy of input block */\r\n+#ifdef SKEIN_DEBUG\r\n+    const u64b_t *Xptr[4];                      /* use for debugging (help compiler put Xn in registers) */\r\n+    Xptr[0] = &X0;  Xptr[1] = &X1;  Xptr[2] = &X2;  Xptr[3] = &X3;\r\n+#endif\r\n+    Skein_assert(blkCnt != 0);                  /* never call with blkCnt == 0! */\r\n+    ts[0] = ctx->h.T[0];\r\n+    ts[1] = ctx->h.T[1];\r\n+    do  {\r\n+        /* this implementation only supports 2**64 input bytes (no carry out here) */\r\n+        ts[0] += byteCntAdd;                    /* update processed length */\r\n+\r\n+        /* precompute the key schedule for this block */\r\n+        ks[0] = ctx->X[0];     \r\n+        ks[1] = ctx->X[1];\r\n+        ks[2] = ctx->X[2];\r\n+        ks[3] = ctx->X[3];\r\n+        ks[4] = ks[0] ^ ks[1] ^ ks[2] ^ ks[3] ^ SKEIN_KS_PARITY;\r\n+\r\n+        ts[2] = ts[0] ^ ts[1];\r\n+\r\n+        Skein_Get64_LSB_First(w,blkPtr,WCNT);   /* get input block in little-endian format */\r\n+        DebugSaveTweak(ctx);\r\n+        Skein_Show_Block(BLK_BITS,&ctx->h,ctx->X,blkPtr,w,ks,ts);\r\n+\r\n+        X0 = w[0] + ks[0];                      /* do the first full key injection */\r\n+        X1 = w[1] + ks[1] + ts[0];\r\n+        X2 = w[2] + ks[2] + ts[1];\r\n+        X3 = w[3] + ks[3];\r\n+\r\n+        Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INITIAL,Xptr);    /* show starting state values */\r\n+\r\n+        blkPtr += SKEIN_256_BLOCK_BYTES;\r\n+\r\n+        /* run the rounds */\r\n+\r\n+#define Round256(p0,p1,p2,p3,ROT,rNum)                              \\\r\n+    X##p0 += X##p1; X##p1 = RotL_64(X##p1,ROT##_0); X##p1 ^= X##p0; \\\r\n+    X##p2 += X##p3; X##p3 = RotL_64(X##p3,ROT##_1); X##p3 ^= X##p2; \\\r\n+\r\n+#if SKEIN_UNROLL_256 == 0                       \r\n+#define R256(p0,p1,p2,p3,ROT,rNum)           /* fully unrolled */   \\\r\n+    Round256(p0,p1,p2,p3,ROT,rNum)                                  \\\r\n+    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,rNum,Xptr);\r\n+\r\n+#define I256(R)                                                     \\\r\n+    X0   += ks[((R)+1) % 5];    /* inject the key schedule value */ \\\r\n+    X1   += ks[((R)+2) % 5] + ts[((R)+1) % 3];                      \\\r\n+    X2   += ks[((R)+3) % 5] + ts[((R)+2) % 3];                      \\\r\n+    X3   += ks[((R)+4) % 5] +     (R)+1;                            \\\r\n+    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);\r\n+#else                                       /* looping version */\r\n+#define R256(p0,p1,p2,p3,ROT,rNum)                                  \\\r\n+    Round256(p0,p1,p2,p3,ROT,rNum)                                  \\\r\n+    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,4*(r-1)+rNum,Xptr);\r\n+\r\n+#define I256(R)                                                     \\\r\n+    X0   += ks[r+(R)+0];        /* inject the key schedule value */ \\\r\n+    X1   += ks[r+(R)+1] + ts[r+(R)+0];                              \\\r\n+    X2   += ks[r+(R)+2] + ts[r+(R)+1];                              \\\r\n+    X3   += ks[r+(R)+3] +    r+(R)   ;                              \\\r\n+    ks[r + (R)+4    ]   = ks[r+(R)-1];     /* rotate key schedule */\\\r\n+    ts[r + (R)+2    ]   = ts[r+(R)-1];                              \\\r\n+    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);\r\n+\r\n+    for (r=1;r < 2*RCNT;r+=2*SKEIN_UNROLL_256)  /* loop thru it */\r\n+#endif  \r\n+        {    \r\n+#define R256_8_rounds(R)                  \\\r\n+        R256(0,1,2,3,R_256_0,8*(R) + 1);  \\\r\n+        R256(0,3,2,1,R_256_1,8*(R) + 2);  \\\r\n+        R256(0,1,2,3,R_256_2,8*(R) + 3);  \\\r\n+        R256(0,3,2,1,R_256_3,8*(R) + 4);  \\\r\n+        I256(2*(R));                      \\\r\n+        R256(0,1,2,3,R_256_4,8*(R) + 5);  \\\r\n+        R256(0,3,2,1,R_256_5,8*(R) + 6);  \\\r\n+        R256(0,1,2,3,R_256_6,8*(R) + 7);  \\\r\n+        R256(0,3,2,1,R_256_7,8*(R) + 8);  \\\r\n+        I256(2*(R)+1);\r\n+\r\n+        R256_8_rounds( 0);\r\n+\r\n+#define R256_Unroll_R(NN) ((SKEIN_UNROLL_256 == 0 && SKEIN_256_ROUNDS_TOTAL/8 > (NN)) || (SKEIN_UNROLL_256 > (NN)))\r\n+\r\n+  #if   R256_Unroll_R( 1)\r\n+        R256_8_rounds( 1);\r\n+  #endif\r\n+  #if   R256_Unroll_R( 2)\r\n+        R256_8_rounds( 2);\r\n+  #endif\r\n+  #if   R256_Unroll_R( 3)\r\n+        R256_8_rounds( 3);\r\n+  #endif\r\n+  #if   R256_Unroll_R( 4)\r\n+        R256_8_rounds( 4);\r\n+  #endif\r\n+  #if   R256_Unroll_R( 5)\r\n+        R256_8_rounds( 5);\r\n+  #endif\r\n+  #if   R256_Unroll_R( 6)\r\n+        R256_8_rounds( 6);\r\n+  #endif\r\n+  #if   R256_Unroll_R( 7)\r\n+        R256_8_rounds( 7);\r\n+  #endif\r\n+  #if   R256_Unroll_R( 8)\r\n+        R256_8_rounds( 8);\r\n+  #endif\r\n+  #if   R256_Unroll_R( 9)\r\n+        R256_8_rounds( 9);\r\n+  #endif\r\n+  #if   R256_Unroll_R(10)\r\n+        R256_8_rounds(10);\r\n+  #endif\r\n+  #if   R256_Unroll_R(11)\r\n+        R256_8_rounds(11);\r\n+  #endif\r\n+  #if   R256_Unroll_R(12)\r\n+        R256_8_rounds(12);\r\n+  #endif\r\n+  #if   R256_Unroll_R(13)\r\n+        R256_8_rounds(13);\r\n+  #endif\r\n+  #if   R256_Unroll_R(14)\r\n+        R256_8_rounds(14);\r\n+  #endif\r\n+  #if  (SKEIN_UNROLL_256 > 14)\r\n+#error  \"need more unrolling in Skein_256_Process_Block\"\r\n+  #endif\r\n+        }\r\n+        /* do the final \"feedforward\" xor, update context chaining vars */\r\n+        ctx->X[0] = X0 ^ w[0];\r\n+        ctx->X[1] = X1 ^ w[1];\r\n+        ctx->X[2] = X2 ^ w[2];\r\n+        ctx->X[3] = X3 ^ w[3];\r\n+\r\n+        Skein_Show_Round(BLK_BITS,&ctx->h,SKEIN_RND_FEED_FWD,ctx->X);\r\n+\r\n+        ts[1] &= ~SKEIN_T1_FLAG_FIRST;\r\n+        }\r\n+    while (--blkCnt);\r\n+    ctx->h.T[0] = ts[0];\r\n+    ctx->h.T[1] = ts[1];\r\n+    }\r\n+\r\n+#if defined(SKEIN_CODE_SIZE) || defined(SKEIN_PERF)\r\n+static size_t Skein_256_Process_Block_CodeSize(void)\r\n+    {\r\n+    return ((u08b_t *) Skein_256_Process_Block_CodeSize) -\r\n+           ((u08b_t *) Skein_256_Process_Block);\r\n+    }\r\n+static uint_t Skein_256_Unroll_Cnt(void)\r\n+    {\r\n+    return SKEIN_UNROLL_256;\r\n+    }\r\n+#endif\r\n+#endif\r\n+\r\n+/*****************************  Skein_512 ******************************/\r\n+#if !(SKEIN_USE_ASM & 512)\r\n+static void Skein_512_Process_Block(Skein_512_Ctxt_t *ctx,const u08b_t *blkPtr,size_t blkCnt,size_t byteCntAdd)\r\n+    { /* do it in C */\r\n+    enum\r\n+        {\r\n+        WCNT = SKEIN_512_STATE_WORDS\r\n+        };\r\n+#undef  RCNT\r\n+#define RCNT  (SKEIN_512_ROUNDS_TOTAL/8)\r\n+\r\n+#ifdef  SKEIN_LOOP                              /* configure how much to unroll the loop */\r\n+#define SKEIN_UNROLL_512 (((SKEIN_LOOP)/10)%10)\r\n+#else\r\n+#define SKEIN_UNROLL_512 (0)\r\n+#endif\r\n+\r\n+#if SKEIN_UNROLL_512\r\n+#if (RCNT % SKEIN_UNROLL_512)\r\n+#error \"Invalid SKEIN_UNROLL_512\"               /* sanity check on unroll count */\r\n+#endif\r\n+    size_t  r;\r\n+    u64b_t  kw[WCNT+4+RCNT*2];                  /* key schedule words : chaining vars + tweak + \"rotation\"*/\r\n+#else\r\n+    u64b_t  kw[WCNT+4];                         /* key schedule words : chaining vars + tweak */\r\n+#endif\r\n+    u64b_t  X0,X1,X2,X3,X4,X5,X6,X7;            /* local copy of vars, for speed */\r\n+    u64b_t  w [WCNT];                           /* local copy of input block */\r\n+#ifdef SKEIN_DEBUG\r\n+    const u64b_t *Xptr[8];                      /* use for debugging (help compiler put Xn in registers) */\r\n+    Xptr[0] = &X0;  Xptr[1] = &X1;  Xptr[2] = &X2;  Xptr[3] = &X3;\r\n+    Xptr[4] = &X4;  Xptr[5] = &X5;  Xptr[6] = &X6;  Xptr[7] = &X7;\r\n+#endif\r\n+\r\n+    Skein_assert(blkCnt != 0);                  /* never call with blkCnt == 0! */\r\n+    ts[0] = ctx->h.T[0];\r\n+    ts[1] = ctx->h.T[1];\r\n+    do  {\r\n+        /* this implementation only supports 2**64 input bytes (no carry out here) */\r\n+        ts[0] += byteCntAdd;                    /* update processed length */\r\n+\r\n+        /* precompute the key schedule for this block */\r\n+        ks[0] = ctx->X[0];\r\n+        ks[1] = ctx->X[1];\r\n+        ks[2] = ctx->X[2];\r\n+        ks[3] = ctx->X[3];\r\n+        ks[4] = ctx->X[4];\r\n+        ks[5] = ctx->X[5];\r\n+        ks[6] = ctx->X[6];\r\n+        ks[7] = ctx->X[7];\r\n+        ks[8] = ks[0] ^ ks[1] ^ ks[2] ^ ks[3] ^ \r\n+                ks[4] ^ ks[5] ^ ks[6] ^ ks[7] ^ SKEIN_KS_PARITY;\r\n+\r\n+        ts[2] = ts[0] ^ ts[1];\r\n+\r\n+        Skein_Get64_LSB_First(w,blkPtr,WCNT); /* get input block in little-endian format */\r\n+        DebugSaveTweak(ctx);\r\n+        Skein_Show_Block(BLK_BITS,&ctx->h,ctx->X,blkPtr,w,ks,ts);\r\n+\r\n+        X0   = w[0] + ks[0];                    /* do the first full key injection */\r\n+        X1   = w[1] + ks[1];\r\n+        X2   = w[2] + ks[2];\r\n+        X3   = w[3] + ks[3];\r\n+        X4   = w[4] + ks[4];\r\n+        X5   = w[5] + ks[5] + ts[0];\r\n+        X6   = w[6] + ks[6] + ts[1];\r\n+        X7   = w[7] + ks[7];\r\n+\r\n+        blkPtr += SKEIN_512_BLOCK_BYTES;\r\n+\r\n+        Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INITIAL,Xptr);\r\n+        /* run the rounds */\r\n+#define Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                  \\\r\n+    X##p0 += X##p1; X##p1 = RotL_64(X##p1,ROT##_0); X##p1 ^= X##p0; \\\r\n+    X##p2 += X##p3; X##p3 = RotL_64(X##p3,ROT##_1); X##p3 ^= X##p2; \\\r\n+    X##p4 += X##p5; X##p5 = RotL_64(X##p5,ROT##_2); X##p5 ^= X##p4; \\\r\n+    X##p6 += X##p7; X##p7 = RotL_64(X##p7,ROT##_3); X##p7 ^= X##p6; \\\r\n+\r\n+#if SKEIN_UNROLL_512 == 0                       \r\n+#define R512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)      /* unrolled */  \\\r\n+    Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                      \\\r\n+    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,rNum,Xptr);\r\n+\r\n+#define I512(R)                                                     \\\r\n+    X0   += ks[((R)+1) % 9];   /* inject the key schedule value */  \\\r\n+    X1   += ks[((R)+2) % 9];                                        \\\r\n+    X2   += ks[((R)+3) % 9];                                        \\\r\n+    X3   += ks[((R)+4) % 9];                                        \\\r\n+    X4   += ks[((R)+5) % 9];                                        \\\r\n+    X5   += ks[((R)+6) % 9] + ts[((R)+1) % 3];                      \\\r\n+    X6   += ks[((R)+7) % 9] + ts[((R)+2) % 3];                      \\\r\n+    X7   += ks[((R)+8) % 9] +     (R)+1;                            \\\r\n+    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);\r\n+#else                                       /* looping version */\r\n+#define R512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                      \\\r\n+    Round512(p0,p1,p2,p3,p4,p5,p6,p7,ROT,rNum)                      \\\r\n+    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,4*(r-1)+rNum,Xptr);\r\n+\r\n+#define I512(R)                                                     \\\r\n+    X0   += ks[r+(R)+0];        /* inject the key schedule value */ \\\r\n+    X1   += ks[r+(R)+1];                                            \\\r\n+    X2   += ks[r+(R)+2];                                            \\\r\n+    X3   += ks[r+(R)+3];                                            \\\r\n+    X4   += ks[r+(R)+4];                                            \\\r\n+    X5   += ks[r+(R)+5] + ts[r+(R)+0];                              \\\r\n+    X6   += ks[r+(R)+6] + ts[r+(R)+1];                              \\\r\n+    X7   += ks[r+(R)+7] +    r+(R)   ;                              \\\r\n+    ks[r +       (R)+8] = ks[r+(R)-1];  /* rotate key schedule */   \\\r\n+    ts[r +       (R)+2] = ts[r+(R)-1];                              \\\r\n+    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);\r\n+\r\n+    for (r=1;r < 2*RCNT;r+=2*SKEIN_UNROLL_512)   /* loop thru it */\r\n+#endif                         /* end of looped code definitions */\r\n+        {\r\n+#define R512_8_rounds(R)  /* do 8 full rounds */  \\\r\n+        R512(0,1,2,3,4,5,6,7,R_512_0,8*(R)+ 1);   \\\r\n+        R512(2,1,4,7,6,5,0,3,R_512_1,8*(R)+ 2);   \\\r\n+        R512(4,1,6,3,0,5,2,7,R_512_2,8*(R)+ 3);   \\\r\n+        R512(6,1,0,7,2,5,4,3,R_512_3,8*(R)+ 4);   \\\r\n+        I512(2*(R));                              \\\r\n+        R512(0,1,2,3,4,5,6,7,R_512_4,8*(R)+ 5);   \\\r\n+        R512(2,1,4,7,6,5,0,3,R_512_5,8*(R)+ 6);   \\\r\n+        R512(4,1,6,3,0,5,2,7,R_512_6,8*(R)+ 7);   \\\r\n+        R512(6,1,0,7,2,5,4,3,R_512_7,8*(R)+ 8);   \\\r\n+        I512(2*(R)+1);        /* and key injection */\r\n+\r\n+        R512_8_rounds( 0);\r\n+\r\n+#define R512_Unroll_R(NN) ((SKEIN_UNROLL_512 == 0 && SKEIN_512_ROUNDS_TOTAL/8 > (NN)) || (SKEIN_UNROLL_512 > (NN)))\r\n+\r\n+  #if   R512_Unroll_R( 1)\r\n+        R512_8_rounds( 1);\r\n+  #endif\r\n+  #if   R512_Unroll_R( 2)\r\n+        R512_8_rounds( 2);\r\n+  #endif\r\n+  #if   R512_Unroll_R( 3)\r\n+        R512_8_rounds( 3);\r\n+  #endif\r\n+  #if   R512_Unroll_R( 4)\r\n+        R512_8_rounds( 4);\r\n+  #endif\r\n+  #if   R512_Unroll_R( 5)\r\n+        R512_8_rounds( 5);\r\n+  #endif\r\n+  #if   R512_Unroll_R( 6)\r\n+        R512_8_rounds( 6);\r\n+  #endif\r\n+  #if   R512_Unroll_R( 7)\r\n+        R512_8_rounds( 7);\r\n+  #endif\r\n+  #if   R512_Unroll_R( 8)\r\n+        R512_8_rounds( 8);\r\n+  #endif\r\n+  #if   R512_Unroll_R( 9)\r\n+        R512_8_rounds( 9);\r\n+  #endif\r\n+  #if   R512_Unroll_R(10)\r\n+        R512_8_rounds(10);\r\n+  #endif\r\n+  #if   R512_Unroll_R(11)\r\n+        R512_8_rounds(11);\r\n+  #endif\r\n+  #if   R512_Unroll_R(12)\r\n+        R512_8_rounds(12);\r\n+  #endif\r\n+  #if   R512_Unroll_R(13)\r\n+        R512_8_rounds(13);\r\n+  #endif\r\n+  #if   R512_Unroll_R(14)\r\n+        R512_8_rounds(14);\r\n+  #endif\r\n+  #if  (SKEIN_UNROLL_512 > 14)\r\n+#error  \"need more unrolling in Skein_512_Process_Block\"\r\n+  #endif\r\n+        }\r\n+\r\n+        /* do the final \"feedforward\" xor, update context chaining vars */\r\n+        ctx->X[0] = X0 ^ w[0];\r\n+        ctx->X[1] = X1 ^ w[1];\r\n+        ctx->X[2] = X2 ^ w[2];\r\n+        ctx->X[3] = X3 ^ w[3];\r\n+        ctx->X[4] = X4 ^ w[4];\r\n+        ctx->X[5] = X5 ^ w[5];\r\n+        ctx->X[6] = X6 ^ w[6];\r\n+        ctx->X[7] = X7 ^ w[7];\r\n+        Skein_Show_Round(BLK_BITS,&ctx->h,SKEIN_RND_FEED_FWD,ctx->X);\r\n+\r\n+        ts[1] &= ~SKEIN_T1_FLAG_FIRST;\r\n+        }\r\n+    while (--blkCnt);\r\n+    ctx->h.T[0] = ts[0];\r\n+    ctx->h.T[1] = ts[1];\r\n+    }\r\n+\r\n+#if defined(SKEIN_CODE_SIZE) || defined(SKEIN_PERF)\r\n+static size_t Skein_512_Process_Block_CodeSize(void)\r\n+    {\r\n+    return ((u08b_t *) Skein_512_Process_Block_CodeSize) -\r\n+           ((u08b_t *) Skein_512_Process_Block);\r\n+    }\r\n+static uint_t Skein_512_Unroll_Cnt(void)\r\n+    {\r\n+    return SKEIN_UNROLL_512;\r\n+    }\r\n+#endif\r\n+#endif\r\n+\r\n+/*****************************  Skein1024 ******************************/\r\n+#if !(SKEIN_USE_ASM & 1024)\r\n+static void Skein1024_Process_Block(Skein1024_Ctxt_t *ctx,const u08b_t *blkPtr,size_t blkCnt,size_t byteCntAdd)\r\n+    { /* do it in C, always looping (unrolled is bigger AND slower!) */\r\n+    enum\r\n+        {\r\n+        WCNT = SKEIN1024_STATE_WORDS\r\n+        };\r\n+#undef  RCNT\r\n+#define RCNT  (SKEIN1024_ROUNDS_TOTAL/8)\r\n+\r\n+#ifdef  SKEIN_LOOP                              /* configure how much to unroll the loop */\r\n+#define SKEIN_UNROLL_1024 ((SKEIN_LOOP)%10)\r\n+#else\r\n+#define SKEIN_UNROLL_1024 (0)\r\n+#endif\r\n+\r\n+#if (SKEIN_UNROLL_1024 != 0)\r\n+#if (RCNT % SKEIN_UNROLL_1024)\r\n+#error \"Invalid SKEIN_UNROLL_1024\"              /* sanity check on unroll count */\r\n+#endif\r\n+    size_t  r;\r\n+    u64b_t  kw[WCNT+4+RCNT*2];                  /* key schedule words : chaining vars + tweak + \"rotation\"*/\r\n+#else\r\n+    u64b_t  kw[WCNT+4];                         /* key schedule words : chaining vars + tweak */\r\n+#endif\r\n+\r\n+    u64b_t  X00,X01,X02,X03,X04,X05,X06,X07,    /* local copy of vars, for speed */\r\n+            X08,X09,X10,X11,X12,X13,X14,X15;\r\n+    u64b_t  w [WCNT];                           /* local copy of input block */\r\n+#ifdef SKEIN_DEBUG\r\n+    const u64b_t *Xptr[16];                     /* use for debugging (help compiler put Xn in registers) */\r\n+    Xptr[ 0] = &X00;  Xptr[ 1] = &X01;  Xptr[ 2] = &X02;  Xptr[ 3] = &X03;\r\n+    Xptr[ 4] = &X04;  Xptr[ 5] = &X05;  Xptr[ 6] = &X06;  Xptr[ 7] = &X07;\r\n+    Xptr[ 8] = &X08;  Xptr[ 9] = &X09;  Xptr[10] = &X10;  Xptr[11] = &X11;\r\n+    Xptr[12] = &X12;  Xptr[13] = &X13;  Xptr[14] = &X14;  Xptr[15] = &X15;\r\n+#endif\r\n+\r\n+    Skein_assert(blkCnt != 0);                  /* never call with blkCnt == 0! */\r\n+    ts[0] = ctx->h.T[0];\r\n+    ts[1] = ctx->h.T[1];\r\n+    do  {\r\n+        /* this implementation only supports 2**64 input bytes (no carry out here) */\r\n+        ts[0] += byteCntAdd;                    /* update processed length */\r\n+\r\n+        /* precompute the key schedule for this block */\r\n+        ks[ 0] = ctx->X[ 0];\r\n+        ks[ 1] = ctx->X[ 1];\r\n+        ks[ 2] = ctx->X[ 2];\r\n+        ks[ 3] = ctx->X[ 3];\r\n+        ks[ 4] = ctx->X[ 4];\r\n+        ks[ 5] = ctx->X[ 5];\r\n+        ks[ 6] = ctx->X[ 6];\r\n+        ks[ 7] = ctx->X[ 7];\r\n+        ks[ 8] = ctx->X[ 8];\r\n+        ks[ 9] = ctx->X[ 9];\r\n+        ks[10] = ctx->X[10];\r\n+        ks[11] = ctx->X[11];\r\n+        ks[12] = ctx->X[12];\r\n+        ks[13] = ctx->X[13];\r\n+        ks[14] = ctx->X[14];\r\n+        ks[15] = ctx->X[15];\r\n+        ks[16] = ks[ 0] ^ ks[ 1] ^ ks[ 2] ^ ks[ 3] ^\r\n+                 ks[ 4] ^ ks[ 5] ^ ks[ 6] ^ ks[ 7] ^\r\n+                 ks[ 8] ^ ks[ 9] ^ ks[10] ^ ks[11] ^\r\n+                 ks[12] ^ ks[13] ^ ks[14] ^ ks[15] ^ SKEIN_KS_PARITY;\r\n+\r\n+        ts[2]  = ts[0] ^ ts[1];\r\n+\r\n+        Skein_Get64_LSB_First(w,blkPtr,WCNT); /* get input block in little-endian format */\r\n+        DebugSaveTweak(ctx);\r\n+        Skein_Show_Block(BLK_BITS,&ctx->h,ctx->X,blkPtr,w,ks,ts);\r\n+\r\n+        X00    = w[ 0] + ks[ 0];                 /* do the first full key injection */\r\n+        X01    = w[ 1] + ks[ 1];\r\n+        X02    = w[ 2] + ks[ 2];\r\n+        X03    = w[ 3] + ks[ 3];\r\n+        X04    = w[ 4] + ks[ 4];\r\n+        X05    = w[ 5] + ks[ 5];\r\n+        X06    = w[ 6] + ks[ 6];\r\n+        X07    = w[ 7] + ks[ 7];\r\n+        X08    = w[ 8] + ks[ 8];\r\n+        X09    = w[ 9] + ks[ 9];\r\n+        X10    = w[10] + ks[10];\r\n+        X11    = w[11] + ks[11];\r\n+        X12    = w[12] + ks[12];\r\n+        X13    = w[13] + ks[13] + ts[0];\r\n+        X14    = w[14] + ks[14] + ts[1];\r\n+        X15    = w[15] + ks[15];\r\n+\r\n+        Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INITIAL,Xptr);\r\n+\r\n+#define Round1024(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,ROT,rNum) \\\r\n+    X##p0 += X##p1; X##p1 = RotL_64(X##p1,ROT##_0); X##p1 ^= X##p0;   \\\r\n+    X##p2 += X##p3; X##p3 = RotL_64(X##p3,ROT##_1); X##p3 ^= X##p2;   \\\r\n+    X##p4 += X##p5; X##p5 = RotL_64(X##p5,ROT##_2); X##p5 ^= X##p4;   \\\r\n+    X##p6 += X##p7; X##p7 = RotL_64(X##p7,ROT##_3); X##p7 ^= X##p6;   \\\r\n+    X##p8 += X##p9; X##p9 = RotL_64(X##p9,ROT##_4); X##p9 ^= X##p8;   \\\r\n+    X##pA += X##pB; X##pB = RotL_64(X##pB,ROT##_5); X##pB ^= X##pA;   \\\r\n+    X##pC += X##pD; X##pD = RotL_64(X##pD,ROT##_6); X##pD ^= X##pC;   \\\r\n+    X##pE += X##pF; X##pF = RotL_64(X##pF,ROT##_7); X##pF ^= X##pE;   \\\r\n+\r\n+#if SKEIN_UNROLL_1024 == 0                      \r\n+#define R1024(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,ROT,rn) \\\r\n+    Round1024(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,ROT,rn) \\\r\n+    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,rn,Xptr);\r\n+\r\n+#define I1024(R)                                                      \\\r\n+    X00   += ks[((R)+ 1) % 17]; /* inject the key schedule value */   \\\r\n+    X01   += ks[((R)+ 2) % 17];                                       \\\r\n+    X02   += ks[((R)+ 3) % 17];                                       \\\r\n+    X03   += ks[((R)+ 4) % 17];                                       \\\r\n+    X04   += ks[((R)+ 5) % 17];                                       \\\r\n+    X05   += ks[((R)+ 6) % 17];                                       \\\r\n+    X06   += ks[((R)+ 7) % 17];                                       \\\r\n+    X07   += ks[((R)+ 8) % 17];                                       \\\r\n+    X08   += ks[((R)+ 9) % 17];                                       \\\r\n+    X09   += ks[((R)+10) % 17];                                       \\\r\n+    X10   += ks[((R)+11) % 17];                                       \\\r\n+    X11   += ks[((R)+12) % 17];                                       \\\r\n+    X12   += ks[((R)+13) % 17];                                       \\\r\n+    X13   += ks[((R)+14) % 17] + ts[((R)+1) % 3];                     \\\r\n+    X14   += ks[((R)+15) % 17] + ts[((R)+2) % 3];                     \\\r\n+    X15   += ks[((R)+16) % 17] +     (R)+1;                           \\\r\n+    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr); \r\n+#else                                       /* looping version */\r\n+#define R1024(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,ROT,rn) \\\r\n+    Round1024(p0,p1,p2,p3,p4,p5,p6,p7,p8,p9,pA,pB,pC,pD,pE,pF,ROT,rn) \\\r\n+    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,4*(r-1)+rn,Xptr);\r\n+\r\n+#define I1024(R)                                                      \\\r\n+    X00   += ks[r+(R)+ 0];    /* inject the key schedule value */     \\\r\n+    X01   += ks[r+(R)+ 1];                                            \\\r\n+    X02   += ks[r+(R)+ 2];                                            \\\r\n+    X03   += ks[r+(R)+ 3];                                            \\\r\n+    X04   += ks[r+(R)+ 4];                                            \\\r\n+    X05   += ks[r+(R)+ 5];                                            \\\r\n+    X06   += ks[r+(R)+ 6];                                            \\\r\n+    X07   += ks[r+(R)+ 7];                                            \\\r\n+    X08   += ks[r+(R)+ 8];                                            \\\r\n+    X09   += ks[r+(R)+ 9];                                            \\\r\n+    X10   += ks[r+(R)+10];                                            \\\r\n+    X11   += ks[r+(R)+11];                                            \\\r\n+    X12   += ks[r+(R)+12];                                            \\\r\n+    X13   += ks[r+(R)+13] + ts[r+(R)+0];                              \\\r\n+    X14   += ks[r+(R)+14] + ts[r+(R)+1];                              \\\r\n+    X15   += ks[r+(R)+15] +    r+(R)   ;                              \\\r\n+    ks[r  +       (R)+16] = ks[r+(R)-1];  /* rotate key schedule */   \\\r\n+    ts[r  +       (R)+ 2] = ts[r+(R)-1];                              \\\r\n+    Skein_Show_R_Ptr(BLK_BITS,&ctx->h,SKEIN_RND_KEY_INJECT,Xptr);\r\n+\r\n+    for (r=1;r <= 2*RCNT;r+=2*SKEIN_UNROLL_1024)    /* loop thru it */\r\n+#endif  \r\n+        {\r\n+#define R1024_8_rounds(R)    /* do 8 full rounds */                               \\\r\n+        R1024(00,01,02,03,04,05,06,07,08,09,10,11,12,13,14,15,R1024_0,8*(R) + 1); \\\r\n+        R1024(00,09,02,13,06,11,04,15,10,07,12,03,14,05,08,01,R1024_1,8*(R) + 2); \\\r\n+        R1024(00,07,02,05,04,03,06,01,12,15,14,13,08,11,10,09,R1024_2,8*(R) + 3); \\\r\n+        R1024(00,15,02,11,06,13,04,09,14,01,08,05,10,03,12,07,R1024_3,8*(R) + 4); \\\r\n+        I1024(2*(R));                                                             \\\r\n+        R1024(00,01,02,03,04,05,06,07,08,09,10,11,12,13,14,15,R1024_4,8*(R) + 5); \\\r\n+        R1024(00,09,02,13,06,11,04,15,10,07,12,03,14,05,08,01,R1024_5,8*(R) + 6); \\\r\n+        R1024(00,07,02,05,04,03,06,01,12,15,14,13,08,11,10,09,R1024_6,8*(R) + 7); \\\r\n+        R1024(00,15,02,11,06,13,04,09,14,01,08,05,10,03,12,07,R1024_7,8*(R) + 8); \\\r\n+        I1024(2*(R)+1);\r\n+\r\n+        R1024_8_rounds( 0);\r\n+\r\n+#define R1024_Unroll_R(NN) ((SKEIN_UNROLL_1024 == 0 && SKEIN1024_ROUNDS_TOTAL/8 > (NN)) || (SKEIN_UNROLL_1024 > (NN)))\r\n+\r\n+  #if   R1024_Unroll_R( 1)\r\n+        R1024_8_rounds( 1);\r\n+  #endif\r\n+  #if   R1024_Unroll_R( 2)\r\n+        R1024_8_rounds( 2);\r\n+  #endif\r\n+  #if   R1024_Unroll_R( 3)\r\n+        R1024_8_rounds( 3);\r\n+  #endif\r\n+  #if   R1024_Unroll_R( 4)\r\n+        R1024_8_rounds( 4);\r\n+  #endif\r\n+  #if   R1024_Unroll_R( 5)\r\n+        R1024_8_rounds( 5);\r\n+  #endif\r\n+  #if   R1024_Unroll_R( 6)\r\n+        R1024_8_rounds( 6);\r\n+  #endif\r\n+  #if   R1024_Unroll_R( 7)\r\n+        R1024_8_rounds( 7);\r\n+  #endif\r\n+  #if   R1024_Unroll_R( 8)\r\n+        R1024_8_rounds( 8);\r\n+  #endif\r\n+  #if   R1024_Unroll_R( 9)\r\n+        R1024_8_rounds( 9);\r\n+  #endif\r\n+  #if   R1024_Unroll_R(10)\r\n+        R1024_8_rounds(10);\r\n+  #endif\r\n+  #if   R1024_Unroll_R(11)\r\n+        R1024_8_rounds(11);\r\n+  #endif\r\n+  #if   R1024_Unroll_R(12)\r\n+        R1024_8_rounds(12);\r\n+  #endif\r\n+  #if   R1024_Unroll_R(13)\r\n+        R1024_8_rounds(13);\r\n+  #endif\r\n+  #if   R1024_Unroll_R(14)\r\n+        R1024_8_rounds(14);\r\n+  #endif\r\n+  #if  (SKEIN_UNROLL_1024 > 14)\r\n+#error  \"need more unrolling in Skein_1024_Process_Block\"\r\n+  #endif\r\n+        }\r\n+        /* do the final \"feedforward\" xor, update context chaining vars */\r\n+\r\n+        ctx->X[ 0] = X00 ^ w[ 0];\r\n+        ctx->X[ 1] = X01 ^ w[ 1];\r\n+        ctx->X[ 2] = X02 ^ w[ 2];\r\n+        ctx->X[ 3] = X03 ^ w[ 3];\r\n+        ctx->X[ 4] = X04 ^ w[ 4];\r\n+        ctx->X[ 5] = X05 ^ w[ 5];\r\n+        ctx->X[ 6] = X06 ^ w[ 6];\r\n+        ctx->X[ 7] = X07 ^ w[ 7];\r\n+        ctx->X[ 8] = X08 ^ w[ 8];\r\n+        ctx->X[ 9] = X09 ^ w[ 9];\r\n+        ctx->X[10] = X10 ^ w[10];\r\n+        ctx->X[11] = X11 ^ w[11];\r\n+        ctx->X[12] = X12 ^ w[12];\r\n+        ctx->X[13] = X13 ^ w[13];\r\n+        ctx->X[14] = X14 ^ w[14];\r\n+        ctx->X[15] = X15 ^ w[15];\r\n+\r\n+        Skein_Show_Round(BLK_BITS,&ctx->h,SKEIN_RND_FEED_FWD,ctx->X);\r\n+        \r\n+        ts[1] &= ~SKEIN_T1_FLAG_FIRST;\r\n+        blkPtr += SKEIN1024_BLOCK_BYTES;\r\n+        }\r\n+    while (--blkCnt);\r\n+    ctx->h.T[0] = ts[0];\r\n+    ctx->h.T[1] = ts[1];\r\n+    }\r\n+\r\n+#if defined(SKEIN_CODE_SIZE) || defined(SKEIN_PERF)\r\n+static size_t Skein1024_Process_Block_CodeSize(void)\r\n+    {\r\n+    return ((u08b_t *) Skein1024_Process_Block_CodeSize) -\r\n+           ((u08b_t *) Skein1024_Process_Block);\r\n+    }\r\n+static uint_t Skein1024_Unroll_Cnt(void)\r\n+    {\r\n+    return SKEIN_UNROLL_1024;\r\n+    }\r\n+#endif\r\n+#endif\r\n+\r\n+\r\n+#if 0\r\n+/*****************************************************************/\r\n+/*     256-bit Skein                                             */\r\n+/*****************************************************************/\r\n+\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* init the context for a straight hashing operation  */\r\n+static int Skein_256_Init(Skein_256_Ctxt_t *ctx, size_t hashBitLen)\r\n+    {\r\n+    union\r\n+        {\r\n+        u08b_t  b[SKEIN_256_STATE_BYTES];\r\n+        u64b_t  w[SKEIN_256_STATE_WORDS];\r\n+        } cfg;                              /* config block */\r\n+        \r\n+    Skein_Assert(hashBitLen > 0,SKEIN_BAD_HASHLEN);\r\n+    ctx->h.hashBitLen = hashBitLen;         /* output hash bit count */\r\n+\r\n+    switch (hashBitLen)\r\n+        {             /* use pre-computed values, where available */\r\n+#ifndef SKEIN_NO_PRECOMP\r\n+        case  256: memcpy(ctx->X,SKEIN_256_IV_256,sizeof(ctx->X));  break;\r\n+        case  224: memcpy(ctx->X,SKEIN_256_IV_224,sizeof(ctx->X));  break;\r\n+        case  160: memcpy(ctx->X,SKEIN_256_IV_160,sizeof(ctx->X));  break;\r\n+        case  128: memcpy(ctx->X,SKEIN_256_IV_128,sizeof(ctx->X));  break;\r\n+#endif\r\n+        default:\r\n+            /* here if there is no precomputed IV value available */\r\n+            /* build/process the config block, type == CONFIG (could be precomputed) */\r\n+            Skein_Start_New_Type(ctx,CFG_FINAL);        /* set tweaks: T0=0; T1=CFG | FINAL */\r\n+\r\n+            cfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);  /* set the schema, version */\r\n+            cfg.w[1] = Skein_Swap64(hashBitLen);        /* hash result length in bits */\r\n+            cfg.w[2] = Skein_Swap64(SKEIN_CFG_TREE_INFO_SEQUENTIAL);\r\n+            memset(&cfg.w[3],0,sizeof(cfg) - 3*sizeof(cfg.w[0])); /* zero pad config block */\r\n+\r\n+            /* compute the initial chaining values from config block */\r\n+            memset(ctx->X,0,sizeof(ctx->X));            /* zero the chaining variables */\r\n+            Skein_256_Process_Block(ctx,cfg.b,1,SKEIN_CFG_STR_LEN);\r\n+            break;\r\n+        }\r\n+    /* The chaining vars ctx->X are now initialized for the given hashBitLen. */\r\n+    /* Set up to process the data message portion of the hash (default) */\r\n+    Skein_Start_New_Type(ctx,MSG);              /* T0=0, T1= MSG type */\r\n+\r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* init the context for a MAC and/or tree hash operation */\r\n+/* [identical to Skein_256_Init() when keyBytes == 0 && treeInfo == SKEIN_CFG_TREE_INFO_SEQUENTIAL] */\r\n+static int Skein_256_InitExt(Skein_256_Ctxt_t *ctx,size_t hashBitLen,u64b_t treeInfo, const u08b_t *key, size_t keyBytes)\r\n+    {\r\n+    union\r\n+        {\r\n+        u08b_t  b[SKEIN_256_STATE_BYTES];\r\n+        u64b_t  w[SKEIN_256_STATE_WORDS];\r\n+        } cfg;                              /* config block */\r\n+        \r\n+    Skein_Assert(hashBitLen > 0,SKEIN_BAD_HASHLEN);\r\n+    Skein_Assert(keyBytes == 0 || key != NULL,SKEIN_FAIL);\r\n+\r\n+    /* compute the initial chaining values ctx->X[], based on key */\r\n+    if (keyBytes == 0)                          /* is there a key? */\r\n+        {                                   \r\n+        memset(ctx->X,0,sizeof(ctx->X));        /* no key: use all zeroes as key for config block */\r\n+        }\r\n+    else                                        /* here to pre-process a key */\r\n+        {\r\n+        Skein_assert(sizeof(cfg.b) >= sizeof(ctx->X));\r\n+        /* do a mini-Init right here */\r\n+        ctx->h.hashBitLen=8*sizeof(ctx->X);     /* set output hash bit count = state size */\r\n+        Skein_Start_New_Type(ctx,KEY);          /* set tweaks: T0 = 0; T1 = KEY type */\r\n+        memset(ctx->X,0,sizeof(ctx->X));        /* zero the initial chaining variables */\r\n+        Skein_256_Update(ctx,key,keyBytes);     /* hash the key */\r\n+        Skein_256_Final_Pad(ctx,cfg.b);         /* put result into cfg.b[] */\r\n+        memcpy(ctx->X,cfg.b,sizeof(cfg.b));     /* copy over into ctx->X[] */\r\n+#if SKEIN_NEED_SWAP\r\n+        {\r\n+        uint_t i;\r\n+        for (i=0;i<SKEIN_256_STATE_WORDS;i++)   /* convert key bytes to context words */\r\n+            ctx->X[i] = Skein_Swap64(ctx->X[i]);\r\n+        }\r\n+#endif\r\n+        }\r\n+    /* build/process the config block, type == CONFIG (could be precomputed for each key) */\r\n+    ctx->h.hashBitLen = hashBitLen;             /* output hash bit count */\r\n+    Skein_Start_New_Type(ctx,CFG_FINAL);\r\n+\r\n+    memset(&cfg.w,0,sizeof(cfg.w));             /* pre-pad cfg.w[] with zeroes */\r\n+    cfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);\r\n+    cfg.w[1] = Skein_Swap64(hashBitLen);        /* hash result length in bits */\r\n+    cfg.w[2] = Skein_Swap64(treeInfo);          /* tree hash config info (or SKEIN_CFG_TREE_INFO_SEQUENTIAL) */\r\n+\r\n+    Skein_Show_Key(256,&ctx->h,key,keyBytes);\r\n+\r\n+    /* compute the initial chaining values from config block */\r\n+    Skein_256_Process_Block(ctx,cfg.b,1,SKEIN_CFG_STR_LEN);\r\n+\r\n+    /* The chaining vars ctx->X are now initialized */\r\n+    /* Set up to process the data message portion of the hash (default) */\r\n+    ctx->h.bCnt = 0;                            /* buffer b[] starts out empty */\r\n+    Skein_Start_New_Type(ctx,MSG);\r\n+    \r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+#endif\r\n+\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* process the input bytes */\r\n+static int Skein_256_Update(Skein_256_Ctxt_t *ctx, const u08b_t *msg, size_t msgByteCnt)\r\n+    {\r\n+    size_t n;\r\n+\r\n+    Skein_Assert(ctx->h.bCnt <= SKEIN_256_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\r\n+\r\n+    /* process full blocks, if any */\r\n+    if (msgByteCnt + ctx->h.bCnt > SKEIN_256_BLOCK_BYTES)\r\n+        {\r\n+        if (ctx->h.bCnt)                              /* finish up any buffered message data */\r\n+            {\r\n+            n = SKEIN_256_BLOCK_BYTES - ctx->h.bCnt;  /* # bytes free in buffer b[] */\r\n+            if (n)\r\n+                {\r\n+                Skein_assert(n < msgByteCnt);         /* check on our logic here */\r\n+                memcpy(&ctx->b[ctx->h.bCnt],msg,n);\r\n+                msgByteCnt  -= n;\r\n+                msg         += n;\r\n+                ctx->h.bCnt += n;\r\n+                }\r\n+            Skein_assert(ctx->h.bCnt == SKEIN_256_BLOCK_BYTES);\r\n+            Skein_256_Process_Block(ctx,ctx->b,1,SKEIN_256_BLOCK_BYTES);\r\n+            ctx->h.bCnt = 0;\r\n+            }\r\n+        /* now process any remaining full blocks, directly from input message data */\r\n+        if (msgByteCnt > SKEIN_256_BLOCK_BYTES)\r\n+            {\r\n+            n = (msgByteCnt-1) / SKEIN_256_BLOCK_BYTES;   /* number of full blocks to process */\r\n+            Skein_256_Process_Block(ctx,msg,n,SKEIN_256_BLOCK_BYTES);\r\n+            msgByteCnt -= n * SKEIN_256_BLOCK_BYTES;\r\n+            msg        += n * SKEIN_256_BLOCK_BYTES;\r\n+            }\r\n+        Skein_assert(ctx->h.bCnt == 0);\r\n+        }\r\n+\r\n+    /* copy any remaining source message data bytes into b[] */\r\n+    if (msgByteCnt)\r\n+        {\r\n+        Skein_assert(msgByteCnt + ctx->h.bCnt <= SKEIN_256_BLOCK_BYTES);\r\n+        memcpy(&ctx->b[ctx->h.bCnt],msg,msgByteCnt);\r\n+        ctx->h.bCnt += msgByteCnt;\r\n+        }\r\n+\r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+   \r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* finalize the hash computation and output the result */\r\n+static int Skein_256_Final(Skein_256_Ctxt_t *ctx, u08b_t *hashVal)\r\n+    {\r\n+    size_t i,n,byteCnt;\r\n+    u64b_t X[SKEIN_256_STATE_WORDS];\r\n+    Skein_Assert(ctx->h.bCnt <= SKEIN_256_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\r\n+\r\n+    ctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;                 /* tag as the final block */\r\n+    if (ctx->h.bCnt < SKEIN_256_BLOCK_BYTES)            /* zero pad b[] if necessary */\r\n+        memset(&ctx->b[ctx->h.bCnt],0,SKEIN_256_BLOCK_BYTES - ctx->h.bCnt);\r\n+\r\n+    Skein_256_Process_Block(ctx,ctx->b,1,ctx->h.bCnt);  /* process the final block */\r\n+    \r\n+    /* now output the result */\r\n+    byteCnt = (ctx->h.hashBitLen + 7) >> 3;             /* total number of output bytes */\r\n+\r\n+    /* run Threefish in \"counter mode\" to generate output */\r\n+    memset(ctx->b,0,sizeof(ctx->b));  /* zero out b[], so it can hold the counter */\r\n+    memcpy(X,ctx->X,sizeof(X));       /* keep a local copy of counter mode \"key\" */\r\n+    for (i=0;i < byteCnt;i += SKEIN_256_BLOCK_BYTES)\r\n+        {\r\n+        ((u64b_t *)ctx->b)[0]= Skein_Swap64((u64b_t) i); /* build the counter block */\r\n+        Skein_Start_New_Type(ctx,OUT_FINAL);\r\n+        Skein_256_Process_Block(ctx,ctx->b,1,sizeof(u64b_t)); /* run \"counter mode\" */\r\n+        n = byteCnt - i;   /* number of output bytes left to go */\r\n+        if (n >= SKEIN_256_BLOCK_BYTES)\r\n+            n  = SKEIN_256_BLOCK_BYTES;\r\n+        Skein_Put64_LSB_First(hashVal+i,ctx->X,n);   /* \"output\" the ctr mode bytes */\r\n+        Skein_Show_Final(256,&ctx->h,n,hashVal+i*SKEIN_256_BLOCK_BYTES);\r\n+        memcpy(ctx->X,X,sizeof(X));   /* restore the counter mode key for next time */\r\n+        }\r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+\r\n+#if defined(SKEIN_CODE_SIZE) || defined(SKEIN_PERF)\r\n+static size_t Skein_256_API_CodeSize(void)\r\n+    {\r\n+    return ((u08b_t *) Skein_256_API_CodeSize) -\r\n+           ((u08b_t *) Skein_256_Init);\r\n+    }\r\n+#endif\r\n+\r\n+/*****************************************************************/\r\n+/*     512-bit Skein                                             */\r\n+/*****************************************************************/\r\n+\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* init the context for a straight hashing operation  */\r\n+static int Skein_512_Init(Skein_512_Ctxt_t *ctx, size_t hashBitLen)\r\n+    {\r\n+    union\r\n+        {\r\n+        u08b_t  b[SKEIN_512_STATE_BYTES];\r\n+        u64b_t  w[SKEIN_512_STATE_WORDS];\r\n+        } cfg;                              /* config block */\r\n+        \r\n+    Skein_Assert(hashBitLen > 0,SKEIN_BAD_HASHLEN);\r\n+    ctx->h.hashBitLen = hashBitLen;         /* output hash bit count */\r\n+\r\n+    switch (hashBitLen)\r\n+        {             /* use pre-computed values, where available */\r\n+#ifndef SKEIN_NO_PRECOMP\r\n+        case  512: memcpy(ctx->X,SKEIN_512_IV_512,sizeof(ctx->X));  break;\r\n+        case  384: memcpy(ctx->X,SKEIN_512_IV_384,sizeof(ctx->X));  break;\r\n+        case  256: memcpy(ctx->X,SKEIN_512_IV_256,sizeof(ctx->X));  break;\r\n+        case  224: memcpy(ctx->X,SKEIN_512_IV_224,sizeof(ctx->X));  break;\r\n+#endif\r\n+        default:\r\n+            /* here if there is no precomputed IV value available */\r\n+            /* build/process the config block, type == CONFIG (could be precomputed) */\r\n+            Skein_Start_New_Type(ctx,CFG_FINAL);        /* set tweaks: T0=0; T1=CFG | FINAL */\r\n+\r\n+            cfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);  /* set the schema, version */\r\n+            cfg.w[1] = Skein_Swap64(hashBitLen);        /* hash result length in bits */\r\n+            cfg.w[2] = Skein_Swap64(SKEIN_CFG_TREE_INFO_SEQUENTIAL);\r\n+            memset(&cfg.w[3],0,sizeof(cfg) - 3*sizeof(cfg.w[0])); /* zero pad config block */\r\n+\r\n+            /* compute the initial chaining values from config block */\r\n+            memset(ctx->X,0,sizeof(ctx->X));            /* zero the chaining variables */\r\n+            Skein_512_Process_Block(ctx,cfg.b,1,SKEIN_CFG_STR_LEN);\r\n+            break;\r\n+        }\r\n+\r\n+    /* The chaining vars ctx->X are now initialized for the given hashBitLen. */\r\n+    /* Set up to process the data message portion of the hash (default) */\r\n+    Skein_Start_New_Type(ctx,MSG);              /* T0=0, T1= MSG type */\r\n+\r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+\r\n+#if 0\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* init the context for a MAC and/or tree hash operation */\r\n+/* [identical to Skein_512_Init() when keyBytes == 0 && treeInfo == SKEIN_CFG_TREE_INFO_SEQUENTIAL] */\r\n+static int Skein_512_InitExt(Skein_512_Ctxt_t *ctx,size_t hashBitLen,u64b_t treeInfo, const u08b_t *key, size_t keyBytes)\r\n+    {\r\n+    union\r\n+        {\r\n+        u08b_t  b[SKEIN_512_STATE_BYTES];\r\n+        u64b_t  w[SKEIN_512_STATE_WORDS];\r\n+        } cfg;                              /* config block */\r\n+        \r\n+    Skein_Assert(hashBitLen > 0,SKEIN_BAD_HASHLEN);\r\n+    Skein_Assert(keyBytes == 0 || key != NULL,SKEIN_FAIL);\r\n+\r\n+    /* compute the initial chaining values ctx->X[], based on key */\r\n+    if (keyBytes == 0)                          /* is there a key? */\r\n+        {                                   \r\n+        memset(ctx->X,0,sizeof(ctx->X));        /* no key: use all zeroes as key for config block */\r\n+        }\r\n+    else                                        /* here to pre-process a key */\r\n+        {\r\n+        Skein_assert(sizeof(cfg.b) >= sizeof(ctx->X));\r\n+        /* do a mini-Init right here */\r\n+        ctx->h.hashBitLen=8*sizeof(ctx->X);     /* set output hash bit count = state size */\r\n+        Skein_Start_New_Type(ctx,KEY);          /* set tweaks: T0 = 0; T1 = KEY type */\r\n+        memset(ctx->X,0,sizeof(ctx->X));        /* zero the initial chaining variables */\r\n+        Skein_512_Update(ctx,key,keyBytes);     /* hash the key */\r\n+        Skein_512_Final_Pad(ctx,cfg.b);         /* put result into cfg.b[] */\r\n+        memcpy(ctx->X,cfg.b,sizeof(cfg.b));     /* copy over into ctx->X[] */\r\n+#if SKEIN_NEED_SWAP\r\n+        {\r\n+        uint_t i;\r\n+        for (i=0;i<SKEIN_512_STATE_WORDS;i++)   /* convert key bytes to context words */\r\n+            ctx->X[i] = Skein_Swap64(ctx->X[i]);\r\n+        }\r\n+#endif\r\n+        }\r\n+    /* build/process the config block, type == CONFIG (could be precomputed for each key) */\r\n+    ctx->h.hashBitLen = hashBitLen;             /* output hash bit count */\r\n+    Skein_Start_New_Type(ctx,CFG_FINAL);\r\n+\r\n+    memset(&cfg.w,0,sizeof(cfg.w));             /* pre-pad cfg.w[] with zeroes */\r\n+    cfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);\r\n+    cfg.w[1] = Skein_Swap64(hashBitLen);        /* hash result length in bits */\r\n+    cfg.w[2] = Skein_Swap64(treeInfo);          /* tree hash config info (or SKEIN_CFG_TREE_INFO_SEQUENTIAL) */\r\n+\r\n+    Skein_Show_Key(512,&ctx->h,key,keyBytes);\r\n+\r\n+    /* compute the initial chaining values from config block */\r\n+    Skein_512_Process_Block(ctx,cfg.b,1,SKEIN_CFG_STR_LEN);\r\n+\r\n+    /* The chaining vars ctx->X are now initialized */\r\n+    /* Set up to process the data message portion of the hash (default) */\r\n+    ctx->h.bCnt = 0;                            /* buffer b[] starts out empty */\r\n+    Skein_Start_New_Type(ctx,MSG);\r\n+    \r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+#endif\r\n+\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* process the input bytes */\r\n+static int Skein_512_Update(Skein_512_Ctxt_t *ctx, const u08b_t *msg, size_t msgByteCnt)\r\n+    {\r\n+    size_t n;\r\n+\r\n+    Skein_Assert(ctx->h.bCnt <= SKEIN_512_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\r\n+\r\n+    /* process full blocks, if any */\r\n+    if (msgByteCnt + ctx->h.bCnt > SKEIN_512_BLOCK_BYTES)\r\n+        {\r\n+        if (ctx->h.bCnt)                              /* finish up any buffered message data */\r\n+            {\r\n+            n = SKEIN_512_BLOCK_BYTES - ctx->h.bCnt;  /* # bytes free in buffer b[] */\r\n+            if (n)\r\n+                {\r\n+                Skein_assert(n < msgByteCnt);         /* check on our logic here */\r\n+                memcpy(&ctx->b[ctx->h.bCnt],msg,n);\r\n+                msgByteCnt  -= n;\r\n+                msg         += n;\r\n+                ctx->h.bCnt += n;\r\n+                }\r\n+            Skein_assert(ctx->h.bCnt == SKEIN_512_BLOCK_BYTES);\r\n+            Skein_512_Process_Block(ctx,ctx->b,1,SKEIN_512_BLOCK_BYTES);\r\n+            ctx->h.bCnt = 0;\r\n+            }\r\n+        /* now process any remaining full blocks, directly from input message data */\r\n+        if (msgByteCnt > SKEIN_512_BLOCK_BYTES)\r\n+            {\r\n+            n = (msgByteCnt-1) / SKEIN_512_BLOCK_BYTES;   /* number of full blocks to process */\r\n+            Skein_512_Process_Block(ctx,msg,n,SKEIN_512_BLOCK_BYTES);\r\n+            msgByteCnt -= n * SKEIN_512_BLOCK_BYTES;\r\n+            msg        += n * SKEIN_512_BLOCK_BYTES;\r\n+            }\r\n+        Skein_assert(ctx->h.bCnt == 0);\r\n+        }\r\n+\r\n+    /* copy any remaining source message data bytes into b[] */\r\n+    if (msgByteCnt)\r\n+        {\r\n+        Skein_assert(msgByteCnt + ctx->h.bCnt <= SKEIN_512_BLOCK_BYTES);\r\n+        memcpy(&ctx->b[ctx->h.bCnt],msg,msgByteCnt);\r\n+        ctx->h.bCnt += msgByteCnt;\r\n+        }\r\n+\r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+   \r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* finalize the hash computation and output the result */\r\n+static int Skein_512_Final(Skein_512_Ctxt_t *ctx, u08b_t *hashVal)\r\n+    {\r\n+    size_t i,n,byteCnt;\r\n+    u64b_t X[SKEIN_512_STATE_WORDS];\r\n+    Skein_Assert(ctx->h.bCnt <= SKEIN_512_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\r\n+\r\n+    ctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;                 /* tag as the final block */\r\n+    if (ctx->h.bCnt < SKEIN_512_BLOCK_BYTES)            /* zero pad b[] if necessary */\r\n+        memset(&ctx->b[ctx->h.bCnt],0,SKEIN_512_BLOCK_BYTES - ctx->h.bCnt);\r\n+\r\n+    Skein_512_Process_Block(ctx,ctx->b,1,ctx->h.bCnt);  /* process the final block */\r\n+    \r\n+    /* now output the result */\r\n+    byteCnt = (ctx->h.hashBitLen + 7) >> 3;             /* total number of output bytes */\r\n+\r\n+    /* run Threefish in \"counter mode\" to generate output */\r\n+    memset(ctx->b,0,sizeof(ctx->b));  /* zero out b[], so it can hold the counter */\r\n+    memcpy(X,ctx->X,sizeof(X));       /* keep a local copy of counter mode \"key\" */\r\n+    for (i=0;i*SKEIN_512_BLOCK_BYTES < byteCnt;i++)\r\n+        {\r\n+        ((u64b_t *)ctx->b)[0]= Skein_Swap64((u64b_t) i); /* build the counter block */\r\n+        Skein_Start_New_Type(ctx,OUT_FINAL);\r\n+        Skein_512_Process_Block(ctx,ctx->b,1,sizeof(u64b_t)); /* run \"counter mode\" */\r\n+        n = byteCnt - i*SKEIN_512_BLOCK_BYTES;   /* number of output bytes left to go */\r\n+        if (n >= SKEIN_512_BLOCK_BYTES)\r\n+            n  = SKEIN_512_BLOCK_BYTES;\r\n+        Skein_Put64_LSB_First(hashVal+i*SKEIN_512_BLOCK_BYTES,ctx->X,n);   /* \"output\" the ctr mode bytes */\r\n+        Skein_Show_Final(512,&ctx->h,n,hashVal+i*SKEIN_512_BLOCK_BYTES);\r\n+        memcpy(ctx->X,X,sizeof(X));   /* restore the counter mode key for next time */\r\n+        }\r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+\r\n+#if defined(SKEIN_CODE_SIZE) || defined(SKEIN_PERF)\r\n+static size_t Skein_512_API_CodeSize(void)\r\n+    {\r\n+    return ((u08b_t *) Skein_512_API_CodeSize) -\r\n+           ((u08b_t *) Skein_512_Init);\r\n+    }\r\n+#endif\r\n+\r\n+/*****************************************************************/\r\n+/*    1024-bit Skein                                             */\r\n+/*****************************************************************/\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* init the context for a straight hashing operation  */\r\n+static int Skein1024_Init(Skein1024_Ctxt_t *ctx, size_t hashBitLen)\r\n+    {\r\n+    union\r\n+        {\r\n+        u08b_t  b[SKEIN1024_STATE_BYTES];\r\n+        u64b_t  w[SKEIN1024_STATE_WORDS];\r\n+        } cfg;                              /* config block */\r\n+        \r\n+    Skein_Assert(hashBitLen > 0,SKEIN_BAD_HASHLEN);\r\n+    ctx->h.hashBitLen = hashBitLen;         /* output hash bit count */\r\n+\r\n+    switch (hashBitLen)\r\n+        {              /* use pre-computed values, where available */\r\n+#ifndef SKEIN_NO_PRECOMP\r\n+        case  512: memcpy(ctx->X,SKEIN1024_IV_512 ,sizeof(ctx->X)); break;\r\n+        case  384: memcpy(ctx->X,SKEIN1024_IV_384 ,sizeof(ctx->X)); break;\r\n+        case 1024: memcpy(ctx->X,SKEIN1024_IV_1024,sizeof(ctx->X)); break;\r\n+#endif\r\n+        default:\r\n+            /* here if there is no precomputed IV value available */\r\n+            /* build/process the config block, type == CONFIG (could be precomputed) */\r\n+            Skein_Start_New_Type(ctx,CFG_FINAL);        /* set tweaks: T0=0; T1=CFG | FINAL */\r\n+\r\n+            cfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);  /* set the schema, version */\r\n+            cfg.w[1] = Skein_Swap64(hashBitLen);        /* hash result length in bits */\r\n+            cfg.w[2] = Skein_Swap64(SKEIN_CFG_TREE_INFO_SEQUENTIAL);\r\n+            memset(&cfg.w[3],0,sizeof(cfg) - 3*sizeof(cfg.w[0])); /* zero pad config block */\r\n+\r\n+            /* compute the initial chaining values from config block */\r\n+            memset(ctx->X,0,sizeof(ctx->X));            /* zero the chaining variables */\r\n+            Skein1024_Process_Block(ctx,cfg.b,1,SKEIN_CFG_STR_LEN);\r\n+            break;\r\n+        }\r\n+\r\n+    /* The chaining vars ctx->X are now initialized for the given hashBitLen. */\r\n+    /* Set up to process the data message portion of the hash (default) */\r\n+    Skein_Start_New_Type(ctx,MSG);              /* T0=0, T1= MSG type */\r\n+\r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+\r\n+#if 0\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* init the context for a MAC and/or tree hash operation */\r\n+/* [identical to Skein1024_Init() when keyBytes == 0 && treeInfo == SKEIN_CFG_TREE_INFO_SEQUENTIAL] */\r\n+static int Skein1024_InitExt(Skein1024_Ctxt_t *ctx,size_t hashBitLen,u64b_t treeInfo, const u08b_t *key, size_t keyBytes)\r\n+    {\r\n+    union\r\n+        {\r\n+        u08b_t  b[SKEIN1024_STATE_BYTES];\r\n+        u64b_t  w[SKEIN1024_STATE_WORDS];\r\n+        } cfg;                              /* config block */\r\n+        \r\n+    Skein_Assert(hashBitLen > 0,SKEIN_BAD_HASHLEN);\r\n+    Skein_Assert(keyBytes == 0 || key != NULL,SKEIN_FAIL);\r\n+\r\n+    /* compute the initial chaining values ctx->X[], based on key */\r\n+    if (keyBytes == 0)                          /* is there a key? */\r\n+        {                                   \r\n+        memset(ctx->X,0,sizeof(ctx->X));        /* no key: use all zeroes as key for config block */\r\n+        }\r\n+    else                                        /* here to pre-process a key */\r\n+        {\r\n+        Skein_assert(sizeof(cfg.b) >= sizeof(ctx->X));\r\n+        /* do a mini-Init right here */\r\n+        ctx->h.hashBitLen=8*sizeof(ctx->X);     /* set output hash bit count = state size */\r\n+        Skein_Start_New_Type(ctx,KEY);          /* set tweaks: T0 = 0; T1 = KEY type */\r\n+        memset(ctx->X,0,sizeof(ctx->X));        /* zero the initial chaining variables */\r\n+        Skein1024_Update(ctx,key,keyBytes);     /* hash the key */\r\n+        Skein1024_Final_Pad(ctx,cfg.b);         /* put result into cfg.b[] */\r\n+        memcpy(ctx->X,cfg.b,sizeof(cfg.b));     /* copy over into ctx->X[] */\r\n+#if SKEIN_NEED_SWAP\r\n+        {\r\n+        uint_t i;\r\n+        for (i=0;i<SKEIN1024_STATE_WORDS;i++)   /* convert key bytes to context words */\r\n+            ctx->X[i] = Skein_Swap64(ctx->X[i]);\r\n+        }\r\n+#endif\r\n+        }\r\n+    /* build/process the config block, type == CONFIG (could be precomputed for each key) */\r\n+    ctx->h.hashBitLen = hashBitLen;             /* output hash bit count */\r\n+    Skein_Start_New_Type(ctx,CFG_FINAL);\r\n+\r\n+    memset(&cfg.w,0,sizeof(cfg.w));             /* pre-pad cfg.w[] with zeroes */\r\n+    cfg.w[0] = Skein_Swap64(SKEIN_SCHEMA_VER);\r\n+    cfg.w[1] = Skein_Swap64(hashBitLen);        /* hash result length in bits */\r\n+    cfg.w[2] = Skein_Swap64(treeInfo);          /* tree hash config info (or SKEIN_CFG_TREE_INFO_SEQUENTIAL) */\r\n+\r\n+    Skein_Show_Key(1024,&ctx->h,key,keyBytes);\r\n+\r\n+    /* compute the initial chaining values from config block */\r\n+    Skein1024_Process_Block(ctx,cfg.b,1,SKEIN_CFG_STR_LEN);\r\n+\r\n+    /* The chaining vars ctx->X are now initialized */\r\n+    /* Set up to process the data message portion of the hash (default) */\r\n+    ctx->h.bCnt = 0;                            /* buffer b[] starts out empty */\r\n+    Skein_Start_New_Type(ctx,MSG);\r\n+    \r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+#endif\r\n+\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* process the input bytes */\r\n+static int Skein1024_Update(Skein1024_Ctxt_t *ctx, const u08b_t *msg, size_t msgByteCnt)\r\n+    {\r\n+    size_t n;\r\n+\r\n+    Skein_Assert(ctx->h.bCnt <= SKEIN1024_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\r\n+\r\n+    /* process full blocks, if any */\r\n+    if (msgByteCnt + ctx->h.bCnt > SKEIN1024_BLOCK_BYTES)\r\n+        {\r\n+        if (ctx->h.bCnt)                              /* finish up any buffered message data */\r\n+            {\r\n+            n = SKEIN1024_BLOCK_BYTES - ctx->h.bCnt;  /* # bytes free in buffer b[] */\r\n+            if (n)\r\n+                {\r\n+                Skein_assert(n < msgByteCnt);         /* check on our logic here */\r\n+                memcpy(&ctx->b[ctx->h.bCnt],msg,n);\r\n+                msgByteCnt  -= n;\r\n+                msg         += n;\r\n+                ctx->h.bCnt += n;\r\n+                }\r\n+            Skein_assert(ctx->h.bCnt == SKEIN1024_BLOCK_BYTES);\r\n+            Skein1024_Process_Block(ctx,ctx->b,1,SKEIN1024_BLOCK_BYTES);\r\n+            ctx->h.bCnt = 0;\r\n+            }\r\n+        /* now process any remaining full blocks, directly from input message data */\r\n+        if (msgByteCnt > SKEIN1024_BLOCK_BYTES)\r\n+            {\r\n+            n = (msgByteCnt-1) / SKEIN1024_BLOCK_BYTES;   /* number of full blocks to process */\r\n+            Skein1024_Process_Block(ctx,msg,n,SKEIN1024_BLOCK_BYTES);\r\n+            msgByteCnt -= n * SKEIN1024_BLOCK_BYTES;\r\n+            msg        += n * SKEIN1024_BLOCK_BYTES;\r\n+            }\r\n+        Skein_assert(ctx->h.bCnt == 0);\r\n+        }\r\n+\r\n+    /* copy any remaining source message data bytes into b[] */\r\n+    if (msgByteCnt)\r\n+        {\r\n+        Skein_assert(msgByteCnt + ctx->h.bCnt <= SKEIN1024_BLOCK_BYTES);\r\n+        memcpy(&ctx->b[ctx->h.bCnt],msg,msgByteCnt);\r\n+        ctx->h.bCnt += msgByteCnt;\r\n+        }\r\n+\r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+   \r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* finalize the hash computation and output the result */\r\n+static int Skein1024_Final(Skein1024_Ctxt_t *ctx, u08b_t *hashVal)\r\n+    {\r\n+    size_t i,n,byteCnt;\r\n+    u64b_t X[SKEIN1024_STATE_WORDS];\r\n+    Skein_Assert(ctx->h.bCnt <= SKEIN1024_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\r\n+\r\n+    ctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;                 /* tag as the final block */\r\n+    if (ctx->h.bCnt < SKEIN1024_BLOCK_BYTES)            /* zero pad b[] if necessary */\r\n+        memset(&ctx->b[ctx->h.bCnt],0,SKEIN1024_BLOCK_BYTES - ctx->h.bCnt);\r\n+\r\n+    Skein1024_Process_Block(ctx,ctx->b,1,ctx->h.bCnt);  /* process the final block */\r\n+    \r\n+    /* now output the result */\r\n+    byteCnt = (ctx->h.hashBitLen + 7) >> 3;             /* total number of output bytes */\r\n+\r\n+    /* run Threefish in \"counter mode\" to generate output */\r\n+    memset(ctx->b,0,sizeof(ctx->b));  /* zero out b[], so it can hold the counter */\r\n+    memcpy(X,ctx->X,sizeof(X));       /* keep a local copy of counter mode \"key\" */\r\n+    for (i=0;i*SKEIN1024_BLOCK_BYTES < byteCnt;i++)\r\n+        {\r\n+        ((u64b_t *)ctx->b)[0]= Skein_Swap64((u64b_t) i); /* build the counter block */\r\n+        Skein_Start_New_Type(ctx,OUT_FINAL);\r\n+        Skein1024_Process_Block(ctx,ctx->b,1,sizeof(u64b_t)); /* run \"counter mode\" */\r\n+        n = byteCnt - i*SKEIN1024_BLOCK_BYTES;   /* number of output bytes left to go */\r\n+        if (n >= SKEIN1024_BLOCK_BYTES)\r\n+            n  = SKEIN1024_BLOCK_BYTES;\r\n+        Skein_Put64_LSB_First(hashVal+i*SKEIN1024_BLOCK_BYTES,ctx->X,n);   /* \"output\" the ctr mode bytes */\r\n+        Skein_Show_Final(1024,&ctx->h,n,hashVal+i*SKEIN1024_BLOCK_BYTES);\r\n+        memcpy(ctx->X,X,sizeof(X));   /* restore the counter mode key for next time */\r\n+        }\r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+\r\n+#if defined(SKEIN_CODE_SIZE) || defined(SKEIN_PERF)\r\n+static size_t Skein1024_API_CodeSize(void)\r\n+    {\r\n+    return ((u08b_t *) Skein1024_API_CodeSize) -\r\n+           ((u08b_t *) Skein1024_Init);\r\n+    }\r\n+#endif\r\n+\r\n+/**************** Functions to support MAC/tree hashing ***************/\r\n+/*   (this code is identical for Optimized and Reference versions)    */\r\n+\r\n+#if 0\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* finalize the hash computation and output the block, no OUTPUT stage */\r\n+static int Skein_256_Final_Pad(Skein_256_Ctxt_t *ctx, u08b_t *hashVal)\r\n+    {\r\n+    Skein_Assert(ctx->h.bCnt <= SKEIN_256_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\r\n+\r\n+    ctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;        /* tag as the final block */\r\n+    if (ctx->h.bCnt < SKEIN_256_BLOCK_BYTES)   /* zero pad b[] if necessary */\r\n+        memset(&ctx->b[ctx->h.bCnt],0,SKEIN_256_BLOCK_BYTES - ctx->h.bCnt);\r\n+    Skein_256_Process_Block(ctx,ctx->b,1,ctx->h.bCnt);    /* process the final block */\r\n+    \r\n+    Skein_Put64_LSB_First(hashVal,ctx->X,SKEIN_256_BLOCK_BYTES);   /* \"output\" the state bytes */\r\n+    \r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* finalize the hash computation and output the block, no OUTPUT stage */\r\n+static int Skein_512_Final_Pad(Skein_512_Ctxt_t *ctx, u08b_t *hashVal)\r\n+    {\r\n+    Skein_Assert(ctx->h.bCnt <= SKEIN_512_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\r\n+\r\n+    ctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;        /* tag as the final block */\r\n+    if (ctx->h.bCnt < SKEIN_512_BLOCK_BYTES)   /* zero pad b[] if necessary */\r\n+        memset(&ctx->b[ctx->h.bCnt],0,SKEIN_512_BLOCK_BYTES - ctx->h.bCnt);\r\n+    Skein_512_Process_Block(ctx,ctx->b,1,ctx->h.bCnt);    /* process the final block */\r\n+    \r\n+    Skein_Put64_LSB_First(hashVal,ctx->X,SKEIN_512_BLOCK_BYTES);   /* \"output\" the state bytes */\r\n+    \r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* finalize the hash computation and output the block, no OUTPUT stage */\r\n+static int Skein1024_Final_Pad(Skein1024_Ctxt_t *ctx, u08b_t *hashVal)\r\n+    {\r\n+    Skein_Assert(ctx->h.bCnt <= SKEIN1024_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\r\n+\r\n+    ctx->h.T[1] |= SKEIN_T1_FLAG_FINAL;        /* tag as the final block */\r\n+    if (ctx->h.bCnt < SKEIN1024_BLOCK_BYTES)   /* zero pad b[] if necessary */\r\n+        memset(&ctx->b[ctx->h.bCnt],0,SKEIN1024_BLOCK_BYTES - ctx->h.bCnt);\r\n+    Skein1024_Process_Block(ctx,ctx->b,1,ctx->h.bCnt);    /* process the final block */\r\n+    \r\n+    Skein_Put64_LSB_First(hashVal,ctx->X,SKEIN1024_BLOCK_BYTES);   /* \"output\" the state bytes */\r\n+    \r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+\r\n+\r\n+#if SKEIN_TREE_HASH\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* just do the OUTPUT stage                                       */\r\n+static int Skein_256_Output(Skein_256_Ctxt_t *ctx, u08b_t *hashVal)\r\n+    {\r\n+    size_t i,n,byteCnt;\r\n+    u64b_t X[SKEIN_256_STATE_WORDS];\r\n+    Skein_Assert(ctx->h.bCnt <= SKEIN_256_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\r\n+\r\n+    /* now output the result */\r\n+    byteCnt = (ctx->h.hashBitLen + 7) >> 3;    /* total number of output bytes */\r\n+\r\n+    /* run Threefish in \"counter mode\" to generate output */\r\n+    memset(ctx->b,0,sizeof(ctx->b));  /* zero out b[], so it can hold the counter */\r\n+    memcpy(X,ctx->X,sizeof(X));       /* keep a local copy of counter mode \"key\" */\r\n+    for (i=0;i*SKEIN_256_BLOCK_BYTES < byteCnt;i++)\r\n+        {\r\n+        ((u64b_t *)ctx->b)[0]= Skein_Swap64((u64b_t) i); /* build the counter block */\r\n+        Skein_Start_New_Type(ctx,OUT_FINAL);\r\n+        Skein_256_Process_Block(ctx,ctx->b,1,sizeof(u64b_t)); /* run \"counter mode\" */\r\n+        n = byteCnt - i*SKEIN_256_BLOCK_BYTES;   /* number of output bytes left to go */\r\n+        if (n >= SKEIN_256_BLOCK_BYTES)\r\n+            n  = SKEIN_256_BLOCK_BYTES;\r\n+        Skein_Put64_LSB_First(hashVal+i*SKEIN_256_BLOCK_BYTES,ctx->X,n);   /* \"output\" the ctr mode bytes */\r\n+        Skein_Show_Final(256,&ctx->h,n,hashVal+i*SKEIN_256_BLOCK_BYTES);\r\n+        memcpy(ctx->X,X,sizeof(X));   /* restore the counter mode key for next time */\r\n+        }\r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* just do the OUTPUT stage                                       */\r\n+static int Skein_512_Output(Skein_512_Ctxt_t *ctx, u08b_t *hashVal)\r\n+    {\r\n+    size_t i,n,byteCnt;\r\n+    u64b_t X[SKEIN_512_STATE_WORDS];\r\n+    Skein_Assert(ctx->h.bCnt <= SKEIN_512_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\r\n+\r\n+    /* now output the result */\r\n+    byteCnt = (ctx->h.hashBitLen + 7) >> 3;    /* total number of output bytes */\r\n+\r\n+    /* run Threefish in \"counter mode\" to generate output */\r\n+    memset(ctx->b,0,sizeof(ctx->b));  /* zero out b[], so it can hold the counter */\r\n+    memcpy(X,ctx->X,sizeof(X));       /* keep a local copy of counter mode \"key\" */\r\n+    for (i=0;i*SKEIN_512_BLOCK_BYTES < byteCnt;i++)\r\n+        {\r\n+        ((u64b_t *)ctx->b)[0]= Skein_Swap64((u64b_t) i); /* build the counter block */\r\n+        Skein_Start_New_Type(ctx,OUT_FINAL);\r\n+        Skein_512_Process_Block(ctx,ctx->b,1,sizeof(u64b_t)); /* run \"counter mode\" */\r\n+        n = byteCnt - i*SKEIN_512_BLOCK_BYTES;   /* number of output bytes left to go */\r\n+        if (n >= SKEIN_512_BLOCK_BYTES)\r\n+            n  = SKEIN_512_BLOCK_BYTES;\r\n+        Skein_Put64_LSB_First(hashVal+i*SKEIN_512_BLOCK_BYTES,ctx->X,n);   /* \"output\" the ctr mode bytes */\r\n+        Skein_Show_Final(256,&ctx->h,n,hashVal+i*SKEIN_512_BLOCK_BYTES);\r\n+        memcpy(ctx->X,X,sizeof(X));   /* restore the counter mode key for next time */\r\n+        }\r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* just do the OUTPUT stage                                       */\r\n+static int Skein1024_Output(Skein1024_Ctxt_t *ctx, u08b_t *hashVal)\r\n+    {\r\n+    size_t i,n,byteCnt;\r\n+    u64b_t X[SKEIN1024_STATE_WORDS];\r\n+    Skein_Assert(ctx->h.bCnt <= SKEIN1024_BLOCK_BYTES,SKEIN_FAIL);    /* catch uninitialized context */\r\n+\r\n+    /* now output the result */\r\n+    byteCnt = (ctx->h.hashBitLen + 7) >> 3;    /* total number of output bytes */\r\n+\r\n+    /* run Threefish in \"counter mode\" to generate output */\r\n+    memset(ctx->b,0,sizeof(ctx->b));  /* zero out b[], so it can hold the counter */\r\n+    memcpy(X,ctx->X,sizeof(X));       /* keep a local copy of counter mode \"key\" */\r\n+    for (i=0;i*SKEIN1024_BLOCK_BYTES < byteCnt;i++)\r\n+        {\r\n+        ((u64b_t *)ctx->b)[0]= Skein_Swap64((u64b_t) i); /* build the counter block */\r\n+        Skein_Start_New_Type(ctx,OUT_FINAL);\r\n+        Skein1024_Process_Block(ctx,ctx->b,1,sizeof(u64b_t)); /* run \"counter mode\" */\r\n+        n = byteCnt - i*SKEIN1024_BLOCK_BYTES;   /* number of output bytes left to go */\r\n+        if (n >= SKEIN1024_BLOCK_BYTES)\r\n+            n  = SKEIN1024_BLOCK_BYTES;\r\n+        Skein_Put64_LSB_First(hashVal+i*SKEIN1024_BLOCK_BYTES,ctx->X,n);   /* \"output\" the ctr mode bytes */\r\n+        Skein_Show_Final(256,&ctx->h,n,hashVal+i*SKEIN1024_BLOCK_BYTES);\r\n+        memcpy(ctx->X,X,sizeof(X));   /* restore the counter mode key for next time */\r\n+        }\r\n+    return SKEIN_SUCCESS;\r\n+    }\r\n+#endif\r\n+#endif\r\n+\r\n+typedef struct\r\n+{\r\n+  uint_t  statebits;                      /* 256, 512, or 1024 */\r\n+  union\r\n+  {\r\n+    Skein_Ctxt_Hdr_t h;                 /* common header \"overlay\" */\r\n+    Skein_256_Ctxt_t ctx_256;\r\n+    Skein_512_Ctxt_t ctx_512;\r\n+    Skein1024_Ctxt_t ctx1024;\r\n+  } u;\r\n+}\r\n+hashState;\r\n+\r\n+/* \"incremental\" hashing API */\r\n+static SkeinHashReturn Init  (hashState *state, int hashbitlen);\r\n+static SkeinHashReturn Update(hashState *state, const SkeinBitSequence *data, SkeinDataLength databitlen);\r\n+static SkeinHashReturn Final (hashState *state,       SkeinBitSequence *hashval);\r\n+\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* select the context size and init the context */\r\n+static SkeinHashReturn Init(hashState *state, int hashbitlen)\r\n+{\r\n+#if SKEIN_256_NIST_MAX_HASH_BITS\r\n+  if (hashbitlen <= SKEIN_256_NIST_MAX_HASHBITS)\r\n+  {\r\n+    Skein_Assert(hashbitlen > 0,BAD_HASHLEN);\r\n+    state->statebits = 64*SKEIN_256_STATE_WORDS;\r\n+    return (SkeinHashReturn) Skein_256_Init(&state->u.ctx_256,(size_t) hashbitlen);\r\n+  }\r\n+#endif\r\n+  if (hashbitlen <= SKEIN_512_NIST_MAX_HASHBITS)\r\n+  {\r\n+    state->statebits = 64*SKEIN_512_STATE_WORDS;\r\n+    return (SkeinHashReturn) Skein_512_Init(&state->u.ctx_512,(size_t) hashbitlen);\r\n+  }\r\n+  else\r\n+  {\r\n+    state->statebits = 64*SKEIN1024_STATE_WORDS;\r\n+    return (SkeinHashReturn) Skein1024_Init(&state->u.ctx1024,(size_t) hashbitlen);\r\n+  }\r\n+}\r\n+\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* process data to be hashed */\r\n+static SkeinHashReturn Update(hashState *state, const SkeinBitSequence *data, SkeinDataLength databitlen)\r\n+{\r\n+  /* only the final Update() call is allowed do partial bytes, else assert an error */\r\n+  Skein_Assert((state->u.h.T[1] & SKEIN_T1_FLAG_BIT_PAD) == 0 || databitlen == 0, SKEIN_FAIL);\r\n+\r\n+  Skein_Assert(state->statebits % 256 == 0 && (state->statebits-256) < 1024,SKEIN_FAIL);\r\n+  if ((databitlen & 7) == 0)  /* partial bytes? */\r\n+  {\r\n+    switch ((state->statebits >> 8) & 3)\r\n+    {\r\n+    case 2:  return (SkeinHashReturn) Skein_512_Update(&state->u.ctx_512,data,databitlen >> 3);\r\n+    case 1:  return (SkeinHashReturn) Skein_256_Update(&state->u.ctx_256,data,databitlen >> 3);\r\n+    case 0:  return (SkeinHashReturn) Skein1024_Update(&state->u.ctx1024,data,databitlen >> 3);\r\n+    default: return SKEIN_FAIL;\r\n+    }\r\n+  }\r\n+  else\r\n+  {   /* handle partial final byte */\r\n+    size_t bCnt = (databitlen >> 3) + 1;                  /* number of bytes to handle (nonzero here!) */\r\n+    u08b_t b,mask;\r\n+\r\n+    mask = (u08b_t) (1u << (7 - (databitlen & 7)));       /* partial byte bit mask */\r\n+    b    = (u08b_t) ((data[bCnt-1] & (0-mask)) | mask);   /* apply bit padding on final byte */\r\n+\r\n+    switch ((state->statebits >> 8) & 3)\r\n+    {\r\n+    case 2:  Skein_512_Update(&state->u.ctx_512,data,bCnt-1); /* process all but the final byte    */\r\n+      Skein_512_Update(&state->u.ctx_512,&b  ,  1   ); /* process the (masked) partial byte */\r\n+      break;\r\n+    case 1:  Skein_256_Update(&state->u.ctx_256,data,bCnt-1); /* process all but the final byte    */\r\n+      Skein_256_Update(&state->u.ctx_256,&b  ,  1   ); /* process the (masked) partial byte */\r\n+      break;\r\n+    case 0:  Skein1024_Update(&state->u.ctx1024,data,bCnt-1); /* process all but the final byte    */\r\n+      Skein1024_Update(&state->u.ctx1024,&b  ,  1   ); /* process the (masked) partial byte */\r\n+      break;\r\n+    default: return SKEIN_FAIL;\r\n+    }\r\n+    Skein_Set_Bit_Pad_Flag(state->u.h);                    /* set tweak flag for the final call */\r\n+\r\n+    return SKEIN_SUCCESS;\r\n+  }\r\n+}\r\n+\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* finalize hash computation and output the result (hashbitlen bits) */\r\n+static SkeinHashReturn Final(hashState *state, SkeinBitSequence *hashval)\r\n+{\r\n+  Skein_Assert(state->statebits % 256 == 0 && (state->statebits-256) < 1024,FAIL);\r\n+  switch ((state->statebits >> 8) & 3)\r\n+  {\r\n+  case 2:  return (SkeinHashReturn) Skein_512_Final(&state->u.ctx_512,hashval);\r\n+  case 1:  return (SkeinHashReturn) Skein_256_Final(&state->u.ctx_256,hashval);\r\n+  case 0:  return (SkeinHashReturn) Skein1024_Final(&state->u.ctx1024,hashval);\r\n+  default: return SKEIN_FAIL;\r\n+  }\r\n+}\r\n+\r\n+/*++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++++*/\r\n+/* all-in-one hash function */\r\n+SkeinHashReturn skein_hash(int hashbitlen, const SkeinBitSequence *data, /* all-in-one call */\r\n+                SkeinDataLength databitlen,SkeinBitSequence *hashval)\r\n+{\r\n+  hashState  state;\r\n+  SkeinHashReturn r = Init(&state,hashbitlen);\r\n+  if (r == SKEIN_SUCCESS)\r\n+  { /* these calls do not fail when called properly */\r\n+    r = Update(&state,data,databitlen);\r\n+    Final(&state,hashval);\r\n+  }\r\n+  return r;\r\n+}\r"
      },
      {
        "sha": "05bdb86c9bdea89a1382b86823eff4a61d65eae2",
        "filename": "src/crypto/c_skein.h",
        "status": "added",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_skein.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/c_skein.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/c_skein.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,47 @@\n+#ifndef _SKEIN_H_\r\n+#define _SKEIN_H_     1\r\n+/**************************************************************************\r\n+**\r\n+** Interface declarations and internal definitions for Skein hashing.\r\n+**\r\n+** Source code author: Doug Whiting, 2008.\r\n+**\r\n+** This algorithm and source code is released to the public domain.\r\n+**\r\n+***************************************************************************\r\n+** \r\n+** The following compile-time switches may be defined to control some\r\n+** tradeoffs between speed, code size, error checking, and security.\r\n+**\r\n+** The \"default\" note explains what happens when the switch is not defined.\r\n+**\r\n+**  SKEIN_DEBUG            -- make callouts from inside Skein code\r\n+**                            to examine/display intermediate values.\r\n+**                            [default: no callouts (no overhead)]\r\n+**\r\n+**  SKEIN_ERR_CHECK        -- how error checking is handled inside Skein\r\n+**                            code. If not defined, most error checking \r\n+**                            is disabled (for performance). Otherwise, \r\n+**                            the switch value is interpreted as:\r\n+**                                0: use assert()      to flag errors\r\n+**                                1: return SKEIN_FAIL to flag errors\r\n+**\r\n+***************************************************************************/\r\n+#include \"skein_port.h\"                      /* get platform-specific definitions */\r\n+\r\n+typedef enum\r\n+{\r\n+  SKEIN_SUCCESS         =      0,          /* return codes from Skein calls */\r\n+  SKEIN_FAIL            =      1,\r\n+  SKEIN_BAD_HASHLEN     =      2\r\n+}\r\n+SkeinHashReturn;\r\n+\r\n+typedef size_t   SkeinDataLength;                /* bit count  type */\r\n+typedef u08b_t   SkeinBitSequence;               /* bit stream type */\r\n+\r\n+/* \"all-in-one\" call */\r\n+SkeinHashReturn skein_hash(int hashbitlen,   const SkeinBitSequence *data,\r\n+        SkeinDataLength databitlen, SkeinBitSequence *hashval);\r\n+\r\n+#endif  /* ifndef _SKEIN_H_ */\r"
      },
      {
        "sha": "e31c1e466fd74411146cccf07fbc181cf7a9792c",
        "filename": "src/crypto/cryptonight.c",
        "status": "added",
        "additions": 201,
        "deletions": 0,
        "changes": 201,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/cryptonight.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/cryptonight.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/cryptonight.c?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,201 @@\n+// Copyright (c) 2012-2013 The Cryptonote developers\r\n+// Distributed under the MIT/X11 software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+// Modified for CPUminer by Lucas Jones\r\n+\r\n+//#include \"cpuminer-config.h\"\r\n+//#include \"miner.h\"\r\n+#include <stdlib.h>\r\n+\r\n+#include <crypto/oaes_lib.h>\r\n+#include <crypto/c_keccak.h>\r\n+#include <crypto/c_groestl.h>\r\n+#include <crypto/c_blake256.h>\r\n+#include <crypto/c_jh.h>\r\n+#include <crypto/c_skein.h>\r\n+#include <crypto/cryptonight.h>\r\n+#include <crypto/types.h>\r\n+\r\n+struct cryptonight_ctx {\r\n+    uint8_t long_state[MEMORY];\r\n+    union cn_slow_hash_state state;\r\n+    uint8_t text[INIT_SIZE_BYTE];\r\n+    uint8_t a[AES_BLOCK_SIZE];\r\n+    uint8_t b[AES_BLOCK_SIZE];\r\n+    uint8_t c[AES_BLOCK_SIZE];\r\n+    oaes_ctx* aes_ctx;\r\n+};\r\n+\r\n+static void do_blake_hash(const void* input, size_t len, char* output) {\r\n+    blake256_hash((uint8_t*)output, (const uint8_t*)input, len);\r\n+}\r\n+\r\n+void do_groestl_hash(const void* input, size_t len, char* output) {\r\n+    groestl((const uint8_t*)input, len * 8, (uint8_t*)output);\r\n+}\r\n+\r\n+static void do_jh_hash(const void* input, size_t len, char* output) {\r\n+    int r = jh_hash(HASH_SIZE * 8, (const uint8_t*)input, 8 * len, (uint8_t*)output);\r\n+}\r\n+\r\n+static void do_skein_hash(const void* input, size_t len, char* output) {\r\n+    int r = skein_hash(8 * HASH_SIZE, (const uint8_t*)input, 8 * len, (uint8_t*)output);\r\n+}\r\n+\r\n+void hash_permutation(union hash_state *state) {\r\n+  keccakf((uint64_t*)state, 24);\r\n+}\r\n+\r\n+void hash_process(union hash_state *state, const uint8_t *buf, size_t count) {\r\n+  keccak1600(buf, count, (uint8_t*)state);\r\n+}\r\n+\r\n+//extern int fast_aesb_single_round(const uint8_t *in, uint8_t*out, const uint8_t *expandedKey);\r\n+//extern void aesb_single_round(const uint8_t *in, uint8_t*out, const uint8_t *expandedKey);\r\n+void aesb_single_round(const uint8_t *in, uint8_t *out, uint8_t *expandedKey);\r\n+//extern void aesb_pseudo_round_mut(uint8_t *val, uint8_t *expandedKey);\r\n+void aesb_pseudo_round_mut(uint8_t *val, uint8_t *expandedKey);\r\n+//extern int fast_aesb_pseudo_round_mut(uint8_t *val, uint8_t *expandedKey);\r\n+\r\n+static void (* const extra_hashes[4])(const void *, size_t, char *) = {\r\n+        do_blake_hash, do_groestl_hash, do_jh_hash, do_skein_hash\r\n+};\r\n+\r\n+uint64_t mul128(uint64_t multiplier, uint64_t multiplicand, uint64_t* product_hi) {\r\n+  // multiplier   = ab = a * 2^32 + b\r\n+  // multiplicand = cd = c * 2^32 + d\r\n+  // ab * cd = a * c * 2^64 + (a * d + b * c) * 2^32 + b * d\r\n+  uint64_t a = hi_dword(multiplier);\r\n+  uint64_t b = lo_dword(multiplier);\r\n+  uint64_t c = hi_dword(multiplicand);\r\n+  uint64_t d = lo_dword(multiplicand);\r\n+\r\n+  uint64_t ac = a * c;\r\n+  uint64_t ad = a * d;\r\n+  uint64_t bc = b * c;\r\n+  uint64_t bd = b * d;\r\n+\r\n+  uint64_t adbc = ad + bc;\r\n+  uint64_t adbc_carry = adbc < ad ? 1 : 0;\r\n+\r\n+  // multiplier * multiplicand = product_hi * 2^64 + product_lo\r\n+  uint64_t product_lo = bd + (adbc << 32);\r\n+  uint64_t product_lo_carry = product_lo < bd ? 1 : 0;\r\n+  *product_hi = ac + (adbc >> 32) + (adbc_carry << 32) + product_lo_carry;\r\n+\r\n+  return product_lo;\r\n+}\r\n+\r\n+static size_t e2i(const uint8_t* a) {\r\n+    return (*((uint64_t*) a) / AES_BLOCK_SIZE) & (MEMORY / AES_BLOCK_SIZE - 1);\r\n+}\r\n+\r\n+static void mul(const uint8_t* a, const uint8_t* b, uint8_t* res) {\r\n+    ((uint64_t*) res)[1] = mul128(((uint64_t*) a)[0], ((uint64_t*) b)[0], (uint64_t*) res);\r\n+}\r\n+\r\n+static void sum_half_blocks(uint8_t* a, const uint8_t* b) {\r\n+    ((uint64_t*) a)[0] += ((uint64_t*) b)[0];\r\n+    ((uint64_t*) a)[1] += ((uint64_t*) b)[1];\r\n+}\r\n+\r\n+static void sum_half_blocks_dst(const uint8_t* a, const uint8_t* b, uint8_t* dst) {\r\n+    ((uint64_t*) dst)[0] = ((uint64_t*) a)[0] + ((uint64_t*) b)[0];\r\n+    ((uint64_t*) dst)[1] = ((uint64_t*) a)[1] + ((uint64_t*) b)[1];\r\n+}\r\n+\r\n+static void mul_sum_dst(const uint8_t* a, const uint8_t* b, const uint8_t* c, uint8_t* dst) {\r\n+    ((uint64_t*) dst)[1] = mul128(((uint64_t*) a)[0], ((uint64_t*) b)[0], (uint64_t*) dst) + ((uint64_t*) c)[1];\r\n+    ((uint64_t*) dst)[0] += ((uint64_t*) c)[0];\r\n+}\r\n+\r\n+static void mul_sum_xor_dst(const uint8_t* a, uint8_t* c, uint8_t* dst) {\r\n+    uint64_t hi, lo = mul128(((uint64_t*) a)[0], ((uint64_t*) dst)[0], &hi) + ((uint64_t*) c)[1];\r\n+    hi += ((uint64_t*) c)[0];\r\n+\r\n+    ((uint64_t*) c)[0] = ((uint64_t*) dst)[0] ^ hi;\r\n+    ((uint64_t*) c)[1] = ((uint64_t*) dst)[1] ^ lo;\r\n+    ((uint64_t*) dst)[0] = hi;\r\n+    ((uint64_t*) dst)[1] = lo;\r\n+}\r\n+\r\n+static void copy_block(uint8_t* dst, const uint8_t* src) {\r\n+    ((uint64_t*) dst)[0] = ((uint64_t*) src)[0];\r\n+    ((uint64_t*) dst)[1] = ((uint64_t*) src)[1];\r\n+}\r\n+\r\n+static void xor_blocks(uint8_t* a, const uint8_t* b) {\r\n+    ((uint64_t*) a)[0] ^= ((uint64_t*) b)[0];\r\n+    ((uint64_t*) a)[1] ^= ((uint64_t*) b)[1];\r\n+}\r\n+\r\n+static void xor_blocks_dst(const uint8_t* a, const uint8_t* b, uint8_t* dst) {\r\n+    ((uint64_t*) dst)[0] = ((uint64_t*) a)[0] ^ ((uint64_t*) b)[0];\r\n+    ((uint64_t*) dst)[1] = ((uint64_t*) a)[1] ^ ((uint64_t*) b)[1];\r\n+}\r\n+\r\n+void cryptonight_hash_ctx(void* output, const void* input, size_t len, struct cryptonight_ctx* ctx) {\r\n+    size_t i, j;\r\n+    hash_process(&ctx->state.hs, (const uint8_t*) input, len);\r\n+    ctx->aes_ctx = (oaes_ctx*) oaes_alloc();\r\n+    memcpy(ctx->text, ctx->state.init, INIT_SIZE_BYTE);\r\n+\r\n+    oaes_key_import_data(ctx->aes_ctx, ctx->state.hs.b, AES_KEY_SIZE);\r\n+    for (i = 0; likely(i < MEMORY); i += INIT_SIZE_BYTE) {\r\n+#undef RND\r\n+#define RND(p) aesb_pseudo_round_mut((uint8_t *)&ctx->text[AES_BLOCK_SIZE * p], (uint8_t *)ctx->aes_ctx->key->exp_data);\r\n+        RND(0);\r\n+        RND(1);\r\n+        RND(2);\r\n+        RND(3);\r\n+        RND(4);\r\n+        RND(5);\r\n+        RND(6);\r\n+        RND(7);\r\n+        memcpy(&ctx->long_state[i], ctx->text, INIT_SIZE_BYTE);\r\n+    }\r\n+\r\n+    xor_blocks_dst(&ctx->state.k[0], &ctx->state.k[32], ctx->a);\r\n+    xor_blocks_dst(&ctx->state.k[16], &ctx->state.k[48], ctx->b);\r\n+\r\n+    for (i = 0; likely(i < ITER / 4); ++i) {\r\n+        j = e2i(ctx->a) * AES_BLOCK_SIZE;\r\n+        aesb_single_round((const uint8_t *)&ctx->long_state[j], (uint8_t *)ctx->c, (uint8_t *)ctx->a);\r\n+        xor_blocks_dst(ctx->c, ctx->b, &ctx->long_state[j]);\r\n+\r\n+        mul_sum_xor_dst(ctx->c, ctx->a, &ctx->long_state[e2i(ctx->c) * AES_BLOCK_SIZE]);\r\n+\r\n+        j = e2i(ctx->a) * AES_BLOCK_SIZE;\r\n+        aesb_single_round((const uint8_t *)&ctx->long_state[j], (uint8_t *)ctx->b, (uint8_t *)ctx->a);\r\n+        xor_blocks_dst(ctx->b, ctx->c, &ctx->long_state[j]);\r\n+\r\n+        mul_sum_xor_dst(ctx->b, ctx->a, &ctx->long_state[e2i(ctx->b) * AES_BLOCK_SIZE]);\r\n+    }\r\n+\r\n+    memcpy(ctx->text, ctx->state.init, INIT_SIZE_BYTE);\r\n+    oaes_key_import_data(ctx->aes_ctx, &ctx->state.hs.b[32], AES_KEY_SIZE);\r\n+    for (i = 0; likely(i < MEMORY); i += INIT_SIZE_BYTE) {\r\n+#undef RND\r\n+#define RND(p) xor_blocks(&ctx->text[p * AES_BLOCK_SIZE], &ctx->long_state[i + p * AES_BLOCK_SIZE]); \\\r\n+        aesb_pseudo_round_mut((uint8_t *)&ctx->text[p * AES_BLOCK_SIZE], (uint8_t *)ctx->aes_ctx->key->exp_data);\r\n+        RND(0);\r\n+        RND(1);\r\n+        RND(2);\r\n+        RND(3);\r\n+        RND(4);\r\n+        RND(5);\r\n+        RND(6);\r\n+        RND(7);\r\n+    }\r\n+    memcpy(ctx->state.init, ctx->text, INIT_SIZE_BYTE);\r\n+    hash_permutation(&ctx->state.hs);\r\n+    extra_hashes[ctx->state.hs.b[0] & 3](&ctx->state, 200, (char *)output);\r\n+    oaes_free((OAES_CTX **) &ctx->aes_ctx);\r\n+}\r\n+\r\n+void cryptonight_hash(void* output, const void* input, size_t len) {\r\n+    struct cryptonight_ctx *ctx = (struct cryptonight_ctx*)malloc(sizeof(struct cryptonight_ctx));\r\n+    cryptonight_hash_ctx(output, input, len, ctx);\r\n+    free(ctx);\r\n+}\r"
      },
      {
        "sha": "9dd10d5386807d6ade57ce5f6c6e8d32e27cacb1",
        "filename": "src/crypto/cryptonight.h",
        "status": "added",
        "additions": 139,
        "deletions": 0,
        "changes": 139,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/cryptonight.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/cryptonight.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/cryptonight.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,139 @@\n+#ifndef _CRYPTONIGHT_H_\r\n+#define _CRYPTONIGHT_H_\r\n+\r\n+#include <crypto/types.h>\r\n+\r\n+#define MEMORY         (1 << 21) // 2 MiB / 2097152 B\r\n+#define ITER           (1 << 20) // 1048576\r\n+#define AES_BLOCK_SIZE  16\r\n+#define AES_KEY_SIZE    32\r\n+#define INIT_SIZE_BLK   8\r\n+#define INIT_SIZE_BYTE (INIT_SIZE_BLK * AES_BLOCK_SIZE) // 128 B\r\n+\r\n+#define AES_RKEY_LEN 4\r\n+#define AES_COL_LEN 4\r\n+#define AES_ROUND_BASE 7\r\n+\r\n+#ifndef HASH_SIZE\r\n+#define HASH_SIZE 32\r\n+#endif\r\n+\r\n+#ifndef HASH_DATA_AREA\r\n+#define HASH_DATA_AREA 136\r\n+#endif\r\n+\r\n+#define hi_dword(x) (x >> 32)\r\n+#define lo_dword(x) (x & 0xFFFFFFFF)\r\n+\r\n+#define C32(x)    ((uint32_t)(x ## U))\r\n+#define T32(x) ((x) & C32(0xFFFFFFFF))\r\n+\r\n+#ifndef _ROTL64\r\n+    #if __CUDA_ARCH__ >= 350\r\n+        __forceinline__ __device__ uint64_t cuda_ROTL64(const uint64_t value, const int offset) {\r\n+            uint2 result;\r\n+            if(offset >= 32) {\r\n+                asm(\"shf.l.wrap.b32 %0, %1, %2, %3;\" : \"=r\"(result.x) : \"r\"(__double2loint(__longlong_as_double(value))), \"r\"(__double2hiint(__longlong_as_double(value))), \"r\"(offset));\r\n+                asm(\"shf.l.wrap.b32 %0, %1, %2, %3;\" : \"=r\"(result.y) : \"r\"(__double2hiint(__longlong_as_double(value))), \"r\"(__double2loint(__longlong_as_double(value))), \"r\"(offset));\r\n+            } else {\r\n+                asm(\"shf.l.wrap.b32 %0, %1, %2, %3;\" : \"=r\"(result.x) : \"r\"(__double2hiint(__longlong_as_double(value))), \"r\"(__double2loint(__longlong_as_double(value))), \"r\"(offset));\r\n+                asm(\"shf.l.wrap.b32 %0, %1, %2, %3;\" : \"=r\"(result.y) : \"r\"(__double2loint(__longlong_as_double(value))), \"r\"(__double2hiint(__longlong_as_double(value))), \"r\"(offset));\r\n+            }\r\n+            return  __double_as_longlong(__hiloint2double(result.y, result.x));\r\n+        }\r\n+        #define _ROTL64(x, n) (cuda_ROTL64(x, n))\r\n+    #else\r\n+        #define _ROTL64(x, n)        (((x) << (n)) | ((x) >> (64 - (n))))\r\n+    #endif\r\n+#endif\r\n+\r\n+#ifndef _ROTL32\r\n+    #if __CUDA_ARCH__ < 350 \r\n+        #define _ROTL32(x, n) T32(((x) << (n)) | ((x) >> (32 - (n))))\r\n+    #else\r\n+        #define _ROTL32(x, n) __funnelshift_l( (x), (x), (n) )\r\n+    #endif\r\n+#endif\r\n+\r\n+#ifndef ROTR32\r\n+    #if __CUDA_ARCH__ < 350 \r\n+        #define ROTR32(x, n) (((x) >> (n)) | ((x) << (32 - (n))))\r\n+    #else\r\n+        #define ROTR32(x, n) __funnelshift_r( (x), (x), (n) )\r\n+    #endif\r\n+#endif\r\n+\r\n+#define MEMSET8(dst,what,cnt) { \\\r\n+    int i_memset8; \\\r\n+    uint64_t *out_memset8 = (uint64_t *)(dst); \\\r\n+    for( i_memset8 = 0; i_memset8 < cnt; i_memset8++ ) \\\r\n+        out_memset8[i_memset8] = (what); }\r\n+\r\n+#define MEMSET4(dst,what,cnt) { \\\r\n+    int i_memset4; \\\r\n+    uint32_t *out_memset4 = (uint32_t *)(dst); \\\r\n+    for( i_memset4 = 0; i_memset4 < cnt; i_memset4++ ) \\\r\n+        out_memset4[i_memset4] = (what); }\r\n+\r\n+#define MEMCPY8(dst,src,cnt) { \\\r\n+    int i_memcpy8; \\\r\n+    uint64_t *in_memcpy8 = (uint64_t *)(src); \\\r\n+    uint64_t *out_memcpy8 = (uint64_t *)(dst); \\\r\n+    for( i_memcpy8 = 0; i_memcpy8 < cnt; i_memcpy8++ ) \\\r\n+        out_memcpy8[i_memcpy8] = in_memcpy8[i_memcpy8]; }\r\n+\r\n+#define MEMCPY4(dst,src,cnt) { \\\r\n+    int i_memcpy4; \\\r\n+    uint32_t *in_memcpy4 = (uint32_t *)(src); \\\r\n+    uint32_t *out_memcpy4 = (uint32_t *)(dst); \\\r\n+    for( i_memcpy4 = 0; i_memcpy4 < cnt; i_memcpy4++ ) \\\r\n+        out_memcpy4[i_memcpy4] = in_memcpy4[i_memcpy4]; }\r\n+\r\n+#define XOR_BLOCKS(a,b) { \\\r\n+    ((uint64_t *)a)[0] ^= ((uint64_t *)b)[0]; \\\r\n+    ((uint64_t *)a)[1] ^= ((uint64_t *)b)[1]; }\r\n+\r\n+#define XOR_BLOCKS_DST(x,y,z) { \\\r\n+    ((uint64_t *)z)[0] = ((uint64_t *)(x))[0] ^ ((uint64_t *)(y))[0]; \\\r\n+    ((uint64_t *)z)[1] = ((uint64_t *)(x))[1] ^ ((uint64_t *)(y))[1]; }\r\n+\r\n+#define MUL_SUM_XOR_DST(a,c,dst) { \\\r\n+    uint64_t hi, lo = cuda_mul128(((uint64_t *)a)[0], ((uint64_t *)dst)[0], &hi) + ((uint64_t *)c)[1]; \\\r\n+    hi += ((uint64_t *)c)[0]; \\\r\n+    ((uint64_t *)c)[0] = ((uint64_t *)dst)[0] ^ hi; \\\r\n+    ((uint64_t *)c)[1] = ((uint64_t *)dst)[1] ^ lo; \\\r\n+    ((uint64_t *)dst)[0] = hi; \\\r\n+    ((uint64_t *)dst)[1] = lo; }\r\n+\r\n+#define E2I(x) ((size_t)(((*((uint64_t*)(x)) >> 4) & 0x1ffff)))\r\n+\r\n+union hash_state {\r\n+  uint8_t b[200];\r\n+  uint64_t w[25];\r\n+};\r\n+\r\n+union cn_slow_hash_state {\r\n+    union hash_state hs;\r\n+    struct {\r\n+        uint8_t k[64];\r\n+        uint8_t init[INIT_SIZE_BYTE];\r\n+    };\r\n+};\r\n+\r\n+struct cryptonight_gpu_ctx {\r\n+    uint32_t state[50];\r\n+    uint32_t a[4];\r\n+    uint32_t b[4];\r\n+    uint32_t key1[40];\r\n+    uint32_t key2[40];\r\n+    uint32_t text[32];\r\n+};\r\n+\r\n+#ifdef __cplusplus\r\n+extern \"C\"\r\n+#endif\r\n+void cryptonight_hash(void* output, const void* input, size_t len);\r\n+// void hash_permutation(union hash_state *state);\r\n+// void hash_process(union hash_state *state, const uint8_t *buf, size_t count);\r\n+\r\n+#endif\r"
      },
      {
        "sha": "4c99e47657fa446fe43d860bb84482dc25d9d98f",
        "filename": "src/crypto/groestl_tables.h",
        "status": "added",
        "additions": 38,
        "deletions": 0,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/groestl_tables.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/groestl_tables.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/groestl_tables.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,38 @@\n+#ifndef __tables_h\r\n+#define __tables_h\r\n+\r\n+\r\n+const uint32_t T[512] = {0xa5f432c6, 0xc6a597f4, 0x84976ff8, 0xf884eb97, 0x99b05eee, 0xee99c7b0, 0x8d8c7af6, 0xf68df78c, 0xd17e8ff, 0xff0de517, 0xbddc0ad6, 0xd6bdb7dc, 0xb1c816de, 0xdeb1a7c8, 0x54fc6d91, 0x915439fc\r\n+, 0x50f09060, 0x6050c0f0, 0x3050702, 0x2030405, 0xa9e02ece, 0xcea987e0, 0x7d87d156, 0x567dac87, 0x192bcce7, 0xe719d52b, 0x62a613b5, 0xb56271a6, 0xe6317c4d, 0x4de69a31, 0x9ab559ec, 0xec9ac3b5\r\n+, 0x45cf408f, 0x8f4505cf, 0x9dbca31f, 0x1f9d3ebc, 0x40c04989, 0x894009c0, 0x879268fa, 0xfa87ef92, 0x153fd0ef, 0xef15c53f, 0xeb2694b2, 0xb2eb7f26, 0xc940ce8e, 0x8ec90740, 0xb1de6fb, 0xfb0bed1d\r\n+, 0xec2f6e41, 0x41ec822f, 0x67a91ab3, 0xb3677da9, 0xfd1c435f, 0x5ffdbe1c, 0xea256045, 0x45ea8a25, 0xbfdaf923, 0x23bf46da, 0xf7025153, 0x53f7a602, 0x96a145e4, 0xe496d3a1, 0x5bed769b, 0x9b5b2ded\r\n+, 0xc25d2875, 0x75c2ea5d, 0x1c24c5e1, 0xe11cd924, 0xaee9d43d, 0x3dae7ae9, 0x6abef24c, 0x4c6a98be, 0x5aee826c, 0x6c5ad8ee, 0x41c3bd7e, 0x7e41fcc3, 0x206f3f5, 0xf502f106, 0x4fd15283, 0x834f1dd1\r\n+, 0x5ce48c68, 0x685cd0e4, 0xf4075651, 0x51f4a207, 0x345c8dd1, 0xd134b95c, 0x818e1f9, 0xf908e918, 0x93ae4ce2, 0xe293dfae, 0x73953eab, 0xab734d95, 0x53f59762, 0x6253c4f5, 0x3f416b2a, 0x2a3f5441\r\n+, 0xc141c08, 0x80c1014, 0x52f66395, 0x955231f6, 0x65afe946, 0x46658caf, 0x5ee27f9d, 0x9d5e21e2, 0x28784830, 0x30286078, 0xa1f8cf37, 0x37a16ef8, 0xf111b0a, 0xa0f1411, 0xb5c4eb2f, 0x2fb55ec4\r\n+, 0x91b150e, 0xe091c1b, 0x365a7e24, 0x2436485a, 0x9bb6ad1b, 0x1b9b36b6, 0x3d4798df, 0xdf3da547, 0x266aa7cd, 0xcd26816a, 0x69bbf54e, 0x4e699cbb, 0xcd4c337f, 0x7fcdfe4c, 0x9fba50ea, 0xea9fcfba\r\n+, 0x1b2d3f12, 0x121b242d, 0x9eb9a41d, 0x1d9e3ab9, 0x749cc458, 0x5874b09c, 0x2e724634, 0x342e6872, 0x2d774136, 0x362d6c77, 0xb2cd11dc, 0xdcb2a3cd, 0xee299db4, 0xb4ee7329, 0xfb164d5b, 0x5bfbb616\r\n+, 0xf601a5a4, 0xa4f65301, 0x4dd7a176, 0x764decd7, 0x61a314b7, 0xb76175a3, 0xce49347d, 0x7dcefa49, 0x7b8ddf52, 0x527ba48d, 0x3e429fdd, 0xdd3ea142, 0x7193cd5e, 0x5e71bc93, 0x97a2b113, 0x139726a2\r\n+, 0xf504a2a6, 0xa6f55704, 0x68b801b9, 0xb96869b8, 0x0, 0x0, 0x2c74b5c1, 0xc12c9974, 0x60a0e040, 0x406080a0, 0x1f21c2e3, 0xe31fdd21, 0xc8433a79, 0x79c8f243, 0xed2c9ab6, 0xb6ed772c\r\n+, 0xbed90dd4, 0xd4beb3d9, 0x46ca478d, 0x8d4601ca, 0xd9701767, 0x67d9ce70, 0x4bddaf72, 0x724be4dd, 0xde79ed94, 0x94de3379, 0xd467ff98, 0x98d42b67, 0xe82393b0, 0xb0e87b23, 0x4ade5b85, 0x854a11de\r\n+, 0x6bbd06bb, 0xbb6b6dbd, 0x2a7ebbc5, 0xc52a917e, 0xe5347b4f, 0x4fe59e34, 0x163ad7ed, 0xed16c13a, 0xc554d286, 0x86c51754, 0xd762f89a, 0x9ad72f62, 0x55ff9966, 0x6655ccff, 0x94a7b611, 0x119422a7\r\n+, 0xcf4ac08a, 0x8acf0f4a, 0x1030d9e9, 0xe910c930, 0x60a0e04, 0x406080a, 0x819866fe, 0xfe81e798, 0xf00baba0, 0xa0f05b0b, 0x44ccb478, 0x7844f0cc, 0xbad5f025, 0x25ba4ad5, 0xe33e754b, 0x4be3963e\r\n+, 0xf30eaca2, 0xa2f35f0e, 0xfe19445d, 0x5dfeba19, 0xc05bdb80, 0x80c01b5b, 0x8a858005, 0x58a0a85, 0xadecd33f, 0x3fad7eec, 0xbcdffe21, 0x21bc42df, 0x48d8a870, 0x7048e0d8, 0x40cfdf1, 0xf104f90c\r\n+, 0xdf7a1963, 0x63dfc67a, 0xc1582f77, 0x77c1ee58, 0x759f30af, 0xaf75459f, 0x63a5e742, 0x426384a5, 0x30507020, 0x20304050, 0x1a2ecbe5, 0xe51ad12e, 0xe12effd, 0xfd0ee112, 0x6db708bf, 0xbf6d65b7\r\n+, 0x4cd45581, 0x814c19d4, 0x143c2418, 0x1814303c, 0x355f7926, 0x26354c5f, 0x2f71b2c3, 0xc32f9d71, 0xe13886be, 0xbee16738, 0xa2fdc835, 0x35a26afd, 0xcc4fc788, 0x88cc0b4f, 0x394b652e, 0x2e395c4b\r\n+, 0x57f96a93, 0x93573df9, 0xf20d5855, 0x55f2aa0d, 0x829d61fc, 0xfc82e39d, 0x47c9b37a, 0x7a47f4c9, 0xacef27c8, 0xc8ac8bef, 0xe73288ba, 0xbae76f32, 0x2b7d4f32, 0x322b647d, 0x95a442e6, 0xe695d7a4\r\n+, 0xa0fb3bc0, 0xc0a09bfb, 0x98b3aa19, 0x199832b3, 0xd168f69e, 0x9ed12768, 0x7f8122a3, 0xa37f5d81, 0x66aaee44, 0x446688aa, 0x7e82d654, 0x547ea882, 0xabe6dd3b, 0x3bab76e6, 0x839e950b, 0xb83169e\r\n+, 0xca45c98c, 0x8cca0345, 0x297bbcc7, 0xc729957b, 0xd36e056b, 0x6bd3d66e, 0x3c446c28, 0x283c5044, 0x798b2ca7, 0xa779558b, 0xe23d81bc, 0xbce2633d, 0x1d273116, 0x161d2c27, 0x769a37ad, 0xad76419a\r\n+, 0x3b4d96db, 0xdb3bad4d, 0x56fa9e64, 0x6456c8fa, 0x4ed2a674, 0x744ee8d2, 0x1e223614, 0x141e2822, 0xdb76e492, 0x92db3f76, 0xa1e120c, 0xc0a181e, 0x6cb4fc48, 0x486c90b4, 0xe4378fb8, 0xb8e46b37\r\n+, 0x5de7789f, 0x9f5d25e7, 0x6eb20fbd, 0xbd6e61b2, 0xef2a6943, 0x43ef862a, 0xa6f135c4, 0xc4a693f1, 0xa8e3da39, 0x39a872e3, 0xa4f7c631, 0x31a462f7, 0x37598ad3, 0xd337bd59, 0x8b8674f2, 0xf28bff86\r\n+, 0x325683d5, 0xd532b156, 0x43c54e8b, 0x8b430dc5, 0x59eb856e, 0x6e59dceb, 0xb7c218da, 0xdab7afc2, 0x8c8f8e01, 0x18c028f, 0x64ac1db1, 0xb16479ac, 0xd26df19c, 0x9cd2236d, 0xe03b7249, 0x49e0923b\r\n+, 0xb4c71fd8, 0xd8b4abc7, 0xfa15b9ac, 0xacfa4315, 0x709faf3, 0xf307fd09, 0x256fa0cf, 0xcf25856f, 0xafea20ca, 0xcaaf8fea, 0x8e897df4, 0xf48ef389, 0xe9206747, 0x47e98e20, 0x18283810, 0x10182028\r\n+, 0xd5640b6f, 0x6fd5de64, 0x888373f0, 0xf088fb83, 0x6fb1fb4a, 0x4a6f94b1, 0x7296ca5c, 0x5c72b896, 0x246c5438, 0x3824706c, 0xf1085f57, 0x57f1ae08, 0xc7522173, 0x73c7e652, 0x51f36497, 0x975135f3\r\n+, 0x2365aecb, 0xcb238d65, 0x7c8425a1, 0xa17c5984, 0x9cbf57e8, 0xe89ccbbf, 0x21635d3e, 0x3e217c63, 0xdd7cea96, 0x96dd377c, 0xdc7f1e61, 0x61dcc27f, 0x86919c0d, 0xd861a91, 0x85949b0f, 0xf851e94\r\n+, 0x90ab4be0, 0xe090dbab, 0x42c6ba7c, 0x7c42f8c6, 0xc4572671, 0x71c4e257, 0xaae529cc, 0xccaa83e5, 0xd873e390, 0x90d83b73, 0x50f0906, 0x6050c0f, 0x103f4f7, 0xf701f503, 0x12362a1c, 0x1c123836\r\n+, 0xa3fe3cc2, 0xc2a39ffe, 0x5fe18b6a, 0x6a5fd4e1, 0xf910beae, 0xaef94710, 0xd06b0269, 0x69d0d26b, 0x91a8bf17, 0x17912ea8, 0x58e87199, 0x995829e8, 0x2769533a, 0x3a277469, 0xb9d0f727, 0x27b94ed0\r\n+, 0x384891d9, 0xd938a948, 0x1335deeb, 0xeb13cd35, 0xb3cee52b, 0x2bb356ce, 0x33557722, 0x22334455, 0xbbd604d2, 0xd2bbbfd6, 0x709039a9, 0xa9704990, 0x89808707, 0x7890e80, 0xa7f2c133, 0x33a766f2\r\n+, 0xb6c1ec2d, 0x2db65ac1, 0x22665a3c, 0x3c227866, 0x92adb815, 0x15922aad, 0x2060a9c9, 0xc9208960, 0x49db5c87, 0x874915db, 0xff1ab0aa, 0xaaff4f1a, 0x7888d850, 0x5078a088, 0x7a8e2ba5, 0xa57a518e\r\n+, 0x8f8a8903, 0x38f068a, 0xf8134a59, 0x59f8b213, 0x809b9209, 0x980129b, 0x1739231a, 0x1a173439, 0xda751065, 0x65daca75, 0x315384d7, 0xd731b553, 0xc651d584, 0x84c61351, 0xb8d303d0, 0xd0b8bbd3\r\n+, 0xc35edc82, 0x82c31f5e, 0xb0cbe229, 0x29b052cb, 0x7799c35a, 0x5a77b499, 0x11332d1e, 0x1e113c33, 0xcb463d7b, 0x7bcbf646, 0xfc1fb7a8, 0xa8fc4b1f, 0xd6610c6d, 0x6dd6da61, 0x3a4e622c, 0x2c3a584e};\r\n+\r\n+#endif /* __tables_h */\r"
      },
      {
        "sha": "4df9b9a5c7d446ecd205433d56e53459a5f856c4",
        "filename": "src/crypto/oaes_config.h",
        "status": "added",
        "additions": 51,
        "deletions": 0,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/oaes_config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/oaes_config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/oaes_config.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,51 @@\n+/* \r\n+ * ---------------------------------------------------------------------------\r\n+ * OpenAES License\r\n+ * ---------------------------------------------------------------------------\r\n+ * Copyright (c) 2012, Nabil S. Al Ramli, www.nalramli.com\r\n+ * All rights reserved.\r\n+ * \r\n+ * Redistribution and use in source and binary forms, with or without\r\n+ * modification, are permitted provided that the following conditions are met:\r\n+ * \r\n+ *   - Redistributions of source code must retain the above copyright notice,\r\n+ *     this list of conditions and the following disclaimer.\r\n+ *   - Redistributions in binary form must reproduce the above copyright\r\n+ *     notice, this list of conditions and the following disclaimer in the\r\n+ *     documentation and/or other materials provided with the distribution.\r\n+ * \r\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n+ * POSSIBILITY OF SUCH DAMAGE.\r\n+ * ---------------------------------------------------------------------------\r\n+ */\r\n+\r\n+#ifndef _OAES_CONFIG_H\r\n+#define _OAES_CONFIG_H\r\n+\r\n+#ifdef __cplusplus \r\n+extern \"C\" {\r\n+#endif\r\n+\r\n+//#ifndef OAES_HAVE_ISAAC\r\n+//#define OAES_HAVE_ISAAC 1\r\n+//#endif // OAES_HAVE_ISAAC\r\n+\r\n+//#ifndef OAES_DEBUG\r\n+//#define OAES_DEBUG 0\r\n+//#endif // OAES_DEBUG\r\n+//#define OAES_DEBUG 1\r\n+\r\n+#ifdef __cplusplus \r\n+}\r\n+#endif\r\n+\r\n+#endif // _OAES_CONFIG_H\r"
      },
      {
        "sha": "7ea9fe84160dbaf862e608c34cdef002e133bc3e",
        "filename": "src/crypto/oaes_lib.c",
        "status": "added",
        "additions": 1455,
        "deletions": 0,
        "changes": 1455,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/oaes_lib.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/oaes_lib.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/oaes_lib.c?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,1455 @@\n+/* \r\n+ * ---------------------------------------------------------------------------\r\n+ * OpenAES License\r\n+ * ---------------------------------------------------------------------------\r\n+ * Copyright (c) 2012, Nabil S. Al Ramli, www.nalramli.com\r\n+ * All rights reserved.\r\n+ * \r\n+ * Redistribution and use in source and binary forms, with or without\r\n+ * modification, are permitted provided that the following conditions are met:\r\n+ * \r\n+ *   - Redistributions of source code must retain the above copyright notice,\r\n+ *     this list of conditions and the following disclaimer.\r\n+ *   - Redistributions in binary form must reproduce the above copyright\r\n+ *     notice, this list of conditions and the following disclaimer in the\r\n+ *     documentation and/or other materials provided with the distribution.\r\n+ * \r\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n+ * POSSIBILITY OF SUCH DAMAGE.\r\n+ * ---------------------------------------------------------------------------\r\n+ */\r\n+static const char _NR[] = {\r\n+\t0x4e,0x61,0x62,0x69,0x6c,0x20,0x53,0x2e,0x20,\r\n+\t0x41,0x6c,0x20,0x52,0x61,0x6d,0x6c,0x69,0x00 };\r\n+\r\n+#include <crypto/types.h>\r\n+\r\n+#include <stddef.h>\r\n+#include <time.h> \r\n+#include <sys/timeb.h>\r\n+#if !((defined(__FreeBSD__) && __FreeBSD__ >= 10) || defined(__APPLE__))\r\n+#include <malloc.h>\r\n+#endif\r\n+#include <string.h>\r\n+#include <stdlib.h>\r\n+#include <stdio.h>\r\n+\r\n+#ifdef WIN32\r\n+#include <process.h>\r\n+#else\r\n+#include <sys/types.h>\r\n+#include <unistd.h>\r\n+#endif\r\n+\r\n+#include <crypto/oaes_config.h>\r\n+#include <crypto/oaes_lib.h>\r\n+\r\n+#ifdef OAES_HAVE_ISAAC\r\n+#include \"rand.h\"\r\n+#endif // OAES_HAVE_ISAAC\r\n+\r\n+#define OAES_RKEY_LEN 4\r\n+#define OAES_COL_LEN 4\r\n+#define OAES_ROUND_BASE 7\r\n+\r\n+// the block is padded\r\n+#define OAES_FLAG_PAD 0x01\r\n+\r\n+#ifndef min\r\n+# define min(a,b) (((a)<(b)) ? (a) : (b))\r\n+#endif /* min */\r\n+\r\n+// \"OAES<8-bit header version><8-bit type><16-bit options><8-bit flags><56-bit reserved>\"\r\n+static uint8_t oaes_header[OAES_BLOCK_SIZE] = {\r\n+\t// \t\t0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,\r\n+\t/*0*/\t0x4f, 0x41, 0x45, 0x53, 0x01, 0x02, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,\r\n+};\r\n+static uint8_t oaes_gf_8[] = {\r\n+\t0x01, 0x02, 0x04, 0x08, 0x10, 0x20, 0x40, 0x80, 0x1b, 0x36 };\r\n+\r\n+static uint8_t oaes_sub_byte_value[16][16] = {\r\n+\t// \t\t0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,\r\n+\t/*0*/\t{ 0x63, 0x7c, 0x77, 0x7b, 0xf2, 0x6b, 0x6f, 0xc5, 0x30, 0x01, 0x67, 0x2b, 0xfe, 0xd7, 0xab, 0x76 },\r\n+\t/*1*/\t{ 0xca, 0x82, 0xc9, 0x7d, 0xfa, 0x59, 0x47, 0xf0, 0xad, 0xd4, 0xa2, 0xaf, 0x9c, 0xa4, 0x72, 0xc0 },\r\n+\t/*2*/\t{ 0xb7, 0xfd, 0x93, 0x26, 0x36, 0x3f, 0xf7, 0xcc, 0x34, 0xa5, 0xe5, 0xf1, 0x71, 0xd8, 0x31, 0x15 },\r\n+\t/*3*/\t{ 0x04, 0xc7, 0x23, 0xc3, 0x18, 0x96, 0x05, 0x9a, 0x07, 0x12, 0x80, 0xe2, 0xeb, 0x27, 0xb2, 0x75 },\r\n+\t/*4*/\t{ 0x09, 0x83, 0x2c, 0x1a, 0x1b, 0x6e, 0x5a, 0xa0, 0x52, 0x3b, 0xd6, 0xb3, 0x29, 0xe3, 0x2f, 0x84 },\r\n+\t/*5*/\t{ 0x53, 0xd1, 0x00, 0xed, 0x20, 0xfc, 0xb1, 0x5b, 0x6a, 0xcb, 0xbe, 0x39, 0x4a, 0x4c, 0x58, 0xcf },\r\n+\t/*6*/\t{ 0xd0, 0xef, 0xaa, 0xfb, 0x43, 0x4d, 0x33, 0x85, 0x45, 0xf9, 0x02, 0x7f, 0x50, 0x3c, 0x9f, 0xa8 },\r\n+\t/*7*/\t{ 0x51, 0xa3, 0x40, 0x8f, 0x92, 0x9d, 0x38, 0xf5, 0xbc, 0xb6, 0xda, 0x21, 0x10, 0xff, 0xf3, 0xd2 },\r\n+\t/*8*/\t{ 0xcd, 0x0c, 0x13, 0xec, 0x5f, 0x97, 0x44, 0x17, 0xc4, 0xa7, 0x7e, 0x3d, 0x64, 0x5d, 0x19, 0x73 },\r\n+\t/*9*/\t{ 0x60, 0x81, 0x4f, 0xdc, 0x22, 0x2a, 0x90, 0x88, 0x46, 0xee, 0xb8, 0x14, 0xde, 0x5e, 0x0b, 0xdb },\r\n+\t/*a*/\t{ 0xe0, 0x32, 0x3a, 0x0a, 0x49, 0x06, 0x24, 0x5c, 0xc2, 0xd3, 0xac, 0x62, 0x91, 0x95, 0xe4, 0x79 },\r\n+\t/*b*/\t{ 0xe7, 0xc8, 0x37, 0x6d, 0x8d, 0xd5, 0x4e, 0xa9, 0x6c, 0x56, 0xf4, 0xea, 0x65, 0x7a, 0xae, 0x08 },\r\n+\t/*c*/\t{ 0xba, 0x78, 0x25, 0x2e, 0x1c, 0xa6, 0xb4, 0xc6, 0xe8, 0xdd, 0x74, 0x1f, 0x4b, 0xbd, 0x8b, 0x8a },\r\n+\t/*d*/\t{ 0x70, 0x3e, 0xb5, 0x66, 0x48, 0x03, 0xf6, 0x0e, 0x61, 0x35, 0x57, 0xb9, 0x86, 0xc1, 0x1d, 0x9e },\r\n+\t/*e*/\t{ 0xe1, 0xf8, 0x98, 0x11, 0x69, 0xd9, 0x8e, 0x94, 0x9b, 0x1e, 0x87, 0xe9, 0xce, 0x55, 0x28, 0xdf },\r\n+\t/*f*/\t{ 0x8c, 0xa1, 0x89, 0x0d, 0xbf, 0xe6, 0x42, 0x68, 0x41, 0x99, 0x2d, 0x0f, 0xb0, 0x54, 0xbb, 0x16 },\r\n+};\r\n+\r\n+static uint8_t oaes_inv_sub_byte_value[16][16] = {\r\n+\t// \t\t0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,\r\n+\t/*0*/\t{ 0x52, 0x09, 0x6a, 0xd5, 0x30, 0x36, 0xa5, 0x38, 0xbf, 0x40, 0xa3, 0x9e, 0x81, 0xf3, 0xd7, 0xfb },\r\n+\t/*1*/\t{ 0x7c, 0xe3, 0x39, 0x82, 0x9b, 0x2f, 0xff, 0x87, 0x34, 0x8e, 0x43, 0x44, 0xc4, 0xde, 0xe9, 0xcb },\r\n+\t/*2*/\t{ 0x54, 0x7b, 0x94, 0x32, 0xa6, 0xc2, 0x23, 0x3d, 0xee, 0x4c, 0x95, 0x0b, 0x42, 0xfa, 0xc3, 0x4e },\r\n+\t/*3*/\t{ 0x08, 0x2e, 0xa1, 0x66, 0x28, 0xd9, 0x24, 0xb2, 0x76, 0x5b, 0xa2, 0x49, 0x6d, 0x8b, 0xd1, 0x25 },\r\n+\t/*4*/\t{ 0x72, 0xf8, 0xf6, 0x64, 0x86, 0x68, 0x98, 0x16, 0xd4, 0xa4, 0x5c, 0xcc, 0x5d, 0x65, 0xb6, 0x92 },\r\n+\t/*5*/\t{ 0x6c, 0x70, 0x48, 0x50, 0xfd, 0xed, 0xb9, 0xda, 0x5e, 0x15, 0x46, 0x57, 0xa7, 0x8d, 0x9d, 0x84 },\r\n+\t/*6*/\t{ 0x90, 0xd8, 0xab, 0x00, 0x8c, 0xbc, 0xd3, 0x0a, 0xf7, 0xe4, 0x58, 0x05, 0xb8, 0xb3, 0x45, 0x06 },\r\n+\t/*7*/\t{ 0xd0, 0x2c, 0x1e, 0x8f, 0xca, 0x3f, 0x0f, 0x02, 0xc1, 0xaf, 0xbd, 0x03, 0x01, 0x13, 0x8a, 0x6b },\r\n+\t/*8*/\t{ 0x3a, 0x91, 0x11, 0x41, 0x4f, 0x67, 0xdc, 0xea, 0x97, 0xf2, 0xcf, 0xce, 0xf0, 0xb4, 0xe6, 0x73 },\r\n+\t/*9*/\t{ 0x96, 0xac, 0x74, 0x22, 0xe7, 0xad, 0x35, 0x85, 0xe2, 0xf9, 0x37, 0xe8, 0x1c, 0x75, 0xdf, 0x6e },\r\n+\t/*a*/\t{ 0x47, 0xf1, 0x1a, 0x71, 0x1d, 0x29, 0xc5, 0x89, 0x6f, 0xb7, 0x62, 0x0e, 0xaa, 0x18, 0xbe, 0x1b },\r\n+\t/*b*/\t{ 0xfc, 0x56, 0x3e, 0x4b, 0xc6, 0xd2, 0x79, 0x20, 0x9a, 0xdb, 0xc0, 0xfe, 0x78, 0xcd, 0x5a, 0xf4 },\r\n+\t/*c*/\t{ 0x1f, 0xdd, 0xa8, 0x33, 0x88, 0x07, 0xc7, 0x31, 0xb1, 0x12, 0x10, 0x59, 0x27, 0x80, 0xec, 0x5f },\r\n+\t/*d*/\t{ 0x60, 0x51, 0x7f, 0xa9, 0x19, 0xb5, 0x4a, 0x0d, 0x2d, 0xe5, 0x7a, 0x9f, 0x93, 0xc9, 0x9c, 0xef },\r\n+\t/*e*/\t{ 0xa0, 0xe0, 0x3b, 0x4d, 0xae, 0x2a, 0xf5, 0xb0, 0xc8, 0xeb, 0xbb, 0x3c, 0x83, 0x53, 0x99, 0x61 },\r\n+\t/*f*/\t{ 0x17, 0x2b, 0x04, 0x7e, 0xba, 0x77, 0xd6, 0x26, 0xe1, 0x69, 0x14, 0x63, 0x55, 0x21, 0x0c, 0x7d },\r\n+};\r\n+\r\n+static uint8_t oaes_gf_mul_2[16][16] = {\r\n+\t// \t\t0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,\r\n+\t/*0*/\t{ 0x00, 0x02, 0x04, 0x06, 0x08, 0x0a, 0x0c, 0x0e, 0x10, 0x12, 0x14, 0x16, 0x18, 0x1a, 0x1c, 0x1e },\r\n+\t/*1*/\t{ 0x20, 0x22, 0x24, 0x26, 0x28, 0x2a, 0x2c, 0x2e, 0x30, 0x32, 0x34, 0x36, 0x38, 0x3a, 0x3c, 0x3e },\r\n+\t/*2*/\t{ 0x40, 0x42, 0x44, 0x46, 0x48, 0x4a, 0x4c, 0x4e, 0x50, 0x52, 0x54, 0x56, 0x58, 0x5a, 0x5c, 0x5e },\r\n+\t/*3*/\t{ 0x60, 0x62, 0x64, 0x66, 0x68, 0x6a, 0x6c, 0x6e, 0x70, 0x72, 0x74, 0x76, 0x78, 0x7a, 0x7c, 0x7e },\r\n+\t/*4*/\t{ 0x80, 0x82, 0x84, 0x86, 0x88, 0x8a, 0x8c, 0x8e, 0x90, 0x92, 0x94, 0x96, 0x98, 0x9a, 0x9c, 0x9e },\r\n+\t/*5*/\t{ 0xa0, 0xa2, 0xa4, 0xa6, 0xa8, 0xaa, 0xac, 0xae, 0xb0, 0xb2, 0xb4, 0xb6, 0xb8, 0xba, 0xbc, 0xbe },\r\n+\t/*6*/\t{ 0xc0, 0xc2, 0xc4, 0xc6, 0xc8, 0xca, 0xcc, 0xce, 0xd0, 0xd2, 0xd4, 0xd6, 0xd8, 0xda, 0xdc, 0xde },\r\n+\t/*7*/\t{ 0xe0, 0xe2, 0xe4, 0xe6, 0xe8, 0xea, 0xec, 0xee, 0xf0, 0xf2, 0xf4, 0xf6, 0xf8, 0xfa, 0xfc, 0xfe },\r\n+\t/*8*/\t{ 0x1b, 0x19, 0x1f, 0x1d, 0x13, 0x11, 0x17, 0x15, 0x0b, 0x09, 0x0f, 0x0d, 0x03, 0x01, 0x07, 0x05 },\r\n+\t/*9*/\t{ 0x3b, 0x39, 0x3f, 0x3d, 0x33, 0x31, 0x37, 0x35, 0x2b, 0x29, 0x2f, 0x2d, 0x23, 0x21, 0x27, 0x25 },\r\n+\t/*a*/\t{ 0x5b, 0x59, 0x5f, 0x5d, 0x53, 0x51, 0x57, 0x55, 0x4b, 0x49, 0x4f, 0x4d, 0x43, 0x41, 0x47, 0x45 },\r\n+\t/*b*/\t{ 0x7b, 0x79, 0x7f, 0x7d, 0x73, 0x71, 0x77, 0x75, 0x6b, 0x69, 0x6f, 0x6d, 0x63, 0x61, 0x67, 0x65 },\r\n+\t/*c*/\t{ 0x9b, 0x99, 0x9f, 0x9d, 0x93, 0x91, 0x97, 0x95, 0x8b, 0x89, 0x8f, 0x8d, 0x83, 0x81, 0x87, 0x85 },\r\n+\t/*d*/\t{ 0xbb, 0xb9, 0xbf, 0xbd, 0xb3, 0xb1, 0xb7, 0xb5, 0xab, 0xa9, 0xaf, 0xad, 0xa3, 0xa1, 0xa7, 0xa5 },\r\n+\t/*e*/\t{ 0xdb, 0xd9, 0xdf, 0xdd, 0xd3, 0xd1, 0xd7, 0xd5, 0xcb, 0xc9, 0xcf, 0xcd, 0xc3, 0xc1, 0xc7, 0xc5 },\r\n+\t/*f*/\t{ 0xfb, 0xf9, 0xff, 0xfd, 0xf3, 0xf1, 0xf7, 0xf5, 0xeb, 0xe9, 0xef, 0xed, 0xe3, 0xe1, 0xe7, 0xe5 },\r\n+};\r\n+\r\n+static uint8_t oaes_gf_mul_3[16][16] = {\r\n+\t// \t\t0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,\r\n+\t/*0*/\t{ 0x00, 0x03, 0x06, 0x05, 0x0c, 0x0f, 0x0a, 0x09, 0x18, 0x1b, 0x1e, 0x1d, 0x14, 0x17, 0x12, 0x11 },\r\n+\t/*1*/\t{ 0x30, 0x33, 0x36, 0x35, 0x3c, 0x3f, 0x3a, 0x39, 0x28, 0x2b, 0x2e, 0x2d, 0x24, 0x27, 0x22, 0x21 },\r\n+\t/*2*/\t{ 0x60, 0x63, 0x66, 0x65, 0x6c, 0x6f, 0x6a, 0x69, 0x78, 0x7b, 0x7e, 0x7d, 0x74, 0x77, 0x72, 0x71 },\r\n+\t/*3*/\t{ 0x50, 0x53, 0x56, 0x55, 0x5c, 0x5f, 0x5a, 0x59, 0x48, 0x4b, 0x4e, 0x4d, 0x44, 0x47, 0x42, 0x41 },\r\n+\t/*4*/\t{ 0xc0, 0xc3, 0xc6, 0xc5, 0xcc, 0xcf, 0xca, 0xc9, 0xd8, 0xdb, 0xde, 0xdd, 0xd4, 0xd7, 0xd2, 0xd1 },\r\n+\t/*5*/\t{ 0xf0, 0xf3, 0xf6, 0xf5, 0xfc, 0xff, 0xfa, 0xf9, 0xe8, 0xeb, 0xee, 0xed, 0xe4, 0xe7, 0xe2, 0xe1 },\r\n+\t/*6*/\t{ 0xa0, 0xa3, 0xa6, 0xa5, 0xac, 0xaf, 0xaa, 0xa9, 0xb8, 0xbb, 0xbe, 0xbd, 0xb4, 0xb7, 0xb2, 0xb1 },\r\n+\t/*7*/\t{ 0x90, 0x93, 0x96, 0x95, 0x9c, 0x9f, 0x9a, 0x99, 0x88, 0x8b, 0x8e, 0x8d, 0x84, 0x87, 0x82, 0x81 },\r\n+\t/*8*/\t{ 0x9b, 0x98, 0x9d, 0x9e, 0x97, 0x94, 0x91, 0x92, 0x83, 0x80, 0x85, 0x86, 0x8f, 0x8c, 0x89, 0x8a },\r\n+\t/*9*/\t{ 0xab, 0xa8, 0xad, 0xae, 0xa7, 0xa4, 0xa1, 0xa2, 0xb3, 0xb0, 0xb5, 0xb6, 0xbf, 0xbc, 0xb9, 0xba },\r\n+\t/*a*/\t{ 0xfb, 0xf8, 0xfd, 0xfe, 0xf7, 0xf4, 0xf1, 0xf2, 0xe3, 0xe0, 0xe5, 0xe6, 0xef, 0xec, 0xe9, 0xea },\r\n+\t/*b*/\t{ 0xcb, 0xc8, 0xcd, 0xce, 0xc7, 0xc4, 0xc1, 0xc2, 0xd3, 0xd0, 0xd5, 0xd6, 0xdf, 0xdc, 0xd9, 0xda },\r\n+\t/*c*/\t{ 0x5b, 0x58, 0x5d, 0x5e, 0x57, 0x54, 0x51, 0x52, 0x43, 0x40, 0x45, 0x46, 0x4f, 0x4c, 0x49, 0x4a },\r\n+\t/*d*/\t{ 0x6b, 0x68, 0x6d, 0x6e, 0x67, 0x64, 0x61, 0x62, 0x73, 0x70, 0x75, 0x76, 0x7f, 0x7c, 0x79, 0x7a },\r\n+\t/*e*/\t{ 0x3b, 0x38, 0x3d, 0x3e, 0x37, 0x34, 0x31, 0x32, 0x23, 0x20, 0x25, 0x26, 0x2f, 0x2c, 0x29, 0x2a },\r\n+\t/*f*/\t{ 0x0b, 0x08, 0x0d, 0x0e, 0x07, 0x04, 0x01, 0x02, 0x13, 0x10, 0x15, 0x16, 0x1f, 0x1c, 0x19, 0x1a },\r\n+};\r\n+\r\n+static uint8_t oaes_gf_mul_9[16][16] = {\r\n+\t// \t\t0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,\r\n+\t/*0*/\t{ 0x00, 0x09, 0x12, 0x1b, 0x24, 0x2d, 0x36, 0x3f, 0x48, 0x41, 0x5a, 0x53, 0x6c, 0x65, 0x7e, 0x77 },\r\n+\t/*1*/\t{ 0x90, 0x99, 0x82, 0x8b, 0xb4, 0xbd, 0xa6, 0xaf, 0xd8, 0xd1, 0xca, 0xc3, 0xfc, 0xf5, 0xee, 0xe7 },\r\n+\t/*2*/\t{ 0x3b, 0x32, 0x29, 0x20, 0x1f, 0x16, 0x0d, 0x04, 0x73, 0x7a, 0x61, 0x68, 0x57, 0x5e, 0x45, 0x4c },\r\n+\t/*3*/\t{ 0xab, 0xa2, 0xb9, 0xb0, 0x8f, 0x86, 0x9d, 0x94, 0xe3, 0xea, 0xf1, 0xf8, 0xc7, 0xce, 0xd5, 0xdc },\r\n+\t/*4*/\t{ 0x76, 0x7f, 0x64, 0x6d, 0x52, 0x5b, 0x40, 0x49, 0x3e, 0x37, 0x2c, 0x25, 0x1a, 0x13, 0x08, 0x01 },\r\n+\t/*5*/\t{ 0xe6, 0xef, 0xf4, 0xfd, 0xc2, 0xcb, 0xd0, 0xd9, 0xae, 0xa7, 0xbc, 0xb5, 0x8a, 0x83, 0x98, 0x91 },\r\n+\t/*6*/\t{ 0x4d, 0x44, 0x5f, 0x56, 0x69, 0x60, 0x7b, 0x72, 0x05, 0x0c, 0x17, 0x1e, 0x21, 0x28, 0x33, 0x3a },\r\n+\t/*7*/\t{ 0xdd, 0xd4, 0xcf, 0xc6, 0xf9, 0xf0, 0xeb, 0xe2, 0x95, 0x9c, 0x87, 0x8e, 0xb1, 0xb8, 0xa3, 0xaa },\r\n+\t/*8*/\t{ 0xec, 0xe5, 0xfe, 0xf7, 0xc8, 0xc1, 0xda, 0xd3, 0xa4, 0xad, 0xb6, 0xbf, 0x80, 0x89, 0x92, 0x9b },\r\n+\t/*9*/\t{ 0x7c, 0x75, 0x6e, 0x67, 0x58, 0x51, 0x4a, 0x43, 0x34, 0x3d, 0x26, 0x2f, 0x10, 0x19, 0x02, 0x0b },\r\n+\t/*a*/\t{ 0xd7, 0xde, 0xc5, 0xcc, 0xf3, 0xfa, 0xe1, 0xe8, 0x9f, 0x96, 0x8d, 0x84, 0xbb, 0xb2, 0xa9, 0xa0 },\r\n+\t/*b*/\t{ 0x47, 0x4e, 0x55, 0x5c, 0x63, 0x6a, 0x71, 0x78, 0x0f, 0x06, 0x1d, 0x14, 0x2b, 0x22, 0x39, 0x30 },\r\n+\t/*c*/\t{ 0x9a, 0x93, 0x88, 0x81, 0xbe, 0xb7, 0xac, 0xa5, 0xd2, 0xdb, 0xc0, 0xc9, 0xf6, 0xff, 0xe4, 0xed },\r\n+\t/*d*/\t{ 0x0a, 0x03, 0x18, 0x11, 0x2e, 0x27, 0x3c, 0x35, 0x42, 0x4b, 0x50, 0x59, 0x66, 0x6f, 0x74, 0x7d },\r\n+\t/*e*/\t{ 0xa1, 0xa8, 0xb3, 0xba, 0x85, 0x8c, 0x97, 0x9e, 0xe9, 0xe0, 0xfb, 0xf2, 0xcd, 0xc4, 0xdf, 0xd6 },\r\n+\t/*f*/\t{ 0x31, 0x38, 0x23, 0x2a, 0x15, 0x1c, 0x07, 0x0e, 0x79, 0x70, 0x6b, 0x62, 0x5d, 0x54, 0x4f, 0x46 },\r\n+};\r\n+\r\n+static uint8_t oaes_gf_mul_b[16][16] = {\r\n+\t// \t\t0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,\r\n+\t/*0*/\t{ 0x00, 0x0b, 0x16, 0x1d, 0x2c, 0x27, 0x3a, 0x31, 0x58, 0x53, 0x4e, 0x45, 0x74, 0x7f, 0x62, 0x69 },\r\n+\t/*1*/\t{ 0xb0, 0xbb, 0xa6, 0xad, 0x9c, 0x97, 0x8a, 0x81, 0xe8, 0xe3, 0xfe, 0xf5, 0xc4, 0xcf, 0xd2, 0xd9 },\r\n+\t/*2*/\t{ 0x7b, 0x70, 0x6d, 0x66, 0x57, 0x5c, 0x41, 0x4a, 0x23, 0x28, 0x35, 0x3e, 0x0f, 0x04, 0x19, 0x12 },\r\n+\t/*3*/\t{ 0xcb, 0xc0, 0xdd, 0xd6, 0xe7, 0xec, 0xf1, 0xfa, 0x93, 0x98, 0x85, 0x8e, 0xbf, 0xb4, 0xa9, 0xa2 },\r\n+\t/*4*/\t{ 0xf6, 0xfd, 0xe0, 0xeb, 0xda, 0xd1, 0xcc, 0xc7, 0xae, 0xa5, 0xb8, 0xb3, 0x82, 0x89, 0x94, 0x9f },\r\n+\t/*5*/\t{ 0x46, 0x4d, 0x50, 0x5b, 0x6a, 0x61, 0x7c, 0x77, 0x1e, 0x15, 0x08, 0x03, 0x32, 0x39, 0x24, 0x2f },\r\n+\t/*6*/\t{ 0x8d, 0x86, 0x9b, 0x90, 0xa1, 0xaa, 0xb7, 0xbc, 0xd5, 0xde, 0xc3, 0xc8, 0xf9, 0xf2, 0xef, 0xe4 },\r\n+\t/*7*/\t{ 0x3d, 0x36, 0x2b, 0x20, 0x11, 0x1a, 0x07, 0x0c, 0x65, 0x6e, 0x73, 0x78, 0x49, 0x42, 0x5f, 0x54 },\r\n+\t/*8*/\t{ 0xf7, 0xfc, 0xe1, 0xea, 0xdb, 0xd0, 0xcd, 0xc6, 0xaf, 0xa4, 0xb9, 0xb2, 0x83, 0x88, 0x95, 0x9e },\r\n+\t/*9*/\t{ 0x47, 0x4c, 0x51, 0x5a, 0x6b, 0x60, 0x7d, 0x76, 0x1f, 0x14, 0x09, 0x02, 0x33, 0x38, 0x25, 0x2e },\r\n+\t/*a*/\t{ 0x8c, 0x87, 0x9a, 0x91, 0xa0, 0xab, 0xb6, 0xbd, 0xd4, 0xdf, 0xc2, 0xc9, 0xf8, 0xf3, 0xee, 0xe5 },\r\n+\t/*b*/\t{ 0x3c, 0x37, 0x2a, 0x21, 0x10, 0x1b, 0x06, 0x0d, 0x64, 0x6f, 0x72, 0x79, 0x48, 0x43, 0x5e, 0x55 },\r\n+\t/*c*/\t{ 0x01, 0x0a, 0x17, 0x1c, 0x2d, 0x26, 0x3b, 0x30, 0x59, 0x52, 0x4f, 0x44, 0x75, 0x7e, 0x63, 0x68 },\r\n+\t/*d*/\t{ 0xb1, 0xba, 0xa7, 0xac, 0x9d, 0x96, 0x8b, 0x80, 0xe9, 0xe2, 0xff, 0xf4, 0xc5, 0xce, 0xd3, 0xd8 },\r\n+\t/*e*/\t{ 0x7a, 0x71, 0x6c, 0x67, 0x56, 0x5d, 0x40, 0x4b, 0x22, 0x29, 0x34, 0x3f, 0x0e, 0x05, 0x18, 0x13 },\r\n+\t/*f*/\t{ 0xca, 0xc1, 0xdc, 0xd7, 0xe6, 0xed, 0xf0, 0xfb, 0x92, 0x99, 0x84, 0x8f, 0xbe, 0xb5, 0xa8, 0xa3 },\r\n+};\r\n+\r\n+static uint8_t oaes_gf_mul_d[16][16] = {\r\n+\t// \t\t0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,\r\n+\t/*0*/\t{ 0x00, 0x0d, 0x1a, 0x17, 0x34, 0x39, 0x2e, 0x23, 0x68, 0x65, 0x72, 0x7f, 0x5c, 0x51, 0x46, 0x4b },\r\n+\t/*1*/\t{ 0xd0, 0xdd, 0xca, 0xc7, 0xe4, 0xe9, 0xfe, 0xf3, 0xb8, 0xb5, 0xa2, 0xaf, 0x8c, 0x81, 0x96, 0x9b },\r\n+\t/*2*/\t{ 0xbb, 0xb6, 0xa1, 0xac, 0x8f, 0x82, 0x95, 0x98, 0xd3, 0xde, 0xc9, 0xc4, 0xe7, 0xea, 0xfd, 0xf0 },\r\n+\t/*3*/\t{ 0x6b, 0x66, 0x71, 0x7c, 0x5f, 0x52, 0x45, 0x48, 0x03, 0x0e, 0x19, 0x14, 0x37, 0x3a, 0x2d, 0x20 },\r\n+\t/*4*/\t{ 0x6d, 0x60, 0x77, 0x7a, 0x59, 0x54, 0x43, 0x4e, 0x05, 0x08, 0x1f, 0x12, 0x31, 0x3c, 0x2b, 0x26 },\r\n+\t/*5*/\t{ 0xbd, 0xb0, 0xa7, 0xaa, 0x89, 0x84, 0x93, 0x9e, 0xd5, 0xd8, 0xcf, 0xc2, 0xe1, 0xec, 0xfb, 0xf6 },\r\n+\t/*6*/\t{ 0xd6, 0xdb, 0xcc, 0xc1, 0xe2, 0xef, 0xf8, 0xf5, 0xbe, 0xb3, 0xa4, 0xa9, 0x8a, 0x87, 0x90, 0x9d },\r\n+\t/*7*/\t{ 0x06, 0x0b, 0x1c, 0x11, 0x32, 0x3f, 0x28, 0x25, 0x6e, 0x63, 0x74, 0x79, 0x5a, 0x57, 0x40, 0x4d },\r\n+\t/*8*/\t{ 0xda, 0xd7, 0xc0, 0xcd, 0xee, 0xe3, 0xf4, 0xf9, 0xb2, 0xbf, 0xa8, 0xa5, 0x86, 0x8b, 0x9c, 0x91 },\r\n+\t/*9*/\t{ 0x0a, 0x07, 0x10, 0x1d, 0x3e, 0x33, 0x24, 0x29, 0x62, 0x6f, 0x78, 0x75, 0x56, 0x5b, 0x4c, 0x41 },\r\n+\t/*a*/\t{ 0x61, 0x6c, 0x7b, 0x76, 0x55, 0x58, 0x4f, 0x42, 0x09, 0x04, 0x13, 0x1e, 0x3d, 0x30, 0x27, 0x2a },\r\n+\t/*b*/\t{ 0xb1, 0xbc, 0xab, 0xa6, 0x85, 0x88, 0x9f, 0x92, 0xd9, 0xd4, 0xc3, 0xce, 0xed, 0xe0, 0xf7, 0xfa },\r\n+\t/*c*/\t{ 0xb7, 0xba, 0xad, 0xa0, 0x83, 0x8e, 0x99, 0x94, 0xdf, 0xd2, 0xc5, 0xc8, 0xeb, 0xe6, 0xf1, 0xfc },\r\n+\t/*d*/\t{ 0x67, 0x6a, 0x7d, 0x70, 0x53, 0x5e, 0x49, 0x44, 0x0f, 0x02, 0x15, 0x18, 0x3b, 0x36, 0x21, 0x2c },\r\n+\t/*e*/\t{ 0x0c, 0x01, 0x16, 0x1b, 0x38, 0x35, 0x22, 0x2f, 0x64, 0x69, 0x7e, 0x73, 0x50, 0x5d, 0x4a, 0x47 },\r\n+\t/*f*/\t{ 0xdc, 0xd1, 0xc6, 0xcb, 0xe8, 0xe5, 0xf2, 0xff, 0xb4, 0xb9, 0xae, 0xa3, 0x80, 0x8d, 0x9a, 0x97 },\r\n+};\r\n+\r\n+static uint8_t oaes_gf_mul_e[16][16] = {\r\n+\t// \t\t0,    1,    2,    3,    4,    5,    6,    7,    8,    9,    a,    b,    c,    d,    e,    f,\r\n+\t/*0*/\t{ 0x00, 0x0e, 0x1c, 0x12, 0x38, 0x36, 0x24, 0x2a, 0x70, 0x7e, 0x6c, 0x62, 0x48, 0x46, 0x54, 0x5a },\r\n+\t/*1*/\t{ 0xe0, 0xee, 0xfc, 0xf2, 0xd8, 0xd6, 0xc4, 0xca, 0x90, 0x9e, 0x8c, 0x82, 0xa8, 0xa6, 0xb4, 0xba },\r\n+\t/*2*/\t{ 0xdb, 0xd5, 0xc7, 0xc9, 0xe3, 0xed, 0xff, 0xf1, 0xab, 0xa5, 0xb7, 0xb9, 0x93, 0x9d, 0x8f, 0x81 },\r\n+\t/*3*/\t{ 0x3b, 0x35, 0x27, 0x29, 0x03, 0x0d, 0x1f, 0x11, 0x4b, 0x45, 0x57, 0x59, 0x73, 0x7d, 0x6f, 0x61 },\r\n+\t/*4*/\t{ 0xad, 0xa3, 0xb1, 0xbf, 0x95, 0x9b, 0x89, 0x87, 0xdd, 0xd3, 0xc1, 0xcf, 0xe5, 0xeb, 0xf9, 0xf7 },\r\n+\t/*5*/\t{ 0x4d, 0x43, 0x51, 0x5f, 0x75, 0x7b, 0x69, 0x67, 0x3d, 0x33, 0x21, 0x2f, 0x05, 0x0b, 0x19, 0x17 },\r\n+\t/*6*/\t{ 0x76, 0x78, 0x6a, 0x64, 0x4e, 0x40, 0x52, 0x5c, 0x06, 0x08, 0x1a, 0x14, 0x3e, 0x30, 0x22, 0x2c },\r\n+\t/*7*/\t{ 0x96, 0x98, 0x8a, 0x84, 0xae, 0xa0, 0xb2, 0xbc, 0xe6, 0xe8, 0xfa, 0xf4, 0xde, 0xd0, 0xc2, 0xcc },\r\n+\t/*8*/\t{ 0x41, 0x4f, 0x5d, 0x53, 0x79, 0x77, 0x65, 0x6b, 0x31, 0x3f, 0x2d, 0x23, 0x09, 0x07, 0x15, 0x1b },\r\n+\t/*9*/\t{ 0xa1, 0xaf, 0xbd, 0xb3, 0x99, 0x97, 0x85, 0x8b, 0xd1, 0xdf, 0xcd, 0xc3, 0xe9, 0xe7, 0xf5, 0xfb },\r\n+\t/*a*/\t{ 0x9a, 0x94, 0x86, 0x88, 0xa2, 0xac, 0xbe, 0xb0, 0xea, 0xe4, 0xf6, 0xf8, 0xd2, 0xdc, 0xce, 0xc0 },\r\n+\t/*b*/\t{ 0x7a, 0x74, 0x66, 0x68, 0x42, 0x4c, 0x5e, 0x50, 0x0a, 0x04, 0x16, 0x18, 0x32, 0x3c, 0x2e, 0x20 },\r\n+\t/*c*/\t{ 0xec, 0xe2, 0xf0, 0xfe, 0xd4, 0xda, 0xc8, 0xc6, 0x9c, 0x92, 0x80, 0x8e, 0xa4, 0xaa, 0xb8, 0xb6 },\r\n+\t/*d*/\t{ 0x0c, 0x02, 0x10, 0x1e, 0x34, 0x3a, 0x28, 0x26, 0x7c, 0x72, 0x60, 0x6e, 0x44, 0x4a, 0x58, 0x56 },\r\n+\t/*e*/\t{ 0x37, 0x39, 0x2b, 0x25, 0x0f, 0x01, 0x13, 0x1d, 0x47, 0x49, 0x5b, 0x55, 0x7f, 0x71, 0x63, 0x6d },\r\n+\t/*f*/\t{ 0xd7, 0xd9, 0xcb, 0xc5, 0xef, 0xe1, 0xf3, 0xfd, 0xa7, 0xa9, 0xbb, 0xb5, 0x9f, 0x91, 0x83, 0x8d },\r\n+};\r\n+\r\n+static OAES_RET oaes_sub_byte( uint8_t * byte )\r\n+{\r\n+\tsize_t _x, _y;\r\n+\t\r\n+\tif( unlikely(NULL == byte) )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\r\n+\t_y = ((_x = *byte) >> 4) & 0x0f;\r\n+\t_x &= 0x0f;\r\n+\t*byte = oaes_sub_byte_value[_y][_x];\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+static OAES_RET oaes_inv_sub_byte( uint8_t * byte )\r\n+{\r\n+\tsize_t _x, _y;\r\n+\t\r\n+\tif( NULL == byte )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\r\n+\t_x = _y = *byte;\r\n+\t_x &= 0x0f;\r\n+\t_y &= 0xf0;\r\n+\t_y >>= 4;\r\n+\t*byte = oaes_inv_sub_byte_value[_y][_x];\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+/*\r\n+static OAES_RET oaes_word_rot_right( uint8_t word[OAES_COL_LEN] )\r\n+{\r\n+\tuint8_t _temp[OAES_COL_LEN];\r\n+\t\r\n+\tif( NULL == word )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\r\n+\tmemcpy( _temp + 1, word, OAES_COL_LEN - 1 );\r\n+\t_temp[0] = word[OAES_COL_LEN - 1];\r\n+\tmemcpy( word, _temp, OAES_COL_LEN );\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+*/\r\n+static OAES_RET oaes_word_rot_left( uint8_t word[OAES_COL_LEN] )\r\n+{\r\n+\tuint8_t _temp[OAES_COL_LEN];\r\n+\t\r\n+\tif( NULL == word )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\r\n+\tmemcpy( _temp, word + 1, OAES_COL_LEN - 1 );\r\n+\t_temp[OAES_COL_LEN - 1] = word[0];\r\n+\tmemcpy( word, _temp, OAES_COL_LEN );\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+static OAES_RET oaes_shift_rows( uint8_t block[OAES_BLOCK_SIZE] )\r\n+{\r\n+\tuint8_t _temp[] = { block[0x03], block[0x02], block[0x01], block[0x06], block[0x0b] };\r\n+\r\n+\tif( unlikely(NULL == block) )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\r\n+\tblock[0x0b] = block[0x07];\r\n+\tblock[0x01] = block[0x05];\r\n+\tblock[0x02] = block[0x0a];\r\n+\tblock[0x03] = block[0x0f];\r\n+\tblock[0x05] = block[0x09];\r\n+\tblock[0x06] = block[0x0e];\r\n+\tblock[0x07] = _temp[0];\r\n+\tblock[0x09] = block[0x0d];\r\n+\tblock[0x0a] = _temp[1];\r\n+\tblock[0x0d] = _temp[2];\r\n+\tblock[0x0e] = _temp[3];\r\n+\tblock[0x0f] = _temp[4];\r\n+\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+static OAES_RET oaes_inv_shift_rows( uint8_t block[OAES_BLOCK_SIZE] )\r\n+{\r\n+\tuint8_t _temp[OAES_BLOCK_SIZE];\r\n+\r\n+\tif( NULL == block )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\r\n+\t_temp[0x00] = block[0x00];\r\n+\t_temp[0x01] = block[0x0d];\r\n+\t_temp[0x02] = block[0x0a];\r\n+\t_temp[0x03] = block[0x07];\r\n+\t_temp[0x04] = block[0x04];\r\n+\t_temp[0x05] = block[0x01];\r\n+\t_temp[0x06] = block[0x0e];\r\n+\t_temp[0x07] = block[0x0b];\r\n+\t_temp[0x08] = block[0x08];\r\n+\t_temp[0x09] = block[0x05];\r\n+\t_temp[0x0a] = block[0x02];\r\n+\t_temp[0x0b] = block[0x0f];\r\n+\t_temp[0x0c] = block[0x0c];\r\n+\t_temp[0x0d] = block[0x09];\r\n+\t_temp[0x0e] = block[0x06];\r\n+\t_temp[0x0f] = block[0x03];\r\n+\tmemcpy( block, _temp, OAES_BLOCK_SIZE );\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+static uint8_t oaes_gf_mul(uint8_t left, uint8_t right)\r\n+{\r\n+\tsize_t _x, _y;\r\n+\r\n+\t_y = ((_x = left) >> 4) & 0x0f;\r\n+\t_x &= 0x0f;\r\n+\t\r\n+\tswitch( right )\r\n+\t{\r\n+\t\tcase 0x02:\r\n+\t\t\treturn oaes_gf_mul_2[_y][_x];\r\n+\t\t\tbreak;\r\n+\t\tcase 0x03:\r\n+\t\t\treturn oaes_gf_mul_3[_y][_x];\r\n+\t\t\tbreak;\r\n+\t\tcase 0x09:\r\n+\t\t\treturn oaes_gf_mul_9[_y][_x];\r\n+\t\t\tbreak;\r\n+\t\tcase 0x0b:\r\n+\t\t\treturn oaes_gf_mul_b[_y][_x];\r\n+\t\t\tbreak;\r\n+\t\tcase 0x0d:\r\n+\t\t\treturn oaes_gf_mul_d[_y][_x];\r\n+\t\t\tbreak;\r\n+\t\tcase 0x0e:\r\n+\t\t\treturn oaes_gf_mul_e[_y][_x];\r\n+\t\t\tbreak;\r\n+\t\tdefault:\r\n+\t\t\treturn left;\r\n+\t\t\tbreak;\r\n+\t}\r\n+}\r\n+\r\n+static OAES_RET oaes_mix_cols( uint8_t word[OAES_COL_LEN] )\r\n+{\r\n+\tuint8_t _temp[OAES_COL_LEN];\r\n+\r\n+\tif( unlikely(NULL == word) )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\t\r\n+\t_temp[0] = oaes_gf_mul(word[0], 0x02) ^ oaes_gf_mul( word[1], 0x03 ) ^\r\n+\t\t\tword[2] ^ word[3];\r\n+\t_temp[1] = word[0] ^ oaes_gf_mul( word[1], 0x02 ) ^\r\n+\t\t\toaes_gf_mul( word[2], 0x03 ) ^ word[3];\r\n+\t_temp[2] = word[0] ^ word[1] ^\r\n+\t\t\toaes_gf_mul( word[2], 0x02 ) ^ oaes_gf_mul( word[3], 0x03 );\r\n+\t_temp[3] = oaes_gf_mul( word[0], 0x03 ) ^ word[1] ^\r\n+\t\t\tword[2] ^ oaes_gf_mul( word[3], 0x02 );\r\n+\tmemcpy( word, _temp, OAES_COL_LEN );\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+static OAES_RET oaes_inv_mix_cols( uint8_t word[OAES_COL_LEN] )\r\n+{\r\n+\tuint8_t _temp[OAES_COL_LEN];\r\n+\r\n+\tif( NULL == word )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\t\r\n+\t_temp[0] = oaes_gf_mul( word[0], 0x0e ) ^ oaes_gf_mul( word[1], 0x0b ) ^\r\n+\t\t\toaes_gf_mul( word[2], 0x0d ) ^ oaes_gf_mul( word[3], 0x09 );\r\n+\t_temp[1] = oaes_gf_mul( word[0], 0x09 ) ^ oaes_gf_mul( word[1], 0x0e ) ^\r\n+\t\t\toaes_gf_mul( word[2], 0x0b ) ^ oaes_gf_mul( word[3], 0x0d );\r\n+\t_temp[2] = oaes_gf_mul( word[0], 0x0d ) ^ oaes_gf_mul( word[1], 0x09 ) ^\r\n+\t\t\toaes_gf_mul( word[2], 0x0e ) ^ oaes_gf_mul( word[3], 0x0b );\r\n+\t_temp[3] = oaes_gf_mul( word[0], 0x0b ) ^ oaes_gf_mul( word[1], 0x0d ) ^\r\n+\t\t\toaes_gf_mul( word[2], 0x09 ) ^ oaes_gf_mul( word[3], 0x0e );\r\n+\tmemcpy( word, _temp, OAES_COL_LEN );\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+OAES_RET oaes_sprintf(\r\n+\t\tchar * buf, size_t * buf_len, const uint8_t * data, size_t data_len )\r\n+{\r\n+\tsize_t _i, _buf_len_in;\r\n+\tchar _temp[4];\r\n+\t\r\n+\tif( NULL == buf_len )\r\n+\t\treturn OAES_RET_ARG2;\r\n+\r\n+\t_buf_len_in = *buf_len;\r\n+\t*buf_len = data_len * 3 + data_len / OAES_BLOCK_SIZE + 1;\r\n+\t\r\n+\tif( NULL == buf )\r\n+\t\treturn OAES_RET_SUCCESS;\r\n+\r\n+\tif( *buf_len > _buf_len_in )\r\n+\t\treturn OAES_RET_BUF;\r\n+\r\n+\tif( NULL == data )\r\n+\t\treturn OAES_RET_ARG3;\r\n+\r\n+\tstrcpy( buf, \"\" );\r\n+\t\r\n+\tfor( _i = 0; _i < data_len; _i++ )\r\n+\t{\r\n+\t\tsprintf( _temp, \"%02x \", data[_i] );\r\n+\t\tstrcat( buf, _temp );\r\n+\t\tif( _i && 0 == ( _i + 1 ) % OAES_BLOCK_SIZE )\r\n+\t\t\tstrcat( buf, \"\\n\" );\r\n+\t}\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+#ifdef OAES_HAVE_ISAAC\r\n+static void oaes_get_seed( char buf[RANDSIZ + 1] )\r\n+{\r\n+\tstruct timeb timer;\r\n+\tstruct tm *gmTimer;\r\n+\tchar * _test = NULL;\r\n+\t\r\n+\tftime (&timer);\r\n+\tgmTimer = gmtime( &timer.time );\r\n+\t_test = (char *) calloc( sizeof( char ), timer.millitm );\r\n+\tsprintf( buf, \"%04d%02d%02d%02d%02d%02d%03d%p%d\",\r\n+\t\tgmTimer->tm_year + 1900, gmTimer->tm_mon + 1, gmTimer->tm_mday,\r\n+\t\tgmTimer->tm_hour, gmTimer->tm_min, gmTimer->tm_sec, timer.millitm,\r\n+\t\t_test + timer.millitm, getpid() );\r\n+\t\r\n+\tif( _test )\r\n+\t\tfree( _test );\r\n+}\r\n+#else\r\n+static uint32_t oaes_get_seed(void)\r\n+{\r\n+\tstruct timeb timer;\r\n+\tstruct tm *gmTimer;\r\n+\tchar * _test = NULL;\r\n+\tuint32_t _ret = 0;\r\n+\t\r\n+\tftime (&timer);\r\n+\tgmTimer = gmtime( &timer.time );\r\n+\t_test = (char *) calloc( sizeof( char ), timer.millitm );\r\n+\t_ret = gmTimer->tm_year + 1900 + gmTimer->tm_mon + 1 + gmTimer->tm_mday +\r\n+\t\t\tgmTimer->tm_hour + gmTimer->tm_min + gmTimer->tm_sec + timer.millitm +\r\n+\t\t\t(uintptr_t) ( _test + timer.millitm ) + getpid();\r\n+\r\n+\tif( _test )\r\n+\t\tfree( _test );\r\n+\t\r\n+\treturn _ret;\r\n+}\r\n+#endif // OAES_HAVE_ISAAC\r\n+\r\n+static OAES_RET oaes_key_destroy( oaes_key ** key )\r\n+{\r\n+\tif( NULL == *key )\r\n+\t\treturn OAES_RET_SUCCESS;\r\n+\t\r\n+\tif( (*key)->data )\r\n+\t{\r\n+\t\tfree( (*key)->data );\r\n+\t\t(*key)->data = NULL;\r\n+\t}\r\n+\t\r\n+\tif( (*key)->exp_data )\r\n+\t{\r\n+\t\tfree( (*key)->exp_data );\r\n+\t\t(*key)->exp_data = NULL;\r\n+\t}\r\n+\t\r\n+\t(*key)->data_len = 0;\r\n+\t(*key)->exp_data_len = 0;\r\n+\t(*key)->num_keys = 0;\r\n+\t(*key)->key_base = 0;\r\n+\tfree( *key );\r\n+\t*key = NULL;\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+static OAES_RET oaes_key_expand( OAES_CTX * ctx )\r\n+{\r\n+\tsize_t _i, _j;\r\n+\toaes_ctx * _ctx = (oaes_ctx *) ctx;\r\n+    uint8_t _temp[OAES_COL_LEN];\r\n+\t\r\n+\tif( NULL == _ctx )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\t\r\n+\tif( NULL == _ctx->key )\r\n+\t\treturn OAES_RET_NOKEY;\r\n+\t\r\n+\t_ctx->key->key_base = _ctx->key->data_len / OAES_RKEY_LEN;\r\n+\t_ctx->key->num_keys =  _ctx->key->key_base + OAES_ROUND_BASE;\r\n+\t\t\t\t\t\r\n+\t_ctx->key->exp_data_len = _ctx->key->num_keys * OAES_RKEY_LEN * OAES_COL_LEN;\r\n+\t_ctx->key->exp_data = (uint8_t *)\r\n+\t\t\tcalloc( _ctx->key->exp_data_len, sizeof( uint8_t ));\r\n+\t\r\n+\tif( NULL == _ctx->key->exp_data )\r\n+\t\treturn OAES_RET_MEM;\r\n+\t\r\n+\t// the first _ctx->key->data_len are a direct copy\r\n+\tmemcpy( _ctx->key->exp_data, _ctx->key->data, _ctx->key->data_len );\r\n+\r\n+\t// apply ExpandKey algorithm for remainder\r\n+\tfor( _i = _ctx->key->key_base; _i < _ctx->key->num_keys * OAES_RKEY_LEN; _i++ )\r\n+\t{\r\n+\t\t\r\n+\t\tmemcpy( _temp,\r\n+\t\t\t\t_ctx->key->exp_data + ( _i - 1 ) * OAES_RKEY_LEN, OAES_COL_LEN );\r\n+\t\t\r\n+\t\t// transform key column\r\n+\t\tif( 0 == _i % _ctx->key->key_base )\r\n+\t\t{\r\n+\t\t\toaes_word_rot_left( _temp );\r\n+\r\n+\t\t\tfor( _j = 0; _j < OAES_COL_LEN; _j++ )\r\n+\t\t\t\toaes_sub_byte( _temp + _j );\r\n+\r\n+\t\t\t_temp[0] = _temp[0] ^ oaes_gf_8[ _i / _ctx->key->key_base - 1 ];\r\n+\t\t}\r\n+\t\telse if( _ctx->key->key_base > 6 && 4 == _i % _ctx->key->key_base )\r\n+\t\t{\r\n+\t\t\tfor( _j = 0; _j < OAES_COL_LEN; _j++ )\r\n+\t\t\t\toaes_sub_byte( _temp + _j );\r\n+\t\t}\r\n+\t\t\r\n+\t\tfor( _j = 0; _j < OAES_COL_LEN; _j++ )\r\n+\t\t{\r\n+\t\t\t_ctx->key->exp_data[ _i * OAES_RKEY_LEN + _j ] =\r\n+\t\t\t\t\t_ctx->key->exp_data[ ( _i - _ctx->key->key_base ) *\r\n+\t\t\t\t\tOAES_RKEY_LEN + _j ] ^ _temp[_j];\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+static OAES_RET oaes_key_gen( OAES_CTX * ctx, size_t key_size )\r\n+{\r\n+\tsize_t _i;\r\n+\toaes_key * _key = NULL;\r\n+\toaes_ctx * _ctx = (oaes_ctx *) ctx;\r\n+\tOAES_RET _rc = OAES_RET_SUCCESS;\r\n+\t\r\n+\tif( NULL == _ctx )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\t\r\n+\t_key = (oaes_key *) calloc( sizeof( oaes_key ), 1 );\r\n+\t\r\n+\tif( NULL == _key )\r\n+\t\treturn OAES_RET_MEM;\r\n+\t\r\n+\tif( _ctx->key )\r\n+\t\toaes_key_destroy( &(_ctx->key) );\r\n+\t\r\n+\t_key->data_len = key_size;\r\n+\t_key->data = (uint8_t *) calloc( key_size, sizeof( uint8_t ));\r\n+\t\r\n+\tif( NULL == _key->data )\r\n+\t\treturn OAES_RET_MEM;\r\n+\t\r\n+\tfor( _i = 0; _i < key_size; _i++ )\r\n+#ifdef OAES_HAVE_ISAAC\r\n+\t\t_key->data[_i] = (uint8_t) rand( _ctx->rctx );\r\n+#else\r\n+\t\t_key->data[_i] = (uint8_t) rand();\r\n+#endif // OAES_HAVE_ISAAC\r\n+\t\r\n+\t_ctx->key = _key;\r\n+\t_rc = (OAES_RET) (_rc || oaes_key_expand( ctx ));\r\n+\t\r\n+\tif( _rc != OAES_RET_SUCCESS )\r\n+\t{\r\n+\t\toaes_key_destroy( &(_ctx->key) );\r\n+\t\treturn _rc;\r\n+\t}\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+OAES_RET oaes_key_gen_128( OAES_CTX * ctx )\r\n+{\r\n+\treturn oaes_key_gen( ctx, 16 );\r\n+}\r\n+\r\n+OAES_RET oaes_key_gen_192( OAES_CTX * ctx )\r\n+{\r\n+\treturn oaes_key_gen( ctx, 24 );\r\n+}\r\n+\r\n+OAES_RET oaes_key_gen_256( OAES_CTX * ctx )\r\n+{\r\n+\treturn oaes_key_gen( ctx, 32 );\r\n+}\r\n+\r\n+OAES_RET oaes_key_export( OAES_CTX * ctx,\r\n+\t\tuint8_t * data, size_t * data_len )\r\n+{\r\n+\tsize_t _data_len_in;\r\n+\toaes_ctx * _ctx = (oaes_ctx *) ctx;\r\n+\t\r\n+\tif( NULL == _ctx )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\t\r\n+\tif( NULL == _ctx->key )\r\n+\t\treturn OAES_RET_NOKEY;\r\n+\t\r\n+\tif( NULL == data_len )\r\n+\t\treturn OAES_RET_ARG3;\r\n+\r\n+\t_data_len_in = *data_len;\r\n+\t// data + header\r\n+\t*data_len = _ctx->key->data_len + OAES_BLOCK_SIZE;\r\n+\r\n+\tif( NULL == data )\r\n+\t\treturn OAES_RET_SUCCESS;\r\n+\t\r\n+\tif( _data_len_in < *data_len )\r\n+\t\treturn OAES_RET_BUF;\r\n+\t\r\n+\t// header\r\n+\tmemcpy( data, oaes_header, OAES_BLOCK_SIZE );\r\n+\tdata[5] = 0x01;\r\n+\tdata[7] = _ctx->key->data_len;\r\n+\tmemcpy( data + OAES_BLOCK_SIZE, _ctx->key->data, _ctx->key->data_len );\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+OAES_RET oaes_key_export_data( OAES_CTX * ctx,\r\n+\t\tuint8_t * data, size_t * data_len )\r\n+{\r\n+\tsize_t _data_len_in;\r\n+\toaes_ctx * _ctx = (oaes_ctx *) ctx;\r\n+\t\r\n+\tif( NULL == _ctx )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\t\r\n+\tif( NULL == _ctx->key )\r\n+\t\treturn OAES_RET_NOKEY;\r\n+\t\r\n+\tif( NULL == data_len )\r\n+\t\treturn OAES_RET_ARG3;\r\n+\r\n+\t_data_len_in = *data_len;\r\n+\t*data_len = _ctx->key->data_len;\r\n+\r\n+\tif( NULL == data )\r\n+\t\treturn OAES_RET_SUCCESS;\r\n+\t\r\n+\tif( _data_len_in < *data_len )\r\n+\t\treturn OAES_RET_BUF;\r\n+\t\r\n+\tmemcpy( data, _ctx->key->data, *data_len );\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+OAES_RET oaes_key_import( OAES_CTX * ctx,\r\n+\t\tconst uint8_t * data, size_t data_len )\r\n+{\r\n+\toaes_ctx * _ctx = (oaes_ctx *) ctx;\r\n+\tOAES_RET _rc = OAES_RET_SUCCESS;\r\n+\tint _key_length;\r\n+\t\r\n+\tif( NULL == _ctx )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\t\r\n+\tif( NULL == data )\r\n+\t\treturn OAES_RET_ARG2;\r\n+\t\r\n+\tswitch( data_len )\r\n+\t{\r\n+\t\tcase 16 + OAES_BLOCK_SIZE:\r\n+\t\tcase 24 + OAES_BLOCK_SIZE:\r\n+\t\tcase 32 + OAES_BLOCK_SIZE:\r\n+\t\t\tbreak;\r\n+\t\tdefault:\r\n+\t\t\treturn OAES_RET_ARG3;\r\n+\t}\r\n+\t\r\n+\t// header\r\n+\tif( 0 != memcmp( data, oaes_header, 4 ) )\r\n+\t\treturn OAES_RET_HEADER;\r\n+\r\n+\t// header version\r\n+\tswitch( data[4] )\r\n+\t{\r\n+\t\tcase 0x01:\r\n+\t\t\tbreak;\r\n+\t\tdefault:\r\n+\t\t\treturn OAES_RET_HEADER;\r\n+\t}\r\n+\t\r\n+\t// header type\r\n+\tswitch( data[5] )\r\n+\t{\r\n+\t\tcase 0x01:\r\n+\t\t\tbreak;\r\n+\t\tdefault:\r\n+\t\t\treturn OAES_RET_HEADER;\r\n+\t}\r\n+\t\r\n+\t// options\r\n+\t_key_length = data[7];\r\n+\tswitch( _key_length )\r\n+\t{\r\n+\t\tcase 16:\r\n+\t\tcase 24:\r\n+\t\tcase 32:\r\n+\t\t\tbreak;\r\n+\t\tdefault:\r\n+\t\t\treturn OAES_RET_HEADER;\r\n+\t}\r\n+\t\r\n+\tif( (int)data_len != _key_length + OAES_BLOCK_SIZE )\r\n+\t\t\treturn OAES_RET_ARG3;\r\n+\t\r\n+\tif( _ctx->key )\r\n+\t\toaes_key_destroy( &(_ctx->key) );\r\n+\t\r\n+\t_ctx->key = (oaes_key *) calloc( sizeof( oaes_key ), 1 );\r\n+\t\r\n+\tif( NULL == _ctx->key )\r\n+\t\treturn OAES_RET_MEM;\r\n+\t\r\n+\t_ctx->key->data_len = _key_length;\r\n+\t_ctx->key->data = (uint8_t *)\r\n+\t\t\tcalloc( _key_length, sizeof( uint8_t ));\r\n+\t\r\n+\tif( NULL == _ctx->key->data )\r\n+\t{\r\n+\t\toaes_key_destroy( &(_ctx->key) );\r\n+\t\treturn OAES_RET_MEM;\r\n+\t}\r\n+\r\n+\tmemcpy( _ctx->key->data, data + OAES_BLOCK_SIZE, _key_length );\r\n+\t_rc = (OAES_RET) (_rc || oaes_key_expand( ctx ));\r\n+\t\r\n+\tif( _rc != OAES_RET_SUCCESS )\r\n+\t{\r\n+\t\toaes_key_destroy( &(_ctx->key) );\r\n+\t\treturn _rc;\r\n+\t}\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+OAES_RET oaes_key_import_data( OAES_CTX * ctx,\r\n+\t\tconst uint8_t * data, size_t data_len )\r\n+{\r\n+\toaes_ctx * _ctx = (oaes_ctx *) ctx;\r\n+\tOAES_RET _rc = OAES_RET_SUCCESS;\r\n+\t\r\n+\tif( NULL == _ctx )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\t\r\n+\tif( NULL == data )\r\n+\t\treturn OAES_RET_ARG2;\r\n+\t\r\n+\tswitch( data_len )\r\n+\t{\r\n+\t\tcase 16:\r\n+\t\tcase 24:\r\n+\t\tcase 32:\r\n+\t\t\tbreak;\r\n+\t\tdefault:\r\n+\t\t\treturn OAES_RET_ARG3;\r\n+\t}\r\n+\t\r\n+\tif( _ctx->key )\r\n+\t\toaes_key_destroy( &(_ctx->key) );\r\n+\t\r\n+\t_ctx->key = (oaes_key *) calloc( sizeof( oaes_key ), 1 );\r\n+\t\r\n+\tif( NULL == _ctx->key )\r\n+\t\treturn OAES_RET_MEM;\r\n+\t\r\n+\t_ctx->key->data_len = data_len;\r\n+\t_ctx->key->data = (uint8_t *)\r\n+\t\t\tcalloc( data_len, sizeof( uint8_t ));\r\n+\t\r\n+\tif( NULL == _ctx->key->data )\r\n+\t{\r\n+\t\toaes_key_destroy( &(_ctx->key) );\r\n+\t\treturn OAES_RET_MEM;\r\n+\t}\r\n+\r\n+\tmemcpy( _ctx->key->data, data, data_len );\r\n+\t_rc = (OAES_RET) (_rc || oaes_key_expand( ctx ));\r\n+\t\r\n+\tif( _rc != OAES_RET_SUCCESS )\r\n+\t{\r\n+\t\toaes_key_destroy( &(_ctx->key) );\r\n+\t\treturn _rc;\r\n+\t}\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+OAES_CTX * oaes_alloc(void)\r\n+{\r\n+\toaes_ctx * _ctx = (oaes_ctx *) calloc( sizeof( oaes_ctx ), 1 );\r\n+\t\r\n+\tif( NULL == _ctx )\r\n+\t\treturn NULL;\r\n+\r\n+#ifdef OAES_HAVE_ISAAC\r\n+\t{\r\n+\t  ub4 _i = 0;\r\n+\t\tchar _seed[RANDSIZ + 1];\r\n+\t\t\r\n+\t\t_ctx->rctx = (randctx *) calloc( sizeof( randctx ), 1 );\r\n+\r\n+\t\tif( NULL == _ctx->rctx )\r\n+\t\t{\r\n+\t\t\tfree( _ctx );\r\n+\t\t\treturn NULL;\r\n+\t\t}\r\n+\r\n+\t\toaes_get_seed( _seed );\r\n+\t\tmemset( _ctx->rctx->randrsl, 0, RANDSIZ );\r\n+\t\tmemcpy( _ctx->rctx->randrsl, _seed, RANDSIZ );\r\n+\t\trandinit( _ctx->rctx, TRUE);\r\n+\t}\r\n+#else\r\n+\t\tsrand( oaes_get_seed() );\r\n+#endif // OAES_HAVE_ISAAC\r\n+\r\n+\t_ctx->key = NULL;\r\n+\toaes_set_option( _ctx, OAES_OPTION_CBC, NULL );\r\n+\r\n+#ifdef OAES_DEBUG\r\n+\t_ctx->step_cb = NULL;\r\n+\toaes_set_option( _ctx, OAES_OPTION_STEP_OFF, NULL );\r\n+#endif // OAES_DEBUG\r\n+\r\n+\treturn (OAES_CTX *) _ctx;\r\n+}\r\n+\r\n+OAES_RET oaes_free( OAES_CTX ** ctx )\r\n+{\r\n+\toaes_ctx ** _ctx = (oaes_ctx **) ctx;\r\n+\r\n+\tif( NULL == _ctx )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\t\r\n+\tif( NULL == *_ctx )\r\n+\t\treturn OAES_RET_SUCCESS;\r\n+\t\r\n+\tif( (*_ctx)->key )\r\n+\t\toaes_key_destroy( &((*_ctx)->key) );\r\n+\r\n+#ifdef OAES_HAVE_ISAAC\r\n+\tif( (*_ctx)->rctx )\r\n+\t{\r\n+\t\tfree( (*_ctx)->rctx );\r\n+\t\t(*_ctx)->rctx = NULL;\r\n+\t}\r\n+#endif // OAES_HAVE_ISAAC\r\n+\t\r\n+\tfree( *_ctx );\r\n+\t*_ctx = NULL;\r\n+\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+OAES_RET oaes_set_option( OAES_CTX * ctx,\r\n+\t\tOAES_OPTION option, const void * value )\r\n+{\r\n+\tsize_t _i;\r\n+\toaes_ctx * _ctx = (oaes_ctx *) ctx;\r\n+\t\r\n+\tif( NULL == _ctx )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\r\n+\tswitch( option )\r\n+\t{\r\n+\t\tcase OAES_OPTION_ECB:\r\n+\t\t\t_ctx->options &= ~OAES_OPTION_CBC;\r\n+\t\t\tmemset( _ctx->iv, 0, OAES_BLOCK_SIZE );\r\n+\t\t\tbreak;\r\n+\r\n+\t\tcase OAES_OPTION_CBC:\r\n+\t\t\t_ctx->options &= ~OAES_OPTION_ECB;\r\n+\t\t\tif( value )\r\n+\t\t\t\tmemcpy( _ctx->iv, value, OAES_BLOCK_SIZE );\r\n+\t\t\telse\r\n+\t\t\t{\r\n+\t\t\t\tfor( _i = 0; _i < OAES_BLOCK_SIZE; _i++ )\r\n+#ifdef OAES_HAVE_ISAAC\r\n+\t\t\t\t\t_ctx->iv[_i] = (uint8_t) rand( _ctx->rctx );\r\n+#else\r\n+\t\t\t\t\t_ctx->iv[_i] = (uint8_t) rand();\r\n+#endif // OAES_HAVE_ISAAC\r\n+\t\t\t}\r\n+\t\t\tbreak;\r\n+\r\n+#ifdef OAES_DEBUG\r\n+\r\n+\t\tcase OAES_OPTION_STEP_ON:\r\n+\t\t\tif( value )\r\n+\t\t\t{\r\n+\t\t\t\t_ctx->options &= ~OAES_OPTION_STEP_OFF;\r\n+\t\t\t\t_ctx->step_cb = value;\r\n+\t\t\t}\r\n+\t\t\telse\r\n+\t\t\t{\r\n+\t\t\t\t_ctx->options &= ~OAES_OPTION_STEP_ON;\r\n+\t\t\t\t_ctx->options |= OAES_OPTION_STEP_OFF;\r\n+\t\t\t\t_ctx->step_cb = NULL;\r\n+\t\t\t\treturn OAES_RET_ARG3;\r\n+\t\t\t}\r\n+\t\t\tbreak;\r\n+\r\n+\t\tcase OAES_OPTION_STEP_OFF:\r\n+\t\t\t_ctx->options &= ~OAES_OPTION_STEP_ON;\r\n+\t\t\t_ctx->step_cb = NULL;\r\n+\t\t\tbreak;\r\n+\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t\tdefault:\r\n+\t\t\treturn OAES_RET_ARG2;\r\n+\t}\r\n+\r\n+\t_ctx->options |= option;\r\n+\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+static OAES_RET oaes_encrypt_block(\r\n+\t\tOAES_CTX * ctx, uint8_t * c, size_t c_len )\r\n+{\r\n+\tsize_t _i, _j;\r\n+\toaes_ctx * _ctx = (oaes_ctx *) ctx;\r\n+\t\r\n+\tif( NULL == _ctx )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\t\r\n+\tif( NULL == c )\r\n+\t\treturn OAES_RET_ARG2;\r\n+\t\r\n+\tif( c_len != OAES_BLOCK_SIZE )\r\n+\t\treturn OAES_RET_ARG3;\r\n+\t\r\n+\tif( NULL == _ctx->key )\r\n+\t\treturn OAES_RET_NOKEY;\r\n+\t\r\n+#ifdef OAES_DEBUG\r\n+\tif( _ctx->step_cb )\r\n+\t\t_ctx->step_cb( c, \"input\", 1, NULL );\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t// AddRoundKey(State, K0)\r\n+\tfor( _i = 0; _i < c_len; _i++ )\r\n+\t\tc[_i] = c[_i] ^ _ctx->key->exp_data[_i];\r\n+\t\r\n+#ifdef OAES_DEBUG\r\n+\tif( _ctx->step_cb )\r\n+\t{\r\n+\t\t_ctx->step_cb( _ctx->key->exp_data, \"k_sch\", 1, NULL );\r\n+\t\t_ctx->step_cb( c, \"k_add\", 1, NULL );\r\n+\t}\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t// for round = 1 step 1 to Nr\u20131\r\n+\tfor( _i = 1; _i < _ctx->key->num_keys - 1; _i++ )\r\n+\t{\r\n+\t\t// SubBytes(state)\r\n+\t\tfor( _j = 0; _j < c_len; _j++ )\r\n+\t\t\toaes_sub_byte( c + _j );\r\n+\r\n+#ifdef OAES_DEBUG\r\n+\t\tif( _ctx->step_cb )\r\n+\t\t\t_ctx->step_cb( c, \"s_box\", _i, NULL );\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t\t// ShiftRows(state)\r\n+\t\toaes_shift_rows( c );\r\n+\t\t\r\n+#ifdef OAES_DEBUG\r\n+\t\tif( _ctx->step_cb )\r\n+\t\t\t_ctx->step_cb( c, \"s_row\", _i, NULL );\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t\t// MixColumns(state)\r\n+\t\toaes_mix_cols( c );\r\n+\t\toaes_mix_cols( c + 4 );\r\n+\t\toaes_mix_cols( c + 8 );\r\n+\t\toaes_mix_cols( c + 12 );\r\n+\t\t\r\n+#ifdef OAES_DEBUG\r\n+\t\tif( _ctx->step_cb )\r\n+\t\t\t_ctx->step_cb( c, \"m_col\", _i, NULL );\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t\t// AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])\r\n+\t\tfor( _j = 0; _j < c_len; _j++ )\r\n+\t\t\tc[_j] = c[_j] ^\r\n+\t\t\t\t\t_ctx->key->exp_data[_i * OAES_RKEY_LEN * OAES_COL_LEN + _j];\r\n+\r\n+#ifdef OAES_DEBUG\r\n+\tif( _ctx->step_cb )\r\n+\t{\r\n+\t\t_ctx->step_cb( _ctx->key->exp_data + _i * OAES_RKEY_LEN * OAES_COL_LEN,\r\n+\t\t\t\t\"k_sch\", _i, NULL );\r\n+\t\t_ctx->step_cb( c, \"k_add\", _i, NULL );\r\n+\t}\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t}\r\n+\t\r\n+\t// SubBytes(state)\r\n+\tfor( _i = 0; _i < c_len; _i++ )\r\n+\t\toaes_sub_byte( c + _i );\r\n+\t\r\n+#ifdef OAES_DEBUG\r\n+\tif( _ctx->step_cb )\r\n+\t\t_ctx->step_cb( c, \"s_box\", _ctx->key->num_keys - 1, NULL );\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t// ShiftRows(state)\r\n+\toaes_shift_rows( c );\r\n+\r\n+#ifdef OAES_DEBUG\r\n+\tif( _ctx->step_cb )\r\n+\t\t_ctx->step_cb( c, \"s_row\", _ctx->key->num_keys - 1, NULL );\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t// AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\r\n+\tfor( _i = 0; _i < c_len; _i++ )\r\n+\t\tc[_i] = c[_i] ^ _ctx->key->exp_data[\r\n+\t\t\t\t( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN + _i ];\r\n+\r\n+#ifdef OAES_DEBUG\r\n+\tif( _ctx->step_cb )\r\n+\t{\r\n+\t\t_ctx->step_cb( _ctx->key->exp_data +\r\n+\t\t\t\t( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN,\r\n+\t\t\t\t\"k_sch\", _ctx->key->num_keys - 1, NULL );\r\n+\t\t_ctx->step_cb( c, \"output\", _ctx->key->num_keys - 1, NULL );\r\n+\t}\r\n+#endif // OAES_DEBUG\r\n+\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+static OAES_RET oaes_decrypt_block(\r\n+\t\tOAES_CTX * ctx, uint8_t * c, size_t c_len )\r\n+{\r\n+\tsize_t _i, _j;\r\n+\toaes_ctx * _ctx = (oaes_ctx *) ctx;\r\n+\t\r\n+\tif( NULL == _ctx )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\t\r\n+\tif( NULL == c )\r\n+\t\treturn OAES_RET_ARG2;\r\n+\t\r\n+\tif( c_len != OAES_BLOCK_SIZE )\r\n+\t\treturn OAES_RET_ARG3;\r\n+\t\r\n+\tif( NULL == _ctx->key )\r\n+\t\treturn OAES_RET_NOKEY;\r\n+\t\r\n+#ifdef OAES_DEBUG\r\n+\tif( _ctx->step_cb )\r\n+\t\t_ctx->step_cb( c, \"iinput\", _ctx->key->num_keys - 1, NULL );\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t// AddRoundKey(state, w[Nr*Nb, (Nr+1)*Nb-1])\r\n+\tfor( _i = 0; _i < c_len; _i++ )\r\n+\t\tc[_i] = c[_i] ^ _ctx->key->exp_data[\r\n+\t\t\t\t( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN + _i ];\r\n+\r\n+#ifdef OAES_DEBUG\r\n+\tif( _ctx->step_cb )\r\n+\t{\r\n+\t\t_ctx->step_cb( _ctx->key->exp_data +\r\n+\t\t\t\t( _ctx->key->num_keys - 1 ) * OAES_RKEY_LEN * OAES_COL_LEN,\r\n+\t\t\t\t\"ik_sch\", _ctx->key->num_keys - 1, NULL );\r\n+\t\t_ctx->step_cb( c, \"ik_add\", _ctx->key->num_keys - 1, NULL );\r\n+\t}\r\n+#endif // OAES_DEBUG\r\n+\r\n+\tfor( _i = _ctx->key->num_keys - 2; _i > 0; _i-- )\r\n+\t{\r\n+\t\t// InvShiftRows(state)\r\n+\t\toaes_inv_shift_rows( c );\r\n+\r\n+#ifdef OAES_DEBUG\r\n+\tif( _ctx->step_cb )\r\n+\t\t_ctx->step_cb( c, \"is_row\", _i, NULL );\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t\t// InvSubBytes(state)\r\n+\t\tfor( _j = 0; _j < c_len; _j++ )\r\n+\t\t\toaes_inv_sub_byte( c + _j );\r\n+\t\r\n+#ifdef OAES_DEBUG\r\n+\tif( _ctx->step_cb )\r\n+\t\t_ctx->step_cb( c, \"is_box\", _i, NULL );\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t\t// AddRoundKey(state, w[round*Nb, (round+1)*Nb-1])\r\n+\t\tfor( _j = 0; _j < c_len; _j++ )\r\n+\t\t\tc[_j] = c[_j] ^\r\n+\t\t\t\t\t_ctx->key->exp_data[_i * OAES_RKEY_LEN * OAES_COL_LEN + _j];\r\n+\t\t\r\n+#ifdef OAES_DEBUG\r\n+\tif( _ctx->step_cb )\r\n+\t{\r\n+\t\t_ctx->step_cb( _ctx->key->exp_data + _i * OAES_RKEY_LEN * OAES_COL_LEN,\r\n+\t\t\t\t\"ik_sch\", _i, NULL );\r\n+\t\t_ctx->step_cb( c, \"ik_add\", _i, NULL );\r\n+\t}\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t\t// InvMixColums(state)\r\n+\t\toaes_inv_mix_cols( c );\r\n+\t\toaes_inv_mix_cols( c + 4 );\r\n+\t\toaes_inv_mix_cols( c + 8 );\r\n+\t\toaes_inv_mix_cols( c + 12 );\r\n+\r\n+#ifdef OAES_DEBUG\r\n+\tif( _ctx->step_cb )\r\n+\t\t_ctx->step_cb( c, \"im_col\", _i, NULL );\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t}\r\n+\r\n+\t// InvShiftRows(state)\r\n+\toaes_inv_shift_rows( c );\r\n+\r\n+#ifdef OAES_DEBUG\r\n+\tif( _ctx->step_cb )\r\n+\t\t_ctx->step_cb( c, \"is_row\", 1, NULL );\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t// InvSubBytes(state)\r\n+\tfor( _i = 0; _i < c_len; _i++ )\r\n+\t\toaes_inv_sub_byte( c + _i );\r\n+\r\n+#ifdef OAES_DEBUG\r\n+\tif( _ctx->step_cb )\r\n+\t\t_ctx->step_cb( c, \"is_box\", 1, NULL );\r\n+#endif // OAES_DEBUG\r\n+\r\n+\t// AddRoundKey(state, w[0, Nb-1])\r\n+\tfor( _i = 0; _i < c_len; _i++ )\r\n+\t\tc[_i] = c[_i] ^ _ctx->key->exp_data[_i];\r\n+\t\r\n+#ifdef OAES_DEBUG\r\n+\tif( _ctx->step_cb )\r\n+\t{\r\n+\t\t_ctx->step_cb( _ctx->key->exp_data, \"ik_sch\", 1, NULL );\r\n+\t\t_ctx->step_cb( c, \"ioutput\", 1, NULL );\r\n+\t}\r\n+#endif // OAES_DEBUG\r\n+\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+OAES_RET oaes_encrypt( OAES_CTX * ctx,\r\n+\t\tconst uint8_t * m, size_t m_len, uint8_t * c, size_t * c_len )\r\n+{\r\n+\tsize_t _i, _j, _c_len_in, _c_data_len;\r\n+\tsize_t _pad_len = m_len % OAES_BLOCK_SIZE == 0 ?\r\n+\t\t\t0 : OAES_BLOCK_SIZE - m_len % OAES_BLOCK_SIZE;\r\n+\toaes_ctx * _ctx = (oaes_ctx *) ctx;\r\n+\tOAES_RET _rc = OAES_RET_SUCCESS;\r\n+\tuint8_t _flags = _pad_len ? OAES_FLAG_PAD : 0;\r\n+\t\r\n+\tif( NULL == _ctx )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\t\r\n+\tif( NULL == m )\r\n+\t\treturn OAES_RET_ARG2;\r\n+\t\r\n+\tif( NULL == c_len )\r\n+\t\treturn OAES_RET_ARG5;\r\n+\t\r\n+\t_c_len_in = *c_len;\r\n+\t// data + pad\r\n+\t_c_data_len = m_len + _pad_len;\r\n+\t// header + iv + data + pad\r\n+\t*c_len = 2 * OAES_BLOCK_SIZE + m_len + _pad_len;\r\n+\r\n+\tif( NULL == c )\r\n+\t\treturn OAES_RET_SUCCESS;\r\n+\t\r\n+\tif( _c_len_in < *c_len )\r\n+\t\treturn OAES_RET_BUF;\r\n+\t\r\n+\tif( NULL == _ctx->key )\r\n+\t\treturn OAES_RET_NOKEY;\r\n+\t\r\n+\t// header\r\n+\tmemcpy(c, oaes_header, OAES_BLOCK_SIZE );\r\n+\tmemcpy(c + 6, &_ctx->options, sizeof(_ctx->options));\r\n+\tmemcpy(c + 8, &_flags, sizeof(_flags));\r\n+\t// iv\r\n+\tmemcpy(c + OAES_BLOCK_SIZE, _ctx->iv, OAES_BLOCK_SIZE );\r\n+\t// data\r\n+\tmemcpy(c + 2 * OAES_BLOCK_SIZE, m, m_len );\r\n+\t\r\n+\tfor( _i = 0; _i < _c_data_len; _i += OAES_BLOCK_SIZE )\r\n+\t{\r\n+\t\tuint8_t _block[OAES_BLOCK_SIZE];\r\n+\t\tsize_t _block_size = min( m_len - _i, OAES_BLOCK_SIZE );\r\n+\r\n+\t\tmemcpy( _block, c + 2 * OAES_BLOCK_SIZE + _i, _block_size );\r\n+\t\t\r\n+\t\t// insert pad\r\n+\t\tfor( _j = 0; _j < OAES_BLOCK_SIZE - _block_size; _j++ )\r\n+\t\t\t_block[ _block_size + _j ] = _j + 1;\r\n+\t\r\n+\t\t// CBC\r\n+\t\tif( _ctx->options & OAES_OPTION_CBC )\r\n+\t\t{\r\n+\t\t\tfor( _j = 0; _j < OAES_BLOCK_SIZE; _j++ )\r\n+\t\t\t\t_block[_j] = _block[_j] ^ _ctx->iv[_j];\r\n+\t\t}\r\n+\r\n+\t\t_rc = (OAES_RET) (_rc || oaes_encrypt_block( ctx, _block, OAES_BLOCK_SIZE ));\r\n+\t\tmemcpy( c + 2 * OAES_BLOCK_SIZE + _i, _block, OAES_BLOCK_SIZE );\r\n+\t\t\r\n+\t\tif( _ctx->options & OAES_OPTION_CBC )\r\n+\t\t\tmemcpy( _ctx->iv, _block, OAES_BLOCK_SIZE );\r\n+\t}\r\n+\t\r\n+\treturn _rc;\r\n+}\r\n+\r\n+OAES_RET oaes_decrypt( OAES_CTX * ctx,\r\n+\t\tconst uint8_t * c, size_t c_len, uint8_t * m, size_t * m_len )\r\n+{\r\n+\tsize_t _i, _j, _m_len_in;\r\n+\toaes_ctx * _ctx = (oaes_ctx *) ctx;\r\n+\tOAES_RET _rc = OAES_RET_SUCCESS;\r\n+\tuint8_t _iv[OAES_BLOCK_SIZE];\r\n+\tuint8_t _flags;\r\n+\tOAES_OPTION _options;\r\n+\t\r\n+\tif( NULL == ctx )\r\n+\t\treturn OAES_RET_ARG1;\r\n+\t\r\n+\tif( NULL == c )\r\n+\t\treturn OAES_RET_ARG2;\r\n+\t\r\n+\tif( c_len % OAES_BLOCK_SIZE )\r\n+\t\treturn OAES_RET_ARG3;\r\n+\t\r\n+\tif( NULL == m_len )\r\n+\t\treturn OAES_RET_ARG5;\r\n+\t\r\n+\t_m_len_in = *m_len;\r\n+\t*m_len = c_len - 2 * OAES_BLOCK_SIZE;\r\n+\t\r\n+\tif( NULL == m )\r\n+\t\treturn OAES_RET_SUCCESS;\r\n+\t\r\n+\tif( _m_len_in < *m_len )\r\n+\t\treturn OAES_RET_BUF;\r\n+\t\r\n+\tif( NULL == _ctx->key )\r\n+\t\treturn OAES_RET_NOKEY;\r\n+\t\r\n+\t// header\r\n+\tif( 0 != memcmp( c, oaes_header, 4 ) )\r\n+\t\treturn OAES_RET_HEADER;\r\n+\r\n+\t// header version\r\n+\tswitch( c[4] )\r\n+\t{\r\n+\t\tcase 0x01:\r\n+\t\t\tbreak;\r\n+\t\tdefault:\r\n+\t\t\treturn OAES_RET_HEADER;\r\n+\t}\r\n+\t\r\n+\t// header type\r\n+\tswitch( c[5] )\r\n+\t{\r\n+\t\tcase 0x02:\r\n+\t\t\tbreak;\r\n+\t\tdefault:\r\n+\t\t\treturn OAES_RET_HEADER;\r\n+\t}\r\n+\t\r\n+\t// options\r\n+\tmemcpy(&_options, c + 6, sizeof(_options));\r\n+\t// validate that all options are valid\r\n+\tif( _options & ~(\r\n+\t\t\t  OAES_OPTION_ECB\r\n+\t\t\t| OAES_OPTION_CBC\r\n+#ifdef OAES_DEBUG\r\n+\t\t\t| OAES_OPTION_STEP_ON\r\n+\t\t\t| OAES_OPTION_STEP_OFF\r\n+#endif // OAES_DEBUG\r\n+\t\t\t) )\r\n+\t\treturn OAES_RET_HEADER;\r\n+\tif( ( _options & OAES_OPTION_ECB ) &&\r\n+\t\t\t( _options & OAES_OPTION_CBC ) )\r\n+\t\treturn OAES_RET_HEADER;\r\n+\tif( _options == OAES_OPTION_NONE )\r\n+\t\treturn OAES_RET_HEADER;\r\n+\t\r\n+\t// flags\r\n+\tmemcpy(&_flags, c + 8, sizeof(_flags));\r\n+\t// validate that all flags are valid\r\n+\tif( _flags & ~(\r\n+\t\t\t  OAES_FLAG_PAD\r\n+\t\t\t) )\r\n+\t\treturn OAES_RET_HEADER;\r\n+\r\n+\t// iv\r\n+\tmemcpy( _iv, c + OAES_BLOCK_SIZE, OAES_BLOCK_SIZE);\r\n+\t// data + pad\r\n+\tmemcpy( m, c + 2 * OAES_BLOCK_SIZE, *m_len );\r\n+\t\r\n+\tfor( _i = 0; _i < *m_len; _i += OAES_BLOCK_SIZE )\r\n+\t{\r\n+\t\tif( ( _options & OAES_OPTION_CBC ) && _i > 0 )\r\n+\t\t\tmemcpy( _iv, c + OAES_BLOCK_SIZE + _i, OAES_BLOCK_SIZE );\r\n+\t\t\r\n+\t\t_rc =(OAES_RET) (_rc || oaes_decrypt_block( ctx, m + _i, min( *m_len - _i, OAES_BLOCK_SIZE ) ));\r\n+\t\t\r\n+\t\t// CBC\r\n+\t\tif( _options & OAES_OPTION_CBC )\r\n+\t\t{\r\n+\t\t\tfor( _j = 0; _j < OAES_BLOCK_SIZE; _j++ )\r\n+\t\t\t\tm[ _i + _j ] = m[ _i + _j ] ^ _iv[_j];\r\n+\t\t}\r\n+\t}\r\n+\t\r\n+\t// remove pad\r\n+\tif( _flags & OAES_FLAG_PAD )\r\n+\t{\r\n+\t\tint _is_pad = 1;\r\n+\t\tsize_t _temp = (size_t) m[*m_len - 1];\r\n+\r\n+\t\tif( _temp  <= 0x00 || _temp > 0x0f )\r\n+\t\t\treturn OAES_RET_HEADER;\r\n+\t\tfor( _i = 0; _i < _temp; _i++ )\r\n+\t\t\tif( m[*m_len - 1 - _i] != _temp - _i )\r\n+\t\t\t\t_is_pad = 0;\r\n+\t\tif( _is_pad )\r\n+\t\t{\r\n+\t\t\tmemset( m + *m_len - _temp, 0, _temp );\r\n+\t\t\t*m_len -= _temp;\r\n+\t\t}\r\n+\t\telse\r\n+\t\t\treturn OAES_RET_HEADER;\r\n+\t}\r\n+\t\r\n+\treturn OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+\r\n+OAES_API OAES_RET oaes_encryption_round( const uint8_t * key, uint8_t * c )\r\n+{\r\n+  size_t _i;\r\n+\r\n+  if( unlikely(NULL == key) )\r\n+    return OAES_RET_ARG1;\r\n+\r\n+  if( unlikely(NULL == c) )\r\n+    return OAES_RET_ARG2;\r\n+\r\n+  // SubBytes(state)\r\n+  for( _i = 0; _i < OAES_BLOCK_SIZE; _i++ )\r\n+    oaes_sub_byte( c + _i );\r\n+\r\n+  // ShiftRows(state)\r\n+  oaes_shift_rows( c );\r\n+\r\n+  // MixColumns(state)\r\n+  oaes_mix_cols( c );\r\n+  oaes_mix_cols( c + 4 );\r\n+  oaes_mix_cols( c + 8 );\r\n+  oaes_mix_cols( c + 12 );\r\n+\r\n+  // AddRoundKey(State, key)\r\n+  for( _i = 0; _i < OAES_BLOCK_SIZE; _i++ )\r\n+    c[_i] ^= key[_i];\r\n+\r\n+  return OAES_RET_SUCCESS;\r\n+}\r\n+\r\n+OAES_API OAES_RET oaes_pseudo_encrypt_ecb( OAES_CTX * ctx, uint8_t * c )\r\n+{\r\n+  size_t _i;\r\n+  oaes_ctx * _ctx = (oaes_ctx *) ctx;\r\n+\r\n+  if( unlikely(NULL == _ctx) )\r\n+    return OAES_RET_ARG1;\r\n+\r\n+  if( unlikely(NULL == c) )\r\n+    return OAES_RET_ARG2;\r\n+\r\n+  if( unlikely(NULL == _ctx->key) )\r\n+    return OAES_RET_NOKEY;\r\n+\r\n+  for ( _i = 0; _i < 10; ++_i )\r\n+  {\r\n+    oaes_encryption_round( &_ctx->key->exp_data[_i * OAES_RKEY_LEN * OAES_COL_LEN], c );\r\n+  }\r\n+\r\n+  return OAES_RET_SUCCESS;\r\n+}\r"
      },
      {
        "sha": "14af6472e63f872f962f34eed6946376d32b191b",
        "filename": "src/crypto/oaes_lib.h",
        "status": "added",
        "additions": 214,
        "deletions": 0,
        "changes": 214,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/oaes_lib.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/oaes_lib.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/oaes_lib.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,214 @@\n+/* \r\n+ * ---------------------------------------------------------------------------\r\n+ * OpenAES License\r\n+ * ---------------------------------------------------------------------------\r\n+ * Copyright (c) 2012, Nabil S. Al Ramli, www.nalramli.com\r\n+ * All rights reserved.\r\n+ * \r\n+ * Redistribution and use in source and binary forms, with or without\r\n+ * modification, are permitted provided that the following conditions are met:\r\n+ * \r\n+ *   - Redistributions of source code must retain the above copyright notice,\r\n+ *     this list of conditions and the following disclaimer.\r\n+ *   - Redistributions in binary form must reproduce the above copyright\r\n+ *     notice, this list of conditions and the following disclaimer in the\r\n+ *     documentation and/or other materials provided with the distribution.\r\n+ * \r\n+ * THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS \"AS IS\"\r\n+ * AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE\r\n+ * IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE\r\n+ * ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT HOLDER OR CONTRIBUTORS BE\r\n+ * LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR\r\n+ * CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF\r\n+ * SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS\r\n+ * INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN\r\n+ * CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)\r\n+ * ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE\r\n+ * POSSIBILITY OF SUCH DAMAGE.\r\n+ * ---------------------------------------------------------------------------\r\n+ */\r\n+\r\n+#ifndef _OAES_LIB_H\r\n+#define _OAES_LIB_H\r\n+\r\n+#include <stdint.h>\r\n+\r\n+#ifdef __cplusplus \r\n+extern \"C\" {\r\n+#endif\r\n+\r\n+#ifdef _WIN32\r\n+#\tifdef OAES_SHARED\r\n+#\t\tifdef oaes_lib_EXPORTS\r\n+#\t\t\tdefine OAES_API __declspec(dllexport)\r\n+#\t\telse\r\n+#\t\t\tdefine OAES_API __declspec(dllimport)\r\n+#\t\tendif\r\n+#\telse\r\n+#\t\tdefine OAES_API\r\n+#\tendif\r\n+#else\r\n+#\tdefine OAES_API\r\n+#endif // WIN32\r\n+\r\n+#define OAES_VERSION \"0.8.1\"\r\n+#define OAES_BLOCK_SIZE 16\r\n+\r\n+typedef void OAES_CTX;\r\n+\r\n+typedef enum\r\n+{\r\n+\tOAES_RET_FIRST = 0,\r\n+\tOAES_RET_SUCCESS = 0,\r\n+\tOAES_RET_UNKNOWN,\r\n+\tOAES_RET_ARG1,\r\n+\tOAES_RET_ARG2,\r\n+\tOAES_RET_ARG3,\r\n+\tOAES_RET_ARG4,\r\n+\tOAES_RET_ARG5,\r\n+\tOAES_RET_NOKEY,\r\n+\tOAES_RET_MEM,\r\n+\tOAES_RET_BUF,\r\n+\tOAES_RET_HEADER,\r\n+\tOAES_RET_COUNT\r\n+} OAES_RET;\r\n+\r\n+/*\r\n+ * oaes_set_option() takes one of these values for its [option] parameter\r\n+ * some options accept either an optional or a required [value] parameter\r\n+ */\r\n+// no option\r\n+#define OAES_OPTION_NONE 0\r\n+// enable ECB mode, disable CBC mode\r\n+#define OAES_OPTION_ECB 1\r\n+// enable CBC mode, disable ECB mode\r\n+// value is optional, may pass uint8_t iv[OAES_BLOCK_SIZE] to specify\r\n+// the value of the initialization vector, iv\r\n+#define OAES_OPTION_CBC 2\r\n+\r\n+#ifdef OAES_DEBUG\r\n+typedef int ( * oaes_step_cb ) (\r\n+\t\tconst uint8_t state[OAES_BLOCK_SIZE],\r\n+\t\tconst char * step_name,\r\n+\t\tint step_count,\r\n+\t\tvoid * user_data );\r\n+// enable state stepping mode\r\n+// value is required, must pass oaes_step_cb to receive the state at each step\r\n+#define OAES_OPTION_STEP_ON 4\r\n+// disable state stepping mode\r\n+#define OAES_OPTION_STEP_OFF 8\r\n+#endif // OAES_DEBUG\r\n+\r\n+typedef uint16_t OAES_OPTION;\r\n+\r\n+typedef struct _oaes_key\r\n+{\r\n+  size_t data_len;\r\n+  uint8_t *data;\r\n+  size_t exp_data_len;\r\n+  uint8_t *exp_data;\r\n+  size_t num_keys;\r\n+  size_t key_base;\r\n+} oaes_key;\r\n+\r\n+typedef struct _oaes_ctx\r\n+{\r\n+#ifdef OAES_HAVE_ISAAC\r\n+  randctx * rctx;\r\n+#endif // OAES_HAVE_ISAAC\r\n+\r\n+#ifdef OAES_DEBUG\r\n+  oaes_step_cb step_cb;\r\n+#endif // OAES_DEBUG\r\n+\r\n+  oaes_key * key;\r\n+  OAES_OPTION options;\r\n+  uint8_t iv[OAES_BLOCK_SIZE];\r\n+} oaes_ctx;\r\n+/*\r\n+ * // usage:\r\n+ * \r\n+ * OAES_CTX * ctx = oaes_alloc();\r\n+ * .\r\n+ * .\r\n+ * .\r\n+ * {\r\n+ *   oaes_gen_key_xxx( ctx );\r\n+ *   {\r\n+ *     oaes_key_export( ctx, _buf, &_buf_len );\r\n+ *     // or\r\n+ *     oaes_key_export_data( ctx, _buf, &_buf_len );\\\r\n+ *   }\r\n+ * }\r\n+ * // or\r\n+ * {\r\n+ *   oaes_key_import( ctx, _buf, _buf_len );\r\n+ *   // or\r\n+ *   oaes_key_import_data( ctx, _buf, _buf_len );\r\n+ * }\r\n+ * .\r\n+ * .\r\n+ * .\r\n+ * oaes_encrypt( ctx, m, m_len, c, &c_len );\r\n+ * .\r\n+ * .\r\n+ * .\r\n+ * oaes_decrypt( ctx, c, c_len, m, &m_len );\r\n+ * .\r\n+ * .\r\n+ * .\r\n+ * oaes_free( &ctx );\r\n+ */\r\n+\r\n+OAES_API OAES_CTX * oaes_alloc(void);\r\n+\r\n+OAES_API OAES_RET oaes_free( OAES_CTX ** ctx );\r\n+\r\n+OAES_API OAES_RET oaes_set_option( OAES_CTX * ctx,\r\n+\t\tOAES_OPTION option, const void * value );\r\n+\r\n+OAES_API OAES_RET oaes_key_gen_128( OAES_CTX * ctx );\r\n+\r\n+OAES_API OAES_RET oaes_key_gen_192( OAES_CTX * ctx );\r\n+\r\n+OAES_API OAES_RET oaes_key_gen_256( OAES_CTX * ctx );\r\n+\r\n+// export key with header information\r\n+// set data == NULL to get the required data_len\r\n+OAES_API OAES_RET oaes_key_export( OAES_CTX * ctx,\r\n+\t\tuint8_t * data, size_t * data_len );\r\n+\r\n+// directly export the data from key\r\n+// set data == NULL to get the required data_len\r\n+OAES_API OAES_RET oaes_key_export_data( OAES_CTX * ctx,\r\n+\t\tuint8_t * data, size_t * data_len );\r\n+\r\n+// import key with header information\r\n+OAES_API OAES_RET oaes_key_import( OAES_CTX * ctx,\r\n+\t\tconst uint8_t * data, size_t data_len );\r\n+\r\n+// directly import data into key\r\n+OAES_API OAES_RET oaes_key_import_data( OAES_CTX * ctx,\r\n+\t\tconst uint8_t * data, size_t data_len );\r\n+\r\n+// set c == NULL to get the required c_len\r\n+OAES_API OAES_RET oaes_encrypt( OAES_CTX * ctx,\r\n+\t\tconst uint8_t * m, size_t m_len, uint8_t * c, size_t * c_len );\r\n+\r\n+// set m == NULL to get the required m_len\r\n+OAES_API OAES_RET oaes_decrypt( OAES_CTX * ctx,\r\n+\t\tconst uint8_t * c, size_t c_len, uint8_t * m, size_t * m_len );\r\n+\r\n+// set buf == NULL to get the required buf_len\r\n+OAES_API OAES_RET oaes_sprintf(\r\n+\t\tchar * buf, size_t * buf_len, const uint8_t * data, size_t data_len );\r\n+\r\n+OAES_API OAES_RET oaes_encryption_round( const uint8_t * key, uint8_t * c );\r\n+\r\n+OAES_API OAES_RET oaes_pseudo_encrypt_ecb( OAES_CTX * ctx, uint8_t * c );\r\n+\r\n+#ifdef __cplusplus \r\n+}\r\n+#endif\r\n+\r\n+#endif // _OAES_LIB_H\r"
      },
      {
        "sha": "cd38c150d7b0bc50f0175b556f23a5e80b45124e",
        "filename": "src/crypto/skein_port.h",
        "status": "added",
        "additions": 127,
        "deletions": 0,
        "changes": 127,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/skein_port.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/skein_port.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/skein_port.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,127 @@\n+#ifndef _SKEIN_PORT_H_\r\n+#define _SKEIN_PORT_H_\r\n+\r\n+#include <limits.h>\r\n+#include <stdint.h>\r\n+\r\n+#ifndef RETURN_VALUES\r\n+#  define RETURN_VALUES\r\n+#  if defined( DLL_EXPORT )\r\n+#    if defined( _MSC_VER ) || defined ( __INTEL_COMPILER )\r\n+#      define VOID_RETURN    __declspec( dllexport ) void __stdcall\r\n+#      define INT_RETURN     __declspec( dllexport ) int  __stdcall\r\n+#    elif defined( __GNUC__ )\r\n+#      define VOID_RETURN    __declspec( __dllexport__ ) void\r\n+#      define INT_RETURN     __declspec( __dllexport__ ) int\r\n+#    else\r\n+#      error Use of the DLL is only available on the Microsoft, Intel and GCC compilers\r\n+#    endif\r\n+#  elif defined( DLL_IMPORT )\r\n+#    if defined( _MSC_VER ) || defined ( __INTEL_COMPILER )\r\n+#      define VOID_RETURN    __declspec( dllimport ) void __stdcall\r\n+#      define INT_RETURN     __declspec( dllimport ) int  __stdcall\r\n+#    elif defined( __GNUC__ )\r\n+#      define VOID_RETURN    __declspec( __dllimport__ ) void\r\n+#      define INT_RETURN     __declspec( __dllimport__ ) int\r\n+#    else\r\n+#      error Use of the DLL is only available on the Microsoft, Intel and GCC compilers\r\n+#    endif\r\n+#  elif defined( __WATCOMC__ )\r\n+#    define VOID_RETURN  void __cdecl\r\n+#    define INT_RETURN   int  __cdecl\r\n+#  else\r\n+#    define VOID_RETURN  void\r\n+#    define INT_RETURN   int\r\n+#  endif\r\n+#endif\r\n+\r\n+/*  These defines are used to declare buffers in a way that allows\r\n+    faster operations on longer variables to be used.  In all these\r\n+    defines 'size' must be a power of 2 and >= 8\r\n+\r\n+    dec_unit_type(size,x)       declares a variable 'x' of length \r\n+                                'size' bits\r\n+\r\n+    dec_bufr_type(size,bsize,x) declares a buffer 'x' of length 'bsize' \r\n+                                bytes defined as an array of variables\r\n+                                each of 'size' bits (bsize must be a \r\n+                                multiple of size / 8)\r\n+\r\n+    ptr_cast(x,size)            casts a pointer to a pointer to a \r\n+                                varaiable of length 'size' bits\r\n+*/\r\n+\r\n+#define ui_type(size)               uint##size##_t\r\n+#define dec_unit_type(size,x)       typedef ui_type(size) x\r\n+#define dec_bufr_type(size,bsize,x) typedef ui_type(size) x[bsize / (size >> 3)]\r\n+#define ptr_cast(x,size)            ((ui_type(size)*)(x))\r\n+\r\n+typedef unsigned int    uint_t;             /* native unsigned integer */\r\n+typedef uint8_t         u08b_t;             /*  8-bit unsigned integer */\r\n+typedef uint64_t        u64b_t;             /* 64-bit unsigned integer */\r\n+\r\n+#ifndef RotL_64\r\n+#define RotL_64(x,N)    (((x) << (N)) | ((x) >> (64-(N))))\r\n+#endif\r\n+\r\n+#define SKEIN_NEED_SWAP (0)\r\n+\r\n+/*\r\n+ ******************************************************************\r\n+ *      Provide any definitions still needed.\r\n+ ******************************************************************\r\n+ */\r\n+#ifndef Skein_Swap64  /* swap for big-endian, nop for little-endian */\r\n+#if     SKEIN_NEED_SWAP\r\n+#define Skein_Swap64(w64)                       \\\r\n+  ( (( ((u64b_t)(w64))       & 0xFF) << 56) |   \\\r\n+    (((((u64b_t)(w64)) >> 8) & 0xFF) << 48) |   \\\r\n+    (((((u64b_t)(w64)) >>16) & 0xFF) << 40) |   \\\r\n+    (((((u64b_t)(w64)) >>24) & 0xFF) << 32) |   \\\r\n+    (((((u64b_t)(w64)) >>32) & 0xFF) << 24) |   \\\r\n+    (((((u64b_t)(w64)) >>40) & 0xFF) << 16) |   \\\r\n+    (((((u64b_t)(w64)) >>48) & 0xFF) <<  8) |   \\\r\n+    (((((u64b_t)(w64)) >>56) & 0xFF)      ) )\r\n+#else\r\n+#define Skein_Swap64(w64)  (w64)\r\n+#endif\r\n+#endif  /* ifndef Skein_Swap64 */\r\n+\r\n+\r\n+#ifndef Skein_Put64_LSB_First\r\n+void    Skein_Put64_LSB_First(u08b_t *dst,const u64b_t *src,size_t bCnt)\r\n+#ifdef  SKEIN_PORT_CODE /* instantiate the function code here? */\r\n+    { /* this version is fully portable (big-endian or little-endian), but slow */\r\n+    size_t n;\r\n+\r\n+    for (n=0;n<bCnt;n++)\r\n+        dst[n] = (u08b_t) (src[n>>3] >> (8*(n&7)));\r\n+    }\r\n+#else\r\n+    ;    /* output only the function prototype */\r\n+#endif\r\n+#endif   /* ifndef Skein_Put64_LSB_First */\r\n+\r\n+\r\n+#ifndef Skein_Get64_LSB_First\r\n+void    Skein_Get64_LSB_First(u64b_t *dst,const u08b_t *src,size_t wCnt)\r\n+#ifdef  SKEIN_PORT_CODE /* instantiate the function code here? */\r\n+    { /* this version is fully portable (big-endian or little-endian), but slow */\r\n+    size_t n;\r\n+\r\n+    for (n=0;n<8*wCnt;n+=8)\r\n+        dst[n/8] = (((u64b_t) src[n  ])      ) +\r\n+                   (((u64b_t) src[n+1]) <<  8) +\r\n+                   (((u64b_t) src[n+2]) << 16) +\r\n+                   (((u64b_t) src[n+3]) << 24) +\r\n+                   (((u64b_t) src[n+4]) << 32) +\r\n+                   (((u64b_t) src[n+5]) << 40) +\r\n+                   (((u64b_t) src[n+6]) << 48) +\r\n+                   (((u64b_t) src[n+7]) << 56) ;\r\n+    }\r\n+#else\r\n+    ;    /* output only the function prototype */\r\n+#endif\r\n+#endif   /* ifndef Skein_Get64_LSB_First */\r\n+\r\n+#endif   /* ifndef _SKEIN_PORT_H_ */\r"
      },
      {
        "sha": "2fd1a3692b4a0eb5d210d28e075292ffe936bd7e",
        "filename": "src/crypto/types.h",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/types.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/crypto/types.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/crypto/types.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -0,0 +1,18 @@\n+#ifndef _TYPES_H_\n+#define _TYPES_H_\n+\n+#undef unlikely\n+#undef likely\n+#if defined(__GNUC__) && (__GNUC__ > 2) && defined(__OPTIMIZE__)\n+#define unlikely(expr) (__builtin_expect(!!(expr), 0))\n+#define likely(expr) (__builtin_expect(!!(expr), 1))\n+#else\n+#define unlikely(expr) (expr)\n+#define likely(expr) (expr)\n+#endif\n+\n+typedef unsigned char BitSequence;\n+typedef unsigned long long DataLength;\n+typedef enum {SUCCESS = 0, FAIL = 1, BAD_HASHLEN = 2} HashReturn;\n+\n+#endif"
      },
      {
        "sha": "194bf9f97192232c4965d680a5a1ab317a5ccc4d",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 248,
        "deletions": 248,
        "changes": 496,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,248 +1,248 @@\n-// Copyright (c) 2013-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <hash.h>\n-#include <crypto/common.h>\n-#include <crypto/hmac_sha512.h>\n-#include <pubkey.h>\n-\n-\n-inline uint32_t ROTL32(uint32_t x, int8_t r)\n-{\n-    return (x << r) | (x >> (32 - r));\n-}\n-\n-unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char>& vDataToHash)\n-{\n-    // The following is MurmurHash3 (x86_32), see http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp\n-    uint32_t h1 = nHashSeed;\n-    const uint32_t c1 = 0xcc9e2d51;\n-    const uint32_t c2 = 0x1b873593;\n-\n-    const int nblocks = vDataToHash.size() / 4;\n-\n-    //----------\n-    // body\n-    const uint8_t* blocks = vDataToHash.data();\n-\n-    for (int i = 0; i < nblocks; ++i) {\n-        uint32_t k1 = ReadLE32(blocks + i*4);\n-\n-        k1 *= c1;\n-        k1 = ROTL32(k1, 15);\n-        k1 *= c2;\n-\n-        h1 ^= k1;\n-        h1 = ROTL32(h1, 13);\n-        h1 = h1 * 5 + 0xe6546b64;\n-    }\n-\n-    //----------\n-    // tail\n-    const uint8_t* tail = vDataToHash.data() + nblocks * 4;\n-\n-    uint32_t k1 = 0;\n-\n-    switch (vDataToHash.size() & 3) {\n-        case 3:\n-            k1 ^= tail[2] << 16;\n-        case 2:\n-            k1 ^= tail[1] << 8;\n-        case 1:\n-            k1 ^= tail[0];\n-            k1 *= c1;\n-            k1 = ROTL32(k1, 15);\n-            k1 *= c2;\n-            h1 ^= k1;\n-    }\n-\n-    //----------\n-    // finalization\n-    h1 ^= vDataToHash.size();\n-    h1 ^= h1 >> 16;\n-    h1 *= 0x85ebca6b;\n-    h1 ^= h1 >> 13;\n-    h1 *= 0xc2b2ae35;\n-    h1 ^= h1 >> 16;\n-\n-    return h1;\n-}\n-\n-void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64])\n-{\n-    unsigned char num[4];\n-    num[0] = (nChild >> 24) & 0xFF;\n-    num[1] = (nChild >> 16) & 0xFF;\n-    num[2] = (nChild >>  8) & 0xFF;\n-    num[3] = (nChild >>  0) & 0xFF;\n-    CHMAC_SHA512(chainCode.begin(), chainCode.size()).Write(&header, 1).Write(data, 32).Write(num, 4).Finalize(output);\n-}\n-\n-#define ROTL(x, b) (uint64_t)(((x) << (b)) | ((x) >> (64 - (b))))\n-\n-#define SIPROUND do { \\\n-    v0 += v1; v1 = ROTL(v1, 13); v1 ^= v0; \\\n-    v0 = ROTL(v0, 32); \\\n-    v2 += v3; v3 = ROTL(v3, 16); v3 ^= v2; \\\n-    v0 += v3; v3 = ROTL(v3, 21); v3 ^= v0; \\\n-    v2 += v1; v1 = ROTL(v1, 17); v1 ^= v2; \\\n-    v2 = ROTL(v2, 32); \\\n-} while (0)\n-\n-CSipHasher::CSipHasher(uint64_t k0, uint64_t k1)\n-{\n-    v[0] = 0x736f6d6570736575ULL ^ k0;\n-    v[1] = 0x646f72616e646f6dULL ^ k1;\n-    v[2] = 0x6c7967656e657261ULL ^ k0;\n-    v[3] = 0x7465646279746573ULL ^ k1;\n-    count = 0;\n-    tmp = 0;\n-}\n-\n-CSipHasher& CSipHasher::Write(uint64_t data)\n-{\n-    uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\n-\n-    assert(count % 8 == 0);\n-\n-    v3 ^= data;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= data;\n-\n-    v[0] = v0;\n-    v[1] = v1;\n-    v[2] = v2;\n-    v[3] = v3;\n-\n-    count += 8;\n-    return *this;\n-}\n-\n-CSipHasher& CSipHasher::Write(const unsigned char* data, size_t size)\n-{\n-    uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\n-    uint64_t t = tmp;\n-    int c = count;\n-\n-    while (size--) {\n-        t |= ((uint64_t)(*(data++))) << (8 * (c % 8));\n-        c++;\n-        if ((c & 7) == 0) {\n-            v3 ^= t;\n-            SIPROUND;\n-            SIPROUND;\n-            v0 ^= t;\n-            t = 0;\n-        }\n-    }\n-\n-    v[0] = v0;\n-    v[1] = v1;\n-    v[2] = v2;\n-    v[3] = v3;\n-    count = c;\n-    tmp = t;\n-\n-    return *this;\n-}\n-\n-uint64_t CSipHasher::Finalize() const\n-{\n-    uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\n-\n-    uint64_t t = tmp | (((uint64_t)count) << 56);\n-\n-    v3 ^= t;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= t;\n-    v2 ^= 0xFF;\n-    SIPROUND;\n-    SIPROUND;\n-    SIPROUND;\n-    SIPROUND;\n-    return v0 ^ v1 ^ v2 ^ v3;\n-}\n-\n-uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val)\n-{\n-    /* Specialized implementation for efficiency */\n-    uint64_t d = val.GetUint64(0);\n-\n-    uint64_t v0 = 0x736f6d6570736575ULL ^ k0;\n-    uint64_t v1 = 0x646f72616e646f6dULL ^ k1;\n-    uint64_t v2 = 0x6c7967656e657261ULL ^ k0;\n-    uint64_t v3 = 0x7465646279746573ULL ^ k1 ^ d;\n-\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    d = val.GetUint64(1);\n-    v3 ^= d;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    d = val.GetUint64(2);\n-    v3 ^= d;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    d = val.GetUint64(3);\n-    v3 ^= d;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    v3 ^= ((uint64_t)4) << 59;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= ((uint64_t)4) << 59;\n-    v2 ^= 0xFF;\n-    SIPROUND;\n-    SIPROUND;\n-    SIPROUND;\n-    SIPROUND;\n-    return v0 ^ v1 ^ v2 ^ v3;\n-}\n-\n-uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra)\n-{\n-    /* Specialized implementation for efficiency */\n-    uint64_t d = val.GetUint64(0);\n-\n-    uint64_t v0 = 0x736f6d6570736575ULL ^ k0;\n-    uint64_t v1 = 0x646f72616e646f6dULL ^ k1;\n-    uint64_t v2 = 0x6c7967656e657261ULL ^ k0;\n-    uint64_t v3 = 0x7465646279746573ULL ^ k1 ^ d;\n-\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    d = val.GetUint64(1);\n-    v3 ^= d;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    d = val.GetUint64(2);\n-    v3 ^= d;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    d = val.GetUint64(3);\n-    v3 ^= d;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    d = (((uint64_t)36) << 56) | extra;\n-    v3 ^= d;\n-    SIPROUND;\n-    SIPROUND;\n-    v0 ^= d;\n-    v2 ^= 0xFF;\n-    SIPROUND;\n-    SIPROUND;\n-    SIPROUND;\n-    SIPROUND;\n-    return v0 ^ v1 ^ v2 ^ v3;\n-}\n+// Copyright (c) 2013-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <hash.h>\r\n+#include <crypto/common.h>\r\n+#include <crypto/hmac_sha512.h>\r\n+#include <pubkey.h>\r\n+\r\n+\r\n+inline uint32_t ROTL32(uint32_t x, int8_t r)\r\n+{\r\n+    return (x << r) | (x >> (32 - r));\r\n+}\r\n+\r\n+unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char>& vDataToHash)\r\n+{\r\n+    // The following is MurmurHash3 (x86_32), see http://code.google.com/p/smhasher/source/browse/trunk/MurmurHash3.cpp\r\n+    uint32_t h1 = nHashSeed;\r\n+    const uint32_t c1 = 0xcc9e2d51;\r\n+    const uint32_t c2 = 0x1b873593;\r\n+\r\n+    const int nblocks = vDataToHash.size() / 4;\r\n+\r\n+    //----------\r\n+    // body\r\n+    const uint8_t* blocks = vDataToHash.data();\r\n+\r\n+    for (int i = 0; i < nblocks; ++i) {\r\n+        uint32_t k1 = ReadLE32(blocks + i*4);\r\n+\r\n+        k1 *= c1;\r\n+        k1 = ROTL32(k1, 15);\r\n+        k1 *= c2;\r\n+\r\n+        h1 ^= k1;\r\n+        h1 = ROTL32(h1, 13);\r\n+        h1 = h1 * 5 + 0xe6546b64;\r\n+    }\r\n+\r\n+    //----------\r\n+    // tail\r\n+    const uint8_t* tail = vDataToHash.data() + nblocks * 4;\r\n+\r\n+    uint32_t k1 = 0;\r\n+\r\n+    switch (vDataToHash.size() & 3) {\r\n+        case 3:\r\n+            k1 ^= tail[2] << 16;\r\n+        case 2:\r\n+            k1 ^= tail[1] << 8;\r\n+        case 1:\r\n+            k1 ^= tail[0];\r\n+            k1 *= c1;\r\n+            k1 = ROTL32(k1, 15);\r\n+            k1 *= c2;\r\n+            h1 ^= k1;\r\n+    }\r\n+\r\n+    //----------\r\n+    // finalization\r\n+    h1 ^= vDataToHash.size();\r\n+    h1 ^= h1 >> 16;\r\n+    h1 *= 0x85ebca6b;\r\n+    h1 ^= h1 >> 13;\r\n+    h1 *= 0xc2b2ae35;\r\n+    h1 ^= h1 >> 16;\r\n+\r\n+    return h1;\r\n+}\r\n+\r\n+void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64])\r\n+{\r\n+    unsigned char num[4];\r\n+    num[0] = (nChild >> 24) & 0xFF;\r\n+    num[1] = (nChild >> 16) & 0xFF;\r\n+    num[2] = (nChild >>  8) & 0xFF;\r\n+    num[3] = (nChild >>  0) & 0xFF;\r\n+    CHMAC_SHA512(chainCode.begin(), chainCode.size()).Write(&header, 1).Write(data, 32).Write(num, 4).Finalize(output);\r\n+}\r\n+\r\n+#define ROTL(x, b) (uint64_t)(((x) << (b)) | ((x) >> (64 - (b))))\r\n+\r\n+#define SIPROUND do { \\\r\n+    v0 += v1; v1 = ROTL(v1, 13); v1 ^= v0; \\\r\n+    v0 = ROTL(v0, 32); \\\r\n+    v2 += v3; v3 = ROTL(v3, 16); v3 ^= v2; \\\r\n+    v0 += v3; v3 = ROTL(v3, 21); v3 ^= v0; \\\r\n+    v2 += v1; v1 = ROTL(v1, 17); v1 ^= v2; \\\r\n+    v2 = ROTL(v2, 32); \\\r\n+} while (0)\r\n+\r\n+CSipHasher::CSipHasher(uint64_t k0, uint64_t k1)\r\n+{\r\n+    v[0] = 0x736f6d6570736575ULL ^ k0;\r\n+    v[1] = 0x646f72616e646f6dULL ^ k1;\r\n+    v[2] = 0x6c7967656e657261ULL ^ k0;\r\n+    v[3] = 0x7465646279746573ULL ^ k1;\r\n+    count = 0;\r\n+    tmp = 0;\r\n+}\r\n+\r\n+CSipHasher& CSipHasher::Write(uint64_t data)\r\n+{\r\n+    uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\r\n+\r\n+    assert(count % 8 == 0);\r\n+\r\n+    v3 ^= data;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    v0 ^= data;\r\n+\r\n+    v[0] = v0;\r\n+    v[1] = v1;\r\n+    v[2] = v2;\r\n+    v[3] = v3;\r\n+\r\n+    count += 8;\r\n+    return *this;\r\n+}\r\n+\r\n+CSipHasher& CSipHasher::Write(const unsigned char* data, size_t size)\r\n+{\r\n+    uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\r\n+    uint64_t t = tmp;\r\n+    int c = count;\r\n+\r\n+    while (size--) {\r\n+        t |= ((uint64_t)(*(data++))) << (8 * (c % 8));\r\n+        c++;\r\n+        if ((c & 7) == 0) {\r\n+            v3 ^= t;\r\n+            SIPROUND;\r\n+            SIPROUND;\r\n+            v0 ^= t;\r\n+            t = 0;\r\n+        }\r\n+    }\r\n+\r\n+    v[0] = v0;\r\n+    v[1] = v1;\r\n+    v[2] = v2;\r\n+    v[3] = v3;\r\n+    count = c;\r\n+    tmp = t;\r\n+\r\n+    return *this;\r\n+}\r\n+\r\n+uint64_t CSipHasher::Finalize() const\r\n+{\r\n+    uint64_t v0 = v[0], v1 = v[1], v2 = v[2], v3 = v[3];\r\n+\r\n+    uint64_t t = tmp | (((uint64_t)count) << 56);\r\n+\r\n+    v3 ^= t;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    v0 ^= t;\r\n+    v2 ^= 0xFF;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    return v0 ^ v1 ^ v2 ^ v3;\r\n+}\r\n+\r\n+uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val)\r\n+{\r\n+    /* Specialized implementation for efficiency */\r\n+    uint64_t d = val.GetUint64(0);\r\n+\r\n+    uint64_t v0 = 0x736f6d6570736575ULL ^ k0;\r\n+    uint64_t v1 = 0x646f72616e646f6dULL ^ k1;\r\n+    uint64_t v2 = 0x6c7967656e657261ULL ^ k0;\r\n+    uint64_t v3 = 0x7465646279746573ULL ^ k1 ^ d;\r\n+\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    v0 ^= d;\r\n+    d = val.GetUint64(1);\r\n+    v3 ^= d;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    v0 ^= d;\r\n+    d = val.GetUint64(2);\r\n+    v3 ^= d;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    v0 ^= d;\r\n+    d = val.GetUint64(3);\r\n+    v3 ^= d;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    v0 ^= d;\r\n+    v3 ^= ((uint64_t)4) << 59;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    v0 ^= ((uint64_t)4) << 59;\r\n+    v2 ^= 0xFF;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    return v0 ^ v1 ^ v2 ^ v3;\r\n+}\r\n+\r\n+uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra)\r\n+{\r\n+    /* Specialized implementation for efficiency */\r\n+    uint64_t d = val.GetUint64(0);\r\n+\r\n+    uint64_t v0 = 0x736f6d6570736575ULL ^ k0;\r\n+    uint64_t v1 = 0x646f72616e646f6dULL ^ k1;\r\n+    uint64_t v2 = 0x6c7967656e657261ULL ^ k0;\r\n+    uint64_t v3 = 0x7465646279746573ULL ^ k1 ^ d;\r\n+\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    v0 ^= d;\r\n+    d = val.GetUint64(1);\r\n+    v3 ^= d;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    v0 ^= d;\r\n+    d = val.GetUint64(2);\r\n+    v3 ^= d;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    v0 ^= d;\r\n+    d = val.GetUint64(3);\r\n+    v3 ^= d;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    v0 ^= d;\r\n+    d = (((uint64_t)36) << 56) | extra;\r\n+    v3 ^= d;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    v0 ^= d;\r\n+    v2 ^= 0xFF;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    SIPROUND;\r\n+    return v0 ^ v1 ^ v2 ^ v3;\r\n+}\r"
      },
      {
        "sha": "3f759e9ededc2441b7e7c5198b9a177ff0263f3c",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 232,
        "deletions": 232,
        "changes": 464,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,232 +1,232 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_HASH_H\n-#define BITCOIN_HASH_H\n-\n-#include <crypto/ripemd160.h>\n-#include <crypto/sha256.h>\n-#include <prevector.h>\n-#include <serialize.h>\n-#include <uint256.h>\n-#include <version.h>\n-\n-#include <vector>\n-\n-typedef uint256 ChainCode;\n-\n-/** A hasher class for Bitcoin's 256-bit hash (double SHA-256). */\n-class CHash256 {\n-private:\n-    CSHA256 sha;\n-public:\n-    static const size_t OUTPUT_SIZE = CSHA256::OUTPUT_SIZE;\n-\n-    void Finalize(unsigned char hash[OUTPUT_SIZE]) {\n-        unsigned char buf[CSHA256::OUTPUT_SIZE];\n-        sha.Finalize(buf);\n-        sha.Reset().Write(buf, CSHA256::OUTPUT_SIZE).Finalize(hash);\n-    }\n-\n-    CHash256& Write(const unsigned char *data, size_t len) {\n-        sha.Write(data, len);\n-        return *this;\n-    }\n-\n-    CHash256& Reset() {\n-        sha.Reset();\n-        return *this;\n-    }\n-};\n-\n-/** A hasher class for Bitcoin's 160-bit hash (SHA-256 + RIPEMD-160). */\n-class CHash160 {\n-private:\n-    CSHA256 sha;\n-public:\n-    static const size_t OUTPUT_SIZE = CRIPEMD160::OUTPUT_SIZE;\n-\n-    void Finalize(unsigned char hash[OUTPUT_SIZE]) {\n-        unsigned char buf[CSHA256::OUTPUT_SIZE];\n-        sha.Finalize(buf);\n-        CRIPEMD160().Write(buf, CSHA256::OUTPUT_SIZE).Finalize(hash);\n-    }\n-\n-    CHash160& Write(const unsigned char *data, size_t len) {\n-        sha.Write(data, len);\n-        return *this;\n-    }\n-\n-    CHash160& Reset() {\n-        sha.Reset();\n-        return *this;\n-    }\n-};\n-\n-/** Compute the 256-bit hash of an object. */\n-template<typename T1>\n-inline uint256 Hash(const T1 pbegin, const T1 pend)\n-{\n-    static const unsigned char pblank[1] = {};\n-    uint256 result;\n-    CHash256().Write(pbegin == pend ? pblank : (const unsigned char*)&pbegin[0], (pend - pbegin) * sizeof(pbegin[0]))\n-              .Finalize((unsigned char*)&result);\n-    return result;\n-}\n-\n-/** Compute the 256-bit hash of the concatenation of two objects. */\n-template<typename T1, typename T2>\n-inline uint256 Hash(const T1 p1begin, const T1 p1end,\n-                    const T2 p2begin, const T2 p2end) {\n-    static const unsigned char pblank[1] = {};\n-    uint256 result;\n-    CHash256().Write(p1begin == p1end ? pblank : (const unsigned char*)&p1begin[0], (p1end - p1begin) * sizeof(p1begin[0]))\n-              .Write(p2begin == p2end ? pblank : (const unsigned char*)&p2begin[0], (p2end - p2begin) * sizeof(p2begin[0]))\n-              .Finalize((unsigned char*)&result);\n-    return result;\n-}\n-\n-/** Compute the 160-bit hash an object. */\n-template<typename T1>\n-inline uint160 Hash160(const T1 pbegin, const T1 pend)\n-{\n-    static unsigned char pblank[1] = {};\n-    uint160 result;\n-    CHash160().Write(pbegin == pend ? pblank : (const unsigned char*)&pbegin[0], (pend - pbegin) * sizeof(pbegin[0]))\n-              .Finalize((unsigned char*)&result);\n-    return result;\n-}\n-\n-/** Compute the 160-bit hash of a vector. */\n-inline uint160 Hash160(const std::vector<unsigned char>& vch)\n-{\n-    return Hash160(vch.begin(), vch.end());\n-}\n-\n-/** Compute the 160-bit hash of a vector. */\n-template<unsigned int N>\n-inline uint160 Hash160(const prevector<N, unsigned char>& vch)\n-{\n-    return Hash160(vch.begin(), vch.end());\n-}\n-\n-/** A writer stream (for serialization) that computes a 256-bit hash. */\n-class CHashWriter\n-{\n-private:\n-    CHash256 ctx;\n-\n-    const int nType;\n-    const int nVersion;\n-public:\n-\n-    CHashWriter(int nTypeIn, int nVersionIn) : nType(nTypeIn), nVersion(nVersionIn) {}\n-\n-    int GetType() const { return nType; }\n-    int GetVersion() const { return nVersion; }\n-\n-    void write(const char *pch, size_t size) {\n-        ctx.Write((const unsigned char*)pch, size);\n-    }\n-\n-    // invalidates the object\n-    uint256 GetHash() {\n-        uint256 result;\n-        ctx.Finalize((unsigned char*)&result);\n-        return result;\n-    }\n-\n-    template<typename T>\n-    CHashWriter& operator<<(const T& obj) {\n-        // Serialize to this stream\n-        ::Serialize(*this, obj);\n-        return (*this);\n-    }\n-};\n-\n-/** Reads data from an underlying stream, while hashing the read data. */\n-template<typename Source>\n-class CHashVerifier : public CHashWriter\n-{\n-private:\n-    Source* source;\n-\n-public:\n-    explicit CHashVerifier(Source* source_) : CHashWriter(source_->GetType(), source_->GetVersion()), source(source_) {}\n-\n-    void read(char* pch, size_t nSize)\n-    {\n-        source->read(pch, nSize);\n-        this->write(pch, nSize);\n-    }\n-\n-    void ignore(size_t nSize)\n-    {\n-        char data[1024];\n-        while (nSize > 0) {\n-            size_t now = std::min<size_t>(nSize, 1024);\n-            read(data, now);\n-            nSize -= now;\n-        }\n-    }\n-\n-    template<typename T>\n-    CHashVerifier<Source>& operator>>(T& obj)\n-    {\n-        // Unserialize from this stream\n-        ::Unserialize(*this, obj);\n-        return (*this);\n-    }\n-};\n-\n-/** Compute the 256-bit hash of an object's serialization. */\n-template<typename T>\n-uint256 SerializeHash(const T& obj, int nType=SER_GETHASH, int nVersion=PROTOCOL_VERSION)\n-{\n-    CHashWriter ss(nType, nVersion);\n-    ss << obj;\n-    return ss.GetHash();\n-}\n-\n-unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char>& vDataToHash);\n-\n-void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64]);\n-\n-/** SipHash-2-4 */\n-class CSipHasher\n-{\n-private:\n-    uint64_t v[4];\n-    uint64_t tmp;\n-    int count;\n-\n-public:\n-    /** Construct a SipHash calculator initialized with 128-bit key (k0, k1) */\n-    CSipHasher(uint64_t k0, uint64_t k1);\n-    /** Hash a 64-bit integer worth of data\n-     *  It is treated as if this was the little-endian interpretation of 8 bytes.\n-     *  This function can only be used when a multiple of 8 bytes have been written so far.\n-     */\n-    CSipHasher& Write(uint64_t data);\n-    /** Hash arbitrary bytes. */\n-    CSipHasher& Write(const unsigned char* data, size_t size);\n-    /** Compute the 64-bit SipHash-2-4 of the data written so far. The object remains untouched. */\n-    uint64_t Finalize() const;\n-};\n-\n-/** Optimized SipHash-2-4 implementation for uint256.\n- *\n- *  It is identical to:\n- *    SipHasher(k0, k1)\n- *      .Write(val.GetUint64(0))\n- *      .Write(val.GetUint64(1))\n- *      .Write(val.GetUint64(2))\n- *      .Write(val.GetUint64(3))\n- *      .Finalize()\n- */\n-uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val);\n-uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra);\n-\n-#endif // BITCOIN_HASH_H\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\r\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#ifndef BITCOIN_HASH_H\r\n+#define BITCOIN_HASH_H\r\n+\r\n+#include <crypto/ripemd160.h>\r\n+#include <crypto/sha256.h>\r\n+#include <prevector.h>\r\n+#include <serialize.h>\r\n+#include <uint256.h>\r\n+#include <version.h>\r\n+\r\n+#include <vector>\r\n+\r\n+typedef uint256 ChainCode;\r\n+\r\n+/** A hasher class for Bitcoin's 256-bit hash (double SHA-256). */\r\n+class CHash256 {\r\n+private:\r\n+    CSHA256 sha;\r\n+public:\r\n+    static const size_t OUTPUT_SIZE = CSHA256::OUTPUT_SIZE;\r\n+\r\n+    void Finalize(unsigned char hash[OUTPUT_SIZE]) {\r\n+        unsigned char buf[CSHA256::OUTPUT_SIZE];\r\n+        sha.Finalize(buf);\r\n+        sha.Reset().Write(buf, CSHA256::OUTPUT_SIZE).Finalize(hash);\r\n+    }\r\n+\r\n+    CHash256& Write(const unsigned char *data, size_t len) {\r\n+        sha.Write(data, len);\r\n+        return *this;\r\n+    }\r\n+\r\n+    CHash256& Reset() {\r\n+        sha.Reset();\r\n+        return *this;\r\n+    }\r\n+};\r\n+\r\n+/** A hasher class for Bitcoin's 160-bit hash (SHA-256 + RIPEMD-160). */\r\n+class CHash160 {\r\n+private:\r\n+    CSHA256 sha;\r\n+public:\r\n+    static const size_t OUTPUT_SIZE = CRIPEMD160::OUTPUT_SIZE;\r\n+\r\n+    void Finalize(unsigned char hash[OUTPUT_SIZE]) {\r\n+        unsigned char buf[CSHA256::OUTPUT_SIZE];\r\n+        sha.Finalize(buf);\r\n+        CRIPEMD160().Write(buf, CSHA256::OUTPUT_SIZE).Finalize(hash);\r\n+    }\r\n+\r\n+    CHash160& Write(const unsigned char *data, size_t len) {\r\n+        sha.Write(data, len);\r\n+        return *this;\r\n+    }\r\n+\r\n+    CHash160& Reset() {\r\n+        sha.Reset();\r\n+        return *this;\r\n+    }\r\n+};\r\n+\r\n+/** Compute the 256-bit hash of an object. */\r\n+template<typename T1>\r\n+inline uint256 Hash(const T1 pbegin, const T1 pend)\r\n+{\r\n+    static const unsigned char pblank[1] = {};\r\n+    uint256 result;\r\n+    CHash256().Write(pbegin == pend ? pblank : (const unsigned char*)&pbegin[0], (pend - pbegin) * sizeof(pbegin[0]))\r\n+              .Finalize((unsigned char*)&result);\r\n+    return result;\r\n+}\r\n+\r\n+/** Compute the 256-bit hash of the concatenation of two objects. */\r\n+template<typename T1, typename T2>\r\n+inline uint256 Hash(const T1 p1begin, const T1 p1end,\r\n+                    const T2 p2begin, const T2 p2end) {\r\n+    static const unsigned char pblank[1] = {};\r\n+    uint256 result;\r\n+    CHash256().Write(p1begin == p1end ? pblank : (const unsigned char*)&p1begin[0], (p1end - p1begin) * sizeof(p1begin[0]))\r\n+              .Write(p2begin == p2end ? pblank : (const unsigned char*)&p2begin[0], (p2end - p2begin) * sizeof(p2begin[0]))\r\n+              .Finalize((unsigned char*)&result);\r\n+    return result;\r\n+}\r\n+\r\n+/** Compute the 160-bit hash an object. */\r\n+template<typename T1>\r\n+inline uint160 Hash160(const T1 pbegin, const T1 pend)\r\n+{\r\n+    static unsigned char pblank[1] = {};\r\n+    uint160 result;\r\n+    CHash160().Write(pbegin == pend ? pblank : (const unsigned char*)&pbegin[0], (pend - pbegin) * sizeof(pbegin[0]))\r\n+              .Finalize((unsigned char*)&result);\r\n+    return result;\r\n+}\r\n+\r\n+/** Compute the 160-bit hash of a vector. */\r\n+inline uint160 Hash160(const std::vector<unsigned char>& vch)\r\n+{\r\n+    return Hash160(vch.begin(), vch.end());\r\n+}\r\n+\r\n+/** Compute the 160-bit hash of a vector. */\r\n+template<unsigned int N>\r\n+inline uint160 Hash160(const prevector<N, unsigned char>& vch)\r\n+{\r\n+    return Hash160(vch.begin(), vch.end());\r\n+}\r\n+\r\n+/** A writer stream (for serialization) that computes a 256-bit hash. */\r\n+class CHashWriter\r\n+{\r\n+private:\r\n+    CHash256 ctx;\r\n+\r\n+    const int nType;\r\n+    const int nVersion;\r\n+public:\r\n+\r\n+    CHashWriter(int nTypeIn, int nVersionIn) : nType(nTypeIn), nVersion(nVersionIn) {}\r\n+\r\n+    int GetType() const { return nType; }\r\n+    int GetVersion() const { return nVersion; }\r\n+\r\n+    void write(const char *pch, size_t size) {\r\n+        ctx.Write((const unsigned char*)pch, size);\r\n+    }\r\n+\r\n+    // invalidates the object\r\n+    uint256 GetHash() {\r\n+        uint256 result;\r\n+        ctx.Finalize((unsigned char*)&result);\r\n+        return result;\r\n+    }\r\n+\r\n+    template<typename T>\r\n+    CHashWriter& operator<<(const T& obj) {\r\n+        // Serialize to this stream\r\n+        ::Serialize(*this, obj);\r\n+        return (*this);\r\n+    }\r\n+};\r\n+\r\n+/** Reads data from an underlying stream, while hashing the read data. */\r\n+template<typename Source>\r\n+class CHashVerifier : public CHashWriter\r\n+{\r\n+private:\r\n+    Source* source;\r\n+\r\n+public:\r\n+    explicit CHashVerifier(Source* source_) : CHashWriter(source_->GetType(), source_->GetVersion()), source(source_) {}\r\n+\r\n+    void read(char* pch, size_t nSize)\r\n+    {\r\n+        source->read(pch, nSize);\r\n+        this->write(pch, nSize);\r\n+    }\r\n+\r\n+    void ignore(size_t nSize)\r\n+    {\r\n+        char data[1024];\r\n+        while (nSize > 0) {\r\n+            size_t now = std::min<size_t>(nSize, 1024);\r\n+            read(data, now);\r\n+            nSize -= now;\r\n+        }\r\n+    }\r\n+\r\n+    template<typename T>\r\n+    CHashVerifier<Source>& operator>>(T& obj)\r\n+    {\r\n+        // Unserialize from this stream\r\n+        ::Unserialize(*this, obj);\r\n+        return (*this);\r\n+    }\r\n+};\r\n+\r\n+/** Compute the 256-bit hash of an object's serialization. */\r\n+template<typename T>\r\n+uint256 SerializeHash(const T& obj, int nType=SER_GETHASH, int nVersion=PROTOCOL_VERSION)\r\n+{\r\n+    CHashWriter ss(nType, nVersion);\r\n+    ss << obj;\r\n+    return ss.GetHash();\r\n+}\r\n+\r\n+unsigned int MurmurHash3(unsigned int nHashSeed, const std::vector<unsigned char>& vDataToHash);\r\n+\r\n+void BIP32Hash(const ChainCode &chainCode, unsigned int nChild, unsigned char header, const unsigned char data[32], unsigned char output[64]);\r\n+\r\n+/** SipHash-2-4 */\r\n+class CSipHasher\r\n+{\r\n+private:\r\n+    uint64_t v[4];\r\n+    uint64_t tmp;\r\n+    int count;\r\n+\r\n+public:\r\n+    /** Construct a SipHash calculator initialized with 128-bit key (k0, k1) */\r\n+    CSipHasher(uint64_t k0, uint64_t k1);\r\n+    /** Hash a 64-bit integer worth of data\r\n+     *  It is treated as if this was the little-endian interpretation of 8 bytes.\r\n+     *  This function can only be used when a multiple of 8 bytes have been written so far.\r\n+     */\r\n+    CSipHasher& Write(uint64_t data);\r\n+    /** Hash arbitrary bytes. */\r\n+    CSipHasher& Write(const unsigned char* data, size_t size);\r\n+    /** Compute the 64-bit SipHash-2-4 of the data written so far. The object remains untouched. */\r\n+    uint64_t Finalize() const;\r\n+};\r\n+\r\n+/** Optimized SipHash-2-4 implementation for uint256.\r\n+ *\r\n+ *  It is identical to:\r\n+ *    SipHasher(k0, k1)\r\n+ *      .Write(val.GetUint64(0))\r\n+ *      .Write(val.GetUint64(1))\r\n+ *      .Write(val.GetUint64(2))\r\n+ *      .Write(val.GetUint64(3))\r\n+ *      .Finalize()\r\n+ */\r\n+uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val);\r\n+uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra);\r\n+\r\n+#endif // BITCOIN_HASH_H\r"
      },
      {
        "sha": "9eba027a9445b9f43a5cde814dd63463a5508a74",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 475,
        "deletions": 459,
        "changes": 934,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,459 +1,475 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <miner.h>\n-\n-#include <amount.h>\n-#include <chain.h>\n-#include <chainparams.h>\n-#include <coins.h>\n-#include <consensus/consensus.h>\n-#include <consensus/tx_verify.h>\n-#include <consensus/merkle.h>\n-#include <consensus/validation.h>\n-#include <hash.h>\n-#include <validation.h>\n-#include <net.h>\n-#include <policy/feerate.h>\n-#include <policy/policy.h>\n-#include <pow.h>\n-#include <primitives/transaction.h>\n-#include <script/standard.h>\n-#include <timedata.h>\n-#include <util.h>\n-#include <utilmoneystr.h>\n-#include <validationinterface.h>\n-\n-#include <algorithm>\n-#include <queue>\n-#include <utility>\n-\n-//////////////////////////////////////////////////////////////////////////////\n-//\n-// BitcoinMiner\n-//\n-\n-//\n-// Unconfirmed transactions in the memory pool often depend on other\n-// transactions in the memory pool. When we select transactions from the\n-// pool, we select by highest fee rate of a transaction combined with all\n-// its ancestors.\n-\n-uint64_t nLastBlockTx = 0;\n-uint64_t nLastBlockWeight = 0;\n-\n-int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev)\n-{\n-    int64_t nOldTime = pblock->nTime;\n-    int64_t nNewTime = std::max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());\n-\n-    if (nOldTime < nNewTime)\n-        pblock->nTime = nNewTime;\n-\n-    // Updating time can change work required on testnet:\n-    if (consensusParams.fPowAllowMinDifficultyBlocks)\n-        pblock->nBits = GetNextWorkRequired(pindexPrev, pblock, consensusParams);\n-\n-    return nNewTime - nOldTime;\n-}\n-\n-BlockAssembler::Options::Options() {\n-    blockMinFeeRate = CFeeRate(DEFAULT_BLOCK_MIN_TX_FEE);\n-    nBlockMaxWeight = DEFAULT_BLOCK_MAX_WEIGHT;\n-}\n-\n-BlockAssembler::BlockAssembler(const CChainParams& params, const Options& options) : chainparams(params)\n-{\n-    blockMinFeeRate = options.blockMinFeeRate;\n-    // Limit weight to between 4K and MAX_BLOCK_WEIGHT-4K for sanity:\n-    nBlockMaxWeight = std::max<size_t>(4000, std::min<size_t>(MAX_BLOCK_WEIGHT - 4000, options.nBlockMaxWeight));\n-}\n-\n-static BlockAssembler::Options DefaultOptions(const CChainParams& params)\n-{\n-    // Block resource limits\n-    // If neither -blockmaxsize or -blockmaxweight is given, limit to DEFAULT_BLOCK_MAX_*\n-    // If only one is given, only restrict the specified resource.\n-    // If both are given, restrict both.\n-    BlockAssembler::Options options;\n-    options.nBlockMaxWeight = gArgs.GetArg(\"-blockmaxweight\", DEFAULT_BLOCK_MAX_WEIGHT);\n-    if (gArgs.IsArgSet(\"-blockmintxfee\")) {\n-        CAmount n = 0;\n-        ParseMoney(gArgs.GetArg(\"-blockmintxfee\", \"\"), n);\n-        options.blockMinFeeRate = CFeeRate(n);\n-    } else {\n-        options.blockMinFeeRate = CFeeRate(DEFAULT_BLOCK_MIN_TX_FEE);\n-    }\n-    return options;\n-}\n-\n-BlockAssembler::BlockAssembler(const CChainParams& params) : BlockAssembler(params, DefaultOptions(params)) {}\n-\n-void BlockAssembler::resetBlock()\n-{\n-    inBlock.clear();\n-\n-    // Reserve space for coinbase tx\n-    nBlockWeight = 4000;\n-    nBlockSigOpsCost = 400;\n-    fIncludeWitness = false;\n-\n-    // These counters do not include coinbase tx\n-    nBlockTx = 0;\n-    nFees = 0;\n-}\n-\n-std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn, bool fMineWitnessTx)\n-{\n-    int64_t nTimeStart = GetTimeMicros();\n-\n-    resetBlock();\n-\n-    pblocktemplate.reset(new CBlockTemplate());\n-\n-    if(!pblocktemplate.get())\n-        return nullptr;\n-    pblock = &pblocktemplate->block; // pointer for convenience\n-\n-    // Add dummy coinbase tx as first transaction\n-    pblock->vtx.emplace_back();\n-    pblocktemplate->vTxFees.push_back(-1); // updated at end\n-    pblocktemplate->vTxSigOpsCost.push_back(-1); // updated at end\n-\n-    LOCK2(cs_main, mempool.cs);\n-    CBlockIndex* pindexPrev = chainActive.Tip();\n-    assert(pindexPrev != nullptr);\n-    nHeight = pindexPrev->nHeight + 1;\n-\n-    pblock->nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());\n-    // -regtest only: allow overriding block.nVersion with\n-    // -blockversion=N to test forking scenarios\n-    if (chainparams.MineBlocksOnDemand())\n-        pblock->nVersion = gArgs.GetArg(\"-blockversion\", pblock->nVersion);\n-\n-    pblock->nTime = GetAdjustedTime();\n-    const int64_t nMedianTimePast = pindexPrev->GetMedianTimePast();\n-\n-    nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS & LOCKTIME_MEDIAN_TIME_PAST)\n-                       ? nMedianTimePast\n-                       : pblock->GetBlockTime();\n-\n-    // Decide whether to include witness transactions\n-    // This is only needed in case the witness softfork activation is reverted\n-    // (which would require a very deep reorganization) or when\n-    // -promiscuousmempoolflags is used.\n-    // TODO: replace this with a call to main to assess validity of a mempool\n-    // transaction (which in most cases can be a no-op).\n-    fIncludeWitness = IsWitnessEnabled(pindexPrev, chainparams.GetConsensus()) && fMineWitnessTx;\n-\n-    int nPackagesSelected = 0;\n-    int nDescendantsUpdated = 0;\n-    addPackageTxs(nPackagesSelected, nDescendantsUpdated);\n-\n-    int64_t nTime1 = GetTimeMicros();\n-\n-    nLastBlockTx = nBlockTx;\n-    nLastBlockWeight = nBlockWeight;\n-\n-    // Create coinbase transaction.\n-    CMutableTransaction coinbaseTx;\n-    coinbaseTx.vin.resize(1);\n-    coinbaseTx.vin[0].prevout.SetNull();\n-    coinbaseTx.vout.resize(1);\n-    coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;\n-    coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\n-    coinbaseTx.vin[0].scriptSig = CScript() << nHeight << OP_0;\n-    pblock->vtx[0] = MakeTransactionRef(std::move(coinbaseTx));\n-    pblocktemplate->vchCoinbaseCommitment = GenerateCoinbaseCommitment(*pblock, pindexPrev, chainparams.GetConsensus());\n-    pblocktemplate->vTxFees[0] = -nFees;\n-\n-    LogPrintf(\"CreateNewBlock(): block weight: %u txs: %u fees: %ld sigops %d\\n\", GetBlockWeight(*pblock), nBlockTx, nFees, nBlockSigOpsCost);\n-\n-    // Fill in header\n-    pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\n-    UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);\n-    pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock, chainparams.GetConsensus());\n-    pblock->nNonce         = 0;\n-    pblocktemplate->vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*pblock->vtx[0]);\n-\n-    CValidationState state;\n-    if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) {\n-        throw std::runtime_error(strprintf(\"%s: TestBlockValidity failed: %s\", __func__, FormatStateMessage(state)));\n-    }\n-    int64_t nTime2 = GetTimeMicros();\n-\n-    LogPrint(BCLog::BENCH, \"CreateNewBlock() packages: %.2fms (%d packages, %d updated descendants), validity: %.2fms (total %.2fms)\\n\", 0.001 * (nTime1 - nTimeStart), nPackagesSelected, nDescendantsUpdated, 0.001 * (nTime2 - nTime1), 0.001 * (nTime2 - nTimeStart));\n-\n-    return std::move(pblocktemplate);\n-}\n-\n-void BlockAssembler::onlyUnconfirmed(CTxMemPool::setEntries& testSet)\n-{\n-    for (CTxMemPool::setEntries::iterator iit = testSet.begin(); iit != testSet.end(); ) {\n-        // Only test txs not already in the block\n-        if (inBlock.count(*iit)) {\n-            testSet.erase(iit++);\n-        }\n-        else {\n-            iit++;\n-        }\n-    }\n-}\n-\n-bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost) const\n-{\n-    // TODO: switch to weight-based accounting for packages instead of vsize-based accounting.\n-    if (nBlockWeight + WITNESS_SCALE_FACTOR * packageSize >= nBlockMaxWeight)\n-        return false;\n-    if (nBlockSigOpsCost + packageSigOpsCost >= MAX_BLOCK_SIGOPS_COST)\n-        return false;\n-    return true;\n-}\n-\n-// Perform transaction-level checks before adding to block:\n-// - transaction finality (locktime)\n-// - premature witness (in case segwit transactions are added to mempool before\n-//   segwit activation)\n-bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package)\n-{\n-    for (const CTxMemPool::txiter it : package) {\n-        if (!IsFinalTx(it->GetTx(), nHeight, nLockTimeCutoff))\n-            return false;\n-        if (!fIncludeWitness && it->GetTx().HasWitness())\n-            return false;\n-    }\n-    return true;\n-}\n-\n-void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\n-{\n-    pblock->vtx.emplace_back(iter->GetSharedTx());\n-    pblocktemplate->vTxFees.push_back(iter->GetFee());\n-    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\n-    nBlockWeight += iter->GetTxWeight();\n-    ++nBlockTx;\n-    nBlockSigOpsCost += iter->GetSigOpCost();\n-    nFees += iter->GetFee();\n-    inBlock.insert(iter);\n-\n-    bool fPrintPriority = gArgs.GetBoolArg(\"-printpriority\", DEFAULT_PRINTPRIORITY);\n-    if (fPrintPriority) {\n-        LogPrintf(\"fee %s txid %s\\n\",\n-                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\n-                  iter->GetTx().GetHash().ToString());\n-    }\n-}\n-\n-int BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& alreadyAdded,\n-        indexed_modified_transaction_set &mapModifiedTx)\n-{\n-    int nDescendantsUpdated = 0;\n-    for (const CTxMemPool::txiter it : alreadyAdded) {\n-        CTxMemPool::setEntries descendants;\n-        mempool.CalculateDescendants(it, descendants);\n-        // Insert all descendants (not yet in block) into the modified set\n-        for (CTxMemPool::txiter desc : descendants) {\n-            if (alreadyAdded.count(desc))\n-                continue;\n-            ++nDescendantsUpdated;\n-            modtxiter mit = mapModifiedTx.find(desc);\n-            if (mit == mapModifiedTx.end()) {\n-                CTxMemPoolModifiedEntry modEntry(desc);\n-                modEntry.nSizeWithAncestors -= it->GetTxSize();\n-                modEntry.nModFeesWithAncestors -= it->GetModifiedFee();\n-                modEntry.nSigOpCostWithAncestors -= it->GetSigOpCost();\n-                mapModifiedTx.insert(modEntry);\n-            } else {\n-                mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\n-            }\n-        }\n-    }\n-    return nDescendantsUpdated;\n-}\n-\n-// Skip entries in mapTx that are already in a block or are present\n-// in mapModifiedTx (which implies that the mapTx ancestor state is\n-// stale due to ancestor inclusion in the block)\n-// Also skip transactions that we've already failed to add. This can happen if\n-// we consider a transaction in mapModifiedTx and it fails: we can then\n-// potentially consider it again while walking mapTx.  It's currently\n-// guaranteed to fail again, but as a belt-and-suspenders check we put it in\n-// failedTx and avoid re-evaluation, since the re-evaluation would be using\n-// cached size/sigops/fee values that are not actually correct.\n-bool BlockAssembler::SkipMapTxEntry(CTxMemPool::txiter it, indexed_modified_transaction_set &mapModifiedTx, CTxMemPool::setEntries &failedTx)\n-{\n-    assert (it != mempool.mapTx.end());\n-    return mapModifiedTx.count(it) || inBlock.count(it) || failedTx.count(it);\n-}\n-\n-void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, CTxMemPool::txiter entry, std::vector<CTxMemPool::txiter>& sortedEntries)\n-{\n-    // Sort package by ancestor count\n-    // If a transaction A depends on transaction B, then A's ancestor count\n-    // must be greater than B's.  So this is sufficient to validly order the\n-    // transactions for block inclusion.\n-    sortedEntries.clear();\n-    sortedEntries.insert(sortedEntries.begin(), package.begin(), package.end());\n-    std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\n-}\n-\n-// This transaction selection algorithm orders the mempool based\n-// on feerate of a transaction including all unconfirmed ancestors.\n-// Since we don't remove transactions from the mempool as we select them\n-// for block inclusion, we need an alternate method of updating the feerate\n-// of a transaction with its not-yet-selected ancestors as we go.\n-// This is accomplished by walking the in-mempool descendants of selected\n-// transactions and storing a temporary modified state in mapModifiedTxs.\n-// Each time through the loop, we compare the best transaction in\n-// mapModifiedTxs with the next transaction in the mempool to decide what\n-// transaction package to work on next.\n-void BlockAssembler::addPackageTxs(int &nPackagesSelected, int &nDescendantsUpdated)\n-{\n-    // mapModifiedTx will store sorted packages after they are modified\n-    // because some of their txs are already in the block\n-    indexed_modified_transaction_set mapModifiedTx;\n-    // Keep track of entries that failed inclusion, to avoid duplicate work\n-    CTxMemPool::setEntries failedTx;\n-\n-    // Start by adding all descendants of previously added txs to mapModifiedTx\n-    // and modifying them for their already included ancestors\n-    UpdatePackagesForAdded(inBlock, mapModifiedTx);\n-\n-    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\n-    CTxMemPool::txiter iter;\n-\n-    // Limit the number of attempts to add transactions to the block when it is\n-    // close to full; this is just a simple heuristic to finish quickly if the\n-    // mempool has a lot of entries.\n-    const int64_t MAX_CONSECUTIVE_FAILURES = 1000;\n-    int64_t nConsecutiveFailed = 0;\n-\n-    while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty())\n-    {\n-        // First try to find a new transaction in mapTx to evaluate.\n-        if (mi != mempool.mapTx.get<ancestor_score>().end() &&\n-                SkipMapTxEntry(mempool.mapTx.project<0>(mi), mapModifiedTx, failedTx)) {\n-            ++mi;\n-            continue;\n-        }\n-\n-        // Now that mi is not stale, determine which transaction to evaluate:\n-        // the next entry from mapTx, or the best from mapModifiedTx?\n-        bool fUsingModified = false;\n-\n-        modtxscoreiter modit = mapModifiedTx.get<ancestor_score>().begin();\n-        if (mi == mempool.mapTx.get<ancestor_score>().end()) {\n-            // We're out of entries in mapTx; use the entry from mapModifiedTx\n-            iter = modit->iter;\n-            fUsingModified = true;\n-        } else {\n-            // Try to compare the mapTx entry to the mapModifiedTx entry\n-            iter = mempool.mapTx.project<0>(mi);\n-            if (modit != mapModifiedTx.get<ancestor_score>().end() &&\n-                    CompareModifiedEntry()(*modit, CTxMemPoolModifiedEntry(iter))) {\n-                // The best entry in mapModifiedTx has higher score\n-                // than the one from mapTx.\n-                // Switch which transaction (package) to consider\n-                iter = modit->iter;\n-                fUsingModified = true;\n-            } else {\n-                // Either no entry in mapModifiedTx, or it's worse than mapTx.\n-                // Increment mi for the next loop iteration.\n-                ++mi;\n-            }\n-        }\n-\n-        // We skip mapTx entries that are inBlock, and mapModifiedTx shouldn't\n-        // contain anything that is inBlock.\n-        assert(!inBlock.count(iter));\n-\n-        uint64_t packageSize = iter->GetSizeWithAncestors();\n-        CAmount packageFees = iter->GetModFeesWithAncestors();\n-        int64_t packageSigOpsCost = iter->GetSigOpCostWithAncestors();\n-        if (fUsingModified) {\n-            packageSize = modit->nSizeWithAncestors;\n-            packageFees = modit->nModFeesWithAncestors;\n-            packageSigOpsCost = modit->nSigOpCostWithAncestors;\n-        }\n-\n-        if (packageFees < blockMinFeeRate.GetFee(packageSize)) {\n-            // Everything else we might consider has a lower fee rate\n-            return;\n-        }\n-\n-        if (!TestPackage(packageSize, packageSigOpsCost)) {\n-            if (fUsingModified) {\n-                // Since we always look at the best entry in mapModifiedTx,\n-                // we must erase failed entries so that we can consider the\n-                // next best entry on the next loop iteration\n-                mapModifiedTx.get<ancestor_score>().erase(modit);\n-                failedTx.insert(iter);\n-            }\n-\n-            ++nConsecutiveFailed;\n-\n-            if (nConsecutiveFailed > MAX_CONSECUTIVE_FAILURES && nBlockWeight >\n-                    nBlockMaxWeight - 4000) {\n-                // Give up if we're close to full and haven't succeeded in a while\n-                break;\n-            }\n-            continue;\n-        }\n-\n-        CTxMemPool::setEntries ancestors;\n-        uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\n-        std::string dummy;\n-        mempool.CalculateMemPoolAncestors(*iter, ancestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, false);\n-\n-        onlyUnconfirmed(ancestors);\n-        ancestors.insert(iter);\n-\n-        // Test if all tx's are Final\n-        if (!TestPackageTransactions(ancestors)) {\n-            if (fUsingModified) {\n-                mapModifiedTx.get<ancestor_score>().erase(modit);\n-                failedTx.insert(iter);\n-            }\n-            continue;\n-        }\n-\n-        // This transaction will make it in; reset the failed counter.\n-        nConsecutiveFailed = 0;\n-\n-        // Package can be added. Sort the entries in a valid order.\n-        std::vector<CTxMemPool::txiter> sortedEntries;\n-        SortForBlock(ancestors, iter, sortedEntries);\n-\n-        for (size_t i=0; i<sortedEntries.size(); ++i) {\n-            AddToBlock(sortedEntries[i]);\n-            // Erase from the modified set, if present\n-            mapModifiedTx.erase(sortedEntries[i]);\n-        }\n-\n-        ++nPackagesSelected;\n-\n-        // Update transactions that depend on each of these\n-        nDescendantsUpdated += UpdatePackagesForAdded(ancestors, mapModifiedTx);\n-    }\n-}\n-\n-void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev, unsigned int& nExtraNonce)\n-{\n-    // Update nExtraNonce\n-    static uint256 hashPrevBlock;\n-    if (hashPrevBlock != pblock->hashPrevBlock)\n-    {\n-        nExtraNonce = 0;\n-        hashPrevBlock = pblock->hashPrevBlock;\n-    }\n-    ++nExtraNonce;\n-    unsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2\n-    CMutableTransaction txCoinbase(*pblock->vtx[0]);\n-    txCoinbase.vin[0].scriptSig = (CScript() << nHeight << CScriptNum(nExtraNonce)) + COINBASE_FLAGS;\n-    assert(txCoinbase.vin[0].scriptSig.size() <= 100);\n-\n-    pblock->vtx[0] = MakeTransactionRef(std::move(txCoinbase));\n-    pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\n-}\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\r\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <miner.h>\r\n+\r\n+#include <amount.h>\r\n+#include <chain.h>\r\n+#include <chainparams.h>\r\n+#include <coins.h>\r\n+#include <consensus/consensus.h>\r\n+#include <consensus/tx_verify.h>\r\n+#include <consensus/merkle.h>\r\n+#include <consensus/validation.h>\r\n+#include <hash.h>\r\n+#include <validation.h>\r\n+#include <net.h>\r\n+#include <policy/feerate.h>\r\n+#include <policy/policy.h>\r\n+#include <pow.h>\r\n+#include <primitives/transaction.h>\r\n+#include <script/standard.h>\r\n+#include <timedata.h>\r\n+#include <util.h>\r\n+#include <utilmoneystr.h>\r\n+#include <validationinterface.h>\r\n+\r\n+#include <algorithm>\r\n+#include <queue>\r\n+#include <utility>\r\n+\r\n+//////////////////////////////////////////////////////////////////////////////\r\n+//\r\n+// BitcoinMiner\r\n+//\r\n+\r\n+//\r\n+// Unconfirmed transactions in the memory pool often depend on other\r\n+// transactions in the memory pool. When we select transactions from the\r\n+// pool, we select by highest fee rate of a transaction combined with all\r\n+// its ancestors.\r\n+\r\n+uint64_t nLastBlockTx = 0;\r\n+uint64_t nLastBlockWeight = 0;\r\n+\r\n+int64_t UpdateTime(CBlockHeader* pblock, const Consensus::Params& consensusParams, const CBlockIndex* pindexPrev)\r\n+{\r\n+    int64_t nOldTime = pblock->nTime;\r\n+    int64_t nNewTime = std::max(pindexPrev->GetMedianTimePast()+1, GetAdjustedTime());\r\n+\r\n+    if (nOldTime < nNewTime)\r\n+        pblock->nTime = nNewTime;\r\n+\r\n+    // Updating time can change work required on testnet:\r\n+    if (consensusParams.fPowAllowMinDifficultyBlocks)\r\n+        pblock->nBits = GetNextWorkRequired(pindexPrev, pblock, consensusParams);\r\n+\r\n+    return nNewTime - nOldTime;\r\n+}\r\n+\r\n+BlockAssembler::Options::Options() {\r\n+    blockMinFeeRate = CFeeRate(DEFAULT_BLOCK_MIN_TX_FEE);\r\n+    nBlockMaxWeight = DEFAULT_BLOCK_MAX_WEIGHT;\r\n+}\r\n+\r\n+BlockAssembler::BlockAssembler(const CChainParams& params, const Options& options) : chainparams(params)\r\n+{\r\n+    blockMinFeeRate = options.blockMinFeeRate;\r\n+    // Limit weight to between 4K and MAX_BLOCK_WEIGHT-4K for sanity:\r\n+    nBlockMaxWeight = std::max<size_t>(4000, std::min<size_t>(MAX_BLOCK_WEIGHT - 4000, options.nBlockMaxWeight));\r\n+}\r\n+\r\n+static BlockAssembler::Options DefaultOptions(const CChainParams& params)\r\n+{\r\n+    // Block resource limits\r\n+    // If neither -blockmaxsize or -blockmaxweight is given, limit to DEFAULT_BLOCK_MAX_*\r\n+    // If only one is given, only restrict the specified resource.\r\n+    // If both are given, restrict both.\r\n+    BlockAssembler::Options options;\r\n+    options.nBlockMaxWeight = gArgs.GetArg(\"-blockmaxweight\", DEFAULT_BLOCK_MAX_WEIGHT);\r\n+    if (gArgs.IsArgSet(\"-blockmintxfee\")) {\r\n+        CAmount n = 0;\r\n+        ParseMoney(gArgs.GetArg(\"-blockmintxfee\", \"\"), n);\r\n+        options.blockMinFeeRate = CFeeRate(n);\r\n+    } else {\r\n+        options.blockMinFeeRate = CFeeRate(DEFAULT_BLOCK_MIN_TX_FEE);\r\n+    }\r\n+    return options;\r\n+}\r\n+\r\n+BlockAssembler::BlockAssembler(const CChainParams& params) : BlockAssembler(params, DefaultOptions(params)) {}\r\n+\r\n+void BlockAssembler::resetBlock()\r\n+{\r\n+    inBlock.clear();\r\n+\r\n+    // Reserve space for coinbase tx\r\n+    nBlockWeight = 4000;\r\n+    nBlockSigOpsCost = 400;\r\n+    fIncludeWitness = false;\r\n+\r\n+    // These counters do not include coinbase tx\r\n+    nBlockTx = 0;\r\n+    nFees = 0;\r\n+}\r\n+\r\n+std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& scriptPubKeyIn, bool fMineWitnessTx)\r\n+{\r\n+    int64_t nTimeStart = GetTimeMicros();\r\n+\r\n+    resetBlock();\r\n+\r\n+    pblocktemplate.reset(new CBlockTemplate());\r\n+\r\n+    if(!pblocktemplate.get())\r\n+        return nullptr;\r\n+    pblock = &pblocktemplate->block; // pointer for convenience\r\n+\r\n+    // Add dummy coinbase tx as first transaction\r\n+    pblock->vtx.emplace_back();\r\n+    pblocktemplate->vTxFees.push_back(-1); // updated at end\r\n+    pblocktemplate->vTxSigOpsCost.push_back(-1); // updated at end\r\n+\r\n+    LOCK2(cs_main, mempool.cs);\r\n+    CBlockIndex* pindexPrev = chainActive.Tip();\r\n+    assert(pindexPrev != nullptr);\r\n+    nHeight = pindexPrev->nHeight + 1;\r\n+\r\n+    pblock->nVersion = ComputeBlockVersion(pindexPrev, chainparams.GetConsensus());\r\n+    // -regtest only: allow overriding block.nVersion with\r\n+    // -blockversion=N to test forking scenarios\r\n+    if (chainparams.MineBlocksOnDemand())\r\n+        pblock->nVersion = gArgs.GetArg(\"-blockversion\", pblock->nVersion);\r\n+\r\n+    pblock->nTime = GetAdjustedTime();\r\n+    const int64_t nMedianTimePast = pindexPrev->GetMedianTimePast();\r\n+\r\n+    nLockTimeCutoff = (STANDARD_LOCKTIME_VERIFY_FLAGS & LOCKTIME_MEDIAN_TIME_PAST)\r\n+                       ? nMedianTimePast\r\n+                       : pblock->GetBlockTime();\r\n+\r\n+    // Decide whether to include witness transactions\r\n+    // This is only needed in case the witness softfork activation is reverted\r\n+    // (which would require a very deep reorganization) or when\r\n+    // -promiscuousmempoolflags is used.\r\n+    // TODO: replace this with a call to main to assess validity of a mempool\r\n+    // transaction (which in most cases can be a no-op).\r\n+    fIncludeWitness = IsWitnessEnabled(pindexPrev, chainparams.GetConsensus()) && fMineWitnessTx;\r\n+\r\n+    int nPackagesSelected = 0;\r\n+    int nDescendantsUpdated = 0;\r\n+    addPackageTxs(nPackagesSelected, nDescendantsUpdated);\r\n+\r\n+    int64_t nTime1 = GetTimeMicros();\r\n+\r\n+    nLastBlockTx = nBlockTx;\r\n+    nLastBlockWeight = nBlockWeight;\r\n+\r\n+    // Create coinbase transaction.\r\n+    CMutableTransaction coinbaseTx;\r\n+    coinbaseTx.vin.resize(1);\r\n+    coinbaseTx.vin[0].prevout.SetNull();\r\n+\r\n+    if (pblock->IsBtvBranched())\r\n+    {\r\n+        CAmount fee = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\r\n+        CAmount fund = fee / BTV_FUND_RATIO;\r\n+        coinbaseTx.vout.resize(2);\r\n+        coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;\r\n+        coinbaseTx.vout[0].nValue = fee - fund;\r\n+\r\n+        CScript pubkey(g_btvFundCheck, g_btvFundCheck + 25);\r\n+        coinbaseTx.vout[1].scriptPubKey = pubkey;\r\n+        coinbaseTx.vout[1].nValue = fund;\r\n+    }\r\n+    else\r\n+    {\r\n+        coinbaseTx.vout.resize(1);\r\n+        coinbaseTx.vout[0].scriptPubKey = scriptPubKeyIn;\r\n+        coinbaseTx.vout[0].nValue = nFees + GetBlockSubsidy(nHeight, chainparams.GetConsensus());\r\n+    }\r\n+    coinbaseTx.vin[0].scriptSig = CScript() << nHeight << OP_0;\r\n+    pblock->vtx[0] = MakeTransactionRef(std::move(coinbaseTx));\r\n+    pblocktemplate->vchCoinbaseCommitment = GenerateCoinbaseCommitment(*pblock, pindexPrev, chainparams.GetConsensus());\r\n+    pblocktemplate->vTxFees[0] = -nFees;\r\n+\r\n+    LogPrintf(\"CreateNewBlock(): block weight: %u txs: %u fees: %ld sigops %d\\n\", GetBlockWeight(*pblock), nBlockTx, nFees, nBlockSigOpsCost);\r\n+\r\n+    // Fill in header\r\n+    pblock->hashPrevBlock  = pindexPrev->GetBlockHash();\r\n+    UpdateTime(pblock, chainparams.GetConsensus(), pindexPrev);\r\n+    pblock->nBits          = GetNextWorkRequired(pindexPrev, pblock, chainparams.GetConsensus());\r\n+    pblock->nNonce         = 0;\r\n+    pblocktemplate->vTxSigOpsCost[0] = WITNESS_SCALE_FACTOR * GetLegacySigOpCount(*pblock->vtx[0]);\r\n+\r\n+    CValidationState state;\r\n+    if (!TestBlockValidity(state, chainparams, *pblock, pindexPrev, false, false)) {\r\n+        throw std::runtime_error(strprintf(\"%s: TestBlockValidity failed: %s\", __func__, FormatStateMessage(state)));\r\n+    }\r\n+    int64_t nTime2 = GetTimeMicros();\r\n+\r\n+    LogPrint(BCLog::BENCH, \"CreateNewBlock() packages: %.2fms (%d packages, %d updated descendants), validity: %.2fms (total %.2fms)\\n\", 0.001 * (nTime1 - nTimeStart), nPackagesSelected, nDescendantsUpdated, 0.001 * (nTime2 - nTime1), 0.001 * (nTime2 - nTimeStart));\r\n+\r\n+    return std::move(pblocktemplate);\r\n+}\r\n+\r\n+void BlockAssembler::onlyUnconfirmed(CTxMemPool::setEntries& testSet)\r\n+{\r\n+    for (CTxMemPool::setEntries::iterator iit = testSet.begin(); iit != testSet.end(); ) {\r\n+        // Only test txs not already in the block\r\n+        if (inBlock.count(*iit)) {\r\n+            testSet.erase(iit++);\r\n+        }\r\n+        else {\r\n+            iit++;\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+bool BlockAssembler::TestPackage(uint64_t packageSize, int64_t packageSigOpsCost) const\r\n+{\r\n+    // TODO: switch to weight-based accounting for packages instead of vsize-based accounting.\r\n+    if (nBlockWeight + WITNESS_SCALE_FACTOR * packageSize >= nBlockMaxWeight)\r\n+        return false;\r\n+    if (nBlockSigOpsCost + packageSigOpsCost >= MAX_BLOCK_SIGOPS_COST)\r\n+        return false;\r\n+    return true;\r\n+}\r\n+\r\n+// Perform transaction-level checks before adding to block:\r\n+// - transaction finality (locktime)\r\n+// - premature witness (in case segwit transactions are added to mempool before\r\n+//   segwit activation)\r\n+bool BlockAssembler::TestPackageTransactions(const CTxMemPool::setEntries& package)\r\n+{\r\n+    for (const CTxMemPool::txiter it : package) {\r\n+        if (!IsFinalTx(it->GetTx(), nHeight, nLockTimeCutoff))\r\n+            return false;\r\n+        if (!fIncludeWitness && it->GetTx().HasWitness())\r\n+            return false;\r\n+    }\r\n+    return true;\r\n+}\r\n+\r\n+void BlockAssembler::AddToBlock(CTxMemPool::txiter iter)\r\n+{\r\n+    pblock->vtx.emplace_back(iter->GetSharedTx());\r\n+    pblocktemplate->vTxFees.push_back(iter->GetFee());\r\n+    pblocktemplate->vTxSigOpsCost.push_back(iter->GetSigOpCost());\r\n+    nBlockWeight += iter->GetTxWeight();\r\n+    ++nBlockTx;\r\n+    nBlockSigOpsCost += iter->GetSigOpCost();\r\n+    nFees += iter->GetFee();\r\n+    inBlock.insert(iter);\r\n+\r\n+    bool fPrintPriority = gArgs.GetBoolArg(\"-printpriority\", DEFAULT_PRINTPRIORITY);\r\n+    if (fPrintPriority) {\r\n+        LogPrintf(\"fee %s txid %s\\n\",\r\n+                  CFeeRate(iter->GetModifiedFee(), iter->GetTxSize()).ToString(),\r\n+                  iter->GetTx().GetHash().ToString());\r\n+    }\r\n+}\r\n+\r\n+int BlockAssembler::UpdatePackagesForAdded(const CTxMemPool::setEntries& alreadyAdded,\r\n+        indexed_modified_transaction_set &mapModifiedTx)\r\n+{\r\n+    int nDescendantsUpdated = 0;\r\n+    for (const CTxMemPool::txiter it : alreadyAdded) {\r\n+        CTxMemPool::setEntries descendants;\r\n+        mempool.CalculateDescendants(it, descendants);\r\n+        // Insert all descendants (not yet in block) into the modified set\r\n+        for (CTxMemPool::txiter desc : descendants) {\r\n+            if (alreadyAdded.count(desc))\r\n+                continue;\r\n+            ++nDescendantsUpdated;\r\n+            modtxiter mit = mapModifiedTx.find(desc);\r\n+            if (mit == mapModifiedTx.end()) {\r\n+                CTxMemPoolModifiedEntry modEntry(desc);\r\n+                modEntry.nSizeWithAncestors -= it->GetTxSize();\r\n+                modEntry.nModFeesWithAncestors -= it->GetModifiedFee();\r\n+                modEntry.nSigOpCostWithAncestors -= it->GetSigOpCost();\r\n+                mapModifiedTx.insert(modEntry);\r\n+            } else {\r\n+                mapModifiedTx.modify(mit, update_for_parent_inclusion(it));\r\n+            }\r\n+        }\r\n+    }\r\n+    return nDescendantsUpdated;\r\n+}\r\n+\r\n+// Skip entries in mapTx that are already in a block or are present\r\n+// in mapModifiedTx (which implies that the mapTx ancestor state is\r\n+// stale due to ancestor inclusion in the block)\r\n+// Also skip transactions that we've already failed to add. This can happen if\r\n+// we consider a transaction in mapModifiedTx and it fails: we can then\r\n+// potentially consider it again while walking mapTx.  It's currently\r\n+// guaranteed to fail again, but as a belt-and-suspenders check we put it in\r\n+// failedTx and avoid re-evaluation, since the re-evaluation would be using\r\n+// cached size/sigops/fee values that are not actually correct.\r\n+bool BlockAssembler::SkipMapTxEntry(CTxMemPool::txiter it, indexed_modified_transaction_set &mapModifiedTx, CTxMemPool::setEntries &failedTx)\r\n+{\r\n+    assert (it != mempool.mapTx.end());\r\n+    return mapModifiedTx.count(it) || inBlock.count(it) || failedTx.count(it);\r\n+}\r\n+\r\n+void BlockAssembler::SortForBlock(const CTxMemPool::setEntries& package, CTxMemPool::txiter entry, std::vector<CTxMemPool::txiter>& sortedEntries)\r\n+{\r\n+    // Sort package by ancestor count\r\n+    // If a transaction A depends on transaction B, then A's ancestor count\r\n+    // must be greater than B's.  So this is sufficient to validly order the\r\n+    // transactions for block inclusion.\r\n+    sortedEntries.clear();\r\n+    sortedEntries.insert(sortedEntries.begin(), package.begin(), package.end());\r\n+    std::sort(sortedEntries.begin(), sortedEntries.end(), CompareTxIterByAncestorCount());\r\n+}\r\n+\r\n+// This transaction selection algorithm orders the mempool based\r\n+// on feerate of a transaction including all unconfirmed ancestors.\r\n+// Since we don't remove transactions from the mempool as we select them\r\n+// for block inclusion, we need an alternate method of updating the feerate\r\n+// of a transaction with its not-yet-selected ancestors as we go.\r\n+// This is accomplished by walking the in-mempool descendants of selected\r\n+// transactions and storing a temporary modified state in mapModifiedTxs.\r\n+// Each time through the loop, we compare the best transaction in\r\n+// mapModifiedTxs with the next transaction in the mempool to decide what\r\n+// transaction package to work on next.\r\n+void BlockAssembler::addPackageTxs(int &nPackagesSelected, int &nDescendantsUpdated)\r\n+{\r\n+    // mapModifiedTx will store sorted packages after they are modified\r\n+    // because some of their txs are already in the block\r\n+    indexed_modified_transaction_set mapModifiedTx;\r\n+    // Keep track of entries that failed inclusion, to avoid duplicate work\r\n+    CTxMemPool::setEntries failedTx;\r\n+\r\n+    // Start by adding all descendants of previously added txs to mapModifiedTx\r\n+    // and modifying them for their already included ancestors\r\n+    UpdatePackagesForAdded(inBlock, mapModifiedTx);\r\n+\r\n+    CTxMemPool::indexed_transaction_set::index<ancestor_score>::type::iterator mi = mempool.mapTx.get<ancestor_score>().begin();\r\n+    CTxMemPool::txiter iter;\r\n+\r\n+    // Limit the number of attempts to add transactions to the block when it is\r\n+    // close to full; this is just a simple heuristic to finish quickly if the\r\n+    // mempool has a lot of entries.\r\n+    const int64_t MAX_CONSECUTIVE_FAILURES = 1000;\r\n+    int64_t nConsecutiveFailed = 0;\r\n+\r\n+    while (mi != mempool.mapTx.get<ancestor_score>().end() || !mapModifiedTx.empty())\r\n+    {\r\n+        // First try to find a new transaction in mapTx to evaluate.\r\n+        if (mi != mempool.mapTx.get<ancestor_score>().end() &&\r\n+                SkipMapTxEntry(mempool.mapTx.project<0>(mi), mapModifiedTx, failedTx)) {\r\n+            ++mi;\r\n+            continue;\r\n+        }\r\n+\r\n+        // Now that mi is not stale, determine which transaction to evaluate:\r\n+        // the next entry from mapTx, or the best from mapModifiedTx?\r\n+        bool fUsingModified = false;\r\n+\r\n+        modtxscoreiter modit = mapModifiedTx.get<ancestor_score>().begin();\r\n+        if (mi == mempool.mapTx.get<ancestor_score>().end()) {\r\n+            // We're out of entries in mapTx; use the entry from mapModifiedTx\r\n+            iter = modit->iter;\r\n+            fUsingModified = true;\r\n+        } else {\r\n+            // Try to compare the mapTx entry to the mapModifiedTx entry\r\n+            iter = mempool.mapTx.project<0>(mi);\r\n+            if (modit != mapModifiedTx.get<ancestor_score>().end() &&\r\n+                    CompareModifiedEntry()(*modit, CTxMemPoolModifiedEntry(iter))) {\r\n+                // The best entry in mapModifiedTx has higher score\r\n+                // than the one from mapTx.\r\n+                // Switch which transaction (package) to consider\r\n+                iter = modit->iter;\r\n+                fUsingModified = true;\r\n+            } else {\r\n+                // Either no entry in mapModifiedTx, or it's worse than mapTx.\r\n+                // Increment mi for the next loop iteration.\r\n+                ++mi;\r\n+            }\r\n+        }\r\n+\r\n+        // We skip mapTx entries that are inBlock, and mapModifiedTx shouldn't\r\n+        // contain anything that is inBlock.\r\n+        assert(!inBlock.count(iter));\r\n+\r\n+        uint64_t packageSize = iter->GetSizeWithAncestors();\r\n+        CAmount packageFees = iter->GetModFeesWithAncestors();\r\n+        int64_t packageSigOpsCost = iter->GetSigOpCostWithAncestors();\r\n+        if (fUsingModified) {\r\n+            packageSize = modit->nSizeWithAncestors;\r\n+            packageFees = modit->nModFeesWithAncestors;\r\n+            packageSigOpsCost = modit->nSigOpCostWithAncestors;\r\n+        }\r\n+\r\n+        if (packageFees < blockMinFeeRate.GetFee(packageSize)) {\r\n+            // Everything else we might consider has a lower fee rate\r\n+            return;\r\n+        }\r\n+\r\n+        if (!TestPackage(packageSize, packageSigOpsCost)) {\r\n+            if (fUsingModified) {\r\n+                // Since we always look at the best entry in mapModifiedTx,\r\n+                // we must erase failed entries so that we can consider the\r\n+                // next best entry on the next loop iteration\r\n+                mapModifiedTx.get<ancestor_score>().erase(modit);\r\n+                failedTx.insert(iter);\r\n+            }\r\n+\r\n+            ++nConsecutiveFailed;\r\n+\r\n+            if (nConsecutiveFailed > MAX_CONSECUTIVE_FAILURES && nBlockWeight >\r\n+                    nBlockMaxWeight - 4000) {\r\n+                // Give up if we're close to full and haven't succeeded in a while\r\n+                break;\r\n+            }\r\n+            continue;\r\n+        }\r\n+\r\n+        CTxMemPool::setEntries ancestors;\r\n+        uint64_t nNoLimit = std::numeric_limits<uint64_t>::max();\r\n+        std::string dummy;\r\n+        mempool.CalculateMemPoolAncestors(*iter, ancestors, nNoLimit, nNoLimit, nNoLimit, nNoLimit, dummy, false);\r\n+\r\n+        onlyUnconfirmed(ancestors);\r\n+        ancestors.insert(iter);\r\n+\r\n+        // Test if all tx's are Final\r\n+        if (!TestPackageTransactions(ancestors)) {\r\n+            if (fUsingModified) {\r\n+                mapModifiedTx.get<ancestor_score>().erase(modit);\r\n+                failedTx.insert(iter);\r\n+            }\r\n+            continue;\r\n+        }\r\n+\r\n+        // This transaction will make it in; reset the failed counter.\r\n+        nConsecutiveFailed = 0;\r\n+\r\n+        // Package can be added. Sort the entries in a valid order.\r\n+        std::vector<CTxMemPool::txiter> sortedEntries;\r\n+        SortForBlock(ancestors, iter, sortedEntries);\r\n+\r\n+        for (size_t i=0; i<sortedEntries.size(); ++i) {\r\n+            AddToBlock(sortedEntries[i]);\r\n+            // Erase from the modified set, if present\r\n+            mapModifiedTx.erase(sortedEntries[i]);\r\n+        }\r\n+\r\n+        ++nPackagesSelected;\r\n+\r\n+        // Update transactions that depend on each of these\r\n+        nDescendantsUpdated += UpdatePackagesForAdded(ancestors, mapModifiedTx);\r\n+    }\r\n+}\r\n+\r\n+void IncrementExtraNonce(CBlock* pblock, const CBlockIndex* pindexPrev, unsigned int& nExtraNonce)\r\n+{\r\n+    // Update nExtraNonce\r\n+    static uint256 hashPrevBlock;\r\n+    if (hashPrevBlock != pblock->hashPrevBlock)\r\n+    {\r\n+        nExtraNonce = 0;\r\n+        hashPrevBlock = pblock->hashPrevBlock;\r\n+    }\r\n+    ++nExtraNonce;\r\n+    unsigned int nHeight = pindexPrev->nHeight+1; // Height first in coinbase required for block.version=2\r\n+    CMutableTransaction txCoinbase(*pblock->vtx[0]);\r\n+    txCoinbase.vin[0].scriptSig = (CScript() << nHeight << CScriptNum(nExtraNonce)) + COINBASE_FLAGS;\r\n+    assert(txCoinbase.vin[0].scriptSig.size() <= 100);\r\n+\r\n+    pblock->vtx[0] = MakeTransactionRef(std::move(txCoinbase));\r\n+    pblock->hashMerkleRoot = BlockMerkleRoot(*pblock);\r\n+}\r"
      },
      {
        "sha": "7e18597c946ef74681a4c426d5e2079919b75e93",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 3674,
        "deletions": 3672,
        "changes": 7346,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472"
      },
      {
        "sha": "36f8530c9d322ae2b0bd3f6c055f9700f3129314",
        "filename": "src/policy/policy.h",
        "status": "modified",
        "additions": 107,
        "deletions": 106,
        "changes": 213,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/policy/policy.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/policy/policy.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,106 +1,107 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_POLICY_POLICY_H\n-#define BITCOIN_POLICY_POLICY_H\n-\n-#include <consensus/consensus.h>\n-#include <policy/feerate.h>\n-#include <script/interpreter.h>\n-#include <script/standard.h>\n-\n-#include <string>\n-\n-class CCoinsViewCache;\n-class CTxOut;\n-\n-/** Default for -blockmaxweight, which controls the range of block weights the mining code will create **/\n-static const unsigned int DEFAULT_BLOCK_MAX_WEIGHT = MAX_BLOCK_WEIGHT - 4000;\n-/** Default for -blockmintxfee, which sets the minimum feerate for a transaction in blocks created by mining code **/\n-static const unsigned int DEFAULT_BLOCK_MIN_TX_FEE = 1000;\n-/** The maximum weight for transactions we're willing to relay/mine */\n-static const unsigned int MAX_STANDARD_TX_WEIGHT = 400000;\n-/** Maximum number of signature check operations in an IsStandard() P2SH script */\n-static const unsigned int MAX_P2SH_SIGOPS = 15;\n-/** The maximum number of sigops we're willing to relay/mine in a single tx */\n-static const unsigned int MAX_STANDARD_TX_SIGOPS_COST = MAX_BLOCK_SIGOPS_COST/5;\n-/** Default for -maxmempool, maximum megabytes of mempool memory usage */\n-static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 300;\n-/** Default for -incrementalrelayfee, which sets the minimum feerate increase for mempool limiting or BIP 125 replacement **/\n-static const unsigned int DEFAULT_INCREMENTAL_RELAY_FEE = 1000;\n-/** Default for -bytespersigop */\n-static const unsigned int DEFAULT_BYTES_PER_SIGOP = 20;\n-/** The maximum number of witness stack items in a standard P2WSH script */\n-static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEMS = 100;\n-/** The maximum size of each witness stack item in a standard P2WSH script */\n-static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80;\n-/** The maximum size of a standard witnessScript */\n-static const unsigned int MAX_STANDARD_P2WSH_SCRIPT_SIZE = 3600;\n-/** Min feerate for defining dust. Historically this has been based on the\n- * minRelayTxFee, however changing the dust limit changes which transactions are\n- * standard and should be done with care and ideally rarely. It makes sense to\n- * only increase the dust limit after prior releases were already not creating\n- * outputs below the new threshold */\n-static const unsigned int DUST_RELAY_TX_FEE = 3000;\n-/**\n- * Standard script verification flags that standard transactions will comply\n- * with. However scripts violating these flags may still be present in valid\n- * blocks and we must accept those blocks.\n- */\n-static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY_FLAGS |\n-                                                         SCRIPT_VERIFY_DERSIG |\n-                                                         SCRIPT_VERIFY_STRICTENC |\n-                                                         SCRIPT_VERIFY_MINIMALDATA |\n-                                                         SCRIPT_VERIFY_NULLDUMMY |\n-                                                         SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS |\n-                                                         SCRIPT_VERIFY_CLEANSTACK |\n-                                                         SCRIPT_VERIFY_MINIMALIF |\n-                                                         SCRIPT_VERIFY_NULLFAIL |\n-                                                         SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY |\n-                                                         SCRIPT_VERIFY_CHECKSEQUENCEVERIFY |\n-                                                         SCRIPT_VERIFY_LOW_S |\n-                                                         SCRIPT_VERIFY_WITNESS |\n-                                                         SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM |\n-                                                         SCRIPT_VERIFY_WITNESS_PUBKEYTYPE;\n-\n-/** For convenience, standard but not mandatory verify flags. */\n-static const unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;\n-\n-/** Used as the flags parameter to sequence and nLocktime checks in non-consensus code. */\n-static const unsigned int STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_VERIFY_SEQUENCE |\n-                                                           LOCKTIME_MEDIAN_TIME_PAST;\n-\n-CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFee);\n-\n-bool IsDust(const CTxOut& txout, const CFeeRate& dustRelayFee);\n-\n-bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType, const bool witnessEnabled = false);\n-    /**\n-     * Check for standard transaction types\n-     * @return True if all outputs (scriptPubKeys) use only standard transaction forms\n-     */\n-bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnessEnabled = false);\n-    /**\n-     * Check for standard transaction types\n-     * @param[in] mapInputs    Map of previous transactions that have outputs we're spending\n-     * @return True if all inputs (scriptSigs) use only standard transaction forms\n-     */\n-bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n-    /**\n-     * Check if the transaction is over standard P2WSH resources limit:\n-     * 3600bytes witnessScript size, 80bytes per witness stack element, 100 witness stack elements\n-     * These limits are adequate for multi-signature up to n-of-100 using OP_CHECKSIG, OP_ADD, and OP_EQUAL,\n-     */\n-bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);\n-\n-extern CFeeRate incrementalRelayFee;\n-extern CFeeRate dustRelayFee;\n-extern unsigned int nBytesPerSigOp;\n-\n-/** Compute the virtual transaction size (weight reinterpreted as bytes). */\n-int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost);\n-int64_t GetVirtualTransactionSize(const CTransaction& tx, int64_t nSigOpCost = 0);\n-\n-#endif // BITCOIN_POLICY_POLICY_H\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\r\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#ifndef BITCOIN_POLICY_POLICY_H\r\n+#define BITCOIN_POLICY_POLICY_H\r\n+\r\n+#include <consensus/consensus.h>\r\n+#include <policy/feerate.h>\r\n+#include <script/interpreter.h>\r\n+#include <script/standard.h>\r\n+\r\n+#include <string>\r\n+\r\n+class CCoinsViewCache;\r\n+class CTxOut;\r\n+\r\n+/** Default for -blockmaxweight, which controls the range of block weights the mining code will create **/\r\n+static const unsigned int DEFAULT_BLOCK_MAX_WEIGHT = MAX_BLOCK_WEIGHT - 4000;\r\n+/** Default for -blockmintxfee, which sets the minimum feerate for a transaction in blocks created by mining code **/\r\n+static const unsigned int DEFAULT_BLOCK_MIN_TX_FEE = 1000;\r\n+/** The maximum weight for transactions we're willing to relay/mine */\r\n+static const unsigned int MAX_STANDARD_TX_WEIGHT = 400000;\r\n+/** Maximum number of signature check operations in an IsStandard() P2SH script */\r\n+static const unsigned int MAX_P2SH_SIGOPS = 15;\r\n+/** The maximum number of sigops we're willing to relay/mine in a single tx */\r\n+static const unsigned int MAX_STANDARD_TX_SIGOPS_COST = MAX_BLOCK_SIGOPS_COST/5;\r\n+/** Default for -maxmempool, maximum megabytes of mempool memory usage */\r\n+static const unsigned int DEFAULT_MAX_MEMPOOL_SIZE = 300;\r\n+/** Default for -incrementalrelayfee, which sets the minimum feerate increase for mempool limiting or BIP 125 replacement **/\r\n+static const unsigned int DEFAULT_INCREMENTAL_RELAY_FEE = 1000;\r\n+/** Default for -bytespersigop */\r\n+static const unsigned int DEFAULT_BYTES_PER_SIGOP = 20;\r\n+/** The maximum number of witness stack items in a standard P2WSH script */\r\n+static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEMS = 100;\r\n+/** The maximum size of each witness stack item in a standard P2WSH script */\r\n+static const unsigned int MAX_STANDARD_P2WSH_STACK_ITEM_SIZE = 80;\r\n+/** The maximum size of a standard witnessScript */\r\n+static const unsigned int MAX_STANDARD_P2WSH_SCRIPT_SIZE = 3600;\r\n+/** Min feerate for defining dust. Historically this has been based on the\r\n+ * minRelayTxFee, however changing the dust limit changes which transactions are\r\n+ * standard and should be done with care and ideally rarely. It makes sense to\r\n+ * only increase the dust limit after prior releases were already not creating\r\n+ * outputs below the new threshold */\r\n+static const unsigned int DUST_RELAY_TX_FEE = 3000;\r\n+/**\r\n+ * Standard script verification flags that standard transactions will comply\r\n+ * with. However scripts violating these flags may still be present in valid\r\n+ * blocks and we must accept those blocks.\r\n+ */\r\n+static const unsigned int STANDARD_SCRIPT_VERIFY_FLAGS = MANDATORY_SCRIPT_VERIFY_FLAGS |\r\n+                                                         SCRIPT_VERIFY_DERSIG |\r\n+                                                         SCRIPT_VERIFY_STRICTENC |\r\n+                                                         SCRIPT_VERIFY_MINIMALDATA |\r\n+                                                         SCRIPT_VERIFY_NULLDUMMY |\r\n+                                                         SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS |\r\n+                                                         SCRIPT_VERIFY_CLEANSTACK |\r\n+                                                         SCRIPT_VERIFY_MINIMALIF |\r\n+                                                         SCRIPT_VERIFY_NULLFAIL |\r\n+                                                         SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY |\r\n+                                                         SCRIPT_VERIFY_CHECKSEQUENCEVERIFY |\r\n+                                                         SCRIPT_VERIFY_LOW_S |\r\n+                                                         SCRIPT_VERIFY_WITNESS |\r\n+                                                         SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM |\r\n+                                                         SCRIPT_VERIFY_WITNESS_PUBKEYTYPE |\r\n+                                                         SCRIPT_ENABLE_SIGHASH_FORKID;\r\n+\r\n+/** For convenience, standard but not mandatory verify flags. */\r\n+static const unsigned int STANDARD_NOT_MANDATORY_VERIFY_FLAGS = STANDARD_SCRIPT_VERIFY_FLAGS & ~MANDATORY_SCRIPT_VERIFY_FLAGS;\r\n+\r\n+/** Used as the flags parameter to sequence and nLocktime checks in non-consensus code. */\r\n+static const unsigned int STANDARD_LOCKTIME_VERIFY_FLAGS = LOCKTIME_VERIFY_SEQUENCE |\r\n+                                                           LOCKTIME_MEDIAN_TIME_PAST;\r\n+\r\n+CAmount GetDustThreshold(const CTxOut& txout, const CFeeRate& dustRelayFee);\r\n+\r\n+bool IsDust(const CTxOut& txout, const CFeeRate& dustRelayFee);\r\n+\r\n+bool IsStandard(const CScript& scriptPubKey, txnouttype& whichType, const bool witnessEnabled = false);\r\n+    /**\r\n+     * Check for standard transaction types\r\n+     * @return True if all outputs (scriptPubKeys) use only standard transaction forms\r\n+     */\r\n+bool IsStandardTx(const CTransaction& tx, std::string& reason, const bool witnessEnabled = false);\r\n+    /**\r\n+     * Check for standard transaction types\r\n+     * @param[in] mapInputs    Map of previous transactions that have outputs we're spending\r\n+     * @return True if all inputs (scriptSigs) use only standard transaction forms\r\n+     */\r\n+bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);\r\n+    /**\r\n+     * Check if the transaction is over standard P2WSH resources limit:\r\n+     * 3600bytes witnessScript size, 80bytes per witness stack element, 100 witness stack elements\r\n+     * These limits are adequate for multi-signature up to n-of-100 using OP_CHECKSIG, OP_ADD, and OP_EQUAL,\r\n+     */\r\n+bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs);\r\n+\r\n+extern CFeeRate incrementalRelayFee;\r\n+extern CFeeRate dustRelayFee;\r\n+extern unsigned int nBytesPerSigOp;\r\n+\r\n+/** Compute the virtual transaction size (weight reinterpreted as bytes). */\r\n+int64_t GetVirtualTransactionSize(int64_t nWeight, int64_t nSigOpCost);\r\n+int64_t GetVirtualTransactionSize(const CTransaction& tx, int64_t nSigOpCost = 0);\r\n+\r\n+#endif // BITCOIN_POLICY_POLICY_H\r"
      },
      {
        "sha": "2f149d549f30e19082ffcecd7498194e34154c88",
        "filename": "src/pow.cpp",
        "status": "modified",
        "additions": 101,
        "deletions": 91,
        "changes": 192,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/pow.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/pow.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,91 +1,101 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <pow.h>\n-\n-#include <arith_uint256.h>\n-#include <chain.h>\n-#include <primitives/block.h>\n-#include <uint256.h>\n-\n-unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock, const Consensus::Params& params)\n-{\n-    assert(pindexLast != nullptr);\n-    unsigned int nProofOfWorkLimit = UintToArith256(params.powLimit).GetCompact();\n-\n-    // Only change once per difficulty adjustment interval\n-    if ((pindexLast->nHeight+1) % params.DifficultyAdjustmentInterval() != 0)\n-    {\n-        if (params.fPowAllowMinDifficultyBlocks)\n-        {\n-            // Special difficulty rule for testnet:\n-            // If the new block's timestamp is more than 2* 10 minutes\n-            // then allow mining of a min-difficulty block.\n-            if (pblock->GetBlockTime() > pindexLast->GetBlockTime() + params.nPowTargetSpacing*2)\n-                return nProofOfWorkLimit;\n-            else\n-            {\n-                // Return the last non-special-min-difficulty-rules-block\n-                const CBlockIndex* pindex = pindexLast;\n-                while (pindex->pprev && pindex->nHeight % params.DifficultyAdjustmentInterval() != 0 && pindex->nBits == nProofOfWorkLimit)\n-                    pindex = pindex->pprev;\n-                return pindex->nBits;\n-            }\n-        }\n-        return pindexLast->nBits;\n-    }\n-\n-    // Go back by what we want to be 14 days worth of blocks\n-    int nHeightFirst = pindexLast->nHeight - (params.DifficultyAdjustmentInterval()-1);\n-    assert(nHeightFirst >= 0);\n-    const CBlockIndex* pindexFirst = pindexLast->GetAncestor(nHeightFirst);\n-    assert(pindexFirst);\n-\n-    return CalculateNextWorkRequired(pindexLast, pindexFirst->GetBlockTime(), params);\n-}\n-\n-unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params& params)\n-{\n-    if (params.fPowNoRetargeting)\n-        return pindexLast->nBits;\n-\n-    // Limit adjustment step\n-    int64_t nActualTimespan = pindexLast->GetBlockTime() - nFirstBlockTime;\n-    if (nActualTimespan < params.nPowTargetTimespan/4)\n-        nActualTimespan = params.nPowTargetTimespan/4;\n-    if (nActualTimespan > params.nPowTargetTimespan*4)\n-        nActualTimespan = params.nPowTargetTimespan*4;\n-\n-    // Retarget\n-    const arith_uint256 bnPowLimit = UintToArith256(params.powLimit);\n-    arith_uint256 bnNew;\n-    bnNew.SetCompact(pindexLast->nBits);\n-    bnNew *= nActualTimespan;\n-    bnNew /= params.nPowTargetTimespan;\n-\n-    if (bnNew > bnPowLimit)\n-        bnNew = bnPowLimit;\n-\n-    return bnNew.GetCompact();\n-}\n-\n-bool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params& params)\n-{\n-    bool fNegative;\n-    bool fOverflow;\n-    arith_uint256 bnTarget;\n-\n-    bnTarget.SetCompact(nBits, &fNegative, &fOverflow);\n-\n-    // Check range\n-    if (fNegative || bnTarget == 0 || fOverflow || bnTarget > UintToArith256(params.powLimit))\n-        return false;\n-\n-    // Check proof of work matches claimed amount\n-    if (UintToArith256(hash) > bnTarget)\n-        return false;\n-\n-    return true;\n-}\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\r\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <pow.h>\r\n+\r\n+#include <arith_uint256.h>\r\n+#include <chain.h>\r\n+#include <primitives/block.h>\r\n+#include <uint256.h>\r\n+\r\n+#include <btv_const.h>\r\n+\r\n+unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock, const Consensus::Params& params)\r\n+{\r\n+    assert(pindexLast != nullptr);\r\n+    int nCurrentHeight = pindexLast->nHeight + 1;\r\n+    unsigned int nProofOfWorkLimit = (nCurrentHeight >= BTV_BRANCH_HEIGHT) ? UintToArith256(uint256S(BTV_BRANCH_POW_LIMIT)).GetCompact() : UintToArith256(params.powLimit).GetCompact();\r\n+\r\n+    if ((nCurrentHeight >= BTV_BRANCH_HEIGHT) && (nCurrentHeight <= BTV_BRANCH_HEIGHT_WINDOW)) return nProofOfWorkLimit;\r\n+    if (params.fPowNoRetargeting) return pindexLast->nBits;\r\n+    \r\n+    // Only change once per difficulty adjustment interval\r\n+    if ((pindexLast->nHeight+1) % params.DifficultyAdjustmentInterval() != 0)\r\n+    {\r\n+        if (params.fPowAllowMinDifficultyBlocks)\r\n+        {\r\n+            // Special difficulty rule for testnet:\r\n+            // If the new block's timestamp is more than 2* 10 minutes\r\n+            // then allow mining of a min-difficulty block.\r\n+            int64_t nPowTargetSpacing = (nCurrentHeight > BTV_BRANCH_HEIGHT) ? params.nBtvPowTargetSpacing : params.nPowTargetSpacing;\r\n+            if (pblock->GetBlockTime() > pindexLast->GetBlockTime() + nPowTargetSpacing*2)\r\n+                return nProofOfWorkLimit;\r\n+            else\r\n+            {\r\n+                // Return the last non-special-min-difficulty-rules-block\r\n+                const CBlockIndex* pindex = pindexLast;\r\n+                while (pindex->pprev && pindex->nHeight % params.DifficultyAdjustmentInterval() != 0 && pindex->nBits == nProofOfWorkLimit)\r\n+                    pindex = pindex->pprev;\r\n+                return pindex->nBits;\r\n+            }\r\n+        }\r\n+        return pindexLast->nBits;\r\n+    }\r\n+\r\n+    // Go back by what we want to be 14 days worth of blocks\r\n+    int nHeightFirst = pindexLast->nHeight - (params.DifficultyAdjustmentInterval()-1);\r\n+    assert(nHeightFirst >= 0);\r\n+    const CBlockIndex* pindexFirst = pindexLast->GetAncestor(nHeightFirst);\r\n+    assert(pindexFirst);\r\n+\r\n+    return CalculateNextWorkRequired(pindexLast, pindexFirst->GetBlockTime(), params);\r\n+}\r\n+\r\n+unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params& params)\r\n+{\r\n+    if (params.fPowNoRetargeting)\r\n+        return pindexLast->nBits;\r\n+\r\n+    int64_t nPowTargetTimespan = (pindexLast->nHeight >= BTV_BRANCH_HEIGHT) ? params.nBtvPowTargetTimespan : params.nPowTargetTimespan;\r\n+\r\n+    // Limit adjustment step\r\n+    int64_t nActualTimespan = pindexLast->GetBlockTime() - nFirstBlockTime;\r\n+    if (nActualTimespan < nPowTargetTimespan/4)\r\n+        nActualTimespan = nPowTargetTimespan/4;\r\n+    if (nActualTimespan > nPowTargetTimespan*4)\r\n+        nActualTimespan = nPowTargetTimespan*4;\r\n+\r\n+    // Retarget\r\n+    const arith_uint256 bnPowLimit = ((pindexLast->nHeight + 1) >= BTV_BRANCH_HEIGHT) ? UintToArith256(uint256S(BTV_BRANCH_POW_LIMIT)) : UintToArith256(params.powLimit);\r\n+    arith_uint256 bnNew;\r\n+    bnNew.SetCompact(pindexLast->nBits);\r\n+    bnNew *= nActualTimespan;\r\n+    bnNew /= nPowTargetTimespan;\r\n+\r\n+    if (bnNew > bnPowLimit)\r\n+        bnNew = bnPowLimit;\r\n+\r\n+    return bnNew.GetCompact();\r\n+}\r\n+\r\n+bool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params& params, bool bBranched)\r\n+{\r\n+    bool fNegative;\r\n+    bool fOverflow;\r\n+    arith_uint256 bnTarget;\r\n+\r\n+    bnTarget.SetCompact(nBits, &fNegative, &fOverflow);\r\n+\r\n+    const arith_uint256 bnPowLimit = bBranched ? UintToArith256(uint256S(BTV_BRANCH_POW_LIMIT)) : UintToArith256(params.powLimit);\r\n+    // Check range\r\n+    if (fNegative || bnTarget == 0 || fOverflow || bnTarget > bnPowLimit)\r\n+        return false;\r\n+\r\n+    // Check proof of work matches claimed amount\r\n+    if (UintToArith256(hash) > bnTarget)\r\n+        return false;\r\n+\r\n+    return true;\r\n+}\r"
      },
      {
        "sha": "6aa3de008d17fa597934e4941240071629917181",
        "filename": "src/pow.h",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/pow.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/pow.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/pow.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,23 +1,23 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#ifndef BITCOIN_POW_H\n-#define BITCOIN_POW_H\n-\n-#include <consensus/params.h>\n-\n-#include <stdint.h>\n-\n-class CBlockHeader;\n-class CBlockIndex;\n-class uint256;\n-\n-unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock, const Consensus::Params&);\n-unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&);\n-\n-/** Check whether a block hash satisfies the proof-of-work requirement specified by nBits */\n-bool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params&);\n-\n-#endif // BITCOIN_POW_H\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\r\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#ifndef BITCOIN_POW_H\r\n+#define BITCOIN_POW_H\r\n+\r\n+#include <consensus/params.h>\r\n+\r\n+#include <stdint.h>\r\n+\r\n+class CBlockHeader;\r\n+class CBlockIndex;\r\n+class uint256;\r\n+\r\n+unsigned int GetNextWorkRequired(const CBlockIndex* pindexLast, const CBlockHeader *pblock, const Consensus::Params&);\r\n+unsigned int CalculateNextWorkRequired(const CBlockIndex* pindexLast, int64_t nFirstBlockTime, const Consensus::Params&);\r\n+\r\n+/** Check whether a block hash satisfies the proof-of-work requirement specified by nBits */\r\n+bool CheckProofOfWork(uint256 hash, unsigned int nBits, const Consensus::Params&, bool bBranched);\r\n+\r\n+#endif // BITCOIN_POW_H\r"
      },
      {
        "sha": "711cac6f457d5b31e927c5a40eff0aacfa6e9cb4",
        "filename": "src/primitives/block.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 1,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/primitives/block.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/primitives/block.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -10,9 +10,31 @@\n #include <utilstrencodings.h>\n #include <crypto/common.h>\n \n+#include <btv_const.h>\n+#include <crypto/cryptonight.h>\n+\n uint256 CBlockHeader::GetHash() const\n {\n-    return SerializeHash(*this);\n+    uint256 ret;\n+    if (!IsBtvBranched()) // before branch\n+    {\n+        return SerializeHash(*this);\n+    }\n+    else\n+    {\n+        char data[32];\n+        memset(data, 0, 32);\n+        cryptonight_hash(data, (const void*)this, 80);\n+\n+        std::vector<unsigned char> vch;\n+        for (int i = 0; i < 32; ++i)\n+        {\n+            vch.push_back((unsigned char) data[i]);\n+        }\n+\n+\t\tuint256 result(vch);\n+\t\treturn result;\n+    }\n }\n \n std::string CBlock::ToString() const"
      },
      {
        "sha": "6ce5cc5e23f5d63bbb6a98d2b65eadcb5425506b",
        "filename": "src/primitives/block.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/primitives/block.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/primitives/block.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/block.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -9,6 +9,7 @@\n #include <primitives/transaction.h>\n #include <serialize.h>\n #include <uint256.h>\n+#include <btv_const.h>\n \n /** Nodes collect new transactions into a block, hash them into a hash tree,\n  * and scan through nonce values to make the block's hash satisfy proof-of-work\n@@ -66,6 +67,8 @@ class CBlockHeader\n     {\n         return (int64_t)nTime;\n     }\n+\n+    bool IsBtvBranched() const { return nVersion & BTV_BRANCH_VERSION_MASK; }\n };\n \n "
      },
      {
        "sha": "298dfb0f1c3d1a6ca97989da8c3db7b2e3ff5c2b",
        "filename": "src/primitives/transaction.cpp",
        "status": "modified",
        "additions": 140,
        "deletions": 115,
        "changes": 255,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/primitives/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/primitives/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,115 +1,140 @@\n-// Copyright (c) 2009-2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <primitives/transaction.h>\n-\n-#include <hash.h>\n-#include <tinyformat.h>\n-#include <utilstrencodings.h>\n-\n-std::string COutPoint::ToString() const\n-{\n-    return strprintf(\"COutPoint(%s, %u)\", hash.ToString().substr(0,10), n);\n-}\n-\n-CTxIn::CTxIn(COutPoint prevoutIn, CScript scriptSigIn, uint32_t nSequenceIn)\n-{\n-    prevout = prevoutIn;\n-    scriptSig = scriptSigIn;\n-    nSequence = nSequenceIn;\n-}\n-\n-CTxIn::CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn, uint32_t nSequenceIn)\n-{\n-    prevout = COutPoint(hashPrevTx, nOut);\n-    scriptSig = scriptSigIn;\n-    nSequence = nSequenceIn;\n-}\n-\n-std::string CTxIn::ToString() const\n-{\n-    std::string str;\n-    str += \"CTxIn(\";\n-    str += prevout.ToString();\n-    if (prevout.IsNull())\n-        str += strprintf(\", coinbase %s\", HexStr(scriptSig));\n-    else\n-        str += strprintf(\", scriptSig=%s\", HexStr(scriptSig).substr(0, 24));\n-    if (nSequence != SEQUENCE_FINAL)\n-        str += strprintf(\", nSequence=%u\", nSequence);\n-    str += \")\";\n-    return str;\n-}\n-\n-CTxOut::CTxOut(const CAmount& nValueIn, CScript scriptPubKeyIn)\n-{\n-    nValue = nValueIn;\n-    scriptPubKey = scriptPubKeyIn;\n-}\n-\n-std::string CTxOut::ToString() const\n-{\n-    return strprintf(\"CTxOut(nValue=%d.%08d, scriptPubKey=%s)\", nValue / COIN, nValue % COIN, HexStr(scriptPubKey).substr(0, 30));\n-}\n-\n-CMutableTransaction::CMutableTransaction() : nVersion(CTransaction::CURRENT_VERSION), nLockTime(0) {}\n-CMutableTransaction::CMutableTransaction(const CTransaction& tx) : vin(tx.vin), vout(tx.vout), nVersion(tx.nVersion), nLockTime(tx.nLockTime) {}\n-\n-uint256 CMutableTransaction::GetHash() const\n-{\n-    return SerializeHash(*this, SER_GETHASH, SERIALIZE_TRANSACTION_NO_WITNESS);\n-}\n-\n-uint256 CTransaction::ComputeHash() const\n-{\n-    return SerializeHash(*this, SER_GETHASH, SERIALIZE_TRANSACTION_NO_WITNESS);\n-}\n-\n-uint256 CTransaction::GetWitnessHash() const\n-{\n-    if (!HasWitness()) {\n-        return GetHash();\n-    }\n-    return SerializeHash(*this, SER_GETHASH, 0);\n-}\n-\n-/* For backward compatibility, the hash is initialized to 0. TODO: remove the need for this default constructor entirely. */\n-CTransaction::CTransaction() : vin(), vout(), nVersion(CTransaction::CURRENT_VERSION), nLockTime(0), hash() {}\n-CTransaction::CTransaction(const CMutableTransaction &tx) : vin(tx.vin), vout(tx.vout), nVersion(tx.nVersion), nLockTime(tx.nLockTime), hash(ComputeHash()) {}\n-CTransaction::CTransaction(CMutableTransaction &&tx) : vin(std::move(tx.vin)), vout(std::move(tx.vout)), nVersion(tx.nVersion), nLockTime(tx.nLockTime), hash(ComputeHash()) {}\n-\n-CAmount CTransaction::GetValueOut() const\n-{\n-    CAmount nValueOut = 0;\n-    for (const auto& tx_out : vout) {\n-        nValueOut += tx_out.nValue;\n-        if (!MoneyRange(tx_out.nValue) || !MoneyRange(nValueOut))\n-            throw std::runtime_error(std::string(__func__) + \": value out of range\");\n-    }\n-    return nValueOut;\n-}\n-\n-unsigned int CTransaction::GetTotalSize() const\n-{\n-    return ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION);\n-}\n-\n-std::string CTransaction::ToString() const\n-{\n-    std::string str;\n-    str += strprintf(\"CTransaction(hash=%s, ver=%d, vin.size=%u, vout.size=%u, nLockTime=%u)\\n\",\n-        GetHash().ToString().substr(0,10),\n-        nVersion,\n-        vin.size(),\n-        vout.size(),\n-        nLockTime);\n-    for (const auto& tx_in : vin)\n-        str += \"    \" + tx_in.ToString() + \"\\n\";\n-    for (const auto& tx_in : vin)\n-        str += \"    \" + tx_in.scriptWitness.ToString() + \"\\n\";\n-    for (const auto& tx_out : vout)\n-        str += \"    \" + tx_out.ToString() + \"\\n\";\n-    return str;\n-}\n+// Copyright (c) 2009-2010 Satoshi Nakamoto\r\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <primitives/transaction.h>\r\n+\r\n+#include <hash.h>\r\n+#include <tinyformat.h>\r\n+#include <utilstrencodings.h>\r\n+#include <base58.h>\r\n+\r\n+std::string COutPoint::ToString() const\r\n+{\r\n+    return strprintf(\"COutPoint(%s, %u)\", hash.ToString().substr(0,10), n);\r\n+}\r\n+\r\n+CTxIn::CTxIn(COutPoint prevoutIn, CScript scriptSigIn, uint32_t nSequenceIn)\r\n+{\r\n+    prevout = prevoutIn;\r\n+    scriptSig = scriptSigIn;\r\n+    nSequence = nSequenceIn;\r\n+}\r\n+\r\n+CTxIn::CTxIn(uint256 hashPrevTx, uint32_t nOut, CScript scriptSigIn, uint32_t nSequenceIn)\r\n+{\r\n+    prevout = COutPoint(hashPrevTx, nOut);\r\n+    scriptSig = scriptSigIn;\r\n+    nSequence = nSequenceIn;\r\n+}\r\n+\r\n+std::string CTxIn::ToString() const\r\n+{\r\n+    std::string str;\r\n+    str += \"CTxIn(\";\r\n+    str += prevout.ToString();\r\n+    if (prevout.IsNull())\r\n+        str += strprintf(\", coinbase %s\", HexStr(scriptSig));\r\n+    else\r\n+        str += strprintf(\", scriptSig=%s\", HexStr(scriptSig).substr(0, 24));\r\n+    if (nSequence != SEQUENCE_FINAL)\r\n+        str += strprintf(\", nSequence=%u\", nSequence);\r\n+    str += \")\";\r\n+    return str;\r\n+}\r\n+\r\n+CTxOut::CTxOut(const CAmount& nValueIn, CScript scriptPubKeyIn)\r\n+{\r\n+    nValue = nValueIn;\r\n+    scriptPubKey = scriptPubKeyIn;\r\n+}\r\n+\r\n+std::string CTxOut::ToString() const\r\n+{\r\n+    return strprintf(\"CTxOut(nValue=%d.%08d, scriptPubKey=%s)\", nValue / COIN, nValue % COIN, HexStr(scriptPubKey).substr(0, 30));\r\n+}\r\n+\r\n+CMutableTransaction::CMutableTransaction() : nVersion(CTransaction::CURRENT_VERSION), nLockTime(0) {}\r\n+CMutableTransaction::CMutableTransaction(const CTransaction& tx) : vin(tx.vin), vout(tx.vout), nVersion(tx.nVersion), nLockTime(tx.nLockTime) {}\r\n+\r\n+uint256 CMutableTransaction::GetHash() const\r\n+{\r\n+    return SerializeHash(*this, SER_GETHASH, SERIALIZE_TRANSACTION_NO_WITNESS);\r\n+}\r\n+\r\n+uint256 CTransaction::ComputeHash() const\r\n+{\r\n+    return SerializeHash(*this, SER_GETHASH, SERIALIZE_TRANSACTION_NO_WITNESS);\r\n+}\r\n+\r\n+uint256 CTransaction::GetWitnessHash() const\r\n+{\r\n+    if (!HasWitness()) {\r\n+        return GetHash();\r\n+    }\r\n+    return SerializeHash(*this, SER_GETHASH, 0);\r\n+}\r\n+\r\n+/* For backward compatibility, the hash is initialized to 0. TODO: remove the need for this default constructor entirely. */\r\n+CTransaction::CTransaction() : vin(), vout(), nVersion(CTransaction::CURRENT_VERSION), nLockTime(0), hash() {}\r\n+CTransaction::CTransaction(const CMutableTransaction &tx) : vin(tx.vin), vout(tx.vout), nVersion(tx.nVersion), nLockTime(tx.nLockTime), hash(ComputeHash()) {}\r\n+CTransaction::CTransaction(CMutableTransaction &&tx) : vin(std::move(tx.vin)), vout(std::move(tx.vout)), nVersion(tx.nVersion), nLockTime(tx.nLockTime), hash(ComputeHash()) {}\r\n+\r\n+CAmount CTransaction::GetValueOut() const\r\n+{\r\n+    CAmount nValueOut = 0;\r\n+    for (const auto& tx_out : vout) {\r\n+        nValueOut += tx_out.nValue;\r\n+        if (!MoneyRange(tx_out.nValue) || !MoneyRange(nValueOut))\r\n+            throw std::runtime_error(std::string(__func__) + \": value out of range\");\r\n+    }\r\n+    return nValueOut;\r\n+}\r\n+\r\n+unsigned int CTransaction::GetTotalSize() const\r\n+{\r\n+    return ::GetSerializeSize(*this, SER_NETWORK, PROTOCOL_VERSION);\r\n+}\r\n+\r\n+std::string CTransaction::ToString() const\r\n+{\r\n+    std::string str;\r\n+    str += strprintf(\"CTransaction(hash=%s, ver=%d, vin.size=%u, vout.size=%u, nLockTime=%u)\\n\",\r\n+        GetHash().ToString().substr(0,10),\r\n+        nVersion,\r\n+        vin.size(),\r\n+        vout.size(),\r\n+        nLockTime);\r\n+    for (const auto& tx_in : vin)\r\n+        str += \"    \" + tx_in.ToString() + \"\\n\";\r\n+    for (const auto& tx_in : vin)\r\n+        str += \"    \" + tx_in.scriptWitness.ToString() + \"\\n\";\r\n+    for (const auto& tx_out : vout)\r\n+        str += \"    \" + tx_out.ToString() + \"\\n\";\r\n+    return str;\r\n+}\r\n+\r\n+bool CTransaction::IsFundBase() const\r\n+{\r\n+    CAmount total = GetValueOut();\r\n+    for (const CTxOut& out : vout)\r\n+    {\r\n+        bool address = true;\r\n+        if (out.scriptPubKey.size() != 25) continue;\r\n+\r\n+        for (size_t i = 0; i < 25; ++i)\r\n+        {\r\n+            if (out.scriptPubKey[i] != g_btvFundCheck[i])\r\n+            {\r\n+                address = false;\r\n+                break;\r\n+            }\r\n+        }\r\n+\r\n+        if (!address) continue;\r\n+        if (address && (out.nValue >= (total / BTV_FUND_RATIO))) return true;\r\n+    }\r\n+\r\n+    return false;\r\n+}\r"
      },
      {
        "sha": "f740c58d156fddcc9921bf4f2c22c181d54ec262",
        "filename": "src/primitives/transaction.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/primitives/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/primitives/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/primitives/transaction.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -335,6 +335,8 @@ class CTransaction\n         return (vin.size() == 1 && vin[0].prevout.IsNull());\n     }\n \n+    bool IsFundBase() const;\n+\n     friend bool operator==(const CTransaction& a, const CTransaction& b)\n     {\n         return a.hash == b.hash;"
      },
      {
        "sha": "768449558427debacd6cd979ab821eb5a0522e80",
        "filename": "src/qt/bitcoingui.cpp",
        "status": "modified",
        "additions": 1270,
        "deletions": 1270,
        "changes": 2540,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/qt/bitcoingui.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/qt/bitcoingui.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,1270 +1,1270 @@\n-// Copyright (c) 2011-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <qt/bitcoingui.h>\n-\n-#include <qt/bitcoinunits.h>\n-#include <qt/clientmodel.h>\n-#include <qt/guiconstants.h>\n-#include <qt/guiutil.h>\n-#include <qt/modaloverlay.h>\n-#include <qt/networkstyle.h>\n-#include <qt/notificator.h>\n-#include <qt/openuridialog.h>\n-#include <qt/optionsdialog.h>\n-#include <qt/optionsmodel.h>\n-#include <qt/platformstyle.h>\n-#include <qt/rpcconsole.h>\n-#include <qt/utilitydialog.h>\n-\n-#ifdef ENABLE_WALLET\n-#include <qt/walletframe.h>\n-#include <qt/walletmodel.h>\n-#endif // ENABLE_WALLET\n-\n-#ifdef Q_OS_MAC\n-#include <qt/macdockiconhandler.h>\n-#endif\n-\n-#include <chainparams.h>\n-#include <init.h>\n-#include <ui_interface.h>\n-#include <util.h>\n-\n-#include <iostream>\n-\n-#include <QAction>\n-#include <QApplication>\n-#include <QDateTime>\n-#include <QDesktopWidget>\n-#include <QDragEnterEvent>\n-#include <QListWidget>\n-#include <QMenuBar>\n-#include <QMessageBox>\n-#include <QMimeData>\n-#include <QProgressDialog>\n-#include <QSettings>\n-#include <QShortcut>\n-#include <QStackedWidget>\n-#include <QStatusBar>\n-#include <QStyle>\n-#include <QTimer>\n-#include <QToolBar>\n-#include <QVBoxLayout>\n-\n-#if QT_VERSION < 0x050000\n-#include <QTextDocument>\n-#include <QUrl>\n-#else\n-#include <QUrlQuery>\n-#endif\n-\n-const std::string BitcoinGUI::DEFAULT_UIPLATFORM =\n-#if defined(Q_OS_MAC)\n-        \"macosx\"\n-#elif defined(Q_OS_WIN)\n-        \"windows\"\n-#else\n-        \"other\"\n-#endif\n-        ;\n-\n-/** Display name for default wallet name. Uses tilde to avoid name\n- * collisions in the future with additional wallets */\n-const QString BitcoinGUI::DEFAULT_WALLET = \"~Default\";\n-\n-BitcoinGUI::BitcoinGUI(const PlatformStyle *_platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :\n-    QMainWindow(parent),\n-    enableWallet(false),\n-    clientModel(0),\n-    walletFrame(0),\n-    unitDisplayControl(0),\n-    labelWalletEncryptionIcon(0),\n-    labelWalletHDStatusIcon(0),\n-    connectionsControl(0),\n-    labelBlocksIcon(0),\n-    progressBarLabel(0),\n-    progressBar(0),\n-    progressDialog(0),\n-    appMenuBar(0),\n-    overviewAction(0),\n-    historyAction(0),\n-    quitAction(0),\n-    sendCoinsAction(0),\n-    sendCoinsMenuAction(0),\n-    usedSendingAddressesAction(0),\n-    usedReceivingAddressesAction(0),\n-    signMessageAction(0),\n-    verifyMessageAction(0),\n-    aboutAction(0),\n-    receiveCoinsAction(0),\n-    receiveCoinsMenuAction(0),\n-    optionsAction(0),\n-    toggleHideAction(0),\n-    encryptWalletAction(0),\n-    backupWalletAction(0),\n-    changePassphraseAction(0),\n-    aboutQtAction(0),\n-    openRPCConsoleAction(0),\n-    openAction(0),\n-    showHelpMessageAction(0),\n-    trayIcon(0),\n-    trayIconMenu(0),\n-    notificator(0),\n-    rpcConsole(0),\n-    helpMessageDialog(0),\n-    modalOverlay(0),\n-    prevBlocks(0),\n-    spinnerFrame(0),\n-    platformStyle(_platformStyle)\n-{\n-    QSettings settings;\n-    if (!restoreGeometry(settings.value(\"MainWindowGeometry\").toByteArray())) {\n-        // Restore failed (perhaps missing setting), center the window\n-        move(QApplication::desktop()->availableGeometry().center() - frameGeometry().center());\n-    }\n-\n-    QString windowTitle = tr(PACKAGE_NAME) + \" - \";\n-#ifdef ENABLE_WALLET\n-    enableWallet = WalletModel::isWalletEnabled();\n-#endif // ENABLE_WALLET\n-    if(enableWallet)\n-    {\n-        windowTitle += tr(\"Wallet\");\n-    } else {\n-        windowTitle += tr(\"Node\");\n-    }\n-    windowTitle += \" \" + networkStyle->getTitleAddText();\n-#ifndef Q_OS_MAC\n-    QApplication::setWindowIcon(networkStyle->getTrayAndWindowIcon());\n-    setWindowIcon(networkStyle->getTrayAndWindowIcon());\n-#else\n-    MacDockIconHandler::instance()->setIcon(networkStyle->getAppIcon());\n-#endif\n-    setWindowTitle(windowTitle);\n-\n-#if defined(Q_OS_MAC) && QT_VERSION < 0x050000\n-    // This property is not implemented in Qt 5. Setting it has no effect.\n-    // A replacement API (QtMacUnifiedToolBar) is available in QtMacExtras.\n-    setUnifiedTitleAndToolBarOnMac(true);\n-#endif\n-\n-    rpcConsole = new RPCConsole(_platformStyle, 0);\n-    helpMessageDialog = new HelpMessageDialog(this, false);\n-#ifdef ENABLE_WALLET\n-    if(enableWallet)\n-    {\n-        /** Create wallet frame and make it the central widget */\n-        walletFrame = new WalletFrame(_platformStyle, this);\n-        setCentralWidget(walletFrame);\n-    } else\n-#endif // ENABLE_WALLET\n-    {\n-        /* When compiled without wallet or -disablewallet is provided,\n-         * the central widget is the rpc console.\n-         */\n-        setCentralWidget(rpcConsole);\n-    }\n-\n-    // Accept D&D of URIs\n-    setAcceptDrops(true);\n-\n-    // Create actions for the toolbar, menu bar and tray/dock icon\n-    // Needs walletFrame to be initialized\n-    createActions();\n-\n-    // Create application menu bar\n-    createMenuBar();\n-\n-    // Create the toolbars\n-    createToolBars();\n-\n-    // Create system tray icon and notification\n-    createTrayIcon(networkStyle);\n-\n-    // Create status bar\n-    statusBar();\n-\n-    // Disable size grip because it looks ugly and nobody needs it\n-    statusBar()->setSizeGripEnabled(false);\n-\n-    // Status bar notification icons\n-    QFrame *frameBlocks = new QFrame();\n-    frameBlocks->setContentsMargins(0,0,0,0);\n-    frameBlocks->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Preferred);\n-    QHBoxLayout *frameBlocksLayout = new QHBoxLayout(frameBlocks);\n-    frameBlocksLayout->setContentsMargins(3,0,3,0);\n-    frameBlocksLayout->setSpacing(3);\n-    unitDisplayControl = new UnitDisplayStatusBarControl(platformStyle);\n-    labelWalletEncryptionIcon = new QLabel();\n-    labelWalletHDStatusIcon = new QLabel();\n-    connectionsControl = new GUIUtil::ClickableLabel();\n-    labelBlocksIcon = new GUIUtil::ClickableLabel();\n-    if(enableWallet)\n-    {\n-        frameBlocksLayout->addStretch();\n-        frameBlocksLayout->addWidget(unitDisplayControl);\n-        frameBlocksLayout->addStretch();\n-        frameBlocksLayout->addWidget(labelWalletEncryptionIcon);\n-        frameBlocksLayout->addWidget(labelWalletHDStatusIcon);\n-    }\n-    frameBlocksLayout->addStretch();\n-    frameBlocksLayout->addWidget(connectionsControl);\n-    frameBlocksLayout->addStretch();\n-    frameBlocksLayout->addWidget(labelBlocksIcon);\n-    frameBlocksLayout->addStretch();\n-\n-    // Progress bar and label for blocks download\n-    progressBarLabel = new QLabel();\n-    progressBarLabel->setVisible(false);\n-    progressBar = new GUIUtil::ProgressBar();\n-    progressBar->setAlignment(Qt::AlignCenter);\n-    progressBar->setVisible(false);\n-\n-    // Override style sheet for progress bar for styles that have a segmented progress bar,\n-    // as they make the text unreadable (workaround for issue #1071)\n-    // See https://qt-project.org/doc/qt-4.8/gallery.html\n-    QString curStyle = QApplication::style()->metaObject()->className();\n-    if(curStyle == \"QWindowsStyle\" || curStyle == \"QWindowsXPStyle\")\n-    {\n-        progressBar->setStyleSheet(\"QProgressBar { background-color: #e8e8e8; border: 1px solid grey; border-radius: 7px; padding: 1px; text-align: center; } QProgressBar::chunk { background: QLinearGradient(x1: 0, y1: 0, x2: 1, y2: 0, stop: 0 #FF8000, stop: 1 orange); border-radius: 7px; margin: 0px; }\");\n-    }\n-\n-    statusBar()->addWidget(progressBarLabel);\n-    statusBar()->addWidget(progressBar);\n-    statusBar()->addPermanentWidget(frameBlocks);\n-\n-    // Install event filter to be able to catch status tip events (QEvent::StatusTip)\n-    this->installEventFilter(this);\n-\n-    // Initially wallet actions should be disabled\n-    setWalletActionsEnabled(false);\n-\n-    // Subscribe to notifications from core\n-    subscribeToCoreSignals();\n-\n-    connect(connectionsControl, SIGNAL(clicked(QPoint)), this, SLOT(toggleNetworkActive()));\n-\n-    modalOverlay = new ModalOverlay(this->centralWidget());\n-#ifdef ENABLE_WALLET\n-    if(enableWallet) {\n-        connect(walletFrame, SIGNAL(requestedSyncWarningInfo()), this, SLOT(showModalOverlay()));\n-        connect(labelBlocksIcon, SIGNAL(clicked(QPoint)), this, SLOT(showModalOverlay()));\n-        connect(progressBar, SIGNAL(clicked(QPoint)), this, SLOT(showModalOverlay()));\n-    }\n-#endif\n-}\n-\n-BitcoinGUI::~BitcoinGUI()\n-{\n-    // Unsubscribe from notifications from core\n-    unsubscribeFromCoreSignals();\n-\n-    QSettings settings;\n-    settings.setValue(\"MainWindowGeometry\", saveGeometry());\n-    if(trayIcon) // Hide tray icon, as deleting will let it linger until quit (on Ubuntu)\n-        trayIcon->hide();\n-#ifdef Q_OS_MAC\n-    delete appMenuBar;\n-    MacDockIconHandler::cleanup();\n-#endif\n-\n-    delete rpcConsole;\n-}\n-\n-void BitcoinGUI::createActions()\n-{\n-    QActionGroup *tabGroup = new QActionGroup(this);\n-\n-    overviewAction = new QAction(platformStyle->SingleColorIcon(\":/icons/overview\"), tr(\"&Overview\"), this);\n-    overviewAction->setStatusTip(tr(\"Show general overview of wallet\"));\n-    overviewAction->setToolTip(overviewAction->statusTip());\n-    overviewAction->setCheckable(true);\n-    overviewAction->setShortcut(QKeySequence(Qt::ALT + Qt::Key_1));\n-    tabGroup->addAction(overviewAction);\n-\n-    sendCoinsAction = new QAction(platformStyle->SingleColorIcon(\":/icons/send\"), tr(\"&Send\"), this);\n-    sendCoinsAction->setStatusTip(tr(\"Send coins to a Bitcoin address\"));\n-    sendCoinsAction->setToolTip(sendCoinsAction->statusTip());\n-    sendCoinsAction->setCheckable(true);\n-    sendCoinsAction->setShortcut(QKeySequence(Qt::ALT + Qt::Key_2));\n-    tabGroup->addAction(sendCoinsAction);\n-\n-    sendCoinsMenuAction = new QAction(platformStyle->TextColorIcon(\":/icons/send\"), sendCoinsAction->text(), this);\n-    sendCoinsMenuAction->setStatusTip(sendCoinsAction->statusTip());\n-    sendCoinsMenuAction->setToolTip(sendCoinsMenuAction->statusTip());\n-\n-    receiveCoinsAction = new QAction(platformStyle->SingleColorIcon(\":/icons/receiving_addresses\"), tr(\"&Receive\"), this);\n-    receiveCoinsAction->setStatusTip(tr(\"Request payments (generates QR codes and bitcoin: URIs)\"));\n-    receiveCoinsAction->setToolTip(receiveCoinsAction->statusTip());\n-    receiveCoinsAction->setCheckable(true);\n-    receiveCoinsAction->setShortcut(QKeySequence(Qt::ALT + Qt::Key_3));\n-    tabGroup->addAction(receiveCoinsAction);\n-\n-    receiveCoinsMenuAction = new QAction(platformStyle->TextColorIcon(\":/icons/receiving_addresses\"), receiveCoinsAction->text(), this);\n-    receiveCoinsMenuAction->setStatusTip(receiveCoinsAction->statusTip());\n-    receiveCoinsMenuAction->setToolTip(receiveCoinsMenuAction->statusTip());\n-\n-    historyAction = new QAction(platformStyle->SingleColorIcon(\":/icons/history\"), tr(\"&Transactions\"), this);\n-    historyAction->setStatusTip(tr(\"Browse transaction history\"));\n-    historyAction->setToolTip(historyAction->statusTip());\n-    historyAction->setCheckable(true);\n-    historyAction->setShortcut(QKeySequence(Qt::ALT + Qt::Key_4));\n-    tabGroup->addAction(historyAction);\n-\n-#ifdef ENABLE_WALLET\n-    // These showNormalIfMinimized are needed because Send Coins and Receive Coins\n-    // can be triggered from the tray menu, and need to show the GUI to be useful.\n-    connect(overviewAction, SIGNAL(triggered()), this, SLOT(showNormalIfMinimized()));\n-    connect(overviewAction, SIGNAL(triggered()), this, SLOT(gotoOverviewPage()));\n-    connect(sendCoinsAction, SIGNAL(triggered()), this, SLOT(showNormalIfMinimized()));\n-    connect(sendCoinsAction, SIGNAL(triggered()), this, SLOT(gotoSendCoinsPage()));\n-    connect(sendCoinsMenuAction, SIGNAL(triggered()), this, SLOT(showNormalIfMinimized()));\n-    connect(sendCoinsMenuAction, SIGNAL(triggered()), this, SLOT(gotoSendCoinsPage()));\n-    connect(receiveCoinsAction, SIGNAL(triggered()), this, SLOT(showNormalIfMinimized()));\n-    connect(receiveCoinsAction, SIGNAL(triggered()), this, SLOT(gotoReceiveCoinsPage()));\n-    connect(receiveCoinsMenuAction, SIGNAL(triggered()), this, SLOT(showNormalIfMinimized()));\n-    connect(receiveCoinsMenuAction, SIGNAL(triggered()), this, SLOT(gotoReceiveCoinsPage()));\n-    connect(historyAction, SIGNAL(triggered()), this, SLOT(showNormalIfMinimized()));\n-    connect(historyAction, SIGNAL(triggered()), this, SLOT(gotoHistoryPage()));\n-#endif // ENABLE_WALLET\n-\n-    quitAction = new QAction(platformStyle->TextColorIcon(\":/icons/quit\"), tr(\"E&xit\"), this);\n-    quitAction->setStatusTip(tr(\"Quit application\"));\n-    quitAction->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_Q));\n-    quitAction->setMenuRole(QAction::QuitRole);\n-    aboutAction = new QAction(platformStyle->TextColorIcon(\":/icons/about\"), tr(\"&About %1\").arg(tr(PACKAGE_NAME)), this);\n-    aboutAction->setStatusTip(tr(\"Show information about %1\").arg(tr(PACKAGE_NAME)));\n-    aboutAction->setMenuRole(QAction::AboutRole);\n-    aboutAction->setEnabled(false);\n-    aboutQtAction = new QAction(platformStyle->TextColorIcon(\":/icons/about_qt\"), tr(\"About &Qt\"), this);\n-    aboutQtAction->setStatusTip(tr(\"Show information about Qt\"));\n-    aboutQtAction->setMenuRole(QAction::AboutQtRole);\n-    optionsAction = new QAction(platformStyle->TextColorIcon(\":/icons/options\"), tr(\"&Options...\"), this);\n-    optionsAction->setStatusTip(tr(\"Modify configuration options for %1\").arg(tr(PACKAGE_NAME)));\n-    optionsAction->setMenuRole(QAction::PreferencesRole);\n-    optionsAction->setEnabled(false);\n-    toggleHideAction = new QAction(platformStyle->TextColorIcon(\":/icons/about\"), tr(\"&Show / Hide\"), this);\n-    toggleHideAction->setStatusTip(tr(\"Show or hide the main Window\"));\n-\n-    encryptWalletAction = new QAction(platformStyle->TextColorIcon(\":/icons/lock_closed\"), tr(\"&Encrypt Wallet...\"), this);\n-    encryptWalletAction->setStatusTip(tr(\"Encrypt the private keys that belong to your wallet\"));\n-    encryptWalletAction->setCheckable(true);\n-    backupWalletAction = new QAction(platformStyle->TextColorIcon(\":/icons/filesave\"), tr(\"&Backup Wallet...\"), this);\n-    backupWalletAction->setStatusTip(tr(\"Backup wallet to another location\"));\n-    changePassphraseAction = new QAction(platformStyle->TextColorIcon(\":/icons/key\"), tr(\"&Change Passphrase...\"), this);\n-    changePassphraseAction->setStatusTip(tr(\"Change the passphrase used for wallet encryption\"));\n-    signMessageAction = new QAction(platformStyle->TextColorIcon(\":/icons/edit\"), tr(\"Sign &message...\"), this);\n-    signMessageAction->setStatusTip(tr(\"Sign messages with your Bitcoin addresses to prove you own them\"));\n-    verifyMessageAction = new QAction(platformStyle->TextColorIcon(\":/icons/verify\"), tr(\"&Verify message...\"), this);\n-    verifyMessageAction->setStatusTip(tr(\"Verify messages to ensure they were signed with specified Bitcoin addresses\"));\n-\n-    openRPCConsoleAction = new QAction(platformStyle->TextColorIcon(\":/icons/debugwindow\"), tr(\"&Debug window\"), this);\n-    openRPCConsoleAction->setStatusTip(tr(\"Open debugging and diagnostic console\"));\n-    // initially disable the debug window menu item\n-    openRPCConsoleAction->setEnabled(false);\n-\n-    usedSendingAddressesAction = new QAction(platformStyle->TextColorIcon(\":/icons/address-book\"), tr(\"&Sending addresses...\"), this);\n-    usedSendingAddressesAction->setStatusTip(tr(\"Show the list of used sending addresses and labels\"));\n-    usedReceivingAddressesAction = new QAction(platformStyle->TextColorIcon(\":/icons/address-book\"), tr(\"&Receiving addresses...\"), this);\n-    usedReceivingAddressesAction->setStatusTip(tr(\"Show the list of used receiving addresses and labels\"));\n-\n-    openAction = new QAction(platformStyle->TextColorIcon(\":/icons/open\"), tr(\"Open &URI...\"), this);\n-    openAction->setStatusTip(tr(\"Open a bitcoin: URI or payment request\"));\n-\n-    showHelpMessageAction = new QAction(platformStyle->TextColorIcon(\":/icons/info\"), tr(\"&Command-line options\"), this);\n-    showHelpMessageAction->setMenuRole(QAction::NoRole);\n-    showHelpMessageAction->setStatusTip(tr(\"Show the %1 help message to get a list with possible Bitcoin command-line options\").arg(tr(PACKAGE_NAME)));\n-\n-    connect(quitAction, SIGNAL(triggered()), qApp, SLOT(quit()));\n-    connect(aboutAction, SIGNAL(triggered()), this, SLOT(aboutClicked()));\n-    connect(aboutQtAction, SIGNAL(triggered()), qApp, SLOT(aboutQt()));\n-    connect(optionsAction, SIGNAL(triggered()), this, SLOT(optionsClicked()));\n-    connect(toggleHideAction, SIGNAL(triggered()), this, SLOT(toggleHidden()));\n-    connect(showHelpMessageAction, SIGNAL(triggered()), this, SLOT(showHelpMessageClicked()));\n-    connect(openRPCConsoleAction, SIGNAL(triggered()), this, SLOT(showDebugWindow()));\n-    // prevents an open debug window from becoming stuck/unusable on client shutdown\n-    connect(quitAction, SIGNAL(triggered()), rpcConsole, SLOT(hide()));\n-\n-#ifdef ENABLE_WALLET\n-    if(walletFrame)\n-    {\n-        connect(encryptWalletAction, SIGNAL(triggered(bool)), walletFrame, SLOT(encryptWallet(bool)));\n-        connect(backupWalletAction, SIGNAL(triggered()), walletFrame, SLOT(backupWallet()));\n-        connect(changePassphraseAction, SIGNAL(triggered()), walletFrame, SLOT(changePassphrase()));\n-        connect(signMessageAction, SIGNAL(triggered()), this, SLOT(gotoSignMessageTab()));\n-        connect(verifyMessageAction, SIGNAL(triggered()), this, SLOT(gotoVerifyMessageTab()));\n-        connect(usedSendingAddressesAction, SIGNAL(triggered()), walletFrame, SLOT(usedSendingAddresses()));\n-        connect(usedReceivingAddressesAction, SIGNAL(triggered()), walletFrame, SLOT(usedReceivingAddresses()));\n-        connect(openAction, SIGNAL(triggered()), this, SLOT(openClicked()));\n-    }\n-#endif // ENABLE_WALLET\n-\n-    new QShortcut(QKeySequence(Qt::CTRL + Qt::SHIFT + Qt::Key_C), this, SLOT(showDebugWindowActivateConsole()));\n-    new QShortcut(QKeySequence(Qt::CTRL + Qt::SHIFT + Qt::Key_D), this, SLOT(showDebugWindow()));\n-}\n-\n-void BitcoinGUI::createMenuBar()\n-{\n-#ifdef Q_OS_MAC\n-    // Create a decoupled menu bar on Mac which stays even if the window is closed\n-    appMenuBar = new QMenuBar();\n-#else\n-    // Get the main window's menu bar on other platforms\n-    appMenuBar = menuBar();\n-#endif\n-\n-    // Configure the menus\n-    QMenu *file = appMenuBar->addMenu(tr(\"&File\"));\n-    if(walletFrame)\n-    {\n-        file->addAction(openAction);\n-        file->addAction(backupWalletAction);\n-        file->addAction(signMessageAction);\n-        file->addAction(verifyMessageAction);\n-        file->addSeparator();\n-        file->addAction(usedSendingAddressesAction);\n-        file->addAction(usedReceivingAddressesAction);\n-        file->addSeparator();\n-    }\n-    file->addAction(quitAction);\n-\n-    QMenu *settings = appMenuBar->addMenu(tr(\"&Settings\"));\n-    if(walletFrame)\n-    {\n-        settings->addAction(encryptWalletAction);\n-        settings->addAction(changePassphraseAction);\n-        settings->addSeparator();\n-    }\n-    settings->addAction(optionsAction);\n-\n-    QMenu *help = appMenuBar->addMenu(tr(\"&Help\"));\n-    if(walletFrame)\n-    {\n-        help->addAction(openRPCConsoleAction);\n-    }\n-    help->addAction(showHelpMessageAction);\n-    help->addSeparator();\n-    help->addAction(aboutAction);\n-    help->addAction(aboutQtAction);\n-}\n-\n-void BitcoinGUI::createToolBars()\n-{\n-    if(walletFrame)\n-    {\n-        QToolBar *toolbar = addToolBar(tr(\"Tabs toolbar\"));\n-        toolbar->setContextMenuPolicy(Qt::PreventContextMenu);\n-        toolbar->setMovable(false);\n-        toolbar->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);\n-        toolbar->addAction(overviewAction);\n-        toolbar->addAction(sendCoinsAction);\n-        toolbar->addAction(receiveCoinsAction);\n-        toolbar->addAction(historyAction);\n-        overviewAction->setChecked(true);\n-    }\n-}\n-\n-void BitcoinGUI::setClientModel(ClientModel *_clientModel)\n-{\n-    this->clientModel = _clientModel;\n-    if(_clientModel)\n-    {\n-        // Create system tray menu (or setup the dock menu) that late to prevent users from calling actions,\n-        // while the client has not yet fully loaded\n-        createTrayIconMenu();\n-\n-        // Keep up to date with client\n-        updateNetworkState();\n-        connect(_clientModel, SIGNAL(numConnectionsChanged(int)), this, SLOT(setNumConnections(int)));\n-        connect(_clientModel, SIGNAL(networkActiveChanged(bool)), this, SLOT(setNetworkActive(bool)));\n-\n-        modalOverlay->setKnownBestHeight(_clientModel->getHeaderTipHeight(), QDateTime::fromTime_t(_clientModel->getHeaderTipTime()));\n-        setNumBlocks(_clientModel->getNumBlocks(), _clientModel->getLastBlockDate(), _clientModel->getVerificationProgress(nullptr), false);\n-        connect(_clientModel, SIGNAL(numBlocksChanged(int,QDateTime,double,bool)), this, SLOT(setNumBlocks(int,QDateTime,double,bool)));\n-\n-        // Receive and report messages from client model\n-        connect(_clientModel, SIGNAL(message(QString,QString,unsigned int)), this, SLOT(message(QString,QString,unsigned int)));\n-\n-        // Show progress dialog\n-        connect(_clientModel, SIGNAL(showProgress(QString,int)), this, SLOT(showProgress(QString,int)));\n-\n-        rpcConsole->setClientModel(_clientModel);\n-#ifdef ENABLE_WALLET\n-        if(walletFrame)\n-        {\n-            walletFrame->setClientModel(_clientModel);\n-        }\n-#endif // ENABLE_WALLET\n-        unitDisplayControl->setOptionsModel(_clientModel->getOptionsModel());\n-        \n-        OptionsModel* optionsModel = _clientModel->getOptionsModel();\n-        if(optionsModel)\n-        {\n-            // be aware of the tray icon disable state change reported by the OptionsModel object.\n-            connect(optionsModel,SIGNAL(hideTrayIconChanged(bool)),this,SLOT(setTrayIconVisible(bool)));\n-        \n-            // initialize the disable state of the tray icon with the current value in the model.\n-            setTrayIconVisible(optionsModel->getHideTrayIcon());\n-        }\n-    } else {\n-        // Disable possibility to show main window via action\n-        toggleHideAction->setEnabled(false);\n-        if(trayIconMenu)\n-        {\n-            // Disable context menu on tray icon\n-            trayIconMenu->clear();\n-        }\n-        // Propagate cleared model to child objects\n-        rpcConsole->setClientModel(nullptr);\n-#ifdef ENABLE_WALLET\n-        if (walletFrame)\n-        {\n-            walletFrame->setClientModel(nullptr);\n-        }\n-#endif // ENABLE_WALLET\n-        unitDisplayControl->setOptionsModel(nullptr);\n-    }\n-}\n-\n-#ifdef ENABLE_WALLET\n-bool BitcoinGUI::addWallet(const QString& name, WalletModel *walletModel)\n-{\n-    if(!walletFrame)\n-        return false;\n-    setWalletActionsEnabled(true);\n-    return walletFrame->addWallet(name, walletModel);\n-}\n-\n-bool BitcoinGUI::setCurrentWallet(const QString& name)\n-{\n-    if(!walletFrame)\n-        return false;\n-    return walletFrame->setCurrentWallet(name);\n-}\n-\n-void BitcoinGUI::removeAllWallets()\n-{\n-    if(!walletFrame)\n-        return;\n-    setWalletActionsEnabled(false);\n-    walletFrame->removeAllWallets();\n-}\n-#endif // ENABLE_WALLET\n-\n-void BitcoinGUI::setWalletActionsEnabled(bool enabled)\n-{\n-    overviewAction->setEnabled(enabled);\n-    sendCoinsAction->setEnabled(enabled);\n-    sendCoinsMenuAction->setEnabled(enabled);\n-    receiveCoinsAction->setEnabled(enabled);\n-    receiveCoinsMenuAction->setEnabled(enabled);\n-    historyAction->setEnabled(enabled);\n-    encryptWalletAction->setEnabled(enabled);\n-    backupWalletAction->setEnabled(enabled);\n-    changePassphraseAction->setEnabled(enabled);\n-    signMessageAction->setEnabled(enabled);\n-    verifyMessageAction->setEnabled(enabled);\n-    usedSendingAddressesAction->setEnabled(enabled);\n-    usedReceivingAddressesAction->setEnabled(enabled);\n-    openAction->setEnabled(enabled);\n-}\n-\n-void BitcoinGUI::createTrayIcon(const NetworkStyle *networkStyle)\n-{\n-#ifndef Q_OS_MAC\n-    trayIcon = new QSystemTrayIcon(this);\n-    QString toolTip = tr(\"%1 client\").arg(tr(PACKAGE_NAME)) + \" \" + networkStyle->getTitleAddText();\n-    trayIcon->setToolTip(toolTip);\n-    trayIcon->setIcon(networkStyle->getTrayAndWindowIcon());\n-    trayIcon->hide();\n-#endif\n-\n-    notificator = new Notificator(QApplication::applicationName(), trayIcon, this);\n-}\n-\n-void BitcoinGUI::createTrayIconMenu()\n-{\n-#ifndef Q_OS_MAC\n-    // return if trayIcon is unset (only on non-Mac OSes)\n-    if (!trayIcon)\n-        return;\n-\n-    trayIconMenu = new QMenu(this);\n-    trayIcon->setContextMenu(trayIconMenu);\n-\n-    connect(trayIcon, SIGNAL(activated(QSystemTrayIcon::ActivationReason)),\n-            this, SLOT(trayIconActivated(QSystemTrayIcon::ActivationReason)));\n-#else\n-    // Note: On Mac, the dock icon is used to provide the tray's functionality.\n-    MacDockIconHandler *dockIconHandler = MacDockIconHandler::instance();\n-    dockIconHandler->setMainWindow((QMainWindow *)this);\n-    trayIconMenu = dockIconHandler->dockMenu();\n-#endif\n-\n-    // Configuration of the tray icon (or dock icon) icon menu\n-    trayIconMenu->addAction(toggleHideAction);\n-    trayIconMenu->addSeparator();\n-    trayIconMenu->addAction(sendCoinsMenuAction);\n-    trayIconMenu->addAction(receiveCoinsMenuAction);\n-    trayIconMenu->addSeparator();\n-    trayIconMenu->addAction(signMessageAction);\n-    trayIconMenu->addAction(verifyMessageAction);\n-    trayIconMenu->addSeparator();\n-    trayIconMenu->addAction(optionsAction);\n-    trayIconMenu->addAction(openRPCConsoleAction);\n-#ifndef Q_OS_MAC // This is built-in on Mac\n-    trayIconMenu->addSeparator();\n-    trayIconMenu->addAction(quitAction);\n-#endif\n-}\n-\n-#ifndef Q_OS_MAC\n-void BitcoinGUI::trayIconActivated(QSystemTrayIcon::ActivationReason reason)\n-{\n-    if(reason == QSystemTrayIcon::Trigger)\n-    {\n-        // Click on system tray icon triggers show/hide of the main window\n-        toggleHidden();\n-    }\n-}\n-#endif\n-\n-void BitcoinGUI::optionsClicked()\n-{\n-    if(!clientModel || !clientModel->getOptionsModel())\n-        return;\n-\n-    OptionsDialog dlg(this, enableWallet);\n-    dlg.setModel(clientModel->getOptionsModel());\n-    dlg.exec();\n-}\n-\n-void BitcoinGUI::aboutClicked()\n-{\n-    if(!clientModel)\n-        return;\n-\n-    HelpMessageDialog dlg(this, true);\n-    dlg.exec();\n-}\n-\n-void BitcoinGUI::showDebugWindow()\n-{\n-    rpcConsole->showNormal();\n-    rpcConsole->show();\n-    rpcConsole->raise();\n-    rpcConsole->activateWindow();\n-}\n-\n-void BitcoinGUI::showDebugWindowActivateConsole()\n-{\n-    rpcConsole->setTabFocus(RPCConsole::TAB_CONSOLE);\n-    showDebugWindow();\n-}\n-\n-void BitcoinGUI::showHelpMessageClicked()\n-{\n-    helpMessageDialog->show();\n-}\n-\n-#ifdef ENABLE_WALLET\n-void BitcoinGUI::openClicked()\n-{\n-    OpenURIDialog dlg(this);\n-    if(dlg.exec())\n-    {\n-        Q_EMIT receivedURI(dlg.getURI());\n-    }\n-}\n-\n-void BitcoinGUI::gotoOverviewPage()\n-{\n-    overviewAction->setChecked(true);\n-    if (walletFrame) walletFrame->gotoOverviewPage();\n-}\n-\n-void BitcoinGUI::gotoHistoryPage()\n-{\n-    historyAction->setChecked(true);\n-    if (walletFrame) walletFrame->gotoHistoryPage();\n-}\n-\n-void BitcoinGUI::gotoReceiveCoinsPage()\n-{\n-    receiveCoinsAction->setChecked(true);\n-    if (walletFrame) walletFrame->gotoReceiveCoinsPage();\n-}\n-\n-void BitcoinGUI::gotoSendCoinsPage(QString addr)\n-{\n-    sendCoinsAction->setChecked(true);\n-    if (walletFrame) walletFrame->gotoSendCoinsPage(addr);\n-}\n-\n-void BitcoinGUI::gotoSignMessageTab(QString addr)\n-{\n-    if (walletFrame) walletFrame->gotoSignMessageTab(addr);\n-}\n-\n-void BitcoinGUI::gotoVerifyMessageTab(QString addr)\n-{\n-    if (walletFrame) walletFrame->gotoVerifyMessageTab(addr);\n-}\n-#endif // ENABLE_WALLET\n-\n-void BitcoinGUI::updateNetworkState()\n-{\n-    int count = clientModel->getNumConnections();\n-    QString icon;\n-    switch(count)\n-    {\n-    case 0: icon = \":/icons/connect_0\"; break;\n-    case 1: case 2: case 3: icon = \":/icons/connect_1\"; break;\n-    case 4: case 5: case 6: icon = \":/icons/connect_2\"; break;\n-    case 7: case 8: case 9: icon = \":/icons/connect_3\"; break;\n-    default: icon = \":/icons/connect_4\"; break;\n-    }\n-\n-    QString tooltip;\n-\n-    if (clientModel->getNetworkActive()) {\n-        tooltip = tr(\"%n active connection(s) to Bitcoin network\", \"\", count) + QString(\".<br>\") + tr(\"Click to disable network activity.\");\n-    } else {\n-        tooltip = tr(\"Network activity disabled.\") + QString(\"<br>\") + tr(\"Click to enable network activity again.\");\n-        icon = \":/icons/network_disabled\";\n-    }\n-\n-    // Don't word-wrap this (fixed-width) tooltip\n-    tooltip = QString(\"<nobr>\") + tooltip + QString(\"</nobr>\");\n-    connectionsControl->setToolTip(tooltip);\n-\n-    connectionsControl->setPixmap(platformStyle->SingleColorIcon(icon).pixmap(STATUSBAR_ICONSIZE,STATUSBAR_ICONSIZE));\n-}\n-\n-void BitcoinGUI::setNumConnections(int count)\n-{\n-    updateNetworkState();\n-}\n-\n-void BitcoinGUI::setNetworkActive(bool networkActive)\n-{\n-    updateNetworkState();\n-}\n-\n-void BitcoinGUI::updateHeadersSyncProgressLabel()\n-{\n-    int64_t headersTipTime = clientModel->getHeaderTipTime();\n-    int headersTipHeight = clientModel->getHeaderTipHeight();\n-    int estHeadersLeft = (GetTime() - headersTipTime) / Params().GetConsensus().nPowTargetSpacing;\n-    if (estHeadersLeft > HEADER_HEIGHT_DELTA_SYNC)\n-        progressBarLabel->setText(tr(\"Syncing Headers (%1%)...\").arg(QString::number(100.0 / (headersTipHeight+estHeadersLeft)*headersTipHeight, 'f', 1)));\n-}\n-\n-void BitcoinGUI::setNumBlocks(int count, const QDateTime& blockDate, double nVerificationProgress, bool header)\n-{\n-    if (modalOverlay)\n-    {\n-        if (header)\n-            modalOverlay->setKnownBestHeight(count, blockDate);\n-        else\n-            modalOverlay->tipUpdate(count, blockDate, nVerificationProgress);\n-    }\n-    if (!clientModel)\n-        return;\n-\n-    // Prevent orphan statusbar messages (e.g. hover Quit in main menu, wait until chain-sync starts -> garbled text)\n-    statusBar()->clearMessage();\n-\n-    // Acquire current block source\n-    enum BlockSource blockSource = clientModel->getBlockSource();\n-    switch (blockSource) {\n-        case BLOCK_SOURCE_NETWORK:\n-            if (header) {\n-                updateHeadersSyncProgressLabel();\n-                return;\n-            }\n-            progressBarLabel->setText(tr(\"Synchronizing with network...\"));\n-            updateHeadersSyncProgressLabel();\n-            break;\n-        case BLOCK_SOURCE_DISK:\n-            if (header) {\n-                progressBarLabel->setText(tr(\"Indexing blocks on disk...\"));\n-            } else {\n-                progressBarLabel->setText(tr(\"Processing blocks on disk...\"));\n-            }\n-            break;\n-        case BLOCK_SOURCE_REINDEX:\n-            progressBarLabel->setText(tr(\"Reindexing blocks on disk...\"));\n-            break;\n-        case BLOCK_SOURCE_NONE:\n-            if (header) {\n-                return;\n-            }\n-            progressBarLabel->setText(tr(\"Connecting to peers...\"));\n-            break;\n-    }\n-\n-    QString tooltip;\n-\n-    QDateTime currentDate = QDateTime::currentDateTime();\n-    qint64 secs = blockDate.secsTo(currentDate);\n-\n-    tooltip = tr(\"Processed %n block(s) of transaction history.\", \"\", count);\n-\n-    // Set icon state: spinning if catching up, tick otherwise\n-    if(secs < 90*60)\n-    {\n-        tooltip = tr(\"Up to date\") + QString(\".<br>\") + tooltip;\n-        labelBlocksIcon->setPixmap(platformStyle->SingleColorIcon(\":/icons/synced\").pixmap(STATUSBAR_ICONSIZE, STATUSBAR_ICONSIZE));\n-\n-#ifdef ENABLE_WALLET\n-        if(walletFrame)\n-        {\n-            walletFrame->showOutOfSyncWarning(false);\n-            modalOverlay->showHide(true, true);\n-        }\n-#endif // ENABLE_WALLET\n-\n-        progressBarLabel->setVisible(false);\n-        progressBar->setVisible(false);\n-    }\n-    else\n-    {\n-        QString timeBehindText = GUIUtil::formatNiceTimeOffset(secs);\n-\n-        progressBarLabel->setVisible(true);\n-        progressBar->setFormat(tr(\"%1 behind\").arg(timeBehindText));\n-        progressBar->setMaximum(1000000000);\n-        progressBar->setValue(nVerificationProgress * 1000000000.0 + 0.5);\n-        progressBar->setVisible(true);\n-\n-        tooltip = tr(\"Catching up...\") + QString(\"<br>\") + tooltip;\n-        if(count != prevBlocks)\n-        {\n-            labelBlocksIcon->setPixmap(platformStyle->SingleColorIcon(QString(\n-                \":/movies/spinner-%1\").arg(spinnerFrame, 3, 10, QChar('0')))\n-                .pixmap(STATUSBAR_ICONSIZE, STATUSBAR_ICONSIZE));\n-            spinnerFrame = (spinnerFrame + 1) % SPINNER_FRAMES;\n-        }\n-        prevBlocks = count;\n-\n-#ifdef ENABLE_WALLET\n-        if(walletFrame)\n-        {\n-            walletFrame->showOutOfSyncWarning(true);\n-            modalOverlay->showHide();\n-        }\n-#endif // ENABLE_WALLET\n-\n-        tooltip += QString(\"<br>\");\n-        tooltip += tr(\"Last received block was generated %1 ago.\").arg(timeBehindText);\n-        tooltip += QString(\"<br>\");\n-        tooltip += tr(\"Transactions after this will not yet be visible.\");\n-    }\n-\n-    // Don't word-wrap this (fixed-width) tooltip\n-    tooltip = QString(\"<nobr>\") + tooltip + QString(\"</nobr>\");\n-\n-    labelBlocksIcon->setToolTip(tooltip);\n-    progressBarLabel->setToolTip(tooltip);\n-    progressBar->setToolTip(tooltip);\n-}\n-\n-void BitcoinGUI::message(const QString &title, const QString &message, unsigned int style, bool *ret)\n-{\n-    QString strTitle = tr(\"Bitcoin\"); // default title\n-    // Default to information icon\n-    int nMBoxIcon = QMessageBox::Information;\n-    int nNotifyIcon = Notificator::Information;\n-\n-    QString msgType;\n-\n-    // Prefer supplied title over style based title\n-    if (!title.isEmpty()) {\n-        msgType = title;\n-    }\n-    else {\n-        switch (style) {\n-        case CClientUIInterface::MSG_ERROR:\n-            msgType = tr(\"Error\");\n-            break;\n-        case CClientUIInterface::MSG_WARNING:\n-            msgType = tr(\"Warning\");\n-            break;\n-        case CClientUIInterface::MSG_INFORMATION:\n-            msgType = tr(\"Information\");\n-            break;\n-        default:\n-            break;\n-        }\n-    }\n-    // Append title to \"Bitcoin - \"\n-    if (!msgType.isEmpty())\n-        strTitle += \" - \" + msgType;\n-\n-    // Check for error/warning icon\n-    if (style & CClientUIInterface::ICON_ERROR) {\n-        nMBoxIcon = QMessageBox::Critical;\n-        nNotifyIcon = Notificator::Critical;\n-    }\n-    else if (style & CClientUIInterface::ICON_WARNING) {\n-        nMBoxIcon = QMessageBox::Warning;\n-        nNotifyIcon = Notificator::Warning;\n-    }\n-\n-    // Display message\n-    if (style & CClientUIInterface::MODAL) {\n-        // Check for buttons, use OK as default, if none was supplied\n-        QMessageBox::StandardButton buttons;\n-        if (!(buttons = (QMessageBox::StandardButton)(style & CClientUIInterface::BTN_MASK)))\n-            buttons = QMessageBox::Ok;\n-\n-        showNormalIfMinimized();\n-        QMessageBox mBox((QMessageBox::Icon)nMBoxIcon, strTitle, message, buttons, this);\n-        int r = mBox.exec();\n-        if (ret != nullptr)\n-            *ret = r == QMessageBox::Ok;\n-    }\n-    else\n-        notificator->notify((Notificator::Class)nNotifyIcon, strTitle, message);\n-}\n-\n-void BitcoinGUI::changeEvent(QEvent *e)\n-{\n-    QMainWindow::changeEvent(e);\n-#ifndef Q_OS_MAC // Ignored on Mac\n-    if(e->type() == QEvent::WindowStateChange)\n-    {\n-        if(clientModel && clientModel->getOptionsModel() && clientModel->getOptionsModel()->getMinimizeToTray())\n-        {\n-            QWindowStateChangeEvent *wsevt = static_cast<QWindowStateChangeEvent*>(e);\n-            if(!(wsevt->oldState() & Qt::WindowMinimized) && isMinimized())\n-            {\n-                QTimer::singleShot(0, this, SLOT(hide()));\n-                e->ignore();\n-            }\n-        }\n-    }\n-#endif\n-}\n-\n-void BitcoinGUI::closeEvent(QCloseEvent *event)\n-{\n-#ifndef Q_OS_MAC // Ignored on Mac\n-    if(clientModel && clientModel->getOptionsModel())\n-    {\n-        if(!clientModel->getOptionsModel()->getMinimizeOnClose())\n-        {\n-            // close rpcConsole in case it was open to make some space for the shutdown window\n-            rpcConsole->close();\n-\n-            QApplication::quit();\n-        }\n-        else\n-        {\n-            QMainWindow::showMinimized();\n-            event->ignore();\n-        }\n-    }\n-#else\n-    QMainWindow::closeEvent(event);\n-#endif\n-}\n-\n-void BitcoinGUI::showEvent(QShowEvent *event)\n-{\n-    // enable the debug window when the main window shows up\n-    openRPCConsoleAction->setEnabled(true);\n-    aboutAction->setEnabled(true);\n-    optionsAction->setEnabled(true);\n-}\n-\n-#ifdef ENABLE_WALLET\n-void BitcoinGUI::incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label)\n-{\n-    // On new transaction, make an info balloon\n-    QString msg = tr(\"Date: %1\\n\").arg(date) +\n-                  tr(\"Amount: %1\\n\").arg(BitcoinUnits::formatWithUnit(unit, amount, true)) +\n-                  tr(\"Type: %1\\n\").arg(type);\n-    if (!label.isEmpty())\n-        msg += tr(\"Label: %1\\n\").arg(label);\n-    else if (!address.isEmpty())\n-        msg += tr(\"Address: %1\\n\").arg(address);\n-    message((amount)<0 ? tr(\"Sent transaction\") : tr(\"Incoming transaction\"),\n-             msg, CClientUIInterface::MSG_INFORMATION);\n-}\n-#endif // ENABLE_WALLET\n-\n-void BitcoinGUI::dragEnterEvent(QDragEnterEvent *event)\n-{\n-    // Accept only URIs\n-    if(event->mimeData()->hasUrls())\n-        event->acceptProposedAction();\n-}\n-\n-void BitcoinGUI::dropEvent(QDropEvent *event)\n-{\n-    if(event->mimeData()->hasUrls())\n-    {\n-        for (const QUrl &uri : event->mimeData()->urls())\n-        {\n-            Q_EMIT receivedURI(uri.toString());\n-        }\n-    }\n-    event->acceptProposedAction();\n-}\n-\n-bool BitcoinGUI::eventFilter(QObject *object, QEvent *event)\n-{\n-    // Catch status tip events\n-    if (event->type() == QEvent::StatusTip)\n-    {\n-        // Prevent adding text from setStatusTip(), if we currently use the status bar for displaying other stuff\n-        if (progressBarLabel->isVisible() || progressBar->isVisible())\n-            return true;\n-    }\n-    return QMainWindow::eventFilter(object, event);\n-}\n-\n-#ifdef ENABLE_WALLET\n-bool BitcoinGUI::handlePaymentRequest(const SendCoinsRecipient& recipient)\n-{\n-    // URI has to be valid\n-    if (walletFrame && walletFrame->handlePaymentRequest(recipient))\n-    {\n-        showNormalIfMinimized();\n-        gotoSendCoinsPage();\n-        return true;\n-    }\n-    return false;\n-}\n-\n-void BitcoinGUI::setHDStatus(int hdEnabled)\n-{\n-    labelWalletHDStatusIcon->setPixmap(platformStyle->SingleColorIcon(hdEnabled ? \":/icons/hd_enabled\" : \":/icons/hd_disabled\").pixmap(STATUSBAR_ICONSIZE,STATUSBAR_ICONSIZE));\n-    labelWalletHDStatusIcon->setToolTip(hdEnabled ? tr(\"HD key generation is <b>enabled</b>\") : tr(\"HD key generation is <b>disabled</b>\"));\n-\n-    // eventually disable the QLabel to set its opacity to 50% \n-    labelWalletHDStatusIcon->setEnabled(hdEnabled);\n-}\n-\n-void BitcoinGUI::setEncryptionStatus(int status)\n-{\n-    switch(status)\n-    {\n-    case WalletModel::Unencrypted:\n-        labelWalletEncryptionIcon->hide();\n-        encryptWalletAction->setChecked(false);\n-        changePassphraseAction->setEnabled(false);\n-        encryptWalletAction->setEnabled(true);\n-        break;\n-    case WalletModel::Unlocked:\n-        labelWalletEncryptionIcon->show();\n-        labelWalletEncryptionIcon->setPixmap(platformStyle->SingleColorIcon(\":/icons/lock_open\").pixmap(STATUSBAR_ICONSIZE,STATUSBAR_ICONSIZE));\n-        labelWalletEncryptionIcon->setToolTip(tr(\"Wallet is <b>encrypted</b> and currently <b>unlocked</b>\"));\n-        encryptWalletAction->setChecked(true);\n-        changePassphraseAction->setEnabled(true);\n-        encryptWalletAction->setEnabled(false); // TODO: decrypt currently not supported\n-        break;\n-    case WalletModel::Locked:\n-        labelWalletEncryptionIcon->show();\n-        labelWalletEncryptionIcon->setPixmap(platformStyle->SingleColorIcon(\":/icons/lock_closed\").pixmap(STATUSBAR_ICONSIZE,STATUSBAR_ICONSIZE));\n-        labelWalletEncryptionIcon->setToolTip(tr(\"Wallet is <b>encrypted</b> and currently <b>locked</b>\"));\n-        encryptWalletAction->setChecked(true);\n-        changePassphraseAction->setEnabled(true);\n-        encryptWalletAction->setEnabled(false); // TODO: decrypt currently not supported\n-        break;\n-    }\n-}\n-#endif // ENABLE_WALLET\n-\n-void BitcoinGUI::showNormalIfMinimized(bool fToggleHidden)\n-{\n-    if(!clientModel)\n-        return;\n-\n-    // activateWindow() (sometimes) helps with keyboard focus on Windows\n-    if (isHidden())\n-    {\n-        show();\n-        activateWindow();\n-    }\n-    else if (isMinimized())\n-    {\n-        showNormal();\n-        activateWindow();\n-    }\n-    else if (GUIUtil::isObscured(this))\n-    {\n-        raise();\n-        activateWindow();\n-    }\n-    else if(fToggleHidden)\n-        hide();\n-}\n-\n-void BitcoinGUI::toggleHidden()\n-{\n-    showNormalIfMinimized(true);\n-}\n-\n-void BitcoinGUI::detectShutdown()\n-{\n-    if (ShutdownRequested())\n-    {\n-        if(rpcConsole)\n-            rpcConsole->hide();\n-        qApp->quit();\n-    }\n-}\n-\n-void BitcoinGUI::showProgress(const QString &title, int nProgress)\n-{\n-    if (nProgress == 0)\n-    {\n-        progressDialog = new QProgressDialog(title, \"\", 0, 100);\n-        progressDialog->setWindowModality(Qt::ApplicationModal);\n-        progressDialog->setMinimumDuration(0);\n-        progressDialog->setCancelButton(0);\n-        progressDialog->setAutoClose(false);\n-        progressDialog->setValue(0);\n-    }\n-    else if (nProgress == 100)\n-    {\n-        if (progressDialog)\n-        {\n-            progressDialog->close();\n-            progressDialog->deleteLater();\n-        }\n-    }\n-    else if (progressDialog)\n-        progressDialog->setValue(nProgress);\n-}\n-\n-void BitcoinGUI::setTrayIconVisible(bool fHideTrayIcon)\n-{\n-    if (trayIcon)\n-    {\n-        trayIcon->setVisible(!fHideTrayIcon);\n-    }\n-}\n-\n-void BitcoinGUI::showModalOverlay()\n-{\n-    if (modalOverlay && (progressBar->isVisible() || modalOverlay->isLayerVisible()))\n-        modalOverlay->toggleVisibility();\n-}\n-\n-static bool ThreadSafeMessageBox(BitcoinGUI *gui, const std::string& message, const std::string& caption, unsigned int style)\n-{\n-    bool modal = (style & CClientUIInterface::MODAL);\n-    // The SECURE flag has no effect in the Qt GUI.\n-    // bool secure = (style & CClientUIInterface::SECURE);\n-    style &= ~CClientUIInterface::SECURE;\n-    bool ret = false;\n-    // In case of modal message, use blocking connection to wait for user to click a button\n-    QMetaObject::invokeMethod(gui, \"message\",\n-                               modal ? GUIUtil::blockingGUIThreadConnection() : Qt::QueuedConnection,\n-                               Q_ARG(QString, QString::fromStdString(caption)),\n-                               Q_ARG(QString, QString::fromStdString(message)),\n-                               Q_ARG(unsigned int, style),\n-                               Q_ARG(bool*, &ret));\n-    return ret;\n-}\n-\n-void BitcoinGUI::subscribeToCoreSignals()\n-{\n-    // Connect signals to client\n-    uiInterface.ThreadSafeMessageBox.connect(boost::bind(ThreadSafeMessageBox, this, _1, _2, _3));\n-    uiInterface.ThreadSafeQuestion.connect(boost::bind(ThreadSafeMessageBox, this, _1, _3, _4));\n-}\n-\n-void BitcoinGUI::unsubscribeFromCoreSignals()\n-{\n-    // Disconnect signals from client\n-    uiInterface.ThreadSafeMessageBox.disconnect(boost::bind(ThreadSafeMessageBox, this, _1, _2, _3));\n-    uiInterface.ThreadSafeQuestion.disconnect(boost::bind(ThreadSafeMessageBox, this, _1, _3, _4));\n-}\n-\n-void BitcoinGUI::toggleNetworkActive()\n-{\n-    if (clientModel) {\n-        clientModel->setNetworkActive(!clientModel->getNetworkActive());\n-    }\n-}\n-\n-UnitDisplayStatusBarControl::UnitDisplayStatusBarControl(const PlatformStyle *platformStyle) :\n-    optionsModel(0),\n-    menu(0)\n-{\n-    createContextMenu();\n-    setToolTip(tr(\"Unit to show amounts in. Click to select another unit.\"));\n-    QList<BitcoinUnits::Unit> units = BitcoinUnits::availableUnits();\n-    int max_width = 0;\n-    const QFontMetrics fm(font());\n-    for (const BitcoinUnits::Unit unit : units)\n-    {\n-        max_width = qMax(max_width, fm.width(BitcoinUnits::name(unit)));\n-    }\n-    setMinimumSize(max_width, 0);\n-    setAlignment(Qt::AlignRight | Qt::AlignVCenter);\n-    setStyleSheet(QString(\"QLabel { color : %1 }\").arg(platformStyle->SingleColor().name()));\n-}\n-\n-/** So that it responds to button clicks */\n-void UnitDisplayStatusBarControl::mousePressEvent(QMouseEvent *event)\n-{\n-    onDisplayUnitsClicked(event->pos());\n-}\n-\n-/** Creates context menu, its actions, and wires up all the relevant signals for mouse events. */\n-void UnitDisplayStatusBarControl::createContextMenu()\n-{\n-    menu = new QMenu(this);\n-    for (BitcoinUnits::Unit u : BitcoinUnits::availableUnits())\n-    {\n-        QAction *menuAction = new QAction(QString(BitcoinUnits::name(u)), this);\n-        menuAction->setData(QVariant(u));\n-        menu->addAction(menuAction);\n-    }\n-    connect(menu,SIGNAL(triggered(QAction*)),this,SLOT(onMenuSelection(QAction*)));\n-}\n-\n-/** Lets the control know about the Options Model (and its signals) */\n-void UnitDisplayStatusBarControl::setOptionsModel(OptionsModel *_optionsModel)\n-{\n-    if (_optionsModel)\n-    {\n-        this->optionsModel = _optionsModel;\n-\n-        // be aware of a display unit change reported by the OptionsModel object.\n-        connect(_optionsModel,SIGNAL(displayUnitChanged(int)),this,SLOT(updateDisplayUnit(int)));\n-\n-        // initialize the display units label with the current value in the model.\n-        updateDisplayUnit(_optionsModel->getDisplayUnit());\n-    }\n-}\n-\n-/** When Display Units are changed on OptionsModel it will refresh the display text of the control on the status bar */\n-void UnitDisplayStatusBarControl::updateDisplayUnit(int newUnits)\n-{\n-    setText(BitcoinUnits::name(newUnits));\n-}\n-\n-/** Shows context menu with Display Unit options by the mouse coordinates */\n-void UnitDisplayStatusBarControl::onDisplayUnitsClicked(const QPoint& point)\n-{\n-    QPoint globalPos = mapToGlobal(point);\n-    menu->exec(globalPos);\n-}\n-\n-/** Tells underlying optionsModel to update its current display unit. */\n-void UnitDisplayStatusBarControl::onMenuSelection(QAction* action)\n-{\n-    if (action)\n-    {\n-        optionsModel->setDisplayUnit(action->data());\n-    }\n-}\n+// Copyright (c) 2011-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <qt/bitcoingui.h>\r\n+\r\n+#include <qt/bitcoinunits.h>\r\n+#include <qt/clientmodel.h>\r\n+#include <qt/guiconstants.h>\r\n+#include <qt/guiutil.h>\r\n+#include <qt/modaloverlay.h>\r\n+#include <qt/networkstyle.h>\r\n+#include <qt/notificator.h>\r\n+#include <qt/openuridialog.h>\r\n+#include <qt/optionsdialog.h>\r\n+#include <qt/optionsmodel.h>\r\n+#include <qt/platformstyle.h>\r\n+#include <qt/rpcconsole.h>\r\n+#include <qt/utilitydialog.h>\r\n+\r\n+#ifdef ENABLE_WALLET\r\n+#include <qt/walletframe.h>\r\n+#include <qt/walletmodel.h>\r\n+#endif // ENABLE_WALLET\r\n+\r\n+#ifdef Q_OS_MAC\r\n+#include <qt/macdockiconhandler.h>\r\n+#endif\r\n+\r\n+#include <chainparams.h>\r\n+#include <init.h>\r\n+#include <ui_interface.h>\r\n+#include <util.h>\r\n+\r\n+#include <iostream>\r\n+\r\n+#include <QAction>\r\n+#include <QApplication>\r\n+#include <QDateTime>\r\n+#include <QDesktopWidget>\r\n+#include <QDragEnterEvent>\r\n+#include <QListWidget>\r\n+#include <QMenuBar>\r\n+#include <QMessageBox>\r\n+#include <QMimeData>\r\n+#include <QProgressDialog>\r\n+#include <QSettings>\r\n+#include <QShortcut>\r\n+#include <QStackedWidget>\r\n+#include <QStatusBar>\r\n+#include <QStyle>\r\n+#include <QTimer>\r\n+#include <QToolBar>\r\n+#include <QVBoxLayout>\r\n+\r\n+#if QT_VERSION < 0x050000\r\n+#include <QTextDocument>\r\n+#include <QUrl>\r\n+#else\r\n+#include <QUrlQuery>\r\n+#endif\r\n+\r\n+const std::string BitcoinGUI::DEFAULT_UIPLATFORM =\r\n+#if defined(Q_OS_MAC)\r\n+        \"macosx\"\r\n+#elif defined(Q_OS_WIN)\r\n+        \"windows\"\r\n+#else\r\n+        \"other\"\r\n+#endif\r\n+        ;\r\n+\r\n+/** Display name for default wallet name. Uses tilde to avoid name\r\n+ * collisions in the future with additional wallets */\r\n+const QString BitcoinGUI::DEFAULT_WALLET = \"~Default\";\r\n+\r\n+BitcoinGUI::BitcoinGUI(const PlatformStyle *_platformStyle, const NetworkStyle *networkStyle, QWidget *parent) :\r\n+    QMainWindow(parent),\r\n+    enableWallet(false),\r\n+    clientModel(0),\r\n+    walletFrame(0),\r\n+    unitDisplayControl(0),\r\n+    labelWalletEncryptionIcon(0),\r\n+    labelWalletHDStatusIcon(0),\r\n+    connectionsControl(0),\r\n+    labelBlocksIcon(0),\r\n+    progressBarLabel(0),\r\n+    progressBar(0),\r\n+    progressDialog(0),\r\n+    appMenuBar(0),\r\n+    overviewAction(0),\r\n+    historyAction(0),\r\n+    quitAction(0),\r\n+    sendCoinsAction(0),\r\n+    sendCoinsMenuAction(0),\r\n+    usedSendingAddressesAction(0),\r\n+    usedReceivingAddressesAction(0),\r\n+    signMessageAction(0),\r\n+    verifyMessageAction(0),\r\n+    aboutAction(0),\r\n+    receiveCoinsAction(0),\r\n+    receiveCoinsMenuAction(0),\r\n+    optionsAction(0),\r\n+    toggleHideAction(0),\r\n+    encryptWalletAction(0),\r\n+    backupWalletAction(0),\r\n+    changePassphraseAction(0),\r\n+    aboutQtAction(0),\r\n+    openRPCConsoleAction(0),\r\n+    openAction(0),\r\n+    showHelpMessageAction(0),\r\n+    trayIcon(0),\r\n+    trayIconMenu(0),\r\n+    notificator(0),\r\n+    rpcConsole(0),\r\n+    helpMessageDialog(0),\r\n+    modalOverlay(0),\r\n+    prevBlocks(0),\r\n+    spinnerFrame(0),\r\n+    platformStyle(_platformStyle)\r\n+{\r\n+    QSettings settings;\r\n+    if (!restoreGeometry(settings.value(\"MainWindowGeometry\").toByteArray())) {\r\n+        // Restore failed (perhaps missing setting), center the window\r\n+        move(QApplication::desktop()->availableGeometry().center() - frameGeometry().center());\r\n+    }\r\n+\r\n+    QString windowTitle = tr(PACKAGE_NAME) + \" - \";\r\n+#ifdef ENABLE_WALLET\r\n+    enableWallet = WalletModel::isWalletEnabled();\r\n+#endif // ENABLE_WALLET\r\n+    if(enableWallet)\r\n+    {\r\n+        windowTitle += tr(\"Wallet\");\r\n+    } else {\r\n+        windowTitle += tr(\"Node\");\r\n+    }\r\n+    windowTitle += \" \" + networkStyle->getTitleAddText();\r\n+#ifndef Q_OS_MAC\r\n+    QApplication::setWindowIcon(networkStyle->getTrayAndWindowIcon());\r\n+    setWindowIcon(networkStyle->getTrayAndWindowIcon());\r\n+#else\r\n+    MacDockIconHandler::instance()->setIcon(networkStyle->getAppIcon());\r\n+#endif\r\n+    setWindowTitle(windowTitle);\r\n+\r\n+#if defined(Q_OS_MAC) && QT_VERSION < 0x050000\r\n+    // This property is not implemented in Qt 5. Setting it has no effect.\r\n+    // A replacement API (QtMacUnifiedToolBar) is available in QtMacExtras.\r\n+    setUnifiedTitleAndToolBarOnMac(true);\r\n+#endif\r\n+\r\n+    rpcConsole = new RPCConsole(_platformStyle, 0);\r\n+    helpMessageDialog = new HelpMessageDialog(this, false);\r\n+#ifdef ENABLE_WALLET\r\n+    if(enableWallet)\r\n+    {\r\n+        /** Create wallet frame and make it the central widget */\r\n+        walletFrame = new WalletFrame(_platformStyle, this);\r\n+        setCentralWidget(walletFrame);\r\n+    } else\r\n+#endif // ENABLE_WALLET\r\n+    {\r\n+        /* When compiled without wallet or -disablewallet is provided,\r\n+         * the central widget is the rpc console.\r\n+         */\r\n+        setCentralWidget(rpcConsole);\r\n+    }\r\n+\r\n+    // Accept D&D of URIs\r\n+    setAcceptDrops(true);\r\n+\r\n+    // Create actions for the toolbar, menu bar and tray/dock icon\r\n+    // Needs walletFrame to be initialized\r\n+    createActions();\r\n+\r\n+    // Create application menu bar\r\n+    createMenuBar();\r\n+\r\n+    // Create the toolbars\r\n+    createToolBars();\r\n+\r\n+    // Create system tray icon and notification\r\n+    createTrayIcon(networkStyle);\r\n+\r\n+    // Create status bar\r\n+    statusBar();\r\n+\r\n+    // Disable size grip because it looks ugly and nobody needs it\r\n+    statusBar()->setSizeGripEnabled(false);\r\n+\r\n+    // Status bar notification icons\r\n+    QFrame *frameBlocks = new QFrame();\r\n+    frameBlocks->setContentsMargins(0,0,0,0);\r\n+    frameBlocks->setSizePolicy(QSizePolicy::Fixed, QSizePolicy::Preferred);\r\n+    QHBoxLayout *frameBlocksLayout = new QHBoxLayout(frameBlocks);\r\n+    frameBlocksLayout->setContentsMargins(3,0,3,0);\r\n+    frameBlocksLayout->setSpacing(3);\r\n+    unitDisplayControl = new UnitDisplayStatusBarControl(platformStyle);\r\n+    labelWalletEncryptionIcon = new QLabel();\r\n+    labelWalletHDStatusIcon = new QLabel();\r\n+    connectionsControl = new GUIUtil::ClickableLabel();\r\n+    labelBlocksIcon = new GUIUtil::ClickableLabel();\r\n+    if(enableWallet)\r\n+    {\r\n+        frameBlocksLayout->addStretch();\r\n+        frameBlocksLayout->addWidget(unitDisplayControl);\r\n+        frameBlocksLayout->addStretch();\r\n+        frameBlocksLayout->addWidget(labelWalletEncryptionIcon);\r\n+        frameBlocksLayout->addWidget(labelWalletHDStatusIcon);\r\n+    }\r\n+    frameBlocksLayout->addStretch();\r\n+    frameBlocksLayout->addWidget(connectionsControl);\r\n+    frameBlocksLayout->addStretch();\r\n+    frameBlocksLayout->addWidget(labelBlocksIcon);\r\n+    frameBlocksLayout->addStretch();\r\n+\r\n+    // Progress bar and label for blocks download\r\n+    progressBarLabel = new QLabel();\r\n+    progressBarLabel->setVisible(false);\r\n+    progressBar = new GUIUtil::ProgressBar();\r\n+    progressBar->setAlignment(Qt::AlignCenter);\r\n+    progressBar->setVisible(false);\r\n+\r\n+    // Override style sheet for progress bar for styles that have a segmented progress bar,\r\n+    // as they make the text unreadable (workaround for issue #1071)\r\n+    // See https://qt-project.org/doc/qt-4.8/gallery.html\r\n+    QString curStyle = QApplication::style()->metaObject()->className();\r\n+    if(curStyle == \"QWindowsStyle\" || curStyle == \"QWindowsXPStyle\")\r\n+    {\r\n+        progressBar->setStyleSheet(\"QProgressBar { background-color: #e8e8e8; border: 1px solid grey; border-radius: 7px; padding: 1px; text-align: center; } QProgressBar::chunk { background: QLinearGradient(x1: 0, y1: 0, x2: 1, y2: 0, stop: 0 #FF8000, stop: 1 orange); border-radius: 7px; margin: 0px; }\");\r\n+    }\r\n+\r\n+    statusBar()->addWidget(progressBarLabel);\r\n+    statusBar()->addWidget(progressBar);\r\n+    statusBar()->addPermanentWidget(frameBlocks);\r\n+\r\n+    // Install event filter to be able to catch status tip events (QEvent::StatusTip)\r\n+    this->installEventFilter(this);\r\n+\r\n+    // Initially wallet actions should be disabled\r\n+    setWalletActionsEnabled(false);\r\n+\r\n+    // Subscribe to notifications from core\r\n+    subscribeToCoreSignals();\r\n+\r\n+    connect(connectionsControl, SIGNAL(clicked(QPoint)), this, SLOT(toggleNetworkActive()));\r\n+\r\n+    modalOverlay = new ModalOverlay(this->centralWidget());\r\n+#ifdef ENABLE_WALLET\r\n+    if(enableWallet) {\r\n+        connect(walletFrame, SIGNAL(requestedSyncWarningInfo()), this, SLOT(showModalOverlay()));\r\n+        connect(labelBlocksIcon, SIGNAL(clicked(QPoint)), this, SLOT(showModalOverlay()));\r\n+        connect(progressBar, SIGNAL(clicked(QPoint)), this, SLOT(showModalOverlay()));\r\n+    }\r\n+#endif\r\n+}\r\n+\r\n+BitcoinGUI::~BitcoinGUI()\r\n+{\r\n+    // Unsubscribe from notifications from core\r\n+    unsubscribeFromCoreSignals();\r\n+\r\n+    QSettings settings;\r\n+    settings.setValue(\"MainWindowGeometry\", saveGeometry());\r\n+    if(trayIcon) // Hide tray icon, as deleting will let it linger until quit (on Ubuntu)\r\n+        trayIcon->hide();\r\n+#ifdef Q_OS_MAC\r\n+    delete appMenuBar;\r\n+    MacDockIconHandler::cleanup();\r\n+#endif\r\n+\r\n+    delete rpcConsole;\r\n+}\r\n+\r\n+void BitcoinGUI::createActions()\r\n+{\r\n+    QActionGroup *tabGroup = new QActionGroup(this);\r\n+\r\n+    overviewAction = new QAction(platformStyle->SingleColorIcon(\":/icons/overview\"), tr(\"&Overview\"), this);\r\n+    overviewAction->setStatusTip(tr(\"Show general overview of wallet\"));\r\n+    overviewAction->setToolTip(overviewAction->statusTip());\r\n+    overviewAction->setCheckable(true);\r\n+    overviewAction->setShortcut(QKeySequence(Qt::ALT + Qt::Key_1));\r\n+    tabGroup->addAction(overviewAction);\r\n+\r\n+    sendCoinsAction = new QAction(platformStyle->SingleColorIcon(\":/icons/send\"), tr(\"&Send\"), this);\r\n+    sendCoinsAction->setStatusTip(tr(\"Send coins to a Bitcoin address\"));\r\n+    sendCoinsAction->setToolTip(sendCoinsAction->statusTip());\r\n+    sendCoinsAction->setCheckable(true);\r\n+    sendCoinsAction->setShortcut(QKeySequence(Qt::ALT + Qt::Key_2));\r\n+    tabGroup->addAction(sendCoinsAction);\r\n+\r\n+    sendCoinsMenuAction = new QAction(platformStyle->TextColorIcon(\":/icons/send\"), sendCoinsAction->text(), this);\r\n+    sendCoinsMenuAction->setStatusTip(sendCoinsAction->statusTip());\r\n+    sendCoinsMenuAction->setToolTip(sendCoinsMenuAction->statusTip());\r\n+\r\n+    receiveCoinsAction = new QAction(platformStyle->SingleColorIcon(\":/icons/receiving_addresses\"), tr(\"&Receive\"), this);\r\n+    receiveCoinsAction->setStatusTip(tr(\"Request payments (generates QR codes and bitcoin: URIs)\"));\r\n+    receiveCoinsAction->setToolTip(receiveCoinsAction->statusTip());\r\n+    receiveCoinsAction->setCheckable(true);\r\n+    receiveCoinsAction->setShortcut(QKeySequence(Qt::ALT + Qt::Key_3));\r\n+    tabGroup->addAction(receiveCoinsAction);\r\n+\r\n+    receiveCoinsMenuAction = new QAction(platformStyle->TextColorIcon(\":/icons/receiving_addresses\"), receiveCoinsAction->text(), this);\r\n+    receiveCoinsMenuAction->setStatusTip(receiveCoinsAction->statusTip());\r\n+    receiveCoinsMenuAction->setToolTip(receiveCoinsMenuAction->statusTip());\r\n+\r\n+    historyAction = new QAction(platformStyle->SingleColorIcon(\":/icons/history\"), tr(\"&Transactions\"), this);\r\n+    historyAction->setStatusTip(tr(\"Browse transaction history\"));\r\n+    historyAction->setToolTip(historyAction->statusTip());\r\n+    historyAction->setCheckable(true);\r\n+    historyAction->setShortcut(QKeySequence(Qt::ALT + Qt::Key_4));\r\n+    tabGroup->addAction(historyAction);\r\n+\r\n+#ifdef ENABLE_WALLET\r\n+    // These showNormalIfMinimized are needed because Send Coins and Receive Coins\r\n+    // can be triggered from the tray menu, and need to show the GUI to be useful.\r\n+    connect(overviewAction, SIGNAL(triggered()), this, SLOT(showNormalIfMinimized()));\r\n+    connect(overviewAction, SIGNAL(triggered()), this, SLOT(gotoOverviewPage()));\r\n+    connect(sendCoinsAction, SIGNAL(triggered()), this, SLOT(showNormalIfMinimized()));\r\n+    connect(sendCoinsAction, SIGNAL(triggered()), this, SLOT(gotoSendCoinsPage()));\r\n+    connect(sendCoinsMenuAction, SIGNAL(triggered()), this, SLOT(showNormalIfMinimized()));\r\n+    connect(sendCoinsMenuAction, SIGNAL(triggered()), this, SLOT(gotoSendCoinsPage()));\r\n+    connect(receiveCoinsAction, SIGNAL(triggered()), this, SLOT(showNormalIfMinimized()));\r\n+    connect(receiveCoinsAction, SIGNAL(triggered()), this, SLOT(gotoReceiveCoinsPage()));\r\n+    connect(receiveCoinsMenuAction, SIGNAL(triggered()), this, SLOT(showNormalIfMinimized()));\r\n+    connect(receiveCoinsMenuAction, SIGNAL(triggered()), this, SLOT(gotoReceiveCoinsPage()));\r\n+    connect(historyAction, SIGNAL(triggered()), this, SLOT(showNormalIfMinimized()));\r\n+    connect(historyAction, SIGNAL(triggered()), this, SLOT(gotoHistoryPage()));\r\n+#endif // ENABLE_WALLET\r\n+\r\n+    quitAction = new QAction(platformStyle->TextColorIcon(\":/icons/quit\"), tr(\"E&xit\"), this);\r\n+    quitAction->setStatusTip(tr(\"Quit application\"));\r\n+    quitAction->setShortcut(QKeySequence(Qt::CTRL + Qt::Key_Q));\r\n+    quitAction->setMenuRole(QAction::QuitRole);\r\n+    aboutAction = new QAction(platformStyle->TextColorIcon(\":/icons/about\"), tr(\"&About %1\").arg(tr(PACKAGE_NAME)), this);\r\n+    aboutAction->setStatusTip(tr(\"Show information about %1\").arg(tr(PACKAGE_NAME)));\r\n+    aboutAction->setMenuRole(QAction::AboutRole);\r\n+    aboutAction->setEnabled(false);\r\n+    aboutQtAction = new QAction(platformStyle->TextColorIcon(\":/icons/about_qt\"), tr(\"About &Qt\"), this);\r\n+    aboutQtAction->setStatusTip(tr(\"Show information about Qt\"));\r\n+    aboutQtAction->setMenuRole(QAction::AboutQtRole);\r\n+    optionsAction = new QAction(platformStyle->TextColorIcon(\":/icons/options\"), tr(\"&Options...\"), this);\r\n+    optionsAction->setStatusTip(tr(\"Modify configuration options for %1\").arg(tr(PACKAGE_NAME)));\r\n+    optionsAction->setMenuRole(QAction::PreferencesRole);\r\n+    optionsAction->setEnabled(false);\r\n+    toggleHideAction = new QAction(platformStyle->TextColorIcon(\":/icons/about\"), tr(\"&Show / Hide\"), this);\r\n+    toggleHideAction->setStatusTip(tr(\"Show or hide the main Window\"));\r\n+\r\n+    encryptWalletAction = new QAction(platformStyle->TextColorIcon(\":/icons/lock_closed\"), tr(\"&Encrypt Wallet...\"), this);\r\n+    encryptWalletAction->setStatusTip(tr(\"Encrypt the private keys that belong to your wallet\"));\r\n+    encryptWalletAction->setCheckable(true);\r\n+    backupWalletAction = new QAction(platformStyle->TextColorIcon(\":/icons/filesave\"), tr(\"&Backup Wallet...\"), this);\r\n+    backupWalletAction->setStatusTip(tr(\"Backup wallet to another location\"));\r\n+    changePassphraseAction = new QAction(platformStyle->TextColorIcon(\":/icons/key\"), tr(\"&Change Passphrase...\"), this);\r\n+    changePassphraseAction->setStatusTip(tr(\"Change the passphrase used for wallet encryption\"));\r\n+    signMessageAction = new QAction(platformStyle->TextColorIcon(\":/icons/edit\"), tr(\"Sign &message...\"), this);\r\n+    signMessageAction->setStatusTip(tr(\"Sign messages with your Bitcoin addresses to prove you own them\"));\r\n+    verifyMessageAction = new QAction(platformStyle->TextColorIcon(\":/icons/verify\"), tr(\"&Verify message...\"), this);\r\n+    verifyMessageAction->setStatusTip(tr(\"Verify messages to ensure they were signed with specified Bitcoin addresses\"));\r\n+\r\n+    openRPCConsoleAction = new QAction(platformStyle->TextColorIcon(\":/icons/debugwindow\"), tr(\"&Debug window\"), this);\r\n+    openRPCConsoleAction->setStatusTip(tr(\"Open debugging and diagnostic console\"));\r\n+    // initially disable the debug window menu item\r\n+    openRPCConsoleAction->setEnabled(false);\r\n+\r\n+    usedSendingAddressesAction = new QAction(platformStyle->TextColorIcon(\":/icons/address-book\"), tr(\"&Sending addresses...\"), this);\r\n+    usedSendingAddressesAction->setStatusTip(tr(\"Show the list of used sending addresses and labels\"));\r\n+    usedReceivingAddressesAction = new QAction(platformStyle->TextColorIcon(\":/icons/address-book\"), tr(\"&Receiving addresses...\"), this);\r\n+    usedReceivingAddressesAction->setStatusTip(tr(\"Show the list of used receiving addresses and labels\"));\r\n+\r\n+    openAction = new QAction(platformStyle->TextColorIcon(\":/icons/open\"), tr(\"Open &URI...\"), this);\r\n+    openAction->setStatusTip(tr(\"Open a bitcoin: URI or payment request\"));\r\n+\r\n+    showHelpMessageAction = new QAction(platformStyle->TextColorIcon(\":/icons/info\"), tr(\"&Command-line options\"), this);\r\n+    showHelpMessageAction->setMenuRole(QAction::NoRole);\r\n+    showHelpMessageAction->setStatusTip(tr(\"Show the %1 help message to get a list with possible Bitcoin command-line options\").arg(tr(PACKAGE_NAME)));\r\n+\r\n+    connect(quitAction, SIGNAL(triggered()), qApp, SLOT(quit()));\r\n+    connect(aboutAction, SIGNAL(triggered()), this, SLOT(aboutClicked()));\r\n+    connect(aboutQtAction, SIGNAL(triggered()), qApp, SLOT(aboutQt()));\r\n+    connect(optionsAction, SIGNAL(triggered()), this, SLOT(optionsClicked()));\r\n+    connect(toggleHideAction, SIGNAL(triggered()), this, SLOT(toggleHidden()));\r\n+    connect(showHelpMessageAction, SIGNAL(triggered()), this, SLOT(showHelpMessageClicked()));\r\n+    connect(openRPCConsoleAction, SIGNAL(triggered()), this, SLOT(showDebugWindow()));\r\n+    // prevents an open debug window from becoming stuck/unusable on client shutdown\r\n+    connect(quitAction, SIGNAL(triggered()), rpcConsole, SLOT(hide()));\r\n+\r\n+#ifdef ENABLE_WALLET\r\n+    if(walletFrame)\r\n+    {\r\n+        connect(encryptWalletAction, SIGNAL(triggered(bool)), walletFrame, SLOT(encryptWallet(bool)));\r\n+        connect(backupWalletAction, SIGNAL(triggered()), walletFrame, SLOT(backupWallet()));\r\n+        connect(changePassphraseAction, SIGNAL(triggered()), walletFrame, SLOT(changePassphrase()));\r\n+        connect(signMessageAction, SIGNAL(triggered()), this, SLOT(gotoSignMessageTab()));\r\n+        connect(verifyMessageAction, SIGNAL(triggered()), this, SLOT(gotoVerifyMessageTab()));\r\n+        connect(usedSendingAddressesAction, SIGNAL(triggered()), walletFrame, SLOT(usedSendingAddresses()));\r\n+        connect(usedReceivingAddressesAction, SIGNAL(triggered()), walletFrame, SLOT(usedReceivingAddresses()));\r\n+        connect(openAction, SIGNAL(triggered()), this, SLOT(openClicked()));\r\n+    }\r\n+#endif // ENABLE_WALLET\r\n+\r\n+    new QShortcut(QKeySequence(Qt::CTRL + Qt::SHIFT + Qt::Key_C), this, SLOT(showDebugWindowActivateConsole()));\r\n+    new QShortcut(QKeySequence(Qt::CTRL + Qt::SHIFT + Qt::Key_D), this, SLOT(showDebugWindow()));\r\n+}\r\n+\r\n+void BitcoinGUI::createMenuBar()\r\n+{\r\n+#ifdef Q_OS_MAC\r\n+    // Create a decoupled menu bar on Mac which stays even if the window is closed\r\n+    appMenuBar = new QMenuBar();\r\n+#else\r\n+    // Get the main window's menu bar on other platforms\r\n+    appMenuBar = menuBar();\r\n+#endif\r\n+\r\n+    // Configure the menus\r\n+    QMenu *file = appMenuBar->addMenu(tr(\"&File\"));\r\n+    if(walletFrame)\r\n+    {\r\n+        file->addAction(openAction);\r\n+        file->addAction(backupWalletAction);\r\n+        file->addAction(signMessageAction);\r\n+        file->addAction(verifyMessageAction);\r\n+        file->addSeparator();\r\n+        file->addAction(usedSendingAddressesAction);\r\n+        file->addAction(usedReceivingAddressesAction);\r\n+        file->addSeparator();\r\n+    }\r\n+    file->addAction(quitAction);\r\n+\r\n+    QMenu *settings = appMenuBar->addMenu(tr(\"&Settings\"));\r\n+    if(walletFrame)\r\n+    {\r\n+        settings->addAction(encryptWalletAction);\r\n+        settings->addAction(changePassphraseAction);\r\n+        settings->addSeparator();\r\n+    }\r\n+    settings->addAction(optionsAction);\r\n+\r\n+    QMenu *help = appMenuBar->addMenu(tr(\"&Help\"));\r\n+    if(walletFrame)\r\n+    {\r\n+        help->addAction(openRPCConsoleAction);\r\n+    }\r\n+    help->addAction(showHelpMessageAction);\r\n+    help->addSeparator();\r\n+    help->addAction(aboutAction);\r\n+    help->addAction(aboutQtAction);\r\n+}\r\n+\r\n+void BitcoinGUI::createToolBars()\r\n+{\r\n+    if(walletFrame)\r\n+    {\r\n+        QToolBar *toolbar = addToolBar(tr(\"Tabs toolbar\"));\r\n+        toolbar->setContextMenuPolicy(Qt::PreventContextMenu);\r\n+        toolbar->setMovable(false);\r\n+        toolbar->setToolButtonStyle(Qt::ToolButtonTextBesideIcon);\r\n+        toolbar->addAction(overviewAction);\r\n+        toolbar->addAction(sendCoinsAction);\r\n+        toolbar->addAction(receiveCoinsAction);\r\n+        toolbar->addAction(historyAction);\r\n+        overviewAction->setChecked(true);\r\n+    }\r\n+}\r\n+\r\n+void BitcoinGUI::setClientModel(ClientModel *_clientModel)\r\n+{\r\n+    this->clientModel = _clientModel;\r\n+    if(_clientModel)\r\n+    {\r\n+        // Create system tray menu (or setup the dock menu) that late to prevent users from calling actions,\r\n+        // while the client has not yet fully loaded\r\n+        createTrayIconMenu();\r\n+\r\n+        // Keep up to date with client\r\n+        updateNetworkState();\r\n+        connect(_clientModel, SIGNAL(numConnectionsChanged(int)), this, SLOT(setNumConnections(int)));\r\n+        connect(_clientModel, SIGNAL(networkActiveChanged(bool)), this, SLOT(setNetworkActive(bool)));\r\n+\r\n+        modalOverlay->setKnownBestHeight(_clientModel->getHeaderTipHeight(), QDateTime::fromTime_t(_clientModel->getHeaderTipTime()));\r\n+        setNumBlocks(_clientModel->getNumBlocks(), _clientModel->getLastBlockDate(), _clientModel->getVerificationProgress(nullptr), false);\r\n+        connect(_clientModel, SIGNAL(numBlocksChanged(int,QDateTime,double,bool)), this, SLOT(setNumBlocks(int,QDateTime,double,bool)));\r\n+\r\n+        // Receive and report messages from client model\r\n+        connect(_clientModel, SIGNAL(message(QString,QString,unsigned int)), this, SLOT(message(QString,QString,unsigned int)));\r\n+\r\n+        // Show progress dialog\r\n+        connect(_clientModel, SIGNAL(showProgress(QString,int)), this, SLOT(showProgress(QString,int)));\r\n+\r\n+        rpcConsole->setClientModel(_clientModel);\r\n+#ifdef ENABLE_WALLET\r\n+        if(walletFrame)\r\n+        {\r\n+            walletFrame->setClientModel(_clientModel);\r\n+        }\r\n+#endif // ENABLE_WALLET\r\n+        unitDisplayControl->setOptionsModel(_clientModel->getOptionsModel());\r\n+        \r\n+        OptionsModel* optionsModel = _clientModel->getOptionsModel();\r\n+        if(optionsModel)\r\n+        {\r\n+            // be aware of the tray icon disable state change reported by the OptionsModel object.\r\n+            connect(optionsModel,SIGNAL(hideTrayIconChanged(bool)),this,SLOT(setTrayIconVisible(bool)));\r\n+        \r\n+            // initialize the disable state of the tray icon with the current value in the model.\r\n+            setTrayIconVisible(optionsModel->getHideTrayIcon());\r\n+        }\r\n+    } else {\r\n+        // Disable possibility to show main window via action\r\n+        toggleHideAction->setEnabled(false);\r\n+        if(trayIconMenu)\r\n+        {\r\n+            // Disable context menu on tray icon\r\n+            trayIconMenu->clear();\r\n+        }\r\n+        // Propagate cleared model to child objects\r\n+        rpcConsole->setClientModel(nullptr);\r\n+#ifdef ENABLE_WALLET\r\n+        if (walletFrame)\r\n+        {\r\n+            walletFrame->setClientModel(nullptr);\r\n+        }\r\n+#endif // ENABLE_WALLET\r\n+        unitDisplayControl->setOptionsModel(nullptr);\r\n+    }\r\n+}\r\n+\r\n+#ifdef ENABLE_WALLET\r\n+bool BitcoinGUI::addWallet(const QString& name, WalletModel *walletModel)\r\n+{\r\n+    if(!walletFrame)\r\n+        return false;\r\n+    setWalletActionsEnabled(true);\r\n+    return walletFrame->addWallet(name, walletModel);\r\n+}\r\n+\r\n+bool BitcoinGUI::setCurrentWallet(const QString& name)\r\n+{\r\n+    if(!walletFrame)\r\n+        return false;\r\n+    return walletFrame->setCurrentWallet(name);\r\n+}\r\n+\r\n+void BitcoinGUI::removeAllWallets()\r\n+{\r\n+    if(!walletFrame)\r\n+        return;\r\n+    setWalletActionsEnabled(false);\r\n+    walletFrame->removeAllWallets();\r\n+}\r\n+#endif // ENABLE_WALLET\r\n+\r\n+void BitcoinGUI::setWalletActionsEnabled(bool enabled)\r\n+{\r\n+    overviewAction->setEnabled(enabled);\r\n+    sendCoinsAction->setEnabled(enabled);\r\n+    sendCoinsMenuAction->setEnabled(enabled);\r\n+    receiveCoinsAction->setEnabled(enabled);\r\n+    receiveCoinsMenuAction->setEnabled(enabled);\r\n+    historyAction->setEnabled(enabled);\r\n+    encryptWalletAction->setEnabled(enabled);\r\n+    backupWalletAction->setEnabled(enabled);\r\n+    changePassphraseAction->setEnabled(enabled);\r\n+    signMessageAction->setEnabled(enabled);\r\n+    verifyMessageAction->setEnabled(enabled);\r\n+    usedSendingAddressesAction->setEnabled(enabled);\r\n+    usedReceivingAddressesAction->setEnabled(enabled);\r\n+    openAction->setEnabled(enabled);\r\n+}\r\n+\r\n+void BitcoinGUI::createTrayIcon(const NetworkStyle *networkStyle)\r\n+{\r\n+#ifndef Q_OS_MAC\r\n+    trayIcon = new QSystemTrayIcon(this);\r\n+    QString toolTip = tr(\"%1 client\").arg(tr(PACKAGE_NAME)) + \" \" + networkStyle->getTitleAddText();\r\n+    trayIcon->setToolTip(toolTip);\r\n+    trayIcon->setIcon(networkStyle->getTrayAndWindowIcon());\r\n+    trayIcon->hide();\r\n+#endif\r\n+\r\n+    notificator = new Notificator(QApplication::applicationName(), trayIcon, this);\r\n+}\r\n+\r\n+void BitcoinGUI::createTrayIconMenu()\r\n+{\r\n+#ifndef Q_OS_MAC\r\n+    // return if trayIcon is unset (only on non-Mac OSes)\r\n+    if (!trayIcon)\r\n+        return;\r\n+\r\n+    trayIconMenu = new QMenu(this);\r\n+    trayIcon->setContextMenu(trayIconMenu);\r\n+\r\n+    connect(trayIcon, SIGNAL(activated(QSystemTrayIcon::ActivationReason)),\r\n+            this, SLOT(trayIconActivated(QSystemTrayIcon::ActivationReason)));\r\n+#else\r\n+    // Note: On Mac, the dock icon is used to provide the tray's functionality.\r\n+    MacDockIconHandler *dockIconHandler = MacDockIconHandler::instance();\r\n+    dockIconHandler->setMainWindow((QMainWindow *)this);\r\n+    trayIconMenu = dockIconHandler->dockMenu();\r\n+#endif\r\n+\r\n+    // Configuration of the tray icon (or dock icon) icon menu\r\n+    trayIconMenu->addAction(toggleHideAction);\r\n+    trayIconMenu->addSeparator();\r\n+    trayIconMenu->addAction(sendCoinsMenuAction);\r\n+    trayIconMenu->addAction(receiveCoinsMenuAction);\r\n+    trayIconMenu->addSeparator();\r\n+    trayIconMenu->addAction(signMessageAction);\r\n+    trayIconMenu->addAction(verifyMessageAction);\r\n+    trayIconMenu->addSeparator();\r\n+    trayIconMenu->addAction(optionsAction);\r\n+    trayIconMenu->addAction(openRPCConsoleAction);\r\n+#ifndef Q_OS_MAC // This is built-in on Mac\r\n+    trayIconMenu->addSeparator();\r\n+    trayIconMenu->addAction(quitAction);\r\n+#endif\r\n+}\r\n+\r\n+#ifndef Q_OS_MAC\r\n+void BitcoinGUI::trayIconActivated(QSystemTrayIcon::ActivationReason reason)\r\n+{\r\n+    if(reason == QSystemTrayIcon::Trigger)\r\n+    {\r\n+        // Click on system tray icon triggers show/hide of the main window\r\n+        toggleHidden();\r\n+    }\r\n+}\r\n+#endif\r\n+\r\n+void BitcoinGUI::optionsClicked()\r\n+{\r\n+    if(!clientModel || !clientModel->getOptionsModel())\r\n+        return;\r\n+\r\n+    OptionsDialog dlg(this, enableWallet);\r\n+    dlg.setModel(clientModel->getOptionsModel());\r\n+    dlg.exec();\r\n+}\r\n+\r\n+void BitcoinGUI::aboutClicked()\r\n+{\r\n+    if(!clientModel)\r\n+        return;\r\n+\r\n+    HelpMessageDialog dlg(this, true);\r\n+    dlg.exec();\r\n+}\r\n+\r\n+void BitcoinGUI::showDebugWindow()\r\n+{\r\n+    rpcConsole->showNormal();\r\n+    rpcConsole->show();\r\n+    rpcConsole->raise();\r\n+    rpcConsole->activateWindow();\r\n+}\r\n+\r\n+void BitcoinGUI::showDebugWindowActivateConsole()\r\n+{\r\n+    rpcConsole->setTabFocus(RPCConsole::TAB_CONSOLE);\r\n+    showDebugWindow();\r\n+}\r\n+\r\n+void BitcoinGUI::showHelpMessageClicked()\r\n+{\r\n+    helpMessageDialog->show();\r\n+}\r\n+\r\n+#ifdef ENABLE_WALLET\r\n+void BitcoinGUI::openClicked()\r\n+{\r\n+    OpenURIDialog dlg(this);\r\n+    if(dlg.exec())\r\n+    {\r\n+        Q_EMIT receivedURI(dlg.getURI());\r\n+    }\r\n+}\r\n+\r\n+void BitcoinGUI::gotoOverviewPage()\r\n+{\r\n+    overviewAction->setChecked(true);\r\n+    if (walletFrame) walletFrame->gotoOverviewPage();\r\n+}\r\n+\r\n+void BitcoinGUI::gotoHistoryPage()\r\n+{\r\n+    historyAction->setChecked(true);\r\n+    if (walletFrame) walletFrame->gotoHistoryPage();\r\n+}\r\n+\r\n+void BitcoinGUI::gotoReceiveCoinsPage()\r\n+{\r\n+    receiveCoinsAction->setChecked(true);\r\n+    if (walletFrame) walletFrame->gotoReceiveCoinsPage();\r\n+}\r\n+\r\n+void BitcoinGUI::gotoSendCoinsPage(QString addr)\r\n+{\r\n+    sendCoinsAction->setChecked(true);\r\n+    if (walletFrame) walletFrame->gotoSendCoinsPage(addr);\r\n+}\r\n+\r\n+void BitcoinGUI::gotoSignMessageTab(QString addr)\r\n+{\r\n+    if (walletFrame) walletFrame->gotoSignMessageTab(addr);\r\n+}\r\n+\r\n+void BitcoinGUI::gotoVerifyMessageTab(QString addr)\r\n+{\r\n+    if (walletFrame) walletFrame->gotoVerifyMessageTab(addr);\r\n+}\r\n+#endif // ENABLE_WALLET\r\n+\r\n+void BitcoinGUI::updateNetworkState()\r\n+{\r\n+    int count = clientModel->getNumConnections();\r\n+    QString icon;\r\n+    switch(count)\r\n+    {\r\n+    case 0: icon = \":/icons/connect_0\"; break;\r\n+    case 1: case 2: case 3: icon = \":/icons/connect_1\"; break;\r\n+    case 4: case 5: case 6: icon = \":/icons/connect_2\"; break;\r\n+    case 7: case 8: case 9: icon = \":/icons/connect_3\"; break;\r\n+    default: icon = \":/icons/connect_4\"; break;\r\n+    }\r\n+\r\n+    QString tooltip;\r\n+\r\n+    if (clientModel->getNetworkActive()) {\r\n+        tooltip = tr(\"%n active connection(s) to Bitcoin network\", \"\", count) + QString(\".<br>\") + tr(\"Click to disable network activity.\");\r\n+    } else {\r\n+        tooltip = tr(\"Network activity disabled.\") + QString(\"<br>\") + tr(\"Click to enable network activity again.\");\r\n+        icon = \":/icons/network_disabled\";\r\n+    }\r\n+\r\n+    // Don't word-wrap this (fixed-width) tooltip\r\n+    tooltip = QString(\"<nobr>\") + tooltip + QString(\"</nobr>\");\r\n+    connectionsControl->setToolTip(tooltip);\r\n+\r\n+    connectionsControl->setPixmap(platformStyle->SingleColorIcon(icon).pixmap(STATUSBAR_ICONSIZE,STATUSBAR_ICONSIZE));\r\n+}\r\n+\r\n+void BitcoinGUI::setNumConnections(int count)\r\n+{\r\n+    updateNetworkState();\r\n+}\r\n+\r\n+void BitcoinGUI::setNetworkActive(bool networkActive)\r\n+{\r\n+    updateNetworkState();\r\n+}\r\n+\r\n+void BitcoinGUI::updateHeadersSyncProgressLabel()\r\n+{\r\n+    int64_t headersTipTime = clientModel->getHeaderTipTime();\r\n+    int headersTipHeight = clientModel->getHeaderTipHeight();\r\n+    int estHeadersLeft = (GetTime() - headersTipTime) / Params().GetConsensus().nBtvPowTargetSpacing;\r\n+    if (estHeadersLeft > HEADER_HEIGHT_DELTA_SYNC)\r\n+        progressBarLabel->setText(tr(\"Syncing Headers (%1%)...\").arg(QString::number(100.0 / (headersTipHeight+estHeadersLeft)*headersTipHeight, 'f', 1)));\r\n+}\r\n+\r\n+void BitcoinGUI::setNumBlocks(int count, const QDateTime& blockDate, double nVerificationProgress, bool header)\r\n+{\r\n+    if (modalOverlay)\r\n+    {\r\n+        if (header)\r\n+            modalOverlay->setKnownBestHeight(count, blockDate);\r\n+        else\r\n+            modalOverlay->tipUpdate(count, blockDate, nVerificationProgress);\r\n+    }\r\n+    if (!clientModel)\r\n+        return;\r\n+\r\n+    // Prevent orphan statusbar messages (e.g. hover Quit in main menu, wait until chain-sync starts -> garbled text)\r\n+    statusBar()->clearMessage();\r\n+\r\n+    // Acquire current block source\r\n+    enum BlockSource blockSource = clientModel->getBlockSource();\r\n+    switch (blockSource) {\r\n+        case BLOCK_SOURCE_NETWORK:\r\n+            if (header) {\r\n+                updateHeadersSyncProgressLabel();\r\n+                return;\r\n+            }\r\n+            progressBarLabel->setText(tr(\"Synchronizing with network...\"));\r\n+            updateHeadersSyncProgressLabel();\r\n+            break;\r\n+        case BLOCK_SOURCE_DISK:\r\n+            if (header) {\r\n+                progressBarLabel->setText(tr(\"Indexing blocks on disk...\"));\r\n+            } else {\r\n+                progressBarLabel->setText(tr(\"Processing blocks on disk...\"));\r\n+            }\r\n+            break;\r\n+        case BLOCK_SOURCE_REINDEX:\r\n+            progressBarLabel->setText(tr(\"Reindexing blocks on disk...\"));\r\n+            break;\r\n+        case BLOCK_SOURCE_NONE:\r\n+            if (header) {\r\n+                return;\r\n+            }\r\n+            progressBarLabel->setText(tr(\"Connecting to peers...\"));\r\n+            break;\r\n+    }\r\n+\r\n+    QString tooltip;\r\n+\r\n+    QDateTime currentDate = QDateTime::currentDateTime();\r\n+    qint64 secs = blockDate.secsTo(currentDate);\r\n+\r\n+    tooltip = tr(\"Processed %n block(s) of transaction history.\", \"\", count);\r\n+\r\n+    // Set icon state: spinning if catching up, tick otherwise\r\n+    if(secs < 90*60)\r\n+    {\r\n+        tooltip = tr(\"Up to date\") + QString(\".<br>\") + tooltip;\r\n+        labelBlocksIcon->setPixmap(platformStyle->SingleColorIcon(\":/icons/synced\").pixmap(STATUSBAR_ICONSIZE, STATUSBAR_ICONSIZE));\r\n+\r\n+#ifdef ENABLE_WALLET\r\n+        if(walletFrame)\r\n+        {\r\n+            walletFrame->showOutOfSyncWarning(false);\r\n+            modalOverlay->showHide(true, true);\r\n+        }\r\n+#endif // ENABLE_WALLET\r\n+\r\n+        progressBarLabel->setVisible(false);\r\n+        progressBar->setVisible(false);\r\n+    }\r\n+    else\r\n+    {\r\n+        QString timeBehindText = GUIUtil::formatNiceTimeOffset(secs);\r\n+\r\n+        progressBarLabel->setVisible(true);\r\n+        progressBar->setFormat(tr(\"%1 behind\").arg(timeBehindText));\r\n+        progressBar->setMaximum(1000000000);\r\n+        progressBar->setValue(nVerificationProgress * 1000000000.0 + 0.5);\r\n+        progressBar->setVisible(true);\r\n+\r\n+        tooltip = tr(\"Catching up...\") + QString(\"<br>\") + tooltip;\r\n+        if(count != prevBlocks)\r\n+        {\r\n+            labelBlocksIcon->setPixmap(platformStyle->SingleColorIcon(QString(\r\n+                \":/movies/spinner-%1\").arg(spinnerFrame, 3, 10, QChar('0')))\r\n+                .pixmap(STATUSBAR_ICONSIZE, STATUSBAR_ICONSIZE));\r\n+            spinnerFrame = (spinnerFrame + 1) % SPINNER_FRAMES;\r\n+        }\r\n+        prevBlocks = count;\r\n+\r\n+#ifdef ENABLE_WALLET\r\n+        if(walletFrame)\r\n+        {\r\n+            walletFrame->showOutOfSyncWarning(true);\r\n+            modalOverlay->showHide();\r\n+        }\r\n+#endif // ENABLE_WALLET\r\n+\r\n+        tooltip += QString(\"<br>\");\r\n+        tooltip += tr(\"Last received block was generated %1 ago.\").arg(timeBehindText);\r\n+        tooltip += QString(\"<br>\");\r\n+        tooltip += tr(\"Transactions after this will not yet be visible.\");\r\n+    }\r\n+\r\n+    // Don't word-wrap this (fixed-width) tooltip\r\n+    tooltip = QString(\"<nobr>\") + tooltip + QString(\"</nobr>\");\r\n+\r\n+    labelBlocksIcon->setToolTip(tooltip);\r\n+    progressBarLabel->setToolTip(tooltip);\r\n+    progressBar->setToolTip(tooltip);\r\n+}\r\n+\r\n+void BitcoinGUI::message(const QString &title, const QString &message, unsigned int style, bool *ret)\r\n+{\r\n+    QString strTitle = tr(\"Bitcoin\"); // default title\r\n+    // Default to information icon\r\n+    int nMBoxIcon = QMessageBox::Information;\r\n+    int nNotifyIcon = Notificator::Information;\r\n+\r\n+    QString msgType;\r\n+\r\n+    // Prefer supplied title over style based title\r\n+    if (!title.isEmpty()) {\r\n+        msgType = title;\r\n+    }\r\n+    else {\r\n+        switch (style) {\r\n+        case CClientUIInterface::MSG_ERROR:\r\n+            msgType = tr(\"Error\");\r\n+            break;\r\n+        case CClientUIInterface::MSG_WARNING:\r\n+            msgType = tr(\"Warning\");\r\n+            break;\r\n+        case CClientUIInterface::MSG_INFORMATION:\r\n+            msgType = tr(\"Information\");\r\n+            break;\r\n+        default:\r\n+            break;\r\n+        }\r\n+    }\r\n+    // Append title to \"Bitcoin - \"\r\n+    if (!msgType.isEmpty())\r\n+        strTitle += \" - \" + msgType;\r\n+\r\n+    // Check for error/warning icon\r\n+    if (style & CClientUIInterface::ICON_ERROR) {\r\n+        nMBoxIcon = QMessageBox::Critical;\r\n+        nNotifyIcon = Notificator::Critical;\r\n+    }\r\n+    else if (style & CClientUIInterface::ICON_WARNING) {\r\n+        nMBoxIcon = QMessageBox::Warning;\r\n+        nNotifyIcon = Notificator::Warning;\r\n+    }\r\n+\r\n+    // Display message\r\n+    if (style & CClientUIInterface::MODAL) {\r\n+        // Check for buttons, use OK as default, if none was supplied\r\n+        QMessageBox::StandardButton buttons;\r\n+        if (!(buttons = (QMessageBox::StandardButton)(style & CClientUIInterface::BTN_MASK)))\r\n+            buttons = QMessageBox::Ok;\r\n+\r\n+        showNormalIfMinimized();\r\n+        QMessageBox mBox((QMessageBox::Icon)nMBoxIcon, strTitle, message, buttons, this);\r\n+        int r = mBox.exec();\r\n+        if (ret != nullptr)\r\n+            *ret = r == QMessageBox::Ok;\r\n+    }\r\n+    else\r\n+        notificator->notify((Notificator::Class)nNotifyIcon, strTitle, message);\r\n+}\r\n+\r\n+void BitcoinGUI::changeEvent(QEvent *e)\r\n+{\r\n+    QMainWindow::changeEvent(e);\r\n+#ifndef Q_OS_MAC // Ignored on Mac\r\n+    if(e->type() == QEvent::WindowStateChange)\r\n+    {\r\n+        if(clientModel && clientModel->getOptionsModel() && clientModel->getOptionsModel()->getMinimizeToTray())\r\n+        {\r\n+            QWindowStateChangeEvent *wsevt = static_cast<QWindowStateChangeEvent*>(e);\r\n+            if(!(wsevt->oldState() & Qt::WindowMinimized) && isMinimized())\r\n+            {\r\n+                QTimer::singleShot(0, this, SLOT(hide()));\r\n+                e->ignore();\r\n+            }\r\n+        }\r\n+    }\r\n+#endif\r\n+}\r\n+\r\n+void BitcoinGUI::closeEvent(QCloseEvent *event)\r\n+{\r\n+#ifndef Q_OS_MAC // Ignored on Mac\r\n+    if(clientModel && clientModel->getOptionsModel())\r\n+    {\r\n+        if(!clientModel->getOptionsModel()->getMinimizeOnClose())\r\n+        {\r\n+            // close rpcConsole in case it was open to make some space for the shutdown window\r\n+            rpcConsole->close();\r\n+\r\n+            QApplication::quit();\r\n+        }\r\n+        else\r\n+        {\r\n+            QMainWindow::showMinimized();\r\n+            event->ignore();\r\n+        }\r\n+    }\r\n+#else\r\n+    QMainWindow::closeEvent(event);\r\n+#endif\r\n+}\r\n+\r\n+void BitcoinGUI::showEvent(QShowEvent *event)\r\n+{\r\n+    // enable the debug window when the main window shows up\r\n+    openRPCConsoleAction->setEnabled(true);\r\n+    aboutAction->setEnabled(true);\r\n+    optionsAction->setEnabled(true);\r\n+}\r\n+\r\n+#ifdef ENABLE_WALLET\r\n+void BitcoinGUI::incomingTransaction(const QString& date, int unit, const CAmount& amount, const QString& type, const QString& address, const QString& label)\r\n+{\r\n+    // On new transaction, make an info balloon\r\n+    QString msg = tr(\"Date: %1\\n\").arg(date) +\r\n+                  tr(\"Amount: %1\\n\").arg(BitcoinUnits::formatWithUnit(unit, amount, true)) +\r\n+                  tr(\"Type: %1\\n\").arg(type);\r\n+    if (!label.isEmpty())\r\n+        msg += tr(\"Label: %1\\n\").arg(label);\r\n+    else if (!address.isEmpty())\r\n+        msg += tr(\"Address: %1\\n\").arg(address);\r\n+    message((amount)<0 ? tr(\"Sent transaction\") : tr(\"Incoming transaction\"),\r\n+             msg, CClientUIInterface::MSG_INFORMATION);\r\n+}\r\n+#endif // ENABLE_WALLET\r\n+\r\n+void BitcoinGUI::dragEnterEvent(QDragEnterEvent *event)\r\n+{\r\n+    // Accept only URIs\r\n+    if(event->mimeData()->hasUrls())\r\n+        event->acceptProposedAction();\r\n+}\r\n+\r\n+void BitcoinGUI::dropEvent(QDropEvent *event)\r\n+{\r\n+    if(event->mimeData()->hasUrls())\r\n+    {\r\n+        for (const QUrl &uri : event->mimeData()->urls())\r\n+        {\r\n+            Q_EMIT receivedURI(uri.toString());\r\n+        }\r\n+    }\r\n+    event->acceptProposedAction();\r\n+}\r\n+\r\n+bool BitcoinGUI::eventFilter(QObject *object, QEvent *event)\r\n+{\r\n+    // Catch status tip events\r\n+    if (event->type() == QEvent::StatusTip)\r\n+    {\r\n+        // Prevent adding text from setStatusTip(), if we currently use the status bar for displaying other stuff\r\n+        if (progressBarLabel->isVisible() || progressBar->isVisible())\r\n+            return true;\r\n+    }\r\n+    return QMainWindow::eventFilter(object, event);\r\n+}\r\n+\r\n+#ifdef ENABLE_WALLET\r\n+bool BitcoinGUI::handlePaymentRequest(const SendCoinsRecipient& recipient)\r\n+{\r\n+    // URI has to be valid\r\n+    if (walletFrame && walletFrame->handlePaymentRequest(recipient))\r\n+    {\r\n+        showNormalIfMinimized();\r\n+        gotoSendCoinsPage();\r\n+        return true;\r\n+    }\r\n+    return false;\r\n+}\r\n+\r\n+void BitcoinGUI::setHDStatus(int hdEnabled)\r\n+{\r\n+    labelWalletHDStatusIcon->setPixmap(platformStyle->SingleColorIcon(hdEnabled ? \":/icons/hd_enabled\" : \":/icons/hd_disabled\").pixmap(STATUSBAR_ICONSIZE,STATUSBAR_ICONSIZE));\r\n+    labelWalletHDStatusIcon->setToolTip(hdEnabled ? tr(\"HD key generation is <b>enabled</b>\") : tr(\"HD key generation is <b>disabled</b>\"));\r\n+\r\n+    // eventually disable the QLabel to set its opacity to 50% \r\n+    labelWalletHDStatusIcon->setEnabled(hdEnabled);\r\n+}\r\n+\r\n+void BitcoinGUI::setEncryptionStatus(int status)\r\n+{\r\n+    switch(status)\r\n+    {\r\n+    case WalletModel::Unencrypted:\r\n+        labelWalletEncryptionIcon->hide();\r\n+        encryptWalletAction->setChecked(false);\r\n+        changePassphraseAction->setEnabled(false);\r\n+        encryptWalletAction->setEnabled(true);\r\n+        break;\r\n+    case WalletModel::Unlocked:\r\n+        labelWalletEncryptionIcon->show();\r\n+        labelWalletEncryptionIcon->setPixmap(platformStyle->SingleColorIcon(\":/icons/lock_open\").pixmap(STATUSBAR_ICONSIZE,STATUSBAR_ICONSIZE));\r\n+        labelWalletEncryptionIcon->setToolTip(tr(\"Wallet is <b>encrypted</b> and currently <b>unlocked</b>\"));\r\n+        encryptWalletAction->setChecked(true);\r\n+        changePassphraseAction->setEnabled(true);\r\n+        encryptWalletAction->setEnabled(false); // TODO: decrypt currently not supported\r\n+        break;\r\n+    case WalletModel::Locked:\r\n+        labelWalletEncryptionIcon->show();\r\n+        labelWalletEncryptionIcon->setPixmap(platformStyle->SingleColorIcon(\":/icons/lock_closed\").pixmap(STATUSBAR_ICONSIZE,STATUSBAR_ICONSIZE));\r\n+        labelWalletEncryptionIcon->setToolTip(tr(\"Wallet is <b>encrypted</b> and currently <b>locked</b>\"));\r\n+        encryptWalletAction->setChecked(true);\r\n+        changePassphraseAction->setEnabled(true);\r\n+        encryptWalletAction->setEnabled(false); // TODO: decrypt currently not supported\r\n+        break;\r\n+    }\r\n+}\r\n+#endif // ENABLE_WALLET\r\n+\r\n+void BitcoinGUI::showNormalIfMinimized(bool fToggleHidden)\r\n+{\r\n+    if(!clientModel)\r\n+        return;\r\n+\r\n+    // activateWindow() (sometimes) helps with keyboard focus on Windows\r\n+    if (isHidden())\r\n+    {\r\n+        show();\r\n+        activateWindow();\r\n+    }\r\n+    else if (isMinimized())\r\n+    {\r\n+        showNormal();\r\n+        activateWindow();\r\n+    }\r\n+    else if (GUIUtil::isObscured(this))\r\n+    {\r\n+        raise();\r\n+        activateWindow();\r\n+    }\r\n+    else if(fToggleHidden)\r\n+        hide();\r\n+}\r\n+\r\n+void BitcoinGUI::toggleHidden()\r\n+{\r\n+    showNormalIfMinimized(true);\r\n+}\r\n+\r\n+void BitcoinGUI::detectShutdown()\r\n+{\r\n+    if (ShutdownRequested())\r\n+    {\r\n+        if(rpcConsole)\r\n+            rpcConsole->hide();\r\n+        qApp->quit();\r\n+    }\r\n+}\r\n+\r\n+void BitcoinGUI::showProgress(const QString &title, int nProgress)\r\n+{\r\n+    if (nProgress == 0)\r\n+    {\r\n+        progressDialog = new QProgressDialog(title, \"\", 0, 100);\r\n+        progressDialog->setWindowModality(Qt::ApplicationModal);\r\n+        progressDialog->setMinimumDuration(0);\r\n+        progressDialog->setCancelButton(0);\r\n+        progressDialog->setAutoClose(false);\r\n+        progressDialog->setValue(0);\r\n+    }\r\n+    else if (nProgress == 100)\r\n+    {\r\n+        if (progressDialog)\r\n+        {\r\n+            progressDialog->close();\r\n+            progressDialog->deleteLater();\r\n+        }\r\n+    }\r\n+    else if (progressDialog)\r\n+        progressDialog->setValue(nProgress);\r\n+}\r\n+\r\n+void BitcoinGUI::setTrayIconVisible(bool fHideTrayIcon)\r\n+{\r\n+    if (trayIcon)\r\n+    {\r\n+        trayIcon->setVisible(!fHideTrayIcon);\r\n+    }\r\n+}\r\n+\r\n+void BitcoinGUI::showModalOverlay()\r\n+{\r\n+    if (modalOverlay && (progressBar->isVisible() || modalOverlay->isLayerVisible()))\r\n+        modalOverlay->toggleVisibility();\r\n+}\r\n+\r\n+static bool ThreadSafeMessageBox(BitcoinGUI *gui, const std::string& message, const std::string& caption, unsigned int style)\r\n+{\r\n+    bool modal = (style & CClientUIInterface::MODAL);\r\n+    // The SECURE flag has no effect in the Qt GUI.\r\n+    // bool secure = (style & CClientUIInterface::SECURE);\r\n+    style &= ~CClientUIInterface::SECURE;\r\n+    bool ret = false;\r\n+    // In case of modal message, use blocking connection to wait for user to click a button\r\n+    QMetaObject::invokeMethod(gui, \"message\",\r\n+                               modal ? GUIUtil::blockingGUIThreadConnection() : Qt::QueuedConnection,\r\n+                               Q_ARG(QString, QString::fromStdString(caption)),\r\n+                               Q_ARG(QString, QString::fromStdString(message)),\r\n+                               Q_ARG(unsigned int, style),\r\n+                               Q_ARG(bool*, &ret));\r\n+    return ret;\r\n+}\r\n+\r\n+void BitcoinGUI::subscribeToCoreSignals()\r\n+{\r\n+    // Connect signals to client\r\n+    uiInterface.ThreadSafeMessageBox.connect(boost::bind(ThreadSafeMessageBox, this, _1, _2, _3));\r\n+    uiInterface.ThreadSafeQuestion.connect(boost::bind(ThreadSafeMessageBox, this, _1, _3, _4));\r\n+}\r\n+\r\n+void BitcoinGUI::unsubscribeFromCoreSignals()\r\n+{\r\n+    // Disconnect signals from client\r\n+    uiInterface.ThreadSafeMessageBox.disconnect(boost::bind(ThreadSafeMessageBox, this, _1, _2, _3));\r\n+    uiInterface.ThreadSafeQuestion.disconnect(boost::bind(ThreadSafeMessageBox, this, _1, _3, _4));\r\n+}\r\n+\r\n+void BitcoinGUI::toggleNetworkActive()\r\n+{\r\n+    if (clientModel) {\r\n+        clientModel->setNetworkActive(!clientModel->getNetworkActive());\r\n+    }\r\n+}\r\n+\r\n+UnitDisplayStatusBarControl::UnitDisplayStatusBarControl(const PlatformStyle *platformStyle) :\r\n+    optionsModel(0),\r\n+    menu(0)\r\n+{\r\n+    createContextMenu();\r\n+    setToolTip(tr(\"Unit to show amounts in. Click to select another unit.\"));\r\n+    QList<BitcoinUnits::Unit> units = BitcoinUnits::availableUnits();\r\n+    int max_width = 0;\r\n+    const QFontMetrics fm(font());\r\n+    for (const BitcoinUnits::Unit unit : units)\r\n+    {\r\n+        max_width = qMax(max_width, fm.width(BitcoinUnits::name(unit)));\r\n+    }\r\n+    setMinimumSize(max_width, 0);\r\n+    setAlignment(Qt::AlignRight | Qt::AlignVCenter);\r\n+    setStyleSheet(QString(\"QLabel { color : %1 }\").arg(platformStyle->SingleColor().name()));\r\n+}\r\n+\r\n+/** So that it responds to button clicks */\r\n+void UnitDisplayStatusBarControl::mousePressEvent(QMouseEvent *event)\r\n+{\r\n+    onDisplayUnitsClicked(event->pos());\r\n+}\r\n+\r\n+/** Creates context menu, its actions, and wires up all the relevant signals for mouse events. */\r\n+void UnitDisplayStatusBarControl::createContextMenu()\r\n+{\r\n+    menu = new QMenu(this);\r\n+    for (BitcoinUnits::Unit u : BitcoinUnits::availableUnits())\r\n+    {\r\n+        QAction *menuAction = new QAction(QString(BitcoinUnits::name(u)), this);\r\n+        menuAction->setData(QVariant(u));\r\n+        menu->addAction(menuAction);\r\n+    }\r\n+    connect(menu,SIGNAL(triggered(QAction*)),this,SLOT(onMenuSelection(QAction*)));\r\n+}\r\n+\r\n+/** Lets the control know about the Options Model (and its signals) */\r\n+void UnitDisplayStatusBarControl::setOptionsModel(OptionsModel *_optionsModel)\r\n+{\r\n+    if (_optionsModel)\r\n+    {\r\n+        this->optionsModel = _optionsModel;\r\n+\r\n+        // be aware of a display unit change reported by the OptionsModel object.\r\n+        connect(_optionsModel,SIGNAL(displayUnitChanged(int)),this,SLOT(updateDisplayUnit(int)));\r\n+\r\n+        // initialize the display units label with the current value in the model.\r\n+        updateDisplayUnit(_optionsModel->getDisplayUnit());\r\n+    }\r\n+}\r\n+\r\n+/** When Display Units are changed on OptionsModel it will refresh the display text of the control on the status bar */\r\n+void UnitDisplayStatusBarControl::updateDisplayUnit(int newUnits)\r\n+{\r\n+    setText(BitcoinUnits::name(newUnits));\r\n+}\r\n+\r\n+/** Shows context menu with Display Unit options by the mouse coordinates */\r\n+void UnitDisplayStatusBarControl::onDisplayUnitsClicked(const QPoint& point)\r\n+{\r\n+    QPoint globalPos = mapToGlobal(point);\r\n+    menu->exec(globalPos);\r\n+}\r\n+\r\n+/** Tells underlying optionsModel to update its current display unit. */\r\n+void UnitDisplayStatusBarControl::onMenuSelection(QAction* action)\r\n+{\r\n+    if (action)\r\n+    {\r\n+        optionsModel->setDisplayUnit(action->data());\r\n+    }\r\n+}\r"
      },
      {
        "sha": "63fc2a44eeb59e27b0b2132511203707f5bed3fd",
        "filename": "src/qt/modaloverlay.cpp",
        "status": "modified",
        "additions": 174,
        "deletions": 174,
        "changes": 348,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/qt/modaloverlay.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/qt/modaloverlay.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/modaloverlay.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,174 +1,174 @@\n-// Copyright (c) 2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <qt/modaloverlay.h>\n-#include <qt/forms/ui_modaloverlay.h>\n-\n-#include <qt/guiutil.h>\n-\n-#include <chainparams.h>\n-\n-#include <QResizeEvent>\n-#include <QPropertyAnimation>\n-\n-ModalOverlay::ModalOverlay(QWidget *parent) :\n-QWidget(parent),\n-ui(new Ui::ModalOverlay),\n-bestHeaderHeight(0),\n-bestHeaderDate(QDateTime()),\n-layerIsVisible(false),\n-userClosed(false)\n-{\n-    ui->setupUi(this);\n-    connect(ui->closeButton, SIGNAL(clicked()), this, SLOT(closeClicked()));\n-    if (parent) {\n-        parent->installEventFilter(this);\n-        raise();\n-    }\n-\n-    blockProcessTime.clear();\n-    setVisible(false);\n-}\n-\n-ModalOverlay::~ModalOverlay()\n-{\n-    delete ui;\n-}\n-\n-bool ModalOverlay::eventFilter(QObject * obj, QEvent * ev) {\n-    if (obj == parent()) {\n-        if (ev->type() == QEvent::Resize) {\n-            QResizeEvent * rev = static_cast<QResizeEvent*>(ev);\n-            resize(rev->size());\n-            if (!layerIsVisible)\n-                setGeometry(0, height(), width(), height());\n-\n-        }\n-        else if (ev->type() == QEvent::ChildAdded) {\n-            raise();\n-        }\n-    }\n-    return QWidget::eventFilter(obj, ev);\n-}\n-\n-//! Tracks parent widget changes\n-bool ModalOverlay::event(QEvent* ev) {\n-    if (ev->type() == QEvent::ParentAboutToChange) {\n-        if (parent()) parent()->removeEventFilter(this);\n-    }\n-    else if (ev->type() == QEvent::ParentChange) {\n-        if (parent()) {\n-            parent()->installEventFilter(this);\n-            raise();\n-        }\n-    }\n-    return QWidget::event(ev);\n-}\n-\n-void ModalOverlay::setKnownBestHeight(int count, const QDateTime& blockDate)\n-{\n-    if (count > bestHeaderHeight) {\n-        bestHeaderHeight = count;\n-        bestHeaderDate = blockDate;\n-    }\n-}\n-\n-void ModalOverlay::tipUpdate(int count, const QDateTime& blockDate, double nVerificationProgress)\n-{\n-    QDateTime currentDate = QDateTime::currentDateTime();\n-\n-    // keep a vector of samples of verification progress at height\n-    blockProcessTime.push_front(qMakePair(currentDate.toMSecsSinceEpoch(), nVerificationProgress));\n-\n-    // show progress speed if we have more then one sample\n-    if (blockProcessTime.size() >= 2) {\n-        double progressDelta = 0;\n-        double progressPerHour = 0;\n-        qint64 timeDelta = 0;\n-        qint64 remainingMSecs = 0;\n-        double remainingProgress = 1.0 - nVerificationProgress;\n-        for (int i = 1; i < blockProcessTime.size(); i++) {\n-            QPair<qint64, double> sample = blockProcessTime[i];\n-\n-            // take first sample after 500 seconds or last available one\n-            if (sample.first < (currentDate.toMSecsSinceEpoch() - 500 * 1000) || i == blockProcessTime.size() - 1) {\n-                progressDelta = blockProcessTime[0].second - sample.second;\n-                timeDelta = blockProcessTime[0].first - sample.first;\n-                progressPerHour = progressDelta / (double) timeDelta * 1000 * 3600;\n-                remainingMSecs = (progressDelta > 0) ? remainingProgress / progressDelta * timeDelta : -1;\n-                break;\n-            }\n-        }\n-        // show progress increase per hour\n-        ui->progressIncreasePerH->setText(QString::number(progressPerHour * 100, 'f', 2)+\"%\");\n-\n-        // show expected remaining time\n-        if(remainingMSecs >= 0) {\t\n-            ui->expectedTimeLeft->setText(GUIUtil::formatNiceTimeOffset(remainingMSecs / 1000.0));\n-        } else {\n-            ui->expectedTimeLeft->setText(QObject::tr(\"unknown\"));\n-        }\n-\n-        static const int MAX_SAMPLES = 5000;\n-        if (blockProcessTime.count() > MAX_SAMPLES) {\n-            blockProcessTime.remove(MAX_SAMPLES, blockProcessTime.count() - MAX_SAMPLES);\n-        }\n-    }\n-\n-    // show the last block date\n-    ui->newestBlockDate->setText(blockDate.toString());\n-\n-    // show the percentage done according to nVerificationProgress\n-    ui->percentageProgress->setText(QString::number(nVerificationProgress*100, 'f', 2)+\"%\");\n-    ui->progressBar->setValue(nVerificationProgress*100);\n-\n-    if (!bestHeaderDate.isValid())\n-        // not syncing\n-        return;\n-\n-    // estimate the number of headers left based on nPowTargetSpacing\n-    // and check if the gui is not aware of the best header (happens rarely)\n-    int estimateNumHeadersLeft = bestHeaderDate.secsTo(currentDate) / Params().GetConsensus().nPowTargetSpacing;\n-    bool hasBestHeader = bestHeaderHeight >= count;\n-\n-    // show remaining number of blocks\n-    if (estimateNumHeadersLeft < HEADER_HEIGHT_DELTA_SYNC && hasBestHeader) {\n-        ui->numberOfBlocksLeft->setText(QString::number(bestHeaderHeight - count));\n-    } else {\n-        ui->numberOfBlocksLeft->setText(tr(\"Unknown. Syncing Headers (%1)...\").arg(bestHeaderHeight));\n-        ui->expectedTimeLeft->setText(tr(\"Unknown...\"));\n-    }\n-}\n-\n-void ModalOverlay::toggleVisibility()\n-{\n-    showHide(layerIsVisible, true);\n-    if (!layerIsVisible)\n-        userClosed = true;\n-}\n-\n-void ModalOverlay::showHide(bool hide, bool userRequested)\n-{\n-    if ( (layerIsVisible && !hide) || (!layerIsVisible && hide) || (!hide && userClosed && !userRequested))\n-        return;\n-\n-    if (!isVisible() && !hide)\n-        setVisible(true);\n-\n-    setGeometry(0, hide ? 0 : height(), width(), height());\n-\n-    QPropertyAnimation* animation = new QPropertyAnimation(this, \"pos\");\n-    animation->setDuration(300);\n-    animation->setStartValue(QPoint(0, hide ? 0 : this->height()));\n-    animation->setEndValue(QPoint(0, hide ? this->height() : 0));\n-    animation->setEasingCurve(QEasingCurve::OutQuad);\n-    animation->start(QAbstractAnimation::DeleteWhenStopped);\n-    layerIsVisible = !hide;\n-}\n-\n-void ModalOverlay::closeClicked()\n-{\n-    showHide(true);\n-    userClosed = true;\n-}\n+// Copyright (c) 2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <qt/modaloverlay.h>\r\n+#include <qt/forms/ui_modaloverlay.h>\r\n+\r\n+#include <qt/guiutil.h>\r\n+\r\n+#include <chainparams.h>\r\n+\r\n+#include <QResizeEvent>\r\n+#include <QPropertyAnimation>\r\n+\r\n+ModalOverlay::ModalOverlay(QWidget *parent) :\r\n+QWidget(parent),\r\n+ui(new Ui::ModalOverlay),\r\n+bestHeaderHeight(0),\r\n+bestHeaderDate(QDateTime()),\r\n+layerIsVisible(false),\r\n+userClosed(false)\r\n+{\r\n+    ui->setupUi(this);\r\n+    connect(ui->closeButton, SIGNAL(clicked()), this, SLOT(closeClicked()));\r\n+    if (parent) {\r\n+        parent->installEventFilter(this);\r\n+        raise();\r\n+    }\r\n+\r\n+    blockProcessTime.clear();\r\n+    setVisible(false);\r\n+}\r\n+\r\n+ModalOverlay::~ModalOverlay()\r\n+{\r\n+    delete ui;\r\n+}\r\n+\r\n+bool ModalOverlay::eventFilter(QObject * obj, QEvent * ev) {\r\n+    if (obj == parent()) {\r\n+        if (ev->type() == QEvent::Resize) {\r\n+            QResizeEvent * rev = static_cast<QResizeEvent*>(ev);\r\n+            resize(rev->size());\r\n+            if (!layerIsVisible)\r\n+                setGeometry(0, height(), width(), height());\r\n+\r\n+        }\r\n+        else if (ev->type() == QEvent::ChildAdded) {\r\n+            raise();\r\n+        }\r\n+    }\r\n+    return QWidget::eventFilter(obj, ev);\r\n+}\r\n+\r\n+//! Tracks parent widget changes\r\n+bool ModalOverlay::event(QEvent* ev) {\r\n+    if (ev->type() == QEvent::ParentAboutToChange) {\r\n+        if (parent()) parent()->removeEventFilter(this);\r\n+    }\r\n+    else if (ev->type() == QEvent::ParentChange) {\r\n+        if (parent()) {\r\n+            parent()->installEventFilter(this);\r\n+            raise();\r\n+        }\r\n+    }\r\n+    return QWidget::event(ev);\r\n+}\r\n+\r\n+void ModalOverlay::setKnownBestHeight(int count, const QDateTime& blockDate)\r\n+{\r\n+    if (count > bestHeaderHeight) {\r\n+        bestHeaderHeight = count;\r\n+        bestHeaderDate = blockDate;\r\n+    }\r\n+}\r\n+\r\n+void ModalOverlay::tipUpdate(int count, const QDateTime& blockDate, double nVerificationProgress)\r\n+{\r\n+    QDateTime currentDate = QDateTime::currentDateTime();\r\n+\r\n+    // keep a vector of samples of verification progress at height\r\n+    blockProcessTime.push_front(qMakePair(currentDate.toMSecsSinceEpoch(), nVerificationProgress));\r\n+\r\n+    // show progress speed if we have more then one sample\r\n+    if (blockProcessTime.size() >= 2) {\r\n+        double progressDelta = 0;\r\n+        double progressPerHour = 0;\r\n+        qint64 timeDelta = 0;\r\n+        qint64 remainingMSecs = 0;\r\n+        double remainingProgress = 1.0 - nVerificationProgress;\r\n+        for (int i = 1; i < blockProcessTime.size(); i++) {\r\n+            QPair<qint64, double> sample = blockProcessTime[i];\r\n+\r\n+            // take first sample after 500 seconds or last available one\r\n+            if (sample.first < (currentDate.toMSecsSinceEpoch() - 500 * 1000) || i == blockProcessTime.size() - 1) {\r\n+                progressDelta = blockProcessTime[0].second - sample.second;\r\n+                timeDelta = blockProcessTime[0].first - sample.first;\r\n+                progressPerHour = progressDelta / (double) timeDelta * 1000 * 3600;\r\n+                remainingMSecs = (progressDelta > 0) ? remainingProgress / progressDelta * timeDelta : -1;\r\n+                break;\r\n+            }\r\n+        }\r\n+        // show progress increase per hour\r\n+        ui->progressIncreasePerH->setText(QString::number(progressPerHour * 100, 'f', 2)+\"%\");\r\n+\r\n+        // show expected remaining time\r\n+        if(remainingMSecs >= 0) {\t\r\n+            ui->expectedTimeLeft->setText(GUIUtil::formatNiceTimeOffset(remainingMSecs / 1000.0));\r\n+        } else {\r\n+            ui->expectedTimeLeft->setText(QObject::tr(\"unknown\"));\r\n+        }\r\n+\r\n+        static const int MAX_SAMPLES = 5000;\r\n+        if (blockProcessTime.count() > MAX_SAMPLES) {\r\n+            blockProcessTime.remove(MAX_SAMPLES, blockProcessTime.count() - MAX_SAMPLES);\r\n+        }\r\n+    }\r\n+\r\n+    // show the last block date\r\n+    ui->newestBlockDate->setText(blockDate.toString());\r\n+\r\n+    // show the percentage done according to nVerificationProgress\r\n+    ui->percentageProgress->setText(QString::number(nVerificationProgress*100, 'f', 2)+\"%\");\r\n+    ui->progressBar->setValue(nVerificationProgress*100);\r\n+\r\n+    if (!bestHeaderDate.isValid())\r\n+        // not syncing\r\n+        return;\r\n+\r\n+    // estimate the number of headers left based on nPowTargetSpacing\r\n+    // and check if the gui is not aware of the best header (happens rarely)\r\n+    int estimateNumHeadersLeft = bestHeaderDate.secsTo(currentDate) / Params().GetConsensus().nBtvPowTargetSpacing;\r\n+    bool hasBestHeader = bestHeaderHeight >= count;\r\n+\r\n+    // show remaining number of blocks\r\n+    if (estimateNumHeadersLeft < HEADER_HEIGHT_DELTA_SYNC && hasBestHeader) {\r\n+        ui->numberOfBlocksLeft->setText(QString::number(bestHeaderHeight - count));\r\n+    } else {\r\n+        ui->numberOfBlocksLeft->setText(tr(\"Unknown. Syncing Headers (%1)...\").arg(bestHeaderHeight));\r\n+        ui->expectedTimeLeft->setText(tr(\"Unknown...\"));\r\n+    }\r\n+}\r\n+\r\n+void ModalOverlay::toggleVisibility()\r\n+{\r\n+    showHide(layerIsVisible, true);\r\n+    if (!layerIsVisible)\r\n+        userClosed = true;\r\n+}\r\n+\r\n+void ModalOverlay::showHide(bool hide, bool userRequested)\r\n+{\r\n+    if ( (layerIsVisible && !hide) || (!layerIsVisible && hide) || (!hide && userClosed && !userRequested))\r\n+        return;\r\n+\r\n+    if (!isVisible() && !hide)\r\n+        setVisible(true);\r\n+\r\n+    setGeometry(0, hide ? 0 : height(), width(), height());\r\n+\r\n+    QPropertyAnimation* animation = new QPropertyAnimation(this, \"pos\");\r\n+    animation->setDuration(300);\r\n+    animation->setStartValue(QPoint(0, hide ? 0 : this->height()));\r\n+    animation->setEndValue(QPoint(0, hide ? this->height() : 0));\r\n+    animation->setEasingCurve(QEasingCurve::OutQuad);\r\n+    animation->start(QAbstractAnimation::DeleteWhenStopped);\r\n+    layerIsVisible = !hide;\r\n+}\r\n+\r\n+void ModalOverlay::closeClicked()\r\n+{\r\n+    showHide(true);\r\n+    userClosed = true;\r\n+}\r"
      },
      {
        "sha": "a0449bda93971d5b76352f8270060226ca6ea003",
        "filename": "src/qt/sendcoinsdialog.cpp",
        "status": "modified",
        "additions": 920,
        "deletions": 920,
        "changes": 1840,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/qt/sendcoinsdialog.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/qt/sendcoinsdialog.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/sendcoinsdialog.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,920 +1,920 @@\n-// Copyright (c) 2011-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <qt/sendcoinsdialog.h>\n-#include <qt/forms/ui_sendcoinsdialog.h>\n-\n-#include <qt/addresstablemodel.h>\n-#include <qt/bitcoinunits.h>\n-#include <qt/clientmodel.h>\n-#include <qt/coincontroldialog.h>\n-#include <qt/guiutil.h>\n-#include <qt/optionsmodel.h>\n-#include <qt/platformstyle.h>\n-#include <qt/sendcoinsentry.h>\n-\n-#include <base58.h>\n-#include <chainparams.h>\n-#include <wallet/coincontrol.h>\n-#include <validation.h> // mempool and minRelayTxFee\n-#include <ui_interface.h>\n-#include <txmempool.h>\n-#include <policy/fees.h>\n-#include <wallet/fees.h>\n-\n-#include <QFontMetrics>\n-#include <QScrollBar>\n-#include <QSettings>\n-#include <QTextDocument>\n-\n-static const std::array<int, 9> confTargets = { {2, 4, 6, 12, 24, 48, 144, 504, 1008} };\n-int getConfTargetForIndex(int index) {\n-    if (index+1 > static_cast<int>(confTargets.size())) {\n-        return confTargets.back();\n-    }\n-    if (index < 0) {\n-        return confTargets[0];\n-    }\n-    return confTargets[index];\n-}\n-int getIndexForConfTarget(int target) {\n-    for (unsigned int i = 0; i < confTargets.size(); i++) {\n-        if (confTargets[i] >= target) {\n-            return i;\n-        }\n-    }\n-    return confTargets.size() - 1;\n-}\n-\n-SendCoinsDialog::SendCoinsDialog(const PlatformStyle *_platformStyle, QWidget *parent) :\n-    QDialog(parent),\n-    ui(new Ui::SendCoinsDialog),\n-    clientModel(0),\n-    model(0),\n-    fNewRecipientAllowed(true),\n-    fFeeMinimized(true),\n-    platformStyle(_platformStyle)\n-{\n-    ui->setupUi(this);\n-\n-    if (!_platformStyle->getImagesOnButtons()) {\n-        ui->addButton->setIcon(QIcon());\n-        ui->clearButton->setIcon(QIcon());\n-        ui->sendButton->setIcon(QIcon());\n-    } else {\n-        ui->addButton->setIcon(_platformStyle->SingleColorIcon(\":/icons/add\"));\n-        ui->clearButton->setIcon(_platformStyle->SingleColorIcon(\":/icons/remove\"));\n-        ui->sendButton->setIcon(_platformStyle->SingleColorIcon(\":/icons/send\"));\n-    }\n-\n-    GUIUtil::setupAddressWidget(ui->lineEditCoinControlChange, this);\n-\n-    addEntry();\n-\n-    connect(ui->addButton, SIGNAL(clicked()), this, SLOT(addEntry()));\n-    connect(ui->clearButton, SIGNAL(clicked()), this, SLOT(clear()));\n-\n-    // Coin Control\n-    connect(ui->pushButtonCoinControl, SIGNAL(clicked()), this, SLOT(coinControlButtonClicked()));\n-    connect(ui->checkBoxCoinControlChange, SIGNAL(stateChanged(int)), this, SLOT(coinControlChangeChecked(int)));\n-    connect(ui->lineEditCoinControlChange, SIGNAL(textEdited(const QString &)), this, SLOT(coinControlChangeEdited(const QString &)));\n-\n-    // Coin Control: clipboard actions\n-    QAction *clipboardQuantityAction = new QAction(tr(\"Copy quantity\"), this);\n-    QAction *clipboardAmountAction = new QAction(tr(\"Copy amount\"), this);\n-    QAction *clipboardFeeAction = new QAction(tr(\"Copy fee\"), this);\n-    QAction *clipboardAfterFeeAction = new QAction(tr(\"Copy after fee\"), this);\n-    QAction *clipboardBytesAction = new QAction(tr(\"Copy bytes\"), this);\n-    QAction *clipboardLowOutputAction = new QAction(tr(\"Copy dust\"), this);\n-    QAction *clipboardChangeAction = new QAction(tr(\"Copy change\"), this);\n-    connect(clipboardQuantityAction, SIGNAL(triggered()), this, SLOT(coinControlClipboardQuantity()));\n-    connect(clipboardAmountAction, SIGNAL(triggered()), this, SLOT(coinControlClipboardAmount()));\n-    connect(clipboardFeeAction, SIGNAL(triggered()), this, SLOT(coinControlClipboardFee()));\n-    connect(clipboardAfterFeeAction, SIGNAL(triggered()), this, SLOT(coinControlClipboardAfterFee()));\n-    connect(clipboardBytesAction, SIGNAL(triggered()), this, SLOT(coinControlClipboardBytes()));\n-    connect(clipboardLowOutputAction, SIGNAL(triggered()), this, SLOT(coinControlClipboardLowOutput()));\n-    connect(clipboardChangeAction, SIGNAL(triggered()), this, SLOT(coinControlClipboardChange()));\n-    ui->labelCoinControlQuantity->addAction(clipboardQuantityAction);\n-    ui->labelCoinControlAmount->addAction(clipboardAmountAction);\n-    ui->labelCoinControlFee->addAction(clipboardFeeAction);\n-    ui->labelCoinControlAfterFee->addAction(clipboardAfterFeeAction);\n-    ui->labelCoinControlBytes->addAction(clipboardBytesAction);\n-    ui->labelCoinControlLowOutput->addAction(clipboardLowOutputAction);\n-    ui->labelCoinControlChange->addAction(clipboardChangeAction);\n-\n-    // init transaction fee section\n-    QSettings settings;\n-    if (!settings.contains(\"fFeeSectionMinimized\"))\n-        settings.setValue(\"fFeeSectionMinimized\", true);\n-    if (!settings.contains(\"nFeeRadio\") && settings.contains(\"nTransactionFee\") && settings.value(\"nTransactionFee\").toLongLong() > 0) // compatibility\n-        settings.setValue(\"nFeeRadio\", 1); // custom\n-    if (!settings.contains(\"nFeeRadio\"))\n-        settings.setValue(\"nFeeRadio\", 0); // recommended\n-    if (!settings.contains(\"nSmartFeeSliderPosition\"))\n-        settings.setValue(\"nSmartFeeSliderPosition\", 0);\n-    if (!settings.contains(\"nTransactionFee\"))\n-        settings.setValue(\"nTransactionFee\", (qint64)DEFAULT_TRANSACTION_FEE);\n-    if (!settings.contains(\"fPayOnlyMinFee\"))\n-        settings.setValue(\"fPayOnlyMinFee\", false);\n-    ui->groupFee->setId(ui->radioSmartFee, 0);\n-    ui->groupFee->setId(ui->radioCustomFee, 1);\n-    ui->groupFee->button((int)std::max(0, std::min(1, settings.value(\"nFeeRadio\").toInt())))->setChecked(true);\n-    ui->customFee->setValue(settings.value(\"nTransactionFee\").toLongLong());\n-    ui->checkBoxMinimumFee->setChecked(settings.value(\"fPayOnlyMinFee\").toBool());\n-    minimizeFeeSection(settings.value(\"fFeeSectionMinimized\").toBool());\n-}\n-\n-void SendCoinsDialog::setClientModel(ClientModel *_clientModel)\n-{\n-    this->clientModel = _clientModel;\n-\n-    if (_clientModel) {\n-        connect(_clientModel, SIGNAL(numBlocksChanged(int,QDateTime,double,bool)), this, SLOT(updateSmartFeeLabel()));\n-    }\n-}\n-\n-void SendCoinsDialog::setModel(WalletModel *_model)\n-{\n-    this->model = _model;\n-\n-    if(_model && _model->getOptionsModel())\n-    {\n-        for(int i = 0; i < ui->entries->count(); ++i)\n-        {\n-            SendCoinsEntry *entry = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(i)->widget());\n-            if(entry)\n-            {\n-                entry->setModel(_model);\n-            }\n-        }\n-\n-        setBalance(_model->getBalance(), _model->getUnconfirmedBalance(), _model->getImmatureBalance(),\n-                   _model->getWatchBalance(), _model->getWatchUnconfirmedBalance(), _model->getWatchImmatureBalance());\n-        connect(_model, SIGNAL(balanceChanged(CAmount,CAmount,CAmount,CAmount,CAmount,CAmount)), this, SLOT(setBalance(CAmount,CAmount,CAmount,CAmount,CAmount,CAmount)));\n-        connect(_model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\n-        updateDisplayUnit();\n-\n-        // Coin Control\n-        connect(_model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(coinControlUpdateLabels()));\n-        connect(_model->getOptionsModel(), SIGNAL(coinControlFeaturesChanged(bool)), this, SLOT(coinControlFeatureChanged(bool)));\n-        ui->frameCoinControl->setVisible(_model->getOptionsModel()->getCoinControlFeatures());\n-        coinControlUpdateLabels();\n-\n-        // fee section\n-        for (const int &n : confTargets) {\n-            ui->confTargetSelector->addItem(tr(\"%1 (%2 blocks)\").arg(GUIUtil::formatNiceTimeOffset(n*Params().GetConsensus().nPowTargetSpacing)).arg(n));\n-        }\n-        connect(ui->confTargetSelector, SIGNAL(currentIndexChanged(int)), this, SLOT(updateSmartFeeLabel()));\n-        connect(ui->confTargetSelector, SIGNAL(currentIndexChanged(int)), this, SLOT(coinControlUpdateLabels()));\n-        connect(ui->groupFee, SIGNAL(buttonClicked(int)), this, SLOT(updateFeeSectionControls()));\n-        connect(ui->groupFee, SIGNAL(buttonClicked(int)), this, SLOT(coinControlUpdateLabels()));\n-        connect(ui->customFee, SIGNAL(valueChanged()), this, SLOT(coinControlUpdateLabels()));\n-        connect(ui->checkBoxMinimumFee, SIGNAL(stateChanged(int)), this, SLOT(setMinimumFee()));\n-        connect(ui->checkBoxMinimumFee, SIGNAL(stateChanged(int)), this, SLOT(updateFeeSectionControls()));\n-        connect(ui->checkBoxMinimumFee, SIGNAL(stateChanged(int)), this, SLOT(coinControlUpdateLabels()));\n-        connect(ui->optInRBF, SIGNAL(stateChanged(int)), this, SLOT(updateSmartFeeLabel()));\n-        connect(ui->optInRBF, SIGNAL(stateChanged(int)), this, SLOT(coinControlUpdateLabels()));\n-        ui->customFee->setSingleStep(GetRequiredFee(1000));\n-        updateFeeSectionControls();\n-        updateMinFeeLabel();\n-        updateSmartFeeLabel();\n-\n-        // set default rbf checkbox state\n-        ui->optInRBF->setCheckState(model->getDefaultWalletRbf() ? Qt::Checked : Qt::Unchecked);\n-\n-        // set the smartfee-sliders default value (wallets default conf.target or last stored value)\n-        QSettings settings;\n-        if (settings.value(\"nSmartFeeSliderPosition\").toInt() != 0) {\n-            // migrate nSmartFeeSliderPosition to nConfTarget\n-            // nConfTarget is available since 0.15 (replaced nSmartFeeSliderPosition)\n-            int nConfirmTarget = 25 - settings.value(\"nSmartFeeSliderPosition\").toInt(); // 25 == old slider range\n-            settings.setValue(\"nConfTarget\", nConfirmTarget);\n-            settings.remove(\"nSmartFeeSliderPosition\");\n-        }\n-        if (settings.value(\"nConfTarget\").toInt() == 0)\n-            ui->confTargetSelector->setCurrentIndex(getIndexForConfTarget(model->getDefaultConfirmTarget()));\n-        else\n-            ui->confTargetSelector->setCurrentIndex(getIndexForConfTarget(settings.value(\"nConfTarget\").toInt()));\n-    }\n-}\n-\n-SendCoinsDialog::~SendCoinsDialog()\n-{\n-    QSettings settings;\n-    settings.setValue(\"fFeeSectionMinimized\", fFeeMinimized);\n-    settings.setValue(\"nFeeRadio\", ui->groupFee->checkedId());\n-    settings.setValue(\"nConfTarget\", getConfTargetForIndex(ui->confTargetSelector->currentIndex()));\n-    settings.setValue(\"nTransactionFee\", (qint64)ui->customFee->value());\n-    settings.setValue(\"fPayOnlyMinFee\", ui->checkBoxMinimumFee->isChecked());\n-\n-    delete ui;\n-}\n-\n-void SendCoinsDialog::on_sendButton_clicked()\n-{\n-    if(!model || !model->getOptionsModel())\n-        return;\n-\n-    QList<SendCoinsRecipient> recipients;\n-    bool valid = true;\n-\n-    for(int i = 0; i < ui->entries->count(); ++i)\n-    {\n-        SendCoinsEntry *entry = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(i)->widget());\n-        if(entry)\n-        {\n-            if(entry->validate())\n-            {\n-                recipients.append(entry->getValue());\n-            }\n-            else\n-            {\n-                valid = false;\n-            }\n-        }\n-    }\n-\n-    if(!valid || recipients.isEmpty())\n-    {\n-        return;\n-    }\n-\n-    fNewRecipientAllowed = false;\n-    WalletModel::UnlockContext ctx(model->requestUnlock());\n-    if(!ctx.isValid())\n-    {\n-        // Unlock wallet was cancelled\n-        fNewRecipientAllowed = true;\n-        return;\n-    }\n-\n-    // prepare transaction for getting txFee earlier\n-    WalletModelTransaction currentTransaction(recipients);\n-    WalletModel::SendCoinsReturn prepareStatus;\n-\n-    // Always use a CCoinControl instance, use the CoinControlDialog instance if CoinControl has been enabled\n-    CCoinControl ctrl;\n-    if (model->getOptionsModel()->getCoinControlFeatures())\n-        ctrl = *CoinControlDialog::coinControl;\n-\n-    updateCoinControlState(ctrl);\n-\n-    prepareStatus = model->prepareTransaction(currentTransaction, ctrl);\n-\n-    // process prepareStatus and on error generate message shown to user\n-    processSendCoinsReturn(prepareStatus,\n-        BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), currentTransaction.getTransactionFee()));\n-\n-    if(prepareStatus.status != WalletModel::OK) {\n-        fNewRecipientAllowed = true;\n-        return;\n-    }\n-\n-    CAmount txFee = currentTransaction.getTransactionFee();\n-\n-    // Format confirmation message\n-    QStringList formatted;\n-    for (const SendCoinsRecipient &rcp : currentTransaction.getRecipients())\n-    {\n-        // generate bold amount string\n-        QString amount = \"<b>\" + BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), rcp.amount);\n-        amount.append(\"</b>\");\n-        // generate monospace address string\n-        QString address = \"<span style='font-family: monospace;'>\" + rcp.address;\n-        address.append(\"</span>\");\n-\n-        QString recipientElement;\n-\n-        if (!rcp.paymentRequest.IsInitialized()) // normal payment\n-        {\n-            if(rcp.label.length() > 0) // label with address\n-            {\n-                recipientElement = tr(\"%1 to %2\").arg(amount, GUIUtil::HtmlEscape(rcp.label));\n-                recipientElement.append(QString(\" (%1)\").arg(address));\n-            }\n-            else // just address\n-            {\n-                recipientElement = tr(\"%1 to %2\").arg(amount, address);\n-            }\n-        }\n-        else if(!rcp.authenticatedMerchant.isEmpty()) // authenticated payment request\n-        {\n-            recipientElement = tr(\"%1 to %2\").arg(amount, GUIUtil::HtmlEscape(rcp.authenticatedMerchant));\n-        }\n-        else // unauthenticated payment request\n-        {\n-            recipientElement = tr(\"%1 to %2\").arg(amount, address);\n-        }\n-\n-        formatted.append(recipientElement);\n-    }\n-\n-    QString questionString = tr(\"Are you sure you want to send?\");\n-    questionString.append(\"<br /><br />%1\");\n-\n-    if(txFee > 0)\n-    {\n-        // append fee string if a fee is required\n-        questionString.append(\"<hr /><span style='color:#aa0000;'>\");\n-        questionString.append(BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), txFee));\n-        questionString.append(\"</span> \");\n-        questionString.append(tr(\"added as transaction fee\"));\n-\n-        // append transaction size\n-        questionString.append(\" (\" + QString::number((double)currentTransaction.getTransactionSize() / 1000) + \" kB)\");\n-    }\n-\n-    // add total amount in all subdivision units\n-    questionString.append(\"<hr />\");\n-    CAmount totalAmount = currentTransaction.getTotalTransactionAmount() + txFee;\n-    QStringList alternativeUnits;\n-    for (BitcoinUnits::Unit u : BitcoinUnits::availableUnits())\n-    {\n-        if(u != model->getOptionsModel()->getDisplayUnit())\n-            alternativeUnits.append(BitcoinUnits::formatHtmlWithUnit(u, totalAmount));\n-    }\n-    questionString.append(tr(\"Total Amount %1\")\n-        .arg(BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), totalAmount)));\n-    questionString.append(QString(\"<span style='font-size:10pt;font-weight:normal;'><br />(=%2)</span>\")\n-        .arg(alternativeUnits.join(\" \" + tr(\"or\") + \"<br />\")));\n-\n-    if (ui->optInRBF->isChecked())\n-    {\n-        questionString.append(\"<hr /><span>\");\n-        questionString.append(tr(\"You can increase the fee later (signals Replace-By-Fee).\"));\n-        questionString.append(\"</span>\");\n-    }\n-\n-    SendConfirmationDialog confirmationDialog(tr(\"Confirm send coins\"),\n-        questionString.arg(formatted.join(\"<br />\")), SEND_CONFIRM_DELAY, this);\n-    confirmationDialog.exec();\n-    QMessageBox::StandardButton retval = (QMessageBox::StandardButton)confirmationDialog.result();\n-\n-    if(retval != QMessageBox::Yes)\n-    {\n-        fNewRecipientAllowed = true;\n-        return;\n-    }\n-\n-    // now send the prepared transaction\n-    WalletModel::SendCoinsReturn sendStatus = model->sendCoins(currentTransaction);\n-    // process sendStatus and on error generate message shown to user\n-    processSendCoinsReturn(sendStatus);\n-\n-    if (sendStatus.status == WalletModel::OK)\n-    {\n-        accept();\n-        CoinControlDialog::coinControl->UnSelectAll();\n-        coinControlUpdateLabels();\n-    }\n-    fNewRecipientAllowed = true;\n-}\n-\n-void SendCoinsDialog::clear()\n-{\n-    // Remove entries until only one left\n-    while(ui->entries->count())\n-    {\n-        ui->entries->takeAt(0)->widget()->deleteLater();\n-    }\n-    addEntry();\n-\n-    updateTabsAndLabels();\n-}\n-\n-void SendCoinsDialog::reject()\n-{\n-    clear();\n-}\n-\n-void SendCoinsDialog::accept()\n-{\n-    clear();\n-}\n-\n-SendCoinsEntry *SendCoinsDialog::addEntry()\n-{\n-    SendCoinsEntry *entry = new SendCoinsEntry(platformStyle, this);\n-    entry->setModel(model);\n-    ui->entries->addWidget(entry);\n-    connect(entry, SIGNAL(removeEntry(SendCoinsEntry*)), this, SLOT(removeEntry(SendCoinsEntry*)));\n-    connect(entry, SIGNAL(useAvailableBalance(SendCoinsEntry*)), this, SLOT(useAvailableBalance(SendCoinsEntry*)));\n-    connect(entry, SIGNAL(payAmountChanged()), this, SLOT(coinControlUpdateLabels()));\n-    connect(entry, SIGNAL(subtractFeeFromAmountChanged()), this, SLOT(coinControlUpdateLabels()));\n-\n-    // Focus the field, so that entry can start immediately\n-    entry->clear();\n-    entry->setFocus();\n-    ui->scrollAreaWidgetContents->resize(ui->scrollAreaWidgetContents->sizeHint());\n-    qApp->processEvents();\n-    QScrollBar* bar = ui->scrollArea->verticalScrollBar();\n-    if(bar)\n-        bar->setSliderPosition(bar->maximum());\n-\n-    updateTabsAndLabels();\n-    return entry;\n-}\n-\n-void SendCoinsDialog::updateTabsAndLabels()\n-{\n-    setupTabChain(0);\n-    coinControlUpdateLabels();\n-}\n-\n-void SendCoinsDialog::removeEntry(SendCoinsEntry* entry)\n-{\n-    entry->hide();\n-\n-    // If the last entry is about to be removed add an empty one\n-    if (ui->entries->count() == 1)\n-        addEntry();\n-\n-    entry->deleteLater();\n-\n-    updateTabsAndLabels();\n-}\n-\n-QWidget *SendCoinsDialog::setupTabChain(QWidget *prev)\n-{\n-    for(int i = 0; i < ui->entries->count(); ++i)\n-    {\n-        SendCoinsEntry *entry = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(i)->widget());\n-        if(entry)\n-        {\n-            prev = entry->setupTabChain(prev);\n-        }\n-    }\n-    QWidget::setTabOrder(prev, ui->sendButton);\n-    QWidget::setTabOrder(ui->sendButton, ui->clearButton);\n-    QWidget::setTabOrder(ui->clearButton, ui->addButton);\n-    return ui->addButton;\n-}\n-\n-void SendCoinsDialog::setAddress(const QString &address)\n-{\n-    SendCoinsEntry *entry = 0;\n-    // Replace the first entry if it is still unused\n-    if(ui->entries->count() == 1)\n-    {\n-        SendCoinsEntry *first = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(0)->widget());\n-        if(first->isClear())\n-        {\n-            entry = first;\n-        }\n-    }\n-    if(!entry)\n-    {\n-        entry = addEntry();\n-    }\n-\n-    entry->setAddress(address);\n-}\n-\n-void SendCoinsDialog::pasteEntry(const SendCoinsRecipient &rv)\n-{\n-    if(!fNewRecipientAllowed)\n-        return;\n-\n-    SendCoinsEntry *entry = 0;\n-    // Replace the first entry if it is still unused\n-    if(ui->entries->count() == 1)\n-    {\n-        SendCoinsEntry *first = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(0)->widget());\n-        if(first->isClear())\n-        {\n-            entry = first;\n-        }\n-    }\n-    if(!entry)\n-    {\n-        entry = addEntry();\n-    }\n-\n-    entry->setValue(rv);\n-    updateTabsAndLabels();\n-}\n-\n-bool SendCoinsDialog::handlePaymentRequest(const SendCoinsRecipient &rv)\n-{\n-    // Just paste the entry, all pre-checks\n-    // are done in paymentserver.cpp.\n-    pasteEntry(rv);\n-    return true;\n-}\n-\n-void SendCoinsDialog::setBalance(const CAmount& balance, const CAmount& unconfirmedBalance, const CAmount& immatureBalance,\n-                                 const CAmount& watchBalance, const CAmount& watchUnconfirmedBalance, const CAmount& watchImmatureBalance)\n-{\n-    Q_UNUSED(unconfirmedBalance);\n-    Q_UNUSED(immatureBalance);\n-    Q_UNUSED(watchBalance);\n-    Q_UNUSED(watchUnconfirmedBalance);\n-    Q_UNUSED(watchImmatureBalance);\n-\n-    if(model && model->getOptionsModel())\n-    {\n-        ui->labelBalance->setText(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), balance));\n-    }\n-}\n-\n-void SendCoinsDialog::updateDisplayUnit()\n-{\n-    setBalance(model->getBalance(), 0, 0, 0, 0, 0);\n-    ui->customFee->setDisplayUnit(model->getOptionsModel()->getDisplayUnit());\n-    updateMinFeeLabel();\n-    updateSmartFeeLabel();\n-}\n-\n-void SendCoinsDialog::processSendCoinsReturn(const WalletModel::SendCoinsReturn &sendCoinsReturn, const QString &msgArg)\n-{\n-    QPair<QString, CClientUIInterface::MessageBoxFlags> msgParams;\n-    // Default to a warning message, override if error message is needed\n-    msgParams.second = CClientUIInterface::MSG_WARNING;\n-\n-    // This comment is specific to SendCoinsDialog usage of WalletModel::SendCoinsReturn.\n-    // WalletModel::TransactionCommitFailed is used only in WalletModel::sendCoins()\n-    // all others are used only in WalletModel::prepareTransaction()\n-    switch(sendCoinsReturn.status)\n-    {\n-    case WalletModel::InvalidAddress:\n-        msgParams.first = tr(\"The recipient address is not valid. Please recheck.\");\n-        break;\n-    case WalletModel::InvalidAmount:\n-        msgParams.first = tr(\"The amount to pay must be larger than 0.\");\n-        break;\n-    case WalletModel::AmountExceedsBalance:\n-        msgParams.first = tr(\"The amount exceeds your balance.\");\n-        break;\n-    case WalletModel::AmountWithFeeExceedsBalance:\n-        msgParams.first = tr(\"The total exceeds your balance when the %1 transaction fee is included.\").arg(msgArg);\n-        break;\n-    case WalletModel::DuplicateAddress:\n-        msgParams.first = tr(\"Duplicate address found: addresses should only be used once each.\");\n-        break;\n-    case WalletModel::TransactionCreationFailed:\n-        msgParams.first = tr(\"Transaction creation failed!\");\n-        msgParams.second = CClientUIInterface::MSG_ERROR;\n-        break;\n-    case WalletModel::TransactionCommitFailed:\n-        msgParams.first = tr(\"The transaction was rejected with the following reason: %1\").arg(sendCoinsReturn.reasonCommitFailed);\n-        msgParams.second = CClientUIInterface::MSG_ERROR;\n-        break;\n-    case WalletModel::AbsurdFee:\n-        msgParams.first = tr(\"A fee higher than %1 is considered an absurdly high fee.\").arg(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), maxTxFee));\n-        break;\n-    case WalletModel::PaymentRequestExpired:\n-        msgParams.first = tr(\"Payment request expired.\");\n-        msgParams.second = CClientUIInterface::MSG_ERROR;\n-        break;\n-    // included to prevent a compiler warning.\n-    case WalletModel::OK:\n-    default:\n-        return;\n-    }\n-\n-    Q_EMIT message(tr(\"Send Coins\"), msgParams.first, msgParams.second);\n-}\n-\n-void SendCoinsDialog::minimizeFeeSection(bool fMinimize)\n-{\n-    ui->labelFeeMinimized->setVisible(fMinimize);\n-    ui->buttonChooseFee  ->setVisible(fMinimize);\n-    ui->buttonMinimizeFee->setVisible(!fMinimize);\n-    ui->frameFeeSelection->setVisible(!fMinimize);\n-    ui->horizontalLayoutSmartFee->setContentsMargins(0, (fMinimize ? 0 : 6), 0, 0);\n-    fFeeMinimized = fMinimize;\n-}\n-\n-void SendCoinsDialog::on_buttonChooseFee_clicked()\n-{\n-    minimizeFeeSection(false);\n-}\n-\n-void SendCoinsDialog::on_buttonMinimizeFee_clicked()\n-{\n-    updateFeeMinimizedLabel();\n-    minimizeFeeSection(true);\n-}\n-\n-void SendCoinsDialog::useAvailableBalance(SendCoinsEntry* entry)\n-{\n-    // Get CCoinControl instance if CoinControl is enabled or create a new one.\n-    CCoinControl coin_control;\n-    if (model->getOptionsModel()->getCoinControlFeatures()) {\n-        coin_control = *CoinControlDialog::coinControl;\n-    }\n-\n-    // Calculate available amount to send.\n-    CAmount amount = model->getBalance(&coin_control);\n-    for (int i = 0; i < ui->entries->count(); ++i) {\n-        SendCoinsEntry* e = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(i)->widget());\n-        if (e && !e->isHidden() && e != entry) {\n-            amount -= e->getValue().amount;\n-        }\n-    }\n-\n-    if (amount > 0) {\n-      entry->checkSubtractFeeFromAmount();\n-      entry->setAmount(amount);\n-    } else {\n-      entry->setAmount(0);\n-    }\n-}\n-\n-void SendCoinsDialog::setMinimumFee()\n-{\n-    ui->customFee->setValue(GetRequiredFee(1000));\n-}\n-\n-void SendCoinsDialog::updateFeeSectionControls()\n-{\n-    ui->confTargetSelector      ->setEnabled(ui->radioSmartFee->isChecked());\n-    ui->labelSmartFee           ->setEnabled(ui->radioSmartFee->isChecked());\n-    ui->labelSmartFee2          ->setEnabled(ui->radioSmartFee->isChecked());\n-    ui->labelSmartFee3          ->setEnabled(ui->radioSmartFee->isChecked());\n-    ui->labelFeeEstimation      ->setEnabled(ui->radioSmartFee->isChecked());\n-    ui->checkBoxMinimumFee      ->setEnabled(ui->radioCustomFee->isChecked());\n-    ui->labelMinFeeWarning      ->setEnabled(ui->radioCustomFee->isChecked());\n-    ui->labelCustomPerKilobyte  ->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked());\n-    ui->customFee               ->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked());\n-}\n-\n-void SendCoinsDialog::updateFeeMinimizedLabel()\n-{\n-    if(!model || !model->getOptionsModel())\n-        return;\n-\n-    if (ui->radioSmartFee->isChecked())\n-        ui->labelFeeMinimized->setText(ui->labelSmartFee->text());\n-    else {\n-        ui->labelFeeMinimized->setText(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), ui->customFee->value()) + \"/kB\");\n-    }\n-}\n-\n-void SendCoinsDialog::updateMinFeeLabel()\n-{\n-    if (model && model->getOptionsModel())\n-        ui->checkBoxMinimumFee->setText(tr(\"Pay only the required fee of %1\").arg(\n-            BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), GetRequiredFee(1000)) + \"/kB\")\n-        );\n-}\n-\n-void SendCoinsDialog::updateCoinControlState(CCoinControl& ctrl)\n-{\n-    if (ui->radioCustomFee->isChecked()) {\n-        ctrl.m_feerate = CFeeRate(ui->customFee->value());\n-    } else {\n-        ctrl.m_feerate.reset();\n-    }\n-    // Avoid using global defaults when sending money from the GUI\n-    // Either custom fee will be used or if not selected, the confirmation target from dropdown box\n-    ctrl.m_confirm_target = getConfTargetForIndex(ui->confTargetSelector->currentIndex());\n-    ctrl.signalRbf = ui->optInRBF->isChecked();\n-}\n-\n-void SendCoinsDialog::updateSmartFeeLabel()\n-{\n-    if(!model || !model->getOptionsModel())\n-        return;\n-    CCoinControl coin_control;\n-    updateCoinControlState(coin_control);\n-    coin_control.m_feerate.reset(); // Explicitly use only fee estimation rate for smart fee labels\n-    FeeCalculation feeCalc;\n-    CFeeRate feeRate = CFeeRate(GetMinimumFee(1000, coin_control, ::mempool, ::feeEstimator, &feeCalc));\n-\n-    ui->labelSmartFee->setText(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), feeRate.GetFeePerK()) + \"/kB\");\n-\n-    if (feeCalc.reason == FeeReason::FALLBACK) {\n-        ui->labelSmartFee2->show(); // (Smart fee not initialized yet. This usually takes a few blocks...)\n-        ui->labelFeeEstimation->setText(\"\");\n-        ui->fallbackFeeWarningLabel->setVisible(true);\n-        int lightness = ui->fallbackFeeWarningLabel->palette().color(QPalette::WindowText).lightness();\n-        QColor warning_colour(255 - (lightness / 5), 176 - (lightness / 3), 48 - (lightness / 14));\n-        ui->fallbackFeeWarningLabel->setStyleSheet(\"QLabel { color: \" + warning_colour.name() + \"; }\");\n-        ui->fallbackFeeWarningLabel->setIndent(QFontMetrics(ui->fallbackFeeWarningLabel->font()).width(\"x\"));\n-    }\n-    else\n-    {\n-        ui->labelSmartFee2->hide();\n-        ui->labelFeeEstimation->setText(tr(\"Estimated to begin confirmation within %n block(s).\", \"\", feeCalc.returnedTarget));\n-        ui->fallbackFeeWarningLabel->setVisible(false);\n-    }\n-\n-    updateFeeMinimizedLabel();\n-}\n-\n-// Coin Control: copy label \"Quantity\" to clipboard\n-void SendCoinsDialog::coinControlClipboardQuantity()\n-{\n-    GUIUtil::setClipboard(ui->labelCoinControlQuantity->text());\n-}\n-\n-// Coin Control: copy label \"Amount\" to clipboard\n-void SendCoinsDialog::coinControlClipboardAmount()\n-{\n-    GUIUtil::setClipboard(ui->labelCoinControlAmount->text().left(ui->labelCoinControlAmount->text().indexOf(\" \")));\n-}\n-\n-// Coin Control: copy label \"Fee\" to clipboard\n-void SendCoinsDialog::coinControlClipboardFee()\n-{\n-    GUIUtil::setClipboard(ui->labelCoinControlFee->text().left(ui->labelCoinControlFee->text().indexOf(\" \")).replace(ASYMP_UTF8, \"\"));\n-}\n-\n-// Coin Control: copy label \"After fee\" to clipboard\n-void SendCoinsDialog::coinControlClipboardAfterFee()\n-{\n-    GUIUtil::setClipboard(ui->labelCoinControlAfterFee->text().left(ui->labelCoinControlAfterFee->text().indexOf(\" \")).replace(ASYMP_UTF8, \"\"));\n-}\n-\n-// Coin Control: copy label \"Bytes\" to clipboard\n-void SendCoinsDialog::coinControlClipboardBytes()\n-{\n-    GUIUtil::setClipboard(ui->labelCoinControlBytes->text().replace(ASYMP_UTF8, \"\"));\n-}\n-\n-// Coin Control: copy label \"Dust\" to clipboard\n-void SendCoinsDialog::coinControlClipboardLowOutput()\n-{\n-    GUIUtil::setClipboard(ui->labelCoinControlLowOutput->text());\n-}\n-\n-// Coin Control: copy label \"Change\" to clipboard\n-void SendCoinsDialog::coinControlClipboardChange()\n-{\n-    GUIUtil::setClipboard(ui->labelCoinControlChange->text().left(ui->labelCoinControlChange->text().indexOf(\" \")).replace(ASYMP_UTF8, \"\"));\n-}\n-\n-// Coin Control: settings menu - coin control enabled/disabled by user\n-void SendCoinsDialog::coinControlFeatureChanged(bool checked)\n-{\n-    ui->frameCoinControl->setVisible(checked);\n-\n-    if (!checked && model) // coin control features disabled\n-        CoinControlDialog::coinControl->SetNull();\n-\n-    coinControlUpdateLabels();\n-}\n-\n-// Coin Control: button inputs -> show actual coin control dialog\n-void SendCoinsDialog::coinControlButtonClicked()\n-{\n-    CoinControlDialog dlg(platformStyle);\n-    dlg.setModel(model);\n-    dlg.exec();\n-    coinControlUpdateLabels();\n-}\n-\n-// Coin Control: checkbox custom change address\n-void SendCoinsDialog::coinControlChangeChecked(int state)\n-{\n-    if (state == Qt::Unchecked)\n-    {\n-        CoinControlDialog::coinControl->destChange = CNoDestination();\n-        ui->labelCoinControlChangeLabel->clear();\n-    }\n-    else\n-        // use this to re-validate an already entered address\n-        coinControlChangeEdited(ui->lineEditCoinControlChange->text());\n-\n-    ui->lineEditCoinControlChange->setEnabled((state == Qt::Checked));\n-}\n-\n-// Coin Control: custom change address changed\n-void SendCoinsDialog::coinControlChangeEdited(const QString& text)\n-{\n-    if (model && model->getAddressTableModel())\n-    {\n-        // Default to no change address until verified\n-        CoinControlDialog::coinControl->destChange = CNoDestination();\n-        ui->labelCoinControlChangeLabel->setStyleSheet(\"QLabel{color:red;}\");\n-\n-        const CTxDestination dest = DecodeDestination(text.toStdString());\n-\n-        if (text.isEmpty()) // Nothing entered\n-        {\n-            ui->labelCoinControlChangeLabel->setText(\"\");\n-        }\n-        else if (!IsValidDestination(dest)) // Invalid address\n-        {\n-            ui->labelCoinControlChangeLabel->setText(tr(\"Warning: Invalid Bitcoin address\"));\n-        }\n-        else // Valid address\n-        {\n-            if (!model->IsSpendable(dest)) {\n-                ui->labelCoinControlChangeLabel->setText(tr(\"Warning: Unknown change address\"));\n-\n-                // confirmation dialog\n-                QMessageBox::StandardButton btnRetVal = QMessageBox::question(this, tr(\"Confirm custom change address\"), tr(\"The address you selected for change is not part of this wallet. Any or all funds in your wallet may be sent to this address. Are you sure?\"),\n-                    QMessageBox::Yes | QMessageBox::Cancel, QMessageBox::Cancel);\n-\n-                if(btnRetVal == QMessageBox::Yes)\n-                    CoinControlDialog::coinControl->destChange = dest;\n-                else\n-                {\n-                    ui->lineEditCoinControlChange->setText(\"\");\n-                    ui->labelCoinControlChangeLabel->setStyleSheet(\"QLabel{color:black;}\");\n-                    ui->labelCoinControlChangeLabel->setText(\"\");\n-                }\n-            }\n-            else // Known change address\n-            {\n-                ui->labelCoinControlChangeLabel->setStyleSheet(\"QLabel{color:black;}\");\n-\n-                // Query label\n-                QString associatedLabel = model->getAddressTableModel()->labelForAddress(text);\n-                if (!associatedLabel.isEmpty())\n-                    ui->labelCoinControlChangeLabel->setText(associatedLabel);\n-                else\n-                    ui->labelCoinControlChangeLabel->setText(tr(\"(no label)\"));\n-\n-                CoinControlDialog::coinControl->destChange = dest;\n-            }\n-        }\n-    }\n-}\n-\n-// Coin Control: update labels\n-void SendCoinsDialog::coinControlUpdateLabels()\n-{\n-    if (!model || !model->getOptionsModel())\n-        return;\n-\n-    updateCoinControlState(*CoinControlDialog::coinControl);\n-\n-    // set pay amounts\n-    CoinControlDialog::payAmounts.clear();\n-    CoinControlDialog::fSubtractFeeFromAmount = false;\n-\n-    for(int i = 0; i < ui->entries->count(); ++i)\n-    {\n-        SendCoinsEntry *entry = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(i)->widget());\n-        if(entry && !entry->isHidden())\n-        {\n-            SendCoinsRecipient rcp = entry->getValue();\n-            CoinControlDialog::payAmounts.append(rcp.amount);\n-            if (rcp.fSubtractFeeFromAmount)\n-                CoinControlDialog::fSubtractFeeFromAmount = true;\n-        }\n-    }\n-\n-    if (CoinControlDialog::coinControl->HasSelected())\n-    {\n-        // actual coin control calculation\n-        CoinControlDialog::updateLabels(model, this);\n-\n-        // show coin control stats\n-        ui->labelCoinControlAutomaticallySelected->hide();\n-        ui->widgetCoinControl->show();\n-    }\n-    else\n-    {\n-        // hide coin control stats\n-        ui->labelCoinControlAutomaticallySelected->show();\n-        ui->widgetCoinControl->hide();\n-        ui->labelCoinControlInsuffFunds->hide();\n-    }\n-}\n-\n-SendConfirmationDialog::SendConfirmationDialog(const QString &title, const QString &text, int _secDelay,\n-    QWidget *parent) :\n-    QMessageBox(QMessageBox::Question, title, text, QMessageBox::Yes | QMessageBox::Cancel, parent), secDelay(_secDelay)\n-{\n-    setDefaultButton(QMessageBox::Cancel);\n-    yesButton = button(QMessageBox::Yes);\n-    updateYesButton();\n-    connect(&countDownTimer, SIGNAL(timeout()), this, SLOT(countDown()));\n-}\n-\n-int SendConfirmationDialog::exec()\n-{\n-    updateYesButton();\n-    countDownTimer.start(1000);\n-    return QMessageBox::exec();\n-}\n-\n-void SendConfirmationDialog::countDown()\n-{\n-    secDelay--;\n-    updateYesButton();\n-\n-    if(secDelay <= 0)\n-    {\n-        countDownTimer.stop();\n-    }\n-}\n-\n-void SendConfirmationDialog::updateYesButton()\n-{\n-    if(secDelay > 0)\n-    {\n-        yesButton->setEnabled(false);\n-        yesButton->setText(tr(\"Yes\") + \" (\" + QString::number(secDelay) + \")\");\n-    }\n-    else\n-    {\n-        yesButton->setEnabled(true);\n-        yesButton->setText(tr(\"Yes\"));\n-    }\n-}\n+// Copyright (c) 2011-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <qt/sendcoinsdialog.h>\r\n+#include <qt/forms/ui_sendcoinsdialog.h>\r\n+\r\n+#include <qt/addresstablemodel.h>\r\n+#include <qt/bitcoinunits.h>\r\n+#include <qt/clientmodel.h>\r\n+#include <qt/coincontroldialog.h>\r\n+#include <qt/guiutil.h>\r\n+#include <qt/optionsmodel.h>\r\n+#include <qt/platformstyle.h>\r\n+#include <qt/sendcoinsentry.h>\r\n+\r\n+#include <base58.h>\r\n+#include <chainparams.h>\r\n+#include <wallet/coincontrol.h>\r\n+#include <validation.h> // mempool and minRelayTxFee\r\n+#include <ui_interface.h>\r\n+#include <txmempool.h>\r\n+#include <policy/fees.h>\r\n+#include <wallet/fees.h>\r\n+\r\n+#include <QFontMetrics>\r\n+#include <QScrollBar>\r\n+#include <QSettings>\r\n+#include <QTextDocument>\r\n+\r\n+static const std::array<int, 9> confTargets = { {2, 4, 6, 12, 24, 48, 144, 504, 1008} };\r\n+int getConfTargetForIndex(int index) {\r\n+    if (index+1 > static_cast<int>(confTargets.size())) {\r\n+        return confTargets.back();\r\n+    }\r\n+    if (index < 0) {\r\n+        return confTargets[0];\r\n+    }\r\n+    return confTargets[index];\r\n+}\r\n+int getIndexForConfTarget(int target) {\r\n+    for (unsigned int i = 0; i < confTargets.size(); i++) {\r\n+        if (confTargets[i] >= target) {\r\n+            return i;\r\n+        }\r\n+    }\r\n+    return confTargets.size() - 1;\r\n+}\r\n+\r\n+SendCoinsDialog::SendCoinsDialog(const PlatformStyle *_platformStyle, QWidget *parent) :\r\n+    QDialog(parent),\r\n+    ui(new Ui::SendCoinsDialog),\r\n+    clientModel(0),\r\n+    model(0),\r\n+    fNewRecipientAllowed(true),\r\n+    fFeeMinimized(true),\r\n+    platformStyle(_platformStyle)\r\n+{\r\n+    ui->setupUi(this);\r\n+\r\n+    if (!_platformStyle->getImagesOnButtons()) {\r\n+        ui->addButton->setIcon(QIcon());\r\n+        ui->clearButton->setIcon(QIcon());\r\n+        ui->sendButton->setIcon(QIcon());\r\n+    } else {\r\n+        ui->addButton->setIcon(_platformStyle->SingleColorIcon(\":/icons/add\"));\r\n+        ui->clearButton->setIcon(_platformStyle->SingleColorIcon(\":/icons/remove\"));\r\n+        ui->sendButton->setIcon(_platformStyle->SingleColorIcon(\":/icons/send\"));\r\n+    }\r\n+\r\n+    GUIUtil::setupAddressWidget(ui->lineEditCoinControlChange, this);\r\n+\r\n+    addEntry();\r\n+\r\n+    connect(ui->addButton, SIGNAL(clicked()), this, SLOT(addEntry()));\r\n+    connect(ui->clearButton, SIGNAL(clicked()), this, SLOT(clear()));\r\n+\r\n+    // Coin Control\r\n+    connect(ui->pushButtonCoinControl, SIGNAL(clicked()), this, SLOT(coinControlButtonClicked()));\r\n+    connect(ui->checkBoxCoinControlChange, SIGNAL(stateChanged(int)), this, SLOT(coinControlChangeChecked(int)));\r\n+    connect(ui->lineEditCoinControlChange, SIGNAL(textEdited(const QString &)), this, SLOT(coinControlChangeEdited(const QString &)));\r\n+\r\n+    // Coin Control: clipboard actions\r\n+    QAction *clipboardQuantityAction = new QAction(tr(\"Copy quantity\"), this);\r\n+    QAction *clipboardAmountAction = new QAction(tr(\"Copy amount\"), this);\r\n+    QAction *clipboardFeeAction = new QAction(tr(\"Copy fee\"), this);\r\n+    QAction *clipboardAfterFeeAction = new QAction(tr(\"Copy after fee\"), this);\r\n+    QAction *clipboardBytesAction = new QAction(tr(\"Copy bytes\"), this);\r\n+    QAction *clipboardLowOutputAction = new QAction(tr(\"Copy dust\"), this);\r\n+    QAction *clipboardChangeAction = new QAction(tr(\"Copy change\"), this);\r\n+    connect(clipboardQuantityAction, SIGNAL(triggered()), this, SLOT(coinControlClipboardQuantity()));\r\n+    connect(clipboardAmountAction, SIGNAL(triggered()), this, SLOT(coinControlClipboardAmount()));\r\n+    connect(clipboardFeeAction, SIGNAL(triggered()), this, SLOT(coinControlClipboardFee()));\r\n+    connect(clipboardAfterFeeAction, SIGNAL(triggered()), this, SLOT(coinControlClipboardAfterFee()));\r\n+    connect(clipboardBytesAction, SIGNAL(triggered()), this, SLOT(coinControlClipboardBytes()));\r\n+    connect(clipboardLowOutputAction, SIGNAL(triggered()), this, SLOT(coinControlClipboardLowOutput()));\r\n+    connect(clipboardChangeAction, SIGNAL(triggered()), this, SLOT(coinControlClipboardChange()));\r\n+    ui->labelCoinControlQuantity->addAction(clipboardQuantityAction);\r\n+    ui->labelCoinControlAmount->addAction(clipboardAmountAction);\r\n+    ui->labelCoinControlFee->addAction(clipboardFeeAction);\r\n+    ui->labelCoinControlAfterFee->addAction(clipboardAfterFeeAction);\r\n+    ui->labelCoinControlBytes->addAction(clipboardBytesAction);\r\n+    ui->labelCoinControlLowOutput->addAction(clipboardLowOutputAction);\r\n+    ui->labelCoinControlChange->addAction(clipboardChangeAction);\r\n+\r\n+    // init transaction fee section\r\n+    QSettings settings;\r\n+    if (!settings.contains(\"fFeeSectionMinimized\"))\r\n+        settings.setValue(\"fFeeSectionMinimized\", true);\r\n+    if (!settings.contains(\"nFeeRadio\") && settings.contains(\"nTransactionFee\") && settings.value(\"nTransactionFee\").toLongLong() > 0) // compatibility\r\n+        settings.setValue(\"nFeeRadio\", 1); // custom\r\n+    if (!settings.contains(\"nFeeRadio\"))\r\n+        settings.setValue(\"nFeeRadio\", 0); // recommended\r\n+    if (!settings.contains(\"nSmartFeeSliderPosition\"))\r\n+        settings.setValue(\"nSmartFeeSliderPosition\", 0);\r\n+    if (!settings.contains(\"nTransactionFee\"))\r\n+        settings.setValue(\"nTransactionFee\", (qint64)DEFAULT_TRANSACTION_FEE);\r\n+    if (!settings.contains(\"fPayOnlyMinFee\"))\r\n+        settings.setValue(\"fPayOnlyMinFee\", false);\r\n+    ui->groupFee->setId(ui->radioSmartFee, 0);\r\n+    ui->groupFee->setId(ui->radioCustomFee, 1);\r\n+    ui->groupFee->button((int)std::max(0, std::min(1, settings.value(\"nFeeRadio\").toInt())))->setChecked(true);\r\n+    ui->customFee->setValue(settings.value(\"nTransactionFee\").toLongLong());\r\n+    ui->checkBoxMinimumFee->setChecked(settings.value(\"fPayOnlyMinFee\").toBool());\r\n+    minimizeFeeSection(settings.value(\"fFeeSectionMinimized\").toBool());\r\n+}\r\n+\r\n+void SendCoinsDialog::setClientModel(ClientModel *_clientModel)\r\n+{\r\n+    this->clientModel = _clientModel;\r\n+\r\n+    if (_clientModel) {\r\n+        connect(_clientModel, SIGNAL(numBlocksChanged(int,QDateTime,double,bool)), this, SLOT(updateSmartFeeLabel()));\r\n+    }\r\n+}\r\n+\r\n+void SendCoinsDialog::setModel(WalletModel *_model)\r\n+{\r\n+    this->model = _model;\r\n+\r\n+    if(_model && _model->getOptionsModel())\r\n+    {\r\n+        for(int i = 0; i < ui->entries->count(); ++i)\r\n+        {\r\n+            SendCoinsEntry *entry = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(i)->widget());\r\n+            if(entry)\r\n+            {\r\n+                entry->setModel(_model);\r\n+            }\r\n+        }\r\n+\r\n+        setBalance(_model->getBalance(), _model->getUnconfirmedBalance(), _model->getImmatureBalance(),\r\n+                   _model->getWatchBalance(), _model->getWatchUnconfirmedBalance(), _model->getWatchImmatureBalance());\r\n+        connect(_model, SIGNAL(balanceChanged(CAmount,CAmount,CAmount,CAmount,CAmount,CAmount)), this, SLOT(setBalance(CAmount,CAmount,CAmount,CAmount,CAmount,CAmount)));\r\n+        connect(_model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(updateDisplayUnit()));\r\n+        updateDisplayUnit();\r\n+\r\n+        // Coin Control\r\n+        connect(_model->getOptionsModel(), SIGNAL(displayUnitChanged(int)), this, SLOT(coinControlUpdateLabels()));\r\n+        connect(_model->getOptionsModel(), SIGNAL(coinControlFeaturesChanged(bool)), this, SLOT(coinControlFeatureChanged(bool)));\r\n+        ui->frameCoinControl->setVisible(_model->getOptionsModel()->getCoinControlFeatures());\r\n+        coinControlUpdateLabels();\r\n+\r\n+        // fee section\r\n+        for (const int &n : confTargets) {\r\n+            ui->confTargetSelector->addItem(tr(\"%1 (%2 blocks)\").arg(GUIUtil::formatNiceTimeOffset(n*Params().GetConsensus().nBtvPowTargetSpacing)).arg(n));\r\n+        }\r\n+        connect(ui->confTargetSelector, SIGNAL(currentIndexChanged(int)), this, SLOT(updateSmartFeeLabel()));\r\n+        connect(ui->confTargetSelector, SIGNAL(currentIndexChanged(int)), this, SLOT(coinControlUpdateLabels()));\r\n+        connect(ui->groupFee, SIGNAL(buttonClicked(int)), this, SLOT(updateFeeSectionControls()));\r\n+        connect(ui->groupFee, SIGNAL(buttonClicked(int)), this, SLOT(coinControlUpdateLabels()));\r\n+        connect(ui->customFee, SIGNAL(valueChanged()), this, SLOT(coinControlUpdateLabels()));\r\n+        connect(ui->checkBoxMinimumFee, SIGNAL(stateChanged(int)), this, SLOT(setMinimumFee()));\r\n+        connect(ui->checkBoxMinimumFee, SIGNAL(stateChanged(int)), this, SLOT(updateFeeSectionControls()));\r\n+        connect(ui->checkBoxMinimumFee, SIGNAL(stateChanged(int)), this, SLOT(coinControlUpdateLabels()));\r\n+        connect(ui->optInRBF, SIGNAL(stateChanged(int)), this, SLOT(updateSmartFeeLabel()));\r\n+        connect(ui->optInRBF, SIGNAL(stateChanged(int)), this, SLOT(coinControlUpdateLabels()));\r\n+        ui->customFee->setSingleStep(GetRequiredFee(1000));\r\n+        updateFeeSectionControls();\r\n+        updateMinFeeLabel();\r\n+        updateSmartFeeLabel();\r\n+\r\n+        // set default rbf checkbox state\r\n+        ui->optInRBF->setCheckState(model->getDefaultWalletRbf() ? Qt::Checked : Qt::Unchecked);\r\n+\r\n+        // set the smartfee-sliders default value (wallets default conf.target or last stored value)\r\n+        QSettings settings;\r\n+        if (settings.value(\"nSmartFeeSliderPosition\").toInt() != 0) {\r\n+            // migrate nSmartFeeSliderPosition to nConfTarget\r\n+            // nConfTarget is available since 0.15 (replaced nSmartFeeSliderPosition)\r\n+            int nConfirmTarget = 25 - settings.value(\"nSmartFeeSliderPosition\").toInt(); // 25 == old slider range\r\n+            settings.setValue(\"nConfTarget\", nConfirmTarget);\r\n+            settings.remove(\"nSmartFeeSliderPosition\");\r\n+        }\r\n+        if (settings.value(\"nConfTarget\").toInt() == 0)\r\n+            ui->confTargetSelector->setCurrentIndex(getIndexForConfTarget(model->getDefaultConfirmTarget()));\r\n+        else\r\n+            ui->confTargetSelector->setCurrentIndex(getIndexForConfTarget(settings.value(\"nConfTarget\").toInt()));\r\n+    }\r\n+}\r\n+\r\n+SendCoinsDialog::~SendCoinsDialog()\r\n+{\r\n+    QSettings settings;\r\n+    settings.setValue(\"fFeeSectionMinimized\", fFeeMinimized);\r\n+    settings.setValue(\"nFeeRadio\", ui->groupFee->checkedId());\r\n+    settings.setValue(\"nConfTarget\", getConfTargetForIndex(ui->confTargetSelector->currentIndex()));\r\n+    settings.setValue(\"nTransactionFee\", (qint64)ui->customFee->value());\r\n+    settings.setValue(\"fPayOnlyMinFee\", ui->checkBoxMinimumFee->isChecked());\r\n+\r\n+    delete ui;\r\n+}\r\n+\r\n+void SendCoinsDialog::on_sendButton_clicked()\r\n+{\r\n+    if(!model || !model->getOptionsModel())\r\n+        return;\r\n+\r\n+    QList<SendCoinsRecipient> recipients;\r\n+    bool valid = true;\r\n+\r\n+    for(int i = 0; i < ui->entries->count(); ++i)\r\n+    {\r\n+        SendCoinsEntry *entry = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(i)->widget());\r\n+        if(entry)\r\n+        {\r\n+            if(entry->validate())\r\n+            {\r\n+                recipients.append(entry->getValue());\r\n+            }\r\n+            else\r\n+            {\r\n+                valid = false;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    if(!valid || recipients.isEmpty())\r\n+    {\r\n+        return;\r\n+    }\r\n+\r\n+    fNewRecipientAllowed = false;\r\n+    WalletModel::UnlockContext ctx(model->requestUnlock());\r\n+    if(!ctx.isValid())\r\n+    {\r\n+        // Unlock wallet was cancelled\r\n+        fNewRecipientAllowed = true;\r\n+        return;\r\n+    }\r\n+\r\n+    // prepare transaction for getting txFee earlier\r\n+    WalletModelTransaction currentTransaction(recipients);\r\n+    WalletModel::SendCoinsReturn prepareStatus;\r\n+\r\n+    // Always use a CCoinControl instance, use the CoinControlDialog instance if CoinControl has been enabled\r\n+    CCoinControl ctrl;\r\n+    if (model->getOptionsModel()->getCoinControlFeatures())\r\n+        ctrl = *CoinControlDialog::coinControl;\r\n+\r\n+    updateCoinControlState(ctrl);\r\n+\r\n+    prepareStatus = model->prepareTransaction(currentTransaction, ctrl);\r\n+\r\n+    // process prepareStatus and on error generate message shown to user\r\n+    processSendCoinsReturn(prepareStatus,\r\n+        BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), currentTransaction.getTransactionFee()));\r\n+\r\n+    if(prepareStatus.status != WalletModel::OK) {\r\n+        fNewRecipientAllowed = true;\r\n+        return;\r\n+    }\r\n+\r\n+    CAmount txFee = currentTransaction.getTransactionFee();\r\n+\r\n+    // Format confirmation message\r\n+    QStringList formatted;\r\n+    for (const SendCoinsRecipient &rcp : currentTransaction.getRecipients())\r\n+    {\r\n+        // generate bold amount string\r\n+        QString amount = \"<b>\" + BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), rcp.amount);\r\n+        amount.append(\"</b>\");\r\n+        // generate monospace address string\r\n+        QString address = \"<span style='font-family: monospace;'>\" + rcp.address;\r\n+        address.append(\"</span>\");\r\n+\r\n+        QString recipientElement;\r\n+\r\n+        if (!rcp.paymentRequest.IsInitialized()) // normal payment\r\n+        {\r\n+            if(rcp.label.length() > 0) // label with address\r\n+            {\r\n+                recipientElement = tr(\"%1 to %2\").arg(amount, GUIUtil::HtmlEscape(rcp.label));\r\n+                recipientElement.append(QString(\" (%1)\").arg(address));\r\n+            }\r\n+            else // just address\r\n+            {\r\n+                recipientElement = tr(\"%1 to %2\").arg(amount, address);\r\n+            }\r\n+        }\r\n+        else if(!rcp.authenticatedMerchant.isEmpty()) // authenticated payment request\r\n+        {\r\n+            recipientElement = tr(\"%1 to %2\").arg(amount, GUIUtil::HtmlEscape(rcp.authenticatedMerchant));\r\n+        }\r\n+        else // unauthenticated payment request\r\n+        {\r\n+            recipientElement = tr(\"%1 to %2\").arg(amount, address);\r\n+        }\r\n+\r\n+        formatted.append(recipientElement);\r\n+    }\r\n+\r\n+    QString questionString = tr(\"Are you sure you want to send?\");\r\n+    questionString.append(\"<br /><br />%1\");\r\n+\r\n+    if(txFee > 0)\r\n+    {\r\n+        // append fee string if a fee is required\r\n+        questionString.append(\"<hr /><span style='color:#aa0000;'>\");\r\n+        questionString.append(BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), txFee));\r\n+        questionString.append(\"</span> \");\r\n+        questionString.append(tr(\"added as transaction fee\"));\r\n+\r\n+        // append transaction size\r\n+        questionString.append(\" (\" + QString::number((double)currentTransaction.getTransactionSize() / 1000) + \" kB)\");\r\n+    }\r\n+\r\n+    // add total amount in all subdivision units\r\n+    questionString.append(\"<hr />\");\r\n+    CAmount totalAmount = currentTransaction.getTotalTransactionAmount() + txFee;\r\n+    QStringList alternativeUnits;\r\n+    for (BitcoinUnits::Unit u : BitcoinUnits::availableUnits())\r\n+    {\r\n+        if(u != model->getOptionsModel()->getDisplayUnit())\r\n+            alternativeUnits.append(BitcoinUnits::formatHtmlWithUnit(u, totalAmount));\r\n+    }\r\n+    questionString.append(tr(\"Total Amount %1\")\r\n+        .arg(BitcoinUnits::formatHtmlWithUnit(model->getOptionsModel()->getDisplayUnit(), totalAmount)));\r\n+    questionString.append(QString(\"<span style='font-size:10pt;font-weight:normal;'><br />(=%2)</span>\")\r\n+        .arg(alternativeUnits.join(\" \" + tr(\"or\") + \"<br />\")));\r\n+\r\n+    if (ui->optInRBF->isChecked())\r\n+    {\r\n+        questionString.append(\"<hr /><span>\");\r\n+        questionString.append(tr(\"You can increase the fee later (signals Replace-By-Fee).\"));\r\n+        questionString.append(\"</span>\");\r\n+    }\r\n+\r\n+    SendConfirmationDialog confirmationDialog(tr(\"Confirm send coins\"),\r\n+        questionString.arg(formatted.join(\"<br />\")), SEND_CONFIRM_DELAY, this);\r\n+    confirmationDialog.exec();\r\n+    QMessageBox::StandardButton retval = (QMessageBox::StandardButton)confirmationDialog.result();\r\n+\r\n+    if(retval != QMessageBox::Yes)\r\n+    {\r\n+        fNewRecipientAllowed = true;\r\n+        return;\r\n+    }\r\n+\r\n+    // now send the prepared transaction\r\n+    WalletModel::SendCoinsReturn sendStatus = model->sendCoins(currentTransaction);\r\n+    // process sendStatus and on error generate message shown to user\r\n+    processSendCoinsReturn(sendStatus);\r\n+\r\n+    if (sendStatus.status == WalletModel::OK)\r\n+    {\r\n+        accept();\r\n+        CoinControlDialog::coinControl->UnSelectAll();\r\n+        coinControlUpdateLabels();\r\n+    }\r\n+    fNewRecipientAllowed = true;\r\n+}\r\n+\r\n+void SendCoinsDialog::clear()\r\n+{\r\n+    // Remove entries until only one left\r\n+    while(ui->entries->count())\r\n+    {\r\n+        ui->entries->takeAt(0)->widget()->deleteLater();\r\n+    }\r\n+    addEntry();\r\n+\r\n+    updateTabsAndLabels();\r\n+}\r\n+\r\n+void SendCoinsDialog::reject()\r\n+{\r\n+    clear();\r\n+}\r\n+\r\n+void SendCoinsDialog::accept()\r\n+{\r\n+    clear();\r\n+}\r\n+\r\n+SendCoinsEntry *SendCoinsDialog::addEntry()\r\n+{\r\n+    SendCoinsEntry *entry = new SendCoinsEntry(platformStyle, this);\r\n+    entry->setModel(model);\r\n+    ui->entries->addWidget(entry);\r\n+    connect(entry, SIGNAL(removeEntry(SendCoinsEntry*)), this, SLOT(removeEntry(SendCoinsEntry*)));\r\n+    connect(entry, SIGNAL(useAvailableBalance(SendCoinsEntry*)), this, SLOT(useAvailableBalance(SendCoinsEntry*)));\r\n+    connect(entry, SIGNAL(payAmountChanged()), this, SLOT(coinControlUpdateLabels()));\r\n+    connect(entry, SIGNAL(subtractFeeFromAmountChanged()), this, SLOT(coinControlUpdateLabels()));\r\n+\r\n+    // Focus the field, so that entry can start immediately\r\n+    entry->clear();\r\n+    entry->setFocus();\r\n+    ui->scrollAreaWidgetContents->resize(ui->scrollAreaWidgetContents->sizeHint());\r\n+    qApp->processEvents();\r\n+    QScrollBar* bar = ui->scrollArea->verticalScrollBar();\r\n+    if(bar)\r\n+        bar->setSliderPosition(bar->maximum());\r\n+\r\n+    updateTabsAndLabels();\r\n+    return entry;\r\n+}\r\n+\r\n+void SendCoinsDialog::updateTabsAndLabels()\r\n+{\r\n+    setupTabChain(0);\r\n+    coinControlUpdateLabels();\r\n+}\r\n+\r\n+void SendCoinsDialog::removeEntry(SendCoinsEntry* entry)\r\n+{\r\n+    entry->hide();\r\n+\r\n+    // If the last entry is about to be removed add an empty one\r\n+    if (ui->entries->count() == 1)\r\n+        addEntry();\r\n+\r\n+    entry->deleteLater();\r\n+\r\n+    updateTabsAndLabels();\r\n+}\r\n+\r\n+QWidget *SendCoinsDialog::setupTabChain(QWidget *prev)\r\n+{\r\n+    for(int i = 0; i < ui->entries->count(); ++i)\r\n+    {\r\n+        SendCoinsEntry *entry = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(i)->widget());\r\n+        if(entry)\r\n+        {\r\n+            prev = entry->setupTabChain(prev);\r\n+        }\r\n+    }\r\n+    QWidget::setTabOrder(prev, ui->sendButton);\r\n+    QWidget::setTabOrder(ui->sendButton, ui->clearButton);\r\n+    QWidget::setTabOrder(ui->clearButton, ui->addButton);\r\n+    return ui->addButton;\r\n+}\r\n+\r\n+void SendCoinsDialog::setAddress(const QString &address)\r\n+{\r\n+    SendCoinsEntry *entry = 0;\r\n+    // Replace the first entry if it is still unused\r\n+    if(ui->entries->count() == 1)\r\n+    {\r\n+        SendCoinsEntry *first = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(0)->widget());\r\n+        if(first->isClear())\r\n+        {\r\n+            entry = first;\r\n+        }\r\n+    }\r\n+    if(!entry)\r\n+    {\r\n+        entry = addEntry();\r\n+    }\r\n+\r\n+    entry->setAddress(address);\r\n+}\r\n+\r\n+void SendCoinsDialog::pasteEntry(const SendCoinsRecipient &rv)\r\n+{\r\n+    if(!fNewRecipientAllowed)\r\n+        return;\r\n+\r\n+    SendCoinsEntry *entry = 0;\r\n+    // Replace the first entry if it is still unused\r\n+    if(ui->entries->count() == 1)\r\n+    {\r\n+        SendCoinsEntry *first = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(0)->widget());\r\n+        if(first->isClear())\r\n+        {\r\n+            entry = first;\r\n+        }\r\n+    }\r\n+    if(!entry)\r\n+    {\r\n+        entry = addEntry();\r\n+    }\r\n+\r\n+    entry->setValue(rv);\r\n+    updateTabsAndLabels();\r\n+}\r\n+\r\n+bool SendCoinsDialog::handlePaymentRequest(const SendCoinsRecipient &rv)\r\n+{\r\n+    // Just paste the entry, all pre-checks\r\n+    // are done in paymentserver.cpp.\r\n+    pasteEntry(rv);\r\n+    return true;\r\n+}\r\n+\r\n+void SendCoinsDialog::setBalance(const CAmount& balance, const CAmount& unconfirmedBalance, const CAmount& immatureBalance,\r\n+                                 const CAmount& watchBalance, const CAmount& watchUnconfirmedBalance, const CAmount& watchImmatureBalance)\r\n+{\r\n+    Q_UNUSED(unconfirmedBalance);\r\n+    Q_UNUSED(immatureBalance);\r\n+    Q_UNUSED(watchBalance);\r\n+    Q_UNUSED(watchUnconfirmedBalance);\r\n+    Q_UNUSED(watchImmatureBalance);\r\n+\r\n+    if(model && model->getOptionsModel())\r\n+    {\r\n+        ui->labelBalance->setText(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), balance));\r\n+    }\r\n+}\r\n+\r\n+void SendCoinsDialog::updateDisplayUnit()\r\n+{\r\n+    setBalance(model->getBalance(), 0, 0, 0, 0, 0);\r\n+    ui->customFee->setDisplayUnit(model->getOptionsModel()->getDisplayUnit());\r\n+    updateMinFeeLabel();\r\n+    updateSmartFeeLabel();\r\n+}\r\n+\r\n+void SendCoinsDialog::processSendCoinsReturn(const WalletModel::SendCoinsReturn &sendCoinsReturn, const QString &msgArg)\r\n+{\r\n+    QPair<QString, CClientUIInterface::MessageBoxFlags> msgParams;\r\n+    // Default to a warning message, override if error message is needed\r\n+    msgParams.second = CClientUIInterface::MSG_WARNING;\r\n+\r\n+    // This comment is specific to SendCoinsDialog usage of WalletModel::SendCoinsReturn.\r\n+    // WalletModel::TransactionCommitFailed is used only in WalletModel::sendCoins()\r\n+    // all others are used only in WalletModel::prepareTransaction()\r\n+    switch(sendCoinsReturn.status)\r\n+    {\r\n+    case WalletModel::InvalidAddress:\r\n+        msgParams.first = tr(\"The recipient address is not valid. Please recheck.\");\r\n+        break;\r\n+    case WalletModel::InvalidAmount:\r\n+        msgParams.first = tr(\"The amount to pay must be larger than 0.\");\r\n+        break;\r\n+    case WalletModel::AmountExceedsBalance:\r\n+        msgParams.first = tr(\"The amount exceeds your balance.\");\r\n+        break;\r\n+    case WalletModel::AmountWithFeeExceedsBalance:\r\n+        msgParams.first = tr(\"The total exceeds your balance when the %1 transaction fee is included.\").arg(msgArg);\r\n+        break;\r\n+    case WalletModel::DuplicateAddress:\r\n+        msgParams.first = tr(\"Duplicate address found: addresses should only be used once each.\");\r\n+        break;\r\n+    case WalletModel::TransactionCreationFailed:\r\n+        msgParams.first = tr(\"Transaction creation failed!\");\r\n+        msgParams.second = CClientUIInterface::MSG_ERROR;\r\n+        break;\r\n+    case WalletModel::TransactionCommitFailed:\r\n+        msgParams.first = tr(\"The transaction was rejected with the following reason: %1\").arg(sendCoinsReturn.reasonCommitFailed);\r\n+        msgParams.second = CClientUIInterface::MSG_ERROR;\r\n+        break;\r\n+    case WalletModel::AbsurdFee:\r\n+        msgParams.first = tr(\"A fee higher than %1 is considered an absurdly high fee.\").arg(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), maxTxFee));\r\n+        break;\r\n+    case WalletModel::PaymentRequestExpired:\r\n+        msgParams.first = tr(\"Payment request expired.\");\r\n+        msgParams.second = CClientUIInterface::MSG_ERROR;\r\n+        break;\r\n+    // included to prevent a compiler warning.\r\n+    case WalletModel::OK:\r\n+    default:\r\n+        return;\r\n+    }\r\n+\r\n+    Q_EMIT message(tr(\"Send Coins\"), msgParams.first, msgParams.second);\r\n+}\r\n+\r\n+void SendCoinsDialog::minimizeFeeSection(bool fMinimize)\r\n+{\r\n+    ui->labelFeeMinimized->setVisible(fMinimize);\r\n+    ui->buttonChooseFee  ->setVisible(fMinimize);\r\n+    ui->buttonMinimizeFee->setVisible(!fMinimize);\r\n+    ui->frameFeeSelection->setVisible(!fMinimize);\r\n+    ui->horizontalLayoutSmartFee->setContentsMargins(0, (fMinimize ? 0 : 6), 0, 0);\r\n+    fFeeMinimized = fMinimize;\r\n+}\r\n+\r\n+void SendCoinsDialog::on_buttonChooseFee_clicked()\r\n+{\r\n+    minimizeFeeSection(false);\r\n+}\r\n+\r\n+void SendCoinsDialog::on_buttonMinimizeFee_clicked()\r\n+{\r\n+    updateFeeMinimizedLabel();\r\n+    minimizeFeeSection(true);\r\n+}\r\n+\r\n+void SendCoinsDialog::useAvailableBalance(SendCoinsEntry* entry)\r\n+{\r\n+    // Get CCoinControl instance if CoinControl is enabled or create a new one.\r\n+    CCoinControl coin_control;\r\n+    if (model->getOptionsModel()->getCoinControlFeatures()) {\r\n+        coin_control = *CoinControlDialog::coinControl;\r\n+    }\r\n+\r\n+    // Calculate available amount to send.\r\n+    CAmount amount = model->getBalance(&coin_control);\r\n+    for (int i = 0; i < ui->entries->count(); ++i) {\r\n+        SendCoinsEntry* e = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(i)->widget());\r\n+        if (e && !e->isHidden() && e != entry) {\r\n+            amount -= e->getValue().amount;\r\n+        }\r\n+    }\r\n+\r\n+    if (amount > 0) {\r\n+      entry->checkSubtractFeeFromAmount();\r\n+      entry->setAmount(amount);\r\n+    } else {\r\n+      entry->setAmount(0);\r\n+    }\r\n+}\r\n+\r\n+void SendCoinsDialog::setMinimumFee()\r\n+{\r\n+    ui->customFee->setValue(GetRequiredFee(1000));\r\n+}\r\n+\r\n+void SendCoinsDialog::updateFeeSectionControls()\r\n+{\r\n+    ui->confTargetSelector      ->setEnabled(ui->radioSmartFee->isChecked());\r\n+    ui->labelSmartFee           ->setEnabled(ui->radioSmartFee->isChecked());\r\n+    ui->labelSmartFee2          ->setEnabled(ui->radioSmartFee->isChecked());\r\n+    ui->labelSmartFee3          ->setEnabled(ui->radioSmartFee->isChecked());\r\n+    ui->labelFeeEstimation      ->setEnabled(ui->radioSmartFee->isChecked());\r\n+    ui->checkBoxMinimumFee      ->setEnabled(ui->radioCustomFee->isChecked());\r\n+    ui->labelMinFeeWarning      ->setEnabled(ui->radioCustomFee->isChecked());\r\n+    ui->labelCustomPerKilobyte  ->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked());\r\n+    ui->customFee               ->setEnabled(ui->radioCustomFee->isChecked() && !ui->checkBoxMinimumFee->isChecked());\r\n+}\r\n+\r\n+void SendCoinsDialog::updateFeeMinimizedLabel()\r\n+{\r\n+    if(!model || !model->getOptionsModel())\r\n+        return;\r\n+\r\n+    if (ui->radioSmartFee->isChecked())\r\n+        ui->labelFeeMinimized->setText(ui->labelSmartFee->text());\r\n+    else {\r\n+        ui->labelFeeMinimized->setText(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), ui->customFee->value()) + \"/kB\");\r\n+    }\r\n+}\r\n+\r\n+void SendCoinsDialog::updateMinFeeLabel()\r\n+{\r\n+    if (model && model->getOptionsModel())\r\n+        ui->checkBoxMinimumFee->setText(tr(\"Pay only the required fee of %1\").arg(\r\n+            BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), GetRequiredFee(1000)) + \"/kB\")\r\n+        );\r\n+}\r\n+\r\n+void SendCoinsDialog::updateCoinControlState(CCoinControl& ctrl)\r\n+{\r\n+    if (ui->radioCustomFee->isChecked()) {\r\n+        ctrl.m_feerate = CFeeRate(ui->customFee->value());\r\n+    } else {\r\n+        ctrl.m_feerate.reset();\r\n+    }\r\n+    // Avoid using global defaults when sending money from the GUI\r\n+    // Either custom fee will be used or if not selected, the confirmation target from dropdown box\r\n+    ctrl.m_confirm_target = getConfTargetForIndex(ui->confTargetSelector->currentIndex());\r\n+    ctrl.signalRbf = ui->optInRBF->isChecked();\r\n+}\r\n+\r\n+void SendCoinsDialog::updateSmartFeeLabel()\r\n+{\r\n+    if(!model || !model->getOptionsModel())\r\n+        return;\r\n+    CCoinControl coin_control;\r\n+    updateCoinControlState(coin_control);\r\n+    coin_control.m_feerate.reset(); // Explicitly use only fee estimation rate for smart fee labels\r\n+    FeeCalculation feeCalc;\r\n+    CFeeRate feeRate = CFeeRate(GetMinimumFee(1000, coin_control, ::mempool, ::feeEstimator, &feeCalc));\r\n+\r\n+    ui->labelSmartFee->setText(BitcoinUnits::formatWithUnit(model->getOptionsModel()->getDisplayUnit(), feeRate.GetFeePerK()) + \"/kB\");\r\n+\r\n+    if (feeCalc.reason == FeeReason::FALLBACK) {\r\n+        ui->labelSmartFee2->show(); // (Smart fee not initialized yet. This usually takes a few blocks...)\r\n+        ui->labelFeeEstimation->setText(\"\");\r\n+        ui->fallbackFeeWarningLabel->setVisible(true);\r\n+        int lightness = ui->fallbackFeeWarningLabel->palette().color(QPalette::WindowText).lightness();\r\n+        QColor warning_colour(255 - (lightness / 5), 176 - (lightness / 3), 48 - (lightness / 14));\r\n+        ui->fallbackFeeWarningLabel->setStyleSheet(\"QLabel { color: \" + warning_colour.name() + \"; }\");\r\n+        ui->fallbackFeeWarningLabel->setIndent(QFontMetrics(ui->fallbackFeeWarningLabel->font()).width(\"x\"));\r\n+    }\r\n+    else\r\n+    {\r\n+        ui->labelSmartFee2->hide();\r\n+        ui->labelFeeEstimation->setText(tr(\"Estimated to begin confirmation within %n block(s).\", \"\", feeCalc.returnedTarget));\r\n+        ui->fallbackFeeWarningLabel->setVisible(false);\r\n+    }\r\n+\r\n+    updateFeeMinimizedLabel();\r\n+}\r\n+\r\n+// Coin Control: copy label \"Quantity\" to clipboard\r\n+void SendCoinsDialog::coinControlClipboardQuantity()\r\n+{\r\n+    GUIUtil::setClipboard(ui->labelCoinControlQuantity->text());\r\n+}\r\n+\r\n+// Coin Control: copy label \"Amount\" to clipboard\r\n+void SendCoinsDialog::coinControlClipboardAmount()\r\n+{\r\n+    GUIUtil::setClipboard(ui->labelCoinControlAmount->text().left(ui->labelCoinControlAmount->text().indexOf(\" \")));\r\n+}\r\n+\r\n+// Coin Control: copy label \"Fee\" to clipboard\r\n+void SendCoinsDialog::coinControlClipboardFee()\r\n+{\r\n+    GUIUtil::setClipboard(ui->labelCoinControlFee->text().left(ui->labelCoinControlFee->text().indexOf(\" \")).replace(ASYMP_UTF8, \"\"));\r\n+}\r\n+\r\n+// Coin Control: copy label \"After fee\" to clipboard\r\n+void SendCoinsDialog::coinControlClipboardAfterFee()\r\n+{\r\n+    GUIUtil::setClipboard(ui->labelCoinControlAfterFee->text().left(ui->labelCoinControlAfterFee->text().indexOf(\" \")).replace(ASYMP_UTF8, \"\"));\r\n+}\r\n+\r\n+// Coin Control: copy label \"Bytes\" to clipboard\r\n+void SendCoinsDialog::coinControlClipboardBytes()\r\n+{\r\n+    GUIUtil::setClipboard(ui->labelCoinControlBytes->text().replace(ASYMP_UTF8, \"\"));\r\n+}\r\n+\r\n+// Coin Control: copy label \"Dust\" to clipboard\r\n+void SendCoinsDialog::coinControlClipboardLowOutput()\r\n+{\r\n+    GUIUtil::setClipboard(ui->labelCoinControlLowOutput->text());\r\n+}\r\n+\r\n+// Coin Control: copy label \"Change\" to clipboard\r\n+void SendCoinsDialog::coinControlClipboardChange()\r\n+{\r\n+    GUIUtil::setClipboard(ui->labelCoinControlChange->text().left(ui->labelCoinControlChange->text().indexOf(\" \")).replace(ASYMP_UTF8, \"\"));\r\n+}\r\n+\r\n+// Coin Control: settings menu - coin control enabled/disabled by user\r\n+void SendCoinsDialog::coinControlFeatureChanged(bool checked)\r\n+{\r\n+    ui->frameCoinControl->setVisible(checked);\r\n+\r\n+    if (!checked && model) // coin control features disabled\r\n+        CoinControlDialog::coinControl->SetNull();\r\n+\r\n+    coinControlUpdateLabels();\r\n+}\r\n+\r\n+// Coin Control: button inputs -> show actual coin control dialog\r\n+void SendCoinsDialog::coinControlButtonClicked()\r\n+{\r\n+    CoinControlDialog dlg(platformStyle);\r\n+    dlg.setModel(model);\r\n+    dlg.exec();\r\n+    coinControlUpdateLabels();\r\n+}\r\n+\r\n+// Coin Control: checkbox custom change address\r\n+void SendCoinsDialog::coinControlChangeChecked(int state)\r\n+{\r\n+    if (state == Qt::Unchecked)\r\n+    {\r\n+        CoinControlDialog::coinControl->destChange = CNoDestination();\r\n+        ui->labelCoinControlChangeLabel->clear();\r\n+    }\r\n+    else\r\n+        // use this to re-validate an already entered address\r\n+        coinControlChangeEdited(ui->lineEditCoinControlChange->text());\r\n+\r\n+    ui->lineEditCoinControlChange->setEnabled((state == Qt::Checked));\r\n+}\r\n+\r\n+// Coin Control: custom change address changed\r\n+void SendCoinsDialog::coinControlChangeEdited(const QString& text)\r\n+{\r\n+    if (model && model->getAddressTableModel())\r\n+    {\r\n+        // Default to no change address until verified\r\n+        CoinControlDialog::coinControl->destChange = CNoDestination();\r\n+        ui->labelCoinControlChangeLabel->setStyleSheet(\"QLabel{color:red;}\");\r\n+\r\n+        const CTxDestination dest = DecodeDestination(text.toStdString());\r\n+\r\n+        if (text.isEmpty()) // Nothing entered\r\n+        {\r\n+            ui->labelCoinControlChangeLabel->setText(\"\");\r\n+        }\r\n+        else if (!IsValidDestination(dest)) // Invalid address\r\n+        {\r\n+            ui->labelCoinControlChangeLabel->setText(tr(\"Warning: Invalid Bitcoin address\"));\r\n+        }\r\n+        else // Valid address\r\n+        {\r\n+            if (!model->IsSpendable(dest)) {\r\n+                ui->labelCoinControlChangeLabel->setText(tr(\"Warning: Unknown change address\"));\r\n+\r\n+                // confirmation dialog\r\n+                QMessageBox::StandardButton btnRetVal = QMessageBox::question(this, tr(\"Confirm custom change address\"), tr(\"The address you selected for change is not part of this wallet. Any or all funds in your wallet may be sent to this address. Are you sure?\"),\r\n+                    QMessageBox::Yes | QMessageBox::Cancel, QMessageBox::Cancel);\r\n+\r\n+                if(btnRetVal == QMessageBox::Yes)\r\n+                    CoinControlDialog::coinControl->destChange = dest;\r\n+                else\r\n+                {\r\n+                    ui->lineEditCoinControlChange->setText(\"\");\r\n+                    ui->labelCoinControlChangeLabel->setStyleSheet(\"QLabel{color:black;}\");\r\n+                    ui->labelCoinControlChangeLabel->setText(\"\");\r\n+                }\r\n+            }\r\n+            else // Known change address\r\n+            {\r\n+                ui->labelCoinControlChangeLabel->setStyleSheet(\"QLabel{color:black;}\");\r\n+\r\n+                // Query label\r\n+                QString associatedLabel = model->getAddressTableModel()->labelForAddress(text);\r\n+                if (!associatedLabel.isEmpty())\r\n+                    ui->labelCoinControlChangeLabel->setText(associatedLabel);\r\n+                else\r\n+                    ui->labelCoinControlChangeLabel->setText(tr(\"(no label)\"));\r\n+\r\n+                CoinControlDialog::coinControl->destChange = dest;\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+// Coin Control: update labels\r\n+void SendCoinsDialog::coinControlUpdateLabels()\r\n+{\r\n+    if (!model || !model->getOptionsModel())\r\n+        return;\r\n+\r\n+    updateCoinControlState(*CoinControlDialog::coinControl);\r\n+\r\n+    // set pay amounts\r\n+    CoinControlDialog::payAmounts.clear();\r\n+    CoinControlDialog::fSubtractFeeFromAmount = false;\r\n+\r\n+    for(int i = 0; i < ui->entries->count(); ++i)\r\n+    {\r\n+        SendCoinsEntry *entry = qobject_cast<SendCoinsEntry*>(ui->entries->itemAt(i)->widget());\r\n+        if(entry && !entry->isHidden())\r\n+        {\r\n+            SendCoinsRecipient rcp = entry->getValue();\r\n+            CoinControlDialog::payAmounts.append(rcp.amount);\r\n+            if (rcp.fSubtractFeeFromAmount)\r\n+                CoinControlDialog::fSubtractFeeFromAmount = true;\r\n+        }\r\n+    }\r\n+\r\n+    if (CoinControlDialog::coinControl->HasSelected())\r\n+    {\r\n+        // actual coin control calculation\r\n+        CoinControlDialog::updateLabels(model, this);\r\n+\r\n+        // show coin control stats\r\n+        ui->labelCoinControlAutomaticallySelected->hide();\r\n+        ui->widgetCoinControl->show();\r\n+    }\r\n+    else\r\n+    {\r\n+        // hide coin control stats\r\n+        ui->labelCoinControlAutomaticallySelected->show();\r\n+        ui->widgetCoinControl->hide();\r\n+        ui->labelCoinControlInsuffFunds->hide();\r\n+    }\r\n+}\r\n+\r\n+SendConfirmationDialog::SendConfirmationDialog(const QString &title, const QString &text, int _secDelay,\r\n+    QWidget *parent) :\r\n+    QMessageBox(QMessageBox::Question, title, text, QMessageBox::Yes | QMessageBox::Cancel, parent), secDelay(_secDelay)\r\n+{\r\n+    setDefaultButton(QMessageBox::Cancel);\r\n+    yesButton = button(QMessageBox::Yes);\r\n+    updateYesButton();\r\n+    connect(&countDownTimer, SIGNAL(timeout()), this, SLOT(countDown()));\r\n+}\r\n+\r\n+int SendConfirmationDialog::exec()\r\n+{\r\n+    updateYesButton();\r\n+    countDownTimer.start(1000);\r\n+    return QMessageBox::exec();\r\n+}\r\n+\r\n+void SendConfirmationDialog::countDown()\r\n+{\r\n+    secDelay--;\r\n+    updateYesButton();\r\n+\r\n+    if(secDelay <= 0)\r\n+    {\r\n+        countDownTimer.stop();\r\n+    }\r\n+}\r\n+\r\n+void SendConfirmationDialog::updateYesButton()\r\n+{\r\n+    if(secDelay > 0)\r\n+    {\r\n+        yesButton->setEnabled(false);\r\n+        yesButton->setText(tr(\"Yes\") + \" (\" + QString::number(secDelay) + \")\");\r\n+    }\r\n+    else\r\n+    {\r\n+        yesButton->setEnabled(true);\r\n+        yesButton->setText(tr(\"Yes\"));\r\n+    }\r\n+}\r"
      },
      {
        "sha": "2febad5aa972d5a683733ab4a7d37a775196186f",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 1007,
        "deletions": 999,
        "changes": 2006,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,999 +1,1007 @@\n-// Copyright (c) 2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <base58.h>\n-#include <amount.h>\n-#include <chain.h>\n-#include <chainparams.h>\n-#include <consensus/consensus.h>\n-#include <consensus/params.h>\n-#include <consensus/validation.h>\n-#include <core_io.h>\n-#include <init.h>\n-#include <validation.h>\n-#include <miner.h>\n-#include <net.h>\n-#include <policy/fees.h>\n-#include <pow.h>\n-#include <rpc/blockchain.h>\n-#include <rpc/mining.h>\n-#include <rpc/server.h>\n-#include <txmempool.h>\n-#include <util.h>\n-#include <utilstrencodings.h>\n-#include <validationinterface.h>\n-#include <warnings.h>\n-\n-#include <memory>\n-#include <stdint.h>\n-\n-unsigned int ParseConfirmTarget(const UniValue& value)\n-{\n-    int target = value.get_int();\n-    unsigned int max_target = ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\n-    if (target < 1 || (unsigned int)target > max_target) {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid conf_target, must be between %u - %u\", 1, max_target));\n-    }\n-    return (unsigned int)target;\n-}\n-\n-/**\n- * Return average network hashes per second based on the last 'lookup' blocks,\n- * or from the last difficulty change if 'lookup' is nonpositive.\n- * If 'height' is nonnegative, compute the estimate at the time when a given block was found.\n- */\n-UniValue GetNetworkHashPS(int lookup, int height) {\n-    CBlockIndex *pb = chainActive.Tip();\n-\n-    if (height >= 0 && height < chainActive.Height())\n-        pb = chainActive[height];\n-\n-    if (pb == nullptr || !pb->nHeight)\n-        return 0;\n-\n-    // If lookup is -1, then use blocks since last difficulty change.\n-    if (lookup <= 0)\n-        lookup = pb->nHeight % Params().GetConsensus().DifficultyAdjustmentInterval() + 1;\n-\n-    // If lookup is larger than chain, then set it to chain length.\n-    if (lookup > pb->nHeight)\n-        lookup = pb->nHeight;\n-\n-    CBlockIndex *pb0 = pb;\n-    int64_t minTime = pb0->GetBlockTime();\n-    int64_t maxTime = minTime;\n-    for (int i = 0; i < lookup; i++) {\n-        pb0 = pb0->pprev;\n-        int64_t time = pb0->GetBlockTime();\n-        minTime = std::min(time, minTime);\n-        maxTime = std::max(time, maxTime);\n-    }\n-\n-    // In case there's a situation where minTime == maxTime, we don't want a divide by zero exception.\n-    if (minTime == maxTime)\n-        return 0;\n-\n-    arith_uint256 workDiff = pb->nChainWork - pb0->nChainWork;\n-    int64_t timeDiff = maxTime - minTime;\n-\n-    return workDiff.getdouble() / timeDiff;\n-}\n-\n-UniValue getnetworkhashps(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() > 2)\n-        throw std::runtime_error(\n-            \"getnetworkhashps ( nblocks height )\\n\"\n-            \"\\nReturns the estimated network hashes per second based on the last n blocks.\\n\"\n-            \"Pass in [blocks] to override # of blocks, -1 specifies since last difficulty change.\\n\"\n-            \"Pass in [height] to estimate the network speed at the time when a certain block was found.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. nblocks     (numeric, optional, default=120) The number of blocks, or -1 for blocks since last difficulty change.\\n\"\n-            \"2. height      (numeric, optional, default=-1) To estimate at the time of the given height.\\n\"\n-            \"\\nResult:\\n\"\n-            \"x             (numeric) Hashes per second estimated\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getnetworkhashps\", \"\")\n-            + HelpExampleRpc(\"getnetworkhashps\", \"\")\n-       );\n-\n-    LOCK(cs_main);\n-    return GetNetworkHashPS(!request.params[0].isNull() ? request.params[0].get_int() : 120, !request.params[1].isNull() ? request.params[1].get_int() : -1);\n-}\n-\n-UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)\n-{\n-    static const int nInnerLoopCount = 0x10000;\n-    int nHeightEnd = 0;\n-    int nHeight = 0;\n-\n-    {   // Don't keep cs_main locked\n-        LOCK(cs_main);\n-        nHeight = chainActive.Height();\n-        nHeightEnd = nHeight+nGenerate;\n-    }\n-    unsigned int nExtraNonce = 0;\n-    UniValue blockHashes(UniValue::VARR);\n-    while (nHeight < nHeightEnd)\n-    {\n-        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript->reserveScript));\n-        if (!pblocktemplate.get())\n-            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\n-        CBlock *pblock = &pblocktemplate->block;\n-        {\n-            LOCK(cs_main);\n-            IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);\n-        }\n-        while (nMaxTries > 0 && pblock->nNonce < nInnerLoopCount && !CheckProofOfWork(pblock->GetHash(), pblock->nBits, Params().GetConsensus())) {\n-            ++pblock->nNonce;\n-            --nMaxTries;\n-        }\n-        if (nMaxTries == 0) {\n-            break;\n-        }\n-        if (pblock->nNonce == nInnerLoopCount) {\n-            continue;\n-        }\n-        std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n-        if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))\n-            throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n-        ++nHeight;\n-        blockHashes.push_back(pblock->GetHash().GetHex());\n-\n-        //mark script as important because it was used at least for one coinbase output if the script came from the wallet\n-        if (keepScript)\n-        {\n-            coinbaseScript->KeepScript();\n-        }\n-    }\n-    return blockHashes;\n-}\n-\n-UniValue generatetoaddress(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n-        throw std::runtime_error(\n-            \"generatetoaddress nblocks address (maxtries)\\n\"\n-            \"\\nMine blocks immediately to a specified address (before the RPC call returns)\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. nblocks      (numeric, required) How many blocks are generated immediately.\\n\"\n-            \"2. address      (string, required) The address to send the newly generated bitcoin to.\\n\"\n-            \"3. maxtries     (numeric, optional) How many iterations to try (default = 1000000).\\n\"\n-            \"\\nResult:\\n\"\n-            \"[ blockhashes ]     (array) hashes of blocks generated\\n\"\n-            \"\\nExamples:\\n\"\n-            \"\\nGenerate 11 blocks to myaddress\\n\"\n-            + HelpExampleCli(\"generatetoaddress\", \"11 \\\"myaddress\\\"\")\n-        );\n-\n-    int nGenerate = request.params[0].get_int();\n-    uint64_t nMaxTries = 1000000;\n-    if (!request.params[2].isNull()) {\n-        nMaxTries = request.params[2].get_int();\n-    }\n-\n-    CTxDestination destination = DecodeDestination(request.params[1].get_str());\n-    if (!IsValidDestination(destination)) {\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Error: Invalid address\");\n-    }\n-\n-    std::shared_ptr<CReserveScript> coinbaseScript = std::make_shared<CReserveScript>();\n-    coinbaseScript->reserveScript = GetScriptForDestination(destination);\n-\n-    return generateBlocks(coinbaseScript, nGenerate, nMaxTries, false);\n-}\n-\n-UniValue getmininginfo(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() != 0)\n-        throw std::runtime_error(\n-            \"getmininginfo\\n\"\n-            \"\\nReturns a json object containing mining-related information.\"\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"blocks\\\": nnn,             (numeric) The current block\\n\"\n-            \"  \\\"currentblockweight\\\": nnn, (numeric) The last block weight\\n\"\n-            \"  \\\"currentblocktx\\\": nnn,     (numeric) The last block transaction\\n\"\n-            \"  \\\"difficulty\\\": xxx.xxxxx    (numeric) The current difficulty\\n\"\n-            \"  \\\"networkhashps\\\": nnn,      (numeric) The network hashes per second\\n\"\n-            \"  \\\"pooledtx\\\": n              (numeric) The size of the mempool\\n\"\n-            \"  \\\"chain\\\": \\\"xxxx\\\",           (string) current network name as defined in BIP70 (main, test, regtest)\\n\"\n-            \"  \\\"warnings\\\": \\\"...\\\"          (string) any network and blockchain warnings\\n\"\n-            \"  \\\"errors\\\": \\\"...\\\"            (string) DEPRECATED. Same as warnings. Only shown when bitcoind is started with -deprecatedrpc=getmininginfo\\n\"\n-            \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getmininginfo\", \"\")\n-            + HelpExampleRpc(\"getmininginfo\", \"\")\n-        );\n-\n-\n-    LOCK(cs_main);\n-\n-    UniValue obj(UniValue::VOBJ);\n-    obj.push_back(Pair(\"blocks\",           (int)chainActive.Height()));\n-    obj.push_back(Pair(\"currentblockweight\", (uint64_t)nLastBlockWeight));\n-    obj.push_back(Pair(\"currentblocktx\",   (uint64_t)nLastBlockTx));\n-    obj.push_back(Pair(\"difficulty\",       (double)GetDifficulty()));\n-    obj.push_back(Pair(\"networkhashps\",    getnetworkhashps(request)));\n-    obj.push_back(Pair(\"pooledtx\",         (uint64_t)mempool.size()));\n-    obj.push_back(Pair(\"chain\",            Params().NetworkIDString()));\n-    if (IsDeprecatedRPCEnabled(\"getmininginfo\")) {\n-        obj.push_back(Pair(\"errors\",       GetWarnings(\"statusbar\")));\n-    } else {\n-        obj.push_back(Pair(\"warnings\",     GetWarnings(\"statusbar\")));\n-    }\n-    return obj;\n-}\n-\n-\n-// NOTE: Unlike wallet RPC (which use BTC values), mining RPCs follow GBT (BIP 22) in using satoshi amounts\n-UniValue prioritisetransaction(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() != 3)\n-        throw std::runtime_error(\n-            \"prioritisetransaction <txid> <dummy value> <fee delta>\\n\"\n-            \"Accepts the transaction into mined blocks at a higher (or lower) priority\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txid\\\"       (string, required) The transaction id.\\n\"\n-            \"2. dummy          (numeric, optional) API-Compatibility for previous API. Must be zero or null.\\n\"\n-            \"                  DEPRECATED. For forward compatibility use named arguments and omit this parameter.\\n\"\n-            \"3. fee_delta      (numeric, required) The fee value (in satoshis) to add (or subtract, if negative).\\n\"\n-            \"                  The fee is not actually paid, only the algorithm for selecting transactions into a block\\n\"\n-            \"                  considers the transaction as it would have paid a higher (or lower) fee.\\n\"\n-            \"\\nResult:\\n\"\n-            \"true              (boolean) Returns true\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"prioritisetransaction\", \"\\\"txid\\\" 0.0 10000\")\n-            + HelpExampleRpc(\"prioritisetransaction\", \"\\\"txid\\\", 0.0, 10000\")\n-        );\n-\n-    LOCK(cs_main);\n-\n-    uint256 hash = ParseHashStr(request.params[0].get_str(), \"txid\");\n-    CAmount nAmount = request.params[2].get_int64();\n-\n-    if (!(request.params[1].isNull() || request.params[1].get_real() == 0)) {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Priority is no longer supported, dummy argument to prioritisetransaction must be 0.\");\n-    }\n-\n-    mempool.PrioritiseTransaction(hash, nAmount);\n-    return true;\n-}\n-\n-\n-// NOTE: Assumes a conclusive result; if result is inconclusive, it must be handled by caller\n-static UniValue BIP22ValidationResult(const CValidationState& state)\n-{\n-    if (state.IsValid())\n-        return NullUniValue;\n-\n-    std::string strRejectReason = state.GetRejectReason();\n-    if (state.IsError())\n-        throw JSONRPCError(RPC_VERIFY_ERROR, strRejectReason);\n-    if (state.IsInvalid())\n-    {\n-        if (strRejectReason.empty())\n-            return \"rejected\";\n-        return strRejectReason;\n-    }\n-    // Should be impossible\n-    return \"valid?\";\n-}\n-\n-std::string gbt_vb_name(const Consensus::DeploymentPos pos) {\n-    const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n-    std::string s = vbinfo.name;\n-    if (!vbinfo.gbt_force) {\n-        s.insert(s.begin(), '!');\n-    }\n-    return s;\n-}\n-\n-UniValue getblocktemplate(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() > 1)\n-        throw std::runtime_error(\n-            \"getblocktemplate ( TemplateRequest )\\n\"\n-            \"\\nIf the request parameters include a 'mode' key, that is used to explicitly select between the default 'template' request or a 'proposal'.\\n\"\n-            \"It returns data needed to construct a block to work on.\\n\"\n-            \"For full specification, see BIPs 22, 23, 9, and 145:\\n\"\n-            \"    https://github.com/bitcoin/bips/blob/master/bip-0022.mediawiki\\n\"\n-            \"    https://github.com/bitcoin/bips/blob/master/bip-0023.mediawiki\\n\"\n-            \"    https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki#getblocktemplate_changes\\n\"\n-            \"    https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. template_request         (json object, optional) A json object in the following spec\\n\"\n-            \"     {\\n\"\n-            \"       \\\"mode\\\":\\\"template\\\"    (string, optional) This must be set to \\\"template\\\", \\\"proposal\\\" (see BIP 23), or omitted\\n\"\n-            \"       \\\"capabilities\\\":[     (array, optional) A list of strings\\n\"\n-            \"           \\\"support\\\"          (string) client side supported feature, 'longpoll', 'coinbasetxn', 'coinbasevalue', 'proposal', 'serverlist', 'workid'\\n\"\n-            \"           ,...\\n\"\n-            \"       ],\\n\"\n-            \"       \\\"rules\\\":[            (array, optional) A list of strings\\n\"\n-            \"           \\\"support\\\"          (string) client side supported softfork deployment\\n\"\n-            \"           ,...\\n\"\n-            \"       ]\\n\"\n-            \"     }\\n\"\n-            \"\\n\"\n-\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"version\\\" : n,                    (numeric) The preferred block version\\n\"\n-            \"  \\\"rules\\\" : [ \\\"rulename\\\", ... ],    (array of strings) specific block rules that are to be enforced\\n\"\n-            \"  \\\"vbavailable\\\" : {                 (json object) set of pending, supported versionbit (BIP 9) softfork deployments\\n\"\n-            \"      \\\"rulename\\\" : bitnumber          (numeric) identifies the bit number as indicating acceptance and readiness for the named softfork rule\\n\"\n-            \"      ,...\\n\"\n-            \"  },\\n\"\n-            \"  \\\"vbrequired\\\" : n,                 (numeric) bit mask of versionbits the server requires set in submissions\\n\"\n-            \"  \\\"previousblockhash\\\" : \\\"xxxx\\\",     (string) The hash of current highest block\\n\"\n-            \"  \\\"transactions\\\" : [                (array) contents of non-coinbase transactions that should be included in the next block\\n\"\n-            \"      {\\n\"\n-            \"         \\\"data\\\" : \\\"xxxx\\\",             (string) transaction data encoded in hexadecimal (byte-for-byte)\\n\"\n-            \"         \\\"txid\\\" : \\\"xxxx\\\",             (string) transaction id encoded in little-endian hexadecimal\\n\"\n-            \"         \\\"hash\\\" : \\\"xxxx\\\",             (string) hash encoded in little-endian hexadecimal (including witness data)\\n\"\n-            \"         \\\"depends\\\" : [                (array) array of numbers \\n\"\n-            \"             n                          (numeric) transactions before this one (by 1-based index in 'transactions' list) that must be present in the final block if this one is\\n\"\n-            \"             ,...\\n\"\n-            \"         ],\\n\"\n-            \"         \\\"fee\\\": n,                    (numeric) difference in value between transaction inputs and outputs (in satoshis); for coinbase transactions, this is a negative Number of the total collected block fees (ie, not including the block subsidy); if key is not present, fee is unknown and clients MUST NOT assume there isn't one\\n\"\n-            \"         \\\"sigops\\\" : n,                (numeric) total SigOps cost, as counted for purposes of block limits; if key is not present, sigop cost is unknown and clients MUST NOT assume it is zero\\n\"\n-            \"         \\\"weight\\\" : n,                (numeric) total transaction weight, as counted for purposes of block limits\\n\"\n-            \"         \\\"required\\\" : true|false      (boolean) if provided and true, this transaction must be in the final block\\n\"\n-            \"      }\\n\"\n-            \"      ,...\\n\"\n-            \"  ],\\n\"\n-            \"  \\\"coinbaseaux\\\" : {                 (json object) data that should be included in the coinbase's scriptSig content\\n\"\n-            \"      \\\"flags\\\" : \\\"xx\\\"                  (string) key name is to be ignored, and value included in scriptSig\\n\"\n-            \"  },\\n\"\n-            \"  \\\"coinbasevalue\\\" : n,              (numeric) maximum allowable input to coinbase transaction, including the generation award and transaction fees (in satoshis)\\n\"\n-            \"  \\\"coinbasetxn\\\" : { ... },          (json object) information for coinbase transaction\\n\"\n-            \"  \\\"target\\\" : \\\"xxxx\\\",                (string) The hash target\\n\"\n-            \"  \\\"mintime\\\" : xxx,                  (numeric) The minimum timestamp appropriate for next block time in seconds since epoch (Jan 1 1970 GMT)\\n\"\n-            \"  \\\"mutable\\\" : [                     (array of string) list of ways the block template may be changed \\n\"\n-            \"     \\\"value\\\"                          (string) A way the block template may be changed, e.g. 'time', 'transactions', 'prevblock'\\n\"\n-            \"     ,...\\n\"\n-            \"  ],\\n\"\n-            \"  \\\"noncerange\\\" : \\\"00000000ffffffff\\\",(string) A range of valid nonces\\n\"\n-            \"  \\\"sigoplimit\\\" : n,                 (numeric) limit of sigops in blocks\\n\"\n-            \"  \\\"sizelimit\\\" : n,                  (numeric) limit of block size\\n\"\n-            \"  \\\"weightlimit\\\" : n,                (numeric) limit of block weight\\n\"\n-            \"  \\\"curtime\\\" : ttt,                  (numeric) current timestamp in seconds since epoch (Jan 1 1970 GMT)\\n\"\n-            \"  \\\"bits\\\" : \\\"xxxxxxxx\\\",              (string) compressed target of next block\\n\"\n-            \"  \\\"height\\\" : n                      (numeric) The height of the next block\\n\"\n-            \"}\\n\"\n-\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getblocktemplate\", \"\")\n-            + HelpExampleRpc(\"getblocktemplate\", \"\")\n-         );\n-\n-    LOCK(cs_main);\n-\n-    std::string strMode = \"template\";\n-    UniValue lpval = NullUniValue;\n-    std::set<std::string> setClientRules;\n-    int64_t nMaxVersionPreVB = -1;\n-    if (!request.params[0].isNull())\n-    {\n-        const UniValue& oparam = request.params[0].get_obj();\n-        const UniValue& modeval = find_value(oparam, \"mode\");\n-        if (modeval.isStr())\n-            strMode = modeval.get_str();\n-        else if (modeval.isNull())\n-        {\n-            /* Do nothing */\n-        }\n-        else\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid mode\");\n-        lpval = find_value(oparam, \"longpollid\");\n-\n-        if (strMode == \"proposal\")\n-        {\n-            const UniValue& dataval = find_value(oparam, \"data\");\n-            if (!dataval.isStr())\n-                throw JSONRPCError(RPC_TYPE_ERROR, \"Missing data String key for proposal\");\n-\n-            CBlock block;\n-            if (!DecodeHexBlk(block, dataval.get_str()))\n-                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block decode failed\");\n-\n-            uint256 hash = block.GetHash();\n-            BlockMap::iterator mi = mapBlockIndex.find(hash);\n-            if (mi != mapBlockIndex.end()) {\n-                CBlockIndex *pindex = mi->second;\n-                if (pindex->IsValid(BLOCK_VALID_SCRIPTS))\n-                    return \"duplicate\";\n-                if (pindex->nStatus & BLOCK_FAILED_MASK)\n-                    return \"duplicate-invalid\";\n-                return \"duplicate-inconclusive\";\n-            }\n-\n-            CBlockIndex* const pindexPrev = chainActive.Tip();\n-            // TestBlockValidity only supports blocks built on the current Tip\n-            if (block.hashPrevBlock != pindexPrev->GetBlockHash())\n-                return \"inconclusive-not-best-prevblk\";\n-            CValidationState state;\n-            TestBlockValidity(state, Params(), block, pindexPrev, false, true);\n-            return BIP22ValidationResult(state);\n-        }\n-\n-        const UniValue& aClientRules = find_value(oparam, \"rules\");\n-        if (aClientRules.isArray()) {\n-            for (unsigned int i = 0; i < aClientRules.size(); ++i) {\n-                const UniValue& v = aClientRules[i];\n-                setClientRules.insert(v.get_str());\n-            }\n-        } else {\n-            // NOTE: It is important that this NOT be read if versionbits is supported\n-            const UniValue& uvMaxVersion = find_value(oparam, \"maxversion\");\n-            if (uvMaxVersion.isNum()) {\n-                nMaxVersionPreVB = uvMaxVersion.get_int64();\n-            }\n-        }\n-    }\n-\n-    if (strMode != \"template\")\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid mode\");\n-\n-    if(!g_connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n-\n-    if (g_connman->GetNodeCount(CConnman::CONNECTIONS_ALL) == 0)\n-        throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, \"Bitcoin is not connected!\");\n-\n-    if (IsInitialBlockDownload())\n-        throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, \"Bitcoin is downloading blocks...\");\n-\n-    static unsigned int nTransactionsUpdatedLast;\n-\n-    if (!lpval.isNull())\n-    {\n-        // Wait to respond until either the best block changes, OR a minute has passed and there are more transactions\n-        uint256 hashWatchedChain;\n-        std::chrono::steady_clock::time_point checktxtime;\n-        unsigned int nTransactionsUpdatedLastLP;\n-\n-        if (lpval.isStr())\n-        {\n-            // Format: <hashBestChain><nTransactionsUpdatedLast>\n-            std::string lpstr = lpval.get_str();\n-\n-            hashWatchedChain.SetHex(lpstr.substr(0, 64));\n-            nTransactionsUpdatedLastLP = atoi64(lpstr.substr(64));\n-        }\n-        else\n-        {\n-            // NOTE: Spec does not specify behaviour for non-string longpollid, but this makes testing easier\n-            hashWatchedChain = chainActive.Tip()->GetBlockHash();\n-            nTransactionsUpdatedLastLP = nTransactionsUpdatedLast;\n-        }\n-\n-        // Release the wallet and main lock while waiting\n-        LEAVE_CRITICAL_SECTION(cs_main);\n-        {\n-            checktxtime = std::chrono::steady_clock::now() + std::chrono::minutes(1);\n-\n-            WaitableLock lock(csBestBlock);\n-            while (chainActive.Tip()->GetBlockHash() == hashWatchedChain && IsRPCRunning())\n-            {\n-                if (cvBlockChange.wait_until(lock, checktxtime) == std::cv_status::timeout)\n-                {\n-                    // Timeout: Check transactions for update\n-                    if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLastLP)\n-                        break;\n-                    checktxtime += std::chrono::seconds(10);\n-                }\n-            }\n-        }\n-        ENTER_CRITICAL_SECTION(cs_main);\n-\n-        if (!IsRPCRunning())\n-            throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, \"Shutting down\");\n-        // TODO: Maybe recheck connections/IBD and (if something wrong) send an expires-immediately template to stop miners?\n-    }\n-\n-    const struct VBDeploymentInfo& segwit_info = VersionBitsDeploymentInfo[Consensus::DEPLOYMENT_SEGWIT];\n-    // If the caller is indicating segwit support, then allow CreateNewBlock()\n-    // to select witness transactions, after segwit activates (otherwise\n-    // don't).\n-    bool fSupportsSegwit = setClientRules.find(segwit_info.name) != setClientRules.end();\n-\n-    // Update block\n-    static CBlockIndex* pindexPrev;\n-    static int64_t nStart;\n-    static std::unique_ptr<CBlockTemplate> pblocktemplate;\n-    // Cache whether the last invocation was with segwit support, to avoid returning\n-    // a segwit-block to a non-segwit caller.\n-    static bool fLastTemplateSupportsSegwit = true;\n-    if (pindexPrev != chainActive.Tip() ||\n-        (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 5) ||\n-        fLastTemplateSupportsSegwit != fSupportsSegwit)\n-    {\n-        // Clear pindexPrev so future calls make a new block, despite any failures from here on\n-        pindexPrev = nullptr;\n-\n-        // Store the pindexBest used before CreateNewBlock, to avoid races\n-        nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\n-        CBlockIndex* pindexPrevNew = chainActive.Tip();\n-        nStart = GetTime();\n-        fLastTemplateSupportsSegwit = fSupportsSegwit;\n-\n-        // Create new block\n-        CScript scriptDummy = CScript() << OP_TRUE;\n-        pblocktemplate = BlockAssembler(Params()).CreateNewBlock(scriptDummy, fSupportsSegwit);\n-        if (!pblocktemplate)\n-            throw JSONRPCError(RPC_OUT_OF_MEMORY, \"Out of memory\");\n-\n-        // Need to update only after we know CreateNewBlock succeeded\n-        pindexPrev = pindexPrevNew;\n-    }\n-    CBlock* pblock = &pblocktemplate->block; // pointer for convenience\n-    const Consensus::Params& consensusParams = Params().GetConsensus();\n-\n-    // Update nTime\n-    UpdateTime(pblock, consensusParams, pindexPrev);\n-    pblock->nNonce = 0;\n-\n-    // NOTE: If at some point we support pre-segwit miners post-segwit-activation, this needs to take segwit support into consideration\n-    const bool fPreSegWit = (THRESHOLD_ACTIVE != VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache));\n-\n-    UniValue aCaps(UniValue::VARR); aCaps.push_back(\"proposal\");\n-\n-    UniValue transactions(UniValue::VARR);\n-    std::map<uint256, int64_t> setTxIndex;\n-    int i = 0;\n-    for (const auto& it : pblock->vtx) {\n-        const CTransaction& tx = *it;\n-        uint256 txHash = tx.GetHash();\n-        setTxIndex[txHash] = i++;\n-\n-        if (tx.IsCoinBase())\n-            continue;\n-\n-        UniValue entry(UniValue::VOBJ);\n-\n-        entry.push_back(Pair(\"data\", EncodeHexTx(tx)));\n-        entry.push_back(Pair(\"txid\", txHash.GetHex()));\n-        entry.push_back(Pair(\"hash\", tx.GetWitnessHash().GetHex()));\n-\n-        UniValue deps(UniValue::VARR);\n-        for (const CTxIn &in : tx.vin)\n-        {\n-            if (setTxIndex.count(in.prevout.hash))\n-                deps.push_back(setTxIndex[in.prevout.hash]);\n-        }\n-        entry.push_back(Pair(\"depends\", deps));\n-\n-        int index_in_template = i - 1;\n-        entry.push_back(Pair(\"fee\", pblocktemplate->vTxFees[index_in_template]));\n-        int64_t nTxSigOps = pblocktemplate->vTxSigOpsCost[index_in_template];\n-        if (fPreSegWit) {\n-            assert(nTxSigOps % WITNESS_SCALE_FACTOR == 0);\n-            nTxSigOps /= WITNESS_SCALE_FACTOR;\n-        }\n-        entry.push_back(Pair(\"sigops\", nTxSigOps));\n-        entry.push_back(Pair(\"weight\", GetTransactionWeight(tx)));\n-\n-        transactions.push_back(entry);\n-    }\n-\n-    UniValue aux(UniValue::VOBJ);\n-    aux.push_back(Pair(\"flags\", HexStr(COINBASE_FLAGS.begin(), COINBASE_FLAGS.end())));\n-\n-    arith_uint256 hashTarget = arith_uint256().SetCompact(pblock->nBits);\n-\n-    UniValue aMutable(UniValue::VARR);\n-    aMutable.push_back(\"time\");\n-    aMutable.push_back(\"transactions\");\n-    aMutable.push_back(\"prevblock\");\n-\n-    UniValue result(UniValue::VOBJ);\n-    result.push_back(Pair(\"capabilities\", aCaps));\n-\n-    UniValue aRules(UniValue::VARR);\n-    UniValue vbavailable(UniValue::VOBJ);\n-    for (int j = 0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {\n-        Consensus::DeploymentPos pos = Consensus::DeploymentPos(j);\n-        ThresholdState state = VersionBitsState(pindexPrev, consensusParams, pos, versionbitscache);\n-        switch (state) {\n-            case THRESHOLD_DEFINED:\n-            case THRESHOLD_FAILED:\n-                // Not exposed to GBT at all\n-                break;\n-            case THRESHOLD_LOCKED_IN:\n-                // Ensure bit is set in block version\n-                pblock->nVersion |= VersionBitsMask(consensusParams, pos);\n-                // FALL THROUGH to get vbavailable set...\n-            case THRESHOLD_STARTED:\n-            {\n-                const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n-                vbavailable.push_back(Pair(gbt_vb_name(pos), consensusParams.vDeployments[pos].bit));\n-                if (setClientRules.find(vbinfo.name) == setClientRules.end()) {\n-                    if (!vbinfo.gbt_force) {\n-                        // If the client doesn't support this, don't indicate it in the [default] version\n-                        pblock->nVersion &= ~VersionBitsMask(consensusParams, pos);\n-                    }\n-                }\n-                break;\n-            }\n-            case THRESHOLD_ACTIVE:\n-            {\n-                // Add to rules only\n-                const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\n-                aRules.push_back(gbt_vb_name(pos));\n-                if (setClientRules.find(vbinfo.name) == setClientRules.end()) {\n-                    // Not supported by the client; make sure it's safe to proceed\n-                    if (!vbinfo.gbt_force) {\n-                        // If we do anything other than throw an exception here, be sure version/force isn't sent to old clients\n-                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Support for '%s' rule requires explicit client support\", vbinfo.name));\n-                    }\n-                }\n-                break;\n-            }\n-        }\n-    }\n-    result.push_back(Pair(\"version\", pblock->nVersion));\n-    result.push_back(Pair(\"rules\", aRules));\n-    result.push_back(Pair(\"vbavailable\", vbavailable));\n-    result.push_back(Pair(\"vbrequired\", int(0)));\n-\n-    if (nMaxVersionPreVB >= 2) {\n-        // If VB is supported by the client, nMaxVersionPreVB is -1, so we won't get here\n-        // Because BIP 34 changed how the generation transaction is serialized, we can only use version/force back to v2 blocks\n-        // This is safe to do [otherwise-]unconditionally only because we are throwing an exception above if a non-force deployment gets activated\n-        // Note that this can probably also be removed entirely after the first BIP9 non-force deployment (ie, probably segwit) gets activated\n-        aMutable.push_back(\"version/force\");\n-    }\n-\n-    result.push_back(Pair(\"previousblockhash\", pblock->hashPrevBlock.GetHex()));\n-    result.push_back(Pair(\"transactions\", transactions));\n-    result.push_back(Pair(\"coinbaseaux\", aux));\n-    result.push_back(Pair(\"coinbasevalue\", (int64_t)pblock->vtx[0]->vout[0].nValue));\n-    result.push_back(Pair(\"longpollid\", chainActive.Tip()->GetBlockHash().GetHex() + i64tostr(nTransactionsUpdatedLast)));\n-    result.push_back(Pair(\"target\", hashTarget.GetHex()));\n-    result.push_back(Pair(\"mintime\", (int64_t)pindexPrev->GetMedianTimePast()+1));\n-    result.push_back(Pair(\"mutable\", aMutable));\n-    result.push_back(Pair(\"noncerange\", \"00000000ffffffff\"));\n-    int64_t nSigOpLimit = MAX_BLOCK_SIGOPS_COST;\n-    int64_t nSizeLimit = MAX_BLOCK_SERIALIZED_SIZE;\n-    if (fPreSegWit) {\n-        assert(nSigOpLimit % WITNESS_SCALE_FACTOR == 0);\n-        nSigOpLimit /= WITNESS_SCALE_FACTOR;\n-        assert(nSizeLimit % WITNESS_SCALE_FACTOR == 0);\n-        nSizeLimit /= WITNESS_SCALE_FACTOR;\n-    }\n-    result.push_back(Pair(\"sigoplimit\", nSigOpLimit));\n-    result.push_back(Pair(\"sizelimit\", nSizeLimit));\n-    if (!fPreSegWit) {\n-        result.push_back(Pair(\"weightlimit\", (int64_t)MAX_BLOCK_WEIGHT));\n-    }\n-    result.push_back(Pair(\"curtime\", pblock->GetBlockTime()));\n-    result.push_back(Pair(\"bits\", strprintf(\"%08x\", pblock->nBits)));\n-    result.push_back(Pair(\"height\", (int64_t)(pindexPrev->nHeight+1)));\n-\n-    if (!pblocktemplate->vchCoinbaseCommitment.empty() && fSupportsSegwit) {\n-        result.push_back(Pair(\"default_witness_commitment\", HexStr(pblocktemplate->vchCoinbaseCommitment.begin(), pblocktemplate->vchCoinbaseCommitment.end())));\n-    }\n-\n-    return result;\n-}\n-\n-class submitblock_StateCatcher : public CValidationInterface\n-{\n-public:\n-    uint256 hash;\n-    bool found;\n-    CValidationState state;\n-\n-    explicit submitblock_StateCatcher(const uint256 &hashIn) : hash(hashIn), found(false), state() {}\n-\n-protected:\n-    void BlockChecked(const CBlock& block, const CValidationState& stateIn) override {\n-        if (block.GetHash() != hash)\n-            return;\n-        found = true;\n-        state = stateIn;\n-    }\n-};\n-\n-UniValue submitblock(const JSONRPCRequest& request)\n-{\n-    // We allow 2 arguments for compliance with BIP22. Argument 2 is ignored.\n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n-        throw std::runtime_error(\n-            \"submitblock \\\"hexdata\\\"  ( \\\"dummy\\\" )\\n\"\n-            \"\\nAttempts to submit new block to network.\\n\"\n-            \"See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\\n\"\n-\n-            \"\\nArguments\\n\"\n-            \"1. \\\"hexdata\\\"        (string, required) the hex-encoded block data to submit\\n\"\n-            \"2. \\\"dummy\\\"          (optional) dummy value, for compatibility with BIP22. This value is ignored.\\n\"\n-            \"\\nResult:\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"submitblock\", \"\\\"mydata\\\"\")\n-            + HelpExampleRpc(\"submitblock\", \"\\\"mydata\\\"\")\n-        );\n-    }\n-\n-    std::shared_ptr<CBlock> blockptr = std::make_shared<CBlock>();\n-    CBlock& block = *blockptr;\n-    if (!DecodeHexBlk(block, request.params[0].get_str())) {\n-        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block decode failed\");\n-    }\n-\n-    if (block.vtx.empty() || !block.vtx[0]->IsCoinBase()) {\n-        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block does not start with a coinbase\");\n-    }\n-\n-    uint256 hash = block.GetHash();\n-    bool fBlockPresent = false;\n-    {\n-        LOCK(cs_main);\n-        BlockMap::iterator mi = mapBlockIndex.find(hash);\n-        if (mi != mapBlockIndex.end()) {\n-            CBlockIndex *pindex = mi->second;\n-            if (pindex->IsValid(BLOCK_VALID_SCRIPTS)) {\n-                return \"duplicate\";\n-            }\n-            if (pindex->nStatus & BLOCK_FAILED_MASK) {\n-                return \"duplicate-invalid\";\n-            }\n-            // Otherwise, we might only have the header - process the block before returning\n-            fBlockPresent = true;\n-        }\n-    }\n-\n-    {\n-        LOCK(cs_main);\n-        BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\n-        if (mi != mapBlockIndex.end()) {\n-            UpdateUncommittedBlockStructures(block, mi->second, Params().GetConsensus());\n-        }\n-    }\n-\n-    submitblock_StateCatcher sc(block.GetHash());\n-    RegisterValidationInterface(&sc);\n-    bool fAccepted = ProcessNewBlock(Params(), blockptr, true, nullptr);\n-    UnregisterValidationInterface(&sc);\n-    if (fBlockPresent) {\n-        if (fAccepted && !sc.found) {\n-            return \"duplicate-inconclusive\";\n-        }\n-        return \"duplicate\";\n-    }\n-    if (!sc.found) {\n-        return \"inconclusive\";\n-    }\n-    return BIP22ValidationResult(sc.state);\n-}\n-\n-UniValue estimatefee(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() != 1)\n-        throw std::runtime_error(\n-            \"estimatefee nblocks\\n\"\n-            \"\\nDEPRECATED. Please use estimatesmartfee for more intelligent estimates.\"\n-            \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\n-            \"confirmation within nblocks blocks. Uses virtual transaction size of transaction\\n\"\n-            \"as defined in BIP 141 (witness data is discounted).\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. nblocks     (numeric, required)\\n\"\n-            \"\\nResult:\\n\"\n-            \"n              (numeric) estimated fee-per-kilobyte\\n\"\n-            \"\\n\"\n-            \"A negative value is returned if not enough transactions and blocks\\n\"\n-            \"have been observed to make an estimate.\\n\"\n-            \"-1 is always returned for nblocks == 1 as it is impossible to calculate\\n\"\n-            \"a fee that is high enough to get reliably included in the next block.\\n\"\n-            \"\\nExample:\\n\"\n-            + HelpExampleCli(\"estimatefee\", \"6\")\n-            );\n-\n-    if (!IsDeprecatedRPCEnabled(\"estimatefee\")) {\n-        throw JSONRPCError(RPC_METHOD_DEPRECATED, \"estimatefee is deprecated and will be fully removed in v0.17. \"\n-            \"To use estimatefee in v0.16, restart bitcoind with -deprecatedrpc=estimatefee.\\n\"\n-            \"Projects should transition to using estimatesmartfee before upgrading to v0.17\");\n-    }\n-\n-    RPCTypeCheck(request.params, {UniValue::VNUM});\n-\n-    int nBlocks = request.params[0].get_int();\n-    if (nBlocks < 1)\n-        nBlocks = 1;\n-\n-    CFeeRate feeRate = ::feeEstimator.estimateFee(nBlocks);\n-    if (feeRate == CFeeRate(0))\n-        return -1.0;\n-\n-    return ValueFromAmount(feeRate.GetFeePerK());\n-}\n-\n-UniValue estimatesmartfee(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw std::runtime_error(\n-            \"estimatesmartfee conf_target (\\\"estimate_mode\\\")\\n\"\n-            \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\n-            \"confirmation within conf_target blocks if possible and return the number of blocks\\n\"\n-            \"for which the estimate is valid. Uses virtual transaction size as defined\\n\"\n-            \"in BIP 141 (witness data is discounted).\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. conf_target     (numeric) Confirmation target in blocks (1 - 1008)\\n\"\n-            \"2. \\\"estimate_mode\\\" (string, optional, default=CONSERVATIVE) The fee estimate mode.\\n\"\n-            \"                   Whether to return a more conservative estimate which also satisfies\\n\"\n-            \"                   a longer history. A conservative estimate potentially returns a\\n\"\n-            \"                   higher feerate and is more likely to be sufficient for the desired\\n\"\n-            \"                   target, but is not as responsive to short term drops in the\\n\"\n-            \"                   prevailing fee market.  Must be one of:\\n\"\n-            \"       \\\"UNSET\\\" (defaults to CONSERVATIVE)\\n\"\n-            \"       \\\"ECONOMICAL\\\"\\n\"\n-            \"       \\\"CONSERVATIVE\\\"\\n\"\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"feerate\\\" : x.x,     (numeric, optional) estimate fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n-            \"  \\\"errors\\\": [ str... ] (json array of strings, optional) Errors encountered during processing\\n\"\n-            \"  \\\"blocks\\\" : n         (numeric) block number where estimate was found\\n\"\n-            \"}\\n\"\n-            \"\\n\"\n-            \"The request target will be clamped between 2 and the highest target\\n\"\n-            \"fee estimation is able to return based on how long it has been running.\\n\"\n-            \"An error is returned if not enough transactions and blocks\\n\"\n-            \"have been observed to make an estimate for any number of blocks.\\n\"\n-            \"\\nExample:\\n\"\n-            + HelpExampleCli(\"estimatesmartfee\", \"6\")\n-            );\n-\n-    RPCTypeCheck(request.params, {UniValue::VNUM, UniValue::VSTR});\n-    RPCTypeCheckArgument(request.params[0], UniValue::VNUM);\n-    unsigned int conf_target = ParseConfirmTarget(request.params[0]);\n-    bool conservative = true;\n-    if (!request.params[1].isNull()) {\n-        FeeEstimateMode fee_mode;\n-        if (!FeeModeFromString(request.params[1].get_str(), fee_mode)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid estimate_mode parameter\");\n-        }\n-        if (fee_mode == FeeEstimateMode::ECONOMICAL) conservative = false;\n-    }\n-\n-    UniValue result(UniValue::VOBJ);\n-    UniValue errors(UniValue::VARR);\n-    FeeCalculation feeCalc;\n-    CFeeRate feeRate = ::feeEstimator.estimateSmartFee(conf_target, &feeCalc, conservative);\n-    if (feeRate != CFeeRate(0)) {\n-        result.push_back(Pair(\"feerate\", ValueFromAmount(feeRate.GetFeePerK())));\n-    } else {\n-        errors.push_back(\"Insufficient data or no feerate found\");\n-        result.push_back(Pair(\"errors\", errors));\n-    }\n-    result.push_back(Pair(\"blocks\", feeCalc.returnedTarget));\n-    return result;\n-}\n-\n-UniValue estimaterawfee(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw std::runtime_error(\n-            \"estimaterawfee conf_target (threshold)\\n\"\n-            \"\\nWARNING: This interface is unstable and may disappear or change!\\n\"\n-            \"\\nWARNING: This is an advanced API call that is tightly coupled to the specific\\n\"\n-            \"         implementation of fee estimation. The parameters it can be called with\\n\"\n-            \"         and the results it returns will change if the internal implementation changes.\\n\"\n-            \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\n-            \"confirmation within conf_target blocks if possible. Uses virtual transaction size as\\n\"\n-            \"defined in BIP 141 (witness data is discounted).\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. conf_target (numeric) Confirmation target in blocks (1 - 1008)\\n\"\n-            \"2. threshold   (numeric, optional) The proportion of transactions in a given feerate range that must have been\\n\"\n-            \"               confirmed within conf_target in order to consider those feerates as high enough and proceed to check\\n\"\n-            \"               lower buckets.  Default: 0.95\\n\"\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"short\\\" : {            (json object, optional) estimate for short time horizon\\n\"\n-            \"      \\\"feerate\\\" : x.x,        (numeric, optional) estimate fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\n-            \"      \\\"decay\\\" : x.x,          (numeric) exponential decay (per block) for historical moving average of confirmation data\\n\"\n-            \"      \\\"scale\\\" : x,            (numeric) The resolution of confirmation targets at this time horizon\\n\"\n-            \"      \\\"pass\\\" : {              (json object, optional) information about the lowest range of feerates to succeed in meeting the threshold\\n\"\n-            \"          \\\"startrange\\\" : x.x,     (numeric) start of feerate range\\n\"\n-            \"          \\\"endrange\\\" : x.x,       (numeric) end of feerate range\\n\"\n-            \"          \\\"withintarget\\\" : x.x,   (numeric) number of txs over history horizon in the feerate range that were confirmed within target\\n\"\n-            \"          \\\"totalconfirmed\\\" : x.x, (numeric) number of txs over history horizon in the feerate range that were confirmed at any point\\n\"\n-            \"          \\\"inmempool\\\" : x.x,      (numeric) current number of txs in mempool in the feerate range unconfirmed for at least target blocks\\n\"\n-            \"          \\\"leftmempool\\\" : x.x,    (numeric) number of txs over history horizon in the feerate range that left mempool unconfirmed after target\\n\"\n-            \"      },\\n\"\n-            \"      \\\"fail\\\" : { ... },       (json object, optional) information about the highest range of feerates to fail to meet the threshold\\n\"\n-            \"      \\\"errors\\\":  [ str... ]   (json array of strings, optional) Errors encountered during processing\\n\"\n-            \"  },\\n\"\n-            \"  \\\"medium\\\" : { ... },    (json object, optional) estimate for medium time horizon\\n\"\n-            \"  \\\"long\\\" : { ... }       (json object) estimate for long time horizon\\n\"\n-            \"}\\n\"\n-            \"\\n\"\n-            \"Results are returned for any horizon which tracks blocks up to the confirmation target.\\n\"\n-            \"\\nExample:\\n\"\n-            + HelpExampleCli(\"estimaterawfee\", \"6 0.9\")\n-            );\n-\n-    RPCTypeCheck(request.params, {UniValue::VNUM, UniValue::VNUM}, true);\n-    RPCTypeCheckArgument(request.params[0], UniValue::VNUM);\n-    unsigned int conf_target = ParseConfirmTarget(request.params[0]);\n-    double threshold = 0.95;\n-    if (!request.params[1].isNull()) {\n-        threshold = request.params[1].get_real();\n-    }\n-    if (threshold < 0 || threshold > 1) {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid threshold\");\n-    }\n-\n-    UniValue result(UniValue::VOBJ);\n-\n-    for (FeeEstimateHorizon horizon : {FeeEstimateHorizon::SHORT_HALFLIFE, FeeEstimateHorizon::MED_HALFLIFE, FeeEstimateHorizon::LONG_HALFLIFE}) {\n-        CFeeRate feeRate;\n-        EstimationResult buckets;\n-\n-        // Only output results for horizons which track the target\n-        if (conf_target > ::feeEstimator.HighestTargetTracked(horizon)) continue;\n-\n-        feeRate = ::feeEstimator.estimateRawFee(conf_target, threshold, horizon, &buckets);\n-        UniValue horizon_result(UniValue::VOBJ);\n-        UniValue errors(UniValue::VARR);\n-        UniValue passbucket(UniValue::VOBJ);\n-        passbucket.push_back(Pair(\"startrange\", round(buckets.pass.start)));\n-        passbucket.push_back(Pair(\"endrange\", round(buckets.pass.end)));\n-        passbucket.push_back(Pair(\"withintarget\", round(buckets.pass.withinTarget * 100.0) / 100.0));\n-        passbucket.push_back(Pair(\"totalconfirmed\", round(buckets.pass.totalConfirmed * 100.0) / 100.0));\n-        passbucket.push_back(Pair(\"inmempool\", round(buckets.pass.inMempool * 100.0) / 100.0));\n-        passbucket.push_back(Pair(\"leftmempool\", round(buckets.pass.leftMempool * 100.0) / 100.0));\n-        UniValue failbucket(UniValue::VOBJ);\n-        failbucket.push_back(Pair(\"startrange\", round(buckets.fail.start)));\n-        failbucket.push_back(Pair(\"endrange\", round(buckets.fail.end)));\n-        failbucket.push_back(Pair(\"withintarget\", round(buckets.fail.withinTarget * 100.0) / 100.0));\n-        failbucket.push_back(Pair(\"totalconfirmed\", round(buckets.fail.totalConfirmed * 100.0) / 100.0));\n-        failbucket.push_back(Pair(\"inmempool\", round(buckets.fail.inMempool * 100.0) / 100.0));\n-        failbucket.push_back(Pair(\"leftmempool\", round(buckets.fail.leftMempool * 100.0) / 100.0));\n-\n-        // CFeeRate(0) is used to indicate error as a return value from estimateRawFee\n-        if (feeRate != CFeeRate(0)) {\n-            horizon_result.push_back(Pair(\"feerate\", ValueFromAmount(feeRate.GetFeePerK())));\n-            horizon_result.push_back(Pair(\"decay\", buckets.decay));\n-            horizon_result.push_back(Pair(\"scale\", (int)buckets.scale));\n-            horizon_result.push_back(Pair(\"pass\", passbucket));\n-            // buckets.fail.start == -1 indicates that all buckets passed, there is no fail bucket to output\n-            if (buckets.fail.start != -1) horizon_result.push_back(Pair(\"fail\", failbucket));\n-        } else {\n-            // Output only information that is still meaningful in the event of error\n-            horizon_result.push_back(Pair(\"decay\", buckets.decay));\n-            horizon_result.push_back(Pair(\"scale\", (int)buckets.scale));\n-            horizon_result.push_back(Pair(\"fail\", failbucket));\n-            errors.push_back(\"Insufficient data or no feerate found which meets threshold\");\n-            horizon_result.push_back(Pair(\"errors\",errors));\n-        }\n-        result.push_back(Pair(StringForFeeEstimateHorizon(horizon), horizon_result));\n-    }\n-    return result;\n-}\n-\n-static const CRPCCommand commands[] =\n-{ //  category              name                      actor (function)         argNames\n-  //  --------------------- ------------------------  -----------------------  ----------\n-    { \"mining\",             \"getnetworkhashps\",       &getnetworkhashps,       {\"nblocks\",\"height\"} },\n-    { \"mining\",             \"getmininginfo\",          &getmininginfo,          {} },\n-    { \"mining\",             \"prioritisetransaction\",  &prioritisetransaction,  {\"txid\",\"dummy\",\"fee_delta\"} },\n-    { \"mining\",             \"getblocktemplate\",       &getblocktemplate,       {\"template_request\"} },\n-    { \"mining\",             \"submitblock\",            &submitblock,            {\"hexdata\",\"dummy\"} },\n-\n-\n-    { \"generating\",         \"generatetoaddress\",      &generatetoaddress,      {\"nblocks\",\"address\",\"maxtries\"} },\n-\n-    { \"util\",               \"estimatefee\",            &estimatefee,            {\"nblocks\"} },\n-    { \"util\",               \"estimatesmartfee\",       &estimatesmartfee,       {\"conf_target\", \"estimate_mode\"} },\n-\n-    { \"hidden\",             \"estimaterawfee\",         &estimaterawfee,         {\"conf_target\", \"threshold\"} },\n-};\n-\n-void RegisterMiningRPCCommands(CRPCTable &t)\n-{\n-    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)\n-        t.appendCommand(commands[vcidx].name, &commands[vcidx]);\n-}\n+// Copyright (c) 2010 Satoshi Nakamoto\r\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <base58.h>\r\n+#include <amount.h>\r\n+#include <chain.h>\r\n+#include <chainparams.h>\r\n+#include <consensus/consensus.h>\r\n+#include <consensus/params.h>\r\n+#include <consensus/validation.h>\r\n+#include <core_io.h>\r\n+#include <init.h>\r\n+#include <validation.h>\r\n+#include <miner.h>\r\n+#include <net.h>\r\n+#include <policy/fees.h>\r\n+#include <pow.h>\r\n+#include <rpc/blockchain.h>\r\n+#include <rpc/mining.h>\r\n+#include <rpc/server.h>\r\n+#include <txmempool.h>\r\n+#include <util.h>\r\n+#include <utilstrencodings.h>\r\n+#include <validationinterface.h>\r\n+#include <warnings.h>\r\n+\r\n+#include <memory>\r\n+#include <stdint.h>\r\n+\r\n+#include \"btv_const.h\"\r\n+\r\n+unsigned int ParseConfirmTarget(const UniValue& value)\r\n+{\r\n+    int target = value.get_int();\r\n+    unsigned int max_target = ::feeEstimator.HighestTargetTracked(FeeEstimateHorizon::LONG_HALFLIFE);\r\n+    if (target < 1 || (unsigned int)target > max_target) {\r\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Invalid conf_target, must be between %u - %u\", 1, max_target));\r\n+    }\r\n+    return (unsigned int)target;\r\n+}\r\n+\r\n+/**\r\n+ * Return average network hashes per second based on the last 'lookup' blocks,\r\n+ * or from the last difficulty change if 'lookup' is nonpositive.\r\n+ * If 'height' is nonnegative, compute the estimate at the time when a given block was found.\r\n+ */\r\n+UniValue GetNetworkHashPS(int lookup, int height) {\r\n+    CBlockIndex *pb = chainActive.Tip();\r\n+\r\n+    if (height >= 0 && height < chainActive.Height())\r\n+        pb = chainActive[height];\r\n+\r\n+    if (pb == nullptr || !pb->nHeight)\r\n+        return 0;\r\n+\r\n+    // If lookup is -1, then use blocks since last difficulty change.\r\n+    if (lookup <= 0)\r\n+        lookup = pb->nHeight % Params().GetConsensus().DifficultyAdjustmentInterval() + 1;\r\n+\r\n+    // If lookup is larger than chain, then set it to chain length.\r\n+    if (lookup > pb->nHeight)\r\n+        lookup = pb->nHeight;\r\n+\r\n+    CBlockIndex *pb0 = pb;\r\n+    int64_t minTime = pb0->GetBlockTime();\r\n+    int64_t maxTime = minTime;\r\n+    for (int i = 0; i < lookup; i++) {\r\n+        pb0 = pb0->pprev;\r\n+        int64_t time = pb0->GetBlockTime();\r\n+        minTime = std::min(time, minTime);\r\n+        maxTime = std::max(time, maxTime);\r\n+    }\r\n+\r\n+    // In case there's a situation where minTime == maxTime, we don't want a divide by zero exception.\r\n+    if (minTime == maxTime)\r\n+        return 0;\r\n+\r\n+    arith_uint256 workDiff = pb->nChainWork - pb0->nChainWork;\r\n+    int64_t timeDiff = maxTime - minTime;\r\n+\r\n+    return workDiff.getdouble() / timeDiff;\r\n+}\r\n+\r\n+UniValue getnetworkhashps(const JSONRPCRequest& request)\r\n+{\r\n+    if (request.fHelp || request.params.size() > 2)\r\n+        throw std::runtime_error(\r\n+            \"getnetworkhashps ( nblocks height )\\n\"\r\n+            \"\\nReturns the estimated network hashes per second based on the last n blocks.\\n\"\r\n+            \"Pass in [blocks] to override # of blocks, -1 specifies since last difficulty change.\\n\"\r\n+            \"Pass in [height] to estimate the network speed at the time when a certain block was found.\\n\"\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. nblocks     (numeric, optional, default=120) The number of blocks, or -1 for blocks since last difficulty change.\\n\"\r\n+            \"2. height      (numeric, optional, default=-1) To estimate at the time of the given height.\\n\"\r\n+            \"\\nResult:\\n\"\r\n+            \"x             (numeric) Hashes per second estimated\\n\"\r\n+            \"\\nExamples:\\n\"\r\n+            + HelpExampleCli(\"getnetworkhashps\", \"\")\r\n+            + HelpExampleRpc(\"getnetworkhashps\", \"\")\r\n+       );\r\n+\r\n+    LOCK(cs_main);\r\n+    return GetNetworkHashPS(!request.params[0].isNull() ? request.params[0].get_int() : 120, !request.params[1].isNull() ? request.params[1].get_int() : -1);\r\n+}\r\n+\r\n+UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGenerate, uint64_t nMaxTries, bool keepScript)\r\n+{\r\n+    static const int nInnerLoopCount = 0x10000;\r\n+    int nHeightEnd = 0;\r\n+    int nHeight = 0;\r\n+\r\n+    {   // Don't keep cs_main locked\r\n+        LOCK(cs_main);\r\n+        nHeight = chainActive.Height();\r\n+        nHeightEnd = nHeight+nGenerate;\r\n+    }\r\n+    unsigned int nExtraNonce = 0;\r\n+    UniValue blockHashes(UniValue::VARR);\r\n+    while (nHeight < nHeightEnd)\r\n+    {\r\n+        std::unique_ptr<CBlockTemplate> pblocktemplate(BlockAssembler(Params()).CreateNewBlock(coinbaseScript->reserveScript));\r\n+        if (!pblocktemplate.get())\r\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Couldn't create new block\");\r\n+        CBlock *pblock = &pblocktemplate->block;\r\n+        {\r\n+            LOCK(cs_main);\r\n+            IncrementExtraNonce(pblock, chainActive.Tip(), nExtraNonce);\r\n+        }\r\n+        while (nMaxTries > 0 && pblock->nNonce < nInnerLoopCount && !CheckProofOfWork(pblock->GetHash(), pblock->nBits, Params().GetConsensus(), pblock->IsBtvBranched())) {\r\n+            ++pblock->nNonce;\r\n+            --nMaxTries;\r\n+        }\r\n+        if (nMaxTries == 0) {\r\n+            break;\r\n+        }\r\n+        if (pblock->nNonce == nInnerLoopCount) {\r\n+            continue;\r\n+        }\r\n+        std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\r\n+        if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))\r\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\r\n+        ++nHeight;\r\n+        blockHashes.push_back(pblock->GetHash().GetHex());\r\n+\r\n+        //mark script as important because it was used at least for one coinbase output if the script came from the wallet\r\n+        if (keepScript)\r\n+        {\r\n+            coinbaseScript->KeepScript();\r\n+        }\r\n+    }\r\n+    return blockHashes;\r\n+}\r\n+\r\n+UniValue generatetoaddress(const JSONRPCRequest& request)\r\n+{\r\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\r\n+        throw std::runtime_error(\r\n+            \"generatetoaddress nblocks address (maxtries)\\n\"\r\n+            \"\\nMine blocks immediately to a specified address (before the RPC call returns)\\n\"\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. nblocks      (numeric, required) How many blocks are generated immediately.\\n\"\r\n+            \"2. address      (string, required) The address to send the newly generated bitcoin to.\\n\"\r\n+            \"3. maxtries     (numeric, optional) How many iterations to try (default = 1000000).\\n\"\r\n+            \"\\nResult:\\n\"\r\n+            \"[ blockhashes ]     (array) hashes of blocks generated\\n\"\r\n+            \"\\nExamples:\\n\"\r\n+            \"\\nGenerate 11 blocks to myaddress\\n\"\r\n+            + HelpExampleCli(\"generatetoaddress\", \"11 \\\"myaddress\\\"\")\r\n+        );\r\n+\r\n+    int nGenerate = request.params[0].get_int();\r\n+    uint64_t nMaxTries = 1000000;\r\n+    if (!request.params[2].isNull()) {\r\n+        nMaxTries = request.params[2].get_int();\r\n+    }\r\n+\r\n+    CTxDestination destination = DecodeDestination(request.params[1].get_str());\r\n+    if (!IsValidDestination(destination)) {\r\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Error: Invalid address\");\r\n+    }\r\n+\r\n+    std::shared_ptr<CReserveScript> coinbaseScript = std::make_shared<CReserveScript>();\r\n+    coinbaseScript->reserveScript = GetScriptForDestination(destination);\r\n+\r\n+    return generateBlocks(coinbaseScript, nGenerate, nMaxTries, false);\r\n+}\r\n+\r\n+UniValue getmininginfo(const JSONRPCRequest& request)\r\n+{\r\n+    if (request.fHelp || request.params.size() != 0)\r\n+        throw std::runtime_error(\r\n+            \"getmininginfo\\n\"\r\n+            \"\\nReturns a json object containing mining-related information.\"\r\n+            \"\\nResult:\\n\"\r\n+            \"{\\n\"\r\n+            \"  \\\"blocks\\\": nnn,             (numeric) The current block\\n\"\r\n+            \"  \\\"currentblockweight\\\": nnn, (numeric) The last block weight\\n\"\r\n+            \"  \\\"currentblocktx\\\": nnn,     (numeric) The last block transaction\\n\"\r\n+            \"  \\\"difficulty\\\": xxx.xxxxx    (numeric) The current difficulty\\n\"\r\n+            \"  \\\"networkhashps\\\": nnn,      (numeric) The network hashes per second\\n\"\r\n+            \"  \\\"pooledtx\\\": n              (numeric) The size of the mempool\\n\"\r\n+            \"  \\\"chain\\\": \\\"xxxx\\\",           (string) current network name as defined in BIP70 (main, test, regtest)\\n\"\r\n+            \"  \\\"warnings\\\": \\\"...\\\"          (string) any network and blockchain warnings\\n\"\r\n+            \"  \\\"errors\\\": \\\"...\\\"            (string) DEPRECATED. Same as warnings. Only shown when bitcoind is started with -deprecatedrpc=getmininginfo\\n\"\r\n+            \"}\\n\"\r\n+            \"\\nExamples:\\n\"\r\n+            + HelpExampleCli(\"getmininginfo\", \"\")\r\n+            + HelpExampleRpc(\"getmininginfo\", \"\")\r\n+        );\r\n+\r\n+\r\n+    LOCK(cs_main);\r\n+\r\n+    UniValue obj(UniValue::VOBJ);\r\n+    obj.push_back(Pair(\"blocks\",           (int)chainActive.Height()));\r\n+    obj.push_back(Pair(\"currentblockweight\", (uint64_t)nLastBlockWeight));\r\n+    obj.push_back(Pair(\"currentblocktx\",   (uint64_t)nLastBlockTx));\r\n+    obj.push_back(Pair(\"difficulty\",       (double)GetDifficulty()));\r\n+    obj.push_back(Pair(\"networkhashps\",    getnetworkhashps(request)));\r\n+    obj.push_back(Pair(\"pooledtx\",         (uint64_t)mempool.size()));\r\n+    obj.push_back(Pair(\"chain\",            Params().NetworkIDString()));\r\n+    if (IsDeprecatedRPCEnabled(\"getmininginfo\")) {\r\n+        obj.push_back(Pair(\"errors\",       GetWarnings(\"statusbar\")));\r\n+    } else {\r\n+        obj.push_back(Pair(\"warnings\",     GetWarnings(\"statusbar\")));\r\n+    }\r\n+    return obj;\r\n+}\r\n+\r\n+\r\n+// NOTE: Unlike wallet RPC (which use BTC values), mining RPCs follow GBT (BIP 22) in using satoshi amounts\r\n+UniValue prioritisetransaction(const JSONRPCRequest& request)\r\n+{\r\n+    if (request.fHelp || request.params.size() != 3)\r\n+        throw std::runtime_error(\r\n+            \"prioritisetransaction <txid> <dummy value> <fee delta>\\n\"\r\n+            \"Accepts the transaction into mined blocks at a higher (or lower) priority\\n\"\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. \\\"txid\\\"       (string, required) The transaction id.\\n\"\r\n+            \"2. dummy          (numeric, optional) API-Compatibility for previous API. Must be zero or null.\\n\"\r\n+            \"                  DEPRECATED. For forward compatibility use named arguments and omit this parameter.\\n\"\r\n+            \"3. fee_delta      (numeric, required) The fee value (in satoshis) to add (or subtract, if negative).\\n\"\r\n+            \"                  The fee is not actually paid, only the algorithm for selecting transactions into a block\\n\"\r\n+            \"                  considers the transaction as it would have paid a higher (or lower) fee.\\n\"\r\n+            \"\\nResult:\\n\"\r\n+            \"true              (boolean) Returns true\\n\"\r\n+            \"\\nExamples:\\n\"\r\n+            + HelpExampleCli(\"prioritisetransaction\", \"\\\"txid\\\" 0.0 10000\")\r\n+            + HelpExampleRpc(\"prioritisetransaction\", \"\\\"txid\\\", 0.0, 10000\")\r\n+        );\r\n+\r\n+    LOCK(cs_main);\r\n+\r\n+    uint256 hash = ParseHashStr(request.params[0].get_str(), \"txid\");\r\n+    CAmount nAmount = request.params[2].get_int64();\r\n+\r\n+    if (!(request.params[1].isNull() || request.params[1].get_real() == 0)) {\r\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Priority is no longer supported, dummy argument to prioritisetransaction must be 0.\");\r\n+    }\r\n+\r\n+    mempool.PrioritiseTransaction(hash, nAmount);\r\n+    return true;\r\n+}\r\n+\r\n+\r\n+// NOTE: Assumes a conclusive result; if result is inconclusive, it must be handled by caller\r\n+static UniValue BIP22ValidationResult(const CValidationState& state)\r\n+{\r\n+    if (state.IsValid())\r\n+        return NullUniValue;\r\n+\r\n+    std::string strRejectReason = state.GetRejectReason();\r\n+    if (state.IsError())\r\n+        throw JSONRPCError(RPC_VERIFY_ERROR, strRejectReason);\r\n+    if (state.IsInvalid())\r\n+    {\r\n+        if (strRejectReason.empty())\r\n+            return \"rejected\";\r\n+        return strRejectReason;\r\n+    }\r\n+    // Should be impossible\r\n+    return \"valid?\";\r\n+}\r\n+\r\n+std::string gbt_vb_name(const Consensus::DeploymentPos pos) {\r\n+    const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\r\n+    std::string s = vbinfo.name;\r\n+    if (!vbinfo.gbt_force) {\r\n+        s.insert(s.begin(), '!');\r\n+    }\r\n+    return s;\r\n+}\r\n+\r\n+UniValue getblocktemplate(const JSONRPCRequest& request)\r\n+{\r\n+    if (request.fHelp || request.params.size() > 1)\r\n+        throw std::runtime_error(\r\n+            \"getblocktemplate ( TemplateRequest )\\n\"\r\n+            \"\\nIf the request parameters include a 'mode' key, that is used to explicitly select between the default 'template' request or a 'proposal'.\\n\"\r\n+            \"It returns data needed to construct a block to work on.\\n\"\r\n+            \"For full specification, see BIPs 22, 23, 9, and 145:\\n\"\r\n+            \"    https://github.com/bitcoin/bips/blob/master/bip-0022.mediawiki\\n\"\r\n+            \"    https://github.com/bitcoin/bips/blob/master/bip-0023.mediawiki\\n\"\r\n+            \"    https://github.com/bitcoin/bips/blob/master/bip-0009.mediawiki#getblocktemplate_changes\\n\"\r\n+            \"    https://github.com/bitcoin/bips/blob/master/bip-0145.mediawiki\\n\"\r\n+\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. template_request         (json object, optional) A json object in the following spec\\n\"\r\n+            \"     {\\n\"\r\n+            \"       \\\"mode\\\":\\\"template\\\"    (string, optional) This must be set to \\\"template\\\", \\\"proposal\\\" (see BIP 23), or omitted\\n\"\r\n+            \"       \\\"capabilities\\\":[     (array, optional) A list of strings\\n\"\r\n+            \"           \\\"support\\\"          (string) client side supported feature, 'longpoll', 'coinbasetxn', 'coinbasevalue', 'proposal', 'serverlist', 'workid'\\n\"\r\n+            \"           ,...\\n\"\r\n+            \"       ],\\n\"\r\n+            \"       \\\"rules\\\":[            (array, optional) A list of strings\\n\"\r\n+            \"           \\\"support\\\"          (string) client side supported softfork deployment\\n\"\r\n+            \"           ,...\\n\"\r\n+            \"       ]\\n\"\r\n+            \"     }\\n\"\r\n+            \"\\n\"\r\n+\r\n+            \"\\nResult:\\n\"\r\n+            \"{\\n\"\r\n+            \"  \\\"version\\\" : n,                    (numeric) The preferred block version\\n\"\r\n+            \"  \\\"rules\\\" : [ \\\"rulename\\\", ... ],    (array of strings) specific block rules that are to be enforced\\n\"\r\n+            \"  \\\"vbavailable\\\" : {                 (json object) set of pending, supported versionbit (BIP 9) softfork deployments\\n\"\r\n+            \"      \\\"rulename\\\" : bitnumber          (numeric) identifies the bit number as indicating acceptance and readiness for the named softfork rule\\n\"\r\n+            \"      ,...\\n\"\r\n+            \"  },\\n\"\r\n+            \"  \\\"vbrequired\\\" : n,                 (numeric) bit mask of versionbits the server requires set in submissions\\n\"\r\n+            \"  \\\"previousblockhash\\\" : \\\"xxxx\\\",     (string) The hash of current highest block\\n\"\r\n+            \"  \\\"transactions\\\" : [                (array) contents of non-coinbase transactions that should be included in the next block\\n\"\r\n+            \"      {\\n\"\r\n+            \"         \\\"data\\\" : \\\"xxxx\\\",             (string) transaction data encoded in hexadecimal (byte-for-byte)\\n\"\r\n+            \"         \\\"txid\\\" : \\\"xxxx\\\",             (string) transaction id encoded in little-endian hexadecimal\\n\"\r\n+            \"         \\\"hash\\\" : \\\"xxxx\\\",             (string) hash encoded in little-endian hexadecimal (including witness data)\\n\"\r\n+            \"         \\\"depends\\\" : [                (array) array of numbers \\n\"\r\n+            \"             n                          (numeric) transactions before this one (by 1-based index in 'transactions' list) that must be present in the final block if this one is\\n\"\r\n+            \"             ,...\\n\"\r\n+            \"         ],\\n\"\r\n+            \"         \\\"fee\\\": n,                    (numeric) difference in value between transaction inputs and outputs (in satoshis); for coinbase transactions, this is a negative Number of the total collected block fees (ie, not including the block subsidy); if key is not present, fee is unknown and clients MUST NOT assume there isn't one\\n\"\r\n+            \"         \\\"sigops\\\" : n,                (numeric) total SigOps cost, as counted for purposes of block limits; if key is not present, sigop cost is unknown and clients MUST NOT assume it is zero\\n\"\r\n+            \"         \\\"weight\\\" : n,                (numeric) total transaction weight, as counted for purposes of block limits\\n\"\r\n+            \"         \\\"required\\\" : true|false      (boolean) if provided and true, this transaction must be in the final block\\n\"\r\n+            \"      }\\n\"\r\n+            \"      ,...\\n\"\r\n+            \"  ],\\n\"\r\n+            \"  \\\"coinbaseaux\\\" : {                 (json object) data that should be included in the coinbase's scriptSig content\\n\"\r\n+            \"      \\\"flags\\\" : \\\"xx\\\"                  (string) key name is to be ignored, and value included in scriptSig\\n\"\r\n+            \"  },\\n\"\r\n+            \"  \\\"coinbasevalue\\\" : n,              (numeric) maximum allowable input to coinbase transaction, including the generation award and transaction fees (in satoshis)\\n\"\r\n+            \"  \\\"coinbasetxn\\\" : { ... },          (json object) information for coinbase transaction\\n\"\r\n+            \"  \\\"target\\\" : \\\"xxxx\\\",                (string) The hash target\\n\"\r\n+            \"  \\\"mintime\\\" : xxx,                  (numeric) The minimum timestamp appropriate for next block time in seconds since epoch (Jan 1 1970 GMT)\\n\"\r\n+            \"  \\\"mutable\\\" : [                     (array of string) list of ways the block template may be changed \\n\"\r\n+            \"     \\\"value\\\"                          (string) A way the block template may be changed, e.g. 'time', 'transactions', 'prevblock'\\n\"\r\n+            \"     ,...\\n\"\r\n+            \"  ],\\n\"\r\n+            \"  \\\"noncerange\\\" : \\\"00000000ffffffff\\\",(string) A range of valid nonces\\n\"\r\n+            \"  \\\"sigoplimit\\\" : n,                 (numeric) limit of sigops in blocks\\n\"\r\n+            \"  \\\"sizelimit\\\" : n,                  (numeric) limit of block size\\n\"\r\n+            \"  \\\"weightlimit\\\" : n,                (numeric) limit of block weight\\n\"\r\n+            \"  \\\"curtime\\\" : ttt,                  (numeric) current timestamp in seconds since epoch (Jan 1 1970 GMT)\\n\"\r\n+            \"  \\\"bits\\\" : \\\"xxxxxxxx\\\",              (string) compressed target of next block\\n\"\r\n+            \"  \\\"height\\\" : n                      (numeric) The height of the next block\\n\"\r\n+            \"}\\n\"\r\n+\r\n+            \"\\nExamples:\\n\"\r\n+            + HelpExampleCli(\"getblocktemplate\", \"\")\r\n+            + HelpExampleRpc(\"getblocktemplate\", \"\")\r\n+         );\r\n+\r\n+    LOCK(cs_main);\r\n+\r\n+    std::string strMode = \"template\";\r\n+    UniValue lpval = NullUniValue;\r\n+    std::set<std::string> setClientRules;\r\n+    int64_t nMaxVersionPreVB = -1;\r\n+    if (!request.params[0].isNull())\r\n+    {\r\n+        const UniValue& oparam = request.params[0].get_obj();\r\n+        const UniValue& modeval = find_value(oparam, \"mode\");\r\n+        if (modeval.isStr())\r\n+            strMode = modeval.get_str();\r\n+        else if (modeval.isNull())\r\n+        {\r\n+            /* Do nothing */\r\n+        }\r\n+        else\r\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid mode\");\r\n+        lpval = find_value(oparam, \"longpollid\");\r\n+\r\n+        if (strMode == \"proposal\")\r\n+        {\r\n+            const UniValue& dataval = find_value(oparam, \"data\");\r\n+            if (!dataval.isStr())\r\n+                throw JSONRPCError(RPC_TYPE_ERROR, \"Missing data String key for proposal\");\r\n+\r\n+            CBlock block;\r\n+            if (!DecodeHexBlk(block, dataval.get_str()))\r\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block decode failed\");\r\n+\r\n+            uint256 hash = block.GetHash();\r\n+            BlockMap::iterator mi = mapBlockIndex.find(hash);\r\n+            if (mi != mapBlockIndex.end()) {\r\n+                CBlockIndex *pindex = mi->second;\r\n+                if (pindex->IsValid(BLOCK_VALID_SCRIPTS))\r\n+                    return \"duplicate\";\r\n+                if (pindex->nStatus & BLOCK_FAILED_MASK)\r\n+                    return \"duplicate-invalid\";\r\n+                return \"duplicate-inconclusive\";\r\n+            }\r\n+\r\n+            CBlockIndex* const pindexPrev = chainActive.Tip();\r\n+            // TestBlockValidity only supports blocks built on the current Tip\r\n+            if (block.hashPrevBlock != pindexPrev->GetBlockHash())\r\n+                return \"inconclusive-not-best-prevblk\";\r\n+            CValidationState state;\r\n+            TestBlockValidity(state, Params(), block, pindexPrev, false, true);\r\n+            return BIP22ValidationResult(state);\r\n+        }\r\n+\r\n+        const UniValue& aClientRules = find_value(oparam, \"rules\");\r\n+        if (aClientRules.isArray()) {\r\n+            for (unsigned int i = 0; i < aClientRules.size(); ++i) {\r\n+                const UniValue& v = aClientRules[i];\r\n+                setClientRules.insert(v.get_str());\r\n+            }\r\n+        } else {\r\n+            // NOTE: It is important that this NOT be read if versionbits is supported\r\n+            const UniValue& uvMaxVersion = find_value(oparam, \"maxversion\");\r\n+            if (uvMaxVersion.isNum()) {\r\n+                nMaxVersionPreVB = uvMaxVersion.get_int64();\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    if (strMode != \"template\")\r\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid mode\");\r\n+\r\n+    if(!g_connman)\r\n+        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\r\n+\r\n+    if (g_connman->GetNodeCount(CConnman::CONNECTIONS_ALL) == 0)\r\n+        throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, \"Bitcoin is not connected!\");\r\n+\r\n+    if (IsInitialBlockDownload())\r\n+        throw JSONRPCError(RPC_CLIENT_IN_INITIAL_DOWNLOAD, \"Bitcoin is downloading blocks...\");\r\n+\r\n+    static unsigned int nTransactionsUpdatedLast;\r\n+\r\n+    if (!lpval.isNull())\r\n+    {\r\n+        // Wait to respond until either the best block changes, OR a minute has passed and there are more transactions\r\n+        uint256 hashWatchedChain;\r\n+        std::chrono::steady_clock::time_point checktxtime;\r\n+        unsigned int nTransactionsUpdatedLastLP;\r\n+\r\n+        if (lpval.isStr())\r\n+        {\r\n+            // Format: <hashBestChain><nTransactionsUpdatedLast>\r\n+            std::string lpstr = lpval.get_str();\r\n+\r\n+            hashWatchedChain.SetHex(lpstr.substr(0, 64));\r\n+            nTransactionsUpdatedLastLP = atoi64(lpstr.substr(64));\r\n+        }\r\n+        else\r\n+        {\r\n+            // NOTE: Spec does not specify behaviour for non-string longpollid, but this makes testing easier\r\n+            hashWatchedChain = chainActive.Tip()->GetBlockHash();\r\n+            nTransactionsUpdatedLastLP = nTransactionsUpdatedLast;\r\n+        }\r\n+\r\n+        // Release the wallet and main lock while waiting\r\n+        LEAVE_CRITICAL_SECTION(cs_main);\r\n+        {\r\n+            checktxtime = std::chrono::steady_clock::now() + std::chrono::minutes(1);\r\n+\r\n+            WaitableLock lock(csBestBlock);\r\n+            while (chainActive.Tip()->GetBlockHash() == hashWatchedChain && IsRPCRunning())\r\n+            {\r\n+                if (cvBlockChange.wait_until(lock, checktxtime) == std::cv_status::timeout)\r\n+                {\r\n+                    // Timeout: Check transactions for update\r\n+                    if (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLastLP)\r\n+                        break;\r\n+                    checktxtime += std::chrono::seconds(10);\r\n+                }\r\n+            }\r\n+        }\r\n+        ENTER_CRITICAL_SECTION(cs_main);\r\n+\r\n+        if (!IsRPCRunning())\r\n+            throw JSONRPCError(RPC_CLIENT_NOT_CONNECTED, \"Shutting down\");\r\n+        // TODO: Maybe recheck connections/IBD and (if something wrong) send an expires-immediately template to stop miners?\r\n+    }\r\n+\r\n+    const struct VBDeploymentInfo& segwit_info = VersionBitsDeploymentInfo[Consensus::DEPLOYMENT_SEGWIT];\r\n+    // If the caller is indicating segwit support, then allow CreateNewBlock()\r\n+    // to select witness transactions, after segwit activates (otherwise\r\n+    // don't).\r\n+    bool fSupportsSegwit = setClientRules.find(segwit_info.name) != setClientRules.end();\r\n+\r\n+    // Update block\r\n+    static CBlockIndex* pindexPrev;\r\n+    static int64_t nStart;\r\n+    static std::unique_ptr<CBlockTemplate> pblocktemplate;\r\n+    // Cache whether the last invocation was with segwit support, to avoid returning\r\n+    // a segwit-block to a non-segwit caller.\r\n+    static bool fLastTemplateSupportsSegwit = true;\r\n+    if (pindexPrev != chainActive.Tip() ||\r\n+        (mempool.GetTransactionsUpdated() != nTransactionsUpdatedLast && GetTime() - nStart > 5) ||\r\n+        fLastTemplateSupportsSegwit != fSupportsSegwit)\r\n+    {\r\n+        // Clear pindexPrev so future calls make a new block, despite any failures from here on\r\n+        pindexPrev = nullptr;\r\n+\r\n+        // Store the pindexBest used before CreateNewBlock, to avoid races\r\n+        nTransactionsUpdatedLast = mempool.GetTransactionsUpdated();\r\n+        CBlockIndex* pindexPrevNew = chainActive.Tip();\r\n+        nStart = GetTime();\r\n+        fLastTemplateSupportsSegwit = fSupportsSegwit;\r\n+\r\n+        // Create new block\r\n+        CScript scriptDummy = CScript() << OP_TRUE;\r\n+        pblocktemplate = BlockAssembler(Params()).CreateNewBlock(scriptDummy, fSupportsSegwit);\r\n+        if (!pblocktemplate)\r\n+            throw JSONRPCError(RPC_OUT_OF_MEMORY, \"Out of memory\");\r\n+\r\n+        // Need to update only after we know CreateNewBlock succeeded\r\n+        pindexPrev = pindexPrevNew;\r\n+    }\r\n+    CBlock* pblock = &pblocktemplate->block; // pointer for convenience\r\n+    const Consensus::Params& consensusParams = Params().GetConsensus();\r\n+\r\n+    // Update nTime\r\n+    UpdateTime(pblock, consensusParams, pindexPrev);\r\n+    pblock->nNonce = 0;\r\n+\r\n+    // NOTE: If at some point we support pre-segwit miners post-segwit-activation, this needs to take segwit support into consideration\r\n+    const bool fPreSegWit = (THRESHOLD_ACTIVE != VersionBitsState(pindexPrev, consensusParams, Consensus::DEPLOYMENT_SEGWIT, versionbitscache));\r\n+\r\n+    UniValue aCaps(UniValue::VARR); aCaps.push_back(\"proposal\");\r\n+\r\n+    UniValue transactions(UniValue::VARR);\r\n+    std::map<uint256, int64_t> setTxIndex;\r\n+    int i = 0;\r\n+    for (const auto& it : pblock->vtx) {\r\n+        const CTransaction& tx = *it;\r\n+        uint256 txHash = tx.GetHash();\r\n+        setTxIndex[txHash] = i++;\r\n+\r\n+        if (tx.IsCoinBase())\r\n+            continue;\r\n+\r\n+        UniValue entry(UniValue::VOBJ);\r\n+\r\n+        entry.push_back(Pair(\"data\", EncodeHexTx(tx)));\r\n+        entry.push_back(Pair(\"txid\", txHash.GetHex()));\r\n+        entry.push_back(Pair(\"hash\", tx.GetWitnessHash().GetHex()));\r\n+\r\n+        UniValue deps(UniValue::VARR);\r\n+        for (const CTxIn &in : tx.vin)\r\n+        {\r\n+            if (setTxIndex.count(in.prevout.hash))\r\n+                deps.push_back(setTxIndex[in.prevout.hash]);\r\n+        }\r\n+        entry.push_back(Pair(\"depends\", deps));\r\n+\r\n+        int index_in_template = i - 1;\r\n+        entry.push_back(Pair(\"fee\", pblocktemplate->vTxFees[index_in_template]));\r\n+        int64_t nTxSigOps = pblocktemplate->vTxSigOpsCost[index_in_template];\r\n+        if (fPreSegWit) {\r\n+            assert(nTxSigOps % WITNESS_SCALE_FACTOR == 0);\r\n+            nTxSigOps /= WITNESS_SCALE_FACTOR;\r\n+        }\r\n+        entry.push_back(Pair(\"sigops\", nTxSigOps));\r\n+        entry.push_back(Pair(\"weight\", GetTransactionWeight(tx)));\r\n+\r\n+        transactions.push_back(entry);\r\n+    }\r\n+\r\n+    UniValue aux(UniValue::VOBJ);\r\n+    aux.push_back(Pair(\"flags\", HexStr(COINBASE_FLAGS.begin(), COINBASE_FLAGS.end())));\r\n+\r\n+    arith_uint256 hashTarget = arith_uint256().SetCompact(pblock->nBits);\r\n+\r\n+    UniValue aMutable(UniValue::VARR);\r\n+    aMutable.push_back(\"time\");\r\n+    aMutable.push_back(\"transactions\");\r\n+    aMutable.push_back(\"prevblock\");\r\n+\r\n+    UniValue result(UniValue::VOBJ);\r\n+    result.push_back(Pair(\"capabilities\", aCaps));\r\n+\r\n+    UniValue aRules(UniValue::VARR);\r\n+    UniValue vbavailable(UniValue::VOBJ);\r\n+    for (int j = 0; j < (int)Consensus::MAX_VERSION_BITS_DEPLOYMENTS; ++j) {\r\n+        Consensus::DeploymentPos pos = Consensus::DeploymentPos(j);\r\n+        ThresholdState state = VersionBitsState(pindexPrev, consensusParams, pos, versionbitscache);\r\n+        switch (state) {\r\n+            case THRESHOLD_DEFINED:\r\n+            case THRESHOLD_FAILED:\r\n+                // Not exposed to GBT at all\r\n+                break;\r\n+            case THRESHOLD_LOCKED_IN:\r\n+                // Ensure bit is set in block version\r\n+                pblock->nVersion |= VersionBitsMask(consensusParams, pos);\r\n+                // FALL THROUGH to get vbavailable set...\r\n+            case THRESHOLD_STARTED:\r\n+            {\r\n+                const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\r\n+                vbavailable.push_back(Pair(gbt_vb_name(pos), consensusParams.vDeployments[pos].bit));\r\n+                if (setClientRules.find(vbinfo.name) == setClientRules.end()) {\r\n+                    if (!vbinfo.gbt_force) {\r\n+                        // If the client doesn't support this, don't indicate it in the [default] version\r\n+                        pblock->nVersion &= ~VersionBitsMask(consensusParams, pos);\r\n+                    }\r\n+                }\r\n+                break;\r\n+            }\r\n+            case THRESHOLD_ACTIVE:\r\n+            {\r\n+                // Add to rules only\r\n+                const struct VBDeploymentInfo& vbinfo = VersionBitsDeploymentInfo[pos];\r\n+                aRules.push_back(gbt_vb_name(pos));\r\n+                if (setClientRules.find(vbinfo.name) == setClientRules.end()) {\r\n+                    // Not supported by the client; make sure it's safe to proceed\r\n+                    if (!vbinfo.gbt_force) {\r\n+                        // If we do anything other than throw an exception here, be sure version/force isn't sent to old clients\r\n+                        throw JSONRPCError(RPC_INVALID_PARAMETER, strprintf(\"Support for '%s' rule requires explicit client support\", vbinfo.name));\r\n+                    }\r\n+                }\r\n+                break;\r\n+            }\r\n+        }\r\n+    }\r\n+    result.push_back(Pair(\"version\", pblock->nVersion));\r\n+    result.push_back(Pair(\"rules\", aRules));\r\n+    result.push_back(Pair(\"vbavailable\", vbavailable));\r\n+    result.push_back(Pair(\"vbrequired\", int(0)));\r\n+\r\n+    if (nMaxVersionPreVB >= 2) {\r\n+        // If VB is supported by the client, nMaxVersionPreVB is -1, so we won't get here\r\n+        // Because BIP 34 changed how the generation transaction is serialized, we can only use version/force back to v2 blocks\r\n+        // This is safe to do [otherwise-]unconditionally only because we are throwing an exception above if a non-force deployment gets activated\r\n+        // Note that this can probably also be removed entirely after the first BIP9 non-force deployment (ie, probably segwit) gets activated\r\n+        aMutable.push_back(\"version/force\");\r\n+    }\r\n+\r\n+    result.push_back(Pair(\"previousblockhash\", pblock->hashPrevBlock.GetHex()));\r\n+    result.push_back(Pair(\"transactions\", transactions));\r\n+    result.push_back(Pair(\"coinbaseaux\", aux));\r\n+\r\n+    CAmount sum = 0;\r\n+    for (CTxOut out : pblock->vtx[0]->vout) sum += out.nValue;\r\n+\r\n+    result.push_back(Pair(\"coinbasevalue\", (int64_t)sum));\r\n+    result.push_back(Pair(\"fund_address\", BTV_FUND_ADDR));\r\n+    result.push_back(Pair(\"fund_coinbasevalue\", (int64_t)sum / BTV_FUND_RATIO));\r\n+    result.push_back(Pair(\"longpollid\", chainActive.Tip()->GetBlockHash().GetHex() + i64tostr(nTransactionsUpdatedLast)));\r\n+    result.push_back(Pair(\"target\", hashTarget.GetHex()));\r\n+    result.push_back(Pair(\"mintime\", (int64_t)pindexPrev->GetMedianTimePast()+1));\r\n+    result.push_back(Pair(\"mutable\", aMutable));\r\n+    result.push_back(Pair(\"noncerange\", \"00000000ffffffff\"));\r\n+    int64_t nSigOpLimit = MAX_BLOCK_SIGOPS_COST;\r\n+    int64_t nSizeLimit = MAX_BLOCK_SERIALIZED_SIZE;\r\n+    if (fPreSegWit) {\r\n+        assert(nSigOpLimit % WITNESS_SCALE_FACTOR == 0);\r\n+        nSigOpLimit /= WITNESS_SCALE_FACTOR;\r\n+        assert(nSizeLimit % WITNESS_SCALE_FACTOR == 0);\r\n+        nSizeLimit /= WITNESS_SCALE_FACTOR;\r\n+    }\r\n+    result.push_back(Pair(\"sigoplimit\", nSigOpLimit));\r\n+    result.push_back(Pair(\"sizelimit\", nSizeLimit));\r\n+    if (!fPreSegWit) {\r\n+        result.push_back(Pair(\"weightlimit\", (int64_t)MAX_BLOCK_WEIGHT));\r\n+    }\r\n+    result.push_back(Pair(\"curtime\", pblock->GetBlockTime()));\r\n+    result.push_back(Pair(\"bits\", strprintf(\"%08x\", pblock->nBits)));\r\n+    result.push_back(Pair(\"height\", (int64_t)(pindexPrev->nHeight+1)));\r\n+\r\n+    if (!pblocktemplate->vchCoinbaseCommitment.empty() && fSupportsSegwit) {\r\n+        result.push_back(Pair(\"default_witness_commitment\", HexStr(pblocktemplate->vchCoinbaseCommitment.begin(), pblocktemplate->vchCoinbaseCommitment.end())));\r\n+    }\r\n+\r\n+    return result;\r\n+}\r\n+\r\n+class submitblock_StateCatcher : public CValidationInterface\r\n+{\r\n+public:\r\n+    uint256 hash;\r\n+    bool found;\r\n+    CValidationState state;\r\n+\r\n+    explicit submitblock_StateCatcher(const uint256 &hashIn) : hash(hashIn), found(false), state() {}\r\n+\r\n+protected:\r\n+    void BlockChecked(const CBlock& block, const CValidationState& stateIn) override {\r\n+        if (block.GetHash() != hash)\r\n+            return;\r\n+        found = true;\r\n+        state = stateIn;\r\n+    }\r\n+};\r\n+\r\n+UniValue submitblock(const JSONRPCRequest& request)\r\n+{\r\n+    // We allow 2 arguments for compliance with BIP22. Argument 2 is ignored.\r\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\r\n+        throw std::runtime_error(\r\n+            \"submitblock \\\"hexdata\\\"  ( \\\"dummy\\\" )\\n\"\r\n+            \"\\nAttempts to submit new block to network.\\n\"\r\n+            \"See https://en.bitcoin.it/wiki/BIP_0022 for full specification.\\n\"\r\n+\r\n+            \"\\nArguments\\n\"\r\n+            \"1. \\\"hexdata\\\"        (string, required) the hex-encoded block data to submit\\n\"\r\n+            \"2. \\\"dummy\\\"          (optional) dummy value, for compatibility with BIP22. This value is ignored.\\n\"\r\n+            \"\\nResult:\\n\"\r\n+            \"\\nExamples:\\n\"\r\n+            + HelpExampleCli(\"submitblock\", \"\\\"mydata\\\"\")\r\n+            + HelpExampleRpc(\"submitblock\", \"\\\"mydata\\\"\")\r\n+        );\r\n+    }\r\n+\r\n+    std::shared_ptr<CBlock> blockptr = std::make_shared<CBlock>();\r\n+    CBlock& block = *blockptr;\r\n+    if (!DecodeHexBlk(block, request.params[0].get_str())) {\r\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block decode failed\");\r\n+    }\r\n+\r\n+    if (block.vtx.empty() || !block.vtx[0]->IsCoinBase()) {\r\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Block does not start with a coinbase\");\r\n+    }\r\n+\r\n+    uint256 hash = block.GetHash();\r\n+    bool fBlockPresent = false;\r\n+    {\r\n+        LOCK(cs_main);\r\n+        BlockMap::iterator mi = mapBlockIndex.find(hash);\r\n+        if (mi != mapBlockIndex.end()) {\r\n+            CBlockIndex *pindex = mi->second;\r\n+            if (pindex->IsValid(BLOCK_VALID_SCRIPTS)) {\r\n+                return \"duplicate\";\r\n+            }\r\n+            if (pindex->nStatus & BLOCK_FAILED_MASK) {\r\n+                return \"duplicate-invalid\";\r\n+            }\r\n+            // Otherwise, we might only have the header - process the block before returning\r\n+            fBlockPresent = true;\r\n+        }\r\n+    }\r\n+\r\n+    {\r\n+        LOCK(cs_main);\r\n+        BlockMap::iterator mi = mapBlockIndex.find(block.hashPrevBlock);\r\n+        if (mi != mapBlockIndex.end()) {\r\n+            UpdateUncommittedBlockStructures(block, mi->second, Params().GetConsensus());\r\n+        }\r\n+    }\r\n+\r\n+    submitblock_StateCatcher sc(block.GetHash());\r\n+    RegisterValidationInterface(&sc);\r\n+    bool fAccepted = ProcessNewBlock(Params(), blockptr, true, nullptr);\r\n+    UnregisterValidationInterface(&sc);\r\n+    if (fBlockPresent) {\r\n+        if (fAccepted && !sc.found) {\r\n+            return \"duplicate-inconclusive\";\r\n+        }\r\n+        return \"duplicate\";\r\n+    }\r\n+    if (!sc.found) {\r\n+        return \"inconclusive\";\r\n+    }\r\n+    return BIP22ValidationResult(sc.state);\r\n+}\r\n+\r\n+UniValue estimatefee(const JSONRPCRequest& request)\r\n+{\r\n+    if (request.fHelp || request.params.size() != 1)\r\n+        throw std::runtime_error(\r\n+            \"estimatefee nblocks\\n\"\r\n+            \"\\nDEPRECATED. Please use estimatesmartfee for more intelligent estimates.\"\r\n+            \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\r\n+            \"confirmation within nblocks blocks. Uses virtual transaction size of transaction\\n\"\r\n+            \"as defined in BIP 141 (witness data is discounted).\\n\"\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. nblocks     (numeric, required)\\n\"\r\n+            \"\\nResult:\\n\"\r\n+            \"n              (numeric) estimated fee-per-kilobyte\\n\"\r\n+            \"\\n\"\r\n+            \"A negative value is returned if not enough transactions and blocks\\n\"\r\n+            \"have been observed to make an estimate.\\n\"\r\n+            \"-1 is always returned for nblocks == 1 as it is impossible to calculate\\n\"\r\n+            \"a fee that is high enough to get reliably included in the next block.\\n\"\r\n+            \"\\nExample:\\n\"\r\n+            + HelpExampleCli(\"estimatefee\", \"6\")\r\n+            );\r\n+\r\n+    if (!IsDeprecatedRPCEnabled(\"estimatefee\")) {\r\n+        throw JSONRPCError(RPC_METHOD_DEPRECATED, \"estimatefee is deprecated and will be fully removed in v0.17. \"\r\n+            \"To use estimatefee in v0.16, restart bitcoind with -deprecatedrpc=estimatefee.\\n\"\r\n+            \"Projects should transition to using estimatesmartfee before upgrading to v0.17\");\r\n+    }\r\n+\r\n+    RPCTypeCheck(request.params, {UniValue::VNUM});\r\n+\r\n+    int nBlocks = request.params[0].get_int();\r\n+    if (nBlocks < 1)\r\n+        nBlocks = 1;\r\n+\r\n+    CFeeRate feeRate = ::feeEstimator.estimateFee(nBlocks);\r\n+    if (feeRate == CFeeRate(0))\r\n+        return -1.0;\r\n+\r\n+    return ValueFromAmount(feeRate.GetFeePerK());\r\n+}\r\n+\r\n+UniValue estimatesmartfee(const JSONRPCRequest& request)\r\n+{\r\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\r\n+        throw std::runtime_error(\r\n+            \"estimatesmartfee conf_target (\\\"estimate_mode\\\")\\n\"\r\n+            \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\r\n+            \"confirmation within conf_target blocks if possible and return the number of blocks\\n\"\r\n+            \"for which the estimate is valid. Uses virtual transaction size as defined\\n\"\r\n+            \"in BIP 141 (witness data is discounted).\\n\"\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. conf_target     (numeric) Confirmation target in blocks (1 - 1008)\\n\"\r\n+            \"2. \\\"estimate_mode\\\" (string, optional, default=CONSERVATIVE) The fee estimate mode.\\n\"\r\n+            \"                   Whether to return a more conservative estimate which also satisfies\\n\"\r\n+            \"                   a longer history. A conservative estimate potentially returns a\\n\"\r\n+            \"                   higher feerate and is more likely to be sufficient for the desired\\n\"\r\n+            \"                   target, but is not as responsive to short term drops in the\\n\"\r\n+            \"                   prevailing fee market.  Must be one of:\\n\"\r\n+            \"       \\\"UNSET\\\" (defaults to CONSERVATIVE)\\n\"\r\n+            \"       \\\"ECONOMICAL\\\"\\n\"\r\n+            \"       \\\"CONSERVATIVE\\\"\\n\"\r\n+            \"\\nResult:\\n\"\r\n+            \"{\\n\"\r\n+            \"  \\\"feerate\\\" : x.x,     (numeric, optional) estimate fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\r\n+            \"  \\\"errors\\\": [ str... ] (json array of strings, optional) Errors encountered during processing\\n\"\r\n+            \"  \\\"blocks\\\" : n         (numeric) block number where estimate was found\\n\"\r\n+            \"}\\n\"\r\n+            \"\\n\"\r\n+            \"The request target will be clamped between 2 and the highest target\\n\"\r\n+            \"fee estimation is able to return based on how long it has been running.\\n\"\r\n+            \"An error is returned if not enough transactions and blocks\\n\"\r\n+            \"have been observed to make an estimate for any number of blocks.\\n\"\r\n+            \"\\nExample:\\n\"\r\n+            + HelpExampleCli(\"estimatesmartfee\", \"6\")\r\n+            );\r\n+\r\n+    RPCTypeCheck(request.params, {UniValue::VNUM, UniValue::VSTR});\r\n+    RPCTypeCheckArgument(request.params[0], UniValue::VNUM);\r\n+    unsigned int conf_target = ParseConfirmTarget(request.params[0]);\r\n+    bool conservative = true;\r\n+    if (!request.params[1].isNull()) {\r\n+        FeeEstimateMode fee_mode;\r\n+        if (!FeeModeFromString(request.params[1].get_str(), fee_mode)) {\r\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid estimate_mode parameter\");\r\n+        }\r\n+        if (fee_mode == FeeEstimateMode::ECONOMICAL) conservative = false;\r\n+    }\r\n+\r\n+    UniValue result(UniValue::VOBJ);\r\n+    UniValue errors(UniValue::VARR);\r\n+    FeeCalculation feeCalc;\r\n+    CFeeRate feeRate = ::feeEstimator.estimateSmartFee(conf_target, &feeCalc, conservative);\r\n+    if (feeRate != CFeeRate(0)) {\r\n+        result.push_back(Pair(\"feerate\", ValueFromAmount(feeRate.GetFeePerK())));\r\n+    } else {\r\n+        errors.push_back(\"Insufficient data or no feerate found\");\r\n+        result.push_back(Pair(\"errors\", errors));\r\n+    }\r\n+    result.push_back(Pair(\"blocks\", feeCalc.returnedTarget));\r\n+    return result;\r\n+}\r\n+\r\n+UniValue estimaterawfee(const JSONRPCRequest& request)\r\n+{\r\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\r\n+        throw std::runtime_error(\r\n+            \"estimaterawfee conf_target (threshold)\\n\"\r\n+            \"\\nWARNING: This interface is unstable and may disappear or change!\\n\"\r\n+            \"\\nWARNING: This is an advanced API call that is tightly coupled to the specific\\n\"\r\n+            \"         implementation of fee estimation. The parameters it can be called with\\n\"\r\n+            \"         and the results it returns will change if the internal implementation changes.\\n\"\r\n+            \"\\nEstimates the approximate fee per kilobyte needed for a transaction to begin\\n\"\r\n+            \"confirmation within conf_target blocks if possible. Uses virtual transaction size as\\n\"\r\n+            \"defined in BIP 141 (witness data is discounted).\\n\"\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. conf_target (numeric) Confirmation target in blocks (1 - 1008)\\n\"\r\n+            \"2. threshold   (numeric, optional) The proportion of transactions in a given feerate range that must have been\\n\"\r\n+            \"               confirmed within conf_target in order to consider those feerates as high enough and proceed to check\\n\"\r\n+            \"               lower buckets.  Default: 0.95\\n\"\r\n+            \"\\nResult:\\n\"\r\n+            \"{\\n\"\r\n+            \"  \\\"short\\\" : {            (json object, optional) estimate for short time horizon\\n\"\r\n+            \"      \\\"feerate\\\" : x.x,        (numeric, optional) estimate fee rate in \" + CURRENCY_UNIT + \"/kB\\n\"\r\n+            \"      \\\"decay\\\" : x.x,          (numeric) exponential decay (per block) for historical moving average of confirmation data\\n\"\r\n+            \"      \\\"scale\\\" : x,            (numeric) The resolution of confirmation targets at this time horizon\\n\"\r\n+            \"      \\\"pass\\\" : {              (json object, optional) information about the lowest range of feerates to succeed in meeting the threshold\\n\"\r\n+            \"          \\\"startrange\\\" : x.x,     (numeric) start of feerate range\\n\"\r\n+            \"          \\\"endrange\\\" : x.x,       (numeric) end of feerate range\\n\"\r\n+            \"          \\\"withintarget\\\" : x.x,   (numeric) number of txs over history horizon in the feerate range that were confirmed within target\\n\"\r\n+            \"          \\\"totalconfirmed\\\" : x.x, (numeric) number of txs over history horizon in the feerate range that were confirmed at any point\\n\"\r\n+            \"          \\\"inmempool\\\" : x.x,      (numeric) current number of txs in mempool in the feerate range unconfirmed for at least target blocks\\n\"\r\n+            \"          \\\"leftmempool\\\" : x.x,    (numeric) number of txs over history horizon in the feerate range that left mempool unconfirmed after target\\n\"\r\n+            \"      },\\n\"\r\n+            \"      \\\"fail\\\" : { ... },       (json object, optional) information about the highest range of feerates to fail to meet the threshold\\n\"\r\n+            \"      \\\"errors\\\":  [ str... ]   (json array of strings, optional) Errors encountered during processing\\n\"\r\n+            \"  },\\n\"\r\n+            \"  \\\"medium\\\" : { ... },    (json object, optional) estimate for medium time horizon\\n\"\r\n+            \"  \\\"long\\\" : { ... }       (json object) estimate for long time horizon\\n\"\r\n+            \"}\\n\"\r\n+            \"\\n\"\r\n+            \"Results are returned for any horizon which tracks blocks up to the confirmation target.\\n\"\r\n+            \"\\nExample:\\n\"\r\n+            + HelpExampleCli(\"estimaterawfee\", \"6 0.9\")\r\n+            );\r\n+\r\n+    RPCTypeCheck(request.params, {UniValue::VNUM, UniValue::VNUM}, true);\r\n+    RPCTypeCheckArgument(request.params[0], UniValue::VNUM);\r\n+    unsigned int conf_target = ParseConfirmTarget(request.params[0]);\r\n+    double threshold = 0.95;\r\n+    if (!request.params[1].isNull()) {\r\n+        threshold = request.params[1].get_real();\r\n+    }\r\n+    if (threshold < 0 || threshold > 1) {\r\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid threshold\");\r\n+    }\r\n+\r\n+    UniValue result(UniValue::VOBJ);\r\n+\r\n+    for (FeeEstimateHorizon horizon : {FeeEstimateHorizon::SHORT_HALFLIFE, FeeEstimateHorizon::MED_HALFLIFE, FeeEstimateHorizon::LONG_HALFLIFE}) {\r\n+        CFeeRate feeRate;\r\n+        EstimationResult buckets;\r\n+\r\n+        // Only output results for horizons which track the target\r\n+        if (conf_target > ::feeEstimator.HighestTargetTracked(horizon)) continue;\r\n+\r\n+        feeRate = ::feeEstimator.estimateRawFee(conf_target, threshold, horizon, &buckets);\r\n+        UniValue horizon_result(UniValue::VOBJ);\r\n+        UniValue errors(UniValue::VARR);\r\n+        UniValue passbucket(UniValue::VOBJ);\r\n+        passbucket.push_back(Pair(\"startrange\", round(buckets.pass.start)));\r\n+        passbucket.push_back(Pair(\"endrange\", round(buckets.pass.end)));\r\n+        passbucket.push_back(Pair(\"withintarget\", round(buckets.pass.withinTarget * 100.0) / 100.0));\r\n+        passbucket.push_back(Pair(\"totalconfirmed\", round(buckets.pass.totalConfirmed * 100.0) / 100.0));\r\n+        passbucket.push_back(Pair(\"inmempool\", round(buckets.pass.inMempool * 100.0) / 100.0));\r\n+        passbucket.push_back(Pair(\"leftmempool\", round(buckets.pass.leftMempool * 100.0) / 100.0));\r\n+        UniValue failbucket(UniValue::VOBJ);\r\n+        failbucket.push_back(Pair(\"startrange\", round(buckets.fail.start)));\r\n+        failbucket.push_back(Pair(\"endrange\", round(buckets.fail.end)));\r\n+        failbucket.push_back(Pair(\"withintarget\", round(buckets.fail.withinTarget * 100.0) / 100.0));\r\n+        failbucket.push_back(Pair(\"totalconfirmed\", round(buckets.fail.totalConfirmed * 100.0) / 100.0));\r\n+        failbucket.push_back(Pair(\"inmempool\", round(buckets.fail.inMempool * 100.0) / 100.0));\r\n+        failbucket.push_back(Pair(\"leftmempool\", round(buckets.fail.leftMempool * 100.0) / 100.0));\r\n+\r\n+        // CFeeRate(0) is used to indicate error as a return value from estimateRawFee\r\n+        if (feeRate != CFeeRate(0)) {\r\n+            horizon_result.push_back(Pair(\"feerate\", ValueFromAmount(feeRate.GetFeePerK())));\r\n+            horizon_result.push_back(Pair(\"decay\", buckets.decay));\r\n+            horizon_result.push_back(Pair(\"scale\", (int)buckets.scale));\r\n+            horizon_result.push_back(Pair(\"pass\", passbucket));\r\n+            // buckets.fail.start == -1 indicates that all buckets passed, there is no fail bucket to output\r\n+            if (buckets.fail.start != -1) horizon_result.push_back(Pair(\"fail\", failbucket));\r\n+        } else {\r\n+            // Output only information that is still meaningful in the event of error\r\n+            horizon_result.push_back(Pair(\"decay\", buckets.decay));\r\n+            horizon_result.push_back(Pair(\"scale\", (int)buckets.scale));\r\n+            horizon_result.push_back(Pair(\"fail\", failbucket));\r\n+            errors.push_back(\"Insufficient data or no feerate found which meets threshold\");\r\n+            horizon_result.push_back(Pair(\"errors\",errors));\r\n+        }\r\n+        result.push_back(Pair(StringForFeeEstimateHorizon(horizon), horizon_result));\r\n+    }\r\n+    return result;\r\n+}\r\n+\r\n+static const CRPCCommand commands[] =\r\n+{ //  category              name                      actor (function)         argNames\r\n+  //  --------------------- ------------------------  -----------------------  ----------\r\n+    { \"mining\",             \"getnetworkhashps\",       &getnetworkhashps,       {\"nblocks\",\"height\"} },\r\n+    { \"mining\",             \"getmininginfo\",          &getmininginfo,          {} },\r\n+    { \"mining\",             \"prioritisetransaction\",  &prioritisetransaction,  {\"txid\",\"dummy\",\"fee_delta\"} },\r\n+    { \"mining\",             \"getblocktemplate\",       &getblocktemplate,       {\"template_request\"} },\r\n+    { \"mining\",             \"submitblock\",            &submitblock,            {\"hexdata\",\"dummy\"} },\r\n+\r\n+\r\n+    { \"generating\",         \"generatetoaddress\",      &generatetoaddress,      {\"nblocks\",\"address\",\"maxtries\"} },\r\n+\r\n+    { \"util\",               \"estimatefee\",            &estimatefee,            {\"nblocks\"} },\r\n+    { \"util\",               \"estimatesmartfee\",       &estimatesmartfee,       {\"conf_target\", \"estimate_mode\"} },\r\n+\r\n+    { \"hidden\",             \"estimaterawfee\",         &estimaterawfee,         {\"conf_target\", \"threshold\"} },\r\n+};\r\n+\r\n+void RegisterMiningRPCCommands(CRPCTable &t)\r\n+{\r\n+    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)\r\n+        t.appendCommand(commands[vcidx].name, &commands[vcidx]);\r\n+}\r"
      },
      {
        "sha": "fa4ab5f41d5b7ddc25137bca1de0a090e36b2efb",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 1039,
        "deletions": 1033,
        "changes": 2072,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "patch": "@@ -1,1033 +1,1039 @@\n-// Copyright (c) 2010 Satoshi Nakamoto\n-// Copyright (c) 2009-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <base58.h>\n-#include <chain.h>\n-#include <coins.h>\n-#include <consensus/validation.h>\n-#include <core_io.h>\n-#include <init.h>\n-#include <keystore.h>\n-#include <validation.h>\n-#include <validationinterface.h>\n-#include <merkleblock.h>\n-#include <net.h>\n-#include <policy/policy.h>\n-#include <policy/rbf.h>\n-#include <primitives/transaction.h>\n-#include <rpc/safemode.h>\n-#include <rpc/server.h>\n-#include <script/script.h>\n-#include <script/script_error.h>\n-#include <script/sign.h>\n-#include <script/standard.h>\n-#include <txmempool.h>\n-#include <uint256.h>\n-#include <utilstrencodings.h>\n-#ifdef ENABLE_WALLET\n-#include <wallet/rpcwallet.h>\n-#include <wallet/wallet.h>\n-#endif\n-\n-#include <future>\n-#include <stdint.h>\n-\n-#include <univalue.h>\n-\n-\n-void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\n-{\n-    // Call into TxToUniv() in bitcoin-common to decode the transaction hex.\n-    //\n-    // Blockchain contextual information (confirmations and blocktime) is not\n-    // available to code in bitcoin-common, so we query them here and push the\n-    // data into the returned UniValue.\n-    TxToUniv(tx, uint256(), entry, true, RPCSerializationFlags());\n-\n-    if (!hashBlock.IsNull()) {\n-        entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\n-        BlockMap::iterator mi = mapBlockIndex.find(hashBlock);\n-        if (mi != mapBlockIndex.end() && (*mi).second) {\n-            CBlockIndex* pindex = (*mi).second;\n-            if (chainActive.Contains(pindex)) {\n-                entry.push_back(Pair(\"confirmations\", 1 + chainActive.Height() - pindex->nHeight));\n-                entry.push_back(Pair(\"time\", pindex->GetBlockTime()));\n-                entry.push_back(Pair(\"blocktime\", pindex->GetBlockTime()));\n-            }\n-            else\n-                entry.push_back(Pair(\"confirmations\", 0));\n-        }\n-    }\n-}\n-\n-UniValue getrawtransaction(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n-        throw std::runtime_error(\n-            \"getrawtransaction \\\"txid\\\" ( verbose \\\"blockhash\\\" )\\n\"\n-\n-            \"\\nNOTE: By default this function only works for mempool transactions. If the -txindex option is\\n\"\n-            \"enabled, it also works for blockchain transactions. If the block which contains the transaction\\n\"\n-            \"is known, its hash can be provided even for nodes without -txindex. Note that if a blockhash is\\n\"\n-            \"provided, only that block will be searched and if the transaction is in the mempool or other\\n\"\n-            \"blocks, or if this node does not have the given block available, the transaction will not be found.\\n\"\n-            \"DEPRECATED: for now, it also works for transactions with unspent outputs.\\n\"\n-\n-            \"\\nReturn the raw transaction data.\\n\"\n-            \"\\nIf verbose is 'true', returns an Object with information about 'txid'.\\n\"\n-            \"If verbose is 'false' or omitted, returns a string that is serialized, hex-encoded data for 'txid'.\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txid\\\"      (string, required) The transaction id\\n\"\n-            \"2. verbose     (bool, optional, default=false) If false, return a string, otherwise return a json object\\n\"\n-            \"3. \\\"blockhash\\\" (string, optional) The block in which to look for the transaction\\n\"\n-\n-            \"\\nResult (if verbose is not set or set to false):\\n\"\n-            \"\\\"data\\\"      (string) The serialized, hex-encoded data for 'txid'\\n\"\n-\n-            \"\\nResult (if verbose is set to true):\\n\"\n-            \"{\\n\"\n-            \"  \\\"in_active_chain\\\": b, (bool) Whether specified block is in the active chain or not (only present with explicit \\\"blockhash\\\" argument)\\n\"\n-            \"  \\\"hex\\\" : \\\"data\\\",       (string) The serialized, hex-encoded data for 'txid'\\n\"\n-            \"  \\\"txid\\\" : \\\"id\\\",        (string) The transaction id (same as provided)\\n\"\n-            \"  \\\"hash\\\" : \\\"id\\\",        (string) The transaction hash (differs from txid for witness transactions)\\n\"\n-            \"  \\\"size\\\" : n,             (numeric) The serialized transaction size\\n\"\n-            \"  \\\"vsize\\\" : n,            (numeric) The virtual transaction size (differs from size for witness transactions)\\n\"\n-            \"  \\\"version\\\" : n,          (numeric) The version\\n\"\n-            \"  \\\"locktime\\\" : ttt,       (numeric) The lock time\\n\"\n-            \"  \\\"vin\\\" : [               (array of json objects)\\n\"\n-            \"     {\\n\"\n-            \"       \\\"txid\\\": \\\"id\\\",    (string) The transaction id\\n\"\n-            \"       \\\"vout\\\": n,         (numeric) \\n\"\n-            \"       \\\"scriptSig\\\": {     (json object) The script\\n\"\n-            \"         \\\"asm\\\": \\\"asm\\\",  (string) asm\\n\"\n-            \"         \\\"hex\\\": \\\"hex\\\"   (string) hex\\n\"\n-            \"       },\\n\"\n-            \"       \\\"sequence\\\": n      (numeric) The script sequence number\\n\"\n-            \"       \\\"txinwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n-            \"     }\\n\"\n-            \"     ,...\\n\"\n-            \"  ],\\n\"\n-            \"  \\\"vout\\\" : [              (array of json objects)\\n\"\n-            \"     {\\n\"\n-            \"       \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n-            \"       \\\"n\\\" : n,                    (numeric) index\\n\"\n-            \"       \\\"scriptPubKey\\\" : {          (json object)\\n\"\n-            \"         \\\"asm\\\" : \\\"asm\\\",          (string) the asm\\n\"\n-            \"         \\\"hex\\\" : \\\"hex\\\",          (string) the hex\\n\"\n-            \"         \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n-            \"         \\\"type\\\" : \\\"pubkeyhash\\\",  (string) The type, eg 'pubkeyhash'\\n\"\n-            \"         \\\"addresses\\\" : [           (json array of string)\\n\"\n-            \"           \\\"address\\\"        (string) bitcoin address\\n\"\n-            \"           ,...\\n\"\n-            \"         ]\\n\"\n-            \"       }\\n\"\n-            \"     }\\n\"\n-            \"     ,...\\n\"\n-            \"  ],\\n\"\n-            \"  \\\"blockhash\\\" : \\\"hash\\\",   (string) the block hash\\n\"\n-            \"  \\\"confirmations\\\" : n,      (numeric) The confirmations\\n\"\n-            \"  \\\"time\\\" : ttt,             (numeric) The transaction time in seconds since epoch (Jan 1 1970 GMT)\\n\"\n-            \"  \\\"blocktime\\\" : ttt         (numeric) The block time in seconds since epoch (Jan 1 1970 GMT)\\n\"\n-            \"}\\n\"\n-\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"getrawtransaction\", \"\\\"mytxid\\\"\")\n-            + HelpExampleCli(\"getrawtransaction\", \"\\\"mytxid\\\" true\")\n-            + HelpExampleRpc(\"getrawtransaction\", \"\\\"mytxid\\\", true\")\n-            + HelpExampleCli(\"getrawtransaction\", \"\\\"mytxid\\\" false \\\"myblockhash\\\"\")\n-            + HelpExampleCli(\"getrawtransaction\", \"\\\"mytxid\\\" true \\\"myblockhash\\\"\")\n-        );\n-\n-    LOCK(cs_main);\n-\n-    bool in_active_chain = true;\n-    uint256 hash = ParseHashV(request.params[0], \"parameter 1\");\n-    CBlockIndex* blockindex = nullptr;\n-\n-    // Accept either a bool (true) or a num (>=1) to indicate verbose output.\n-    bool fVerbose = false;\n-    if (!request.params[1].isNull()) {\n-        fVerbose = request.params[1].isNum() ? (request.params[1].get_int() != 0) : request.params[1].get_bool();\n-    }\n-\n-    if (!request.params[2].isNull()) {\n-        uint256 blockhash = ParseHashV(request.params[2], \"parameter 3\");\n-        BlockMap::iterator it = mapBlockIndex.find(blockhash);\n-        if (it == mapBlockIndex.end()) {\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block hash not found\");\n-        }\n-        blockindex = it->second;\n-        in_active_chain = chainActive.Contains(blockindex);\n-    }\n-\n-    CTransactionRef tx;\n-    uint256 hash_block;\n-    if (!GetTransaction(hash, tx, Params().GetConsensus(), hash_block, true, blockindex)) {\n-        std::string errmsg;\n-        if (blockindex) {\n-            if (!(blockindex->nStatus & BLOCK_HAVE_DATA)) {\n-                throw JSONRPCError(RPC_MISC_ERROR, \"Block not available\");\n-            }\n-            errmsg = \"No such transaction found in the provided block\";\n-        } else {\n-            errmsg = fTxIndex\n-              ? \"No such mempool or blockchain transaction\"\n-              : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\";\n-        }\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, errmsg + \". Use gettransaction for wallet transactions.\");\n-    }\n-\n-    if (!fVerbose) {\n-        return EncodeHexTx(*tx, RPCSerializationFlags());\n-    }\n-\n-    UniValue result(UniValue::VOBJ);\n-    if (blockindex) result.push_back(Pair(\"in_active_chain\", in_active_chain));\n-    TxToJSON(*tx, hash_block, result);\n-    return result;\n-}\n-\n-UniValue gettxoutproof(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || (request.params.size() != 1 && request.params.size() != 2))\n-        throw std::runtime_error(\n-            \"gettxoutproof [\\\"txid\\\",...] ( blockhash )\\n\"\n-            \"\\nReturns a hex-encoded proof that \\\"txid\\\" was included in a block.\\n\"\n-            \"\\nNOTE: By default this function only works sometimes. This is when there is an\\n\"\n-            \"unspent output in the utxo for this transaction. To make it always work,\\n\"\n-            \"you need to maintain a transaction index, using the -txindex command line option or\\n\"\n-            \"specify the block in which the transaction is included manually (by blockhash).\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txids\\\"       (string) A json array of txids to filter\\n\"\n-            \"    [\\n\"\n-            \"      \\\"txid\\\"     (string) A transaction hash\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-            \"2. \\\"blockhash\\\"   (string, optional) If specified, looks for txid in the block with this hash\\n\"\n-            \"\\nResult:\\n\"\n-            \"\\\"data\\\"           (string) A string that is a serialized, hex-encoded data for the proof.\\n\"\n-        );\n-\n-    std::set<uint256> setTxids;\n-    uint256 oneTxid;\n-    UniValue txids = request.params[0].get_array();\n-    for (unsigned int idx = 0; idx < txids.size(); idx++) {\n-        const UniValue& txid = txids[idx];\n-        if (txid.get_str().length() != 64 || !IsHex(txid.get_str()))\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid txid \")+txid.get_str());\n-        uint256 hash(uint256S(txid.get_str()));\n-        if (setTxids.count(hash))\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated txid: \")+txid.get_str());\n-       setTxids.insert(hash);\n-       oneTxid = hash;\n-    }\n-\n-    LOCK(cs_main);\n-\n-    CBlockIndex* pblockindex = nullptr;\n-\n-    uint256 hashBlock;\n-    if (!request.params[1].isNull())\n-    {\n-        hashBlock = uint256S(request.params[1].get_str());\n-        if (!mapBlockIndex.count(hashBlock))\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n-        pblockindex = mapBlockIndex[hashBlock];\n-    } else {\n-        // Loop through txids and try to find which block they're in. Exit loop once a block is found.\n-        for (const auto& tx : setTxids) {\n-            const Coin& coin = AccessByTxid(*pcoinsTip, tx);\n-            if (!coin.IsSpent()) {\n-                pblockindex = chainActive[coin.nHeight];\n-                break;\n-            }\n-        }\n-    }\n-\n-    if (pblockindex == nullptr)\n-    {\n-        CTransactionRef tx;\n-        if (!GetTransaction(oneTxid, tx, Params().GetConsensus(), hashBlock, false) || hashBlock.IsNull())\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction not yet in block\");\n-        if (!mapBlockIndex.count(hashBlock))\n-            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Transaction index corrupt\");\n-        pblockindex = mapBlockIndex[hashBlock];\n-    }\n-\n-    CBlock block;\n-    if(!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus()))\n-        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Can't read block from disk\");\n-\n-    unsigned int ntxFound = 0;\n-    for (const auto& tx : block.vtx)\n-        if (setTxids.count(tx->GetHash()))\n-            ntxFound++;\n-    if (ntxFound != setTxids.size())\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Not all transactions found in specified or retrieved block\");\n-\n-    CDataStream ssMB(SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\n-    CMerkleBlock mb(block, setTxids);\n-    ssMB << mb;\n-    std::string strHex = HexStr(ssMB.begin(), ssMB.end());\n-    return strHex;\n-}\n-\n-UniValue verifytxoutproof(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() != 1)\n-        throw std::runtime_error(\n-            \"verifytxoutproof \\\"proof\\\"\\n\"\n-            \"\\nVerifies that a proof points to a transaction in a block, returning the transaction it commits to\\n\"\n-            \"and throwing an RPC error if the block is not in our best chain\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"proof\\\"    (string, required) The hex-encoded proof generated by gettxoutproof\\n\"\n-            \"\\nResult:\\n\"\n-            \"[\\\"txid\\\"]      (array, strings) The txid(s) which the proof commits to, or empty array if the proof is invalid\\n\"\n-        );\n-\n-    CDataStream ssMB(ParseHexV(request.params[0], \"proof\"), SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\n-    CMerkleBlock merkleBlock;\n-    ssMB >> merkleBlock;\n-\n-    UniValue res(UniValue::VARR);\n-\n-    std::vector<uint256> vMatch;\n-    std::vector<unsigned int> vIndex;\n-    if (merkleBlock.txn.ExtractMatches(vMatch, vIndex) != merkleBlock.header.hashMerkleRoot)\n-        return res;\n-\n-    LOCK(cs_main);\n-\n-    if (!mapBlockIndex.count(merkleBlock.header.GetHash()) || !chainActive.Contains(mapBlockIndex[merkleBlock.header.GetHash()]))\n-        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\n-\n-    for (const uint256& hash : vMatch)\n-        res.push_back(hash.GetHex());\n-    return res;\n-}\n-\n-UniValue createrawtransaction(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\n-        throw std::runtime_error(\n-            \"createrawtransaction [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] {\\\"address\\\":amount,\\\"data\\\":\\\"hex\\\",...} ( locktime ) ( replaceable )\\n\"\n-            \"\\nCreate a transaction spending the given inputs and creating new outputs.\\n\"\n-            \"Outputs can be addresses or data.\\n\"\n-            \"Returns hex-encoded raw transaction.\\n\"\n-            \"Note that the transaction's inputs are not signed, and\\n\"\n-            \"it is not stored in the wallet or transmitted to the network.\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\n-            \"     [\\n\"\n-            \"       {\\n\"\n-            \"         \\\"txid\\\":\\\"id\\\",    (string, required) The transaction id\\n\"\n-            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\n-            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\n-            \"       } \\n\"\n-            \"       ,...\\n\"\n-            \"     ]\\n\"\n-            \"2. \\\"outputs\\\"               (object, required) a json object with outputs\\n\"\n-            \"    {\\n\"\n-            \"      \\\"address\\\": x.xxx,    (numeric or string, required) The key is the bitcoin address, the numeric value (can be string) is the \" + CURRENCY_UNIT + \" amount\\n\"\n-            \"      \\\"data\\\": \\\"hex\\\"      (string, required) The key is \\\"data\\\", the value is hex encoded data\\n\"\n-            \"      ,...\\n\"\n-            \"    }\\n\"\n-            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\n-            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\n-            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\n-            \"\\nResult:\\n\"\n-            \"\\\"transaction\\\"              (string) hex string of the transaction\\n\"\n-\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"address\\\\\\\":0.01}\\\"\")\n-            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}\\\"\")\n-            + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"{\\\\\\\"address\\\\\\\":0.01}\\\"\")\n-            + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}\\\"\")\n-        );\n-\n-    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VOBJ, UniValue::VNUM, UniValue::VBOOL}, true);\n-    if (request.params[0].isNull() || request.params[1].isNull())\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, arguments 1 and 2 must be non-null\");\n-\n-    UniValue inputs = request.params[0].get_array();\n-    UniValue sendTo = request.params[1].get_obj();\n-\n-    CMutableTransaction rawTx;\n-\n-    if (!request.params[2].isNull()) {\n-        int64_t nLockTime = request.params[2].get_int64();\n-        if (nLockTime < 0 || nLockTime > std::numeric_limits<uint32_t>::max())\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, locktime out of range\");\n-        rawTx.nLockTime = nLockTime;\n-    }\n-\n-    bool rbfOptIn = request.params[3].isTrue();\n-\n-    for (unsigned int idx = 0; idx < inputs.size(); idx++) {\n-        const UniValue& input = inputs[idx];\n-        const UniValue& o = input.get_obj();\n-\n-        uint256 txid = ParseHashO(o, \"txid\");\n-\n-        const UniValue& vout_v = find_value(o, \"vout\");\n-        if (!vout_v.isNum())\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, missing vout key\");\n-        int nOutput = vout_v.get_int();\n-        if (nOutput < 0)\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, vout must be positive\");\n-\n-        uint32_t nSequence;\n-        if (rbfOptIn) {\n-            nSequence = MAX_BIP125_RBF_SEQUENCE;\n-        } else if (rawTx.nLockTime) {\n-            nSequence = std::numeric_limits<uint32_t>::max() - 1;\n-        } else {\n-            nSequence = std::numeric_limits<uint32_t>::max();\n-        }\n-\n-        // set the sequence number if passed in the parameters object\n-        const UniValue& sequenceObj = find_value(o, \"sequence\");\n-        if (sequenceObj.isNum()) {\n-            int64_t seqNr64 = sequenceObj.get_int64();\n-            if (seqNr64 < 0 || seqNr64 > std::numeric_limits<uint32_t>::max()) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, sequence number is out of range\");\n-            } else {\n-                nSequence = (uint32_t)seqNr64;\n-            }\n-        }\n-\n-        CTxIn in(COutPoint(txid, nOutput), CScript(), nSequence);\n-\n-        rawTx.vin.push_back(in);\n-    }\n-\n-    std::set<CTxDestination> destinations;\n-    std::vector<std::string> addrList = sendTo.getKeys();\n-    for (const std::string& name_ : addrList) {\n-\n-        if (name_ == \"data\") {\n-            std::vector<unsigned char> data = ParseHexV(sendTo[name_].getValStr(),\"Data\");\n-\n-            CTxOut out(0, CScript() << OP_RETURN << data);\n-            rawTx.vout.push_back(out);\n-        } else {\n-            CTxDestination destination = DecodeDestination(name_);\n-            if (!IsValidDestination(destination)) {\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(\"Invalid Bitcoin address: \") + name_);\n-            }\n-\n-            if (!destinations.insert(destination).second) {\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated address: \") + name_);\n-            }\n-\n-            CScript scriptPubKey = GetScriptForDestination(destination);\n-            CAmount nAmount = AmountFromValue(sendTo[name_]);\n-\n-            CTxOut out(nAmount, scriptPubKey);\n-            rawTx.vout.push_back(out);\n-        }\n-    }\n-\n-    if (!request.params[3].isNull() && rbfOptIn != SignalsOptInRBF(rawTx)) {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter combination: Sequence number(s) contradict replaceable option\");\n-    }\n-\n-    return EncodeHexTx(rawTx);\n-}\n-\n-UniValue decoderawtransaction(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() != 1)\n-        throw std::runtime_error(\n-            \"decoderawtransaction \\\"hexstring\\\"\\n\"\n-            \"\\nReturn a JSON object representing the serialized, hex-encoded transaction.\\n\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\n-\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"txid\\\" : \\\"id\\\",        (string) The transaction id\\n\"\n-            \"  \\\"hash\\\" : \\\"id\\\",        (string) The transaction hash (differs from txid for witness transactions)\\n\"\n-            \"  \\\"size\\\" : n,             (numeric) The transaction size\\n\"\n-            \"  \\\"vsize\\\" : n,            (numeric) The virtual transaction size (differs from size for witness transactions)\\n\"\n-            \"  \\\"version\\\" : n,          (numeric) The version\\n\"\n-            \"  \\\"locktime\\\" : ttt,       (numeric) The lock time\\n\"\n-            \"  \\\"vin\\\" : [               (array of json objects)\\n\"\n-            \"     {\\n\"\n-            \"       \\\"txid\\\": \\\"id\\\",    (string) The transaction id\\n\"\n-            \"       \\\"vout\\\": n,         (numeric) The output number\\n\"\n-            \"       \\\"scriptSig\\\": {     (json object) The script\\n\"\n-            \"         \\\"asm\\\": \\\"asm\\\",  (string) asm\\n\"\n-            \"         \\\"hex\\\": \\\"hex\\\"   (string) hex\\n\"\n-            \"       },\\n\"\n-            \"       \\\"txinwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\n-            \"       \\\"sequence\\\": n     (numeric) The script sequence number\\n\"\n-            \"     }\\n\"\n-            \"     ,...\\n\"\n-            \"  ],\\n\"\n-            \"  \\\"vout\\\" : [             (array of json objects)\\n\"\n-            \"     {\\n\"\n-            \"       \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\n-            \"       \\\"n\\\" : n,                    (numeric) index\\n\"\n-            \"       \\\"scriptPubKey\\\" : {          (json object)\\n\"\n-            \"         \\\"asm\\\" : \\\"asm\\\",          (string) the asm\\n\"\n-            \"         \\\"hex\\\" : \\\"hex\\\",          (string) the hex\\n\"\n-            \"         \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\n-            \"         \\\"type\\\" : \\\"pubkeyhash\\\",  (string) The type, eg 'pubkeyhash'\\n\"\n-            \"         \\\"addresses\\\" : [           (json array of string)\\n\"\n-            \"           \\\"12tvKAXCxZjSmdNbao16dKXC8tRWfcF5oc\\\"   (string) bitcoin address\\n\"\n-            \"           ,...\\n\"\n-            \"         ]\\n\"\n-            \"       }\\n\"\n-            \"     }\\n\"\n-            \"     ,...\\n\"\n-            \"  ],\\n\"\n-            \"}\\n\"\n-\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"decoderawtransaction\", \"\\\"hexstring\\\"\")\n-            + HelpExampleRpc(\"decoderawtransaction\", \"\\\"hexstring\\\"\")\n-        );\n-\n-    LOCK(cs_main);\n-    RPCTypeCheck(request.params, {UniValue::VSTR});\n-\n-    CMutableTransaction mtx;\n-\n-    if (!DecodeHexTx(mtx, request.params[0].get_str(), true))\n-        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n-\n-    UniValue result(UniValue::VOBJ);\n-    TxToUniv(CTransaction(std::move(mtx)), uint256(), result, false);\n-\n-    return result;\n-}\n-\n-UniValue decodescript(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() != 1)\n-        throw std::runtime_error(\n-            \"decodescript \\\"hexstring\\\"\\n\"\n-            \"\\nDecode a hex-encoded script.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"hexstring\\\"     (string) the hex encoded script\\n\"\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"asm\\\":\\\"asm\\\",   (string) Script public key\\n\"\n-            \"  \\\"hex\\\":\\\"hex\\\",   (string) hex encoded public key\\n\"\n-            \"  \\\"type\\\":\\\"type\\\", (string) The output type\\n\"\n-            \"  \\\"reqSigs\\\": n,    (numeric) The required signatures\\n\"\n-            \"  \\\"addresses\\\": [   (json array of string)\\n\"\n-            \"     \\\"address\\\"     (string) bitcoin address\\n\"\n-            \"     ,...\\n\"\n-            \"  ],\\n\"\n-            \"  \\\"p2sh\\\",\\\"address\\\" (string) address of P2SH script wrapping this redeem script (not returned if the script is already a P2SH).\\n\"\n-            \"}\\n\"\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"decodescript\", \"\\\"hexstring\\\"\")\n-            + HelpExampleRpc(\"decodescript\", \"\\\"hexstring\\\"\")\n-        );\n-\n-    RPCTypeCheck(request.params, {UniValue::VSTR});\n-\n-    UniValue r(UniValue::VOBJ);\n-    CScript script;\n-    if (request.params[0].get_str().size() > 0){\n-        std::vector<unsigned char> scriptData(ParseHexV(request.params[0], \"argument\"));\n-        script = CScript(scriptData.begin(), scriptData.end());\n-    } else {\n-        // Empty scripts are valid\n-    }\n-    ScriptPubKeyToUniv(script, r, false);\n-\n-    UniValue type;\n-    type = find_value(r, \"type\");\n-\n-    if (type.isStr() && type.get_str() != \"scripthash\") {\n-        // P2SH cannot be wrapped in a P2SH. If this script is already a P2SH,\n-        // don't return the address for a P2SH of the P2SH.\n-        r.push_back(Pair(\"p2sh\", EncodeDestination(CScriptID(script))));\n-    }\n-\n-    return r;\n-}\n-\n-/** Pushes a JSON object for script verification or signing errors to vErrorsRet. */\n-static void TxInErrorToJSON(const CTxIn& txin, UniValue& vErrorsRet, const std::string& strMessage)\n-{\n-    UniValue entry(UniValue::VOBJ);\n-    entry.push_back(Pair(\"txid\", txin.prevout.hash.ToString()));\n-    entry.push_back(Pair(\"vout\", (uint64_t)txin.prevout.n));\n-    UniValue witness(UniValue::VARR);\n-    for (unsigned int i = 0; i < txin.scriptWitness.stack.size(); i++) {\n-        witness.push_back(HexStr(txin.scriptWitness.stack[i].begin(), txin.scriptWitness.stack[i].end()));\n-    }\n-    entry.push_back(Pair(\"witness\", witness));\n-    entry.push_back(Pair(\"scriptSig\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\n-    entry.push_back(Pair(\"sequence\", (uint64_t)txin.nSequence));\n-    entry.push_back(Pair(\"error\", strMessage));\n-    vErrorsRet.push_back(entry);\n-}\n-\n-UniValue combinerawtransaction(const JSONRPCRequest& request)\n-{\n-\n-    if (request.fHelp || request.params.size() != 1)\n-        throw std::runtime_error(\n-            \"combinerawtransaction [\\\"hexstring\\\",...]\\n\"\n-            \"\\nCombine multiple partially signed transactions into one transaction.\\n\"\n-            \"The combined transaction may be another partially signed transaction or a \\n\"\n-            \"fully signed transaction.\"\n-\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"txs\\\"         (string) A json array of hex strings of partially signed transactions\\n\"\n-            \"    [\\n\"\n-            \"      \\\"hexstring\\\"     (string) A transaction hash\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-\n-            \"\\nResult:\\n\"\n-            \"\\\"hex\\\"            (string) The hex-encoded raw transaction with signature(s)\\n\"\n-\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"combinerawtransaction\", \"[\\\"myhex1\\\", \\\"myhex2\\\", \\\"myhex3\\\"]\")\n-        );\n-\n-\n-    UniValue txs = request.params[0].get_array();\n-    std::vector<CMutableTransaction> txVariants(txs.size());\n-\n-    for (unsigned int idx = 0; idx < txs.size(); idx++) {\n-        if (!DecodeHexTx(txVariants[idx], txs[idx].get_str(), true)) {\n-            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed for tx %d\", idx));\n-        }\n-    }\n-\n-    if (txVariants.empty()) {\n-        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Missing transactions\");\n-    }\n-\n-    // mergedTx will end up with all the signatures; it\n-    // starts as a clone of the rawtx:\n-    CMutableTransaction mergedTx(txVariants[0]);\n-\n-    // Fetch previous transactions (inputs):\n-    CCoinsView viewDummy;\n-    CCoinsViewCache view(&viewDummy);\n-    {\n-        LOCK(cs_main);\n-        LOCK(mempool.cs);\n-        CCoinsViewCache &viewChain = *pcoinsTip;\n-        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n-        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n-\n-        for (const CTxIn& txin : mergedTx.vin) {\n-            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n-        }\n-\n-        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n-    }\n-\n-    // Use CTransaction for the constant parts of the\n-    // transaction to avoid rehashing.\n-    const CTransaction txConst(mergedTx);\n-    // Sign what we can:\n-    for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n-        CTxIn& txin = mergedTx.vin[i];\n-        const Coin& coin = view.AccessCoin(txin.prevout);\n-        if (coin.IsSpent()) {\n-            throw JSONRPCError(RPC_VERIFY_ERROR, \"Input not found or already spent\");\n-        }\n-        const CScript& prevPubKey = coin.out.scriptPubKey;\n-        const CAmount& amount = coin.out.nValue;\n-\n-        SignatureData sigdata;\n-\n-        // ... and merge in other signatures:\n-        for (const CMutableTransaction& txv : txVariants) {\n-            if (txv.vin.size() > i) {\n-                sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(txv, i));\n-            }\n-        }\n-\n-        UpdateTransaction(mergedTx, i, sigdata);\n-    }\n-\n-    return EncodeHexTx(mergedTx);\n-}\n-\n-UniValue signrawtransaction(const JSONRPCRequest& request)\n-{\n-#ifdef ENABLE_WALLET\n-    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\n-#endif\n-\n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n-        throw std::runtime_error(\n-            \"signrawtransaction \\\"hexstring\\\" ( [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n,\\\"scriptPubKey\\\":\\\"hex\\\",\\\"redeemScript\\\":\\\"hex\\\"},...] [\\\"privatekey1\\\",...] sighashtype )\\n\"\n-            \"\\nSign inputs for raw transaction (serialized, hex-encoded).\\n\"\n-            \"The second optional argument (may be null) is an array of previous transaction outputs that\\n\"\n-            \"this transaction depends on but may not yet be in the block chain.\\n\"\n-            \"The third optional argument (may be null) is an array of base58-encoded private\\n\"\n-            \"keys that, if given, will be the only keys used to sign the transaction.\\n\"\n-#ifdef ENABLE_WALLET\n-            + HelpRequiringPassphrase(pwallet) + \"\\n\"\n-#endif\n-\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"hexstring\\\"     (string, required) The transaction hex string\\n\"\n-            \"2. \\\"prevtxs\\\"       (string, optional) An json array of previous dependent transaction outputs\\n\"\n-            \"     [               (json array of json objects, or 'null' if none provided)\\n\"\n-            \"       {\\n\"\n-            \"         \\\"txid\\\":\\\"id\\\",             (string, required) The transaction id\\n\"\n-            \"         \\\"vout\\\":n,                  (numeric, required) The output number\\n\"\n-            \"         \\\"scriptPubKey\\\": \\\"hex\\\",   (string, required) script key\\n\"\n-            \"         \\\"redeemScript\\\": \\\"hex\\\",   (string, required for P2SH or P2WSH) redeem script\\n\"\n-            \"         \\\"amount\\\": value            (numeric, required) The amount spent\\n\"\n-            \"       }\\n\"\n-            \"       ,...\\n\"\n-            \"    ]\\n\"\n-            \"3. \\\"privkeys\\\"     (string, optional) A json array of base58-encoded private keys for signing\\n\"\n-            \"    [                  (json array of strings, or 'null' if none provided)\\n\"\n-            \"      \\\"privatekey\\\"   (string) private key in base58-encoding\\n\"\n-            \"      ,...\\n\"\n-            \"    ]\\n\"\n-            \"4. \\\"sighashtype\\\"     (string, optional, default=ALL) The signature hash type. Must be one of\\n\"\n-            \"       \\\"ALL\\\"\\n\"\n-            \"       \\\"NONE\\\"\\n\"\n-            \"       \\\"SINGLE\\\"\\n\"\n-            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\n-            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\n-            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\n-\n-            \"\\nResult:\\n\"\n-            \"{\\n\"\n-            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded raw transaction with signature(s)\\n\"\n-            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\n-            \"  \\\"errors\\\" : [                 (json array of objects) Script verification errors (if there are any)\\n\"\n-            \"    {\\n\"\n-            \"      \\\"txid\\\" : \\\"hash\\\",           (string) The hash of the referenced, previous transaction\\n\"\n-            \"      \\\"vout\\\" : n,                (numeric) The index of the output to spent and used as input\\n\"\n-            \"      \\\"scriptSig\\\" : \\\"hex\\\",       (string) The hex-encoded signature script\\n\"\n-            \"      \\\"sequence\\\" : n,            (numeric) Script sequence number\\n\"\n-            \"      \\\"error\\\" : \\\"text\\\"           (string) Verification or signing error related to the input\\n\"\n-            \"    }\\n\"\n-            \"    ,...\\n\"\n-            \"  ]\\n\"\n-            \"}\\n\"\n-\n-            \"\\nExamples:\\n\"\n-            + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\")\n-            + HelpExampleRpc(\"signrawtransaction\", \"\\\"myhex\\\"\")\n-        );\n-\n-    ObserveSafeMode();\n-#ifdef ENABLE_WALLET\n-    LOCK2(cs_main, pwallet ? &pwallet->cs_wallet : nullptr);\n-#else\n-    LOCK(cs_main);\n-#endif\n-    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR, UniValue::VARR, UniValue::VSTR}, true);\n-\n-    CMutableTransaction mtx;\n-    if (!DecodeHexTx(mtx, request.params[0].get_str(), true))\n-        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n-\n-    // Fetch previous transactions (inputs):\n-    CCoinsView viewDummy;\n-    CCoinsViewCache view(&viewDummy);\n-    {\n-        LOCK(mempool.cs);\n-        CCoinsViewCache &viewChain = *pcoinsTip;\n-        CCoinsViewMemPool viewMempool(&viewChain, mempool);\n-        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n-\n-        for (const CTxIn& txin : mtx.vin) {\n-            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n-        }\n-\n-        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n-    }\n-\n-    bool fGivenKeys = false;\n-    CBasicKeyStore tempKeystore;\n-    if (!request.params[2].isNull()) {\n-        fGivenKeys = true;\n-        UniValue keys = request.params[2].get_array();\n-        for (unsigned int idx = 0; idx < keys.size(); idx++) {\n-            UniValue k = keys[idx];\n-            CBitcoinSecret vchSecret;\n-            bool fGood = vchSecret.SetString(k.get_str());\n-            if (!fGood)\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\");\n-            CKey key = vchSecret.GetKey();\n-            if (!key.IsValid())\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\n-            tempKeystore.AddKey(key);\n-        }\n-    }\n-#ifdef ENABLE_WALLET\n-    else if (pwallet) {\n-        EnsureWalletIsUnlocked(pwallet);\n-    }\n-#endif\n-\n-    // Add previous txouts given in the RPC call:\n-    if (!request.params[1].isNull()) {\n-        UniValue prevTxs = request.params[1].get_array();\n-        for (unsigned int idx = 0; idx < prevTxs.size(); idx++) {\n-            const UniValue& p = prevTxs[idx];\n-            if (!p.isObject())\n-                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"expected object with {\\\"txid'\\\",\\\"vout\\\",\\\"scriptPubKey\\\"}\");\n-\n-            UniValue prevOut = p.get_obj();\n-\n-            RPCTypeCheckObj(prevOut,\n-                {\n-                    {\"txid\", UniValueType(UniValue::VSTR)},\n-                    {\"vout\", UniValueType(UniValue::VNUM)},\n-                    {\"scriptPubKey\", UniValueType(UniValue::VSTR)},\n-                });\n-\n-            uint256 txid = ParseHashO(prevOut, \"txid\");\n-\n-            int nOut = find_value(prevOut, \"vout\").get_int();\n-            if (nOut < 0)\n-                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"vout must be positive\");\n-\n-            COutPoint out(txid, nOut);\n-            std::vector<unsigned char> pkData(ParseHexO(prevOut, \"scriptPubKey\"));\n-            CScript scriptPubKey(pkData.begin(), pkData.end());\n-\n-            {\n-                const Coin& coin = view.AccessCoin(out);\n-                if (!coin.IsSpent() && coin.out.scriptPubKey != scriptPubKey) {\n-                    std::string err(\"Previous output scriptPubKey mismatch:\\n\");\n-                    err = err + ScriptToAsmStr(coin.out.scriptPubKey) + \"\\nvs:\\n\"+\n-                        ScriptToAsmStr(scriptPubKey);\n-                    throw JSONRPCError(RPC_DESERIALIZATION_ERROR, err);\n-                }\n-                Coin newcoin;\n-                newcoin.out.scriptPubKey = scriptPubKey;\n-                newcoin.out.nValue = 0;\n-                if (prevOut.exists(\"amount\")) {\n-                    newcoin.out.nValue = AmountFromValue(find_value(prevOut, \"amount\"));\n-                }\n-                newcoin.nHeight = 1;\n-                view.AddCoin(out, std::move(newcoin), true);\n-            }\n-\n-            // if redeemScript given and not using the local wallet (private keys\n-            // given), add redeemScript to the tempKeystore so it can be signed:\n-            if (fGivenKeys && (scriptPubKey.IsPayToScriptHash() || scriptPubKey.IsPayToWitnessScriptHash())) {\n-                RPCTypeCheckObj(prevOut,\n-                    {\n-                        {\"txid\", UniValueType(UniValue::VSTR)},\n-                        {\"vout\", UniValueType(UniValue::VNUM)},\n-                        {\"scriptPubKey\", UniValueType(UniValue::VSTR)},\n-                        {\"redeemScript\", UniValueType(UniValue::VSTR)},\n-                    });\n-                UniValue v = find_value(prevOut, \"redeemScript\");\n-                if (!v.isNull()) {\n-                    std::vector<unsigned char> rsData(ParseHexV(v, \"redeemScript\"));\n-                    CScript redeemScript(rsData.begin(), rsData.end());\n-                    tempKeystore.AddCScript(redeemScript);\n-                }\n-            }\n-        }\n-    }\n-\n-#ifdef ENABLE_WALLET\n-    const CKeyStore& keystore = ((fGivenKeys || !pwallet) ? tempKeystore : *pwallet);\n-#else\n-    const CKeyStore& keystore = tempKeystore;\n-#endif\n-\n-    int nHashType = SIGHASH_ALL;\n-    if (!request.params[3].isNull()) {\n-        static std::map<std::string, int> mapSigHashValues = {\n-            {std::string(\"ALL\"), int(SIGHASH_ALL)},\n-            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\n-            {std::string(\"NONE\"), int(SIGHASH_NONE)},\n-            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\n-            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\n-            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\n-        };\n-        std::string strHashType = request.params[3].get_str();\n-        if (mapSigHashValues.count(strHashType))\n-            nHashType = mapSigHashValues[strHashType];\n-        else\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid sighash param\");\n-    }\n-\n-    bool fHashSingle = ((nHashType & ~SIGHASH_ANYONECANPAY) == SIGHASH_SINGLE);\n-\n-    // Script verification errors\n-    UniValue vErrors(UniValue::VARR);\n-\n-    // Use CTransaction for the constant parts of the\n-    // transaction to avoid rehashing.\n-    const CTransaction txConst(mtx);\n-    // Sign what we can:\n-    for (unsigned int i = 0; i < mtx.vin.size(); i++) {\n-        CTxIn& txin = mtx.vin[i];\n-        const Coin& coin = view.AccessCoin(txin.prevout);\n-        if (coin.IsSpent()) {\n-            TxInErrorToJSON(txin, vErrors, \"Input not found or already spent\");\n-            continue;\n-        }\n-        const CScript& prevPubKey = coin.out.scriptPubKey;\n-        const CAmount& amount = coin.out.nValue;\n-\n-        SignatureData sigdata;\n-        // Only sign SIGHASH_SINGLE if there's a corresponding output:\n-        if (!fHashSingle || (i < mtx.vout.size()))\n-            ProduceSignature(MutableTransactionSignatureCreator(&keystore, &mtx, i, amount, nHashType), prevPubKey, sigdata);\n-        sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(mtx, i));\n-\n-        UpdateTransaction(mtx, i, sigdata);\n-\n-        ScriptError serror = SCRIPT_ERR_OK;\n-        if (!VerifyScript(txin.scriptSig, prevPubKey, &txin.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&txConst, i, amount), &serror)) {\n-            if (serror == SCRIPT_ERR_INVALID_STACK_OPERATION) {\n-                // Unable to sign input and verification failed (possible attempt to partially sign).\n-                TxInErrorToJSON(txin, vErrors, \"Unable to sign input, invalid stack size (possibly missing key)\");\n-            } else {\n-                TxInErrorToJSON(txin, vErrors, ScriptErrorString(serror));\n-            }\n-        }\n-    }\n-    bool fComplete = vErrors.empty();\n-\n-    UniValue result(UniValue::VOBJ);\n-    result.push_back(Pair(\"hex\", EncodeHexTx(mtx)));\n-    result.push_back(Pair(\"complete\", fComplete));\n-    if (!vErrors.empty()) {\n-        result.push_back(Pair(\"errors\", vErrors));\n-    }\n-\n-    return result;\n-}\n-\n-UniValue sendrawtransaction(const JSONRPCRequest& request)\n-{\n-    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw std::runtime_error(\n-            \"sendrawtransaction \\\"hexstring\\\" ( allowhighfees )\\n\"\n-            \"\\nSubmits raw transaction (serialized, hex-encoded) to local node and network.\\n\"\n-            \"\\nAlso see createrawtransaction and signrawtransaction calls.\\n\"\n-            \"\\nArguments:\\n\"\n-            \"1. \\\"hexstring\\\"    (string, required) The hex string of the raw transaction)\\n\"\n-            \"2. allowhighfees    (boolean, optional, default=false) Allow high fees\\n\"\n-            \"\\nResult:\\n\"\n-            \"\\\"hex\\\"             (string) The transaction hash in hex\\n\"\n-            \"\\nExamples:\\n\"\n-            \"\\nCreate a transaction\\n\"\n-            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\" : \\\\\\\"mytxid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\n-            \"Sign the transaction, and get back the hex\\n\"\n-            + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\") +\n-            \"\\nSend the transaction (signed hex)\\n\"\n-            + HelpExampleCli(\"sendrawtransaction\", \"\\\"signedhex\\\"\") +\n-            \"\\nAs a json rpc call\\n\"\n-            + HelpExampleRpc(\"sendrawtransaction\", \"\\\"signedhex\\\"\")\n-        );\n-\n-    ObserveSafeMode();\n-\n-    std::promise<void> promise;\n-\n-    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL});\n-\n-    // parse hex string from parameter\n-    CMutableTransaction mtx;\n-    if (!DecodeHexTx(mtx, request.params[0].get_str()))\n-        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n-    CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-    const uint256& hashTx = tx->GetHash();\n-\n-    CAmount nMaxRawTxFee = maxTxFee;\n-    if (!request.params[1].isNull() && request.params[1].get_bool())\n-        nMaxRawTxFee = 0;\n-\n-    { // cs_main scope\n-    LOCK(cs_main);\n-    CCoinsViewCache &view = *pcoinsTip;\n-    bool fHaveChain = false;\n-    for (size_t o = 0; !fHaveChain && o < tx->vout.size(); o++) {\n-        const Coin& existingCoin = view.AccessCoin(COutPoint(hashTx, o));\n-        fHaveChain = !existingCoin.IsSpent();\n-    }\n-    bool fHaveMempool = mempool.exists(hashTx);\n-    if (!fHaveMempool && !fHaveChain) {\n-        // push to local node and sync with wallets\n-        CValidationState state;\n-        bool fMissingInputs;\n-        if (!AcceptToMemoryPool(mempool, state, std::move(tx), &fMissingInputs,\n-                                nullptr /* plTxnReplaced */, false /* bypass_limits */, nMaxRawTxFee)) {\n-            if (state.IsInvalid()) {\n-                throw JSONRPCError(RPC_TRANSACTION_REJECTED, strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason()));\n-            } else {\n-                if (fMissingInputs) {\n-                    throw JSONRPCError(RPC_TRANSACTION_ERROR, \"Missing inputs\");\n-                }\n-                throw JSONRPCError(RPC_TRANSACTION_ERROR, state.GetRejectReason());\n-            }\n-        } else {\n-            // If wallet is enabled, ensure that the wallet has been made aware\n-            // of the new transaction prior to returning. This prevents a race\n-            // where a user might call sendrawtransaction with a transaction\n-            // to/from their wallet, immediately call some wallet RPC, and get\n-            // a stale result because callbacks have not yet been processed.\n-            CallFunctionInValidationInterfaceQueue([&promise] {\n-                promise.set_value();\n-            });\n-        }\n-    } else if (fHaveChain) {\n-        throw JSONRPCError(RPC_TRANSACTION_ALREADY_IN_CHAIN, \"transaction already in block chain\");\n-    } else {\n-        // Make sure we don't block forever if re-sending\n-        // a transaction already in mempool.\n-        promise.set_value();\n-    }\n-\n-    } // cs_main\n-\n-    promise.get_future().wait();\n-\n-    if(!g_connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n-\n-    CInv inv(MSG_TX, hashTx);\n-    g_connman->ForEachNode([&inv](CNode* pnode)\n-    {\n-        pnode->PushInventory(inv);\n-    });\n-\n-    return hashTx.GetHex();\n-}\n-\n-static const CRPCCommand commands[] =\n-{ //  category              name                      actor (function)         argNames\n-  //  --------------------- ------------------------  -----------------------  ----------\n-    { \"rawtransactions\",    \"getrawtransaction\",      &getrawtransaction,      {\"txid\",\"verbose\",\"blockhash\"} },\n-    { \"rawtransactions\",    \"createrawtransaction\",   &createrawtransaction,   {\"inputs\",\"outputs\",\"locktime\",\"replaceable\"} },\n-    { \"rawtransactions\",    \"decoderawtransaction\",   &decoderawtransaction,   {\"hexstring\"} },\n-    { \"rawtransactions\",    \"decodescript\",           &decodescript,           {\"hexstring\"} },\n-    { \"rawtransactions\",    \"sendrawtransaction\",     &sendrawtransaction,     {\"hexstring\",\"allowhighfees\"} },\n-    { \"rawtransactions\",    \"combinerawtransaction\",  &combinerawtransaction,  {\"txs\"} },\n-    { \"rawtransactions\",    \"signrawtransaction\",     &signrawtransaction,     {\"hexstring\",\"prevtxs\",\"privkeys\",\"sighashtype\"} }, /* uses wallet if enabled */\n-\n-    { \"blockchain\",         \"gettxoutproof\",          &gettxoutproof,          {\"txids\", \"blockhash\"} },\n-    { \"blockchain\",         \"verifytxoutproof\",       &verifytxoutproof,       {\"proof\"} },\n-};\n-\n-void RegisterRawTransactionRPCCommands(CRPCTable &t)\n-{\n-    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)\n-        t.appendCommand(commands[vcidx].name, &commands[vcidx]);\n-}\n+// Copyright (c) 2010 Satoshi Nakamoto\r\n+// Copyright (c) 2009-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <base58.h>\r\n+#include <chain.h>\r\n+#include <coins.h>\r\n+#include <consensus/validation.h>\r\n+#include <core_io.h>\r\n+#include <init.h>\r\n+#include <keystore.h>\r\n+#include <validation.h>\r\n+#include <validationinterface.h>\r\n+#include <merkleblock.h>\r\n+#include <net.h>\r\n+#include <policy/policy.h>\r\n+#include <policy/rbf.h>\r\n+#include <primitives/transaction.h>\r\n+#include <rpc/safemode.h>\r\n+#include <rpc/server.h>\r\n+#include <script/script.h>\r\n+#include <script/script_error.h>\r\n+#include <script/sign.h>\r\n+#include <script/standard.h>\r\n+#include <txmempool.h>\r\n+#include <uint256.h>\r\n+#include <utilstrencodings.h>\r\n+#ifdef ENABLE_WALLET\r\n+#include <wallet/rpcwallet.h>\r\n+#include <wallet/wallet.h>\r\n+#endif\r\n+\r\n+#include <future>\r\n+#include <stdint.h>\r\n+\r\n+#include <univalue.h>\r\n+\r\n+\r\n+void TxToJSON(const CTransaction& tx, const uint256 hashBlock, UniValue& entry)\r\n+{\r\n+    // Call into TxToUniv() in bitcoin-common to decode the transaction hex.\r\n+    //\r\n+    // Blockchain contextual information (confirmations and blocktime) is not\r\n+    // available to code in bitcoin-common, so we query them here and push the\r\n+    // data into the returned UniValue.\r\n+    TxToUniv(tx, uint256(), entry, true, RPCSerializationFlags());\r\n+\r\n+    if (!hashBlock.IsNull()) {\r\n+        entry.push_back(Pair(\"blockhash\", hashBlock.GetHex()));\r\n+        BlockMap::iterator mi = mapBlockIndex.find(hashBlock);\r\n+        if (mi != mapBlockIndex.end() && (*mi).second) {\r\n+            CBlockIndex* pindex = (*mi).second;\r\n+            if (chainActive.Contains(pindex)) {\r\n+                entry.push_back(Pair(\"confirmations\", 1 + chainActive.Height() - pindex->nHeight));\r\n+                entry.push_back(Pair(\"time\", pindex->GetBlockTime()));\r\n+                entry.push_back(Pair(\"blocktime\", pindex->GetBlockTime()));\r\n+            }\r\n+            else\r\n+                entry.push_back(Pair(\"confirmations\", 0));\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+UniValue getrawtransaction(const JSONRPCRequest& request)\r\n+{\r\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\r\n+        throw std::runtime_error(\r\n+            \"getrawtransaction \\\"txid\\\" ( verbose \\\"blockhash\\\" )\\n\"\r\n+\r\n+            \"\\nNOTE: By default this function only works for mempool transactions. If the -txindex option is\\n\"\r\n+            \"enabled, it also works for blockchain transactions. If the block which contains the transaction\\n\"\r\n+            \"is known, its hash can be provided even for nodes without -txindex. Note that if a blockhash is\\n\"\r\n+            \"provided, only that block will be searched and if the transaction is in the mempool or other\\n\"\r\n+            \"blocks, or if this node does not have the given block available, the transaction will not be found.\\n\"\r\n+            \"DEPRECATED: for now, it also works for transactions with unspent outputs.\\n\"\r\n+\r\n+            \"\\nReturn the raw transaction data.\\n\"\r\n+            \"\\nIf verbose is 'true', returns an Object with information about 'txid'.\\n\"\r\n+            \"If verbose is 'false' or omitted, returns a string that is serialized, hex-encoded data for 'txid'.\\n\"\r\n+\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. \\\"txid\\\"      (string, required) The transaction id\\n\"\r\n+            \"2. verbose     (bool, optional, default=false) If false, return a string, otherwise return a json object\\n\"\r\n+            \"3. \\\"blockhash\\\" (string, optional) The block in which to look for the transaction\\n\"\r\n+\r\n+            \"\\nResult (if verbose is not set or set to false):\\n\"\r\n+            \"\\\"data\\\"      (string) The serialized, hex-encoded data for 'txid'\\n\"\r\n+\r\n+            \"\\nResult (if verbose is set to true):\\n\"\r\n+            \"{\\n\"\r\n+            \"  \\\"in_active_chain\\\": b, (bool) Whether specified block is in the active chain or not (only present with explicit \\\"blockhash\\\" argument)\\n\"\r\n+            \"  \\\"hex\\\" : \\\"data\\\",       (string) The serialized, hex-encoded data for 'txid'\\n\"\r\n+            \"  \\\"txid\\\" : \\\"id\\\",        (string) The transaction id (same as provided)\\n\"\r\n+            \"  \\\"hash\\\" : \\\"id\\\",        (string) The transaction hash (differs from txid for witness transactions)\\n\"\r\n+            \"  \\\"size\\\" : n,             (numeric) The serialized transaction size\\n\"\r\n+            \"  \\\"vsize\\\" : n,            (numeric) The virtual transaction size (differs from size for witness transactions)\\n\"\r\n+            \"  \\\"version\\\" : n,          (numeric) The version\\n\"\r\n+            \"  \\\"locktime\\\" : ttt,       (numeric) The lock time\\n\"\r\n+            \"  \\\"vin\\\" : [               (array of json objects)\\n\"\r\n+            \"     {\\n\"\r\n+            \"       \\\"txid\\\": \\\"id\\\",    (string) The transaction id\\n\"\r\n+            \"       \\\"vout\\\": n,         (numeric) \\n\"\r\n+            \"       \\\"scriptSig\\\": {     (json object) The script\\n\"\r\n+            \"         \\\"asm\\\": \\\"asm\\\",  (string) asm\\n\"\r\n+            \"         \\\"hex\\\": \\\"hex\\\"   (string) hex\\n\"\r\n+            \"       },\\n\"\r\n+            \"       \\\"sequence\\\": n      (numeric) The script sequence number\\n\"\r\n+            \"       \\\"txinwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\r\n+            \"     }\\n\"\r\n+            \"     ,...\\n\"\r\n+            \"  ],\\n\"\r\n+            \"  \\\"vout\\\" : [              (array of json objects)\\n\"\r\n+            \"     {\\n\"\r\n+            \"       \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\r\n+            \"       \\\"n\\\" : n,                    (numeric) index\\n\"\r\n+            \"       \\\"scriptPubKey\\\" : {          (json object)\\n\"\r\n+            \"         \\\"asm\\\" : \\\"asm\\\",          (string) the asm\\n\"\r\n+            \"         \\\"hex\\\" : \\\"hex\\\",          (string) the hex\\n\"\r\n+            \"         \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\r\n+            \"         \\\"type\\\" : \\\"pubkeyhash\\\",  (string) The type, eg 'pubkeyhash'\\n\"\r\n+            \"         \\\"addresses\\\" : [           (json array of string)\\n\"\r\n+            \"           \\\"address\\\"        (string) bitcoin address\\n\"\r\n+            \"           ,...\\n\"\r\n+            \"         ]\\n\"\r\n+            \"       }\\n\"\r\n+            \"     }\\n\"\r\n+            \"     ,...\\n\"\r\n+            \"  ],\\n\"\r\n+            \"  \\\"blockhash\\\" : \\\"hash\\\",   (string) the block hash\\n\"\r\n+            \"  \\\"confirmations\\\" : n,      (numeric) The confirmations\\n\"\r\n+            \"  \\\"time\\\" : ttt,             (numeric) The transaction time in seconds since epoch (Jan 1 1970 GMT)\\n\"\r\n+            \"  \\\"blocktime\\\" : ttt         (numeric) The block time in seconds since epoch (Jan 1 1970 GMT)\\n\"\r\n+            \"}\\n\"\r\n+\r\n+            \"\\nExamples:\\n\"\r\n+            + HelpExampleCli(\"getrawtransaction\", \"\\\"mytxid\\\"\")\r\n+            + HelpExampleCli(\"getrawtransaction\", \"\\\"mytxid\\\" true\")\r\n+            + HelpExampleRpc(\"getrawtransaction\", \"\\\"mytxid\\\", true\")\r\n+            + HelpExampleCli(\"getrawtransaction\", \"\\\"mytxid\\\" false \\\"myblockhash\\\"\")\r\n+            + HelpExampleCli(\"getrawtransaction\", \"\\\"mytxid\\\" true \\\"myblockhash\\\"\")\r\n+        );\r\n+\r\n+    LOCK(cs_main);\r\n+\r\n+    bool in_active_chain = true;\r\n+    uint256 hash = ParseHashV(request.params[0], \"parameter 1\");\r\n+    CBlockIndex* blockindex = nullptr;\r\n+\r\n+    // Accept either a bool (true) or a num (>=1) to indicate verbose output.\r\n+    bool fVerbose = false;\r\n+    if (!request.params[1].isNull()) {\r\n+        fVerbose = request.params[1].isNum() ? (request.params[1].get_int() != 0) : request.params[1].get_bool();\r\n+    }\r\n+\r\n+    if (!request.params[2].isNull()) {\r\n+        uint256 blockhash = ParseHashV(request.params[2], \"parameter 3\");\r\n+        BlockMap::iterator it = mapBlockIndex.find(blockhash);\r\n+        if (it == mapBlockIndex.end()) {\r\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block hash not found\");\r\n+        }\r\n+        blockindex = it->second;\r\n+        in_active_chain = chainActive.Contains(blockindex);\r\n+    }\r\n+\r\n+    CTransactionRef tx;\r\n+    uint256 hash_block;\r\n+    if (!GetTransaction(hash, tx, Params().GetConsensus(), hash_block, true, blockindex)) {\r\n+        std::string errmsg;\r\n+        if (blockindex) {\r\n+            if (!(blockindex->nStatus & BLOCK_HAVE_DATA)) {\r\n+                throw JSONRPCError(RPC_MISC_ERROR, \"Block not available\");\r\n+            }\r\n+            errmsg = \"No such transaction found in the provided block\";\r\n+        } else {\r\n+            errmsg = fTxIndex\r\n+              ? \"No such mempool or blockchain transaction\"\r\n+              : \"No such mempool transaction. Use -txindex to enable blockchain transaction queries\";\r\n+        }\r\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, errmsg + \". Use gettransaction for wallet transactions.\");\r\n+    }\r\n+\r\n+    if (!fVerbose) {\r\n+        return EncodeHexTx(*tx, RPCSerializationFlags());\r\n+    }\r\n+\r\n+    UniValue result(UniValue::VOBJ);\r\n+    if (blockindex) result.push_back(Pair(\"in_active_chain\", in_active_chain));\r\n+    TxToJSON(*tx, hash_block, result);\r\n+    return result;\r\n+}\r\n+\r\n+UniValue gettxoutproof(const JSONRPCRequest& request)\r\n+{\r\n+    if (request.fHelp || (request.params.size() != 1 && request.params.size() != 2))\r\n+        throw std::runtime_error(\r\n+            \"gettxoutproof [\\\"txid\\\",...] ( blockhash )\\n\"\r\n+            \"\\nReturns a hex-encoded proof that \\\"txid\\\" was included in a block.\\n\"\r\n+            \"\\nNOTE: By default this function only works sometimes. This is when there is an\\n\"\r\n+            \"unspent output in the utxo for this transaction. To make it always work,\\n\"\r\n+            \"you need to maintain a transaction index, using the -txindex command line option or\\n\"\r\n+            \"specify the block in which the transaction is included manually (by blockhash).\\n\"\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. \\\"txids\\\"       (string) A json array of txids to filter\\n\"\r\n+            \"    [\\n\"\r\n+            \"      \\\"txid\\\"     (string) A transaction hash\\n\"\r\n+            \"      ,...\\n\"\r\n+            \"    ]\\n\"\r\n+            \"2. \\\"blockhash\\\"   (string, optional) If specified, looks for txid in the block with this hash\\n\"\r\n+            \"\\nResult:\\n\"\r\n+            \"\\\"data\\\"           (string) A string that is a serialized, hex-encoded data for the proof.\\n\"\r\n+        );\r\n+\r\n+    std::set<uint256> setTxids;\r\n+    uint256 oneTxid;\r\n+    UniValue txids = request.params[0].get_array();\r\n+    for (unsigned int idx = 0; idx < txids.size(); idx++) {\r\n+        const UniValue& txid = txids[idx];\r\n+        if (txid.get_str().length() != 64 || !IsHex(txid.get_str()))\r\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid txid \")+txid.get_str());\r\n+        uint256 hash(uint256S(txid.get_str()));\r\n+        if (setTxids.count(hash))\r\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated txid: \")+txid.get_str());\r\n+       setTxids.insert(hash);\r\n+       oneTxid = hash;\r\n+    }\r\n+\r\n+    LOCK(cs_main);\r\n+\r\n+    CBlockIndex* pblockindex = nullptr;\r\n+\r\n+    uint256 hashBlock;\r\n+    if (!request.params[1].isNull())\r\n+    {\r\n+        hashBlock = uint256S(request.params[1].get_str());\r\n+        if (!mapBlockIndex.count(hashBlock))\r\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\r\n+        pblockindex = mapBlockIndex[hashBlock];\r\n+    } else {\r\n+        // Loop through txids and try to find which block they're in. Exit loop once a block is found.\r\n+        for (const auto& tx : setTxids) {\r\n+            const Coin& coin = AccessByTxid(*pcoinsTip, tx);\r\n+            if (!coin.IsSpent()) {\r\n+                pblockindex = chainActive[coin.nHeight];\r\n+                break;\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+    if (pblockindex == nullptr)\r\n+    {\r\n+        CTransactionRef tx;\r\n+        if (!GetTransaction(oneTxid, tx, Params().GetConsensus(), hashBlock, false) || hashBlock.IsNull())\r\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction not yet in block\");\r\n+        if (!mapBlockIndex.count(hashBlock))\r\n+            throw JSONRPCError(RPC_INTERNAL_ERROR, \"Transaction index corrupt\");\r\n+        pblockindex = mapBlockIndex[hashBlock];\r\n+    }\r\n+\r\n+    CBlock block;\r\n+    if(!ReadBlockFromDisk(block, pblockindex, Params().GetConsensus()))\r\n+        throw JSONRPCError(RPC_INTERNAL_ERROR, \"Can't read block from disk\");\r\n+\r\n+    unsigned int ntxFound = 0;\r\n+    for (const auto& tx : block.vtx)\r\n+        if (setTxids.count(tx->GetHash()))\r\n+            ntxFound++;\r\n+    if (ntxFound != setTxids.size())\r\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Not all transactions found in specified or retrieved block\");\r\n+\r\n+    CDataStream ssMB(SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\r\n+    CMerkleBlock mb(block, setTxids);\r\n+    ssMB << mb;\r\n+    std::string strHex = HexStr(ssMB.begin(), ssMB.end());\r\n+    return strHex;\r\n+}\r\n+\r\n+UniValue verifytxoutproof(const JSONRPCRequest& request)\r\n+{\r\n+    if (request.fHelp || request.params.size() != 1)\r\n+        throw std::runtime_error(\r\n+            \"verifytxoutproof \\\"proof\\\"\\n\"\r\n+            \"\\nVerifies that a proof points to a transaction in a block, returning the transaction it commits to\\n\"\r\n+            \"and throwing an RPC error if the block is not in our best chain\\n\"\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. \\\"proof\\\"    (string, required) The hex-encoded proof generated by gettxoutproof\\n\"\r\n+            \"\\nResult:\\n\"\r\n+            \"[\\\"txid\\\"]      (array, strings) The txid(s) which the proof commits to, or empty array if the proof is invalid\\n\"\r\n+        );\r\n+\r\n+    CDataStream ssMB(ParseHexV(request.params[0], \"proof\"), SER_NETWORK, PROTOCOL_VERSION | SERIALIZE_TRANSACTION_NO_WITNESS);\r\n+    CMerkleBlock merkleBlock;\r\n+    ssMB >> merkleBlock;\r\n+\r\n+    UniValue res(UniValue::VARR);\r\n+\r\n+    std::vector<uint256> vMatch;\r\n+    std::vector<unsigned int> vIndex;\r\n+    if (merkleBlock.txn.ExtractMatches(vMatch, vIndex) != merkleBlock.header.hashMerkleRoot)\r\n+        return res;\r\n+\r\n+    LOCK(cs_main);\r\n+\r\n+    if (!mapBlockIndex.count(merkleBlock.header.GetHash()) || !chainActive.Contains(mapBlockIndex[merkleBlock.header.GetHash()]))\r\n+        throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\r\n+\r\n+    for (const uint256& hash : vMatch)\r\n+        res.push_back(hash.GetHex());\r\n+    return res;\r\n+}\r\n+\r\n+UniValue createrawtransaction(const JSONRPCRequest& request)\r\n+{\r\n+    if (request.fHelp || request.params.size() < 2 || request.params.size() > 4)\r\n+        throw std::runtime_error(\r\n+            \"createrawtransaction [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n},...] {\\\"address\\\":amount,\\\"data\\\":\\\"hex\\\",...} ( locktime ) ( replaceable )\\n\"\r\n+            \"\\nCreate a transaction spending the given inputs and creating new outputs.\\n\"\r\n+            \"Outputs can be addresses or data.\\n\"\r\n+            \"Returns hex-encoded raw transaction.\\n\"\r\n+            \"Note that the transaction's inputs are not signed, and\\n\"\r\n+            \"it is not stored in the wallet or transmitted to the network.\\n\"\r\n+\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. \\\"inputs\\\"                (array, required) A json array of json objects\\n\"\r\n+            \"     [\\n\"\r\n+            \"       {\\n\"\r\n+            \"         \\\"txid\\\":\\\"id\\\",    (string, required) The transaction id\\n\"\r\n+            \"         \\\"vout\\\":n,         (numeric, required) The output number\\n\"\r\n+            \"         \\\"sequence\\\":n      (numeric, optional) The sequence number\\n\"\r\n+            \"       } \\n\"\r\n+            \"       ,...\\n\"\r\n+            \"     ]\\n\"\r\n+            \"2. \\\"outputs\\\"               (object, required) a json object with outputs\\n\"\r\n+            \"    {\\n\"\r\n+            \"      \\\"address\\\": x.xxx,    (numeric or string, required) The key is the bitcoin address, the numeric value (can be string) is the \" + CURRENCY_UNIT + \" amount\\n\"\r\n+            \"      \\\"data\\\": \\\"hex\\\"      (string, required) The key is \\\"data\\\", the value is hex encoded data\\n\"\r\n+            \"      ,...\\n\"\r\n+            \"    }\\n\"\r\n+            \"3. locktime                  (numeric, optional, default=0) Raw locktime. Non-0 value also locktime-activates inputs\\n\"\r\n+            \"4. replaceable               (boolean, optional, default=false) Marks this transaction as BIP125 replaceable.\\n\"\r\n+            \"                             Allows this transaction to be replaced by a transaction with higher fees. If provided, it is an error if explicit sequence numbers are incompatible.\\n\"\r\n+            \"\\nResult:\\n\"\r\n+            \"\\\"transaction\\\"              (string) hex string of the transaction\\n\"\r\n+\r\n+            \"\\nExamples:\\n\"\r\n+            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"address\\\\\\\":0.01}\\\"\")\r\n+            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}\\\"\")\r\n+            + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"{\\\\\\\"address\\\\\\\":0.01}\\\"\")\r\n+            + HelpExampleRpc(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\":\\\\\\\"myid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\", \\\"{\\\\\\\"data\\\\\\\":\\\\\\\"00010203\\\\\\\"}\\\"\")\r\n+        );\r\n+\r\n+    RPCTypeCheck(request.params, {UniValue::VARR, UniValue::VOBJ, UniValue::VNUM, UniValue::VBOOL}, true);\r\n+    if (request.params[0].isNull() || request.params[1].isNull())\r\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, arguments 1 and 2 must be non-null\");\r\n+\r\n+    UniValue inputs = request.params[0].get_array();\r\n+    UniValue sendTo = request.params[1].get_obj();\r\n+\r\n+    CMutableTransaction rawTx;\r\n+\r\n+    if (!request.params[2].isNull()) {\r\n+        int64_t nLockTime = request.params[2].get_int64();\r\n+        if (nLockTime < 0 || nLockTime > std::numeric_limits<uint32_t>::max())\r\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, locktime out of range\");\r\n+        rawTx.nLockTime = nLockTime;\r\n+    }\r\n+\r\n+    bool rbfOptIn = request.params[3].isTrue();\r\n+\r\n+    for (unsigned int idx = 0; idx < inputs.size(); idx++) {\r\n+        const UniValue& input = inputs[idx];\r\n+        const UniValue& o = input.get_obj();\r\n+\r\n+        uint256 txid = ParseHashO(o, \"txid\");\r\n+\r\n+        const UniValue& vout_v = find_value(o, \"vout\");\r\n+        if (!vout_v.isNum())\r\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, missing vout key\");\r\n+        int nOutput = vout_v.get_int();\r\n+        if (nOutput < 0)\r\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, vout must be positive\");\r\n+\r\n+        uint32_t nSequence;\r\n+        if (rbfOptIn) {\r\n+            nSequence = MAX_BIP125_RBF_SEQUENCE;\r\n+        } else if (rawTx.nLockTime) {\r\n+            nSequence = std::numeric_limits<uint32_t>::max() - 1;\r\n+        } else {\r\n+            nSequence = std::numeric_limits<uint32_t>::max();\r\n+        }\r\n+\r\n+        // set the sequence number if passed in the parameters object\r\n+        const UniValue& sequenceObj = find_value(o, \"sequence\");\r\n+        if (sequenceObj.isNum()) {\r\n+            int64_t seqNr64 = sequenceObj.get_int64();\r\n+            if (seqNr64 < 0 || seqNr64 > std::numeric_limits<uint32_t>::max()) {\r\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, sequence number is out of range\");\r\n+            } else {\r\n+                nSequence = (uint32_t)seqNr64;\r\n+            }\r\n+        }\r\n+\r\n+        CTxIn in(COutPoint(txid, nOutput), CScript(), nSequence);\r\n+\r\n+        rawTx.vin.push_back(in);\r\n+    }\r\n+\r\n+    std::set<CTxDestination> destinations;\r\n+    std::vector<std::string> addrList = sendTo.getKeys();\r\n+    for (const std::string& name_ : addrList) {\r\n+\r\n+        if (name_ == \"data\") {\r\n+            std::vector<unsigned char> data = ParseHexV(sendTo[name_].getValStr(),\"Data\");\r\n+\r\n+            CTxOut out(0, CScript() << OP_RETURN << data);\r\n+            rawTx.vout.push_back(out);\r\n+        } else {\r\n+            CTxDestination destination = DecodeDestination(name_);\r\n+            if (!IsValidDestination(destination)) {\r\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(\"Invalid Bitcoin address: \") + name_);\r\n+            }\r\n+\r\n+            if (!destinations.insert(destination).second) {\r\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated address: \") + name_);\r\n+            }\r\n+\r\n+            CScript scriptPubKey = GetScriptForDestination(destination);\r\n+            CAmount nAmount = AmountFromValue(sendTo[name_]);\r\n+\r\n+            CTxOut out(nAmount, scriptPubKey);\r\n+            rawTx.vout.push_back(out);\r\n+        }\r\n+    }\r\n+\r\n+    if (!request.params[3].isNull() && rbfOptIn != SignalsOptInRBF(rawTx)) {\r\n+        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter combination: Sequence number(s) contradict replaceable option\");\r\n+    }\r\n+\r\n+    return EncodeHexTx(rawTx);\r\n+}\r\n+\r\n+UniValue decoderawtransaction(const JSONRPCRequest& request)\r\n+{\r\n+    if (request.fHelp || request.params.size() != 1)\r\n+        throw std::runtime_error(\r\n+            \"decoderawtransaction \\\"hexstring\\\"\\n\"\r\n+            \"\\nReturn a JSON object representing the serialized, hex-encoded transaction.\\n\"\r\n+\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. \\\"hexstring\\\"      (string, required) The transaction hex string\\n\"\r\n+\r\n+            \"\\nResult:\\n\"\r\n+            \"{\\n\"\r\n+            \"  \\\"txid\\\" : \\\"id\\\",        (string) The transaction id\\n\"\r\n+            \"  \\\"hash\\\" : \\\"id\\\",        (string) The transaction hash (differs from txid for witness transactions)\\n\"\r\n+            \"  \\\"size\\\" : n,             (numeric) The transaction size\\n\"\r\n+            \"  \\\"vsize\\\" : n,            (numeric) The virtual transaction size (differs from size for witness transactions)\\n\"\r\n+            \"  \\\"version\\\" : n,          (numeric) The version\\n\"\r\n+            \"  \\\"locktime\\\" : ttt,       (numeric) The lock time\\n\"\r\n+            \"  \\\"vin\\\" : [               (array of json objects)\\n\"\r\n+            \"     {\\n\"\r\n+            \"       \\\"txid\\\": \\\"id\\\",    (string) The transaction id\\n\"\r\n+            \"       \\\"vout\\\": n,         (numeric) The output number\\n\"\r\n+            \"       \\\"scriptSig\\\": {     (json object) The script\\n\"\r\n+            \"         \\\"asm\\\": \\\"asm\\\",  (string) asm\\n\"\r\n+            \"         \\\"hex\\\": \\\"hex\\\"   (string) hex\\n\"\r\n+            \"       },\\n\"\r\n+            \"       \\\"txinwitness\\\": [\\\"hex\\\", ...] (array of string) hex-encoded witness data (if any)\\n\"\r\n+            \"       \\\"sequence\\\": n     (numeric) The script sequence number\\n\"\r\n+            \"     }\\n\"\r\n+            \"     ,...\\n\"\r\n+            \"  ],\\n\"\r\n+            \"  \\\"vout\\\" : [             (array of json objects)\\n\"\r\n+            \"     {\\n\"\r\n+            \"       \\\"value\\\" : x.xxx,            (numeric) The value in \" + CURRENCY_UNIT + \"\\n\"\r\n+            \"       \\\"n\\\" : n,                    (numeric) index\\n\"\r\n+            \"       \\\"scriptPubKey\\\" : {          (json object)\\n\"\r\n+            \"         \\\"asm\\\" : \\\"asm\\\",          (string) the asm\\n\"\r\n+            \"         \\\"hex\\\" : \\\"hex\\\",          (string) the hex\\n\"\r\n+            \"         \\\"reqSigs\\\" : n,            (numeric) The required sigs\\n\"\r\n+            \"         \\\"type\\\" : \\\"pubkeyhash\\\",  (string) The type, eg 'pubkeyhash'\\n\"\r\n+            \"         \\\"addresses\\\" : [           (json array of string)\\n\"\r\n+            \"           \\\"12tvKAXCxZjSmdNbao16dKXC8tRWfcF5oc\\\"   (string) bitcoin address\\n\"\r\n+            \"           ,...\\n\"\r\n+            \"         ]\\n\"\r\n+            \"       }\\n\"\r\n+            \"     }\\n\"\r\n+            \"     ,...\\n\"\r\n+            \"  ],\\n\"\r\n+            \"}\\n\"\r\n+\r\n+            \"\\nExamples:\\n\"\r\n+            + HelpExampleCli(\"decoderawtransaction\", \"\\\"hexstring\\\"\")\r\n+            + HelpExampleRpc(\"decoderawtransaction\", \"\\\"hexstring\\\"\")\r\n+        );\r\n+\r\n+    LOCK(cs_main);\r\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\r\n+\r\n+    CMutableTransaction mtx;\r\n+\r\n+    if (!DecodeHexTx(mtx, request.params[0].get_str(), true))\r\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\r\n+\r\n+    UniValue result(UniValue::VOBJ);\r\n+    TxToUniv(CTransaction(std::move(mtx)), uint256(), result, false);\r\n+\r\n+    return result;\r\n+}\r\n+\r\n+UniValue decodescript(const JSONRPCRequest& request)\r\n+{\r\n+    if (request.fHelp || request.params.size() != 1)\r\n+        throw std::runtime_error(\r\n+            \"decodescript \\\"hexstring\\\"\\n\"\r\n+            \"\\nDecode a hex-encoded script.\\n\"\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. \\\"hexstring\\\"     (string) the hex encoded script\\n\"\r\n+            \"\\nResult:\\n\"\r\n+            \"{\\n\"\r\n+            \"  \\\"asm\\\":\\\"asm\\\",   (string) Script public key\\n\"\r\n+            \"  \\\"hex\\\":\\\"hex\\\",   (string) hex encoded public key\\n\"\r\n+            \"  \\\"type\\\":\\\"type\\\", (string) The output type\\n\"\r\n+            \"  \\\"reqSigs\\\": n,    (numeric) The required signatures\\n\"\r\n+            \"  \\\"addresses\\\": [   (json array of string)\\n\"\r\n+            \"     \\\"address\\\"     (string) bitcoin address\\n\"\r\n+            \"     ,...\\n\"\r\n+            \"  ],\\n\"\r\n+            \"  \\\"p2sh\\\",\\\"address\\\" (string) address of P2SH script wrapping this redeem script (not returned if the script is already a P2SH).\\n\"\r\n+            \"}\\n\"\r\n+            \"\\nExamples:\\n\"\r\n+            + HelpExampleCli(\"decodescript\", \"\\\"hexstring\\\"\")\r\n+            + HelpExampleRpc(\"decodescript\", \"\\\"hexstring\\\"\")\r\n+        );\r\n+\r\n+    RPCTypeCheck(request.params, {UniValue::VSTR});\r\n+\r\n+    UniValue r(UniValue::VOBJ);\r\n+    CScript script;\r\n+    if (request.params[0].get_str().size() > 0){\r\n+        std::vector<unsigned char> scriptData(ParseHexV(request.params[0], \"argument\"));\r\n+        script = CScript(scriptData.begin(), scriptData.end());\r\n+    } else {\r\n+        // Empty scripts are valid\r\n+    }\r\n+    ScriptPubKeyToUniv(script, r, false);\r\n+\r\n+    UniValue type;\r\n+    type = find_value(r, \"type\");\r\n+\r\n+    if (type.isStr() && type.get_str() != \"scripthash\") {\r\n+        // P2SH cannot be wrapped in a P2SH. If this script is already a P2SH,\r\n+        // don't return the address for a P2SH of the P2SH.\r\n+        r.push_back(Pair(\"p2sh\", EncodeDestination(CScriptID(script))));\r\n+    }\r\n+\r\n+    return r;\r\n+}\r\n+\r\n+/** Pushes a JSON object for script verification or signing errors to vErrorsRet. */\r\n+static void TxInErrorToJSON(const CTxIn& txin, UniValue& vErrorsRet, const std::string& strMessage)\r\n+{\r\n+    UniValue entry(UniValue::VOBJ);\r\n+    entry.push_back(Pair(\"txid\", txin.prevout.hash.ToString()));\r\n+    entry.push_back(Pair(\"vout\", (uint64_t)txin.prevout.n));\r\n+    UniValue witness(UniValue::VARR);\r\n+    for (unsigned int i = 0; i < txin.scriptWitness.stack.size(); i++) {\r\n+        witness.push_back(HexStr(txin.scriptWitness.stack[i].begin(), txin.scriptWitness.stack[i].end()));\r\n+    }\r\n+    entry.push_back(Pair(\"witness\", witness));\r\n+    entry.push_back(Pair(\"scriptSig\", HexStr(txin.scriptSig.begin(), txin.scriptSig.end())));\r\n+    entry.push_back(Pair(\"sequence\", (uint64_t)txin.nSequence));\r\n+    entry.push_back(Pair(\"error\", strMessage));\r\n+    vErrorsRet.push_back(entry);\r\n+}\r\n+\r\n+UniValue combinerawtransaction(const JSONRPCRequest& request)\r\n+{\r\n+\r\n+    if (request.fHelp || request.params.size() != 1)\r\n+        throw std::runtime_error(\r\n+            \"combinerawtransaction [\\\"hexstring\\\",...]\\n\"\r\n+            \"\\nCombine multiple partially signed transactions into one transaction.\\n\"\r\n+            \"The combined transaction may be another partially signed transaction or a \\n\"\r\n+            \"fully signed transaction.\"\r\n+\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. \\\"txs\\\"         (string) A json array of hex strings of partially signed transactions\\n\"\r\n+            \"    [\\n\"\r\n+            \"      \\\"hexstring\\\"     (string) A transaction hash\\n\"\r\n+            \"      ,...\\n\"\r\n+            \"    ]\\n\"\r\n+\r\n+            \"\\nResult:\\n\"\r\n+            \"\\\"hex\\\"            (string) The hex-encoded raw transaction with signature(s)\\n\"\r\n+\r\n+            \"\\nExamples:\\n\"\r\n+            + HelpExampleCli(\"combinerawtransaction\", \"[\\\"myhex1\\\", \\\"myhex2\\\", \\\"myhex3\\\"]\")\r\n+        );\r\n+\r\n+\r\n+    UniValue txs = request.params[0].get_array();\r\n+    std::vector<CMutableTransaction> txVariants(txs.size());\r\n+\r\n+    for (unsigned int idx = 0; idx < txs.size(); idx++) {\r\n+        if (!DecodeHexTx(txVariants[idx], txs[idx].get_str(), true)) {\r\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed for tx %d\", idx));\r\n+        }\r\n+    }\r\n+\r\n+    if (txVariants.empty()) {\r\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Missing transactions\");\r\n+    }\r\n+\r\n+    // mergedTx will end up with all the signatures; it\r\n+    // starts as a clone of the rawtx:\r\n+    CMutableTransaction mergedTx(txVariants[0]);\r\n+\r\n+    // Fetch previous transactions (inputs):\r\n+    CCoinsView viewDummy;\r\n+    CCoinsViewCache view(&viewDummy);\r\n+    {\r\n+        LOCK(cs_main);\r\n+        LOCK(mempool.cs);\r\n+        CCoinsViewCache &viewChain = *pcoinsTip;\r\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\r\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\r\n+\r\n+        for (const CTxIn& txin : mergedTx.vin) {\r\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\r\n+        }\r\n+\r\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\r\n+    }\r\n+\r\n+    // Use CTransaction for the constant parts of the\r\n+    // transaction to avoid rehashing.\r\n+    const CTransaction txConst(mergedTx);\r\n+    // Sign what we can:\r\n+    for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\r\n+        CTxIn& txin = mergedTx.vin[i];\r\n+        const Coin& coin = view.AccessCoin(txin.prevout);\r\n+        if (coin.IsSpent()) {\r\n+            throw JSONRPCError(RPC_VERIFY_ERROR, \"Input not found or already spent\");\r\n+        }\r\n+        const CScript& prevPubKey = coin.out.scriptPubKey;\r\n+        const CAmount& amount = coin.out.nValue;\r\n+\r\n+        SignatureData sigdata;\r\n+\r\n+        // ... and merge in other signatures:\r\n+        for (const CMutableTransaction& txv : txVariants) {\r\n+            if (txv.vin.size() > i) {\r\n+                sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(txv, i));\r\n+            }\r\n+        }\r\n+\r\n+        UpdateTransaction(mergedTx, i, sigdata);\r\n+    }\r\n+\r\n+    return EncodeHexTx(mergedTx);\r\n+}\r\n+\r\n+UniValue signrawtransaction(const JSONRPCRequest& request)\r\n+{\r\n+#ifdef ENABLE_WALLET\r\n+    CWallet * const pwallet = GetWalletForJSONRPCRequest(request);\r\n+#endif\r\n+\r\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\r\n+        throw std::runtime_error(\r\n+            \"signrawtransaction \\\"hexstring\\\" ( [{\\\"txid\\\":\\\"id\\\",\\\"vout\\\":n,\\\"scriptPubKey\\\":\\\"hex\\\",\\\"redeemScript\\\":\\\"hex\\\"},...] [\\\"privatekey1\\\",...] sighashtype )\\n\"\r\n+            \"\\nSign inputs for raw transaction (serialized, hex-encoded).\\n\"\r\n+            \"The second optional argument (may be null) is an array of previous transaction outputs that\\n\"\r\n+            \"this transaction depends on but may not yet be in the block chain.\\n\"\r\n+            \"The third optional argument (may be null) is an array of base58-encoded private\\n\"\r\n+            \"keys that, if given, will be the only keys used to sign the transaction.\\n\"\r\n+#ifdef ENABLE_WALLET\r\n+            + HelpRequiringPassphrase(pwallet) + \"\\n\"\r\n+#endif\r\n+\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. \\\"hexstring\\\"     (string, required) The transaction hex string\\n\"\r\n+            \"2. \\\"prevtxs\\\"       (string, optional) An json array of previous dependent transaction outputs\\n\"\r\n+            \"     [               (json array of json objects, or 'null' if none provided)\\n\"\r\n+            \"       {\\n\"\r\n+            \"         \\\"txid\\\":\\\"id\\\",             (string, required) The transaction id\\n\"\r\n+            \"         \\\"vout\\\":n,                  (numeric, required) The output number\\n\"\r\n+            \"         \\\"scriptPubKey\\\": \\\"hex\\\",   (string, required) script key\\n\"\r\n+            \"         \\\"redeemScript\\\": \\\"hex\\\",   (string, required for P2SH or P2WSH) redeem script\\n\"\r\n+            \"         \\\"amount\\\": value            (numeric, required) The amount spent\\n\"\r\n+            \"       }\\n\"\r\n+            \"       ,...\\n\"\r\n+            \"    ]\\n\"\r\n+            \"3. \\\"privkeys\\\"     (string, optional) A json array of base58-encoded private keys for signing\\n\"\r\n+            \"    [                  (json array of strings, or 'null' if none provided)\\n\"\r\n+            \"      \\\"privatekey\\\"   (string) private key in base58-encoding\\n\"\r\n+            \"      ,...\\n\"\r\n+            \"    ]\\n\"\r\n+            \"4. \\\"sighashtype\\\"     (string, optional, default=ALL) The signature hash type. Must be one of\\n\"\r\n+            \"       \\\"ALL\\\"\\n\"\r\n+            \"       \\\"NONE\\\"\\n\"\r\n+            \"       \\\"SINGLE\\\"\\n\"\r\n+            \"       \\\"ALL|ANYONECANPAY\\\"\\n\"\r\n+            \"       \\\"NONE|ANYONECANPAY\\\"\\n\"\r\n+            \"       \\\"SINGLE|ANYONECANPAY\\\"\\n\"\r\n+\r\n+            \"\\nResult:\\n\"\r\n+            \"{\\n\"\r\n+            \"  \\\"hex\\\" : \\\"value\\\",           (string) The hex-encoded raw transaction with signature(s)\\n\"\r\n+            \"  \\\"complete\\\" : true|false,   (boolean) If the transaction has a complete set of signatures\\n\"\r\n+            \"  \\\"errors\\\" : [                 (json array of objects) Script verification errors (if there are any)\\n\"\r\n+            \"    {\\n\"\r\n+            \"      \\\"txid\\\" : \\\"hash\\\",           (string) The hash of the referenced, previous transaction\\n\"\r\n+            \"      \\\"vout\\\" : n,                (numeric) The index of the output to spent and used as input\\n\"\r\n+            \"      \\\"scriptSig\\\" : \\\"hex\\\",       (string) The hex-encoded signature script\\n\"\r\n+            \"      \\\"sequence\\\" : n,            (numeric) Script sequence number\\n\"\r\n+            \"      \\\"error\\\" : \\\"text\\\"           (string) Verification or signing error related to the input\\n\"\r\n+            \"    }\\n\"\r\n+            \"    ,...\\n\"\r\n+            \"  ]\\n\"\r\n+            \"}\\n\"\r\n+\r\n+            \"\\nExamples:\\n\"\r\n+            + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\")\r\n+            + HelpExampleRpc(\"signrawtransaction\", \"\\\"myhex\\\"\")\r\n+        );\r\n+\r\n+    ObserveSafeMode();\r\n+#ifdef ENABLE_WALLET\r\n+    LOCK2(cs_main, pwallet ? &pwallet->cs_wallet : nullptr);\r\n+#else\r\n+    LOCK(cs_main);\r\n+#endif\r\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VARR, UniValue::VARR, UniValue::VSTR}, true);\r\n+\r\n+    CMutableTransaction mtx;\r\n+    if (!DecodeHexTx(mtx, request.params[0].get_str(), true))\r\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\r\n+\r\n+    // Fetch previous transactions (inputs):\r\n+    CCoinsView viewDummy;\r\n+    CCoinsViewCache view(&viewDummy);\r\n+    {\r\n+        LOCK(mempool.cs);\r\n+        CCoinsViewCache &viewChain = *pcoinsTip;\r\n+        CCoinsViewMemPool viewMempool(&viewChain, mempool);\r\n+        view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\r\n+\r\n+        for (const CTxIn& txin : mtx.vin) {\r\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\r\n+        }\r\n+\r\n+        view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\r\n+    }\r\n+\r\n+    bool fGivenKeys = false;\r\n+    CBasicKeyStore tempKeystore;\r\n+    if (!request.params[2].isNull()) {\r\n+        fGivenKeys = true;\r\n+        UniValue keys = request.params[2].get_array();\r\n+        for (unsigned int idx = 0; idx < keys.size(); idx++) {\r\n+            UniValue k = keys[idx];\r\n+            CBitcoinSecret vchSecret;\r\n+            bool fGood = vchSecret.SetString(k.get_str());\r\n+            if (!fGood)\r\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid private key\");\r\n+            CKey key = vchSecret.GetKey();\r\n+            if (!key.IsValid())\r\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Private key outside allowed range\");\r\n+            tempKeystore.AddKey(key);\r\n+        }\r\n+    }\r\n+#ifdef ENABLE_WALLET\r\n+    else if (pwallet) {\r\n+        EnsureWalletIsUnlocked(pwallet);\r\n+    }\r\n+#endif\r\n+\r\n+    // Add previous txouts given in the RPC call:\r\n+    if (!request.params[1].isNull()) {\r\n+        UniValue prevTxs = request.params[1].get_array();\r\n+        for (unsigned int idx = 0; idx < prevTxs.size(); idx++) {\r\n+            const UniValue& p = prevTxs[idx];\r\n+            if (!p.isObject())\r\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"expected object with {\\\"txid'\\\",\\\"vout\\\",\\\"scriptPubKey\\\"}\");\r\n+\r\n+            UniValue prevOut = p.get_obj();\r\n+\r\n+            RPCTypeCheckObj(prevOut,\r\n+                {\r\n+                    {\"txid\", UniValueType(UniValue::VSTR)},\r\n+                    {\"vout\", UniValueType(UniValue::VNUM)},\r\n+                    {\"scriptPubKey\", UniValueType(UniValue::VSTR)},\r\n+                });\r\n+\r\n+            uint256 txid = ParseHashO(prevOut, \"txid\");\r\n+\r\n+            int nOut = find_value(prevOut, \"vout\").get_int();\r\n+            if (nOut < 0)\r\n+                throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"vout must be positive\");\r\n+\r\n+            COutPoint out(txid, nOut);\r\n+            std::vector<unsigned char> pkData(ParseHexO(prevOut, \"scriptPubKey\"));\r\n+            CScript scriptPubKey(pkData.begin(), pkData.end());\r\n+\r\n+            {\r\n+                const Coin& coin = view.AccessCoin(out);\r\n+                if (!coin.IsSpent() && coin.out.scriptPubKey != scriptPubKey) {\r\n+                    std::string err(\"Previous output scriptPubKey mismatch:\\n\");\r\n+                    err = err + ScriptToAsmStr(coin.out.scriptPubKey) + \"\\nvs:\\n\"+\r\n+                        ScriptToAsmStr(scriptPubKey);\r\n+                    throw JSONRPCError(RPC_DESERIALIZATION_ERROR, err);\r\n+                }\r\n+                Coin newcoin;\r\n+                newcoin.out.scriptPubKey = scriptPubKey;\r\n+                newcoin.out.nValue = 0;\r\n+                if (prevOut.exists(\"amount\")) {\r\n+                    newcoin.out.nValue = AmountFromValue(find_value(prevOut, \"amount\"));\r\n+                }\r\n+                newcoin.nHeight = 1;\r\n+                view.AddCoin(out, std::move(newcoin), true);\r\n+            }\r\n+\r\n+            // if redeemScript given and not using the local wallet (private keys\r\n+            // given), add redeemScript to the tempKeystore so it can be signed:\r\n+            if (fGivenKeys && (scriptPubKey.IsPayToScriptHash() || scriptPubKey.IsPayToWitnessScriptHash())) {\r\n+                RPCTypeCheckObj(prevOut,\r\n+                    {\r\n+                        {\"txid\", UniValueType(UniValue::VSTR)},\r\n+                        {\"vout\", UniValueType(UniValue::VNUM)},\r\n+                        {\"scriptPubKey\", UniValueType(UniValue::VSTR)},\r\n+                        {\"redeemScript\", UniValueType(UniValue::VSTR)},\r\n+                    });\r\n+                UniValue v = find_value(prevOut, \"redeemScript\");\r\n+                if (!v.isNull()) {\r\n+                    std::vector<unsigned char> rsData(ParseHexV(v, \"redeemScript\"));\r\n+                    CScript redeemScript(rsData.begin(), rsData.end());\r\n+                    tempKeystore.AddCScript(redeemScript);\r\n+                }\r\n+            }\r\n+        }\r\n+    }\r\n+\r\n+#ifdef ENABLE_WALLET\r\n+    const CKeyStore& keystore = ((fGivenKeys || !pwallet) ? tempKeystore : *pwallet);\r\n+#else\r\n+    const CKeyStore& keystore = tempKeystore;\r\n+#endif\r\n+\r\n+    int nHashType = SIGHASH_ALL | SIGHASH_FORKID;\r\n+    if (!request.params[3].isNull()) {\r\n+        static std::map<std::string, int> mapSigHashValues = {\r\n+            {std::string(\"ALL\"), int(SIGHASH_ALL)},\r\n+            {std::string(\"ALL|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_ANYONECANPAY)},\r\n+            {std::string(\"NONE\"), int(SIGHASH_NONE)},\r\n+            {std::string(\"NONE|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_ANYONECANPAY)},\r\n+            {std::string(\"SINGLE\"), int(SIGHASH_SINGLE)},\r\n+            {std::string(\"SINGLE|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_ANYONECANPAY)},\r\n+            {std::string(\"ALL|FORKID\"), int(SIGHASH_ALL|SIGHASH_FORKID)},\r\n+            {std::string(\"NONE|FORKID\"), int(SIGHASH_NONE|SIGHASH_FORKID)},\r\n+            {std::string(\"SINGLE|FORKID\"), int(SIGHASH_SINGLE|SIGHASH_FORKID)},\r\n+            {std::string(\"ALL|FORKID|ANYONECANPAY\"), int(SIGHASH_ALL|SIGHASH_FORKID|SIGHASH_ANYONECANPAY)},\r\n+            {std::string(\"NONE|FORKID|ANYONECANPAY\"), int(SIGHASH_NONE|SIGHASH_FORKID|SIGHASH_ANYONECANPAY)},\r\n+            {std::string(\"SINGLE|FORKID|ANYONECANPAY\"), int(SIGHASH_SINGLE|SIGHASH_FORKID|SIGHASH_ANYONECANPAY)},\r\n+        };\r\n+        std::string strHashType = request.params[3].get_str();\r\n+        if (mapSigHashValues.count(strHashType))\r\n+            nHashType = mapSigHashValues[strHashType];\r\n+        else\r\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid sighash param\");\r\n+    }\r\n+\r\n+    bool fHashSingle = ((nHashType & ~SIGHASH_ANYONECANPAY) == SIGHASH_SINGLE);\r\n+\r\n+    // Script verification errors\r\n+    UniValue vErrors(UniValue::VARR);\r\n+\r\n+    // Use CTransaction for the constant parts of the\r\n+    // transaction to avoid rehashing.\r\n+    const CTransaction txConst(mtx);\r\n+    // Sign what we can:\r\n+    for (unsigned int i = 0; i < mtx.vin.size(); i++) {\r\n+        CTxIn& txin = mtx.vin[i];\r\n+        const Coin& coin = view.AccessCoin(txin.prevout);\r\n+        if (coin.IsSpent()) {\r\n+            TxInErrorToJSON(txin, vErrors, \"Input not found or already spent\");\r\n+            continue;\r\n+        }\r\n+        const CScript& prevPubKey = coin.out.scriptPubKey;\r\n+        const CAmount& amount = coin.out.nValue;\r\n+\r\n+        SignatureData sigdata;\r\n+        // Only sign SIGHASH_SINGLE if there's a corresponding output:\r\n+        if (!fHashSingle || (i < mtx.vout.size()))\r\n+            ProduceSignature(MutableTransactionSignatureCreator(&keystore, &mtx, i, amount, nHashType), prevPubKey, sigdata);\r\n+        sigdata = CombineSignatures(prevPubKey, TransactionSignatureChecker(&txConst, i, amount), sigdata, DataFromTransaction(mtx, i));\r\n+\r\n+        UpdateTransaction(mtx, i, sigdata);\r\n+\r\n+        ScriptError serror = SCRIPT_ERR_OK;\r\n+        if (!VerifyScript(txin.scriptSig, prevPubKey, &txin.scriptWitness, STANDARD_SCRIPT_VERIFY_FLAGS, TransactionSignatureChecker(&txConst, i, amount), &serror)) {\r\n+            if (serror == SCRIPT_ERR_INVALID_STACK_OPERATION) {\r\n+                // Unable to sign input and verification failed (possible attempt to partially sign).\r\n+                TxInErrorToJSON(txin, vErrors, \"Unable to sign input, invalid stack size (possibly missing key)\");\r\n+            } else {\r\n+                TxInErrorToJSON(txin, vErrors, ScriptErrorString(serror));\r\n+            }\r\n+        }\r\n+    }\r\n+    bool fComplete = vErrors.empty();\r\n+\r\n+    UniValue result(UniValue::VOBJ);\r\n+    result.push_back(Pair(\"hex\", EncodeHexTx(mtx)));\r\n+    result.push_back(Pair(\"complete\", fComplete));\r\n+    if (!vErrors.empty()) {\r\n+        result.push_back(Pair(\"errors\", vErrors));\r\n+    }\r\n+\r\n+    return result;\r\n+}\r\n+\r\n+UniValue sendrawtransaction(const JSONRPCRequest& request)\r\n+{\r\n+    if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\r\n+        throw std::runtime_error(\r\n+            \"sendrawtransaction \\\"hexstring\\\" ( allowhighfees )\\n\"\r\n+            \"\\nSubmits raw transaction (serialized, hex-encoded) to local node and network.\\n\"\r\n+            \"\\nAlso see createrawtransaction and signrawtransaction calls.\\n\"\r\n+            \"\\nArguments:\\n\"\r\n+            \"1. \\\"hexstring\\\"    (string, required) The hex string of the raw transaction)\\n\"\r\n+            \"2. allowhighfees    (boolean, optional, default=false) Allow high fees\\n\"\r\n+            \"\\nResult:\\n\"\r\n+            \"\\\"hex\\\"             (string) The transaction hash in hex\\n\"\r\n+            \"\\nExamples:\\n\"\r\n+            \"\\nCreate a transaction\\n\"\r\n+            + HelpExampleCli(\"createrawtransaction\", \"\\\"[{\\\\\\\"txid\\\\\\\" : \\\\\\\"mytxid\\\\\\\",\\\\\\\"vout\\\\\\\":0}]\\\" \\\"{\\\\\\\"myaddress\\\\\\\":0.01}\\\"\") +\r\n+            \"Sign the transaction, and get back the hex\\n\"\r\n+            + HelpExampleCli(\"signrawtransaction\", \"\\\"myhex\\\"\") +\r\n+            \"\\nSend the transaction (signed hex)\\n\"\r\n+            + HelpExampleCli(\"sendrawtransaction\", \"\\\"signedhex\\\"\") +\r\n+            \"\\nAs a json rpc call\\n\"\r\n+            + HelpExampleRpc(\"sendrawtransaction\", \"\\\"signedhex\\\"\")\r\n+        );\r\n+\r\n+    ObserveSafeMode();\r\n+\r\n+    std::promise<void> promise;\r\n+\r\n+    RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL});\r\n+\r\n+    // parse hex string from parameter\r\n+    CMutableTransaction mtx;\r\n+    if (!DecodeHexTx(mtx, request.params[0].get_str()))\r\n+        throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\r\n+    CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\r\n+    const uint256& hashTx = tx->GetHash();\r\n+\r\n+    CAmount nMaxRawTxFee = maxTxFee;\r\n+    if (!request.params[1].isNull() && request.params[1].get_bool())\r\n+        nMaxRawTxFee = 0;\r\n+\r\n+    { // cs_main scope\r\n+    LOCK(cs_main);\r\n+    CCoinsViewCache &view = *pcoinsTip;\r\n+    bool fHaveChain = false;\r\n+    for (size_t o = 0; !fHaveChain && o < tx->vout.size(); o++) {\r\n+        const Coin& existingCoin = view.AccessCoin(COutPoint(hashTx, o));\r\n+        fHaveChain = !existingCoin.IsSpent();\r\n+    }\r\n+    bool fHaveMempool = mempool.exists(hashTx);\r\n+    if (!fHaveMempool && !fHaveChain) {\r\n+        // push to local node and sync with wallets\r\n+        CValidationState state;\r\n+        bool fMissingInputs;\r\n+        if (!AcceptToMemoryPool(mempool, state, std::move(tx), &fMissingInputs,\r\n+                                nullptr /* plTxnReplaced */, false /* bypass_limits */, nMaxRawTxFee)) {\r\n+            if (state.IsInvalid()) {\r\n+                throw JSONRPCError(RPC_TRANSACTION_REJECTED, strprintf(\"%i: %s\", state.GetRejectCode(), state.GetRejectReason()));\r\n+            } else {\r\n+                if (fMissingInputs) {\r\n+                    throw JSONRPCError(RPC_TRANSACTION_ERROR, \"Missing inputs\");\r\n+                }\r\n+                throw JSONRPCError(RPC_TRANSACTION_ERROR, state.GetRejectReason());\r\n+            }\r\n+        } else {\r\n+            // If wallet is enabled, ensure that the wallet has been made aware\r\n+            // of the new transaction prior to returning. This prevents a race\r\n+            // where a user might call sendrawtransaction with a transaction\r\n+            // to/from their wallet, immediately call some wallet RPC, and get\r\n+            // a stale result because callbacks have not yet been processed.\r\n+            CallFunctionInValidationInterfaceQueue([&promise] {\r\n+                promise.set_value();\r\n+            });\r\n+        }\r\n+    } else if (fHaveChain) {\r\n+        throw JSONRPCError(RPC_TRANSACTION_ALREADY_IN_CHAIN, \"transaction already in block chain\");\r\n+    } else {\r\n+        // Make sure we don't block forever if re-sending\r\n+        // a transaction already in mempool.\r\n+        promise.set_value();\r\n+    }\r\n+\r\n+    } // cs_main\r\n+\r\n+    promise.get_future().wait();\r\n+\r\n+    if(!g_connman)\r\n+        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\r\n+\r\n+    CInv inv(MSG_TX, hashTx);\r\n+    g_connman->ForEachNode([&inv](CNode* pnode)\r\n+    {\r\n+        pnode->PushInventory(inv);\r\n+    });\r\n+\r\n+    return hashTx.GetHex();\r\n+}\r\n+\r\n+static const CRPCCommand commands[] =\r\n+{ //  category              name                      actor (function)         argNames\r\n+  //  --------------------- ------------------------  -----------------------  ----------\r\n+    { \"rawtransactions\",    \"getrawtransaction\",      &getrawtransaction,      {\"txid\",\"verbose\",\"blockhash\"} },\r\n+    { \"rawtransactions\",    \"createrawtransaction\",   &createrawtransaction,   {\"inputs\",\"outputs\",\"locktime\",\"replaceable\"} },\r\n+    { \"rawtransactions\",    \"decoderawtransaction\",   &decoderawtransaction,   {\"hexstring\"} },\r\n+    { \"rawtransactions\",    \"decodescript\",           &decodescript,           {\"hexstring\"} },\r\n+    { \"rawtransactions\",    \"sendrawtransaction\",     &sendrawtransaction,     {\"hexstring\",\"allowhighfees\"} },\r\n+    { \"rawtransactions\",    \"combinerawtransaction\",  &combinerawtransaction,  {\"txs\"} },\r\n+    { \"rawtransactions\",    \"signrawtransaction\",     &signrawtransaction,     {\"hexstring\",\"prevtxs\",\"privkeys\",\"sighashtype\"} }, /* uses wallet if enabled */\r\n+\r\n+    { \"blockchain\",         \"gettxoutproof\",          &gettxoutproof,          {\"txids\", \"blockhash\"} },\r\n+    { \"blockchain\",         \"verifytxoutproof\",       &verifytxoutproof,       {\"proof\"} },\r\n+};\r\n+\r\n+void RegisterRawTransactionRPCCommands(CRPCTable &t)\r\n+{\r\n+    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)\r\n+        t.appendCommand(commands[vcidx].name, &commands[vcidx]);\r\n+}\r"
      },
      {
        "sha": "2b8a06693173a4369ad0d7120928039b874b75d1",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472"
      },
      {
        "sha": "4fe9c099107fbd3cce5571b1d34f8e026fbbe137",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 193,
        "deletions": 188,
        "changes": 381,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472"
      },
      {
        "sha": "8046c1562a5f3a5445ec3084db7bc43dd9ca0586",
        "filename": "src/script/script_error.cpp",
        "status": "modified",
        "additions": 101,
        "deletions": 97,
        "changes": 198,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/script/script_error.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/script/script_error.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472"
      },
      {
        "sha": "5022074d8e813c708aa1b2436e95f5fb6c7ef089",
        "filename": "src/script/script_error.h",
        "status": "modified",
        "additions": 78,
        "deletions": 74,
        "changes": 152,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/script/script_error.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/script/script_error.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/script_error.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472"
      },
      {
        "sha": "3776d34bd148e228cf091ca3e5d01cc0830ef1c7",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 424,
        "deletions": 424,
        "changes": 848,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472"
      },
      {
        "sha": "1acead271314a45a062106c1e0b35dddf80aa342",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 84,
        "deletions": 84,
        "changes": 168,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472"
      },
      {
        "sha": "f35e190c46d481ff91f3fb4dd5a96243bbecdf21",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 426,
        "deletions": 426,
        "changes": 852,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472"
      },
      {
        "sha": "551447cec83e2e20ffe85ff94637fb9a6f60f99a",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4696,
        "deletions": 4672,
        "changes": 9368,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472"
      },
      {
        "sha": "ba82e51367acf9ce982444814cca0809298f6b82",
        "filename": "src/wallet/feebumper.cpp",
        "status": "modified",
        "additions": 293,
        "deletions": 293,
        "changes": 586,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/wallet/feebumper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/wallet/feebumper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/feebumper.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472"
      },
      {
        "sha": "19a233f403124443966e44abf5f600119347c625",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 3503,
        "deletions": 3503,
        "changes": 7006,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472"
      },
      {
        "sha": "660e27c765e8d856228aceaacc582981ce11c303",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 4134,
        "deletions": 4134,
        "changes": 8268,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fe99bdb0e4664d1bd6679bcaf0cddad06451472/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=8fe99bdb0e4664d1bd6679bcaf0cddad06451472"
      }
    ]
  },
  {
    "sha": "b8461f9655ceec64a3bb3835b12b51f2b5ac42e6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiODQ2MWY5NjU1Y2VlYzY0YTNiYjM4MzViMTJiNTFmMmI1YWM0MmU2",
    "commit": {
      "author": {
        "name": "admin",
        "email": "admin@bitvote.one",
        "date": "2018-01-23T13:38:26Z"
      },
      "committer": {
        "name": "admin",
        "email": "admin@bitvote.one",
        "date": "2018-01-23T13:38:26Z"
      },
      "message": "tests and Makefile",
      "tree": {
        "sha": "22bf4c56de3406a5b35b4442290ed7849b3aed97",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/22bf4c56de3406a5b35b4442290ed7849b3aed97"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/comments",
    "author": {
      "login": "bitcoinvote",
      "id": 34435980,
      "node_id": "MDQ6VXNlcjM0NDM1OTgw",
      "avatar_url": "https://avatars.githubusercontent.com/u/34435980?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bitcoinvote",
      "html_url": "https://github.com/bitcoinvote",
      "followers_url": "https://api.github.com/users/bitcoinvote/followers",
      "following_url": "https://api.github.com/users/bitcoinvote/following{/other_user}",
      "gists_url": "https://api.github.com/users/bitcoinvote/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bitcoinvote/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bitcoinvote/subscriptions",
      "organizations_url": "https://api.github.com/users/bitcoinvote/orgs",
      "repos_url": "https://api.github.com/users/bitcoinvote/repos",
      "events_url": "https://api.github.com/users/bitcoinvote/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bitcoinvote/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "bitcoinvote",
      "id": 34435980,
      "node_id": "MDQ6VXNlcjM0NDM1OTgw",
      "avatar_url": "https://avatars.githubusercontent.com/u/34435980?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/bitcoinvote",
      "html_url": "https://github.com/bitcoinvote",
      "followers_url": "https://api.github.com/users/bitcoinvote/followers",
      "following_url": "https://api.github.com/users/bitcoinvote/following{/other_user}",
      "gists_url": "https://api.github.com/users/bitcoinvote/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/bitcoinvote/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/bitcoinvote/subscriptions",
      "organizations_url": "https://api.github.com/users/bitcoinvote/orgs",
      "repos_url": "https://api.github.com/users/bitcoinvote/repos",
      "events_url": "https://api.github.com/users/bitcoinvote/events{/privacy}",
      "received_events_url": "https://api.github.com/users/bitcoinvote/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8fe99bdb0e4664d1bd6679bcaf0cddad06451472",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8fe99bdb0e4664d1bd6679bcaf0cddad06451472"
      }
    ],
    "stats": {
      "total": 8728,
      "additions": 4374,
      "deletions": 4354
    },
    "files": [
      {
        "sha": "f128c2f7275b26397060cbfbc2536eea9a6d6dc2",
        "filename": "doc/build-unix.md",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/doc/build-unix.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/doc/build-unix.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/build-unix.md?ref=b8461f9655ceec64a3bb3835b12b51f2b5ac42e6",
        "patch": "@@ -19,7 +19,7 @@ To Build\n \n ```bash\n ./autogen.sh\n-./configure\n+CFLAGS=\"-g -O2 -fPIC\" CXXFLAGS=\"-g -O2 -Wall -Wextra -Wformat -Wvla -Wformat-security -Wno-unused-parameter -fPIC\" ./configure --with-incompatible-bdb\n make\n make install # optional\n ```"
      },
      {
        "sha": "086b46ccf18655a0350ba2fbe47d06ce83a76939",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 557,
        "deletions": 539,
        "changes": 1096,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=b8461f9655ceec64a3bb3835b12b51f2b5ac42e6",
        "patch": "@@ -1,539 +1,557 @@\n-# Copyright (c) 2013-2016 The Bitcoin Core developers\n-# Distributed under the MIT software license, see the accompanying\n-# file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-DIST_SUBDIRS = secp256k1 univalue\n-\n-AM_LDFLAGS = $(PTHREAD_CFLAGS) $(LIBTOOL_LDFLAGS) $(HARDENED_LDFLAGS)\n-AM_CXXFLAGS = $(HARDENED_CXXFLAGS) $(ERROR_CXXFLAGS)\n-AM_CPPFLAGS = $(HARDENED_CPPFLAGS)\n-EXTRA_LIBRARIES =\n-\n-if EMBEDDED_UNIVALUE\n-LIBUNIVALUE = univalue/libunivalue.la\n-\n-$(LIBUNIVALUE): $(wildcard univalue/lib/*) $(wildcard univalue/include/*)\n-\t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)\n-else\n-LIBUNIVALUE = $(UNIVALUE_LIBS)\n-endif\n-\n-BITCOIN_INCLUDES=-I$(builddir) $(BDB_CPPFLAGS) $(BOOST_CPPFLAGS) $(LEVELDB_CPPFLAGS) $(CRYPTO_CFLAGS) $(SSL_CFLAGS)\n-\n-BITCOIN_INCLUDES += -I$(srcdir)/secp256k1/include\n-BITCOIN_INCLUDES += $(UNIVALUE_CFLAGS)\n-\n-LIBBITCOIN_SERVER=libbitcoin_server.a\n-LIBBITCOIN_COMMON=libbitcoin_common.a\n-LIBBITCOIN_CONSENSUS=libbitcoin_consensus.a\n-LIBBITCOIN_CLI=libbitcoin_cli.a\n-LIBBITCOIN_UTIL=libbitcoin_util.a\n-LIBBITCOIN_CRYPTO=crypto/libbitcoin_crypto.a\n-LIBBITCOINQT=qt/libbitcoinqt.a\n-LIBSECP256K1=secp256k1/libsecp256k1.la\n-\n-if ENABLE_ZMQ\n-LIBBITCOIN_ZMQ=libbitcoin_zmq.a\n-endif\n-if BUILD_BITCOIN_LIBS\n-LIBBITCOINCONSENSUS=libbitcoinconsensus.la\n-endif\n-if ENABLE_WALLET\n-LIBBITCOIN_WALLET=libbitcoin_wallet.a\n-endif\n-\n-$(LIBSECP256K1): $(wildcard secp256k1/src/*) $(wildcard secp256k1/include/*)\n-\t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)\n-\n-# Make is not made aware of per-object dependencies to avoid limiting building parallelization\n-# But to build the less dependent modules first, we manually select their order here:\n-EXTRA_LIBRARIES += \\\n-  $(LIBBITCOIN_CRYPTO) \\\n-  $(LIBBITCOIN_UTIL) \\\n-  $(LIBBITCOIN_COMMON) \\\n-  $(LIBBITCOIN_CONSENSUS) \\\n-  $(LIBBITCOIN_SERVER) \\\n-  $(LIBBITCOIN_CLI) \\\n-  $(LIBBITCOIN_WALLET) \\\n-  $(LIBBITCOIN_ZMQ)\n-\n-lib_LTLIBRARIES = $(LIBBITCOINCONSENSUS)\n-\n-bin_PROGRAMS =\n-noinst_PROGRAMS =\n-TESTS =\n-BENCHMARKS =\n-\n-if BUILD_BITCOIND\n-  bin_PROGRAMS += bitcoind\n-endif\n-\n-if BUILD_BITCOIN_UTILS\n-  bin_PROGRAMS += bitcoin-cli bitcoin-tx\n-endif\n-\n-.PHONY: FORCE check-symbols check-security\n-# bitcoin core #\n-BITCOIN_CORE_H = \\\n-  addrdb.h \\\n-  addrman.h \\\n-  base58.h \\\n-  bech32.h \\\n-  bloom.h \\\n-  blockencodings.h \\\n-  chain.h \\\n-  chainparams.h \\\n-  chainparamsbase.h \\\n-  chainparamsseeds.h \\\n-  checkpoints.h \\\n-  checkqueue.h \\\n-  clientversion.h \\\n-  coins.h \\\n-  compat.h \\\n-  compat/byteswap.h \\\n-  compat/endian.h \\\n-  compat/sanity.h \\\n-  compressor.h \\\n-  consensus/consensus.h \\\n-  consensus/tx_verify.h \\\n-  core_io.h \\\n-  core_memusage.h \\\n-  cuckoocache.h \\\n-  fs.h \\\n-  httprpc.h \\\n-  httpserver.h \\\n-  indirectmap.h \\\n-  init.h \\\n-  key.h \\\n-  keystore.h \\\n-  dbwrapper.h \\\n-  limitedmap.h \\\n-  memusage.h \\\n-  merkleblock.h \\\n-  miner.h \\\n-  net.h \\\n-  net_processing.h \\\n-  netaddress.h \\\n-  netbase.h \\\n-  netmessagemaker.h \\\n-  noui.h \\\n-  policy/feerate.h \\\n-  policy/fees.h \\\n-  policy/policy.h \\\n-  policy/rbf.h \\\n-  pow.h \\\n-  protocol.h \\\n-  random.h \\\n-  reverse_iterator.h \\\n-  reverselock.h \\\n-  rpc/blockchain.h \\\n-  rpc/client.h \\\n-  rpc/mining.h \\\n-  rpc/protocol.h \\\n-  rpc/safemode.h \\\n-  rpc/server.h \\\n-  rpc/register.h \\\n-  scheduler.h \\\n-  script/sigcache.h \\\n-  script/sign.h \\\n-  script/standard.h \\\n-  script/ismine.h \\\n-  streams.h \\\n-  support/allocators/secure.h \\\n-  support/allocators/zeroafterfree.h \\\n-  support/cleanse.h \\\n-  support/events.h \\\n-  support/lockedpool.h \\\n-  sync.h \\\n-  threadsafety.h \\\n-  threadinterrupt.h \\\n-  timedata.h \\\n-  torcontrol.h \\\n-  txdb.h \\\n-  txmempool.h \\\n-  ui_interface.h \\\n-  undo.h \\\n-  util.h \\\n-  utilmoneystr.h \\\n-  utiltime.h \\\n-  validation.h \\\n-  validationinterface.h \\\n-  versionbits.h \\\n-  wallet/coincontrol.h \\\n-  wallet/crypter.h \\\n-  wallet/db.h \\\n-  wallet/feebumper.h \\\n-  wallet/fees.h \\\n-  wallet/init.h \\\n-  wallet/rpcwallet.h \\\n-  wallet/wallet.h \\\n-  wallet/walletdb.h \\\n-  wallet/walletutil.h \\\n-  warnings.h \\\n-  zmq/zmqabstractnotifier.h \\\n-  zmq/zmqconfig.h\\\n-  zmq/zmqnotificationinterface.h \\\n-  zmq/zmqpublishnotifier.h\n-\n-\n-obj/build.h: FORCE\n-\t@$(MKDIR_P) $(builddir)/obj\n-\t@$(top_srcdir)/share/genbuild.sh \"$(abs_top_builddir)/src/obj/build.h\" \\\n-\t  \"$(abs_top_srcdir)\"\n-libbitcoin_util_a-clientversion.$(OBJEXT): obj/build.h\n-\n-# server: shared between bitcoind and bitcoin-qt\n-libbitcoin_server_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(MINIUPNPC_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\n-libbitcoin_server_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-libbitcoin_server_a_SOURCES = \\\n-  addrdb.cpp \\\n-  addrman.cpp \\\n-  bloom.cpp \\\n-  blockencodings.cpp \\\n-  chain.cpp \\\n-  checkpoints.cpp \\\n-  consensus/tx_verify.cpp \\\n-  httprpc.cpp \\\n-  httpserver.cpp \\\n-  init.cpp \\\n-  dbwrapper.cpp \\\n-  merkleblock.cpp \\\n-  miner.cpp \\\n-  net.cpp \\\n-  net_processing.cpp \\\n-  noui.cpp \\\n-  policy/fees.cpp \\\n-  policy/policy.cpp \\\n-  policy/rbf.cpp \\\n-  pow.cpp \\\n-  rest.cpp \\\n-  rpc/blockchain.cpp \\\n-  rpc/mining.cpp \\\n-  rpc/misc.cpp \\\n-  rpc/net.cpp \\\n-  rpc/rawtransaction.cpp \\\n-  rpc/safemode.cpp \\\n-  rpc/server.cpp \\\n-  script/sigcache.cpp \\\n-  script/ismine.cpp \\\n-  timedata.cpp \\\n-  torcontrol.cpp \\\n-  txdb.cpp \\\n-  txmempool.cpp \\\n-  ui_interface.cpp \\\n-  validation.cpp \\\n-  validationinterface.cpp \\\n-  versionbits.cpp \\\n-  $(BITCOIN_CORE_H)\n-\n-if ENABLE_ZMQ\n-libbitcoin_zmq_a_CPPFLAGS = $(BITCOIN_INCLUDES) $(ZMQ_CFLAGS)\n-libbitcoin_zmq_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-libbitcoin_zmq_a_SOURCES = \\\n-  zmq/zmqabstractnotifier.cpp \\\n-  zmq/zmqnotificationinterface.cpp \\\n-  zmq/zmqpublishnotifier.cpp\n-endif\n-\n-\n-# wallet: shared between bitcoind and bitcoin-qt, but only linked\n-# when wallet enabled\n-libbitcoin_wallet_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n-libbitcoin_wallet_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-libbitcoin_wallet_a_SOURCES = \\\n-  wallet/crypter.cpp \\\n-  wallet/db.cpp \\\n-  wallet/feebumper.cpp \\\n-  wallet/fees.cpp \\\n-  wallet/init.cpp \\\n-  wallet/rpcdump.cpp \\\n-  wallet/rpcwallet.cpp \\\n-  wallet/wallet.cpp \\\n-  wallet/walletdb.cpp \\\n-  wallet/walletutil.cpp \\\n-  $(BITCOIN_CORE_H)\n-\n-# crypto primitives library\n-crypto_libbitcoin_crypto_a_CPPFLAGS = $(AM_CPPFLAGS)\n-crypto_libbitcoin_crypto_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-crypto_libbitcoin_crypto_a_SOURCES = \\\n-  crypto/aes.cpp \\\n-  crypto/aes.h \\\n-  crypto/chacha20.h \\\n-  crypto/chacha20.cpp \\\n-  crypto/common.h \\\n-  crypto/hmac_sha256.cpp \\\n-  crypto/hmac_sha256.h \\\n-  crypto/hmac_sha512.cpp \\\n-  crypto/hmac_sha512.h \\\n-  crypto/ripemd160.cpp \\\n-  crypto/ripemd160.h \\\n-  crypto/sha1.cpp \\\n-  crypto/sha1.h \\\n-  crypto/sha256.cpp \\\n-  crypto/sha256.h \\\n-  crypto/sha512.cpp \\\n-  crypto/sha512.h\n-\n-if USE_ASM\n-crypto_libbitcoin_crypto_a_SOURCES += crypto/sha256_sse4.cpp\n-endif\n-\n-# consensus: shared between all executables that validate any consensus rules.\n-libbitcoin_consensus_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n-libbitcoin_consensus_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-libbitcoin_consensus_a_SOURCES = \\\n-  amount.h \\\n-  arith_uint256.cpp \\\n-  arith_uint256.h \\\n-  consensus/merkle.cpp \\\n-  consensus/merkle.h \\\n-  consensus/params.h \\\n-  consensus/validation.h \\\n-  hash.cpp \\\n-  hash.h \\\n-  prevector.h \\\n-  primitives/block.cpp \\\n-  primitives/block.h \\\n-  primitives/transaction.cpp \\\n-  primitives/transaction.h \\\n-  pubkey.cpp \\\n-  pubkey.h \\\n-  script/bitcoinconsensus.cpp \\\n-  script/interpreter.cpp \\\n-  script/interpreter.h \\\n-  script/script.cpp \\\n-  script/script.h \\\n-  script/script_error.cpp \\\n-  script/script_error.h \\\n-  serialize.h \\\n-  tinyformat.h \\\n-  uint256.cpp \\\n-  uint256.h \\\n-  utilstrencodings.cpp \\\n-  utilstrencodings.h \\\n-  version.h\n-\n-# common: shared between bitcoind, and bitcoin-qt and non-server tools\n-libbitcoin_common_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n-libbitcoin_common_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-libbitcoin_common_a_SOURCES = \\\n-  base58.cpp \\\n-  bech32.cpp \\\n-  chainparams.cpp \\\n-  coins.cpp \\\n-  compressor.cpp \\\n-  core_read.cpp \\\n-  core_write.cpp \\\n-  key.cpp \\\n-  keystore.cpp \\\n-  netaddress.cpp \\\n-  netbase.cpp \\\n-  policy/feerate.cpp \\\n-  protocol.cpp \\\n-  scheduler.cpp \\\n-  script/sign.cpp \\\n-  script/standard.cpp \\\n-  warnings.cpp \\\n-  $(BITCOIN_CORE_H)\n-\n-# util: shared between all executables.\n-# This library *must* be included to make sure that the glibc\n-# backward-compatibility objects and their sanity checks are linked.\n-libbitcoin_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n-libbitcoin_util_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-libbitcoin_util_a_SOURCES = \\\n-  support/lockedpool.cpp \\\n-  chainparamsbase.cpp \\\n-  clientversion.cpp \\\n-  compat/glibc_sanity.cpp \\\n-  compat/glibcxx_sanity.cpp \\\n-  compat/strnlen.cpp \\\n-  fs.cpp \\\n-  random.cpp \\\n-  rpc/protocol.cpp \\\n-  support/cleanse.cpp \\\n-  sync.cpp \\\n-  threadinterrupt.cpp \\\n-  util.cpp \\\n-  utilmoneystr.cpp \\\n-  utilstrencodings.cpp \\\n-  utiltime.cpp \\\n-  $(BITCOIN_CORE_H)\n-\n-if GLIBC_BACK_COMPAT\n-libbitcoin_util_a_SOURCES += compat/glibc_compat.cpp\n-endif\n-\n-# cli: shared between bitcoin-cli and bitcoin-qt\n-libbitcoin_cli_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n-libbitcoin_cli_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-libbitcoin_cli_a_SOURCES = \\\n-  rpc/client.cpp \\\n-  $(BITCOIN_CORE_H)\n-\n-nodist_libbitcoin_util_a_SOURCES = $(srcdir)/obj/build.h\n-#\n-\n-# bitcoind binary #\n-bitcoind_SOURCES = bitcoind.cpp\n-bitcoind_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n-bitcoind_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-bitcoind_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-\n-if TARGET_WINDOWS\n-bitcoind_SOURCES += bitcoind-res.rc\n-endif\n-\n-bitcoind_LDADD = \\\n-  $(LIBBITCOIN_SERVER) \\\n-  $(LIBBITCOIN_COMMON) \\\n-  $(LIBUNIVALUE) \\\n-  $(LIBBITCOIN_UTIL) \\\n-  $(LIBBITCOIN_WALLET) \\\n-  $(LIBBITCOIN_ZMQ) \\\n-  $(LIBBITCOIN_CONSENSUS) \\\n-  $(LIBBITCOIN_CRYPTO) \\\n-  $(LIBLEVELDB) \\\n-  $(LIBLEVELDB_SSE42) \\\n-  $(LIBMEMENV) \\\n-  $(LIBSECP256K1)\n-\n-bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS)\n-\n-# bitcoin-cli binary #\n-bitcoin_cli_SOURCES = bitcoin-cli.cpp\n-bitcoin_cli_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(EVENT_CFLAGS)\n-bitcoin_cli_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-bitcoin_cli_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-\n-if TARGET_WINDOWS\n-bitcoin_cli_SOURCES += bitcoin-cli-res.rc\n-endif\n-\n-bitcoin_cli_LDADD = \\\n-  $(LIBBITCOIN_CLI) \\\n-  $(LIBUNIVALUE) \\\n-  $(LIBBITCOIN_UTIL) \\\n-  $(LIBBITCOIN_CRYPTO)\n-\n-bitcoin_cli_LDADD += $(BOOST_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(EVENT_LIBS)\n-#\n-\n-# bitcoin-tx binary #\n-bitcoin_tx_SOURCES = bitcoin-tx.cpp\n-bitcoin_tx_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\n-bitcoin_tx_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-bitcoin_tx_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n-\n-if TARGET_WINDOWS\n-bitcoin_tx_SOURCES += bitcoin-tx-res.rc\n-endif\n-\n-bitcoin_tx_LDADD = \\\n-  $(LIBUNIVALUE) \\\n-  $(LIBBITCOIN_COMMON) \\\n-  $(LIBBITCOIN_UTIL) \\\n-  $(LIBBITCOIN_CONSENSUS) \\\n-  $(LIBBITCOIN_CRYPTO) \\\n-  $(LIBSECP256K1)\n-\n-bitcoin_tx_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\n-#\n-\n-# bitcoinconsensus library #\n-if BUILD_BITCOIN_LIBS\n-include_HEADERS = script/bitcoinconsensus.h\n-libbitcoinconsensus_la_SOURCES = $(crypto_libbitcoin_crypto_a_SOURCES) $(libbitcoin_consensus_a_SOURCES)\n-\n-if GLIBC_BACK_COMPAT\n-  libbitcoinconsensus_la_SOURCES += compat/glibc_compat.cpp\n-endif\n-\n-libbitcoinconsensus_la_LDFLAGS = $(AM_LDFLAGS) -no-undefined $(RELDFLAGS)\n-libbitcoinconsensus_la_LIBADD = $(LIBSECP256K1)\n-libbitcoinconsensus_la_CPPFLAGS = $(AM_CPPFLAGS) -I$(builddir)/obj -I$(srcdir)/secp256k1/include -DBUILD_BITCOIN_INTERNAL\n-libbitcoinconsensus_la_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n-\n-endif\n-#\n-\n-CTAES_DIST =  crypto/ctaes/bench.c\n-CTAES_DIST += crypto/ctaes/ctaes.c\n-CTAES_DIST += crypto/ctaes/ctaes.h\n-CTAES_DIST += crypto/ctaes/README.md\n-CTAES_DIST += crypto/ctaes/test.c\n-\n-CLEANFILES = $(EXTRA_LIBRARIES)\n-\n-CLEANFILES += *.gcda *.gcno\n-CLEANFILES += compat/*.gcda compat/*.gcno\n-CLEANFILES += consensus/*.gcda consensus/*.gcno\n-CLEANFILES += crypto/*.gcda crypto/*.gcno\n-CLEANFILES += policy/*.gcda policy/*.gcno\n-CLEANFILES += primitives/*.gcda primitives/*.gcno\n-CLEANFILES += script/*.gcda script/*.gcno\n-CLEANFILES += support/*.gcda support/*.gcno\n-CLEANFILES += univalue/*.gcda univalue/*.gcno\n-CLEANFILES += wallet/*.gcda wallet/*.gcno\n-CLEANFILES += wallet/test/*.gcda wallet/test/*.gcno\n-CLEANFILES += zmq/*.gcda zmq/*.gcno\n-CLEANFILES += obj/build.h\n-\n-EXTRA_DIST = $(CTAES_DIST)\n-\n-\n-config/bitcoin-config.h: config/stamp-h1\n-\t@$(MAKE) -C $(top_builddir) $(subdir)/$(@)\n-config/stamp-h1: $(top_srcdir)/$(subdir)/config/bitcoin-config.h.in $(top_builddir)/config.status\n-\t$(AM_V_at)$(MAKE) -C $(top_builddir) $(subdir)/$(@)\n-$(top_srcdir)/$(subdir)/config/bitcoin-config.h.in:  $(am__configure_deps)\n-\t$(AM_V_at)$(MAKE) -C $(top_srcdir) $(subdir)/config/bitcoin-config.h.in\n-\n-clean-local:\n-\t-$(MAKE) -C secp256k1 clean\n-\t-$(MAKE) -C univalue clean\n-\t-rm -f leveldb/*/*.gcda leveldb/*/*.gcno leveldb/helpers/memenv/*.gcda leveldb/helpers/memenv/*.gcno\n-\t-rm -f config.h\n-\t-rm -rf test/__pycache__\n-\n-.rc.o:\n-\t@test -f $(WINDRES)\n-\t## FIXME: How to get the appropriate modulename_CPPFLAGS in here?\n-\t$(AM_V_GEN) $(WINDRES) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(CPPFLAGS) -DWINDRES_PREPROC -i $< -o $@\n-\n-check-symbols: $(bin_PROGRAMS)\n-if GLIBC_BACK_COMPAT\n-\t@echo \"Checking glibc back compat...\"\n-\t$(AM_V_at) READELF=$(READELF) CPPFILT=$(CPPFILT) $(top_srcdir)/contrib/devtools/symbol-check.py < $(bin_PROGRAMS)\n-endif\n-\n-check-security: $(bin_PROGRAMS)\n-if HARDEN\n-\t@echo \"Checking binary security...\"\n-\t$(AM_V_at) READELF=$(READELF) OBJDUMP=$(OBJDUMP) $(top_srcdir)/contrib/devtools/security-check.py < $(bin_PROGRAMS)\n-endif\n-\n-%.pb.cc %.pb.h: %.proto\n-\t@test -f $(PROTOC)\n-\t$(AM_V_GEN) $(PROTOC) --cpp_out=$(@D) --proto_path=$(<D) $<\n-\n-if EMBEDDED_LEVELDB\n-include Makefile.leveldb.include\n-endif\n-\n-if ENABLE_TESTS\n-include Makefile.test.include\n-endif\n-\n-if ENABLE_BENCH\n-include Makefile.bench.include\n-endif\n-\n-if ENABLE_QT\n-include Makefile.qt.include\n-endif\n-\n-if ENABLE_QT_TESTS\n-include Makefile.qttest.include\n-endif\n+# Copyright (c) 2013-2016 The Bitcoin Core developers\r\n+# Distributed under the MIT software license, see the accompanying\r\n+# file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+DIST_SUBDIRS = secp256k1 univalue\r\n+\r\n+AM_LDFLAGS = $(PTHREAD_CFLAGS) $(LIBTOOL_LDFLAGS) $(HARDENED_LDFLAGS)\r\n+AM_CXXFLAGS = $(HARDENED_CXXFLAGS) $(ERROR_CXXFLAGS)\r\n+AM_CPPFLAGS = $(HARDENED_CPPFLAGS)\r\n+EXTRA_LIBRARIES =\r\n+\r\n+if EMBEDDED_UNIVALUE\r\n+LIBUNIVALUE = univalue/libunivalue.la\r\n+\r\n+$(LIBUNIVALUE): $(wildcard univalue/lib/*) $(wildcard univalue/include/*)\r\n+\t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)\r\n+else\r\n+LIBUNIVALUE = $(UNIVALUE_LIBS)\r\n+endif\r\n+\r\n+BITCOIN_INCLUDES=-I$(builddir) $(BDB_CPPFLAGS) $(BOOST_CPPFLAGS) $(LEVELDB_CPPFLAGS) $(CRYPTO_CFLAGS) $(SSL_CFLAGS)\r\n+\r\n+BITCOIN_INCLUDES += -I$(srcdir)/secp256k1/include\r\n+BITCOIN_INCLUDES += $(UNIVALUE_CFLAGS)\r\n+\r\n+LIBBITCOIN_SERVER=libbitcoin_server.a\r\n+LIBBITCOIN_COMMON=libbitcoin_common.a\r\n+LIBBITCOIN_CONSENSUS=libbitcoin_consensus.a\r\n+LIBBITCOIN_CLI=libbitcoin_cli.a\r\n+LIBBITCOIN_UTIL=libbitcoin_util.a\r\n+LIBBITCOIN_CRYPTO=crypto/libbitcoin_crypto.a\r\n+LIBBITCOINQT=qt/libbitcoinqt.a\r\n+LIBSECP256K1=secp256k1/libsecp256k1.la\r\n+\r\n+if ENABLE_ZMQ\r\n+LIBBITCOIN_ZMQ=libbitcoin_zmq.a\r\n+endif\r\n+if BUILD_BITCOIN_LIBS\r\n+LIBBITCOINCONSENSUS=libbitcoinconsensus.la\r\n+endif\r\n+if ENABLE_WALLET\r\n+LIBBITCOIN_WALLET=libbitcoin_wallet.a\r\n+endif\r\n+\r\n+$(LIBSECP256K1): $(wildcard secp256k1/src/*) $(wildcard secp256k1/include/*)\r\n+\t$(AM_V_at)$(MAKE) $(AM_MAKEFLAGS) -C $(@D) $(@F)\r\n+\r\n+# Make is not made aware of per-object dependencies to avoid limiting building parallelization\r\n+# But to build the less dependent modules first, we manually select their order here:\r\n+EXTRA_LIBRARIES += \\\r\n+  $(LIBBITCOIN_CRYPTO) \\\r\n+  $(LIBBITCOIN_UTIL) \\\r\n+  $(LIBBITCOIN_COMMON) \\\r\n+  $(LIBBITCOIN_CONSENSUS) \\\r\n+  $(LIBBITCOIN_SERVER) \\\r\n+  $(LIBBITCOIN_CLI) \\\r\n+  $(LIBBITCOIN_WALLET) \\\r\n+  $(LIBBITCOIN_ZMQ)\r\n+\r\n+lib_LTLIBRARIES = $(LIBBITCOINCONSENSUS)\r\n+\r\n+bin_PROGRAMS =\r\n+noinst_PROGRAMS =\r\n+TESTS =\r\n+BENCHMARKS =\r\n+\r\n+if BUILD_BITCOIND\r\n+  bin_PROGRAMS += bitcoind\r\n+endif\r\n+\r\n+if BUILD_BITCOIN_UTILS\r\n+  bin_PROGRAMS += bitcoin-cli bitcoin-tx\r\n+endif\r\n+\r\n+.PHONY: FORCE check-symbols check-security\r\n+# bitcoin core #\r\n+BITCOIN_CORE_H = \\\r\n+  addrdb.h \\\r\n+  addrman.h \\\r\n+  base58.h \\\r\n+  bech32.h \\\r\n+  bloom.h \\\r\n+  blockencodings.h \\\r\n+  chain.h \\\r\n+  chainparams.h \\\r\n+  chainparamsbase.h \\\r\n+  chainparamsseeds.h \\\r\n+  checkpoints.h \\\r\n+  checkqueue.h \\\r\n+  clientversion.h \\\r\n+  coins.h \\\r\n+  compat.h \\\r\n+  compat/byteswap.h \\\r\n+  compat/endian.h \\\r\n+  compat/sanity.h \\\r\n+  compressor.h \\\r\n+  consensus/consensus.h \\\r\n+  consensus/tx_verify.h \\\r\n+  core_io.h \\\r\n+  core_memusage.h \\\r\n+  cuckoocache.h \\\r\n+  fs.h \\\r\n+  httprpc.h \\\r\n+  httpserver.h \\\r\n+  indirectmap.h \\\r\n+  init.h \\\r\n+  key.h \\\r\n+  keystore.h \\\r\n+  dbwrapper.h \\\r\n+  limitedmap.h \\\r\n+  memusage.h \\\r\n+  merkleblock.h \\\r\n+  miner.h \\\r\n+  net.h \\\r\n+  net_processing.h \\\r\n+  netaddress.h \\\r\n+  netbase.h \\\r\n+  netmessagemaker.h \\\r\n+  noui.h \\\r\n+  policy/feerate.h \\\r\n+  policy/fees.h \\\r\n+  policy/policy.h \\\r\n+  policy/rbf.h \\\r\n+  pow.h \\\r\n+  protocol.h \\\r\n+  random.h \\\r\n+  reverse_iterator.h \\\r\n+  reverselock.h \\\r\n+  rpc/blockchain.h \\\r\n+  rpc/client.h \\\r\n+  rpc/mining.h \\\r\n+  rpc/protocol.h \\\r\n+  rpc/safemode.h \\\r\n+  rpc/server.h \\\r\n+  rpc/register.h \\\r\n+  scheduler.h \\\r\n+  script/sigcache.h \\\r\n+  script/sign.h \\\r\n+  script/standard.h \\\r\n+  script/ismine.h \\\r\n+  streams.h \\\r\n+  support/allocators/secure.h \\\r\n+  support/allocators/zeroafterfree.h \\\r\n+  support/cleanse.h \\\r\n+  support/events.h \\\r\n+  support/lockedpool.h \\\r\n+  sync.h \\\r\n+  threadsafety.h \\\r\n+  threadinterrupt.h \\\r\n+  timedata.h \\\r\n+  torcontrol.h \\\r\n+  txdb.h \\\r\n+  txmempool.h \\\r\n+  ui_interface.h \\\r\n+  undo.h \\\r\n+  util.h \\\r\n+  utilmoneystr.h \\\r\n+  utiltime.h \\\r\n+  validation.h \\\r\n+  validationinterface.h \\\r\n+  versionbits.h \\\r\n+  wallet/coincontrol.h \\\r\n+  wallet/crypter.h \\\r\n+  wallet/db.h \\\r\n+  wallet/feebumper.h \\\r\n+  wallet/fees.h \\\r\n+  wallet/init.h \\\r\n+  wallet/rpcwallet.h \\\r\n+  wallet/wallet.h \\\r\n+  wallet/walletdb.h \\\r\n+  wallet/walletutil.h \\\r\n+  warnings.h \\\r\n+  zmq/zmqabstractnotifier.h \\\r\n+  zmq/zmqconfig.h\\\r\n+  zmq/zmqnotificationinterface.h \\\r\n+  zmq/zmqpublishnotifier.h\r\n+\r\n+\r\n+obj/build.h: FORCE\r\n+\t@$(MKDIR_P) $(builddir)/obj\r\n+\t@$(top_srcdir)/share/genbuild.sh \"$(abs_top_builddir)/src/obj/build.h\" \\\r\n+\t  \"$(abs_top_srcdir)\"\r\n+libbitcoin_util_a-clientversion.$(OBJEXT): obj/build.h\r\n+\r\n+# server: shared between bitcoind and bitcoin-qt\r\n+libbitcoin_server_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(MINIUPNPC_CPPFLAGS) $(EVENT_CFLAGS) $(EVENT_PTHREADS_CFLAGS)\r\n+libbitcoin_server_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\r\n+libbitcoin_server_a_SOURCES = \\\r\n+  addrdb.cpp \\\r\n+  addrman.cpp \\\r\n+  bloom.cpp \\\r\n+  blockencodings.cpp \\\r\n+  chain.cpp \\\r\n+  checkpoints.cpp \\\r\n+  consensus/tx_verify.cpp \\\r\n+  httprpc.cpp \\\r\n+  httpserver.cpp \\\r\n+  init.cpp \\\r\n+  dbwrapper.cpp \\\r\n+  merkleblock.cpp \\\r\n+  miner.cpp \\\r\n+  net.cpp \\\r\n+  net_processing.cpp \\\r\n+  noui.cpp \\\r\n+  policy/fees.cpp \\\r\n+  policy/policy.cpp \\\r\n+  policy/rbf.cpp \\\r\n+  pow.cpp \\\r\n+  rest.cpp \\\r\n+  rpc/blockchain.cpp \\\r\n+  rpc/mining.cpp \\\r\n+  rpc/misc.cpp \\\r\n+  rpc/net.cpp \\\r\n+  rpc/rawtransaction.cpp \\\r\n+  rpc/safemode.cpp \\\r\n+  rpc/server.cpp \\\r\n+  script/sigcache.cpp \\\r\n+  script/ismine.cpp \\\r\n+  timedata.cpp \\\r\n+  torcontrol.cpp \\\r\n+  txdb.cpp \\\r\n+  txmempool.cpp \\\r\n+  ui_interface.cpp \\\r\n+  validation.cpp \\\r\n+  validationinterface.cpp \\\r\n+  versionbits.cpp \\\r\n+  $(BITCOIN_CORE_H)\r\n+\r\n+if ENABLE_ZMQ\r\n+libbitcoin_zmq_a_CPPFLAGS = $(BITCOIN_INCLUDES) $(ZMQ_CFLAGS)\r\n+libbitcoin_zmq_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\r\n+libbitcoin_zmq_a_SOURCES = \\\r\n+  zmq/zmqabstractnotifier.cpp \\\r\n+  zmq/zmqnotificationinterface.cpp \\\r\n+  zmq/zmqpublishnotifier.cpp\r\n+endif\r\n+\r\n+\r\n+# wallet: shared between bitcoind and bitcoin-qt, but only linked\r\n+# when wallet enabled\r\n+libbitcoin_wallet_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\r\n+libbitcoin_wallet_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\r\n+libbitcoin_wallet_a_SOURCES = \\\r\n+  wallet/crypter.cpp \\\r\n+  wallet/db.cpp \\\r\n+  wallet/feebumper.cpp \\\r\n+  wallet/fees.cpp \\\r\n+  wallet/init.cpp \\\r\n+  wallet/rpcdump.cpp \\\r\n+  wallet/rpcwallet.cpp \\\r\n+  wallet/wallet.cpp \\\r\n+  wallet/walletdb.cpp \\\r\n+  wallet/walletutil.cpp \\\r\n+  $(BITCOIN_CORE_H)\r\n+\r\n+# crypto primitives library\r\n+crypto_libbitcoin_crypto_a_CPPFLAGS = $(AM_CPPFLAGS)\r\n+crypto_libbitcoin_crypto_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\r\n+crypto_libbitcoin_crypto_a_SOURCES = \\\r\n+  crypto/aes.cpp \\\r\n+  crypto/aes.h \\\r\n+  crypto/chacha20.h \\\r\n+  crypto/chacha20.cpp \\\r\n+  crypto/common.h \\\r\n+  crypto/hmac_sha256.cpp \\\r\n+  crypto/hmac_sha256.h \\\r\n+  crypto/hmac_sha512.cpp \\\r\n+  crypto/hmac_sha512.h \\\r\n+  crypto/ripemd160.cpp \\\r\n+  crypto/ripemd160.h \\\r\n+  crypto/sha1.cpp \\\r\n+  crypto/sha1.h \\\r\n+  crypto/sha256.cpp \\\r\n+  crypto/sha256.h \\\r\n+  crypto/sha512.cpp \\\r\n+  crypto/sha512.h\r\n+\r\n+if USE_ASM\r\n+crypto_libbitcoin_crypto_a_SOURCES += crypto/sha256_sse4.cpp\r\n+endif\r\n+\r\n+# consensus: shared between all executables that validate any consensus rules.\r\n+libbitcoin_consensus_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\r\n+libbitcoin_consensus_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\r\n+libbitcoin_consensus_a_SOURCES = \\\r\n+  amount.h \\\r\n+  arith_uint256.cpp \\\r\n+  arith_uint256.h \\\r\n+  consensus/merkle.cpp \\\r\n+  consensus/merkle.h \\\r\n+  consensus/params.h \\\r\n+  consensus/validation.h \\\r\n+  crypto/cryptonight.c \\\r\n+  crypto/cryptonight.h \\\r\n+  crypto/aesb.c \\\r\n+  crypto/c_skein.c \\\r\n+  crypto/c_skein.h \\\r\n+  crypto/c_jh.c \\\r\n+  crypto/c_jh.h \\\r\n+  crypto/c_blake256.c \\\r\n+  crypto/c_blake256.h \\\r\n+  crypto/c_groestl.c \\\r\n+  crypto/c_groestl.h \\\r\n+  crypto/groestl_tables.h \\\r\n+  crypto/c_keccak.c \\\r\n+  crypto/c_keccak.h \\\r\n+  crypto/oaes_lib.c \\\r\n+  crypto/oaes_lib.h \\\r\n+  crypto/oaes_config.h \\\r\n+  crypto/types.h \\\r\n+  hash.cpp \\\r\n+  hash.h \\\r\n+  prevector.h \\\r\n+  primitives/block.cpp \\\r\n+  primitives/block.h \\\r\n+  primitives/transaction.cpp \\\r\n+  primitives/transaction.h \\\r\n+  pubkey.cpp \\\r\n+  pubkey.h \\\r\n+  script/bitcoinconsensus.cpp \\\r\n+  script/interpreter.cpp \\\r\n+  script/interpreter.h \\\r\n+  script/script.cpp \\\r\n+  script/script.h \\\r\n+  script/script_error.cpp \\\r\n+  script/script_error.h \\\r\n+  serialize.h \\\r\n+  tinyformat.h \\\r\n+  uint256.cpp \\\r\n+  uint256.h \\\r\n+  utilstrencodings.cpp \\\r\n+  utilstrencodings.h \\\r\n+  version.h\r\n+\r\n+# common: shared between bitcoind, and bitcoin-qt and non-server tools\r\n+libbitcoin_common_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\r\n+libbitcoin_common_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\r\n+libbitcoin_common_a_SOURCES = \\\r\n+  base58.cpp \\\r\n+  bech32.cpp \\\r\n+  chainparams.cpp \\\r\n+  coins.cpp \\\r\n+  compressor.cpp \\\r\n+  core_read.cpp \\\r\n+  core_write.cpp \\\r\n+  key.cpp \\\r\n+  keystore.cpp \\\r\n+  netaddress.cpp \\\r\n+  netbase.cpp \\\r\n+  policy/feerate.cpp \\\r\n+  protocol.cpp \\\r\n+  scheduler.cpp \\\r\n+  script/sign.cpp \\\r\n+  script/standard.cpp \\\r\n+  warnings.cpp \\\r\n+  $(BITCOIN_CORE_H)\r\n+\r\n+# util: shared between all executables.\r\n+# This library *must* be included to make sure that the glibc\r\n+# backward-compatibility objects and their sanity checks are linked.\r\n+libbitcoin_util_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\r\n+libbitcoin_util_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\r\n+libbitcoin_util_a_SOURCES = \\\r\n+  support/lockedpool.cpp \\\r\n+  chainparamsbase.cpp \\\r\n+  clientversion.cpp \\\r\n+  compat/glibc_sanity.cpp \\\r\n+  compat/glibcxx_sanity.cpp \\\r\n+  compat/strnlen.cpp \\\r\n+  fs.cpp \\\r\n+  random.cpp \\\r\n+  rpc/protocol.cpp \\\r\n+  support/cleanse.cpp \\\r\n+  sync.cpp \\\r\n+  threadinterrupt.cpp \\\r\n+  util.cpp \\\r\n+  utilmoneystr.cpp \\\r\n+  utilstrencodings.cpp \\\r\n+  utiltime.cpp \\\r\n+  $(BITCOIN_CORE_H)\r\n+\r\n+if GLIBC_BACK_COMPAT\r\n+libbitcoin_util_a_SOURCES += compat/glibc_compat.cpp\r\n+endif\r\n+\r\n+# cli: shared between bitcoin-cli and bitcoin-qt\r\n+libbitcoin_cli_a_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\r\n+libbitcoin_cli_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\r\n+libbitcoin_cli_a_SOURCES = \\\r\n+  rpc/client.cpp \\\r\n+  $(BITCOIN_CORE_H)\r\n+\r\n+nodist_libbitcoin_util_a_SOURCES = $(srcdir)/obj/build.h\r\n+#\r\n+\r\n+# bitcoind binary #\r\n+bitcoind_SOURCES = bitcoind.cpp\r\n+bitcoind_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\r\n+bitcoind_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\r\n+bitcoind_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\r\n+\r\n+if TARGET_WINDOWS\r\n+bitcoind_SOURCES += bitcoind-res.rc\r\n+endif\r\n+\r\n+bitcoind_LDADD = \\\r\n+  $(LIBBITCOIN_SERVER) \\\r\n+  $(LIBBITCOIN_COMMON) \\\r\n+  $(LIBUNIVALUE) \\\r\n+  $(LIBBITCOIN_UTIL) \\\r\n+  $(LIBBITCOIN_WALLET) \\\r\n+  $(LIBBITCOIN_ZMQ) \\\r\n+  $(LIBBITCOIN_CONSENSUS) \\\r\n+  $(LIBBITCOIN_CRYPTO) \\\r\n+  $(LIBLEVELDB) \\\r\n+  $(LIBLEVELDB_SSE42) \\\r\n+  $(LIBMEMENV) \\\r\n+  $(LIBSECP256K1)\r\n+\r\n+bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS)\r\n+\r\n+# bitcoin-cli binary #\r\n+bitcoin_cli_SOURCES = bitcoin-cli.cpp\r\n+bitcoin_cli_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES) $(EVENT_CFLAGS)\r\n+bitcoin_cli_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\r\n+bitcoin_cli_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\r\n+\r\n+if TARGET_WINDOWS\r\n+bitcoin_cli_SOURCES += bitcoin-cli-res.rc\r\n+endif\r\n+\r\n+bitcoin_cli_LDADD = \\\r\n+  $(LIBBITCOIN_CLI) \\\r\n+  $(LIBUNIVALUE) \\\r\n+  $(LIBBITCOIN_UTIL) \\\r\n+  $(LIBBITCOIN_CRYPTO)\r\n+\r\n+bitcoin_cli_LDADD += $(BOOST_LIBS) $(SSL_LIBS) $(CRYPTO_LIBS) $(EVENT_LIBS)\r\n+#\r\n+\r\n+# bitcoin-tx binary #\r\n+bitcoin_tx_SOURCES = bitcoin-tx.cpp\r\n+bitcoin_tx_CPPFLAGS = $(AM_CPPFLAGS) $(BITCOIN_INCLUDES)\r\n+bitcoin_tx_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\r\n+bitcoin_tx_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\r\n+\r\n+if TARGET_WINDOWS\r\n+bitcoin_tx_SOURCES += bitcoin-tx-res.rc\r\n+endif\r\n+\r\n+bitcoin_tx_LDADD = \\\r\n+  $(LIBUNIVALUE) \\\r\n+  $(LIBBITCOIN_COMMON) \\\r\n+  $(LIBBITCOIN_UTIL) \\\r\n+  $(LIBBITCOIN_CONSENSUS) \\\r\n+  $(LIBBITCOIN_CRYPTO) \\\r\n+  $(LIBSECP256K1)\r\n+\r\n+bitcoin_tx_LDADD += $(BOOST_LIBS) $(CRYPTO_LIBS)\r\n+#\r\n+\r\n+# bitcoinconsensus library #\r\n+if BUILD_BITCOIN_LIBS\r\n+include_HEADERS = script/bitcoinconsensus.h\r\n+libbitcoinconsensus_la_SOURCES = $(crypto_libbitcoin_crypto_a_SOURCES) $(libbitcoin_consensus_a_SOURCES)\r\n+\r\n+if GLIBC_BACK_COMPAT\r\n+  libbitcoinconsensus_la_SOURCES += compat/glibc_compat.cpp\r\n+endif\r\n+\r\n+libbitcoinconsensus_la_LDFLAGS = $(AM_LDFLAGS) -no-undefined $(RELDFLAGS)\r\n+libbitcoinconsensus_la_LIBADD = $(LIBSECP256K1)\r\n+libbitcoinconsensus_la_CPPFLAGS = $(AM_CPPFLAGS) -I$(builddir)/obj -I$(srcdir)/secp256k1/include -DBUILD_BITCOIN_INTERNAL\r\n+libbitcoinconsensus_la_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\r\n+\r\n+endif\r\n+#\r\n+\r\n+CTAES_DIST =  crypto/ctaes/bench.c\r\n+CTAES_DIST += crypto/ctaes/ctaes.c\r\n+CTAES_DIST += crypto/ctaes/ctaes.h\r\n+CTAES_DIST += crypto/ctaes/README.md\r\n+CTAES_DIST += crypto/ctaes/test.c\r\n+\r\n+CLEANFILES = $(EXTRA_LIBRARIES)\r\n+\r\n+CLEANFILES += *.gcda *.gcno\r\n+CLEANFILES += compat/*.gcda compat/*.gcno\r\n+CLEANFILES += consensus/*.gcda consensus/*.gcno\r\n+CLEANFILES += crypto/*.gcda crypto/*.gcno\r\n+CLEANFILES += policy/*.gcda policy/*.gcno\r\n+CLEANFILES += primitives/*.gcda primitives/*.gcno\r\n+CLEANFILES += script/*.gcda script/*.gcno\r\n+CLEANFILES += support/*.gcda support/*.gcno\r\n+CLEANFILES += univalue/*.gcda univalue/*.gcno\r\n+CLEANFILES += wallet/*.gcda wallet/*.gcno\r\n+CLEANFILES += wallet/test/*.gcda wallet/test/*.gcno\r\n+CLEANFILES += zmq/*.gcda zmq/*.gcno\r\n+CLEANFILES += obj/build.h\r\n+\r\n+EXTRA_DIST = $(CTAES_DIST)\r\n+\r\n+\r\n+config/bitcoin-config.h: config/stamp-h1\r\n+\t@$(MAKE) -C $(top_builddir) $(subdir)/$(@)\r\n+config/stamp-h1: $(top_srcdir)/$(subdir)/config/bitcoin-config.h.in $(top_builddir)/config.status\r\n+\t$(AM_V_at)$(MAKE) -C $(top_builddir) $(subdir)/$(@)\r\n+$(top_srcdir)/$(subdir)/config/bitcoin-config.h.in:  $(am__configure_deps)\r\n+\t$(AM_V_at)$(MAKE) -C $(top_srcdir) $(subdir)/config/bitcoin-config.h.in\r\n+\r\n+clean-local:\r\n+\t-$(MAKE) -C secp256k1 clean\r\n+\t-$(MAKE) -C univalue clean\r\n+\t-rm -f leveldb/*/*.gcda leveldb/*/*.gcno leveldb/helpers/memenv/*.gcda leveldb/helpers/memenv/*.gcno\r\n+\t-rm -f config.h\r\n+\t-rm -rf test/__pycache__\r\n+\r\n+.rc.o:\r\n+\t@test -f $(WINDRES)\r\n+\t## FIXME: How to get the appropriate modulename_CPPFLAGS in here?\r\n+\t$(AM_V_GEN) $(WINDRES) $(DEFS) $(DEFAULT_INCLUDES) $(INCLUDES) $(CPPFLAGS) -DWINDRES_PREPROC -i $< -o $@\r\n+\r\n+check-symbols: $(bin_PROGRAMS)\r\n+if GLIBC_BACK_COMPAT\r\n+\t@echo \"Checking glibc back compat...\"\r\n+\t$(AM_V_at) READELF=$(READELF) CPPFILT=$(CPPFILT) $(top_srcdir)/contrib/devtools/symbol-check.py < $(bin_PROGRAMS)\r\n+endif\r\n+\r\n+check-security: $(bin_PROGRAMS)\r\n+if HARDEN\r\n+\t@echo \"Checking binary security...\"\r\n+\t$(AM_V_at) READELF=$(READELF) OBJDUMP=$(OBJDUMP) $(top_srcdir)/contrib/devtools/security-check.py < $(bin_PROGRAMS)\r\n+endif\r\n+\r\n+%.pb.cc %.pb.h: %.proto\r\n+\t@test -f $(PROTOC)\r\n+\t$(AM_V_GEN) $(PROTOC) --cpp_out=$(@D) --proto_path=$(<D) $<\r\n+\r\n+if EMBEDDED_LEVELDB\r\n+include Makefile.leveldb.include\r\n+endif\r\n+\r\n+if ENABLE_TESTS\r\n+include Makefile.test.include\r\n+endif\r\n+\r\n+if ENABLE_BENCH\r\n+include Makefile.bench.include\r\n+endif\r\n+\r\n+if ENABLE_QT\r\n+include Makefile.qt.include\r\n+endif\r\n+\r\n+if ENABLE_QT_TESTS\r\n+include Makefile.qttest.include\r\n+endif\r"
      },
      {
        "sha": "1d937f31ecad140a5ac6aae2aa2dc02e83fbb674",
        "filename": "src/test/blockencodings_tests.cpp",
        "status": "modified",
        "additions": 343,
        "deletions": 343,
        "changes": 686,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/blockencodings_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/blockencodings_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/blockencodings_tests.cpp?ref=b8461f9655ceec64a3bb3835b12b51f2b5ac42e6",
        "patch": "@@ -1,343 +1,343 @@\n-// Copyright (c) 2011-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <blockencodings.h>\n-#include <consensus/merkle.h>\n-#include <chainparams.h>\n-#include <random.h>\n-\n-#include <test/test_bitcoin.h>\n-\n-#include <boost/test/unit_test.hpp>\n-\n-std::vector<std::pair<uint256, CTransactionRef>> extra_txn;\n-\n-struct RegtestingSetup : public TestingSetup {\n-    RegtestingSetup() : TestingSetup(CBaseChainParams::REGTEST) {}\n-};\n-\n-BOOST_FIXTURE_TEST_SUITE(blockencodings_tests, RegtestingSetup)\n-\n-static CBlock BuildBlockTestCase() {\n-    CBlock block;\n-    CMutableTransaction tx;\n-    tx.vin.resize(1);\n-    tx.vin[0].scriptSig.resize(10);\n-    tx.vout.resize(1);\n-    tx.vout[0].nValue = 42;\n-\n-    block.vtx.resize(3);\n-    block.vtx[0] = MakeTransactionRef(tx);\n-    block.nVersion = 42;\n-    block.hashPrevBlock = InsecureRand256();\n-    block.nBits = 0x207fffff;\n-\n-    tx.vin[0].prevout.hash = InsecureRand256();\n-    tx.vin[0].prevout.n = 0;\n-    block.vtx[1] = MakeTransactionRef(tx);\n-\n-    tx.vin.resize(10);\n-    for (size_t i = 0; i < tx.vin.size(); i++) {\n-        tx.vin[i].prevout.hash = InsecureRand256();\n-        tx.vin[i].prevout.n = 0;\n-    }\n-    block.vtx[2] = MakeTransactionRef(tx);\n-\n-    bool mutated;\n-    block.hashMerkleRoot = BlockMerkleRoot(block, &mutated);\n-    assert(!mutated);\n-    while (!CheckProofOfWork(block.GetHash(), block.nBits, Params().GetConsensus())) ++block.nNonce;\n-    return block;\n-}\n-\n-// Number of shared use_counts we expect for a tx we haven't touched\n-// == 2 (mempool + our copy from the GetSharedTx call)\n-#define SHARED_TX_OFFSET 2\n-\n-BOOST_AUTO_TEST_CASE(SimpleRoundTripTest)\n-{\n-    CTxMemPool pool;\n-    TestMemPoolEntryHelper entry;\n-    CBlock block(BuildBlockTestCase());\n-\n-    pool.addUnchecked(block.vtx[2]->GetHash(), entry.FromTx(*block.vtx[2]));\n-    LOCK(pool.cs);\n-    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n-\n-    // Do a simple ShortTxIDs RT\n-    {\n-        CBlockHeaderAndShortTxIDs shortIDs(block, true);\n-\n-        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n-        stream << shortIDs;\n-\n-        CBlockHeaderAndShortTxIDs shortIDs2;\n-        stream >> shortIDs2;\n-\n-        PartiallyDownloadedBlock partialBlock(&pool);\n-        BOOST_CHECK(partialBlock.InitData(shortIDs2, extra_txn) == READ_STATUS_OK);\n-        BOOST_CHECK( partialBlock.IsTxAvailable(0));\n-        BOOST_CHECK(!partialBlock.IsTxAvailable(1));\n-        BOOST_CHECK( partialBlock.IsTxAvailable(2));\n-\n-        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n-\n-        size_t poolSize = pool.size();\n-        pool.removeRecursive(*block.vtx[2]);\n-        BOOST_CHECK_EQUAL(pool.size(), poolSize - 1);\n-\n-        CBlock block2;\n-        {\n-            PartiallyDownloadedBlock tmp = partialBlock;\n-            BOOST_CHECK(partialBlock.FillBlock(block2, {}) == READ_STATUS_INVALID); // No transactions\n-            partialBlock = tmp;\n-        }\n-\n-        // Wrong transaction\n-        {\n-            PartiallyDownloadedBlock tmp = partialBlock;\n-            partialBlock.FillBlock(block2, {block.vtx[2]}); // Current implementation doesn't check txn here, but don't require that\n-            partialBlock = tmp;\n-        }\n-        bool mutated;\n-        BOOST_CHECK(block.hashMerkleRoot != BlockMerkleRoot(block2, &mutated));\n-\n-        CBlock block3;\n-        BOOST_CHECK(partialBlock.FillBlock(block3, {block.vtx[1]}) == READ_STATUS_OK);\n-        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block3.GetHash().ToString());\n-        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block3, &mutated).ToString());\n-        BOOST_CHECK(!mutated);\n-    }\n-}\n-\n-class TestHeaderAndShortIDs {\n-    // Utility to encode custom CBlockHeaderAndShortTxIDs\n-public:\n-    CBlockHeader header;\n-    uint64_t nonce;\n-    std::vector<uint64_t> shorttxids;\n-    std::vector<PrefilledTransaction> prefilledtxn;\n-\n-    explicit TestHeaderAndShortIDs(const CBlockHeaderAndShortTxIDs& orig) {\n-        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n-        stream << orig;\n-        stream >> *this;\n-    }\n-    explicit TestHeaderAndShortIDs(const CBlock& block) :\n-        TestHeaderAndShortIDs(CBlockHeaderAndShortTxIDs(block, true)) {}\n-\n-    uint64_t GetShortID(const uint256& txhash) const {\n-        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n-        stream << *this;\n-        CBlockHeaderAndShortTxIDs base;\n-        stream >> base;\n-        return base.GetShortID(txhash);\n-    }\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITE(header);\n-        READWRITE(nonce);\n-        size_t shorttxids_size = shorttxids.size();\n-        READWRITE(VARINT(shorttxids_size));\n-        shorttxids.resize(shorttxids_size);\n-        for (size_t i = 0; i < shorttxids.size(); i++) {\n-            uint32_t lsb = shorttxids[i] & 0xffffffff;\n-            uint16_t msb = (shorttxids[i] >> 32) & 0xffff;\n-            READWRITE(lsb);\n-            READWRITE(msb);\n-            shorttxids[i] = (uint64_t(msb) << 32) | uint64_t(lsb);\n-        }\n-        READWRITE(prefilledtxn);\n-    }\n-};\n-\n-BOOST_AUTO_TEST_CASE(NonCoinbasePreforwardRTTest)\n-{\n-    CTxMemPool pool;\n-    TestMemPoolEntryHelper entry;\n-    CBlock block(BuildBlockTestCase());\n-\n-    pool.addUnchecked(block.vtx[2]->GetHash(), entry.FromTx(*block.vtx[2]));\n-    LOCK(pool.cs);\n-    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n-\n-    uint256 txhash;\n-\n-    // Test with pre-forwarding tx 1, but not coinbase\n-    {\n-        TestHeaderAndShortIDs shortIDs(block);\n-        shortIDs.prefilledtxn.resize(1);\n-        shortIDs.prefilledtxn[0] = {1, block.vtx[1]};\n-        shortIDs.shorttxids.resize(2);\n-        shortIDs.shorttxids[0] = shortIDs.GetShortID(block.vtx[0]->GetHash());\n-        shortIDs.shorttxids[1] = shortIDs.GetShortID(block.vtx[2]->GetHash());\n-\n-        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n-        stream << shortIDs;\n-\n-        CBlockHeaderAndShortTxIDs shortIDs2;\n-        stream >> shortIDs2;\n-\n-        PartiallyDownloadedBlock partialBlock(&pool);\n-        BOOST_CHECK(partialBlock.InitData(shortIDs2, extra_txn) == READ_STATUS_OK);\n-        BOOST_CHECK(!partialBlock.IsTxAvailable(0));\n-        BOOST_CHECK( partialBlock.IsTxAvailable(1));\n-        BOOST_CHECK( partialBlock.IsTxAvailable(2));\n-\n-        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n-\n-        CBlock block2;\n-        {\n-            PartiallyDownloadedBlock tmp = partialBlock;\n-            BOOST_CHECK(partialBlock.FillBlock(block2, {}) == READ_STATUS_INVALID); // No transactions\n-            partialBlock = tmp;\n-        }\n-\n-        // Wrong transaction\n-        {\n-            PartiallyDownloadedBlock tmp = partialBlock;\n-            partialBlock.FillBlock(block2, {block.vtx[1]}); // Current implementation doesn't check txn here, but don't require that\n-            partialBlock = tmp;\n-        }\n-        bool mutated;\n-        BOOST_CHECK(block.hashMerkleRoot != BlockMerkleRoot(block2, &mutated));\n-\n-        CBlock block3;\n-        PartiallyDownloadedBlock partialBlockCopy = partialBlock;\n-        BOOST_CHECK(partialBlock.FillBlock(block3, {block.vtx[0]}) == READ_STATUS_OK);\n-        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block3.GetHash().ToString());\n-        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block3, &mutated).ToString());\n-        BOOST_CHECK(!mutated);\n-\n-        txhash = block.vtx[2]->GetHash();\n-        block.vtx.clear();\n-        block2.vtx.clear();\n-        block3.vtx.clear();\n-        BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1); // + 1 because of partialBlockCopy.\n-    }\n-    BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n-}\n-\n-BOOST_AUTO_TEST_CASE(SufficientPreforwardRTTest)\n-{\n-    CTxMemPool pool;\n-    TestMemPoolEntryHelper entry;\n-    CBlock block(BuildBlockTestCase());\n-\n-    pool.addUnchecked(block.vtx[1]->GetHash(), entry.FromTx(*block.vtx[1]));\n-    LOCK(pool.cs);\n-    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n-\n-    uint256 txhash;\n-\n-    // Test with pre-forwarding coinbase + tx 2 with tx 1 in mempool\n-    {\n-        TestHeaderAndShortIDs shortIDs(block);\n-        shortIDs.prefilledtxn.resize(2);\n-        shortIDs.prefilledtxn[0] = {0, block.vtx[0]};\n-        shortIDs.prefilledtxn[1] = {1, block.vtx[2]}; // id == 1 as it is 1 after index 1\n-        shortIDs.shorttxids.resize(1);\n-        shortIDs.shorttxids[0] = shortIDs.GetShortID(block.vtx[1]->GetHash());\n-\n-        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n-        stream << shortIDs;\n-\n-        CBlockHeaderAndShortTxIDs shortIDs2;\n-        stream >> shortIDs2;\n-\n-        PartiallyDownloadedBlock partialBlock(&pool);\n-        BOOST_CHECK(partialBlock.InitData(shortIDs2, extra_txn) == READ_STATUS_OK);\n-        BOOST_CHECK( partialBlock.IsTxAvailable(0));\n-        BOOST_CHECK( partialBlock.IsTxAvailable(1));\n-        BOOST_CHECK( partialBlock.IsTxAvailable(2));\n-\n-        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\n-\n-        CBlock block2;\n-        PartiallyDownloadedBlock partialBlockCopy = partialBlock;\n-        BOOST_CHECK(partialBlock.FillBlock(block2, {}) == READ_STATUS_OK);\n-        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block2.GetHash().ToString());\n-        bool mutated;\n-        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block2, &mutated).ToString());\n-        BOOST_CHECK(!mutated);\n-\n-        txhash = block.vtx[1]->GetHash();\n-        block.vtx.clear();\n-        block2.vtx.clear();\n-        BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1); // + 1 because of partialBlockCopy.\n-    }\n-    BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\n-}\n-\n-BOOST_AUTO_TEST_CASE(EmptyBlockRoundTripTest)\n-{\n-    CTxMemPool pool;\n-    CMutableTransaction coinbase;\n-    coinbase.vin.resize(1);\n-    coinbase.vin[0].scriptSig.resize(10);\n-    coinbase.vout.resize(1);\n-    coinbase.vout[0].nValue = 42;\n-\n-    CBlock block;\n-    block.vtx.resize(1);\n-    block.vtx[0] = MakeTransactionRef(std::move(coinbase));\n-    block.nVersion = 42;\n-    block.hashPrevBlock = InsecureRand256();\n-    block.nBits = 0x207fffff;\n-\n-    bool mutated;\n-    block.hashMerkleRoot = BlockMerkleRoot(block, &mutated);\n-    assert(!mutated);\n-    while (!CheckProofOfWork(block.GetHash(), block.nBits, Params().GetConsensus())) ++block.nNonce;\n-\n-    // Test simple header round-trip with only coinbase\n-    {\n-        CBlockHeaderAndShortTxIDs shortIDs(block, false);\n-\n-        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n-        stream << shortIDs;\n-\n-        CBlockHeaderAndShortTxIDs shortIDs2;\n-        stream >> shortIDs2;\n-\n-        PartiallyDownloadedBlock partialBlock(&pool);\n-        BOOST_CHECK(partialBlock.InitData(shortIDs2, extra_txn) == READ_STATUS_OK);\n-        BOOST_CHECK(partialBlock.IsTxAvailable(0));\n-\n-        CBlock block2;\n-        std::vector<CTransactionRef> vtx_missing;\n-        BOOST_CHECK(partialBlock.FillBlock(block2, vtx_missing) == READ_STATUS_OK);\n-        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block2.GetHash().ToString());\n-        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block2, &mutated).ToString());\n-        BOOST_CHECK(!mutated);\n-    }\n-}\n-\n-BOOST_AUTO_TEST_CASE(TransactionsRequestSerializationTest) {\n-    BlockTransactionsRequest req1;\n-    req1.blockhash = InsecureRand256();\n-    req1.indexes.resize(4);\n-    req1.indexes[0] = 0;\n-    req1.indexes[1] = 1;\n-    req1.indexes[2] = 3;\n-    req1.indexes[3] = 4;\n-\n-    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\n-    stream << req1;\n-\n-    BlockTransactionsRequest req2;\n-    stream >> req2;\n-\n-    BOOST_CHECK_EQUAL(req1.blockhash.ToString(), req2.blockhash.ToString());\n-    BOOST_CHECK_EQUAL(req1.indexes.size(), req2.indexes.size());\n-    BOOST_CHECK_EQUAL(req1.indexes[0], req2.indexes[0]);\n-    BOOST_CHECK_EQUAL(req1.indexes[1], req2.indexes[1]);\n-    BOOST_CHECK_EQUAL(req1.indexes[2], req2.indexes[2]);\n-    BOOST_CHECK_EQUAL(req1.indexes[3], req2.indexes[3]);\n-}\n-\n-BOOST_AUTO_TEST_SUITE_END()\n+// Copyright (c) 2011-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <blockencodings.h>\r\n+#include <consensus/merkle.h>\r\n+#include <chainparams.h>\r\n+#include <random.h>\r\n+\r\n+#include <test/test_bitcoin.h>\r\n+\r\n+#include <boost/test/unit_test.hpp>\r\n+\r\n+std::vector<std::pair<uint256, CTransactionRef>> extra_txn;\r\n+\r\n+struct RegtestingSetup : public TestingSetup {\r\n+    RegtestingSetup() : TestingSetup(CBaseChainParams::REGTEST) {}\r\n+};\r\n+\r\n+BOOST_FIXTURE_TEST_SUITE(blockencodings_tests, RegtestingSetup)\r\n+\r\n+static CBlock BuildBlockTestCase() {\r\n+    CBlock block;\r\n+    CMutableTransaction tx;\r\n+    tx.vin.resize(1);\r\n+    tx.vin[0].scriptSig.resize(10);\r\n+    tx.vout.resize(1);\r\n+    tx.vout[0].nValue = 42;\r\n+\r\n+    block.vtx.resize(3);\r\n+    block.vtx[0] = MakeTransactionRef(tx);\r\n+    block.nVersion = 42;\r\n+    block.hashPrevBlock = InsecureRand256();\r\n+    block.nBits = 0x207fffff;\r\n+\r\n+    tx.vin[0].prevout.hash = InsecureRand256();\r\n+    tx.vin[0].prevout.n = 0;\r\n+    block.vtx[1] = MakeTransactionRef(tx);\r\n+\r\n+    tx.vin.resize(10);\r\n+    for (size_t i = 0; i < tx.vin.size(); i++) {\r\n+        tx.vin[i].prevout.hash = InsecureRand256();\r\n+        tx.vin[i].prevout.n = 0;\r\n+    }\r\n+    block.vtx[2] = MakeTransactionRef(tx);\r\n+\r\n+    bool mutated;\r\n+    block.hashMerkleRoot = BlockMerkleRoot(block, &mutated);\r\n+    assert(!mutated);\r\n+    while (!CheckProofOfWork(block.GetHash(), block.nBits, Params().GetConsensus(), block.IsBtvBranched())) ++block.nNonce;\r\n+    return block;\r\n+}\r\n+\r\n+// Number of shared use_counts we expect for a tx we haven't touched\r\n+// == 2 (mempool + our copy from the GetSharedTx call)\r\n+#define SHARED_TX_OFFSET 2\r\n+\r\n+BOOST_AUTO_TEST_CASE(SimpleRoundTripTest)\r\n+{\r\n+    CTxMemPool pool;\r\n+    TestMemPoolEntryHelper entry;\r\n+    CBlock block(BuildBlockTestCase());\r\n+\r\n+    pool.addUnchecked(block.vtx[2]->GetHash(), entry.FromTx(*block.vtx[2]));\r\n+    LOCK(pool.cs);\r\n+    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\r\n+\r\n+    // Do a simple ShortTxIDs RT\r\n+    {\r\n+        CBlockHeaderAndShortTxIDs shortIDs(block, true);\r\n+\r\n+        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\r\n+        stream << shortIDs;\r\n+\r\n+        CBlockHeaderAndShortTxIDs shortIDs2;\r\n+        stream >> shortIDs2;\r\n+\r\n+        PartiallyDownloadedBlock partialBlock(&pool);\r\n+        BOOST_CHECK(partialBlock.InitData(shortIDs2, extra_txn) == READ_STATUS_OK);\r\n+        BOOST_CHECK( partialBlock.IsTxAvailable(0));\r\n+        BOOST_CHECK(!partialBlock.IsTxAvailable(1));\r\n+        BOOST_CHECK( partialBlock.IsTxAvailable(2));\r\n+\r\n+        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\r\n+\r\n+        size_t poolSize = pool.size();\r\n+        pool.removeRecursive(*block.vtx[2]);\r\n+        BOOST_CHECK_EQUAL(pool.size(), poolSize - 1);\r\n+\r\n+        CBlock block2;\r\n+        {\r\n+            PartiallyDownloadedBlock tmp = partialBlock;\r\n+            BOOST_CHECK(partialBlock.FillBlock(block2, {}) == READ_STATUS_INVALID); // No transactions\r\n+            partialBlock = tmp;\r\n+        }\r\n+\r\n+        // Wrong transaction\r\n+        {\r\n+            PartiallyDownloadedBlock tmp = partialBlock;\r\n+            partialBlock.FillBlock(block2, {block.vtx[2]}); // Current implementation doesn't check txn here, but don't require that\r\n+            partialBlock = tmp;\r\n+        }\r\n+        bool mutated;\r\n+        BOOST_CHECK(block.hashMerkleRoot != BlockMerkleRoot(block2, &mutated));\r\n+\r\n+        CBlock block3;\r\n+        BOOST_CHECK(partialBlock.FillBlock(block3, {block.vtx[1]}) == READ_STATUS_OK);\r\n+        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block3.GetHash().ToString());\r\n+        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block3, &mutated).ToString());\r\n+        BOOST_CHECK(!mutated);\r\n+    }\r\n+}\r\n+\r\n+class TestHeaderAndShortIDs {\r\n+    // Utility to encode custom CBlockHeaderAndShortTxIDs\r\n+public:\r\n+    CBlockHeader header;\r\n+    uint64_t nonce;\r\n+    std::vector<uint64_t> shorttxids;\r\n+    std::vector<PrefilledTransaction> prefilledtxn;\r\n+\r\n+    explicit TestHeaderAndShortIDs(const CBlockHeaderAndShortTxIDs& orig) {\r\n+        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\r\n+        stream << orig;\r\n+        stream >> *this;\r\n+    }\r\n+    explicit TestHeaderAndShortIDs(const CBlock& block) :\r\n+        TestHeaderAndShortIDs(CBlockHeaderAndShortTxIDs(block, true)) {}\r\n+\r\n+    uint64_t GetShortID(const uint256& txhash) const {\r\n+        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\r\n+        stream << *this;\r\n+        CBlockHeaderAndShortTxIDs base;\r\n+        stream >> base;\r\n+        return base.GetShortID(txhash);\r\n+    }\r\n+\r\n+    ADD_SERIALIZE_METHODS;\r\n+\r\n+    template <typename Stream, typename Operation>\r\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\r\n+        READWRITE(header);\r\n+        READWRITE(nonce);\r\n+        size_t shorttxids_size = shorttxids.size();\r\n+        READWRITE(VARINT(shorttxids_size));\r\n+        shorttxids.resize(shorttxids_size);\r\n+        for (size_t i = 0; i < shorttxids.size(); i++) {\r\n+            uint32_t lsb = shorttxids[i] & 0xffffffff;\r\n+            uint16_t msb = (shorttxids[i] >> 32) & 0xffff;\r\n+            READWRITE(lsb);\r\n+            READWRITE(msb);\r\n+            shorttxids[i] = (uint64_t(msb) << 32) | uint64_t(lsb);\r\n+        }\r\n+        READWRITE(prefilledtxn);\r\n+    }\r\n+};\r\n+\r\n+BOOST_AUTO_TEST_CASE(NonCoinbasePreforwardRTTest)\r\n+{\r\n+    CTxMemPool pool;\r\n+    TestMemPoolEntryHelper entry;\r\n+    CBlock block(BuildBlockTestCase());\r\n+\r\n+    pool.addUnchecked(block.vtx[2]->GetHash(), entry.FromTx(*block.vtx[2]));\r\n+    LOCK(pool.cs);\r\n+    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\r\n+\r\n+    uint256 txhash;\r\n+\r\n+    // Test with pre-forwarding tx 1, but not coinbase\r\n+    {\r\n+        TestHeaderAndShortIDs shortIDs(block);\r\n+        shortIDs.prefilledtxn.resize(1);\r\n+        shortIDs.prefilledtxn[0] = {1, block.vtx[1]};\r\n+        shortIDs.shorttxids.resize(2);\r\n+        shortIDs.shorttxids[0] = shortIDs.GetShortID(block.vtx[0]->GetHash());\r\n+        shortIDs.shorttxids[1] = shortIDs.GetShortID(block.vtx[2]->GetHash());\r\n+\r\n+        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\r\n+        stream << shortIDs;\r\n+\r\n+        CBlockHeaderAndShortTxIDs shortIDs2;\r\n+        stream >> shortIDs2;\r\n+\r\n+        PartiallyDownloadedBlock partialBlock(&pool);\r\n+        BOOST_CHECK(partialBlock.InitData(shortIDs2, extra_txn) == READ_STATUS_OK);\r\n+        BOOST_CHECK(!partialBlock.IsTxAvailable(0));\r\n+        BOOST_CHECK( partialBlock.IsTxAvailable(1));\r\n+        BOOST_CHECK( partialBlock.IsTxAvailable(2));\r\n+\r\n+        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[2]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\r\n+\r\n+        CBlock block2;\r\n+        {\r\n+            PartiallyDownloadedBlock tmp = partialBlock;\r\n+            BOOST_CHECK(partialBlock.FillBlock(block2, {}) == READ_STATUS_INVALID); // No transactions\r\n+            partialBlock = tmp;\r\n+        }\r\n+\r\n+        // Wrong transaction\r\n+        {\r\n+            PartiallyDownloadedBlock tmp = partialBlock;\r\n+            partialBlock.FillBlock(block2, {block.vtx[1]}); // Current implementation doesn't check txn here, but don't require that\r\n+            partialBlock = tmp;\r\n+        }\r\n+        bool mutated;\r\n+        BOOST_CHECK(block.hashMerkleRoot != BlockMerkleRoot(block2, &mutated));\r\n+\r\n+        CBlock block3;\r\n+        PartiallyDownloadedBlock partialBlockCopy = partialBlock;\r\n+        BOOST_CHECK(partialBlock.FillBlock(block3, {block.vtx[0]}) == READ_STATUS_OK);\r\n+        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block3.GetHash().ToString());\r\n+        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block3, &mutated).ToString());\r\n+        BOOST_CHECK(!mutated);\r\n+\r\n+        txhash = block.vtx[2]->GetHash();\r\n+        block.vtx.clear();\r\n+        block2.vtx.clear();\r\n+        block3.vtx.clear();\r\n+        BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1); // + 1 because of partialBlockCopy.\r\n+    }\r\n+    BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(SufficientPreforwardRTTest)\r\n+{\r\n+    CTxMemPool pool;\r\n+    TestMemPoolEntryHelper entry;\r\n+    CBlock block(BuildBlockTestCase());\r\n+\r\n+    pool.addUnchecked(block.vtx[1]->GetHash(), entry.FromTx(*block.vtx[1]));\r\n+    LOCK(pool.cs);\r\n+    BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\r\n+\r\n+    uint256 txhash;\r\n+\r\n+    // Test with pre-forwarding coinbase + tx 2 with tx 1 in mempool\r\n+    {\r\n+        TestHeaderAndShortIDs shortIDs(block);\r\n+        shortIDs.prefilledtxn.resize(2);\r\n+        shortIDs.prefilledtxn[0] = {0, block.vtx[0]};\r\n+        shortIDs.prefilledtxn[1] = {1, block.vtx[2]}; // id == 1 as it is 1 after index 1\r\n+        shortIDs.shorttxids.resize(1);\r\n+        shortIDs.shorttxids[0] = shortIDs.GetShortID(block.vtx[1]->GetHash());\r\n+\r\n+        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\r\n+        stream << shortIDs;\r\n+\r\n+        CBlockHeaderAndShortTxIDs shortIDs2;\r\n+        stream >> shortIDs2;\r\n+\r\n+        PartiallyDownloadedBlock partialBlock(&pool);\r\n+        BOOST_CHECK(partialBlock.InitData(shortIDs2, extra_txn) == READ_STATUS_OK);\r\n+        BOOST_CHECK( partialBlock.IsTxAvailable(0));\r\n+        BOOST_CHECK( partialBlock.IsTxAvailable(1));\r\n+        BOOST_CHECK( partialBlock.IsTxAvailable(2));\r\n+\r\n+        BOOST_CHECK_EQUAL(pool.mapTx.find(block.vtx[1]->GetHash())->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1);\r\n+\r\n+        CBlock block2;\r\n+        PartiallyDownloadedBlock partialBlockCopy = partialBlock;\r\n+        BOOST_CHECK(partialBlock.FillBlock(block2, {}) == READ_STATUS_OK);\r\n+        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block2.GetHash().ToString());\r\n+        bool mutated;\r\n+        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block2, &mutated).ToString());\r\n+        BOOST_CHECK(!mutated);\r\n+\r\n+        txhash = block.vtx[1]->GetHash();\r\n+        block.vtx.clear();\r\n+        block2.vtx.clear();\r\n+        BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET + 1); // + 1 because of partialBlockCopy.\r\n+    }\r\n+    BOOST_CHECK_EQUAL(pool.mapTx.find(txhash)->GetSharedTx().use_count(), SHARED_TX_OFFSET + 0);\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(EmptyBlockRoundTripTest)\r\n+{\r\n+    CTxMemPool pool;\r\n+    CMutableTransaction coinbase;\r\n+    coinbase.vin.resize(1);\r\n+    coinbase.vin[0].scriptSig.resize(10);\r\n+    coinbase.vout.resize(1);\r\n+    coinbase.vout[0].nValue = 42;\r\n+\r\n+    CBlock block;\r\n+    block.vtx.resize(1);\r\n+    block.vtx[0] = MakeTransactionRef(std::move(coinbase));\r\n+    block.nVersion = 42;\r\n+    block.hashPrevBlock = InsecureRand256();\r\n+    block.nBits = 0x207fffff;\r\n+\r\n+    bool mutated;\r\n+    block.hashMerkleRoot = BlockMerkleRoot(block, &mutated);\r\n+    assert(!mutated);\r\n+    while (!CheckProofOfWork(block.GetHash(), block.nBits, Params().GetConsensus(), block.IsBtvBranched())) ++block.nNonce;\r\n+\r\n+    // Test simple header round-trip with only coinbase\r\n+    {\r\n+        CBlockHeaderAndShortTxIDs shortIDs(block, false);\r\n+\r\n+        CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\r\n+        stream << shortIDs;\r\n+\r\n+        CBlockHeaderAndShortTxIDs shortIDs2;\r\n+        stream >> shortIDs2;\r\n+\r\n+        PartiallyDownloadedBlock partialBlock(&pool);\r\n+        BOOST_CHECK(partialBlock.InitData(shortIDs2, extra_txn) == READ_STATUS_OK);\r\n+        BOOST_CHECK(partialBlock.IsTxAvailable(0));\r\n+\r\n+        CBlock block2;\r\n+        std::vector<CTransactionRef> vtx_missing;\r\n+        BOOST_CHECK(partialBlock.FillBlock(block2, vtx_missing) == READ_STATUS_OK);\r\n+        BOOST_CHECK_EQUAL(block.GetHash().ToString(), block2.GetHash().ToString());\r\n+        BOOST_CHECK_EQUAL(block.hashMerkleRoot.ToString(), BlockMerkleRoot(block2, &mutated).ToString());\r\n+        BOOST_CHECK(!mutated);\r\n+    }\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(TransactionsRequestSerializationTest) {\r\n+    BlockTransactionsRequest req1;\r\n+    req1.blockhash = InsecureRand256();\r\n+    req1.indexes.resize(4);\r\n+    req1.indexes[0] = 0;\r\n+    req1.indexes[1] = 1;\r\n+    req1.indexes[2] = 3;\r\n+    req1.indexes[3] = 4;\r\n+\r\n+    CDataStream stream(SER_NETWORK, PROTOCOL_VERSION);\r\n+    stream << req1;\r\n+\r\n+    BlockTransactionsRequest req2;\r\n+    stream >> req2;\r\n+\r\n+    BOOST_CHECK_EQUAL(req1.blockhash.ToString(), req2.blockhash.ToString());\r\n+    BOOST_CHECK_EQUAL(req1.indexes.size(), req2.indexes.size());\r\n+    BOOST_CHECK_EQUAL(req1.indexes[0], req2.indexes[0]);\r\n+    BOOST_CHECK_EQUAL(req1.indexes[1], req2.indexes[1]);\r\n+    BOOST_CHECK_EQUAL(req1.indexes[2], req2.indexes[2]);\r\n+    BOOST_CHECK_EQUAL(req1.indexes[3], req2.indexes[3]);\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_SUITE_END()\r"
      },
      {
        "sha": "f4ffd65a3faf293e27d3f2ff943a0cfa3e63021e",
        "filename": "src/test/multisig_tests.cpp",
        "status": "modified",
        "additions": 217,
        "deletions": 217,
        "changes": 434,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/multisig_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/multisig_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/multisig_tests.cpp?ref=b8461f9655ceec64a3bb3835b12b51f2b5ac42e6",
        "patch": "@@ -1,217 +1,217 @@\n-// Copyright (c) 2011-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <key.h>\n-#include <keystore.h>\n-#include <policy/policy.h>\n-#include <script/script.h>\n-#include <script/script_error.h>\n-#include <script/interpreter.h>\n-#include <script/sign.h>\n-#include <script/ismine.h>\n-#include <uint256.h>\n-#include <test/test_bitcoin.h>\n-\n-\n-#include <boost/test/unit_test.hpp>\n-\n-BOOST_FIXTURE_TEST_SUITE(multisig_tests, BasicTestingSetup)\n-\n-CScript\n-sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transaction, int whichIn)\n-{\n-    uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL, 0, SIGVERSION_BASE);\n-\n-    CScript result;\n-    result << OP_0; // CHECKMULTISIG bug workaround\n-    for (const CKey &key : keys)\n-    {\n-        std::vector<unsigned char> vchSig;\n-        BOOST_CHECK(key.Sign(hash, vchSig));\n-        vchSig.push_back((unsigned char)SIGHASH_ALL);\n-        result << vchSig;\n-    }\n-    return result;\n-}\n-\n-BOOST_AUTO_TEST_CASE(multisig_verify)\n-{\n-    unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC;\n-\n-    ScriptError err;\n-    CKey key[4];\n-    CAmount amount = 0;\n-    for (int i = 0; i < 4; i++)\n-        key[i].MakeNewKey(true);\n-\n-    CScript a_and_b;\n-    a_and_b << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-\n-    CScript a_or_b;\n-    a_or_b << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-\n-    CScript escrow;\n-    escrow << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\n-\n-    CMutableTransaction txFrom;  // Funding transaction\n-    txFrom.vout.resize(3);\n-    txFrom.vout[0].scriptPubKey = a_and_b;\n-    txFrom.vout[1].scriptPubKey = a_or_b;\n-    txFrom.vout[2].scriptPubKey = escrow;\n-\n-    CMutableTransaction txTo[3]; // Spending transaction\n-    for (int i = 0; i < 3; i++)\n-    {\n-        txTo[i].vin.resize(1);\n-        txTo[i].vout.resize(1);\n-        txTo[i].vin[0].prevout.n = i;\n-        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n-        txTo[i].vout[0].nValue = 1;\n-    }\n-\n-    std::vector<CKey> keys;\n-    CScript s;\n-\n-    // Test a AND b:\n-    keys.assign(1,key[0]);\n-    keys.push_back(key[1]);\n-    s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-    BOOST_CHECK(VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-\n-    for (int i = 0; i < 4; i++)\n-    {\n-        keys.assign(1,key[i]);\n-        s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 1: %d\", i));\n-        BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\n-\n-        keys.assign(1,key[1]);\n-        keys.push_back(key[i]);\n-        s = sign_multisig(a_and_b, keys, txTo[0], 0);\n-        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 2: %d\", i));\n-        BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n-    }\n-\n-    // Test a OR b:\n-    for (int i = 0; i < 4; i++)\n-    {\n-        keys.assign(1,key[i]);\n-        s = sign_multisig(a_or_b, keys, txTo[1], 0);\n-        if (i == 0 || i == 1)\n-        {\n-            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err), strprintf(\"a|b: %d\", i));\n-            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-        }\n-        else\n-        {\n-            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err), strprintf(\"a|b: %d\", i));\n-            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n-        }\n-    }\n-    s.clear();\n-    s << OP_0 << OP_1;\n-    BOOST_CHECK(!VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_SIG_DER, ScriptErrorString(err));\n-\n-\n-    for (int i = 0; i < 4; i++)\n-        for (int j = 0; j < 4; j++)\n-        {\n-            keys.assign(1,key[i]);\n-            keys.push_back(key[j]);\n-            s = sign_multisig(escrow, keys, txTo[2], 0);\n-            if (i < j && i < 3 && j < 3)\n-            {\n-                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, nullptr, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount), &err), strprintf(\"escrow 1: %d %d\", i, j));\n-                BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-            }\n-            else\n-            {\n-                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, nullptr, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount), &err), strprintf(\"escrow 2: %d %d\", i, j));\n-                BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\n-            }\n-        }\n-}\n-\n-BOOST_AUTO_TEST_CASE(multisig_IsStandard)\n-{\n-    CKey key[4];\n-    for (int i = 0; i < 4; i++)\n-        key[i].MakeNewKey(true);\n-\n-    txnouttype whichType;\n-\n-    CScript a_and_b;\n-    a_and_b << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-    BOOST_CHECK(::IsStandard(a_and_b, whichType));\n-\n-    CScript a_or_b;\n-    a_or_b  << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-    BOOST_CHECK(::IsStandard(a_or_b, whichType));\n-\n-    CScript escrow;\n-    escrow << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\n-    BOOST_CHECK(::IsStandard(escrow, whichType));\n-\n-    CScript one_of_four;\n-    one_of_four << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey()) << ToByteVector(key[3].GetPubKey()) << OP_4 << OP_CHECKMULTISIG;\n-    BOOST_CHECK(!::IsStandard(one_of_four, whichType));\n-\n-    CScript malformed[6];\n-    malformed[0] << OP_3 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-    malformed[1] << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\n-    malformed[2] << OP_0 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-    malformed[3] << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_0 << OP_CHECKMULTISIG;\n-    malformed[4] << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_CHECKMULTISIG;\n-    malformed[5] << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey());\n-\n-    for (int i = 0; i < 6; i++)\n-        BOOST_CHECK(!::IsStandard(malformed[i], whichType));\n-}\n-\n-BOOST_AUTO_TEST_CASE(multisig_Sign)\n-{\n-    // Test SignSignature() (and therefore the version of Solver() that signs transactions)\n-    CBasicKeyStore keystore;\n-    CKey key[4];\n-    for (int i = 0; i < 4; i++)\n-    {\n-        key[i].MakeNewKey(true);\n-        keystore.AddKey(key[i]);\n-    }\n-\n-    CScript a_and_b;\n-    a_and_b << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-\n-    CScript a_or_b;\n-    a_or_b  << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\n-\n-    CScript escrow;\n-    escrow << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\n-\n-    CMutableTransaction txFrom;  // Funding transaction\n-    txFrom.vout.resize(3);\n-    txFrom.vout[0].scriptPubKey = a_and_b;\n-    txFrom.vout[1].scriptPubKey = a_or_b;\n-    txFrom.vout[2].scriptPubKey = escrow;\n-\n-    CMutableTransaction txTo[3]; // Spending transaction\n-    for (int i = 0; i < 3; i++)\n-    {\n-        txTo[i].vin.resize(1);\n-        txTo[i].vout.resize(1);\n-        txTo[i].vin[0].prevout.n = i;\n-        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n-        txTo[i].vout[0].nValue = 1;\n-    }\n-\n-    for (int i = 0; i < 3; i++)\n-    {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n-    }\n-}\n-\n-\n-BOOST_AUTO_TEST_SUITE_END()\n+// Copyright (c) 2011-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <key.h>\r\n+#include <keystore.h>\r\n+#include <policy/policy.h>\r\n+#include <script/script.h>\r\n+#include <script/script_error.h>\r\n+#include <script/interpreter.h>\r\n+#include <script/sign.h>\r\n+#include <script/ismine.h>\r\n+#include <uint256.h>\r\n+#include <test/test_bitcoin.h>\r\n+\r\n+\r\n+#include <boost/test/unit_test.hpp>\r\n+\r\n+BOOST_FIXTURE_TEST_SUITE(multisig_tests, BasicTestingSetup)\r\n+\r\n+CScript\r\n+sign_multisig(CScript scriptPubKey, std::vector<CKey> keys, CTransaction transaction, int whichIn)\r\n+{\r\n+    uint256 hash = SignatureHash(scriptPubKey, transaction, whichIn, SIGHASH_ALL, 0, SIGVERSION_BASE);\r\n+\r\n+    CScript result;\r\n+    result << OP_0; // CHECKMULTISIG bug workaround\r\n+    for (const CKey &key : keys)\r\n+    {\r\n+        std::vector<unsigned char> vchSig;\r\n+        BOOST_CHECK(key.Sign(hash, vchSig));\r\n+        vchSig.push_back((unsigned char)SIGHASH_ALL | SIGHASH_FORKID);\r\n+        result << vchSig;\r\n+    }\r\n+    return result;\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(multisig_verify)\r\n+{\r\n+    unsigned int flags = SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC | SCRIPT_ENABLE_SIGHASH_FORKID;\r\n+\r\n+    ScriptError err;\r\n+    CKey key[4];\r\n+    CAmount amount = 0;\r\n+    for (int i = 0; i < 4; i++)\r\n+        key[i].MakeNewKey(true);\r\n+\r\n+    CScript a_and_b;\r\n+    a_and_b << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\r\n+\r\n+    CScript a_or_b;\r\n+    a_or_b << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\r\n+\r\n+    CScript escrow;\r\n+    escrow << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\r\n+\r\n+    CMutableTransaction txFrom;  // Funding transaction\r\n+    txFrom.vout.resize(3);\r\n+    txFrom.vout[0].scriptPubKey = a_and_b;\r\n+    txFrom.vout[1].scriptPubKey = a_or_b;\r\n+    txFrom.vout[2].scriptPubKey = escrow;\r\n+\r\n+    CMutableTransaction txTo[3]; // Spending transaction\r\n+    for (int i = 0; i < 3; i++)\r\n+    {\r\n+        txTo[i].vin.resize(1);\r\n+        txTo[i].vout.resize(1);\r\n+        txTo[i].vin[0].prevout.n = i;\r\n+        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\r\n+        txTo[i].vout[0].nValue = 1;\r\n+    }\r\n+\r\n+    std::vector<CKey> keys;\r\n+    CScript s;\r\n+\r\n+    // Test a AND b:\r\n+    keys.assign(1,key[0]);\r\n+    keys.push_back(key[1]);\r\n+    s = sign_multisig(a_and_b, keys, txTo[0], 0);\r\n+    BOOST_CHECK(VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err));\r\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\r\n+\r\n+    for (int i = 0; i < 4; i++)\r\n+    {\r\n+        keys.assign(1,key[i]);\r\n+        s = sign_multisig(a_and_b, keys, txTo[0], 0);\r\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 1: %d\", i));\r\n+        BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_INVALID_STACK_OPERATION, ScriptErrorString(err));\r\n+\r\n+        keys.assign(1,key[1]);\r\n+        keys.push_back(key[i]);\r\n+        s = sign_multisig(a_and_b, keys, txTo[0], 0);\r\n+        BOOST_CHECK_MESSAGE(!VerifyScript(s, a_and_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[0], 0, amount), &err), strprintf(\"a&b 2: %d\", i));\r\n+        BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\r\n+    }\r\n+\r\n+    // Test a OR b:\r\n+    for (int i = 0; i < 4; i++)\r\n+    {\r\n+        keys.assign(1,key[i]);\r\n+        s = sign_multisig(a_or_b, keys, txTo[1], 0);\r\n+        if (i == 0 || i == 1)\r\n+        {\r\n+            BOOST_CHECK_MESSAGE(VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err), strprintf(\"a|b: %d\", i));\r\n+            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\r\n+        }\r\n+        else\r\n+        {\r\n+            BOOST_CHECK_MESSAGE(!VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err), strprintf(\"a|b: %d\", i));\r\n+            BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\r\n+        }\r\n+    }\r\n+    s.clear();\r\n+    s << OP_0 << OP_1;\r\n+    BOOST_CHECK(!VerifyScript(s, a_or_b, nullptr, flags, MutableTransactionSignatureChecker(&txTo[1], 0, amount), &err));\r\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_SIG_DER, ScriptErrorString(err));\r\n+\r\n+\r\n+    for (int i = 0; i < 4; i++)\r\n+        for (int j = 0; j < 4; j++)\r\n+        {\r\n+            keys.assign(1,key[i]);\r\n+            keys.push_back(key[j]);\r\n+            s = sign_multisig(escrow, keys, txTo[2], 0);\r\n+            if (i < j && i < 3 && j < 3)\r\n+            {\r\n+                BOOST_CHECK_MESSAGE(VerifyScript(s, escrow, nullptr, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount), &err), strprintf(\"escrow 1: %d %d\", i, j));\r\n+                BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\r\n+            }\r\n+            else\r\n+            {\r\n+                BOOST_CHECK_MESSAGE(!VerifyScript(s, escrow, nullptr, flags, MutableTransactionSignatureChecker(&txTo[2], 0, amount), &err), strprintf(\"escrow 2: %d %d\", i, j));\r\n+                BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EVAL_FALSE, ScriptErrorString(err));\r\n+            }\r\n+        }\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(multisig_IsStandard)\r\n+{\r\n+    CKey key[4];\r\n+    for (int i = 0; i < 4; i++)\r\n+        key[i].MakeNewKey(true);\r\n+\r\n+    txnouttype whichType;\r\n+\r\n+    CScript a_and_b;\r\n+    a_and_b << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\r\n+    BOOST_CHECK(::IsStandard(a_and_b, whichType));\r\n+\r\n+    CScript a_or_b;\r\n+    a_or_b  << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\r\n+    BOOST_CHECK(::IsStandard(a_or_b, whichType));\r\n+\r\n+    CScript escrow;\r\n+    escrow << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\r\n+    BOOST_CHECK(::IsStandard(escrow, whichType));\r\n+\r\n+    CScript one_of_four;\r\n+    one_of_four << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey()) << ToByteVector(key[3].GetPubKey()) << OP_4 << OP_CHECKMULTISIG;\r\n+    BOOST_CHECK(!::IsStandard(one_of_four, whichType));\r\n+\r\n+    CScript malformed[6];\r\n+    malformed[0] << OP_3 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\r\n+    malformed[1] << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\r\n+    malformed[2] << OP_0 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\r\n+    malformed[3] << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_0 << OP_CHECKMULTISIG;\r\n+    malformed[4] << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_CHECKMULTISIG;\r\n+    malformed[5] << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey());\r\n+\r\n+    for (int i = 0; i < 6; i++)\r\n+        BOOST_CHECK(!::IsStandard(malformed[i], whichType));\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(multisig_Sign)\r\n+{\r\n+    // Test SignSignature() (and therefore the version of Solver() that signs transactions)\r\n+    CBasicKeyStore keystore;\r\n+    CKey key[4];\r\n+    for (int i = 0; i < 4; i++)\r\n+    {\r\n+        key[i].MakeNewKey(true);\r\n+        keystore.AddKey(key[i]);\r\n+    }\r\n+\r\n+    CScript a_and_b;\r\n+    a_and_b << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\r\n+\r\n+    CScript a_or_b;\r\n+    a_or_b  << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << OP_2 << OP_CHECKMULTISIG;\r\n+\r\n+    CScript escrow;\r\n+    escrow << OP_2 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey()) << OP_3 << OP_CHECKMULTISIG;\r\n+\r\n+    CMutableTransaction txFrom;  // Funding transaction\r\n+    txFrom.vout.resize(3);\r\n+    txFrom.vout[0].scriptPubKey = a_and_b;\r\n+    txFrom.vout[1].scriptPubKey = a_or_b;\r\n+    txFrom.vout[2].scriptPubKey = escrow;\r\n+\r\n+    CMutableTransaction txTo[3]; // Spending transaction\r\n+    for (int i = 0; i < 3; i++)\r\n+    {\r\n+        txTo[i].vin.resize(1);\r\n+        txTo[i].vout.resize(1);\r\n+        txTo[i].vin[0].prevout.n = i;\r\n+        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\r\n+        txTo[i].vout[0].nValue = 1;\r\n+    }\r\n+\r\n+    for (int i = 0; i < 3; i++)\r\n+    {\r\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL | SIGHASH_FORKID), strprintf(\"SignSignature %d\", i));\r\n+    }\r\n+}\r\n+\r\n+\r\n+BOOST_AUTO_TEST_SUITE_END()\r"
      },
      {
        "sha": "cc7e18bf5709b1f8c6f54b5dec24c6e55256475e",
        "filename": "src/test/pow_tests.cpp",
        "status": "modified",
        "additions": 86,
        "deletions": 86,
        "changes": 172,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/pow_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/pow_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/pow_tests.cpp?ref=b8461f9655ceec64a3bb3835b12b51f2b5ac42e6",
        "patch": "@@ -1,86 +1,86 @@\n-// Copyright (c) 2015 The Bitcoin Core developers\n-// Distributed under the MIT/X11 software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <chain.h>\n-#include <chainparams.h>\n-#include <pow.h>\n-#include <random.h>\n-#include <util.h>\n-#include <test/test_bitcoin.h>\n-\n-#include <boost/test/unit_test.hpp>\n-\n-BOOST_FIXTURE_TEST_SUITE(pow_tests, BasicTestingSetup)\n-\n-/* Test calculation of next difficulty target with no constraints applying */\n-BOOST_AUTO_TEST_CASE(get_next_work)\n-{\n-    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n-    int64_t nLastRetargetTime = 1261130161; // Block #30240\n-    CBlockIndex pindexLast;\n-    pindexLast.nHeight = 32255;\n-    pindexLast.nTime = 1262152739;  // Block #32255\n-    pindexLast.nBits = 0x1d00ffff;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00d86a);\n-}\n-\n-/* Test the constraint on the upper bound for next work */\n-BOOST_AUTO_TEST_CASE(get_next_work_pow_limit)\n-{\n-    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n-    int64_t nLastRetargetTime = 1231006505; // Block #0\n-    CBlockIndex pindexLast;\n-    pindexLast.nHeight = 2015;\n-    pindexLast.nTime = 1233061996;  // Block #2015\n-    pindexLast.nBits = 0x1d00ffff;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00ffff);\n-}\n-\n-/* Test the constraint on the lower bound for actual time taken */\n-BOOST_AUTO_TEST_CASE(get_next_work_lower_limit_actual)\n-{\n-    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n-    int64_t nLastRetargetTime = 1279008237; // Block #66528\n-    CBlockIndex pindexLast;\n-    pindexLast.nHeight = 68543;\n-    pindexLast.nTime = 1279297671;  // Block #68543\n-    pindexLast.nBits = 0x1c05a3f4;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1c0168fd);\n-}\n-\n-/* Test the constraint on the upper bound for actual time taken */\n-BOOST_AUTO_TEST_CASE(get_next_work_upper_limit_actual)\n-{\n-    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n-    int64_t nLastRetargetTime = 1263163443; // NOTE: Not an actual block time\n-    CBlockIndex pindexLast;\n-    pindexLast.nHeight = 46367;\n-    pindexLast.nTime = 1269211443;  // Block #46367\n-    pindexLast.nBits = 0x1c387f6f;\n-    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00e1fd);\n-}\n-\n-BOOST_AUTO_TEST_CASE(GetBlockProofEquivalentTime_test)\n-{\n-    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\n-    std::vector<CBlockIndex> blocks(10000);\n-    for (int i = 0; i < 10000; i++) {\n-        blocks[i].pprev = i ? &blocks[i - 1] : nullptr;\n-        blocks[i].nHeight = i;\n-        blocks[i].nTime = 1269211443 + i * chainParams->GetConsensus().nPowTargetSpacing;\n-        blocks[i].nBits = 0x207fffff; /* target 0x7fffff000... */\n-        blocks[i].nChainWork = i ? blocks[i - 1].nChainWork + GetBlockProof(blocks[i - 1]) : arith_uint256(0);\n-    }\n-\n-    for (int j = 0; j < 1000; j++) {\n-        CBlockIndex *p1 = &blocks[InsecureRandRange(10000)];\n-        CBlockIndex *p2 = &blocks[InsecureRandRange(10000)];\n-        CBlockIndex *p3 = &blocks[InsecureRandRange(10000)];\n-\n-        int64_t tdiff = GetBlockProofEquivalentTime(*p1, *p2, *p3, chainParams->GetConsensus());\n-        BOOST_CHECK_EQUAL(tdiff, p1->GetBlockTime() - p2->GetBlockTime());\n-    }\n-}\n-\n-BOOST_AUTO_TEST_SUITE_END()\n+// Copyright (c) 2015 The Bitcoin Core developers\r\n+// Distributed under the MIT/X11 software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <chain.h>\r\n+#include <chainparams.h>\r\n+#include <pow.h>\r\n+#include <random.h>\r\n+#include <util.h>\r\n+#include <test/test_bitcoin.h>\r\n+\r\n+#include <boost/test/unit_test.hpp>\r\n+\r\n+BOOST_FIXTURE_TEST_SUITE(pow_tests, BasicTestingSetup)\r\n+\r\n+/* Test calculation of next difficulty target with no constraints applying */\r\n+BOOST_AUTO_TEST_CASE(get_next_work)\r\n+{\r\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\r\n+    int64_t nLastRetargetTime = 1261130161; // Block #30240\r\n+    CBlockIndex pindexLast;\r\n+    pindexLast.nHeight = 32255;\r\n+    pindexLast.nTime = 1262152739;  // Block #32255\r\n+    pindexLast.nBits = 0x1d00ffff;\r\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00d86a);\r\n+}\r\n+\r\n+/* Test the constraint on the upper bound for next work */\r\n+BOOST_AUTO_TEST_CASE(get_next_work_pow_limit)\r\n+{\r\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\r\n+    int64_t nLastRetargetTime = 1231006505; // Block #0\r\n+    CBlockIndex pindexLast;\r\n+    pindexLast.nHeight = 2015;\r\n+    pindexLast.nTime = 1233061996;  // Block #2015\r\n+    pindexLast.nBits = 0x1d00ffff;\r\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00ffff);\r\n+}\r\n+\r\n+/* Test the constraint on the lower bound for actual time taken */\r\n+BOOST_AUTO_TEST_CASE(get_next_work_lower_limit_actual)\r\n+{\r\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\r\n+    int64_t nLastRetargetTime = 1279008237; // Block #66528\r\n+    CBlockIndex pindexLast;\r\n+    pindexLast.nHeight = 68543;\r\n+    pindexLast.nTime = 1279297671;  // Block #68543\r\n+    pindexLast.nBits = 0x1c05a3f4;\r\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1c0168fd);\r\n+}\r\n+\r\n+/* Test the constraint on the upper bound for actual time taken */\r\n+BOOST_AUTO_TEST_CASE(get_next_work_upper_limit_actual)\r\n+{\r\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\r\n+    int64_t nLastRetargetTime = 1263163443; // NOTE: Not an actual block time\r\n+    CBlockIndex pindexLast;\r\n+    pindexLast.nHeight = 46367;\r\n+    pindexLast.nTime = 1269211443;  // Block #46367\r\n+    pindexLast.nBits = 0x1c387f6f;\r\n+    BOOST_CHECK_EQUAL(CalculateNextWorkRequired(&pindexLast, nLastRetargetTime, chainParams->GetConsensus()), 0x1d00e1fd);\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(GetBlockProofEquivalentTime_test)\r\n+{\r\n+    const auto chainParams = CreateChainParams(CBaseChainParams::MAIN);\r\n+    std::vector<CBlockIndex> blocks(10000);\r\n+    for (int i = 0; i < 10000; i++) {\r\n+        blocks[i].pprev = i ? &blocks[i - 1] : nullptr;\r\n+        blocks[i].nHeight = i;\r\n+        blocks[i].nTime = 1269211443 + i * chainParams->GetConsensus().nBtvPowTargetSpacing;\r\n+        blocks[i].nBits = 0x207fffff; /* target 0x7fffff000... */\r\n+        blocks[i].nChainWork = i ? blocks[i - 1].nChainWork + GetBlockProof(blocks[i - 1]) : arith_uint256(0);\r\n+    }\r\n+\r\n+    for (int j = 0; j < 1000; j++) {\r\n+        CBlockIndex *p1 = &blocks[InsecureRandRange(10000)];\r\n+        CBlockIndex *p2 = &blocks[InsecureRandRange(10000)];\r\n+        CBlockIndex *p3 = &blocks[InsecureRandRange(10000)];\r\n+\r\n+        int64_t tdiff = GetBlockProofEquivalentTime(*p1, *p2, *p3, chainParams->GetConsensus());\r\n+        BOOST_CHECK_EQUAL(tdiff, p1->GetBlockTime() - p2->GetBlockTime());\r\n+    }\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_SUITE_END()\r"
      },
      {
        "sha": "b6afb5c08e4f03ba2f4d5dbe3dd5205f28532117",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 369,
        "deletions": 369,
        "changes": 738,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=b8461f9655ceec64a3bb3835b12b51f2b5ac42e6",
        "patch": "@@ -1,369 +1,369 @@\n-// Copyright (c) 2012-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <consensus/tx_verify.h>\n-#include <core_io.h>\n-#include <key.h>\n-#include <keystore.h>\n-#include <validation.h>\n-#include <policy/policy.h>\n-#include <script/script.h>\n-#include <script/script_error.h>\n-#include <script/sign.h>\n-#include <script/ismine.h>\n-#include <test/test_bitcoin.h>\n-\n-#include <vector>\n-\n-#include <boost/test/unit_test.hpp>\n-\n-// Helpers:\n-static std::vector<unsigned char>\n-Serialize(const CScript& s)\n-{\n-    std::vector<unsigned char> sSerialized(s.begin(), s.end());\n-    return sSerialized;\n-}\n-\n-static bool\n-Verify(const CScript& scriptSig, const CScript& scriptPubKey, bool fStrict, ScriptError& err)\n-{\n-    // Create dummy to/from transactions:\n-    CMutableTransaction txFrom;\n-    txFrom.vout.resize(1);\n-    txFrom.vout[0].scriptPubKey = scriptPubKey;\n-\n-    CMutableTransaction txTo;\n-    txTo.vin.resize(1);\n-    txTo.vout.resize(1);\n-    txTo.vin[0].prevout.n = 0;\n-    txTo.vin[0].prevout.hash = txFrom.GetHash();\n-    txTo.vin[0].scriptSig = scriptSig;\n-    txTo.vout[0].nValue = 1;\n-\n-    return VerifyScript(scriptSig, scriptPubKey, nullptr, fStrict ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE, MutableTransactionSignatureChecker(&txTo, 0, txFrom.vout[0].nValue), &err);\n-}\n-\n-\n-BOOST_FIXTURE_TEST_SUITE(script_P2SH_tests, BasicTestingSetup)\n-\n-BOOST_AUTO_TEST_CASE(sign)\n-{\n-    LOCK(cs_main);\n-    // Pay-to-script-hash looks like this:\n-    // scriptSig:    <sig> <sig...> <serialized_script>\n-    // scriptPubKey: HASH160 <hash> EQUAL\n-\n-    // Test SignSignature() (and therefore the version of Solver() that signs transactions)\n-    CBasicKeyStore keystore;\n-    CKey key[4];\n-    for (int i = 0; i < 4; i++)\n-    {\n-        key[i].MakeNewKey(true);\n-        keystore.AddKey(key[i]);\n-    }\n-\n-    // 8 Scripts: checking all combinations of\n-    // different keys, straight/P2SH, pubkey/pubkeyhash\n-    CScript standardScripts[4];\n-    standardScripts[0] << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n-    standardScripts[1] = GetScriptForDestination(key[1].GetPubKey().GetID());\n-    standardScripts[2] << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\n-    standardScripts[3] = GetScriptForDestination(key[2].GetPubKey().GetID());\n-    CScript evalScripts[4];\n-    for (int i = 0; i < 4; i++)\n-    {\n-        keystore.AddCScript(standardScripts[i]);\n-        evalScripts[i] = GetScriptForDestination(CScriptID(standardScripts[i]));\n-    }\n-\n-    CMutableTransaction txFrom;  // Funding transaction:\n-    std::string reason;\n-    txFrom.vout.resize(8);\n-    for (int i = 0; i < 4; i++)\n-    {\n-        txFrom.vout[i].scriptPubKey = evalScripts[i];\n-        txFrom.vout[i].nValue = COIN;\n-        txFrom.vout[i+4].scriptPubKey = standardScripts[i];\n-        txFrom.vout[i+4].nValue = COIN;\n-    }\n-    BOOST_CHECK(IsStandardTx(txFrom, reason));\n-\n-    CMutableTransaction txTo[8]; // Spending transactions\n-    for (int i = 0; i < 8; i++)\n-    {\n-        txTo[i].vin.resize(1);\n-        txTo[i].vout.resize(1);\n-        txTo[i].vin[0].prevout.n = i;\n-        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n-        txTo[i].vout[0].nValue = 1;\n-        BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\n-    }\n-    for (int i = 0; i < 8; i++)\n-    {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n-    }\n-    // All of the above should be OK, and the txTos have valid signatures\n-    // Check to make sure signature verification fails if we use the wrong ScriptSig:\n-    for (int i = 0; i < 8; i++) {\n-        PrecomputedTransactionData txdata(txTo[i]);\n-        for (int j = 0; j < 8; j++)\n-        {\n-            CScript sigSave = txTo[i].vin[0].scriptSig;\n-            txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n-            bool sigOK = CScriptCheck(txFrom.vout[txTo[i].vin[0].prevout.n], txTo[i], 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC, false, &txdata)();\n-            if (i == j)\n-                BOOST_CHECK_MESSAGE(sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n-            else\n-                BOOST_CHECK_MESSAGE(!sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n-            txTo[i].vin[0].scriptSig = sigSave;\n-        }\n-    }\n-}\n-\n-BOOST_AUTO_TEST_CASE(norecurse)\n-{\n-    ScriptError err;\n-    // Make sure only the outer pay-to-script-hash does the\n-    // extra-validation thing:\n-    CScript invalidAsScript;\n-    invalidAsScript << OP_INVALIDOPCODE << OP_INVALIDOPCODE;\n-\n-    CScript p2sh = GetScriptForDestination(CScriptID(invalidAsScript));\n-\n-    CScript scriptSig;\n-    scriptSig << Serialize(invalidAsScript);\n-\n-    // Should not verify, because it will try to execute OP_INVALIDOPCODE\n-    BOOST_CHECK(!Verify(scriptSig, p2sh, true, err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_BAD_OPCODE, ScriptErrorString(err));\n-\n-    // Try to recur, and verification should succeed because\n-    // the inner HASH160 <> EQUAL should only check the hash:\n-    CScript p2sh2 = GetScriptForDestination(CScriptID(p2sh));\n-    CScript scriptSig2;\n-    scriptSig2 << Serialize(invalidAsScript) << Serialize(p2sh);\n-\n-    BOOST_CHECK(Verify(scriptSig2, p2sh2, true, err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-}\n-\n-BOOST_AUTO_TEST_CASE(set)\n-{\n-    LOCK(cs_main);\n-    // Test the CScript::Set* methods\n-    CBasicKeyStore keystore;\n-    CKey key[4];\n-    std::vector<CPubKey> keys;\n-    for (int i = 0; i < 4; i++)\n-    {\n-        key[i].MakeNewKey(true);\n-        keystore.AddKey(key[i]);\n-        keys.push_back(key[i].GetPubKey());\n-    }\n-\n-    CScript inner[4];\n-    inner[0] = GetScriptForDestination(key[0].GetPubKey().GetID());\n-    inner[1] = GetScriptForMultisig(2, std::vector<CPubKey>(keys.begin(), keys.begin()+2));\n-    inner[2] = GetScriptForMultisig(1, std::vector<CPubKey>(keys.begin(), keys.begin()+2));\n-    inner[3] = GetScriptForMultisig(2, std::vector<CPubKey>(keys.begin(), keys.begin()+3));\n-\n-    CScript outer[4];\n-    for (int i = 0; i < 4; i++)\n-    {\n-        outer[i] = GetScriptForDestination(CScriptID(inner[i]));\n-        keystore.AddCScript(inner[i]);\n-    }\n-\n-    CMutableTransaction txFrom;  // Funding transaction:\n-    std::string reason;\n-    txFrom.vout.resize(4);\n-    for (int i = 0; i < 4; i++)\n-    {\n-        txFrom.vout[i].scriptPubKey = outer[i];\n-        txFrom.vout[i].nValue = CENT;\n-    }\n-    BOOST_CHECK(IsStandardTx(txFrom, reason));\n-\n-    CMutableTransaction txTo[4]; // Spending transactions\n-    for (int i = 0; i < 4; i++)\n-    {\n-        txTo[i].vin.resize(1);\n-        txTo[i].vout.resize(1);\n-        txTo[i].vin[0].prevout.n = i;\n-        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\n-        txTo[i].vout[0].nValue = 1*CENT;\n-        txTo[i].vout[0].scriptPubKey = inner[i];\n-        BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\n-    }\n-    for (int i = 0; i < 4; i++)\n-    {\n-        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL), strprintf(\"SignSignature %d\", i));\n-        BOOST_CHECK_MESSAGE(IsStandardTx(txTo[i], reason), strprintf(\"txTo[%d].IsStandard\", i));\n-    }\n-}\n-\n-BOOST_AUTO_TEST_CASE(is)\n-{\n-    // Test CScript::IsPayToScriptHash()\n-    uint160 dummy;\n-    CScript p2sh;\n-    p2sh << OP_HASH160 << ToByteVector(dummy) << OP_EQUAL;\n-    BOOST_CHECK(p2sh.IsPayToScriptHash());\n-\n-    // Not considered pay-to-script-hash if using one of the OP_PUSHDATA opcodes:\n-    static const unsigned char direct[] =    { OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n-    BOOST_CHECK(CScript(direct, direct+sizeof(direct)).IsPayToScriptHash());\n-    static const unsigned char pushdata1[] = { OP_HASH160, OP_PUSHDATA1, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n-    BOOST_CHECK(!CScript(pushdata1, pushdata1+sizeof(pushdata1)).IsPayToScriptHash());\n-    static const unsigned char pushdata2[] = { OP_HASH160, OP_PUSHDATA2, 20,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n-    BOOST_CHECK(!CScript(pushdata2, pushdata2+sizeof(pushdata2)).IsPayToScriptHash());\n-    static const unsigned char pushdata4[] = { OP_HASH160, OP_PUSHDATA4, 20,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\n-    BOOST_CHECK(!CScript(pushdata4, pushdata4+sizeof(pushdata4)).IsPayToScriptHash());\n-\n-    CScript not_p2sh;\n-    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n-\n-    not_p2sh.clear(); not_p2sh << OP_HASH160 << ToByteVector(dummy) << ToByteVector(dummy) << OP_EQUAL;\n-    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n-\n-    not_p2sh.clear(); not_p2sh << OP_NOP << ToByteVector(dummy) << OP_EQUAL;\n-    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n-\n-    not_p2sh.clear(); not_p2sh << OP_HASH160 << ToByteVector(dummy) << OP_CHECKSIG;\n-    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\n-}\n-\n-BOOST_AUTO_TEST_CASE(switchover)\n-{\n-    // Test switch over code\n-    CScript notValid;\n-    ScriptError err;\n-    notValid << OP_11 << OP_12 << OP_EQUALVERIFY;\n-    CScript scriptSig;\n-    scriptSig << Serialize(notValid);\n-\n-    CScript fund = GetScriptForDestination(CScriptID(notValid));\n-\n-\n-    // Validation should succeed under old rules (hash is correct):\n-    BOOST_CHECK(Verify(scriptSig, fund, false, err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-    // Fail under new:\n-    BOOST_CHECK(!Verify(scriptSig, fund, true, err));\n-    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EQUALVERIFY, ScriptErrorString(err));\n-}\n-\n-BOOST_AUTO_TEST_CASE(AreInputsStandard)\n-{\n-    LOCK(cs_main);\n-    CCoinsView coinsDummy;\n-    CCoinsViewCache coins(&coinsDummy);\n-    CBasicKeyStore keystore;\n-    CKey key[6];\n-    std::vector<CPubKey> keys;\n-    for (int i = 0; i < 6; i++)\n-    {\n-        key[i].MakeNewKey(true);\n-        keystore.AddKey(key[i]);\n-    }\n-    for (int i = 0; i < 3; i++)\n-        keys.push_back(key[i].GetPubKey());\n-\n-    CMutableTransaction txFrom;\n-    txFrom.vout.resize(7);\n-\n-    // First three are standard:\n-    CScript pay1 = GetScriptForDestination(key[0].GetPubKey().GetID());\n-    keystore.AddCScript(pay1);\n-    CScript pay1of3 = GetScriptForMultisig(1, keys);\n-\n-    txFrom.vout[0].scriptPubKey = GetScriptForDestination(CScriptID(pay1)); // P2SH (OP_CHECKSIG)\n-    txFrom.vout[0].nValue = 1000;\n-    txFrom.vout[1].scriptPubKey = pay1; // ordinary OP_CHECKSIG\n-    txFrom.vout[1].nValue = 2000;\n-    txFrom.vout[2].scriptPubKey = pay1of3; // ordinary OP_CHECKMULTISIG\n-    txFrom.vout[2].nValue = 3000;\n-\n-    // vout[3] is complicated 1-of-3 AND 2-of-3\n-    // ... that is OK if wrapped in P2SH:\n-    CScript oneAndTwo;\n-    oneAndTwo << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey());\n-    oneAndTwo << OP_3 << OP_CHECKMULTISIGVERIFY;\n-    oneAndTwo << OP_2 << ToByteVector(key[3].GetPubKey()) << ToByteVector(key[4].GetPubKey()) << ToByteVector(key[5].GetPubKey());\n-    oneAndTwo << OP_3 << OP_CHECKMULTISIG;\n-    keystore.AddCScript(oneAndTwo);\n-    txFrom.vout[3].scriptPubKey = GetScriptForDestination(CScriptID(oneAndTwo));\n-    txFrom.vout[3].nValue = 4000;\n-\n-    // vout[4] is max sigops:\n-    CScript fifteenSigops; fifteenSigops << OP_1;\n-    for (unsigned i = 0; i < MAX_P2SH_SIGOPS; i++)\n-        fifteenSigops << ToByteVector(key[i%3].GetPubKey());\n-    fifteenSigops << OP_15 << OP_CHECKMULTISIG;\n-    keystore.AddCScript(fifteenSigops);\n-    txFrom.vout[4].scriptPubKey = GetScriptForDestination(CScriptID(fifteenSigops));\n-    txFrom.vout[4].nValue = 5000;\n-\n-    // vout[5/6] are non-standard because they exceed MAX_P2SH_SIGOPS\n-    CScript sixteenSigops; sixteenSigops << OP_16 << OP_CHECKMULTISIG;\n-    keystore.AddCScript(sixteenSigops);\n-    txFrom.vout[5].scriptPubKey = GetScriptForDestination(CScriptID(fifteenSigops));\n-    txFrom.vout[5].nValue = 5000;\n-    CScript twentySigops; twentySigops << OP_CHECKMULTISIG;\n-    keystore.AddCScript(twentySigops);\n-    txFrom.vout[6].scriptPubKey = GetScriptForDestination(CScriptID(twentySigops));\n-    txFrom.vout[6].nValue = 6000;\n-\n-    AddCoins(coins, txFrom, 0);\n-\n-    CMutableTransaction txTo;\n-    txTo.vout.resize(1);\n-    txTo.vout[0].scriptPubKey = GetScriptForDestination(key[1].GetPubKey().GetID());\n-\n-    txTo.vin.resize(5);\n-    for (int i = 0; i < 5; i++)\n-    {\n-        txTo.vin[i].prevout.n = i;\n-        txTo.vin[i].prevout.hash = txFrom.GetHash();\n-    }\n-    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL));\n-    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 1, SIGHASH_ALL));\n-    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 2, SIGHASH_ALL));\n-    // SignSignature doesn't know how to sign these. We're\n-    // not testing validating signatures, so just create\n-    // dummy signatures that DO include the correct P2SH scripts:\n-    txTo.vin[3].scriptSig << OP_11 << OP_11 << std::vector<unsigned char>(oneAndTwo.begin(), oneAndTwo.end());\n-    txTo.vin[4].scriptSig << std::vector<unsigned char>(fifteenSigops.begin(), fifteenSigops.end());\n-\n-    BOOST_CHECK(::AreInputsStandard(txTo, coins));\n-    // 22 P2SH sigops for all inputs (1 for vin[0], 6 for vin[3], 15 for vin[4]\n-    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txTo, coins), 22U);\n-\n-    CMutableTransaction txToNonStd1;\n-    txToNonStd1.vout.resize(1);\n-    txToNonStd1.vout[0].scriptPubKey = GetScriptForDestination(key[1].GetPubKey().GetID());\n-    txToNonStd1.vout[0].nValue = 1000;\n-    txToNonStd1.vin.resize(1);\n-    txToNonStd1.vin[0].prevout.n = 5;\n-    txToNonStd1.vin[0].prevout.hash = txFrom.GetHash();\n-    txToNonStd1.vin[0].scriptSig << std::vector<unsigned char>(sixteenSigops.begin(), sixteenSigops.end());\n-\n-    BOOST_CHECK(!::AreInputsStandard(txToNonStd1, coins));\n-    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd1, coins), 16U);\n-\n-    CMutableTransaction txToNonStd2;\n-    txToNonStd2.vout.resize(1);\n-    txToNonStd2.vout[0].scriptPubKey = GetScriptForDestination(key[1].GetPubKey().GetID());\n-    txToNonStd2.vout[0].nValue = 1000;\n-    txToNonStd2.vin.resize(1);\n-    txToNonStd2.vin[0].prevout.n = 6;\n-    txToNonStd2.vin[0].prevout.hash = txFrom.GetHash();\n-    txToNonStd2.vin[0].scriptSig << std::vector<unsigned char>(twentySigops.begin(), twentySigops.end());\n-\n-    BOOST_CHECK(!::AreInputsStandard(txToNonStd2, coins));\n-    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd2, coins), 20U);\n-}\n-\n-BOOST_AUTO_TEST_SUITE_END()\n+// Copyright (c) 2012-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <consensus/tx_verify.h>\r\n+#include <core_io.h>\r\n+#include <key.h>\r\n+#include <keystore.h>\r\n+#include <validation.h>\r\n+#include <policy/policy.h>\r\n+#include <script/script.h>\r\n+#include <script/script_error.h>\r\n+#include <script/sign.h>\r\n+#include <script/ismine.h>\r\n+#include <test/test_bitcoin.h>\r\n+\r\n+#include <vector>\r\n+\r\n+#include <boost/test/unit_test.hpp>\r\n+\r\n+// Helpers:\r\n+static std::vector<unsigned char>\r\n+Serialize(const CScript& s)\r\n+{\r\n+    std::vector<unsigned char> sSerialized(s.begin(), s.end());\r\n+    return sSerialized;\r\n+}\r\n+\r\n+static bool\r\n+Verify(const CScript& scriptSig, const CScript& scriptPubKey, bool fStrict, ScriptError& err)\r\n+{\r\n+    // Create dummy to/from transactions:\r\n+    CMutableTransaction txFrom;\r\n+    txFrom.vout.resize(1);\r\n+    txFrom.vout[0].scriptPubKey = scriptPubKey;\r\n+\r\n+    CMutableTransaction txTo;\r\n+    txTo.vin.resize(1);\r\n+    txTo.vout.resize(1);\r\n+    txTo.vin[0].prevout.n = 0;\r\n+    txTo.vin[0].prevout.hash = txFrom.GetHash();\r\n+    txTo.vin[0].scriptSig = scriptSig;\r\n+    txTo.vout[0].nValue = 1;\r\n+\r\n+    return VerifyScript(scriptSig, scriptPubKey, nullptr, fStrict ? SCRIPT_VERIFY_P2SH : SCRIPT_VERIFY_NONE, MutableTransactionSignatureChecker(&txTo, 0, txFrom.vout[0].nValue), &err);\r\n+}\r\n+\r\n+\r\n+BOOST_FIXTURE_TEST_SUITE(script_P2SH_tests, BasicTestingSetup)\r\n+\r\n+BOOST_AUTO_TEST_CASE(sign)\r\n+{\r\n+    LOCK(cs_main);\r\n+    // Pay-to-script-hash looks like this:\r\n+    // scriptSig:    <sig> <sig...> <serialized_script>\r\n+    // scriptPubKey: HASH160 <hash> EQUAL\r\n+\r\n+    // Test SignSignature() (and therefore the version of Solver() that signs transactions)\r\n+    CBasicKeyStore keystore;\r\n+    CKey key[4];\r\n+    for (int i = 0; i < 4; i++)\r\n+    {\r\n+        key[i].MakeNewKey(true);\r\n+        keystore.AddKey(key[i]);\r\n+    }\r\n+\r\n+    // 8 Scripts: checking all combinations of\r\n+    // different keys, straight/P2SH, pubkey/pubkeyhash\r\n+    CScript standardScripts[4];\r\n+    standardScripts[0] << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\r\n+    standardScripts[1] = GetScriptForDestination(key[1].GetPubKey().GetID());\r\n+    standardScripts[2] << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\r\n+    standardScripts[3] = GetScriptForDestination(key[2].GetPubKey().GetID());\r\n+    CScript evalScripts[4];\r\n+    for (int i = 0; i < 4; i++)\r\n+    {\r\n+        keystore.AddCScript(standardScripts[i]);\r\n+        evalScripts[i] = GetScriptForDestination(CScriptID(standardScripts[i]));\r\n+    }\r\n+\r\n+    CMutableTransaction txFrom;  // Funding transaction:\r\n+    std::string reason;\r\n+    txFrom.vout.resize(8);\r\n+    for (int i = 0; i < 4; i++)\r\n+    {\r\n+        txFrom.vout[i].scriptPubKey = evalScripts[i];\r\n+        txFrom.vout[i].nValue = COIN;\r\n+        txFrom.vout[i+4].scriptPubKey = standardScripts[i];\r\n+        txFrom.vout[i+4].nValue = COIN;\r\n+    }\r\n+    BOOST_CHECK(IsStandardTx(txFrom, reason));\r\n+\r\n+    CMutableTransaction txTo[8]; // Spending transactions\r\n+    for (int i = 0; i < 8; i++)\r\n+    {\r\n+        txTo[i].vin.resize(1);\r\n+        txTo[i].vout.resize(1);\r\n+        txTo[i].vin[0].prevout.n = i;\r\n+        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\r\n+        txTo[i].vout[0].nValue = 1;\r\n+        BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\r\n+    }\r\n+    for (int i = 0; i < 8; i++)\r\n+    {\r\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL | SIGHASH_FORKID), strprintf(\"SignSignature %d\", i));\r\n+    }\r\n+    // All of the above should be OK, and the txTos have valid signatures\r\n+    // Check to make sure signature verification fails if we use the wrong ScriptSig:\r\n+    for (int i = 0; i < 8; i++) {\r\n+        PrecomputedTransactionData txdata(txTo[i]);\r\n+        for (int j = 0; j < 8; j++)\r\n+        {\r\n+            CScript sigSave = txTo[i].vin[0].scriptSig;\r\n+            txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\r\n+            bool sigOK = CScriptCheck(txFrom.vout[txTo[i].vin[0].prevout.n], txTo[i], 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC | SCRIPT_ENABLE_SIGHASH_FORKID, false, &txdata)();\r\n+            if (i == j)\r\n+                BOOST_CHECK_MESSAGE(sigOK, strprintf(\"VerifySignature %d %d\", i, j));\r\n+            else\r\n+                BOOST_CHECK_MESSAGE(!sigOK, strprintf(\"VerifySignature %d %d\", i, j));\r\n+            txTo[i].vin[0].scriptSig = sigSave;\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(norecurse)\r\n+{\r\n+    ScriptError err;\r\n+    // Make sure only the outer pay-to-script-hash does the\r\n+    // extra-validation thing:\r\n+    CScript invalidAsScript;\r\n+    invalidAsScript << OP_INVALIDOPCODE << OP_INVALIDOPCODE;\r\n+\r\n+    CScript p2sh = GetScriptForDestination(CScriptID(invalidAsScript));\r\n+\r\n+    CScript scriptSig;\r\n+    scriptSig << Serialize(invalidAsScript);\r\n+\r\n+    // Should not verify, because it will try to execute OP_INVALIDOPCODE\r\n+    BOOST_CHECK(!Verify(scriptSig, p2sh, true, err));\r\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_BAD_OPCODE, ScriptErrorString(err));\r\n+\r\n+    // Try to recur, and verification should succeed because\r\n+    // the inner HASH160 <> EQUAL should only check the hash:\r\n+    CScript p2sh2 = GetScriptForDestination(CScriptID(p2sh));\r\n+    CScript scriptSig2;\r\n+    scriptSig2 << Serialize(invalidAsScript) << Serialize(p2sh);\r\n+\r\n+    BOOST_CHECK(Verify(scriptSig2, p2sh2, true, err));\r\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(set)\r\n+{\r\n+    LOCK(cs_main);\r\n+    // Test the CScript::Set* methods\r\n+    CBasicKeyStore keystore;\r\n+    CKey key[4];\r\n+    std::vector<CPubKey> keys;\r\n+    for (int i = 0; i < 4; i++)\r\n+    {\r\n+        key[i].MakeNewKey(true);\r\n+        keystore.AddKey(key[i]);\r\n+        keys.push_back(key[i].GetPubKey());\r\n+    }\r\n+\r\n+    CScript inner[4];\r\n+    inner[0] = GetScriptForDestination(key[0].GetPubKey().GetID());\r\n+    inner[1] = GetScriptForMultisig(2, std::vector<CPubKey>(keys.begin(), keys.begin()+2));\r\n+    inner[2] = GetScriptForMultisig(1, std::vector<CPubKey>(keys.begin(), keys.begin()+2));\r\n+    inner[3] = GetScriptForMultisig(2, std::vector<CPubKey>(keys.begin(), keys.begin()+3));\r\n+\r\n+    CScript outer[4];\r\n+    for (int i = 0; i < 4; i++)\r\n+    {\r\n+        outer[i] = GetScriptForDestination(CScriptID(inner[i]));\r\n+        keystore.AddCScript(inner[i]);\r\n+    }\r\n+\r\n+    CMutableTransaction txFrom;  // Funding transaction:\r\n+    std::string reason;\r\n+    txFrom.vout.resize(4);\r\n+    for (int i = 0; i < 4; i++)\r\n+    {\r\n+        txFrom.vout[i].scriptPubKey = outer[i];\r\n+        txFrom.vout[i].nValue = CENT;\r\n+    }\r\n+    BOOST_CHECK(IsStandardTx(txFrom, reason));\r\n+\r\n+    CMutableTransaction txTo[4]; // Spending transactions\r\n+    for (int i = 0; i < 4; i++)\r\n+    {\r\n+        txTo[i].vin.resize(1);\r\n+        txTo[i].vout.resize(1);\r\n+        txTo[i].vin[0].prevout.n = i;\r\n+        txTo[i].vin[0].prevout.hash = txFrom.GetHash();\r\n+        txTo[i].vout[0].nValue = 1*CENT;\r\n+        txTo[i].vout[0].scriptPubKey = inner[i];\r\n+        BOOST_CHECK_MESSAGE(IsMine(keystore, txFrom.vout[i].scriptPubKey), strprintf(\"IsMine %d\", i));\r\n+    }\r\n+    for (int i = 0; i < 4; i++)\r\n+    {\r\n+        BOOST_CHECK_MESSAGE(SignSignature(keystore, txFrom, txTo[i], 0, SIGHASH_ALL | SIGHASH_FORKID), strprintf(\"SignSignature %d\", i));\r\n+        BOOST_CHECK_MESSAGE(IsStandardTx(txTo[i], reason), strprintf(\"txTo[%d].IsStandard\", i));\r\n+    }\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(is)\r\n+{\r\n+    // Test CScript::IsPayToScriptHash()\r\n+    uint160 dummy;\r\n+    CScript p2sh;\r\n+    p2sh << OP_HASH160 << ToByteVector(dummy) << OP_EQUAL;\r\n+    BOOST_CHECK(p2sh.IsPayToScriptHash());\r\n+\r\n+    // Not considered pay-to-script-hash if using one of the OP_PUSHDATA opcodes:\r\n+    static const unsigned char direct[] =    { OP_HASH160, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\r\n+    BOOST_CHECK(CScript(direct, direct+sizeof(direct)).IsPayToScriptHash());\r\n+    static const unsigned char pushdata1[] = { OP_HASH160, OP_PUSHDATA1, 20, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\r\n+    BOOST_CHECK(!CScript(pushdata1, pushdata1+sizeof(pushdata1)).IsPayToScriptHash());\r\n+    static const unsigned char pushdata2[] = { OP_HASH160, OP_PUSHDATA2, 20,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\r\n+    BOOST_CHECK(!CScript(pushdata2, pushdata2+sizeof(pushdata2)).IsPayToScriptHash());\r\n+    static const unsigned char pushdata4[] = { OP_HASH160, OP_PUSHDATA4, 20,0,0,0, 0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0, OP_EQUAL };\r\n+    BOOST_CHECK(!CScript(pushdata4, pushdata4+sizeof(pushdata4)).IsPayToScriptHash());\r\n+\r\n+    CScript not_p2sh;\r\n+    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\r\n+\r\n+    not_p2sh.clear(); not_p2sh << OP_HASH160 << ToByteVector(dummy) << ToByteVector(dummy) << OP_EQUAL;\r\n+    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\r\n+\r\n+    not_p2sh.clear(); not_p2sh << OP_NOP << ToByteVector(dummy) << OP_EQUAL;\r\n+    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\r\n+\r\n+    not_p2sh.clear(); not_p2sh << OP_HASH160 << ToByteVector(dummy) << OP_CHECKSIG;\r\n+    BOOST_CHECK(!not_p2sh.IsPayToScriptHash());\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(switchover)\r\n+{\r\n+    // Test switch over code\r\n+    CScript notValid;\r\n+    ScriptError err;\r\n+    notValid << OP_11 << OP_12 << OP_EQUALVERIFY;\r\n+    CScript scriptSig;\r\n+    scriptSig << Serialize(notValid);\r\n+\r\n+    CScript fund = GetScriptForDestination(CScriptID(notValid));\r\n+\r\n+\r\n+    // Validation should succeed under old rules (hash is correct):\r\n+    BOOST_CHECK(Verify(scriptSig, fund, false, err));\r\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\r\n+    // Fail under new:\r\n+    BOOST_CHECK(!Verify(scriptSig, fund, true, err));\r\n+    BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_EQUALVERIFY, ScriptErrorString(err));\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(AreInputsStandard)\r\n+{\r\n+    LOCK(cs_main);\r\n+    CCoinsView coinsDummy;\r\n+    CCoinsViewCache coins(&coinsDummy);\r\n+    CBasicKeyStore keystore;\r\n+    CKey key[6];\r\n+    std::vector<CPubKey> keys;\r\n+    for (int i = 0; i < 6; i++)\r\n+    {\r\n+        key[i].MakeNewKey(true);\r\n+        keystore.AddKey(key[i]);\r\n+    }\r\n+    for (int i = 0; i < 3; i++)\r\n+        keys.push_back(key[i].GetPubKey());\r\n+\r\n+    CMutableTransaction txFrom;\r\n+    txFrom.vout.resize(7);\r\n+\r\n+    // First three are standard:\r\n+    CScript pay1 = GetScriptForDestination(key[0].GetPubKey().GetID());\r\n+    keystore.AddCScript(pay1);\r\n+    CScript pay1of3 = GetScriptForMultisig(1, keys);\r\n+\r\n+    txFrom.vout[0].scriptPubKey = GetScriptForDestination(CScriptID(pay1)); // P2SH (OP_CHECKSIG)\r\n+    txFrom.vout[0].nValue = 1000;\r\n+    txFrom.vout[1].scriptPubKey = pay1; // ordinary OP_CHECKSIG\r\n+    txFrom.vout[1].nValue = 2000;\r\n+    txFrom.vout[2].scriptPubKey = pay1of3; // ordinary OP_CHECKMULTISIG\r\n+    txFrom.vout[2].nValue = 3000;\r\n+\r\n+    // vout[3] is complicated 1-of-3 AND 2-of-3\r\n+    // ... that is OK if wrapped in P2SH:\r\n+    CScript oneAndTwo;\r\n+    oneAndTwo << OP_1 << ToByteVector(key[0].GetPubKey()) << ToByteVector(key[1].GetPubKey()) << ToByteVector(key[2].GetPubKey());\r\n+    oneAndTwo << OP_3 << OP_CHECKMULTISIGVERIFY;\r\n+    oneAndTwo << OP_2 << ToByteVector(key[3].GetPubKey()) << ToByteVector(key[4].GetPubKey()) << ToByteVector(key[5].GetPubKey());\r\n+    oneAndTwo << OP_3 << OP_CHECKMULTISIG;\r\n+    keystore.AddCScript(oneAndTwo);\r\n+    txFrom.vout[3].scriptPubKey = GetScriptForDestination(CScriptID(oneAndTwo));\r\n+    txFrom.vout[3].nValue = 4000;\r\n+\r\n+    // vout[4] is max sigops:\r\n+    CScript fifteenSigops; fifteenSigops << OP_1;\r\n+    for (unsigned i = 0; i < MAX_P2SH_SIGOPS; i++)\r\n+        fifteenSigops << ToByteVector(key[i%3].GetPubKey());\r\n+    fifteenSigops << OP_15 << OP_CHECKMULTISIG;\r\n+    keystore.AddCScript(fifteenSigops);\r\n+    txFrom.vout[4].scriptPubKey = GetScriptForDestination(CScriptID(fifteenSigops));\r\n+    txFrom.vout[4].nValue = 5000;\r\n+\r\n+    // vout[5/6] are non-standard because they exceed MAX_P2SH_SIGOPS\r\n+    CScript sixteenSigops; sixteenSigops << OP_16 << OP_CHECKMULTISIG;\r\n+    keystore.AddCScript(sixteenSigops);\r\n+    txFrom.vout[5].scriptPubKey = GetScriptForDestination(CScriptID(fifteenSigops));\r\n+    txFrom.vout[5].nValue = 5000;\r\n+    CScript twentySigops; twentySigops << OP_CHECKMULTISIG;\r\n+    keystore.AddCScript(twentySigops);\r\n+    txFrom.vout[6].scriptPubKey = GetScriptForDestination(CScriptID(twentySigops));\r\n+    txFrom.vout[6].nValue = 6000;\r\n+\r\n+    AddCoins(coins, txFrom, 0);\r\n+\r\n+    CMutableTransaction txTo;\r\n+    txTo.vout.resize(1);\r\n+    txTo.vout[0].scriptPubKey = GetScriptForDestination(key[1].GetPubKey().GetID());\r\n+\r\n+    txTo.vin.resize(5);\r\n+    for (int i = 0; i < 5; i++)\r\n+    {\r\n+        txTo.vin[i].prevout.n = i;\r\n+        txTo.vin[i].prevout.hash = txFrom.GetHash();\r\n+    }\r\n+    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 0, SIGHASH_ALL | SIGHASH_FORKID));\r\n+    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 1, SIGHASH_ALL | SIGHASH_FORKID));\r\n+    BOOST_CHECK(SignSignature(keystore, txFrom, txTo, 2, SIGHASH_ALL | SIGHASH_FORKID));\r\n+    // SignSignature doesn't know how to sign these. We're\r\n+    // not testing validating signatures, so just create\r\n+    // dummy signatures that DO include the correct P2SH scripts:\r\n+    txTo.vin[3].scriptSig << OP_11 << OP_11 << std::vector<unsigned char>(oneAndTwo.begin(), oneAndTwo.end());\r\n+    txTo.vin[4].scriptSig << std::vector<unsigned char>(fifteenSigops.begin(), fifteenSigops.end());\r\n+\r\n+    BOOST_CHECK(::AreInputsStandard(txTo, coins));\r\n+    // 22 P2SH sigops for all inputs (1 for vin[0], 6 for vin[3], 15 for vin[4]\r\n+    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txTo, coins), 22U);\r\n+\r\n+    CMutableTransaction txToNonStd1;\r\n+    txToNonStd1.vout.resize(1);\r\n+    txToNonStd1.vout[0].scriptPubKey = GetScriptForDestination(key[1].GetPubKey().GetID());\r\n+    txToNonStd1.vout[0].nValue = 1000;\r\n+    txToNonStd1.vin.resize(1);\r\n+    txToNonStd1.vin[0].prevout.n = 5;\r\n+    txToNonStd1.vin[0].prevout.hash = txFrom.GetHash();\r\n+    txToNonStd1.vin[0].scriptSig << std::vector<unsigned char>(sixteenSigops.begin(), sixteenSigops.end());\r\n+\r\n+    BOOST_CHECK(!::AreInputsStandard(txToNonStd1, coins));\r\n+    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd1, coins), 16U);\r\n+\r\n+    CMutableTransaction txToNonStd2;\r\n+    txToNonStd2.vout.resize(1);\r\n+    txToNonStd2.vout[0].scriptPubKey = GetScriptForDestination(key[1].GetPubKey().GetID());\r\n+    txToNonStd2.vout[0].nValue = 1000;\r\n+    txToNonStd2.vin.resize(1);\r\n+    txToNonStd2.vin[0].prevout.n = 6;\r\n+    txToNonStd2.vin[0].prevout.hash = txFrom.GetHash();\r\n+    txToNonStd2.vin[0].scriptSig << std::vector<unsigned char>(twentySigops.begin(), twentySigops.end());\r\n+\r\n+    BOOST_CHECK(!::AreInputsStandard(txToNonStd2, coins));\r\n+    BOOST_CHECK_EQUAL(GetP2SHSigOpCount(txToNonStd2, coins), 20U);\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_SUITE_END()\r"
      },
      {
        "sha": "98eef79f9dca4b31a259c26c7c1919a56537650d",
        "filename": "src/test/script_tests.cpp",
        "status": "modified",
        "additions": 1482,
        "deletions": 1482,
        "changes": 2964,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/script_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/script_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_tests.cpp?ref=b8461f9655ceec64a3bb3835b12b51f2b5ac42e6"
      },
      {
        "sha": "4d001541c6306c711ba90808b0531da6d54a33f4",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 185,
        "deletions": 185,
        "changes": 370,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=b8461f9655ceec64a3bb3835b12b51f2b5ac42e6",
        "patch": "@@ -1,185 +1,185 @@\n-// Copyright (c) 2011-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <test/test_bitcoin.h>\n-\n-#include <chainparams.h>\n-#include <consensus/consensus.h>\n-#include <consensus/validation.h>\n-#include <crypto/sha256.h>\n-#include <validation.h>\n-#include <miner.h>\n-#include <net_processing.h>\n-#include <ui_interface.h>\n-#include <streams.h>\n-#include <rpc/server.h>\n-#include <rpc/register.h>\n-#include <script/sigcache.h>\n-\n-#include <memory>\n-\n-void CConnmanTest::AddNode(CNode& node)\n-{\n-    LOCK(g_connman->cs_vNodes);\n-    g_connman->vNodes.push_back(&node);\n-}\n-\n-void CConnmanTest::ClearNodes()\n-{\n-    LOCK(g_connman->cs_vNodes);\n-    g_connman->vNodes.clear();\n-}\n-\n-uint256 insecure_rand_seed = GetRandHash();\n-FastRandomContext insecure_rand_ctx(insecure_rand_seed);\n-\n-extern bool fPrintToConsole;\n-extern void noui_connect();\n-\n-BasicTestingSetup::BasicTestingSetup(const std::string& chainName)\n-{\n-        SHA256AutoDetect();\n-        RandomInit();\n-        ECC_Start();\n-        SetupEnvironment();\n-        SetupNetworking();\n-        InitSignatureCache();\n-        InitScriptExecutionCache();\n-        fPrintToDebugLog = false; // don't want to write to debug.log file\n-        fCheckBlockIndex = true;\n-        SelectParams(chainName);\n-        noui_connect();\n-}\n-\n-BasicTestingSetup::~BasicTestingSetup()\n-{\n-        ECC_Stop();\n-}\n-\n-TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(chainName)\n-{\n-    const CChainParams& chainparams = Params();\n-        // Ideally we'd move all the RPC tests to the functional testing framework\n-        // instead of unit tests, but for now we need these here.\n-\n-        RegisterAllCoreRPCCommands(tableRPC);\n-        ClearDatadirCache();\n-        pathTemp = fs::temp_directory_path() / strprintf(\"test_bitcoin_%lu_%i\", (unsigned long)GetTime(), (int)(InsecureRandRange(100000)));\n-        fs::create_directories(pathTemp);\n-        gArgs.ForceSetArg(\"-datadir\", pathTemp.string());\n-\n-        // Note that because we don't bother running a scheduler thread here,\n-        // callbacks via CValidationInterface are unreliable, but that's OK,\n-        // our unit tests aren't testing multiple parts of the code at once.\n-        GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\n-\n-        mempool.setSanityCheck(1.0);\n-        pblocktree.reset(new CBlockTreeDB(1 << 20, true));\n-        pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));\n-        pcoinsTip.reset(new CCoinsViewCache(pcoinsdbview.get()));\n-        if (!LoadGenesisBlock(chainparams)) {\n-            throw std::runtime_error(\"LoadGenesisBlock failed.\");\n-        }\n-        {\n-            CValidationState state;\n-            if (!ActivateBestChain(state, chainparams)) {\n-                throw std::runtime_error(\"ActivateBestChain failed.\");\n-            }\n-        }\n-        nScriptCheckThreads = 3;\n-        for (int i=0; i < nScriptCheckThreads-1; i++)\n-            threadGroup.create_thread(&ThreadScriptCheck);\n-        g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.\n-        connman = g_connman.get();\n-        peerLogic.reset(new PeerLogicValidation(connman, scheduler));\n-}\n-\n-TestingSetup::~TestingSetup()\n-{\n-        threadGroup.interrupt_all();\n-        threadGroup.join_all();\n-        GetMainSignals().FlushBackgroundCallbacks();\n-        GetMainSignals().UnregisterBackgroundSignalScheduler();\n-        g_connman.reset();\n-        peerLogic.reset();\n-        UnloadBlockIndex();\n-        pcoinsTip.reset();\n-        pcoinsdbview.reset();\n-        pblocktree.reset();\n-        fs::remove_all(pathTemp);\n-}\n-\n-TestChain100Setup::TestChain100Setup() : TestingSetup(CBaseChainParams::REGTEST)\n-{\n-    // CreateAndProcessBlock() does not support building SegWit blocks, so don't activate in these tests.\n-    // TODO: fix the code to support SegWit blocks.\n-    UpdateVersionBitsParameters(Consensus::DEPLOYMENT_SEGWIT, 0, Consensus::BIP9Deployment::NO_TIMEOUT);\n-    // Generate a 100-block chain:\n-    coinbaseKey.MakeNewKey(true);\n-    CScript scriptPubKey = CScript() <<  ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n-    for (int i = 0; i < COINBASE_MATURITY; i++)\n-    {\n-        std::vector<CMutableTransaction> noTxns;\n-        CBlock b = CreateAndProcessBlock(noTxns, scriptPubKey);\n-        coinbaseTxns.push_back(*b.vtx[0]);\n-    }\n-}\n-\n-//\n-// Create a new block with just given transactions, coinbase paying to\n-// scriptPubKey, and try to add it to the current chain.\n-//\n-CBlock\n-TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>& txns, const CScript& scriptPubKey)\n-{\n-    const CChainParams& chainparams = Params();\n-    std::unique_ptr<CBlockTemplate> pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey);\n-    CBlock& block = pblocktemplate->block;\n-\n-    // Replace mempool-selected txns with just coinbase plus passed-in txns:\n-    block.vtx.resize(1);\n-    for (const CMutableTransaction& tx : txns)\n-        block.vtx.push_back(MakeTransactionRef(tx));\n-    // IncrementExtraNonce creates a valid coinbase and merkleRoot\n-    unsigned int extraNonce = 0;\n-    {\n-        LOCK(cs_main);\n-        IncrementExtraNonce(&block, chainActive.Tip(), extraNonce);\n-    }\n-\n-    while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;\n-\n-    std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(block);\n-    ProcessNewBlock(chainparams, shared_pblock, true, nullptr);\n-\n-    CBlock result = block;\n-    return result;\n-}\n-\n-TestChain100Setup::~TestChain100Setup()\n-{\n-}\n-\n-\n-CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CMutableTransaction &tx) {\n-    CTransaction txn(tx);\n-    return FromTx(txn);\n-}\n-\n-CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CTransaction &txn) {\n-    return CTxMemPoolEntry(MakeTransactionRef(txn), nFee, nTime, nHeight,\n-                           spendsCoinbase, sigOpCost, lp);\n-}\n-\n-/**\n- * @returns a real block (0000000000013b8ab2cd513b0261a14096412195a72a0c4827d229dcc7e0f7af)\n- *      with 9 txs.\n- */\n-CBlock getBlock13b8a()\n-{\n-    CBlock block;\n-    CDataStream stream(ParseHex(\"0100000090f0a9f110702f808219ebea1173056042a714bad51b916cb6800000000000005275289558f51c9966699404ae2294730c3c9f9bda53523ce50e9b95e558da2fdb261b4d4c86041b1ab1bf930901000000010000000000000000000000000000000000000000000000000000000000000000ffffffff07044c86041b0146ffffffff0100f2052a01000000434104e18f7afbe4721580e81e8414fc8c24d7cfacf254bb5c7b949450c3e997c2dc1242487a8169507b631eb3771f2b425483fb13102c4eb5d858eef260fe70fbfae0ac00000000010000000196608ccbafa16abada902780da4dc35dafd7af05fa0da08cf833575f8cf9e836000000004a493046022100dab24889213caf43ae6adc41cf1c9396c08240c199f5225acf45416330fd7dbd022100fe37900e0644bf574493a07fc5edba06dbc07c311b947520c2d514bc5725dcb401ffffffff0100f2052a010000001976a914f15d1921f52e4007b146dfa60f369ed2fc393ce288ac000000000100000001fb766c1288458c2bafcfec81e48b24d98ec706de6b8af7c4e3c29419bfacb56d000000008c493046022100f268ba165ce0ad2e6d93f089cfcd3785de5c963bb5ea6b8c1b23f1ce3e517b9f022100da7c0f21adc6c401887f2bfd1922f11d76159cbc597fbd756a23dcbb00f4d7290141042b4e8625a96127826915a5b109852636ad0da753c9e1d5606a50480cd0c40f1f8b8d898235e571fe9357d9ec842bc4bba1827daaf4de06d71844d0057707966affffffff0280969800000000001976a9146963907531db72d0ed1a0cfb471ccb63923446f388ac80d6e34c000000001976a914f0688ba1c0d1ce182c7af6741e02658c7d4dfcd388ac000000000100000002c40297f730dd7b5a99567eb8d27b78758f607507c52292d02d4031895b52f2ff010000008b483045022100f7edfd4b0aac404e5bab4fd3889e0c6c41aa8d0e6fa122316f68eddd0a65013902205b09cc8b2d56e1cd1f7f2fafd60a129ed94504c4ac7bdc67b56fe67512658b3e014104732012cb962afa90d31b25d8fb0e32c94e513ab7a17805c14ca4c3423e18b4fb5d0e676841733cb83abaf975845c9f6f2a8097b7d04f4908b18368d6fc2d68ecffffffffca5065ff9617cbcba45eb23726df6498a9b9cafed4f54cbab9d227b0035ddefb000000008a473044022068010362a13c7f9919fa832b2dee4e788f61f6f5d344a7c2a0da6ae740605658022006d1af525b9a14a35c003b78b72bd59738cd676f845d1ff3fc25049e01003614014104732012cb962afa90d31b25d8fb0e32c94e513ab7a17805c14ca4c3423e18b4fb5d0e676841733cb83abaf975845c9f6f2a8097b7d04f4908b18368d6fc2d68ecffffffff01001ec4110200000043410469ab4181eceb28985b9b4e895c13fa5e68d85761b7eee311db5addef76fa8621865134a221bd01f28ec9999ee3e021e60766e9d1f3458c115fb28650605f11c9ac000000000100000001cdaf2f758e91c514655e2dc50633d1e4c84989f8aa90a0dbc883f0d23ed5c2fa010000008b48304502207ab51be6f12a1962ba0aaaf24a20e0b69b27a94fac5adf45aa7d2d18ffd9236102210086ae728b370e5329eead9accd880d0cb070aea0c96255fae6c4f1ddcce1fd56e014104462e76fd4067b3a0aa42070082dcb0bf2f388b6495cf33d789904f07d0f55c40fbd4b82963c69b3dc31895d0c772c812b1d5fbcade15312ef1c0e8ebbb12dcd4ffffffff02404b4c00000000001976a9142b6ba7c9d796b75eef7942fc9288edd37c32f5c388ac002d3101000000001976a9141befba0cdc1ad56529371864d9f6cb042faa06b588ac000000000100000001b4a47603e71b61bc3326efd90111bf02d2f549b067f4c4a8fa183b57a0f800cb010000008a4730440220177c37f9a505c3f1a1f0ce2da777c339bd8339ffa02c7cb41f0a5804f473c9230220585b25a2ee80eb59292e52b987dad92acb0c64eced92ed9ee105ad153cdb12d001410443bd44f683467e549dae7d20d1d79cbdb6df985c6e9c029c8d0c6cb46cc1a4d3cf7923c5021b27f7a0b562ada113bc85d5fda5a1b41e87fe6e8802817cf69996ffffffff0280651406000000001976a9145505614859643ab7b547cd7f1f5e7e2a12322d3788ac00aa0271000000001976a914ea4720a7a52fc166c55ff2298e07baf70ae67e1b88ac00000000010000000586c62cd602d219bb60edb14a3e204de0705176f9022fe49a538054fb14abb49e010000008c493046022100f2bc2aba2534becbdf062eb993853a42bbbc282083d0daf9b4b585bd401aa8c9022100b1d7fd7ee0b95600db8535bbf331b19eed8d961f7a8e54159c53675d5f69df8c014104462e76fd4067b3a0aa42070082dcb0bf2f388b6495cf33d789904f07d0f55c40fbd4b82963c69b3dc31895d0c772c812b1d5fbcade15312ef1c0e8ebbb12dcd4ffffffff03ad0e58ccdac3df9dc28a218bcf6f1997b0a93306faaa4b3a28ae83447b2179010000008b483045022100be12b2937179da88599e27bb31c3525097a07cdb52422d165b3ca2f2020ffcf702200971b51f853a53d644ebae9ec8f3512e442b1bcb6c315a5b491d119d10624c83014104462e76fd4067b3a0aa42070082dcb0bf2f388b6495cf33d789904f07d0f55c40fbd4b82963c69b3dc31895d0c772c812b1d5fbcade15312ef1c0e8ebbb12dcd4ffffffff2acfcab629bbc8685792603762c921580030ba144af553d271716a95089e107b010000008b483045022100fa579a840ac258871365dd48cd7552f96c8eea69bd00d84f05b283a0dab311e102207e3c0ee9234814cfbb1b659b83671618f45abc1326b9edcc77d552a4f2a805c0014104462e76fd4067b3a0aa42070082dcb0bf2f388b6495cf33d789904f07d0f55c40fbd4b82963c69b3dc31895d0c772c812b1d5fbcade15312ef1c0e8ebbb12dcd4ffffffffdcdc6023bbc9944a658ddc588e61eacb737ddf0a3cd24f113b5a8634c517fcd2000000008b4830450221008d6df731df5d32267954bd7d2dda2302b74c6c2a6aa5c0ca64ecbabc1af03c75022010e55c571d65da7701ae2da1956c442df81bbf076cdbac25133f99d98a9ed34c014104462e76fd4067b3a0aa42070082dcb0bf2f388b6495cf33d789904f07d0f55c40fbd4b82963c69b3dc31895d0c772c812b1d5fbcade15312ef1c0e8ebbb12dcd4ffffffffe15557cd5ce258f479dfd6dc6514edf6d7ed5b21fcfa4a038fd69f06b83ac76e010000008b483045022023b3e0ab071eb11de2eb1cc3a67261b866f86bf6867d4558165f7c8c8aca2d86022100dc6e1f53a91de3efe8f63512850811f26284b62f850c70ca73ed5de8771fb451014104462e76fd4067b3a0aa42070082dcb0bf2f388b6495cf33d789904f07d0f55c40fbd4b82963c69b3dc31895d0c772c812b1d5fbcade15312ef1c0e8ebbb12dcd4ffffffff01404b4c00000000001976a9142b6ba7c9d796b75eef7942fc9288edd37c32f5c388ac00000000010000000166d7577163c932b4f9690ca6a80b6e4eb001f0a2fa9023df5595602aae96ed8d000000008a4730440220262b42546302dfb654a229cefc86432b89628ff259dc87edd1154535b16a67e102207b4634c020a97c3e7bbd0d4d19da6aa2269ad9dded4026e896b213d73ca4b63f014104979b82d02226b3a4597523845754d44f13639e3bf2df5e82c6aab2bdc79687368b01b1ab8b19875ae3c90d661a3d0a33161dab29934edeb36aa01976be3baf8affffffff02404b4c00000000001976a9144854e695a02af0aeacb823ccbc272134561e0a1688ac40420f00000000001976a914abee93376d6b37b5c2940655a6fcaf1c8e74237988ac0000000001000000014e3f8ef2e91349a9059cb4f01e54ab2597c1387161d3da89919f7ea6acdbb371010000008c49304602210081f3183471a5ca22307c0800226f3ef9c353069e0773ac76bb580654d56aa523022100d4c56465bdc069060846f4fbf2f6b20520b2a80b08b168b31e66ddb9c694e240014104976c79848e18251612f8940875b2b08d06e6dc73b9840e8860c066b7e87432c477e9a59a453e71e6d76d5fe34058b800a098fc1740ce3012e8fc8a00c96af966ffffffff02c0e1e400000000001976a9144134e75a6fcb6042034aab5e18570cf1f844f54788ac404b4c00000000001976a9142b6ba7c9d796b75eef7942fc9288edd37c32f5c388ac00000000\"), SER_NETWORK, PROTOCOL_VERSION);\n-    stream >> block;\n-    return block;\n-}\n+// Copyright (c) 2011-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <test/test_bitcoin.h>\r\n+\r\n+#include <chainparams.h>\r\n+#include <consensus/consensus.h>\r\n+#include <consensus/validation.h>\r\n+#include <crypto/sha256.h>\r\n+#include <validation.h>\r\n+#include <miner.h>\r\n+#include <net_processing.h>\r\n+#include <ui_interface.h>\r\n+#include <streams.h>\r\n+#include <rpc/server.h>\r\n+#include <rpc/register.h>\r\n+#include <script/sigcache.h>\r\n+\r\n+#include <memory>\r\n+\r\n+void CConnmanTest::AddNode(CNode& node)\r\n+{\r\n+    LOCK(g_connman->cs_vNodes);\r\n+    g_connman->vNodes.push_back(&node);\r\n+}\r\n+\r\n+void CConnmanTest::ClearNodes()\r\n+{\r\n+    LOCK(g_connman->cs_vNodes);\r\n+    g_connman->vNodes.clear();\r\n+}\r\n+\r\n+uint256 insecure_rand_seed = GetRandHash();\r\n+FastRandomContext insecure_rand_ctx(insecure_rand_seed);\r\n+\r\n+extern bool fPrintToConsole;\r\n+extern void noui_connect();\r\n+\r\n+BasicTestingSetup::BasicTestingSetup(const std::string& chainName)\r\n+{\r\n+        SHA256AutoDetect();\r\n+        RandomInit();\r\n+        ECC_Start();\r\n+        SetupEnvironment();\r\n+        SetupNetworking();\r\n+        InitSignatureCache();\r\n+        InitScriptExecutionCache();\r\n+        fPrintToDebugLog = false; // don't want to write to debug.log file\r\n+        fCheckBlockIndex = true;\r\n+        SelectParams(chainName);\r\n+        noui_connect();\r\n+}\r\n+\r\n+BasicTestingSetup::~BasicTestingSetup()\r\n+{\r\n+        ECC_Stop();\r\n+}\r\n+\r\n+TestingSetup::TestingSetup(const std::string& chainName) : BasicTestingSetup(chainName)\r\n+{\r\n+    const CChainParams& chainparams = Params();\r\n+        // Ideally we'd move all the RPC tests to the functional testing framework\r\n+        // instead of unit tests, but for now we need these here.\r\n+\r\n+        RegisterAllCoreRPCCommands(tableRPC);\r\n+        ClearDatadirCache();\r\n+        pathTemp = fs::temp_directory_path() / strprintf(\"test_bitcoin_%lu_%i\", (unsigned long)GetTime(), (int)(InsecureRandRange(100000)));\r\n+        fs::create_directories(pathTemp);\r\n+        gArgs.ForceSetArg(\"-datadir\", pathTemp.string());\r\n+\r\n+        // Note that because we don't bother running a scheduler thread here,\r\n+        // callbacks via CValidationInterface are unreliable, but that's OK,\r\n+        // our unit tests aren't testing multiple parts of the code at once.\r\n+        GetMainSignals().RegisterBackgroundSignalScheduler(scheduler);\r\n+\r\n+        mempool.setSanityCheck(1.0);\r\n+        pblocktree.reset(new CBlockTreeDB(1 << 20, true));\r\n+        pcoinsdbview.reset(new CCoinsViewDB(1 << 23, true));\r\n+        pcoinsTip.reset(new CCoinsViewCache(pcoinsdbview.get()));\r\n+        if (!LoadGenesisBlock(chainparams)) {\r\n+            throw std::runtime_error(\"LoadGenesisBlock failed.\");\r\n+        }\r\n+        {\r\n+            CValidationState state;\r\n+            if (!ActivateBestChain(state, chainparams)) {\r\n+                throw std::runtime_error(\"ActivateBestChain failed.\");\r\n+            }\r\n+        }\r\n+        nScriptCheckThreads = 3;\r\n+        for (int i=0; i < nScriptCheckThreads-1; i++)\r\n+            threadGroup.create_thread(&ThreadScriptCheck);\r\n+        g_connman = std::unique_ptr<CConnman>(new CConnman(0x1337, 0x1337)); // Deterministic randomness for tests.\r\n+        connman = g_connman.get();\r\n+        peerLogic.reset(new PeerLogicValidation(connman, scheduler));\r\n+}\r\n+\r\n+TestingSetup::~TestingSetup()\r\n+{\r\n+        threadGroup.interrupt_all();\r\n+        threadGroup.join_all();\r\n+        GetMainSignals().FlushBackgroundCallbacks();\r\n+        GetMainSignals().UnregisterBackgroundSignalScheduler();\r\n+        g_connman.reset();\r\n+        peerLogic.reset();\r\n+        UnloadBlockIndex();\r\n+        pcoinsTip.reset();\r\n+        pcoinsdbview.reset();\r\n+        pblocktree.reset();\r\n+        fs::remove_all(pathTemp);\r\n+}\r\n+\r\n+TestChain100Setup::TestChain100Setup() : TestingSetup(CBaseChainParams::REGTEST)\r\n+{\r\n+    // CreateAndProcessBlock() does not support building SegWit blocks, so don't activate in these tests.\r\n+    // TODO: fix the code to support SegWit blocks.\r\n+    UpdateVersionBitsParameters(Consensus::DEPLOYMENT_SEGWIT, 0, Consensus::BIP9Deployment::NO_TIMEOUT);\r\n+    // Generate a 100-block chain:\r\n+    coinbaseKey.MakeNewKey(true);\r\n+    CScript scriptPubKey = CScript() <<  ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\r\n+    for (int i = 0; i < COINBASE_MATURITY; i++)\r\n+    {\r\n+        std::vector<CMutableTransaction> noTxns;\r\n+        CBlock b = CreateAndProcessBlock(noTxns, scriptPubKey);\r\n+        coinbaseTxns.push_back(*b.vtx[0]);\r\n+    }\r\n+}\r\n+\r\n+//\r\n+// Create a new block with just given transactions, coinbase paying to\r\n+// scriptPubKey, and try to add it to the current chain.\r\n+//\r\n+CBlock\r\n+TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>& txns, const CScript& scriptPubKey)\r\n+{\r\n+    const CChainParams& chainparams = Params();\r\n+    std::unique_ptr<CBlockTemplate> pblocktemplate = BlockAssembler(chainparams).CreateNewBlock(scriptPubKey);\r\n+    CBlock& block = pblocktemplate->block;\r\n+\r\n+    // Replace mempool-selected txns with just coinbase plus passed-in txns:\r\n+    block.vtx.resize(1);\r\n+    for (const CMutableTransaction& tx : txns)\r\n+        block.vtx.push_back(MakeTransactionRef(tx));\r\n+    // IncrementExtraNonce creates a valid coinbase and merkleRoot\r\n+    unsigned int extraNonce = 0;\r\n+    {\r\n+        LOCK(cs_main);\r\n+        IncrementExtraNonce(&block, chainActive.Tip(), extraNonce);\r\n+    }\r\n+\r\n+    while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus(), block.IsBtvBranched())) ++block.nNonce;\r\n+\r\n+    std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(block);\r\n+    ProcessNewBlock(chainparams, shared_pblock, true, nullptr);\r\n+\r\n+    CBlock result = block;\r\n+    return result;\r\n+}\r\n+\r\n+TestChain100Setup::~TestChain100Setup()\r\n+{\r\n+}\r\n+\r\n+\r\n+CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CMutableTransaction &tx) {\r\n+    CTransaction txn(tx);\r\n+    return FromTx(txn);\r\n+}\r\n+\r\n+CTxMemPoolEntry TestMemPoolEntryHelper::FromTx(const CTransaction &txn) {\r\n+    return CTxMemPoolEntry(MakeTransactionRef(txn), nFee, nTime, nHeight,\r\n+                           spendsCoinbase, sigOpCost, lp);\r\n+}\r\n+\r\n+/**\r\n+ * @returns a real block (0000000000013b8ab2cd513b0261a14096412195a72a0c4827d229dcc7e0f7af)\r\n+ *      with 9 txs.\r\n+ */\r\n+CBlock getBlock13b8a()\r\n+{\r\n+    CBlock block;\r\n+    CDataStream stream(ParseHex(\"0100000090f0a9f110702f808219ebea1173056042a714bad51b916cb6800000000000005275289558f51c9966699404ae2294730c3c9f9bda53523ce50e9b95e558da2fdb261b4d4c86041b1ab1bf930901000000010000000000000000000000000000000000000000000000000000000000000000ffffffff07044c86041b0146ffffffff0100f2052a01000000434104e18f7afbe4721580e81e8414fc8c24d7cfacf254bb5c7b949450c3e997c2dc1242487a8169507b631eb3771f2b425483fb13102c4eb5d858eef260fe70fbfae0ac00000000010000000196608ccbafa16abada902780da4dc35dafd7af05fa0da08cf833575f8cf9e836000000004a493046022100dab24889213caf43ae6adc41cf1c9396c08240c199f5225acf45416330fd7dbd022100fe37900e0644bf574493a07fc5edba06dbc07c311b947520c2d514bc5725dcb401ffffffff0100f2052a010000001976a914f15d1921f52e4007b146dfa60f369ed2fc393ce288ac000000000100000001fb766c1288458c2bafcfec81e48b24d98ec706de6b8af7c4e3c29419bfacb56d000000008c493046022100f268ba165ce0ad2e6d93f089cfcd3785de5c963bb5ea6b8c1b23f1ce3e517b9f022100da7c0f21adc6c401887f2bfd1922f11d76159cbc597fbd756a23dcbb00f4d7290141042b4e8625a96127826915a5b109852636ad0da753c9e1d5606a50480cd0c40f1f8b8d898235e571fe9357d9ec842bc4bba1827daaf4de06d71844d0057707966affffffff0280969800000000001976a9146963907531db72d0ed1a0cfb471ccb63923446f388ac80d6e34c000000001976a914f0688ba1c0d1ce182c7af6741e02658c7d4dfcd388ac000000000100000002c40297f730dd7b5a99567eb8d27b78758f607507c52292d02d4031895b52f2ff010000008b483045022100f7edfd4b0aac404e5bab4fd3889e0c6c41aa8d0e6fa122316f68eddd0a65013902205b09cc8b2d56e1cd1f7f2fafd60a129ed94504c4ac7bdc67b56fe67512658b3e014104732012cb962afa90d31b25d8fb0e32c94e513ab7a17805c14ca4c3423e18b4fb5d0e676841733cb83abaf975845c9f6f2a8097b7d04f4908b18368d6fc2d68ecffffffffca5065ff9617cbcba45eb23726df6498a9b9cafed4f54cbab9d227b0035ddefb000000008a473044022068010362a13c7f9919fa832b2dee4e788f61f6f5d344a7c2a0da6ae740605658022006d1af525b9a14a35c003b78b72bd59738cd676f845d1ff3fc25049e01003614014104732012cb962afa90d31b25d8fb0e32c94e513ab7a17805c14ca4c3423e18b4fb5d0e676841733cb83abaf975845c9f6f2a8097b7d04f4908b18368d6fc2d68ecffffffff01001ec4110200000043410469ab4181eceb28985b9b4e895c13fa5e68d85761b7eee311db5addef76fa8621865134a221bd01f28ec9999ee3e021e60766e9d1f3458c115fb28650605f11c9ac000000000100000001cdaf2f758e91c514655e2dc50633d1e4c84989f8aa90a0dbc883f0d23ed5c2fa010000008b48304502207ab51be6f12a1962ba0aaaf24a20e0b69b27a94fac5adf45aa7d2d18ffd9236102210086ae728b370e5329eead9accd880d0cb070aea0c96255fae6c4f1ddcce1fd56e014104462e76fd4067b3a0aa42070082dcb0bf2f388b6495cf33d789904f07d0f55c40fbd4b82963c69b3dc31895d0c772c812b1d5fbcade15312ef1c0e8ebbb12dcd4ffffffff02404b4c00000000001976a9142b6ba7c9d796b75eef7942fc9288edd37c32f5c388ac002d3101000000001976a9141befba0cdc1ad56529371864d9f6cb042faa06b588ac000000000100000001b4a47603e71b61bc3326efd90111bf02d2f549b067f4c4a8fa183b57a0f800cb010000008a4730440220177c37f9a505c3f1a1f0ce2da777c339bd8339ffa02c7cb41f0a5804f473c9230220585b25a2ee80eb59292e52b987dad92acb0c64eced92ed9ee105ad153cdb12d001410443bd44f683467e549dae7d20d1d79cbdb6df985c6e9c029c8d0c6cb46cc1a4d3cf7923c5021b27f7a0b562ada113bc85d5fda5a1b41e87fe6e8802817cf69996ffffffff0280651406000000001976a9145505614859643ab7b547cd7f1f5e7e2a12322d3788ac00aa0271000000001976a914ea4720a7a52fc166c55ff2298e07baf70ae67e1b88ac00000000010000000586c62cd602d219bb60edb14a3e204de0705176f9022fe49a538054fb14abb49e010000008c493046022100f2bc2aba2534becbdf062eb993853a42bbbc282083d0daf9b4b585bd401aa8c9022100b1d7fd7ee0b95600db8535bbf331b19eed8d961f7a8e54159c53675d5f69df8c014104462e76fd4067b3a0aa42070082dcb0bf2f388b6495cf33d789904f07d0f55c40fbd4b82963c69b3dc31895d0c772c812b1d5fbcade15312ef1c0e8ebbb12dcd4ffffffff03ad0e58ccdac3df9dc28a218bcf6f1997b0a93306faaa4b3a28ae83447b2179010000008b483045022100be12b2937179da88599e27bb31c3525097a07cdb52422d165b3ca2f2020ffcf702200971b51f853a53d644ebae9ec8f3512e442b1bcb6c315a5b491d119d10624c83014104462e76fd4067b3a0aa42070082dcb0bf2f388b6495cf33d789904f07d0f55c40fbd4b82963c69b3dc31895d0c772c812b1d5fbcade15312ef1c0e8ebbb12dcd4ffffffff2acfcab629bbc8685792603762c921580030ba144af553d271716a95089e107b010000008b483045022100fa579a840ac258871365dd48cd7552f96c8eea69bd00d84f05b283a0dab311e102207e3c0ee9234814cfbb1b659b83671618f45abc1326b9edcc77d552a4f2a805c0014104462e76fd4067b3a0aa42070082dcb0bf2f388b6495cf33d789904f07d0f55c40fbd4b82963c69b3dc31895d0c772c812b1d5fbcade15312ef1c0e8ebbb12dcd4ffffffffdcdc6023bbc9944a658ddc588e61eacb737ddf0a3cd24f113b5a8634c517fcd2000000008b4830450221008d6df731df5d32267954bd7d2dda2302b74c6c2a6aa5c0ca64ecbabc1af03c75022010e55c571d65da7701ae2da1956c442df81bbf076cdbac25133f99d98a9ed34c014104462e76fd4067b3a0aa42070082dcb0bf2f388b6495cf33d789904f07d0f55c40fbd4b82963c69b3dc31895d0c772c812b1d5fbcade15312ef1c0e8ebbb12dcd4ffffffffe15557cd5ce258f479dfd6dc6514edf6d7ed5b21fcfa4a038fd69f06b83ac76e010000008b483045022023b3e0ab071eb11de2eb1cc3a67261b866f86bf6867d4558165f7c8c8aca2d86022100dc6e1f53a91de3efe8f63512850811f26284b62f850c70ca73ed5de8771fb451014104462e76fd4067b3a0aa42070082dcb0bf2f388b6495cf33d789904f07d0f55c40fbd4b82963c69b3dc31895d0c772c812b1d5fbcade15312ef1c0e8ebbb12dcd4ffffffff01404b4c00000000001976a9142b6ba7c9d796b75eef7942fc9288edd37c32f5c388ac00000000010000000166d7577163c932b4f9690ca6a80b6e4eb001f0a2fa9023df5595602aae96ed8d000000008a4730440220262b42546302dfb654a229cefc86432b89628ff259dc87edd1154535b16a67e102207b4634c020a97c3e7bbd0d4d19da6aa2269ad9dded4026e896b213d73ca4b63f014104979b82d02226b3a4597523845754d44f13639e3bf2df5e82c6aab2bdc79687368b01b1ab8b19875ae3c90d661a3d0a33161dab29934edeb36aa01976be3baf8affffffff02404b4c00000000001976a9144854e695a02af0aeacb823ccbc272134561e0a1688ac40420f00000000001976a914abee93376d6b37b5c2940655a6fcaf1c8e74237988ac0000000001000000014e3f8ef2e91349a9059cb4f01e54ab2597c1387161d3da89919f7ea6acdbb371010000008c49304602210081f3183471a5ca22307c0800226f3ef9c353069e0773ac76bb580654d56aa523022100d4c56465bdc069060846f4fbf2f6b20520b2a80b08b168b31e66ddb9c694e240014104976c79848e18251612f8940875b2b08d06e6dc73b9840e8860c066b7e87432c477e9a59a453e71e6d76d5fe34058b800a098fc1740ce3012e8fc8a00c96af966ffffffff02c0e1e400000000001976a9144134e75a6fcb6042034aab5e18570cf1f844f54788ac404b4c00000000001976a9142b6ba7c9d796b75eef7942fc9288edd37c32f5c388ac00000000\"), SER_NETWORK, PROTOCOL_VERSION);\r\n+    stream >> block;\r\n+    return block;\r\n+}\r"
      },
      {
        "sha": "1eac31cddc99476c190dfef1f4da2d242c209008",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 763,
        "deletions": 762,
        "changes": 1525,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=b8461f9655ceec64a3bb3835b12b51f2b5ac42e6",
        "patch": "@@ -1,762 +1,763 @@\n-// Copyright (c) 2011-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <test/data/tx_invalid.json.h>\n-#include <test/data/tx_valid.json.h>\n-#include <test/test_bitcoin.h>\n-\n-#include <clientversion.h>\n-#include <checkqueue.h>\n-#include <consensus/tx_verify.h>\n-#include <consensus/validation.h>\n-#include <core_io.h>\n-#include <key.h>\n-#include <keystore.h>\n-#include <validation.h>\n-#include <policy/policy.h>\n-#include <script/script.h>\n-#include <script/sign.h>\n-#include <script/script_error.h>\n-#include <script/standard.h>\n-#include <utilstrencodings.h>\n-\n-#include <map>\n-#include <string>\n-\n-#include <boost/algorithm/string/classification.hpp>\n-#include <boost/algorithm/string/split.hpp>\n-#include <boost/test/unit_test.hpp>\n-\n-#include <univalue.h>\n-\n-typedef std::vector<unsigned char> valtype;\n-\n-// In script_tests.cpp\n-extern UniValue read_json(const std::string& jsondata);\n-\n-static std::map<std::string, unsigned int> mapFlagNames = {\n-    {std::string(\"NONE\"), (unsigned int)SCRIPT_VERIFY_NONE},\n-    {std::string(\"P2SH\"), (unsigned int)SCRIPT_VERIFY_P2SH},\n-    {std::string(\"STRICTENC\"), (unsigned int)SCRIPT_VERIFY_STRICTENC},\n-    {std::string(\"DERSIG\"), (unsigned int)SCRIPT_VERIFY_DERSIG},\n-    {std::string(\"LOW_S\"), (unsigned int)SCRIPT_VERIFY_LOW_S},\n-    {std::string(\"SIGPUSHONLY\"), (unsigned int)SCRIPT_VERIFY_SIGPUSHONLY},\n-    {std::string(\"MINIMALDATA\"), (unsigned int)SCRIPT_VERIFY_MINIMALDATA},\n-    {std::string(\"NULLDUMMY\"), (unsigned int)SCRIPT_VERIFY_NULLDUMMY},\n-    {std::string(\"DISCOURAGE_UPGRADABLE_NOPS\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS},\n-    {std::string(\"CLEANSTACK\"), (unsigned int)SCRIPT_VERIFY_CLEANSTACK},\n-    {std::string(\"MINIMALIF\"), (unsigned int)SCRIPT_VERIFY_MINIMALIF},\n-    {std::string(\"NULLFAIL\"), (unsigned int)SCRIPT_VERIFY_NULLFAIL},\n-    {std::string(\"CHECKLOCKTIMEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY},\n-    {std::string(\"CHECKSEQUENCEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY},\n-    {std::string(\"WITNESS\"), (unsigned int)SCRIPT_VERIFY_WITNESS},\n-    {std::string(\"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM},\n-    {std::string(\"WITNESS_PUBKEYTYPE\"), (unsigned int)SCRIPT_VERIFY_WITNESS_PUBKEYTYPE},\n-};\n-\n-unsigned int ParseScriptFlags(std::string strFlags)\n-{\n-    if (strFlags.empty()) {\n-        return 0;\n-    }\n-    unsigned int flags = 0;\n-    std::vector<std::string> words;\n-    boost::algorithm::split(words, strFlags, boost::algorithm::is_any_of(\",\"));\n-\n-    for (std::string word : words)\n-    {\n-        if (!mapFlagNames.count(word))\n-            BOOST_ERROR(\"Bad test: unknown verification flag '\" << word << \"'\");\n-        flags |= mapFlagNames[word];\n-    }\n-\n-    return flags;\n-}\n-\n-std::string FormatScriptFlags(unsigned int flags)\n-{\n-    if (flags == 0) {\n-        return \"\";\n-    }\n-    std::string ret;\n-    std::map<std::string, unsigned int>::const_iterator it = mapFlagNames.begin();\n-    while (it != mapFlagNames.end()) {\n-        if (flags & it->second) {\n-            ret += it->first + \",\";\n-        }\n-        it++;\n-    }\n-    return ret.substr(0, ret.size() - 1);\n-}\n-\n-BOOST_FIXTURE_TEST_SUITE(transaction_tests, BasicTestingSetup)\n-\n-BOOST_AUTO_TEST_CASE(tx_valid)\n-{\n-    // Read tests from test/data/tx_valid.json\n-    // Format is an array of arrays\n-    // Inner arrays are either [ \"comment\" ]\n-    // or [[[prevout hash, prevout index, prevout scriptPubKey], [input 2], ...],\"], serializedTransaction, verifyFlags\n-    // ... where all scripts are stringified scripts.\n-    //\n-    // verifyFlags is a comma separated list of script verification flags to apply, or \"NONE\"\n-    UniValue tests = read_json(std::string(json_tests::tx_valid, json_tests::tx_valid + sizeof(json_tests::tx_valid)));\n-\n-    ScriptError err;\n-    for (unsigned int idx = 0; idx < tests.size(); idx++) {\n-        UniValue test = tests[idx];\n-        std::string strTest = test.write();\n-        if (test[0].isArray())\n-        {\n-            if (test.size() != 3 || !test[1].isStr() || !test[2].isStr())\n-            {\n-                BOOST_ERROR(\"Bad test: \" << strTest);\n-                continue;\n-            }\n-\n-            std::map<COutPoint, CScript> mapprevOutScriptPubKeys;\n-            std::map<COutPoint, int64_t> mapprevOutValues;\n-            UniValue inputs = test[0].get_array();\n-            bool fValid = true;\n-\t    for (unsigned int inpIdx = 0; inpIdx < inputs.size(); inpIdx++) {\n-\t        const UniValue& input = inputs[inpIdx];\n-                if (!input.isArray())\n-                {\n-                    fValid = false;\n-                    break;\n-                }\n-                UniValue vinput = input.get_array();\n-                if (vinput.size() < 3 || vinput.size() > 4)\n-                {\n-                    fValid = false;\n-                    break;\n-                }\n-                COutPoint outpoint(uint256S(vinput[0].get_str()), vinput[1].get_int());\n-                mapprevOutScriptPubKeys[outpoint] = ParseScript(vinput[2].get_str());\n-                if (vinput.size() >= 4)\n-                {\n-                    mapprevOutValues[outpoint] = vinput[3].get_int64();\n-                }\n-            }\n-            if (!fValid)\n-            {\n-                BOOST_ERROR(\"Bad test: \" << strTest);\n-                continue;\n-            }\n-\n-            std::string transaction = test[1].get_str();\n-            CDataStream stream(ParseHex(transaction), SER_NETWORK, PROTOCOL_VERSION);\n-            CTransaction tx(deserialize, stream);\n-\n-            CValidationState state;\n-            BOOST_CHECK_MESSAGE(CheckTransaction(tx, state), strTest);\n-            BOOST_CHECK(state.IsValid());\n-\n-            PrecomputedTransactionData txdata(tx);\n-            for (unsigned int i = 0; i < tx.vin.size(); i++)\n-            {\n-                if (!mapprevOutScriptPubKeys.count(tx.vin[i].prevout))\n-                {\n-                    BOOST_ERROR(\"Bad test: \" << strTest);\n-                    break;\n-                }\n-\n-                CAmount amount = 0;\n-                if (mapprevOutValues.count(tx.vin[i].prevout)) {\n-                    amount = mapprevOutValues[tx.vin[i].prevout];\n-                }\n-                unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n-                const CScriptWitness *witness = &tx.vin[i].scriptWitness;\n-                BOOST_CHECK_MESSAGE(VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n-                                                 witness, verify_flags, TransactionSignatureChecker(&tx, i, amount, txdata), &err),\n-                                    strTest);\n-                BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\n-            }\n-        }\n-    }\n-}\n-\n-BOOST_AUTO_TEST_CASE(tx_invalid)\n-{\n-    // Read tests from test/data/tx_invalid.json\n-    // Format is an array of arrays\n-    // Inner arrays are either [ \"comment\" ]\n-    // or [[[prevout hash, prevout index, prevout scriptPubKey], [input 2], ...],\"], serializedTransaction, verifyFlags\n-    // ... where all scripts are stringified scripts.\n-    //\n-    // verifyFlags is a comma separated list of script verification flags to apply, or \"NONE\"\n-    UniValue tests = read_json(std::string(json_tests::tx_invalid, json_tests::tx_invalid + sizeof(json_tests::tx_invalid)));\n-\n-    // Initialize to SCRIPT_ERR_OK. The tests expect err to be changed to a\n-    // value other than SCRIPT_ERR_OK.\n-    ScriptError err = SCRIPT_ERR_OK;\n-    for (unsigned int idx = 0; idx < tests.size(); idx++) {\n-        UniValue test = tests[idx];\n-        std::string strTest = test.write();\n-        if (test[0].isArray())\n-        {\n-            if (test.size() != 3 || !test[1].isStr() || !test[2].isStr())\n-            {\n-                BOOST_ERROR(\"Bad test: \" << strTest);\n-                continue;\n-            }\n-\n-            std::map<COutPoint, CScript> mapprevOutScriptPubKeys;\n-            std::map<COutPoint, int64_t> mapprevOutValues;\n-            UniValue inputs = test[0].get_array();\n-            bool fValid = true;\n-\t    for (unsigned int inpIdx = 0; inpIdx < inputs.size(); inpIdx++) {\n-\t        const UniValue& input = inputs[inpIdx];\n-                if (!input.isArray())\n-                {\n-                    fValid = false;\n-                    break;\n-                }\n-                UniValue vinput = input.get_array();\n-                if (vinput.size() < 3 || vinput.size() > 4)\n-                {\n-                    fValid = false;\n-                    break;\n-                }\n-                COutPoint outpoint(uint256S(vinput[0].get_str()), vinput[1].get_int());\n-                mapprevOutScriptPubKeys[outpoint] = ParseScript(vinput[2].get_str());\n-                if (vinput.size() >= 4)\n-                {\n-                    mapprevOutValues[outpoint] = vinput[3].get_int64();\n-                }\n-            }\n-            if (!fValid)\n-            {\n-                BOOST_ERROR(\"Bad test: \" << strTest);\n-                continue;\n-            }\n-\n-            std::string transaction = test[1].get_str();\n-            CDataStream stream(ParseHex(transaction), SER_NETWORK, PROTOCOL_VERSION );\n-            CTransaction tx(deserialize, stream);\n-\n-            CValidationState state;\n-            fValid = CheckTransaction(tx, state) && state.IsValid();\n-\n-            PrecomputedTransactionData txdata(tx);\n-            for (unsigned int i = 0; i < tx.vin.size() && fValid; i++)\n-            {\n-                if (!mapprevOutScriptPubKeys.count(tx.vin[i].prevout))\n-                {\n-                    BOOST_ERROR(\"Bad test: \" << strTest);\n-                    break;\n-                }\n-\n-                unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\n-                CAmount amount = 0;\n-                if (mapprevOutValues.count(tx.vin[i].prevout)) {\n-                    amount = mapprevOutValues[tx.vin[i].prevout];\n-                }\n-                const CScriptWitness *witness = &tx.vin[i].scriptWitness;\n-                fValid = VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\n-                                      witness, verify_flags, TransactionSignatureChecker(&tx, i, amount, txdata), &err);\n-            }\n-            BOOST_CHECK_MESSAGE(!fValid, strTest);\n-            BOOST_CHECK_MESSAGE(err != SCRIPT_ERR_OK, ScriptErrorString(err));\n-        }\n-    }\n-}\n-\n-BOOST_AUTO_TEST_CASE(basic_transaction_tests)\n-{\n-    // Random real transaction (e2769b09e784f32f62ef849763d4f45b98e07ba658647343b915ff832b110436)\n-    unsigned char ch[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x6b, 0xff, 0x7f, 0xcd, 0x4f, 0x85, 0x65, 0xef, 0x40, 0x6d, 0xd5, 0xd6, 0x3d, 0x4f, 0xf9, 0x4f, 0x31, 0x8f, 0xe8, 0x20, 0x27, 0xfd, 0x4d, 0xc4, 0x51, 0xb0, 0x44, 0x74, 0x01, 0x9f, 0x74, 0xb4, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x49, 0x30, 0x46, 0x02, 0x21, 0x00, 0xda, 0x0d, 0xc6, 0xae, 0xce, 0xfe, 0x1e, 0x06, 0xef, 0xdf, 0x05, 0x77, 0x37, 0x57, 0xde, 0xb1, 0x68, 0x82, 0x09, 0x30, 0xe3, 0xb0, 0xd0, 0x3f, 0x46, 0xf5, 0xfc, 0xf1, 0x50, 0xbf, 0x99, 0x0c, 0x02, 0x21, 0x00, 0xd2, 0x5b, 0x5c, 0x87, 0x04, 0x00, 0x76, 0xe4, 0xf2, 0x53, 0xf8, 0x26, 0x2e, 0x76, 0x3e, 0x2d, 0xd5, 0x1e, 0x7f, 0xf0, 0xbe, 0x15, 0x77, 0x27, 0xc4, 0xbc, 0x42, 0x80, 0x7f, 0x17, 0xbd, 0x39, 0x01, 0x41, 0x04, 0xe6, 0xc2, 0x6e, 0xf6, 0x7d, 0xc6, 0x10, 0xd2, 0xcd, 0x19, 0x24, 0x84, 0x78, 0x9a, 0x6c, 0xf9, 0xae, 0xa9, 0x93, 0x0b, 0x94, 0x4b, 0x7e, 0x2d, 0xb5, 0x34, 0x2b, 0x9d, 0x9e, 0x5b, 0x9f, 0xf7, 0x9a, 0xff, 0x9a, 0x2e, 0xe1, 0x97, 0x8d, 0xd7, 0xfd, 0x01, 0xdf, 0xc5, 0x22, 0xee, 0x02, 0x28, 0x3d, 0x3b, 0x06, 0xa9, 0xd0, 0x3a, 0xcf, 0x80, 0x96, 0x96, 0x8d, 0x7d, 0xbb, 0x0f, 0x91, 0x78, 0xff, 0xff, 0xff, 0xff, 0x02, 0x8b, 0xa7, 0x94, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xba, 0xde, 0xec, 0xfd, 0xef, 0x05, 0x07, 0x24, 0x7f, 0xc8, 0xf7, 0x42, 0x41, 0xd7, 0x3b, 0xc0, 0x39, 0x97, 0x2d, 0x7b, 0x88, 0xac, 0x40, 0x94, 0xa8, 0x02, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xc1, 0x09, 0x32, 0x48, 0x3f, 0xec, 0x93, 0xed, 0x51, 0xf5, 0xfe, 0x95, 0xe7, 0x25, 0x59, 0xf2, 0xcc, 0x70, 0x43, 0xf9, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00};\n-    std::vector<unsigned char> vch(ch, ch + sizeof(ch) -1);\n-    CDataStream stream(vch, SER_DISK, CLIENT_VERSION);\n-    CMutableTransaction tx;\n-    stream >> tx;\n-    CValidationState state;\n-    BOOST_CHECK_MESSAGE(CheckTransaction(tx, state) && state.IsValid(), \"Simple deserialized transaction should be valid.\");\n-\n-    // Check that duplicate txins fail\n-    tx.vin.push_back(tx.vin[0]);\n-    BOOST_CHECK_MESSAGE(!CheckTransaction(tx, state) || !state.IsValid(), \"Transaction with duplicate txins should be invalid.\");\n-}\n-\n-//\n-// Helper: create two dummy transactions, each with\n-// two outputs.  The first has 11 and 50 CENT outputs\n-// paid to a TX_PUBKEY, the second 21 and 22 CENT outputs\n-// paid to a TX_PUBKEYHASH.\n-//\n-static std::vector<CMutableTransaction>\n-SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n-{\n-    std::vector<CMutableTransaction> dummyTransactions;\n-    dummyTransactions.resize(2);\n-\n-    // Add some keys to the keystore:\n-    CKey key[4];\n-    for (int i = 0; i < 4; i++)\n-    {\n-        key[i].MakeNewKey(i % 2);\n-        keystoreRet.AddKey(key[i]);\n-    }\n-\n-    // Create some dummy input transactions\n-    dummyTransactions[0].vout.resize(2);\n-    dummyTransactions[0].vout[0].nValue = 11*CENT;\n-    dummyTransactions[0].vout[0].scriptPubKey << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n-    dummyTransactions[0].vout[1].nValue = 50*CENT;\n-    dummyTransactions[0].vout[1].scriptPubKey << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\n-    AddCoins(coinsRet, dummyTransactions[0], 0);\n-\n-    dummyTransactions[1].vout.resize(2);\n-    dummyTransactions[1].vout[0].nValue = 21*CENT;\n-    dummyTransactions[1].vout[0].scriptPubKey = GetScriptForDestination(key[2].GetPubKey().GetID());\n-    dummyTransactions[1].vout[1].nValue = 22*CENT;\n-    dummyTransactions[1].vout[1].scriptPubKey = GetScriptForDestination(key[3].GetPubKey().GetID());\n-    AddCoins(coinsRet, dummyTransactions[1], 0);\n-\n-    return dummyTransactions;\n-}\n-\n-BOOST_AUTO_TEST_CASE(test_Get)\n-{\n-    CBasicKeyStore keystore;\n-    CCoinsView coinsDummy;\n-    CCoinsViewCache coins(&coinsDummy);\n-    std::vector<CMutableTransaction> dummyTransactions = SetupDummyInputs(keystore, coins);\n-\n-    CMutableTransaction t1;\n-    t1.vin.resize(3);\n-    t1.vin[0].prevout.hash = dummyTransactions[0].GetHash();\n-    t1.vin[0].prevout.n = 1;\n-    t1.vin[0].scriptSig << std::vector<unsigned char>(65, 0);\n-    t1.vin[1].prevout.hash = dummyTransactions[1].GetHash();\n-    t1.vin[1].prevout.n = 0;\n-    t1.vin[1].scriptSig << std::vector<unsigned char>(65, 0) << std::vector<unsigned char>(33, 4);\n-    t1.vin[2].prevout.hash = dummyTransactions[1].GetHash();\n-    t1.vin[2].prevout.n = 1;\n-    t1.vin[2].scriptSig << std::vector<unsigned char>(65, 0) << std::vector<unsigned char>(33, 4);\n-    t1.vout.resize(2);\n-    t1.vout[0].nValue = 90*CENT;\n-    t1.vout[0].scriptPubKey << OP_1;\n-\n-    BOOST_CHECK(AreInputsStandard(t1, coins));\n-    BOOST_CHECK_EQUAL(coins.GetValueIn(t1), (50+21+22)*CENT);\n-}\n-\n-void CreateCreditAndSpend(const CKeyStore& keystore, const CScript& outscript, CTransactionRef& output, CMutableTransaction& input, bool success = true)\n-{\n-    CMutableTransaction outputm;\n-    outputm.nVersion = 1;\n-    outputm.vin.resize(1);\n-    outputm.vin[0].prevout.SetNull();\n-    outputm.vin[0].scriptSig = CScript();\n-    outputm.vout.resize(1);\n-    outputm.vout[0].nValue = 1;\n-    outputm.vout[0].scriptPubKey = outscript;\n-    CDataStream ssout(SER_NETWORK, PROTOCOL_VERSION);\n-    ssout << outputm;\n-    ssout >> output;\n-    assert(output->vin.size() == 1);\n-    assert(output->vin[0] == outputm.vin[0]);\n-    assert(output->vout.size() == 1);\n-    assert(output->vout[0] == outputm.vout[0]);\n-\n-    CMutableTransaction inputm;\n-    inputm.nVersion = 1;\n-    inputm.vin.resize(1);\n-    inputm.vin[0].prevout.hash = output->GetHash();\n-    inputm.vin[0].prevout.n = 0;\n-    inputm.vout.resize(1);\n-    inputm.vout[0].nValue = 1;\n-    inputm.vout[0].scriptPubKey = CScript();\n-    bool ret = SignSignature(keystore, *output, inputm, 0, SIGHASH_ALL);\n-    assert(ret == success);\n-    CDataStream ssin(SER_NETWORK, PROTOCOL_VERSION);\n-    ssin << inputm;\n-    ssin >> input;\n-    assert(input.vin.size() == 1);\n-    assert(input.vin[0] == inputm.vin[0]);\n-    assert(input.vout.size() == 1);\n-    assert(input.vout[0] == inputm.vout[0]);\n-    assert(input.vin[0].scriptWitness.stack == inputm.vin[0].scriptWitness.stack);\n-}\n-\n-void CheckWithFlag(const CTransactionRef& output, const CMutableTransaction& input, int flags, bool success)\n-{\n-    ScriptError error;\n-    CTransaction inputi(input);\n-    bool ret = VerifyScript(inputi.vin[0].scriptSig, output->vout[0].scriptPubKey, &inputi.vin[0].scriptWitness, flags, TransactionSignatureChecker(&inputi, 0, output->vout[0].nValue), &error);\n-    assert(ret == success);\n-}\n-\n-static CScript PushAll(const std::vector<valtype>& values)\n-{\n-    CScript result;\n-    for (const valtype& v : values) {\n-        if (v.size() == 0) {\n-            result << OP_0;\n-        } else if (v.size() == 1 && v[0] >= 1 && v[0] <= 16) {\n-            result << CScript::EncodeOP_N(v[0]);\n-        } else {\n-            result << v;\n-        }\n-    }\n-    return result;\n-}\n-\n-void ReplaceRedeemScript(CScript& script, const CScript& redeemScript)\n-{\n-    std::vector<valtype> stack;\n-    EvalScript(stack, script, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\n-    assert(stack.size() > 0);\n-    stack.back() = std::vector<unsigned char>(redeemScript.begin(), redeemScript.end());\n-    script = PushAll(stack);\n-}\n-\n-BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n-    CMutableTransaction mtx;\n-    mtx.nVersion = 1;\n-\n-    CKey key;\n-    key.MakeNewKey(true); // Need to use compressed keys in segwit or the signing will fail\n-    CBasicKeyStore keystore;\n-    keystore.AddKeyPubKey(key, key.GetPubKey());\n-    CKeyID hash = key.GetPubKey().GetID();\n-    CScript scriptPubKey = CScript() << OP_0 << std::vector<unsigned char>(hash.begin(), hash.end());\n-\n-    std::vector<int> sigHashes;\n-    sigHashes.push_back(SIGHASH_NONE | SIGHASH_ANYONECANPAY);\n-    sigHashes.push_back(SIGHASH_SINGLE | SIGHASH_ANYONECANPAY);\n-    sigHashes.push_back(SIGHASH_ALL | SIGHASH_ANYONECANPAY);\n-    sigHashes.push_back(SIGHASH_NONE);\n-    sigHashes.push_back(SIGHASH_SINGLE);\n-    sigHashes.push_back(SIGHASH_ALL);\n-\n-    // create a big transaction of 4500 inputs signed by the same key\n-    for(uint32_t ij = 0; ij < 4500; ij++) {\n-        uint32_t i = mtx.vin.size();\n-        uint256 prevId;\n-        prevId.SetHex(\"0000000000000000000000000000000000000000000000000000000000000100\");\n-        COutPoint outpoint(prevId, i);\n-\n-        mtx.vin.resize(mtx.vin.size() + 1);\n-        mtx.vin[i].prevout = outpoint;\n-        mtx.vin[i].scriptSig = CScript();\n-\n-        mtx.vout.resize(mtx.vout.size() + 1);\n-        mtx.vout[i].nValue = 1000;\n-        mtx.vout[i].scriptPubKey = CScript() << OP_1;\n-    }\n-\n-    // sign all inputs\n-    for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n-        bool hashSigned = SignSignature(keystore, scriptPubKey, mtx, i, 1000, sigHashes.at(i % sigHashes.size()));\n-        assert(hashSigned);\n-    }\n-\n-    CDataStream ssout(SER_NETWORK, PROTOCOL_VERSION);\n-    auto vstream = WithOrVersion(&ssout, 0);\n-    vstream << mtx;\n-    CTransaction tx(deserialize, vstream);\n-\n-    // check all inputs concurrently, with the cache\n-    PrecomputedTransactionData txdata(tx);\n-    boost::thread_group threadGroup;\n-    CCheckQueue<CScriptCheck> scriptcheckqueue(128);\n-    CCheckQueueControl<CScriptCheck> control(&scriptcheckqueue);\n-\n-    for (int i=0; i<20; i++)\n-        threadGroup.create_thread(boost::bind(&CCheckQueue<CScriptCheck>::Thread, boost::ref(scriptcheckqueue)));\n-\n-    std::vector<Coin> coins;\n-    for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n-        Coin coin;\n-        coin.nHeight = 1;\n-        coin.fCoinBase = false;\n-        coin.out.nValue = 1000;\n-        coin.out.scriptPubKey = scriptPubKey;\n-        coins.emplace_back(std::move(coin));\n-    }\n-\n-    for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n-        std::vector<CScriptCheck> vChecks;\n-        CScriptCheck check(coins[tx.vin[i].prevout.n].out, tx, i, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false, &txdata);\n-        vChecks.push_back(CScriptCheck());\n-        check.swap(vChecks.back());\n-        control.Add(vChecks);\n-    }\n-\n-    bool controlCheck = control.Wait();\n-    assert(controlCheck);\n-\n-    threadGroup.interrupt_all();\n-    threadGroup.join_all();\n-}\n-\n-BOOST_AUTO_TEST_CASE(test_witness)\n-{\n-    CBasicKeyStore keystore, keystore2;\n-    CKey key1, key2, key3, key1L, key2L;\n-    CPubKey pubkey1, pubkey2, pubkey3, pubkey1L, pubkey2L;\n-    key1.MakeNewKey(true);\n-    key2.MakeNewKey(true);\n-    key3.MakeNewKey(true);\n-    key1L.MakeNewKey(false);\n-    key2L.MakeNewKey(false);\n-    pubkey1 = key1.GetPubKey();\n-    pubkey2 = key2.GetPubKey();\n-    pubkey3 = key3.GetPubKey();\n-    pubkey1L = key1L.GetPubKey();\n-    pubkey2L = key2L.GetPubKey();\n-    keystore.AddKeyPubKey(key1, pubkey1);\n-    keystore.AddKeyPubKey(key2, pubkey2);\n-    keystore.AddKeyPubKey(key1L, pubkey1L);\n-    keystore.AddKeyPubKey(key2L, pubkey2L);\n-    CScript scriptPubkey1, scriptPubkey2, scriptPubkey1L, scriptPubkey2L, scriptMulti;\n-    scriptPubkey1 << ToByteVector(pubkey1) << OP_CHECKSIG;\n-    scriptPubkey2 << ToByteVector(pubkey2) << OP_CHECKSIG;\n-    scriptPubkey1L << ToByteVector(pubkey1L) << OP_CHECKSIG;\n-    scriptPubkey2L << ToByteVector(pubkey2L) << OP_CHECKSIG;\n-    std::vector<CPubKey> oneandthree;\n-    oneandthree.push_back(pubkey1);\n-    oneandthree.push_back(pubkey3);\n-    scriptMulti = GetScriptForMultisig(2, oneandthree);\n-    keystore.AddCScript(scriptPubkey1);\n-    keystore.AddCScript(scriptPubkey2);\n-    keystore.AddCScript(scriptPubkey1L);\n-    keystore.AddCScript(scriptPubkey2L);\n-    keystore.AddCScript(scriptMulti);\n-    keystore.AddCScript(GetScriptForWitness(scriptPubkey1));\n-    keystore.AddCScript(GetScriptForWitness(scriptPubkey2));\n-    keystore.AddCScript(GetScriptForWitness(scriptPubkey1L));\n-    keystore.AddCScript(GetScriptForWitness(scriptPubkey2L));\n-    keystore.AddCScript(GetScriptForWitness(scriptMulti));\n-    keystore2.AddCScript(scriptMulti);\n-    keystore2.AddCScript(GetScriptForWitness(scriptMulti));\n-    keystore2.AddKeyPubKey(key3, pubkey3);\n-\n-    CTransactionRef output1, output2;\n-    CMutableTransaction input1, input2;\n-    SignatureData sigdata;\n-\n-    // Normal pay-to-compressed-pubkey.\n-    CreateCreditAndSpend(keystore, scriptPubkey1, output1, input1);\n-    CreateCreditAndSpend(keystore, scriptPubkey2, output2, input2);\n-    CheckWithFlag(output1, input1, 0, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, false);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n-    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n-\n-    // P2SH pay-to-compressed-pubkey.\n-    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey1)), output1, input1);\n-    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey2)), output2, input2);\n-    ReplaceRedeemScript(input2.vin[0].scriptSig, scriptPubkey1);\n-    CheckWithFlag(output1, input1, 0, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, true);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n-    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n-\n-    // Witness pay-to-compressed-pubkey (v0).\n-    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey1), output1, input1);\n-    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey2), output2, input2);\n-    CheckWithFlag(output1, input1, 0, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, true);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n-    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n-\n-    // P2SH witness pay-to-compressed-pubkey (v0).\n-    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey1))), output1, input1);\n-    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey2))), output2, input2);\n-    ReplaceRedeemScript(input2.vin[0].scriptSig, GetScriptForWitness(scriptPubkey1));\n-    CheckWithFlag(output1, input1, 0, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, true);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n-    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n-\n-    // Normal pay-to-uncompressed-pubkey.\n-    CreateCreditAndSpend(keystore, scriptPubkey1L, output1, input1);\n-    CreateCreditAndSpend(keystore, scriptPubkey2L, output2, input2);\n-    CheckWithFlag(output1, input1, 0, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, false);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n-    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n-\n-    // P2SH pay-to-uncompressed-pubkey.\n-    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey1L)), output1, input1);\n-    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey2L)), output2, input2);\n-    ReplaceRedeemScript(input2.vin[0].scriptSig, scriptPubkey1L);\n-    CheckWithFlag(output1, input1, 0, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-    CheckWithFlag(output1, input2, 0, true);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\n-    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\n-    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\n-\n-    // Signing disabled for witness pay-to-uncompressed-pubkey (v1).\n-    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey1L), output1, input1, false);\n-    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey2L), output2, input2, false);\n-\n-    // Signing disabled for P2SH witness pay-to-uncompressed-pubkey (v1).\n-    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey1L))), output1, input1, false);\n-    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey2L))), output2, input2, false);\n-\n-    // Normal 2-of-2 multisig\n-    CreateCreditAndSpend(keystore, scriptMulti, output1, input1, false);\n-    CheckWithFlag(output1, input1, 0, false);\n-    CreateCreditAndSpend(keystore2, scriptMulti, output2, input2, false);\n-    CheckWithFlag(output2, input2, 0, false);\n-    BOOST_CHECK(*output1 == *output2);\n-    UpdateTransaction(input1, 0, CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n-    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-\n-    // P2SH 2-of-2 multisig\n-    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptMulti)), output1, input1, false);\n-    CheckWithFlag(output1, input1, 0, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, false);\n-    CreateCreditAndSpend(keystore2, GetScriptForDestination(CScriptID(scriptMulti)), output2, input2, false);\n-    CheckWithFlag(output2, input2, 0, true);\n-    CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH, false);\n-    BOOST_CHECK(*output1 == *output2);\n-    UpdateTransaction(input1, 0, CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-\n-    // Witness 2-of-2 multisig\n-    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptMulti), output1, input1, false);\n-    CheckWithFlag(output1, input1, 0, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n-    CreateCreditAndSpend(keystore2, GetScriptForWitness(scriptMulti), output2, input2, false);\n-    CheckWithFlag(output2, input2, 0, true);\n-    CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n-    BOOST_CHECK(*output1 == *output2);\n-    UpdateTransaction(input1, 0, CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true);\n-    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-\n-    // P2SH witness 2-of-2 multisig\n-    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptMulti))), output1, input1, false);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n-    CreateCreditAndSpend(keystore2, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptMulti))), output2, input2, false);\n-    CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH, true);\n-    CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\n-    BOOST_CHECK(*output1 == *output2);\n-    UpdateTransaction(input1, 0, CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\n-    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true);\n-    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\n-}\n-\n-BOOST_AUTO_TEST_CASE(test_IsStandard)\n-{\n-    LOCK(cs_main);\n-    CBasicKeyStore keystore;\n-    CCoinsView coinsDummy;\n-    CCoinsViewCache coins(&coinsDummy);\n-    std::vector<CMutableTransaction> dummyTransactions = SetupDummyInputs(keystore, coins);\n-\n-    CMutableTransaction t;\n-    t.vin.resize(1);\n-    t.vin[0].prevout.hash = dummyTransactions[0].GetHash();\n-    t.vin[0].prevout.n = 1;\n-    t.vin[0].scriptSig << std::vector<unsigned char>(65, 0);\n-    t.vout.resize(1);\n-    t.vout[0].nValue = 90*CENT;\n-    CKey key;\n-    key.MakeNewKey(true);\n-    t.vout[0].scriptPubKey = GetScriptForDestination(key.GetPubKey().GetID());\n-\n-    std::string reason;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n-\n-    // Check dust with default relay fee:\n-    CAmount nDustThreshold = 182 * dustRelayFee.GetFeePerK()/1000;\n-    BOOST_CHECK_EQUAL(nDustThreshold, 546);\n-    // dust:\n-    t.vout[0].nValue = nDustThreshold - 1;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n-    // not dust:\n-    t.vout[0].nValue = nDustThreshold;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n-\n-    // Check dust with odd relay fee to verify rounding:\n-    // nDustThreshold = 182 * 3702 / 1000\n-    dustRelayFee = CFeeRate(3702);\n-    // dust:\n-    t.vout[0].nValue = 673 - 1;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n-    // not dust:\n-    t.vout[0].nValue = 673;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n-    dustRelayFee = CFeeRate(DUST_RELAY_TX_FEE);\n-\n-    t.vout[0].scriptPubKey = CScript() << OP_1;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n-\n-    // MAX_OP_RETURN_RELAY-byte TX_NULL_DATA (standard)\n-    t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3804678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n-    BOOST_CHECK_EQUAL(MAX_OP_RETURN_RELAY, t.vout[0].scriptPubKey.size());\n-    BOOST_CHECK(IsStandardTx(t, reason));\n-\n-    // MAX_OP_RETURN_RELAY+1-byte TX_NULL_DATA (non-standard)\n-    t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3804678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3800\");\n-    BOOST_CHECK_EQUAL(MAX_OP_RETURN_RELAY + 1, t.vout[0].scriptPubKey.size());\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n-\n-    // Data payload can be encoded in any way...\n-    t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"\");\n-    BOOST_CHECK(IsStandardTx(t, reason));\n-    t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"00\") << ParseHex(\"01\");\n-    BOOST_CHECK(IsStandardTx(t, reason));\n-    // OP_RESERVED *is* considered to be a PUSHDATA type opcode by IsPushOnly()!\n-    t.vout[0].scriptPubKey = CScript() << OP_RETURN << OP_RESERVED << -1 << 0 << ParseHex(\"01\") << 2 << 3 << 4 << 5 << 6 << 7 << 8 << 9 << 10 << 11 << 12 << 13 << 14 << 15 << 16;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n-    t.vout[0].scriptPubKey = CScript() << OP_RETURN << 0 << ParseHex(\"01\") << 2 << ParseHex(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\n-    BOOST_CHECK(IsStandardTx(t, reason));\n-\n-    // ...so long as it only contains PUSHDATA's\n-    t.vout[0].scriptPubKey = CScript() << OP_RETURN << OP_RETURN;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n-\n-    // TX_NULL_DATA w/o PUSHDATA\n-    t.vout.resize(1);\n-    t.vout[0].scriptPubKey = CScript() << OP_RETURN;\n-    BOOST_CHECK(IsStandardTx(t, reason));\n-\n-    // Only one TX_NULL_DATA permitted in all cases\n-    t.vout.resize(2);\n-    t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n-    t.vout[1].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n-\n-    t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\n-    t.vout[1].scriptPubKey = CScript() << OP_RETURN;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n-\n-    t.vout[0].scriptPubKey = CScript() << OP_RETURN;\n-    t.vout[1].scriptPubKey = CScript() << OP_RETURN;\n-    BOOST_CHECK(!IsStandardTx(t, reason));\n-}\n-\n-BOOST_AUTO_TEST_SUITE_END()\n+// Copyright (c) 2011-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <test/data/tx_invalid.json.h>\r\n+#include <test/data/tx_valid.json.h>\r\n+#include <test/test_bitcoin.h>\r\n+\r\n+#include <clientversion.h>\r\n+#include <checkqueue.h>\r\n+#include <consensus/tx_verify.h>\r\n+#include <consensus/validation.h>\r\n+#include <core_io.h>\r\n+#include <key.h>\r\n+#include <keystore.h>\r\n+#include <validation.h>\r\n+#include <policy/policy.h>\r\n+#include <script/script.h>\r\n+#include <script/sign.h>\r\n+#include <script/script_error.h>\r\n+#include <script/standard.h>\r\n+#include <utilstrencodings.h>\r\n+\r\n+#include <map>\r\n+#include <string>\r\n+\r\n+#include <boost/algorithm/string/classification.hpp>\r\n+#include <boost/algorithm/string/split.hpp>\r\n+#include <boost/test/unit_test.hpp>\r\n+\r\n+#include <univalue.h>\r\n+\r\n+typedef std::vector<unsigned char> valtype;\r\n+\r\n+// In script_tests.cpp\r\n+extern UniValue read_json(const std::string& jsondata);\r\n+\r\n+static std::map<std::string, unsigned int> mapFlagNames = {\r\n+    {std::string(\"NONE\"), (unsigned int)SCRIPT_VERIFY_NONE},\r\n+    {std::string(\"P2SH\"), (unsigned int)SCRIPT_VERIFY_P2SH},\r\n+    {std::string(\"STRICTENC\"), (unsigned int)SCRIPT_VERIFY_STRICTENC},\r\n+    {std::string(\"DERSIG\"), (unsigned int)SCRIPT_VERIFY_DERSIG},\r\n+    {std::string(\"LOW_S\"), (unsigned int)SCRIPT_VERIFY_LOW_S},\r\n+    {std::string(\"SIGPUSHONLY\"), (unsigned int)SCRIPT_VERIFY_SIGPUSHONLY},\r\n+    {std::string(\"MINIMALDATA\"), (unsigned int)SCRIPT_VERIFY_MINIMALDATA},\r\n+    {std::string(\"NULLDUMMY\"), (unsigned int)SCRIPT_VERIFY_NULLDUMMY},\r\n+    {std::string(\"DISCOURAGE_UPGRADABLE_NOPS\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_NOPS},\r\n+    {std::string(\"CLEANSTACK\"), (unsigned int)SCRIPT_VERIFY_CLEANSTACK},\r\n+    {std::string(\"MINIMALIF\"), (unsigned int)SCRIPT_VERIFY_MINIMALIF},\r\n+    {std::string(\"NULLFAIL\"), (unsigned int)SCRIPT_VERIFY_NULLFAIL},\r\n+    {std::string(\"CHECKLOCKTIMEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY},\r\n+    {std::string(\"CHECKSEQUENCEVERIFY\"), (unsigned int)SCRIPT_VERIFY_CHECKSEQUENCEVERIFY},\r\n+    {std::string(\"WITNESS\"), (unsigned int)SCRIPT_VERIFY_WITNESS},\r\n+    {std::string(\"DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM\"), (unsigned int)SCRIPT_VERIFY_DISCOURAGE_UPGRADABLE_WITNESS_PROGRAM},\r\n+    {std::string(\"WITNESS_PUBKEYTYPE\"), (unsigned int)SCRIPT_VERIFY_WITNESS_PUBKEYTYPE},\r\n+    {std::string(\"ENABLE_SIGHASH_FORKID\"), (unsigned int)SCRIPT_ENABLE_SIGHASH_FORKID},\r\n+};\r\n+\r\n+unsigned int ParseScriptFlags(std::string strFlags)\r\n+{\r\n+    if (strFlags.empty()) {\r\n+        return 0;\r\n+    }\r\n+    unsigned int flags = 0;\r\n+    std::vector<std::string> words;\r\n+    boost::algorithm::split(words, strFlags, boost::algorithm::is_any_of(\",\"));\r\n+\r\n+    for (std::string word : words)\r\n+    {\r\n+        if (!mapFlagNames.count(word))\r\n+            BOOST_ERROR(\"Bad test: unknown verification flag '\" << word << \"'\");\r\n+        flags |= mapFlagNames[word];\r\n+    }\r\n+\r\n+    return flags;\r\n+}\r\n+\r\n+std::string FormatScriptFlags(unsigned int flags)\r\n+{\r\n+    if (flags == 0) {\r\n+        return \"\";\r\n+    }\r\n+    std::string ret;\r\n+    std::map<std::string, unsigned int>::const_iterator it = mapFlagNames.begin();\r\n+    while (it != mapFlagNames.end()) {\r\n+        if (flags & it->second) {\r\n+            ret += it->first + \",\";\r\n+        }\r\n+        it++;\r\n+    }\r\n+    return ret.substr(0, ret.size() - 1);\r\n+}\r\n+\r\n+BOOST_FIXTURE_TEST_SUITE(transaction_tests, BasicTestingSetup)\r\n+\r\n+BOOST_AUTO_TEST_CASE(tx_valid)\r\n+{\r\n+    // Read tests from test/data/tx_valid.json\r\n+    // Format is an array of arrays\r\n+    // Inner arrays are either [ \"comment\" ]\r\n+    // or [[[prevout hash, prevout index, prevout scriptPubKey], [input 2], ...],\"], serializedTransaction, verifyFlags\r\n+    // ... where all scripts are stringified scripts.\r\n+    //\r\n+    // verifyFlags is a comma separated list of script verification flags to apply, or \"NONE\"\r\n+    UniValue tests = read_json(std::string(json_tests::tx_valid, json_tests::tx_valid + sizeof(json_tests::tx_valid)));\r\n+\r\n+    ScriptError err;\r\n+    for (unsigned int idx = 0; idx < tests.size(); idx++) {\r\n+        UniValue test = tests[idx];\r\n+        std::string strTest = test.write();\r\n+        if (test[0].isArray())\r\n+        {\r\n+            if (test.size() != 3 || !test[1].isStr() || !test[2].isStr())\r\n+            {\r\n+                BOOST_ERROR(\"Bad test: \" << strTest);\r\n+                continue;\r\n+            }\r\n+\r\n+            std::map<COutPoint, CScript> mapprevOutScriptPubKeys;\r\n+            std::map<COutPoint, int64_t> mapprevOutValues;\r\n+            UniValue inputs = test[0].get_array();\r\n+            bool fValid = true;\r\n+\t    for (unsigned int inpIdx = 0; inpIdx < inputs.size(); inpIdx++) {\r\n+\t        const UniValue& input = inputs[inpIdx];\r\n+                if (!input.isArray())\r\n+                {\r\n+                    fValid = false;\r\n+                    break;\r\n+                }\r\n+                UniValue vinput = input.get_array();\r\n+                if (vinput.size() < 3 || vinput.size() > 4)\r\n+                {\r\n+                    fValid = false;\r\n+                    break;\r\n+                }\r\n+                COutPoint outpoint(uint256S(vinput[0].get_str()), vinput[1].get_int());\r\n+                mapprevOutScriptPubKeys[outpoint] = ParseScript(vinput[2].get_str());\r\n+                if (vinput.size() >= 4)\r\n+                {\r\n+                    mapprevOutValues[outpoint] = vinput[3].get_int64();\r\n+                }\r\n+            }\r\n+            if (!fValid)\r\n+            {\r\n+                BOOST_ERROR(\"Bad test: \" << strTest);\r\n+                continue;\r\n+            }\r\n+\r\n+            std::string transaction = test[1].get_str();\r\n+            CDataStream stream(ParseHex(transaction), SER_NETWORK, PROTOCOL_VERSION);\r\n+            CTransaction tx(deserialize, stream);\r\n+\r\n+            CValidationState state;\r\n+            BOOST_CHECK_MESSAGE(CheckTransaction(tx, state), strTest);\r\n+            BOOST_CHECK(state.IsValid());\r\n+\r\n+            PrecomputedTransactionData txdata(tx);\r\n+            for (unsigned int i = 0; i < tx.vin.size(); i++)\r\n+            {\r\n+                if (!mapprevOutScriptPubKeys.count(tx.vin[i].prevout))\r\n+                {\r\n+                    BOOST_ERROR(\"Bad test: \" << strTest);\r\n+                    break;\r\n+                }\r\n+\r\n+                CAmount amount = 0;\r\n+                if (mapprevOutValues.count(tx.vin[i].prevout)) {\r\n+                    amount = mapprevOutValues[tx.vin[i].prevout];\r\n+                }\r\n+                unsigned int verify_flags = ParseScriptFlags(test[2].get_str()) | SCRIPT_ENABLE_SIGHASH_FORKID;\r\n+                const CScriptWitness *witness = &tx.vin[i].scriptWitness;\r\n+                BOOST_CHECK_MESSAGE(VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\r\n+                                                 witness, verify_flags, TransactionSignatureChecker(&tx, i, amount, txdata), &err),\r\n+                                    strTest);\r\n+                BOOST_CHECK_MESSAGE(err == SCRIPT_ERR_OK, ScriptErrorString(err));\r\n+            }\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(tx_invalid)\r\n+{\r\n+    // Read tests from test/data/tx_invalid.json\r\n+    // Format is an array of arrays\r\n+    // Inner arrays are either [ \"comment\" ]\r\n+    // or [[[prevout hash, prevout index, prevout scriptPubKey], [input 2], ...],\"], serializedTransaction, verifyFlags\r\n+    // ... where all scripts are stringified scripts.\r\n+    //\r\n+    // verifyFlags is a comma separated list of script verification flags to apply, or \"NONE\"\r\n+    UniValue tests = read_json(std::string(json_tests::tx_invalid, json_tests::tx_invalid + sizeof(json_tests::tx_invalid)));\r\n+\r\n+    // Initialize to SCRIPT_ERR_OK. The tests expect err to be changed to a\r\n+    // value other than SCRIPT_ERR_OK.\r\n+    ScriptError err = SCRIPT_ERR_OK;\r\n+    for (unsigned int idx = 0; idx < tests.size(); idx++) {\r\n+        UniValue test = tests[idx];\r\n+        std::string strTest = test.write();\r\n+        if (test[0].isArray())\r\n+        {\r\n+            if (test.size() != 3 || !test[1].isStr() || !test[2].isStr())\r\n+            {\r\n+                BOOST_ERROR(\"Bad test: \" << strTest);\r\n+                continue;\r\n+            }\r\n+\r\n+            std::map<COutPoint, CScript> mapprevOutScriptPubKeys;\r\n+            std::map<COutPoint, int64_t> mapprevOutValues;\r\n+            UniValue inputs = test[0].get_array();\r\n+            bool fValid = true;\r\n+\t    for (unsigned int inpIdx = 0; inpIdx < inputs.size(); inpIdx++) {\r\n+\t        const UniValue& input = inputs[inpIdx];\r\n+                if (!input.isArray())\r\n+                {\r\n+                    fValid = false;\r\n+                    break;\r\n+                }\r\n+                UniValue vinput = input.get_array();\r\n+                if (vinput.size() < 3 || vinput.size() > 4)\r\n+                {\r\n+                    fValid = false;\r\n+                    break;\r\n+                }\r\n+                COutPoint outpoint(uint256S(vinput[0].get_str()), vinput[1].get_int());\r\n+                mapprevOutScriptPubKeys[outpoint] = ParseScript(vinput[2].get_str());\r\n+                if (vinput.size() >= 4)\r\n+                {\r\n+                    mapprevOutValues[outpoint] = vinput[3].get_int64();\r\n+                }\r\n+            }\r\n+            if (!fValid)\r\n+            {\r\n+                BOOST_ERROR(\"Bad test: \" << strTest);\r\n+                continue;\r\n+            }\r\n+\r\n+            std::string transaction = test[1].get_str();\r\n+            CDataStream stream(ParseHex(transaction), SER_NETWORK, PROTOCOL_VERSION );\r\n+            CTransaction tx(deserialize, stream);\r\n+\r\n+            CValidationState state;\r\n+            fValid = CheckTransaction(tx, state) && state.IsValid();\r\n+\r\n+            PrecomputedTransactionData txdata(tx);\r\n+            for (unsigned int i = 0; i < tx.vin.size() && fValid; i++)\r\n+            {\r\n+                if (!mapprevOutScriptPubKeys.count(tx.vin[i].prevout))\r\n+                {\r\n+                    BOOST_ERROR(\"Bad test: \" << strTest);\r\n+                    break;\r\n+                }\r\n+\r\n+                unsigned int verify_flags = ParseScriptFlags(test[2].get_str());\r\n+                CAmount amount = 0;\r\n+                if (mapprevOutValues.count(tx.vin[i].prevout)) {\r\n+                    amount = mapprevOutValues[tx.vin[i].prevout];\r\n+                }\r\n+                const CScriptWitness *witness = &tx.vin[i].scriptWitness;\r\n+                fValid = VerifyScript(tx.vin[i].scriptSig, mapprevOutScriptPubKeys[tx.vin[i].prevout],\r\n+                                      witness, verify_flags, TransactionSignatureChecker(&tx, i, amount, txdata), &err);\r\n+            }\r\n+            BOOST_CHECK_MESSAGE(!fValid, strTest);\r\n+            BOOST_CHECK_MESSAGE(err != SCRIPT_ERR_OK, ScriptErrorString(err));\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(basic_transaction_tests)\r\n+{\r\n+    // Random real transaction (e2769b09e784f32f62ef849763d4f45b98e07ba658647343b915ff832b110436)\r\n+    unsigned char ch[] = {0x01, 0x00, 0x00, 0x00, 0x01, 0x6b, 0xff, 0x7f, 0xcd, 0x4f, 0x85, 0x65, 0xef, 0x40, 0x6d, 0xd5, 0xd6, 0x3d, 0x4f, 0xf9, 0x4f, 0x31, 0x8f, 0xe8, 0x20, 0x27, 0xfd, 0x4d, 0xc4, 0x51, 0xb0, 0x44, 0x74, 0x01, 0x9f, 0x74, 0xb4, 0x00, 0x00, 0x00, 0x00, 0x8c, 0x49, 0x30, 0x46, 0x02, 0x21, 0x00, 0xda, 0x0d, 0xc6, 0xae, 0xce, 0xfe, 0x1e, 0x06, 0xef, 0xdf, 0x05, 0x77, 0x37, 0x57, 0xde, 0xb1, 0x68, 0x82, 0x09, 0x30, 0xe3, 0xb0, 0xd0, 0x3f, 0x46, 0xf5, 0xfc, 0xf1, 0x50, 0xbf, 0x99, 0x0c, 0x02, 0x21, 0x00, 0xd2, 0x5b, 0x5c, 0x87, 0x04, 0x00, 0x76, 0xe4, 0xf2, 0x53, 0xf8, 0x26, 0x2e, 0x76, 0x3e, 0x2d, 0xd5, 0x1e, 0x7f, 0xf0, 0xbe, 0x15, 0x77, 0x27, 0xc4, 0xbc, 0x42, 0x80, 0x7f, 0x17, 0xbd, 0x39, 0x01, 0x41, 0x04, 0xe6, 0xc2, 0x6e, 0xf6, 0x7d, 0xc6, 0x10, 0xd2, 0xcd, 0x19, 0x24, 0x84, 0x78, 0x9a, 0x6c, 0xf9, 0xae, 0xa9, 0x93, 0x0b, 0x94, 0x4b, 0x7e, 0x2d, 0xb5, 0x34, 0x2b, 0x9d, 0x9e, 0x5b, 0x9f, 0xf7, 0x9a, 0xff, 0x9a, 0x2e, 0xe1, 0x97, 0x8d, 0xd7, 0xfd, 0x01, 0xdf, 0xc5, 0x22, 0xee, 0x02, 0x28, 0x3d, 0x3b, 0x06, 0xa9, 0xd0, 0x3a, 0xcf, 0x80, 0x96, 0x96, 0x8d, 0x7d, 0xbb, 0x0f, 0x91, 0x78, 0xff, 0xff, 0xff, 0xff, 0x02, 0x8b, 0xa7, 0x94, 0x0e, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xba, 0xde, 0xec, 0xfd, 0xef, 0x05, 0x07, 0x24, 0x7f, 0xc8, 0xf7, 0x42, 0x41, 0xd7, 0x3b, 0xc0, 0x39, 0x97, 0x2d, 0x7b, 0x88, 0xac, 0x40, 0x94, 0xa8, 0x02, 0x00, 0x00, 0x00, 0x00, 0x19, 0x76, 0xa9, 0x14, 0xc1, 0x09, 0x32, 0x48, 0x3f, 0xec, 0x93, 0xed, 0x51, 0xf5, 0xfe, 0x95, 0xe7, 0x25, 0x59, 0xf2, 0xcc, 0x70, 0x43, 0xf9, 0x88, 0xac, 0x00, 0x00, 0x00, 0x00, 0x00};\r\n+    std::vector<unsigned char> vch(ch, ch + sizeof(ch) -1);\r\n+    CDataStream stream(vch, SER_DISK, CLIENT_VERSION);\r\n+    CMutableTransaction tx;\r\n+    stream >> tx;\r\n+    CValidationState state;\r\n+    BOOST_CHECK_MESSAGE(CheckTransaction(tx, state) && state.IsValid(), \"Simple deserialized transaction should be valid.\");\r\n+\r\n+    // Check that duplicate txins fail\r\n+    tx.vin.push_back(tx.vin[0]);\r\n+    BOOST_CHECK_MESSAGE(!CheckTransaction(tx, state) || !state.IsValid(), \"Transaction with duplicate txins should be invalid.\");\r\n+}\r\n+\r\n+//\r\n+// Helper: create two dummy transactions, each with\r\n+// two outputs.  The first has 11 and 50 CENT outputs\r\n+// paid to a TX_PUBKEY, the second 21 and 22 CENT outputs\r\n+// paid to a TX_PUBKEYHASH.\r\n+//\r\n+static std::vector<CMutableTransaction>\r\n+SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\r\n+{\r\n+    std::vector<CMutableTransaction> dummyTransactions;\r\n+    dummyTransactions.resize(2);\r\n+\r\n+    // Add some keys to the keystore:\r\n+    CKey key[4];\r\n+    for (int i = 0; i < 4; i++)\r\n+    {\r\n+        key[i].MakeNewKey(i % 2);\r\n+        keystoreRet.AddKey(key[i]);\r\n+    }\r\n+\r\n+    // Create some dummy input transactions\r\n+    dummyTransactions[0].vout.resize(2);\r\n+    dummyTransactions[0].vout[0].nValue = 11*CENT;\r\n+    dummyTransactions[0].vout[0].scriptPubKey << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\r\n+    dummyTransactions[0].vout[1].nValue = 50*CENT;\r\n+    dummyTransactions[0].vout[1].scriptPubKey << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\r\n+    AddCoins(coinsRet, dummyTransactions[0], 0);\r\n+\r\n+    dummyTransactions[1].vout.resize(2);\r\n+    dummyTransactions[1].vout[0].nValue = 21*CENT;\r\n+    dummyTransactions[1].vout[0].scriptPubKey = GetScriptForDestination(key[2].GetPubKey().GetID());\r\n+    dummyTransactions[1].vout[1].nValue = 22*CENT;\r\n+    dummyTransactions[1].vout[1].scriptPubKey = GetScriptForDestination(key[3].GetPubKey().GetID());\r\n+    AddCoins(coinsRet, dummyTransactions[1], 0);\r\n+\r\n+    return dummyTransactions;\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(test_Get)\r\n+{\r\n+    CBasicKeyStore keystore;\r\n+    CCoinsView coinsDummy;\r\n+    CCoinsViewCache coins(&coinsDummy);\r\n+    std::vector<CMutableTransaction> dummyTransactions = SetupDummyInputs(keystore, coins);\r\n+\r\n+    CMutableTransaction t1;\r\n+    t1.vin.resize(3);\r\n+    t1.vin[0].prevout.hash = dummyTransactions[0].GetHash();\r\n+    t1.vin[0].prevout.n = 1;\r\n+    t1.vin[0].scriptSig << std::vector<unsigned char>(65, 0);\r\n+    t1.vin[1].prevout.hash = dummyTransactions[1].GetHash();\r\n+    t1.vin[1].prevout.n = 0;\r\n+    t1.vin[1].scriptSig << std::vector<unsigned char>(65, 0) << std::vector<unsigned char>(33, 4);\r\n+    t1.vin[2].prevout.hash = dummyTransactions[1].GetHash();\r\n+    t1.vin[2].prevout.n = 1;\r\n+    t1.vin[2].scriptSig << std::vector<unsigned char>(65, 0) << std::vector<unsigned char>(33, 4);\r\n+    t1.vout.resize(2);\r\n+    t1.vout[0].nValue = 90*CENT;\r\n+    t1.vout[0].scriptPubKey << OP_1;\r\n+\r\n+    BOOST_CHECK(AreInputsStandard(t1, coins));\r\n+    BOOST_CHECK_EQUAL(coins.GetValueIn(t1), (50+21+22)*CENT);\r\n+}\r\n+\r\n+void CreateCreditAndSpend(const CKeyStore& keystore, const CScript& outscript, CTransactionRef& output, CMutableTransaction& input, bool success = true)\r\n+{\r\n+    CMutableTransaction outputm;\r\n+    outputm.nVersion = 1;\r\n+    outputm.vin.resize(1);\r\n+    outputm.vin[0].prevout.SetNull();\r\n+    outputm.vin[0].scriptSig = CScript();\r\n+    outputm.vout.resize(1);\r\n+    outputm.vout[0].nValue = 1;\r\n+    outputm.vout[0].scriptPubKey = outscript;\r\n+    CDataStream ssout(SER_NETWORK, PROTOCOL_VERSION);\r\n+    ssout << outputm;\r\n+    ssout >> output;\r\n+    assert(output->vin.size() == 1);\r\n+    assert(output->vin[0] == outputm.vin[0]);\r\n+    assert(output->vout.size() == 1);\r\n+    assert(output->vout[0] == outputm.vout[0]);\r\n+\r\n+    CMutableTransaction inputm;\r\n+    inputm.nVersion = 1;\r\n+    inputm.vin.resize(1);\r\n+    inputm.vin[0].prevout.hash = output->GetHash();\r\n+    inputm.vin[0].prevout.n = 0;\r\n+    inputm.vout.resize(1);\r\n+    inputm.vout[0].nValue = 1;\r\n+    inputm.vout[0].scriptPubKey = CScript();\r\n+    bool ret = SignSignature(keystore, *output, inputm, 0, SIGHASH_ALL | SIGHASH_FORKID);\r\n+    assert(ret == success);\r\n+    CDataStream ssin(SER_NETWORK, PROTOCOL_VERSION);\r\n+    ssin << inputm;\r\n+    ssin >> input;\r\n+    assert(input.vin.size() == 1);\r\n+    assert(input.vin[0] == inputm.vin[0]);\r\n+    assert(input.vout.size() == 1);\r\n+    assert(input.vout[0] == inputm.vout[0]);\r\n+    assert(input.vin[0].scriptWitness.stack == inputm.vin[0].scriptWitness.stack);\r\n+}\r\n+\r\n+void CheckWithFlag(const CTransactionRef& output, const CMutableTransaction& input, int flags, bool success)\r\n+{\r\n+    ScriptError error;\r\n+    CTransaction inputi(input);\r\n+    bool ret = VerifyScript(inputi.vin[0].scriptSig, output->vout[0].scriptPubKey, &inputi.vin[0].scriptWitness, flags, TransactionSignatureChecker(&inputi, 0, output->vout[0].nValue), &error);\r\n+    assert(ret == success);\r\n+}\r\n+\r\n+static CScript PushAll(const std::vector<valtype>& values)\r\n+{\r\n+    CScript result;\r\n+    for (const valtype& v : values) {\r\n+        if (v.size() == 0) {\r\n+            result << OP_0;\r\n+        } else if (v.size() == 1 && v[0] >= 1 && v[0] <= 16) {\r\n+            result << CScript::EncodeOP_N(v[0]);\r\n+        } else {\r\n+            result << v;\r\n+        }\r\n+    }\r\n+    return result;\r\n+}\r\n+\r\n+void ReplaceRedeemScript(CScript& script, const CScript& redeemScript)\r\n+{\r\n+    std::vector<valtype> stack;\r\n+    EvalScript(stack, script, SCRIPT_VERIFY_STRICTENC, BaseSignatureChecker(), SIGVERSION_BASE);\r\n+    assert(stack.size() > 0);\r\n+    stack.back() = std::vector<unsigned char>(redeemScript.begin(), redeemScript.end());\r\n+    script = PushAll(stack);\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\r\n+    CMutableTransaction mtx;\r\n+    mtx.nVersion = 1;\r\n+\r\n+    CKey key;\r\n+    key.MakeNewKey(true); // Need to use compressed keys in segwit or the signing will fail\r\n+    CBasicKeyStore keystore;\r\n+    keystore.AddKeyPubKey(key, key.GetPubKey());\r\n+    CKeyID hash = key.GetPubKey().GetID();\r\n+    CScript scriptPubKey = CScript() << OP_0 << std::vector<unsigned char>(hash.begin(), hash.end());\r\n+\r\n+    std::vector<int> sigHashes;\r\n+    sigHashes.push_back(SIGHASH_NONE | SIGHASH_FORKID | SIGHASH_ANYONECANPAY);\r\n+    sigHashes.push_back(SIGHASH_SINGLE | SIGHASH_FORKID | SIGHASH_ANYONECANPAY);\r\n+    sigHashes.push_back(SIGHASH_ALL | SIGHASH_FORKID | SIGHASH_ANYONECANPAY);\r\n+    sigHashes.push_back(SIGHASH_NONE | SIGHASH_FORKID);\r\n+    sigHashes.push_back(SIGHASH_SINGLE | SIGHASH_FORKID);\r\n+    sigHashes.push_back(SIGHASH_ALL | SIGHASH_FORKID);\r\n+\r\n+    // create a big transaction of 4500 inputs signed by the same key\r\n+    for(uint32_t ij = 0; ij < 4500; ij++) {\r\n+        uint32_t i = mtx.vin.size();\r\n+        uint256 prevId;\r\n+        prevId.SetHex(\"0000000000000000000000000000000000000000000000000000000000000100\");\r\n+        COutPoint outpoint(prevId, i);\r\n+\r\n+        mtx.vin.resize(mtx.vin.size() + 1);\r\n+        mtx.vin[i].prevout = outpoint;\r\n+        mtx.vin[i].scriptSig = CScript();\r\n+\r\n+        mtx.vout.resize(mtx.vout.size() + 1);\r\n+        mtx.vout[i].nValue = 1000;\r\n+        mtx.vout[i].scriptPubKey = CScript() << OP_1;\r\n+    }\r\n+\r\n+    // sign all inputs\r\n+    for(uint32_t i = 0; i < mtx.vin.size(); i++) {\r\n+        bool hashSigned = SignSignature(keystore, scriptPubKey, mtx, i, 1000, sigHashes.at(i % sigHashes.size()));\r\n+        assert(hashSigned);\r\n+    }\r\n+\r\n+    CDataStream ssout(SER_NETWORK, PROTOCOL_VERSION);\r\n+    auto vstream = WithOrVersion(&ssout, 0);\r\n+    vstream << mtx;\r\n+    CTransaction tx(deserialize, vstream);\r\n+\r\n+    // check all inputs concurrently, with the cache\r\n+    PrecomputedTransactionData txdata(tx);\r\n+    boost::thread_group threadGroup;\r\n+    CCheckQueue<CScriptCheck> scriptcheckqueue(128);\r\n+    CCheckQueueControl<CScriptCheck> control(&scriptcheckqueue);\r\n+\r\n+    for (int i=0; i<20; i++)\r\n+        threadGroup.create_thread(boost::bind(&CCheckQueue<CScriptCheck>::Thread, boost::ref(scriptcheckqueue)));\r\n+\r\n+    std::vector<Coin> coins;\r\n+    for(uint32_t i = 0; i < mtx.vin.size(); i++) {\r\n+        Coin coin;\r\n+        coin.nHeight = 1;\r\n+        coin.fCoinBase = false;\r\n+        coin.out.nValue = 1000;\r\n+        coin.out.scriptPubKey = scriptPubKey;\r\n+        coins.emplace_back(std::move(coin));\r\n+    }\r\n+\r\n+    for(uint32_t i = 0; i < mtx.vin.size(); i++) {\r\n+        std::vector<CScriptCheck> vChecks;\r\n+        CScriptCheck check(coins[tx.vin[i].prevout.n].out, tx, i, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false, &txdata);\r\n+        vChecks.push_back(CScriptCheck());\r\n+        check.swap(vChecks.back());\r\n+        control.Add(vChecks);\r\n+    }\r\n+\r\n+    bool controlCheck = control.Wait();\r\n+    assert(controlCheck);\r\n+\r\n+    threadGroup.interrupt_all();\r\n+    threadGroup.join_all();\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(test_witness)\r\n+{\r\n+    CBasicKeyStore keystore, keystore2;\r\n+    CKey key1, key2, key3, key1L, key2L;\r\n+    CPubKey pubkey1, pubkey2, pubkey3, pubkey1L, pubkey2L;\r\n+    key1.MakeNewKey(true);\r\n+    key2.MakeNewKey(true);\r\n+    key3.MakeNewKey(true);\r\n+    key1L.MakeNewKey(false);\r\n+    key2L.MakeNewKey(false);\r\n+    pubkey1 = key1.GetPubKey();\r\n+    pubkey2 = key2.GetPubKey();\r\n+    pubkey3 = key3.GetPubKey();\r\n+    pubkey1L = key1L.GetPubKey();\r\n+    pubkey2L = key2L.GetPubKey();\r\n+    keystore.AddKeyPubKey(key1, pubkey1);\r\n+    keystore.AddKeyPubKey(key2, pubkey2);\r\n+    keystore.AddKeyPubKey(key1L, pubkey1L);\r\n+    keystore.AddKeyPubKey(key2L, pubkey2L);\r\n+    CScript scriptPubkey1, scriptPubkey2, scriptPubkey1L, scriptPubkey2L, scriptMulti;\r\n+    scriptPubkey1 << ToByteVector(pubkey1) << OP_CHECKSIG;\r\n+    scriptPubkey2 << ToByteVector(pubkey2) << OP_CHECKSIG;\r\n+    scriptPubkey1L << ToByteVector(pubkey1L) << OP_CHECKSIG;\r\n+    scriptPubkey2L << ToByteVector(pubkey2L) << OP_CHECKSIG;\r\n+    std::vector<CPubKey> oneandthree;\r\n+    oneandthree.push_back(pubkey1);\r\n+    oneandthree.push_back(pubkey3);\r\n+    scriptMulti = GetScriptForMultisig(2, oneandthree);\r\n+    keystore.AddCScript(scriptPubkey1);\r\n+    keystore.AddCScript(scriptPubkey2);\r\n+    keystore.AddCScript(scriptPubkey1L);\r\n+    keystore.AddCScript(scriptPubkey2L);\r\n+    keystore.AddCScript(scriptMulti);\r\n+    keystore.AddCScript(GetScriptForWitness(scriptPubkey1));\r\n+    keystore.AddCScript(GetScriptForWitness(scriptPubkey2));\r\n+    keystore.AddCScript(GetScriptForWitness(scriptPubkey1L));\r\n+    keystore.AddCScript(GetScriptForWitness(scriptPubkey2L));\r\n+    keystore.AddCScript(GetScriptForWitness(scriptMulti));\r\n+    keystore2.AddCScript(scriptMulti);\r\n+    keystore2.AddCScript(GetScriptForWitness(scriptMulti));\r\n+    keystore2.AddKeyPubKey(key3, pubkey3);\r\n+\r\n+    CTransactionRef output1, output2;\r\n+    CMutableTransaction input1, input2;\r\n+    SignatureData sigdata;\r\n+\r\n+    // Normal pay-to-compressed-pubkey.\r\n+    CreateCreditAndSpend(keystore, scriptPubkey1, output1, input1);\r\n+    CreateCreditAndSpend(keystore, scriptPubkey2, output2, input2);\r\n+    CheckWithFlag(output1, input1, 0, true);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\r\n+    CheckWithFlag(output1, input2, 0, false);\r\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\r\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\r\n+    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\r\n+\r\n+    // P2SH pay-to-compressed-pubkey.\r\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey1)), output1, input1);\r\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey2)), output2, input2);\r\n+    ReplaceRedeemScript(input2.vin[0].scriptSig, scriptPubkey1);\r\n+    CheckWithFlag(output1, input1, 0, true);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\r\n+    CheckWithFlag(output1, input2, 0, true);\r\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\r\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\r\n+    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\r\n+\r\n+    // Witness pay-to-compressed-pubkey (v0).\r\n+    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey1), output1, input1);\r\n+    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey2), output2, input2);\r\n+    CheckWithFlag(output1, input1, 0, true);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\r\n+    CheckWithFlag(output1, input2, 0, true);\r\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\r\n+    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\r\n+\r\n+    // P2SH witness pay-to-compressed-pubkey (v0).\r\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey1))), output1, input1);\r\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey2))), output2, input2);\r\n+    ReplaceRedeemScript(input2.vin[0].scriptSig, GetScriptForWitness(scriptPubkey1));\r\n+    CheckWithFlag(output1, input1, 0, true);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\r\n+    CheckWithFlag(output1, input2, 0, true);\r\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\r\n+    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\r\n+\r\n+    // Normal pay-to-uncompressed-pubkey.\r\n+    CreateCreditAndSpend(keystore, scriptPubkey1L, output1, input1);\r\n+    CreateCreditAndSpend(keystore, scriptPubkey2L, output2, input2);\r\n+    CheckWithFlag(output1, input1, 0, true);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\r\n+    CheckWithFlag(output1, input2, 0, false);\r\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\r\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\r\n+    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\r\n+\r\n+    // P2SH pay-to-uncompressed-pubkey.\r\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey1L)), output1, input1);\r\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptPubkey2L)), output2, input2);\r\n+    ReplaceRedeemScript(input2.vin[0].scriptSig, scriptPubkey1L);\r\n+    CheckWithFlag(output1, input1, 0, true);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\r\n+    CheckWithFlag(output1, input2, 0, true);\r\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_P2SH, false);\r\n+    CheckWithFlag(output1, input2, SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_P2SH, false);\r\n+    CheckWithFlag(output1, input2, STANDARD_SCRIPT_VERIFY_FLAGS, false);\r\n+\r\n+    // Signing disabled for witness pay-to-uncompressed-pubkey (v1).\r\n+    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey1L), output1, input1, false);\r\n+    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptPubkey2L), output2, input2, false);\r\n+\r\n+    // Signing disabled for P2SH witness pay-to-uncompressed-pubkey (v1).\r\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey1L))), output1, input1, false);\r\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptPubkey2L))), output2, input2, false);\r\n+\r\n+    // Normal 2-of-2 multisig\r\n+    CreateCreditAndSpend(keystore, scriptMulti, output1, input1, false);\r\n+    CheckWithFlag(output1, input1, 0, false);\r\n+    CreateCreditAndSpend(keystore2, scriptMulti, output2, input2, false);\r\n+    CheckWithFlag(output2, input2, 0, false);\r\n+    BOOST_CHECK(*output1 == *output2);\r\n+    UpdateTransaction(input1, 0, CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\r\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\r\n+\r\n+    // P2SH 2-of-2 multisig\r\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(scriptMulti)), output1, input1, false);\r\n+    CheckWithFlag(output1, input1, 0, true);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, false);\r\n+    CreateCreditAndSpend(keystore2, GetScriptForDestination(CScriptID(scriptMulti)), output2, input2, false);\r\n+    CheckWithFlag(output2, input2, 0, true);\r\n+    CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH, false);\r\n+    BOOST_CHECK(*output1 == *output2);\r\n+    UpdateTransaction(input1, 0, CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\r\n+\r\n+    // Witness 2-of-2 multisig\r\n+    CreateCreditAndSpend(keystore, GetScriptForWitness(scriptMulti), output1, input1, false);\r\n+    CheckWithFlag(output1, input1, 0, true);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\r\n+    CreateCreditAndSpend(keystore2, GetScriptForWitness(scriptMulti), output2, input2, false);\r\n+    CheckWithFlag(output2, input2, 0, true);\r\n+    CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\r\n+    BOOST_CHECK(*output1 == *output2);\r\n+    UpdateTransaction(input1, 0, CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true);\r\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\r\n+\r\n+    // P2SH witness 2-of-2 multisig\r\n+    CreateCreditAndSpend(keystore, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptMulti))), output1, input1, false);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\r\n+    CreateCreditAndSpend(keystore2, GetScriptForDestination(CScriptID(GetScriptForWitness(scriptMulti))), output2, input2, false);\r\n+    CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH, true);\r\n+    CheckWithFlag(output2, input2, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false);\r\n+    BOOST_CHECK(*output1 == *output2);\r\n+    UpdateTransaction(input1, 0, CombineSignatures(output1->vout[0].scriptPubKey, MutableTransactionSignatureChecker(&input1, 0, output1->vout[0].nValue), DataFromTransaction(input1, 0), DataFromTransaction(input2, 0)));\r\n+    CheckWithFlag(output1, input1, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true);\r\n+    CheckWithFlag(output1, input1, STANDARD_SCRIPT_VERIFY_FLAGS, true);\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_CASE(test_IsStandard)\r\n+{\r\n+    LOCK(cs_main);\r\n+    CBasicKeyStore keystore;\r\n+    CCoinsView coinsDummy;\r\n+    CCoinsViewCache coins(&coinsDummy);\r\n+    std::vector<CMutableTransaction> dummyTransactions = SetupDummyInputs(keystore, coins);\r\n+\r\n+    CMutableTransaction t;\r\n+    t.vin.resize(1);\r\n+    t.vin[0].prevout.hash = dummyTransactions[0].GetHash();\r\n+    t.vin[0].prevout.n = 1;\r\n+    t.vin[0].scriptSig << std::vector<unsigned char>(65, 0);\r\n+    t.vout.resize(1);\r\n+    t.vout[0].nValue = 90*CENT;\r\n+    CKey key;\r\n+    key.MakeNewKey(true);\r\n+    t.vout[0].scriptPubKey = GetScriptForDestination(key.GetPubKey().GetID());\r\n+\r\n+    std::string reason;\r\n+    BOOST_CHECK(IsStandardTx(t, reason));\r\n+\r\n+    // Check dust with default relay fee:\r\n+    CAmount nDustThreshold = 182 * dustRelayFee.GetFeePerK()/1000;\r\n+    BOOST_CHECK_EQUAL(nDustThreshold, 546);\r\n+    // dust:\r\n+    t.vout[0].nValue = nDustThreshold - 1;\r\n+    BOOST_CHECK(!IsStandardTx(t, reason));\r\n+    // not dust:\r\n+    t.vout[0].nValue = nDustThreshold;\r\n+    BOOST_CHECK(IsStandardTx(t, reason));\r\n+\r\n+    // Check dust with odd relay fee to verify rounding:\r\n+    // nDustThreshold = 182 * 3702 / 1000\r\n+    dustRelayFee = CFeeRate(3702);\r\n+    // dust:\r\n+    t.vout[0].nValue = 673 - 1;\r\n+    BOOST_CHECK(!IsStandardTx(t, reason));\r\n+    // not dust:\r\n+    t.vout[0].nValue = 673;\r\n+    BOOST_CHECK(IsStandardTx(t, reason));\r\n+    dustRelayFee = CFeeRate(DUST_RELAY_TX_FEE);\r\n+\r\n+    t.vout[0].scriptPubKey = CScript() << OP_1;\r\n+    BOOST_CHECK(!IsStandardTx(t, reason));\r\n+\r\n+    // MAX_OP_RETURN_RELAY-byte TX_NULL_DATA (standard)\r\n+    t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3804678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\r\n+    BOOST_CHECK_EQUAL(MAX_OP_RETURN_RELAY, t.vout[0].scriptPubKey.size());\r\n+    BOOST_CHECK(IsStandardTx(t, reason));\r\n+\r\n+    // MAX_OP_RETURN_RELAY+1-byte TX_NULL_DATA (non-standard)\r\n+    t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3804678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef3800\");\r\n+    BOOST_CHECK_EQUAL(MAX_OP_RETURN_RELAY + 1, t.vout[0].scriptPubKey.size());\r\n+    BOOST_CHECK(!IsStandardTx(t, reason));\r\n+\r\n+    // Data payload can be encoded in any way...\r\n+    t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"\");\r\n+    BOOST_CHECK(IsStandardTx(t, reason));\r\n+    t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"00\") << ParseHex(\"01\");\r\n+    BOOST_CHECK(IsStandardTx(t, reason));\r\n+    // OP_RESERVED *is* considered to be a PUSHDATA type opcode by IsPushOnly()!\r\n+    t.vout[0].scriptPubKey = CScript() << OP_RETURN << OP_RESERVED << -1 << 0 << ParseHex(\"01\") << 2 << 3 << 4 << 5 << 6 << 7 << 8 << 9 << 10 << 11 << 12 << 13 << 14 << 15 << 16;\r\n+    BOOST_CHECK(IsStandardTx(t, reason));\r\n+    t.vout[0].scriptPubKey = CScript() << OP_RETURN << 0 << ParseHex(\"01\") << 2 << ParseHex(\"ffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffffff\");\r\n+    BOOST_CHECK(IsStandardTx(t, reason));\r\n+\r\n+    // ...so long as it only contains PUSHDATA's\r\n+    t.vout[0].scriptPubKey = CScript() << OP_RETURN << OP_RETURN;\r\n+    BOOST_CHECK(!IsStandardTx(t, reason));\r\n+\r\n+    // TX_NULL_DATA w/o PUSHDATA\r\n+    t.vout.resize(1);\r\n+    t.vout[0].scriptPubKey = CScript() << OP_RETURN;\r\n+    BOOST_CHECK(IsStandardTx(t, reason));\r\n+\r\n+    // Only one TX_NULL_DATA permitted in all cases\r\n+    t.vout.resize(2);\r\n+    t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\r\n+    t.vout[1].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\r\n+    BOOST_CHECK(!IsStandardTx(t, reason));\r\n+\r\n+    t.vout[0].scriptPubKey = CScript() << OP_RETURN << ParseHex(\"04678afdb0fe5548271967f1a67130b7105cd6a828e03909a67962e0ea1f61deb649f6bc3f4cef38\");\r\n+    t.vout[1].scriptPubKey = CScript() << OP_RETURN;\r\n+    BOOST_CHECK(!IsStandardTx(t, reason));\r\n+\r\n+    t.vout[0].scriptPubKey = CScript() << OP_RETURN;\r\n+    t.vout[1].scriptPubKey = CScript() << OP_RETURN;\r\n+    BOOST_CHECK(!IsStandardTx(t, reason));\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_SUITE_END()\r"
      },
      {
        "sha": "c8d26b5d1a9a19b5d7a501a42d61edbe90a558cc",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 371,
        "deletions": 370,
        "changes": 741,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b8461f9655ceec64a3bb3835b12b51f2b5ac42e6/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=b8461f9655ceec64a3bb3835b12b51f2b5ac42e6",
        "patch": "@@ -1,370 +1,371 @@\n-// Copyright (c) 2011-2016 The Bitcoin Core developers\n-// Distributed under the MIT software license, see the accompanying\n-// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n-\n-#include <consensus/validation.h>\n-#include <key.h>\n-#include <validation.h>\n-#include <miner.h>\n-#include <pubkey.h>\n-#include <txmempool.h>\n-#include <random.h>\n-#include <script/standard.h>\n-#include <script/sign.h>\n-#include <test/test_bitcoin.h>\n-#include <utiltime.h>\n-#include <core_io.h>\n-#include <keystore.h>\n-#include <policy/policy.h>\n-\n-#include <boost/test/unit_test.hpp>\n-\n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks);\n-\n-BOOST_AUTO_TEST_SUITE(tx_validationcache_tests)\n-\n-static bool\n-ToMemPool(CMutableTransaction& tx)\n-{\n-    LOCK(cs_main);\n-\n-    CValidationState state;\n-    return AcceptToMemoryPool(mempool, state, MakeTransactionRef(tx), nullptr /* pfMissingInputs */,\n-                              nullptr /* plTxnReplaced */, true /* bypass_limits */, 0 /* nAbsurdFee */);\n-}\n-\n-BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\n-{\n-    // Make sure skipping validation of transctions that were\n-    // validated going into the memory pool does not allow\n-    // double-spends in blocks to pass validation when they should not.\n-\n-    CScript scriptPubKey = CScript() <<  ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n-\n-    // Create a double-spend of mature coinbase txn:\n-    std::vector<CMutableTransaction> spends;\n-    spends.resize(2);\n-    for (int i = 0; i < 2; i++)\n-    {\n-        spends[i].nVersion = 1;\n-        spends[i].vin.resize(1);\n-        spends[i].vin[0].prevout.hash = coinbaseTxns[0].GetHash();\n-        spends[i].vin[0].prevout.n = 0;\n-        spends[i].vout.resize(1);\n-        spends[i].vout[0].nValue = 11*CENT;\n-        spends[i].vout[0].scriptPubKey = scriptPubKey;\n-\n-        // Sign:\n-        std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(scriptPubKey, spends[i], 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n-        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n-        vchSig.push_back((unsigned char)SIGHASH_ALL);\n-        spends[i].vin[0].scriptSig << vchSig;\n-    }\n-\n-    CBlock block;\n-\n-    // Test 1: block with both of those transactions should be rejected.\n-    block = CreateAndProcessBlock(spends, scriptPubKey);\n-    LOCK(cs_main);\n-    BOOST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\n-\n-    // Test 2: ... and should be rejected if spend1 is in the memory pool\n-    BOOST_CHECK(ToMemPool(spends[0]));\n-    block = CreateAndProcessBlock(spends, scriptPubKey);\n-    BOOST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\n-    mempool.clear();\n-\n-    // Test 3: ... and should be rejected if spend2 is in the memory pool\n-    BOOST_CHECK(ToMemPool(spends[1]));\n-    block = CreateAndProcessBlock(spends, scriptPubKey);\n-    BOOST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\n-    mempool.clear();\n-\n-    // Final sanity test: first spend in mempool, second in block, that's OK:\n-    std::vector<CMutableTransaction> oneSpend;\n-    oneSpend.push_back(spends[0]);\n-    BOOST_CHECK(ToMemPool(spends[1]));\n-    block = CreateAndProcessBlock(oneSpend, scriptPubKey);\n-    BOOST_CHECK(chainActive.Tip()->GetBlockHash() == block.GetHash());\n-    // spends[1] should have been removed from the mempool when the\n-    // block with spends[0] is accepted:\n-    BOOST_CHECK_EQUAL(mempool.size(), 0);\n-}\n-\n-// Run CheckInputs (using pcoinsTip) on the given transaction, for all script\n-// flags.  Test that CheckInputs passes for all flags that don't overlap with\n-// the failing_flags argument, but otherwise fails.\n-// CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY (and future NOP codes that may\n-// get reassigned) have an interaction with DISCOURAGE_UPGRADABLE_NOPS: if\n-// the script flags used contain DISCOURAGE_UPGRADABLE_NOPS but don't contain\n-// CHECKLOCKTIMEVERIFY (or CHECKSEQUENCEVERIFY), but the script does contain\n-// OP_CHECKLOCKTIMEVERIFY (or OP_CHECKSEQUENCEVERIFY), then script execution\n-// should fail.\n-// Capture this interaction with the upgraded_nop argument: set it when evaluating\n-// any script flag that is implemented as an upgraded NOP code.\n-void ValidateCheckInputsForAllFlags(CMutableTransaction &tx, uint32_t failing_flags, bool add_to_cache)\n-{\n-    PrecomputedTransactionData txdata(tx);\n-    // If we add many more flags, this loop can get too expensive, but we can\n-    // rewrite in the future to randomly pick a set of flags to evaluate.\n-    for (uint32_t test_flags=0; test_flags < (1U << 16); test_flags += 1) {\n-        CValidationState state;\n-        // Filter out incompatible flag choices\n-        if ((test_flags & SCRIPT_VERIFY_CLEANSTACK)) {\n-            // CLEANSTACK requires P2SH and WITNESS, see VerifyScript() in\n-            // script/interpreter.cpp\n-            test_flags |= SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS;\n-        }\n-        if ((test_flags & SCRIPT_VERIFY_WITNESS)) {\n-            // WITNESS requires P2SH\n-            test_flags |= SCRIPT_VERIFY_P2SH;\n-        }\n-        bool ret = CheckInputs(tx, state, pcoinsTip.get(), true, test_flags, true, add_to_cache, txdata, nullptr);\n-        // CheckInputs should succeed iff test_flags doesn't intersect with\n-        // failing_flags\n-        bool expected_return_value = !(test_flags & failing_flags);\n-        BOOST_CHECK_EQUAL(ret, expected_return_value);\n-\n-        // Test the caching\n-        if (ret && add_to_cache) {\n-            // Check that we get a cache hit if the tx was valid\n-            std::vector<CScriptCheck> scriptchecks;\n-            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n-            BOOST_CHECK(scriptchecks.empty());\n-        } else {\n-            // Check that we get script executions to check, if the transaction\n-            // was invalid, or we didn't add to cache.\n-            std::vector<CScriptCheck> scriptchecks;\n-            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n-            BOOST_CHECK_EQUAL(scriptchecks.size(), tx.vin.size());\n-        }\n-    }\n-}\n-\n-BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n-{\n-    // Test that passing CheckInputs with one set of script flags doesn't imply\n-    // that we would pass again with a different set of flags.\n-    {\n-        LOCK(cs_main);\n-        InitScriptExecutionCache();\n-    }\n-\n-    CScript p2pk_scriptPubKey = CScript() << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n-    CScript p2sh_scriptPubKey = GetScriptForDestination(CScriptID(p2pk_scriptPubKey));\n-    CScript p2pkh_scriptPubKey = GetScriptForDestination(coinbaseKey.GetPubKey().GetID());\n-    CScript p2wpkh_scriptPubKey = GetScriptForWitness(p2pkh_scriptPubKey);\n-\n-    CBasicKeyStore keystore;\n-    keystore.AddKey(coinbaseKey);\n-    keystore.AddCScript(p2pk_scriptPubKey);\n-\n-    // flags to test: SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, SCRIPT_VERIFY_CHECKSEQUENCE_VERIFY, SCRIPT_VERIFY_NULLDUMMY, uncompressed pubkey thing\n-\n-    // Create 2 outputs that match the three scripts above, spending the first\n-    // coinbase tx.\n-    CMutableTransaction spend_tx;\n-\n-    spend_tx.nVersion = 1;\n-    spend_tx.vin.resize(1);\n-    spend_tx.vin[0].prevout.hash = coinbaseTxns[0].GetHash();\n-    spend_tx.vin[0].prevout.n = 0;\n-    spend_tx.vout.resize(4);\n-    spend_tx.vout[0].nValue = 11*CENT;\n-    spend_tx.vout[0].scriptPubKey = p2sh_scriptPubKey;\n-    spend_tx.vout[1].nValue = 11*CENT;\n-    spend_tx.vout[1].scriptPubKey = p2wpkh_scriptPubKey;\n-    spend_tx.vout[2].nValue = 11*CENT;\n-    spend_tx.vout[2].scriptPubKey = CScript() << OP_CHECKLOCKTIMEVERIFY << OP_DROP << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n-    spend_tx.vout[3].nValue = 11*CENT;\n-    spend_tx.vout[3].scriptPubKey = CScript() << OP_CHECKSEQUENCEVERIFY << OP_DROP << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\n-\n-    // Sign, with a non-DER signature\n-    {\n-        std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(p2pk_scriptPubKey, spend_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n-        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n-        vchSig.push_back((unsigned char) 0); // padding byte makes this non-DER\n-        vchSig.push_back((unsigned char)SIGHASH_ALL);\n-        spend_tx.vin[0].scriptSig << vchSig;\n-    }\n-\n-    LOCK(cs_main);\n-\n-    // Test that invalidity under a set of flags doesn't preclude validity\n-    // under other (eg consensus) flags.\n-    // spend_tx is invalid according to DERSIG\n-    {\n-        CValidationState state;\n-        PrecomputedTransactionData ptd_spend_tx(spend_tx);\n-\n-        BOOST_CHECK(!CheckInputs(spend_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n-\n-        // If we call again asking for scriptchecks (as happens in\n-        // ConnectBlock), we should add a script check object for this -- we're\n-        // not caching invalidity (if that changes, delete this test case).\n-        std::vector<CScriptCheck> scriptchecks;\n-        BOOST_CHECK(CheckInputs(spend_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n-        BOOST_CHECK_EQUAL(scriptchecks.size(), 1);\n-\n-        // Test that CheckInputs returns true iff DERSIG-enforcing flags are\n-        // not present.  Don't add these checks to the cache, so that we can\n-        // test later that block validation works fine in the absence of cached\n-        // successes.\n-        ValidateCheckInputsForAllFlags(spend_tx, SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC, false);\n-\n-        // And if we produce a block with this tx, it should be valid (DERSIG not\n-        // enabled yet), even though there's no cache entry.\n-        CBlock block;\n-\n-        block = CreateAndProcessBlock({spend_tx}, p2pk_scriptPubKey);\n-        BOOST_CHECK(chainActive.Tip()->GetBlockHash() == block.GetHash());\n-        BOOST_CHECK(pcoinsTip->GetBestBlock() == block.GetHash());\n-    }\n-\n-    // Test P2SH: construct a transaction that is valid without P2SH, and\n-    // then test validity with P2SH.\n-    {\n-        CMutableTransaction invalid_under_p2sh_tx;\n-        invalid_under_p2sh_tx.nVersion = 1;\n-        invalid_under_p2sh_tx.vin.resize(1);\n-        invalid_under_p2sh_tx.vin[0].prevout.hash = spend_tx.GetHash();\n-        invalid_under_p2sh_tx.vin[0].prevout.n = 0;\n-        invalid_under_p2sh_tx.vout.resize(1);\n-        invalid_under_p2sh_tx.vout[0].nValue = 11*CENT;\n-        invalid_under_p2sh_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n-        std::vector<unsigned char> vchSig2(p2pk_scriptPubKey.begin(), p2pk_scriptPubKey.end());\n-        invalid_under_p2sh_tx.vin[0].scriptSig << vchSig2;\n-\n-        ValidateCheckInputsForAllFlags(invalid_under_p2sh_tx, SCRIPT_VERIFY_P2SH, true);\n-    }\n-\n-    // Test CHECKLOCKTIMEVERIFY\n-    {\n-        CMutableTransaction invalid_with_cltv_tx;\n-        invalid_with_cltv_tx.nVersion = 1;\n-        invalid_with_cltv_tx.nLockTime = 100;\n-        invalid_with_cltv_tx.vin.resize(1);\n-        invalid_with_cltv_tx.vin[0].prevout.hash = spend_tx.GetHash();\n-        invalid_with_cltv_tx.vin[0].prevout.n = 2;\n-        invalid_with_cltv_tx.vin[0].nSequence = 0;\n-        invalid_with_cltv_tx.vout.resize(1);\n-        invalid_with_cltv_tx.vout[0].nValue = 11*CENT;\n-        invalid_with_cltv_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n-\n-        // Sign\n-        std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(spend_tx.vout[2].scriptPubKey, invalid_with_cltv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n-        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n-        vchSig.push_back((unsigned char)SIGHASH_ALL);\n-        invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n-\n-        ValidateCheckInputsForAllFlags(invalid_with_cltv_tx, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true);\n-\n-        // Make it valid, and check again\n-        invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n-        CValidationState state;\n-        PrecomputedTransactionData txdata(invalid_with_cltv_tx);\n-        BOOST_CHECK(CheckInputs(invalid_with_cltv_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n-    }\n-\n-    // TEST CHECKSEQUENCEVERIFY\n-    {\n-        CMutableTransaction invalid_with_csv_tx;\n-        invalid_with_csv_tx.nVersion = 2;\n-        invalid_with_csv_tx.vin.resize(1);\n-        invalid_with_csv_tx.vin[0].prevout.hash = spend_tx.GetHash();\n-        invalid_with_csv_tx.vin[0].prevout.n = 3;\n-        invalid_with_csv_tx.vin[0].nSequence = 100;\n-        invalid_with_csv_tx.vout.resize(1);\n-        invalid_with_csv_tx.vout[0].nValue = 11*CENT;\n-        invalid_with_csv_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n-\n-        // Sign\n-        std::vector<unsigned char> vchSig;\n-        uint256 hash = SignatureHash(spend_tx.vout[3].scriptPubKey, invalid_with_csv_tx, 0, SIGHASH_ALL, 0, SIGVERSION_BASE);\n-        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\n-        vchSig.push_back((unsigned char)SIGHASH_ALL);\n-        invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\n-\n-        ValidateCheckInputsForAllFlags(invalid_with_csv_tx, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true);\n-\n-        // Make it valid, and check again\n-        invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n-        CValidationState state;\n-        PrecomputedTransactionData txdata(invalid_with_csv_tx);\n-        BOOST_CHECK(CheckInputs(invalid_with_csv_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n-    }\n-\n-    // TODO: add tests for remaining script flags\n-\n-    // Test that passing CheckInputs with a valid witness doesn't imply success\n-    // for the same tx with a different witness.\n-    {\n-        CMutableTransaction valid_with_witness_tx;\n-        valid_with_witness_tx.nVersion = 1;\n-        valid_with_witness_tx.vin.resize(1);\n-        valid_with_witness_tx.vin[0].prevout.hash = spend_tx.GetHash();\n-        valid_with_witness_tx.vin[0].prevout.n = 1;\n-        valid_with_witness_tx.vout.resize(1);\n-        valid_with_witness_tx.vout[0].nValue = 11*CENT;\n-        valid_with_witness_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n-\n-        // Sign\n-        SignatureData sigdata;\n-        ProduceSignature(MutableTransactionSignatureCreator(&keystore, &valid_with_witness_tx, 0, 11*CENT, SIGHASH_ALL), spend_tx.vout[1].scriptPubKey, sigdata);\n-        UpdateTransaction(valid_with_witness_tx, 0, sigdata);\n-\n-        // This should be valid under all script flags.\n-        ValidateCheckInputsForAllFlags(valid_with_witness_tx, 0, true);\n-\n-        // Remove the witness, and check that it is now invalid.\n-        valid_with_witness_tx.vin[0].scriptWitness.SetNull();\n-        ValidateCheckInputsForAllFlags(valid_with_witness_tx, SCRIPT_VERIFY_WITNESS, true);\n-    }\n-\n-    {\n-        // Test a transaction with multiple inputs.\n-        CMutableTransaction tx;\n-\n-        tx.nVersion = 1;\n-        tx.vin.resize(2);\n-        tx.vin[0].prevout.hash = spend_tx.GetHash();\n-        tx.vin[0].prevout.n = 0;\n-        tx.vin[1].prevout.hash = spend_tx.GetHash();\n-        tx.vin[1].prevout.n = 1;\n-        tx.vout.resize(1);\n-        tx.vout[0].nValue = 22*CENT;\n-        tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\n-\n-        // Sign\n-        for (int i=0; i<2; ++i) {\n-            SignatureData sigdata;\n-            ProduceSignature(MutableTransactionSignatureCreator(&keystore, &tx, i, 11*CENT, SIGHASH_ALL), spend_tx.vout[i].scriptPubKey, sigdata);\n-            UpdateTransaction(tx, i, sigdata);\n-        }\n-\n-        // This should be valid under all script flags\n-        ValidateCheckInputsForAllFlags(tx, 0, true);\n-\n-        // Check that if the second input is invalid, but the first input is\n-        // valid, the transaction is not cached.\n-        // Invalidate vin[1]\n-        tx.vin[1].scriptWitness.SetNull();\n-\n-        CValidationState state;\n-        PrecomputedTransactionData txdata(tx);\n-        // This transaction is now invalid under segwit, because of the second input.\n-        BOOST_CHECK(!CheckInputs(tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n-\n-        std::vector<CScriptCheck> scriptchecks;\n-        // Make sure this transaction was not cached (ie because the first\n-        // input was valid)\n-        BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n-        // Should get 2 script checks back -- caching is on a whole-transaction basis.\n-        BOOST_CHECK_EQUAL(scriptchecks.size(), 2);\n-    }\n-}\n-\n-BOOST_AUTO_TEST_SUITE_END()\n+// Copyright (c) 2011-2016 The Bitcoin Core developers\r\n+// Distributed under the MIT software license, see the accompanying\r\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\r\n+\r\n+#include <consensus/validation.h>\r\n+#include <key.h>\r\n+#include <validation.h>\r\n+#include <miner.h>\r\n+#include <pubkey.h>\r\n+#include <txmempool.h>\r\n+#include <random.h>\r\n+#include <script/standard.h>\r\n+#include <script/sign.h>\r\n+#include <test/test_bitcoin.h>\r\n+#include <utiltime.h>\r\n+#include <core_io.h>\r\n+#include <keystore.h>\r\n+#include <policy/policy.h>\r\n+\r\n+#include <boost/test/unit_test.hpp>\r\n+\r\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks);\r\n+\r\n+BOOST_AUTO_TEST_SUITE(tx_validationcache_tests)\r\n+\r\n+static bool\r\n+ToMemPool(CMutableTransaction& tx)\r\n+{\r\n+    LOCK(cs_main);\r\n+\r\n+    CValidationState state;\r\n+    return AcceptToMemoryPool(mempool, state, MakeTransactionRef(tx), nullptr /* pfMissingInputs */,\r\n+                              nullptr /* plTxnReplaced */, true /* bypass_limits */, 0 /* nAbsurdFee */);\r\n+}\r\n+\r\n+BOOST_FIXTURE_TEST_CASE(tx_mempool_block_doublespend, TestChain100Setup)\r\n+{\r\n+    // Make sure skipping validation of transctions that were\r\n+    // validated going into the memory pool does not allow\r\n+    // double-spends in blocks to pass validation when they should not.\r\n+\r\n+    CScript scriptPubKey = CScript() <<  ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\r\n+\r\n+    // Create a double-spend of mature coinbase txn:\r\n+    std::vector<CMutableTransaction> spends;\r\n+    spends.resize(2);\r\n+    for (int i = 0; i < 2; i++)\r\n+    {\r\n+        spends[i].nVersion = 1;\r\n+        spends[i].vin.resize(1);\r\n+        spends[i].vin[0].prevout.hash = coinbaseTxns[0].GetHash();\r\n+        spends[i].vin[0].prevout.n = 0;\r\n+        spends[i].vout.resize(1);\r\n+        spends[i].vout[0].nValue = 11*CENT;\r\n+        spends[i].vout[0].scriptPubKey = scriptPubKey;\r\n+\r\n+        // Sign:\r\n+        std::vector<unsigned char> vchSig;\r\n+        uint256 hash = SignatureHash(scriptPubKey, spends[i], 0, SIGHASH_ALL | SIGHASH_FORKID, 0, SIGVERSION_BASE);\r\n+        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\r\n+        vchSig.push_back((unsigned char)SIGHASH_ALL | SIGHASH_FORKID);\r\n+        spends[i].vin[0].scriptSig << vchSig;\r\n+    }\r\n+\r\n+    CBlock block;\r\n+\r\n+    // Test 1: block with both of those transactions should be rejected.\r\n+    block = CreateAndProcessBlock(spends, scriptPubKey);\r\n+    LOCK(cs_main);\r\n+    BOOST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\r\n+\r\n+    // Test 2: ... and should be rejected if spend1 is in the memory pool\r\n+    BOOST_CHECK(ToMemPool(spends[0]));\r\n+    block = CreateAndProcessBlock(spends, scriptPubKey);\r\n+    BOOST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\r\n+    mempool.clear();\r\n+\r\n+    // Test 3: ... and should be rejected if spend2 is in the memory pool\r\n+    BOOST_CHECK(ToMemPool(spends[1]));\r\n+    block = CreateAndProcessBlock(spends, scriptPubKey);\r\n+    BOOST_CHECK(chainActive.Tip()->GetBlockHash() != block.GetHash());\r\n+    mempool.clear();\r\n+\r\n+    // Final sanity test: first spend in mempool, second in block, that's OK:\r\n+    std::vector<CMutableTransaction> oneSpend;\r\n+    oneSpend.push_back(spends[0]);\r\n+    BOOST_CHECK(ToMemPool(spends[1]));\r\n+    block = CreateAndProcessBlock(oneSpend, scriptPubKey);\r\n+    BOOST_CHECK(chainActive.Tip()->GetBlockHash() == block.GetHash());\r\n+    // spends[1] should have been removed from the mempool when the\r\n+    // block with spends[0] is accepted:\r\n+    BOOST_CHECK_EQUAL(mempool.size(), 0);\r\n+}\r\n+\r\n+// Run CheckInputs (using pcoinsTip) on the given transaction, for all script\r\n+// flags.  Test that CheckInputs passes for all flags that don't overlap with\r\n+// the failing_flags argument, but otherwise fails.\r\n+// CHECKLOCKTIMEVERIFY and CHECKSEQUENCEVERIFY (and future NOP codes that may\r\n+// get reassigned) have an interaction with DISCOURAGE_UPGRADABLE_NOPS: if\r\n+// the script flags used contain DISCOURAGE_UPGRADABLE_NOPS but don't contain\r\n+// CHECKLOCKTIMEVERIFY (or CHECKSEQUENCEVERIFY), but the script does contain\r\n+// OP_CHECKLOCKTIMEVERIFY (or OP_CHECKSEQUENCEVERIFY), then script execution\r\n+// should fail.\r\n+// Capture this interaction with the upgraded_nop argument: set it when evaluating\r\n+// any script flag that is implemented as an upgraded NOP code.\r\n+void ValidateCheckInputsForAllFlags(CMutableTransaction &tx, uint32_t failing_flags, bool add_to_cache)\r\n+{\r\n+    PrecomputedTransactionData txdata(tx);\r\n+    // If we add many more flags, this loop can get too expensive, but we can\r\n+    // rewrite in the future to randomly pick a set of flags to evaluate.\r\n+    for (uint32_t test_flags=0; test_flags < (1U << 16); test_flags += 1) {\r\n+        CValidationState state;\r\n+        test_flags |= SCRIPT_ENABLE_SIGHASH_FORKID;\r\n+        // Filter out incompatible flag choices\r\n+        if ((test_flags & SCRIPT_VERIFY_CLEANSTACK)) {\r\n+            // CLEANSTACK requires P2SH and WITNESS, see VerifyScript() in\r\n+            // script/interpreter.cpp\r\n+            test_flags |= SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS;\r\n+        }\r\n+        if ((test_flags & SCRIPT_VERIFY_WITNESS)) {\r\n+            // WITNESS requires P2SH\r\n+            test_flags |= SCRIPT_VERIFY_P2SH;\r\n+        }\r\n+        bool ret = CheckInputs(tx, state, pcoinsTip.get(), true, test_flags, true, add_to_cache, txdata, nullptr);\r\n+        // CheckInputs should succeed iff test_flags doesn't intersect with\r\n+        // failing_flags\r\n+        bool expected_return_value = !(test_flags & failing_flags);\r\n+        BOOST_CHECK_EQUAL(ret, expected_return_value);\r\n+\r\n+        // Test the caching\r\n+        if (ret && add_to_cache) {\r\n+            // Check that we get a cache hit if the tx was valid\r\n+            std::vector<CScriptCheck> scriptchecks;\r\n+            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\r\n+            BOOST_CHECK(scriptchecks.empty());\r\n+        } else {\r\n+            // Check that we get script executions to check, if the transaction\r\n+            // was invalid, or we didn't add to cache.\r\n+            std::vector<CScriptCheck> scriptchecks;\r\n+            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\r\n+            BOOST_CHECK_EQUAL(scriptchecks.size(), tx.vin.size());\r\n+        }\r\n+    }\r\n+}\r\n+\r\n+BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\r\n+{\r\n+    // Test that passing CheckInputs with one set of script flags doesn't imply\r\n+    // that we would pass again with a different set of flags.\r\n+    {\r\n+        LOCK(cs_main);\r\n+        InitScriptExecutionCache();\r\n+    }\r\n+\r\n+    CScript p2pk_scriptPubKey = CScript() << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\r\n+    CScript p2sh_scriptPubKey = GetScriptForDestination(CScriptID(p2pk_scriptPubKey));\r\n+    CScript p2pkh_scriptPubKey = GetScriptForDestination(coinbaseKey.GetPubKey().GetID());\r\n+    CScript p2wpkh_scriptPubKey = GetScriptForWitness(p2pkh_scriptPubKey);\r\n+\r\n+    CBasicKeyStore keystore;\r\n+    keystore.AddKey(coinbaseKey);\r\n+    keystore.AddCScript(p2pk_scriptPubKey);\r\n+\r\n+    // flags to test: SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, SCRIPT_VERIFY_CHECKSEQUENCE_VERIFY, SCRIPT_VERIFY_NULLDUMMY, uncompressed pubkey thing\r\n+\r\n+    // Create 2 outputs that match the three scripts above, spending the first\r\n+    // coinbase tx.\r\n+    CMutableTransaction spend_tx;\r\n+\r\n+    spend_tx.nVersion = 1;\r\n+    spend_tx.vin.resize(1);\r\n+    spend_tx.vin[0].prevout.hash = coinbaseTxns[0].GetHash();\r\n+    spend_tx.vin[0].prevout.n = 0;\r\n+    spend_tx.vout.resize(4);\r\n+    spend_tx.vout[0].nValue = 11*CENT;\r\n+    spend_tx.vout[0].scriptPubKey = p2sh_scriptPubKey;\r\n+    spend_tx.vout[1].nValue = 11*CENT;\r\n+    spend_tx.vout[1].scriptPubKey = p2wpkh_scriptPubKey;\r\n+    spend_tx.vout[2].nValue = 11*CENT;\r\n+    spend_tx.vout[2].scriptPubKey = CScript() << OP_CHECKLOCKTIMEVERIFY << OP_DROP << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\r\n+    spend_tx.vout[3].nValue = 11*CENT;\r\n+    spend_tx.vout[3].scriptPubKey = CScript() << OP_CHECKSEQUENCEVERIFY << OP_DROP << ToByteVector(coinbaseKey.GetPubKey()) << OP_CHECKSIG;\r\n+\r\n+    // Sign, with a non-DER signature\r\n+    {\r\n+        std::vector<unsigned char> vchSig;\r\n+        uint256 hash = SignatureHash(p2pk_scriptPubKey, spend_tx, 0, SIGHASH_ALL | SIGHASH_FORKID, 0, SIGVERSION_BASE);\r\n+        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\r\n+        vchSig.push_back((unsigned char) 0); // padding byte makes this non-DER\r\n+        vchSig.push_back((unsigned char)SIGHASH_ALL | SIGHASH_FORKID);\r\n+        spend_tx.vin[0].scriptSig << vchSig;\r\n+    }\r\n+\r\n+    LOCK(cs_main);\r\n+\r\n+    // Test that invalidity under a set of flags doesn't preclude validity\r\n+    // under other (eg consensus) flags.\r\n+    // spend_tx is invalid according to DERSIG\r\n+    {\r\n+        CValidationState state;\r\n+        PrecomputedTransactionData ptd_spend_tx(spend_tx);\r\n+\r\n+        BOOST_CHECK(!CheckInputs(spend_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\r\n+\r\n+        // If we call again asking for scriptchecks (as happens in\r\n+        // ConnectBlock), we should add a script check object for this -- we're\r\n+        // not caching invalidity (if that changes, delete this test case).\r\n+        std::vector<CScriptCheck> scriptchecks;\r\n+        BOOST_CHECK(CheckInputs(spend_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\r\n+        BOOST_CHECK_EQUAL(scriptchecks.size(), 1);\r\n+\r\n+        // Test that CheckInputs returns true iff DERSIG-enforcing flags are\r\n+        // not present.  Don't add these checks to the cache, so that we can\r\n+        // test later that block validation works fine in the absence of cached\r\n+        // successes.\r\n+        ValidateCheckInputsForAllFlags(spend_tx, SCRIPT_VERIFY_DERSIG | SCRIPT_VERIFY_LOW_S | SCRIPT_VERIFY_STRICTENC, false);\r\n+\r\n+        // And if we produce a block with this tx, it should be valid (DERSIG not\r\n+        // enabled yet), even though there's no cache entry.\r\n+        CBlock block;\r\n+\r\n+        block = CreateAndProcessBlock({spend_tx}, p2pk_scriptPubKey);\r\n+        BOOST_CHECK(chainActive.Tip()->GetBlockHash() == block.GetHash());\r\n+        BOOST_CHECK(pcoinsTip->GetBestBlock() == block.GetHash());\r\n+    }\r\n+\r\n+    // Test P2SH: construct a transaction that is valid without P2SH, and\r\n+    // then test validity with P2SH.\r\n+    {\r\n+        CMutableTransaction invalid_under_p2sh_tx;\r\n+        invalid_under_p2sh_tx.nVersion = 1;\r\n+        invalid_under_p2sh_tx.vin.resize(1);\r\n+        invalid_under_p2sh_tx.vin[0].prevout.hash = spend_tx.GetHash();\r\n+        invalid_under_p2sh_tx.vin[0].prevout.n = 0;\r\n+        invalid_under_p2sh_tx.vout.resize(1);\r\n+        invalid_under_p2sh_tx.vout[0].nValue = 11*CENT;\r\n+        invalid_under_p2sh_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\r\n+        std::vector<unsigned char> vchSig2(p2pk_scriptPubKey.begin(), p2pk_scriptPubKey.end());\r\n+        invalid_under_p2sh_tx.vin[0].scriptSig << vchSig2;\r\n+\r\n+        ValidateCheckInputsForAllFlags(invalid_under_p2sh_tx, SCRIPT_VERIFY_P2SH, true);\r\n+    }\r\n+\r\n+    // Test CHECKLOCKTIMEVERIFY\r\n+    {\r\n+        CMutableTransaction invalid_with_cltv_tx;\r\n+        invalid_with_cltv_tx.nVersion = 1;\r\n+        invalid_with_cltv_tx.nLockTime = 100;\r\n+        invalid_with_cltv_tx.vin.resize(1);\r\n+        invalid_with_cltv_tx.vin[0].prevout.hash = spend_tx.GetHash();\r\n+        invalid_with_cltv_tx.vin[0].prevout.n = 2;\r\n+        invalid_with_cltv_tx.vin[0].nSequence = 0;\r\n+        invalid_with_cltv_tx.vout.resize(1);\r\n+        invalid_with_cltv_tx.vout[0].nValue = 11*CENT;\r\n+        invalid_with_cltv_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\r\n+\r\n+        // Sign\r\n+        std::vector<unsigned char> vchSig;\r\n+        uint256 hash = SignatureHash(spend_tx.vout[2].scriptPubKey, invalid_with_cltv_tx, 0, SIGHASH_ALL | SIGHASH_FORKID, 0, SIGVERSION_BASE);\r\n+        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\r\n+        vchSig.push_back((unsigned char)SIGHASH_ALL | SIGHASH_FORKID);\r\n+        invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\r\n+\r\n+        ValidateCheckInputsForAllFlags(invalid_with_cltv_tx, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true);\r\n+\r\n+        // Make it valid, and check again\r\n+        invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\r\n+        CValidationState state;\r\n+        PrecomputedTransactionData txdata(invalid_with_cltv_tx);\r\n+        BOOST_CHECK(CheckInputs(invalid_with_cltv_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\r\n+    }\r\n+\r\n+    // TEST CHECKSEQUENCEVERIFY\r\n+    {\r\n+        CMutableTransaction invalid_with_csv_tx;\r\n+        invalid_with_csv_tx.nVersion = 2;\r\n+        invalid_with_csv_tx.vin.resize(1);\r\n+        invalid_with_csv_tx.vin[0].prevout.hash = spend_tx.GetHash();\r\n+        invalid_with_csv_tx.vin[0].prevout.n = 3;\r\n+        invalid_with_csv_tx.vin[0].nSequence = 100;\r\n+        invalid_with_csv_tx.vout.resize(1);\r\n+        invalid_with_csv_tx.vout[0].nValue = 11*CENT;\r\n+        invalid_with_csv_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\r\n+\r\n+        // Sign\r\n+        std::vector<unsigned char> vchSig;\r\n+        uint256 hash = SignatureHash(spend_tx.vout[3].scriptPubKey, invalid_with_csv_tx, 0, SIGHASH_ALL | SIGHASH_FORKID, 0, SIGVERSION_BASE);\r\n+        BOOST_CHECK(coinbaseKey.Sign(hash, vchSig));\r\n+        vchSig.push_back((unsigned char)SIGHASH_ALL | SIGHASH_FORKID);\r\n+        invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 101;\r\n+\r\n+        ValidateCheckInputsForAllFlags(invalid_with_csv_tx, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true);\r\n+\r\n+        // Make it valid, and check again\r\n+        invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\r\n+        CValidationState state;\r\n+        PrecomputedTransactionData txdata(invalid_with_csv_tx);\r\n+        BOOST_CHECK(CheckInputs(invalid_with_csv_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\r\n+    }\r\n+\r\n+    // TODO: add tests for remaining script flags\r\n+\r\n+    // Test that passing CheckInputs with a valid witness doesn't imply success\r\n+    // for the same tx with a different witness.\r\n+    {\r\n+        CMutableTransaction valid_with_witness_tx;\r\n+        valid_with_witness_tx.nVersion = 1;\r\n+        valid_with_witness_tx.vin.resize(1);\r\n+        valid_with_witness_tx.vin[0].prevout.hash = spend_tx.GetHash();\r\n+        valid_with_witness_tx.vin[0].prevout.n = 1;\r\n+        valid_with_witness_tx.vout.resize(1);\r\n+        valid_with_witness_tx.vout[0].nValue = 11*CENT;\r\n+        valid_with_witness_tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\r\n+\r\n+        // Sign\r\n+        SignatureData sigdata;\r\n+        ProduceSignature(MutableTransactionSignatureCreator(&keystore, &valid_with_witness_tx, 0, 11*CENT, SIGHASH_ALL | SIGHASH_FORKID), spend_tx.vout[1].scriptPubKey, sigdata);\r\n+        UpdateTransaction(valid_with_witness_tx, 0, sigdata);\r\n+\r\n+        // This should be valid under all script flags.\r\n+        ValidateCheckInputsForAllFlags(valid_with_witness_tx, 0, true);\r\n+\r\n+        // Remove the witness, and check that it is now invalid.\r\n+        valid_with_witness_tx.vin[0].scriptWitness.SetNull();\r\n+        ValidateCheckInputsForAllFlags(valid_with_witness_tx, SCRIPT_VERIFY_WITNESS, true);\r\n+    }\r\n+\r\n+    {\r\n+        // Test a transaction with multiple inputs.\r\n+        CMutableTransaction tx;\r\n+\r\n+        tx.nVersion = 1;\r\n+        tx.vin.resize(2);\r\n+        tx.vin[0].prevout.hash = spend_tx.GetHash();\r\n+        tx.vin[0].prevout.n = 0;\r\n+        tx.vin[1].prevout.hash = spend_tx.GetHash();\r\n+        tx.vin[1].prevout.n = 1;\r\n+        tx.vout.resize(1);\r\n+        tx.vout[0].nValue = 22*CENT;\r\n+        tx.vout[0].scriptPubKey = p2pk_scriptPubKey;\r\n+\r\n+        // Sign\r\n+        for (int i=0; i<2; ++i) {\r\n+            SignatureData sigdata;\r\n+            ProduceSignature(MutableTransactionSignatureCreator(&keystore, &tx, i, 11*CENT, SIGHASH_ALL | SIGHASH_FORKID), spend_tx.vout[i].scriptPubKey, sigdata);\r\n+            UpdateTransaction(tx, i, sigdata);\r\n+        }\r\n+\r\n+        // This should be valid under all script flags\r\n+        ValidateCheckInputsForAllFlags(tx, 0, true);\r\n+\r\n+        // Check that if the second input is invalid, but the first input is\r\n+        // valid, the transaction is not cached.\r\n+        // Invalidate vin[1]\r\n+        tx.vin[1].scriptWitness.SetNull();\r\n+\r\n+        CValidationState state;\r\n+        PrecomputedTransactionData txdata(tx);\r\n+        // This transaction is now invalid under segwit, because of the second input.\r\n+        BOOST_CHECK(!CheckInputs(tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\r\n+\r\n+        std::vector<CScriptCheck> scriptchecks;\r\n+        // Make sure this transaction was not cached (ie because the first\r\n+        // input was valid)\r\n+        BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\r\n+        // Should get 2 script checks back -- caching is on a whole-transaction basis.\r\n+        BOOST_CHECK_EQUAL(scriptchecks.size(), 2);\r\n+    }\r\n+}\r\n+\r\n+BOOST_AUTO_TEST_SUITE_END()\r"
      }
    ]
  }
]