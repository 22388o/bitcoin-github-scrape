[
  {
    "sha": "b1afd3e7a25adef1912a04929f35cbcf3692ef5b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMWFmZDNlN2EyNWFkZWYxOTEyYTA0OTI5ZjM1Y2JjZjM2OTJlZjVi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-08T21:03:53Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-01-10T21:59:27Z"
      },
      "message": "Require setBlockIndexCandidates be !BLOCK_FAILED_MASK\n\nWhen we find an invalid block, instead of adding BLOCK_FAILED_CHILD\nto its descendants in FindMostWorkChain, iterate\nsetBlockIndexCandidates to find candidate descendants and mark them\nas BLOCK_FAILED_CHILD immediately, removing them from\nsetBlockIndexCandidates as we go. This keeps BLOCK_FAILED_MASK\nentries out of setBlockIndexCandidates.\n\nThis also adds a few checks to CheckBlockIndex, including one which\nchecks that blocks with BLOCK_FAILED_CHILD are not, themselves,\nmarked invalid, but have an invalid parent. This should be fine for\nmost block indexes, however InvalidateBlock previously violated\nthis. Luckily most users shouldn't be running with -checkblockindex\n\nNote that this introduces a bug where a block who's header was\nreceived but data was not when a ancestor was found to be invalid\nwill not be marked BLOCK_FAILED_CHILD. Thus, when that block is\nreceived, it will be added to setBlockIndexCandidates, violating\nthe new invariant. This is fixed in the next commit.",
      "tree": {
        "sha": "fdbd0ea15cbd42646a70951a61363ad9f6235f34",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fdbd0ea15cbd42646a70951a61363ad9f6235f34"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b1afd3e7a25adef1912a04929f35cbcf3692ef5b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b1afd3e7a25adef1912a04929f35cbcf3692ef5b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b1afd3e7a25adef1912a04929f35cbcf3692ef5b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b1afd3e7a25adef1912a04929f35cbcf3692ef5b/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "45173fa6fca9537abb0a0554f731d14b9f89c456",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/45173fa6fca9537abb0a0554f731d14b9f89c456",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/45173fa6fca9537abb0a0554f731d14b9f89c456"
      }
    ],
    "stats": {
      "total": 101,
      "additions": 72,
      "deletions": 29
    },
    "files": [
      {
        "sha": "d9388c79adbde9a69e602d37cddb8012b6a8db6d",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 72,
        "deletions": 29,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b1afd3e7a25adef1912a04929f35cbcf3692ef5b/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b1afd3e7a25adef1912a04929f35cbcf3692ef5b/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b1afd3e7a25adef1912a04929f35cbcf3692ef5b",
        "patch": "@@ -60,6 +60,7 @@\n namespace {\n     struct CBlockIndexWorkComparator\n     {\n+        // Returns pa < pb in work-order\n         bool operator()(const CBlockIndex *pa, const CBlockIndex *pb) const {\n             // First sort by most total work, ...\n             if (pa->nChainWork > pb->nChainWork) return false;\n@@ -107,8 +108,7 @@ class CChainState {\n private:\n     /**\n      * The set of all CBlockIndex entries with BLOCK_VALID_TRANSACTIONS (for itself and all ancestors) and\n-     * as good as our current tip or better. Entries may be failed, though, and pruning nodes may be\n-     * missing the data for the block.\n+     * as good as our current tip or better. Pruning nodes may be missing the data for the block.\n      */\n     std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n \n@@ -191,6 +191,7 @@ class CChainState {\n     CBlockIndex* FindMostWorkChain();\n     bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBlockIndex *pindexNew, const CDiskBlockPos& pos, const Consensus::Params& consensusParams);\n \n+    void PruneInvalidBlockIndexCandidates(CBlockIndex* pindexInvalid);\n \n     bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs, const CChainParams& params);\n } g_chainstate;\n@@ -1259,6 +1260,48 @@ static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n     CheckForkWarningConditions();\n }\n \n+// Helper for PruneInvalidBlockIndexCandidates\n+static void PruneInvalidIndexCandidatesInSet(CBlockIndex* pindexInvalid, std::set<CBlockIndex*, CBlockIndexWorkComparator>& set_candidates) {\n+    // Iterate set_candidates downwards, deleting parents of pindexInvalid,\n+    // until we get to headers which are lower total-work than pindexInvalid\n+    // (at which point they can't be parents of pindexInvalid).\n+    std::set<CBlockIndex*, CBlockIndexWorkComparator>::reverse_iterator it = set_candidates.rbegin();\n+    while (it != set_candidates.rend() && (*it)->nChainWork > pindexInvalid->nChainWork) {\n+        if ((*it)->GetAncestor(pindexInvalid->nHeight) == pindexInvalid) {\n+            CBlockIndex* pindexInvalidTip = *it;\n+            if (!pindexBestInvalid || pindexInvalidTip->nChainWork > pindexBestInvalid->nChainWork)\n+                pindexBestInvalid = pindexInvalidTip;\n+\n+            while (pindexInvalidTip != pindexInvalid) {\n+                if (!(pindexInvalidTip->nStatus & BLOCK_FAILED_MASK)) {\n+                    pindexInvalidTip->nStatus |= BLOCK_FAILED_CHILD;\n+                    setDirtyBlockIndex.insert(pindexInvalidTip);\n+                }\n+                pindexInvalidTip = pindexInvalidTip->pprev;\n+            }\n+            std::set<CBlockIndex*, CBlockIndexWorkComparator>::iterator forward_it = it.base(); // Is one past it\n+            forward_it--; // Now points to it\n+            forward_it = set_candidates.erase(forward_it);\n+            it = std::set<CBlockIndex*, CBlockIndexWorkComparator>::reverse_iterator(forward_it);\n+            // forward_it == it.base() now points to one-past previous it, making it point to one-before previous it.\n+        } else {\n+            it++;\n+        }\n+    }\n+    set_candidates.erase(pindexInvalid);\n+}\n+\n+/**\n+ * Removes any descendants of pindexInvalid from candidate blocks,\n+ * marking them BLOCK_FAILED_CHILD as we go\n+ */\n+void CChainState::PruneInvalidBlockIndexCandidates(CBlockIndex* pindexInvalid) {\n+    AssertLockHeld(cs_main);\n+    assert(pindexInvalid->nStatus & BLOCK_FAILED_MASK);\n+\n+    PruneInvalidIndexCandidatesInSet(pindexInvalid, setBlockIndexCandidates);\n+}\n+\n void static InvalidChainFound(CBlockIndex* pindexNew)\n {\n     if (!pindexBestInvalid || pindexNew->nChainWork > pindexBestInvalid->nChainWork)\n@@ -1281,7 +1324,7 @@ void CChainState::InvalidBlockFound(CBlockIndex *pindex, const CValidationState\n         pindex->nStatus |= BLOCK_FAILED_VALID;\n         g_failed_blocks.insert(pindex);\n         setDirtyBlockIndex.insert(pindex);\n-        setBlockIndexCandidates.erase(pindex);\n+        PruneInvalidBlockIndexCandidates(pindex);\n         InvalidChainFound(pindex);\n     }\n }\n@@ -2396,28 +2439,21 @@ CBlockIndex* CChainState::FindMostWorkChain() {\n         bool fInvalidAncestor = false;\n         while (pindexTest && !chainActive.Contains(pindexTest)) {\n             assert(pindexTest->nChainTx || pindexTest->nHeight == 0);\n+            assert(pindexTest->IsValid(BLOCK_VALID_TRANSACTIONS));\n \n             // Pruned nodes may have entries in setBlockIndexCandidates for\n             // which block files have been deleted.  Remove those as candidates\n             // for the most work chain if we come across them; we can't switch\n             // to a chain unless we have all the non-active-chain parent blocks.\n-            bool fFailedChain = pindexTest->nStatus & BLOCK_FAILED_MASK;\n-            bool fMissingData = !(pindexTest->nStatus & BLOCK_HAVE_DATA);\n-            if (fFailedChain || fMissingData) {\n+            if (!(pindexTest->nStatus & BLOCK_HAVE_DATA)) {\n                 // Candidate chain is not usable (either invalid or missing data)\n-                if (fFailedChain && (pindexBestInvalid == nullptr || pindexNew->nChainWork > pindexBestInvalid->nChainWork))\n-                    pindexBestInvalid = pindexNew;\n                 CBlockIndex *pindexFailed = pindexNew;\n                 // Remove the entire chain from the set.\n                 while (pindexTest != pindexFailed) {\n-                    if (fFailedChain) {\n-                        pindexFailed->nStatus |= BLOCK_FAILED_CHILD;\n-                    } else if (fMissingData) {\n-                        // If we're missing data, then add back to mapBlocksUnlinked,\n-                        // so that if the block arrives in the future we can try adding\n-                        // to setBlockIndexCandidates again.\n-                        mapBlocksUnlinked.insert(std::make_pair(pindexFailed->pprev, pindexFailed));\n-                    }\n+                    // If we're missing data, then add back to mapBlocksUnlinked,\n+                    // so that if the block arrives in the future we can try adding\n+                    // to setBlockIndexCandidates again.\n+                    mapBlocksUnlinked.insert(std::make_pair(pindexFailed->pprev, pindexFailed));\n                     setBlockIndexCandidates.erase(pindexFailed);\n                     pindexFailed = pindexFailed->pprev;\n                 }\n@@ -4395,20 +4431,27 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n             // Checks for not-invalid blocks.\n             assert((pindex->nStatus & BLOCK_FAILED_MASK) == 0); // The failed mask cannot be set for blocks without invalid parents.\n         }\n-        if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && pindexFirstNeverProcessed == nullptr) {\n-            if (pindexFirstInvalid == nullptr) {\n-                // If this block sorts at least as good as the current tip and\n-                // is valid and we have all data for its parents, it must be in\n-                // setBlockIndexCandidates.  chainActive.Tip() must also be there\n-                // even if some data has been pruned.\n-                if (pindexFirstMissing == nullptr || pindex == chainActive.Tip()) {\n-                    assert(setBlockIndexCandidates.count(pindex));\n-                }\n-                // If some parent is missing, then it could be that this block was in\n-                // setBlockIndexCandidates but had to be removed because of the missing data.\n-                // In this case it must be in mapBlocksUnlinked -- see test below.\n+        if (pindex->nStatus & BLOCK_FAILED_CHILD) {\n+            // Blocks which failed with \"CHILD\" must have an invalid parent\n+            assert(pindexFirstInvalid);\n+            assert(pindexFirstInvalid != pindex);\n+            assert(!(pindex->nStatus & BLOCK_FAILED_VALID));\n+        }\n+        if (pindex->nStatus & BLOCK_FAILED_VALID) {\n+            assert(!(pindex->nStatus & BLOCK_FAILED_CHILD));\n+        }\n+        if (!CBlockIndexWorkComparator()(pindex, chainActive.Tip()) && pindexFirstNeverProcessed == nullptr && pindexFirstInvalid == nullptr) {\n+            // If this block sorts at least as good as the current tip and\n+            // is valid and we have all data for its parents, it must be in\n+            // setBlockIndexCandidates.  chainActive.Tip() must also be there\n+            // even if some data has been pruned.\n+            if (pindexFirstMissing == nullptr || pindex == chainActive.Tip()) {\n+                assert(setBlockIndexCandidates.count(pindex));\n             }\n-        } else { // If this block sorts worse than the current tip or some ancestor's block has never been seen, it cannot be in setBlockIndexCandidates.\n+            // If some parent is missing, then it could be that this block was in\n+            // setBlockIndexCandidates but had to be removed because of the missing data.\n+            // In this case it must be in mapBlocksUnlinked -- see test below.\n+        } else { // If this block sorts worse than the current tip or some ancestor's block has never been seen or is invalid, it cannot be in setBlockIndexCandidates.\n             assert(setBlockIndexCandidates.count(pindex) == 0);\n         }\n         // Check whether this block is in mapBlocksUnlinked."
      }
    ]
  },
  {
    "sha": "7b8055ff53f7a0d33db148ebf18ef90f46a21941",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3YjgwNTVmZjUzZjdhMGQzM2RiMTQ4ZWJmMThlZjkwZjQ2YTIxOTQx",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-08T23:43:23Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-01-10T21:59:27Z"
      },
      "message": "Add a set to track potential future chain tips based only on SPV.\n\nThis mirrors setBlockIndexCandidates but for BLOCK_VALID_TREE\ninstead of BLOCK_VALID_TRANSACTIONS && nTx. There are a few\ndifferences between the two to keep the new set practical, see\ncode comments for more.",
      "tree": {
        "sha": "ac4cef153a987179361fba61af9b85aaca0365e4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ac4cef153a987179361fba61af9b85aaca0365e4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7b8055ff53f7a0d33db148ebf18ef90f46a21941",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b8055ff53f7a0d33db148ebf18ef90f46a21941",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7b8055ff53f7a0d33db148ebf18ef90f46a21941",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b8055ff53f7a0d33db148ebf18ef90f46a21941/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b1afd3e7a25adef1912a04929f35cbcf3692ef5b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b1afd3e7a25adef1912a04929f35cbcf3692ef5b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b1afd3e7a25adef1912a04929f35cbcf3692ef5b"
      }
    ],
    "stats": {
      "total": 230,
      "additions": 209,
      "deletions": 21
    },
    "files": [
      {
        "sha": "1d7e508f2e2c96fe7e411cc93750074e3ed7d877",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 209,
        "deletions": 21,
        "changes": 230,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7b8055ff53f7a0d33db148ebf18ef90f46a21941/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7b8055ff53f7a0d33db148ebf18ef90f46a21941/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=7b8055ff53f7a0d33db148ebf18ef90f46a21941",
        "patch": "@@ -111,6 +111,31 @@ class CChainState {\n      * as good as our current tip or better. Pruning nodes may be missing the data for the block.\n      */\n     std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexCandidates;\n+    /**\n+     * The set of all leaf CBlockIndex entries with BLOCK_VALID_TREE (for itself and all ancestors) and\n+     * as good as our current tip or better. Entries here are potential future candidates for insertion\n+     * into setBlockIndexCandidates, once we get all the required block data. Thus, entries here\n+     * represent chains on which we should be actively downloading block data.\n+     *\n+     * Note that we define \"as good as our current tip or better\" slightly differently here than in\n+     * setBlockIndexCandidates - we include things which will have a higher nSequence (but have the\n+     * same chain work) here, but do not include such entries in setBlockIndexCandidates. This is\n+     * because we prefer to also download towards chains which have the same total work as our current\n+     * chain (as an optimization since a reorg is very possible in such cases).\n+     *\n+     * Note that, unlike setBlockIndexCandidates, we only store \"leaf\" entries here, as we are not as\n+     * aggressively prune-able (setBlockIndexCandidates are things which we can, and usually do, try to\n+     * connect immediately, and thus entries dont stick around for long). Thus, it may be the case that\n+     * chainActive.Tip() is NOT in setBlockIndexHeaderCandidates.\n+     *\n+     * Additionally, unlike setBlockIndexCandidates, we are happy to store entries which are not\n+     * connectable due to pruning here.\n+     *\n+     * Note that we have to be pretty careful with nSequenceId here - CBlockIndexWorkComparator uses\n+     * nSequenceId to sort, but entries may have the same work and sequence! Thus, we don't use the set's\n+     * sorter but instead compare using nChainWork while iterating!\n+     */\n+    std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexHeaderCandidates;\n \n     /**\n      * Every received block is assigned a unique and increasing identifier, so we\n@@ -192,6 +217,7 @@ class CChainState {\n     bool ReceivedBlockTransactions(const CBlock &block, CValidationState& state, CBlockIndex *pindexNew, const CDiskBlockPos& pos, const Consensus::Params& consensusParams);\n \n     void PruneInvalidBlockIndexCandidates(CBlockIndex* pindexInvalid);\n+    void MaybeAddNewHeaderCandidate(CBlockIndex* pindex, bool chain_ordered_insertion, bool no_descendants);\n \n     bool RollforwardBlock(const CBlockIndex* pindex, CCoinsViewCache& inputs, const CChainParams& params);\n } g_chainstate;\n@@ -1260,6 +1286,75 @@ static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip)\n     CheckForkWarningConditions();\n }\n \n+/**\n+ * Called when a header (re-)reached BLOCK_VALID_TREE.\n+ *\n+ * setBlockIndexHeaderCandidates is a bit more complicated than\n+ * setBlockIndexCandidates as setBlockIndexCandidates can be rather lazy\n+ * as everything in it is about to be connected. In our case, we may have many\n+ * headers above the tip leading down different chains, for which we really\n+ * only want to keep the tip of each chain.\n+ *\n+ * Works even if chainActive is empty!\n+ *\n+ * If chain_ordered_inertion, we assume that if pindex->pprev was previously a\n+ * header candidate, it will be when we're called. ie we assume that there are\n+ * no header candidates which are parents of us except for possibly our direct\n+ * parent.\n+ *\n+ * no_descendants allows us to make a similar, but inverted, assumption -\n+ * assuming no descendant blocks may be header candidates.\n+ */\n+void CChainState::MaybeAddNewHeaderCandidate(CBlockIndex* pindex, bool chain_ordered_insertion, bool no_descendants) {\n+    if (!pindex->IsValid(BLOCK_VALID_TREE)) return; // We only want things that have a valid header tree\n+\n+    bool lower_work = chainActive.Tip() != nullptr && chainActive.Tip()->nChainWork > pindex->nChainWork;\n+    if (lower_work) return; // We don't want things with less work than our current tip\n+\n+    bool parent_present = false;\n+    if (pindex->pprev && setBlockIndexHeaderCandidates.count(pindex->pprev)) {\n+        // If the parent is a previous candidate, then no parents of it could\n+        // be candidates, either. This is the only thing we need to check by\n+        // definition of chain_ordered_insertion, however even in the case of\n+        // !chain_ordered_insertion, if this is true, no need to do a full\n+        // parent scan (as no further-up parent can be a candidate, either).\n+        setBlockIndexHeaderCandidates.erase(pindex->pprev);\n+        parent_present = true;\n+    } else if (!chain_ordered_insertion) {\n+        // We are being called in a for(p : mapBlockIndex) loop, so can make no\n+        // assumptions about existing entries. Scan all other entries to check\n+        // if we're a descendant of some other candidate.\n+        for (auto it = setBlockIndexHeaderCandidates.begin(); it != setBlockIndexHeaderCandidates.end() && (*it)->nChainWork < pindex->nChainWork; it++) {\n+            if (pindex->GetAncestor((*it)->nHeight) == *it) {\n+                // it should be removed - we only keep the tip of potential\n+                // chains, not anything in them. At this point we should be\n+                // consistent by adding pindex, there should be more more work\n+                // to do here.\n+                setBlockIndexHeaderCandidates.erase(it);\n+                break;\n+                parent_present = true;\n+            }\n+        }\n+    }\n+\n+    if (!parent_present && !no_descendants) {\n+        // Scan higher-work entries to check that we're not a parent of some\n+        // other candidate(s). If a parent of ours was already present then we\n+        // can be certain that no such child is also a candidate, so we can\n+        // skip the whole scan.\n+        for (auto it = setBlockIndexHeaderCandidates.rbegin(); it != setBlockIndexHeaderCandidates.rend() && (*it)->nChainWork > pindex->nChainWork; it++) {\n+            if ((*it)->GetAncestor(pindex->nHeight) == pindex) {\n+                // pindex is useless - even if there are other tips based on it\n+                // which we want in setBlockIndexHeaderCandidates, we're not\n+                // gonna find them here.\n+                return;\n+            }\n+        }\n+    }\n+\n+    setBlockIndexHeaderCandidates.insert(pindex);\n+}\n+\n // Helper for PruneInvalidBlockIndexCandidates\n static void PruneInvalidIndexCandidatesInSet(CBlockIndex* pindexInvalid, std::set<CBlockIndex*, CBlockIndexWorkComparator>& set_candidates) {\n     // Iterate set_candidates downwards, deleting parents of pindexInvalid,\n@@ -1300,6 +1395,7 @@ void CChainState::PruneInvalidBlockIndexCandidates(CBlockIndex* pindexInvalid) {\n     assert(pindexInvalid->nStatus & BLOCK_FAILED_MASK);\n \n     PruneInvalidIndexCandidatesInSet(pindexInvalid, setBlockIndexCandidates);\n+    PruneInvalidIndexCandidatesInSet(pindexInvalid, setBlockIndexHeaderCandidates);\n }\n \n void static InvalidChainFound(CBlockIndex* pindexNew)\n@@ -1325,6 +1421,16 @@ void CChainState::InvalidBlockFound(CBlockIndex *pindex, const CValidationState\n         g_failed_blocks.insert(pindex);\n         setDirtyBlockIndex.insert(pindex);\n         PruneInvalidBlockIndexCandidates(pindex);\n+        if (pindex->pprev) {\n+            // In the simple case where we tried to advance forward one block,\n+            // but failed, we may now have an empty setBlockIndexHeaderCandidates,\n+            // so we need to re-add the previous block here. The same is not true\n+            // for setBlockIndexCandidates, as it does not have the same leaf-only\n+            // precondition which setBlockIndexHeaderCandidates has.\n+            // Note that its possible there are later descendants that are candidates\n+            // so we cannot set no_descendants here.\n+            MaybeAddNewHeaderCandidate(pindex->pprev, true, false);\n+        }\n         InvalidChainFound(pindex);\n     }\n }\n@@ -2478,6 +2584,16 @@ void CChainState::PruneBlockIndexCandidates() {\n     }\n     // Either the current tip or a successor of it we're working towards is left in setBlockIndexCandidates.\n     assert(!setBlockIndexCandidates.empty());\n+    // Now do the same for setBlockIndexHeaderCandidates (noting that we have to compare manually due to nSequenceId oddities)\n+    it = setBlockIndexHeaderCandidates.begin();\n+    while (it != setBlockIndexHeaderCandidates.end() && (*it)->nChainWork <= chainActive.Tip()->nChainWork) {\n+        if (chainActive.Tip()->nChainWork > (*it)->nChainWork) {\n+            setBlockIndexHeaderCandidates.erase(it++);\n+        } else {\n+            it++;\n+        }\n+    }\n+    assert(!setBlockIndexHeaderCandidates.empty());\n }\n \n /**\n@@ -2687,13 +2803,20 @@ bool CChainState::PreciousBlock(CValidationState& state, const CChainParams& par\n             nBlockReverseSequenceId = -1;\n         }\n         nLastPreciousChainwork = chainActive.Tip()->nChainWork;\n+        // Make sure to remove from sets which are indexed by nSequenceId first...\n         setBlockIndexCandidates.erase(pindex);\n+        bool pindex_is_header_candidate = setBlockIndexHeaderCandidates.erase(pindex);\n         pindex->nSequenceId = nBlockReverseSequenceId;\n         if (nBlockReverseSequenceId > std::numeric_limits<int32_t>::min()) {\n             // We can't keep reducing the counter if somebody really wants to\n             // call preciousblock 2**31-1 times on the same set of tips...\n             nBlockReverseSequenceId--;\n         }\n+        if (pindex_is_header_candidate) {\n+            // Note that because we only changed the sequence, pindex should be in\n+            // setBlockIndexHeaderCandidates iff it was previously in the same.\n+            setBlockIndexHeaderCandidates.insert(pindex);\n+        }\n         if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && pindex->nChainTx) {\n             setBlockIndexCandidates.insert(pindex);\n             PruneBlockIndexCandidates();\n@@ -2716,12 +2839,8 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n     // are no blocks that meet the \"have data and are not invalid per\n     // nStatus\" criteria for inclusion in setBlockIndexCandidates).\n \n-    bool pindex_was_in_chain = false;\n-    CBlockIndex *invalid_walk_tip = chainActive.Tip();\n-\n     DisconnectedBlockTransactions disconnectpool;\n     while (chainActive.Contains(pindex)) {\n-        pindex_was_in_chain = true;\n         // ActivateBestChain considers blocks already in chainActive\n         // unconditionally valid already, so force disconnect away from it.\n         if (!DisconnectTip(state, chainparams, &disconnectpool)) {\n@@ -2732,19 +2851,13 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n         }\n     }\n \n-    // Now mark the blocks we just disconnected as descendants invalid\n-    // (note this may not be all descendants).\n-    while (pindex_was_in_chain && invalid_walk_tip != pindex) {\n-        invalid_walk_tip->nStatus |= BLOCK_FAILED_CHILD;\n-        setDirtyBlockIndex.insert(invalid_walk_tip);\n-        setBlockIndexCandidates.erase(invalid_walk_tip);\n-        invalid_walk_tip = invalid_walk_tip->pprev;\n-    }\n-\n     // Mark the block itself as invalid.\n     pindex->nStatus |= BLOCK_FAILED_VALID;\n     setDirtyBlockIndex.insert(pindex);\n-    setBlockIndexCandidates.erase(pindex);\n+\n+    // chainActive.Tip() is always in our candidate sets, so any blocks we just\n+    // disconnected will be marked BLOCK_FAILED_CHILD by PruneInvalidBlockIndexCandidates.\n+    PruneInvalidBlockIndexCandidates(pindex);\n     g_failed_blocks.insert(pindex);\n \n     // DisconnectTip will add transactions to disconnectpool; try to add these\n@@ -2755,8 +2868,26 @@ bool CChainState::InvalidateBlock(CValidationState& state, const CChainParams& c\n     // add it again.\n     BlockMap::iterator it = mapBlockIndex.begin();\n     while (it != mapBlockIndex.end()) {\n-        if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->nChainTx && !setBlockIndexCandidates.value_comp()(it->second, chainActive.Tip())) {\n-            setBlockIndexCandidates.insert(it->second);\n+        if (it->second->nChainWork >= chainActive.Tip()->nChainWork) {\n+            if (it->second->GetAncestor(pindex->nHeight) == pindex) {\n+                // It is possible that we have a CBlockIndex which is a\n+                // descendant of the one we just marked invalid, but which we\n+                // did not mark BLOCK_FAILED_CHILD in the\n+                // PruneInvalidBlockIndexCandidates pass, as it was below our\n+                // previous tip. We should mark it (and its parents) invalid.\n+                CBlockIndex* invalid_walk = it->second;\n+                while (invalid_walk != pindex && !(invalid_walk->nStatus & BLOCK_FAILED_MASK)) {\n+                    invalid_walk->nStatus |= BLOCK_FAILED_CHILD;\n+                    setDirtyBlockIndex.insert(invalid_walk);\n+                    invalid_walk = invalid_walk->pprev;\n+                }\n+            } else if (it->second->IsValid(BLOCK_VALID_TREE)) {\n+                MaybeAddNewHeaderCandidate(it->second, false, false);\n+                if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->nChainTx &&\n+                        !setBlockIndexCandidates.value_comp()(it->second, chainActive.Tip())) { // check sequence now because we didn't earlier\n+                    setBlockIndexCandidates.insert(it->second);\n+                }\n+            }\n         }\n         it++;\n     }\n@@ -2780,8 +2911,12 @@ bool CChainState::ResetBlockFailureFlags(CBlockIndex *pindex) {\n         if (!it->second->IsValid() && it->second->GetAncestor(nHeight) == pindex) {\n             it->second->nStatus &= ~BLOCK_FAILED_MASK;\n             setDirtyBlockIndex.insert(it->second);\n-            if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->nChainTx && setBlockIndexCandidates.value_comp()(chainActive.Tip(), it->second)) {\n-                setBlockIndexCandidates.insert(it->second);\n+            if (it->second->IsValid(BLOCK_VALID_TREE) && it->second->nChainWork >= chainActive.Tip()->nChainWork) {\n+                MaybeAddNewHeaderCandidate(it->second, false, false);\n+                if (it->second->IsValid(BLOCK_VALID_TRANSACTIONS) && it->second->nChainTx &&\n+                        setBlockIndexCandidates.value_comp()(chainActive.Tip(), it->second)) { // Check nSequence here\n+                    setBlockIndexCandidates.insert(it->second);\n+                }\n             }\n             if (it->second == pindexBestInvalid) {\n                 // Reset invalid block marker if it was pointing to one of those.\n@@ -2834,6 +2969,7 @@ CBlockIndex* CChainState::AddToBlockIndex(const CBlockHeader& block)\n     pindexNew->RaiseValidity(BLOCK_VALID_TREE);\n     if (pindexBestHeader == nullptr || pindexBestHeader->nChainWork < pindexNew->nChainWork)\n         pindexBestHeader = pindexNew;\n+    MaybeAddNewHeaderCandidate(pindexNew, true, true);\n \n     setDirtyBlockIndex.insert(pindexNew);\n \n@@ -2865,10 +3001,18 @@ bool CChainState::ReceivedBlockTransactions(const CBlock &block, CValidationStat\n             CBlockIndex *pindex = queue.front();\n             queue.pop_front();\n             pindex->nChainTx = (pindex->pprev ? pindex->pprev->nChainTx : 0) + pindex->nTx;\n+            // Make sure to remove from sets which are indexed by nSequenceId first...\n+            bool was_header_candidate = setBlockIndexHeaderCandidates.erase(pindex);\n             {\n                 LOCK(cs_nBlockSequenceId);\n                 pindex->nSequenceId = nBlockSequenceId++;\n             }\n+            if (was_header_candidate) {\n+                // It is safe to use chain_ordered_insertion and no_descendants here\n+                // as, if the block was previously a header candidate, we know there\n+                // are no parents/descendants which are also header candidates.\n+                MaybeAddNewHeaderCandidate(pindex, true, true);\n+            }\n             if (chainActive.Tip() == nullptr || !setBlockIndexCandidates.value_comp()(pindex, chainActive.Tip())) {\n                 setBlockIndexCandidates.insert(pindex);\n             }\n@@ -3279,6 +3423,23 @@ bool CChainState::AcceptBlockHeader(const CBlockHeader& block, CValidationState&\n         if (!ContextualCheckBlockHeader(block, state, chainparams, pindexPrev, GetAdjustedTime()))\n             return error(\"%s: Consensus::ContextualCheckBlockHeader: %s, %s\", __func__, hash.ToString(), FormatStateMessage(state));\n \n+        /* Take the following chain:\n+         *\n+         *                D3\n+         *              /\n+         *      B2 - C2\n+         *    /         \\\n+         *  A             D2 - E2 - F2\n+         *    \\\n+         *      B1 - C1 - D1 - E1\n+         *\n+         * In the case that we attempted to reorg from E1 to F2, only to find\n+         * C2 to be invalid, we would mark D2, E2, and F2 as BLOCK_FAILED_CHILD\n+         * but NOT D3 (it was not in any of our candidate sets at the time).\n+         * Thus, if we now are accepting headers built on D3, it may be the\n+         * case that they actually have failed parents despite pindexPrev being\n+         * !BLOCK_FAILED_MASK. We check for this case here:\n+         */\n         if (!pindexPrev->IsValid(BLOCK_VALID_SCRIPTS)) {\n             for (const CBlockIndex* failedit : g_failed_blocks) {\n                 if (pindexPrev->GetAncestor(failedit->nHeight) == failedit) {\n@@ -3394,9 +3555,8 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n \n     if (!CheckBlock(block, state, chainparams.GetConsensus()) ||\n         !ContextualCheckBlock(block, state, chainparams.GetConsensus(), pindex->pprev)) {\n-        if (state.IsInvalid() && !state.CorruptionPossible()) {\n-            pindex->nStatus |= BLOCK_FAILED_VALID;\n-            setDirtyBlockIndex.insert(pindex);\n+        if (state.IsInvalid()) {\n+            InvalidBlockFound(pindex, state);\n         }\n         return error(\"%s: %s\", __func__, FormatStateMessage(state));\n     }\n@@ -3741,6 +3901,8 @@ bool CChainState::LoadBlockIndex(const Consensus::Params& consensus_params, CBlo\n             pindex->nStatus |= BLOCK_FAILED_CHILD;\n             setDirtyBlockIndex.insert(pindex);\n         }\n+        if (pindex->IsValid(BLOCK_VALID_TREE))\n+            MaybeAddNewHeaderCandidate(pindex, true, true);\n         if (pindex->IsValid(BLOCK_VALID_TRANSACTIONS) && (pindex->nChainTx || pindex->pprev == nullptr))\n             setBlockIndexCandidates.insert(pindex);\n         if (pindex->nStatus & BLOCK_FAILED_MASK && (!pindexBestInvalid || pindex->nChainWork > pindexBestInvalid->nChainWork))\n@@ -4107,6 +4269,11 @@ bool CChainState::RewindBlockIndex(const CChainParams& params)\n         } else if (pindexIter->IsValid(BLOCK_VALID_TRANSACTIONS) && pindexIter->nChainTx) {\n             setBlockIndexCandidates.insert(pindexIter);\n         }\n+        // In case we disconnected blocks which resulted in new header\n+        // candidates, we need to re-add them here.\n+        if (pindexIter->IsValid(BLOCK_VALID_TREE)) {\n+            MaybeAddNewHeaderCandidate(pindexIter, false, false);\n+        }\n     }\n \n     if (chainActive.Tip() != nullptr) {\n@@ -4142,6 +4309,7 @@ void CChainState::UnloadBlockIndex() {\n     nBlockSequenceId = 1;\n     g_failed_blocks.clear();\n     setBlockIndexCandidates.clear();\n+    setBlockIndexHeaderCandidates.clear();\n }\n \n // May NOT be used after any connections are up as much\n@@ -4388,6 +4556,7 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n     CBlockIndex* pindexFirstNotTransactionsValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_TRANSACTIONS (regardless of being valid or not).\n     CBlockIndex* pindexFirstNotChainValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_CHAIN (regardless of being valid or not).\n     CBlockIndex* pindexFirstNotScriptsValid = nullptr; // Oldest ancestor of pindex which does not have BLOCK_VALID_SCRIPTS (regardless of being valid or not).\n+    CBlockIndex* pindexFirstInBlockIndexHeaderCandidates = nullptr; // Oldest ancestor of pindex which is in setBlockIndexHeaderCandidates (should always be only pindex)\n     while (pindex != nullptr) {\n         nNodes++;\n         if (pindexFirstInvalid == nullptr && pindex->nStatus & BLOCK_FAILED_VALID) pindexFirstInvalid = pindex;\n@@ -4454,6 +4623,23 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n         } else { // If this block sorts worse than the current tip or some ancestor's block has never been seen or is invalid, it cannot be in setBlockIndexCandidates.\n             assert(setBlockIndexCandidates.count(pindex) == 0);\n         }\n+        bool must_be_header_candidate_if_leaf = false;\n+        if (pindex->nChainWork < chainActive.Tip()->nChainWork) {\n+            // Irrespective of pruned-ness, if this block sorts worse than the current tip, it cannot be in setBlockIndexHeaderCandidates\n+            assert(setBlockIndexHeaderCandidates.count(pindex) == 0);\n+        } else if (pindexFirstInvalid == nullptr) {\n+            // If pindex is a leaf node and sorts at the same or greater height\n+            // than chainActive.Tip(), it must be in setBlockIndexHeaderCandidates.\n+            must_be_header_candidate_if_leaf = true;\n+        }\n+        if (setBlockIndexHeaderCandidates.count(pindex)) {\n+            // setBlockIndexHeaderCandidates may not contain anything for which a parent is invalid\n+            assert(pindexFirstInvalid == nullptr);\n+            assert(pindex->IsValid(BLOCK_VALID_TREE));\n+            // We should only be in setBlockIndexHeaderCandidates if we are a leaf node\n+            assert(pindexFirstInBlockIndexHeaderCandidates == nullptr);\n+            pindexFirstInBlockIndexHeaderCandidates = pindex;\n+        }\n         // Check whether this block is in mapBlocksUnlinked.\n         std::pair<std::multimap<CBlockIndex*,CBlockIndex*>::iterator,std::multimap<CBlockIndex*,CBlockIndex*>::iterator> rangeUnlinked = mapBlocksUnlinked.equal_range(pindex->pprev);\n         bool foundInUnlinked = false;\n@@ -4500,6 +4686,7 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n             continue;\n         }\n         // This is a leaf node.\n+        if (must_be_header_candidate_if_leaf) assert(setBlockIndexHeaderCandidates.count(pindex));\n         // Move upwards until we reach a node of which we have not yet visited the last child.\n         while (pindex) {\n             // We are going to either move to a parent or a sibling of pindex.\n@@ -4511,6 +4698,7 @@ void CChainState::CheckBlockIndex(const Consensus::Params& consensusParams)\n             if (pindex == pindexFirstNotTransactionsValid) pindexFirstNotTransactionsValid = nullptr;\n             if (pindex == pindexFirstNotChainValid) pindexFirstNotChainValid = nullptr;\n             if (pindex == pindexFirstNotScriptsValid) pindexFirstNotScriptsValid = nullptr;\n+            if (pindex == pindexFirstInBlockIndexHeaderCandidates) pindexFirstInBlockIndexHeaderCandidates = nullptr;\n             // Find our parent.\n             CBlockIndex* pindexPar = pindex->pprev;\n             // Find which child we just visited."
      }
    ]
  },
  {
    "sha": "350395d1b5caf09d71866eb8de0475db65da6704",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozNTAzOTVkMWI1Y2FmMDlkNzE4NjZlYjhkZTA0NzVkYjY1ZGE2NzA0",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-08T21:16:32Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-01-10T21:59:27Z"
      },
      "message": "Default to running -checkblockindex in test_framework\n\nBlock index inconsistencies are one of the most critical types of\nbugs we could see. Making sure we get good coverage of\nCheckBlockIndex() is pretty important (and there is minimal, if any\nperformance difference in a default run).",
      "tree": {
        "sha": "b96cccdad3d0000c96ea12774eada931bf94a019",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b96cccdad3d0000c96ea12774eada931bf94a019"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/350395d1b5caf09d71866eb8de0475db65da6704",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/350395d1b5caf09d71866eb8de0475db65da6704",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/350395d1b5caf09d71866eb8de0475db65da6704",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/350395d1b5caf09d71866eb8de0475db65da6704/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7b8055ff53f7a0d33db148ebf18ef90f46a21941",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7b8055ff53f7a0d33db148ebf18ef90f46a21941",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7b8055ff53f7a0d33db148ebf18ef90f46a21941"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "99415b124372516b11dc39dc379b20f3d46843d4",
        "filename": "test/functional/test_framework/test_node.py",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/350395d1b5caf09d71866eb8de0475db65da6704/test/functional/test_framework/test_node.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/350395d1b5caf09d71866eb8de0475db65da6704/test/functional/test_framework/test_node.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/test_framework/test_node.py?ref=350395d1b5caf09d71866eb8de0475db65da6704",
        "patch": "@@ -55,7 +55,7 @@ def __init__(self, i, dirname, extra_args, rpchost, timewait, binary, stderr, mo\n         self.coverage_dir = coverage_dir\n         # Most callers will just need to add extra args to the standard list below. For those callers that need more flexibity, they can just set the args property directly.\n         self.extra_args = extra_args\n-        self.args = [self.binary, \"-datadir=\" + self.datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-debugexclude=libevent\", \"-debugexclude=leveldb\", \"-mocktime=\" + str(mocktime), \"-uacomment=testnode%d\" % i]\n+        self.args = [self.binary, \"-datadir=\" + self.datadir, \"-server\", \"-keypool=1\", \"-discover=0\", \"-rest\", \"-logtimemicros\", \"-debug\", \"-debugexclude=libevent\", \"-debugexclude=leveldb\", \"-mocktime=\" + str(mocktime), \"-uacomment=testnode%d\" % i, \"-checkblockindex=1\"]\n \n         self.cli = TestNodeCLI(os.getenv(\"BITCOINCLI\", \"bitcoin-cli\"), self.datadir)\n "
      }
    ]
  },
  {
    "sha": "a9db3dada0119c183d16627805e90c4dbca05c6a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphOWRiM2RhZGEwMTE5YzE4M2QxNjYyNzgwNWU5MGM0ZGJjYTA1YzZh",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-09T15:19:10Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-01-10T21:59:27Z"
      },
      "message": "Do not unlock cs_main in ABC unless we've actually made progress.\n\nTechnically, some internal datastructures may be in an inconsistent\nstate if we do this, though there are no known bugs there. Still,\nfor future safety, its much better to only unlock cs_main if we've\nmade progress (not just tried a reorg which may make progress).",
      "tree": {
        "sha": "fc8efdb18dc5e45ce637ddd41c0959fc3de2513c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fc8efdb18dc5e45ce637ddd41c0959fc3de2513c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a9db3dada0119c183d16627805e90c4dbca05c6a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9db3dada0119c183d16627805e90c4dbca05c6a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a9db3dada0119c183d16627805e90c4dbca05c6a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9db3dada0119c183d16627805e90c4dbca05c6a/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "350395d1b5caf09d71866eb8de0475db65da6704",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/350395d1b5caf09d71866eb8de0475db65da6704",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/350395d1b5caf09d71866eb8de0475db65da6704"
      }
    ],
    "stats": {
      "total": 57,
      "additions": 33,
      "deletions": 24
    },
    "files": [
      {
        "sha": "52546d78e5da9c5c14ba9a68280d9ae4756c4c20",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 33,
        "deletions": 24,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a9db3dada0119c183d16627805e90c4dbca05c6a/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a9db3dada0119c183d16627805e90c4dbca05c6a/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=a9db3dada0119c183d16627805e90c4dbca05c6a",
        "patch": "@@ -2734,34 +2734,43 @@ bool CChainState::ActivateBestChain(CValidationState &state, const CChainParams&\n         bool fInitialDownload;\n         {\n             LOCK(cs_main);\n-            ConnectTrace connectTrace(mempool); // Destructed before cs_main is unlocked\n-\n-            CBlockIndex *pindexOldTip = chainActive.Tip();\n-            if (pindexMostWork == nullptr) {\n-                pindexMostWork = FindMostWorkChain();\n-            }\n+            arith_uint256 starting_work = chainActive.Tip() ? chainActive.Tip()->nChainWork : arith_uint256(0);\n+            bool blocks_connected = false;\n+            do {\n+                // We absolutely may not unlock cs_main until we've made forward progress\n+                // (with the exception of shutdown due to hardware issues, low disk space, etc).\n+                ConnectTrace connectTrace(mempool); // Destructed before cs_main is unlocked\n+\n+                CBlockIndex *pindexOldTip = chainActive.Tip();\n+                if (pindexMostWork == nullptr) {\n+                    pindexMostWork = FindMostWorkChain();\n+                }\n \n-            // Whether we have anything to do at all.\n-            if (pindexMostWork == nullptr || pindexMostWork == chainActive.Tip())\n-                return true;\n+                // Whether we have anything to do at all.\n+                if (pindexMostWork == nullptr || pindexMostWork == chainActive.Tip()) {\n+                    break;\n+                }\n \n-            bool fInvalidFound = false;\n-            std::shared_ptr<const CBlock> nullBlockPtr;\n-            if (!ActivateBestChainStep(state, chainparams, pindexMostWork, pblock && pblock->GetHash() == pindexMostWork->GetBlockHash() ? pblock : nullBlockPtr, fInvalidFound, connectTrace))\n-                return false;\n+                bool fInvalidFound = false;\n+                std::shared_ptr<const CBlock> nullBlockPtr;\n+                if (!ActivateBestChainStep(state, chainparams, pindexMostWork, pblock && pblock->GetHash() == pindexMostWork->GetBlockHash() ? pblock : nullBlockPtr, fInvalidFound, connectTrace))\n+                    return false;\n+                blocks_connected = true;\n \n-            if (fInvalidFound) {\n-                // Wipe cache, we may need another branch now.\n-                pindexMostWork = nullptr;\n-            }\n-            pindexNewTip = chainActive.Tip();\n-            pindexFork = chainActive.FindFork(pindexOldTip);\n-            fInitialDownload = IsInitialBlockDownload();\n+                if (fInvalidFound) {\n+                    // Wipe cache, we may need another branch now.\n+                    pindexMostWork = nullptr;\n+                }\n+                pindexNewTip = chainActive.Tip();\n+                pindexFork = chainActive.FindFork(pindexOldTip);\n+                fInitialDownload = IsInitialBlockDownload();\n \n-            for (const PerBlockConnectTrace& trace : connectTrace.GetBlocksConnected()) {\n-                assert(trace.pblock && trace.pindex);\n-                GetMainSignals().BlockConnected(trace.pblock, trace.pindex, trace.conflictedTxs);\n-            }\n+                for (const PerBlockConnectTrace& trace : connectTrace.GetBlocksConnected()) {\n+                    assert(trace.pblock && trace.pindex);\n+                    GetMainSignals().BlockConnected(trace.pblock, trace.pindex, trace.conflictedTxs);\n+                }\n+            } while (!chainActive.Tip() || chainActive.Tip()->nChainWork < starting_work);\n+            if (!blocks_connected) return true; // no work done, no notifications to fire\n         }\n         // When we reach this point, we switched to a new tip (stored in pindexNewTip).\n "
      }
    ]
  },
  {
    "sha": "8525f50c369e737098f785c6867d89f392b77f95",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4NTI1ZjUwYzM2OWU3MzcwOThmNzg1YzY4NjdkODlmMzkyYjc3Zjk1",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-09T16:34:42Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-01-10T21:59:27Z"
      },
      "message": "Stop using pindexBestHeader outside of validation.cpp\n\npindexBestHeader never considers the invalidity of a chain, only\nthe validity of the header chain. Using it for sync estimation and\nGETHEADERS etc requests in net makes no sense. Instead, use the\nnew setBlockIndexHeaderCandidates to find the best candidate tip.",
      "tree": {
        "sha": "416f3d538a04c7baca53e709faec0907dc085253",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/416f3d538a04c7baca53e709faec0907dc085253"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8525f50c369e737098f785c6867d89f392b77f95",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8525f50c369e737098f785c6867d89f392b77f95",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8525f50c369e737098f785c6867d89f392b77f95",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8525f50c369e737098f785c6867d89f392b77f95/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a9db3dada0119c183d16627805e90c4dbca05c6a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a9db3dada0119c183d16627805e90c4dbca05c6a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a9db3dada0119c183d16627805e90c4dbca05c6a"
      }
    ],
    "stats": {
      "total": 89,
      "additions": 53,
      "deletions": 36
    },
    "files": [
      {
        "sha": "6ea5f4aefe63934c8f36548badd024fdb68b41b9",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 16,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8525f50c369e737098f785c6867d89f392b77f95/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8525f50c369e737098f785c6867d89f392b77f95/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=8525f50c369e737098f785c6867d89f392b77f95",
        "patch": "@@ -789,9 +789,10 @@ static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Para\n {\n     AssertLockHeld(cs_main);\n     if (chainActive.Contains(pindex)) return true;\n-    return pindex->IsValid(BLOCK_VALID_SCRIPTS) && (pindexBestHeader != nullptr) &&\n-        (pindexBestHeader->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&\n-        (GetBlockProofEquivalentTime(*pindexBestHeader, *pindex, *pindexBestHeader, consensusParams) < STALE_RELAY_AGE_LIMIT);\n+    const CBlockIndex* best_header = GetBestHeader();\n+    return pindex->IsValid(BLOCK_VALID_SCRIPTS) &&\n+        (best_header->GetBlockTime() - pindex->GetBlockTime() < STALE_RELAY_AGE_LIMIT) &&\n+        (GetBlockProofEquivalentTime(*best_header, *pindex, *best_header, consensusParams) < STALE_RELAY_AGE_LIMIT);\n }\n \n PeerLogicValidation::PeerLogicValidation(CConnman* connmanIn, CScheduler &scheduler) : connman(connmanIn), m_stale_tip_check_time(0) {\n@@ -1084,7 +1085,7 @@ void static ProcessGetBlockData(CNode* pfrom, const Consensus::Params& consensus\n     const CNetMsgMaker msgMaker(pfrom->GetSendVersion());\n     // disconnect node in case we have reached the outbound limit for serving historical blocks\n     // never disconnect whitelisted nodes\n-    if (send && connman->OutboundTargetReached(true) && ( ((pindexBestHeader != nullptr) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > HISTORICAL_BLOCK_AGE)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n+    if (send && connman->OutboundTargetReached(true) && ( (GetBestHeader()->GetBlockTime() - mi->second->GetBlockTime() > HISTORICAL_BLOCK_AGE) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n     {\n         LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n \n@@ -1298,11 +1299,12 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         //   nUnconnectingHeaders gets reset back to 0.\n         if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n             nodestate->nUnconnectingHeaders++;\n-            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n+            const CBlockIndex* best_header = GetBestHeader();\n+            connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(best_header), uint256()));\n             LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n-                    pindexBestHeader->nHeight,\n+                    best_header->nHeight,\n                     pfrom->GetId(), nodestate->nUnconnectingHeaders);\n             // Set hashLastUnknownBlock for this peer, so that if we\n             // eventually get the headers - even from a different peer -\n@@ -1893,8 +1895,9 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     // fell back to inv we probably have a reorg which we should get the headers for first,\n                     // we now only provide a getheaders response here. When we receive the headers, we will\n                     // then ask for the blocks we need.\n-                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash));\n-                    LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->GetId());\n+                    const CBlockIndex* best_header = GetBestHeader();\n+                    connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(best_header), inv.hash));\n+                    LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", best_header->nHeight, inv.hash.ToString(), pfrom->GetId());\n                 }\n             }\n             else\n@@ -2308,7 +2311,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (mapBlockIndex.find(cmpctblock.header.hashPrevBlock) == mapBlockIndex.end()) {\n             // Doesn't connect (or is genesis), instead of DoSing in AcceptBlockHeader, request deeper headers\n             if (!IsInitialBlockDownload())\n-                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n+                connman->PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(GetBestHeader()), uint256()));\n             return true;\n         }\n \n@@ -3240,22 +3243,22 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n         }\n \n         // Start block sync\n-        if (pindexBestHeader == nullptr)\n-            pindexBestHeader = chainActive.Tip();\n+        const CBlockIndex* best_header = GetBestHeader();\n+        assert(best_header != nullptr);\n         bool fFetch = state.fPreferredDownload || (nPreferredDownload == 0 && !pto->fClient && !pto->fOneShot); // Download if this is a nice peer, or we have no nice peers and this one might do.\n         if (!state.fSyncStarted && !pto->fClient && !fImporting && !fReindex) {\n             // Only actively request headers from a single peer, unless we're close to today.\n-            if ((nSyncStarted == 0 && fFetch) || pindexBestHeader->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n+            if ((nSyncStarted == 0 && fFetch) || best_header->GetBlockTime() > GetAdjustedTime() - 24 * 60 * 60) {\n                 state.fSyncStarted = true;\n-                state.nHeadersSyncTimeout = GetTimeMicros() + HEADERS_DOWNLOAD_TIMEOUT_BASE + HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER * (GetAdjustedTime() - pindexBestHeader->GetBlockTime())/(consensusParams.nPowTargetSpacing);\n+                state.nHeadersSyncTimeout = GetTimeMicros() + HEADERS_DOWNLOAD_TIMEOUT_BASE + HEADERS_DOWNLOAD_TIMEOUT_PER_HEADER * (GetAdjustedTime() - best_header->GetBlockTime())/(consensusParams.nPowTargetSpacing);\n                 nSyncStarted++;\n-                const CBlockIndex *pindexStart = pindexBestHeader;\n+                const CBlockIndex *pindexStart = best_header;\n                 /* If possible, start at the block preceding the currently\n                    best known header.  This ensures that we always get a\n                    non-empty list of headers back as long as the peer\n                    is up-to-date.  With a non-empty response, we can initialise\n                    the peer's known best block.  This wouldn't be possible\n-                   if we requested starting at pindexBestHeader and\n+                   if we requested starting at best_header and\n                    got back an empty response.  */\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n@@ -3574,7 +3577,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto, std::atomic<bool>& interruptM\n         // Check for headers sync timeouts\n         if (state.fSyncStarted && state.nHeadersSyncTimeout < std::numeric_limits<int64_t>::max()) {\n             // Detect whether this is a stalling initial-headers-sync peer\n-            if (pindexBestHeader->GetBlockTime() <= GetAdjustedTime() - 24*60*60) {\n+            if (best_header->GetBlockTime() <= GetAdjustedTime() - 24*60*60) {\n                 if (nNow > state.nHeadersSyncTimeout && nSyncStarted == 1 && (nPreferredDownload - state.fPreferredDownload >= 1)) {\n                     // Disconnect a (non-whitelisted) peer if it is our only sync peer,\n                     // and we have others we could be using instead."
      },
      {
        "sha": "0ea3f0ed556e2d98dee1b195215cdd686dfdeb48",
        "filename": "src/qt/clientmodel.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 10,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8525f50c369e737098f785c6867d89f392b77f95/src/qt/clientmodel.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8525f50c369e737098f785c6867d89f392b77f95/src/qt/clientmodel.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/clientmodel.cpp?ref=8525f50c369e737098f785c6867d89f392b77f95",
        "patch": "@@ -78,12 +78,10 @@ int ClientModel::getNumBlocks() const\n int ClientModel::getHeaderTipHeight() const\n {\n     if (cachedBestHeaderHeight == -1) {\n-        // make sure we initially populate the cache via a cs_main lock\n-        // otherwise we need to wait for a tip update\n-        LOCK(cs_main);\n-        if (pindexBestHeader) {\n-            cachedBestHeaderHeight = pindexBestHeader->nHeight;\n-            cachedBestHeaderTime = pindexBestHeader->GetBlockTime();\n+        const CBlockIndex* best_header = GetBestHeader();\n+        if (best_header) {\n+            cachedBestHeaderHeight = best_header->nHeight;\n+            cachedBestHeaderTime = best_header->GetBlockTime();\n         }\n     }\n     return cachedBestHeaderHeight;\n@@ -92,10 +90,10 @@ int ClientModel::getHeaderTipHeight() const\n int64_t ClientModel::getHeaderTipTime() const\n {\n     if (cachedBestHeaderTime == -1) {\n-        LOCK(cs_main);\n-        if (pindexBestHeader) {\n-            cachedBestHeaderHeight = pindexBestHeader->nHeight;\n-            cachedBestHeaderTime = pindexBestHeader->GetBlockTime();\n+        const CBlockIndex* best_header = GetBestHeader();\n+        if (best_header) {\n+            cachedBestHeaderHeight = best_header->nHeight;\n+            cachedBestHeaderTime = best_header->GetBlockTime();\n         }\n     }\n     return cachedBestHeaderTime;"
      },
      {
        "sha": "758e91b36ba1e41eb5a41e95e6e77c39c6cf9390",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8525f50c369e737098f785c6867d89f392b77f95/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8525f50c369e737098f785c6867d89f392b77f95/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=8525f50c369e737098f785c6867d89f392b77f95",
        "patch": "@@ -1188,7 +1188,7 @@ UniValue getblockchaininfo(const JSONRPCRequest& request)\n     UniValue obj(UniValue::VOBJ);\n     obj.push_back(Pair(\"chain\",                 Params().NetworkIDString()));\n     obj.push_back(Pair(\"blocks\",                (int)chainActive.Height()));\n-    obj.push_back(Pair(\"headers\",               pindexBestHeader ? pindexBestHeader->nHeight : -1));\n+    obj.push_back(Pair(\"headers\",               GetBestHeader()->nHeight));\n     obj.push_back(Pair(\"bestblockhash\",         chainActive.Tip()->GetBlockHash().GetHex()));\n     obj.push_back(Pair(\"difficulty\",            (double)GetDifficulty()));\n     obj.push_back(Pair(\"mediantime\",            (int64_t)chainActive.Tip()->GetMedianTimePast()));"
      },
      {
        "sha": "a4a02b0033b005da24450b7224ddea4e1b987fcb",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 7,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8525f50c369e737098f785c6867d89f392b77f95/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8525f50c369e737098f785c6867d89f392b77f95/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=8525f50c369e737098f785c6867d89f392b77f95",
        "patch": "@@ -137,6 +137,8 @@ class CChainState {\n      */\n     std::set<CBlockIndex*, CBlockIndexWorkComparator> setBlockIndexHeaderCandidates;\n \n+    CBlockIndex *pindexBestHeader = nullptr;\n+\n     /**\n      * Every received block is assigned a unique and increasing identifier, so we\n      * know which one to give priority in case of a fork.\n@@ -203,6 +205,7 @@ class CChainState {\n \n     void UnloadBlockIndex();\n \n+    const CBlockIndex* GetBestHeader();\n private:\n     bool ActivateBestChainStep(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexMostWork, const std::shared_ptr<const CBlock>& pblock, bool& fInvalidFound, ConnectTrace& connectTrace);\n     bool ConnectTip(CValidationState& state, const CChainParams& chainparams, CBlockIndex* pindexNew, const std::shared_ptr<const CBlock>& pblock, ConnectTrace& connectTrace, DisconnectedBlockTransactions &disconnectpool);\n@@ -228,7 +231,6 @@ CCriticalSection cs_main;\n \n BlockMap& mapBlockIndex = g_chainstate.mapBlockIndex;\n CChain& chainActive = g_chainstate.chainActive;\n-CBlockIndex *pindexBestHeader = nullptr;\n CWaitableCriticalSection csBestBlock;\n CConditionVariable cvBlockChange;\n int nScriptCheckThreads = 0;\n@@ -474,7 +476,7 @@ static bool IsCurrentForFeeEstimation()\n         return false;\n     if (chainActive.Tip()->GetBlockTime() < (GetTime() - MAX_FEE_ESTIMATION_TIP_AGE))\n         return false;\n-    if (chainActive.Height() < pindexBestHeader->nHeight - 1)\n+    if (chainActive.Height() < GetBestHeader()->nHeight - 1)\n         return false;\n     return true;\n }\n@@ -1193,7 +1195,7 @@ bool IsInitialBlockDownload()\n     return false;\n }\n \n-CBlockIndex *pindexBestForkTip = nullptr, *pindexBestForkBase = nullptr;\n+static CBlockIndex *pindexBestForkTip = nullptr, *pindexBestForkBase = nullptr;\n \n static void AlertNotify(const std::string& strMessage)\n {\n@@ -1355,6 +1357,18 @@ void CChainState::MaybeAddNewHeaderCandidate(CBlockIndex* pindex, bool chain_ord\n     setBlockIndexHeaderCandidates.insert(pindex);\n }\n \n+const CBlockIndex* CChainState::GetBestHeader() {\n+    LOCK(cs_main);\n+    auto it = setBlockIndexHeaderCandidates.rbegin();\n+    if (it == setBlockIndexHeaderCandidates.rend())\n+        return nullptr;\n+    return *it;\n+}\n+\n+const CBlockIndex* GetBestHeader() {\n+    return g_chainstate.GetBestHeader();\n+}\n+\n // Helper for PruneInvalidBlockIndexCandidates\n static void PruneInvalidIndexCandidatesInSet(CBlockIndex* pindexInvalid, std::set<CBlockIndex*, CBlockIndexWorkComparator>& set_candidates) {\n     // Iterate set_candidates downwards, deleting parents of pindexInvalid,\n@@ -1969,6 +1983,8 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n                 pindexBestHeader->GetAncestor(pindex->nHeight) == pindex &&\n                 pindexBestHeader->nChainWork >= nMinimumChainWork) {\n                 // This block is a member of the assumed verified chain and an ancestor of the best header.\n+                // Note that we use pindexBestHeader here, not GetBestHeader(), ignoring potential\n+                // chain-invalidity of the best header.\n                 // The equivalent time check discourages hash power from extorting the network via DOS attack\n                 //  into accepting an invalid block through telling users they must manually set assumevalid.\n                 //  Requiring a software change or burying the invalid block, regardless of the setting, makes\n@@ -2684,11 +2700,11 @@ bool CChainState::ActivateBestChainStep(CValidationState& state, const CChainPar\n static void NotifyHeaderTip() {\n     bool fNotify = false;\n     bool fInitialBlockDownload = false;\n-    static CBlockIndex* pindexHeaderOld = nullptr;\n-    CBlockIndex* pindexHeader = nullptr;\n+    static const CBlockIndex* pindexHeaderOld = nullptr;\n+    const CBlockIndex* pindexHeader = nullptr;\n     {\n         LOCK(cs_main);\n-        pindexHeader = pindexBestHeader;\n+        pindexHeader = GetBestHeader();\n \n         if (pindexHeader != pindexHeaderOld) {\n             fNotify = true;\n@@ -4316,6 +4332,7 @@ bool RewindBlockIndex(const CChainParams& params) {\n \n void CChainState::UnloadBlockIndex() {\n     nBlockSequenceId = 1;\n+    pindexBestHeader = nullptr;\n     g_failed_blocks.clear();\n     setBlockIndexCandidates.clear();\n     setBlockIndexHeaderCandidates.clear();\n@@ -4329,7 +4346,6 @@ void UnloadBlockIndex()\n     LOCK(cs_main);\n     chainActive.SetTip(nullptr);\n     pindexBestInvalid = nullptr;\n-    pindexBestHeader = nullptr;\n     mempool.clear();\n     mapBlocksUnlinked.clear();\n     vinfoBlockFile.clear();"
      },
      {
        "sha": "03a92dcde46ad0aa955e543104d104a5dd5b51ab",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8525f50c369e737098f785c6867d89f392b77f95/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8525f50c369e737098f785c6867d89f392b77f95/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=8525f50c369e737098f785c6867d89f392b77f95",
        "patch": "@@ -188,8 +188,8 @@ extern uint256 hashAssumeValid;\n /** Minimum work we will assume exists on some valid chain. */\n extern arith_uint256 nMinimumChainWork;\n \n-/** Best header we've seen so far (used for getheaders queries' starting points). */\n-extern CBlockIndex *pindexBestHeader;\n+/** Get the best (potentially-)valid header we've seen so far (used for getheaders queries' starting points). */\n+const CBlockIndex* GetBestHeader();\n \n /** Minimum disk space required - used in CheckDiskSpace() */\n static const uint64_t nMinDiskSpace = 52428800;"
      }
    ]
  },
  {
    "sha": "ed5b2770b019d66e4ce841a3d6b804e8d7d763df",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplZDViMjc3MGIwMTlkNjZlNGNlODQxYTNkNmI4MDRlOGQ3ZDc2M2Rm",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-10-09T19:18:53Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-01-10T22:52:59Z"
      },
      "message": "Replace ProcessNewBlock's fRequested with candidate header check\n\nInstead of allowing net_processing to inform AcceptBlock as to\nwhether a block is interesting enough to commit to disk, use the\nnew setBlockIndexHeadersCandidates to determine if they lead\ntowards a chain with at least the same (or more) work as our\ncurrent tip. This further decouples the maze in net_processing from\nour consensus anti-DoS logic.",
      "tree": {
        "sha": "ba3407faddf44391d019be390c6c375e9e0c2896",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ba3407faddf44391d019be390c6c375e9e0c2896"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ed5b2770b019d66e4ce841a3d6b804e8d7d763df",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ed5b2770b019d66e4ce841a3d6b804e8d7d763df",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ed5b2770b019d66e4ce841a3d6b804e8d7d763df",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ed5b2770b019d66e4ce841a3d6b804e8d7d763df/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8525f50c369e737098f785c6867d89f392b77f95",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8525f50c369e737098f785c6867d89f392b77f95",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8525f50c369e737098f785c6867d89f392b77f95"
      }
    ],
    "stats": {
      "total": 136,
      "additions": 49,
      "deletions": 87
    },
    "files": [
      {
        "sha": "7a3cc67b6be5e7de55d4b31696b4e02cc228240e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 20,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed5b2770b019d66e4ce841a3d6b804e8d7d763df/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed5b2770b019d66e4ce841a3d6b804e8d7d763df/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=ed5b2770b019d66e4ce841a3d6b804e8d7d763df",
        "patch": "@@ -2493,16 +2493,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 mapBlockSource.emplace(pblock->GetHash(), std::make_pair(pfrom->GetId(), false));\n             }\n             bool fNewBlock = false;\n-            // Setting fForceProcessing to true means that we bypass some of\n-            // our anti-DoS protections in AcceptBlock, which filters\n-            // unrequested blocks that might be trying to waste our resources\n-            // (eg disk space). Because we only try to reconstruct blocks when\n-            // we're close to caught up (via the CanDirectFetch() requirement\n-            // above, combined with the behavior of not requesting blocks until\n-            // we have a chain with at least nMinimumChainWork), and we ignore\n-            // compact blocks with less work than our tip, it is safe to treat\n-            // reconstructed compact blocks as having been requested.\n-            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n+            ProcessNewBlock(chainparams, pblock, &fNewBlock);\n             if (fNewBlock) {\n                 pfrom->nLastBlockTime = GetTime();\n             } else {\n@@ -2582,11 +2573,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             bool fNewBlock = false;\n             // Since we requested this block (it was in mapBlocksInFlight), force it to be processed,\n             // even if it would not be a candidate for new tip (missing previous block, chain not long enough, etc)\n-            // This bypasses some anti-DoS logic in AcceptBlock (eg to prevent\n-            // disk-space attacks), but this should be safe due to the\n-            // protections in the compact block handler -- see related comment\n-            // in compact block optimistic reconstruction handling.\n-            ProcessNewBlock(chainparams, pblock, /*fForceProcessing=*/true, &fNewBlock);\n+            ProcessNewBlock(chainparams, pblock, &fNewBlock);\n             if (fNewBlock) {\n                 pfrom->nLastBlockTime = GetTime();\n             } else {\n@@ -2629,19 +2616,16 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->GetId());\n \n-        bool forceProcessing = false;\n         const uint256 hash(pblock->GetHash());\n         {\n             LOCK(cs_main);\n-            // Also always process if we requested the block explicitly, as we may\n-            // need it even though it is not a candidate for a new best tip.\n-            forceProcessing |= MarkBlockAsReceived(hash);\n+            MarkBlockAsReceived(hash);\n             // mapBlockSource is only used for sending reject messages and DoS scores,\n             // so the race between here and cs_main in ProcessNewBlock is fine.\n             mapBlockSource.emplace(hash, std::make_pair(pfrom->GetId(), true));\n         }\n         bool fNewBlock = false;\n-        ProcessNewBlock(chainparams, pblock, forceProcessing, &fNewBlock);\n+        ProcessNewBlock(chainparams, pblock, &fNewBlock);\n         if (fNewBlock) {\n             pfrom->nLastBlockTime = GetTime();\n         } else {"
      },
      {
        "sha": "e0beaa5810ad5e741cbd921e5e65723370f6c3a8",
        "filename": "src/rpc/mining.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed5b2770b019d66e4ce841a3d6b804e8d7d763df/src/rpc/mining.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed5b2770b019d66e4ce841a3d6b804e8d7d763df/src/rpc/mining.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/mining.cpp?ref=ed5b2770b019d66e4ce841a3d6b804e8d7d763df",
        "patch": "@@ -137,7 +137,7 @@ UniValue generateBlocks(std::shared_ptr<CReserveScript> coinbaseScript, int nGen\n             continue;\n         }\n         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n-        if (!ProcessNewBlock(Params(), shared_pblock, true, nullptr))\n+        if (!ProcessNewBlock(Params(), shared_pblock, nullptr))\n             throw JSONRPCError(RPC_INTERNAL_ERROR, \"ProcessNewBlock, block not accepted\");\n         ++nHeight;\n         blockHashes.push_back(pblock->GetHash().GetHex());\n@@ -756,7 +756,7 @@ UniValue submitblock(const JSONRPCRequest& request)\n \n     submitblock_StateCatcher sc(block.GetHash());\n     RegisterValidationInterface(&sc);\n-    bool fAccepted = ProcessNewBlock(Params(), blockptr, true, nullptr);\n+    bool fAccepted = ProcessNewBlock(Params(), blockptr, nullptr);\n     UnregisterValidationInterface(&sc);\n     if (fBlockPresent) {\n         if (fAccepted && !sc.found) {"
      },
      {
        "sha": "928a9e9edee3f18c7a7e0b974f8f1af592b31ae5",
        "filename": "src/test/miner_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed5b2770b019d66e4ce841a3d6b804e8d7d763df/src/test/miner_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed5b2770b019d66e4ce841a3d6b804e8d7d763df/src/test/miner_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/miner_tests.cpp?ref=ed5b2770b019d66e4ce841a3d6b804e8d7d763df",
        "patch": "@@ -248,7 +248,7 @@ BOOST_AUTO_TEST_CASE(CreateNewBlock_validity)\n             pblock->nNonce = blockinfo[i].nonce;\n         }\n         std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(*pblock);\n-        BOOST_CHECK(ProcessNewBlock(chainparams, shared_pblock, true, nullptr));\n+        BOOST_CHECK(ProcessNewBlock(chainparams, shared_pblock, nullptr));\n         pblock->hashPrevBlock = pblock->GetHash();\n     }\n "
      },
      {
        "sha": "2d30456bc0965df139a86d5ea79c20e3facb4f31",
        "filename": "src/test/test_bitcoin.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed5b2770b019d66e4ce841a3d6b804e8d7d763df/src/test/test_bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed5b2770b019d66e4ce841a3d6b804e8d7d763df/src/test/test_bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin.cpp?ref=ed5b2770b019d66e4ce841a3d6b804e8d7d763df",
        "patch": "@@ -151,7 +151,7 @@ TestChain100Setup::CreateAndProcessBlock(const std::vector<CMutableTransaction>&\n     while (!CheckProofOfWork(block.GetHash(), block.nBits, chainparams.GetConsensus())) ++block.nNonce;\n \n     std::shared_ptr<const CBlock> shared_pblock = std::make_shared<const CBlock>(block);\n-    ProcessNewBlock(chainparams, shared_pblock, true, nullptr);\n+    ProcessNewBlock(chainparams, shared_pblock, nullptr);\n \n     CBlock result = block;\n     return result;"
      },
      {
        "sha": "dd0d11918244901f690a0de91d9b5cff5a730e13",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 21,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed5b2770b019d66e4ce841a3d6b804e8d7d763df/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed5b2770b019d66e4ce841a3d6b804e8d7d763df/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=ed5b2770b019d66e4ce841a3d6b804e8d7d763df",
        "patch": "@@ -182,7 +182,7 @@ class CChainState {\n     bool ActivateBestChain(CValidationState &state, const CChainParams& chainparams, std::shared_ptr<const CBlock> pblock);\n \n     bool AcceptBlockHeader(const CBlockHeader& block, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex);\n-    bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const CDiskBlockPos* dbp, bool* fNewBlock);\n+    bool AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, const CDiskBlockPos* dbp, bool* fNewBlock);\n \n     // Block (dis)connection on a given view:\n     DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex* pindex, CCoinsViewCache& view);\n@@ -3532,7 +3532,7 @@ static CDiskBlockPos SaveBlockToDisk(const CBlock& block, int nHeight, const CCh\n }\n \n /** Store block on disk. If dbp is non-nullptr, the file is known to already reside on disk */\n-bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, bool fRequested, const CDiskBlockPos* dbp, bool* fNewBlock)\n+bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CValidationState& state, const CChainParams& chainparams, CBlockIndex** ppindex, const CDiskBlockPos* dbp, bool* fNewBlock)\n {\n     const CBlock& block = *pblock;\n \n@@ -3557,25 +3557,34 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n     // not process unrequested blocks.\n     bool fTooFarAhead = (pindex->nHeight > int(chainActive.Height() + MIN_BLOCKS_TO_KEEP));\n \n-    // TODO: Decouple this function from the block download logic by removing fRequested\n-    // This requires some new chain data structure to efficiently look up if a\n-    // block is in a chain leading to a candidate for best tip, despite not\n-    // being such a candidate itself.\n-\n     // TODO: deal better with return value and error conditions for duplicate\n     // and unrequested blocks.\n     if (fAlreadyHave) return true;\n-    if (!fRequested) {  // If we didn't ask for it:\n-        if (pindex->nTx != 0) return true;    // This is a previously-processed block that was pruned\n-        if (!fHasMoreOrSameWork) return true; // Don't process less-work chains\n-        if (fTooFarAhead) return true;        // Block height is too high\n-\n-        // Protect against DoS attacks from low-work chains.\n-        // If our tip is behind, a peer could try to send us\n-        // low-work blocks on a fake chain that we would never\n-        // request; don't process these.\n-        if (pindex->nChainWork < nMinimumChainWork) return true;\n+    if (!pindex->IsValid(BLOCK_VALID_TREE)) return true; // Parent block somewhere is invalid\n+    if (pindex->nTx != 0) return true;                   // This is a previously-processed block that was pruned\n+    if (fTooFarAhead) return true;                       // Block height is too high\n+\n+    bool parent_of_header_candidate = false;\n+    bool parent_of_min_chainwork_header_candidate = false;\n+    for (auto it = setBlockIndexHeaderCandidates.rbegin(); it != setBlockIndexHeaderCandidates.rend(); it++) {\n+        if ((*it)->GetAncestor(pindex->nHeight) == pindex) {\n+            parent_of_header_candidate = true;\n+            // Protect against DoS attacks from low-work chains.\n+            // If our tip is behind, a peer could try to send us\n+            // low-work blocks on a fake chain that we would never\n+            // request; don't process these.\n+            if ((*it)->nChainWork >= nMinimumChainWork) {\n+                parent_of_min_chainwork_header_candidate = true;\n+                break;\n+            }\n+        }\n+    }\n+    if (!fHasMoreOrSameWork && !parent_of_header_candidate) return true; // We dont think this block leads somewhere interesting\n+    if (!parent_of_min_chainwork_header_candidate && pindex->nChainWork < nMinimumChainWork) {\n+        // Neither this new block, nor any descendants we have, meet our minimum chain work.\n+        return true;\n     }\n+\n     if (fNewBlock) *fNewBlock = true;\n \n     if (!CheckBlock(block, state, chainparams.GetConsensus()) ||\n@@ -3612,7 +3621,7 @@ bool CChainState::AcceptBlock(const std::shared_ptr<const CBlock>& pblock, CVali\n     return true;\n }\n \n-bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing, bool *fNewBlock)\n+bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool *fNewBlock)\n {\n     AssertLockNotHeld(cs_main);\n \n@@ -3628,7 +3637,7 @@ bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<cons\n \n         if (ret) {\n             // Store to disk\n-            ret = g_chainstate.AcceptBlock(pblock, state, chainparams, &pindex, fForceProcessing, nullptr, fNewBlock);\n+            ret = g_chainstate.AcceptBlock(pblock, state, chainparams, &pindex, nullptr, fNewBlock);\n         }\n         if (!ret) {\n             GetMainSignals().BlockChecked(*pblock, state);\n@@ -4483,7 +4492,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                 if (mapBlockIndex.count(hash) == 0 || (mapBlockIndex[hash]->nStatus & BLOCK_HAVE_DATA) == 0) {\n                     LOCK(cs_main);\n                     CValidationState state;\n-                    if (g_chainstate.AcceptBlock(pblock, state, chainparams, nullptr, true, dbp, nullptr))\n+                    if (g_chainstate.AcceptBlock(pblock, state, chainparams, nullptr, dbp, nullptr))\n                         nLoaded++;\n                     if (state.IsError())\n                         break;\n@@ -4517,7 +4526,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                                     head.ToString());\n                             LOCK(cs_main);\n                             CValidationState dummy;\n-                            if (g_chainstate.AcceptBlock(pblockrecursive, dummy, chainparams, nullptr, true, &it->second, nullptr))\n+                            if (g_chainstate.AcceptBlock(pblockrecursive, dummy, chainparams, nullptr, &it->second, nullptr))\n                             {\n                                 nLoaded++;\n                                 queue.push_back(pblockrecursive->GetHash());"
      },
      {
        "sha": "7d0b8ca7b91d23fb9c12808eafe1764df6c354f6",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed5b2770b019d66e4ce841a3d6b804e8d7d763df/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed5b2770b019d66e4ce841a3d6b804e8d7d763df/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=ed5b2770b019d66e4ce841a3d6b804e8d7d763df",
        "patch": "@@ -234,11 +234,10 @@ static const uint64_t MIN_DISK_SPACE_FOR_BLOCK_FILES = 550 * 1024 * 1024;\n  * Call without cs_main held.\n  *\n  * @param[in]   pblock  The block we want to process.\n- * @param[in]   fForceProcessing Process this block even if unrequested; used for non-network block sources and whitelisted peers.\n  * @param[out]  fNewBlock A boolean which is set to indicate if the block was first received via this call\n  * @return True if state.IsValid()\n  */\n-bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool fForceProcessing, bool* fNewBlock);\n+bool ProcessNewBlock(const CChainParams& chainparams, const std::shared_ptr<const CBlock> pblock, bool* fNewBlock);\n \n /**\n  * Process incoming block headers."
      },
      {
        "sha": "b1641d12d49c367e38dd0a3c48d8716a3f84f151",
        "filename": "test/functional/p2p-acceptblock.py",
        "status": "modified",
        "additions": 10,
        "deletions": 40,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ed5b2770b019d66e4ce841a3d6b804e8d7d763df/test/functional/p2p-acceptblock.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ed5b2770b019d66e4ce841a3d6b804e8d7d763df/test/functional/p2p-acceptblock.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p-acceptblock.py?ref=ed5b2770b019d66e4ce841a3d6b804e8d7d763df",
        "patch": "@@ -32,22 +32,15 @@\n    Node0 should process all but the last block (too far ahead in height).\n \n 5. Send a duplicate of the block in #3 to Node0.\n-   Node0 should not process the block because it is unrequested, and stay on\n-   the shorter chain.\n+   Node0 should process the block even though it is unrequested, and reorg to\n+   the longer chain.\n \n-6. Send Node0 an inv for the height 3 block produced in #4 above.\n-   Node0 should figure out that Node0 has the missing height 2 block and send a\n-   getdata.\n-\n-7. Send Node0 the missing block again.\n-   Node0 should process and the tip should advance.\n-\n-8. Create a fork which is invalid at a height longer than the current chain\n+6. Create a fork which is invalid at a height longer than the current chain\n    (ie to which the node will try to reorg) but which has headers built on top\n    of the invalid block. Check that we get disconnected if we send more headers\n    on the chain the node now knows to be invalid.\n \n-9. Test Node1 is able to sync when connected to node0 (which should have sufficient\n+7. Test Node1 is able to sync when connected to node0 (which should have sufficient\n    work on its chain).\n \"\"\"\n \n@@ -107,8 +100,8 @@ def run_test(self):\n         for x in [test_node, min_work_node]:\n             x.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 2)\n-        assert_equal(self.nodes[1].getblockcount(), 1)\n-        self.log.info(\"First height 2 block accepted by node0; correctly rejected by node1\")\n+        assert_equal(self.nodes[1].getblockcount(), 0)\n+        self.log.info(\"First height 2 block accepted by node0; all blocks correctly rejected by node1\")\n \n         # 3. Send another block that builds on genesis.\n         block_h1f = create_block(int(\"0x\" + self.nodes[0].getblockhash(0), 0), create_coinbase(1), block_time)\n@@ -200,8 +193,8 @@ def run_test(self):\n         assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, all_blocks[-1].hash)\n \n         # 5. Test handling of unrequested block on the node that didn't process\n-        # Should still not be processed (even though it has a child that has more\n-        # work).\n+        # Should be processed as the node can figure out that it leads to a new\n+        # chain that it will want.\n \n         # The node should have requested the blocks at some point, so\n         # disconnect/reconnect first\n@@ -216,37 +209,14 @@ def run_test(self):\n \n         test_node.send_message(msg_block(block_h1f))\n \n-        test_node.sync_with_ping()\n-        assert_equal(self.nodes[0].getblockcount(), 2)\n-        self.log.info(\"Unrequested block that would complete more-work chain was ignored\")\n-\n-        # 6. Try to get node to request the missing block.\n-        # Poke the node with an inv for block at height 3 and see if that\n-        # triggers a getdata on block 2 (it should if block 2 is missing).\n-        with mininode_lock:\n-            # Clear state so we can check the getdata request\n-            test_node.last_message.pop(\"getdata\", None)\n-            test_node.send_message(msg_inv([CInv(2, block_h3.sha256)]))\n-\n-        test_node.sync_with_ping()\n-        with mininode_lock:\n-            getdata = test_node.last_message[\"getdata\"]\n-\n-        # Check that the getdata includes the right block\n-        assert_equal(getdata.inv[0].hash, block_h1f.sha256)\n-        self.log.info(\"Inv at tip triggered getdata for unprocessed block\")\n-\n-        # 7. Send the missing block for the third time (now it is requested)\n-        test_node.send_message(msg_block(block_h1f))\n-\n         test_node.sync_with_ping()\n         assert_equal(self.nodes[0].getblockcount(), 290)\n         self.nodes[0].getblock(all_blocks[286].hash)\n         assert_equal(self.nodes[0].getbestblockhash(), all_blocks[286].hash)\n         assert_raises_rpc_error(-1, \"Block not found on disk\", self.nodes[0].getblock, all_blocks[287].hash)\n         self.log.info(\"Successfully reorged to longer chain from non-whitelisted peer\")\n \n-        # 8. Create a chain which is invalid at a height longer than the\n+        # 6. Create a chain which is invalid at a height longer than the\n         # current chain, but which has more blocks on top of that\n         block_289f = create_block(all_blocks[284].sha256, create_coinbase(289), all_blocks[284].nTime+1)\n         block_289f.solve()\n@@ -314,7 +284,7 @@ def run_test(self):\n         test_node.send_message(headers_message)\n         test_node.wait_for_disconnect()\n \n-        # 9. Connect node1 to node0 and ensure it is able to sync\n+        # 7. Connect node1 to node0 and ensure it is able to sync\n         connect_nodes(self.nodes[0], 1)\n         sync_blocks([self.nodes[0], self.nodes[1]])\n         self.log.info(\"Successfully synced nodes 1 and 0\")"
      }
    ]
  }
]