[
  {
    "sha": "9424ab37dea7c3e85b86ddfe744b6aa212fcbded",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NDI0YWIzN2RlYTdjM2U4NWI4NmRkZmU3NDRiNmFhMjEyZmNiZGVk",
    "commit": {
      "author": {
        "name": "Jordan Lewis",
        "email": "jordanthelewis@gmail.com",
        "date": "2011-05-02T00:41:54Z"
      },
      "committer": {
        "name": "Jordan Lewis",
        "email": "jordanthelewis@gmail.com",
        "date": "2011-05-30T02:43:16Z"
      },
      "message": "Update RPC server to use asynchronous IO\n\nProperly does ASIO for both SSL and non-SSL cases if SSL is enabled, and\nalso if SSL is disabled.\n\nNext steps: attempt to non-block on the actual RPC call.\n            make the whole thing a thread pool",
      "tree": {
        "sha": "79e2128ba7f482df0d50306259b7e9fcc18e382d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/79e2128ba7f482df0d50306259b7e9fcc18e382d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9424ab37dea7c3e85b86ddfe744b6aa212fcbded",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9424ab37dea7c3e85b86ddfe744b6aa212fcbded",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9424ab37dea7c3e85b86ddfe744b6aa212fcbded",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9424ab37dea7c3e85b86ddfe744b6aa212fcbded/comments",
    "author": {
      "login": "jordanlewis",
      "id": 43821,
      "node_id": "MDQ6VXNlcjQzODIx",
      "avatar_url": "https://avatars.githubusercontent.com/u/43821?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jordanlewis",
      "html_url": "https://github.com/jordanlewis",
      "followers_url": "https://api.github.com/users/jordanlewis/followers",
      "following_url": "https://api.github.com/users/jordanlewis/following{/other_user}",
      "gists_url": "https://api.github.com/users/jordanlewis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jordanlewis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jordanlewis/subscriptions",
      "organizations_url": "https://api.github.com/users/jordanlewis/orgs",
      "repos_url": "https://api.github.com/users/jordanlewis/repos",
      "events_url": "https://api.github.com/users/jordanlewis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jordanlewis/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jordanlewis",
      "id": 43821,
      "node_id": "MDQ6VXNlcjQzODIx",
      "avatar_url": "https://avatars.githubusercontent.com/u/43821?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jordanlewis",
      "html_url": "https://github.com/jordanlewis",
      "followers_url": "https://api.github.com/users/jordanlewis/followers",
      "following_url": "https://api.github.com/users/jordanlewis/following{/other_user}",
      "gists_url": "https://api.github.com/users/jordanlewis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jordanlewis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jordanlewis/subscriptions",
      "organizations_url": "https://api.github.com/users/jordanlewis/orgs",
      "repos_url": "https://api.github.com/users/jordanlewis/repos",
      "events_url": "https://api.github.com/users/jordanlewis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jordanlewis/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "5fecb27c1ec6b583fa07028cd26c21dd191c125f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/5fecb27c1ec6b583fa07028cd26c21dd191c125f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/5fecb27c1ec6b583fa07028cd26c21dd191c125f"
      }
    ],
    "stats": {
      "total": 494,
      "additions": 391,
      "deletions": 103
    },
    "files": [
      {
        "sha": "ef767c7c5bfde112a7b21585eedc6ebf90a05e9c",
        "filename": "src/rpc.cpp",
        "status": "modified",
        "additions": 391,
        "deletions": 103,
        "changes": 494,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9424ab37dea7c3e85b86ddfe744b6aa212fcbded/src/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9424ab37dea7c3e85b86ddfe744b6aa212fcbded/src/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc.cpp?ref=9424ab37dea7c3e85b86ddfe744b6aa212fcbded",
        "patch": "@@ -8,6 +8,7 @@\n #include <boost/asio.hpp>\n #include <boost/iostreams/concepts.hpp>\n #include <boost/iostreams/stream.hpp>\n+#include <boost/enable_shared_from_this.hpp>\n #ifdef USE_SSL\n #include <boost/asio/ssl.hpp> \n typedef boost::asio::ssl::stream<boost::asio::ip::tcp::socket> SSLStream;\n@@ -1572,7 +1573,9 @@ int ReadHTTPHeader(std::basic_istream<char>& stream, map<string, string>& mapHea\n         string str;\n         std::getline(stream, str);\n         if (str.empty() || str == \"\\r\")\n+        {\n             break;\n+        }\n         string::size_type nColon = str.find(\":\");\n         if (nColon != string::npos)\n         {\n@@ -1583,7 +1586,9 @@ int ReadHTTPHeader(std::basic_istream<char>& stream, map<string, string>& mapHea\n             boost::trim(strValue);\n             mapHeadersRet[strHeader] = strValue;\n             if (strHeader == \"content-length\")\n+            {\n                 nLen = atoi(strValue.c_str());\n+            }\n         }\n     }\n     return nLen;\n@@ -1707,9 +1712,20 @@ void ErrorReply(std::ostream& stream, const Object& objError, const Value& id)\n     stream << HTTPReply(nStatus, strReply) << std::flush;\n }\n \n+string ErrorString(const Object& objError, const Value& id)\n+{\n+    // Send error reply from json-rpc error object\n+    int nStatus = 500;\n+    int code = find_value(objError, \"code\").get_int();\n+    if (code == -32600) nStatus = 400;\n+    else if (code == -32601) nStatus = 404;\n+    string strReply = JSONRPCReply(Value::null, objError, id);\n+    return HTTPReply(nStatus, strReply);\n+}\n+\n bool ClientAllowed(const string& strAddress)\n {\n-    if (strAddress == asio::ip::address_v4::loopback().to_string())\n+    if (strAddress == ip::address_v4::loopback().to_string())\n         return true;\n     const vector<string>& vAllow = mapMultiArgs[\"-rpcallowip\"];\n     BOOST_FOREACH(string strAllow, vAllow)\n@@ -1772,132 +1788,116 @@ class SSLIOStreamDevice : public iostreams::device<iostreams::bidirectional> {\n };\n #endif\n \n-void ThreadRPCServer(void* parg)\n-{\n-    IMPLEMENT_RANDOMIZE_STACK(ThreadRPCServer(parg));\n-    try\n-    {\n-        vnThreadsRunning[4]++;\n-        ThreadRPCServer2(parg);\n-        vnThreadsRunning[4]--;\n-    }\n-    catch (std::exception& e) {\n-        vnThreadsRunning[4]--;\n-        PrintException(&e, \"ThreadRPCServer()\");\n-    } catch (...) {\n-        vnThreadsRunning[4]--;\n-        PrintException(NULL, \"ThreadRPCServer()\");\n-    }\n-    printf(\"ThreadRPCServer exiting\\n\");\n-}\n \n-void ThreadRPCServer2(void* parg)\n+/* Generic server-side RPC connection. Instantiate one of its children depending\n+ * on whether the desired connection is SSL or non-SSL (Plain).\n+ *\n+ * Uses asynchronous IO.\n+ */\n+class RPCConnection\n {\n-    printf(\"ThreadRPCServer started\\n\");\n-\n-    if (mapArgs[\"-rpcuser\"] == \"\" && mapArgs[\"-rpcpassword\"] == \"\")\n+public:\n+    /* Read the status line of an HTTP request */\n+    virtual void do_read_status() = 0;\n+    /* Read the header of an HTTP request */\n+    virtual void do_read_header() = 0;\n+    /* Read the body of an HTTP request */\n+    virtual void do_read_body() = 0;\n+    /* Respond to an HTTP request with str */\n+    virtual void respond(std::string str) = 0;\n+\n+    /* Initiate the connection */\n+    virtual void start()\n     {\n-        string strWhatAmI = \"To use bitcoind\";\n-        if (mapArgs.count(\"-server\"))\n-            strWhatAmI = strprintf(_(\"To use the %s option\"), \"\\\"-server\\\"\");\n-        else if (mapArgs.count(\"-daemon\"))\n-            strWhatAmI = strprintf(_(\"To use the %s option\"), \"\\\"-daemon\\\"\");\n-        PrintConsole(\n-            _(\"Warning: %s, you must set rpcpassword=<password>\\nin the configuration file: %s\\n\"\n-              \"If the file does not exist, create it with owner-readable-only file permissions.\\n\"),\n-                strWhatAmI.c_str(),\n-                GetConfigFile().c_str());\n-        CreateThread(Shutdown, NULL);\n-        return;\n+        if (! ClientAllowed(peer.address().to_string()))\n+            return;\n+        do_read_status();\n     }\n+    /* Parse status line and continues reading */\n+    void handle_read_status(const boost::system::error_code& err, size_t nBytes)\n+    {\n+        printf(\"read_status err = %s\\n\", err.message().c_str());\n+        if (err) return;\n \n-    bool fUseSSL = GetBoolArg(\"-rpcssl\");\n-    asio::ip::address bindAddress = mapArgs.count(\"-rpcallowip\") ? asio::ip::address_v4::any() : asio::ip::address_v4::loopback();\n-\n-    asio::io_service io_service;\n-    ip::tcp::endpoint endpoint(bindAddress, GetArg(\"-rpcport\", 8332));\n-    ip::tcp::acceptor acceptor(io_service, endpoint);\n+        istream is(&streambuf);\n+        char * pszStatus = new char[nBytes + 1];\n+        is.read(pszStatus, nBytes);\n+        pszStatus[nBytes] = '\\0';\n \n-    acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));\n+        stringstream ss(pszStatus);\n+        int status = ReadHTTPStatus(ss);\n \n-#ifdef USE_SSL\n-    ssl::context context(io_service, ssl::context::sslv23);\n-    if (fUseSSL)\n-    {\n-        context.set_options(ssl::context::no_sslv2);\n-        filesystem::path certfile = GetArg(\"-rpcsslcertificatechainfile\", \"server.cert\");\n-        if (!certfile.is_complete()) certfile = filesystem::path(GetDataDir()) / certfile;\n-        if (filesystem::exists(certfile)) context.use_certificate_chain_file(certfile.string().c_str());\n-        else printf(\"ThreadRPCServer ERROR: missing server certificate file %s\\n\", certfile.string().c_str());\n-        filesystem::path pkfile = GetArg(\"-rpcsslprivatekeyfile\", \"server.pem\");\n-        if (!pkfile.is_complete()) pkfile = filesystem::path(GetDataDir()) / pkfile;\n-        if (filesystem::exists(pkfile)) context.use_private_key_file(pkfile.string().c_str(), ssl::context::pem);\n-        else printf(\"ThreadRPCServer ERROR: missing server private key file %s\\n\", pkfile.string().c_str());\n+        delete[] pszStatus;\n \n-        string ciphers = GetArg(\"-rpcsslciphers\",\n-                                         \"TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH\");\n-        SSL_CTX_set_cipher_list(context.impl(), ciphers.c_str());\n+        do_read_header();\n     }\n-#else\n-    if (fUseSSL)\n-        throw runtime_error(\"-rpcssl=1, but bitcoin compiled without full openssl libraries.\");\n-#endif\n-\n-    loop\n+    /* Parses header lines to determine authentication and body length info,\n+     * and continues reading */\n+    void handle_read_header(const boost::system::error_code& err, size_t nBytes)\n     {\n-        // Accept connection\n-#ifdef USE_SSL\n-        SSLStream sslStream(io_service, context);\n-        SSLIOStreamDevice d(sslStream, fUseSSL);\n-        iostreams::stream<SSLIOStreamDevice> stream(d);\n-#else\n-        ip::tcp::iostream stream;\n-#endif\n-\n-        ip::tcp::endpoint peer;\n-        vnThreadsRunning[4]--;\n-#ifdef USE_SSL\n-        acceptor.accept(sslStream.lowest_layer(), peer);\n-#else\n-        acceptor.accept(*stream.rdbuf(), peer);\n-#endif\n-        vnThreadsRunning[4]++;\n-        if (fShutdown)\n-            return;\n+        printf(\"read_header err = %s\\n\", err.message().c_str());\n+        if (err) return;\n \n-        // Restrict callers by IP\n-        if (!ClientAllowed(peer.address().to_string()))\n-            continue;\n+        std::istream is(&streambuf);\n+        char *pszHeader = new char[nBytes + 1];\n+        is.read(pszHeader, nBytes);\n+        pszHeader[nBytes] = '\\0';\n \n+        stringstream ss(pszHeader);\n         map<string, string> mapHeaders;\n-        string strRequest;\n+        int nLen = ReadHTTPHeader(ss, mapHeaders);\n \n-        boost::thread api_caller(ReadHTTP, boost::ref(stream), boost::ref(mapHeaders), boost::ref(strRequest));\n-        if (!api_caller.timed_join(boost::posix_time::seconds(GetArg(\"-rpctimeout\", 30))))\n-        {   // Timed out:\n-            acceptor.cancel();\n-            printf(\"ThreadRPCServer ReadHTTP timeout\\n\");\n-            continue;\n+        delete[] pszHeader;\n+        if (nLen < 0 || nLen > MAX_SIZE)\n+        {\n+            respond(HTTPReply(500, \"\"));\n         }\n-\n         // Check authorization\n         if (mapHeaders.count(\"authorization\") == 0)\n         {\n-            stream << HTTPReply(401, \"\") << std::flush;\n-            continue;\n+            respond(HTTPReply(401, \"\"));\n         }\n-        if (!HTTPAuthorized(mapHeaders))\n+        else if (!HTTPAuthorized(mapHeaders))\n         {\n             // Deter brute-forcing short passwords\n             if (mapArgs[\"-rpcpassword\"].size() < 15)\n                 Sleep(50);\n \n-            stream << HTTPReply(401, \"\") << std::flush;\n+            respond(HTTPReply(401, \"\"));\n             printf(\"ThreadRPCServer incorrect password attempt\\n\");\n-            continue;\n         }\n+        else\n+        {\n+\n+            size_t nExtra = is.rdbuf()->in_avail();\n+            if (nExtra >= nLen)\n+            {\n+                handle_read_body(err, nLen);\n+            }\n+            else\n+            {\n+                nBytesExpected = nLen - nExtra;\n+\n+                do_read_body();\n+            }\n+        }\n+    }\n+    /* Parses body, dispatches RPC call based on incoming JSONRPC request, and\n+     * responds appropriately when request terminates. */\n+    void handle_read_body (const boost::system::error_code& err, size_t nBytes)\n+    {\n+        printf(\"read_body err = %s\\n\", err.message().c_str());\n+        if (err) return;\n \n         Value id = Value::null;\n+        std::istream is(&streambuf);\n+\n+        char *pszBody = new char[nBytes + 1];\n+        is.read(pszBody, nBytes);\n+        pszBody[nBytes] = '\\0';\n+\n+        string strRequest(pszBody);\n+\n         try\n         {\n             // Parse request\n@@ -1946,22 +1946,310 @@ void ThreadRPCServer2(void* parg)\n \n                 // Send reply\n                 string strReply = JSONRPCReply(result, Value::null, id);\n-                stream << HTTPReply(200, strReply) << std::flush;\n+                respond(HTTPReply(200, strReply));\n             }\n             catch (std::exception& e)\n             {\n-                ErrorReply(stream, JSONRPCError(-1, e.what()), id);\n+                respond(ErrorString(JSONRPCError(-1, e.what()), id));\n             }\n         }\n         catch (Object& objError)\n         {\n-            ErrorReply(stream, objError, id);\n+            respond(ErrorString(objError, id));\n         }\n         catch (std::exception& e)\n         {\n-            ErrorReply(stream, JSONRPCError(-32700, e.what()), id);\n+            respond(ErrorString(JSONRPCError(-32700, e.what()), id));\n         }\n+        delete[] pszBody;\n+    }\n+\n+    /* Called asynchronously during body read. Returns the number of bytes of\n+     * data that's still expected from the network. */\n+    size_t body_done_condition(const boost::system::error_code& err,\n+                               size_t nBytes)\n+    {\n+        if (nBytes < nBytesExpected)\n+            return nBytesExpected - nBytes;\n+        else\n+            return 0;\n+    }\n+\n+    /* Do any necessary handling once the response to the JSONRPC call is\n+     * dispatched to the client. */\n+    void handle_response(const boost::system::error_code& err, size_t nBytes)\n+    {}\n+\n+    ip::tcp::endpoint& getPeer()\n+    {\n+        return peer;\n+    }\n+protected:\n+    ip::tcp::endpoint peer;\n+    asio::streambuf streambuf;\n+    size_t nBytesExpected;\n+};\n+\n+#ifdef USE_SSL\n+/* An RPCConnection that uses SSL. */\n+class SSLRPCConnection :public boost::enable_shared_from_this<SSLRPCConnection>,\n+                        public RPCConnection\n+{\n+public:\n+    SSLRPCConnection(asio::io_service& io_service, ssl::context& context)\n+        : socket(io_service, context)\n+    {}\n+    void start()\n+    {\n+        if (! ClientAllowed(peer.address().to_string()))\n+            return;\n+        socket.async_handshake(ssl::stream_base::server,\n+            boost::bind(&SSLRPCConnection::handle_handshake, shared_from_this(),\n+                        asio::placeholders::error));\n+    }\n+    void handle_handshake(const boost::system::error_code& err)\n+    {\n+        if (err) return;\n+        do_read_status();\n+    }\n+    void do_read_status()\n+    {\n+        asio::async_read_until(socket, streambuf, \"\\r\\n\",\n+            boost::bind(&SSLRPCConnection::handle_read_status,\n+                        shared_from_this(), asio::placeholders::error,\n+                        asio::placeholders::bytes_transferred));\n+    }\n+    void do_read_header()\n+    {\n+        asio::async_read_until(socket, streambuf, \"\\r\\n\\r\\n\",\n+            boost::bind(&SSLRPCConnection::handle_read_header,\n+                        shared_from_this(), asio::placeholders::error,\n+                        asio::placeholders::bytes_transferred));\n+    }\n+    void do_read_body()\n+    {\n+        asio::async_read(socket, streambuf,\n+            boost::bind(&SSLRPCConnection::body_done_condition,\n+                        shared_from_this(), asio::placeholders::error,\n+                        asio::placeholders::bytes_transferred),\n+            boost::bind(&SSLRPCConnection::handle_read_body,\n+                        shared_from_this(), asio::placeholders::error,\n+                        asio::placeholders::bytes_transferred));\n+    }\n+    void respond(std::string str)\n+    {\n+        boost::asio::async_write(socket, boost::asio::buffer(str),\n+            boost::bind(&SSLRPCConnection::handle_response, shared_from_this(),\n+            boost::asio::placeholders::error,\n+            boost::asio::placeholders::bytes_transferred));\n+    }\n+\n+    SSLStream socket;\n+private:\n+};\n+#endif\n+\n+/* An RPCConnection that uses plain TCP. */\n+class PlainRPCConnection :\n+    public boost::enable_shared_from_this<PlainRPCConnection>,\n+    public RPCConnection\n+{\n+public:\n+    PlainRPCConnection(asio::io_service& io_service) : socket(io_service)\n+    {}\n+    void do_read_status()\n+    {\n+        asio::async_read_until(socket, streambuf, \"\\r\\n\",\n+            boost::bind(&PlainRPCConnection::handle_read_status,\n+                        shared_from_this(), asio::placeholders::error,\n+                        asio::placeholders::bytes_transferred));\n+    }\n+    void do_read_header()\n+    {\n+        asio::async_read_until(socket, streambuf, \"\\r\\n\\r\\n\",\n+            boost::bind(&PlainRPCConnection::handle_read_header,\n+                        shared_from_this(), asio::placeholders::error,\n+                        asio::placeholders::bytes_transferred));\n+    }\n+    void do_read_body()\n+    {\n+        asio::async_read(socket, streambuf,\n+            boost::bind(&PlainRPCConnection::body_done_condition,\n+                        shared_from_this(), asio::placeholders::error,\n+                        asio::placeholders::bytes_transferred),\n+            boost::bind(&PlainRPCConnection::handle_read_body,\n+                        shared_from_this(), asio::placeholders::error,\n+                        asio::placeholders::bytes_transferred));\n+    }\n+    void respond(std::string str)\n+    {\n+        boost::asio::async_write(socket, boost::asio::buffer(str),\n+            boost::bind(&PlainRPCConnection::handle_response,\n+            shared_from_this(), boost::asio::placeholders::error,\n+            boost::asio::placeholders::bytes_transferred));\n+    }\n+    ip::tcp::socket socket;\n+private:\n+};\n+\n+typedef boost::shared_ptr<RPCConnection> RPCConnection_p;\n+\n+class AsyncRPCServer {\n+public:\n+    AsyncRPCServer(asio::io_service &io_service, ip::tcp::acceptor &acceptor,\n+                   bool useSSL);\n+    void do_accept(RPCConnection_p& con);\n+    void handle_accept(RPCConnection_p con, const boost::system::error_code &error);\n+private:\n+    asio::io_service& m_io_service;\n+    ip::tcp::acceptor& m_acceptor;\n+    bool fUseSSL;\n+#ifdef USE_SSL\n+    ssl::context context;\n+#endif\n+\n+};\n+\n+AsyncRPCServer::AsyncRPCServer(asio::io_service &io_service,\n+                               ip::tcp::acceptor &acceptor, bool useSSL)\n+    : m_io_service(io_service), m_acceptor(acceptor), fUseSSL(useSSL)\n+#ifdef USE_SSL\n+      , context(io_service, ssl::context::sslv23)\n+#endif\n+{\n+    printf(\"hi from asyncrpc constructor.\\n\");\n+    m_acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));\n+#ifdef USE_SSL\n+    if (fUseSSL)\n+    {\n+        context.set_options(ssl::context::no_sslv2);\n+        filesystem::path certfile = GetArg(\"-rpcsslcertificatechainfile\", \"server.cert\");\n+        if (!certfile.is_complete()) certfile = filesystem::path(GetDataDir()) / certfile;\n+        if (filesystem::exists(certfile)) context.use_certificate_chain_file(certfile.string().c_str());\n+        else printf(\"ThreadRPCServer ERROR: missing server certificate file %s\\n\", certfile.string().c_str());\n+        filesystem::path pkfile = GetArg(\"-rpcsslprivatekeyfile\", \"server.pem\");\n+        if (!pkfile.is_complete()) pkfile = filesystem::path(GetDataDir()) / pkfile;\n+        if (filesystem::exists(pkfile)) context.use_private_key_file(pkfile.string().c_str(), ssl::context::pem);\n+        else printf(\"ThreadRPCServer ERROR: missing server private key file %s\\n\", pkfile.string().c_str());\n+\n+        string ciphers = GetArg(\"-rpcsslciphers\",\n+                                         \"TLSv1+HIGH:!SSLv2:!aNULL:!eNULL:!AH:!3DES:@STRENGTH\");\n+        SSL_CTX_set_cipher_list(context.impl(), ciphers.c_str());\n+        RPCConnection_p con(new SSLRPCConnection(m_io_service, context));\n+        do_accept(con);\n+    }\n+    else\n+    {\n+        RPCConnection_p con(new PlainRPCConnection(m_io_service));\n+        do_accept(con);\n+    }\n+#else\n+    if (fUseSSL)\n+        throw runtime_error(\"-rpcssl=1, but bitcoin compiled without full openssl libraries.\");\n+    RPCConnection_p con(new PlainRPCConnection(m_io_service));\n+    do_accept(con);\n+#endif\n+}\n+\n+void AsyncRPCServer::do_accept(RPCConnection_p& con)\n+{\n+    printf(\"hi do_acept\\n\");\n+\n+#ifdef USE_SSL\n+    if (fUseSSL)\n+    {\n+        boost::shared_ptr<SSLRPCConnection> src = static_pointer_cast<SSLRPCConnection> (con);\n+        m_acceptor.async_accept(src->socket.lowest_layer(), con->getPeer(), boost::bind(&AsyncRPCServer::handle_accept, this, con, boost::asio::placeholders::error));\n+    }\n+    else\n+#endif\n+    {\n+        boost::shared_ptr<PlainRPCConnection> prc = static_pointer_cast<PlainRPCConnection> (con);\n+        m_acceptor.async_accept(prc->socket.lowest_layer(), con->getPeer(), boost::bind(&AsyncRPCServer::handle_accept, this, con, boost::asio::placeholders::error));\n+    }\n+\n+}\n+\n+void AsyncRPCServer::handle_accept(RPCConnection_p con, const boost::system::error_code &error)\n+{\n+    printf(\"hi handle_accept: error = %s\\n\", error.message().c_str());\n+    if (!error && !fShutdown)\n+    {\n+        con->start();\n+#ifdef USE_SSL\n+        if (fUseSSL)\n+        {\n+            RPCConnection_p new_con(new SSLRPCConnection(m_io_service, context));\n+            do_accept(new_con);\n+        }\n+        else\n+#endif\n+        {\n+            RPCConnection_p new_con(new PlainRPCConnection(m_io_service));\n+            do_accept(new_con);\n+        }\n+    }\n+}\n+\n+\n+void ThreadRPCServer(void* parg)\n+{\n+    IMPLEMENT_RANDOMIZE_STACK(ThreadRPCServer(parg));\n+    try\n+    {\n+        vnThreadsRunning[4]++;\n+        ThreadRPCServer2(parg);\n+        vnThreadsRunning[4]--;\n+    }\n+    catch (std::exception& e) {\n+        vnThreadsRunning[4]--;\n+        PrintException(&e, \"ThreadRPCServer()\");\n+    } catch (...) {\n+        vnThreadsRunning[4]--;\n+        PrintException(NULL, \"ThreadRPCServer()\");\n+    }\n+    printf(\"ThreadRPCServer exiting\\n\");\n+}\n+\n+void ThreadRPCServer2(void* parg)\n+{\n+    printf(\"ThreadRPCServer started\\n\");\n+\n+    if (mapArgs[\"-rpcuser\"] == \"\" && mapArgs[\"-rpcpassword\"] == \"\")\n+    {\n+        string strWhatAmI = \"To use bitcoind\";\n+        if (mapArgs.count(\"-server\"))\n+            strWhatAmI = strprintf(_(\"To use the %s option\"), \"\\\"-server\\\"\");\n+        else if (mapArgs.count(\"-daemon\"))\n+            strWhatAmI = strprintf(_(\"To use the %s option\"), \"\\\"-daemon\\\"\");\n+        PrintConsole(\n+            _(\"Warning: %s, you must set rpcpassword=<password>\\nin the configuration file: %s\\n\"\n+              \"If the file does not exist, create it with owner-readable-only file permissions.\\n\"),\n+                strWhatAmI.c_str(),\n+                GetConfigFile().c_str());\n+        CreateThread(Shutdown, NULL);\n+        return;\n+    }\n+\n+    asio::ip::address bindAddress = mapArgs.count(\"-rpcallowip\") ? asio::ip::address_v4::any() : asio::ip::address_v4::loopback();\n+\n+    asio::io_service io_service;\n+    ip::tcp::endpoint endpoint(bindAddress, GetArg(\"-rpcport\", 8332));\n+    ip::tcp::acceptor acceptor(io_service, endpoint);\n+\n+    bool fUseSSL = GetBoolArg(\"-rpcssl\");\n+    AsyncRPCServer server(io_service, acceptor, fUseSSL);\n+\n+    vnThreadsRunning[4]++;\n+    boost::thread io_runner(static_cast <size_t (asio::io_service::*)(void) >(&asio::io_service::run), &io_service);\n+\n+    while (!fShutdown)\n+    {\n+        Sleep(2000);\n     }\n+    io_service.stop();\n+    io_runner.join();\n+    vnThreadsRunning[4]--;\n }\n \n "
      }
    ]
  },
  {
    "sha": "bb04a7750c84a07dc2889155ce5a4895b8253297",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiYjA0YTc3NTBjODRhMDdkYzI4ODkxNTVjZTVhNDg5NWI4MjUzMjk3",
    "commit": {
      "author": {
        "name": "Jordan Lewis",
        "email": "jordanthelewis@gmail.com",
        "date": "2011-05-09T18:48:00Z"
      },
      "committer": {
        "name": "Jordan Lewis",
        "email": "jordanthelewis@gmail.com",
        "date": "2011-05-30T02:43:18Z"
      },
      "message": "Remove debug printfs",
      "tree": {
        "sha": "382f7d8dd6c2353f4c54047f31e30f3817f99d3f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/382f7d8dd6c2353f4c54047f31e30f3817f99d3f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bb04a7750c84a07dc2889155ce5a4895b8253297",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb04a7750c84a07dc2889155ce5a4895b8253297",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bb04a7750c84a07dc2889155ce5a4895b8253297",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bb04a7750c84a07dc2889155ce5a4895b8253297/comments",
    "author": {
      "login": "jordanlewis",
      "id": 43821,
      "node_id": "MDQ6VXNlcjQzODIx",
      "avatar_url": "https://avatars.githubusercontent.com/u/43821?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jordanlewis",
      "html_url": "https://github.com/jordanlewis",
      "followers_url": "https://api.github.com/users/jordanlewis/followers",
      "following_url": "https://api.github.com/users/jordanlewis/following{/other_user}",
      "gists_url": "https://api.github.com/users/jordanlewis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jordanlewis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jordanlewis/subscriptions",
      "organizations_url": "https://api.github.com/users/jordanlewis/orgs",
      "repos_url": "https://api.github.com/users/jordanlewis/repos",
      "events_url": "https://api.github.com/users/jordanlewis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jordanlewis/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jordanlewis",
      "id": 43821,
      "node_id": "MDQ6VXNlcjQzODIx",
      "avatar_url": "https://avatars.githubusercontent.com/u/43821?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jordanlewis",
      "html_url": "https://github.com/jordanlewis",
      "followers_url": "https://api.github.com/users/jordanlewis/followers",
      "following_url": "https://api.github.com/users/jordanlewis/following{/other_user}",
      "gists_url": "https://api.github.com/users/jordanlewis/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jordanlewis/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jordanlewis/subscriptions",
      "organizations_url": "https://api.github.com/users/jordanlewis/orgs",
      "repos_url": "https://api.github.com/users/jordanlewis/repos",
      "events_url": "https://api.github.com/users/jordanlewis/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jordanlewis/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9424ab37dea7c3e85b86ddfe744b6aa212fcbded",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9424ab37dea7c3e85b86ddfe744b6aa212fcbded",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9424ab37dea7c3e85b86ddfe744b6aa212fcbded"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 0,
      "deletions": 6
    },
    "files": [
      {
        "sha": "3d2fda3315ff60f077001635ba7b2c928f49418d",
        "filename": "src/rpc.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bb04a7750c84a07dc2889155ce5a4895b8253297/src/rpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bb04a7750c84a07dc2889155ce5a4895b8253297/src/rpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc.cpp?ref=bb04a7750c84a07dc2889155ce5a4895b8253297",
        "patch": "@@ -1816,7 +1816,6 @@ class RPCConnection\n     /* Parse status line and continues reading */\n     void handle_read_status(const boost::system::error_code& err, size_t nBytes)\n     {\n-        printf(\"read_status err = %s\\n\", err.message().c_str());\n         if (err) return;\n \n         istream is(&streambuf);\n@@ -1835,7 +1834,6 @@ class RPCConnection\n      * and continues reading */\n     void handle_read_header(const boost::system::error_code& err, size_t nBytes)\n     {\n-        printf(\"read_header err = %s\\n\", err.message().c_str());\n         if (err) return;\n \n         std::istream is(&streambuf);\n@@ -1886,7 +1884,6 @@ class RPCConnection\n      * responds appropriately when request terminates. */\n     void handle_read_body (const boost::system::error_code& err, size_t nBytes)\n     {\n-        printf(\"read_body err = %s\\n\", err.message().c_str());\n         if (err) return;\n \n         Value id = Value::null;\n@@ -2117,7 +2114,6 @@ AsyncRPCServer::AsyncRPCServer(asio::io_service &io_service,\n       , context(io_service, ssl::context::sslv23)\n #endif\n {\n-    printf(\"hi from asyncrpc constructor.\\n\");\n     m_acceptor.set_option(boost::asio::ip::tcp::acceptor::reuse_address(true));\n #ifdef USE_SSL\n     if (fUseSSL)\n@@ -2153,7 +2149,6 @@ AsyncRPCServer::AsyncRPCServer(asio::io_service &io_service,\n \n void AsyncRPCServer::do_accept(RPCConnection_p& con)\n {\n-    printf(\"hi do_acept\\n\");\n \n #ifdef USE_SSL\n     if (fUseSSL)\n@@ -2172,7 +2167,6 @@ void AsyncRPCServer::do_accept(RPCConnection_p& con)\n \n void AsyncRPCServer::handle_accept(RPCConnection_p con, const boost::system::error_code &error)\n {\n-    printf(\"hi handle_accept: error = %s\\n\", error.message().c_str());\n     if (!error && !fShutdown)\n     {\n         con->start();"
      }
    ]
  }
]