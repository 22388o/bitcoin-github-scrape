[
  {
    "sha": "712fd182b72b0f5a1bcf843f171c29ec0a49b50f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3MTJmZDE4MmI3MmIwZjVhMWJjZjg0M2YxNzFjMjllYzBhNDliNTBm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-04-02T00:40:41Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-04-04T14:21:08Z"
      },
      "message": "Locking system overhaul, add condition variables\n\nThis commit simplifies the locking system: CCriticalSection becomes a\nsimple typedef for boost::interprocess::interprocess_recursive_mutex,\nand CCriticalBlock and CTryCriticalBlock are replaced by a templated\nCMutexLock, which wraps boost::interprocess::scoped_lock.\n\nBy making the lock type a template parameter, some critical sections\ncan now be changed to non-recursive locks, which support waiting via\ncondition variables. These are implemented in CWaitableCriticalSection\nand WAITABLE_CRITICAL_BLOCK.\n\nCWaitableCriticalSection is a wrapper for a different Boost mutex,\nwhich supports waiting/notification via condition variables. This\nshould enable us to remove much of the used polling code. Important\nis that this mutex is not recursive, so functions that perform the\nlocking must not call eachother.\n\nBecause boost::interprocess::scoped_lock does not support assigning\nand copying, I had to revert to the older CRITICAL_BLOCK macros that\nuse a nested for loop instead of a simple if.",
      "tree": {
        "sha": "ac5edf9ece53a8f03fde992b0fbfa9a11c8db688",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ac5edf9ece53a8f03fde992b0fbfa9a11c8db688"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/712fd182b72b0f5a1bcf843f171c29ec0a49b50f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/712fd182b72b0f5a1bcf843f171c29ec0a49b50f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/712fd182b72b0f5a1bcf843f171c29ec0a49b50f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/712fd182b72b0f5a1bcf843f171c29ec0a49b50f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b0a7e05a45a925d78efd00ecca6dce9b7a9530f9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b0a7e05a45a925d78efd00ecca6dce9b7a9530f9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b0a7e05a45a925d78efd00ecca6dce9b7a9530f9"
      }
    ],
    "stats": {
      "total": 213,
      "additions": 110,
      "deletions": 103
    },
    "files": [
      {
        "sha": "09361ef8f2a4616415bcf251c272261514a8a13c",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 52,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/712fd182b72b0f5a1bcf843f171c29ec0a49b50f/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/712fd182b72b0f5a1bcf843f171c29ec0a49b50f/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=712fd182b72b0f5a1bcf843f171c29ec0a49b50f",
        "patch": "@@ -1193,62 +1193,14 @@ static void pop_lock()\n     dd_mutex.unlock();\n }\n \n-void CCriticalSection::Enter(const char* pszName, const char* pszFile, int nLine)\n+void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs)\n {\n-    push_lock(this, CLockLocation(pszName, pszFile, nLine));\n-#ifdef DEBUG_LOCKCONTENTION\n-    bool result = mutex.try_lock();\n-    if (!result)\n-    {\n-        printf(\"LOCKCONTENTION: %s\\n\", pszName);\n-        printf(\"Locker: %s:%d\\n\", pszFile, nLine);\n-        mutex.lock();\n-        printf(\"Locked\\n\");\n-    }\n-#else\n-    mutex.lock();\n-#endif\n-}\n-void CCriticalSection::Leave()\n-{\n-    mutex.unlock();\n-    pop_lock();\n-}\n-bool CCriticalSection::TryEnter(const char* pszName, const char* pszFile, int nLine)\n-{\n-    push_lock(this, CLockLocation(pszName, pszFile, nLine));\n-    bool result = mutex.try_lock();\n-    if (!result) pop_lock();\n-    return result;\n+    push_lock(cs, CLockLocation(pszName, pszFile, nLine));\n }\n \n-#else\n-\n-void CCriticalSection::Enter(const char* pszName, const char* pszFile, int nLine)\n+void LeaveCritical()\n {\n-#ifdef DEBUG_LOCKCONTENTION\n-    bool result = mutex.try_lock();\n-    if (!result)\n-    {\n-        printf(\"LOCKCONTENTION: %s\\n\", pszName);\n-        printf(\"Locker: %s:%d\\n\", pszFile, nLine);\n-        mutex.lock();\n-    }\n-#else\n-    mutex.lock();\n-#endif\n-}\n-\n-void CCriticalSection::Leave()\n-{\n-    mutex.unlock();\n-}\n-\n-bool CCriticalSection::TryEnter(const char*, const char*, int)\n-{\n-    bool result = mutex.try_lock();\n-    return result;\n+    pop_lock();\n }\n \n #endif /* DEBUG_LOCKORDER */\n-"
      },
      {
        "sha": "635790b71b481e1e61648855f40808b2f033fb31",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 106,
        "deletions": 51,
        "changes": 157,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/712fd182b72b0f5a1bcf843f171c29ec0a49b50f/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/712fd182b72b0f5a1bcf843f171c29ec0a49b50f/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=712fd182b72b0f5a1bcf843f171c29ec0a49b50f",
        "patch": "@@ -20,6 +20,9 @@ typedef int pid_t; /* define for windows compatiblity */\n \n #include <boost/thread.hpp>\n #include <boost/interprocess/sync/interprocess_recursive_mutex.hpp>\n+#include <boost/interprocess/sync/scoped_lock.hpp>\n+#include <boost/interprocess/sync/interprocess_condition.hpp>\n+#include <boost/interprocess/sync/lock_options.hpp>\n #include <boost/date_time/gregorian/gregorian_types.hpp>\n #include <boost/date_time/posix_time/posix_time_types.hpp>\n \n@@ -180,82 +183,134 @@ void AddTimeData(const CNetAddr& ip, int64 nTime);\n \n \n \n+/** Wrapped boost mutex: supports recursive locking, but no waiting  */\n+typedef boost::interprocess::interprocess_recursive_mutex CCriticalSection;\n \n-/** Wrapper to automatically initialize mutex. */\n-class CCriticalSection\n-{\n-protected:\n-    boost::interprocess::interprocess_recursive_mutex mutex;\n-public:\n-    explicit CCriticalSection() { }\n-    ~CCriticalSection() { }\n-    void Enter(const char* pszName, const char* pszFile, int nLine);\n-    void Leave();\n-    bool TryEnter(const char* pszName, const char* pszFile, int nLine);\n-};\n+/** Wrapped boost mutex: supports waiting but not recursive locking */\n+typedef boost::interprocess::interprocess_mutex CWaitableCriticalSection;\n \n-/** RAII object that acquires mutex. Needed for exception safety. */\n-class CCriticalBlock\n-{\n-protected:\n-    CCriticalSection* pcs;\n+#ifdef DEBUG_LOCKORDER\n+void EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs);\n+void LeaveCritical();\n+#else\n+void static inline EnterCritical(const char* pszName, const char* pszFile, int nLine, void* cs) {}\n+void static inline LeaveCritical() {}\n+#endif\n \n+/** Wrapper around boost::interprocess::scoped_lock */\n+template<typename Mutex>\n+class CMutexLock\n+{\n+private:\n+    boost::interprocess::scoped_lock<Mutex> lock;\n public:\n-    CCriticalBlock(CCriticalSection& csIn, const char* pszName, const char* pszFile, int nLine)\n+\n+    void Enter(const char* pszName, const char* pszFile, int nLine)\n     {\n-        pcs = &csIn;\n-        pcs->Enter(pszName, pszFile, nLine);\n+        if (!lock.owns())\n+        {\n+            EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()));\n+#ifdef DEBUG_LOCKCONTENTION\n+            if (!lock.try_lock())\n+            {\n+                printf(\"LOCKCONTENTION: %s\\n\", pszName);\n+                printf(\"Locker: %s:%d\\n\", pszFile, nLine);\n+            }\n+#endif\n+            lock.lock();\n+        }\n     }\n \n-    operator bool() const\n+    void Leave()\n     {\n-        return true;\n+        if (lock.owns())\n+        {\n+            lock.unlock();\n+            LeaveCritical();\n+        }\n     }\n \n-    ~CCriticalBlock()\n+    bool TryEnter(const char* pszName, const char* pszFile, int nLine)\n     {\n-        pcs->Leave();\n+        if (!lock.owns())\n+        {\n+            EnterCritical(pszName, pszFile, nLine, (void*)(lock.mutex()));\n+            lock.try_lock();\n+            if (!lock.owns())\n+                LeaveCritical();\n+        }\n+        return lock.owns();\n     }\n-};\n-\n-#define CRITICAL_BLOCK(cs)     \\\n-    if (CCriticalBlock criticalblock = CCriticalBlock(cs, #cs, __FILE__, __LINE__))\n-\n-#define ENTER_CRITICAL_SECTION(cs) \\\n-    (cs).Enter(#cs, __FILE__, __LINE__)\n-\n-#define LEAVE_CRITICAL_SECTION(cs) \\\n-    (cs).Leave()\n \n-/** RAII object that tries to acquire mutex. Needed for exception safety. */\n-class CTryCriticalBlock\n-{\n-protected:\n-    CCriticalSection* pcs;\n+    CMutexLock(Mutex& mutexIn, const char* pszName, const char* pszFile, int nLine, bool fTry = false) : lock(mutexIn, boost::interprocess::defer_lock)\n+    {\n+        if (fTry)\n+            TryEnter(pszName, pszFile, nLine);\n+        else\n+            Enter(pszName, pszFile, nLine);\n+    }\n \n-public:\n-    CTryCriticalBlock(CCriticalSection& csIn, const char* pszName, const char* pszFile, int nLine)\n+    ~CMutexLock()\n     {\n-        pcs = (csIn.TryEnter(pszName, pszFile, nLine) ? &csIn : NULL);\n+        if (lock.owns())\n+            LeaveCritical();\n     }\n \n-    operator bool() const\n+    operator bool()\n     {\n-        return Entered();\n+        return lock.owns();\n     }\n \n-    ~CTryCriticalBlock()\n+    boost::interprocess::scoped_lock<Mutex> &GetLock()\n     {\n-        if (pcs)\n-        {\n-            pcs->Leave();\n-        }\n+        return lock;\n     }\n-    bool Entered() const { return pcs != NULL; }\n };\n \n+typedef CMutexLock<CCriticalSection> CCriticalBlock;\n+typedef CMutexLock<CWaitableCriticalSection> CWaitableCriticalBlock;\n+typedef boost::interprocess::interprocess_condition CConditionVariable;\n+\n+/** Wait for a given condition inside a WAITABLE_CRITICAL_BLOCK */\n+#define WAIT(name,condition) \\\n+   do { while(!(condition)) { (name).wait(waitablecriticalblock.GetLock()); } } while(0)\n+\n+/** Notify waiting threads that a condition may hold now */\n+#define NOTIFY(name) \\\n+   do { (name).notify_one(); } while(0)\n+\n+#define NOTIFY_ALL(name) \\\n+   do { (name).notify_all(); } while(0)\n+\n+#define CRITICAL_BLOCK(cs)     \\\n+    for (bool fcriticalblockonce=true; fcriticalblockonce; assert((\"break caught by CRITICAL_BLOCK!\" && !fcriticalblockonce)), fcriticalblockonce=false) \\\n+        for (CCriticalBlock criticalblock(cs, #cs, __FILE__, __LINE__); fcriticalblockonce; fcriticalblockonce=false)\n+\n+#define WAITABLE_CRITICAL_BLOCK(cs)     \\\n+    for (bool fcriticalblockonce=true; fcriticalblockonce; assert((\"break caught by WAITABLE_CRITICAL_BLOCK!\" && !fcriticalblockonce)), fcriticalblockonce=false) \\\n+        for (CWaitableCriticalBlock waitablecriticalblock(cs, #cs, __FILE__, __LINE__); fcriticalblockonce; fcriticalblockonce=false)\n+\n+#define ENTER_CRITICAL_SECTION(cs) \\\n+    { \\\n+        EnterCritical(#cs, __FILE__, __LINE__, (void*)(&cs)); \\\n+        (cs).lock(); \\\n+    }\n+\n+#define LEAVE_CRITICAL_SECTION(cs) \\\n+    { \\\n+        (cs).unlock(); \\\n+        LeaveCritical(); \\\n+    }\n+\n #define TRY_CRITICAL_BLOCK(cs)     \\\n-    if (CTryCriticalBlock criticalblock = CTryCriticalBlock(cs, #cs, __FILE__, __LINE__))\n+    for (bool fcriticalblockonce=true; fcriticalblockonce; assert((\"break caught by TRY_CRITICAL_BLOCK!\" && !fcriticalblockonce)), fcriticalblockonce=false) \\\n+        for (CCriticalBlock criticalblock(cs, #cs, __FILE__, __LINE__, true); fcriticalblockonce && (fcriticalblockonce = criticalblock); fcriticalblockonce=false)\n+\n+\n+// This is exactly like std::string, but with a custom allocator.\n+// (secure_allocator<> is defined in serialize.h)\n+typedef std::basic_string<char, std::char_traits<char>, secure_allocator<char> > SecureString;\n+\n \n \n "
      }
    ]
  },
  {
    "sha": "092631f0ba0030dec1ccfa66e206fb2a6c9bf73b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowOTI2MzFmMGJhMDAzMGRlYzFjY2ZhNjZlMjA2ZmIyYTZjOWJmNzNi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-04-04T14:01:57Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2012-04-04T15:24:13Z"
      },
      "message": "Condition variable for outbound connection slots\n\nKeep a global counter for nOutbound, protected with its own waitable\ncritical section, and wait when all outbound slots are filled, rather\nthan polling.\n\nThis removes the (on average) 1 second delay between a lost connection\nand a new connection attempt, and may speed up shutdowns.",
      "tree": {
        "sha": "b7e5a843ac4d215227b519efdd251d7b46fb13dc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b7e5a843ac4d215227b519efdd251d7b46fb13dc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/092631f0ba0030dec1ccfa66e206fb2a6c9bf73b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/092631f0ba0030dec1ccfa66e206fb2a6c9bf73b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/092631f0ba0030dec1ccfa66e206fb2a6c9bf73b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/092631f0ba0030dec1ccfa66e206fb2a6c9bf73b/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "712fd182b72b0f5a1bcf843f171c29ec0a49b50f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/712fd182b72b0f5a1bcf843f171c29ec0a49b50f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/712fd182b72b0f5a1bcf843f171c29ec0a49b50f"
      }
    ],
    "stats": {
      "total": 41,
      "additions": 22,
      "deletions": 19
    },
    "files": [
      {
        "sha": "2d9cf6ede00acba99f48afb61d79558d24836b8b",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 19,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/092631f0ba0030dec1ccfa66e206fb2a6c9bf73b/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/092631f0ba0030dec1ccfa66e206fb2a6c9bf73b/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=092631f0ba0030dec1ccfa66e206fb2a6c9bf73b",
        "patch": "@@ -64,6 +64,9 @@ map<CInv, int64> mapAlreadyAskedFor;\n set<CNetAddr> setservAddNodeAddresses;\n CCriticalSection cs_setservAddNodeAddresses;\n \n+static CWaitableCriticalSection csOutbound;\n+static int nOutbound = 0;\n+static CConditionVariable condOutbound;\n \n \n unsigned short GetListenPort()\n@@ -460,6 +463,8 @@ CNode* ConnectNode(CAddress addrConnect, int64 nTimeout)\n             pnode->AddRef();\n         CRITICAL_BLOCK(cs_vNodes)\n             vNodes.push_back(pnode);\n+        WAITABLE_CRITICAL_BLOCK(csOutbound)\n+            nOutbound++;\n \n         pnode->nTimeConnected = GetTime();\n         return pnode;\n@@ -610,6 +615,15 @@ void ThreadSocketHandler2(void* parg)\n                     // remove from vNodes\n                     vNodes.erase(remove(vNodes.begin(), vNodes.end(), pnode), vNodes.end());\n \n+                    if (!pnode->fInbound)\n+                        WAITABLE_CRITICAL_BLOCK(csOutbound)\n+                        {\n+                            nOutbound--;\n+\n+                            // Connection slot(s) were removed, notify connection creator(s)\n+                            NOTIFY(condOutbound);\n+                        }\n+\n                     // close socket and cleanup\n                     pnode->CloseSocketDisconnect();\n                     pnode->Cleanup();\n@@ -1278,32 +1292,20 @@ void ThreadOpenConnections2(void* parg)\n     int64 nStart = GetTime();\n     loop\n     {\n-        int nOutbound = 0;\n-\n         vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n         Sleep(500);\n         vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n         if (fShutdown)\n             return;\n \n         // Limit outbound connections\n-        loop\n-        {\n-            nOutbound = 0;\n-            CRITICAL_BLOCK(cs_vNodes)\n-                BOOST_FOREACH(CNode* pnode, vNodes)\n-                    if (!pnode->fInbound)\n-                        nOutbound++;\n-            int nMaxOutboundConnections = MAX_OUTBOUND_CONNECTIONS;\n-            nMaxOutboundConnections = min(nMaxOutboundConnections, (int)GetArg(\"-maxconnections\", 125));\n-            if (nOutbound < nMaxOutboundConnections)\n-                break;\n-            vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n-            Sleep(2000);\n-            vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n-            if (fShutdown)\n-                return;\n-        }\n+        int nMaxOutbound = min(MAX_OUTBOUND_CONNECTIONS, (int)GetArg(\"-maxconnections\", 125));\n+        vnThreadsRunning[THREAD_OPENCONNECTIONS]--;\n+        WAITABLE_CRITICAL_BLOCK(csOutbound)\n+            WAIT(condOutbound, fShutdown || nOutbound < nMaxOutbound);\n+        vnThreadsRunning[THREAD_OPENCONNECTIONS]++;\n+        if (fShutdown)\n+            return;\n \n         bool fAddSeeds = false;\n \n@@ -1752,6 +1754,7 @@ bool StopNode()\n     fShutdown = true;\n     nTransactionsUpdated++;\n     int64 nStart = GetTime();\n+    NOTIFY_ALL(condOutbound);\n     do\n     {\n         int nThreadsRunning = 0;"
      }
    ]
  }
]