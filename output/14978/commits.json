[
  {
    "sha": "162ffefd2f562169725559906601c25c579aa91c",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxNjJmZmVmZDJmNTYyMTY5NzI1NTU5OTA2NjAxYzI1YzU3OWFhOTFj",
    "commit": {
      "author": {
        "name": "Glenn Willen",
        "email": "gwillen@nerdnet.org",
        "date": "2019-01-29T06:44:11Z"
      },
      "committer": {
        "name": "Glenn Willen",
        "email": "gwillen@nerdnet.org",
        "date": "2019-02-11T20:23:14Z"
      },
      "message": "Add pf_invalid arg to std::string DecodeBase{32,64}\n\nAdd support for the optional \"pf_invalid\" out parameter (which allows the caller\nto detect decoding failures) to the std::string versions of DecodeBase32 and\nDecodeBase64. The char* versions already have this feature.\n\nAlso, rename all uses of pfInvalid to pf_invalid to match style guidelines.",
      "tree": {
        "sha": "1ab7e3660d0a07d6e92dcabddc8875e392452aed",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1ab7e3660d0a07d6e92dcabddc8875e392452aed"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/162ffefd2f562169725559906601c25c579aa91c",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/162ffefd2f562169725559906601c25c579aa91c",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/162ffefd2f562169725559906601c25c579aa91c",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/162ffefd2f562169725559906601c25c579aa91c/comments",
    "author": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "1bc149d05b09d716723d2f091250fab38fd70fc2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/1bc149d05b09d716723d2f091250fab38fd70fc2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/1bc149d05b09d716723d2f091250fab38fd70fc2"
      }
    ],
    "stats": {
      "total": 24,
      "additions": 12,
      "deletions": 12
    },
    "files": [
      {
        "sha": "b55547bc63cd4e7f39e9147c000aa650149c11cf",
        "filename": "src/util/strencodings.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/162ffefd2f562169725559906601c25c579aa91c/src/util/strencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/162ffefd2f562169725559906601c25c579aa91c/src/util/strencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/strencodings.cpp?ref=162ffefd2f562169725559906601c25c579aa91c",
        "patch": "@@ -141,7 +141,7 @@ std::string EncodeBase64(const std::string& str)\n     return EncodeBase64((const unsigned char*)str.c_str(), str.size());\n }\n \n-std::vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid)\n+std::vector<unsigned char> DecodeBase64(const char* p, bool* pf_invalid)\n {\n     static const int decode64_table[256] =\n     {\n@@ -183,14 +183,14 @@ std::vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid)\n         ++p;\n     }\n     valid = valid && (p - e) % 4 == 0 && p - q < 4;\n-    if (pfInvalid) *pfInvalid = !valid;\n+    if (pf_invalid) *pf_invalid = !valid;\n \n     return ret;\n }\n \n-std::string DecodeBase64(const std::string& str)\n+std::string DecodeBase64(const std::string& str, bool* pf_invalid)\n {\n-    std::vector<unsigned char> vchRet = DecodeBase64(str.c_str());\n+    std::vector<unsigned char> vchRet = DecodeBase64(str.c_str(), pf_invalid);\n     return std::string((const char*)vchRet.data(), vchRet.size());\n }\n \n@@ -210,7 +210,7 @@ std::string EncodeBase32(const std::string& str)\n     return EncodeBase32((const unsigned char*)str.c_str(), str.size());\n }\n \n-std::vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid)\n+std::vector<unsigned char> DecodeBase32(const char* p, bool* pf_invalid)\n {\n     static const int decode32_table[256] =\n     {\n@@ -252,14 +252,14 @@ std::vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid)\n         ++p;\n     }\n     valid = valid && (p - e) % 8 == 0 && p - q < 8;\n-    if (pfInvalid) *pfInvalid = !valid;\n+    if (pf_invalid) *pf_invalid = !valid;\n \n     return ret;\n }\n \n-std::string DecodeBase32(const std::string& str)\n+std::string DecodeBase32(const std::string& str, bool* pf_invalid)\n {\n-    std::vector<unsigned char> vchRet = DecodeBase32(str.c_str());\n+    std::vector<unsigned char> vchRet = DecodeBase32(str.c_str(), pf_invalid);\n     return std::string((const char*)vchRet.data(), vchRet.size());\n }\n "
      },
      {
        "sha": "59eefff566f258a26c1ebcc966522837fa1534b7",
        "filename": "src/util/strencodings.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/162ffefd2f562169725559906601c25c579aa91c/src/util/strencodings.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/162ffefd2f562169725559906601c25c579aa91c/src/util/strencodings.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util/strencodings.h?ref=162ffefd2f562169725559906601c25c579aa91c",
        "patch": "@@ -44,12 +44,12 @@ bool IsHex(const std::string& str);\n * Return true if the string is a hex number, optionally prefixed with \"0x\"\n */\n bool IsHexNumber(const std::string& str);\n-std::vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid = nullptr);\n-std::string DecodeBase64(const std::string& str);\n+std::vector<unsigned char> DecodeBase64(const char* p, bool* pf_invalid = nullptr);\n+std::string DecodeBase64(const std::string& str, bool* pf_invalid = nullptr);\n std::string EncodeBase64(const unsigned char* pch, size_t len);\n std::string EncodeBase64(const std::string& str);\n-std::vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid = nullptr);\n-std::string DecodeBase32(const std::string& str);\n+std::vector<unsigned char> DecodeBase32(const char* p, bool* pf_invalid = nullptr);\n+std::string DecodeBase32(const std::string& str, bool* pf_invalid = nullptr);\n std::string EncodeBase32(const unsigned char* pch, size_t len);\n std::string EncodeBase32(const std::string& str);\n "
      }
    ]
  },
  {
    "sha": "c734aaa15d924470cec0f17b00ad2e47472b471f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNzM0YWFhMTVkOTI0NDcwY2VjMGYxN2IwMGFkMmU0NzQ3MmI0NzFm",
    "commit": {
      "author": {
        "name": "Glenn Willen",
        "email": "gwillen@nerdnet.org",
        "date": "2019-01-30T05:32:38Z"
      },
      "committer": {
        "name": "Glenn Willen",
        "email": "gwillen@nerdnet.org",
        "date": "2019-02-11T20:23:14Z"
      },
      "message": "Split DecodePSBT into Base64 and Raw versions\n\nSplit up DecodePSBT, which both decodes base64 and then deserializes a\nPartiallySignedTransaction, into two functions: DecodeBase64PSBT, which retains\nthe old behavior, and DecodeRawPSBT, which only performs the deserialization.\n\nAdd a test for base64 decoding failure.",
      "tree": {
        "sha": "57a374ce9179e44ba453c2d48014b5375268f965",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/57a374ce9179e44ba453c2d48014b5375268f965"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c734aaa15d924470cec0f17b00ad2e47472b471f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c734aaa15d924470cec0f17b00ad2e47472b471f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c734aaa15d924470cec0f17b00ad2e47472b471f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c734aaa15d924470cec0f17b00ad2e47472b471f/comments",
    "author": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "162ffefd2f562169725559906601c25c579aa91c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/162ffefd2f562169725559906601c25c579aa91c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/162ffefd2f562169725559906601c25c579aa91c"
      }
    ],
    "stats": {
      "total": 33,
      "additions": 25,
      "deletions": 8
    },
    "files": [
      {
        "sha": "ae377eb6e811c592be63b14918677a8bf056524e",
        "filename": "src/core_io.h",
        "status": "modified",
        "additions": 5,
        "deletions": 1,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c734aaa15d924470cec0f17b00ad2e47472b471f/src/core_io.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c734aaa15d924470cec0f17b00ad2e47472b471f/src/core_io.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_io.h?ref=c734aaa15d924470cec0f17b00ad2e47472b471f",
        "patch": "@@ -37,7 +37,11 @@ bool DecodeHexBlockHeader(CBlockHeader&, const std::string& hex_header);\n  */\n bool ParseHashStr(const std::string& strHex, uint256& result);\n std::vector<unsigned char> ParseHexUV(const UniValue& v, const std::string& strName);\n-NODISCARD bool DecodePSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error);\n+\n+//! Decode a base64ed PSBT into a PartiallySignedTransaction\n+NODISCARD bool DecodeBase64PSBT(PartiallySignedTransaction& decoded_psbt, const std::string& base64_psbt, std::string& error);\n+//! Decode a raw (binary blob) PSBT into a PartiallySignedTransaction\n+NODISCARD bool DecodeRawPSBT(PartiallySignedTransaction& decoded_psbt, const std::string& raw_psbt, std::string& error);\n int ParseSighashString(const UniValue& sighash);\n \n // core_write.cpp"
      },
      {
        "sha": "0379098712fc5f70179c35f94e9ba2f54b41de66",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 13,
        "deletions": 3,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c734aaa15d924470cec0f17b00ad2e47472b471f/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c734aaa15d924470cec0f17b00ad2e47472b471f/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=c734aaa15d924470cec0f17b00ad2e47472b471f",
        "patch": "@@ -176,10 +176,20 @@ bool DecodeHexBlk(CBlock& block, const std::string& strHexBlk)\n     return true;\n }\n \n-bool DecodePSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error)\n+bool DecodeBase64PSBT(PartiallySignedTransaction& psbt, const std::string& base64_tx, std::string& error)\n {\n-    std::vector<unsigned char> tx_data = DecodeBase64(base64_tx.c_str());\n-    CDataStream ss_data(tx_data, SER_NETWORK, PROTOCOL_VERSION);\n+    bool invalid;\n+    std::string tx_data = DecodeBase64(base64_tx, &invalid);\n+    if (invalid) {\n+        error = \"invalid base64\";\n+        return false;\n+    }\n+    return DecodeRawPSBT(psbt, tx_data, error);\n+}\n+\n+bool DecodeRawPSBT(PartiallySignedTransaction& psbt, const std::string& tx_data, std::string& error)\n+{\n+    CDataStream ss_data(tx_data.data(), tx_data.data() + tx_data.size(), SER_NETWORK, PROTOCOL_VERSION);\n     try {\n         ss_data >> psbt;\n         if (!ss_data.empty()) {"
      },
      {
        "sha": "9dac989b977f4065de3ef332fa424486e30c05e1",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c734aaa15d924470cec0f17b00ad2e47472b471f/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c734aaa15d924470cec0f17b00ad2e47472b471f/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=c734aaa15d924470cec0f17b00ad2e47472b471f",
        "patch": "@@ -1323,7 +1323,7 @@ UniValue decodepsbt(const JSONRPCRequest& request)\n     // Unserialize the transactions\n     PartiallySignedTransaction psbtx;\n     std::string error;\n-    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n     }\n \n@@ -1524,7 +1524,7 @@ UniValue combinepsbt(const JSONRPCRequest& request)\n     for (unsigned int i = 0; i < txs.size(); ++i) {\n         PartiallySignedTransaction psbtx;\n         std::string error;\n-        if (!DecodePSBT(psbtx, txs[i].get_str(), error)) {\n+        if (!DecodeBase64PSBT(psbtx, txs[i].get_str(), error)) {\n             throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n         }\n         psbtxs.push_back(psbtx);\n@@ -1581,7 +1581,7 @@ UniValue finalizepsbt(const JSONRPCRequest& request)\n     // Unserialize the transactions\n     PartiallySignedTransaction psbtx;\n     std::string error;\n-    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n     }\n "
      },
      {
        "sha": "b01f40b125114f337a6976bc6f706e94b9f5aebf",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c734aaa15d924470cec0f17b00ad2e47472b471f/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c734aaa15d924470cec0f17b00ad2e47472b471f/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=c734aaa15d924470cec0f17b00ad2e47472b471f",
        "patch": "@@ -4046,7 +4046,7 @@ UniValue walletprocesspsbt(const JSONRPCRequest& request)\n     // Unserialize the transaction\n     PartiallySignedTransaction psbtx;\n     std::string error;\n-    if (!DecodePSBT(psbtx, request.params[0].get_str(), error)) {\n+    if (!DecodeBase64PSBT(psbtx, request.params[0].get_str(), error)) {\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n     }\n "
      },
      {
        "sha": "c98f1058282c9d22c47874b5bd8f4d3885e128b2",
        "filename": "test/functional/rpc_psbt.py",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c734aaa15d924470cec0f17b00ad2e47472b471f/test/functional/rpc_psbt.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c734aaa15d924470cec0f17b00ad2e47472b471f/test/functional/rpc_psbt.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/rpc_psbt.py?ref=c734aaa15d924470cec0f17b00ad2e47472b471f",
        "patch": "@@ -293,5 +293,8 @@ def run_test(self):\n         psbt = self.nodes[1].walletcreatefundedpsbt([], [{p2pkh : 1}], 0, {\"includeWatching\" : True}, True)\n         self.nodes[0].decodepsbt(psbt['psbt'])\n \n+        # Test decoding error: invalid base64\n+        assert_raises_rpc_error(-22, \"TX decode failed invalid base64\", self.nodes[0].decodepsbt, \";definitely not base64;\")\n+\n if __name__ == '__main__':\n     PSBTTest().main()"
      }
    ]
  },
  {
    "sha": "81cd9588484cb4f4050ea4e239da0681111795db",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MWNkOTU4ODQ4NGNiNGY0MDUwZWE0ZTIzOWRhMDY4MTExMTc5NWRi",
    "commit": {
      "author": {
        "name": "Glenn Willen",
        "email": "gwillen@nerdnet.org",
        "date": "2019-01-09T06:16:50Z"
      },
      "committer": {
        "name": "Glenn Willen",
        "email": "gwillen@nerdnet.org",
        "date": "2019-02-11T20:23:14Z"
      },
      "message": "Factor BroadcastTransaction out of sendrawtransaction\n\nFactor out a new BroadcastTransaction function, performing the core work of the\nsendrawtransaction rpc, so that it can be used from the GUI code. Move it from\nsrc/rpc/ to src/node/.",
      "tree": {
        "sha": "33f5789d3f2d831d2bfb4098b57a4dea3ec75aea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/33f5789d3f2d831d2bfb4098b57a4dea3ec75aea"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/81cd9588484cb4f4050ea4e239da0681111795db",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/81cd9588484cb4f4050ea4e239da0681111795db",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/81cd9588484cb4f4050ea4e239da0681111795db",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/81cd9588484cb4f4050ea4e239da0681111795db/comments",
    "author": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c734aaa15d924470cec0f17b00ad2e47472b471f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c734aaa15d924470cec0f17b00ad2e47472b471f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c734aaa15d924470cec0f17b00ad2e47472b471f"
      }
    ],
    "stats": {
      "total": 164,
      "additions": 99,
      "deletions": 65
    },
    "files": [
      {
        "sha": "9a87af2efcb452a311c9496522c020f11f969be5",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/81cd9588484cb4f4050ea4e239da0681111795db/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/81cd9588484cb4f4050ea4e239da0681111795db/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=81cd9588484cb4f4050ea4e239da0681111795db",
        "patch": "@@ -152,6 +152,7 @@ BITCOIN_CORE_H = \\\n   netaddress.h \\\n   netbase.h \\\n   netmessagemaker.h \\\n+  node/transaction.h \\\n   noui.h \\\n   optional.h \\\n   outputtype.h \\\n@@ -255,6 +256,7 @@ libbitcoin_server_a_SOURCES = \\\n   miner.cpp \\\n   net.cpp \\\n   net_processing.cpp \\\n+  node/transaction.cpp \\\n   noui.cpp \\\n   outputtype.cpp \\\n   policy/fees.cpp \\"
      },
      {
        "sha": "47c0323f146393600f4fda6fd5a551bc60fcd8df",
        "filename": "src/node/transaction.cpp",
        "status": "added",
        "additions": 79,
        "deletions": 0,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/81cd9588484cb4f4050ea4e239da0681111795db/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/81cd9588484cb4f4050ea4e239da0681111795db/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=81cd9588484cb4f4050ea4e239da0681111795db",
        "patch": "@@ -0,0 +1,79 @@\n+// Copyright (c) 2010 Satoshi Nakamoto\n+// Copyright (c) 2009-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <consensus/validation.h>\n+#include <net.h>\n+#include <rpc/server.h>\n+#include <txmempool.h>\n+#include <validation.h>\n+#include <validationinterface.h>\n+#include <node/transaction.h>\n+\n+#include <future>\n+\n+uint256 BroadcastTransaction(const CTransactionRef tx, const bool allowhighfees) {\n+    std::promise<void> promise;\n+    const uint256& hashTx = tx->GetHash();\n+\n+    CAmount nMaxRawTxFee = maxTxFee;\n+    if (allowhighfees)\n+        nMaxRawTxFee = 0;\n+\n+    { // cs_main scope\n+    LOCK(cs_main);\n+    CCoinsViewCache &view = *pcoinsTip;\n+    bool fHaveChain = false;\n+    for (size_t o = 0; !fHaveChain && o < tx->vout.size(); o++) {\n+        const Coin& existingCoin = view.AccessCoin(COutPoint(hashTx, o));\n+        fHaveChain = !existingCoin.IsSpent();\n+    }\n+    bool fHaveMempool = mempool.exists(hashTx);\n+    if (!fHaveMempool && !fHaveChain) {\n+        // push to local node and sync with wallets\n+        CValidationState state;\n+        bool fMissingInputs;\n+        if (!AcceptToMemoryPool(mempool, state, std::move(tx), &fMissingInputs,\n+                                nullptr /* plTxnReplaced */, false /* bypass_limits */, nMaxRawTxFee)) {\n+            if (state.IsInvalid()) {\n+                throw JSONRPCError(RPC_TRANSACTION_REJECTED, FormatStateMessage(state));\n+            } else {\n+                if (fMissingInputs) {\n+                    throw JSONRPCError(RPC_TRANSACTION_ERROR, \"Missing inputs\");\n+                }\n+                throw JSONRPCError(RPC_TRANSACTION_ERROR, FormatStateMessage(state));\n+            }\n+        } else {\n+            // If wallet is enabled, ensure that the wallet has been made aware\n+            // of the new transaction prior to returning. This prevents a race\n+            // where a user might call sendrawtransaction with a transaction\n+            // to/from their wallet, immediately call some wallet RPC, and get\n+            // a stale result because callbacks have not yet been processed.\n+            CallFunctionInValidationInterfaceQueue([&promise] {\n+                promise.set_value();\n+            });\n+        }\n+    } else if (fHaveChain) {\n+        throw JSONRPCError(RPC_TRANSACTION_ALREADY_IN_CHAIN, \"transaction already in block chain\");\n+    } else {\n+        // Make sure we don't block forever if re-sending\n+        // a transaction already in mempool.\n+        promise.set_value();\n+    }\n+\n+    } // cs_main\n+\n+    promise.get_future().wait();\n+\n+    if(!g_connman)\n+        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+\n+    CInv inv(MSG_TX, hashTx);\n+    g_connman->ForEachNode([&inv](CNode* pnode)\n+    {\n+        pnode->PushInventory(inv);\n+    });\n+\n+    return hashTx;\n+}"
      },
      {
        "sha": "1916c6db267e8b3f7fd891dc20d65a8addd46795",
        "filename": "src/node/transaction.h",
        "status": "added",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/81cd9588484cb4f4050ea4e239da0681111795db/src/node/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/81cd9588484cb4f4050ea4e239da0681111795db/src/node/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.h?ref=81cd9588484cb4f4050ea4e239da0681111795db",
        "patch": "@@ -0,0 +1,14 @@\n+// Copyright (c) 2017-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_NODE_TRANSACTION_H\n+#define BITCOIN_NODE_TRANSACTION_H\n+\n+#include <primitives/transaction.h>\n+#include <uint256.h>\n+\n+/** Broadcast a transaction */\n+uint256 BroadcastTransaction(CTransactionRef tx, bool allowhighfees = false);\n+\n+#endif // BITCOIN_NODE_TRANSACTION_H"
      },
      {
        "sha": "8e561c61846dbe86534a737f83e4d70a02715a62",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 65,
        "changes": 69,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/81cd9588484cb4f4050ea4e239da0681111795db/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/81cd9588484cb4f4050ea4e239da0681111795db/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=81cd9588484cb4f4050ea4e239da0681111795db",
        "patch": "@@ -13,7 +13,7 @@\n #include <key_io.h>\n #include <keystore.h>\n #include <merkleblock.h>\n-#include <net.h>\n+#include <node/transaction.h>\n #include <policy/policy.h>\n #include <policy/rbf.h>\n #include <primitives/transaction.h>\n@@ -24,13 +24,11 @@\n #include <script/script_error.h>\n #include <script/sign.h>\n #include <script/standard.h>\n-#include <txmempool.h>\n #include <uint256.h>\n #include <util/strencodings.h>\n #include <validation.h>\n #include <validationinterface.h>\n \n-#include <future>\n #include <stdint.h>\n \n #include <univalue.h>\n@@ -1041,76 +1039,17 @@ static UniValue sendrawtransaction(const JSONRPCRequest& request)\n                 },\n             }.ToString());\n \n-    std::promise<void> promise;\n-\n     RPCTypeCheck(request.params, {UniValue::VSTR, UniValue::VBOOL});\n \n     // parse hex string from parameter\n     CMutableTransaction mtx;\n     if (!DecodeHexTx(mtx, request.params[0].get_str()))\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"TX decode failed\");\n     CTransactionRef tx(MakeTransactionRef(std::move(mtx)));\n-    const uint256& hashTx = tx->GetHash();\n-\n-    CAmount nMaxRawTxFee = maxTxFee;\n-    if (!request.params[1].isNull() && request.params[1].get_bool())\n-        nMaxRawTxFee = 0;\n-\n-    { // cs_main scope\n-    LOCK(cs_main);\n-    CCoinsViewCache &view = *pcoinsTip;\n-    bool fHaveChain = false;\n-    for (size_t o = 0; !fHaveChain && o < tx->vout.size(); o++) {\n-        const Coin& existingCoin = view.AccessCoin(COutPoint(hashTx, o));\n-        fHaveChain = !existingCoin.IsSpent();\n-    }\n-    bool fHaveMempool = mempool.exists(hashTx);\n-    if (!fHaveMempool && !fHaveChain) {\n-        // push to local node and sync with wallets\n-        CValidationState state;\n-        bool fMissingInputs;\n-        if (!AcceptToMemoryPool(mempool, state, std::move(tx), &fMissingInputs,\n-                                nullptr /* plTxnReplaced */, false /* bypass_limits */, nMaxRawTxFee)) {\n-            if (state.IsInvalid()) {\n-                throw JSONRPCError(RPC_TRANSACTION_REJECTED, FormatStateMessage(state));\n-            } else {\n-                if (fMissingInputs) {\n-                    throw JSONRPCError(RPC_TRANSACTION_ERROR, \"Missing inputs\");\n-                }\n-                throw JSONRPCError(RPC_TRANSACTION_ERROR, FormatStateMessage(state));\n-            }\n-        } else {\n-            // If wallet is enabled, ensure that the wallet has been made aware\n-            // of the new transaction prior to returning. This prevents a race\n-            // where a user might call sendrawtransaction with a transaction\n-            // to/from their wallet, immediately call some wallet RPC, and get\n-            // a stale result because callbacks have not yet been processed.\n-            CallFunctionInValidationInterfaceQueue([&promise] {\n-                promise.set_value();\n-            });\n-        }\n-    } else if (fHaveChain) {\n-        throw JSONRPCError(RPC_TRANSACTION_ALREADY_IN_CHAIN, \"transaction already in block chain\");\n-    } else {\n-        // Make sure we don't block forever if re-sending\n-        // a transaction already in mempool.\n-        promise.set_value();\n-    }\n-\n-    } // cs_main\n-\n-    promise.get_future().wait();\n-\n-    if(!g_connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n-\n-    CInv inv(MSG_TX, hashTx);\n-    g_connman->ForEachNode([&inv](CNode* pnode)\n-    {\n-        pnode->PushInventory(inv);\n-    });\n \n-    return hashTx.GetHex();\n+    bool allowhighfees = false;\n+    if (!request.params[1].isNull()) allowhighfees = request.params[1].get_bool();\n+    return BroadcastTransaction(tx, allowhighfees).GetHex();\n }\n \n static UniValue testmempoolaccept(const JSONRPCRequest& request)"
      }
    ]
  },
  {
    "sha": "c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjNmMzZDQyYTdkNmI1MjUxNDRmYzdmYzY2NTNjZDExMTM5ZDJiMzRh",
    "commit": {
      "author": {
        "name": "Glenn Willen",
        "email": "gwillen@nerdnet.org",
        "date": "2019-01-09T10:06:29Z"
      },
      "committer": {
        "name": "Glenn Willen",
        "email": "gwillen@nerdnet.org",
        "date": "2019-02-11T20:23:14Z"
      },
      "message": "Move PSBT definitions and code to separate files\n\nMove non-wallet PSBT code to src/psbt.{h,cpp}, and PSBT wallet code to\nsrc/wallet/psbtwallet.{h,cpp}. This commit contains only code movement (and\nadjustments to includes and Makefile.am.)",
      "tree": {
        "sha": "861f35c6e35fce6509182384fe42007fe864e88c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/861f35c6e35fce6509182384fe42007fe864e88c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/comments",
    "author": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "81cd9588484cb4f4050ea4e239da0681111795db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/81cd9588484cb4f4050ea4e239da0681111795db",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/81cd9588484cb4f4050ea4e239da0681111795db"
      }
    ],
    "stats": {
      "total": 1678,
      "additions": 862,
      "deletions": 816
    },
    "files": [
      {
        "sha": "7490d8b7906e479ef8c450650845175c75b6e460",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
        "patch": "@@ -162,6 +162,7 @@ BITCOIN_CORE_H = \\\n   policy/rbf.h \\\n   pow.h \\\n   protocol.h \\\n+  psbt.h \\\n   random.h \\\n   reverse_iterator.h \\\n   reverselock.h \\\n@@ -210,6 +211,7 @@ BITCOIN_CORE_H = \\\n   wallet/db.h \\\n   wallet/feebumper.h \\\n   wallet/fees.h \\\n+  wallet/psbtwallet.h \\\n   wallet/rpcwallet.h \\\n   wallet/wallet.h \\\n   wallet/walletdb.h \\\n@@ -310,6 +312,7 @@ libbitcoin_wallet_a_SOURCES = \\\n   wallet/feebumper.cpp \\\n   wallet/fees.cpp \\\n   wallet/init.cpp \\\n+  wallet/psbtwallet.cpp \\\n   wallet/rpcdump.cpp \\\n   wallet/rpcwallet.cpp \\\n   wallet/wallet.cpp \\\n@@ -423,6 +426,7 @@ libbitcoin_common_a_SOURCES = \\\n   netaddress.cpp \\\n   netbase.cpp \\\n   policy/feerate.cpp \\\n+  psbt.cpp \\\n   protocol.cpp \\\n   scheduler.cpp \\\n   script/descriptor.cpp \\"
      },
      {
        "sha": "536a7f4f17d989ee0da301dab93be4ee58f61cf1",
        "filename": "src/core_read.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/core_read.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/core_read.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/core_read.cpp?ref=c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
        "patch": "@@ -4,6 +4,7 @@\n \n #include <core_io.h>\n \n+#include <psbt.h>\n #include <primitives/block.h>\n #include <primitives/transaction.h>\n #include <script/script.h>"
      },
      {
        "sha": "97fb39f1c8a97ff8caa995d31aca1685079b8866",
        "filename": "src/psbt.cpp",
        "status": "added",
        "additions": 227,
        "deletions": 0,
        "changes": 227,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/psbt.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/psbt.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/psbt.cpp?ref=c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
        "patch": "@@ -0,0 +1,227 @@\n+// Copyright (c) 2009-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <psbt.h>\n+#include <util/strencodings.h>\n+\n+PartiallySignedTransaction::PartiallySignedTransaction(const CMutableTransaction& tx) : tx(tx)\n+{\n+    inputs.resize(tx.vin.size());\n+    outputs.resize(tx.vout.size());\n+}\n+\n+bool PartiallySignedTransaction::IsNull() const\n+{\n+    return !tx && inputs.empty() && outputs.empty() && unknown.empty();\n+}\n+\n+void PartiallySignedTransaction::Merge(const PartiallySignedTransaction& psbt)\n+{\n+    for (unsigned int i = 0; i < inputs.size(); ++i) {\n+        inputs[i].Merge(psbt.inputs[i]);\n+    }\n+    for (unsigned int i = 0; i < outputs.size(); ++i) {\n+        outputs[i].Merge(psbt.outputs[i]);\n+    }\n+    unknown.insert(psbt.unknown.begin(), psbt.unknown.end());\n+}\n+\n+bool PartiallySignedTransaction::IsSane() const\n+{\n+    for (PSBTInput input : inputs) {\n+        if (!input.IsSane()) return false;\n+    }\n+    return true;\n+}\n+\n+bool PSBTInput::IsNull() const\n+{\n+    return !non_witness_utxo && witness_utxo.IsNull() && partial_sigs.empty() && unknown.empty() && hd_keypaths.empty() && redeem_script.empty() && witness_script.empty();\n+}\n+\n+void PSBTInput::FillSignatureData(SignatureData& sigdata) const\n+{\n+    if (!final_script_sig.empty()) {\n+        sigdata.scriptSig = final_script_sig;\n+        sigdata.complete = true;\n+    }\n+    if (!final_script_witness.IsNull()) {\n+        sigdata.scriptWitness = final_script_witness;\n+        sigdata.complete = true;\n+    }\n+    if (sigdata.complete) {\n+        return;\n+    }\n+\n+    sigdata.signatures.insert(partial_sigs.begin(), partial_sigs.end());\n+    if (!redeem_script.empty()) {\n+        sigdata.redeem_script = redeem_script;\n+    }\n+    if (!witness_script.empty()) {\n+        sigdata.witness_script = witness_script;\n+    }\n+    for (const auto& key_pair : hd_keypaths) {\n+        sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair);\n+    }\n+}\n+\n+void PSBTInput::FromSignatureData(const SignatureData& sigdata)\n+{\n+    if (sigdata.complete) {\n+        partial_sigs.clear();\n+        hd_keypaths.clear();\n+        redeem_script.clear();\n+        witness_script.clear();\n+\n+        if (!sigdata.scriptSig.empty()) {\n+            final_script_sig = sigdata.scriptSig;\n+        }\n+        if (!sigdata.scriptWitness.IsNull()) {\n+            final_script_witness = sigdata.scriptWitness;\n+        }\n+        return;\n+    }\n+\n+    partial_sigs.insert(sigdata.signatures.begin(), sigdata.signatures.end());\n+    if (redeem_script.empty() && !sigdata.redeem_script.empty()) {\n+        redeem_script = sigdata.redeem_script;\n+    }\n+    if (witness_script.empty() && !sigdata.witness_script.empty()) {\n+        witness_script = sigdata.witness_script;\n+    }\n+    for (const auto& entry : sigdata.misc_pubkeys) {\n+        hd_keypaths.emplace(entry.second);\n+    }\n+}\n+\n+void PSBTInput::Merge(const PSBTInput& input)\n+{\n+    if (!non_witness_utxo && input.non_witness_utxo) non_witness_utxo = input.non_witness_utxo;\n+    if (witness_utxo.IsNull() && !input.witness_utxo.IsNull()) {\n+        witness_utxo = input.witness_utxo;\n+        non_witness_utxo = nullptr; // Clear out any non-witness utxo when we set a witness one.\n+    }\n+\n+    partial_sigs.insert(input.partial_sigs.begin(), input.partial_sigs.end());\n+    hd_keypaths.insert(input.hd_keypaths.begin(), input.hd_keypaths.end());\n+    unknown.insert(input.unknown.begin(), input.unknown.end());\n+\n+    if (redeem_script.empty() && !input.redeem_script.empty()) redeem_script = input.redeem_script;\n+    if (witness_script.empty() && !input.witness_script.empty()) witness_script = input.witness_script;\n+    if (final_script_sig.empty() && !input.final_script_sig.empty()) final_script_sig = input.final_script_sig;\n+    if (final_script_witness.IsNull() && !input.final_script_witness.IsNull()) final_script_witness = input.final_script_witness;\n+}\n+\n+bool PSBTInput::IsSane() const\n+{\n+    // Cannot have both witness and non-witness utxos\n+    if (!witness_utxo.IsNull() && non_witness_utxo) return false;\n+\n+    // If we have a witness_script or a scriptWitness, we must also have a witness utxo\n+    if (!witness_script.empty() && witness_utxo.IsNull()) return false;\n+    if (!final_script_witness.IsNull() && witness_utxo.IsNull()) return false;\n+\n+    return true;\n+}\n+\n+void PSBTOutput::FillSignatureData(SignatureData& sigdata) const\n+{\n+    if (!redeem_script.empty()) {\n+        sigdata.redeem_script = redeem_script;\n+    }\n+    if (!witness_script.empty()) {\n+        sigdata.witness_script = witness_script;\n+    }\n+    for (const auto& key_pair : hd_keypaths) {\n+        sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair);\n+    }\n+}\n+\n+void PSBTOutput::FromSignatureData(const SignatureData& sigdata)\n+{\n+    if (redeem_script.empty() && !sigdata.redeem_script.empty()) {\n+        redeem_script = sigdata.redeem_script;\n+    }\n+    if (witness_script.empty() && !sigdata.witness_script.empty()) {\n+        witness_script = sigdata.witness_script;\n+    }\n+    for (const auto& entry : sigdata.misc_pubkeys) {\n+        hd_keypaths.emplace(entry.second);\n+    }\n+}\n+\n+bool PSBTOutput::IsNull() const\n+{\n+    return redeem_script.empty() && witness_script.empty() && hd_keypaths.empty() && unknown.empty();\n+}\n+\n+void PSBTOutput::Merge(const PSBTOutput& output)\n+{\n+    hd_keypaths.insert(output.hd_keypaths.begin(), output.hd_keypaths.end());\n+    unknown.insert(output.unknown.begin(), output.unknown.end());\n+\n+    if (redeem_script.empty() && !output.redeem_script.empty()) redeem_script = output.redeem_script;\n+    if (witness_script.empty() && !output.witness_script.empty()) witness_script = output.witness_script;\n+}\n+\n+bool PSBTInputSigned(PSBTInput& input)\n+{\n+    return !input.final_script_sig.empty() || !input.final_script_witness.IsNull();\n+}\n+\n+bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction& psbt, int index, int sighash)\n+{\n+    PSBTInput& input = psbt.inputs.at(index);\n+    const CMutableTransaction& tx = *psbt.tx;\n+\n+    if (PSBTInputSigned(input)) {\n+        return true;\n+    }\n+\n+    // Fill SignatureData with input info\n+    SignatureData sigdata;\n+    input.FillSignatureData(sigdata);\n+\n+    // Get UTXO\n+    bool require_witness_sig = false;\n+    CTxOut utxo;\n+\n+    // Verify input sanity, which checks that at most one of witness or non-witness utxos is provided.\n+    if (!input.IsSane()) {\n+        return false;\n+    }\n+\n+    if (input.non_witness_utxo) {\n+        // If we're taking our information from a non-witness UTXO, verify that it matches the prevout.\n+        COutPoint prevout = tx.vin[index].prevout;\n+        if (input.non_witness_utxo->GetHash() != prevout.hash) {\n+            return false;\n+        }\n+        utxo = input.non_witness_utxo->vout[prevout.n];\n+    } else if (!input.witness_utxo.IsNull()) {\n+        utxo = input.witness_utxo;\n+        // When we're taking our information from a witness UTXO, we can't verify it is actually data from\n+        // the output being spent. This is safe in case a witness signature is produced (which includes this\n+        // information directly in the hash), but not for non-witness signatures. Remember that we require\n+        // a witness signature in this situation.\n+        require_witness_sig = true;\n+    } else {\n+        return false;\n+    }\n+\n+    MutableTransactionSignatureCreator creator(&tx, index, utxo.nValue, sighash);\n+    sigdata.witness = false;\n+    bool sig_complete = ProduceSignature(provider, creator, utxo.scriptPubKey, sigdata);\n+    // Verify that a witness signature was produced in case one was required.\n+    if (require_witness_sig && !sigdata.witness) return false;\n+    input.FromSignatureData(sigdata);\n+\n+    // If we have a witness signature, use the smaller witness UTXO.\n+    if (sigdata.witness) {\n+        input.witness_utxo = utxo;\n+        input.non_witness_utxo = nullptr;\n+    }\n+\n+    return sig_complete;\n+}"
      },
      {
        "sha": "fbe55ca1006976136f8c38a11d0bfd7bbd776e55",
        "filename": "src/psbt.h",
        "status": "added",
        "additions": 553,
        "deletions": 0,
        "changes": 553,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/psbt.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/psbt.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/psbt.h?ref=c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
        "patch": "@@ -0,0 +1,553 @@\n+// Copyright (c) 2009-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_PSBT_H\n+#define BITCOIN_PSBT_H\n+\n+#include <attributes.h>\n+#include <primitives/transaction.h>\n+#include <pubkey.h>\n+#include <script/sign.h>\n+\n+// Magic bytes\n+static constexpr uint8_t PSBT_MAGIC_BYTES[5] = {'p', 's', 'b', 't', 0xff};\n+\n+// Global types\n+static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n+\n+// Input types\n+static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n+static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n+static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n+static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n+static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n+static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n+static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n+static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n+static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n+\n+// Output types\n+static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n+static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n+static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n+\n+// The separator is 0x00. Reading this in means that the unserializer can interpret it\n+// as a 0 length key which indicates that this is the separator. The separator has no value.\n+static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n+\n+/** A structure for PSBTs which contain per-input information */\n+struct PSBTInput\n+{\n+    CTransactionRef non_witness_utxo;\n+    CTxOut witness_utxo;\n+    CScript redeem_script;\n+    CScript witness_script;\n+    CScript final_script_sig;\n+    CScriptWitness final_script_witness;\n+    std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+    std::map<CKeyID, SigPair> partial_sigs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+    int sighash_type = 0;\n+\n+    bool IsNull() const;\n+    void FillSignatureData(SignatureData& sigdata) const;\n+    void FromSignatureData(const SignatureData& sigdata);\n+    void Merge(const PSBTInput& input);\n+    bool IsSane() const;\n+    PSBTInput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the utxo\n+        // If there is a non-witness utxo, then don't add the witness one.\n+        if (non_witness_utxo) {\n+            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n+            OverrideStream<Stream> os(&s, s.GetType(), s.GetVersion() | SERIALIZE_TRANSACTION_NO_WITNESS);\n+            SerializeToVector(os, non_witness_utxo);\n+        } else if (!witness_utxo.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n+            SerializeToVector(s, witness_utxo);\n+        }\n+\n+        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n+            // Write any partial signatures\n+            for (auto sig_pair : partial_sigs) {\n+                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n+                s << sig_pair.second.second;\n+            }\n+\n+            // Write the sighash type\n+            if (sighash_type > 0) {\n+                SerializeToVector(s, PSBT_IN_SIGHASH);\n+                SerializeToVector(s, sighash_type);\n+            }\n+\n+            // Write the redeem script\n+            if (!redeem_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n+                s << redeem_script;\n+            }\n+\n+            // Write the witness script\n+            if (!witness_script.empty()) {\n+                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n+                s << witness_script;\n+            }\n+\n+            // Write any hd keypaths\n+            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n+        }\n+\n+        // Write script sig\n+        if (!final_script_sig.empty()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n+            s << final_script_sig;\n+        }\n+        // write script witness\n+        if (!final_script_witness.IsNull()) {\n+            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n+            SerializeToVector(s, final_script_witness.stack);\n+        }\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        bool found_sep = false;\n+        while(!s.empty()) {\n+            // Read\n+            std::vector<unsigned char> key;\n+            s >> key;\n+\n+            // the key is empty if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key.empty()) {\n+                found_sep = true;\n+                break;\n+            }\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_IN_NON_WITNESS_UTXO:\n+                {\n+                    if (non_witness_utxo) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n+                    } else if (key.size() != 1) {\n+                        throw std::ios_base::failure(\"Non-witness utxo key is more than one byte type\");\n+                    }\n+                    // Set the stream to unserialize with witness since this is always a valid network transaction\n+                    OverrideStream<Stream> os(&s, s.GetType(), s.GetVersion() & ~SERIALIZE_TRANSACTION_NO_WITNESS);\n+                    UnserializeFromVector(os, non_witness_utxo);\n+                    break;\n+                }\n+                case PSBT_IN_WITNESS_UTXO:\n+                    if (!witness_utxo.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n+                    } else if (key.size() != 1) {\n+                        throw std::ios_base::failure(\"Witness utxo key is more than one byte type\");\n+                    }\n+                    UnserializeFromVector(s, witness_utxo);\n+                    break;\n+                case PSBT_IN_PARTIAL_SIG:\n+                {\n+                    // Make sure that the key is the size of pubkey + 1\n+                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n+                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n+                    }\n+                    // Read in the pubkey from key\n+                    CPubKey pubkey(key.begin() + 1, key.end());\n+                    if (!pubkey.IsFullyValid()) {\n+                       throw std::ios_base::failure(\"Invalid pubkey\");\n+                    }\n+                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n+                    }\n+\n+                    // Read in the signature from value\n+                    std::vector<unsigned char> sig;\n+                    s >> sig;\n+\n+                    // Add to list\n+                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, std::move(sig)));\n+                    break;\n+                }\n+                case PSBT_IN_SIGHASH:\n+                    if (sighash_type > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n+                    } else if (key.size() != 1) {\n+                        throw std::ios_base::failure(\"Sighash type key is more than one byte type\");\n+                    }\n+                    UnserializeFromVector(s, sighash_type);\n+                    break;\n+                case PSBT_IN_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n+                    } else if (key.size() != 1) {\n+                        throw std::ios_base::failure(\"Input redeemScript key is more than one byte type\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_IN_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n+                    } else if (key.size() != 1) {\n+                        throw std::ios_base::failure(\"Input witnessScript key is more than one byte type\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_IN_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTSIG:\n+                {\n+                    if (!final_script_sig.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n+                    } else if (key.size() != 1) {\n+                        throw std::ios_base::failure(\"Final scriptSig key is more than one byte type\");\n+                    }\n+                    s >> final_script_sig;\n+                    break;\n+                }\n+                case PSBT_IN_SCRIPTWITNESS:\n+                {\n+                    if (!final_script_witness.IsNull()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n+                    } else if (key.size() != 1) {\n+                        throw std::ios_base::failure(\"Final scriptWitness key is more than one byte type\");\n+                    }\n+                    UnserializeFromVector(s, final_script_witness.stack);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default:\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+            }\n+        }\n+\n+        if (!found_sep) {\n+            throw std::ios_base::failure(\"Separator is missing at the end of an input map\");\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTInput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A structure for PSBTs which contains per output information */\n+struct PSBTOutput\n+{\n+    CScript redeem_script;\n+    CScript witness_script;\n+    std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    void FillSignatureData(SignatureData& sigdata) const;\n+    void FromSignatureData(const SignatureData& sigdata);\n+    void Merge(const PSBTOutput& output);\n+    bool IsSane() const;\n+    PSBTOutput() {}\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+        // Write the redeem script\n+        if (!redeem_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n+            s << redeem_script;\n+        }\n+\n+        // Write the witness script\n+        if (!witness_script.empty()) {\n+            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n+            s << witness_script;\n+        }\n+\n+        // Write any hd keypaths\n+        SerializeHDKeypaths(s, hd_keypaths, PSBT_OUT_BIP32_DERIVATION);\n+\n+        // Write unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        s << PSBT_SEPARATOR;\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read loop\n+        bool found_sep = false;\n+        while(!s.empty()) {\n+            // Read\n+            std::vector<unsigned char> key;\n+            s >> key;\n+\n+            // the key is empty if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key.empty()) {\n+                found_sep = true;\n+                break;\n+            }\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_OUT_REDEEMSCRIPT:\n+                {\n+                    if (!redeem_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n+                    } else if (key.size() != 1) {\n+                        throw std::ios_base::failure(\"Output redeemScript key is more than one byte type\");\n+                    }\n+                    s >> redeem_script;\n+                    break;\n+                }\n+                case PSBT_OUT_WITNESSSCRIPT:\n+                {\n+                    if (!witness_script.empty()) {\n+                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n+                    } else if (key.size() != 1) {\n+                        throw std::ios_base::failure(\"Output witnessScript key is more than one byte type\");\n+                    }\n+                    s >> witness_script;\n+                    break;\n+                }\n+                case PSBT_OUT_BIP32_DERIVATION:\n+                {\n+                    DeserializeHDKeypaths(s, key, hd_keypaths);\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                    break;\n+                }\n+            }\n+        }\n+\n+        if (!found_sep) {\n+            throw std::ios_base::failure(\"Separator is missing at the end of an output map\");\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PSBTOutput(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** A version of CTransaction with the PSBT format*/\n+struct PartiallySignedTransaction\n+{\n+    boost::optional<CMutableTransaction> tx;\n+    std::vector<PSBTInput> inputs;\n+    std::vector<PSBTOutput> outputs;\n+    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n+\n+    bool IsNull() const;\n+    void Merge(const PartiallySignedTransaction& psbt);\n+    bool IsSane() const;\n+    PartiallySignedTransaction() {}\n+    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n+    explicit PartiallySignedTransaction(const CMutableTransaction& tx);\n+\n+    // Only checks if they refer to the same transaction\n+    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return a.tx->GetHash() == b.tx->GetHash();\n+    }\n+    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n+    {\n+        return !(a == b);\n+    }\n+\n+    template <typename Stream>\n+    inline void Serialize(Stream& s) const {\n+\n+        // magic bytes\n+        s << PSBT_MAGIC_BYTES;\n+\n+        // unsigned tx flag\n+        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n+\n+        // Write serialized tx to a stream\n+        OverrideStream<Stream> os(&s, s.GetType(), s.GetVersion() | SERIALIZE_TRANSACTION_NO_WITNESS);\n+        SerializeToVector(os, *tx);\n+\n+        // Write the unknown things\n+        for (auto& entry : unknown) {\n+            s << entry.first;\n+            s << entry.second;\n+        }\n+\n+        // Separator\n+        s << PSBT_SEPARATOR;\n+\n+        // Write inputs\n+        for (const PSBTInput& input : inputs) {\n+            s << input;\n+        }\n+        // Write outputs\n+        for (const PSBTOutput& output : outputs) {\n+            s << output;\n+        }\n+    }\n+\n+\n+    template <typename Stream>\n+    inline void Unserialize(Stream& s) {\n+        // Read the magic bytes\n+        uint8_t magic[5];\n+        s >> magic;\n+        if (!std::equal(magic, magic + 5, PSBT_MAGIC_BYTES)) {\n+            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n+        }\n+\n+        // Read global data\n+        bool found_sep = false;\n+        while(!s.empty()) {\n+            // Read\n+            std::vector<unsigned char> key;\n+            s >> key;\n+\n+            // the key is empty if that was actually a separator byte\n+            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n+            if (key.empty()) {\n+                found_sep = true;\n+                break;\n+            }\n+\n+            // First byte of key is the type\n+            unsigned char type = key[0];\n+\n+            // Do stuff based on type\n+            switch(type) {\n+                case PSBT_GLOBAL_UNSIGNED_TX:\n+                {\n+                    if (tx) {\n+                        throw std::ios_base::failure(\"Duplicate Key, unsigned tx already provided\");\n+                    } else if (key.size() != 1) {\n+                        throw std::ios_base::failure(\"Global unsigned tx key is more than one byte type\");\n+                    }\n+                    CMutableTransaction mtx;\n+                    // Set the stream to serialize with non-witness since this should always be non-witness\n+                    OverrideStream<Stream> os(&s, s.GetType(), s.GetVersion() | SERIALIZE_TRANSACTION_NO_WITNESS);\n+                    UnserializeFromVector(os, mtx);\n+                    tx = std::move(mtx);\n+                    // Make sure that all scriptSigs and scriptWitnesses are empty\n+                    for (const CTxIn& txin : tx->vin) {\n+                        if (!txin.scriptSig.empty() || !txin.scriptWitness.IsNull()) {\n+                            throw std::ios_base::failure(\"Unsigned tx does not have empty scriptSigs and scriptWitnesses.\");\n+                        }\n+                    }\n+                    break;\n+                }\n+                // Unknown stuff\n+                default: {\n+                    if (unknown.count(key) > 0) {\n+                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n+                    }\n+                    // Read in the value\n+                    std::vector<unsigned char> val_bytes;\n+                    s >> val_bytes;\n+                    unknown.emplace(std::move(key), std::move(val_bytes));\n+                }\n+            }\n+        }\n+\n+        if (!found_sep) {\n+            throw std::ios_base::failure(\"Separator is missing at the end of the global map\");\n+        }\n+\n+        // Make sure that we got an unsigned tx\n+        if (!tx) {\n+            throw std::ios_base::failure(\"No unsigned transcation was provided\");\n+        }\n+\n+        // Read input data\n+        unsigned int i = 0;\n+        while (!s.empty() && i < tx->vin.size()) {\n+            PSBTInput input;\n+            s >> input;\n+            inputs.push_back(input);\n+\n+            // Make sure the non-witness utxo matches the outpoint\n+            if (input.non_witness_utxo && input.non_witness_utxo->GetHash() != tx->vin[i].prevout.hash) {\n+                throw std::ios_base::failure(\"Non-witness UTXO does not match outpoint hash\");\n+            }\n+            ++i;\n+        }\n+        // Make sure that the number of inputs matches the number of inputs in the transaction\n+        if (inputs.size() != tx->vin.size()) {\n+            throw std::ios_base::failure(\"Inputs provided does not match the number of inputs in transaction.\");\n+        }\n+\n+        // Read output data\n+        i = 0;\n+        while (!s.empty() && i < tx->vout.size()) {\n+            PSBTOutput output;\n+            s >> output;\n+            outputs.push_back(output);\n+            ++i;\n+        }\n+        // Make sure that the number of outputs matches the number of outputs in the transaction\n+        if (outputs.size() != tx->vout.size()) {\n+            throw std::ios_base::failure(\"Outputs provided does not match the number of outputs in transaction.\");\n+        }\n+        // Sanity check\n+        if (!IsSane()) {\n+            throw std::ios_base::failure(\"PSBT is not sane.\");\n+        }\n+    }\n+\n+    template <typename Stream>\n+    PartiallySignedTransaction(deserialize_type, Stream& s) {\n+        Unserialize(s);\n+    }\n+};\n+\n+/** Checks whether a PSBTInput is already signed. */\n+bool PSBTInputSigned(PSBTInput& input);\n+\n+/** Signs a PSBTInput, verifying that all provided data matches what is being signed. */\n+bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction& psbt, int index, int sighash = SIGHASH_ALL);\n+\n+#endif // BITCOIN_PSBT_H"
      },
      {
        "sha": "03e38739a1c1857dfb0372bda365af2230b66629",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
        "patch": "@@ -17,6 +17,7 @@\n #include <policy/policy.h>\n #include <policy/rbf.h>\n #include <primitives/transaction.h>\n+#include <psbt.h>\n #include <rpc/rawtransaction.h>\n #include <rpc/server.h>\n #include <rpc/util.h>"
      },
      {
        "sha": "9d6a390ea2119b8f4d5874eceeeb620fef042343",
        "filename": "src/script/sign.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 221,
        "changes": 221,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/script/sign.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/script/sign.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.cpp?ref=c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
        "patch": "@@ -232,67 +232,6 @@ bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreato\n     return sigdata.complete;\n }\n \n-bool PSBTInputSigned(PSBTInput& input)\n-{\n-    return !input.final_script_sig.empty() || !input.final_script_witness.IsNull();\n-}\n-\n-bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction& psbt, int index, int sighash)\n-{\n-    PSBTInput& input = psbt.inputs.at(index);\n-    const CMutableTransaction& tx = *psbt.tx;\n-\n-    if (PSBTInputSigned(input)) {\n-        return true;\n-    }\n-\n-    // Fill SignatureData with input info\n-    SignatureData sigdata;\n-    input.FillSignatureData(sigdata);\n-\n-    // Get UTXO\n-    bool require_witness_sig = false;\n-    CTxOut utxo;\n-\n-    // Verify input sanity, which checks that at most one of witness or non-witness utxos is provided.\n-    if (!input.IsSane()) {\n-        return false;\n-    }\n-\n-    if (input.non_witness_utxo) {\n-        // If we're taking our information from a non-witness UTXO, verify that it matches the prevout.\n-        COutPoint prevout = tx.vin[index].prevout;\n-        if (input.non_witness_utxo->GetHash() != prevout.hash) {\n-            return false;\n-        }\n-        utxo = input.non_witness_utxo->vout[prevout.n];\n-    } else if (!input.witness_utxo.IsNull()) {\n-        utxo = input.witness_utxo;\n-        // When we're taking our information from a witness UTXO, we can't verify it is actually data from\n-        // the output being spent. This is safe in case a witness signature is produced (which includes this\n-        // information directly in the hash), but not for non-witness signatures. Remember that we require\n-        // a witness signature in this situation.\n-        require_witness_sig = true;\n-    } else {\n-        return false;\n-    }\n-\n-    MutableTransactionSignatureCreator creator(&tx, index, utxo.nValue, sighash);\n-    sigdata.witness = false;\n-    bool sig_complete = ProduceSignature(provider, creator, utxo.scriptPubKey, sigdata);\n-    // Verify that a witness signature was produced in case one was required.\n-    if (require_witness_sig && !sigdata.witness) return false;\n-    input.FromSignatureData(sigdata);\n-\n-    // If we have a witness signature, use the smaller witness UTXO.\n-    if (sigdata.witness) {\n-        input.witness_utxo = utxo;\n-        input.non_witness_utxo = nullptr;\n-    }\n-\n-    return sig_complete;\n-}\n-\n class SignatureExtractorChecker final : public BaseSignatureChecker\n {\n private:\n@@ -509,166 +448,6 @@ bool IsSolvable(const SigningProvider& provider, const CScript& script)\n     return false;\n }\n \n-PartiallySignedTransaction::PartiallySignedTransaction(const CMutableTransaction& tx) : tx(tx)\n-{\n-    inputs.resize(tx.vin.size());\n-    outputs.resize(tx.vout.size());\n-}\n-\n-bool PartiallySignedTransaction::IsNull() const\n-{\n-    return !tx && inputs.empty() && outputs.empty() && unknown.empty();\n-}\n-\n-void PartiallySignedTransaction::Merge(const PartiallySignedTransaction& psbt)\n-{\n-    for (unsigned int i = 0; i < inputs.size(); ++i) {\n-        inputs[i].Merge(psbt.inputs[i]);\n-    }\n-    for (unsigned int i = 0; i < outputs.size(); ++i) {\n-        outputs[i].Merge(psbt.outputs[i]);\n-    }\n-    unknown.insert(psbt.unknown.begin(), psbt.unknown.end());\n-}\n-\n-bool PartiallySignedTransaction::IsSane() const\n-{\n-    for (PSBTInput input : inputs) {\n-        if (!input.IsSane()) return false;\n-    }\n-    return true;\n-}\n-\n-bool PSBTInput::IsNull() const\n-{\n-    return !non_witness_utxo && witness_utxo.IsNull() && partial_sigs.empty() && unknown.empty() && hd_keypaths.empty() && redeem_script.empty() && witness_script.empty();\n-}\n-\n-void PSBTInput::FillSignatureData(SignatureData& sigdata) const\n-{\n-    if (!final_script_sig.empty()) {\n-        sigdata.scriptSig = final_script_sig;\n-        sigdata.complete = true;\n-    }\n-    if (!final_script_witness.IsNull()) {\n-        sigdata.scriptWitness = final_script_witness;\n-        sigdata.complete = true;\n-    }\n-    if (sigdata.complete) {\n-        return;\n-    }\n-\n-    sigdata.signatures.insert(partial_sigs.begin(), partial_sigs.end());\n-    if (!redeem_script.empty()) {\n-        sigdata.redeem_script = redeem_script;\n-    }\n-    if (!witness_script.empty()) {\n-        sigdata.witness_script = witness_script;\n-    }\n-    for (const auto& key_pair : hd_keypaths) {\n-        sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair);\n-    }\n-}\n-\n-void PSBTInput::FromSignatureData(const SignatureData& sigdata)\n-{\n-    if (sigdata.complete) {\n-        partial_sigs.clear();\n-        hd_keypaths.clear();\n-        redeem_script.clear();\n-        witness_script.clear();\n-\n-        if (!sigdata.scriptSig.empty()) {\n-            final_script_sig = sigdata.scriptSig;\n-        }\n-        if (!sigdata.scriptWitness.IsNull()) {\n-            final_script_witness = sigdata.scriptWitness;\n-        }\n-        return;\n-    }\n-\n-    partial_sigs.insert(sigdata.signatures.begin(), sigdata.signatures.end());\n-    if (redeem_script.empty() && !sigdata.redeem_script.empty()) {\n-        redeem_script = sigdata.redeem_script;\n-    }\n-    if (witness_script.empty() && !sigdata.witness_script.empty()) {\n-        witness_script = sigdata.witness_script;\n-    }\n-    for (const auto& entry : sigdata.misc_pubkeys) {\n-        hd_keypaths.emplace(entry.second);\n-    }\n-}\n-\n-void PSBTInput::Merge(const PSBTInput& input)\n-{\n-    if (!non_witness_utxo && input.non_witness_utxo) non_witness_utxo = input.non_witness_utxo;\n-    if (witness_utxo.IsNull() && !input.witness_utxo.IsNull()) {\n-        witness_utxo = input.witness_utxo;\n-        non_witness_utxo = nullptr; // Clear out any non-witness utxo when we set a witness one.\n-    }\n-\n-    partial_sigs.insert(input.partial_sigs.begin(), input.partial_sigs.end());\n-    hd_keypaths.insert(input.hd_keypaths.begin(), input.hd_keypaths.end());\n-    unknown.insert(input.unknown.begin(), input.unknown.end());\n-\n-    if (redeem_script.empty() && !input.redeem_script.empty()) redeem_script = input.redeem_script;\n-    if (witness_script.empty() && !input.witness_script.empty()) witness_script = input.witness_script;\n-    if (final_script_sig.empty() && !input.final_script_sig.empty()) final_script_sig = input.final_script_sig;\n-    if (final_script_witness.IsNull() && !input.final_script_witness.IsNull()) final_script_witness = input.final_script_witness;\n-}\n-\n-bool PSBTInput::IsSane() const\n-{\n-    // Cannot have both witness and non-witness utxos\n-    if (!witness_utxo.IsNull() && non_witness_utxo) return false;\n-\n-    // If we have a witness_script or a scriptWitness, we must also have a witness utxo\n-    if (!witness_script.empty() && witness_utxo.IsNull()) return false;\n-    if (!final_script_witness.IsNull() && witness_utxo.IsNull()) return false;\n-\n-    return true;\n-}\n-\n-void PSBTOutput::FillSignatureData(SignatureData& sigdata) const\n-{\n-    if (!redeem_script.empty()) {\n-        sigdata.redeem_script = redeem_script;\n-    }\n-    if (!witness_script.empty()) {\n-        sigdata.witness_script = witness_script;\n-    }\n-    for (const auto& key_pair : hd_keypaths) {\n-        sigdata.misc_pubkeys.emplace(key_pair.first.GetID(), key_pair);\n-    }\n-}\n-\n-void PSBTOutput::FromSignatureData(const SignatureData& sigdata)\n-{\n-    if (redeem_script.empty() && !sigdata.redeem_script.empty()) {\n-        redeem_script = sigdata.redeem_script;\n-    }\n-    if (witness_script.empty() && !sigdata.witness_script.empty()) {\n-        witness_script = sigdata.witness_script;\n-    }\n-    for (const auto& entry : sigdata.misc_pubkeys) {\n-        hd_keypaths.emplace(entry.second);\n-    }\n-}\n-\n-bool PSBTOutput::IsNull() const\n-{\n-    return redeem_script.empty() && witness_script.empty() && hd_keypaths.empty() && unknown.empty();\n-}\n-\n-void PSBTOutput::Merge(const PSBTOutput& output)\n-{\n-    hd_keypaths.insert(output.hd_keypaths.begin(), output.hd_keypaths.end());\n-    unknown.insert(output.unknown.begin(), output.unknown.end());\n-\n-    if (redeem_script.empty() && !output.redeem_script.empty()) redeem_script = output.redeem_script;\n-    if (witness_script.empty() && !output.witness_script.empty()) witness_script = output.witness_script;\n-}\n-\n bool HidingSigningProvider::GetCScript(const CScriptID& scriptid, CScript& script) const\n {\n     return m_provider->GetCScript(scriptid, script);"
      },
      {
        "sha": "64eb3eb8e5328516f30fe914ecb87bc65ff2f1e8",
        "filename": "src/script/sign.h",
        "status": "modified",
        "additions": 0,
        "deletions": 540,
        "changes": 540,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/script/sign.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/script/sign.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/sign.h?ref=c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
        "patch": "@@ -123,32 +123,6 @@ struct SignatureData {\n     void MergeSignatureData(SignatureData sigdata);\n };\n \n-// Magic bytes\n-static constexpr uint8_t PSBT_MAGIC_BYTES[5] = {'p', 's', 'b', 't', 0xff};\n-\n-// Global types\n-static constexpr uint8_t PSBT_GLOBAL_UNSIGNED_TX = 0x00;\n-\n-// Input types\n-static constexpr uint8_t PSBT_IN_NON_WITNESS_UTXO = 0x00;\n-static constexpr uint8_t PSBT_IN_WITNESS_UTXO = 0x01;\n-static constexpr uint8_t PSBT_IN_PARTIAL_SIG = 0x02;\n-static constexpr uint8_t PSBT_IN_SIGHASH = 0x03;\n-static constexpr uint8_t PSBT_IN_REDEEMSCRIPT = 0x04;\n-static constexpr uint8_t PSBT_IN_WITNESSSCRIPT = 0x05;\n-static constexpr uint8_t PSBT_IN_BIP32_DERIVATION = 0x06;\n-static constexpr uint8_t PSBT_IN_SCRIPTSIG = 0x07;\n-static constexpr uint8_t PSBT_IN_SCRIPTWITNESS = 0x08;\n-\n-// Output types\n-static constexpr uint8_t PSBT_OUT_REDEEMSCRIPT = 0x00;\n-static constexpr uint8_t PSBT_OUT_WITNESSSCRIPT = 0x01;\n-static constexpr uint8_t PSBT_OUT_BIP32_DERIVATION = 0x02;\n-\n-// The separator is 0x00. Reading this in means that the unserializer can interpret it\n-// as a 0 length key which indicates that this is the separator. The separator has no value.\n-static constexpr uint8_t PSBT_SEPARATOR = 0x00;\n-\n // Takes a stream and multiple arguments and serializes them as if first serialized into a vector and then into the stream\n // The resulting output into the stream has the total serialized length of all of the objects followed by all objects concatenated with each other.\n template<typename Stream, typename... X>\n@@ -223,527 +197,13 @@ void SerializeHDKeypaths(Stream& s, const std::map<CPubKey, KeyOriginInfo>& hd_k\n     }\n }\n \n-/** A structure for PSBTs which contain per-input information */\n-struct PSBTInput\n-{\n-    CTransactionRef non_witness_utxo;\n-    CTxOut witness_utxo;\n-    CScript redeem_script;\n-    CScript witness_script;\n-    CScript final_script_sig;\n-    CScriptWitness final_script_witness;\n-    std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n-    std::map<CKeyID, SigPair> partial_sigs;\n-    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n-    int sighash_type = 0;\n-\n-    bool IsNull() const;\n-    void FillSignatureData(SignatureData& sigdata) const;\n-    void FromSignatureData(const SignatureData& sigdata);\n-    void Merge(const PSBTInput& input);\n-    bool IsSane() const;\n-    PSBTInput() {}\n-\n-    template <typename Stream>\n-    inline void Serialize(Stream& s) const {\n-        // Write the utxo\n-        // If there is a non-witness utxo, then don't add the witness one.\n-        if (non_witness_utxo) {\n-            SerializeToVector(s, PSBT_IN_NON_WITNESS_UTXO);\n-            OverrideStream<Stream> os(&s, s.GetType(), s.GetVersion() | SERIALIZE_TRANSACTION_NO_WITNESS);\n-            SerializeToVector(os, non_witness_utxo);\n-        } else if (!witness_utxo.IsNull()) {\n-            SerializeToVector(s, PSBT_IN_WITNESS_UTXO);\n-            SerializeToVector(s, witness_utxo);\n-        }\n-\n-        if (final_script_sig.empty() && final_script_witness.IsNull()) {\n-            // Write any partial signatures\n-            for (auto sig_pair : partial_sigs) {\n-                SerializeToVector(s, PSBT_IN_PARTIAL_SIG, MakeSpan(sig_pair.second.first));\n-                s << sig_pair.second.second;\n-            }\n-\n-            // Write the sighash type\n-            if (sighash_type > 0) {\n-                SerializeToVector(s, PSBT_IN_SIGHASH);\n-                SerializeToVector(s, sighash_type);\n-            }\n-\n-            // Write the redeem script\n-            if (!redeem_script.empty()) {\n-                SerializeToVector(s, PSBT_IN_REDEEMSCRIPT);\n-                s << redeem_script;\n-            }\n-\n-            // Write the witness script\n-            if (!witness_script.empty()) {\n-                SerializeToVector(s, PSBT_IN_WITNESSSCRIPT);\n-                s << witness_script;\n-            }\n-\n-            // Write any hd keypaths\n-            SerializeHDKeypaths(s, hd_keypaths, PSBT_IN_BIP32_DERIVATION);\n-        }\n-\n-        // Write script sig\n-        if (!final_script_sig.empty()) {\n-            SerializeToVector(s, PSBT_IN_SCRIPTSIG);\n-            s << final_script_sig;\n-        }\n-        // write script witness\n-        if (!final_script_witness.IsNull()) {\n-            SerializeToVector(s, PSBT_IN_SCRIPTWITNESS);\n-            SerializeToVector(s, final_script_witness.stack);\n-        }\n-\n-        // Write unknown things\n-        for (auto& entry : unknown) {\n-            s << entry.first;\n-            s << entry.second;\n-        }\n-\n-        s << PSBT_SEPARATOR;\n-    }\n-\n-\n-    template <typename Stream>\n-    inline void Unserialize(Stream& s) {\n-        // Read loop\n-        bool found_sep = false;\n-        while(!s.empty()) {\n-            // Read\n-            std::vector<unsigned char> key;\n-            s >> key;\n-\n-            // the key is empty if that was actually a separator byte\n-            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n-            if (key.empty()) {\n-                found_sep = true;\n-                break;\n-            }\n-\n-            // First byte of key is the type\n-            unsigned char type = key[0];\n-\n-            // Do stuff based on type\n-            switch(type) {\n-                case PSBT_IN_NON_WITNESS_UTXO:\n-                {\n-                    if (non_witness_utxo) {\n-                        throw std::ios_base::failure(\"Duplicate Key, input non-witness utxo already provided\");\n-                    } else if (key.size() != 1) {\n-                        throw std::ios_base::failure(\"Non-witness utxo key is more than one byte type\");\n-                    }\n-                    // Set the stream to unserialize with witness since this is always a valid network transaction\n-                    OverrideStream<Stream> os(&s, s.GetType(), s.GetVersion() & ~SERIALIZE_TRANSACTION_NO_WITNESS);\n-                    UnserializeFromVector(os, non_witness_utxo);\n-                    break;\n-                }\n-                case PSBT_IN_WITNESS_UTXO:\n-                    if (!witness_utxo.IsNull()) {\n-                        throw std::ios_base::failure(\"Duplicate Key, input witness utxo already provided\");\n-                    } else if (key.size() != 1) {\n-                        throw std::ios_base::failure(\"Witness utxo key is more than one byte type\");\n-                    }\n-                    UnserializeFromVector(s, witness_utxo);\n-                    break;\n-                case PSBT_IN_PARTIAL_SIG:\n-                {\n-                    // Make sure that the key is the size of pubkey + 1\n-                    if (key.size() != CPubKey::PUBLIC_KEY_SIZE + 1 && key.size() != CPubKey::COMPRESSED_PUBLIC_KEY_SIZE + 1) {\n-                        throw std::ios_base::failure(\"Size of key was not the expected size for the type partial signature pubkey\");\n-                    }\n-                    // Read in the pubkey from key\n-                    CPubKey pubkey(key.begin() + 1, key.end());\n-                    if (!pubkey.IsFullyValid()) {\n-                       throw std::ios_base::failure(\"Invalid pubkey\");\n-                    }\n-                    if (partial_sigs.count(pubkey.GetID()) > 0) {\n-                        throw std::ios_base::failure(\"Duplicate Key, input partial signature for pubkey already provided\");\n-                    }\n-\n-                    // Read in the signature from value\n-                    std::vector<unsigned char> sig;\n-                    s >> sig;\n-\n-                    // Add to list\n-                    partial_sigs.emplace(pubkey.GetID(), SigPair(pubkey, std::move(sig)));\n-                    break;\n-                }\n-                case PSBT_IN_SIGHASH:\n-                    if (sighash_type > 0) {\n-                        throw std::ios_base::failure(\"Duplicate Key, input sighash type already provided\");\n-                    } else if (key.size() != 1) {\n-                        throw std::ios_base::failure(\"Sighash type key is more than one byte type\");\n-                    }\n-                    UnserializeFromVector(s, sighash_type);\n-                    break;\n-                case PSBT_IN_REDEEMSCRIPT:\n-                {\n-                    if (!redeem_script.empty()) {\n-                        throw std::ios_base::failure(\"Duplicate Key, input redeemScript already provided\");\n-                    } else if (key.size() != 1) {\n-                        throw std::ios_base::failure(\"Input redeemScript key is more than one byte type\");\n-                    }\n-                    s >> redeem_script;\n-                    break;\n-                }\n-                case PSBT_IN_WITNESSSCRIPT:\n-                {\n-                    if (!witness_script.empty()) {\n-                        throw std::ios_base::failure(\"Duplicate Key, input witnessScript already provided\");\n-                    } else if (key.size() != 1) {\n-                        throw std::ios_base::failure(\"Input witnessScript key is more than one byte type\");\n-                    }\n-                    s >> witness_script;\n-                    break;\n-                }\n-                case PSBT_IN_BIP32_DERIVATION:\n-                {\n-                    DeserializeHDKeypaths(s, key, hd_keypaths);\n-                    break;\n-                }\n-                case PSBT_IN_SCRIPTSIG:\n-                {\n-                    if (!final_script_sig.empty()) {\n-                        throw std::ios_base::failure(\"Duplicate Key, input final scriptSig already provided\");\n-                    } else if (key.size() != 1) {\n-                        throw std::ios_base::failure(\"Final scriptSig key is more than one byte type\");\n-                    }\n-                    s >> final_script_sig;\n-                    break;\n-                }\n-                case PSBT_IN_SCRIPTWITNESS:\n-                {\n-                    if (!final_script_witness.IsNull()) {\n-                        throw std::ios_base::failure(\"Duplicate Key, input final scriptWitness already provided\");\n-                    } else if (key.size() != 1) {\n-                        throw std::ios_base::failure(\"Final scriptWitness key is more than one byte type\");\n-                    }\n-                    UnserializeFromVector(s, final_script_witness.stack);\n-                    break;\n-                }\n-                // Unknown stuff\n-                default:\n-                    if (unknown.count(key) > 0) {\n-                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n-                    }\n-                    // Read in the value\n-                    std::vector<unsigned char> val_bytes;\n-                    s >> val_bytes;\n-                    unknown.emplace(std::move(key), std::move(val_bytes));\n-                    break;\n-            }\n-        }\n-\n-        if (!found_sep) {\n-            throw std::ios_base::failure(\"Separator is missing at the end of an input map\");\n-        }\n-    }\n-\n-    template <typename Stream>\n-    PSBTInput(deserialize_type, Stream& s) {\n-        Unserialize(s);\n-    }\n-};\n-\n-/** A structure for PSBTs which contains per output information */\n-struct PSBTOutput\n-{\n-    CScript redeem_script;\n-    CScript witness_script;\n-    std::map<CPubKey, KeyOriginInfo> hd_keypaths;\n-    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n-\n-    bool IsNull() const;\n-    void FillSignatureData(SignatureData& sigdata) const;\n-    void FromSignatureData(const SignatureData& sigdata);\n-    void Merge(const PSBTOutput& output);\n-    bool IsSane() const;\n-    PSBTOutput() {}\n-\n-    template <typename Stream>\n-    inline void Serialize(Stream& s) const {\n-        // Write the redeem script\n-        if (!redeem_script.empty()) {\n-            SerializeToVector(s, PSBT_OUT_REDEEMSCRIPT);\n-            s << redeem_script;\n-        }\n-\n-        // Write the witness script\n-        if (!witness_script.empty()) {\n-            SerializeToVector(s, PSBT_OUT_WITNESSSCRIPT);\n-            s << witness_script;\n-        }\n-\n-        // Write any hd keypaths\n-        SerializeHDKeypaths(s, hd_keypaths, PSBT_OUT_BIP32_DERIVATION);\n-\n-        // Write unknown things\n-        for (auto& entry : unknown) {\n-            s << entry.first;\n-            s << entry.second;\n-        }\n-\n-        s << PSBT_SEPARATOR;\n-    }\n-\n-\n-    template <typename Stream>\n-    inline void Unserialize(Stream& s) {\n-        // Read loop\n-        bool found_sep = false;\n-        while(!s.empty()) {\n-            // Read\n-            std::vector<unsigned char> key;\n-            s >> key;\n-\n-            // the key is empty if that was actually a separator byte\n-            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n-            if (key.empty()) {\n-                found_sep = true;\n-                break;\n-            }\n-\n-            // First byte of key is the type\n-            unsigned char type = key[0];\n-\n-            // Do stuff based on type\n-            switch(type) {\n-                case PSBT_OUT_REDEEMSCRIPT:\n-                {\n-                    if (!redeem_script.empty()) {\n-                        throw std::ios_base::failure(\"Duplicate Key, output redeemScript already provided\");\n-                    } else if (key.size() != 1) {\n-                        throw std::ios_base::failure(\"Output redeemScript key is more than one byte type\");\n-                    }\n-                    s >> redeem_script;\n-                    break;\n-                }\n-                case PSBT_OUT_WITNESSSCRIPT:\n-                {\n-                    if (!witness_script.empty()) {\n-                        throw std::ios_base::failure(\"Duplicate Key, output witnessScript already provided\");\n-                    } else if (key.size() != 1) {\n-                        throw std::ios_base::failure(\"Output witnessScript key is more than one byte type\");\n-                    }\n-                    s >> witness_script;\n-                    break;\n-                }\n-                case PSBT_OUT_BIP32_DERIVATION:\n-                {\n-                    DeserializeHDKeypaths(s, key, hd_keypaths);\n-                    break;\n-                }\n-                // Unknown stuff\n-                default: {\n-                    if (unknown.count(key) > 0) {\n-                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n-                    }\n-                    // Read in the value\n-                    std::vector<unsigned char> val_bytes;\n-                    s >> val_bytes;\n-                    unknown.emplace(std::move(key), std::move(val_bytes));\n-                    break;\n-                }\n-            }\n-        }\n-\n-        if (!found_sep) {\n-            throw std::ios_base::failure(\"Separator is missing at the end of an output map\");\n-        }\n-    }\n-\n-    template <typename Stream>\n-    PSBTOutput(deserialize_type, Stream& s) {\n-        Unserialize(s);\n-    }\n-};\n-\n-/** A version of CTransaction with the PSBT format*/\n-struct PartiallySignedTransaction\n-{\n-    boost::optional<CMutableTransaction> tx;\n-    std::vector<PSBTInput> inputs;\n-    std::vector<PSBTOutput> outputs;\n-    std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n-\n-    bool IsNull() const;\n-    void Merge(const PartiallySignedTransaction& psbt);\n-    bool IsSane() const;\n-    PartiallySignedTransaction() {}\n-    PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n-    explicit PartiallySignedTransaction(const CMutableTransaction& tx);\n-\n-    // Only checks if they refer to the same transaction\n-    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n-    {\n-        return a.tx->GetHash() == b.tx->GetHash();\n-    }\n-    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n-    {\n-        return !(a == b);\n-    }\n-\n-    template <typename Stream>\n-    inline void Serialize(Stream& s) const {\n-\n-        // magic bytes\n-        s << PSBT_MAGIC_BYTES;\n-\n-        // unsigned tx flag\n-        SerializeToVector(s, PSBT_GLOBAL_UNSIGNED_TX);\n-\n-        // Write serialized tx to a stream\n-        OverrideStream<Stream> os(&s, s.GetType(), s.GetVersion() | SERIALIZE_TRANSACTION_NO_WITNESS);\n-        SerializeToVector(os, *tx);\n-\n-        // Write the unknown things\n-        for (auto& entry : unknown) {\n-            s << entry.first;\n-            s << entry.second;\n-        }\n-\n-        // Separator\n-        s << PSBT_SEPARATOR;\n-\n-        // Write inputs\n-        for (const PSBTInput& input : inputs) {\n-            s << input;\n-        }\n-        // Write outputs\n-        for (const PSBTOutput& output : outputs) {\n-            s << output;\n-        }\n-    }\n-\n-\n-    template <typename Stream>\n-    inline void Unserialize(Stream& s) {\n-        // Read the magic bytes\n-        uint8_t magic[5];\n-        s >> magic;\n-        if (!std::equal(magic, magic + 5, PSBT_MAGIC_BYTES)) {\n-            throw std::ios_base::failure(\"Invalid PSBT magic bytes\");\n-        }\n-\n-        // Read global data\n-        bool found_sep = false;\n-        while(!s.empty()) {\n-            // Read\n-            std::vector<unsigned char> key;\n-            s >> key;\n-\n-            // the key is empty if that was actually a separator byte\n-            // This is a special case for key lengths 0 as those are not allowed (except for separator)\n-            if (key.empty()) {\n-                found_sep = true;\n-                break;\n-            }\n-\n-            // First byte of key is the type\n-            unsigned char type = key[0];\n-\n-            // Do stuff based on type\n-            switch(type) {\n-                case PSBT_GLOBAL_UNSIGNED_TX:\n-                {\n-                    if (tx) {\n-                        throw std::ios_base::failure(\"Duplicate Key, unsigned tx already provided\");\n-                    } else if (key.size() != 1) {\n-                        throw std::ios_base::failure(\"Global unsigned tx key is more than one byte type\");\n-                    }\n-                    CMutableTransaction mtx;\n-                    // Set the stream to serialize with non-witness since this should always be non-witness\n-                    OverrideStream<Stream> os(&s, s.GetType(), s.GetVersion() | SERIALIZE_TRANSACTION_NO_WITNESS);\n-                    UnserializeFromVector(os, mtx);\n-                    tx = std::move(mtx);\n-                    // Make sure that all scriptSigs and scriptWitnesses are empty\n-                    for (const CTxIn& txin : tx->vin) {\n-                        if (!txin.scriptSig.empty() || !txin.scriptWitness.IsNull()) {\n-                            throw std::ios_base::failure(\"Unsigned tx does not have empty scriptSigs and scriptWitnesses.\");\n-                        }\n-                    }\n-                    break;\n-                }\n-                // Unknown stuff\n-                default: {\n-                    if (unknown.count(key) > 0) {\n-                        throw std::ios_base::failure(\"Duplicate Key, key for unknown value already provided\");\n-                    }\n-                    // Read in the value\n-                    std::vector<unsigned char> val_bytes;\n-                    s >> val_bytes;\n-                    unknown.emplace(std::move(key), std::move(val_bytes));\n-                }\n-            }\n-        }\n-\n-        if (!found_sep) {\n-            throw std::ios_base::failure(\"Separator is missing at the end of the global map\");\n-        }\n-\n-        // Make sure that we got an unsigned tx\n-        if (!tx) {\n-            throw std::ios_base::failure(\"No unsigned transcation was provided\");\n-        }\n-\n-        // Read input data\n-        unsigned int i = 0;\n-        while (!s.empty() && i < tx->vin.size()) {\n-            PSBTInput input;\n-            s >> input;\n-            inputs.push_back(input);\n-\n-            // Make sure the non-witness utxo matches the outpoint\n-            if (input.non_witness_utxo && input.non_witness_utxo->GetHash() != tx->vin[i].prevout.hash) {\n-                throw std::ios_base::failure(\"Non-witness UTXO does not match outpoint hash\");\n-            }\n-            ++i;\n-        }\n-        // Make sure that the number of inputs matches the number of inputs in the transaction\n-        if (inputs.size() != tx->vin.size()) {\n-            throw std::ios_base::failure(\"Inputs provided does not match the number of inputs in transaction.\");\n-        }\n-\n-        // Read output data\n-        i = 0;\n-        while (!s.empty() && i < tx->vout.size()) {\n-            PSBTOutput output;\n-            s >> output;\n-            outputs.push_back(output);\n-            ++i;\n-        }\n-        // Make sure that the number of outputs matches the number of outputs in the transaction\n-        if (outputs.size() != tx->vout.size()) {\n-            throw std::ios_base::failure(\"Outputs provided does not match the number of outputs in transaction.\");\n-        }\n-        // Sanity check\n-        if (!IsSane()) {\n-            throw std::ios_base::failure(\"PSBT is not sane.\");\n-        }\n-    }\n-\n-    template <typename Stream>\n-    PartiallySignedTransaction(deserialize_type, Stream& s) {\n-        Unserialize(s);\n-    }\n-};\n-\n /** Produce a script signature using a generic signature creator. */\n bool ProduceSignature(const SigningProvider& provider, const BaseSignatureCreator& creator, const CScript& scriptPubKey, SignatureData& sigdata);\n \n /** Produce a script signature for a transaction. */\n bool SignSignature(const SigningProvider &provider, const CScript& fromPubKey, CMutableTransaction& txTo, unsigned int nIn, const CAmount& amount, int nHashType);\n bool SignSignature(const SigningProvider &provider, const CTransaction& txFrom, CMutableTransaction& txTo, unsigned int nIn, int nHashType);\n \n-/** Checks whether a PSBTInput is already signed. */\n-bool PSBTInputSigned(PSBTInput& input);\n-\n-/** Signs a PSBTInput, verifying that all provided data matches what is being signed. */\n-bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction& psbt, int index, int sighash = SIGHASH_ALL);\n-\n /** Extract signature data from a transaction input, and insert it. */\n SignatureData DataFromTransaction(const CMutableTransaction& tx, unsigned int nIn, const CTxOut& txout);\n void UpdateInput(CTxIn& input, const SignatureData& data);"
      },
      {
        "sha": "a62ad0837003e569ea6d7011d5f5d2ede52c59e6",
        "filename": "src/wallet/psbtwallet.cpp",
        "status": "added",
        "additions": 60,
        "deletions": 0,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/wallet/psbtwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/wallet/psbtwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/psbtwallet.cpp?ref=c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
        "patch": "@@ -0,0 +1,60 @@\n+// Copyright (c) 2009-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <rpc/protocol.h>\n+#include <wallet/psbtwallet.h>\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, int sighash_type, bool sign, bool bip32derivs)\n+{\n+    LOCK(pwallet->cs_wallet);\n+    // Get all of the previous transactions\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        const CTxIn& txin = psbtx.tx->vin[i];\n+        PSBTInput& input = psbtx.inputs.at(i);\n+\n+        if (PSBTInputSigned(input)) {\n+            continue;\n+        }\n+\n+        // Verify input looks sane. This will check that we have at most one uxto, witness or non-witness.\n+        if (!input.IsSane()) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"PSBT input is not sane.\");\n+        }\n+\n+        // If we have no utxo, grab it from the wallet.\n+        if (!input.non_witness_utxo && input.witness_utxo.IsNull()) {\n+            const uint256& txhash = txin.prevout.hash;\n+            const auto it = pwallet->mapWallet.find(txhash);\n+            if (it != pwallet->mapWallet.end()) {\n+                const CWalletTx& wtx = it->second;\n+                // We only need the non_witness_utxo, which is a superset of the witness_utxo.\n+                //   The signing code will switch to the smaller witness_utxo if this is ok.\n+                input.non_witness_utxo = wtx.tx;\n+            }\n+        }\n+\n+        // Get the Sighash type\n+        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n+            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+        }\n+\n+        complete &= SignPSBTInput(HidingSigningProvider(pwallet, !sign, !bip32derivs), psbtx, i, sighash_type);\n+    }\n+\n+    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n+    for (unsigned int i = 0; i < psbtx.tx->vout.size(); ++i) {\n+        const CTxOut& out = psbtx.tx->vout.at(i);\n+        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n+\n+        // Fill a SignatureData with output info\n+        SignatureData sigdata;\n+        psbt_out.FillSignatureData(sigdata);\n+\n+        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n+        ProduceSignature(HidingSigningProvider(pwallet, true, !bip32derivs), creator, out.scriptPubKey, sigdata);\n+        psbt_out.FromSignatureData(sigdata);\n+    }\n+    return complete;\n+}"
      },
      {
        "sha": "4f888a06ec63b2226fe86a792218b8e5c0b5e568",
        "filename": "src/wallet/psbtwallet.h",
        "status": "added",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/wallet/psbtwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/wallet/psbtwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/psbtwallet.h?ref=c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
        "patch": "@@ -0,0 +1,14 @@\n+// Copyright (c) 2009-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_WALLET_PSBTWALLET_H\n+#define BITCOIN_WALLET_PSBTWALLET_H\n+\n+#include <psbt.h>\n+#include <primitives/transaction.h>\n+#include <wallet/wallet.h>\n+\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, int sighash_type = 1 /* SIGHASH_ALL */, bool sign = true, bool bip32derivs = false);\n+\n+#endif // BITCOIN_WALLET_PSBTWALLET_H"
      },
      {
        "sha": "905b18330758746c09aee14a68acfcaedc320ea6",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 54,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
        "patch": "@@ -30,6 +30,7 @@\n #include <util/moneystr.h>\n #include <wallet/coincontrol.h>\n #include <wallet/feebumper.h>\n+#include <wallet/psbtwallet.h>\n #include <wallet/rpcwallet.h>\n #include <wallet/wallet.h>\n #include <wallet/walletdb.h>\n@@ -3948,60 +3949,6 @@ void AddKeypathToMap(const CWallet* pwallet, const CKeyID& keyID, std::map<CPubK\n     hd_keypaths.emplace(vchPubKey, std::move(info));\n }\n \n-bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, int sighash_type, bool sign, bool bip32derivs)\n-{\n-    LOCK(pwallet->cs_wallet);\n-    // Get all of the previous transactions\n-    bool complete = true;\n-    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n-        const CTxIn& txin = psbtx.tx->vin[i];\n-        PSBTInput& input = psbtx.inputs.at(i);\n-\n-        if (PSBTInputSigned(input)) {\n-            continue;\n-        }\n-\n-        // Verify input looks sane. This will check that we have at most one uxto, witness or non-witness.\n-        if (!input.IsSane()) {\n-            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"PSBT input is not sane.\");\n-        }\n-\n-        // If we have no utxo, grab it from the wallet.\n-        if (!input.non_witness_utxo && input.witness_utxo.IsNull()) {\n-            const uint256& txhash = txin.prevout.hash;\n-            const auto it = pwallet->mapWallet.find(txhash);\n-            if (it != pwallet->mapWallet.end()) {\n-                const CWalletTx& wtx = it->second;\n-                // We only need the non_witness_utxo, which is a superset of the witness_utxo.\n-                //   The signing code will switch to the smaller witness_utxo if this is ok.\n-                input.non_witness_utxo = wtx.tx;\n-            }\n-        }\n-\n-        // Get the Sighash type\n-        if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n-            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n-        }\n-\n-        complete &= SignPSBTInput(HidingSigningProvider(pwallet, !sign, !bip32derivs), psbtx, i, sighash_type);\n-    }\n-\n-    // Fill in the bip32 keypaths and redeemscripts for the outputs so that hardware wallets can identify change\n-    for (unsigned int i = 0; i < psbtx.tx->vout.size(); ++i) {\n-        const CTxOut& out = psbtx.tx->vout.at(i);\n-        PSBTOutput& psbt_out = psbtx.outputs.at(i);\n-\n-        // Fill a SignatureData with output info\n-        SignatureData sigdata;\n-        psbt_out.FillSignatureData(sigdata);\n-\n-        MutableTransactionSignatureCreator creator(psbtx.tx.get_ptr(), 0, out.nValue, 1);\n-        ProduceSignature(HidingSigningProvider(pwallet, true, !bip32derivs), creator, out.scriptPubKey, sigdata);\n-        psbt_out.FromSignatureData(sigdata);\n-    }\n-    return complete;\n-}\n-\n UniValue walletprocesspsbt(const JSONRPCRequest& request)\n {\n     std::shared_ptr<CWallet> const wallet = GetWalletForJSONRPCRequest(request);"
      },
      {
        "sha": "58053bde59a4e8939574d767823523fe0316a97d",
        "filename": "src/wallet/rpcwallet.h",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/wallet/rpcwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/wallet/rpcwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.h?ref=c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
        "patch": "@@ -30,5 +30,4 @@ bool EnsureWalletIsAvailable(CWallet *, bool avoidException);\n \n UniValue getaddressinfo(const JSONRPCRequest& request);\n UniValue signrawtransactionwithwallet(const JSONRPCRequest& request);\n-bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, int sighash_type = 1 /* SIGHASH_ALL */, bool sign = true, bool bip32derivs = false);\n #endif //BITCOIN_WALLET_RPCWALLET_H"
      },
      {
        "sha": "0c5b7c7e98c3fc7186ab2838629ebb4a9b204235",
        "filename": "src/wallet/test/psbt_wallet_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/wallet/test/psbt_wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a/src/wallet/test/psbt_wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/psbt_wallet_tests.cpp?ref=c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
        "patch": "@@ -5,6 +5,7 @@\n #include <key_io.h>\n #include <script/sign.h>\n #include <util/strencodings.h>\n+#include <wallet/psbtwallet.h>\n #include <wallet/rpcwallet.h>\n #include <wallet/wallet.h>\n #include <univalue.h>"
      }
    ]
  },
  {
    "sha": "bd0dbe8763fc3029cf96531c9ccaba280b939445",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZDBkYmU4NzYzZmMzMDI5Y2Y5NjUzMWM5Y2NhYmEyODBiOTM5NDQ1",
    "commit": {
      "author": {
        "name": "Glenn Willen",
        "email": "gwillen@nerdnet.org",
        "date": "2019-02-10T04:51:33Z"
      },
      "committer": {
        "name": "Glenn Willen",
        "email": "gwillen@nerdnet.org",
        "date": "2019-02-11T22:08:04Z"
      },
      "message": "Switch away from exceptions in refactored tx code\n\nAfter refactoring general-purpose PSBT and transaction code out of RPC code,\nfor use in the GUI, it's no longer appropriate to throw exceptions. Instead we\nnow return bools for success, and take an output parameter for an error object.\nWe still use JSONRPCError() for the error objects, since only RPC callers\nactually care about the error codes.",
      "tree": {
        "sha": "f9ac966b3363bec18db36714ffc37ec3c36dd4be",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f9ac966b3363bec18db36714ffc37ec3c36dd4be"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bd0dbe8763fc3029cf96531c9ccaba280b939445",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd0dbe8763fc3029cf96531c9ccaba280b939445",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bd0dbe8763fc3029cf96531c9ccaba280b939445",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd0dbe8763fc3029cf96531c9ccaba280b939445/comments",
    "author": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c6c3d42a7d6b525144fc7fc6653cd11139d2b34a"
      }
    ],
    "stats": {
      "total": 183,
      "additions": 159,
      "deletions": 24
    },
    "files": [
      {
        "sha": "6c4efb3d26e297cc35fefb79fb9f121d6ad0f9f4",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 11,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=bd0dbe8763fc3029cf96531c9ccaba280b939445",
        "patch": "@@ -5,17 +5,43 @@\n \n #include <consensus/validation.h>\n #include <net.h>\n-#include <rpc/server.h>\n #include <txmempool.h>\n #include <validation.h>\n #include <validationinterface.h>\n #include <node/transaction.h>\n \n #include <future>\n \n-uint256 BroadcastTransaction(const CTransactionRef tx, const bool allowhighfees) {\n+const char* TransactionErrorString(const TransactionError err)\n+{\n+    switch (err) {\n+        case TransactionError::OK:\n+            return \"No error\";\n+        case TransactionError::MISSING_INPUTS:\n+            return \"Missing inputs\";\n+        case TransactionError::ALREADY_IN_CHAIN:\n+            return \"Transaction already in block chain\";\n+        case TransactionError::P2P_DISABLED:\n+            return \"Peer-to-peer functionality missing or disabled\";\n+        case TransactionError::MEMPOOL_REJECTED:\n+            return \"Transaction rejected by AcceptToMemoryPool\";\n+        case TransactionError::MEMPOOL_ERROR:\n+            return \"AcceptToMemoryPool failed\";\n+        case TransactionError::INVALID_PSBT:\n+            return \"PSBT is not sane\";\n+        case TransactionError::SIGHASH_MISMATCH:\n+            return \"Specified sighash value does not match existing value\";\n+\n+        case TransactionError::UNKNOWN_ERROR:\n+        default: break;\n+    }\n+    return \"Unknown error\";\n+}\n+\n+bool BroadcastTransaction(const CTransactionRef tx, uint256& hashTx, TransactionError& error, std::string& err_string, const bool allowhighfees)\n+{\n     std::promise<void> promise;\n-    const uint256& hashTx = tx->GetHash();\n+    hashTx = tx->GetHash();\n \n     CAmount nMaxRawTxFee = maxTxFee;\n     if (allowhighfees)\n@@ -37,12 +63,17 @@ uint256 BroadcastTransaction(const CTransactionRef tx, const bool allowhighfees)\n         if (!AcceptToMemoryPool(mempool, state, std::move(tx), &fMissingInputs,\n                                 nullptr /* plTxnReplaced */, false /* bypass_limits */, nMaxRawTxFee)) {\n             if (state.IsInvalid()) {\n-                throw JSONRPCError(RPC_TRANSACTION_REJECTED, FormatStateMessage(state));\n+                err_string = FormatStateMessage(state);\n+                error = TransactionError::MEMPOOL_REJECTED;\n+                return false;\n             } else {\n                 if (fMissingInputs) {\n-                    throw JSONRPCError(RPC_TRANSACTION_ERROR, \"Missing inputs\");\n+                    error = TransactionError::MISSING_INPUTS;\n+                    return false;\n                 }\n-                throw JSONRPCError(RPC_TRANSACTION_ERROR, FormatStateMessage(state));\n+                err_string = FormatStateMessage(state);\n+                error = TransactionError::MEMPOOL_ERROR;\n+                return false;\n             }\n         } else {\n             // If wallet is enabled, ensure that the wallet has been made aware\n@@ -55,7 +86,8 @@ uint256 BroadcastTransaction(const CTransactionRef tx, const bool allowhighfees)\n             });\n         }\n     } else if (fHaveChain) {\n-        throw JSONRPCError(RPC_TRANSACTION_ALREADY_IN_CHAIN, \"transaction already in block chain\");\n+        error = TransactionError::ALREADY_IN_CHAIN;\n+        return false;\n     } else {\n         // Make sure we don't block forever if re-sending\n         // a transaction already in mempool.\n@@ -66,14 +98,16 @@ uint256 BroadcastTransaction(const CTransactionRef tx, const bool allowhighfees)\n \n     promise.get_future().wait();\n \n-    if(!g_connman)\n-        throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n+    if(!g_connman) {\n+        error = TransactionError::P2P_DISABLED;\n+        return false;\n+    }\n \n     CInv inv(MSG_TX, hashTx);\n     g_connman->ForEachNode([&inv](CNode* pnode)\n     {\n         pnode->PushInventory(inv);\n     });\n \n-    return hashTx;\n-}\n+    return true;\n+    }"
      },
      {
        "sha": "83354d9400f1c974a88c7a9c605cb515ded31105",
        "filename": "src/node/transaction.h",
        "status": "modified",
        "additions": 30,
        "deletions": 2,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/node/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/node/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.h?ref=bd0dbe8763fc3029cf96531c9ccaba280b939445",
        "patch": "@@ -8,7 +8,35 @@\n #include <primitives/transaction.h>\n #include <uint256.h>\n \n-/** Broadcast a transaction */\n-uint256 BroadcastTransaction(CTransactionRef tx, bool allowhighfees = false);\n+enum class TransactionError {\n+    OK = 0,\n+    UNKNOWN_ERROR,\n+\n+    MISSING_INPUTS,\n+    ALREADY_IN_CHAIN,\n+    P2P_DISABLED,\n+    MEMPOOL_REJECTED,\n+    MEMPOOL_ERROR,\n+    INVALID_PSBT,\n+    SIGHASH_MISMATCH,\n+\n+    ERROR_COUNT\n+};\n+\n+#define TRANSACTION_ERR_LAST TransactionError::ERROR_COUNT\n+\n+const char* TransactionErrorString(const TransactionError error);\n+\n+/**\n+ * Broadcast a transaction\n+ *\n+ * @param[in]  tx the transaction to broadcast\n+ * @param[out] &txid the txid of the transaction, if successfully broadcast\n+ * @param[out] &error reference to UniValue to fill with error info on failure\n+ * @param[out] &err_string reference to std::string to fill with error string if available\n+ * @param[in]  allowhighfees whether to allow fees exceeding maxTxFee\n+ * return true on success, false on error (and fills in `error`)\n+ */\n+bool BroadcastTransaction(CTransactionRef tx, uint256& txid, TransactionError& error, std::string& err_string, bool allowhighfees = false);\n \n #endif // BITCOIN_NODE_TRANSACTION_H"
      },
      {
        "sha": "ad6f0030157250ce7487ca30de1c526592ec1521",
        "filename": "src/psbt.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/psbt.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/psbt.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/psbt.h?ref=bd0dbe8763fc3029cf96531c9ccaba280b939445",
        "patch": "@@ -6,6 +6,7 @@\n #define BITCOIN_PSBT_H\n \n #include <attributes.h>\n+#include <node/transaction.h>\n #include <primitives/transaction.h>\n #include <pubkey.h>\n #include <script/sign.h>"
      },
      {
        "sha": "bc836614ae3080f1abd2ff9fe7393a6c59683c1f",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=bd0dbe8763fc3029cf96531c9ccaba280b939445",
        "patch": "@@ -1050,7 +1050,14 @@ static UniValue sendrawtransaction(const JSONRPCRequest& request)\n \n     bool allowhighfees = false;\n     if (!request.params[1].isNull()) allowhighfees = request.params[1].get_bool();\n-    return BroadcastTransaction(tx, allowhighfees).GetHex();\n+    uint256 txid;\n+    TransactionError err;\n+    std::string err_string;\n+    if (!BroadcastTransaction(tx, txid, err, err_string, allowhighfees)) {\n+        throw JSONRPCTransactionError(err, err_string);\n+    }\n+\n+    return txid.GetHex();\n }\n \n static UniValue testmempoolaccept(const JSONRPCRequest& request)"
      },
      {
        "sha": "9e825ac12a6a8c8ce6a7b380c3b0feebdb2b0f97",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=bd0dbe8763fc3029cf96531c9ccaba280b939445",
        "patch": "@@ -141,6 +141,32 @@ unsigned int ParseConfirmTarget(const UniValue& value)\n     return (unsigned int)target;\n }\n \n+RPCErrorCode RPCErrorFromTransactionError(TransactionError terr)\n+{\n+    switch (terr) {\n+        case TransactionError::MEMPOOL_REJECTED:\n+            return RPC_TRANSACTION_REJECTED;\n+        case TransactionError::ALREADY_IN_CHAIN:\n+            return RPC_TRANSACTION_ALREADY_IN_CHAIN;\n+        case TransactionError::P2P_DISABLED:\n+            return RPC_CLIENT_P2P_DISABLED;\n+        case TransactionError::INVALID_PSBT:\n+        case TransactionError::SIGHASH_MISMATCH:\n+            return RPC_DESERIALIZATION_ERROR;\n+        default: break;\n+    }\n+    return RPC_TRANSACTION_ERROR;\n+}\n+\n+UniValue JSONRPCTransactionError(TransactionError terr, const std::string& err_string)\n+{\n+    if (err_string.length() > 0) {\n+        return JSONRPCError(RPCErrorFromTransactionError(terr), err_string);\n+    } else {\n+        return JSONRPCError(RPCErrorFromTransactionError(terr), TransactionErrorString(terr));\n+    }\n+}\n+\n struct Section {\n     Section(const std::string& left, const std::string& right)\n         : m_left{left}, m_right{right} {}"
      },
      {
        "sha": "33fca790291752401451a34fbbf35f38ab02f23b",
        "filename": "src/rpc/util.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/rpc/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/rpc/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.h?ref=bd0dbe8763fc3029cf96531c9ccaba280b939445",
        "patch": "@@ -5,6 +5,7 @@\n #ifndef BITCOIN_RPC_UTIL_H\n #define BITCOIN_RPC_UTIL_H\n \n+#include <node/transaction.h>\n #include <pubkey.h>\n #include <script/standard.h>\n #include <univalue.h>\n@@ -31,6 +32,9 @@ UniValue DescribeAddress(const CTxDestination& dest);\n //! Parse a confirm target option and raise an RPC error if it is invalid.\n unsigned int ParseConfirmTarget(const UniValue& value);\n \n+RPCErrorCode RPCErrorFromTransactionError(TransactionError terr);\n+UniValue JSONRPCTransactionError(TransactionError terr, const std::string& err_string = \"\");\n+\n struct RPCArg {\n     enum class Type {\n         OBJ,"
      },
      {
        "sha": "761e7b7dd77878c2c3d5097b235404f017198b2f",
        "filename": "src/wallet/psbtwallet.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 6,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/wallet/psbtwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/wallet/psbtwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/psbtwallet.cpp?ref=bd0dbe8763fc3029cf96531c9ccaba280b939445",
        "patch": "@@ -2,14 +2,13 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <rpc/protocol.h>\n #include <wallet/psbtwallet.h>\n \n-bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, int sighash_type, bool sign, bool bip32derivs)\n+bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, TransactionError& error, bool& complete, int sighash_type, bool sign, bool bip32derivs)\n {\n     LOCK(pwallet->cs_wallet);\n     // Get all of the previous transactions\n-    bool complete = true;\n+    complete = true;\n     for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n         const CTxIn& txin = psbtx.tx->vin[i];\n         PSBTInput& input = psbtx.inputs.at(i);\n@@ -20,7 +19,8 @@ bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, int sig\n \n         // Verify input looks sane. This will check that we have at most one uxto, witness or non-witness.\n         if (!input.IsSane()) {\n-            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"PSBT input is not sane.\");\n+            error = TransactionError::INVALID_PSBT;\n+            return false;\n         }\n \n         // If we have no utxo, grab it from the wallet.\n@@ -37,7 +37,8 @@ bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, int sig\n \n         // Get the Sighash type\n         if (sign && input.sighash_type > 0 && input.sighash_type != sighash_type) {\n-            throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"Specified Sighash and sighash in PSBT do not match.\");\n+            error = TransactionError::SIGHASH_MISMATCH;\n+            return false;\n         }\n \n         complete &= SignPSBTInput(HidingSigningProvider(pwallet, !sign, !bip32derivs), psbtx, i, sighash_type);\n@@ -56,5 +57,6 @@ bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, int sig\n         ProduceSignature(HidingSigningProvider(pwallet, true, !bip32derivs), creator, out.scriptPubKey, sigdata);\n         psbt_out.FromSignatureData(sigdata);\n     }\n-    return complete;\n+\n+    return true;\n }"
      },
      {
        "sha": "b679f5c6ba6c2ae24cc15296ae06f9babee0798a",
        "filename": "src/wallet/psbtwallet.h",
        "status": "modified",
        "additions": 23,
        "deletions": 1,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/wallet/psbtwallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/wallet/psbtwallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/psbtwallet.h?ref=bd0dbe8763fc3029cf96531c9ccaba280b939445",
        "patch": "@@ -5,10 +5,32 @@\n #ifndef BITCOIN_WALLET_PSBTWALLET_H\n #define BITCOIN_WALLET_PSBTWALLET_H\n \n+#include <node/transaction.h>\n #include <psbt.h>\n #include <primitives/transaction.h>\n #include <wallet/wallet.h>\n \n-bool FillPSBT(const CWallet* pwallet, PartiallySignedTransaction& psbtx, int sighash_type = 1 /* SIGHASH_ALL */, bool sign = true, bool bip32derivs = false);\n+/**\n+ * Fills out a PSBT with information from the wallet. Fills in UTXOs if we have\n+ * them. Tries to sign if sign=true. Sets `complete` if the PSBT is now complete\n+ * (i.e. has all required signatures or signature-parts, and is ready to\n+ * finalize.) Sets `error` and returns false if something goes wrong.\n+ *\n+ * @param[in]  pwallet pointer to a wallet\n+ * @param[in]  &psbtx reference to PartiallySignedTransaction to fill in\n+ * @param[out] &error reference to UniValue to fill with error info on failure\n+ * @param[out] &complete indicates whether the PSBT is now complete\n+ * @param[in]  sighash_type the sighash type to use when signing (if PSBT does not specify)\n+ * @param[in]  sign whether to sign or not\n+ * @param[in]  bip32derivs whether to fill in bip32 derivation information if available\n+ * return true on success, false on error (and fills in `error`)\n+ */\n+bool FillPSBT(const CWallet* pwallet,\n+              PartiallySignedTransaction& psbtx,\n+              TransactionError& error,\n+              bool& complete,\n+              int sighash_type = 1 /* SIGHASH_ALL */,\n+              bool sign = true,\n+              bool bip32derivs = false);\n \n #endif // BITCOIN_WALLET_PSBTWALLET_H"
      },
      {
        "sha": "6811d927f201726d0b27dcf8aff6b3806140c68b",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 2,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=bd0dbe8763fc3029cf96531c9ccaba280b939445",
        "patch": "@@ -13,6 +13,7 @@\n #include <validation.h>\n #include <key_io.h>\n #include <net.h>\n+#include <node/transaction.h>\n #include <outputtype.h>\n #include <policy/feerate.h>\n #include <policy/fees.h>\n@@ -4003,7 +4004,11 @@ UniValue walletprocesspsbt(const JSONRPCRequest& request)\n     // Fill transaction with our data and also sign\n     bool sign = request.params[1].isNull() ? true : request.params[1].get_bool();\n     bool bip32derivs = request.params[3].isNull() ? false : request.params[3].get_bool();\n-    bool complete = FillPSBT(pwallet, psbtx, nHashType, sign, bip32derivs);\n+    bool complete = true;\n+    TransactionError err;\n+    if (!FillPSBT(pwallet, psbtx, err, complete, nHashType, sign, bip32derivs)) {\n+        throw JSONRPCTransactionError(err);\n+    }\n \n     UniValue result(UniValue::VOBJ);\n     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n@@ -4117,7 +4122,11 @@ UniValue walletcreatefundedpsbt(const JSONRPCRequest& request)\n \n     // Fill transaction with out data but don't sign\n     bool bip32derivs = request.params[4].isNull() ? false : request.params[4].get_bool();\n-    FillPSBT(pwallet, psbtx, 1, false, bip32derivs);\n+    bool complete = true;\n+    TransactionError err;\n+    if (!FillPSBT(pwallet, psbtx, err, complete, 1, false, bip32derivs)) {\n+        throw JSONRPCTransactionError(err);\n+    }\n \n     // Serialize the PSBT\n     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);"
      },
      {
        "sha": "e89d4121bccfc4810ea267f4b0020916417f8bf8",
        "filename": "src/wallet/test/psbt_wallet_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/wallet/test/psbt_wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd0dbe8763fc3029cf96531c9ccaba280b939445/src/wallet/test/psbt_wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/psbt_wallet_tests.cpp?ref=bd0dbe8763fc3029cf96531c9ccaba280b939445",
        "patch": "@@ -61,7 +61,9 @@ BOOST_AUTO_TEST_CASE(psbt_updater_test)\n     ssData >> psbtx;\n \n     // Fill transaction with our data\n-    FillPSBT(&m_wallet, psbtx, SIGHASH_ALL, false, true);\n+    TransactionError err;\n+    bool complete = true;\n+    FillPSBT(&m_wallet, psbtx, err, complete, SIGHASH_ALL, false, true);\n \n     // Get the final tx\n     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);"
      }
    ]
  },
  {
    "sha": "78b9893d020e8b1351565f1adbf591cb32f6dc90",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3OGI5ODkzZDAyMGU4YjEzNTE1NjVmMWFkYmY1OTFjYjMyZjZkYzkw",
    "commit": {
      "author": {
        "name": "Glenn Willen",
        "email": "gwillen@nerdnet.org",
        "date": "2019-01-30T06:51:56Z"
      },
      "committer": {
        "name": "Glenn Willen",
        "email": "gwillen@nerdnet.org",
        "date": "2019-02-11T22:08:04Z"
      },
      "message": "Remove op== on PSBTs; check compatibility in Merge\n\nRemove the op== on PartiallySignedTransaction, which only checks that the\nCTransactions are equal. Instead, check this directly in Merge, and return\nfalse if the CTransactions are not equal (so the PSBTs cannot be merged.)",
      "tree": {
        "sha": "599c5a1b8627fb1681b038d3b89aef07f3ea8663",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/599c5a1b8627fb1681b038d3b89aef07f3ea8663"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/78b9893d020e8b1351565f1adbf591cb32f6dc90",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/78b9893d020e8b1351565f1adbf591cb32f6dc90",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/78b9893d020e8b1351565f1adbf591cb32f6dc90",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/78b9893d020e8b1351565f1adbf591cb32f6dc90/comments",
    "author": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bd0dbe8763fc3029cf96531c9ccaba280b939445",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd0dbe8763fc3029cf96531c9ccaba280b939445",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bd0dbe8763fc3029cf96531c9ccaba280b939445"
      }
    ],
    "stats": {
      "total": 27,
      "additions": 13,
      "deletions": 14
    },
    "files": [
      {
        "sha": "06032d69538664b60ec9f012d830cbb0574b1b6e",
        "filename": "src/psbt.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 1,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78b9893d020e8b1351565f1adbf591cb32f6dc90/src/psbt.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78b9893d020e8b1351565f1adbf591cb32f6dc90/src/psbt.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/psbt.cpp?ref=78b9893d020e8b1351565f1adbf591cb32f6dc90",
        "patch": "@@ -16,15 +16,22 @@ bool PartiallySignedTransaction::IsNull() const\n     return !tx && inputs.empty() && outputs.empty() && unknown.empty();\n }\n \n-void PartiallySignedTransaction::Merge(const PartiallySignedTransaction& psbt)\n+bool PartiallySignedTransaction::Merge(const PartiallySignedTransaction& psbt)\n {\n+    // Prohibited to merge two PSBTs over different transactions\n+    if (tx->GetHash() != psbt.tx->GetHash()) {\n+        return false;\n+    }\n+\n     for (unsigned int i = 0; i < inputs.size(); ++i) {\n         inputs[i].Merge(psbt.inputs[i]);\n     }\n     for (unsigned int i = 0; i < outputs.size(); ++i) {\n         outputs[i].Merge(psbt.outputs[i]);\n     }\n     unknown.insert(psbt.unknown.begin(), psbt.unknown.end());\n+\n+    return true;\n }\n \n bool PartiallySignedTransaction::IsSane() const"
      },
      {
        "sha": "4b7ea4383a7acc8dbbed78eda0f4a3215a00e1f0",
        "filename": "src/psbt.h",
        "status": "modified",
        "additions": 4,
        "deletions": 11,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78b9893d020e8b1351565f1adbf591cb32f6dc90/src/psbt.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78b9893d020e8b1351565f1adbf591cb32f6dc90/src/psbt.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/psbt.h?ref=78b9893d020e8b1351565f1adbf591cb32f6dc90",
        "patch": "@@ -384,22 +384,15 @@ struct PartiallySignedTransaction\n     std::map<std::vector<unsigned char>, std::vector<unsigned char>> unknown;\n \n     bool IsNull() const;\n-    void Merge(const PartiallySignedTransaction& psbt);\n+\n+    /** Merge psbt into this. The two psbts must have the same underlying CTransaction (i.e. the\n+      * same actual Bitcoin transaction.) Returns true if the merge succeeded, false otherwise. */\n+    NODISCARD bool Merge(const PartiallySignedTransaction& psbt);\n     bool IsSane() const;\n     PartiallySignedTransaction() {}\n     PartiallySignedTransaction(const PartiallySignedTransaction& psbt_in) : tx(psbt_in.tx), inputs(psbt_in.inputs), outputs(psbt_in.outputs), unknown(psbt_in.unknown) {}\n     explicit PartiallySignedTransaction(const CMutableTransaction& tx);\n \n-    // Only checks if they refer to the same transaction\n-    friend bool operator==(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n-    {\n-        return a.tx->GetHash() == b.tx->GetHash();\n-    }\n-    friend bool operator!=(const PartiallySignedTransaction& a, const PartiallySignedTransaction &b)\n-    {\n-        return !(a == b);\n-    }\n-\n     template <typename Stream>\n     inline void Serialize(Stream& s) const {\n "
      },
      {
        "sha": "4205a3d10f9947f5e34a8ea151f2d78baf341d4f",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/78b9893d020e8b1351565f1adbf591cb32f6dc90/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/78b9893d020e8b1351565f1adbf591cb32f6dc90/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=78b9893d020e8b1351565f1adbf591cb32f6dc90",
        "patch": "@@ -1481,10 +1481,9 @@ UniValue combinepsbt(const JSONRPCRequest& request)\n \n     // Merge\n     for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n-        if (*it != merged_psbt) {\n+        if (!merged_psbt.Merge(*it)) {\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n         }\n-        merged_psbt.Merge(*it);\n     }\n     if (!merged_psbt.IsSane()) {\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");"
      }
    ]
  },
  {
    "sha": "102faad81efa1cb12c29c466cfe81fc8c7351e1d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMDJmYWFkODFlZmExY2IxMmMyOWM0NjZjZmU4MWZjOGM3MzUxZTFk",
    "commit": {
      "author": {
        "name": "Glenn Willen",
        "email": "gwillen@nerdnet.org",
        "date": "2019-01-09T11:08:32Z"
      },
      "committer": {
        "name": "Glenn Willen",
        "email": "gwillen@nerdnet.org",
        "date": "2019-02-11T22:08:04Z"
      },
      "message": "Factor out combine / finalize / extract PSBT helpers\n\nRefactor the new CombinePSBT, FinalizePSBT, and FinalizeAndExtractPSBT\ngeneral-purpose functions out of the combinepsbt and finalizepsbt RPCs,\nfor use in the GUI code.",
      "tree": {
        "sha": "7353c37cc34161eb350e41cac2f1a7e1e8b8ee23",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7353c37cc34161eb350e41cac2f1a7e1e8b8ee23"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/102faad81efa1cb12c29c466cfe81fc8c7351e1d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/102faad81efa1cb12c29c466cfe81fc8c7351e1d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/102faad81efa1cb12c29c466cfe81fc8c7351e1d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/102faad81efa1cb12c29c466cfe81fc8c7351e1d/comments",
    "author": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gwillen",
      "id": 458997,
      "node_id": "MDQ6VXNlcjQ1ODk5Nw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/458997?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gwillen",
      "html_url": "https://github.com/gwillen",
      "followers_url": "https://api.github.com/users/gwillen/followers",
      "following_url": "https://api.github.com/users/gwillen/following{/other_user}",
      "gists_url": "https://api.github.com/users/gwillen/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gwillen/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gwillen/subscriptions",
      "organizations_url": "https://api.github.com/users/gwillen/orgs",
      "repos_url": "https://api.github.com/users/gwillen/repos",
      "events_url": "https://api.github.com/users/gwillen/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gwillen/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "78b9893d020e8b1351565f1adbf591cb32f6dc90",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/78b9893d020e8b1351565f1adbf591cb32f6dc90",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/78b9893d020e8b1351565f1adbf591cb32f6dc90"
      }
    ],
    "stats": {
      "total": 121,
      "additions": 95,
      "deletions": 26
    },
    "files": [
      {
        "sha": "c9cdd0d1cdc077fd183d926b5e080d22f30ba302",
        "filename": "src/node/transaction.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102faad81efa1cb12c29c466cfe81fc8c7351e1d/src/node/transaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102faad81efa1cb12c29c466cfe81fc8c7351e1d/src/node/transaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.cpp?ref=102faad81efa1cb12c29c466cfe81fc8c7351e1d",
        "patch": "@@ -29,6 +29,8 @@ const char* TransactionErrorString(const TransactionError err)\n             return \"AcceptToMemoryPool failed\";\n         case TransactionError::INVALID_PSBT:\n             return \"PSBT is not sane\";\n+        case TransactionError::PSBT_MISMATCH:\n+            return \"PSBTs not compatible (different transactions)\";\n         case TransactionError::SIGHASH_MISMATCH:\n             return \"Specified sighash value does not match existing value\";\n "
      },
      {
        "sha": "3b0cbba98b520ef051277eb106737232be127e31",
        "filename": "src/node/transaction.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102faad81efa1cb12c29c466cfe81fc8c7351e1d/src/node/transaction.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102faad81efa1cb12c29c466cfe81fc8c7351e1d/src/node/transaction.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/node/transaction.h?ref=102faad81efa1cb12c29c466cfe81fc8c7351e1d",
        "patch": "@@ -18,6 +18,7 @@ enum class TransactionError {\n     MEMPOOL_REJECTED,\n     MEMPOOL_ERROR,\n     INVALID_PSBT,\n+    PSBT_MISMATCH,\n     SIGHASH_MISMATCH,\n \n     ERROR_COUNT"
      },
      {
        "sha": "81633c0cc7ffa3c95420ee1996f4238b197d1bb8",
        "filename": "src/psbt.cpp",
        "status": "modified",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102faad81efa1cb12c29c466cfe81fc8c7351e1d/src/psbt.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102faad81efa1cb12c29c466cfe81fc8c7351e1d/src/psbt.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/psbt.cpp?ref=102faad81efa1cb12c29c466cfe81fc8c7351e1d",
        "patch": "@@ -232,3 +232,52 @@ bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction&\n \n     return sig_complete;\n }\n+\n+bool FinalizePSBT(PartiallySignedTransaction& psbtx)\n+{\n+    // Finalize input signatures -- in case we have partial signatures that add up to a complete\n+    //   signature, but have not combined them yet (e.g. because the combiner that created this\n+    //   PartiallySignedTransaction did not understand them), this will combine them into a final\n+    //   script.\n+    bool complete = true;\n+    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n+        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, psbtx, i, SIGHASH_ALL);\n+    }\n+\n+    return complete;\n+}\n+\n+bool FinalizeAndExtractPSBT(PartiallySignedTransaction& psbtx, CMutableTransaction& result)\n+{\n+    // It's not safe to extract a PSBT that isn't finalized, and there's no easy way to check\n+    //   whether a PSBT is finalized without finalizing it, so we just do this.\n+    if (!FinalizePSBT(psbtx)) {\n+        return false;\n+    }\n+\n+    result = *psbtx.tx;\n+    for (unsigned int i = 0; i < result.vin.size(); ++i) {\n+        result.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n+        result.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n+    }\n+    return true;\n+}\n+\n+bool CombinePSBTs(PartiallySignedTransaction& out, TransactionError& error, const std::vector<PartiallySignedTransaction>& psbtxs)\n+{\n+    out = psbtxs[0]; // Copy the first one\n+\n+    // Merge\n+    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n+        if (!out.Merge(*it)) {\n+            error = TransactionError::PSBT_MISMATCH;\n+            return false;\n+        }\n+    }\n+    if (!out.IsSane()) {\n+        error = TransactionError::INVALID_PSBT;\n+        return false;\n+    }\n+\n+    return true;\n+}"
      },
      {
        "sha": "e18790322bf997063e42d5c44ffc0724ec5dd6c8",
        "filename": "src/psbt.h",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102faad81efa1cb12c29c466cfe81fc8c7351e1d/src/psbt.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102faad81efa1cb12c29c466cfe81fc8c7351e1d/src/psbt.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/psbt.h?ref=102faad81efa1cb12c29c466cfe81fc8c7351e1d",
        "patch": "@@ -544,4 +544,31 @@ bool PSBTInputSigned(PSBTInput& input);\n /** Signs a PSBTInput, verifying that all provided data matches what is being signed. */\n bool SignPSBTInput(const SigningProvider& provider, PartiallySignedTransaction& psbt, int index, int sighash = SIGHASH_ALL);\n \n+/**\n+ * Finalizes a PSBT if possible, combining partial signatures.\n+ *\n+ * @param[in,out] &psbtx reference to PartiallySignedTransaction to finalize\n+ * return True if the PSBT is now complete, false otherwise\n+ */\n+bool FinalizePSBT(PartiallySignedTransaction& psbtx);\n+\n+/**\n+ * Finalizes a PSBT if possible, and extracts it to a CMutableTransaction if it could be finalized.\n+ *\n+ * @param[in]  &psbtx reference to PartiallySignedTransaction\n+ * @param[out] result CMutableTransaction representing the complete transaction, if successful\n+ * @return True if we successfully extracted the transaction, false otherwise\n+ */\n+bool FinalizeAndExtractPSBT(PartiallySignedTransaction& psbtx, CMutableTransaction& result);\n+\n+/**\n+ * Combines PSBTs with the same underlying transaction, resulting in a single PSBT with all partial signatures from each input.\n+ *\n+ * @param[out] &out   the combined PSBT, if successful\n+ * @param[out] &error reference to TransactionError to fill with error info on failure\n+ * @param[in]  psbtxs the PSBTs to combine\n+ * @return True if we successfully combined the transactions, false if they were not compatible\n+ */\n+bool CombinePSBTs(PartiallySignedTransaction& out, TransactionError& error, const std::vector<PartiallySignedTransaction>& psbtxs);\n+\n #endif // BITCOIN_PSBT_H"
      },
      {
        "sha": "f511cbbdabbd447473f6a98cec3bcd89867aaa54",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 26,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102faad81efa1cb12c29c466cfe81fc8c7351e1d/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102faad81efa1cb12c29c466cfe81fc8c7351e1d/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=102faad81efa1cb12c29c466cfe81fc8c7351e1d",
        "patch": "@@ -1477,16 +1477,10 @@ UniValue combinepsbt(const JSONRPCRequest& request)\n         psbtxs.push_back(psbtx);\n     }\n \n-    PartiallySignedTransaction merged_psbt(psbtxs[0]); // Copy the first one\n-\n-    // Merge\n-    for (auto it = std::next(psbtxs.begin()); it != psbtxs.end(); ++it) {\n-        if (!merged_psbt.Merge(*it)) {\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, \"PSBTs do not refer to the same transactions.\");\n-        }\n-    }\n-    if (!merged_psbt.IsSane()) {\n-        throw JSONRPCError(RPC_INVALID_PARAMETER, \"Merged PSBT is inconsistent\");\n+    PartiallySignedTransaction merged_psbt;\n+    TransactionError error;\n+    if (!CombinePSBTs(merged_psbt, error, psbtxs)) {\n+        throw JSONRPCTransactionError(error);\n     }\n \n     UniValue result(UniValue::VOBJ);\n@@ -1531,29 +1525,23 @@ UniValue finalizepsbt(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_DESERIALIZATION_ERROR, strprintf(\"TX decode failed %s\", error));\n     }\n \n-    // Finalize input signatures -- in case we have partial signatures that add up to a complete\n-    //   signature, but have not combined them yet (e.g. because the combiner that created this\n-    //   PartiallySignedTransaction did not understand them), this will combine them into a final\n-    //   script.\n-    bool complete = true;\n-    for (unsigned int i = 0; i < psbtx.tx->vin.size(); ++i) {\n-        complete &= SignPSBTInput(DUMMY_SIGNING_PROVIDER, psbtx, i, SIGHASH_ALL);\n-    }\n+    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+\n+    CMutableTransaction mtx;\n+    bool complete = FinalizeAndExtractPSBT(psbtx, mtx);\n \n     UniValue result(UniValue::VOBJ);\n     CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n-    bool extract = request.params[1].isNull() || (!request.params[1].isNull() && request.params[1].get_bool());\n+    std::string result_str;\n+\n     if (complete && extract) {\n-        CMutableTransaction mtx(*psbtx.tx);\n-        for (unsigned int i = 0; i < mtx.vin.size(); ++i) {\n-            mtx.vin[i].scriptSig = psbtx.inputs[i].final_script_sig;\n-            mtx.vin[i].scriptWitness = psbtx.inputs[i].final_script_witness;\n-        }\n         ssTx << mtx;\n-        result.pushKV(\"hex\", HexStr(ssTx.str()));\n+        result_str = HexStr(ssTx.str());\n+        result.pushKV(\"hex\", result_str);\n     } else {\n         ssTx << psbtx;\n-        result.pushKV(\"psbt\", EncodeBase64(ssTx.str()));\n+        result_str = EncodeBase64(ssTx.str());\n+        result.pushKV(\"psbt\", result_str);\n     }\n     result.pushKV(\"complete\", complete);\n "
      },
      {
        "sha": "653568044d5af9a1e4eb09e856144e321ad06b13",
        "filename": "src/rpc/util.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/102faad81efa1cb12c29c466cfe81fc8c7351e1d/src/rpc/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/102faad81efa1cb12c29c466cfe81fc8c7351e1d/src/rpc/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/util.cpp?ref=102faad81efa1cb12c29c466cfe81fc8c7351e1d",
        "patch": "@@ -151,6 +151,8 @@ RPCErrorCode RPCErrorFromTransactionError(TransactionError terr)\n         case TransactionError::P2P_DISABLED:\n             return RPC_CLIENT_P2P_DISABLED;\n         case TransactionError::INVALID_PSBT:\n+        case TransactionError::PSBT_MISMATCH:\n+            return RPC_INVALID_PARAMETER;\n         case TransactionError::SIGHASH_MISMATCH:\n             return RPC_DESERIALIZATION_ERROR;\n         default: break;"
      }
    ]
  }
]