[
  {
    "sha": "e66dbde6d14cb5f253b3bf8850a98f4fda2d9f49",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNjZkYmRlNmQxNGNiNWYyNTNiM2JmODg1MGE5OGY0ZmRhMmQ5ZjQ5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:04Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-26T20:24:24Z"
      },
      "message": "Add SizeEstimate to CDBBatch\n\nThis allows estimating the in-memory size of a LevelDB batch.",
      "tree": {
        "sha": "df6998e32cccf3781081d255e3430b4e71cd160f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/df6998e32cccf3781081d255e3430b4e71cd160f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e66dbde6d14cb5f253b3bf8850a98f4fda2d9f49",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e66dbde6d14cb5f253b3bf8850a98f4fda2d9f49",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e66dbde6d14cb5f253b3bf8850a98f4fda2d9f49",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e66dbde6d14cb5f253b3bf8850a98f4fda2d9f49/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b4b057a3e0712dd16b50cbcfe7d613e4413ffa1c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b4b057a3e0712dd16b50cbcfe7d613e4413ffa1c",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b4b057a3e0712dd16b50cbcfe7d613e4413ffa1c"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 25,
      "deletions": 1
    },
    "files": [
      {
        "sha": "442f37b420d59b1e201eb3976be2c6730a29bdd9",
        "filename": "src/dbwrapper.h",
        "status": "modified",
        "additions": 25,
        "deletions": 1,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e66dbde6d14cb5f253b3bf8850a98f4fda2d9f49/src/dbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e66dbde6d14cb5f253b3bf8850a98f4fda2d9f49/src/dbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.h?ref=e66dbde6d14cb5f253b3bf8850a98f4fda2d9f49",
        "patch": "@@ -55,11 +55,19 @@ class CDBBatch\n     CDataStream ssKey;\n     CDataStream ssValue;\n \n+    size_t size_estimate;\n+\n public:\n     /**\n      * @param[in] _parent   CDBWrapper that this batch is to be submitted to\n      */\n-    CDBBatch(const CDBWrapper &_parent) : parent(_parent), ssKey(SER_DISK, CLIENT_VERSION), ssValue(SER_DISK, CLIENT_VERSION) { };\n+    CDBBatch(const CDBWrapper &_parent) : parent(_parent), ssKey(SER_DISK, CLIENT_VERSION), ssValue(SER_DISK, CLIENT_VERSION), size_estimate(0) { };\n+\n+    void Clear()\n+    {\n+        batch.Clear();\n+        size_estimate = 0;\n+    }\n \n     template <typename K, typename V>\n     void Write(const K& key, const V& value)\n@@ -74,6 +82,14 @@ class CDBBatch\n         leveldb::Slice slValue(ssValue.data(), ssValue.size());\n \n         batch.Put(slKey, slValue);\n+        // LevelDB serializes writes as:\n+        // - byte: header\n+        // - varint: key length (1 byte up to 127B, 2 bytes up to 16383B, ...)\n+        // - byte[]: key\n+        // - varint: value length\n+        // - byte[]: value\n+        // The formula below assumes the key and value are both less than 16k.\n+        size_estimate += 3 + (slKey.size() > 127) + slKey.size() + (slValue.size() > 127) + slValue.size();\n         ssKey.clear();\n         ssValue.clear();\n     }\n@@ -86,8 +102,16 @@ class CDBBatch\n         leveldb::Slice slKey(ssKey.data(), ssKey.size());\n \n         batch.Delete(slKey);\n+        // LevelDB serializes erases as:\n+        // - byte: header\n+        // - varint: key length\n+        // - byte[]: key\n+        // The formula below assumes the key is less than 16kB.\n+        size_estimate += 2 + (slKey.size() > 127) + slKey.size();\n         ssKey.clear();\n     }\n+\n+    size_t SizeEstimate() const { return size_estimate; }\n };\n \n class CDBIterator"
      }
    ]
  },
  {
    "sha": "f54580e7e4f225bb615204daef32f72ab8688418",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNTQ1ODBlN2U0ZjIyNWJiNjE1MjA0ZGFlZjMyZjcyYWI4Njg4NDE4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:09Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-26T20:24:25Z"
      },
      "message": "error() in disconnect for disk corruption, not inconsistency\n\nThe error() function unconditionally reports an error. It should only\nbe used for actually exception situations, and not for the type of\ninconsistencies that ApplyTxInUndo/DisconnectBlock can graciously deal\nwith.\n\nThis also makes a subtle semantics change: in ApplyTxInUndo, when a\nrecord with metadata is encountered (indicating it is the last spend\nfrom a tx), don't wipe the CCoins record if it wasn't empty at that\npoint. This makes sure that UTXO operations never affect any other\nUTXOs (including those from the same tx).",
      "tree": {
        "sha": "98677d518472e01bdc307a4dccc0cc44bb835517",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/98677d518472e01bdc307a4dccc0cc44bb835517"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f54580e7e4f225bb615204daef32f72ab8688418",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f54580e7e4f225bb615204daef32f72ab8688418",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f54580e7e4f225bb615204daef32f72ab8688418",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f54580e7e4f225bb615204daef32f72ab8688418/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e66dbde6d14cb5f253b3bf8850a98f4fda2d9f49",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e66dbde6d14cb5f253b3bf8850a98f4fda2d9f49",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e66dbde6d14cb5f253b3bf8850a98f4fda2d9f49"
      }
    ],
    "stats": {
      "total": 40,
      "additions": 18,
      "deletions": 22
    },
    "files": [
      {
        "sha": "1b5d8e91b552ac9a0dd57f813159fab219800d0c",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f54580e7e4f225bb615204daef32f72ab8688418/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f54580e7e4f225bb615204daef32f72ab8688418/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=f54580e7e4f225bb615204daef32f72ab8688418",
        "patch": "@@ -17,7 +17,7 @@\n \n #include <boost/test/unit_test.hpp>\n \n-bool ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint& out);\n+int ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint& out);\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txundo, int nHeight);\n \n namespace"
      },
      {
        "sha": "ed94be5c26e942c6f5c726c4df02e6bcd6a39d05",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 21,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f54580e7e4f225bb615204daef32f72ab8688418/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f54580e7e4f225bb615204daef32f72ab8688418/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=f54580e7e4f225bb615204daef32f72ab8688418",
        "patch": "@@ -1248,46 +1248,42 @@ bool AbortNode(CValidationState& state, const std::string& strMessage, const std\n \n } // anon namespace\n \n+enum DisconnectResult\n+{\n+    DISCONNECT_OK,      // All good.\n+    DISCONNECT_UNCLEAN, // Rolled back, but UTXO set was inconsistent with block.\n+    DISCONNECT_FAILED   // Something else went wrong.\n+};\n+\n /**\n  * Apply the undo operation of a CTxInUndo to the given chain state.\n  * @param undo The undo object.\n  * @param view The coins view to which to apply the changes.\n  * @param out The out point that corresponds to the tx input.\n- * @return True on success.\n+ * @return A DisconnectResult as an int\n  */\n-bool ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint& out)\n+int ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint& out)\n {\n     bool fClean = true;\n \n     CCoinsModifier coins = view.ModifyCoins(out.hash);\n     if (undo.nHeight != 0) {\n         // undo data contains height: this is the last output of the prevout tx being spent\n-        if (!coins->IsPruned())\n-            fClean = fClean && error(\"%s: undo data overwriting existing transaction\", __func__);\n-        coins->Clear();\n+        if (!coins->IsPruned()) fClean = false; // overwriting existing transaction\n         coins->fCoinBase = undo.fCoinBase;\n         coins->nHeight = undo.nHeight;\n         coins->nVersion = undo.nVersion;\n     } else {\n-        if (coins->IsPruned())\n-            fClean = fClean && error(\"%s: undo data adding output to missing transaction\", __func__);\n+        if (coins->IsPruned()) fClean = false; // adding output to missing transaction\n     }\n-    if (coins->IsAvailable(out.n))\n-        fClean = fClean && error(\"%s: undo data overwriting existing output\", __func__);\n+    if (coins->IsAvailable(out.n)) fClean = false; // overwriting existing output\n     if (coins->vout.size() < out.n+1)\n         coins->vout.resize(out.n+1);\n     coins->vout[out.n] = undo.txout;\n \n-    return fClean;\n+    return fClean ? DISCONNECT_OK : DISCONNECT_UNCLEAN;\n }\n \n-enum DisconnectResult\n-{\n-    DISCONNECT_OK,      // All good.\n-    DISCONNECT_UNCLEAN, // Rolled back, but UTXO set was inconsistent with block.\n-    DISCONNECT_FAILED   // Something else went wrong.\n-};\n-\n /** Undo the effects of this block (with given index) on the UTXO set represented by coins.\n  *  When UNCLEAN or FAILED is returned, view is left in an indeterminate state. */\n static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex* pindex, CCoinsViewCache& view)\n@@ -1329,8 +1325,7 @@ static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex*\n         // but it must be corrected before txout nversion ever influences a network rule.\n         if (outsBlock.nVersion < 0)\n             outs->nVersion = outsBlock.nVersion;\n-        if (*outs != outsBlock)\n-            fClean = fClean && error(\"DisconnectBlock(): added transaction mismatch? database corrupted\");\n+        if (*outs != outsBlock) fClean = false; // transaction mismatch\n \n         // remove outputs\n         outs->Clear();\n@@ -1346,8 +1341,9 @@ static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex*\n             for (unsigned int j = tx.vin.size(); j-- > 0;) {\n                 const COutPoint &out = tx.vin[j].prevout;\n                 const CTxInUndo &undo = txundo.vprevout[j];\n-                if (!ApplyTxInUndo(undo, view, out))\n-                    fClean = false;\n+                int res = ApplyTxInUndo(undo, view, out);\n+                if (res == DISCONNECT_FAILED) return DISCONNECT_FAILED;\n+                fClean = fClean && res != DISCONNECT_UNCLEAN;\n             }\n         }\n     }"
      }
    ]
  },
  {
    "sha": "e484652fc36ef7135cf08ad380ea7142b6cbadc0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNDg0NjUyZmMzNmVmNzEzNWNmMDhhZDM4MGVhNzE0MmI2Y2JhZGMw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:14Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-26T20:24:25Z"
      },
      "message": "Introduce CHashVerifier to hash read data\n\nThis is necessary later, when we drop the nVersion field from the undo\ndata. At that point deserializing and reserializing the data won't\nroundtrip anymore, and thus that approach can't be used to verify\nchecksums anymore.\n\nWith this CHashVerifier approach, we can deserialize while hashing the\nexact serialized form that was used. This is both more efficient and\nmore correct in that case.",
      "tree": {
        "sha": "45085d6af75bc045ae486a226c575fef59fd6b22",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/45085d6af75bc045ae486a226c575fef59fd6b22"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e484652fc36ef7135cf08ad380ea7142b6cbadc0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e484652fc36ef7135cf08ad380ea7142b6cbadc0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e484652fc36ef7135cf08ad380ea7142b6cbadc0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e484652fc36ef7135cf08ad380ea7142b6cbadc0/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f54580e7e4f225bb615204daef32f72ab8688418",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f54580e7e4f225bb615204daef32f72ab8688418",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f54580e7e4f225bb615204daef32f72ab8688418"
      }
    ],
    "stats": {
      "total": 44,
      "additions": 39,
      "deletions": 5
    },
    "files": [
      {
        "sha": "b8de19c0fd4b30a1541476d6c777f579fab64737",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e484652fc36ef7135cf08ad380ea7142b6cbadc0/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e484652fc36ef7135cf08ad380ea7142b6cbadc0/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=e484652fc36ef7135cf08ad380ea7142b6cbadc0",
        "patch": "@@ -160,6 +160,41 @@ class CHashWriter\n     }\n };\n \n+/** Reads data from an underlying stream, while hashing the read data. */\n+template<typename Source>\n+class CHashVerifier : public CHashWriter\n+{\n+private:\n+    Source* source;\n+\n+public:\n+    CHashVerifier(Source* source_) : CHashWriter(source_->GetType(), source_->GetVersion()), source(source_) {}\n+\n+    void read(char* pch, size_t nSize)\n+    {\n+        source->read(pch, nSize);\n+        this->write(pch, nSize);\n+    }\n+\n+    void ignore(size_t nSize)\n+    {\n+        char data[1024];\n+        while (nSize > 0) {\n+            size_t now = std::min<size_t>(nSize, 1024);\n+            read(data, now);\n+            nSize -= now;\n+        }\n+    }\n+\n+    template<typename T>\n+    CHashVerifier<Source>& operator>>(T& obj)\n+    {\n+        // Unserialize from this stream\n+        ::Unserialize(*this, obj);\n+        return (*this);\n+    }\n+};\n+\n /** Compute the 256-bit hash of an object's serialization. */\n template<typename T>\n uint256 SerializeHash(const T& obj, int nType=SER_GETHASH, int nVersion=PROTOCOL_VERSION)"
      },
      {
        "sha": "fc7e129c05a4082653d7a03baed94d474901461f",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 5,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e484652fc36ef7135cf08ad380ea7142b6cbadc0/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e484652fc36ef7135cf08ad380ea7142b6cbadc0/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=e484652fc36ef7135cf08ad380ea7142b6cbadc0",
        "patch": "@@ -1210,19 +1210,18 @@ bool UndoReadFromDisk(CBlockUndo& blockundo, const CDiskBlockPos& pos, const uin\n \n     // Read block\n     uint256 hashChecksum;\n+    CHashVerifier<CAutoFile> verifier(&filein); // We need a CHashVerifier as reserializing may lose data\n     try {\n-        filein >> blockundo;\n+        verifier << hashBlock;\n+        verifier >> blockundo;\n         filein >> hashChecksum;\n     }\n     catch (const std::exception& e) {\n         return error(\"%s: Deserialize or I/O error - %s\", __func__, e.what());\n     }\n \n     // Verify checksum\n-    CHashWriter hasher(SER_GETHASH, PROTOCOL_VERSION);\n-    hasher << hashBlock;\n-    hasher << blockundo;\n-    if (hashChecksum != hasher.GetHash())\n+    if (hashChecksum != verifier.GetHash())\n         return error(\"%s: Checksum mismatch\", __func__);\n \n     return true;"
      }
    ]
  },
  {
    "sha": "7e0032290669fae5f52c256856c53038511c7db4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZTAwMzIyOTA2NjlmYWU1ZjUyYzI1Njg1NmM1MzAzODUxMWM3ZGI0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:16Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-26T20:24:25Z"
      },
      "message": "Add specialization of SipHash for 256 + 32 bit data\n\nWe'll need a version of SipHash for tuples of 256 bits and 32 bits\ndata, when CCoinsViewCache switches from using txids to COutPoints as\nkeys.",
      "tree": {
        "sha": "99c8556e0817c0edb36d86cc3196073407539ae5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/99c8556e0817c0edb36d86cc3196073407539ae5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7e0032290669fae5f52c256856c53038511c7db4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e0032290669fae5f52c256856c53038511c7db4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7e0032290669fae5f52c256856c53038511c7db4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e0032290669fae5f52c256856c53038511c7db4/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e484652fc36ef7135cf08ad380ea7142b6cbadc0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e484652fc36ef7135cf08ad380ea7142b6cbadc0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e484652fc36ef7135cf08ad380ea7142b6cbadc0"
      }
    ],
    "stats": {
      "total": 59,
      "additions": 59,
      "deletions": 0
    },
    "files": [
      {
        "sha": "b361c90d1626ae5cb5fc720d54ffb09546549da5",
        "filename": "src/hash.cpp",
        "status": "modified",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7e0032290669fae5f52c256856c53038511c7db4/src/hash.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7e0032290669fae5f52c256856c53038511c7db4/src/hash.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.cpp?ref=7e0032290669fae5f52c256856c53038511c7db4",
        "patch": "@@ -208,3 +208,44 @@ uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val)\n     SIPROUND;\n     return v0 ^ v1 ^ v2 ^ v3;\n }\n+\n+uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra)\n+{\n+    /* Specialized implementation for efficiency */\n+    uint64_t d = val.GetUint64(0);\n+\n+    uint64_t v0 = 0x736f6d6570736575ULL ^ k0;\n+    uint64_t v1 = 0x646f72616e646f6dULL ^ k1;\n+    uint64_t v2 = 0x6c7967656e657261ULL ^ k0;\n+    uint64_t v3 = 0x7465646279746573ULL ^ k1 ^ d;\n+\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(1);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(2);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = val.GetUint64(3);\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    d = (((uint64_t)36) << 56) | extra;\n+    v3 ^= d;\n+    SIPROUND;\n+    SIPROUND;\n+    v0 ^= d;\n+    v2 ^= 0xFF;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    SIPROUND;\n+    return v0 ^ v1 ^ v2 ^ v3;\n+}"
      },
      {
        "sha": "b9952d39fc97dc1472a1c11b6e9e312f1b7a5e01",
        "filename": "src/hash.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7e0032290669fae5f52c256856c53038511c7db4/src/hash.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7e0032290669fae5f52c256856c53038511c7db4/src/hash.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/hash.h?ref=7e0032290669fae5f52c256856c53038511c7db4",
        "patch": "@@ -241,5 +241,6 @@ class CSipHasher\n  *      .Finalize()\n  */\n uint64_t SipHashUint256(uint64_t k0, uint64_t k1, const uint256& val);\n+uint64_t SipHashUint256Extra(uint64_t k0, uint64_t k1, const uint256& val, uint32_t extra);\n \n #endif // BITCOIN_HASH_H"
      },
      {
        "sha": "bb7e473248777f153d298bef3472d407b9ce18a9",
        "filename": "src/test/hash_tests.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7e0032290669fae5f52c256856c53038511c7db4/src/test/hash_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7e0032290669fae5f52c256856c53038511c7db4/src/test/hash_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/hash_tests.cpp?ref=7e0032290669fae5f52c256856c53038511c7db4",
        "patch": "@@ -128,6 +128,23 @@ BOOST_AUTO_TEST_CASE(siphash)\n     tx.nVersion = 1;\n     ss << tx;\n     BOOST_CHECK_EQUAL(SipHashUint256(1, 2, ss.GetHash()), 0x79751e980c2a0a35ULL);\n+\n+    // Check consistency between CSipHasher and SipHashUint256[Extra].\n+    FastRandomContext ctx;\n+    for (int i = 0; i < 16; ++i) {\n+        uint64_t k1 = ctx.rand64();\n+        uint64_t k2 = ctx.rand64();\n+        uint256 x = GetRandHash();\n+        uint32_t n = ctx.rand32();\n+        uint8_t nb[4];\n+        WriteLE32(nb, n);\n+        CSipHasher sip256(k1, k2);\n+        sip256.Write(x.begin(), 32);\n+        CSipHasher sip288 = sip256;\n+        sip288.Write(nb, 4);\n+        BOOST_CHECK_EQUAL(SipHashUint256(k1, k2, x), sip256.Finalize());\n+        BOOST_CHECK_EQUAL(SipHashUint256Extra(k1, k2, x, n), sip288.Finalize());\n+    }\n }\n \n BOOST_AUTO_TEST_SUITE_END()"
      }
    ]
  },
  {
    "sha": "d342424301013ec47dc146a4beb49d5c9319d80a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMzQyNDI0MzAxMDEzZWM0N2RjMTQ2YTRiZWI0OWQ1YzkzMTlkODBh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:18Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-26T20:27:50Z"
      },
      "message": "Remove/ignore tx version in utxo and undo\n\nThis makes the following changes:\n* In undo data and the chainstate database, the transaction nVersion\n  field is removed from the data structures, always written as 0, and\n  ignored when reading.\n* The definition of hash_serialized in gettxoutsetinfo is changed to no\n  longer incude the nVersion field. It is renamed to hash_serialized_2\n  to avoid confusion. The new definition also includes transaction\n  height and coinbase information, as this information was missing\n  before.\n\nThis depends on having a CHashVerifier-based undo data checksum\nverifier.\n\nApart from changing the definition of serialized_hash, downgrading\nafter using this patch is supported, as no release ever used the value\nof nVersion field in UTXO entries.",
      "tree": {
        "sha": "00574e5165c4b96167009fefe525b024e98eae0f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/00574e5165c4b96167009fefe525b024e98eae0f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d342424301013ec47dc146a4beb49d5c9319d80a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d342424301013ec47dc146a4beb49d5c9319d80a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d342424301013ec47dc146a4beb49d5c9319d80a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d342424301013ec47dc146a4beb49d5c9319d80a/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7e0032290669fae5f52c256856c53038511c7db4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7e0032290669fae5f52c256856c53038511c7db4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7e0032290669fae5f52c256856c53038511c7db4"
      }
    ],
    "stats": {
      "total": 83,
      "additions": 36,
      "deletions": 47
    },
    "files": [
      {
        "sha": "075c7c391104c6c5c70e6113431054f4dbc20201",
        "filename": "doc/release-notes.md",
        "status": "modified",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d342424301013ec47dc146a4beb49d5c9319d80a/doc/release-notes.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d342424301013ec47dc146a4beb49d5c9319d80a/doc/release-notes.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/doc/release-notes.md?ref=d342424301013ec47dc146a4beb49d5c9319d80a",
        "patch": "@@ -36,6 +36,15 @@ Notable changes\n Low-level RPC changes\n ---------------------\n \n+- The new database model no longer stores information about transaction\n+  versions of unspent outputs. This means that:\n+  - The `gettxout` RPC no longer has a `version` field in the response.\n+  - The `gettxoutsetinfo` RPC reports `hash_serialized_2` instead of `hash_serialized`,\n+    which does not commit to the transaction versions of unspent outputs, but does\n+    commit to the height and coinbase information.\n+  - The `getutxos` REST path no longer reports the `txvers` field in JSON format,\n+    and always reports 0 for transaction versions in the binary format\n+\n - Error codes have been updated to be more accurate for the following error cases:\n   - `getblock` now returns RPC_MISC_ERROR if the block can't be found on disk (for\n   example if the block has been pruned). Previously returned RPC_INTERNAL_ERROR."
      },
      {
        "sha": "12cfd6bf6b47f6b5d16ce3d2df6dd477652f1841",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 5,
        "deletions": 11,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d342424301013ec47dc146a4beb49d5c9319d80a/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d342424301013ec47dc146a4beb49d5c9319d80a/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=d342424301013ec47dc146a4beb49d5c9319d80a",
        "patch": "@@ -84,15 +84,10 @@ class CCoins\n     //! at which height this transaction was included in the active block chain\n     int nHeight;\n \n-    //! version of the CTransaction; accesses to this value should probably check for nHeight as well,\n-    //! as new tx version will probably only be introduced at certain heights\n-    int nVersion;\n-\n     void FromTx(const CTransaction &tx, int nHeightIn) {\n         fCoinBase = tx.IsCoinBase();\n         vout = tx.vout;\n         nHeight = nHeightIn;\n-        nVersion = tx.nVersion;\n         ClearUnspendable();\n     }\n \n@@ -105,11 +100,10 @@ class CCoins\n         fCoinBase = false;\n         std::vector<CTxOut>().swap(vout);\n         nHeight = 0;\n-        nVersion = 0;\n     }\n \n     //! empty constructor\n-    CCoins() : fCoinBase(false), vout(0), nHeight(0), nVersion(0) { }\n+    CCoins() : fCoinBase(false), vout(0), nHeight(0) { }\n \n     //!remove spent outputs at the end of vout\n     void Cleanup() {\n@@ -131,7 +125,6 @@ class CCoins\n         std::swap(to.fCoinBase, fCoinBase);\n         to.vout.swap(vout);\n         std::swap(to.nHeight, nHeight);\n-        std::swap(to.nVersion, nVersion);\n     }\n \n     //! equality test\n@@ -141,7 +134,6 @@ class CCoins\n              return true;\n          return a.fCoinBase == b.fCoinBase &&\n                 a.nHeight == b.nHeight &&\n-                a.nVersion == b.nVersion &&\n                 a.vout == b.vout;\n     }\n     friend bool operator!=(const CCoins &a, const CCoins &b) {\n@@ -163,7 +155,8 @@ class CCoins\n         assert(fFirst || fSecond || nMaskCode);\n         unsigned int nCode = 8*(nMaskCode - (fFirst || fSecond ? 0 : 1)) + (fCoinBase ? 1 : 0) + (fFirst ? 2 : 0) + (fSecond ? 4 : 0);\n         // version\n-        ::Serialize(s, VARINT(this->nVersion));\n+        int nVersionDummy = 0;\n+        ::Serialize(s, VARINT(nVersionDummy));\n         // header code\n         ::Serialize(s, VARINT(nCode));\n         // spentness bitmask\n@@ -187,7 +180,8 @@ class CCoins\n     void Unserialize(Stream &s) {\n         unsigned int nCode = 0;\n         // version\n-        ::Unserialize(s, VARINT(this->nVersion));\n+        int nVersionDummy;\n+        ::Unserialize(s, VARINT(nVersionDummy));\n         // header code\n         ::Unserialize(s, VARINT(nCode));\n         fCoinBase = nCode & 1;"
      },
      {
        "sha": "9c291fe0a9a3449814b44e379ff0e82c2f047222",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 4,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d342424301013ec47dc146a4beb49d5c9319d80a/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d342424301013ec47dc146a4beb49d5c9319d80a/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=d342424301013ec47dc146a4beb49d5c9319d80a",
        "patch": "@@ -42,7 +42,6 @@ static const struct {\n };\n \n struct CCoin {\n-    uint32_t nTxVer; // Don't call this nVersion, that name has a special meaning inside IMPLEMENT_SERIALIZE\n     uint32_t nHeight;\n     CTxOut out;\n \n@@ -51,7 +50,8 @@ struct CCoin {\n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action)\n     {\n-        READWRITE(nTxVer);\n+        uint32_t nTxVerDummy = 0;\n+        READWRITE(nTxVerDummy);\n         READWRITE(nHeight);\n         READWRITE(out);\n     }\n@@ -519,7 +519,6 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n                     // Safe to index into vout here because IsAvailable checked if it's off the end of the array, or if\n                     // n is valid but points to an already spent output (IsNull).\n                     CCoin coin;\n-                    coin.nTxVer = coins.nVersion;\n                     coin.nHeight = coins.nHeight;\n                     coin.out = coins.vout.at(vOutPoints[i].n);\n                     assert(!coin.out.IsNull());\n@@ -568,7 +567,6 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         UniValue utxos(UniValue::VARR);\n         BOOST_FOREACH (const CCoin& coin, outs) {\n             UniValue utxo(UniValue::VOBJ);\n-            utxo.push_back(Pair(\"txvers\", (int32_t)coin.nTxVer));\n             utxo.push_back(Pair(\"height\", (int32_t)coin.nHeight));\n             utxo.push_back(Pair(\"value\", ValueFromAmount(coin.out.nValue)));\n "
      },
      {
        "sha": "d2f955fb32a48f82f0f31fc3efae54975417d203",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 8,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d342424301013ec47dc146a4beb49d5c9319d80a/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d342424301013ec47dc146a4beb49d5c9319d80a/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=d342424301013ec47dc146a4beb49d5c9319d80a",
        "patch": "@@ -781,11 +781,10 @@ struct CCoinsStats\n     uint256 hashBlock;\n     uint64_t nTransactions;\n     uint64_t nTransactionOutputs;\n-    uint64_t nSerializedSize;\n     uint256 hashSerialized;\n     CAmount nTotalAmount;\n \n-    CCoinsStats() : nHeight(0), nTransactions(0), nTransactionOutputs(0), nSerializedSize(0), nTotalAmount(0) {}\n+    CCoinsStats() : nHeight(0), nTransactions(0), nTransactionOutputs(0), nTotalAmount(0) {}\n };\n \n //! Calculate statistics about the unspent transaction output set\n@@ -808,16 +807,17 @@ static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n         if (pcursor->GetKey(key) && pcursor->GetValue(coins)) {\n             stats.nTransactions++;\n             ss << key;\n+            ss << VARINT(coins.nHeight * 2 + coins.fCoinBase);\n             for (unsigned int i=0; i<coins.vout.size(); i++) {\n                 const CTxOut &out = coins.vout[i];\n                 if (!out.IsNull()) {\n                     stats.nTransactionOutputs++;\n                     ss << VARINT(i+1);\n-                    ss << out;\n+                    ss << *(const CScriptBase*)(&out.scriptPubKey);\n+                    ss << VARINT(out.nValue);\n                     nTotalAmount += out.nValue;\n                 }\n             }\n-            stats.nSerializedSize += 32 + pcursor->GetValueSize();\n             ss << VARINT(0);\n         } else {\n             return error(\"%s: unable to read value\", __func__);\n@@ -891,7 +891,6 @@ UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n             \"  \\\"bestblock\\\": \\\"hex\\\",   (string) the best block hash hex\\n\"\n             \"  \\\"transactions\\\": n,      (numeric) The number of transactions\\n\"\n             \"  \\\"txouts\\\": n,            (numeric) The number of output transactions\\n\"\n-            \"  \\\"bytes_serialized\\\": n,  (numeric) The serialized size\\n\"\n             \"  \\\"hash_serialized\\\": \\\"hash\\\",   (string) The serialized hash\\n\"\n             \"  \\\"total_amount\\\": x.xxx          (numeric) The total amount\\n\"\n             \"}\\n\"\n@@ -909,8 +908,7 @@ UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n         ret.push_back(Pair(\"bestblock\", stats.hashBlock.GetHex()));\n         ret.push_back(Pair(\"transactions\", (int64_t)stats.nTransactions));\n         ret.push_back(Pair(\"txouts\", (int64_t)stats.nTransactionOutputs));\n-        ret.push_back(Pair(\"bytes_serialized\", (int64_t)stats.nSerializedSize));\n-        ret.push_back(Pair(\"hash_serialized\", stats.hashSerialized.GetHex()));\n+        ret.push_back(Pair(\"hash_serialized_2\", stats.hashSerialized.GetHex()));\n         ret.push_back(Pair(\"total_amount\", ValueFromAmount(stats.nTotalAmount)));\n     } else {\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Unable to read UTXO set\");\n@@ -992,7 +990,6 @@ UniValue gettxout(const JSONRPCRequest& request)\n     UniValue o(UniValue::VOBJ);\n     ScriptPubKeyToUniv(coins.vout[n].scriptPubKey, o, true);\n     ret.push_back(Pair(\"scriptPubKey\", o));\n-    ret.push_back(Pair(\"version\", coins.nVersion));\n     ret.push_back(Pair(\"coinbase\", coins.fCoinBase));\n \n     return ret;"
      },
      {
        "sha": "3735f6c868efa0fe2c72acb4569178ff34c6e68b",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d342424301013ec47dc146a4beb49d5c9319d80a/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d342424301013ec47dc146a4beb49d5c9319d80a/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=d342424301013ec47dc146a4beb49d5c9319d80a",
        "patch": "@@ -142,7 +142,6 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n                 } else {\n                     updated_an_entry = true;\n                 }\n-                coins.nVersion = insecure_rand();\n                 coins.vout.resize(1);\n                 coins.vout[0].nValue = insecure_rand();\n                 *entry = coins;\n@@ -436,7 +435,6 @@ BOOST_AUTO_TEST_CASE(ccoins_serialization)\n     CDataStream ss1(ParseHex(\"0104835800816115944e077fe7c803cfa57f29b36bf87c1d358bb85e\"), SER_DISK, CLIENT_VERSION);\n     CCoins cc1;\n     ss1 >> cc1;\n-    BOOST_CHECK_EQUAL(cc1.nVersion, 1);\n     BOOST_CHECK_EQUAL(cc1.fCoinBase, false);\n     BOOST_CHECK_EQUAL(cc1.nHeight, 203998);\n     BOOST_CHECK_EQUAL(cc1.vout.size(), 2);\n@@ -449,7 +447,6 @@ BOOST_AUTO_TEST_CASE(ccoins_serialization)\n     CDataStream ss2(ParseHex(\"0109044086ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4eebbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa486af3b\"), SER_DISK, CLIENT_VERSION);\n     CCoins cc2;\n     ss2 >> cc2;\n-    BOOST_CHECK_EQUAL(cc2.nVersion, 1);\n     BOOST_CHECK_EQUAL(cc2.fCoinBase, true);\n     BOOST_CHECK_EQUAL(cc2.nHeight, 120891);\n     BOOST_CHECK_EQUAL(cc2.vout.size(), 17);\n@@ -468,7 +465,6 @@ BOOST_AUTO_TEST_CASE(ccoins_serialization)\n     CDataStream ss3(ParseHex(\"0002000600\"), SER_DISK, CLIENT_VERSION);\n     CCoins cc3;\n     ss3 >> cc3;\n-    BOOST_CHECK_EQUAL(cc3.nVersion, 0);\n     BOOST_CHECK_EQUAL(cc3.fCoinBase, false);\n     BOOST_CHECK_EQUAL(cc3.nHeight, 0);\n     BOOST_CHECK_EQUAL(cc3.vout.size(), 1);"
      },
      {
        "sha": "ef2e695ee3d974e8503d1da39d0437964cbfe183",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 1,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d342424301013ec47dc146a4beb49d5c9319d80a/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d342424301013ec47dc146a4beb49d5c9319d80a/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=d342424301013ec47dc146a4beb49d5c9319d80a",
        "patch": "@@ -471,7 +471,6 @@ BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n         threadGroup.create_thread(boost::bind(&CCheckQueue<CScriptCheck>::Thread, boost::ref(scriptcheckqueue)));\n \n     CCoins coins;\n-    coins.nVersion = 1;\n     coins.fCoinBase = false;\n     for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n         CTxOut txout;"
      },
      {
        "sha": "d21b82e2ec34e5394afc22f324eef6e685b0cdad",
        "filename": "src/undo.h",
        "status": "modified",
        "additions": 12,
        "deletions": 8,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d342424301013ec47dc146a4beb49d5c9319d80a/src/undo.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d342424301013ec47dc146a4beb49d5c9319d80a/src/undo.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/undo.h?ref=d342424301013ec47dc146a4beb49d5c9319d80a",
        "patch": "@@ -14,24 +14,26 @@\n  *\n  *  Contains the prevout's CTxOut being spent, and if this was the\n  *  last output of the affected transaction, its metadata as well\n- *  (coinbase or not, height, transaction version)\n+ *  (coinbase or not, height). Earlier versions also stored the transaction\n+ *  version.\n  */\n class CTxInUndo\n {\n public:\n     CTxOut txout;         // the txout data before being spent\n     bool fCoinBase;       // if the outpoint was the last unspent: whether it belonged to a coinbase\n     unsigned int nHeight; // if the outpoint was the last unspent: its height\n-    int nVersion;         // if the outpoint was the last unspent: its version\n \n-    CTxInUndo() : txout(), fCoinBase(false), nHeight(0), nVersion(0) {}\n-    CTxInUndo(const CTxOut &txoutIn, bool fCoinBaseIn = false, unsigned int nHeightIn = 0, int nVersionIn = 0) : txout(txoutIn), fCoinBase(fCoinBaseIn), nHeight(nHeightIn), nVersion(nVersionIn) { }\n+    CTxInUndo() : txout(), fCoinBase(false), nHeight(0) {}\n+    CTxInUndo(const CTxOut &txoutIn, bool fCoinBaseIn = false, unsigned int nHeightIn = 0) : txout(txoutIn), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) { }\n \n     template<typename Stream>\n     void Serialize(Stream &s) const {\n         ::Serialize(s, VARINT(nHeight*2+(fCoinBase ? 1 : 0)));\n-        if (nHeight > 0)\n-            ::Serialize(s, VARINT(this->nVersion));\n+        if (nHeight > 0) {\n+            int nVersionDummy = 0;\n+            ::Serialize(s, VARINT(nVersionDummy));\n+        }\n         ::Serialize(s, CTxOutCompressor(REF(txout)));\n     }\n \n@@ -41,8 +43,10 @@ class CTxInUndo\n         ::Unserialize(s, VARINT(nCode));\n         nHeight = nCode / 2;\n         fCoinBase = nCode & 1;\n-        if (nHeight > 0)\n-            ::Unserialize(s, VARINT(this->nVersion));\n+        if (nHeight > 0) {\n+            int nVersionDummy;\n+            ::Unserialize(s, VARINT(nVersionDummy));\n+        }\n         ::Unserialize(s, REF(CTxOutCompressor(REF(txout))));\n     }\n };"
      },
      {
        "sha": "be0c9b564e150c6564ed74f6a00b733743629ded",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 7,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d342424301013ec47dc146a4beb49d5c9319d80a/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d342424301013ec47dc146a4beb49d5c9319d80a/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=d342424301013ec47dc146a4beb49d5c9319d80a",
        "patch": "@@ -1086,7 +1086,6 @@ void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txund\n                 CTxInUndo& undo = txundo.vprevout.back();\n                 undo.nHeight = coins->nHeight;\n                 undo.fCoinBase = coins->fCoinBase;\n-                undo.nVersion = coins->nVersion;\n             }\n         }\n     }\n@@ -1271,7 +1270,6 @@ int ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint&\n         if (!coins->IsPruned()) fClean = false; // overwriting existing transaction\n         coins->fCoinBase = undo.fCoinBase;\n         coins->nHeight = undo.nHeight;\n-        coins->nVersion = undo.nVersion;\n     } else {\n         if (coins->IsPruned()) fClean = false; // adding output to missing transaction\n     }\n@@ -1319,11 +1317,6 @@ static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex*\n         outs->ClearUnspendable();\n \n         CCoins outsBlock(tx, pindex->nHeight);\n-        // The CCoins serialization does not serialize negative numbers.\n-        // No network rules currently depend on the version here, so an inconsistency is harmless\n-        // but it must be corrected before txout nversion ever influences a network rule.\n-        if (outsBlock.nVersion < 0)\n-            outs->nVersion = outsBlock.nVersion;\n         if (*outs != outsBlock) fClean = false; // transaction mismatch\n \n         // remove outputs"
      },
      {
        "sha": "b0faea9b38d2d0f72c3143121565a515dc7a0054",
        "filename": "test/functional/blockchain.py",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d342424301013ec47dc146a4beb49d5c9319d80a/test/functional/blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d342424301013ec47dc146a4beb49d5c9319d80a/test/functional/blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/blockchain.py?ref=d342424301013ec47dc146a4beb49d5c9319d80a",
        "patch": "@@ -49,10 +49,9 @@ def _test_gettxoutsetinfo(self):\n         assert_equal(res['transactions'], 200)\n         assert_equal(res['height'], 200)\n         assert_equal(res['txouts'], 200)\n-        assert_equal(res['bytes_serialized'], 13924),\n         assert_equal(res['bestblock'], node.getblockhash(200))\n         assert_equal(len(res['bestblock']), 64)\n-        assert_equal(len(res['hash_serialized']), 64)\n+        assert_equal(len(res['hash_serialized_2']), 64)\n \n         self.log.info(\"Test that gettxoutsetinfo() works for blockchain with just the genesis block\")\n         b1hash = node.getblockhash(1)\n@@ -64,7 +63,7 @@ def _test_gettxoutsetinfo(self):\n         assert_equal(res2['height'], 0)\n         assert_equal(res2['txouts'], 0)\n         assert_equal(res2['bestblock'], node.getblockhash(0))\n-        assert_equal(len(res2['hash_serialized']), 64)\n+        assert_equal(len(res2['hash_serialized_2']), 64)\n \n         self.log.info(\"Test that gettxoutsetinfo() returns the same result after invalidate/reconsider block\")\n         node.reconsiderblock(b1hash)\n@@ -75,7 +74,7 @@ def _test_gettxoutsetinfo(self):\n         assert_equal(res['height'], res3['height'])\n         assert_equal(res['txouts'], res3['txouts'])\n         assert_equal(res['bestblock'], res3['bestblock'])\n-        assert_equal(res['hash_serialized'], res3['hash_serialized'])\n+        assert_equal(res['hash_serialized_2'], res3['hash_serialized_2'])\n \n     def _test_getblockheader(self):\n         node = self.nodes[0]"
      }
    ]
  },
  {
    "sha": "c3aa0c11947dfd82702df276d39bb7f748dd83a1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjM2FhMGMxMTk0N2RmZDgyNzAyZGYyNzZkMzliYjdmNzQ4ZGQ4M2Ex",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-12T22:19:19Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-26T20:33:39Z"
      },
      "message": "Report on-disk size in gettxoutsetinfo",
      "tree": {
        "sha": "56b0c561bee4a5fcf9f6c54b85c9d1200569d718",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/56b0c561bee4a5fcf9f6c54b85c9d1200569d718"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c3aa0c11947dfd82702df276d39bb7f748dd83a1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c3aa0c11947dfd82702df276d39bb7f748dd83a1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c3aa0c11947dfd82702df276d39bb7f748dd83a1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c3aa0c11947dfd82702df276d39bb7f748dd83a1/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d342424301013ec47dc146a4beb49d5c9319d80a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d342424301013ec47dc146a4beb49d5c9319d80a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d342424301013ec47dc146a4beb49d5c9319d80a"
      }
    ],
    "stats": {
      "total": 36,
      "additions": 35,
      "deletions": 1
    },
    "files": [
      {
        "sha": "02f424fad6d7087743121f92600ed3d83a3f9000",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3aa0c11947dfd82702df276d39bb7f748dd83a1/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3aa0c11947dfd82702df276d39bb7f748dd83a1/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=c3aa0c11947dfd82702df276d39bb7f748dd83a1",
        "patch": "@@ -55,6 +55,7 @@ uint256 CCoinsViewBacked::GetBestBlock() const { return base->GetBestBlock(); }\n void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n CCoinsViewCursor *CCoinsViewBacked::Cursor() const { return base->Cursor(); }\n+size_t CCoinsViewBacked::EstimateSize() const { return base->EstimateSize(); }\n \n SaltedTxidHasher::SaltedTxidHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}\n "
      },
      {
        "sha": "47ef90114b5c6c826cb7ea21fdb9cdca483c004a",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3aa0c11947dfd82702df276d39bb7f748dd83a1/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3aa0c11947dfd82702df276d39bb7f748dd83a1/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=c3aa0c11947dfd82702df276d39bb7f748dd83a1",
        "patch": "@@ -319,6 +319,9 @@ class CCoinsView\n \n     //! As we use CCoinsViews polymorphically, have a virtual destructor\n     virtual ~CCoinsView() {}\n+\n+    //! Estimate database size (0 if not implemented)\n+    virtual size_t EstimateSize() const { return 0; }\n };\n \n \n@@ -336,6 +339,7 @@ class CCoinsViewBacked : public CCoinsView\n     void SetBackend(CCoinsView &viewIn);\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n     CCoinsViewCursor *Cursor() const;\n+    size_t EstimateSize() const override;\n };\n \n "
      },
      {
        "sha": "24ef71bfbffa9461eadcc94e0db83bb3dd3c5a70",
        "filename": "src/dbwrapper.h",
        "status": "modified",
        "additions": 16,
        "deletions": 1,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3aa0c11947dfd82702df276d39bb7f748dd83a1/src/dbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3aa0c11947dfd82702df276d39bb7f748dd83a1/src/dbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.h?ref=c3aa0c11947dfd82702df276d39bb7f748dd83a1",
        "patch": "@@ -305,7 +305,22 @@ class CDBWrapper\n      * Return true if the database managed by this class contains no entries.\n      */\n     bool IsEmpty();\n+\n+    template<typename K>\n+    size_t EstimateSize(const K& key_begin, const K& key_end) const\n+    {\n+        CDataStream ssKey1(SER_DISK, CLIENT_VERSION), ssKey2(SER_DISK, CLIENT_VERSION);\n+        ssKey1.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n+        ssKey2.reserve(DBWRAPPER_PREALLOC_KEY_SIZE);\n+        ssKey1 << key_begin;\n+        ssKey2 << key_end;\n+        leveldb::Slice slKey1(ssKey1.data(), ssKey1.size());\n+        leveldb::Slice slKey2(ssKey2.data(), ssKey2.size());\n+        uint64_t size = 0;\n+        leveldb::Range range(slKey1, slKey2);\n+        pdb->GetApproximateSizes(&range, 1, &size);\n+        return size;\n+    }\n };\n \n #endif // BITCOIN_DBWRAPPER_H\n-"
      },
      {
        "sha": "e59b9b86bbf8428c76db08e7c3ab17f386f3d813",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3aa0c11947dfd82702df276d39bb7f748dd83a1/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3aa0c11947dfd82702df276d39bb7f748dd83a1/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=c3aa0c11947dfd82702df276d39bb7f748dd83a1",
        "patch": "@@ -782,6 +782,7 @@ struct CCoinsStats\n     uint64_t nTransactions;\n     uint64_t nTransactionOutputs;\n     uint256 hashSerialized;\n+    uint64_t nDiskSize;\n     CAmount nTotalAmount;\n \n     CCoinsStats() : nHeight(0), nTransactions(0), nTransactionOutputs(0), nTotalAmount(0) {}\n@@ -826,6 +827,7 @@ static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n     }\n     stats.hashSerialized = ss.GetHash();\n     stats.nTotalAmount = nTotalAmount;\n+    stats.nDiskSize = view->EstimateSize();\n     return true;\n }\n \n@@ -892,6 +894,7 @@ UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n             \"  \\\"transactions\\\": n,      (numeric) The number of transactions\\n\"\n             \"  \\\"txouts\\\": n,            (numeric) The number of output transactions\\n\"\n             \"  \\\"hash_serialized\\\": \\\"hash\\\",   (string) The serialized hash\\n\"\n+            \"  \\\"disk_size\\\": n,         (numeric) The estimated size of the chainstate on disk\\n\"\n             \"  \\\"total_amount\\\": x.xxx          (numeric) The total amount\\n\"\n             \"}\\n\"\n             \"\\nExamples:\\n\"\n@@ -909,6 +912,7 @@ UniValue gettxoutsetinfo(const JSONRPCRequest& request)\n         ret.push_back(Pair(\"transactions\", (int64_t)stats.nTransactions));\n         ret.push_back(Pair(\"txouts\", (int64_t)stats.nTransactionOutputs));\n         ret.push_back(Pair(\"hash_serialized_2\", stats.hashSerialized.GetHex()));\n+        ret.push_back(Pair(\"disk_size\", stats.nDiskSize));\n         ret.push_back(Pair(\"total_amount\", ValueFromAmount(stats.nTotalAmount)));\n     } else {\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Unable to read UTXO set\");"
      },
      {
        "sha": "f139384a223664e03f26631a0d857ed8eeb6ddae",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3aa0c11947dfd82702df276d39bb7f748dd83a1/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3aa0c11947dfd82702df276d39bb7f748dd83a1/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=c3aa0c11947dfd82702df276d39bb7f748dd83a1",
        "patch": "@@ -67,6 +67,11 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     return db.WriteBatch(batch);\n }\n \n+size_t CCoinsViewDB::EstimateSize() const\n+{\n+    return db.EstimateSize(DB_COINS, (char)(DB_COINS+1));\n+}\n+\n CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CDBWrapper(GetDataDir() / \"blocks\" / \"index\", nCacheSize, fMemory, fWipe) {\n }\n "
      },
      {
        "sha": "df164cb820990d4ecf32574f85a6133869f6849e",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3aa0c11947dfd82702df276d39bb7f748dd83a1/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3aa0c11947dfd82702df276d39bb7f748dd83a1/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=c3aa0c11947dfd82702df276d39bb7f748dd83a1",
        "patch": "@@ -78,6 +78,8 @@ class CCoinsViewDB : public CCoinsView\n     uint256 GetBestBlock() const;\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n     CCoinsViewCursor *Cursor() const;\n+\n+    size_t EstimateSize() const override;\n };\n \n /** Specialization of CCoinsViewCursor to iterate over a CCoinsViewDB */"
      },
      {
        "sha": "4bfd3ee6770233c081ac2fd96046afcceffb0271",
        "filename": "test/functional/blockchain.py",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c3aa0c11947dfd82702df276d39bb7f748dd83a1/test/functional/blockchain.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c3aa0c11947dfd82702df276d39bb7f748dd83a1/test/functional/blockchain.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/blockchain.py?ref=c3aa0c11947dfd82702df276d39bb7f748dd83a1",
        "patch": "@@ -50,6 +50,9 @@ def _test_gettxoutsetinfo(self):\n         assert_equal(res['height'], 200)\n         assert_equal(res['txouts'], 200)\n         assert_equal(res['bestblock'], node.getblockhash(200))\n+        size = res['disk_size']\n+        assert size > 6400\n+        assert size < 64000\n         assert_equal(len(res['bestblock']), 64)\n         assert_equal(len(res['hash_serialized_2']), 64)\n "
      }
    ]
  },
  {
    "sha": "7d991b55dbf0b0f6e21c0680ee3ebd09df09012f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3ZDk5MWI1NWRiZjBiMGY2ZTIxYzA2ODBlZTNlYmQwOWRmMDkwMTJm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:19Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-26T20:33:39Z"
      },
      "message": "Store/allow tx metadata in all undo records\n\nPreviously, transaction metadata (height, coinbase or not, and before\nthe previous commit also nVersion) was only stored for undo records\nthat correspond to the last output of a transaction being spent.\n\nThis only saves 2 bytes per undo record. Change this to storing this\ninformation for every undo record, and stop complaining for having it\nin non-last output spends. This means that undo dat written with\nthis patch won't be readable by older versions anymore.",
      "tree": {
        "sha": "78cebf3cfb52326c900393014c7f8b8a3f68210e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/78cebf3cfb52326c900393014c7f8b8a3f68210e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/7d991b55dbf0b0f6e21c0680ee3ebd09df09012f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d991b55dbf0b0f6e21c0680ee3ebd09df09012f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/7d991b55dbf0b0f6e21c0680ee3ebd09df09012f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d991b55dbf0b0f6e21c0680ee3ebd09df09012f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c3aa0c11947dfd82702df276d39bb7f748dd83a1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c3aa0c11947dfd82702df276d39bb7f748dd83a1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c3aa0c11947dfd82702df276d39bb7f748dd83a1"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 11,
      "deletions": 9
    },
    "files": [
      {
        "sha": "37a1c89f4546a3036bd0d17fb148a0e01053986d",
        "filename": "src/undo.h",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d991b55dbf0b0f6e21c0680ee3ebd09df09012f/src/undo.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d991b55dbf0b0f6e21c0680ee3ebd09df09012f/src/undo.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/undo.h?ref=7d991b55dbf0b0f6e21c0680ee3ebd09df09012f",
        "patch": "@@ -12,8 +12,7 @@\n \n /** Undo information for a CTxIn\n  *\n- *  Contains the prevout's CTxOut being spent, and if this was the\n- *  last output of the affected transaction, its metadata as well\n+ *  Contains the prevout's CTxOut being spent, and its metadata as well\n  *  (coinbase or not, height). Earlier versions also stored the transaction\n  *  version.\n  */"
      },
      {
        "sha": "fccef17196ae9b297e3fc9a675a0447ac304d38b",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/7d991b55dbf0b0f6e21c0680ee3ebd09df09012f/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/7d991b55dbf0b0f6e21c0680ee3ebd09df09012f/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=7d991b55dbf0b0f6e21c0680ee3ebd09df09012f",
        "patch": "@@ -1082,11 +1082,9 @@ void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txund\n             // mark an outpoint spent, and construct undo information\n             txundo.vprevout.push_back(CTxInUndo(coins->vout[nPos]));\n             coins->Spend(nPos);\n-            if (coins->vout.size() == 0) {\n-                CTxInUndo& undo = txundo.vprevout.back();\n-                undo.nHeight = coins->nHeight;\n-                undo.fCoinBase = coins->fCoinBase;\n-            }\n+            CTxInUndo& undo = txundo.vprevout.back();\n+            undo.nHeight = coins->nHeight;\n+            undo.fCoinBase = coins->fCoinBase;\n         }\n     }\n     // add outputs\n@@ -1266,11 +1264,16 @@ int ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint&\n \n     CCoinsModifier coins = view.ModifyCoins(out.hash);\n     if (undo.nHeight != 0) {\n-        // undo data contains height: this is the last output of the prevout tx being spent\n-        if (!coins->IsPruned()) fClean = false; // overwriting existing transaction\n+        if (!coins->IsPruned()) {\n+            if (coins->fCoinBase != undo.fCoinBase || (uint32_t)coins->nHeight != undo.nHeight) fClean = false; // metadata mismatch\n+        }\n+        // restore height/coinbase tx metadata from undo data\n         coins->fCoinBase = undo.fCoinBase;\n         coins->nHeight = undo.nHeight;\n     } else {\n+        // Undo data does not contain height/coinbase. This should never happen\n+        // for newly created undo entries. Previously, this data was only saved\n+        // for the last spend of a transaction's outputs, so check IsPruned().\n         if (coins->IsPruned()) fClean = false; // adding output to missing transaction\n     }\n     if (coins->IsAvailable(out.n)) fClean = false; // overwriting existing output"
      }
    ]
  },
  {
    "sha": "422634e2f5ac1ff74cd358144cecbac63007adc4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MjI2MzRlMmY1YWMxZmY3NGNkMzU4MTQ0Y2VjYmFjNjMwMDdhZGM0",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:23Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-26T20:33:40Z"
      },
      "message": "Introduce Coin, a single unspent output",
      "tree": {
        "sha": "bf1b3f471a9685b0754731f1679a922ad22ef1a2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bf1b3f471a9685b0754731f1679a922ad22ef1a2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/422634e2f5ac1ff74cd358144cecbac63007adc4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/422634e2f5ac1ff74cd358144cecbac63007adc4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/422634e2f5ac1ff74cd358144cecbac63007adc4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/422634e2f5ac1ff74cd358144cecbac63007adc4/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "7d991b55dbf0b0f6e21c0680ee3ebd09df09012f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/7d991b55dbf0b0f6e21c0680ee3ebd09df09012f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/7d991b55dbf0b0f6e21c0680ee3ebd09df09012f"
      }
    ],
    "stats": {
      "total": 62,
      "additions": 62,
      "deletions": 0
    },
    "files": [
      {
        "sha": "69c24ab45af8756535fd9e7688d7962babe96c39",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 62,
        "deletions": 0,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/422634e2f5ac1ff74cd358144cecbac63007adc4/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/422634e2f5ac1ff74cd358144cecbac63007adc4/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=422634e2f5ac1ff74cd358144cecbac63007adc4",
        "patch": "@@ -20,6 +20,68 @@\n #include <boost/foreach.hpp>\n #include <unordered_map>\n \n+/**\n+ * A UTXO entry.\n+ *\n+ * Serialized format:\n+ * - VARINT((coinbase ? 1 : 0) | (height << 1))\n+ * - the non-spent CTxOut (via CTxOutCompressor)\n+ */\n+class Coin\n+{\n+public:\n+    //! whether the containing transaction was a coinbase\n+    bool fCoinBase;\n+\n+    //! unspent transaction output\n+    CTxOut out;\n+\n+    //! at which height the containing transaction was included in the active block chain\n+    uint32_t nHeight;\n+\n+    //! construct a Coin from a CTxOut and height/coinbase properties.\n+    Coin(CTxOut&& outIn, int nHeightIn, bool fCoinBaseIn) : fCoinBase(fCoinBaseIn), out(std::move(outIn)), nHeight(nHeightIn) {}\n+    Coin(const CTxOut& outIn, int nHeightIn, bool fCoinBaseIn) : fCoinBase(fCoinBaseIn), out(outIn), nHeight(nHeightIn) {}\n+\n+    void Clear() {\n+        out.SetNull();\n+        fCoinBase = false;\n+        nHeight = 0;\n+    }\n+\n+    //! empty constructor\n+    Coin() : fCoinBase(false), nHeight(0) { }\n+\n+    bool IsCoinBase() const {\n+        return fCoinBase;\n+    }\n+\n+    template<typename Stream>\n+    void Serialize(Stream &s) const {\n+        assert(!IsPruned());\n+        uint32_t code = nHeight * 2 + fCoinBase;\n+        ::Serialize(s, VARINT(code));\n+        ::Serialize(s, CTxOutCompressor(REF(out)));\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream &s) {\n+        uint32_t code = 0;\n+        ::Unserialize(s, VARINT(code));\n+        nHeight = code >> 1;\n+        fCoinBase = code & 1;\n+        ::Unserialize(s, REF(CTxOutCompressor(out)));\n+    }\n+\n+    bool IsPruned() const {\n+        return out.IsNull();\n+    }\n+\n+    size_t DynamicMemoryUsage() const {\n+        return memusage::DynamicUsage(out.scriptPubKey);\n+    }\n+};\n+\n /** \n  * Pruned version of CTransaction: only retains metadata and unspent transaction outputs\n  *"
      }
    ]
  },
  {
    "sha": "cb2c7fdac2dc74368ed24ae4717ed72178956b92",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYjJjN2ZkYWMyZGM3NDM2OGVkMjRhZTQ3MTdlZDcyMTc4OTU2Yjky",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:25Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T18:56:06Z"
      },
      "message": "Replace CTxInUndo with Coin\n\nThe earlier CTxInUndo class now holds the same information as the Coin\nclass. Instead of duplicating functionality, replace CTxInUndo with a\nserialization adapter for Coin.",
      "tree": {
        "sha": "e00cdf124e4399033b2d9354e82e1f5496144903",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e00cdf124e4399033b2d9354e82e1f5496144903"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cb2c7fdac2dc74368ed24ae4717ed72178956b92",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb2c7fdac2dc74368ed24ae4717ed72178956b92",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cb2c7fdac2dc74368ed24ae4717ed72178956b92",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb2c7fdac2dc74368ed24ae4717ed72178956b92/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "422634e2f5ac1ff74cd358144cecbac63007adc4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/422634e2f5ac1ff74cd358144cecbac63007adc4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/422634e2f5ac1ff74cd358144cecbac63007adc4"
      }
    ],
    "stats": {
      "total": 99,
      "additions": 63,
      "deletions": 36
    },
    "files": [
      {
        "sha": "e86c719944b1f91e6c782d69f707ac458222ac0b",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb2c7fdac2dc74368ed24ae4717ed72178956b92/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb2c7fdac2dc74368ed24ae4717ed72178956b92/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=cb2c7fdac2dc74368ed24ae4717ed72178956b92",
        "patch": "@@ -17,7 +17,7 @@\n \n #include <boost/test/unit_test.hpp>\n \n-int ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint& out);\n+int ApplyTxInUndo(const Coin& undo, CCoinsViewCache& view, const COutPoint& out);\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txundo, int nHeight);\n \n namespace\n@@ -371,7 +371,7 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n             // restore inputs\n             if (!tx.IsCoinBase()) {\n                 const COutPoint &out = tx.vin[0].prevout;\n-                const CTxInUndo &undoin = undo.vprevout[0];\n+                const Coin &undoin = undo.vprevout[0];\n                 ApplyTxInUndo(undoin, *(stack.back()), out);\n             }\n             // Store as a candidate for reconnection"
      },
      {
        "sha": "3749d5d7a8df79c1f8e04626b438a48d66a4e979",
        "filename": "src/undo.h",
        "status": "modified",
        "additions": 53,
        "deletions": 24,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb2c7fdac2dc74368ed24ae4717ed72178956b92/src/undo.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb2c7fdac2dc74368ed24ae4717ed72178956b92/src/undo.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/undo.h?ref=cb2c7fdac2dc74368ed24ae4717ed72178956b92",
        "patch": "@@ -7,61 +7,90 @@\n #define BITCOIN_UNDO_H\n \n #include \"compressor.h\" \n+#include \"consensus/consensus.h\"\n #include \"primitives/transaction.h\"\n #include \"serialize.h\"\n \n /** Undo information for a CTxIn\n  *\n  *  Contains the prevout's CTxOut being spent, and its metadata as well\n- *  (coinbase or not, height). Earlier versions also stored the transaction\n- *  version.\n+ *  (coinbase or not, height). The serialization contains a dummy value of\n+ *  zero. This is be compatible with older versions which expect to see\n+ *  the transaction version there.\n  */\n-class CTxInUndo\n+class TxInUndoSerializer\n {\n-public:\n-    CTxOut txout;         // the txout data before being spent\n-    bool fCoinBase;       // if the outpoint was the last unspent: whether it belonged to a coinbase\n-    unsigned int nHeight; // if the outpoint was the last unspent: its height\n-\n-    CTxInUndo() : txout(), fCoinBase(false), nHeight(0) {}\n-    CTxInUndo(const CTxOut &txoutIn, bool fCoinBaseIn = false, unsigned int nHeightIn = 0) : txout(txoutIn), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) { }\n+    const Coin* txout;\n \n+public:\n     template<typename Stream>\n     void Serialize(Stream &s) const {\n-        ::Serialize(s, VARINT(nHeight*2+(fCoinBase ? 1 : 0)));\n-        if (nHeight > 0) {\n-            int nVersionDummy = 0;\n-            ::Serialize(s, VARINT(nVersionDummy));\n+        ::Serialize(s, VARINT(txout->nHeight * 2 + (txout->fCoinBase ? 1 : 0)));\n+        if (txout->nHeight > 0) {\n+            // Required to maintain compatibility with older undo format.\n+            ::Serialize(s, (unsigned char)0);\n         }\n-        ::Serialize(s, CTxOutCompressor(REF(txout)));\n+        ::Serialize(s, CTxOutCompressor(REF(txout->out)));\n     }\n \n+    TxInUndoSerializer(const Coin* coin) : txout(coin) {}\n+};\n+\n+class TxInUndoDeserializer\n+{\n+    Coin* txout;\n+\n+public:\n     template<typename Stream>\n     void Unserialize(Stream &s) {\n         unsigned int nCode = 0;\n         ::Unserialize(s, VARINT(nCode));\n-        nHeight = nCode / 2;\n-        fCoinBase = nCode & 1;\n-        if (nHeight > 0) {\n+        txout->nHeight = nCode / 2;\n+        txout->fCoinBase = nCode & 1;\n+        if (txout->nHeight > 0) {\n+            // Old versions stored the version number for the last spend of\n+            // a transaction's outputs. Non-final spends were indicated with\n+            // height = 0.\n             int nVersionDummy;\n             ::Unserialize(s, VARINT(nVersionDummy));\n         }\n-        ::Unserialize(s, REF(CTxOutCompressor(REF(txout))));\n+        ::Unserialize(s, REF(CTxOutCompressor(REF(txout->out))));\n     }\n+\n+    TxInUndoDeserializer(Coin* coin) : txout(coin) {}\n };\n \n+static const size_t MAX_INPUTS_PER_BLOCK = MAX_BLOCK_BASE_SIZE / ::GetSerializeSize(CTxIn(), SER_NETWORK, PROTOCOL_VERSION);\n+\n /** Undo information for a CTransaction */\n class CTxUndo\n {\n public:\n     // undo information for all txins\n-    std::vector<CTxInUndo> vprevout;\n+    std::vector<Coin> vprevout;\n \n-    ADD_SERIALIZE_METHODS;\n+    template <typename Stream>\n+    void Serialize(Stream& s) const {\n+        // TODO: avoid reimplementing vector serializer\n+        uint64_t count = vprevout.size();\n+        ::Serialize(s, COMPACTSIZE(REF(count)));\n+        for (const auto& prevout : vprevout) {\n+            ::Serialize(s, REF(TxInUndoSerializer(&prevout)));\n+        }\n+    }\n \n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITE(vprevout);\n+    template <typename Stream>\n+    void Unserialize(Stream& s) {\n+        // TODO: avoid reimplementing vector deserializer\n+        uint64_t count = 0;\n+        ::Unserialize(s, COMPACTSIZE(count));\n+        if (count > MAX_INPUTS_PER_BLOCK) {\n+            throw std::ios_base::failure(\"Too many input undo records\");\n+        }\n+        vprevout.resize(count);\n+        for (auto& prevout : vprevout) {\n+            ::Unserialize(s, REF(TxInUndoDeserializer(&prevout)));\n+        }\n     }\n };\n "
      },
      {
        "sha": "dad0e1a3ee4a62b1fe4cf7d928f8dc55606105c5",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 10,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cb2c7fdac2dc74368ed24ae4717ed72178956b92/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cb2c7fdac2dc74368ed24ae4717ed72178956b92/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=cb2c7fdac2dc74368ed24ae4717ed72178956b92",
        "patch": "@@ -1080,11 +1080,9 @@ void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txund\n             if (nPos >= coins->vout.size() || coins->vout[nPos].IsNull())\n                 assert(false);\n             // mark an outpoint spent, and construct undo information\n-            txundo.vprevout.push_back(CTxInUndo(coins->vout[nPos]));\n-            coins->Spend(nPos);\n-            CTxInUndo& undo = txundo.vprevout.back();\n-            undo.nHeight = coins->nHeight;\n-            undo.fCoinBase = coins->fCoinBase;\n+            txundo.vprevout.emplace_back(coins->vout[nPos], coins->nHeight, coins->fCoinBase);\n+            bool ret = coins->Spend(nPos);\n+            assert(ret);\n         }\n     }\n     // add outputs\n@@ -1252,13 +1250,13 @@ enum DisconnectResult\n };\n \n /**\n- * Apply the undo operation of a CTxInUndo to the given chain state.\n- * @param undo The undo object.\n+ * Restore the UTXO in a Coin at a given COutPoint\n+ * @param undo The Coin to be restored.\n  * @param view The coins view to which to apply the changes.\n  * @param out The out point that corresponds to the tx input.\n  * @return A DisconnectResult as an int\n  */\n-int ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint& out)\n+int ApplyTxInUndo(const Coin& undo, CCoinsViewCache& view, const COutPoint& out)\n {\n     bool fClean = true;\n \n@@ -1279,7 +1277,7 @@ int ApplyTxInUndo(const CTxInUndo& undo, CCoinsViewCache& view, const COutPoint&\n     if (coins->IsAvailable(out.n)) fClean = false; // overwriting existing output\n     if (coins->vout.size() < out.n+1)\n         coins->vout.resize(out.n+1);\n-    coins->vout[out.n] = undo.txout;\n+    coins->vout[out.n] = undo.out;\n \n     return fClean ? DISCONNECT_OK : DISCONNECT_UNCLEAN;\n }\n@@ -1335,7 +1333,7 @@ static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex*\n             }\n             for (unsigned int j = tx.vin.size(); j-- > 0;) {\n                 const COutPoint &out = tx.vin[j].prevout;\n-                const CTxInUndo &undo = txundo.vprevout[j];\n+                const Coin &undo = txundo.vprevout[j];\n                 int res = ApplyTxInUndo(undo, view, out);\n                 if (res == DISCONNECT_FAILED) return DISCONNECT_FAILED;\n                 fClean = fClean && res != DISCONNECT_UNCLEAN;"
      }
    ]
  },
  {
    "sha": "bd83111a0fcfdb97204a0180bcf861d3b53bb6c2",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiZDgzMTExYTBmY2ZkYjk3MjA0YTAxODBiY2Y4NjFkM2I1M2JiNmMy",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:27Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T18:56:06Z"
      },
      "message": "Optimization: Coin&& to ApplyTxInUndo\n\nThis avoids a prevector copy in ApplyTxInUndo.",
      "tree": {
        "sha": "365ac791ba05350f8b28f06076157e0d9edacae6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/365ac791ba05350f8b28f06076157e0d9edacae6"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/bd83111a0fcfdb97204a0180bcf861d3b53bb6c2",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd83111a0fcfdb97204a0180bcf861d3b53bb6c2",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/bd83111a0fcfdb97204a0180bcf861d3b53bb6c2",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd83111a0fcfdb97204a0180bcf861d3b53bb6c2/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cb2c7fdac2dc74368ed24ae4717ed72178956b92",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cb2c7fdac2dc74368ed24ae4717ed72178956b92",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cb2c7fdac2dc74368ed24ae4717ed72178956b92"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 8,
      "deletions": 8
    },
    "files": [
      {
        "sha": "9c758ee9abd00d6878d45333ea43fb8648a32bc0",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd83111a0fcfdb97204a0180bcf861d3b53bb6c2/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd83111a0fcfdb97204a0180bcf861d3b53bb6c2/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=bd83111a0fcfdb97204a0180bcf861d3b53bb6c2",
        "patch": "@@ -17,7 +17,7 @@\n \n #include <boost/test/unit_test.hpp>\n \n-int ApplyTxInUndo(const Coin& undo, CCoinsViewCache& view, const COutPoint& out);\n+int ApplyTxInUndo(Coin&& undo, CCoinsViewCache& view, const COutPoint& out);\n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txundo, int nHeight);\n \n namespace\n@@ -371,8 +371,8 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n             // restore inputs\n             if (!tx.IsCoinBase()) {\n                 const COutPoint &out = tx.vin[0].prevout;\n-                const Coin &undoin = undo.vprevout[0];\n-                ApplyTxInUndo(undoin, *(stack.back()), out);\n+                Coin coin = undo.vprevout[0];\n+                ApplyTxInUndo(std::move(coin), *(stack.back()), out);\n             }\n             // Store as a candidate for reconnection\n             disconnectedids.insert(undohash);"
      },
      {
        "sha": "d6cc59b4872b34e5427e46ca531735bf2a111740",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 5,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/bd83111a0fcfdb97204a0180bcf861d3b53bb6c2/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/bd83111a0fcfdb97204a0180bcf861d3b53bb6c2/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=bd83111a0fcfdb97204a0180bcf861d3b53bb6c2",
        "patch": "@@ -1256,7 +1256,7 @@ enum DisconnectResult\n  * @param out The out point that corresponds to the tx input.\n  * @return A DisconnectResult as an int\n  */\n-int ApplyTxInUndo(const Coin& undo, CCoinsViewCache& view, const COutPoint& out)\n+int ApplyTxInUndo(Coin&& undo, CCoinsViewCache& view, const COutPoint& out)\n {\n     bool fClean = true;\n \n@@ -1277,7 +1277,7 @@ int ApplyTxInUndo(const Coin& undo, CCoinsViewCache& view, const COutPoint& out)\n     if (coins->IsAvailable(out.n)) fClean = false; // overwriting existing output\n     if (coins->vout.size() < out.n+1)\n         coins->vout.resize(out.n+1);\n-    coins->vout[out.n] = undo.out;\n+    coins->vout[out.n] = std::move(undo.out);\n \n     return fClean ? DISCONNECT_OK : DISCONNECT_UNCLEAN;\n }\n@@ -1326,18 +1326,18 @@ static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex*\n \n         // restore inputs\n         if (i > 0) { // not coinbases\n-            const CTxUndo &txundo = blockUndo.vtxundo[i-1];\n+            CTxUndo &txundo = blockUndo.vtxundo[i-1];\n             if (txundo.vprevout.size() != tx.vin.size()) {\n                 error(\"DisconnectBlock(): transaction and undo data inconsistent\");\n                 return DISCONNECT_FAILED;\n             }\n             for (unsigned int j = tx.vin.size(); j-- > 0;) {\n                 const COutPoint &out = tx.vin[j].prevout;\n-                const Coin &undo = txundo.vprevout[j];\n-                int res = ApplyTxInUndo(undo, view, out);\n+                int res = ApplyTxInUndo(std::move(txundo.vprevout[j]), view, out);\n                 if (res == DISCONNECT_FAILED) return DISCONNECT_FAILED;\n                 fClean = fClean && res != DISCONNECT_UNCLEAN;\n             }\n+            // At this point, all of txundo.vprevout should have been moved out.\n         }\n     }\n "
      }
    ]
  },
  {
    "sha": "000391132608343c66488d62625c714814959bc9",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowMDAzOTExMzI2MDgzNDNjNjY0ODhkNjI2MjVjNzE0ODE0OTU5YmM5",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:29Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T18:56:06Z"
      },
      "message": "Introduce new per-txout CCoinsViewCache functions\n\nThe new functions are:\n* CCoinsViewCache::AddCoin: Add a single COutPoint/Coin pair.\n* CCoinsViewCache::SpendCoin: Remove a single COutPoint.\n* AddCoins: utility function that invokes CCoinsViewCache::AddCoin for\n  each output in a CTransaction.\n* AccessByTxid: utility function that searches for any output with\n  a given txid.\n* CCoinsViewCache::AccessCoin: retrieve the Coin for a COutPoint.\n* CCoinsViewCache::HaveCoins: check whether a non-empty Coin exists\n  for a given COutPoint.\n\nThe AddCoin and SpendCoin methods will eventually replace ModifyCoins\nand ModifyNewCoins, AddCoins will replace CCoins::FromTx, and the new\nAccessCoins and HaveCoins functions will replace their per-txid\ncounterparts.\n\nNote that AccessCoin for now returns a copy of the Coin object. In a\nlater commit it will be change to returning a const reference (which\nkeeps working in all call sites).",
      "tree": {
        "sha": "0d50712acb21403a32a3a013e54bdedc2b28aeb8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0d50712acb21403a32a3a013e54bdedc2b28aeb8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/000391132608343c66488d62625c714814959bc9",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/000391132608343c66488d62625c714814959bc9",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/000391132608343c66488d62625c714814959bc9",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/000391132608343c66488d62625c714814959bc9/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "bd83111a0fcfdb97204a0180bcf861d3b53bb6c2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/bd83111a0fcfdb97204a0180bcf861d3b53bb6c2",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/bd83111a0fcfdb97204a0180bcf861d3b53bb6c2"
      }
    ],
    "stats": {
      "total": 118,
      "additions": 116,
      "deletions": 2
    },
    "files": [
      {
        "sha": "3ac46d0806303826d114fbadb4eebfcce0836e1d",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 84,
        "deletions": 1,
        "changes": 85,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000391132608343c66488d62625c714814959bc9/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000391132608343c66488d62625c714814959bc9/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=000391132608343c66488d62625c714814959bc9",
        "patch": "@@ -4,6 +4,7 @@\n \n #include \"coins.h\"\n \n+#include \"consensus/consensus.h\"\n #include \"memusage.h\"\n #include \"random.h\"\n \n@@ -70,7 +71,7 @@ size_t CCoinsViewCache::DynamicMemoryUsage() const {\n     return memusage::DynamicUsage(cacheCoins) + cachedCoinsUsage;\n }\n \n-CCoinsMap::const_iterator CCoinsViewCache::FetchCoins(const uint256 &txid) const {\n+CCoinsMap::iterator CCoinsViewCache::FetchCoins(const uint256 &txid) const {\n     CCoinsMap::iterator it = cacheCoins.find(txid);\n     if (it != cacheCoins.end())\n         return it;\n@@ -153,6 +154,58 @@ CCoinsModifier CCoinsViewCache::ModifyNewCoins(const uint256 &txid, bool coinbas\n     return CCoinsModifier(*this, ret.first, 0);\n }\n \n+void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possible_overwrite) {\n+    assert(!coin.IsPruned());\n+    if (coin.out.scriptPubKey.IsUnspendable()) return;\n+    CCoinsMap::iterator it;\n+    bool inserted;\n+    std::tie(it, inserted) = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint.hash), std::tuple<>());\n+    bool fresh = false;\n+    if (!inserted) {\n+        cachedCoinsUsage -= it->second.coins.DynamicMemoryUsage();\n+    }\n+    if (!possible_overwrite) {\n+        if (it->second.coins.IsAvailable(outpoint.n)) {\n+            throw std::logic_error(\"Adding new coin that replaces non-pruned entry\");\n+        }\n+        fresh = it->second.coins.IsPruned() && !(it->second.flags & CCoinsCacheEntry::DIRTY);\n+    }\n+    if (it->second.coins.vout.size() <= outpoint.n) {\n+        it->second.coins.vout.resize(outpoint.n + 1);\n+    }\n+    it->second.coins.vout[outpoint.n] = std::move(coin.out);\n+    it->second.coins.nHeight = coin.nHeight;\n+    it->second.coins.fCoinBase = coin.fCoinBase;\n+    it->second.flags |= CCoinsCacheEntry::DIRTY | (fresh ? CCoinsCacheEntry::FRESH : 0);\n+    cachedCoinsUsage += it->second.coins.DynamicMemoryUsage();\n+}\n+\n+void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight) {\n+    bool fCoinbase = tx.IsCoinBase();\n+    const uint256& txid = tx.GetHash();\n+    for (size_t i = 0; i < tx.vout.size(); ++i) {\n+        // Pass fCoinbase as the possible_overwrite flag to AddCoin, in order to correctly\n+        // deal with the pre-BIP30 occurrances of duplicate coinbase transactions.\n+        cache.AddCoin(COutPoint(txid, i), Coin(tx.vout[i], nHeight, fCoinbase), fCoinbase);\n+    }\n+}\n+\n+void CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n+    CCoinsMap::iterator it = FetchCoins(outpoint.hash);\n+    if (it == cacheCoins.end()) return;\n+    cachedCoinsUsage -= it->second.coins.DynamicMemoryUsage();\n+    if (moveout && it->second.coins.IsAvailable(outpoint.n)) {\n+        *moveout = Coin(it->second.coins.vout[outpoint.n], it->second.coins.nHeight, it->second.coins.fCoinBase);\n+    }\n+    it->second.coins.Spend(outpoint.n); // Ignore return value: SpendCoin has no effect if no UTXO found.\n+    if (it->second.coins.IsPruned() && it->second.flags & CCoinsCacheEntry::FRESH) {\n+        cacheCoins.erase(it);\n+    } else {\n+        cachedCoinsUsage += it->second.coins.DynamicMemoryUsage();\n+        it->second.flags |= CCoinsCacheEntry::DIRTY;\n+    }\n+}\n+\n const CCoins* CCoinsViewCache::AccessCoins(const uint256 &txid) const {\n     CCoinsMap::const_iterator it = FetchCoins(txid);\n     if (it == cacheCoins.end()) {\n@@ -162,6 +215,18 @@ const CCoins* CCoinsViewCache::AccessCoins(const uint256 &txid) const {\n     }\n }\n \n+static const Coin coinEmpty;\n+\n+const Coin CCoinsViewCache::AccessCoin(const COutPoint &outpoint) const {\n+    CCoinsMap::const_iterator it = FetchCoins(outpoint.hash);\n+    if (it == cacheCoins.end() || !it->second.coins.IsAvailable(outpoint.n)) {\n+        return coinEmpty;\n+    } else {\n+        return Coin(it->second.coins.vout[outpoint.n], it->second.coins.nHeight, it->second.coins.fCoinBase);\n+    }\n+}\n+\n+\n bool CCoinsViewCache::HaveCoins(const uint256 &txid) const {\n     CCoinsMap::const_iterator it = FetchCoins(txid);\n     // We're using vtx.empty() instead of IsPruned here for performance reasons,\n@@ -171,6 +236,11 @@ bool CCoinsViewCache::HaveCoins(const uint256 &txid) const {\n     return (it != cacheCoins.end() && !it->second.coins.vout.empty());\n }\n \n+bool CCoinsViewCache::HaveCoins(const COutPoint &outpoint) const {\n+    CCoinsMap::const_iterator it = FetchCoins(outpoint.hash);\n+    return (it != cacheCoins.end() && it->second.coins.IsAvailable(outpoint.n));\n+}\n+\n bool CCoinsViewCache::HaveCoinsInCache(const uint256 &txid) const {\n     CCoinsMap::const_iterator it = cacheCoins.find(txid);\n     return it != cacheCoins.end();\n@@ -318,3 +388,16 @@ CCoinsModifier::~CCoinsModifier()\n CCoinsViewCursor::~CCoinsViewCursor()\n {\n }\n+\n+static const size_t MAX_OUTPUTS_PER_BLOCK = MAX_BLOCK_BASE_SIZE /  ::GetSerializeSize(CTxOut(), SER_NETWORK, PROTOCOL_VERSION); // TODO: merge with similar definition in undo.h.\n+\n+const Coin AccessByTxid(const CCoinsViewCache& view, const uint256& txid)\n+{\n+    COutPoint iter(txid, 0);\n+    while (iter.n < MAX_OUTPUTS_PER_BLOCK) {\n+        const Coin& alternate = view.AccessCoin(iter);\n+        if (!alternate.IsPruned()) return alternate;\n+        ++iter.n;\n+    }\n+    return coinEmpty;\n+}"
      },
      {
        "sha": "5879530f9590ee6f771d7b70fbed5bff849d3d7f",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 32,
        "deletions": 1,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/000391132608343c66488d62625c714814959bc9/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/000391132608343c66488d62625c714814959bc9/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=000391132608343c66488d62625c714814959bc9",
        "patch": "@@ -452,6 +452,7 @@ class CCoinsViewCache : public CCoinsViewBacked\n     // Standard CCoinsView methods\n     bool GetCoins(const uint256 &txid, CCoins &coins) const;\n     bool HaveCoins(const uint256 &txid) const;\n+    bool HaveCoins(const COutPoint &outpoint) const;\n     uint256 GetBestBlock() const;\n     void SetBestBlock(const uint256 &hashBlock);\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n@@ -470,6 +471,14 @@ class CCoinsViewCache : public CCoinsViewBacked\n      */\n     const CCoins* AccessCoins(const uint256 &txid) const;\n \n+    /**\n+     * Return a copy of a Coin in the cache, or a pruned one if not found. This is\n+     * more efficient than GetCoins. Modifications to other cache entries are\n+     * allowed while accessing the returned pointer.\n+     * TODO: return a reference to a Coin after changing CCoinsViewCache storage.\n+     */\n+    const Coin AccessCoin(const COutPoint &output) const;\n+\n     /**\n      * Return a modifiable reference to a CCoins. If no entry with the given\n      * txid exists, a new one is created. Simultaneous modifications are not\n@@ -488,6 +497,19 @@ class CCoinsViewCache : public CCoinsViewBacked\n      */\n     CCoinsModifier ModifyNewCoins(const uint256 &txid, bool coinbase);\n \n+    /**\n+     * Add a coin. Set potential_overwrite to true if a non-pruned version may\n+     * already exist.\n+     */\n+    void AddCoin(const COutPoint& outpoint, Coin&& coin, bool potential_overwrite);\n+\n+    /**\n+     * Spend a coin. Pass moveto in order to get the deleted data.\n+     * If no unspent output exists for the passed outpoint, this call\n+     * has no effect.\n+     */\n+    void SpendCoin(const COutPoint &outpoint, Coin* moveto = nullptr);\n+\n     /**\n      * Push the modifications applied to this cache to its base.\n      * Failure to call this method before destruction will cause the changes to be forgotten.\n@@ -525,12 +547,21 @@ class CCoinsViewCache : public CCoinsViewBacked\n     friend class CCoinsModifier;\n \n private:\n-    CCoinsMap::const_iterator FetchCoins(const uint256 &txid) const;\n+    CCoinsMap::iterator FetchCoins(const uint256 &txid) const;\n \n     /**\n      * By making the copy constructor private, we prevent accidentally using it when one intends to create a cache on top of a base cache.\n      */\n     CCoinsViewCache(const CCoinsViewCache &);\n };\n \n+//! Utility function to add all of a transaction's outputs to a cache.\n+// It assumes that overwrites are only possible for coinbase transactions,\n+// TODO: pass in a boolean to limit these possible overwrites to known\n+// (pre-BIP34) cases.\n+void AddCoins(CCoinsViewCache& cache, const CTransaction& tx, int nHeight);\n+\n+//! Utility function to find any unspent output with a given txid.\n+const Coin AccessByTxid(const CCoinsViewCache& cache, const uint256& txid);\n+\n #endif // BITCOIN_COINS_H"
      }
    ]
  },
  {
    "sha": "f68cdfe92b37f5a75be612b7de3c1a03245696d0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmNjhjZGZlOTJiMzdmNWE3NWJlNjEyYjdkZTNjMWEwMzI0NTY5NmQw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:30Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T18:56:06Z"
      },
      "message": "Switch from per-tx to per-txout CCoinsViewCache methods in some places",
      "tree": {
        "sha": "b1d86511970e341266e4cdb73c74b42fba77f705",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b1d86511970e341266e4cdb73c74b42fba77f705"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f68cdfe92b37f5a75be612b7de3c1a03245696d0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f68cdfe92b37f5a75be612b7de3c1a03245696d0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f68cdfe92b37f5a75be612b7de3c1a03245696d0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f68cdfe92b37f5a75be612b7de3c1a03245696d0/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "000391132608343c66488d62625c714814959bc9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/000391132608343c66488d62625c714814959bc9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/000391132608343c66488d62625c714814959bc9"
      }
    ],
    "stats": {
      "total": 176,
      "additions": 83,
      "deletions": 93
    },
    "files": [
      {
        "sha": "5aab3381fd21dd64684306b01b1dfce9861212fd",
        "filename": "src/bench/ccoins_caching.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/bench/ccoins_caching.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/bench/ccoins_caching.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bench/ccoins_caching.cpp?ref=f68cdfe92b37f5a75be612b7de3c1a03245696d0",
        "patch": "@@ -35,14 +35,14 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n     dummyTransactions[0].vout[0].scriptPubKey << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n     dummyTransactions[0].vout[1].nValue = 50 * CENT;\n     dummyTransactions[0].vout[1].scriptPubKey << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\n-    coinsRet.ModifyCoins(dummyTransactions[0].GetHash())->FromTx(dummyTransactions[0], 0);\n+    AddCoins(coinsRet, dummyTransactions[0], 0);\n \n     dummyTransactions[1].vout.resize(2);\n     dummyTransactions[1].vout[0].nValue = 21 * CENT;\n     dummyTransactions[1].vout[0].scriptPubKey = GetScriptForDestination(key[2].GetPubKey().GetID());\n     dummyTransactions[1].vout[1].nValue = 22 * CENT;\n     dummyTransactions[1].vout[1].scriptPubKey = GetScriptForDestination(key[3].GetPubKey().GetID());\n-    coinsRet.ModifyCoins(dummyTransactions[1].GetHash())->FromTx(dummyTransactions[1], 0);\n+    AddCoins(coinsRet, dummyTransactions[1], 0);\n \n     return dummyTransactions;\n }"
      },
      {
        "sha": "a6a96fa02eb853afd666389cb9d3b010aac161d7",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 12,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=f68cdfe92b37f5a75be612b7de3c1a03245696d0",
        "patch": "@@ -556,24 +556,26 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n             if (nOut < 0)\n                 throw std::runtime_error(\"vout must be positive\");\n \n+            COutPoint out(txid, nOut);\n             std::vector<unsigned char> pkData(ParseHexUV(prevOut[\"scriptPubKey\"], \"scriptPubKey\"));\n             CScript scriptPubKey(pkData.begin(), pkData.end());\n \n             {\n-                CCoinsModifier coins = view.ModifyCoins(txid);\n-                if (coins->IsAvailable(nOut) && coins->vout[nOut].scriptPubKey != scriptPubKey) {\n+                const Coin& coin = view.AccessCoin(out);\n+                if (!coin.IsPruned() && coin.out.scriptPubKey != scriptPubKey) {\n                     std::string err(\"Previous output scriptPubKey mismatch:\\n\");\n-                    err = err + ScriptToAsmStr(coins->vout[nOut].scriptPubKey) + \"\\nvs:\\n\"+\n+                    err = err + ScriptToAsmStr(coin.out.scriptPubKey) + \"\\nvs:\\n\"+\n                         ScriptToAsmStr(scriptPubKey);\n                     throw std::runtime_error(err);\n                 }\n-                if ((unsigned int)nOut >= coins->vout.size())\n-                    coins->vout.resize(nOut+1);\n-                coins->vout[nOut].scriptPubKey = scriptPubKey;\n-                coins->vout[nOut].nValue = 0;\n+                Coin newcoin;\n+                newcoin.out.scriptPubKey = scriptPubKey;\n+                newcoin.out.nValue = 0;\n                 if (prevOut.exists(\"amount\")) {\n-                    coins->vout[nOut].nValue = AmountFromValue(prevOut[\"amount\"]);\n+                    newcoin.out.nValue = AmountFromValue(prevOut[\"amount\"]);\n                 }\n+                newcoin.nHeight = 1;\n+                view.AddCoin(out, std::move(newcoin), true);\n             }\n \n             // if redeemScript given and private keys given,\n@@ -595,13 +597,13 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n     // Sign what we can:\n     for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n         CTxIn& txin = mergedTx.vin[i];\n-        const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n-        if (!coins || !coins->IsAvailable(txin.prevout.n)) {\n+        const Coin& coin = view.AccessCoin(txin.prevout);\n+        if (coin.IsPruned()) {\n             fComplete = false;\n             continue;\n         }\n-        const CScript& prevPubKey = coins->vout[txin.prevout.n].scriptPubKey;\n-        const CAmount& amount = coins->vout[txin.prevout.n].nValue;\n+        const CScript& prevPubKey = coin.out.scriptPubKey;\n+        const CAmount& amount = coin.out.nValue;\n \n         SignatureData sigdata;\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:"
      },
      {
        "sha": "9a6f3c9cdc0899f2c1bab73caea30ee1af1393d9",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=f68cdfe92b37f5a75be612b7de3c1a03245696d0",
        "patch": "@@ -213,20 +213,20 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n         for (unsigned int i = 0; i < tx.vin.size(); i++)\n         {\n             const COutPoint &prevout = tx.vin[i].prevout;\n-            const CCoins *coins = inputs.AccessCoins(prevout.hash);\n-            assert(coins);\n+            const Coin& coin = inputs.AccessCoin(prevout);\n+            assert(!coin.IsPruned());\n \n             // If prev is coinbase, check that it's matured\n-            if (coins->IsCoinBase()) {\n-                if (nSpendHeight - coins->nHeight < COINBASE_MATURITY)\n+            if (coin.IsCoinBase()) {\n+                if (nSpendHeight - coin.nHeight < COINBASE_MATURITY)\n                     return state.Invalid(false,\n                         REJECT_INVALID, \"bad-txns-premature-spend-of-coinbase\",\n-                        strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coins->nHeight));\n+                        strprintf(\"tried to spend coinbase at depth %d\", nSpendHeight - coin.nHeight));\n             }\n \n             // Check for negative or overflow input values\n-            nValueIn += coins->vout[prevout.n].nValue;\n-            if (!MoneyRange(coins->vout[prevout.n].nValue) || !MoneyRange(nValueIn))\n+            nValueIn += coin.out.nValue;\n+            if (!MoneyRange(coin.out.nValue) || !MoneyRange(nValueIn))\n                 return state.DoS(100, false, REJECT_INVALID, \"bad-txns-inputvalues-outofrange\");\n \n         }"
      },
      {
        "sha": "3f7b6adead75e6e39c2919355723ce8c114c5c3a",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 17,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=f68cdfe92b37f5a75be612b7de3c1a03245696d0",
        "patch": "@@ -637,9 +637,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n         view.SetBackend(viewMempool); // temporarily switch cache backend to db+mempool view\n \n         BOOST_FOREACH(const CTxIn& txin, mergedTx.vin) {\n-            const uint256& prevHash = txin.prevout.hash;\n-            CCoins coins;\n-            view.AccessCoins(prevHash); // this is certainly allowed to fail\n+            view.AccessCoin(txin.prevout); // Load entries from viewChain into view; can fail.\n         }\n \n         view.SetBackend(viewDummy); // switch back to avoid locking mempool for too long\n@@ -691,24 +689,26 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n             if (nOut < 0)\n                 throw JSONRPCError(RPC_DESERIALIZATION_ERROR, \"vout must be positive\");\n \n+            COutPoint out(txid, nOut);\n             std::vector<unsigned char> pkData(ParseHexO(prevOut, \"scriptPubKey\"));\n             CScript scriptPubKey(pkData.begin(), pkData.end());\n \n             {\n-                CCoinsModifier coins = view.ModifyCoins(txid);\n-                if (coins->IsAvailable(nOut) && coins->vout[nOut].scriptPubKey != scriptPubKey) {\n+                const Coin& coin = view.AccessCoin(out);\n+                if (!coin.IsPruned() && coin.out.scriptPubKey != scriptPubKey) {\n                     std::string err(\"Previous output scriptPubKey mismatch:\\n\");\n-                    err = err + ScriptToAsmStr(coins->vout[nOut].scriptPubKey) + \"\\nvs:\\n\"+\n+                    err = err + ScriptToAsmStr(coin.out.scriptPubKey) + \"\\nvs:\\n\"+\n                         ScriptToAsmStr(scriptPubKey);\n                     throw JSONRPCError(RPC_DESERIALIZATION_ERROR, err);\n                 }\n-                if ((unsigned int)nOut >= coins->vout.size())\n-                    coins->vout.resize(nOut+1);\n-                coins->vout[nOut].scriptPubKey = scriptPubKey;\n-                coins->vout[nOut].nValue = 0;\n+                Coin newcoin;\n+                newcoin.out.scriptPubKey = scriptPubKey;\n+                newcoin.out.nValue = 0;\n                 if (prevOut.exists(\"amount\")) {\n-                    coins->vout[nOut].nValue = AmountFromValue(find_value(prevOut, \"amount\"));\n+                    newcoin.out.nValue = AmountFromValue(find_value(prevOut, \"amount\"));\n                 }\n+                newcoin.nHeight = 1;\n+                view.AddCoin(out, std::move(newcoin), true);\n             }\n \n             // if redeemScript given and not using the local wallet (private keys\n@@ -766,13 +766,13 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n     // Sign what we can:\n     for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n         CTxIn& txin = mergedTx.vin[i];\n-        const CCoins* coins = view.AccessCoins(txin.prevout.hash);\n-        if (coins == NULL || !coins->IsAvailable(txin.prevout.n)) {\n+        const Coin& coin = view.AccessCoin(txin.prevout);\n+        if (coin.IsPruned()) {\n             TxInErrorToJSON(txin, vErrors, \"Input not found or already spent\");\n             continue;\n         }\n-        const CScript& prevPubKey = coins->vout[txin.prevout.n].scriptPubKey;\n-        const CAmount& amount = coins->vout[txin.prevout.n].nValue;\n+        const CScript& prevPubKey = coin.out.scriptPubKey;\n+        const CAmount& amount = coin.out.nValue;\n \n         SignatureData sigdata;\n         // Only sign SIGHASH_SINGLE if there's a corresponding output:\n@@ -844,9 +844,12 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n         nMaxRawTxFee = 0;\n \n     CCoinsViewCache &view = *pcoinsTip;\n-    const CCoins* existingCoins = view.AccessCoins(hashTx);\n+    bool fHaveChain = false;\n+    for (size_t o = 0; !fHaveChain && o < tx->vout.size(); o++) {\n+        const Coin& existingCoin = view.AccessCoin(COutPoint(hashTx, o));\n+        fHaveChain = !existingCoin.IsPruned();\n+    }\n     bool fHaveMempool = mempool.exists(hashTx);\n-    bool fHaveChain = existingCoins && existingCoins->nHeight < 1000000000;\n     if (!fHaveMempool && !fHaveChain) {\n         // push to local node and sync with wallets\n         CValidationState state;"
      },
      {
        "sha": "1ab0fef44c5ed6de4d1ecbcc1971d94442395e46",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=f68cdfe92b37f5a75be612b7de3c1a03245696d0",
        "patch": "@@ -316,7 +316,7 @@ BOOST_AUTO_TEST_CASE(AreInputsStandard)\n     txFrom.vout[6].scriptPubKey = GetScriptForDestination(CScriptID(twentySigops));\n     txFrom.vout[6].nValue = 6000;\n \n-    coins.ModifyCoins(txFrom.GetHash())->FromTx(txFrom, 0);\n+    AddCoins(coins, txFrom, 0);\n \n     CMutableTransaction txTo;\n     txTo.vout.resize(1);"
      },
      {
        "sha": "4e117448fe2acd9e5abe3ebb0818213d40cadb86",
        "filename": "src/test/sigopcount_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/test/sigopcount_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/test/sigopcount_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/sigopcount_tests.cpp?ref=f68cdfe92b37f5a75be612b7de3c1a03245696d0",
        "patch": "@@ -102,7 +102,7 @@ void BuildTxs(CMutableTransaction& spendingTx, CCoinsViewCache& coins, CMutableT\n     spendingTx.vout[0].nValue = 1;\n     spendingTx.vout[0].scriptPubKey = CScript();\n \n-    coins.ModifyCoins(creationTx.GetHash())->FromTx(creationTx, 0);\n+    AddCoins(coins, creationTx, 0);\n }\n \n BOOST_AUTO_TEST_CASE(GetTxSigOpCost)"
      },
      {
        "sha": "665827696e20637c8bffc2a9757ac821fb2dc074",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=f68cdfe92b37f5a75be612b7de3c1a03245696d0",
        "patch": "@@ -307,14 +307,14 @@ SetupDummyInputs(CBasicKeyStore& keystoreRet, CCoinsViewCache& coinsRet)\n     dummyTransactions[0].vout[0].scriptPubKey << ToByteVector(key[0].GetPubKey()) << OP_CHECKSIG;\n     dummyTransactions[0].vout[1].nValue = 50*CENT;\n     dummyTransactions[0].vout[1].scriptPubKey << ToByteVector(key[1].GetPubKey()) << OP_CHECKSIG;\n-    coinsRet.ModifyCoins(dummyTransactions[0].GetHash())->FromTx(dummyTransactions[0], 0);\n+    AddCoins(coinsRet, dummyTransactions[0], 0);\n \n     dummyTransactions[1].vout.resize(2);\n     dummyTransactions[1].vout[0].nValue = 21*CENT;\n     dummyTransactions[1].vout[0].scriptPubKey = GetScriptForDestination(key[2].GetPubKey().GetID());\n     dummyTransactions[1].vout[1].nValue = 22*CENT;\n     dummyTransactions[1].vout[1].scriptPubKey = GetScriptForDestination(key[3].GetPubKey().GetID());\n-    coinsRet.ModifyCoins(dummyTransactions[1].GetHash())->FromTx(dummyTransactions[1], 0);\n+    AddCoins(coinsRet, dummyTransactions[1], 0);\n \n     return dummyTransactions;\n }"
      },
      {
        "sha": "7ff7efc5e17984ad4831708fb484aa5dcfa91eee",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 51,
        "changes": 87,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f68cdfe92b37f5a75be612b7de3c1a03245696d0/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=f68cdfe92b37f5a75be612b7de3c1a03245696d0",
        "patch": "@@ -498,8 +498,8 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         // during reorgs to ensure COINBASE_MATURITY is still met.\n         bool fSpendsCoinbase = false;\n         BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n-            const CCoins *coins = view.AccessCoins(txin.prevout.hash);\n-            if (coins->IsCoinBase()) {\n+            const Coin &coin = view.AccessCoin(txin.prevout);\n+            if (coin.IsCoinBase()) {\n                 fSpendsCoinbase = true;\n                 break;\n             }\n@@ -818,15 +818,8 @@ bool GetTransaction(const uint256 &hash, CTransactionRef &txOut, const Consensus\n     }\n \n     if (fAllowSlow) { // use coin database to locate block that contains transaction, and scan it\n-        int nHeight = -1;\n-        {\n-            const CCoinsViewCache& view = *pcoinsTip;\n-            const CCoins* coins = view.AccessCoins(hash);\n-            if (coins)\n-                nHeight = coins->nHeight;\n-        }\n-        if (nHeight > 0)\n-            pindexSlow = chainActive[nHeight];\n+        const Coin& coin = AccessByTxid(*pcoinsTip, hash);\n+        if (!coin.IsPruned()) pindexSlow = chainActive[coin.nHeight];\n     }\n \n     if (pindexSlow) {\n@@ -1074,19 +1067,12 @@ void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txund\n     if (!tx.IsCoinBase()) {\n         txundo.vprevout.reserve(tx.vin.size());\n         BOOST_FOREACH(const CTxIn &txin, tx.vin) {\n-            CCoinsModifier coins = inputs.ModifyCoins(txin.prevout.hash);\n-            unsigned nPos = txin.prevout.n;\n-\n-            if (nPos >= coins->vout.size() || coins->vout[nPos].IsNull())\n-                assert(false);\n-            // mark an outpoint spent, and construct undo information\n-            txundo.vprevout.emplace_back(coins->vout[nPos], coins->nHeight, coins->fCoinBase);\n-            bool ret = coins->Spend(nPos);\n-            assert(ret);\n+            txundo.vprevout.emplace_back();\n+            inputs.SpendCoin(txin.prevout, &txundo.vprevout.back());\n         }\n     }\n     // add outputs\n-    inputs.ModifyNewCoins(tx.GetHash(), tx.IsCoinBase())->FromTx(tx, nHeight);\n+    AddCoins(inputs, tx, nHeight);\n }\n \n void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, int nHeight)\n@@ -1260,24 +1246,21 @@ int ApplyTxInUndo(Coin&& undo, CCoinsViewCache& view, const COutPoint& out)\n {\n     bool fClean = true;\n \n-    CCoinsModifier coins = view.ModifyCoins(out.hash);\n-    if (undo.nHeight != 0) {\n-        if (!coins->IsPruned()) {\n-            if (coins->fCoinBase != undo.fCoinBase || (uint32_t)coins->nHeight != undo.nHeight) fClean = false; // metadata mismatch\n+    if (view.HaveCoins(out)) fClean = false; // overwriting transaction output\n+\n+    if (undo.nHeight == 0) {\n+        // Missing undo metadata (height and coinbase). Older versions included this\n+        // information only in undo records for the last spend of a transactions'\n+        // outputs. This implies that it must be present for some other output of the same tx.\n+        const Coin& alternate = AccessByTxid(view, out.hash);\n+        if (!alternate.IsPruned()) {\n+            undo.nHeight = alternate.nHeight;\n+            undo.fCoinBase = alternate.fCoinBase;\n+        } else {\n+            return DISCONNECT_FAILED; // adding output for transaction without known metadata\n         }\n-        // restore height/coinbase tx metadata from undo data\n-        coins->fCoinBase = undo.fCoinBase;\n-        coins->nHeight = undo.nHeight;\n-    } else {\n-        // Undo data does not contain height/coinbase. This should never happen\n-        // for newly created undo entries. Previously, this data was only saved\n-        // for the last spend of a transaction's outputs, so check IsPruned().\n-        if (coins->IsPruned()) fClean = false; // adding output to missing transaction\n     }\n-    if (coins->IsAvailable(out.n)) fClean = false; // overwriting existing output\n-    if (coins->vout.size() < out.n+1)\n-        coins->vout.resize(out.n+1);\n-    coins->vout[out.n] = std::move(undo.out);\n+    view.AddCoin(out, std::move(undo), undo.fCoinBase);\n \n     return fClean ? DISCONNECT_OK : DISCONNECT_UNCLEAN;\n }\n@@ -1313,15 +1296,15 @@ static DisconnectResult DisconnectBlock(const CBlock& block, const CBlockIndex*\n \n         // Check that all outputs are available and match the outputs in the block itself\n         // exactly.\n-        {\n-        CCoinsModifier outs = view.ModifyCoins(hash);\n-        outs->ClearUnspendable();\n-\n-        CCoins outsBlock(tx, pindex->nHeight);\n-        if (*outs != outsBlock) fClean = false; // transaction mismatch\n-\n-        // remove outputs\n-        outs->Clear();\n+        for (size_t o = 0; o < tx.vout.size(); o++) {\n+            if (!tx.vout[o].scriptPubKey.IsUnspendable()) {\n+                COutPoint out(hash, o);\n+                Coin coin;\n+                view.SpendCoin(out, &coin);\n+                if (tx.vout[o] != coin.out) {\n+                    fClean = false; // transaction output mismatch\n+                }\n+            }\n         }\n \n         // restore inputs\n@@ -1518,10 +1501,12 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n \n     if (fEnforceBIP30) {\n         for (const auto& tx : block.vtx) {\n-            const CCoins* coins = view.AccessCoins(tx->GetHash());\n-            if (coins && !coins->IsPruned())\n-                return state.DoS(100, error(\"ConnectBlock(): tried to overwrite transaction\"),\n-                                 REJECT_INVALID, \"bad-txns-BIP30\");\n+            for (size_t o = 0; o < tx->vout.size(); o++) {\n+                if (view.HaveCoins(COutPoint(tx->GetHash(), o))) {\n+                    return state.DoS(100, error(\"ConnectBlock(): tried to overwrite transaction\"),\n+                                     REJECT_INVALID, \"bad-txns-BIP30\");\n+                }\n+            }\n         }\n     }\n \n@@ -1588,7 +1573,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n             // be in ConnectBlock because they require the UTXO set\n             prevheights.resize(tx.vin.size());\n             for (size_t j = 0; j < tx.vin.size(); j++) {\n-                prevheights[j] = view.AccessCoins(tx.vin[j].prevout.hash)->nHeight;\n+                prevheights[j] = view.AccessCoin(tx.vin[j].prevout).nHeight;\n             }\n \n             if (!SequenceLocks(tx, nLockTimeFlags, &prevheights, *pindex)) {"
      }
    ]
  },
  {
    "sha": "c87b957a32e03c09d410abadf661f87eb813bcdb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjODdiOTU3YTMyZTAzYzA5ZDQxMGFiYWRmNjYxZjg3ZWI4MTNiY2Ri",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2017-04-27T14:37:33Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T18:56:06Z"
      },
      "message": "Only pass things committed to by tx's witness hash to CScriptCheck\n\nThis clarifies a bit more the ways in which the new script execution\ncache could break consensus in the future if additional data from\nthe CCoins object were to be used as a part of script execution.\n\nAfter this change, any such consensus breaks should be very visible\nto reviewers, hopefully ensuring no such changes can be made.",
      "tree": {
        "sha": "2e78ed56ca2d41dcc671b482dab2bb0e21df495e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2e78ed56ca2d41dcc671b482dab2bb0e21df495e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/c87b957a32e03c09d410abadf661f87eb813bcdb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c87b957a32e03c09d410abadf661f87eb813bcdb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/c87b957a32e03c09d410abadf661f87eb813bcdb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c87b957a32e03c09d410abadf661f87eb813bcdb/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f68cdfe92b37f5a75be612b7de3c1a03245696d0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f68cdfe92b37f5a75be612b7de3c1a03245696d0",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f68cdfe92b37f5a75be612b7de3c1a03245696d0"
      }
    ],
    "stats": {
      "total": 22,
      "additions": 16,
      "deletions": 6
    },
    "files": [
      {
        "sha": "0789b2e80cacdf2c044c5b3c133500273ccda6dc",
        "filename": "src/test/script_P2SH_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c87b957a32e03c09d410abadf661f87eb813bcdb/src/test/script_P2SH_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c87b957a32e03c09d410abadf661f87eb813bcdb/src/test/script_P2SH_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/script_P2SH_tests.cpp?ref=c87b957a32e03c09d410abadf661f87eb813bcdb",
        "patch": "@@ -112,7 +112,8 @@ BOOST_AUTO_TEST_CASE(sign)\n         {\n             CScript sigSave = txTo[i].vin[0].scriptSig;\n             txTo[i].vin[0].scriptSig = txTo[j].vin[0].scriptSig;\n-            bool sigOK = CScriptCheck(CCoins(txFrom, 0), txTo[i], 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC, false, &txdata)();\n+            const CTxOut& output = txFrom.vout[txTo[i].vin[0].prevout.n];\n+            bool sigOK = CScriptCheck(output.scriptPubKey, output.nValue, txTo[i], 0, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_STRICTENC, false, &txdata)();\n             if (i == j)\n                 BOOST_CHECK_MESSAGE(sigOK, strprintf(\"VerifySignature %d %d\", i, j));\n             else"
      },
      {
        "sha": "986922b2a7f2795f21d7f49022a62e50d9ab316e",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c87b957a32e03c09d410abadf661f87eb813bcdb/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c87b957a32e03c09d410abadf661f87eb813bcdb/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=c87b957a32e03c09d410abadf661f87eb813bcdb",
        "patch": "@@ -481,7 +481,8 @@ BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n \n     for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n         std::vector<CScriptCheck> vChecks;\n-        CScriptCheck check(coins, tx, i, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false, &txdata);\n+        const CTxOut& output = coins.vout[tx.vin[i].prevout.n];\n+        CScriptCheck check(output.scriptPubKey, output.nValue, tx, i, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false, &txdata);\n         vChecks.push_back(CScriptCheck());\n         check.swap(vChecks.back());\n         control.Add(vChecks);"
      },
      {
        "sha": "43d2cf1d6967b32f298798a9d8453f33a9933460",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c87b957a32e03c09d410abadf661f87eb813bcdb/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c87b957a32e03c09d410abadf661f87eb813bcdb/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=c87b957a32e03c09d410abadf661f87eb813bcdb",
        "patch": "@@ -1119,8 +1119,16 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                 const CCoins* coins = inputs.AccessCoins(prevout.hash);\n                 assert(coins);\n \n+                // We very carefully only pass in things to CScriptCheck which\n+                // are clearly committed to by tx' witness hash. This provides\n+                // a sanity check that our caching is not introducing consensus\n+                // failures through additional data in, eg, the coins being\n+                // spent being checked as a part of CScriptCheck.\n+                const CScript& scriptPubKey = coins->vout[prevout.n].scriptPubKey;\n+                const CAmount amount = coins->vout[prevout.n].nValue;\n+\n                 // Verify signature\n-                CScriptCheck check(*coins, tx, i, flags, cacheStore, &txdata);\n+                CScriptCheck check(scriptPubKey, amount, tx, i, flags, cacheStore, &txdata);\n                 if (pvChecks) {\n                     pvChecks->push_back(CScriptCheck());\n                     check.swap(pvChecks->back());\n@@ -1132,7 +1140,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n                         // arguments; if so, don't trigger DoS protection to\n                         // avoid splitting the network between upgraded and\n                         // non-upgraded nodes.\n-                        CScriptCheck check2(*coins, tx, i,\n+                        CScriptCheck check2(scriptPubKey, amount, tx, i,\n                                 flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheStore, &txdata);\n                         if (check2())\n                             return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));"
      },
      {
        "sha": "8931cfc4d49c2a34fea2781c29d7902aa55e12ed",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/c87b957a32e03c09d410abadf661f87eb813bcdb/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/c87b957a32e03c09d410abadf661f87eb813bcdb/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=c87b957a32e03c09d410abadf661f87eb813bcdb",
        "patch": "@@ -404,8 +404,8 @@ class CScriptCheck\n \n public:\n     CScriptCheck(): amount(0), ptxTo(0), nIn(0), nFlags(0), cacheStore(false), error(SCRIPT_ERR_UNKNOWN_ERROR) {}\n-    CScriptCheck(const CCoins& txFromIn, const CTransaction& txToIn, unsigned int nInIn, unsigned int nFlagsIn, bool cacheIn, PrecomputedTransactionData* txdataIn) :\n-        scriptPubKey(txFromIn.vout[txToIn.vin[nInIn].prevout.n].scriptPubKey), amount(txFromIn.vout[txToIn.vin[nInIn].prevout.n].nValue),\n+    CScriptCheck(const CScript& scriptPubKeyIn, const CAmount amountIn, const CTransaction& txToIn, unsigned int nInIn, unsigned int nFlagsIn, bool cacheIn, PrecomputedTransactionData* txdataIn) :\n+        scriptPubKey(scriptPubKeyIn), amount(amountIn),\n         ptxTo(&txToIn), nIn(nInIn), nFlags(nFlagsIn), cacheStore(cacheIn), error(SCRIPT_ERR_UNKNOWN_ERROR), txdata(txdataIn) { }\n \n     bool operator()();"
      }
    ]
  },
  {
    "sha": "8b3868c1b4bf89c41b26ecb3a4b7c3a2557e3868",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YjM4NjhjMWI0YmY4OWM0MWIyNmVjYjNhNGI3YzNhMjU1N2UzODY4",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:32Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T18:56:06Z"
      },
      "message": "Switch CScriptCheck to use Coin instead of CCoins",
      "tree": {
        "sha": "7183c0a73358e4eb26a5d163c18d88be12972631",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7183c0a73358e4eb26a5d163c18d88be12972631"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8b3868c1b4bf89c41b26ecb3a4b7c3a2557e3868",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b3868c1b4bf89c41b26ecb3a4b7c3a2557e3868",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8b3868c1b4bf89c41b26ecb3a4b7c3a2557e3868",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b3868c1b4bf89c41b26ecb3a4b7c3a2557e3868/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "c87b957a32e03c09d410abadf661f87eb813bcdb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/c87b957a32e03c09d410abadf661f87eb813bcdb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/c87b957a32e03c09d410abadf661f87eb813bcdb"
      }
    ],
    "stats": {
      "total": 23,
      "additions": 12,
      "deletions": 11
    },
    "files": [
      {
        "sha": "5c7516fbf1c2385504f435fcdcdf797796f0e82f",
        "filename": "src/test/transaction_tests.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 7,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b3868c1b4bf89c41b26ecb3a4b7c3a2557e3868/src/test/transaction_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b3868c1b4bf89c41b26ecb3a4b7c3a2557e3868/src/test/transaction_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/transaction_tests.cpp?ref=8b3868c1b4bf89c41b26ecb3a4b7c3a2557e3868",
        "patch": "@@ -470,18 +470,19 @@ BOOST_AUTO_TEST_CASE(test_big_witness_transaction) {\n     for (int i=0; i<20; i++)\n         threadGroup.create_thread(boost::bind(&CCheckQueue<CScriptCheck>::Thread, boost::ref(scriptcheckqueue)));\n \n-    CCoins coins;\n-    coins.fCoinBase = false;\n+    std::vector<Coin> coins;\n     for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n-        CTxOut txout;\n-        txout.nValue = 1000;\n-        txout.scriptPubKey = scriptPubKey;\n-        coins.vout.push_back(txout);\n+        Coin coin;\n+        coin.nHeight = 1;\n+        coin.fCoinBase = false;\n+        coin.out.nValue = 1000;\n+        coin.out.scriptPubKey = scriptPubKey;\n+        coins.emplace_back(std::move(coin));\n     }\n \n     for(uint32_t i = 0; i < mtx.vin.size(); i++) {\n         std::vector<CScriptCheck> vChecks;\n-        const CTxOut& output = coins.vout[tx.vin[i].prevout.n];\n+        const CTxOut& output = coins[tx.vin[i].prevout.n].out;\n         CScriptCheck check(output.scriptPubKey, output.nValue, tx, i, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, false, &txdata);\n         vChecks.push_back(CScriptCheck());\n         check.swap(vChecks.back());"
      },
      {
        "sha": "b295a7f86ed073230ca7392a0bad22226687788e",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b3868c1b4bf89c41b26ecb3a4b7c3a2557e3868/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b3868c1b4bf89c41b26ecb3a4b7c3a2557e3868/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=8b3868c1b4bf89c41b26ecb3a4b7c3a2557e3868",
        "patch": "@@ -1116,16 +1116,16 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n         if (fScriptChecks) {\n             for (unsigned int i = 0; i < tx.vin.size(); i++) {\n                 const COutPoint &prevout = tx.vin[i].prevout;\n-                const CCoins* coins = inputs.AccessCoins(prevout.hash);\n-                assert(coins);\n+                const Coin& coin = inputs.AccessCoin(prevout);\n+                assert(!coin.IsPruned());\n \n                 // We very carefully only pass in things to CScriptCheck which\n                 // are clearly committed to by tx' witness hash. This provides\n                 // a sanity check that our caching is not introducing consensus\n                 // failures through additional data in, eg, the coins being\n                 // spent being checked as a part of CScriptCheck.\n-                const CScript& scriptPubKey = coins->vout[prevout.n].scriptPubKey;\n-                const CAmount amount = coins->vout[prevout.n].nValue;\n+                const CScript& scriptPubKey = coin.out.scriptPubKey;\n+                const CAmount amount = coin.out.nValue;\n \n                 // Verify signature\n                 CScriptCheck check(scriptPubKey, amount, tx, i, flags, cacheStore, &txdata);"
      }
    ]
  },
  {
    "sha": "961e4839793f8b4ad37d29672faf1695ff6ec03a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NjFlNDgzOTc5M2Y4YjRhZDM3ZDI5NjcyZmFmMTY5NWZmNmVjMDNh",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:34Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T19:43:12Z"
      },
      "message": "Switch tests from ModifyCoins to AddCoin/SpendCoin",
      "tree": {
        "sha": "f6d3f864e8c91dd083e6b587f863c89ee5b9cd59",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f6d3f864e8c91dd083e6b587f863c89ee5b9cd59"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/961e4839793f8b4ad37d29672faf1695ff6ec03a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/961e4839793f8b4ad37d29672faf1695ff6ec03a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/961e4839793f8b4ad37d29672faf1695ff6ec03a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/961e4839793f8b4ad37d29672faf1695ff6ec03a/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8b3868c1b4bf89c41b26ecb3a4b7c3a2557e3868",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b3868c1b4bf89c41b26ecb3a4b7c3a2557e3868",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8b3868c1b4bf89c41b26ecb3a4b7c3a2557e3868"
      }
    ],
    "stats": {
      "total": 268,
      "additions": 119,
      "deletions": 149
    },
    "files": [
      {
        "sha": "3ad2625bab5bb58573d71ba1c295e139c2a5a497",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 119,
        "deletions": 149,
        "changes": 268,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/961e4839793f8b4ad37d29672faf1695ff6ec03a/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/961e4839793f8b4ad37d29672faf1695ff6ec03a/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=961e4839793f8b4ad37d29672faf1695ff6ec03a",
        "patch": "@@ -22,6 +22,15 @@ void UpdateCoins(const CTransaction& tx, CCoinsViewCache& inputs, CTxUndo &txund\n \n namespace\n {\n+//! equality test\n+bool operator==(const Coin &a, const Coin &b) {\n+    // Empty Coin objects are always equal.\n+    if (a.IsPruned() && b.IsPruned()) return true;\n+    return a.fCoinBase == b.fCoinBase &&\n+           a.nHeight == b.nHeight &&\n+           a.out == b.out;\n+}\n+\n class CCoinsViewTest : public CCoinsView\n {\n     uint256 hashBestBlock_;\n@@ -134,8 +143,9 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n         {\n             uint256 txid = txids[insecure_rand() % txids.size()]; // txid we're going to modify in this iteration.\n             CCoins& coins = result[txid];\n-            CCoinsModifier entry = stack.back()->ModifyCoins(txid);\n-            BOOST_CHECK(coins == *entry);\n+            const Coin& entry = stack.back()->AccessCoin(COutPoint(txid, 0));\n+            BOOST_CHECK((entry.IsPruned() && coins.IsPruned()) || entry == Coin(coins.vout[0], coins.nHeight, coins.fCoinBase));\n+\n             if (insecure_rand() % 5 == 0 || coins.IsPruned()) {\n                 if (coins.IsPruned()) {\n                     added_an_entry = true;\n@@ -144,12 +154,15 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n                 }\n                 coins.vout.resize(1);\n                 coins.vout[0].nValue = insecure_rand();\n-                *entry = coins;\n             } else {\n                 coins.Clear();\n-                entry->Clear();\n                 removed_an_entry = true;\n             }\n+            if (coins.IsPruned()) {\n+                stack.back()->SpendCoin(COutPoint(txid, 0));\n+            } else {\n+                stack.back()->AddCoin(COutPoint(txid, 0), Coin(coins.vout[0], coins.nHeight, coins.fCoinBase), true);\n+            }\n         }\n \n         // Once every 1000 iterations and at the end, verify the full cache.\n@@ -325,8 +338,9 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n \n                 // The test is designed to ensure spending a duplicate coinbase will work properly\n                 // if that ever happens and not resurrect the previously overwritten coinbase\n-                if (duplicateids.count(prevouthash))\n+                if (duplicateids.count(prevouthash)) {\n                     spent_a_duplicate_coinbase = true;\n+                }\n \n             }\n             // Update the expected result to know about the new output coins\n@@ -341,10 +355,8 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n \n             // Track this tx and undo info to use later\n             alltxs.insert(std::make_pair(tx.GetHash(),std::make_tuple(tx,undo,oldcoins)));\n-        }\n-\n-        //1/20 times undo a previous transaction\n-        else if (utxoset.size()) {\n+        } else if (utxoset.size()) {\n+            //1/20 times undo a previous transaction\n             TxData &txd = FindRandomFrom(utxoset);\n \n             CTransaction &tx = std::get<0>(txd);\n@@ -365,8 +377,7 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n             // See code in DisconnectBlock\n             // remove outputs\n             {\n-                CCoinsModifier outs = stack.back()->ModifyCoins(undohash);\n-                outs->Clear();\n+                stack.back()->SpendCoin(COutPoint(undohash, 0));\n             }\n             // restore inputs\n             if (!tx.IsCoinBase()) {\n@@ -496,6 +507,7 @@ BOOST_AUTO_TEST_CASE(ccoins_serialization)\n }\n \n const static uint256 TXID;\n+const static COutPoint OUTPOINT = {uint256(), 0};\n const static CAmount PRUNED = -1;\n const static CAmount ABSENT = -2;\n const static CAmount FAIL = -3;\n@@ -577,10 +589,10 @@ class SingleEntryCacheTest\n     CCoinsViewCacheTest cache{&base};\n };\n \n-void CheckAccessCoins(CAmount base_value, CAmount cache_value, CAmount expected_value, char cache_flags, char expected_flags)\n+void CheckAccessCoin(CAmount base_value, CAmount cache_value, CAmount expected_value, char cache_flags, char expected_flags)\n {\n     SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n-    test.cache.AccessCoins(TXID);\n+    test.cache.AccessCoin(OUTPOINT);\n     test.cache.SelfTest();\n \n     CAmount result_value;\n@@ -599,39 +611,39 @@ BOOST_AUTO_TEST_CASE(ccoins_access)\n      *               Base    Cache   Result  Cache        Result\n      *               Value   Value   Value   Flags        Flags\n      */\n-    CheckAccessCoins(ABSENT, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   );\n-    CheckAccessCoins(ABSENT, PRUNED, PRUNED, 0          , 0          );\n-    CheckAccessCoins(ABSENT, PRUNED, PRUNED, FRESH      , FRESH      );\n-    CheckAccessCoins(ABSENT, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckAccessCoins(ABSENT, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoins(ABSENT, VALUE2, VALUE2, 0          , 0          );\n-    CheckAccessCoins(ABSENT, VALUE2, VALUE2, FRESH      , FRESH      );\n-    CheckAccessCoins(ABSENT, VALUE2, VALUE2, DIRTY      , DIRTY      );\n-    CheckAccessCoins(ABSENT, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoins(PRUNED, ABSENT, PRUNED, NO_ENTRY   , FRESH      );\n-    CheckAccessCoins(PRUNED, PRUNED, PRUNED, 0          , 0          );\n-    CheckAccessCoins(PRUNED, PRUNED, PRUNED, FRESH      , FRESH      );\n-    CheckAccessCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckAccessCoins(PRUNED, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoins(PRUNED, VALUE2, VALUE2, 0          , 0          );\n-    CheckAccessCoins(PRUNED, VALUE2, VALUE2, FRESH      , FRESH      );\n-    CheckAccessCoins(PRUNED, VALUE2, VALUE2, DIRTY      , DIRTY      );\n-    CheckAccessCoins(PRUNED, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoins(VALUE1, ABSENT, VALUE1, NO_ENTRY   , 0          );\n-    CheckAccessCoins(VALUE1, PRUNED, PRUNED, 0          , 0          );\n-    CheckAccessCoins(VALUE1, PRUNED, PRUNED, FRESH      , FRESH      );\n-    CheckAccessCoins(VALUE1, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckAccessCoins(VALUE1, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckAccessCoins(VALUE1, VALUE2, VALUE2, 0          , 0          );\n-    CheckAccessCoins(VALUE1, VALUE2, VALUE2, FRESH      , FRESH      );\n-    CheckAccessCoins(VALUE1, VALUE2, VALUE2, DIRTY      , DIRTY      );\n-    CheckAccessCoins(VALUE1, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(ABSENT, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   );\n+    CheckAccessCoin(ABSENT, PRUNED, PRUNED, 0          , 0          );\n+    CheckAccessCoin(ABSENT, PRUNED, PRUNED, FRESH      , FRESH      );\n+    CheckAccessCoin(ABSENT, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckAccessCoin(ABSENT, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(ABSENT, VALUE2, VALUE2, 0          , 0          );\n+    CheckAccessCoin(ABSENT, VALUE2, VALUE2, FRESH      , FRESH      );\n+    CheckAccessCoin(ABSENT, VALUE2, VALUE2, DIRTY      , DIRTY      );\n+    CheckAccessCoin(ABSENT, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(PRUNED, ABSENT, PRUNED, NO_ENTRY   , FRESH      );\n+    CheckAccessCoin(PRUNED, PRUNED, PRUNED, 0          , 0          );\n+    CheckAccessCoin(PRUNED, PRUNED, PRUNED, FRESH      , FRESH      );\n+    CheckAccessCoin(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckAccessCoin(PRUNED, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(PRUNED, VALUE2, VALUE2, 0          , 0          );\n+    CheckAccessCoin(PRUNED, VALUE2, VALUE2, FRESH      , FRESH      );\n+    CheckAccessCoin(PRUNED, VALUE2, VALUE2, DIRTY      , DIRTY      );\n+    CheckAccessCoin(PRUNED, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(VALUE1, ABSENT, VALUE1, NO_ENTRY   , 0          );\n+    CheckAccessCoin(VALUE1, PRUNED, PRUNED, 0          , 0          );\n+    CheckAccessCoin(VALUE1, PRUNED, PRUNED, FRESH      , FRESH      );\n+    CheckAccessCoin(VALUE1, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckAccessCoin(VALUE1, PRUNED, PRUNED, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckAccessCoin(VALUE1, VALUE2, VALUE2, 0          , 0          );\n+    CheckAccessCoin(VALUE1, VALUE2, VALUE2, FRESH      , FRESH      );\n+    CheckAccessCoin(VALUE1, VALUE2, VALUE2, DIRTY      , DIRTY      );\n+    CheckAccessCoin(VALUE1, VALUE2, VALUE2, DIRTY|FRESH, DIRTY|FRESH);\n }\n \n-void CheckModifyCoins(CAmount base_value, CAmount cache_value, CAmount modify_value, CAmount expected_value, char cache_flags, char expected_flags)\n+void CheckSpendCoins(CAmount base_value, CAmount cache_value, CAmount expected_value, char cache_flags, char expected_flags)\n {\n     SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n-    SetCoinsValue(modify_value, *test.cache.ModifyCoins(TXID));\n+    test.cache.SpendCoin(OUTPOINT);\n     test.cache.SelfTest();\n \n     CAmount result_value;\n@@ -641,79 +653,55 @@ void CheckModifyCoins(CAmount base_value, CAmount cache_value, CAmount modify_va\n     BOOST_CHECK_EQUAL(result_flags, expected_flags);\n };\n \n-BOOST_AUTO_TEST_CASE(ccoins_modify)\n+BOOST_AUTO_TEST_CASE(ccoins_spend)\n {\n-    /* Check ModifyCoin behavior, requesting a coin from a cache view layered on\n-     * top of a base view, writing a modification to the coin, and then checking\n+    /* Check SpendCoin behavior, requesting a coin from a cache view layered on\n+     * top of a base view, spending, and then checking\n      * the resulting entry in the cache after the modification.\n      *\n-     *               Base    Cache   Write   Result  Cache        Result\n-     *               Value   Value   Value   Value   Flags        Flags\n+     *              Base    Cache   Result  Cache        Result\n+     *              Value   Value   Value   Flags        Flags\n      */\n-    CheckModifyCoins(ABSENT, ABSENT, PRUNED, ABSENT, NO_ENTRY   , NO_ENTRY   );\n-    CheckModifyCoins(ABSENT, ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY|FRESH);\n-    CheckModifyCoins(ABSENT, PRUNED, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(ABSENT, PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(ABSENT, PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(ABSENT, PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(ABSENT, PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckModifyCoins(ABSENT, VALUE2, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(ABSENT, VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(ABSENT, VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(ABSENT, VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(ABSENT, VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckModifyCoins(PRUNED, ABSENT, PRUNED, ABSENT, NO_ENTRY   , NO_ENTRY   );\n-    CheckModifyCoins(PRUNED, ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY|FRESH);\n-    CheckModifyCoins(PRUNED, PRUNED, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(PRUNED, PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(PRUNED, PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(PRUNED, PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(PRUNED, PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckModifyCoins(PRUNED, VALUE2, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(PRUNED, VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(PRUNED, VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(PRUNED, VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(PRUNED, VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckModifyCoins(VALUE1, ABSENT, PRUNED, PRUNED, NO_ENTRY   , DIRTY      );\n-    CheckModifyCoins(VALUE1, ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY      );\n-    CheckModifyCoins(VALUE1, PRUNED, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(VALUE1, PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(VALUE1, PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(VALUE1, PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(VALUE1, PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n-    CheckModifyCoins(VALUE1, VALUE2, PRUNED, PRUNED, 0          , DIRTY      );\n-    CheckModifyCoins(VALUE1, VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n-    CheckModifyCoins(VALUE1, VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      );\n-    CheckModifyCoins(VALUE1, VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n-    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, 0          , DIRTY      );\n-    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH);\n-    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      );\n-    CheckModifyCoins(VALUE1, VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH);\n+    CheckSpendCoins(ABSENT, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   );\n+    CheckSpendCoins(ABSENT, PRUNED, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(ABSENT, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(ABSENT, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(ABSENT, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckSpendCoins(ABSENT, VALUE2, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(ABSENT, VALUE2, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(ABSENT, VALUE2, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(ABSENT, VALUE2, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckSpendCoins(PRUNED, ABSENT, ABSENT, NO_ENTRY   , NO_ENTRY   );\n+    CheckSpendCoins(PRUNED, PRUNED, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckSpendCoins(PRUNED, VALUE2, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(PRUNED, VALUE2, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(PRUNED, VALUE2, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(PRUNED, VALUE2, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckSpendCoins(VALUE1, ABSENT, PRUNED, NO_ENTRY   , DIRTY      );\n+    CheckSpendCoins(VALUE1, PRUNED, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(VALUE1, PRUNED, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(VALUE1, PRUNED, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(VALUE1, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n+    CheckSpendCoins(VALUE1, VALUE2, PRUNED, 0          , DIRTY      );\n+    CheckSpendCoins(VALUE1, VALUE2, ABSENT, FRESH      , NO_ENTRY   );\n+    CheckSpendCoins(VALUE1, VALUE2, PRUNED, DIRTY      , DIRTY      );\n+    CheckSpendCoins(VALUE1, VALUE2, ABSENT, DIRTY|FRESH, NO_ENTRY   );\n }\n \n-void CheckModifyNewCoinsBase(CAmount base_value, CAmount cache_value, CAmount modify_value, CAmount expected_value, char cache_flags, char expected_flags, bool coinbase)\n+void CheckAddCoinBase(CAmount base_value, CAmount cache_value, CAmount modify_value, CAmount expected_value, char cache_flags, char expected_flags, bool coinbase)\n {\n     SingleEntryCacheTest test(base_value, cache_value, cache_flags);\n \n     CAmount result_value;\n     char result_flags;\n     try {\n-        SetCoinsValue(modify_value, *test.cache.ModifyNewCoins(TXID, coinbase));\n+        CTxOut output;\n+        output.nValue = modify_value;\n+        test.cache.AddCoin(OUTPOINT, Coin(std::move(output), 1, coinbase), coinbase);\n+        test.cache.SelfTest();\n         GetCoinsMapEntry(test.cache.map(), result_value, result_flags);\n     } catch (std::logic_error& e) {\n         result_value = FAIL;\n@@ -724,64 +712,46 @@ void CheckModifyNewCoinsBase(CAmount base_value, CAmount cache_value, CAmount mo\n     BOOST_CHECK_EQUAL(result_flags, expected_flags);\n }\n \n-// Simple wrapper for CheckModifyNewCoinsBase function above that loops through\n+// Simple wrapper for CheckAddCoinBase function above that loops through\n // different possible base_values, making sure each one gives the same results.\n-// This wrapper lets the modify_new test below be shorter and less repetitive,\n-// while still verifying that the CoinsViewCache::ModifyNewCoins implementation\n+// This wrapper lets the coins_add test below be shorter and less repetitive,\n+// while still verifying that the CoinsViewCache::AddCoin implementation\n // ignores base values.\n template <typename... Args>\n-void CheckModifyNewCoins(Args&&... args)\n+void CheckAddCoin(Args&&... args)\n {\n     for (CAmount base_value : {ABSENT, PRUNED, VALUE1})\n-        CheckModifyNewCoinsBase(base_value, std::forward<Args>(args)...);\n+        CheckAddCoinBase(base_value, std::forward<Args>(args)...);\n }\n \n-BOOST_AUTO_TEST_CASE(ccoins_modify_new)\n+BOOST_AUTO_TEST_CASE(ccoins_add)\n {\n-    /* Check ModifyNewCoin behavior, requesting a new coin from a cache view,\n+    /* Check AddCoin behavior, requesting a new coin from a cache view,\n      * writing a modification to the coin, and then checking the resulting\n      * entry in the cache after the modification. Verify behavior with the\n-     * with the ModifyNewCoin coinbase argument set to false, and to true.\n+     * with the AddCoin potential_overwrite argument set to false, and to true.\n      *\n-     *                  Cache   Write   Result  Cache        Result     Coinbase\n-     *                  Value   Value   Value   Flags        Flags\n+     *           Cache   Write   Result  Cache        Result       potential_overwrite\n+     *           Value   Value   Value   Flags        Flags\n      */\n-    CheckModifyNewCoins(ABSENT, PRUNED, ABSENT, NO_ENTRY   , NO_ENTRY   , false);\n-    CheckModifyNewCoins(ABSENT, PRUNED, PRUNED, NO_ENTRY   , DIRTY      , true );\n-    CheckModifyNewCoins(ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY|FRESH, false);\n-    CheckModifyNewCoins(ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY      , true );\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, 0          , NO_ENTRY   , false);\n-    CheckModifyNewCoins(PRUNED, PRUNED, PRUNED, 0          , DIRTY      , true );\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   , false);\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, FRESH      , NO_ENTRY   , true );\n-    CheckModifyNewCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      , false);\n-    CheckModifyNewCoins(PRUNED, PRUNED, PRUNED, DIRTY      , DIRTY      , true );\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , false);\n-    CheckModifyNewCoins(PRUNED, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , true );\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, 0          , DIRTY|FRESH, false);\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, 0          , DIRTY      , true );\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, false);\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      , false);\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, false);\n-    CheckModifyNewCoins(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , 0          , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, PRUNED, PRUNED, 0          , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , FRESH      , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, FRESH      , NO_ENTRY   , true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , DIRTY      , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, PRUNED, PRUNED, DIRTY      , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, PRUNED, FAIL  , DIRTY|FRESH, NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, PRUNED, ABSENT, DIRTY|FRESH, NO_ENTRY   , true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , 0          , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, 0          , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , FRESH      , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , DIRTY      , NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n-    CheckModifyNewCoins(VALUE2, VALUE3, FAIL  , DIRTY|FRESH, NO_ENTRY   , false);\n-    CheckModifyNewCoins(VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n+    CheckAddCoin(ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY|FRESH, false);\n+    CheckAddCoin(ABSENT, VALUE3, VALUE3, NO_ENTRY   , DIRTY      , true );\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, 0          , DIRTY|FRESH, false);\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, 0          , DIRTY      , true );\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, false);\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      , false);\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, false);\n+    CheckAddCoin(PRUNED, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n+    CheckAddCoin(VALUE2, VALUE3, FAIL  , 0          , NO_ENTRY   , false);\n+    CheckAddCoin(VALUE2, VALUE3, VALUE3, 0          , DIRTY      , true );\n+    CheckAddCoin(VALUE2, VALUE3, FAIL  , FRESH      , NO_ENTRY   , false);\n+    CheckAddCoin(VALUE2, VALUE3, VALUE3, FRESH      , DIRTY|FRESH, true );\n+    CheckAddCoin(VALUE2, VALUE3, FAIL  , DIRTY      , NO_ENTRY   , false);\n+    CheckAddCoin(VALUE2, VALUE3, VALUE3, DIRTY      , DIRTY      , true );\n+    CheckAddCoin(VALUE2, VALUE3, FAIL  , DIRTY|FRESH, NO_ENTRY   , false);\n+    CheckAddCoin(VALUE2, VALUE3, VALUE3, DIRTY|FRESH, DIRTY|FRESH, true );\n }\n \n void CheckWriteCoins(CAmount parent_value, CAmount child_value, CAmount expected_value, char parent_flags, char child_flags, char expected_flags)"
      }
    ]
  },
  {
    "sha": "05293f3cb75ad08ca23cba8e795e27d4d5e4d690",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNTI5M2YzY2I3NWFkMDhjYTIzY2JhOGU3OTVlMjdkNGQ1ZTRkNjkw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:36Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T19:43:16Z"
      },
      "message": "Remove ModifyCoins/ModifyNewCoins",
      "tree": {
        "sha": "20109e5437f7ce1e2a111f0d8a20e0e72204b249",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/20109e5437f7ce1e2a111f0d8a20e0e72204b249"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/05293f3cb75ad08ca23cba8e795e27d4d5e4d690",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05293f3cb75ad08ca23cba8e795e27d4d5e4d690",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/05293f3cb75ad08ca23cba8e795e27d4d5e4d690",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05293f3cb75ad08ca23cba8e795e27d4d5e4d690/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "961e4839793f8b4ad37d29672faf1695ff6ec03a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/961e4839793f8b4ad37d29672faf1695ff6ec03a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/961e4839793f8b4ad37d29672faf1695ff6ec03a"
      }
    ],
    "stats": {
      "total": 130,
      "additions": 1,
      "deletions": 129
    },
    "files": [
      {
        "sha": "8b2f14837990efaf85b64b606123f1656a0d9463",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 82,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05293f3cb75ad08ca23cba8e795e27d4d5e4d690/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05293f3cb75ad08ca23cba8e795e27d4d5e4d690/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=05293f3cb75ad08ca23cba8e795e27d4d5e4d690",
        "patch": "@@ -60,12 +60,7 @@ size_t CCoinsViewBacked::EstimateSize() const { return base->EstimateSize(); }\n \n SaltedTxidHasher::SaltedTxidHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}\n \n-CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), hasModifier(false), cachedCoinsUsage(0) { }\n-\n-CCoinsViewCache::~CCoinsViewCache()\n-{\n-    assert(!hasModifier);\n-}\n+CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), cachedCoinsUsage(0) { }\n \n size_t CCoinsViewCache::DynamicMemoryUsage() const {\n     return memusage::DynamicUsage(cacheCoins) + cachedCoinsUsage;\n@@ -98,62 +93,6 @@ bool CCoinsViewCache::GetCoins(const uint256 &txid, CCoins &coins) const {\n     return false;\n }\n \n-CCoinsModifier CCoinsViewCache::ModifyCoins(const uint256 &txid) {\n-    assert(!hasModifier);\n-    std::pair<CCoinsMap::iterator, bool> ret = cacheCoins.insert(std::make_pair(txid, CCoinsCacheEntry()));\n-    size_t cachedCoinUsage = 0;\n-    if (ret.second) {\n-        if (!base->GetCoins(txid, ret.first->second.coins)) {\n-            // The parent view does not have this entry; mark it as fresh.\n-            ret.first->second.coins.Clear();\n-            ret.first->second.flags = CCoinsCacheEntry::FRESH;\n-        } else if (ret.first->second.coins.IsPruned()) {\n-            // The parent view only has a pruned entry for this; mark it as fresh.\n-            ret.first->second.flags = CCoinsCacheEntry::FRESH;\n-        }\n-    } else {\n-        cachedCoinUsage = ret.first->second.coins.DynamicMemoryUsage();\n-    }\n-    // Assume that whenever ModifyCoins is called, the entry will be modified.\n-    ret.first->second.flags |= CCoinsCacheEntry::DIRTY;\n-    return CCoinsModifier(*this, ret.first, cachedCoinUsage);\n-}\n-\n-/* ModifyNewCoins allows for faster coin modification when creating the new\n- * outputs from a transaction.  It assumes that BIP 30 (no duplicate txids)\n- * applies and has already been tested for (or the test is not required due to\n- * BIP 34, height in coinbase).  If we can assume BIP 30 then we know that any\n- * non-coinbase transaction we are adding to the UTXO must not already exist in\n- * the utxo unless it is fully spent.  Thus we can check only if it exists DIRTY\n- * at the current level of the cache, in which case it is not safe to mark it\n- * FRESH (b/c then its spentness still needs to flushed).  If it's not dirty and\n- * doesn't exist or is pruned in the current cache, we know it either doesn't\n- * exist or is pruned in parent caches, which is the definition of FRESH.  The\n- * exception to this is the two historical violations of BIP 30 in the chain,\n- * both of which were coinbases.  We do not mark these fresh so we we can ensure\n- * that they will still be properly overwritten when spent.\n- */\n-CCoinsModifier CCoinsViewCache::ModifyNewCoins(const uint256 &txid, bool coinbase) {\n-    assert(!hasModifier);\n-    std::pair<CCoinsMap::iterator, bool> ret = cacheCoins.insert(std::make_pair(txid, CCoinsCacheEntry()));\n-    if (!coinbase) {\n-        // New coins must not already exist.\n-        if (!ret.first->second.coins.IsPruned())\n-            throw std::logic_error(\"ModifyNewCoins should not find pre-existing coins on a non-coinbase unless they are pruned!\");\n-\n-        if (!(ret.first->second.flags & CCoinsCacheEntry::DIRTY)) {\n-            // If the coin is known to be pruned (have no unspent outputs) in\n-            // the current view and the cache entry is not dirty, we know the\n-            // coin also must be pruned in the parent view as well, so it is safe\n-            // to mark this fresh.\n-            ret.first->second.flags |= CCoinsCacheEntry::FRESH;\n-        }\n-    }\n-    ret.first->second.coins.Clear();\n-    ret.first->second.flags |= CCoinsCacheEntry::DIRTY;\n-    return CCoinsModifier(*this, ret.first, 0);\n-}\n-\n void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possible_overwrite) {\n     assert(!coin.IsPruned());\n     if (coin.out.scriptPubKey.IsUnspendable()) return;\n@@ -257,7 +196,6 @@ void CCoinsViewCache::SetBestBlock(const uint256 &hashBlockIn) {\n }\n \n bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn) {\n-    assert(!hasModifier);\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) { // Ignore non-dirty entries (optimization).\n             CCoinsMap::iterator itUs = cacheCoins.find(it->first);\n@@ -366,25 +304,6 @@ bool CCoinsViewCache::HaveInputs(const CTransaction& tx) const\n     return true;\n }\n \n-CCoinsModifier::CCoinsModifier(CCoinsViewCache& cache_, CCoinsMap::iterator it_, size_t usage) : cache(cache_), it(it_), cachedCoinUsage(usage) {\n-    assert(!cache.hasModifier);\n-    cache.hasModifier = true;\n-}\n-\n-CCoinsModifier::~CCoinsModifier()\n-{\n-    assert(cache.hasModifier);\n-    cache.hasModifier = false;\n-    it->second.coins.Cleanup();\n-    cache.cachedCoinsUsage -= cachedCoinUsage; // Subtract the old usage\n-    if ((it->second.flags & CCoinsCacheEntry::FRESH) && it->second.coins.IsPruned()) {\n-        cache.cacheCoins.erase(it);\n-    } else {\n-        // If the coin still exists after the modification, add the new usage\n-        cache.cachedCoinsUsage += it->second.coins.DynamicMemoryUsage();\n-    }\n-}\n-\n CCoinsViewCursor::~CCoinsViewCursor()\n {\n }"
      },
      {
        "sha": "fcf7c47a5621fc44757385caf92b2fe031251066",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 0,
        "deletions": 47,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05293f3cb75ad08ca23cba8e795e27d4d5e4d690/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05293f3cb75ad08ca23cba8e795e27d4d5e4d690/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=05293f3cb75ad08ca23cba8e795e27d4d5e4d690",
        "patch": "@@ -405,36 +405,10 @@ class CCoinsViewBacked : public CCoinsView\n };\n \n \n-class CCoinsViewCache;\n-\n-/** \n- * A reference to a mutable cache entry. Encapsulating it allows us to run\n- *  cleanup code after the modification is finished, and keeping track of\n- *  concurrent modifications. \n- */\n-class CCoinsModifier\n-{\n-private:\n-    CCoinsViewCache& cache;\n-    CCoinsMap::iterator it;\n-    size_t cachedCoinUsage; // Cached memory usage of the CCoins object before modification\n-    CCoinsModifier(CCoinsViewCache& cache_, CCoinsMap::iterator it_, size_t usage);\n-\n-public:\n-    CCoins* operator->() { return &it->second.coins; }\n-    CCoins& operator*() { return it->second.coins; }\n-    ~CCoinsModifier();\n-    friend class CCoinsViewCache;\n-};\n-\n /** CCoinsView that adds a memory cache for transactions to another CCoinsView */\n class CCoinsViewCache : public CCoinsViewBacked\n {\n protected:\n-    /* Whether this cache has an active modifier. */\n-    bool hasModifier;\n-\n-\n     /**\n      * Make mutable so that we can \"fill the cache\" even from Get-methods\n      * declared as \"const\".  \n@@ -447,7 +421,6 @@ class CCoinsViewCache : public CCoinsViewBacked\n \n public:\n     CCoinsViewCache(CCoinsView *baseIn);\n-    ~CCoinsViewCache();\n \n     // Standard CCoinsView methods\n     bool GetCoins(const uint256 &txid, CCoins &coins) const;\n@@ -479,24 +452,6 @@ class CCoinsViewCache : public CCoinsViewBacked\n      */\n     const Coin AccessCoin(const COutPoint &output) const;\n \n-    /**\n-     * Return a modifiable reference to a CCoins. If no entry with the given\n-     * txid exists, a new one is created. Simultaneous modifications are not\n-     * allowed.\n-     */\n-    CCoinsModifier ModifyCoins(const uint256 &txid);\n-\n-    /**\n-     * Return a modifiable reference to a CCoins. Assumes that no entry with the given\n-     * txid exists and creates a new one. This saves a database access in the case where\n-     * the coins were to be wiped out by FromTx anyway.  This should not be called with\n-     * the 2 historical coinbase duplicate pairs because the new coins are marked fresh, and\n-     * in the event the duplicate coinbase was spent before a flush, the now pruned coins\n-     * would not properly overwrite the first coinbase of the pair. Simultaneous modifications\n-     * are not allowed.\n-     */\n-    CCoinsModifier ModifyNewCoins(const uint256 &txid, bool coinbase);\n-\n     /**\n      * Add a coin. Set potential_overwrite to true if a non-pruned version may\n      * already exist.\n@@ -544,8 +499,6 @@ class CCoinsViewCache : public CCoinsViewBacked\n \n     const CTxOut &GetOutputFor(const CTxIn& input) const;\n \n-    friend class CCoinsModifier;\n-\n private:\n     CCoinsMap::iterator FetchCoins(const uint256 &txid) const;\n "
      }
    ]
  },
  {
    "sha": "13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMzg3MGI1NmZjZDBiZmFjZWRjZTNhZTQyYTNkZTNkNWU5ZGM3YmMx",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:37Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T19:43:16Z"
      },
      "message": "Replace CCoins-based CTxMemPool::pruneSpent with isSpent",
      "tree": {
        "sha": "874be8e8f747c15d337df1f7b5b94875aac8fb68",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/874be8e8f747c15d337df1f7b5b94875aac8fb68"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "05293f3cb75ad08ca23cba8e795e27d4d5e4d690",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05293f3cb75ad08ca23cba8e795e27d4d5e4d690",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/05293f3cb75ad08ca23cba8e795e27d4d5e4d690"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 5,
      "deletions": 14
    },
    "files": [
      {
        "sha": "4a71010094f4be06df48d1cf7183ca795b02c7da",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1",
        "patch": "@@ -513,8 +513,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n             uint256 hash = vOutPoints[i].hash;\n             bool hit = false;\n             if (view.GetCoins(hash, coins)) {\n-                mempool.pruneSpent(hash, coins);\n-                if (coins.IsAvailable(vOutPoints[i].n)) {\n+                if (coins.IsAvailable(vOutPoints[i].n) && !mempool.isSpent(vOutPoints[i])) {\n                     hit = true;\n                     // Safe to index into vout here because IsAvailable checked if it's off the end of the array, or if\n                     // n is valid but points to an already spent output (IsNull)."
      },
      {
        "sha": "94e42a8644c2b3135b3171d42855a5b76cb1871e",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1",
        "patch": "@@ -973,9 +973,8 @@ UniValue gettxout(const JSONRPCRequest& request)\n     if (fMempool) {\n         LOCK(mempool.cs);\n         CCoinsViewMemPool view(pcoinsTip, mempool);\n-        if (!view.GetCoins(hash, coins))\n+        if (!view.GetCoins(hash, coins) || mempool.isSpent(COutPoint(hash, n))) // TODO: this should be done by the CCoinsViewMemPool\n             return NullUniValue;\n-        mempool.pruneSpent(hash, coins); // TODO: this should be done by the CCoinsViewMemPool\n     } else {\n         if (!pcoinsTip->GetCoins(hash, coins))\n             return NullUniValue;"
      },
      {
        "sha": "51b93e92baa05e61c8a40422c47e1daab432427a",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 9,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1",
        "patch": "@@ -343,17 +343,10 @@ CTxMemPool::CTxMemPool(CBlockPolicyEstimator* estimator) :\n     nCheckFrequency = 0;\n }\n \n-void CTxMemPool::pruneSpent(const uint256 &hashTx, CCoins &coins)\n+bool CTxMemPool::isSpent(const COutPoint& outpoint)\n {\n     LOCK(cs);\n-\n-    auto it = mapNextTx.lower_bound(COutPoint(hashTx, 0));\n-\n-    // iterate over all COutPoints in mapNextTx whose hash equals the provided hashTx\n-    while (it != mapNextTx.end() && it->first->hash == hashTx) {\n-        coins.Spend(it->first->n); // and remove those outputs from coins\n-        it++;\n-    }\n+    return mapNextTx.count(outpoint);\n }\n \n unsigned int CTxMemPool::GetTransactionsUpdated() const"
      },
      {
        "sha": "6547f64f7475d45bccf30cb95a1908de72dd933a",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1",
        "patch": "@@ -509,7 +509,7 @@ class CTxMemPool\n     void _clear(); //lock free\n     bool CompareDepthAndScore(const uint256& hasha, const uint256& hashb);\n     void queryHashes(std::vector<uint256>& vtxid);\n-    void pruneSpent(const uint256& hash, CCoins &coins);\n+    bool isSpent(const COutPoint& outpoint);\n     unsigned int GetTransactionsUpdated() const;\n     void AddTransactionsUpdated(unsigned int n);\n     /**"
      }
    ]
  },
  {
    "sha": "4ec0d9e794e3f338e1ebb8b644ae890d2c2da2ee",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZWMwZDllNzk0ZTNmMzM4ZTFlYmI4YjY0NGFlODkwZDJjMmRhMmVl",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-26T23:39:58Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T19:43:16Z"
      },
      "message": "Refactor GetUTXOStats in preparation for per-COutPoint iteration",
      "tree": {
        "sha": "7a04977d4a0669ce878114279f13c991b4cf1cb0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7a04977d4a0669ce878114279f13c991b4cf1cb0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4ec0d9e794e3f338e1ebb8b644ae890d2c2da2ee",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ec0d9e794e3f338e1ebb8b644ae890d2c2da2ee",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4ec0d9e794e3f338e1ebb8b644ae890d2c2da2ee",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ec0d9e794e3f338e1ebb8b644ae890d2c2da2ee/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/13870b56fcd0bfacedce3ae42a3de3d5e9dc7bc1"
      }
    ],
    "stats": {
      "total": 32,
      "additions": 20,
      "deletions": 12
    },
    "files": [
      {
        "sha": "3e9b1a1b12c9213a1e26697122e1eac954b2a45e",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 12,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4ec0d9e794e3f338e1ebb8b644ae890d2c2da2ee/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4ec0d9e794e3f338e1ebb8b644ae890d2c2da2ee/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=4ec0d9e794e3f338e1ebb8b644ae890d2c2da2ee",
        "patch": "@@ -788,6 +788,22 @@ struct CCoinsStats\n     CCoinsStats() : nHeight(0), nTransactions(0), nTransactionOutputs(0), nTotalAmount(0) {}\n };\n \n+static void ApplyStats(CCoinsStats &stats, CHashWriter& ss, const uint256& hash, const std::map<uint32_t, Coin>& outputs)\n+{\n+    assert(!outputs.empty());\n+    ss << hash;\n+    ss << VARINT(outputs.begin()->second.nHeight * 2 + outputs.begin()->second.fCoinBase);\n+    stats.nTransactions++;\n+    for (const auto output : outputs) {\n+        ss << VARINT(output.first + 1);\n+        ss << *(const CScriptBase*)(&output.second.out.scriptPubKey);\n+        ss << VARINT(output.second.out.nValue);\n+        stats.nTransactionOutputs++;\n+        stats.nTotalAmount += output.second.out.nValue;\n+    }\n+    ss << VARINT(0);\n+}\n+\n //! Calculate statistics about the unspent transaction output set\n static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n {\n@@ -800,33 +816,25 @@ static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n         stats.nHeight = mapBlockIndex.find(stats.hashBlock)->second->nHeight;\n     }\n     ss << stats.hashBlock;\n-    CAmount nTotalAmount = 0;\n     while (pcursor->Valid()) {\n         boost::this_thread::interruption_point();\n         uint256 key;\n         CCoins coins;\n         if (pcursor->GetKey(key) && pcursor->GetValue(coins)) {\n-            stats.nTransactions++;\n-            ss << key;\n-            ss << VARINT(coins.nHeight * 2 + coins.fCoinBase);\n+            std::map<uint32_t, Coin> outputs;\n             for (unsigned int i=0; i<coins.vout.size(); i++) {\n-                const CTxOut &out = coins.vout[i];\n+                CTxOut &out = coins.vout[i];\n                 if (!out.IsNull()) {\n-                    stats.nTransactionOutputs++;\n-                    ss << VARINT(i+1);\n-                    ss << *(const CScriptBase*)(&out.scriptPubKey);\n-                    ss << VARINT(out.nValue);\n-                    nTotalAmount += out.nValue;\n+                    outputs[i] = Coin(std::move(out), coins.nHeight, coins.fCoinBase);\n                 }\n             }\n-            ss << VARINT(0);\n+            ApplyStats(stats, ss, key, outputs);\n         } else {\n             return error(\"%s: unable to read value\", __func__);\n         }\n         pcursor->Next();\n     }\n     stats.hashSerialized = ss.GetHash();\n-    stats.nTotalAmount = nTotalAmount;\n     stats.nDiskSize = view->EstimateSize();\n     return true;\n }"
      }
    ]
  },
  {
    "sha": "50830796889ecaa458871f1db878c255dd2554cb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1MDgzMDc5Njg4OWVjYWE0NTg4NzFmMWRiODc4YzI1NWRkMjU1NGNi",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:39Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T19:59:38Z"
      },
      "message": "Switch CCoinsView and chainstate db from per-txid to per-txout\n\nThis patch makes several related changes:\n* Changes the CCoinsView virtual methods (GetCoins, HaveCoins, ...)\n  to be COutPoint/Coin-based rather than txid/CCoins-based.\n* Changes the chainstate db to a new incompatible format that is also\n  COutPoint/Coin based.\n* Implements reconstruction code for hash_serialized_2.\n* Adapts the coins_tests unit tests (thanks to Russell Yanofsky).\n\nA side effect of the new CCoinsView model is that we can no longer\nuse the (unreliable) test for transaction outputs in the UTXO set\nto determine whether we already have a particular transaction.",
      "tree": {
        "sha": "32f3b55294a28d5328821b334a6b31be40d024d9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/32f3b55294a28d5328821b334a6b31be40d024d9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/50830796889ecaa458871f1db878c255dd2554cb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/50830796889ecaa458871f1db878c255dd2554cb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/50830796889ecaa458871f1db878c255dd2554cb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/50830796889ecaa458871f1db878c255dd2554cb/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4ec0d9e794e3f338e1ebb8b644ae890d2c2da2ee",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4ec0d9e794e3f338e1ebb8b644ae890d2c2da2ee",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4ec0d9e794e3f338e1ebb8b644ae890d2c2da2ee"
      }
    ],
    "stats": {
      "total": 728,
      "additions": 359,
      "deletions": 369
    },
    "files": [
      {
        "sha": "38b8df1713d8eb61482edab77b6dd2b6674f3f2c",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 40,
        "deletions": 72,
        "changes": 112,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50830796889ecaa458871f1db878c255dd2554cb/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50830796889ecaa458871f1db878c255dd2554cb/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=50830796889ecaa458871f1db878c255dd2554cb",
        "patch": "@@ -42,52 +42,51 @@ bool CCoins::Spend(uint32_t nPos)\n     return true;\n }\n \n-bool CCoinsView::GetCoins(const uint256 &txid, CCoins &coins) const { return false; }\n-bool CCoinsView::HaveCoins(const uint256 &txid) const { return false; }\n+bool CCoinsView::GetCoins(const COutPoint &outpoint, Coin &coin) const { return false; }\n+bool CCoinsView::HaveCoins(const COutPoint &outpoint) const { return false; }\n uint256 CCoinsView::GetBestBlock() const { return uint256(); }\n bool CCoinsView::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return false; }\n CCoinsViewCursor *CCoinsView::Cursor() const { return 0; }\n \n \n CCoinsViewBacked::CCoinsViewBacked(CCoinsView *viewIn) : base(viewIn) { }\n-bool CCoinsViewBacked::GetCoins(const uint256 &txid, CCoins &coins) const { return base->GetCoins(txid, coins); }\n-bool CCoinsViewBacked::HaveCoins(const uint256 &txid) const { return base->HaveCoins(txid); }\n+bool CCoinsViewBacked::GetCoins(const COutPoint &outpoint, Coin &coin) const { return base->GetCoins(outpoint, coin); }\n+bool CCoinsViewBacked::HaveCoins(const COutPoint &outpoint) const { return base->HaveCoins(outpoint); }\n uint256 CCoinsViewBacked::GetBestBlock() const { return base->GetBestBlock(); }\n void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n CCoinsViewCursor *CCoinsViewBacked::Cursor() const { return base->Cursor(); }\n size_t CCoinsViewBacked::EstimateSize() const { return base->EstimateSize(); }\n \n-SaltedTxidHasher::SaltedTxidHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}\n+SaltedOutpointHasher::SaltedOutpointHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}\n \n-CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), cachedCoinsUsage(0) { }\n+CCoinsViewCache::CCoinsViewCache(CCoinsView *baseIn) : CCoinsViewBacked(baseIn), cachedCoinsUsage(0) {}\n \n size_t CCoinsViewCache::DynamicMemoryUsage() const {\n     return memusage::DynamicUsage(cacheCoins) + cachedCoinsUsage;\n }\n \n-CCoinsMap::iterator CCoinsViewCache::FetchCoins(const uint256 &txid) const {\n-    CCoinsMap::iterator it = cacheCoins.find(txid);\n+CCoinsMap::iterator CCoinsViewCache::FetchCoins(const COutPoint &outpoint) const {\n+    CCoinsMap::iterator it = cacheCoins.find(outpoint);\n     if (it != cacheCoins.end())\n         return it;\n-    CCoins tmp;\n-    if (!base->GetCoins(txid, tmp))\n+    Coin tmp;\n+    if (!base->GetCoins(outpoint, tmp))\n         return cacheCoins.end();\n-    CCoinsMap::iterator ret = cacheCoins.insert(std::make_pair(txid, CCoinsCacheEntry())).first;\n-    tmp.swap(ret->second.coins);\n+    CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first;\n     if (ret->second.coins.IsPruned()) {\n-        // The parent only has an empty entry for this txid; we can consider our\n+        // The parent only has an empty entry for this outpoint; we can consider our\n         // version as fresh.\n         ret->second.flags = CCoinsCacheEntry::FRESH;\n     }\n     cachedCoinsUsage += ret->second.coins.DynamicMemoryUsage();\n     return ret;\n }\n \n-bool CCoinsViewCache::GetCoins(const uint256 &txid, CCoins &coins) const {\n-    CCoinsMap::const_iterator it = FetchCoins(txid);\n+bool CCoinsViewCache::GetCoins(const COutPoint &outpoint, Coin &coin) const {\n+    CCoinsMap::const_iterator it = FetchCoins(outpoint);\n     if (it != cacheCoins.end()) {\n-        coins = it->second.coins;\n+        coin = it->second.coins;\n         return true;\n     }\n     return false;\n@@ -98,23 +97,18 @@ void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possi\n     if (coin.out.scriptPubKey.IsUnspendable()) return;\n     CCoinsMap::iterator it;\n     bool inserted;\n-    std::tie(it, inserted) = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint.hash), std::tuple<>());\n+    std::tie(it, inserted) = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::tuple<>());\n     bool fresh = false;\n     if (!inserted) {\n         cachedCoinsUsage -= it->second.coins.DynamicMemoryUsage();\n     }\n     if (!possible_overwrite) {\n-        if (it->second.coins.IsAvailable(outpoint.n)) {\n+        if (!it->second.coins.IsPruned()) {\n             throw std::logic_error(\"Adding new coin that replaces non-pruned entry\");\n         }\n-        fresh = it->second.coins.IsPruned() && !(it->second.flags & CCoinsCacheEntry::DIRTY);\n+        fresh = !(it->second.flags & CCoinsCacheEntry::DIRTY);\n     }\n-    if (it->second.coins.vout.size() <= outpoint.n) {\n-        it->second.coins.vout.resize(outpoint.n + 1);\n-    }\n-    it->second.coins.vout[outpoint.n] = std::move(coin.out);\n-    it->second.coins.nHeight = coin.nHeight;\n-    it->second.coins.fCoinBase = coin.fCoinBase;\n+    it->second.coins = std::move(coin);\n     it->second.flags |= CCoinsCacheEntry::DIRTY | (fresh ? CCoinsCacheEntry::FRESH : 0);\n     cachedCoinsUsage += it->second.coins.DynamicMemoryUsage();\n }\n@@ -130,58 +124,38 @@ void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight) {\n }\n \n void CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n-    CCoinsMap::iterator it = FetchCoins(outpoint.hash);\n+    CCoinsMap::iterator it = FetchCoins(outpoint);\n     if (it == cacheCoins.end()) return;\n     cachedCoinsUsage -= it->second.coins.DynamicMemoryUsage();\n-    if (moveout && it->second.coins.IsAvailable(outpoint.n)) {\n-        *moveout = Coin(it->second.coins.vout[outpoint.n], it->second.coins.nHeight, it->second.coins.fCoinBase);\n+    if (moveout) {\n+        *moveout = std::move(it->second.coins);\n     }\n-    it->second.coins.Spend(outpoint.n); // Ignore return value: SpendCoin has no effect if no UTXO found.\n-    if (it->second.coins.IsPruned() && it->second.flags & CCoinsCacheEntry::FRESH) {\n+    if (it->second.flags & CCoinsCacheEntry::FRESH) {\n         cacheCoins.erase(it);\n     } else {\n-        cachedCoinsUsage += it->second.coins.DynamicMemoryUsage();\n         it->second.flags |= CCoinsCacheEntry::DIRTY;\n-    }\n-}\n-\n-const CCoins* CCoinsViewCache::AccessCoins(const uint256 &txid) const {\n-    CCoinsMap::const_iterator it = FetchCoins(txid);\n-    if (it == cacheCoins.end()) {\n-        return NULL;\n-    } else {\n-        return &it->second.coins;\n+        it->second.coins.Clear();\n     }\n }\n \n static const Coin coinEmpty;\n \n-const Coin CCoinsViewCache::AccessCoin(const COutPoint &outpoint) const {\n-    CCoinsMap::const_iterator it = FetchCoins(outpoint.hash);\n-    if (it == cacheCoins.end() || !it->second.coins.IsAvailable(outpoint.n)) {\n+const Coin& CCoinsViewCache::AccessCoin(const COutPoint &outpoint) const {\n+    CCoinsMap::const_iterator it = FetchCoins(outpoint);\n+    if (it == cacheCoins.end()) {\n         return coinEmpty;\n     } else {\n-        return Coin(it->second.coins.vout[outpoint.n], it->second.coins.nHeight, it->second.coins.fCoinBase);\n+        return it->second.coins;\n     }\n }\n \n-\n-bool CCoinsViewCache::HaveCoins(const uint256 &txid) const {\n-    CCoinsMap::const_iterator it = FetchCoins(txid);\n-    // We're using vtx.empty() instead of IsPruned here for performance reasons,\n-    // as we only care about the case where a transaction was replaced entirely\n-    // in a reorganization (which wipes vout entirely, as opposed to spending\n-    // which just cleans individual outputs).\n-    return (it != cacheCoins.end() && !it->second.coins.vout.empty());\n-}\n-\n bool CCoinsViewCache::HaveCoins(const COutPoint &outpoint) const {\n-    CCoinsMap::const_iterator it = FetchCoins(outpoint.hash);\n-    return (it != cacheCoins.end() && it->second.coins.IsAvailable(outpoint.n));\n+    CCoinsMap::const_iterator it = FetchCoins(outpoint);\n+    return (it != cacheCoins.end() && !it->second.coins.IsPruned());\n }\n \n-bool CCoinsViewCache::HaveCoinsInCache(const uint256 &txid) const {\n-    CCoinsMap::const_iterator it = cacheCoins.find(txid);\n+bool CCoinsViewCache::HaveCoinsInCache(const COutPoint &outpoint) const {\n+    CCoinsMap::const_iterator it = cacheCoins.find(outpoint);\n     return it != cacheCoins.end();\n }\n \n@@ -206,7 +180,7 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n                     // Otherwise we will need to create it in the parent\n                     // and move the data up and mark it as dirty\n                     CCoinsCacheEntry& entry = cacheCoins[it->first];\n-                    entry.coins.swap(it->second.coins);\n+                    entry.coins = std::move(it->second.coins);\n                     cachedCoinsUsage += entry.coins.DynamicMemoryUsage();\n                     entry.flags = CCoinsCacheEntry::DIRTY;\n                     // We can mark it FRESH in the parent if it was FRESH in the child\n@@ -233,7 +207,7 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n                 } else {\n                     // A normal modification.\n                     cachedCoinsUsage -= itUs->second.coins.DynamicMemoryUsage();\n-                    itUs->second.coins.swap(it->second.coins);\n+                    itUs->second.coins = std::move(it->second.coins);\n                     cachedCoinsUsage += itUs->second.coins.DynamicMemoryUsage();\n                     itUs->second.flags |= CCoinsCacheEntry::DIRTY;\n                     // NOTE: It is possible the child has a FRESH flag here in\n@@ -258,7 +232,7 @@ bool CCoinsViewCache::Flush() {\n     return fOk;\n }\n \n-void CCoinsViewCache::Uncache(const uint256& hash)\n+void CCoinsViewCache::Uncache(const COutPoint& hash)\n {\n     CCoinsMap::iterator it = cacheCoins.find(hash);\n     if (it != cacheCoins.end() && it->second.flags == 0) {\n@@ -273,9 +247,9 @@ unsigned int CCoinsViewCache::GetCacheSize() const {\n \n const CTxOut &CCoinsViewCache::GetOutputFor(const CTxIn& input) const\n {\n-    const CCoins* coins = AccessCoins(input.prevout.hash);\n-    assert(coins && coins->IsAvailable(input.prevout.n));\n-    return coins->vout[input.prevout.n];\n+    const Coin& coin = AccessCoin(input.prevout);\n+    assert(!coin.IsPruned());\n+    return coin.out;\n }\n \n CAmount CCoinsViewCache::GetValueIn(const CTransaction& tx) const\n@@ -294,23 +268,17 @@ bool CCoinsViewCache::HaveInputs(const CTransaction& tx) const\n {\n     if (!tx.IsCoinBase()) {\n         for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-            const COutPoint &prevout = tx.vin[i].prevout;\n-            const CCoins* coins = AccessCoins(prevout.hash);\n-            if (!coins || !coins->IsAvailable(prevout.n)) {\n+            if (!HaveCoins(tx.vin[i].prevout)) {\n                 return false;\n             }\n         }\n     }\n     return true;\n }\n \n-CCoinsViewCursor::~CCoinsViewCursor()\n-{\n-}\n-\n static const size_t MAX_OUTPUTS_PER_BLOCK = MAX_BLOCK_BASE_SIZE /  ::GetSerializeSize(CTxOut(), SER_NETWORK, PROTOCOL_VERSION); // TODO: merge with similar definition in undo.h.\n \n-const Coin AccessByTxid(const CCoinsViewCache& view, const uint256& txid)\n+const Coin& AccessByTxid(const CCoinsViewCache& view, const uint256& txid)\n {\n     COutPoint iter(txid, 0);\n     while (iter.n < MAX_OUTPUTS_PER_BLOCK) {"
      },
      {
        "sha": "ae85a199caa70c91654ed73e02f2f896375d7180",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 33,
        "deletions": 41,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50830796889ecaa458871f1db878c255dd2554cb/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50830796889ecaa458871f1db878c255dd2554cb/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=50830796889ecaa458871f1db878c255dd2554cb",
        "patch": "@@ -299,28 +299,28 @@ class CCoins\n     }\n };\n \n-class SaltedTxidHasher\n+class SaltedOutpointHasher\n {\n private:\n     /** Salt */\n     const uint64_t k0, k1;\n \n public:\n-    SaltedTxidHasher();\n+    SaltedOutpointHasher();\n \n     /**\n      * This *must* return size_t. With Boost 1.46 on 32-bit systems the\n      * unordered_map will behave unpredictably if the custom hasher returns a\n      * uint64_t, resulting in failures when syncing the chain (#4634).\n      */\n-    size_t operator()(const uint256& txid) const {\n-        return SipHashUint256(k0, k1, txid);\n+    size_t operator()(const COutPoint& id) const {\n+        return SipHashUint256Extra(k0, k1, id.hash, id.n);\n     }\n };\n \n struct CCoinsCacheEntry\n {\n-    CCoins coins; // The actual cached data.\n+    Coin coins; // The actual cached data.\n     unsigned char flags;\n \n     enum Flags {\n@@ -333,20 +333,21 @@ struct CCoinsCacheEntry\n          */\n     };\n \n-    CCoinsCacheEntry() : coins(), flags(0) {}\n+    CCoinsCacheEntry() : flags(0) {}\n+    explicit CCoinsCacheEntry(Coin&& coin_) : coins(std::move(coin_)), flags(0) {}\n };\n \n-typedef std::unordered_map<uint256, CCoinsCacheEntry, SaltedTxidHasher> CCoinsMap;\n+typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;\n \n /** Cursor for iterating over CoinsView state */\n class CCoinsViewCursor\n {\n public:\n     CCoinsViewCursor(const uint256 &hashBlockIn): hashBlock(hashBlockIn) {}\n-    virtual ~CCoinsViewCursor();\n+    virtual ~CCoinsViewCursor() {}\n \n-    virtual bool GetKey(uint256 &key) const = 0;\n-    virtual bool GetValue(CCoins &coins) const = 0;\n+    virtual bool GetKey(COutPoint &key) const = 0;\n+    virtual bool GetValue(Coin &coin) const = 0;\n     virtual unsigned int GetValueSize() const = 0;\n \n     virtual bool Valid() const = 0;\n@@ -362,17 +363,17 @@ class CCoinsViewCursor\n class CCoinsView\n {\n public:\n-    //! Retrieve the CCoins (unspent transaction outputs) for a given txid\n-    virtual bool GetCoins(const uint256 &txid, CCoins &coins) const;\n+    //! Retrieve the Coin (unspent transaction output) for a given outpoint.\n+    virtual bool GetCoins(const COutPoint &outpoint, Coin &coin) const;\n \n-    //! Just check whether we have data for a given txid.\n-    //! This may (but cannot always) return true for fully spent transactions\n-    virtual bool HaveCoins(const uint256 &txid) const;\n+    //! Just check whether we have data for a given outpoint.\n+    //! This may (but cannot always) return true for spent outputs.\n+    virtual bool HaveCoins(const COutPoint &outpoint) const;\n \n     //! Retrieve the block hash whose state this CCoinsView currently represents\n     virtual uint256 GetBestBlock() const;\n \n-    //! Do a bulk modification (multiple CCoins changes + BestBlock change).\n+    //! Do a bulk modification (multiple Coin changes + BestBlock change).\n     //! The passed mapCoins can be modified.\n     virtual bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n \n@@ -395,12 +396,12 @@ class CCoinsViewBacked : public CCoinsView\n \n public:\n     CCoinsViewBacked(CCoinsView *viewIn);\n-    bool GetCoins(const uint256 &txid, CCoins &coins) const;\n-    bool HaveCoins(const uint256 &txid) const;\n-    uint256 GetBestBlock() const;\n+    bool GetCoins(const COutPoint &outpoint, Coin &coin) const override;\n+    bool HaveCoins(const COutPoint &outpoint) const override;\n+    uint256 GetBestBlock() const override;\n     void SetBackend(CCoinsView &viewIn);\n-    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n-    CCoinsViewCursor *Cursor() const;\n+    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n+    CCoinsViewCursor *Cursor() const override;\n     size_t EstimateSize() const override;\n };\n \n@@ -416,41 +417,32 @@ class CCoinsViewCache : public CCoinsViewBacked\n     mutable uint256 hashBlock;\n     mutable CCoinsMap cacheCoins;\n \n-    /* Cached dynamic memory usage for the inner CCoins objects. */\n+    /* Cached dynamic memory usage for the inner Coin objects. */\n     mutable size_t cachedCoinsUsage;\n \n public:\n     CCoinsViewCache(CCoinsView *baseIn);\n \n     // Standard CCoinsView methods\n-    bool GetCoins(const uint256 &txid, CCoins &coins) const;\n-    bool HaveCoins(const uint256 &txid) const;\n+    bool GetCoins(const COutPoint &outpoint, Coin &coin) const;\n     bool HaveCoins(const COutPoint &outpoint) const;\n     uint256 GetBestBlock() const;\n     void SetBestBlock(const uint256 &hashBlock);\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n \n     /**\n-     * Check if we have the given tx already loaded in this cache.\n+     * Check if we have the given utxo already loaded in this cache.\n      * The semantics are the same as HaveCoins(), but no calls to\n      * the backing CCoinsView are made.\n      */\n-    bool HaveCoinsInCache(const uint256 &txid) const;\n-\n-    /**\n-     * Return a pointer to CCoins in the cache, or NULL if not found. This is\n-     * more efficient than GetCoins. Modifications to other cache entries are\n-     * allowed while accessing the returned pointer.\n-     */\n-    const CCoins* AccessCoins(const uint256 &txid) const;\n+    bool HaveCoinsInCache(const COutPoint &outpoint) const;\n \n     /**\n-     * Return a copy of a Coin in the cache, or a pruned one if not found. This is\n+     * Return a reference to Coin in the cache, or a pruned one if not found. This is\n      * more efficient than GetCoins. Modifications to other cache entries are\n      * allowed while accessing the returned pointer.\n-     * TODO: return a reference to a Coin after changing CCoinsViewCache storage.\n      */\n-    const Coin AccessCoin(const COutPoint &output) const;\n+    const Coin& AccessCoin(const COutPoint &output) const;\n \n     /**\n      * Add a coin. Set potential_overwrite to true if a non-pruned version may\n@@ -473,12 +465,12 @@ class CCoinsViewCache : public CCoinsViewBacked\n     bool Flush();\n \n     /**\n-     * Removes the transaction with the given hash from the cache, if it is\n+     * Removes the UTXO with the given outpoint from the cache, if it is\n      * not modified.\n      */\n-    void Uncache(const uint256 &txid);\n+    void Uncache(const COutPoint &outpoint);\n \n-    //! Calculate the size of the cache (in number of transactions)\n+    //! Calculate the size of the cache (in number of transaction outputs)\n     unsigned int GetCacheSize() const;\n \n     //! Calculate the size of the cache (in bytes)\n@@ -500,7 +492,7 @@ class CCoinsViewCache : public CCoinsViewBacked\n     const CTxOut &GetOutputFor(const CTxIn& input) const;\n \n private:\n-    CCoinsMap::iterator FetchCoins(const uint256 &txid) const;\n+    CCoinsMap::iterator FetchCoins(const COutPoint &outpoint) const;\n \n     /**\n      * By making the copy constructor private, we prevent accidentally using it when one intends to create a cache on top of a base cache.\n@@ -515,6 +507,6 @@ class CCoinsViewCache : public CCoinsViewBacked\n void AddCoins(CCoinsViewCache& cache, const CTransaction& tx, int nHeight);\n \n //! Utility function to find any unspent output with a given txid.\n-const Coin AccessByTxid(const CCoinsViewCache& cache, const uint256& txid);\n+const Coin& AccessByTxid(const CCoinsViewCache& cache, const uint256& txid);\n \n #endif // BITCOIN_COINS_H"
      },
      {
        "sha": "4420b6f6582da6c8c4dc1ef6f0f6a0e461feec78",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50830796889ecaa458871f1db878c255dd2554cb/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50830796889ecaa458871f1db878c255dd2554cb/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=50830796889ecaa458871f1db878c255dd2554cb",
        "patch": "@@ -146,9 +146,9 @@ class CCoinsViewErrorCatcher : public CCoinsViewBacked\n {\n public:\n     CCoinsViewErrorCatcher(CCoinsView* view) : CCoinsViewBacked(view) {}\n-    bool GetCoins(const uint256 &txid, CCoins &coins) const {\n+    bool GetCoins(const COutPoint &outpoint, Coin &coin) const override {\n         try {\n-            return CCoinsViewBacked::GetCoins(txid, coins);\n+            return CCoinsViewBacked::GetCoins(outpoint, coin);\n         } catch(const std::runtime_error& e) {\n             uiInterface.ThreadSafeMessageBox(_(\"Error reading from database, shutting down.\"), \"\", CClientUIInterface::MSG_ERROR);\n             LogPrintf(\"Error reading from database: %s\\n\", e.what());"
      },
      {
        "sha": "1c99d047ed5aa24352c8ff472040b74ed62fd782",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50830796889ecaa458871f1db878c255dd2554cb/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50830796889ecaa458871f1db878c255dd2554cb/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=50830796889ecaa458871f1db878c255dd2554cb",
        "patch": "@@ -911,12 +911,11 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n                 recentRejects->reset();\n             }\n \n-            // Use pcoinsTip->HaveCoinsInCache as a quick approximation to exclude\n-            // requesting or processing some txs which have already been included in a block\n             return recentRejects->contains(inv.hash) ||\n                    mempool.exists(inv.hash) ||\n                    mapOrphanTransactions.count(inv.hash) ||\n-                   pcoinsTip->HaveCoinsInCache(inv.hash);\n+                   pcoinsTip->HaveCoinsInCache(COutPoint(inv.hash, 0)) || // Best effort: only try output 0 and 1\n+                   pcoinsTip->HaveCoinsInCache(COutPoint(inv.hash, 1));\n         }\n     case MSG_BLOCK:\n     case MSG_WITNESS_BLOCK:"
      },
      {
        "sha": "78317c1121ce846b32eb59c14dcd119c457a5f38",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 4,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50830796889ecaa458871f1db878c255dd2554cb/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50830796889ecaa458871f1db878c255dd2554cb/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=50830796889ecaa458871f1db878c255dd2554cb",
        "patch": "@@ -293,13 +293,12 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n         {\n             COutPoint prevout = txin.prevout;\n \n-            CCoins prev;\n-            if(pcoinsTip->GetCoins(prevout.hash, prev))\n+            Coin prev;\n+            if(pcoinsTip->GetCoins(prevout, prev))\n             {\n-                if (prevout.n < prev.vout.size())\n                 {\n                     strHTML += \"<li>\";\n-                    const CTxOut &vout = prev.vout[prevout.n];\n+                    const CTxOut &vout = prev.out;\n                     CTxDestination address;\n                     if (ExtractDestination(vout.scriptPubKey, address))\n                     {"
      },
      {
        "sha": "16c8c4f52935113523b72054796d7bc83a8ed240",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 13,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50830796889ecaa458871f1db878c255dd2554cb/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50830796889ecaa458871f1db878c255dd2554cb/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=50830796889ecaa458871f1db878c255dd2554cb",
        "patch": "@@ -47,6 +47,9 @@ struct CCoin {\n \n     ADD_SERIALIZE_METHODS;\n \n+    CCoin() : nHeight(0) {}\n+    CCoin(Coin&& in) : nHeight(in.nHeight), out(std::move(in.out)) {}\n+\n     template <typename Stream, typename Operation>\n     inline void SerializationOp(Stream& s, Operation ser_action)\n     {\n@@ -509,20 +512,11 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n             view.SetBackend(viewMempool); // switch cache backend to db+mempool in case user likes to query mempool\n \n         for (size_t i = 0; i < vOutPoints.size(); i++) {\n-            CCoins coins;\n-            uint256 hash = vOutPoints[i].hash;\n             bool hit = false;\n-            if (view.GetCoins(hash, coins)) {\n-                if (coins.IsAvailable(vOutPoints[i].n) && !mempool.isSpent(vOutPoints[i])) {\n-                    hit = true;\n-                    // Safe to index into vout here because IsAvailable checked if it's off the end of the array, or if\n-                    // n is valid but points to an already spent output (IsNull).\n-                    CCoin coin;\n-                    coin.nHeight = coins.nHeight;\n-                    coin.out = coins.vout.at(vOutPoints[i].n);\n-                    assert(!coin.out.IsNull());\n-                    outs.push_back(coin);\n-                }\n+            Coin coin;\n+            if (view.GetCoins(vOutPoints[i], coin) && !mempool.isSpent(vOutPoints[i])) {\n+                hit = true;\n+                outs.emplace_back(std::move(coin));\n             }\n \n             hits.push_back(hit);"
      },
      {
        "sha": "77f1dcb21f7eadf69b1b23e4eeecc17dd17891df",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 26,
        "deletions": 21,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50830796889ecaa458871f1db878c255dd2554cb/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50830796889ecaa458871f1db878c255dd2554cb/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=50830796889ecaa458871f1db878c255dd2554cb",
        "patch": "@@ -816,24 +816,27 @@ static bool GetUTXOStats(CCoinsView *view, CCoinsStats &stats)\n         stats.nHeight = mapBlockIndex.find(stats.hashBlock)->second->nHeight;\n     }\n     ss << stats.hashBlock;\n+    uint256 prevkey;\n+    std::map<uint32_t, Coin> outputs;\n     while (pcursor->Valid()) {\n         boost::this_thread::interruption_point();\n-        uint256 key;\n-        CCoins coins;\n-        if (pcursor->GetKey(key) && pcursor->GetValue(coins)) {\n-            std::map<uint32_t, Coin> outputs;\n-            for (unsigned int i=0; i<coins.vout.size(); i++) {\n-                CTxOut &out = coins.vout[i];\n-                if (!out.IsNull()) {\n-                    outputs[i] = Coin(std::move(out), coins.nHeight, coins.fCoinBase);\n-                }\n+        COutPoint key;\n+        Coin coin;\n+        if (pcursor->GetKey(key) && pcursor->GetValue(coin)) {\n+            if (!outputs.empty() && key.hash != prevkey) {\n+                ApplyStats(stats, ss, prevkey, outputs);\n+                outputs.clear();\n             }\n-            ApplyStats(stats, ss, key, outputs);\n+            prevkey = key.hash;\n+            outputs[key.n] = std::move(coin);\n         } else {\n             return error(\"%s: unable to read value\", __func__);\n         }\n         pcursor->Next();\n     }\n+    if (!outputs.empty()) {\n+        ApplyStats(stats, ss, prevkey, outputs);\n+    }\n     stats.hashSerialized = ss.GetHash();\n     stats.nDiskSize = view->EstimateSize();\n     return true;\n@@ -973,35 +976,37 @@ UniValue gettxout(const JSONRPCRequest& request)\n     std::string strHash = request.params[0].get_str();\n     uint256 hash(uint256S(strHash));\n     int n = request.params[1].get_int();\n+    COutPoint out(hash, n);\n     bool fMempool = true;\n     if (request.params.size() > 2)\n         fMempool = request.params[2].get_bool();\n \n-    CCoins coins;\n+    Coin coin;\n     if (fMempool) {\n         LOCK(mempool.cs);\n         CCoinsViewMemPool view(pcoinsTip, mempool);\n-        if (!view.GetCoins(hash, coins) || mempool.isSpent(COutPoint(hash, n))) // TODO: this should be done by the CCoinsViewMemPool\n+        if (!view.GetCoins(out, coin) || mempool.isSpent(out)) { // TODO: filtering spent coins should be done by the CCoinsViewMemPool\n             return NullUniValue;\n+        }\n     } else {\n-        if (!pcoinsTip->GetCoins(hash, coins))\n+        if (!pcoinsTip->GetCoins(out, coin)) {\n             return NullUniValue;\n+        }\n     }\n-    if (n<0 || (unsigned int)n>=coins.vout.size() || coins.vout[n].IsNull())\n-        return NullUniValue;\n \n     BlockMap::iterator it = mapBlockIndex.find(pcoinsTip->GetBestBlock());\n     CBlockIndex *pindex = it->second;\n     ret.push_back(Pair(\"bestblock\", pindex->GetBlockHash().GetHex()));\n-    if ((unsigned int)coins.nHeight == MEMPOOL_HEIGHT)\n+    if (coin.nHeight == MEMPOOL_HEIGHT) {\n         ret.push_back(Pair(\"confirmations\", 0));\n-    else\n-        ret.push_back(Pair(\"confirmations\", pindex->nHeight - coins.nHeight + 1));\n-    ret.push_back(Pair(\"value\", ValueFromAmount(coins.vout[n].nValue)));\n+    } else {\n+        ret.push_back(Pair(\"confirmations\", (int64_t)(pindex->nHeight - coin.nHeight + 1)));\n+    }\n+    ret.push_back(Pair(\"value\", ValueFromAmount(coin.out.nValue)));\n     UniValue o(UniValue::VOBJ);\n-    ScriptPubKeyToUniv(coins.vout[n].scriptPubKey, o, true);\n+    ScriptPubKeyToUniv(coin.out.scriptPubKey, o, true);\n     ret.push_back(Pair(\"scriptPubKey\", o));\n-    ret.push_back(Pair(\"coinbase\", coins.fCoinBase));\n+    ret.push_back(Pair(\"coinbase\", (bool)coin.fCoinBase));\n \n     return ret;\n }"
      },
      {
        "sha": "8ecbf9ede53a09fdaa906c89f64a8d2dea739487",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50830796889ecaa458871f1db878c255dd2554cb/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50830796889ecaa458871f1db878c255dd2554cb/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=50830796889ecaa458871f1db878c255dd2554cb",
        "patch": "@@ -219,9 +219,10 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found\");\n         pblockindex = mapBlockIndex[hashBlock];\n     } else {\n-        CCoins coins;\n-        if (pcoinsTip->GetCoins(oneTxid, coins) && coins.nHeight > 0 && coins.nHeight <= chainActive.Height())\n-            pblockindex = chainActive[coins.nHeight];\n+        const Coin& coin = AccessByTxid(*pcoinsTip, oneTxid);\n+        if (!coin.IsPruned() && coin.nHeight > 0 && coin.nHeight <= chainActive.Height()) {\n+            pblockindex = chainActive[coin.nHeight];\n+        }\n     }\n \n     if (pblockindex == NULL)"
      },
      {
        "sha": "8d519c644b9ccd609826f5e824cc6d18d6f72337",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 107,
        "deletions": 132,
        "changes": 239,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50830796889ecaa458871f1db878c255dd2554cb/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50830796889ecaa458871f1db878c255dd2554cb/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=50830796889ecaa458871f1db878c255dd2554cb",
        "patch": "@@ -34,27 +34,27 @@ bool operator==(const Coin &a, const Coin &b) {\n class CCoinsViewTest : public CCoinsView\n {\n     uint256 hashBestBlock_;\n-    std::map<uint256, CCoins> map_;\n+    std::map<COutPoint, Coin> map_;\n \n public:\n-    bool GetCoins(const uint256& txid, CCoins& coins) const\n+    bool GetCoins(const COutPoint& outpoint, Coin& coin) const\n     {\n-        std::map<uint256, CCoins>::const_iterator it = map_.find(txid);\n+        std::map<COutPoint, Coin>::const_iterator it = map_.find(outpoint);\n         if (it == map_.end()) {\n             return false;\n         }\n-        coins = it->second;\n-        if (coins.IsPruned() && insecure_rand() % 2 == 0) {\n+        coin = it->second;\n+        if (coin.IsPruned() && insecure_rand() % 2 == 0) {\n             // Randomly return false in case of an empty entry.\n             return false;\n         }\n         return true;\n     }\n \n-    bool HaveCoins(const uint256& txid) const\n+    bool HaveCoins(const COutPoint& outpoint) const\n     {\n-        CCoins coins;\n-        return GetCoins(txid, coins);\n+        Coin coin;\n+        return GetCoins(outpoint, coin);\n     }\n \n     uint256 GetBestBlock() const { return hashBestBlock_; }\n@@ -106,7 +106,7 @@ static const unsigned int NUM_SIMULATION_ITERATIONS = 40000;\n // This is a large randomized insert/remove simulation test on a variable-size\n // stack of caches on top of CCoinsViewTest.\n //\n-// It will randomly create/update/delete CCoins entries to a tip of caches, with\n+// It will randomly create/update/delete Coin entries to a tip of caches, with\n // txids picked from a limited list of random 256-bit hashes. Occasionally, a\n // new tip is added to the stack of caches, or the tip is flushed and removed.\n //\n@@ -124,7 +124,7 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     bool missed_an_entry = false;\n \n     // A simple map to track what we expect the cache stack to represent.\n-    std::map<uint256, CCoins> result;\n+    std::map<COutPoint, Coin> result;\n \n     // The cache stack.\n     CCoinsViewTest base; // A CCoinsViewTest at the bottom.\n@@ -142,39 +142,38 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n         // Do a random modification.\n         {\n             uint256 txid = txids[insecure_rand() % txids.size()]; // txid we're going to modify in this iteration.\n-            CCoins& coins = result[txid];\n+            Coin& coin = result[COutPoint(txid, 0)];\n             const Coin& entry = stack.back()->AccessCoin(COutPoint(txid, 0));\n-            BOOST_CHECK((entry.IsPruned() && coins.IsPruned()) || entry == Coin(coins.vout[0], coins.nHeight, coins.fCoinBase));\n+            BOOST_CHECK(coin == entry);\n \n-            if (insecure_rand() % 5 == 0 || coins.IsPruned()) {\n-                if (coins.IsPruned()) {\n+            if (insecure_rand() % 5 == 0 || coin.IsPruned()) {\n+                if (coin.IsPruned()) {\n                     added_an_entry = true;\n                 } else {\n                     updated_an_entry = true;\n                 }\n-                coins.vout.resize(1);\n-                coins.vout[0].nValue = insecure_rand();\n+                coin.out.nValue = insecure_rand();\n+                coin.nHeight = 1;\n             } else {\n-                coins.Clear();\n+                coin.Clear();\n                 removed_an_entry = true;\n             }\n-            if (coins.IsPruned()) {\n+            if (coin.IsPruned()) {\n                 stack.back()->SpendCoin(COutPoint(txid, 0));\n             } else {\n-                stack.back()->AddCoin(COutPoint(txid, 0), Coin(coins.vout[0], coins.nHeight, coins.fCoinBase), true);\n+                stack.back()->AddCoin(COutPoint(txid, 0), Coin(coin), true);\n             }\n         }\n \n         // Once every 1000 iterations and at the end, verify the full cache.\n         if (insecure_rand() % 1000 == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n-            for (std::map<uint256, CCoins>::iterator it = result.begin(); it != result.end(); it++) {\n-                const CCoins* coins = stack.back()->AccessCoins(it->first);\n-                if (coins) {\n-                    BOOST_CHECK(*coins == it->second);\n-                    found_an_entry = true;\n-                } else {\n-                    BOOST_CHECK(it->second.IsPruned());\n+            for (auto it = result.begin(); it != result.end(); it++) {\n+                const Coin& coin = stack.back()->AccessCoin(it->first);\n+                BOOST_CHECK(coin == it->second);\n+                if (coin.IsPruned()) {\n                     missed_an_entry = true;\n+                } else {\n+                    found_an_entry = true;\n                 }\n             }\n             BOOST_FOREACH(const CCoinsViewCacheTest *test, stack) {\n@@ -229,19 +228,19 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     BOOST_CHECK(missed_an_entry);\n }\n \n-typedef std::tuple<CTransaction,CTxUndo,CCoins> TxData;\n // Store of all necessary tx and undo data for next test\n-std::map<uint256, TxData> alltxs;\n-\n-TxData &FindRandomFrom(const std::set<uint256> &txidset) {\n-    assert(txidset.size());\n-    std::set<uint256>::iterator txIt = txidset.lower_bound(GetRandHash());\n-    if (txIt == txidset.end()) {\n-        txIt = txidset.begin();\n+typedef std::map<COutPoint, std::tuple<CTransaction,CTxUndo,Coin>> UtxoData;\n+UtxoData utxoData;\n+\n+UtxoData::iterator FindRandomFrom(const std::set<COutPoint> &utxoSet) {\n+    assert(utxoSet.size());\n+    auto utxoSetIt = utxoSet.lower_bound(COutPoint(GetRandHash(), 0));\n+    if (utxoSetIt == utxoSet.end()) {\n+        utxoSetIt = utxoSet.begin();\n     }\n-    std::map<uint256, TxData>::iterator txdit = alltxs.find(*txIt);\n-    assert(txdit != alltxs.end());\n-    return txdit->second;\n+    auto utxoDataIt = utxoData.find(*utxoSetIt);\n+    assert(utxoDataIt != utxoData.end());\n+    return utxoDataIt;\n }\n \n \n@@ -254,18 +253,18 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n {\n     bool spent_a_duplicate_coinbase = false;\n     // A simple map to track what we expect the cache stack to represent.\n-    std::map<uint256, CCoins> result;\n+    std::map<COutPoint, Coin> result;\n \n     // The cache stack.\n     CCoinsViewTest base; // A CCoinsViewTest at the bottom.\n     std::vector<CCoinsViewCacheTest*> stack; // A stack of CCoinsViewCaches on top.\n     stack.push_back(new CCoinsViewCacheTest(&base)); // Start with one cache.\n \n     // Track the txids we've used in various sets\n-    std::set<uint256> coinbaseids;\n-    std::set<uint256> disconnectedids;\n-    std::set<uint256> duplicateids;\n-    std::set<uint256> utxoset;\n+    std::set<COutPoint> coinbaseids;\n+    std::set<COutPoint> disconnectedids;\n+    std::set<COutPoint> duplicateids;\n+    std::set<COutPoint> utxoset;\n \n     for (unsigned int i = 0; i < NUM_SIMULATION_ITERATIONS; i++) {\n         uint32_t randiter = insecure_rand();\n@@ -277,132 +276,125 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n             tx.vout.resize(1);\n             tx.vout[0].nValue = i; //Keep txs unique unless intended to duplicate\n             unsigned int height = insecure_rand();\n-            CCoins oldcoins;\n+            Coin oldcoins;\n \n             // 2/20 times create a new coinbase\n             if (randiter % 20 < 2 || coinbaseids.size() < 10) {\n                 // 1/10 of those times create a duplicate coinbase\n                 if (insecure_rand() % 10 == 0 && coinbaseids.size()) {\n-                    TxData &txd = FindRandomFrom(coinbaseids);\n+                    auto utxod = FindRandomFrom(coinbaseids);\n                     // Reuse the exact same coinbase\n-                    tx = std::get<0>(txd);\n+                    tx = std::get<0>(utxod->second);\n                     // shouldn't be available for reconnection if its been duplicated\n-                    disconnectedids.erase(tx.GetHash());\n+                    disconnectedids.erase(utxod->first);\n \n-                    duplicateids.insert(tx.GetHash());\n+                    duplicateids.insert(utxod->first);\n                 }\n                 else {\n-                    coinbaseids.insert(tx.GetHash());\n+                    coinbaseids.insert(COutPoint(tx.GetHash(), 0));\n                 }\n                 assert(CTransaction(tx).IsCoinBase());\n             }\n \n             // 17/20 times reconnect previous or add a regular tx\n             else {\n \n-                uint256 prevouthash;\n+                COutPoint prevout;\n                 // 1/20 times reconnect a previously disconnected tx\n                 if (randiter % 20 == 2 && disconnectedids.size()) {\n-                    TxData &txd = FindRandomFrom(disconnectedids);\n-                    tx = std::get<0>(txd);\n-                    prevouthash = tx.vin[0].prevout.hash;\n-                    if (!CTransaction(tx).IsCoinBase() && !utxoset.count(prevouthash)) {\n-                        disconnectedids.erase(tx.GetHash());\n+                    auto utxod = FindRandomFrom(disconnectedids);\n+                    tx = std::get<0>(utxod->second);\n+                    prevout = tx.vin[0].prevout;\n+                    if (!CTransaction(tx).IsCoinBase() && !utxoset.count(prevout)) {\n+                        disconnectedids.erase(utxod->first);\n                         continue;\n                     }\n \n                     // If this tx is already IN the UTXO, then it must be a coinbase, and it must be a duplicate\n-                    if (utxoset.count(tx.GetHash())) {\n+                    if (utxoset.count(utxod->first)) {\n                         assert(CTransaction(tx).IsCoinBase());\n-                        assert(duplicateids.count(tx.GetHash()));\n+                        assert(duplicateids.count(utxod->first));\n                     }\n-                    disconnectedids.erase(tx.GetHash());\n+                    disconnectedids.erase(utxod->first);\n                 }\n \n                 // 16/20 times create a regular tx\n                 else {\n-                    TxData &txd = FindRandomFrom(utxoset);\n-                    prevouthash = std::get<0>(txd).GetHash();\n+                    auto utxod = FindRandomFrom(utxoset);\n+                    prevout = utxod->first;\n \n                     // Construct the tx to spend the coins of prevouthash\n-                    tx.vin[0].prevout.hash = prevouthash;\n-                    tx.vin[0].prevout.n = 0;\n+                    tx.vin[0].prevout = prevout;\n                     assert(!CTransaction(tx).IsCoinBase());\n                 }\n                 // In this simple test coins only have two states, spent or unspent, save the unspent state to restore\n-                oldcoins = result[prevouthash];\n+                oldcoins = result[prevout];\n                 // Update the expected result of prevouthash to know these coins are spent\n-                result[prevouthash].Clear();\n+                result[prevout].Clear();\n \n-                utxoset.erase(prevouthash);\n+                utxoset.erase(prevout);\n \n                 // The test is designed to ensure spending a duplicate coinbase will work properly\n                 // if that ever happens and not resurrect the previously overwritten coinbase\n-                if (duplicateids.count(prevouthash)) {\n+                if (duplicateids.count(prevout)) {\n                     spent_a_duplicate_coinbase = true;\n                 }\n \n             }\n             // Update the expected result to know about the new output coins\n-            result[tx.GetHash()].FromTx(tx, height);\n+            assert(tx.vout.size() == 1);\n+            const COutPoint outpoint(tx.GetHash(), 0);\n+            result[outpoint] = Coin(tx.vout[0], height, CTransaction(tx).IsCoinBase());\n \n             // Call UpdateCoins on the top cache\n             CTxUndo undo;\n             UpdateCoins(tx, *(stack.back()), undo, height);\n \n             // Update the utxo set for future spends\n-            utxoset.insert(tx.GetHash());\n+            utxoset.insert(outpoint);\n \n             // Track this tx and undo info to use later\n-            alltxs.insert(std::make_pair(tx.GetHash(),std::make_tuple(tx,undo,oldcoins)));\n+            utxoData.emplace(outpoint, std::make_tuple(tx,undo,oldcoins));\n         } else if (utxoset.size()) {\n             //1/20 times undo a previous transaction\n-            TxData &txd = FindRandomFrom(utxoset);\n-\n-            CTransaction &tx = std::get<0>(txd);\n-            CTxUndo &undo = std::get<1>(txd);\n-            CCoins &origcoins = std::get<2>(txd);\n+            auto utxod = FindRandomFrom(utxoset);\n \n-            uint256 undohash = tx.GetHash();\n+            CTransaction &tx = std::get<0>(utxod->second);\n+            CTxUndo &undo = std::get<1>(utxod->second);\n+            Coin &origcoins = std::get<2>(utxod->second);\n \n             // Update the expected result\n             // Remove new outputs\n-            result[undohash].Clear();\n+            result[utxod->first].Clear();\n             // If not coinbase restore prevout\n             if (!tx.IsCoinBase()) {\n-                result[tx.vin[0].prevout.hash] = origcoins;\n+                result[tx.vin[0].prevout] = origcoins;\n             }\n \n             // Disconnect the tx from the current UTXO\n             // See code in DisconnectBlock\n             // remove outputs\n-            {\n-                stack.back()->SpendCoin(COutPoint(undohash, 0));\n-            }\n+            stack.back()->SpendCoin(utxod->first);\n             // restore inputs\n             if (!tx.IsCoinBase()) {\n                 const COutPoint &out = tx.vin[0].prevout;\n                 Coin coin = undo.vprevout[0];\n                 ApplyTxInUndo(std::move(coin), *(stack.back()), out);\n             }\n             // Store as a candidate for reconnection\n-            disconnectedids.insert(undohash);\n+            disconnectedids.insert(utxod->first);\n \n             // Update the utxoset\n-            utxoset.erase(undohash);\n+            utxoset.erase(utxod->first);\n             if (!tx.IsCoinBase())\n-                utxoset.insert(tx.vin[0].prevout.hash);\n+                utxoset.insert(tx.vin[0].prevout);\n         }\n \n         // Once every 1000 iterations and at the end, verify the full cache.\n         if (insecure_rand() % 1000 == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n-            for (std::map<uint256, CCoins>::iterator it = result.begin(); it != result.end(); it++) {\n-                const CCoins* coins = stack.back()->AccessCoins(it->first);\n-                if (coins) {\n-                    BOOST_CHECK(*coins == it->second);\n-                } else {\n-                    BOOST_CHECK(it->second.IsPruned());\n-                }\n+            for (auto it = result.begin(); it != result.end(); it++) {\n+                const Coin& coin = stack.back()->AccessCoin(it->first);\n+                BOOST_CHECK(coin == it->second);\n             }\n         }\n \n@@ -443,50 +435,36 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n BOOST_AUTO_TEST_CASE(ccoins_serialization)\n {\n     // Good example\n-    CDataStream ss1(ParseHex(\"0104835800816115944e077fe7c803cfa57f29b36bf87c1d358bb85e\"), SER_DISK, CLIENT_VERSION);\n-    CCoins cc1;\n+    CDataStream ss1(ParseHex(\"97f23c835800816115944e077fe7c803cfa57f29b36bf87c1d35\"), SER_DISK, CLIENT_VERSION);\n+    Coin cc1;\n     ss1 >> cc1;\n     BOOST_CHECK_EQUAL(cc1.fCoinBase, false);\n     BOOST_CHECK_EQUAL(cc1.nHeight, 203998);\n-    BOOST_CHECK_EQUAL(cc1.vout.size(), 2);\n-    BOOST_CHECK_EQUAL(cc1.IsAvailable(0), false);\n-    BOOST_CHECK_EQUAL(cc1.IsAvailable(1), true);\n-    BOOST_CHECK_EQUAL(cc1.vout[1].nValue, 60000000000ULL);\n-    BOOST_CHECK_EQUAL(HexStr(cc1.vout[1].scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"816115944e077fe7c803cfa57f29b36bf87c1d35\"))))));\n+    BOOST_CHECK_EQUAL(cc1.out.nValue, 60000000000ULL);\n+    BOOST_CHECK_EQUAL(HexStr(cc1.out.scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"816115944e077fe7c803cfa57f29b36bf87c1d35\"))))));\n \n     // Good example\n-    CDataStream ss2(ParseHex(\"0109044086ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4eebbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa486af3b\"), SER_DISK, CLIENT_VERSION);\n-    CCoins cc2;\n+    CDataStream ss2(ParseHex(\"8ddf77bbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa4\"), SER_DISK, CLIENT_VERSION);\n+    Coin cc2;\n     ss2 >> cc2;\n     BOOST_CHECK_EQUAL(cc2.fCoinBase, true);\n     BOOST_CHECK_EQUAL(cc2.nHeight, 120891);\n-    BOOST_CHECK_EQUAL(cc2.vout.size(), 17);\n-    for (int i = 0; i < 17; i++) {\n-        BOOST_CHECK_EQUAL(cc2.IsAvailable(i), i == 4 || i == 16);\n-    }\n-    BOOST_CHECK_EQUAL(cc2.vout[4].nValue, 234925952);\n-    BOOST_CHECK_EQUAL(HexStr(cc2.vout[4].scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"61b01caab50f1b8e9c50a5057eb43c2d9563a4ee\"))))));\n-    BOOST_CHECK_EQUAL(cc2.vout[16].nValue, 110397);\n-    BOOST_CHECK_EQUAL(HexStr(cc2.vout[16].scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"8c988f1a4a4de2161e0f50aac7f17e7f9555caa4\"))))));\n+    BOOST_CHECK_EQUAL(cc2.out.nValue, 110397);\n+    BOOST_CHECK_EQUAL(HexStr(cc2.out.scriptPubKey), HexStr(GetScriptForDestination(CKeyID(uint160(ParseHex(\"8c988f1a4a4de2161e0f50aac7f17e7f9555caa4\"))))));\n \n     // Smallest possible example\n-    CDataStream ssx(SER_DISK, CLIENT_VERSION);\n-    BOOST_CHECK_EQUAL(HexStr(ssx.begin(), ssx.end()), \"\");\n-\n-    CDataStream ss3(ParseHex(\"0002000600\"), SER_DISK, CLIENT_VERSION);\n-    CCoins cc3;\n+    CDataStream ss3(ParseHex(\"000006\"), SER_DISK, CLIENT_VERSION);\n+    Coin cc3;\n     ss3 >> cc3;\n     BOOST_CHECK_EQUAL(cc3.fCoinBase, false);\n     BOOST_CHECK_EQUAL(cc3.nHeight, 0);\n-    BOOST_CHECK_EQUAL(cc3.vout.size(), 1);\n-    BOOST_CHECK_EQUAL(cc3.IsAvailable(0), true);\n-    BOOST_CHECK_EQUAL(cc3.vout[0].nValue, 0);\n-    BOOST_CHECK_EQUAL(cc3.vout[0].scriptPubKey.size(), 0);\n+    BOOST_CHECK_EQUAL(cc3.out.nValue, 0);\n+    BOOST_CHECK_EQUAL(cc3.out.scriptPubKey.size(), 0);\n \n     // scriptPubKey that ends beyond the end of the stream\n-    CDataStream ss4(ParseHex(\"0002000800\"), SER_DISK, CLIENT_VERSION);\n+    CDataStream ss4(ParseHex(\"000007\"), SER_DISK, CLIENT_VERSION);\n     try {\n-        CCoins cc4;\n+        Coin cc4;\n         ss4 >> cc4;\n         BOOST_CHECK_MESSAGE(false, \"We should have thrown\");\n     } catch (const std::ios_base::failure& e) {\n@@ -497,17 +475,16 @@ BOOST_AUTO_TEST_CASE(ccoins_serialization)\n     uint64_t x = 3000000000ULL;\n     tmp << VARINT(x);\n     BOOST_CHECK_EQUAL(HexStr(tmp.begin(), tmp.end()), \"8a95c0bb00\");\n-    CDataStream ss5(ParseHex(\"0002008a95c0bb0000\"), SER_DISK, CLIENT_VERSION);\n+    CDataStream ss5(ParseHex(\"00008a95c0bb00\"), SER_DISK, CLIENT_VERSION);\n     try {\n-        CCoins cc5;\n+        Coin cc5;\n         ss5 >> cc5;\n         BOOST_CHECK_MESSAGE(false, \"We should have thrown\");\n     } catch (const std::ios_base::failure& e) {\n     }\n }\n \n-const static uint256 TXID;\n-const static COutPoint OUTPOINT = {uint256(), 0};\n+const static COutPoint OUTPOINT;\n const static CAmount PRUNED = -1;\n const static CAmount ABSENT = -2;\n const static CAmount FAIL = -3;\n@@ -522,15 +499,15 @@ const static auto FLAGS = {char(0), FRESH, DIRTY, char(DIRTY | FRESH)};\n const static auto CLEAN_FLAGS = {char(0), FRESH};\n const static auto ABSENT_FLAGS = {NO_ENTRY};\n \n-void SetCoinsValue(CAmount value, CCoins& coins)\n+void SetCoinsValue(CAmount value, Coin& coin)\n {\n     assert(value != ABSENT);\n-    coins.Clear();\n-    assert(coins.IsPruned());\n+    coin.Clear();\n+    assert(coin.IsPruned());\n     if (value != PRUNED) {\n-        coins.vout.emplace_back();\n-        coins.vout.back().nValue = value;\n-        assert(!coins.IsPruned());\n+        coin.out.nValue = value;\n+        coin.nHeight = 1;\n+        assert(!coin.IsPruned());\n     }\n }\n \n@@ -544,24 +521,22 @@ size_t InsertCoinsMapEntry(CCoinsMap& map, CAmount value, char flags)\n     CCoinsCacheEntry entry;\n     entry.flags = flags;\n     SetCoinsValue(value, entry.coins);\n-    auto inserted = map.emplace(TXID, std::move(entry));\n+    auto inserted = map.emplace(OUTPOINT, std::move(entry));\n     assert(inserted.second);\n     return inserted.first->second.coins.DynamicMemoryUsage();\n }\n \n void GetCoinsMapEntry(const CCoinsMap& map, CAmount& value, char& flags)\n {\n-    auto it = map.find(TXID);\n+    auto it = map.find(OUTPOINT);\n     if (it == map.end()) {\n         value = ABSENT;\n         flags = NO_ENTRY;\n     } else {\n         if (it->second.coins.IsPruned()) {\n-            assert(it->second.coins.vout.size() == 0);\n             value = PRUNED;\n         } else {\n-            assert(it->second.coins.vout.size() == 1);\n-            value = it->second.coins.vout[0].nValue;\n+            value = it->second.coins.out.nValue;\n         }\n         flags = it->second.flags;\n         assert(flags != NO_ENTRY);"
      },
      {
        "sha": "de14251601377956cb368634d22f48f54a5a1832",
        "filename": "src/test/test_bitcoin_fuzzy.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50830796889ecaa458871f1db878c255dd2554cb/src/test/test_bitcoin_fuzzy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50830796889ecaa458871f1db878c255dd2554cb/src/test/test_bitcoin_fuzzy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/test_bitcoin_fuzzy.cpp?ref=50830796889ecaa458871f1db878c255dd2554cb",
        "patch": "@@ -168,8 +168,8 @@ int do_fuzz()\n         {\n             try\n             {\n-                CCoins block;\n-                ds >> block;\n+                Coin coin;\n+                ds >> coin;\n             } catch (const std::ios_base::failure& e) {return 0;}\n             break;\n         }"
      },
      {
        "sha": "19c900250690eab0785f61e7a1c035bff56f40b6",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 49,
        "deletions": 17,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50830796889ecaa458871f1db878c255dd2554cb/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50830796889ecaa458871f1db878c255dd2554cb/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=50830796889ecaa458871f1db878c255dd2554cb",
        "patch": "@@ -14,6 +14,7 @@\n \n #include <boost/thread.hpp>\n \n+static const char DB_COIN = 'C';\n static const char DB_COINS = 'c';\n static const char DB_BLOCK_FILES = 'f';\n static const char DB_TXINDEX = 't';\n@@ -24,17 +25,40 @@ static const char DB_FLAG = 'F';\n static const char DB_REINDEX_FLAG = 'R';\n static const char DB_LAST_BLOCK = 'l';\n \n+namespace {\n+\n+struct CoinsEntry {\n+    COutPoint* outpoint;\n+    char key;\n+    CoinsEntry(const COutPoint* ptr) : outpoint(const_cast<COutPoint*>(ptr)), key(DB_COIN)  {}\n+\n+    template<typename Stream>\n+    void Serialize(Stream &s) const {\n+        s << key;\n+        s << outpoint->hash;\n+        s << VARINT(outpoint->n);\n+    }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream& s) {\n+        s >> key;\n+        s >> outpoint->hash;\n+        s >> VARINT(outpoint->n);\n+    }\n+};\n+\n+}\n \n CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe, true) \n {\n }\n \n-bool CCoinsViewDB::GetCoins(const uint256 &txid, CCoins &coins) const {\n-    return db.Read(std::make_pair(DB_COINS, txid), coins);\n+bool CCoinsViewDB::GetCoins(const COutPoint &outpoint, Coin &coin) const {\n+    return db.Read(CoinsEntry(&outpoint), coin);\n }\n \n-bool CCoinsViewDB::HaveCoins(const uint256 &txid) const {\n-    return db.Exists(std::make_pair(DB_COINS, txid));\n+bool CCoinsViewDB::HaveCoins(const COutPoint &outpoint) const {\n+    return db.Exists(CoinsEntry(&outpoint));\n }\n \n uint256 CCoinsViewDB::GetBestBlock() const {\n@@ -50,10 +74,11 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     size_t changed = 0;\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n+            CoinsEntry entry(&it->first);\n             if (it->second.coins.IsPruned())\n-                batch.Erase(std::make_pair(DB_COINS, it->first));\n+                batch.Erase(entry);\n             else\n-                batch.Write(std::make_pair(DB_COINS, it->first), it->second.coins);\n+                batch.Write(entry, it->second.coins);\n             changed++;\n         }\n         count++;\n@@ -63,13 +88,14 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     if (!hashBlock.IsNull())\n         batch.Write(DB_BEST_BLOCK, hashBlock);\n \n-    LogPrint(BCLog::COINDB, \"Committing %u changed transactions (out of %u) to coin database...\\n\", (unsigned int)changed, (unsigned int)count);\n-    return db.WriteBatch(batch);\n+    bool ret = db.WriteBatch(batch);\n+    LogPrint(BCLog::COINDB, \"Committed %u changed transaction outputs (out of %u) to coin database...\\n\", (unsigned int)changed, (unsigned int)count);\n+    return ret;\n }\n \n size_t CCoinsViewDB::EstimateSize() const\n {\n-    return db.EstimateSize(DB_COINS, (char)(DB_COINS+1));\n+    return db.EstimateSize(DB_COIN, (char)(DB_COIN+1));\n }\n \n CBlockTreeDB::CBlockTreeDB(size_t nCacheSize, bool fMemory, bool fWipe) : CDBWrapper(GetDataDir() / \"blocks\" / \"index\", nCacheSize, fMemory, fWipe) {\n@@ -101,29 +127,31 @@ CCoinsViewCursor *CCoinsViewDB::Cursor() const\n     /* It seems that there are no \"const iterators\" for LevelDB.  Since we\n        only need read operations on it, use a const-cast to get around\n        that restriction.  */\n-    i->pcursor->Seek(DB_COINS);\n+    i->pcursor->Seek(DB_COIN);\n     // Cache key of first record\n     if (i->pcursor->Valid()) {\n-        i->pcursor->GetKey(i->keyTmp);\n+        CoinsEntry entry(&i->keyTmp.second);\n+        i->pcursor->GetKey(entry);\n+        i->keyTmp.first = entry.key;\n     } else {\n         i->keyTmp.first = 0; // Make sure Valid() and GetKey() return false\n     }\n     return i;\n }\n \n-bool CCoinsViewDBCursor::GetKey(uint256 &key) const\n+bool CCoinsViewDBCursor::GetKey(COutPoint &key) const\n {\n     // Return cached key\n-    if (keyTmp.first == DB_COINS) {\n+    if (keyTmp.first == DB_COIN) {\n         key = keyTmp.second;\n         return true;\n     }\n     return false;\n }\n \n-bool CCoinsViewDBCursor::GetValue(CCoins &coins) const\n+bool CCoinsViewDBCursor::GetValue(Coin &coin) const\n {\n-    return pcursor->GetValue(coins);\n+    return pcursor->GetValue(coin);\n }\n \n unsigned int CCoinsViewDBCursor::GetValueSize() const\n@@ -133,14 +161,18 @@ unsigned int CCoinsViewDBCursor::GetValueSize() const\n \n bool CCoinsViewDBCursor::Valid() const\n {\n-    return keyTmp.first == DB_COINS;\n+    return keyTmp.first == DB_COIN;\n }\n \n void CCoinsViewDBCursor::Next()\n {\n     pcursor->Next();\n-    if (!pcursor->Valid() || !pcursor->GetKey(keyTmp))\n+    CoinsEntry entry(&keyTmp.second);\n+    if (!pcursor->Valid() || !pcursor->GetKey(entry)) {\n         keyTmp.first = 0; // Invalidate cached key after last record so that Valid() and GetKey() return false\n+    } else {\n+        keyTmp.first = entry.key;\n+    }\n }\n \n bool CBlockTreeDB::WriteBatchSync(const std::vector<std::pair<int, const CBlockFileInfo*> >& fileInfo, int nLastFile, const std::vector<const CBlockIndex*>& blockinfo) {"
      },
      {
        "sha": "73011fe0f92bb4dfcc220772bbbd464f9ede68b0",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50830796889ecaa458871f1db878c255dd2554cb/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50830796889ecaa458871f1db878c255dd2554cb/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=50830796889ecaa458871f1db878c255dd2554cb",
        "patch": "@@ -73,11 +73,11 @@ class CCoinsViewDB : public CCoinsView\n public:\n     CCoinsViewDB(size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n \n-    bool GetCoins(const uint256 &txid, CCoins &coins) const;\n-    bool HaveCoins(const uint256 &txid) const;\n-    uint256 GetBestBlock() const;\n-    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n-    CCoinsViewCursor *Cursor() const;\n+    bool GetCoins(const COutPoint &outpoint, Coin &coin) const override;\n+    bool HaveCoins(const COutPoint &outpoint) const override;\n+    uint256 GetBestBlock() const override;\n+    bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n+    CCoinsViewCursor *Cursor() const override;\n \n     size_t EstimateSize() const override;\n };\n@@ -88,8 +88,8 @@ class CCoinsViewDBCursor: public CCoinsViewCursor\n public:\n     ~CCoinsViewDBCursor() {}\n \n-    bool GetKey(uint256 &key) const;\n-    bool GetValue(CCoins &coins) const;\n+    bool GetKey(COutPoint &key) const;\n+    bool GetValue(Coin &coin) const;\n     unsigned int GetValueSize() const;\n \n     bool Valid() const;\n@@ -99,7 +99,7 @@ class CCoinsViewDBCursor: public CCoinsViewCursor\n     CCoinsViewDBCursor(CDBIterator* pcursorIn, const uint256 &hashBlockIn):\n         CCoinsViewCursor(hashBlockIn), pcursor(pcursorIn) {}\n     std::unique_ptr<CDBIterator> pcursor;\n-    std::pair<char, uint256> keyTmp;\n+    std::pair<char, COutPoint> keyTmp;\n \n     friend class CCoinsViewDB;\n };"
      },
      {
        "sha": "648b40a7a691c87c0fc1c027df201e2b18569764",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 18,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50830796889ecaa458871f1db878c255dd2554cb/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50830796889ecaa458871f1db878c255dd2554cb/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=50830796889ecaa458871f1db878c255dd2554cb",
        "patch": "@@ -524,9 +524,9 @@ void CTxMemPool::removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMem\n                 indexed_transaction_set::const_iterator it2 = mapTx.find(txin.prevout.hash);\n                 if (it2 != mapTx.end())\n                     continue;\n-                const CCoins *coins = pcoins->AccessCoins(txin.prevout.hash);\n-                if (nCheckFrequency != 0) assert(coins);\n-                if (!coins || (coins->IsCoinBase() && ((signed long)nMemPoolHeight) - coins->nHeight < COINBASE_MATURITY)) {\n+                const Coin &coin = pcoins->AccessCoin(txin.prevout);\n+                if (nCheckFrequency != 0) assert(!coin.IsPruned());\n+                if (coin.IsPruned() || (coin.IsCoinBase() && ((signed long)nMemPoolHeight) - coin.nHeight < COINBASE_MATURITY)) {\n                     txToRemove.insert(it);\n                     break;\n                 }\n@@ -654,8 +654,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n                     parentSigOpCost += it2->GetSigOpCost();\n                 }\n             } else {\n-                const CCoins* coins = pcoins->AccessCoins(txin.prevout.hash);\n-                assert(coins && coins->IsAvailable(txin.prevout.n));\n+                assert(pcoins->HaveCoins(txin.prevout));\n             }\n             // Check whether its inputs are marked in mapNextTx.\n             auto it3 = mapNextTx.find(txin.prevout);\n@@ -891,20 +890,24 @@ bool CTxMemPool::HasNoInputsOf(const CTransaction &tx) const\n \n CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool& mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) { }\n \n-bool CCoinsViewMemPool::GetCoins(const uint256 &txid, CCoins &coins) const {\n+bool CCoinsViewMemPool::GetCoins(const COutPoint &outpoint, Coin &coin) const {\n     // If an entry in the mempool exists, always return that one, as it's guaranteed to never\n     // conflict with the underlying cache, and it cannot have pruned entries (as it contains full)\n     // transactions. First checking the underlying cache risks returning a pruned entry instead.\n-    CTransactionRef ptx = mempool.get(txid);\n+    CTransactionRef ptx = mempool.get(outpoint.hash);\n     if (ptx) {\n-        coins = CCoins(*ptx, MEMPOOL_HEIGHT);\n-        return true;\n+        if (outpoint.n < ptx->vout.size()) {\n+            coin = Coin(ptx->vout[outpoint.n], MEMPOOL_HEIGHT, false);\n+            return true;\n+        } else {\n+            return false;\n+        }\n     }\n-    return (base->GetCoins(txid, coins) && !coins.IsPruned());\n+    return (base->GetCoins(outpoint, coin) && !coin.IsPruned());\n }\n \n-bool CCoinsViewMemPool::HaveCoins(const uint256 &txid) const {\n-    return mempool.exists(txid) || base->HaveCoins(txid);\n+bool CCoinsViewMemPool::HaveCoins(const COutPoint &outpoint) const {\n+    return mempool.exists(outpoint) || base->HaveCoins(outpoint);\n }\n \n size_t CTxMemPool::DynamicMemoryUsage() const {\n@@ -1015,7 +1018,7 @@ void CTxMemPool::trackPackageRemoved(const CFeeRate& rate) {\n     }\n }\n \n-void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<uint256>* pvNoSpendsRemaining) {\n+void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpendsRemaining) {\n     LOCK(cs);\n \n     unsigned nTxnRemoved = 0;\n@@ -1046,11 +1049,10 @@ void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<uint256>* pvNoSpendsRe\n         if (pvNoSpendsRemaining) {\n             BOOST_FOREACH(const CTransaction& tx, txn) {\n                 BOOST_FOREACH(const CTxIn& txin, tx.vin) {\n-                    if (exists(txin.prevout.hash))\n-                        continue;\n-                    auto iter = mapNextTx.lower_bound(COutPoint(txin.prevout.hash, 0));\n-                    if (iter == mapNextTx.end() || iter->first->hash != txin.prevout.hash)\n-                        pvNoSpendsRemaining->push_back(txin.prevout.hash);\n+                    if (exists(txin.prevout.hash)) continue;\n+                    if (!mapNextTx.count(txin.prevout)) {\n+                        pvNoSpendsRemaining->push_back(txin.prevout);\n+                    }\n                 }\n             }\n         }\n@@ -1067,3 +1069,5 @@ bool CTxMemPool::TransactionWithinChainLimit(const uint256& txid, size_t chainLi\n     return it == mapTx.end() || (it->GetCountWithAncestors() < chainLimit &&\n        it->GetCountWithDescendants() < chainLimit);\n }\n+\n+SaltedTxidHasher::SaltedTxidHasher() : k0(GetRand(std::numeric_limits<uint64_t>::max())), k1(GetRand(std::numeric_limits<uint64_t>::max())) {}"
      },
      {
        "sha": "c86859118a1c6368098ec0b2ec421f08ffecfc6f",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 27,
        "deletions": 6,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50830796889ecaa458871f1db878c255dd2554cb/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50830796889ecaa458871f1db878c255dd2554cb/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=50830796889ecaa458871f1db878c255dd2554cb",
        "patch": "@@ -30,8 +30,8 @@\n class CAutoFile;\n class CBlockIndex;\n \n-/** Fake height value used in CCoins to signify they are only in the memory pool (since 0.8) */\n-static const unsigned int MEMPOOL_HEIGHT = 0x7FFFFFFF;\n+/** Fake height value used in Coin to signify they are only in the memory pool (since 0.8) */\n+static const uint32_t MEMPOOL_HEIGHT = 0x7FFFFFFF;\n \n struct LockPoints\n {\n@@ -321,6 +321,20 @@ enum class MemPoolRemovalReason {\n     REPLACED     //! Removed for replacement\n };\n \n+class SaltedTxidHasher\n+{\n+private:\n+    /** Salt */\n+    const uint64_t k0, k1;\n+\n+public:\n+    SaltedTxidHasher();\n+\n+    size_t operator()(const uint256& txid) const {\n+        return SipHashUint256(k0, k1, txid);\n+    }\n+};\n+\n /**\n  * CTxMemPool stores valid-according-to-the-current-best-chain transactions\n  * that may be included in the next block.\n@@ -570,10 +584,10 @@ class CTxMemPool\n     CFeeRate GetMinFee(size_t sizelimit) const;\n \n     /** Remove transactions from the mempool until its dynamic size is <= sizelimit.\n-      *  pvNoSpendsRemaining, if set, will be populated with the list of transactions\n+      *  pvNoSpendsRemaining, if set, will be populated with the list of outpoints\n       *  which are not in mempool which no longer have any spends in this mempool.\n       */\n-    void TrimToSize(size_t sizelimit, std::vector<uint256>* pvNoSpendsRemaining=NULL);\n+    void TrimToSize(size_t sizelimit, std::vector<COutPoint>* pvNoSpendsRemaining=NULL);\n \n     /** Expire all transaction (and their dependencies) in the mempool older than time. Return the number of removed transactions. */\n     int Expire(int64_t time);\n@@ -599,6 +613,13 @@ class CTxMemPool\n         return (mapTx.count(hash) != 0);\n     }\n \n+    bool exists(const COutPoint& outpoint) const\n+    {\n+        LOCK(cs);\n+        auto it = mapTx.find(outpoint.hash);\n+        return (it != mapTx.end() && outpoint.n < it->GetTx().vout.size());\n+    }\n+\n     CTransactionRef get(const uint256& hash) const;\n     TxMempoolInfo info(const uint256& hash) const;\n     std::vector<TxMempoolInfo> infoAll() const;\n@@ -658,8 +679,8 @@ class CCoinsViewMemPool : public CCoinsViewBacked\n \n public:\n     CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool& mempoolIn);\n-    bool GetCoins(const uint256 &txid, CCoins &coins) const;\n-    bool HaveCoins(const uint256 &txid) const;\n+    bool GetCoins(const COutPoint &outpoint, Coin &coin) const;\n+    bool HaveCoins(const COutPoint &outpoint) const;\n };\n \n #endif // BITCOIN_TXMEMPOOL_H"
      },
      {
        "sha": "cf4dab420e41b288681fabed9842ade98e5d134c",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 27,
        "deletions": 27,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/50830796889ecaa458871f1db878c255dd2554cb/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/50830796889ecaa458871f1db878c255dd2554cb/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=50830796889ecaa458871f1db878c255dd2554cb",
        "patch": "@@ -268,15 +268,15 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp, bool\n         prevheights.resize(tx.vin.size());\n         for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n             const CTxIn& txin = tx.vin[txinIndex];\n-            CCoins coins;\n-            if (!viewMemPool.GetCoins(txin.prevout.hash, coins)) {\n+            Coin coin;\n+            if (!viewMemPool.GetCoins(txin.prevout, coin)) {\n                 return error(\"%s: Missing input\", __func__);\n             }\n-            if (coins.nHeight == MEMPOOL_HEIGHT) {\n+            if (coin.nHeight == MEMPOOL_HEIGHT) {\n                 // Assume all mempool transaction confirm in the next block\n                 prevheights[txinIndex] = tip->nHeight + 1;\n             } else {\n-                prevheights[txinIndex] = coins.nHeight;\n+                prevheights[txinIndex] = coin.nHeight;\n             }\n         }\n         lockPair = CalculateSequenceLocks(tx, flags, &prevheights, index);\n@@ -315,9 +315,9 @@ void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age) {\n         LogPrint(BCLog::MEMPOOL, \"Expired %i transactions from the memory pool\\n\", expired);\n     }\n \n-    std::vector<uint256> vNoSpendsRemaining;\n+    std::vector<COutPoint> vNoSpendsRemaining;\n     pool.TrimToSize(limit, &vNoSpendsRemaining);\n-    BOOST_FOREACH(const uint256& removed, vNoSpendsRemaining)\n+    BOOST_FOREACH(const COutPoint& removed, vNoSpendsRemaining)\n         pcoinsTip->Uncache(removed);\n }\n \n@@ -344,7 +344,7 @@ static bool IsCurrentForFeeEstimation()\n \n bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx, bool fLimitFree,\n                               bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool fOverrideMempoolLimit, const CAmount& nAbsurdFee, std::vector<uint256>& vHashTxnToUncache)\n+                              bool fOverrideMempoolLimit, const CAmount& nAbsurdFee, std::vector<COutPoint>& vHashTxnToUncache)\n {\n     const CTransaction& tx = *ptx;\n     const uint256 hash = tx.GetHash();\n@@ -437,30 +437,30 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         view.SetBackend(viewMemPool);\n \n         // do we already have it?\n-        bool fHadTxInCache = pcoinsTip->HaveCoinsInCache(hash);\n-        if (view.HaveCoins(hash)) {\n-            if (!fHadTxInCache)\n-                vHashTxnToUncache.push_back(hash);\n-            return state.Invalid(false, REJECT_ALREADY_KNOWN, \"txn-already-known\");\n+        for (size_t out = 0; out < tx.vout.size(); out++) {\n+            COutPoint outpoint(hash, out);\n+            bool fHadTxInCache = pcoinsTip->HaveCoinsInCache(outpoint);\n+            if (view.HaveCoins(outpoint)) {\n+                if (!fHadTxInCache) {\n+                    vHashTxnToUncache.push_back(outpoint);\n+                }\n+                return state.Invalid(false, REJECT_ALREADY_KNOWN, \"txn-already-known\");\n+            }\n         }\n \n         // do all inputs exist?\n-        // Note that this does not check for the presence of actual outputs (see the next check for that),\n-        // and only helps with filling in pfMissingInputs (to determine missing vs spent).\n         BOOST_FOREACH(const CTxIn txin, tx.vin) {\n-            if (!pcoinsTip->HaveCoinsInCache(txin.prevout.hash))\n-                vHashTxnToUncache.push_back(txin.prevout.hash);\n-            if (!view.HaveCoins(txin.prevout.hash)) {\n-                if (pfMissingInputs)\n+            if (!pcoinsTip->HaveCoinsInCache(txin.prevout)) {\n+                vHashTxnToUncache.push_back(txin.prevout);\n+            }\n+            if (!view.HaveCoins(txin.prevout)) {\n+                if (pfMissingInputs) {\n                     *pfMissingInputs = true;\n+                }\n                 return false; // fMissingInputs and !state.IsInvalid() is used to detect this condition, don't set state.Invalid()\n             }\n         }\n \n-        // are the actual inputs available?\n-        if (!view.HaveInputs(tx))\n-            return state.Invalid(false, REJECT_DUPLICATE, \"bad-txns-inputs-spent\");\n-\n         // Bring the best block into scope\n         view.GetBestBlock();\n \n@@ -763,10 +763,10 @@ bool AcceptToMemoryPoolWithTime(CTxMemPool& pool, CValidationState &state, const\n                         bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                         bool fOverrideMempoolLimit, const CAmount nAbsurdFee)\n {\n-    std::vector<uint256> vHashTxToUncache;\n+    std::vector<COutPoint> vHashTxToUncache;\n     bool res = AcceptToMemoryPoolWorker(pool, state, tx, fLimitFree, pfMissingInputs, nAcceptTime, plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee, vHashTxToUncache);\n     if (!res) {\n-        BOOST_FOREACH(const uint256& hashTx, vHashTxToUncache)\n+        BOOST_FOREACH(const COutPoint& hashTx, vHashTxToUncache)\n             pcoinsTip->Uncache(hashTx);\n     }\n     // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n@@ -1762,12 +1762,12 @@ bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode, int n\n     }\n     // Flush best chain related state. This can only be done if the blocks / block index write was also done.\n     if (fDoFullFlush) {\n-        // Typical CCoins structures on disk are around 128 bytes in size.\n+        // Typical Coin structures on disk are around 48 bytes in size.\n         // Pushing a new one to the database can cause it to be written\n         // twice (once in the log, and once in the tables). This is already\n         // an overestimation, as most will delete an existing entry or\n         // overwrite one. Still, use a conservative safety factor of 2.\n-        if (!CheckDiskSpace(128 * 2 * 2 * pcoinsTip->GetCacheSize()))\n+        if (!CheckDiskSpace(48 * 2 * 2 * pcoinsTip->GetCacheSize()))\n             return state.Error(\"out of disk space\");\n         // Flush the chainstate (which may refer to block index entries).\n         if (!pcoinsTip->Flush())\n@@ -1848,7 +1848,7 @@ void static UpdateTip(CBlockIndex *pindexNew, const CChainParams& chainParams) {\n             }\n         }\n     }\n-    LogPrintf(\"%s: new best=%s height=%d version=0x%08x log2_work=%.8g tx=%lu date='%s' progress=%f cache=%.1fMiB(%utx)\", __func__,\n+    LogPrintf(\"%s: new best=%s height=%d version=0x%08x log2_work=%.8g tx=%lu date='%s' progress=%f cache=%.1fMiB(%utxo)\", __func__,\n       chainActive.Tip()->GetBlockHash().ToString(), chainActive.Height(), chainActive.Tip()->nVersion,\n       log(chainActive.Tip()->nChainWork.getdouble())/log(2.0), (unsigned long)chainActive.Tip()->nChainTx,\n       DateTimeStrFormat(\"%Y-%m-%d %H:%M:%S\", chainActive.Tip()->GetBlockTime()),"
      }
    ]
  },
  {
    "sha": "ce23efaa5c2e8e50744a896424b01052db34a3d6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZTIzZWZhYTVjMmU4ZTUwNzQ0YTg5NjQyNGIwMTA1MmRiMzRhM2Q2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-21T19:01:29Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T19:59:41Z"
      },
      "message": "Extend coins_tests",
      "tree": {
        "sha": "97fec92fa46f81beef4f10d76d03973ec9d6195d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/97fec92fa46f81beef4f10d76d03973ec9d6195d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ce23efaa5c2e8e50744a896424b01052db34a3d6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce23efaa5c2e8e50744a896424b01052db34a3d6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ce23efaa5c2e8e50744a896424b01052db34a3d6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce23efaa5c2e8e50744a896424b01052db34a3d6/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "50830796889ecaa458871f1db878c255dd2554cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/50830796889ecaa458871f1db878c255dd2554cb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/50830796889ecaa458871f1db878c255dd2554cb"
      }
    ],
    "stats": {
      "total": 56,
      "additions": 45,
      "deletions": 11
    },
    "files": [
      {
        "sha": "f3f6e9f5f5a7a1e645d508077045703f2d7e3186",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 11,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ce23efaa5c2e8e50744a896424b01052db34a3d6/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ce23efaa5c2e8e50744a896424b01052db34a3d6/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=ce23efaa5c2e8e50744a896424b01052db34a3d6",
        "patch": "@@ -87,9 +87,12 @@ class CCoinsViewCacheTest : public CCoinsViewCache\n     {\n         // Manually recompute the dynamic usage of the whole data, and compare it.\n         size_t ret = memusage::DynamicUsage(cacheCoins);\n+        size_t count = 0;\n         for (CCoinsMap::iterator it = cacheCoins.begin(); it != cacheCoins.end(); it++) {\n             ret += it->second.coins.DynamicMemoryUsage();\n+            ++count;\n         }\n+        BOOST_CHECK_EQUAL(GetCacheSize(), count);\n         BOOST_CHECK_EQUAL(DynamicMemoryUsage(), ret);\n     }\n \n@@ -118,10 +121,12 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     bool removed_all_caches = false;\n     bool reached_4_caches = false;\n     bool added_an_entry = false;\n+    bool added_an_unspendable_entry = false;\n     bool removed_an_entry = false;\n     bool updated_an_entry = false;\n     bool found_an_entry = false;\n     bool missed_an_entry = false;\n+    bool uncached_an_entry = false;\n \n     // A simple map to track what we expect the cache stack to represent.\n     std::map<COutPoint, Coin> result;\n@@ -143,36 +148,49 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n         {\n             uint256 txid = txids[insecure_rand() % txids.size()]; // txid we're going to modify in this iteration.\n             Coin& coin = result[COutPoint(txid, 0)];\n-            const Coin& entry = stack.back()->AccessCoin(COutPoint(txid, 0));\n+            const Coin& entry = (insecure_rand() % 500 == 0) ? AccessByTxid(*stack.back(), txid) : stack.back()->AccessCoin(COutPoint(txid, 0));\n             BOOST_CHECK(coin == entry);\n \n             if (insecure_rand() % 5 == 0 || coin.IsPruned()) {\n-                if (coin.IsPruned()) {\n-                    added_an_entry = true;\n+                Coin newcoin;\n+                newcoin.out.nValue = insecure_rand();\n+                newcoin.nHeight = 1;\n+                if (insecure_rand() % 16 == 0 && coin.IsPruned()) {\n+                    newcoin.out.scriptPubKey.assign(1 + (insecure_rand() & 0x3F), OP_RETURN);\n+                    BOOST_CHECK(newcoin.out.scriptPubKey.IsUnspendable());\n+                    added_an_unspendable_entry = true;\n                 } else {\n-                    updated_an_entry = true;\n+                    newcoin.out.scriptPubKey.assign(insecure_rand() & 0x3F, 0); // Random sizes so we can test memory usage accounting\n+                    (coin.IsPruned() ? added_an_entry : updated_an_entry) = true;\n+                    coin = newcoin;\n                 }\n-                coin.out.nValue = insecure_rand();\n-                coin.nHeight = 1;\n+                stack.back()->AddCoin(COutPoint(txid, 0), std::move(newcoin), !coin.IsPruned() || insecure_rand() & 1);\n             } else {\n-                coin.Clear();\n                 removed_an_entry = true;\n-            }\n-            if (coin.IsPruned()) {\n+                coin.Clear();\n                 stack.back()->SpendCoin(COutPoint(txid, 0));\n-            } else {\n-                stack.back()->AddCoin(COutPoint(txid, 0), Coin(coin), true);\n             }\n         }\n \n+        // One every 10 iterations, remove a random entry from the cache\n+        if (insecure_rand() % 10) {\n+            COutPoint out(txids[insecure_rand() % txids.size()], 0);\n+            int cacheid = insecure_rand() % stack.size();\n+            stack[cacheid]->Uncache(out);\n+            uncached_an_entry |= !stack[cacheid]->HaveCoinsInCache(out);\n+        }\n+\n         // Once every 1000 iterations and at the end, verify the full cache.\n         if (insecure_rand() % 1000 == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n             for (auto it = result.begin(); it != result.end(); it++) {\n+                bool have = stack.back()->HaveCoins(it->first);\n                 const Coin& coin = stack.back()->AccessCoin(it->first);\n+                BOOST_CHECK(have == !coin.IsPruned());\n                 BOOST_CHECK(coin == it->second);\n                 if (coin.IsPruned()) {\n                     missed_an_entry = true;\n                 } else {\n+                    BOOST_CHECK(stack.back()->HaveCoinsInCache(it->first));\n                     found_an_entry = true;\n                 }\n             }\n@@ -222,10 +240,12 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n     BOOST_CHECK(removed_all_caches);\n     BOOST_CHECK(reached_4_caches);\n     BOOST_CHECK(added_an_entry);\n+    BOOST_CHECK(added_an_unspendable_entry);\n     BOOST_CHECK(removed_an_entry);\n     BOOST_CHECK(updated_an_entry);\n     BOOST_CHECK(found_an_entry);\n     BOOST_CHECK(missed_an_entry);\n+    BOOST_CHECK(uncached_an_entry);\n }\n \n // Store of all necessary tx and undo data for next test\n@@ -275,6 +295,7 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n             tx.vin.resize(1);\n             tx.vout.resize(1);\n             tx.vout[0].nValue = i; //Keep txs unique unless intended to duplicate\n+            tx.vout[0].scriptPubKey.assign(insecure_rand() & 0x3F, 0); // Random sizes so we can test memory usage accounting\n             unsigned int height = insecure_rand();\n             Coin oldcoins;\n \n@@ -393,11 +414,24 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n         // Once every 1000 iterations and at the end, verify the full cache.\n         if (insecure_rand() % 1000 == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n             for (auto it = result.begin(); it != result.end(); it++) {\n+                bool have = stack.back()->HaveCoins(it->first);\n                 const Coin& coin = stack.back()->AccessCoin(it->first);\n+                BOOST_CHECK(have == !coin.IsPruned());\n                 BOOST_CHECK(coin == it->second);\n             }\n         }\n \n+        // One every 10 iterations, remove a random entry from the cache\n+        if (utxoset.size() > 1 && insecure_rand() % 30) {\n+            stack[insecure_rand() % stack.size()]->Uncache(FindRandomFrom(utxoset)->first);\n+        }\n+        if (disconnectedids.size() > 1 && insecure_rand() % 30) {\n+            stack[insecure_rand() % stack.size()]->Uncache(FindRandomFrom(disconnectedids)->first);\n+        }\n+        if (duplicateids.size() > 1 && insecure_rand() % 30) {\n+            stack[insecure_rand() % stack.size()]->Uncache(FindRandomFrom(duplicateids)->first);\n+        }\n+\n         if (insecure_rand() % 100 == 0) {\n             // Every 100 iterations, flush an intermediate cache\n             if (stack.size() > 1 && insecure_rand() % 2 == 0) {"
      }
    ]
  },
  {
    "sha": "97072d6685564dd50aab4c145b1758ccc10863b3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5NzA3MmQ2Njg1NTY0ZGQ1MGFhYjRjMTQ1YjE3NThjY2MxMDg2M2Iz",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:41Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T20:15:03Z"
      },
      "message": "Remove unused CCoins methods",
      "tree": {
        "sha": "e8657bd100dfc54ace9d828242eb3e0320d9318c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e8657bd100dfc54ace9d828242eb3e0320d9318c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/97072d6685564dd50aab4c145b1758ccc10863b3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/97072d6685564dd50aab4c145b1758ccc10863b3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/97072d6685564dd50aab4c145b1758ccc10863b3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/97072d6685564dd50aab4c145b1758ccc10863b3/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ce23efaa5c2e8e50744a896424b01052db34a3d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ce23efaa5c2e8e50744a896424b01052db34a3d6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ce23efaa5c2e8e50744a896424b01052db34a3d6"
      }
    ],
    "stats": {
      "total": 199,
      "additions": 0,
      "deletions": 199
    },
    "files": [
      {
        "sha": "09fd2b13d0de27c07b884e51582dd0d74d845d74",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 32,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/97072d6685564dd50aab4c145b1758ccc10863b3/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/97072d6685564dd50aab4c145b1758ccc10863b3/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=97072d6685564dd50aab4c145b1758ccc10863b3",
        "patch": "@@ -10,38 +10,6 @@\n \n #include <assert.h>\n \n-/**\n- * calculate number of bytes for the bitmask, and its number of non-zero bytes\n- * each bit in the bitmask represents the availability of one output, but the\n- * availabilities of the first two outputs are encoded separately\n- */\n-void CCoins::CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const {\n-    unsigned int nLastUsedByte = 0;\n-    for (unsigned int b = 0; 2+b*8 < vout.size(); b++) {\n-        bool fZero = true;\n-        for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++) {\n-            if (!vout[2+b*8+i].IsNull()) {\n-                fZero = false;\n-                continue;\n-            }\n-        }\n-        if (!fZero) {\n-            nLastUsedByte = b + 1;\n-            nNonzeroBytes++;\n-        }\n-    }\n-    nBytes += nLastUsedByte;\n-}\n-\n-bool CCoins::Spend(uint32_t nPos) \n-{\n-    if (nPos >= vout.size() || vout[nPos].IsNull())\n-        return false;\n-    vout[nPos].SetNull();\n-    Cleanup();\n-    return true;\n-}\n-\n bool CCoinsView::GetCoins(const COutPoint &outpoint, Coin &coin) const { return false; }\n bool CCoinsView::HaveCoins(const COutPoint &outpoint) const { return false; }\n uint256 CCoinsView::GetBestBlock() const { return uint256(); }"
      },
      {
        "sha": "bd2f2caf27f225248bad12e1df42d18bf4d49444",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 0,
        "deletions": 167,
        "changes": 167,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/97072d6685564dd50aab4c145b1758ccc10863b3/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/97072d6685564dd50aab4c145b1758ccc10863b3/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=97072d6685564dd50aab4c145b1758ccc10863b3",
        "patch": "@@ -82,58 +82,6 @@ class Coin\n     }\n };\n \n-/** \n- * Pruned version of CTransaction: only retains metadata and unspent transaction outputs\n- *\n- * Serialized format:\n- * - VARINT(nVersion)\n- * - VARINT(nCode)\n- * - unspentness bitvector, for vout[2] and further; least significant byte first\n- * - the non-spent CTxOuts (via CTxOutCompressor)\n- * - VARINT(nHeight)\n- *\n- * The nCode value consists of:\n- * - bit 0: IsCoinBase()\n- * - bit 1: vout[0] is not spent\n- * - bit 2: vout[1] is not spent\n- * - The higher bits encode N, the number of non-zero bytes in the following bitvector.\n- *   - In case both bit 1 and bit 2 are unset, they encode N-1, as there must be at\n- *     least one non-spent output).\n- *\n- * Example: 0104835800816115944e077fe7c803cfa57f29b36bf87c1d358bb85e\n- *          <><><--------------------------------------------><---->\n- *          |  \\                  |                             /\n- *    version   code             vout[1]                  height\n- *\n- *    - version = 1\n- *    - code = 4 (vout[1] is not spent, and 0 non-zero bytes of bitvector follow)\n- *    - unspentness bitvector: as 0 non-zero bytes follow, it has length 0\n- *    - vout[1]: 835800816115944e077fe7c803cfa57f29b36bf87c1d35\n- *               * 8358: compact amount representation for 60000000000 (600 BTC)\n- *               * 00: special txout type pay-to-pubkey-hash\n- *               * 816115944e077fe7c803cfa57f29b36bf87c1d35: address uint160\n- *    - height = 203998\n- *\n- *\n- * Example: 0109044086ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4eebbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa486af3b\n- *          <><><--><--------------------------------------------------><----------------------------------------------><---->\n- *         /  \\   \\                     |                                                           |                     /\n- *  version  code  unspentness       vout[4]                                                     vout[16]           height\n- *\n- *  - version = 1\n- *  - code = 9 (coinbase, neither vout[0] or vout[1] are unspent,\n- *                2 (1, +1 because both bit 1 and bit 2 are unset) non-zero bitvector bytes follow)\n- *  - unspentness bitvector: bits 2 (0x04) and 14 (0x4000) are set, so vout[2+2] and vout[14+2] are unspent\n- *  - vout[4]: 86ef97d5790061b01caab50f1b8e9c50a5057eb43c2d9563a4ee\n- *             * 86ef97d579: compact amount representation for 234925952 (2.35 BTC)\n- *             * 00: special txout type pay-to-pubkey-hash\n- *             * 61b01caab50f1b8e9c50a5057eb43c2d9563a4ee: address uint160\n- *  - vout[16]: bbd123008c988f1a4a4de2161e0f50aac7f17e7f9555caa4\n- *              * bbd123: compact amount representation for 110397 (0.001 BTC)\n- *              * 00: special txout type pay-to-pubkey-hash\n- *              * 8c988f1a4a4de2161e0f50aac7f17e7f9555caa4: address uint160\n- *  - height = 120891\n- */\n class CCoins\n {\n public:\n@@ -146,98 +94,9 @@ class CCoins\n     //! at which height this transaction was included in the active block chain\n     int nHeight;\n \n-    void FromTx(const CTransaction &tx, int nHeightIn) {\n-        fCoinBase = tx.IsCoinBase();\n-        vout = tx.vout;\n-        nHeight = nHeightIn;\n-        ClearUnspendable();\n-    }\n-\n-    //! construct a CCoins from a CTransaction, at a given height\n-    CCoins(const CTransaction &tx, int nHeightIn) {\n-        FromTx(tx, nHeightIn);\n-    }\n-\n-    void Clear() {\n-        fCoinBase = false;\n-        std::vector<CTxOut>().swap(vout);\n-        nHeight = 0;\n-    }\n-\n     //! empty constructor\n     CCoins() : fCoinBase(false), vout(0), nHeight(0) { }\n \n-    //!remove spent outputs at the end of vout\n-    void Cleanup() {\n-        while (vout.size() > 0 && vout.back().IsNull())\n-            vout.pop_back();\n-        if (vout.empty())\n-            std::vector<CTxOut>().swap(vout);\n-    }\n-\n-    void ClearUnspendable() {\n-        BOOST_FOREACH(CTxOut &txout, vout) {\n-            if (txout.scriptPubKey.IsUnspendable())\n-                txout.SetNull();\n-        }\n-        Cleanup();\n-    }\n-\n-    void swap(CCoins &to) {\n-        std::swap(to.fCoinBase, fCoinBase);\n-        to.vout.swap(vout);\n-        std::swap(to.nHeight, nHeight);\n-    }\n-\n-    //! equality test\n-    friend bool operator==(const CCoins &a, const CCoins &b) {\n-         // Empty CCoins objects are always equal.\n-         if (a.IsPruned() && b.IsPruned())\n-             return true;\n-         return a.fCoinBase == b.fCoinBase &&\n-                a.nHeight == b.nHeight &&\n-                a.vout == b.vout;\n-    }\n-    friend bool operator!=(const CCoins &a, const CCoins &b) {\n-        return !(a == b);\n-    }\n-\n-    void CalcMaskSize(unsigned int &nBytes, unsigned int &nNonzeroBytes) const;\n-\n-    bool IsCoinBase() const {\n-        return fCoinBase;\n-    }\n-\n-    template<typename Stream>\n-    void Serialize(Stream &s) const {\n-        unsigned int nMaskSize = 0, nMaskCode = 0;\n-        CalcMaskSize(nMaskSize, nMaskCode);\n-        bool fFirst = vout.size() > 0 && !vout[0].IsNull();\n-        bool fSecond = vout.size() > 1 && !vout[1].IsNull();\n-        assert(fFirst || fSecond || nMaskCode);\n-        unsigned int nCode = 8*(nMaskCode - (fFirst || fSecond ? 0 : 1)) + (fCoinBase ? 1 : 0) + (fFirst ? 2 : 0) + (fSecond ? 4 : 0);\n-        // version\n-        int nVersionDummy = 0;\n-        ::Serialize(s, VARINT(nVersionDummy));\n-        // header code\n-        ::Serialize(s, VARINT(nCode));\n-        // spentness bitmask\n-        for (unsigned int b = 0; b<nMaskSize; b++) {\n-            unsigned char chAvail = 0;\n-            for (unsigned int i = 0; i < 8 && 2+b*8+i < vout.size(); i++)\n-                if (!vout[2+b*8+i].IsNull())\n-                    chAvail |= (1 << i);\n-            ::Serialize(s, chAvail);\n-        }\n-        // txouts themself\n-        for (unsigned int i = 0; i < vout.size(); i++) {\n-            if (!vout[i].IsNull())\n-                ::Serialize(s, CTxOutCompressor(REF(vout[i])));\n-        }\n-        // coinbase height\n-        ::Serialize(s, VARINT(nHeight));\n-    }\n-\n     template<typename Stream>\n     void Unserialize(Stream &s) {\n         unsigned int nCode = 0;\n@@ -270,32 +129,6 @@ class CCoins\n         }\n         // coinbase height\n         ::Unserialize(s, VARINT(nHeight));\n-        Cleanup();\n-    }\n-\n-    //! mark a vout spent\n-    bool Spend(uint32_t nPos);\n-\n-    //! check whether a particular output is still available\n-    bool IsAvailable(unsigned int nPos) const {\n-        return (nPos < vout.size() && !vout[nPos].IsNull());\n-    }\n-\n-    //! check whether the entire CCoins is spent\n-    //! note that only !IsPruned() CCoins can be serialized\n-    bool IsPruned() const {\n-        BOOST_FOREACH(const CTxOut &out, vout)\n-            if (!out.IsNull())\n-                return false;\n-        return true;\n-    }\n-\n-    size_t DynamicMemoryUsage() const {\n-        size_t ret = memusage::DynamicUsage(vout);\n-        BOOST_FOREACH(const CTxOut &out, vout) {\n-            ret += RecursiveDynamicUsage(out.scriptPubKey);\n-        }\n-        return ret;\n     }\n };\n "
      }
    ]
  },
  {
    "sha": "41aa5b79a3d79f8afe4c556b4f14fb1dc0cc3f9f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MWFhNWI3OWEzZDc5ZjhhZmU0YzU1NmI0ZjE0ZmIxZGMwY2MzZjlm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:42Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T20:15:06Z"
      },
      "message": "Pack Coin more tightly",
      "tree": {
        "sha": "ad4446332ea54c54fe5043ba7522091267ae1824",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad4446332ea54c54fe5043ba7522091267ae1824"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/41aa5b79a3d79f8afe4c556b4f14fb1dc0cc3f9f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/41aa5b79a3d79f8afe4c556b4f14fb1dc0cc3f9f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/41aa5b79a3d79f8afe4c556b4f14fb1dc0cc3f9f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/41aa5b79a3d79f8afe4c556b4f14fb1dc0cc3f9f/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "97072d6685564dd50aab4c145b1758ccc10863b3",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/97072d6685564dd50aab4c145b1758ccc10863b3",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/97072d6685564dd50aab4c145b1758ccc10863b3"
      }
    ],
    "stats": {
      "total": 16,
      "additions": 8,
      "deletions": 8
    },
    "files": [
      {
        "sha": "7f4dffc7ec15e2241d33807ec3bdd633b45f079b",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 8,
        "deletions": 8,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/41aa5b79a3d79f8afe4c556b4f14fb1dc0cc3f9f/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/41aa5b79a3d79f8afe4c556b4f14fb1dc0cc3f9f/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=41aa5b79a3d79f8afe4c556b4f14fb1dc0cc3f9f",
        "patch": "@@ -30,18 +30,18 @@\n class Coin\n {\n public:\n-    //! whether the containing transaction was a coinbase\n-    bool fCoinBase;\n-\n     //! unspent transaction output\n     CTxOut out;\n \n-    //! at which height the containing transaction was included in the active block chain\n-    uint32_t nHeight;\n+    //! whether containing transaction was a coinbase\n+    unsigned int fCoinBase : 1;\n+\n+    //! at which height this containing transaction was included in the active block chain\n+    uint32_t nHeight : 31;\n \n-    //! construct a Coin from a CTxOut and height/coinbase properties.\n-    Coin(CTxOut&& outIn, int nHeightIn, bool fCoinBaseIn) : fCoinBase(fCoinBaseIn), out(std::move(outIn)), nHeight(nHeightIn) {}\n-    Coin(const CTxOut& outIn, int nHeightIn, bool fCoinBaseIn) : fCoinBase(fCoinBaseIn), out(outIn), nHeight(nHeightIn) {}\n+    //! construct a Coin from a CTxOut and height/coinbase information.\n+    Coin(CTxOut&& outIn, int nHeightIn, bool fCoinBaseIn) : out(std::move(outIn)), fCoinBase(fCoinBaseIn), nHeight(nHeightIn) {}\n+    Coin(const CTxOut& outIn, int nHeightIn, bool fCoinBaseIn) : out(outIn), fCoinBase(fCoinBaseIn),nHeight(nHeightIn) {}\n \n     void Clear() {\n         out.SetNull();"
      }
    ]
  },
  {
    "sha": "b2af357f39c7d17ab6ddb2938531155bf90126ec",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiMmFmMzU3ZjM5YzdkMTdhYjZkZGIyOTM4NTMxMTU1YmY5MDEyNmVj",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:44Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T20:15:06Z"
      },
      "message": "Reduce reserved memory space for flushing\n\nAs the maximum amount of data that can be pulled into the cache due to\na block validation is much lower now (at most one CCoin entry per input\nand per output), reduce the conservative estimate used to determine\nflushing time.",
      "tree": {
        "sha": "6c03e54ede44ab3c638b4dcddfeed023d5ccd7ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6c03e54ede44ab3c638b4dcddfeed023d5ccd7ea"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b2af357f39c7d17ab6ddb2938531155bf90126ec",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2af357f39c7d17ab6ddb2938531155bf90126ec",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b2af357f39c7d17ab6ddb2938531155bf90126ec",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2af357f39c7d17ab6ddb2938531155bf90126ec/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "41aa5b79a3d79f8afe4c556b4f14fb1dc0cc3f9f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/41aa5b79a3d79f8afe4c556b4f14fb1dc0cc3f9f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/41aa5b79a3d79f8afe4c556b4f14fb1dc0cc3f9f"
      }
    ],
    "stats": {
      "total": 9,
      "additions": 3,
      "deletions": 6
    },
    "files": [
      {
        "sha": "189094737ea87279ca543e7d1f56918ff37526f2",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 1,
        "deletions": 3,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2af357f39c7d17ab6ddb2938531155bf90126ec/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2af357f39c7d17ab6ddb2938531155bf90126ec/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=b2af357f39c7d17ab6ddb2938531155bf90126ec",
        "patch": "@@ -22,9 +22,7 @@ class uint256;\n //! Compensate for extra memory peak (x1.5-x1.9) at flush time.\n static constexpr int DB_PEAK_USAGE_FACTOR = 2;\n //! No need to periodic flush if at least this much space still available.\n-static constexpr int MAX_BLOCK_COINSDB_USAGE = 200 * DB_PEAK_USAGE_FACTOR;\n-//! Always periodic flush if less than this much space still available.\n-static constexpr int MIN_BLOCK_COINSDB_USAGE = 50 * DB_PEAK_USAGE_FACTOR;\n+static constexpr int MAX_BLOCK_COINSDB_USAGE = 10 * DB_PEAK_USAGE_FACTOR;\n //! -dbcache default (MiB)\n static const int64_t nDefaultDbCache = 450;\n //! max. -dbcache (MiB)"
      },
      {
        "sha": "005eaafff799ab26a445780ecaa832e4a81957b8",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 3,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b2af357f39c7d17ab6ddb2938531155bf90126ec/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b2af357f39c7d17ab6ddb2938531155bf90126ec/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=b2af357f39c7d17ab6ddb2938531155bf90126ec",
        "patch": "@@ -1719,9 +1719,8 @@ bool static FlushStateToDisk(CValidationState &state, FlushStateMode mode, int n\n     int64_t nMempoolSizeMax = GetArg(\"-maxmempool\", DEFAULT_MAX_MEMPOOL_SIZE) * 1000000;\n     int64_t cacheSize = pcoinsTip->DynamicMemoryUsage() * DB_PEAK_USAGE_FACTOR;\n     int64_t nTotalSpace = nCoinCacheUsage + std::max<int64_t>(nMempoolSizeMax - nMempoolUsage, 0);\n-    // The cache is large and we're within 10% and 200 MiB or 50% and 50MiB of the limit, but we have time now (not in the middle of a block processing).\n-    bool fCacheLarge = mode == FLUSH_STATE_PERIODIC && cacheSize > std::min(std::max(nTotalSpace / 2, nTotalSpace - MIN_BLOCK_COINSDB_USAGE * 1024 * 1024),\n-                                                                            std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024));\n+    // The cache is large and we're within 10% and 10 MiB of the limit, but we have time now (not in the middle of a block processing).\n+    bool fCacheLarge = mode == FLUSH_STATE_PERIODIC && cacheSize > std::max((9 * nTotalSpace) / 10, nTotalSpace - MAX_BLOCK_COINSDB_USAGE * 1024 * 1024);\n     // The cache is over the limit, we have to write now.\n     bool fCacheCritical = mode == FLUSH_STATE_IF_NEEDED && cacheSize > nTotalSpace;\n     // It's been a while since we wrote the block index to disk. Do this frequently, so we don't need to redownload after a crash."
      }
    ]
  },
  {
    "sha": "8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YjI1ZDJjMGNlNjRkN2Y4NTc3YTBjMmU2MDFlNTA1YzlmMTE0MGJm",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:46Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T20:15:24Z"
      },
      "message": "Upgrade from per-tx database to per-txout",
      "tree": {
        "sha": "f0e2511a6e0aebf0012c209f54574b649651d3b2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/f0e2511a6e0aebf0012c209f54574b649651d3b2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b2af357f39c7d17ab6ddb2938531155bf90126ec",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b2af357f39c7d17ab6ddb2938531155bf90126ec",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b2af357f39c7d17ab6ddb2938531155bf90126ec"
      }
    ],
    "stats": {
      "total": 54,
      "additions": 54,
      "deletions": 0
    },
    "files": [
      {
        "sha": "5ffb810aab69852407642731ead255075f07b254",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf",
        "patch": "@@ -82,6 +82,7 @@ class Coin\n     }\n };\n \n+//! Legacy class to deserialize pre-pertxout database entries without reindex.\n class CCoins\n {\n public:"
      },
      {
        "sha": "8ce38479555fe55513df1e86e18c924139619d1e",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf",
        "patch": "@@ -1455,6 +1455,12 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     //If we're reindexing in prune mode, wipe away unusable block files and all undo data files\n                     if (fPruneMode)\n                         CleanupBlockRevFiles();\n+                } else {\n+                    // If necessary, upgrade from older database format.\n+                    if (!pcoinsdbview->Upgrade()) {\n+                        strLoadError = _(\"Error upgrading chainstate database\");\n+                        break;\n+                    }\n                 }\n \n                 if (!LoadBlockIndex(chainparams)) {"
      },
      {
        "sha": "f4a6fad85b3dbc0881e36dd345964d356dbdf924",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf",
        "patch": "@@ -252,3 +252,48 @@ bool CBlockTreeDB::LoadBlockIndexGuts(std::function<CBlockIndex*(const uint256&)\n \n     return true;\n }\n+\n+/** Upgrade the database from older formats.\n+ *\n+ * Currently implemented: from the per-tx utxo model (0.8..0.14.x) to per-txout.\n+ */\n+bool CCoinsViewDB::Upgrade() {\n+    std::unique_ptr<CDBIterator> pcursor(db.NewIterator());\n+    pcursor->Seek(std::make_pair(DB_COINS, uint256()));\n+    if (!pcursor->Valid()) {\n+        return true;\n+    }\n+\n+    LogPrintf(\"Upgrading database...\\n\");\n+    size_t batch_size = 1 << 24;\n+    CDBBatch batch(db);\n+    while (pcursor->Valid()) {\n+        boost::this_thread::interruption_point();\n+        std::pair<unsigned char, uint256> key;\n+        if (pcursor->GetKey(key) && key.first == DB_COINS) {\n+            CCoins old_coins;\n+            if (!pcursor->GetValue(old_coins)) {\n+                return error(\"%s: cannot parse CCoins record\", __func__);\n+            }\n+            COutPoint outpoint(key.second, 0);\n+            for (size_t i = 0; i < old_coins.vout.size(); ++i) {\n+                if (!old_coins.vout[i].IsNull() && !old_coins.vout[i].scriptPubKey.IsUnspendable()) {\n+                    Coin newcoin(std::move(old_coins.vout[i]), old_coins.nHeight, old_coins.fCoinBase);\n+                    outpoint.n = i;\n+                    CoinEntry entry(&outpoint);\n+                    batch.Write(entry, newcoin);\n+                }\n+            }\n+            batch.Erase(key);\n+            if (batch.SizeEstimate() > batch_size) {\n+                db.WriteBatch(batch);\n+                batch.Clear();\n+            }\n+            pcursor->Next();\n+        } else {\n+            break;\n+        }\n+    }\n+    db.WriteBatch(batch);\n+    return true;\n+}"
      },
      {
        "sha": "51dc355bba5fd525aac8df8d9faac38a6042dd63",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf",
        "patch": "@@ -77,6 +77,8 @@ class CCoinsViewDB : public CCoinsView\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n     CCoinsViewCursor *Cursor() const override;\n \n+    //! Attempt to update from an older database format. Returns whether an error occurred.\n+    bool Upgrade();\n     size_t EstimateSize() const override;\n };\n "
      }
    ]
  },
  {
    "sha": "580b023092a28f444068b53792eb542f9d5e6892",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ODBiMDIzMDkyYTI4ZjQ0NDA2OGI1Mzc5MmViNTQyZjlkNWU2ODky",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-25T18:29:48Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T20:15:25Z"
      },
      "message": "[MOVEONLY] Move old CCoins class to txdb.cpp\n\nIt's only used for upgrading from the old database anymore.",
      "tree": {
        "sha": "a59a6d0e4636cdc442cc2bfa9c4f1a60bdacf80d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/a59a6d0e4636cdc442cc2bfa9c4f1a60bdacf80d"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/580b023092a28f444068b53792eb542f9d5e6892",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/580b023092a28f444068b53792eb542f9d5e6892",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/580b023092a28f444068b53792eb542f9d5e6892",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/580b023092a28f444068b53792eb542f9d5e6892/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8b25d2c0ce64d7f8577a0c2e601e505c9f1140bf"
      }
    ],
    "stats": {
      "total": 106,
      "additions": 55,
      "deletions": 51
    },
    "files": [
      {
        "sha": "43da9a3c63677bb653958fa149d1dfc7927f3779",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 0,
        "deletions": 51,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/580b023092a28f444068b53792eb542f9d5e6892/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/580b023092a28f444068b53792eb542f9d5e6892/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=580b023092a28f444068b53792eb542f9d5e6892",
        "patch": "@@ -82,57 +82,6 @@ class Coin\n     }\n };\n \n-//! Legacy class to deserialize pre-pertxout database entries without reindex.\n-class CCoins\n-{\n-public:\n-    //! whether transaction is a coinbase\n-    bool fCoinBase;\n-\n-    //! unspent transaction outputs; spent outputs are .IsNull(); spent outputs at the end of the array are dropped\n-    std::vector<CTxOut> vout;\n-\n-    //! at which height this transaction was included in the active block chain\n-    int nHeight;\n-\n-    //! empty constructor\n-    CCoins() : fCoinBase(false), vout(0), nHeight(0) { }\n-\n-    template<typename Stream>\n-    void Unserialize(Stream &s) {\n-        unsigned int nCode = 0;\n-        // version\n-        int nVersionDummy;\n-        ::Unserialize(s, VARINT(nVersionDummy));\n-        // header code\n-        ::Unserialize(s, VARINT(nCode));\n-        fCoinBase = nCode & 1;\n-        std::vector<bool> vAvail(2, false);\n-        vAvail[0] = (nCode & 2) != 0;\n-        vAvail[1] = (nCode & 4) != 0;\n-        unsigned int nMaskCode = (nCode / 8) + ((nCode & 6) != 0 ? 0 : 1);\n-        // spentness bitmask\n-        while (nMaskCode > 0) {\n-            unsigned char chAvail = 0;\n-            ::Unserialize(s, chAvail);\n-            for (unsigned int p = 0; p < 8; p++) {\n-                bool f = (chAvail & (1 << p)) != 0;\n-                vAvail.push_back(f);\n-            }\n-            if (chAvail != 0)\n-                nMaskCode--;\n-        }\n-        // txouts themself\n-        vout.assign(vAvail.size(), CTxOut());\n-        for (unsigned int i = 0; i < vAvail.size(); i++) {\n-            if (vAvail[i])\n-                ::Unserialize(s, REF(CTxOutCompressor(vout[i])));\n-        }\n-        // coinbase height\n-        ::Unserialize(s, VARINT(nHeight));\n-    }\n-};\n-\n class SaltedOutpointHasher\n {\n private:"
      },
      {
        "sha": "205b1b0a886ec1eec87b8375e2b9a178da832aed",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 55,
        "deletions": 0,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/580b023092a28f444068b53792eb542f9d5e6892/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/580b023092a28f444068b53792eb542f9d5e6892/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=580b023092a28f444068b53792eb542f9d5e6892",
        "patch": "@@ -253,6 +253,61 @@ bool CBlockTreeDB::LoadBlockIndexGuts(std::function<CBlockIndex*(const uint256&)\n     return true;\n }\n \n+namespace {\n+\n+//! Legacy class to deserialize pre-pertxout database entries without reindex.\n+class CCoins\n+{\n+public:\n+    //! whether transaction is a coinbase\n+    bool fCoinBase;\n+\n+    //! unspent transaction outputs; spent outputs are .IsNull(); spent outputs at the end of the array are dropped\n+    std::vector<CTxOut> vout;\n+\n+    //! at which height this transaction was included in the active block chain\n+    int nHeight;\n+\n+    //! empty constructor\n+    CCoins() : fCoinBase(false), vout(0), nHeight(0) { }\n+\n+    template<typename Stream>\n+    void Unserialize(Stream &s) {\n+        unsigned int nCode = 0;\n+        // version\n+        int nVersionDummy;\n+        ::Unserialize(s, VARINT(nVersionDummy));\n+        // header code\n+        ::Unserialize(s, VARINT(nCode));\n+        fCoinBase = nCode & 1;\n+        std::vector<bool> vAvail(2, false);\n+        vAvail[0] = (nCode & 2) != 0;\n+        vAvail[1] = (nCode & 4) != 0;\n+        unsigned int nMaskCode = (nCode / 8) + ((nCode & 6) != 0 ? 0 : 1);\n+        // spentness bitmask\n+        while (nMaskCode > 0) {\n+            unsigned char chAvail = 0;\n+            ::Unserialize(s, chAvail);\n+            for (unsigned int p = 0; p < 8; p++) {\n+                bool f = (chAvail & (1 << p)) != 0;\n+                vAvail.push_back(f);\n+            }\n+            if (chAvail != 0)\n+                nMaskCode--;\n+        }\n+        // txouts themself\n+        vout.assign(vAvail.size(), CTxOut());\n+        for (unsigned int i = 0; i < vAvail.size(); i++) {\n+            if (vAvail[i])\n+                ::Unserialize(s, REF(CTxOutCompressor(vout[i])));\n+        }\n+        // coinbase height\n+        ::Unserialize(s, VARINT(nHeight));\n+    }\n+};\n+\n+}\n+\n /** Upgrade the database from older formats.\n  *\n  * Currently implemented: from the per-tx utxo model (0.8..0.14.x) to per-txout."
      }
    ]
  },
  {
    "sha": "119e552f7ccd49c0137a3c6b4f94018a84d69620",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoxMTllNTUyZjdjY2Q0OWMwMTM3YTNjNmI0Zjk0MDE4YTg0ZDY5NjIw",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-04-26T23:09:27Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T20:15:25Z"
      },
      "message": "Merge CCoinsViewCache's GetOutputFor and AccessCoin\n\nThey're doing the same thing now.",
      "tree": {
        "sha": "8f57485e1a2e8e4a420081caf9378eda390163cd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8f57485e1a2e8e4a420081caf9378eda390163cd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/119e552f7ccd49c0137a3c6b4f94018a84d69620",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/119e552f7ccd49c0137a3c6b4f94018a84d69620",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/119e552f7ccd49c0137a3c6b4f94018a84d69620",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/119e552f7ccd49c0137a3c6b4f94018a84d69620/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "580b023092a28f444068b53792eb542f9d5e6892",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/580b023092a28f444068b53792eb542f9d5e6892",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/580b023092a28f444068b53792eb542f9d5e6892"
      }
    ],
    "stats": {
      "total": 19,
      "additions": 5,
      "deletions": 14
    },
    "files": [
      {
        "sha": "59bcdce9c48a113d15423c5f9df7728162cd0cf7",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 8,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/119e552f7ccd49c0137a3c6b4f94018a84d69620/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/119e552f7ccd49c0137a3c6b4f94018a84d69620/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=119e552f7ccd49c0137a3c6b4f94018a84d69620",
        "patch": "@@ -213,21 +213,14 @@ unsigned int CCoinsViewCache::GetCacheSize() const {\n     return cacheCoins.size();\n }\n \n-const CTxOut &CCoinsViewCache::GetOutputFor(const CTxIn& input) const\n-{\n-    const Coin& coin = AccessCoin(input.prevout);\n-    assert(!coin.IsPruned());\n-    return coin.out;\n-}\n-\n CAmount CCoinsViewCache::GetValueIn(const CTransaction& tx) const\n {\n     if (tx.IsCoinBase())\n         return 0;\n \n     CAmount nResult = 0;\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n-        nResult += GetOutputFor(tx.vin[i]).nValue;\n+        nResult += AccessCoin(tx.vin[i].prevout).out.nValue;\n \n     return nResult;\n }"
      },
      {
        "sha": "1203c3fadaa3bdc2fa9664c2dcaccee58d7d663d",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/119e552f7ccd49c0137a3c6b4f94018a84d69620/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/119e552f7ccd49c0137a3c6b4f94018a84d69620/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=119e552f7ccd49c0137a3c6b4f94018a84d69620",
        "patch": "@@ -272,8 +272,6 @@ class CCoinsViewCache : public CCoinsViewBacked\n     //! Check whether all prevouts of the transaction are present in the UTXO set represented by this view\n     bool HaveInputs(const CTransaction& tx) const;\n \n-    const CTxOut &GetOutputFor(const CTxIn& input) const;\n-\n private:\n     CCoinsMap::iterator FetchCoins(const COutPoint &outpoint) const;\n "
      },
      {
        "sha": "1195a15613255ec1154f2e88c815cfb94ecac532",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/119e552f7ccd49c0137a3c6b4f94018a84d69620/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/119e552f7ccd49c0137a3c6b4f94018a84d69620/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=119e552f7ccd49c0137a3c6b4f94018a84d69620",
        "patch": "@@ -126,7 +126,7 @@ unsigned int GetP2SHSigOpCount(const CTransaction& tx, const CCoinsViewCache& in\n     unsigned int nSigOps = 0;\n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n     {\n-        const CTxOut &prevout = inputs.GetOutputFor(tx.vin[i]);\n+        const CTxOut &prevout = inputs.AccessCoin(tx.vin[i].prevout).out;\n         if (prevout.scriptPubKey.IsPayToScriptHash())\n             nSigOps += prevout.scriptPubKey.GetSigOpCount(tx.vin[i].scriptSig);\n     }\n@@ -146,7 +146,7 @@ int64_t GetTransactionSigOpCost(const CTransaction& tx, const CCoinsViewCache& i\n \n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n     {\n-        const CTxOut &prevout = inputs.GetOutputFor(tx.vin[i]);\n+        const CTxOut &prevout = inputs.AccessCoin(tx.vin[i].prevout).out;\n         nSigOps += CountWitnessSigOps(tx.vin[i].scriptSig, prevout.scriptPubKey, &tx.vin[i].scriptWitness, flags);\n     }\n     return nSigOps;"
      },
      {
        "sha": "14d58e7442db0b52277dcbdacdc62d8e9bc8234d",
        "filename": "src/policy/policy.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/119e552f7ccd49c0137a3c6b4f94018a84d69620/src/policy/policy.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/119e552f7ccd49c0137a3c6b4f94018a84d69620/src/policy/policy.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/policy.cpp?ref=119e552f7ccd49c0137a3c6b4f94018a84d69620",
        "patch": "@@ -165,7 +165,7 @@ bool AreInputsStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n \n     for (unsigned int i = 0; i < tx.vin.size(); i++)\n     {\n-        const CTxOut& prev = mapInputs.GetOutputFor(tx.vin[i]);\n+        const CTxOut& prev = mapInputs.AccessCoin(tx.vin[i].prevout).out;\n \n         std::vector<std::vector<unsigned char> > vSolutions;\n         txnouttype whichType;\n@@ -204,7 +204,7 @@ bool IsWitnessStandard(const CTransaction& tx, const CCoinsViewCache& mapInputs)\n         if (tx.vin[i].scriptWitness.IsNull())\n             continue;\n \n-        const CTxOut &prev = mapInputs.GetOutputFor(tx.vin[i]);\n+        const CTxOut &prev = mapInputs.AccessCoin(tx.vin[i].prevout).out;\n \n         // get the scriptPubKey corresponding to this input:\n         CScript prevScript = prev.scriptPubKey;"
      }
    ]
  },
  {
    "sha": "73de2c1ff345ac38c098d7b1bef03176f3ea1f16",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo3M2RlMmMxZmYzNDVhYzM4YzA5OGQ3YjFiZWYwMzE3NmYzZWExZjE2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-04T07:15:36Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T20:15:25Z"
      },
      "message": "Rename CCoinsCacheEntry::coins to coin",
      "tree": {
        "sha": "697e34ca54310c6598ee033af7611f63173b57a5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/697e34ca54310c6598ee033af7611f63173b57a5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/73de2c1ff345ac38c098d7b1bef03176f3ea1f16",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/73de2c1ff345ac38c098d7b1bef03176f3ea1f16",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/73de2c1ff345ac38c098d7b1bef03176f3ea1f16",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/73de2c1ff345ac38c098d7b1bef03176f3ea1f16/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "119e552f7ccd49c0137a3c6b4f94018a84d69620",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/119e552f7ccd49c0137a3c6b4f94018a84d69620",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/119e552f7ccd49c0137a3c6b4f94018a84d69620"
      }
    ],
    "stats": {
      "total": 66,
      "additions": 33,
      "deletions": 33
    },
    "files": [
      {
        "sha": "a6b08b4fe3545fbdf101aa78202f1a89dfa05b66",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/73de2c1ff345ac38c098d7b1bef03176f3ea1f16/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/73de2c1ff345ac38c098d7b1bef03176f3ea1f16/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=73de2c1ff345ac38c098d7b1bef03176f3ea1f16",
        "patch": "@@ -42,19 +42,19 @@ CCoinsMap::iterator CCoinsViewCache::FetchCoins(const COutPoint &outpoint) const\n     if (!base->GetCoins(outpoint, tmp))\n         return cacheCoins.end();\n     CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first;\n-    if (ret->second.coins.IsPruned()) {\n+    if (ret->second.coin.IsPruned()) {\n         // The parent only has an empty entry for this outpoint; we can consider our\n         // version as fresh.\n         ret->second.flags = CCoinsCacheEntry::FRESH;\n     }\n-    cachedCoinsUsage += ret->second.coins.DynamicMemoryUsage();\n+    cachedCoinsUsage += ret->second.coin.DynamicMemoryUsage();\n     return ret;\n }\n \n bool CCoinsViewCache::GetCoins(const COutPoint &outpoint, Coin &coin) const {\n     CCoinsMap::const_iterator it = FetchCoins(outpoint);\n     if (it != cacheCoins.end()) {\n-        coin = it->second.coins;\n+        coin = it->second.coin;\n         return true;\n     }\n     return false;\n@@ -68,17 +68,17 @@ void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possi\n     std::tie(it, inserted) = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::tuple<>());\n     bool fresh = false;\n     if (!inserted) {\n-        cachedCoinsUsage -= it->second.coins.DynamicMemoryUsage();\n+        cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n     }\n     if (!possible_overwrite) {\n-        if (!it->second.coins.IsPruned()) {\n+        if (!it->second.coin.IsPruned()) {\n             throw std::logic_error(\"Adding new coin that replaces non-pruned entry\");\n         }\n         fresh = !(it->second.flags & CCoinsCacheEntry::DIRTY);\n     }\n-    it->second.coins = std::move(coin);\n+    it->second.coin = std::move(coin);\n     it->second.flags |= CCoinsCacheEntry::DIRTY | (fresh ? CCoinsCacheEntry::FRESH : 0);\n-    cachedCoinsUsage += it->second.coins.DynamicMemoryUsage();\n+    cachedCoinsUsage += it->second.coin.DynamicMemoryUsage();\n }\n \n void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight) {\n@@ -94,15 +94,15 @@ void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight) {\n void CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n     CCoinsMap::iterator it = FetchCoins(outpoint);\n     if (it == cacheCoins.end()) return;\n-    cachedCoinsUsage -= it->second.coins.DynamicMemoryUsage();\n+    cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n     if (moveout) {\n-        *moveout = std::move(it->second.coins);\n+        *moveout = std::move(it->second.coin);\n     }\n     if (it->second.flags & CCoinsCacheEntry::FRESH) {\n         cacheCoins.erase(it);\n     } else {\n         it->second.flags |= CCoinsCacheEntry::DIRTY;\n-        it->second.coins.Clear();\n+        it->second.coin.Clear();\n     }\n }\n \n@@ -113,13 +113,13 @@ const Coin& CCoinsViewCache::AccessCoin(const COutPoint &outpoint) const {\n     if (it == cacheCoins.end()) {\n         return coinEmpty;\n     } else {\n-        return it->second.coins;\n+        return it->second.coin;\n     }\n }\n \n bool CCoinsViewCache::HaveCoins(const COutPoint &outpoint) const {\n     CCoinsMap::const_iterator it = FetchCoins(outpoint);\n-    return (it != cacheCoins.end() && !it->second.coins.IsPruned());\n+    return (it != cacheCoins.end() && !it->second.coin.IsPruned());\n }\n \n bool CCoinsViewCache::HaveCoinsInCache(const COutPoint &outpoint) const {\n@@ -144,12 +144,12 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n             if (itUs == cacheCoins.end()) {\n                 // The parent cache does not have an entry, while the child does\n                 // We can ignore it if it's both FRESH and pruned in the child\n-                if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coins.IsPruned())) {\n+                if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coin.IsPruned())) {\n                     // Otherwise we will need to create it in the parent\n                     // and move the data up and mark it as dirty\n                     CCoinsCacheEntry& entry = cacheCoins[it->first];\n-                    entry.coins = std::move(it->second.coins);\n-                    cachedCoinsUsage += entry.coins.DynamicMemoryUsage();\n+                    entry.coin = std::move(it->second.coin);\n+                    cachedCoinsUsage += entry.coin.DynamicMemoryUsage();\n                     entry.flags = CCoinsCacheEntry::DIRTY;\n                     // We can mark it FRESH in the parent if it was FRESH in the child\n                     // Otherwise it might have just been flushed from the parent's cache\n@@ -162,21 +162,21 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n                 // parent cache entry has unspent outputs. If this ever happens,\n                 // it means the FRESH flag was misapplied and there is a logic\n                 // error in the calling code.\n-                if ((it->second.flags & CCoinsCacheEntry::FRESH) && !itUs->second.coins.IsPruned())\n+                if ((it->second.flags & CCoinsCacheEntry::FRESH) && !itUs->second.coin.IsPruned())\n                     throw std::logic_error(\"FRESH flag misapplied to cache entry for base transaction with spendable outputs\");\n \n                 // Found the entry in the parent cache\n-                if ((itUs->second.flags & CCoinsCacheEntry::FRESH) && it->second.coins.IsPruned()) {\n+                if ((itUs->second.flags & CCoinsCacheEntry::FRESH) && it->second.coin.IsPruned()) {\n                     // The grandparent does not have an entry, and the child is\n                     // modified and being pruned. This means we can just delete\n                     // it from the parent.\n-                    cachedCoinsUsage -= itUs->second.coins.DynamicMemoryUsage();\n+                    cachedCoinsUsage -= itUs->second.coin.DynamicMemoryUsage();\n                     cacheCoins.erase(itUs);\n                 } else {\n                     // A normal modification.\n-                    cachedCoinsUsage -= itUs->second.coins.DynamicMemoryUsage();\n-                    itUs->second.coins = std::move(it->second.coins);\n-                    cachedCoinsUsage += itUs->second.coins.DynamicMemoryUsage();\n+                    cachedCoinsUsage -= itUs->second.coin.DynamicMemoryUsage();\n+                    itUs->second.coin = std::move(it->second.coin);\n+                    cachedCoinsUsage += itUs->second.coin.DynamicMemoryUsage();\n                     itUs->second.flags |= CCoinsCacheEntry::DIRTY;\n                     // NOTE: It is possible the child has a FRESH flag here in\n                     // the event the entry we found in the parent is pruned. But\n@@ -204,7 +204,7 @@ void CCoinsViewCache::Uncache(const COutPoint& hash)\n {\n     CCoinsMap::iterator it = cacheCoins.find(hash);\n     if (it != cacheCoins.end() && it->second.flags == 0) {\n-        cachedCoinsUsage -= it->second.coins.DynamicMemoryUsage();\n+        cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n         cacheCoins.erase(it);\n     }\n }"
      },
      {
        "sha": "294abb6782b0c68de9a7fc159a27e33791d93bf6",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/73de2c1ff345ac38c098d7b1bef03176f3ea1f16/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/73de2c1ff345ac38c098d7b1bef03176f3ea1f16/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=73de2c1ff345ac38c098d7b1bef03176f3ea1f16",
        "patch": "@@ -103,7 +103,7 @@ class SaltedOutpointHasher\n \n struct CCoinsCacheEntry\n {\n-    Coin coins; // The actual cached data.\n+    Coin coin; // The actual cached data.\n     unsigned char flags;\n \n     enum Flags {\n@@ -117,7 +117,7 @@ struct CCoinsCacheEntry\n     };\n \n     CCoinsCacheEntry() : flags(0) {}\n-    explicit CCoinsCacheEntry(Coin&& coin_) : coins(std::move(coin_)), flags(0) {}\n+    explicit CCoinsCacheEntry(Coin&& coin_) : coin(std::move(coin_)), flags(0) {}\n };\n \n typedef std::unordered_map<COutPoint, CCoinsCacheEntry, SaltedOutpointHasher> CCoinsMap;"
      },
      {
        "sha": "53e01636c35368d6c585a140a8a768d3399162bf",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/73de2c1ff345ac38c098d7b1bef03176f3ea1f16/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/73de2c1ff345ac38c098d7b1bef03176f3ea1f16/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=73de2c1ff345ac38c098d7b1bef03176f3ea1f16",
        "patch": "@@ -64,8 +64,8 @@ class CCoinsViewTest : public CCoinsView\n         for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end(); ) {\n             if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n                 // Same optimization used in CCoinsViewDB is to only write dirty entries.\n-                map_[it->first] = it->second.coins;\n-                if (it->second.coins.IsPruned() && insecure_rand() % 3 == 0) {\n+                map_[it->first] = it->second.coin;\n+                if (it->second.coin.IsPruned() && insecure_rand() % 3 == 0) {\n                     // Randomly delete empty entries on write.\n                     map_.erase(it->first);\n                 }\n@@ -89,7 +89,7 @@ class CCoinsViewCacheTest : public CCoinsViewCache\n         size_t ret = memusage::DynamicUsage(cacheCoins);\n         size_t count = 0;\n         for (CCoinsMap::iterator it = cacheCoins.begin(); it != cacheCoins.end(); it++) {\n-            ret += it->second.coins.DynamicMemoryUsage();\n+            ret += it->second.coin.DynamicMemoryUsage();\n             ++count;\n         }\n         BOOST_CHECK_EQUAL(GetCacheSize(), count);\n@@ -554,10 +554,10 @@ size_t InsertCoinsMapEntry(CCoinsMap& map, CAmount value, char flags)\n     assert(flags != NO_ENTRY);\n     CCoinsCacheEntry entry;\n     entry.flags = flags;\n-    SetCoinsValue(value, entry.coins);\n+    SetCoinsValue(value, entry.coin);\n     auto inserted = map.emplace(OUTPOINT, std::move(entry));\n     assert(inserted.second);\n-    return inserted.first->second.coins.DynamicMemoryUsage();\n+    return inserted.first->second.coin.DynamicMemoryUsage();\n }\n \n void GetCoinsMapEntry(const CCoinsMap& map, CAmount& value, char& flags)\n@@ -567,10 +567,10 @@ void GetCoinsMapEntry(const CCoinsMap& map, CAmount& value, char& flags)\n         value = ABSENT;\n         flags = NO_ENTRY;\n     } else {\n-        if (it->second.coins.IsPruned()) {\n+        if (it->second.coin.IsPruned()) {\n             value = PRUNED;\n         } else {\n-            value = it->second.coins.out.nValue;\n+            value = it->second.coin.out.nValue;\n         }\n         flags = it->second.flags;\n         assert(flags != NO_ENTRY);"
      },
      {
        "sha": "45a7d69a36cc9faa5c90c0a226efda8479afd8ba",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/73de2c1ff345ac38c098d7b1bef03176f3ea1f16/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/73de2c1ff345ac38c098d7b1bef03176f3ea1f16/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=73de2c1ff345ac38c098d7b1bef03176f3ea1f16",
        "patch": "@@ -75,10 +75,10 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n             CoinsEntry entry(&it->first);\n-            if (it->second.coins.IsPruned())\n+            if (it->second.coin.IsPruned())\n                 batch.Erase(entry);\n             else\n-                batch.Write(entry, it->second.coins);\n+                batch.Write(entry, it->second.coin);\n             changed++;\n         }\n         count++;"
      }
    ]
  },
  {
    "sha": "a5e02bc7f8a1af27fcafd892d8da651e8f1ab156",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNWUwMmJjN2Y4YTFhZjI3ZmNhZmQ4OTJkOGRhNjUxZThmMWFiMTU2",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-21T19:30:38Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T20:15:25Z"
      },
      "message": "Increase travis unit test timeout",
      "tree": {
        "sha": "db492457b5bdfb0346b8a59998f2746dba7a969c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/db492457b5bdfb0346b8a59998f2746dba7a969c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a5e02bc7f8a1af27fcafd892d8da651e8f1ab156",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5e02bc7f8a1af27fcafd892d8da651e8f1ab156",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a5e02bc7f8a1af27fcafd892d8da651e8f1ab156",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5e02bc7f8a1af27fcafd892d8da651e8f1ab156/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "73de2c1ff345ac38c098d7b1bef03176f3ea1f16",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/73de2c1ff345ac38c098d7b1bef03176f3ea1f16",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/73de2c1ff345ac38c098d7b1bef03176f3ea1f16"
      }
    ],
    "stats": {
      "total": 2,
      "additions": 1,
      "deletions": 1
    },
    "files": [
      {
        "sha": "a9b246536e5bee0f2a011393a49c64d7a4f9e5f5",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a5e02bc7f8a1af27fcafd892d8da651e8f1ab156/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a5e02bc7f8a1af27fcafd892d8da651e8f1ab156/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=a5e02bc7f8a1af27fcafd892d8da651e8f1ab156",
        "patch": "@@ -69,7 +69,7 @@ script:\n     - ./configure --cache-file=../config.cache $BITCOIN_CONFIG_ALL $BITCOIN_CONFIG || ( cat config.log && false)\n     - make $MAKEJOBS $GOAL || ( echo \"Build failure. Verbose build follows.\" && make $GOAL V=1 ; false )\n     - export LD_LIBRARY_PATH=$TRAVIS_BUILD_DIR/depends/$HOST/lib\n-    - if [ \"$RUN_TESTS\" = \"true\" ]; then make $MAKEJOBS check VERBOSE=1; fi\n+    - if [ \"$RUN_TESTS\" = \"true\" ]; then travis_wait 30 make $MAKEJOBS check VERBOSE=1; fi\n     - if [ \"$TRAVIS_EVENT_TYPE\" = \"cron\" ]; then extended=\"--extended --exclude pruning\"; fi\n     - if [ \"$RUN_TESTS\" = \"true\" ]; then test/functional/test_runner.py --coverage --quiet ${extended}; fi\n after_script:"
      }
    ]
  },
  {
    "sha": "589827975f9f241e2f23eb674a7383592bff1cad",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1ODk4Mjc5NzVmOWYyNDFlMmYyM2ViNjc0YTczODM1OTJiZmYxY2Fk",
    "commit": {
      "author": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-05-31T00:58:54Z"
      },
      "committer": {
        "name": "Pieter Wuille",
        "email": "pieter.wuille@gmail.com",
        "date": "2017-06-01T20:15:25Z"
      },
      "message": "scripted-diff: various renames for per-utxo consistency\n\nThanks to John Newberry for pointing these out.\n\n-BEGIN VERIFY SCRIPT-\nsed -i 's/\\<GetCoins\\>/GetCoin/g' src/*.cpp src/*.h src/*/*.cpp src/*/*.h\nsed -i 's/\\<HaveCoins\\>/HaveCoin/g' src/*.cpp src/*.h src/*/*.cpp src/*/*.h\nsed -i 's/\\<HaveCoinsInCache\\>/HaveCoinInCache/g' src/*.cpp src/*.h src/*/*.cpp src/*/*.h\nsed -i 's/\\<IsPruned\\>/IsSpent/g' src/*.cpp src/*.h src/*/*.cpp src/*/*.h\nsed -i 's/\\<FetchCoins\\>/FetchCoin/g' src/*.cpp src/*.h src/*/*.cpp src/*/*.h\nsed -i 's/\\<CoinsEntry\\>/CoinEntry/g' src/*.cpp src/*.h src/*/*.cpp src/*/*.h\nsed -i 's/\\<vHashTxnToUncache\\>/coins_to_uncache/g' src/*.cpp src/*.h src/*/*.cpp src/*/*.h\nsed -i 's/\\<vHashTxToUncache\\>/coins_to_uncache/g' src/*.cpp src/*.h src/*/*.cpp src/*/*.h\nsed -i 's/\\<fHadTxInCache\\>/had_coin_in_cache/g' src/*.cpp src/*.h src/*/*.cpp src/*/*.h\nsed -i 's/\\<coinbaseids\\>/coinbase_coins/g' src/*.cpp src/*.h src/*/*.cpp src/*/*.h\nsed -i 's/\\<disconnectedids\\>/disconnected_coins/g' src/*.cpp src/*.h src/*/*.cpp src/*/*.h\nsed -i 's/\\<duplicateids\\>/duplicate_coins/g' src/*.cpp src/*.h src/*/*.cpp src/*/*.h\nsed -i 's/\\<oldcoins\\>/old_coin/g' src/test/coins_tests.cpp\nsed -i 's/\\<origcoins\\>/orig_coin/g' src/*.cpp src/*.h src/*/*.cpp src/*/*.h\n-END VERIFY SCRIPT-",
      "tree": {
        "sha": "deb06b310de4bc57ae18cc4dd763fe0146ddae6c",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/deb06b310de4bc57ae18cc4dd763fe0146ddae6c"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/589827975f9f241e2f23eb674a7383592bff1cad",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/589827975f9f241e2f23eb674a7383592bff1cad",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/589827975f9f241e2f23eb674a7383592bff1cad",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/589827975f9f241e2f23eb674a7383592bff1cad/comments",
    "author": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "sipa",
      "id": 548488,
      "node_id": "MDQ6VXNlcjU0ODQ4OA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/548488?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/sipa",
      "html_url": "https://github.com/sipa",
      "followers_url": "https://api.github.com/users/sipa/followers",
      "following_url": "https://api.github.com/users/sipa/following{/other_user}",
      "gists_url": "https://api.github.com/users/sipa/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/sipa/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/sipa/subscriptions",
      "organizations_url": "https://api.github.com/users/sipa/orgs",
      "repos_url": "https://api.github.com/users/sipa/repos",
      "events_url": "https://api.github.com/users/sipa/events{/privacy}",
      "received_events_url": "https://api.github.com/users/sipa/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "a5e02bc7f8a1af27fcafd892d8da651e8f1ab156",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a5e02bc7f8a1af27fcafd892d8da651e8f1ab156",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/a5e02bc7f8a1af27fcafd892d8da651e8f1ab156"
      }
    ],
    "stats": {
      "total": 264,
      "additions": 132,
      "deletions": 132
    },
    "files": [
      {
        "sha": "cf280f485cb93c2634d20747c3133df158139ea1",
        "filename": "src/bitcoin-tx.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/bitcoin-tx.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/bitcoin-tx.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/bitcoin-tx.cpp?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -562,7 +562,7 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n \n             {\n                 const Coin& coin = view.AccessCoin(out);\n-                if (!coin.IsPruned() && coin.out.scriptPubKey != scriptPubKey) {\n+                if (!coin.IsSpent() && coin.out.scriptPubKey != scriptPubKey) {\n                     std::string err(\"Previous output scriptPubKey mismatch:\\n\");\n                     err = err + ScriptToAsmStr(coin.out.scriptPubKey) + \"\\nvs:\\n\"+\n                         ScriptToAsmStr(scriptPubKey);\n@@ -598,7 +598,7 @@ static void MutateTxSign(CMutableTransaction& tx, const std::string& flagStr)\n     for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n         CTxIn& txin = mergedTx.vin[i];\n         const Coin& coin = view.AccessCoin(txin.prevout);\n-        if (coin.IsPruned()) {\n+        if (coin.IsSpent()) {\n             fComplete = false;\n             continue;\n         }"
      },
      {
        "sha": "5b7c56267839b2e10a5fb5cc11e3fcc31df54960",
        "filename": "src/coins.cpp",
        "status": "modified",
        "additions": 22,
        "deletions": 22,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/coins.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/coins.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.cpp?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -10,16 +10,16 @@\n \n #include <assert.h>\n \n-bool CCoinsView::GetCoins(const COutPoint &outpoint, Coin &coin) const { return false; }\n-bool CCoinsView::HaveCoins(const COutPoint &outpoint) const { return false; }\n+bool CCoinsView::GetCoin(const COutPoint &outpoint, Coin &coin) const { return false; }\n+bool CCoinsView::HaveCoin(const COutPoint &outpoint) const { return false; }\n uint256 CCoinsView::GetBestBlock() const { return uint256(); }\n bool CCoinsView::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return false; }\n CCoinsViewCursor *CCoinsView::Cursor() const { return 0; }\n \n \n CCoinsViewBacked::CCoinsViewBacked(CCoinsView *viewIn) : base(viewIn) { }\n-bool CCoinsViewBacked::GetCoins(const COutPoint &outpoint, Coin &coin) const { return base->GetCoins(outpoint, coin); }\n-bool CCoinsViewBacked::HaveCoins(const COutPoint &outpoint) const { return base->HaveCoins(outpoint); }\n+bool CCoinsViewBacked::GetCoin(const COutPoint &outpoint, Coin &coin) const { return base->GetCoin(outpoint, coin); }\n+bool CCoinsViewBacked::HaveCoin(const COutPoint &outpoint) const { return base->HaveCoin(outpoint); }\n uint256 CCoinsViewBacked::GetBestBlock() const { return base->GetBestBlock(); }\n void CCoinsViewBacked::SetBackend(CCoinsView &viewIn) { base = &viewIn; }\n bool CCoinsViewBacked::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) { return base->BatchWrite(mapCoins, hashBlock); }\n@@ -34,15 +34,15 @@ size_t CCoinsViewCache::DynamicMemoryUsage() const {\n     return memusage::DynamicUsage(cacheCoins) + cachedCoinsUsage;\n }\n \n-CCoinsMap::iterator CCoinsViewCache::FetchCoins(const COutPoint &outpoint) const {\n+CCoinsMap::iterator CCoinsViewCache::FetchCoin(const COutPoint &outpoint) const {\n     CCoinsMap::iterator it = cacheCoins.find(outpoint);\n     if (it != cacheCoins.end())\n         return it;\n     Coin tmp;\n-    if (!base->GetCoins(outpoint, tmp))\n+    if (!base->GetCoin(outpoint, tmp))\n         return cacheCoins.end();\n     CCoinsMap::iterator ret = cacheCoins.emplace(std::piecewise_construct, std::forward_as_tuple(outpoint), std::forward_as_tuple(std::move(tmp))).first;\n-    if (ret->second.coin.IsPruned()) {\n+    if (ret->second.coin.IsSpent()) {\n         // The parent only has an empty entry for this outpoint; we can consider our\n         // version as fresh.\n         ret->second.flags = CCoinsCacheEntry::FRESH;\n@@ -51,8 +51,8 @@ CCoinsMap::iterator CCoinsViewCache::FetchCoins(const COutPoint &outpoint) const\n     return ret;\n }\n \n-bool CCoinsViewCache::GetCoins(const COutPoint &outpoint, Coin &coin) const {\n-    CCoinsMap::const_iterator it = FetchCoins(outpoint);\n+bool CCoinsViewCache::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n+    CCoinsMap::const_iterator it = FetchCoin(outpoint);\n     if (it != cacheCoins.end()) {\n         coin = it->second.coin;\n         return true;\n@@ -61,7 +61,7 @@ bool CCoinsViewCache::GetCoins(const COutPoint &outpoint, Coin &coin) const {\n }\n \n void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possible_overwrite) {\n-    assert(!coin.IsPruned());\n+    assert(!coin.IsSpent());\n     if (coin.out.scriptPubKey.IsUnspendable()) return;\n     CCoinsMap::iterator it;\n     bool inserted;\n@@ -71,7 +71,7 @@ void CCoinsViewCache::AddCoin(const COutPoint &outpoint, Coin&& coin, bool possi\n         cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n     }\n     if (!possible_overwrite) {\n-        if (!it->second.coin.IsPruned()) {\n+        if (!it->second.coin.IsSpent()) {\n             throw std::logic_error(\"Adding new coin that replaces non-pruned entry\");\n         }\n         fresh = !(it->second.flags & CCoinsCacheEntry::DIRTY);\n@@ -92,7 +92,7 @@ void AddCoins(CCoinsViewCache& cache, const CTransaction &tx, int nHeight) {\n }\n \n void CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n-    CCoinsMap::iterator it = FetchCoins(outpoint);\n+    CCoinsMap::iterator it = FetchCoin(outpoint);\n     if (it == cacheCoins.end()) return;\n     cachedCoinsUsage -= it->second.coin.DynamicMemoryUsage();\n     if (moveout) {\n@@ -109,20 +109,20 @@ void CCoinsViewCache::SpendCoin(const COutPoint &outpoint, Coin* moveout) {\n static const Coin coinEmpty;\n \n const Coin& CCoinsViewCache::AccessCoin(const COutPoint &outpoint) const {\n-    CCoinsMap::const_iterator it = FetchCoins(outpoint);\n+    CCoinsMap::const_iterator it = FetchCoin(outpoint);\n     if (it == cacheCoins.end()) {\n         return coinEmpty;\n     } else {\n         return it->second.coin;\n     }\n }\n \n-bool CCoinsViewCache::HaveCoins(const COutPoint &outpoint) const {\n-    CCoinsMap::const_iterator it = FetchCoins(outpoint);\n-    return (it != cacheCoins.end() && !it->second.coin.IsPruned());\n+bool CCoinsViewCache::HaveCoin(const COutPoint &outpoint) const {\n+    CCoinsMap::const_iterator it = FetchCoin(outpoint);\n+    return (it != cacheCoins.end() && !it->second.coin.IsSpent());\n }\n \n-bool CCoinsViewCache::HaveCoinsInCache(const COutPoint &outpoint) const {\n+bool CCoinsViewCache::HaveCoinInCache(const COutPoint &outpoint) const {\n     CCoinsMap::const_iterator it = cacheCoins.find(outpoint);\n     return it != cacheCoins.end();\n }\n@@ -144,7 +144,7 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n             if (itUs == cacheCoins.end()) {\n                 // The parent cache does not have an entry, while the child does\n                 // We can ignore it if it's both FRESH and pruned in the child\n-                if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coin.IsPruned())) {\n+                if (!(it->second.flags & CCoinsCacheEntry::FRESH && it->second.coin.IsSpent())) {\n                     // Otherwise we will need to create it in the parent\n                     // and move the data up and mark it as dirty\n                     CCoinsCacheEntry& entry = cacheCoins[it->first];\n@@ -162,11 +162,11 @@ bool CCoinsViewCache::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlockIn\n                 // parent cache entry has unspent outputs. If this ever happens,\n                 // it means the FRESH flag was misapplied and there is a logic\n                 // error in the calling code.\n-                if ((it->second.flags & CCoinsCacheEntry::FRESH) && !itUs->second.coin.IsPruned())\n+                if ((it->second.flags & CCoinsCacheEntry::FRESH) && !itUs->second.coin.IsSpent())\n                     throw std::logic_error(\"FRESH flag misapplied to cache entry for base transaction with spendable outputs\");\n \n                 // Found the entry in the parent cache\n-                if ((itUs->second.flags & CCoinsCacheEntry::FRESH) && it->second.coin.IsPruned()) {\n+                if ((itUs->second.flags & CCoinsCacheEntry::FRESH) && it->second.coin.IsSpent()) {\n                     // The grandparent does not have an entry, and the child is\n                     // modified and being pruned. This means we can just delete\n                     // it from the parent.\n@@ -229,7 +229,7 @@ bool CCoinsViewCache::HaveInputs(const CTransaction& tx) const\n {\n     if (!tx.IsCoinBase()) {\n         for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-            if (!HaveCoins(tx.vin[i].prevout)) {\n+            if (!HaveCoin(tx.vin[i].prevout)) {\n                 return false;\n             }\n         }\n@@ -244,7 +244,7 @@ const Coin& AccessByTxid(const CCoinsViewCache& view, const uint256& txid)\n     COutPoint iter(txid, 0);\n     while (iter.n < MAX_OUTPUTS_PER_BLOCK) {\n         const Coin& alternate = view.AccessCoin(iter);\n-        if (!alternate.IsPruned()) return alternate;\n+        if (!alternate.IsSpent()) return alternate;\n         ++iter.n;\n     }\n     return coinEmpty;"
      },
      {
        "sha": "476db8f37c73b14cbb42adb58488a726e332093a",
        "filename": "src/coins.h",
        "status": "modified",
        "additions": 12,
        "deletions": 12,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/coins.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/coins.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/coins.h?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -58,7 +58,7 @@ class Coin\n \n     template<typename Stream>\n     void Serialize(Stream &s) const {\n-        assert(!IsPruned());\n+        assert(!IsSpent());\n         uint32_t code = nHeight * 2 + fCoinBase;\n         ::Serialize(s, VARINT(code));\n         ::Serialize(s, CTxOutCompressor(REF(out)));\n@@ -73,7 +73,7 @@ class Coin\n         ::Unserialize(s, REF(CTxOutCompressor(out)));\n     }\n \n-    bool IsPruned() const {\n+    bool IsSpent() const {\n         return out.IsNull();\n     }\n \n@@ -147,11 +147,11 @@ class CCoinsView\n {\n public:\n     //! Retrieve the Coin (unspent transaction output) for a given outpoint.\n-    virtual bool GetCoins(const COutPoint &outpoint, Coin &coin) const;\n+    virtual bool GetCoin(const COutPoint &outpoint, Coin &coin) const;\n \n     //! Just check whether we have data for a given outpoint.\n     //! This may (but cannot always) return true for spent outputs.\n-    virtual bool HaveCoins(const COutPoint &outpoint) const;\n+    virtual bool HaveCoin(const COutPoint &outpoint) const;\n \n     //! Retrieve the block hash whose state this CCoinsView currently represents\n     virtual uint256 GetBestBlock() const;\n@@ -179,8 +179,8 @@ class CCoinsViewBacked : public CCoinsView\n \n public:\n     CCoinsViewBacked(CCoinsView *viewIn);\n-    bool GetCoins(const COutPoint &outpoint, Coin &coin) const override;\n-    bool HaveCoins(const COutPoint &outpoint) const override;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n+    bool HaveCoin(const COutPoint &outpoint) const override;\n     uint256 GetBestBlock() const override;\n     void SetBackend(CCoinsView &viewIn);\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n@@ -207,22 +207,22 @@ class CCoinsViewCache : public CCoinsViewBacked\n     CCoinsViewCache(CCoinsView *baseIn);\n \n     // Standard CCoinsView methods\n-    bool GetCoins(const COutPoint &outpoint, Coin &coin) const;\n-    bool HaveCoins(const COutPoint &outpoint) const;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const;\n+    bool HaveCoin(const COutPoint &outpoint) const;\n     uint256 GetBestBlock() const;\n     void SetBestBlock(const uint256 &hashBlock);\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock);\n \n     /**\n      * Check if we have the given utxo already loaded in this cache.\n-     * The semantics are the same as HaveCoins(), but no calls to\n+     * The semantics are the same as HaveCoin(), but no calls to\n      * the backing CCoinsView are made.\n      */\n-    bool HaveCoinsInCache(const COutPoint &outpoint) const;\n+    bool HaveCoinInCache(const COutPoint &outpoint) const;\n \n     /**\n      * Return a reference to Coin in the cache, or a pruned one if not found. This is\n-     * more efficient than GetCoins. Modifications to other cache entries are\n+     * more efficient than GetCoin. Modifications to other cache entries are\n      * allowed while accessing the returned pointer.\n      */\n     const Coin& AccessCoin(const COutPoint &output) const;\n@@ -273,7 +273,7 @@ class CCoinsViewCache : public CCoinsViewBacked\n     bool HaveInputs(const CTransaction& tx) const;\n \n private:\n-    CCoinsMap::iterator FetchCoins(const COutPoint &outpoint) const;\n+    CCoinsMap::iterator FetchCoin(const COutPoint &outpoint) const;\n \n     /**\n      * By making the copy constructor private, we prevent accidentally using it when one intends to create a cache on top of a base cache."
      },
      {
        "sha": "bf68f8754b71739ba3aa4cc11e6180acec62fabf",
        "filename": "src/consensus/tx_verify.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/consensus/tx_verify.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/consensus/tx_verify.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/consensus/tx_verify.cpp?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -214,7 +214,7 @@ bool Consensus::CheckTxInputs(const CTransaction& tx, CValidationState& state, c\n         {\n             const COutPoint &prevout = tx.vin[i].prevout;\n             const Coin& coin = inputs.AccessCoin(prevout);\n-            assert(!coin.IsPruned());\n+            assert(!coin.IsSpent());\n \n             // If prev is coinbase, check that it's matured\n             if (coin.IsCoinBase()) {"
      },
      {
        "sha": "0c17053946ebdfe8d8ec3bb5a00d781d368c3474",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -146,9 +146,9 @@ class CCoinsViewErrorCatcher : public CCoinsViewBacked\n {\n public:\n     CCoinsViewErrorCatcher(CCoinsView* view) : CCoinsViewBacked(view) {}\n-    bool GetCoins(const COutPoint &outpoint, Coin &coin) const override {\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override {\n         try {\n-            return CCoinsViewBacked::GetCoins(outpoint, coin);\n+            return CCoinsViewBacked::GetCoin(outpoint, coin);\n         } catch(const std::runtime_error& e) {\n             uiInterface.ThreadSafeMessageBox(_(\"Error reading from database, shutting down.\"), \"\", CClientUIInterface::MSG_ERROR);\n             LogPrintf(\"Error reading from database: %s\\n\", e.what());"
      },
      {
        "sha": "971db3427c3f8fe78e78ffbca90cc0d681e0bebd",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -914,8 +914,8 @@ bool static AlreadyHave(const CInv& inv) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n             return recentRejects->contains(inv.hash) ||\n                    mempool.exists(inv.hash) ||\n                    mapOrphanTransactions.count(inv.hash) ||\n-                   pcoinsTip->HaveCoinsInCache(COutPoint(inv.hash, 0)) || // Best effort: only try output 0 and 1\n-                   pcoinsTip->HaveCoinsInCache(COutPoint(inv.hash, 1));\n+                   pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 0)) || // Best effort: only try output 0 and 1\n+                   pcoinsTip->HaveCoinInCache(COutPoint(inv.hash, 1));\n         }\n     case MSG_BLOCK:\n     case MSG_WITNESS_BLOCK:"
      },
      {
        "sha": "233fc08772170929ccb05c950bafde9edd3a17eb",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -294,7 +294,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n             COutPoint prevout = txin.prevout;\n \n             Coin prev;\n-            if(pcoinsTip->GetCoins(prevout, prev))\n+            if(pcoinsTip->GetCoin(prevout, prev))\n             {\n                 {\n                     strHTML += \"<li>\";"
      },
      {
        "sha": "b08d7153b1d0a91d1e1e3e003abff475dc36739c",
        "filename": "src/rest.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/rest.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/rest.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rest.cpp?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -514,7 +514,7 @@ static bool rest_getutxos(HTTPRequest* req, const std::string& strURIPart)\n         for (size_t i = 0; i < vOutPoints.size(); i++) {\n             bool hit = false;\n             Coin coin;\n-            if (view.GetCoins(vOutPoints[i], coin) && !mempool.isSpent(vOutPoints[i])) {\n+            if (view.GetCoin(vOutPoints[i], coin) && !mempool.isSpent(vOutPoints[i])) {\n                 hit = true;\n                 outs.emplace_back(std::move(coin));\n             }"
      },
      {
        "sha": "6440cfdadb1c022ca3c8571a51c7f63d8290c5a7",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -985,11 +985,11 @@ UniValue gettxout(const JSONRPCRequest& request)\n     if (fMempool) {\n         LOCK(mempool.cs);\n         CCoinsViewMemPool view(pcoinsTip, mempool);\n-        if (!view.GetCoins(out, coin) || mempool.isSpent(out)) { // TODO: filtering spent coins should be done by the CCoinsViewMemPool\n+        if (!view.GetCoin(out, coin) || mempool.isSpent(out)) { // TODO: filtering spent coins should be done by the CCoinsViewMemPool\n             return NullUniValue;\n         }\n     } else {\n-        if (!pcoinsTip->GetCoins(out, coin)) {\n+        if (!pcoinsTip->GetCoin(out, coin)) {\n             return NullUniValue;\n         }\n     }"
      },
      {
        "sha": "e27c2a77c763c235ee51bfb8301e6569c0728a12",
        "filename": "src/rpc/rawtransaction.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/rpc/rawtransaction.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/rpc/rawtransaction.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/rawtransaction.cpp?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -220,7 +220,7 @@ UniValue gettxoutproof(const JSONRPCRequest& request)\n         pblockindex = mapBlockIndex[hashBlock];\n     } else {\n         const Coin& coin = AccessByTxid(*pcoinsTip, oneTxid);\n-        if (!coin.IsPruned() && coin.nHeight > 0 && coin.nHeight <= chainActive.Height()) {\n+        if (!coin.IsSpent() && coin.nHeight > 0 && coin.nHeight <= chainActive.Height()) {\n             pblockindex = chainActive[coin.nHeight];\n         }\n     }\n@@ -696,7 +696,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n \n             {\n                 const Coin& coin = view.AccessCoin(out);\n-                if (!coin.IsPruned() && coin.out.scriptPubKey != scriptPubKey) {\n+                if (!coin.IsSpent() && coin.out.scriptPubKey != scriptPubKey) {\n                     std::string err(\"Previous output scriptPubKey mismatch:\\n\");\n                     err = err + ScriptToAsmStr(coin.out.scriptPubKey) + \"\\nvs:\\n\"+\n                         ScriptToAsmStr(scriptPubKey);\n@@ -768,7 +768,7 @@ UniValue signrawtransaction(const JSONRPCRequest& request)\n     for (unsigned int i = 0; i < mergedTx.vin.size(); i++) {\n         CTxIn& txin = mergedTx.vin[i];\n         const Coin& coin = view.AccessCoin(txin.prevout);\n-        if (coin.IsPruned()) {\n+        if (coin.IsSpent()) {\n             TxInErrorToJSON(txin, vErrors, \"Input not found or already spent\");\n             continue;\n         }\n@@ -848,7 +848,7 @@ UniValue sendrawtransaction(const JSONRPCRequest& request)\n     bool fHaveChain = false;\n     for (size_t o = 0; !fHaveChain && o < tx->vout.size(); o++) {\n         const Coin& existingCoin = view.AccessCoin(COutPoint(hashTx, o));\n-        fHaveChain = !existingCoin.IsPruned();\n+        fHaveChain = !existingCoin.IsSpent();\n     }\n     bool fHaveMempool = mempool.exists(hashTx);\n     if (!fHaveMempool && !fHaveChain) {"
      },
      {
        "sha": "4a4e5516953a57a6f157789d632f6decdc12f179",
        "filename": "src/test/coins_tests.cpp",
        "status": "modified",
        "additions": 45,
        "deletions": 45,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/test/coins_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/test/coins_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/coins_tests.cpp?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -25,7 +25,7 @@ namespace\n //! equality test\n bool operator==(const Coin &a, const Coin &b) {\n     // Empty Coin objects are always equal.\n-    if (a.IsPruned() && b.IsPruned()) return true;\n+    if (a.IsSpent() && b.IsSpent()) return true;\n     return a.fCoinBase == b.fCoinBase &&\n            a.nHeight == b.nHeight &&\n            a.out == b.out;\n@@ -37,24 +37,24 @@ class CCoinsViewTest : public CCoinsView\n     std::map<COutPoint, Coin> map_;\n \n public:\n-    bool GetCoins(const COutPoint& outpoint, Coin& coin) const\n+    bool GetCoin(const COutPoint& outpoint, Coin& coin) const\n     {\n         std::map<COutPoint, Coin>::const_iterator it = map_.find(outpoint);\n         if (it == map_.end()) {\n             return false;\n         }\n         coin = it->second;\n-        if (coin.IsPruned() && insecure_rand() % 2 == 0) {\n+        if (coin.IsSpent() && insecure_rand() % 2 == 0) {\n             // Randomly return false in case of an empty entry.\n             return false;\n         }\n         return true;\n     }\n \n-    bool HaveCoins(const COutPoint& outpoint) const\n+    bool HaveCoin(const COutPoint& outpoint) const\n     {\n         Coin coin;\n-        return GetCoins(outpoint, coin);\n+        return GetCoin(outpoint, coin);\n     }\n \n     uint256 GetBestBlock() const { return hashBestBlock_; }\n@@ -65,7 +65,7 @@ class CCoinsViewTest : public CCoinsView\n             if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n                 // Same optimization used in CCoinsViewDB is to only write dirty entries.\n                 map_[it->first] = it->second.coin;\n-                if (it->second.coin.IsPruned() && insecure_rand() % 3 == 0) {\n+                if (it->second.coin.IsSpent() && insecure_rand() % 3 == 0) {\n                     // Randomly delete empty entries on write.\n                     map_.erase(it->first);\n                 }\n@@ -151,20 +151,20 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n             const Coin& entry = (insecure_rand() % 500 == 0) ? AccessByTxid(*stack.back(), txid) : stack.back()->AccessCoin(COutPoint(txid, 0));\n             BOOST_CHECK(coin == entry);\n \n-            if (insecure_rand() % 5 == 0 || coin.IsPruned()) {\n+            if (insecure_rand() % 5 == 0 || coin.IsSpent()) {\n                 Coin newcoin;\n                 newcoin.out.nValue = insecure_rand();\n                 newcoin.nHeight = 1;\n-                if (insecure_rand() % 16 == 0 && coin.IsPruned()) {\n+                if (insecure_rand() % 16 == 0 && coin.IsSpent()) {\n                     newcoin.out.scriptPubKey.assign(1 + (insecure_rand() & 0x3F), OP_RETURN);\n                     BOOST_CHECK(newcoin.out.scriptPubKey.IsUnspendable());\n                     added_an_unspendable_entry = true;\n                 } else {\n                     newcoin.out.scriptPubKey.assign(insecure_rand() & 0x3F, 0); // Random sizes so we can test memory usage accounting\n-                    (coin.IsPruned() ? added_an_entry : updated_an_entry) = true;\n+                    (coin.IsSpent() ? added_an_entry : updated_an_entry) = true;\n                     coin = newcoin;\n                 }\n-                stack.back()->AddCoin(COutPoint(txid, 0), std::move(newcoin), !coin.IsPruned() || insecure_rand() & 1);\n+                stack.back()->AddCoin(COutPoint(txid, 0), std::move(newcoin), !coin.IsSpent() || insecure_rand() & 1);\n             } else {\n                 removed_an_entry = true;\n                 coin.Clear();\n@@ -177,20 +177,20 @@ BOOST_AUTO_TEST_CASE(coins_cache_simulation_test)\n             COutPoint out(txids[insecure_rand() % txids.size()], 0);\n             int cacheid = insecure_rand() % stack.size();\n             stack[cacheid]->Uncache(out);\n-            uncached_an_entry |= !stack[cacheid]->HaveCoinsInCache(out);\n+            uncached_an_entry |= !stack[cacheid]->HaveCoinInCache(out);\n         }\n \n         // Once every 1000 iterations and at the end, verify the full cache.\n         if (insecure_rand() % 1000 == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n             for (auto it = result.begin(); it != result.end(); it++) {\n-                bool have = stack.back()->HaveCoins(it->first);\n+                bool have = stack.back()->HaveCoin(it->first);\n                 const Coin& coin = stack.back()->AccessCoin(it->first);\n-                BOOST_CHECK(have == !coin.IsPruned());\n+                BOOST_CHECK(have == !coin.IsSpent());\n                 BOOST_CHECK(coin == it->second);\n-                if (coin.IsPruned()) {\n+                if (coin.IsSpent()) {\n                     missed_an_entry = true;\n                 } else {\n-                    BOOST_CHECK(stack.back()->HaveCoinsInCache(it->first));\n+                    BOOST_CHECK(stack.back()->HaveCoinInCache(it->first));\n                     found_an_entry = true;\n                 }\n             }\n@@ -281,9 +281,9 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n     stack.push_back(new CCoinsViewCacheTest(&base)); // Start with one cache.\n \n     // Track the txids we've used in various sets\n-    std::set<COutPoint> coinbaseids;\n-    std::set<COutPoint> disconnectedids;\n-    std::set<COutPoint> duplicateids;\n+    std::set<COutPoint> coinbase_coins;\n+    std::set<COutPoint> disconnected_coins;\n+    std::set<COutPoint> duplicate_coins;\n     std::set<COutPoint> utxoset;\n \n     for (unsigned int i = 0; i < NUM_SIMULATION_ITERATIONS; i++) {\n@@ -297,22 +297,22 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n             tx.vout[0].nValue = i; //Keep txs unique unless intended to duplicate\n             tx.vout[0].scriptPubKey.assign(insecure_rand() & 0x3F, 0); // Random sizes so we can test memory usage accounting\n             unsigned int height = insecure_rand();\n-            Coin oldcoins;\n+            Coin old_coin;\n \n             // 2/20 times create a new coinbase\n-            if (randiter % 20 < 2 || coinbaseids.size() < 10) {\n+            if (randiter % 20 < 2 || coinbase_coins.size() < 10) {\n                 // 1/10 of those times create a duplicate coinbase\n-                if (insecure_rand() % 10 == 0 && coinbaseids.size()) {\n-                    auto utxod = FindRandomFrom(coinbaseids);\n+                if (insecure_rand() % 10 == 0 && coinbase_coins.size()) {\n+                    auto utxod = FindRandomFrom(coinbase_coins);\n                     // Reuse the exact same coinbase\n                     tx = std::get<0>(utxod->second);\n                     // shouldn't be available for reconnection if its been duplicated\n-                    disconnectedids.erase(utxod->first);\n+                    disconnected_coins.erase(utxod->first);\n \n-                    duplicateids.insert(utxod->first);\n+                    duplicate_coins.insert(utxod->first);\n                 }\n                 else {\n-                    coinbaseids.insert(COutPoint(tx.GetHash(), 0));\n+                    coinbase_coins.insert(COutPoint(tx.GetHash(), 0));\n                 }\n                 assert(CTransaction(tx).IsCoinBase());\n             }\n@@ -322,21 +322,21 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n \n                 COutPoint prevout;\n                 // 1/20 times reconnect a previously disconnected tx\n-                if (randiter % 20 == 2 && disconnectedids.size()) {\n-                    auto utxod = FindRandomFrom(disconnectedids);\n+                if (randiter % 20 == 2 && disconnected_coins.size()) {\n+                    auto utxod = FindRandomFrom(disconnected_coins);\n                     tx = std::get<0>(utxod->second);\n                     prevout = tx.vin[0].prevout;\n                     if (!CTransaction(tx).IsCoinBase() && !utxoset.count(prevout)) {\n-                        disconnectedids.erase(utxod->first);\n+                        disconnected_coins.erase(utxod->first);\n                         continue;\n                     }\n \n                     // If this tx is already IN the UTXO, then it must be a coinbase, and it must be a duplicate\n                     if (utxoset.count(utxod->first)) {\n                         assert(CTransaction(tx).IsCoinBase());\n-                        assert(duplicateids.count(utxod->first));\n+                        assert(duplicate_coins.count(utxod->first));\n                     }\n-                    disconnectedids.erase(utxod->first);\n+                    disconnected_coins.erase(utxod->first);\n                 }\n \n                 // 16/20 times create a regular tx\n@@ -349,15 +349,15 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n                     assert(!CTransaction(tx).IsCoinBase());\n                 }\n                 // In this simple test coins only have two states, spent or unspent, save the unspent state to restore\n-                oldcoins = result[prevout];\n+                old_coin = result[prevout];\n                 // Update the expected result of prevouthash to know these coins are spent\n                 result[prevout].Clear();\n \n                 utxoset.erase(prevout);\n \n                 // The test is designed to ensure spending a duplicate coinbase will work properly\n                 // if that ever happens and not resurrect the previously overwritten coinbase\n-                if (duplicateids.count(prevout)) {\n+                if (duplicate_coins.count(prevout)) {\n                     spent_a_duplicate_coinbase = true;\n                 }\n \n@@ -375,21 +375,21 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n             utxoset.insert(outpoint);\n \n             // Track this tx and undo info to use later\n-            utxoData.emplace(outpoint, std::make_tuple(tx,undo,oldcoins));\n+            utxoData.emplace(outpoint, std::make_tuple(tx,undo,old_coin));\n         } else if (utxoset.size()) {\n             //1/20 times undo a previous transaction\n             auto utxod = FindRandomFrom(utxoset);\n \n             CTransaction &tx = std::get<0>(utxod->second);\n             CTxUndo &undo = std::get<1>(utxod->second);\n-            Coin &origcoins = std::get<2>(utxod->second);\n+            Coin &orig_coin = std::get<2>(utxod->second);\n \n             // Update the expected result\n             // Remove new outputs\n             result[utxod->first].Clear();\n             // If not coinbase restore prevout\n             if (!tx.IsCoinBase()) {\n-                result[tx.vin[0].prevout] = origcoins;\n+                result[tx.vin[0].prevout] = orig_coin;\n             }\n \n             // Disconnect the tx from the current UTXO\n@@ -403,7 +403,7 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n                 ApplyTxInUndo(std::move(coin), *(stack.back()), out);\n             }\n             // Store as a candidate for reconnection\n-            disconnectedids.insert(utxod->first);\n+            disconnected_coins.insert(utxod->first);\n \n             // Update the utxoset\n             utxoset.erase(utxod->first);\n@@ -414,9 +414,9 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n         // Once every 1000 iterations and at the end, verify the full cache.\n         if (insecure_rand() % 1000 == 1 || i == NUM_SIMULATION_ITERATIONS - 1) {\n             for (auto it = result.begin(); it != result.end(); it++) {\n-                bool have = stack.back()->HaveCoins(it->first);\n+                bool have = stack.back()->HaveCoin(it->first);\n                 const Coin& coin = stack.back()->AccessCoin(it->first);\n-                BOOST_CHECK(have == !coin.IsPruned());\n+                BOOST_CHECK(have == !coin.IsSpent());\n                 BOOST_CHECK(coin == it->second);\n             }\n         }\n@@ -425,11 +425,11 @@ BOOST_AUTO_TEST_CASE(updatecoins_simulation_test)\n         if (utxoset.size() > 1 && insecure_rand() % 30) {\n             stack[insecure_rand() % stack.size()]->Uncache(FindRandomFrom(utxoset)->first);\n         }\n-        if (disconnectedids.size() > 1 && insecure_rand() % 30) {\n-            stack[insecure_rand() % stack.size()]->Uncache(FindRandomFrom(disconnectedids)->first);\n+        if (disconnected_coins.size() > 1 && insecure_rand() % 30) {\n+            stack[insecure_rand() % stack.size()]->Uncache(FindRandomFrom(disconnected_coins)->first);\n         }\n-        if (duplicateids.size() > 1 && insecure_rand() % 30) {\n-            stack[insecure_rand() % stack.size()]->Uncache(FindRandomFrom(duplicateids)->first);\n+        if (duplicate_coins.size() > 1 && insecure_rand() % 30) {\n+            stack[insecure_rand() % stack.size()]->Uncache(FindRandomFrom(duplicate_coins)->first);\n         }\n \n         if (insecure_rand() % 100 == 0) {\n@@ -537,11 +537,11 @@ void SetCoinsValue(CAmount value, Coin& coin)\n {\n     assert(value != ABSENT);\n     coin.Clear();\n-    assert(coin.IsPruned());\n+    assert(coin.IsSpent());\n     if (value != PRUNED) {\n         coin.out.nValue = value;\n         coin.nHeight = 1;\n-        assert(!coin.IsPruned());\n+        assert(!coin.IsSpent());\n     }\n }\n \n@@ -567,7 +567,7 @@ void GetCoinsMapEntry(const CCoinsMap& map, CAmount& value, char& flags)\n         value = ABSENT;\n         flags = NO_ENTRY;\n     } else {\n-        if (it->second.coin.IsPruned()) {\n+        if (it->second.coin.IsSpent()) {\n             value = PRUNED;\n         } else {\n             value = it->second.coin.out.nValue;"
      },
      {
        "sha": "c8f509029324e7da3fd3d4a572401414908956a9",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -27,10 +27,10 @@ static const char DB_LAST_BLOCK = 'l';\n \n namespace {\n \n-struct CoinsEntry {\n+struct CoinEntry {\n     COutPoint* outpoint;\n     char key;\n-    CoinsEntry(const COutPoint* ptr) : outpoint(const_cast<COutPoint*>(ptr)), key(DB_COIN)  {}\n+    CoinEntry(const COutPoint* ptr) : outpoint(const_cast<COutPoint*>(ptr)), key(DB_COIN)  {}\n \n     template<typename Stream>\n     void Serialize(Stream &s) const {\n@@ -53,12 +53,12 @@ CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(Get\n {\n }\n \n-bool CCoinsViewDB::GetCoins(const COutPoint &outpoint, Coin &coin) const {\n-    return db.Read(CoinsEntry(&outpoint), coin);\n+bool CCoinsViewDB::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n+    return db.Read(CoinEntry(&outpoint), coin);\n }\n \n-bool CCoinsViewDB::HaveCoins(const COutPoint &outpoint) const {\n-    return db.Exists(CoinsEntry(&outpoint));\n+bool CCoinsViewDB::HaveCoin(const COutPoint &outpoint) const {\n+    return db.Exists(CoinEntry(&outpoint));\n }\n \n uint256 CCoinsViewDB::GetBestBlock() const {\n@@ -74,8 +74,8 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     size_t changed = 0;\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n-            CoinsEntry entry(&it->first);\n-            if (it->second.coin.IsPruned())\n+            CoinEntry entry(&it->first);\n+            if (it->second.coin.IsSpent())\n                 batch.Erase(entry);\n             else\n                 batch.Write(entry, it->second.coin);\n@@ -130,7 +130,7 @@ CCoinsViewCursor *CCoinsViewDB::Cursor() const\n     i->pcursor->Seek(DB_COIN);\n     // Cache key of first record\n     if (i->pcursor->Valid()) {\n-        CoinsEntry entry(&i->keyTmp.second);\n+        CoinEntry entry(&i->keyTmp.second);\n         i->pcursor->GetKey(entry);\n         i->keyTmp.first = entry.key;\n     } else {\n@@ -167,7 +167,7 @@ bool CCoinsViewDBCursor::Valid() const\n void CCoinsViewDBCursor::Next()\n {\n     pcursor->Next();\n-    CoinsEntry entry(&keyTmp.second);\n+    CoinEntry entry(&keyTmp.second);\n     if (!pcursor->Valid() || !pcursor->GetKey(entry)) {\n         keyTmp.first = 0; // Invalidate cached key after last record so that Valid() and GetKey() return false\n     } else {"
      },
      {
        "sha": "974dd4ebe351c42995288ab08ecf644e9dcbc2ab",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -71,8 +71,8 @@ class CCoinsViewDB : public CCoinsView\n public:\n     CCoinsViewDB(size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n \n-    bool GetCoins(const COutPoint &outpoint, Coin &coin) const override;\n-    bool HaveCoins(const COutPoint &outpoint) const override;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const override;\n+    bool HaveCoin(const COutPoint &outpoint) const override;\n     uint256 GetBestBlock() const override;\n     bool BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) override;\n     CCoinsViewCursor *Cursor() const override;"
      },
      {
        "sha": "81d213dcacc18c671a13644369f8482e0980d87f",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 7,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -525,8 +525,8 @@ void CTxMemPool::removeForReorg(const CCoinsViewCache *pcoins, unsigned int nMem\n                 if (it2 != mapTx.end())\n                     continue;\n                 const Coin &coin = pcoins->AccessCoin(txin.prevout);\n-                if (nCheckFrequency != 0) assert(!coin.IsPruned());\n-                if (coin.IsPruned() || (coin.IsCoinBase() && ((signed long)nMemPoolHeight) - coin.nHeight < COINBASE_MATURITY)) {\n+                if (nCheckFrequency != 0) assert(!coin.IsSpent());\n+                if (coin.IsSpent() || (coin.IsCoinBase() && ((signed long)nMemPoolHeight) - coin.nHeight < COINBASE_MATURITY)) {\n                     txToRemove.insert(it);\n                     break;\n                 }\n@@ -654,7 +654,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n                     parentSigOpCost += it2->GetSigOpCost();\n                 }\n             } else {\n-                assert(pcoins->HaveCoins(txin.prevout));\n+                assert(pcoins->HaveCoin(txin.prevout));\n             }\n             // Check whether its inputs are marked in mapNextTx.\n             auto it3 = mapNextTx.find(txin.prevout);\n@@ -890,7 +890,7 @@ bool CTxMemPool::HasNoInputsOf(const CTransaction &tx) const\n \n CCoinsViewMemPool::CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool& mempoolIn) : CCoinsViewBacked(baseIn), mempool(mempoolIn) { }\n \n-bool CCoinsViewMemPool::GetCoins(const COutPoint &outpoint, Coin &coin) const {\n+bool CCoinsViewMemPool::GetCoin(const COutPoint &outpoint, Coin &coin) const {\n     // If an entry in the mempool exists, always return that one, as it's guaranteed to never\n     // conflict with the underlying cache, and it cannot have pruned entries (as it contains full)\n     // transactions. First checking the underlying cache risks returning a pruned entry instead.\n@@ -903,11 +903,11 @@ bool CCoinsViewMemPool::GetCoins(const COutPoint &outpoint, Coin &coin) const {\n             return false;\n         }\n     }\n-    return (base->GetCoins(outpoint, coin) && !coin.IsPruned());\n+    return (base->GetCoin(outpoint, coin) && !coin.IsSpent());\n }\n \n-bool CCoinsViewMemPool::HaveCoins(const COutPoint &outpoint) const {\n-    return mempool.exists(outpoint) || base->HaveCoins(outpoint);\n+bool CCoinsViewMemPool::HaveCoin(const COutPoint &outpoint) const {\n+    return mempool.exists(outpoint) || base->HaveCoin(outpoint);\n }\n \n size_t CTxMemPool::DynamicMemoryUsage() const {"
      },
      {
        "sha": "8cbc4dc8c03c5b58efce09f02defa4c5ac14220f",
        "filename": "src/txmempool.h",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/txmempool.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/txmempool.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.h?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -679,8 +679,8 @@ class CCoinsViewMemPool : public CCoinsViewBacked\n \n public:\n     CCoinsViewMemPool(CCoinsView* baseIn, const CTxMemPool& mempoolIn);\n-    bool GetCoins(const COutPoint &outpoint, Coin &coin) const;\n-    bool HaveCoins(const COutPoint &outpoint) const;\n+    bool GetCoin(const COutPoint &outpoint, Coin &coin) const;\n+    bool HaveCoin(const COutPoint &outpoint) const;\n };\n \n #endif // BITCOIN_TXMEMPOOL_H"
      },
      {
        "sha": "842abf5fb168925f4fbaab433a82a24c18b37842",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 17,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/589827975f9f241e2f23eb674a7383592bff1cad/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/589827975f9f241e2f23eb674a7383592bff1cad/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=589827975f9f241e2f23eb674a7383592bff1cad",
        "patch": "@@ -269,7 +269,7 @@ bool CheckSequenceLocks(const CTransaction &tx, int flags, LockPoints* lp, bool\n         for (size_t txinIndex = 0; txinIndex < tx.vin.size(); txinIndex++) {\n             const CTxIn& txin = tx.vin[txinIndex];\n             Coin coin;\n-            if (!viewMemPool.GetCoins(txin.prevout, coin)) {\n+            if (!viewMemPool.GetCoin(txin.prevout, coin)) {\n                 return error(\"%s: Missing input\", __func__);\n             }\n             if (coin.nHeight == MEMPOOL_HEIGHT) {\n@@ -344,7 +344,7 @@ static bool IsCurrentForFeeEstimation()\n \n bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx, bool fLimitFree,\n                               bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n-                              bool fOverrideMempoolLimit, const CAmount& nAbsurdFee, std::vector<COutPoint>& vHashTxnToUncache)\n+                              bool fOverrideMempoolLimit, const CAmount& nAbsurdFee, std::vector<COutPoint>& coins_to_uncache)\n {\n     const CTransaction& tx = *ptx;\n     const uint256 hash = tx.GetHash();\n@@ -439,21 +439,21 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         // do we already have it?\n         for (size_t out = 0; out < tx.vout.size(); out++) {\n             COutPoint outpoint(hash, out);\n-            bool fHadTxInCache = pcoinsTip->HaveCoinsInCache(outpoint);\n-            if (view.HaveCoins(outpoint)) {\n-                if (!fHadTxInCache) {\n-                    vHashTxnToUncache.push_back(outpoint);\n+            bool had_coin_in_cache = pcoinsTip->HaveCoinInCache(outpoint);\n+            if (view.HaveCoin(outpoint)) {\n+                if (!had_coin_in_cache) {\n+                    coins_to_uncache.push_back(outpoint);\n                 }\n                 return state.Invalid(false, REJECT_ALREADY_KNOWN, \"txn-already-known\");\n             }\n         }\n \n         // do all inputs exist?\n         BOOST_FOREACH(const CTxIn txin, tx.vin) {\n-            if (!pcoinsTip->HaveCoinsInCache(txin.prevout)) {\n-                vHashTxnToUncache.push_back(txin.prevout);\n+            if (!pcoinsTip->HaveCoinInCache(txin.prevout)) {\n+                coins_to_uncache.push_back(txin.prevout);\n             }\n-            if (!view.HaveCoins(txin.prevout)) {\n+            if (!view.HaveCoin(txin.prevout)) {\n                 if (pfMissingInputs) {\n                     *pfMissingInputs = true;\n                 }\n@@ -763,10 +763,10 @@ bool AcceptToMemoryPoolWithTime(CTxMemPool& pool, CValidationState &state, const\n                         bool* pfMissingInputs, int64_t nAcceptTime, std::list<CTransactionRef>* plTxnReplaced,\n                         bool fOverrideMempoolLimit, const CAmount nAbsurdFee)\n {\n-    std::vector<COutPoint> vHashTxToUncache;\n-    bool res = AcceptToMemoryPoolWorker(pool, state, tx, fLimitFree, pfMissingInputs, nAcceptTime, plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee, vHashTxToUncache);\n+    std::vector<COutPoint> coins_to_uncache;\n+    bool res = AcceptToMemoryPoolWorker(pool, state, tx, fLimitFree, pfMissingInputs, nAcceptTime, plTxnReplaced, fOverrideMempoolLimit, nAbsurdFee, coins_to_uncache);\n     if (!res) {\n-        BOOST_FOREACH(const COutPoint& hashTx, vHashTxToUncache)\n+        BOOST_FOREACH(const COutPoint& hashTx, coins_to_uncache)\n             pcoinsTip->Uncache(hashTx);\n     }\n     // After we've (potentially) uncached entries, ensure our coins cache is still within its size limits\n@@ -819,7 +819,7 @@ bool GetTransaction(const uint256 &hash, CTransactionRef &txOut, const Consensus\n \n     if (fAllowSlow) { // use coin database to locate block that contains transaction, and scan it\n         const Coin& coin = AccessByTxid(*pcoinsTip, hash);\n-        if (!coin.IsPruned()) pindexSlow = chainActive[coin.nHeight];\n+        if (!coin.IsSpent()) pindexSlow = chainActive[coin.nHeight];\n     }\n \n     if (pindexSlow) {\n@@ -1117,7 +1117,7 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n             for (unsigned int i = 0; i < tx.vin.size(); i++) {\n                 const COutPoint &prevout = tx.vin[i].prevout;\n                 const Coin& coin = inputs.AccessCoin(prevout);\n-                assert(!coin.IsPruned());\n+                assert(!coin.IsSpent());\n \n                 // We very carefully only pass in things to CScriptCheck which\n                 // are clearly committed to by tx' witness hash. This provides\n@@ -1254,14 +1254,14 @@ int ApplyTxInUndo(Coin&& undo, CCoinsViewCache& view, const COutPoint& out)\n {\n     bool fClean = true;\n \n-    if (view.HaveCoins(out)) fClean = false; // overwriting transaction output\n+    if (view.HaveCoin(out)) fClean = false; // overwriting transaction output\n \n     if (undo.nHeight == 0) {\n         // Missing undo metadata (height and coinbase). Older versions included this\n         // information only in undo records for the last spend of a transactions'\n         // outputs. This implies that it must be present for some other output of the same tx.\n         const Coin& alternate = AccessByTxid(view, out.hash);\n-        if (!alternate.IsPruned()) {\n+        if (!alternate.IsSpent()) {\n             undo.nHeight = alternate.nHeight;\n             undo.fCoinBase = alternate.fCoinBase;\n         } else {\n@@ -1510,7 +1510,7 @@ static bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockInd\n     if (fEnforceBIP30) {\n         for (const auto& tx : block.vtx) {\n             for (size_t o = 0; o < tx->vout.size(); o++) {\n-                if (view.HaveCoins(COutPoint(tx->GetHash(), o))) {\n+                if (view.HaveCoin(COutPoint(tx->GetHash(), o))) {\n                     return state.DoS(100, error(\"ConnectBlock(): tried to overwrite transaction\"),\n                                      REJECT_INVALID, \"bad-txns-BIP30\");\n                 }"
      }
    ]
  }
]