[
  {
    "sha": "6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YjNiYjNkOWJhZTczMGQyNmRkZDU2MWI5M2VmYzY2N2Y1YzhkNDk5",
    "commit": {
      "author": {
        "name": "Gregory Maxwell",
        "email": "greg@xiph.org",
        "date": "2016-12-25T20:19:40Z"
      },
      "committer": {
        "name": "Gregory Maxwell",
        "email": "greg@xiph.org",
        "date": "2017-04-01T18:53:29Z"
      },
      "message": "Change LogAcceptCategory to use uint32_t rather than sets of strings.\n\nThis changes the logging categories to boolean flags instead of strings.\n\nThis simplifies the acceptance testing by avoiding accessing a scoped\n static thread local pointer to a thread local set of strings.  It\n eliminates the only use of boost::thread_specific_ptr outside of\n lockorder debugging.\n\nThis change allows log entries to be directed to multiple categories\n and makes it easy to change the logging flags at runtime (e.g. via\n an RPC, though that isn't done by this commit.)\n\nIt also eliminates the fDebug global.\n\nConfiguration of unknown logging categories now produces a warning.",
      "tree": {
        "sha": "ad62375c446fb8ab80b1d39386a5266d610b7611",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ad62375c446fb8ab80b1d39386a5266d610b7611"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/comments",
    "author": {
      "login": "gmaxwell",
      "id": 858454,
      "node_id": "MDQ6VXNlcjg1ODQ1NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gmaxwell",
      "html_url": "https://github.com/gmaxwell",
      "followers_url": "https://api.github.com/users/gmaxwell/followers",
      "following_url": "https://api.github.com/users/gmaxwell/following{/other_user}",
      "gists_url": "https://api.github.com/users/gmaxwell/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
      "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
      "repos_url": "https://api.github.com/users/gmaxwell/repos",
      "events_url": "https://api.github.com/users/gmaxwell/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "gmaxwell",
      "id": 858454,
      "node_id": "MDQ6VXNlcjg1ODQ1NA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/858454?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/gmaxwell",
      "html_url": "https://github.com/gmaxwell",
      "followers_url": "https://api.github.com/users/gmaxwell/followers",
      "following_url": "https://api.github.com/users/gmaxwell/following{/other_user}",
      "gists_url": "https://api.github.com/users/gmaxwell/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/gmaxwell/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/gmaxwell/subscriptions",
      "organizations_url": "https://api.github.com/users/gmaxwell/orgs",
      "repos_url": "https://api.github.com/users/gmaxwell/repos",
      "events_url": "https://api.github.com/users/gmaxwell/events{/privacy}",
      "received_events_url": "https://api.github.com/users/gmaxwell/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "351d0ad40495d1d2a2400af4d2cc975863258d3f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/351d0ad40495d1d2a2400af4d2cc975863258d3f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/351d0ad40495d1d2a2400af4d2cc975863258d3f"
      }
    ],
    "stats": {
      "total": 650,
      "additions": 377,
      "deletions": 273
    },
    "files": [
      {
        "sha": "ed9c128eb2c0c39392df5d47ac58b90f10ce0665",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -233,7 +233,7 @@ void CAddrMan::Good_(const CService& addr, int64_t nTime)\n     if (nUBucket == -1)\n         return;\n \n-    LogPrint(\"addrman\", \"Moving %s to tried\\n\", addr.ToString());\n+    LogPrint(BCLog::ADDRMAN, \"Moving %s to tried\\n\", addr.ToString());\n \n     // move nId to the tried tables\n     MakeTried(info, nId);"
      },
      {
        "sha": "f123b20b1b23cb627677e2b03075f8d2f92563c0",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 7,
        "deletions": 5,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -442,7 +442,7 @@ class CAddrMan\n             }\n         }\n         if (nLost + nLostUnk > 0) {\n-            LogPrint(\"addrman\", \"addrman lost %i new and %i tried addresses due to collisions\\n\", nLostUnk, nLost);\n+            LogPrint(BCLog::ADDRMAN, \"addrman lost %i new and %i tried addresses due to collisions\\n\", nLostUnk, nLost);\n         }\n \n         Check();\n@@ -507,8 +507,9 @@ class CAddrMan\n         Check();\n         fRet |= Add_(addr, source, nTimePenalty);\n         Check();\n-        if (fRet)\n-            LogPrint(\"addrman\", \"Added %s from %s: %i tried, %i new\\n\", addr.ToStringIPPort(), source.ToString(), nTried, nNew);\n+        if (fRet) {\n+            LogPrint(BCLog::ADDRMAN, \"Added %s from %s: %i tried, %i new\\n\", addr.ToStringIPPort(), source.ToString(), nTried, nNew);\n+        }\n         return fRet;\n     }\n \n@@ -521,8 +522,9 @@ class CAddrMan\n         for (std::vector<CAddress>::const_iterator it = vAddr.begin(); it != vAddr.end(); it++)\n             nAdd += Add_(*it, source, nTimePenalty) ? 1 : 0;\n         Check();\n-        if (nAdd)\n-            LogPrint(\"addrman\", \"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString(), nTried, nNew);\n+        if (nAdd) {\n+            LogPrint(BCLog::ADDRMAN, \"Added %i addresses from %s: %i tried, %i new\\n\", nAdd, source.ToString(), nTried, nNew);\n+        }\n         return nAdd > 0;\n     }\n "
      },
      {
        "sha": "ee2c65498070ced771dcbe454eeb68fd10fe5aaa",
        "filename": "src/blockencodings.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 4,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/blockencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/blockencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/blockencodings.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -164,7 +164,7 @@ ReadStatus PartiallyDownloadedBlock::InitData(const CBlockHeaderAndShortTxIDs& c\n             break;\n     }\n \n-    LogPrint(\"cmpctblock\", \"Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\\n\", cmpctblock.header.GetHash().ToString(), GetSerializeSize(cmpctblock, SER_NETWORK, PROTOCOL_VERSION));\n+    LogPrint(BCLog::CMPCTBLOCK, \"Initialized PartiallyDownloadedBlock for block %s using a cmpctblock of size %lu\\n\", cmpctblock.header.GetHash().ToString(), GetSerializeSize(cmpctblock, SER_NETWORK, PROTOCOL_VERSION));\n \n     return READ_STATUS_OK;\n }\n@@ -209,10 +209,11 @@ ReadStatus PartiallyDownloadedBlock::FillBlock(CBlock& block, const std::vector<\n         return READ_STATUS_CHECKBLOCK_FAILED;\n     }\n \n-    LogPrint(\"cmpctblock\", \"Successfully reconstructed block %s with %lu txn prefilled, %lu txn from mempool (incl at least %lu from extra pool) and %lu txn requested\\n\", hash.ToString(), prefilled_count, mempool_count, extra_count, vtx_missing.size());\n+    LogPrint(BCLog::CMPCTBLOCK, \"Successfully reconstructed block %s with %lu txn prefilled, %lu txn from mempool (incl at least %lu from extra pool) and %lu txn requested\\n\", hash.ToString(), prefilled_count, mempool_count, extra_count, vtx_missing.size());\n     if (vtx_missing.size() < 5) {\n-        for (const auto& tx : vtx_missing)\n-            LogPrint(\"cmpctblock\", \"Reconstructed block %s required tx %s\\n\", hash.ToString(), tx->GetHash().ToString());\n+        for (const auto& tx : vtx_missing) {\n+            LogPrint(BCLog::CMPCTBLOCK, \"Reconstructed block %s required tx %s\\n\", hash.ToString(), tx->GetHash().ToString());\n+        }\n     }\n \n     return READ_STATUS_OK;"
      },
      {
        "sha": "01fcd07420f66e841d9dba13077dcfe136673d84",
        "filename": "src/dbwrapper.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/dbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/dbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/dbwrapper.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -21,8 +21,9 @@ class CBitcoinLevelDBLogger : public leveldb::Logger {\n     // This code is adapted from posix_logger.h, which is why it is using vsprintf.\n     // Please do not do this in normal code\n     virtual void Logv(const char * format, va_list ap) override {\n-            if (!LogAcceptCategory(\"leveldb\"))\n+            if (!LogAcceptCategory(BCLog::LEVELDB)) {\n                 return;\n+            }\n             char buffer[500];\n             for (int iter = 0; iter < 2; iter++) {\n                 char* base;"
      },
      {
        "sha": "21c64c5c839c2d353cf3158c182056c5a26715e7",
        "filename": "src/httprpc.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/httprpc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/httprpc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httprpc.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -233,7 +233,7 @@ static bool InitRPCAuthentication()\n \n bool StartHTTPRPC()\n {\n-    LogPrint(\"rpc\", \"Starting HTTP RPC server\\n\");\n+    LogPrint(BCLog::RPC, \"Starting HTTP RPC server\\n\");\n     if (!InitRPCAuthentication())\n         return false;\n \n@@ -247,12 +247,12 @@ bool StartHTTPRPC()\n \n void InterruptHTTPRPC()\n {\n-    LogPrint(\"rpc\", \"Interrupting HTTP RPC server\\n\");\n+    LogPrint(BCLog::RPC, \"Interrupting HTTP RPC server\\n\");\n }\n \n void StopHTTPRPC()\n {\n-    LogPrint(\"rpc\", \"Stopping HTTP RPC server\\n\");\n+    LogPrint(BCLog::RPC, \"Stopping HTTP RPC server\\n\");\n     UnregisterHTTPHandler(\"/\", true);\n     if (httpRPCTimerInterface) {\n         RPCUnsetTimerInterface(httpRPCTimerInterface);"
      },
      {
        "sha": "347433eb11943e274569a35072334a97448522d6",
        "filename": "src/httpserver.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 18,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/httpserver.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/httpserver.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/httpserver.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -213,7 +213,7 @@ static bool InitHTTPAllowList()\n     std::string strAllowed;\n     for (const CSubNet& subnet : rpc_allow_subnets)\n         strAllowed += subnet.ToString() + \" \";\n-    LogPrint(\"http\", \"Allowing HTTP connections from: %s\\n\", strAllowed);\n+    LogPrint(BCLog::HTTP, \"Allowing HTTP connections from: %s\\n\", strAllowed);\n     return true;\n }\n \n@@ -243,7 +243,7 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\n {\n     std::unique_ptr<HTTPRequest> hreq(new HTTPRequest(req));\n \n-    LogPrint(\"http\", \"Received a %s request for %s from %s\\n\",\n+    LogPrint(BCLog::HTTP, \"Received a %s request for %s from %s\\n\",\n              RequestMethodString(hreq->GetRequestMethod()), hreq->GetURI(), hreq->GetPeer().ToString());\n \n     // Early address-based allow check\n@@ -293,18 +293,18 @@ static void http_request_cb(struct evhttp_request* req, void* arg)\n /** Callback to reject HTTP requests after shutdown. */\n static void http_reject_request_cb(struct evhttp_request* req, void*)\n {\n-    LogPrint(\"http\", \"Rejecting request while shutting down\\n\");\n+    LogPrint(BCLog::HTTP, \"Rejecting request while shutting down\\n\");\n     evhttp_send_error(req, HTTP_SERVUNAVAIL, NULL);\n }\n \n /** Event dispatcher thread */\n static bool ThreadHTTP(struct event_base* base, struct evhttp* http)\n {\n     RenameThread(\"bitcoin-http\");\n-    LogPrint(\"http\", \"Entering http event loop\\n\");\n+    LogPrint(BCLog::HTTP, \"Entering http event loop\\n\");\n     event_base_dispatch(base);\n     // Event loop will be interrupted by InterruptHTTPServer()\n-    LogPrint(\"http\", \"Exited http event loop\\n\");\n+    LogPrint(BCLog::HTTP, \"Exited http event loop\\n\");\n     return event_base_got_break(base) == 0;\n }\n \n@@ -336,7 +336,7 @@ static bool HTTPBindAddresses(struct evhttp* http)\n \n     // Bind addresses\n     for (std::vector<std::pair<std::string, uint16_t> >::iterator i = endpoints.begin(); i != endpoints.end(); ++i) {\n-        LogPrint(\"http\", \"Binding RPC on address %s port %i\\n\", i->first, i->second);\n+        LogPrint(BCLog::HTTP, \"Binding RPC on address %s port %i\\n\", i->first, i->second);\n         evhttp_bound_socket *bind_handle = evhttp_bind_socket_with_handle(http, i->first.empty() ? NULL : i->first.c_str(), i->second);\n         if (bind_handle) {\n             boundSockets.push_back(bind_handle);\n@@ -364,7 +364,7 @@ static void libevent_log_cb(int severity, const char *msg)\n     if (severity >= EVENT_LOG_WARN) // Log warn messages and higher without debug category\n         LogPrintf(\"libevent: %s\\n\", msg);\n     else\n-        LogPrint(\"libevent\", \"libevent: %s\\n\", msg);\n+        LogPrint(BCLog::LIBEVENT, \"libevent: %s\\n\", msg);\n }\n \n bool InitHTTPServer()\n@@ -387,10 +387,11 @@ bool InitHTTPServer()\n #if LIBEVENT_VERSION_NUMBER >= 0x02010100\n     // If -debug=libevent, set full libevent debugging.\n     // Otherwise, disable all libevent debugging.\n-    if (LogAcceptCategory(\"libevent\"))\n+    if (LogAcceptCategory(BCLog::LIBEVENT)) {\n         event_enable_debug_logging(EVENT_DBG_ALL);\n-    else\n+    } else {\n         event_enable_debug_logging(EVENT_DBG_NONE);\n+    }\n #endif\n #ifdef WIN32\n     evthread_use_windows_threads();\n@@ -424,7 +425,7 @@ bool InitHTTPServer()\n         return false;\n     }\n \n-    LogPrint(\"http\", \"Initialized HTTP server\\n\");\n+    LogPrint(BCLog::HTTP, \"Initialized HTTP server\\n\");\n     int workQueueDepth = std::max((long)GetArg(\"-rpcworkqueue\", DEFAULT_HTTP_WORKQUEUE), 1L);\n     LogPrintf(\"HTTP: creating work queue of depth %d\\n\", workQueueDepth);\n \n@@ -439,7 +440,7 @@ std::future<bool> threadResult;\n \n bool StartHTTPServer()\n {\n-    LogPrint(\"http\", \"Starting HTTP server\\n\");\n+    LogPrint(BCLog::HTTP, \"Starting HTTP server\\n\");\n     int rpcThreads = std::max((long)GetArg(\"-rpcthreads\", DEFAULT_HTTP_THREADS), 1L);\n     LogPrintf(\"HTTP: starting %d worker threads\\n\", rpcThreads);\n     std::packaged_task<bool(event_base*, evhttp*)> task(ThreadHTTP);\n@@ -455,7 +456,7 @@ bool StartHTTPServer()\n \n void InterruptHTTPServer()\n {\n-    LogPrint(\"http\", \"Interrupting HTTP server\\n\");\n+    LogPrint(BCLog::HTTP, \"Interrupting HTTP server\\n\");\n     if (eventHTTP) {\n         // Unlisten sockets\n         for (evhttp_bound_socket *socket : boundSockets) {\n@@ -470,15 +471,15 @@ void InterruptHTTPServer()\n \n void StopHTTPServer()\n {\n-    LogPrint(\"http\", \"Stopping HTTP server\\n\");\n+    LogPrint(BCLog::HTTP, \"Stopping HTTP server\\n\");\n     if (workQueue) {\n-        LogPrint(\"http\", \"Waiting for HTTP worker threads to exit\\n\");\n+        LogPrint(BCLog::HTTP, \"Waiting for HTTP worker threads to exit\\n\");\n         workQueue->WaitExit();\n         delete workQueue;\n         workQueue = nullptr;\n     }\n     if (eventBase) {\n-        LogPrint(\"http\", \"Waiting for HTTP event thread to exit\\n\");\n+        LogPrint(BCLog::HTTP, \"Waiting for HTTP event thread to exit\\n\");\n         // Give event loop a few seconds to exit (to send back last RPC responses), then break it\n         // Before this was solved with event_base_loopexit, but that didn't work as expected in\n         // at least libevent 2.0.21 and always introduced a delay. In libevent\n@@ -499,7 +500,7 @@ void StopHTTPServer()\n         event_base_free(eventBase);\n         eventBase = 0;\n     }\n-    LogPrint(\"http\", \"Stopped HTTP server\\n\");\n+    LogPrint(BCLog::HTTP, \"Stopped HTTP server\\n\");\n }\n \n struct event_base* EventBase()\n@@ -646,7 +647,7 @@ HTTPRequest::RequestMethod HTTPRequest::GetRequestMethod()\n \n void RegisterHTTPHandler(const std::string &prefix, bool exactMatch, const HTTPRequestHandler &handler)\n {\n-    LogPrint(\"http\", \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+    LogPrint(BCLog::HTTP, \"Registering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n     pathHandlers.push_back(HTTPPathHandler(prefix, exactMatch, handler));\n }\n \n@@ -659,7 +660,7 @@ void UnregisterHTTPHandler(const std::string &prefix, bool exactMatch)\n             break;\n     if (i != iend)\n     {\n-        LogPrint(\"http\", \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n+        LogPrint(BCLog::HTTP, \"Unregistering HTTP handler for %s (exactmatch %d)\\n\", prefix, exactMatch);\n         pathHandlers.erase(i);\n     }\n }"
      },
      {
        "sha": "23a15b4fd8ae028b382a93051d54d9494e29b179",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 16,
        "deletions": 12,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -312,7 +312,7 @@ void OnRPCStopped()\n     uiInterface.NotifyBlockTip.disconnect(&RPCNotifyBlockChange);\n     RPCNotifyBlockChange(false, nullptr);\n     cvBlockChange.notify_all();\n-    LogPrint(\"rpc\", \"RPC stopped.\\n\");\n+    LogPrint(BCLog::RPC, \"RPC stopped.\\n\");\n }\n \n void OnRPCPreCommand(const CRPCCommand& cmd)\n@@ -441,11 +441,8 @@ std::string HelpMessage(HelpMessageMode mode)\n         strUsage += HelpMessageOpt(\"-limitdescendantsize=<n>\", strprintf(\"Do not accept transactions if any ancestor would have more than <n> kilobytes of in-mempool descendants (default: %u).\", DEFAULT_DESCENDANT_SIZE_LIMIT));\n         strUsage += HelpMessageOpt(\"-bip9params=deployment:start:end\", \"Use given start/end times for specified BIP9 deployment (regtest-only)\");\n     }\n-    std::string debugCategories = \"addrman, alert, bench, cmpctblock, coindb, db, http, leveldb, libevent, lock, mempool, mempoolrej, net, proxy, prune, rand, reindex, rpc, selectcoins, tor, zmq\"; // Don't translate these and qt below\n-    if (mode == HMM_BITCOIN_QT)\n-        debugCategories += \", qt\";\n     strUsage += HelpMessageOpt(\"-debug=<category>\", strprintf(_(\"Output debugging information (default: %u, supplying <category> is optional)\"), 0) + \". \" +\n-        _(\"If <category> is not supplied or if <category> = 1, output all debugging information.\") + _(\"<category> can be:\") + \" \" + debugCategories + \".\");\n+        _(\"If <category> is not supplied or if <category> = 1, output all debugging information.\") + \" \" + _(\"<category> can be:\") + \" \" + ListLogCategories() + \".\");\n     if (showDebug)\n         strUsage += HelpMessageOpt(\"-nodebug\", \"Turn off debugging messages, same as -debug=0\");\n     strUsage += HelpMessageOpt(\"-help-debug\", _(\"Show all debugging options (usage: --help -help-debug)\"));\n@@ -909,12 +906,19 @@ bool AppInitParameterInteraction()\n \n     // ********************************************************* Step 3: parameter-to-internal-flags\n \n-    fDebug = mapMultiArgs.count(\"-debug\");\n-    // Special-case: if -debug=0/-nodebug is set, turn off debugging messages\n-    if (fDebug) {\n+    if (mapMultiArgs.count(\"-debug\") > 0) {\n+        // Special-case: if -debug=0/-nodebug is set, turn off debugging messages\n         const std::vector<std::string>& categories = mapMultiArgs.at(\"-debug\");\n-        if (GetBoolArg(\"-nodebug\", false) || find(categories.begin(), categories.end(), std::string(\"0\")) != categories.end())\n-            fDebug = false;\n+\n+        if (!(GetBoolArg(\"-nodebug\", false) || find(categories.begin(), categories.end(), std::string(\"0\")) != categories.end())) {\n+            for (const auto& cat : categories) {\n+                uint32_t flag;\n+                if (!GetLogCategory(&flag, &cat)) {\n+                    InitWarning(strprintf(_(\"Unsupported logging category %s.\\n\"), cat));\n+                }\n+                logCategories |= flag;\n+            }\n+        }\n     }\n \n     // Check for -debugnet\n@@ -1168,7 +1172,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n #ifndef WIN32\n     CreatePidFile(GetPidFile(), getpid());\n #endif\n-    if (GetBoolArg(\"-shrinkdebugfile\", !fDebug)) {\n+    if (GetBoolArg(\"-shrinkdebugfile\", logCategories != BCLog::NONE)) {\n         // Do this first since it both loads a bunch of debug.log into memory,\n         // and because this needs to happen before any other debug.log printing\n         ShrinkDebugFile();\n@@ -1492,7 +1496,7 @@ bool AppInitMain(boost::thread_group& threadGroup, CScheduler& scheduler)\n                     break;\n                 }\n             } catch (const std::exception& e) {\n-                if (fDebug) LogPrintf(\"%s\\n\", e.what());\n+                LogPrintf(\"%s\\n\", e.what());\n                 strLoadError = _(\"Error opening block database\");\n                 break;\n             }"
      },
      {
        "sha": "386d75c4be77459de5ef8aa03bdfbea703a2508a",
        "filename": "src/miner.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/miner.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/miner.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/miner.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -204,7 +204,7 @@ std::unique_ptr<CBlockTemplate> BlockAssembler::CreateNewBlock(const CScript& sc\n     }\n     int64_t nTime2 = GetTimeMicros();\n \n-    LogPrint(\"bench\", \"CreateNewBlock() packages: %.2fms (%d packages, %d updated descendants), validity: %.2fms (total %.2fms)\\n\", 0.001 * (nTime1 - nTimeStart), nPackagesSelected, nDescendantsUpdated, 0.001 * (nTime2 - nTime1), 0.001 * (nTime2 - nTimeStart));\n+    LogPrint(BCLog::BENCH, \"CreateNewBlock() packages: %.2fms (%d packages, %d updated descendants), validity: %.2fms (total %.2fms)\\n\", 0.001 * (nTime1 - nTimeStart), nPackagesSelected, nDescendantsUpdated, 0.001 * (nTime2 - nTime1), 0.001 * (nTime2 - nTimeStart));\n \n     return std::move(pblocktemplate);\n }"
      },
      {
        "sha": "cf94faf8540fc26021e5464edda7e661a814a7ee",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 23,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -190,7 +190,7 @@ void AdvertiseLocal(CNode *pnode)\n         }\n         if (addrLocal.IsRoutable())\n         {\n-            LogPrint(\"net\", \"AdvertiseLocal: advertising address %s\\n\", addrLocal.ToString());\n+            LogPrint(BCLog::NET, \"AdvertiseLocal: advertising address %s\\n\", addrLocal.ToString());\n             FastRandomContext insecure_rand;\n             pnode->PushAddress(addrLocal, insecure_rand);\n         }\n@@ -356,7 +356,7 @@ CNode* CConnman::ConnectNode(CAddress addrConnect, const char *pszDest, bool fCo\n     }\n \n     /// debug print\n-    LogPrint(\"net\", \"trying connection %s lastseen=%.1fhrs\\n\",\n+    LogPrint(BCLog::NET, \"trying connection %s lastseen=%.1fhrs\\n\",\n         pszDest ? pszDest : addrConnect.ToString(),\n         pszDest ? 0.0 : (double)(GetAdjustedTime() - addrConnect.nTime)/3600.0);\n \n@@ -423,7 +423,7 @@ void CConnman::DumpBanlist()\n     if (!bandb.Write(banmap))\n         SetBannedSetDirty(true);\n \n-    LogPrint(\"net\", \"Flushed %d banned node ips/subnets to banlist.dat  %dms\\n\",\n+    LogPrint(BCLog::NET, \"Flushed %d banned node ips/subnets to banlist.dat  %dms\\n\",\n         banmap.size(), GetTimeMillis() - nStart);\n }\n \n@@ -433,7 +433,7 @@ void CNode::CloseSocketDisconnect()\n     LOCK(cs_hSocket);\n     if (hSocket != INVALID_SOCKET)\n     {\n-        LogPrint(\"net\", \"disconnecting peer=%d\\n\", id);\n+        LogPrint(BCLog::NET, \"disconnecting peer=%d\\n\", id);\n         CloseSocket(hSocket);\n     }\n }\n@@ -565,7 +565,7 @@ void CConnman::SweepBanned()\n         {\n             setBanned.erase(it++);\n             setBannedIsDirty = true;\n-            LogPrint(\"net\", \"%s: Removed banned node ip/subnet from banlist.dat: %s\\n\", __func__, subNet.ToString());\n+            LogPrint(BCLog::NET, \"%s: Removed banned node ip/subnet from banlist.dat: %s\\n\", __func__, subNet.ToString());\n         }\n         else\n             ++it;\n@@ -711,7 +711,7 @@ bool CNode::ReceiveMsgBytes(const char *pch, unsigned int nBytes, bool& complete\n                 return false;\n \n         if (msg.in_data && msg.hdr.nMessageSize > MAX_PROTOCOL_MESSAGE_LENGTH) {\n-            LogPrint(\"net\", \"Oversized message from peer=%i, disconnecting\\n\", GetId());\n+            LogPrint(BCLog::NET, \"Oversized message from peer=%i, disconnecting\\n\", GetId());\n             return false;\n         }\n \n@@ -1087,7 +1087,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     {\n         if (!AttemptToEvictConnection()) {\n             // No connection to evict, disconnect the new connection\n-            LogPrint(\"net\", \"failed to find an eviction candidate - connection dropped (full)\\n\");\n+            LogPrint(BCLog::NET, \"failed to find an eviction candidate - connection dropped (full)\\n\");\n             CloseSocket(hSocket);\n             return;\n         }\n@@ -1101,7 +1101,7 @@ void CConnman::AcceptConnection(const ListenSocket& hListenSocket) {\n     pnode->fWhitelisted = whitelisted;\n     GetNodeSignals().InitializeNode(pnode, *this);\n \n-    LogPrint(\"net\", \"connection from %s accepted\\n\", addr.ToString());\n+    LogPrint(BCLog::NET, \"connection from %s accepted\\n\", addr.ToString());\n \n     {\n         LOCK(cs_vNodes);\n@@ -1336,8 +1336,9 @@ void CConnman::ThreadSocketHandler()\n                         else if (nBytes == 0)\n                         {\n                             // socket closed gracefully\n-                            if (!pnode->fDisconnect)\n-                                LogPrint(\"net\", \"socket closed\\n\");\n+                            if (!pnode->fDisconnect) {\n+                                LogPrint(BCLog::NET, \"socket closed\\n\");\n+                            }\n                             pnode->CloseSocketDisconnect();\n                         }\n                         else if (nBytes < 0)\n@@ -1375,7 +1376,7 @@ void CConnman::ThreadSocketHandler()\n             {\n                 if (pnode->nLastRecv == 0 || pnode->nLastSend == 0)\n                 {\n-                    LogPrint(\"net\", \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->id);\n+                    LogPrint(BCLog::NET, \"socket no message in first 60 seconds, %d %d from %d\\n\", pnode->nLastRecv != 0, pnode->nLastSend != 0, pnode->id);\n                     pnode->fDisconnect = true;\n                 }\n                 else if (nTime - pnode->nLastSend > TIMEOUT_INTERVAL)\n@@ -1634,7 +1635,7 @@ void CConnman::DumpAddresses()\n     CAddrDB adb;\n     adb.Write(addrman);\n \n-    LogPrint(\"net\", \"Flushed %d addresses to peers.dat  %dms\\n\",\n+    LogPrint(BCLog::NET, \"Flushed %d addresses to peers.dat  %dms\\n\",\n            addrman.size(), GetTimeMillis() - nStart);\n }\n \n@@ -1807,7 +1808,7 @@ void CConnman::ThreadOpenConnections()\n                 int randsleep = GetRandInt(FEELER_SLEEP_WINDOW * 1000);\n                 if (!interruptNet.sleep_for(std::chrono::milliseconds(randsleep)))\n                     return;\n-                LogPrint(\"net\", \"Making feeler connection to %s\\n\", addrConnect.ToString());\n+                LogPrint(BCLog::NET, \"Making feeler connection to %s\\n\", addrConnect.ToString());\n             }\n \n             OpenNetworkConnection(addrConnect, (int)setConnected.size() >= std::min(nMaxConnections - 1, 2), &grant, NULL, false, fFeeler);\n@@ -2150,9 +2151,7 @@ void Discover(boost::thread_group& threadGroup)\n \n void CConnman::SetNetworkActive(bool active)\n {\n-    if (fDebug) {\n-        LogPrint(\"net\", \"SetNetworkActive: %s\\n\", active);\n-    }\n+    LogPrint(BCLog::NET, \"SetNetworkActive: %s\\n\", active);\n \n     if (!active) {\n         fNetworkActive = false;\n@@ -2241,7 +2240,7 @@ bool CConnman::Start(CScheduler& scheduler, std::string& strNodeError, Options c\n         SetBannedSetDirty(false); // no need to write down, just read data\n         SweepBanned(); // sweep out unused entries\n \n-        LogPrint(\"net\", \"Loaded %d banned node ips/subnets from banlist.dat  %dms\\n\",\n+        LogPrint(BCLog::NET, \"Loaded %d banned node ips/subnets from banlist.dat  %dms\\n\",\n             banmap.size(), GetTimeMillis() - nStart);\n     } else {\n         LogPrintf(\"Invalid or missing banlist.dat; recreating\\n\");\n@@ -2683,10 +2682,11 @@ CNode::CNode(NodeId idIn, ServiceFlags nLocalServicesIn, int nMyStartingHeightIn\n         mapRecvBytesPerMsgCmd[msg] = 0;\n     mapRecvBytesPerMsgCmd[NET_MESSAGE_COMMAND_OTHER] = 0;\n \n-    if (fLogIPs)\n-        LogPrint(\"net\", \"Added connection to %s peer=%d\\n\", addrName, id);\n-    else\n-        LogPrint(\"net\", \"Added connection peer=%d\\n\", id);\n+    if (fLogIPs) {\n+        LogPrint(BCLog::NET, \"Added connection to %s peer=%d\\n\", addrName, id);\n+    } else {\n+        LogPrint(BCLog::NET, \"Added connection peer=%d\\n\", id);\n+    }\n }\n \n CNode::~CNode()\n@@ -2713,7 +2713,7 @@ void CNode::AskFor(const CInv& inv)\n         nRequestTime = it->second;\n     else\n         nRequestTime = 0;\n-    LogPrint(\"net\", \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000), id);\n+    LogPrint(BCLog::NET, \"askfor %s  %d (%s) peer=%d\\n\", inv.ToString(), nRequestTime, DateTimeStrFormat(\"%H:%M:%S\", nRequestTime/1000000), id);\n \n     // Make sure not to reuse time indexes to keep things in the same order\n     int64_t nNow = GetTimeMicros() - 1000000;\n@@ -2740,7 +2740,7 @@ void CConnman::PushMessage(CNode* pnode, CSerializedNetMsg&& msg)\n {\n     size_t nMessageSize = msg.data.size();\n     size_t nTotalSize = nMessageSize + CMessageHeader::HEADER_SIZE;\n-    LogPrint(\"net\", \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->id);\n+    LogPrint(BCLog::NET, \"sending %s (%d bytes) peer=%d\\n\",  SanitizeString(msg.command.c_str()), nMessageSize, pnode->id);\n \n     std::vector<unsigned char> serializedHeader;\n     serializedHeader.reserve(CMessageHeader::HEADER_SIZE);"
      },
      {
        "sha": "17653f542de788e2e26e4e9bf05da868985cf70f",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 71,
        "deletions": 69,
        "changes": 140,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -256,10 +256,11 @@ void PushNodeVersion(CNode *pnode, CConnman& connman, int64_t nTime)\n     connman.PushMessage(pnode, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::VERSION, PROTOCOL_VERSION, (uint64_t)nLocalNodeServices, nTime, addrYou, addrMe,\n             nonce, strSubVersion, nNodeStartingHeight, ::fRelayTxes));\n \n-    if (fLogIPs)\n-        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), addrYou.ToString(), nodeid);\n-    else\n-        LogPrint(\"net\", \"send version message: version %d, blocks=%d, us=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), nodeid);\n+    if (fLogIPs) {\n+        LogPrint(BCLog::NET, \"send version message: version %d, blocks=%d, us=%s, them=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), addrYou.ToString(), nodeid);\n+    } else {\n+        LogPrint(BCLog::NET, \"send version message: version %d, blocks=%d, us=%s, peer=%d\\n\", PROTOCOL_VERSION, nNodeStartingHeight, addrMe.ToString(), nodeid);\n+    }\n }\n \n void InitializeNode(CNode *pnode, CConnman& connman) {\n@@ -619,7 +620,7 @@ bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRE\n     unsigned int sz = GetTransactionWeight(*tx);\n     if (sz >= MAX_STANDARD_TX_WEIGHT)\n     {\n-        LogPrint(\"mempool\", \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString());\n+        LogPrint(BCLog::MEMPOOL, \"ignoring large orphan tx (size: %u, hash: %s)\\n\", sz, hash.ToString());\n         return false;\n     }\n \n@@ -631,7 +632,7 @@ bool AddOrphanTx(const CTransactionRef& tx, NodeId peer) EXCLUSIVE_LOCKS_REQUIRE\n \n     AddToCompactExtraTransactions(tx);\n \n-    LogPrint(\"mempool\", \"stored orphan tx %s (mapsz %u outsz %u)\\n\", hash.ToString(),\n+    LogPrint(BCLog::MEMPOOL, \"stored orphan tx %s (mapsz %u outsz %u)\\n\", hash.ToString(),\n              mapOrphanTransactions.size(), mapOrphanTransactionsByPrev.size());\n     return true;\n }\n@@ -666,7 +667,7 @@ void EraseOrphansFor(NodeId peer)\n             nErased += EraseOrphanTx(maybeErase->second.tx->GetHash());\n         }\n     }\n-    if (nErased > 0) LogPrint(\"mempool\", \"Erased %d orphan tx from peer=%d\\n\", nErased, peer);\n+    if (nErased > 0) LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx from peer=%d\\n\", nErased, peer);\n }\n \n \n@@ -691,7 +692,7 @@ unsigned int LimitOrphanTxSize(unsigned int nMaxOrphans) EXCLUSIVE_LOCKS_REQUIRE\n         }\n         // Sweep again 5 minutes after the next entry that expires in order to batch the linear scan.\n         nNextSweep = nMinExpTime + ORPHAN_TX_EXPIRE_INTERVAL;\n-        if (nErased > 0) LogPrint(\"mempool\", \"Erased %d orphan tx due to expiration\\n\", nErased);\n+        if (nErased > 0) LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx due to expiration\\n\", nErased);\n     }\n     while (mapOrphanTransactions.size() > nMaxOrphans)\n     {\n@@ -767,7 +768,7 @@ void PeerLogicValidation::SyncTransaction(const CTransaction& tx, const CBlockIn\n         BOOST_FOREACH(uint256 &orphanHash, vOrphanErase) {\n             nErased += EraseOrphanTx(orphanHash);\n         }\n-        LogPrint(\"mempool\", \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n+        LogPrint(BCLog::MEMPOOL, \"Erased %d orphan tx included or conflicted by block\\n\", nErased);\n     }\n }\n \n@@ -808,7 +809,7 @@ void PeerLogicValidation::NewPoWValidBlock(const CBlockIndex *pindex, const std:\n         if (state.fPreferHeaderAndIDs && (!fWitnessEnabled || state.fWantsCmpctWitness) &&\n                 !PeerHasHeader(&state, pindex) && PeerHasHeader(&state, pindex->pprev)) {\n \n-            LogPrint(\"net\", \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerLogicValidation::NewPoWValidBlock\",\n+            LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", \"PeerLogicValidation::NewPoWValidBlock\",\n                     hashBlock.ToString(), pnode->id);\n             connman->PushMessage(pnode, msgMaker.Make(NetMsgType::CMPCTBLOCK, *pcmpctblock));\n             state.pindexBestHeaderSent = pindex;\n@@ -1024,7 +1025,7 @@ void static ProcessGetData(CNode* pfrom, const Consensus::Params& consensusParam\n                 static const int nOneWeek = 7 * 24 * 60 * 60; // assume > 1 week = historical\n                 if (send && connman.OutboundTargetReached(true) && ( ((pindexBestHeader != NULL) && (pindexBestHeader->GetBlockTime() - mi->second->GetBlockTime() > nOneWeek)) || inv.type == MSG_FILTERED_BLOCK) && !pfrom->fWhitelisted)\n                 {\n-                    LogPrint(\"net\", \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n+                    LogPrint(BCLog::NET, \"historical block serving limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n \n                     //disconnect node\n                     pfrom->fDisconnect = true;\n@@ -1168,7 +1169,7 @@ inline void static SendBlockTransactions(const CBlock& block, const BlockTransac\n \n bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStream& vRecv, int64_t nTimeReceived, const CChainParams& chainparams, CConnman& connman, const std::atomic<bool>& interruptMsgProc)\n {\n-    LogPrint(\"net\", \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->id);\n+    LogPrint(BCLog::NET, \"received: %s (%u bytes) peer=%d\\n\", SanitizeString(strCommand), vRecv.size(), pfrom->id);\n     if (IsArgSet(\"-dropmessagestest\") && GetRand(GetArg(\"-dropmessagestest\", 0)) == 0)\n     {\n         LogPrintf(\"dropmessagestest DROPPING RECV MESSAGE\\n\");\n@@ -1192,7 +1193,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n     if (strCommand == NetMsgType::REJECT)\n     {\n-        if (fDebug) {\n+        if (LogAcceptCategory(BCLog::NET)) {\n             try {\n                 std::string strMsg; unsigned char ccode; std::string strReason;\n                 vRecv >> LIMITED_STRING(strMsg, CMessageHeader::COMMAND_SIZE) >> ccode >> LIMITED_STRING(strReason, MAX_REJECT_MESSAGE_LENGTH);\n@@ -1206,10 +1207,10 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     vRecv >> hash;\n                     ss << \": hash \" << hash.ToString();\n                 }\n-                LogPrint(\"net\", \"Reject %s\\n\", SanitizeString(ss.str()));\n+                LogPrint(BCLog::NET, \"Reject %s\\n\", SanitizeString(ss.str()));\n             } catch (const std::ios_base::failure&) {\n                 // Avoid feedback loops by preventing reject messages from triggering a new reject message.\n-                LogPrint(\"net\", \"Unparseable reject message received\\n\");\n+                LogPrint(BCLog::NET, \"Unparseable reject message received\\n\");\n             }\n         }\n     }\n@@ -1247,7 +1248,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n         if (pfrom->nServicesExpected & ~nServices)\n         {\n-            LogPrint(\"net\", \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->id, nServices, pfrom->nServicesExpected);\n+            LogPrint(BCLog::NET, \"peer=%d does not offer the expected services (%08x offered, %08x expected); disconnecting\\n\", pfrom->id, nServices, pfrom->nServicesExpected);\n             connman.PushMessage(pfrom, CNetMsgMaker(INIT_PROTO_VERSION).Make(NetMsgType::REJECT, strCommand, REJECT_NONSTANDARD,\n                                strprintf(\"Expected to offer services %08x\", pfrom->nServicesExpected)));\n             pfrom->fDisconnect = true;\n@@ -1335,11 +1336,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 FastRandomContext insecure_rand;\n                 if (addr.IsRoutable())\n                 {\n-                    LogPrint(\"net\", \"ProcessMessages: advertising address %s\\n\", addr.ToString());\n+                    LogPrint(BCLog::NET, \"ProcessMessages: advertising address %s\\n\", addr.ToString());\n                     pfrom->PushAddress(addr, insecure_rand);\n                 } else if (IsPeerAddrLocalGood(pfrom)) {\n                     addr.SetIP(addrMe);\n-                    LogPrint(\"net\", \"ProcessMessages: advertising address %s\\n\", addr.ToString());\n+                    LogPrint(BCLog::NET, \"ProcessMessages: advertising address %s\\n\", addr.ToString());\n                     pfrom->PushAddress(addr, insecure_rand);\n                 }\n             }\n@@ -1541,7 +1542,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 return true;\n \n             bool fAlreadyHave = AlreadyHave(inv);\n-            LogPrint(\"net\", \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->id);\n+            LogPrint(BCLog::NET, \"got inv: %s  %s peer=%d\\n\", inv.ToString(), fAlreadyHave ? \"have\" : \"new\", pfrom->id);\n \n             if (inv.type == MSG_TX) {\n                 inv.type |= nFetchFlags;\n@@ -1556,16 +1557,17 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     // we now only provide a getheaders response here. When we receive the headers, we will\n                     // then ask for the blocks we need.\n                     connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), inv.hash));\n-                    LogPrint(\"net\", \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->id);\n+                    LogPrint(BCLog::NET, \"getheaders (%d) %s to peer=%d\\n\", pindexBestHeader->nHeight, inv.hash.ToString(), pfrom->id);\n                 }\n             }\n             else\n             {\n                 pfrom->AddInventoryKnown(inv);\n-                if (fBlocksOnly)\n-                    LogPrint(\"net\", \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->id);\n-                else if (!fAlreadyHave && !fImporting && !fReindex && !IsInitialBlockDownload())\n+                if (fBlocksOnly) {\n+                    LogPrint(BCLog::NET, \"transaction (%s) inv sent in violation of protocol peer=%d\\n\", inv.hash.ToString(), pfrom->id);\n+                } else if (!fAlreadyHave && !fImporting && !fReindex && !IsInitialBlockDownload()) {\n                     pfrom->AskFor(inv);\n+                }\n             }\n \n             // Track requests for our stuff\n@@ -1588,11 +1590,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             return error(\"message getdata size() = %u\", vInv.size());\n         }\n \n-        if (fDebug || (vInv.size() != 1))\n-            LogPrint(\"net\", \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom->id);\n+        LogPrint(BCLog::NET, \"received getdata (%u invsz) peer=%d\\n\", vInv.size(), pfrom->id);\n \n-        if ((fDebug && vInv.size() > 0) || (vInv.size() == 1))\n-            LogPrint(\"net\", \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->id);\n+        if (vInv.size() > 0) {\n+            LogPrint(BCLog::NET, \"received getdata for: %s peer=%d\\n\", vInv[0].ToString(), pfrom->id);\n+        }\n \n         pfrom->vRecvGetData.insert(pfrom->vRecvGetData.end(), vInv.begin(), vInv.end());\n         ProcessGetData(pfrom, chainparams.GetConsensus(), connman, interruptMsgProc);\n@@ -1631,28 +1633,28 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (pindex)\n             pindex = chainActive.Next(pindex);\n         int nLimit = 500;\n-        LogPrint(\"net\", \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom->id);\n+        LogPrint(BCLog::NET, \"getblocks %d to %s limit %d from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), nLimit, pfrom->id);\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             if (pindex->GetBlockHash() == hashStop)\n             {\n-                LogPrint(\"net\", \"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+                LogPrint(BCLog::NET, \"  getblocks stopping at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n                 break;\n             }\n             // If pruning, don't inv blocks unless we have on disk and are likely to still have\n             // for some reasonable time window (1 hour) that block relay might require.\n             const int nPrunedBlocksLikelyToHave = MIN_BLOCKS_TO_KEEP - 3600 / chainparams.GetConsensus().nPowTargetSpacing;\n             if (fPruneMode && (!(pindex->nStatus & BLOCK_HAVE_DATA) || pindex->nHeight <= chainActive.Tip()->nHeight - nPrunedBlocksLikelyToHave))\n             {\n-                LogPrint(\"net\", \" getblocks stopping, pruned or too old block at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+                LogPrint(BCLog::NET, \" getblocks stopping, pruned or too old block at %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n                 break;\n             }\n             pfrom->PushInventory(CInv(MSG_BLOCK, pindex->GetBlockHash()));\n             if (--nLimit <= 0)\n             {\n                 // When this block is requested, we'll send an inv that'll\n                 // trigger the peer to getblocks the next batch of inventory.\n-                LogPrint(\"net\", \"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n+                LogPrint(BCLog::NET, \"  getblocks stopping at limit %d %s\\n\", pindex->nHeight, pindex->GetBlockHash().ToString());\n                 pfrom->hashContinue = pindex->GetBlockHash();\n                 break;\n             }\n@@ -1693,7 +1695,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // might maliciously send lots of getblocktxn requests to trigger\n             // expensive disk reads, because it will require the peer to\n             // actually receive all the data read from disk over the network.\n-            LogPrint(\"net\", \"Peer %d sent us a getblocktxn for a block > %i deep\", pfrom->id, MAX_BLOCKTXN_DEPTH);\n+            LogPrint(BCLog::NET, \"Peer %d sent us a getblocktxn for a block > %i deep\", pfrom->id, MAX_BLOCKTXN_DEPTH);\n             CInv inv;\n             inv.type = State(pfrom->GetId())->fWantsCmpctWitness ? MSG_WITNESS_BLOCK : MSG_BLOCK;\n             inv.hash = req.blockhash;\n@@ -1718,7 +1720,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n         LOCK(cs_main);\n         if (IsInitialBlockDownload() && !pfrom->fWhitelisted) {\n-            LogPrint(\"net\", \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"Ignoring getheaders from peer=%d because node is in initial block download\\n\", pfrom->id);\n             return true;\n         }\n \n@@ -1743,7 +1745,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // we must use CBlocks, as CBlockHeaders won't include the 0x00 nTx count at the end\n         std::vector<CBlock> vHeaders;\n         int nLimit = MAX_HEADERS_RESULTS;\n-        LogPrint(\"net\", \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->id);\n+        LogPrint(BCLog::NET, \"getheaders %d to %s from peer=%d\\n\", (pindex ? pindex->nHeight : -1), hashStop.IsNull() ? \"end\" : hashStop.ToString(), pfrom->id);\n         for (; pindex; pindex = chainActive.Next(pindex))\n         {\n             vHeaders.push_back(pindex->GetBlockHeader());\n@@ -1773,7 +1775,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // We are in blocks only mode and peer is either not whitelisted or whitelistrelay is off\n         if (!fRelayTxes && (!pfrom->fWhitelisted || !GetBoolArg(\"-whitelistrelay\", DEFAULT_WHITELISTRELAY)))\n         {\n-            LogPrint(\"net\", \"transaction sent in violation of protocol peer=%d\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"transaction sent in violation of protocol peer=%d\\n\", pfrom->id);\n             return true;\n         }\n \n@@ -1805,7 +1807,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n             pfrom->nLastTXTime = GetTime();\n \n-            LogPrint(\"mempool\", \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n+            LogPrint(BCLog::MEMPOOL, \"AcceptToMemoryPool: peer=%d: accepted %s (poolsz %u txn, %u kB)\\n\",\n                 pfrom->id,\n                 tx.GetHash().ToString(),\n                 mempool.size(), mempool.DynamicMemoryUsage() / 1000);\n@@ -1835,7 +1837,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     if (setMisbehaving.count(fromPeer))\n                         continue;\n                     if (AcceptToMemoryPool(mempool, stateDummy, porphanTx, true, &fMissingInputs2, &lRemovedTxn)) {\n-                        LogPrint(\"mempool\", \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n+                        LogPrint(BCLog::MEMPOOL, \"   accepted orphan tx %s\\n\", orphanHash.ToString());\n                         RelayTransaction(orphanTx, connman);\n                         for (unsigned int i = 0; i < orphanTx.vout.size(); i++) {\n                             vWorkQueue.emplace_back(orphanHash, i);\n@@ -1850,11 +1852,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                             // Punish peer that gave us an invalid orphan tx\n                             Misbehaving(fromPeer, nDos);\n                             setMisbehaving.insert(fromPeer);\n-                            LogPrint(\"mempool\", \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n+                            LogPrint(BCLog::MEMPOOL, \"   invalid orphan tx %s\\n\", orphanHash.ToString());\n                         }\n                         // Has inputs but not accepted to mempool\n                         // Probably non-standard or insufficient fee\n-                        LogPrint(\"mempool\", \"   removed orphan tx %s\\n\", orphanHash.ToString());\n+                        LogPrint(BCLog::MEMPOOL, \"   removed orphan tx %s\\n\", orphanHash.ToString());\n                         vEraseQueue.push_back(orphanHash);\n                         if (!orphanTx.HasWitness() && !stateDummy.CorruptionPossible()) {\n                             // Do not use rejection cache for witness transactions or\n@@ -1892,10 +1894,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 // DoS prevention: do not allow mapOrphanTransactions to grow unbounded\n                 unsigned int nMaxOrphanTx = (unsigned int)std::max((int64_t)0, GetArg(\"-maxorphantx\", DEFAULT_MAX_ORPHAN_TRANSACTIONS));\n                 unsigned int nEvicted = LimitOrphanTxSize(nMaxOrphanTx);\n-                if (nEvicted > 0)\n-                    LogPrint(\"mempool\", \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n+                if (nEvicted > 0) {\n+                    LogPrint(BCLog::MEMPOOL, \"mapOrphan overflow, removed %u tx\\n\", nEvicted);\n+                }\n             } else {\n-                LogPrint(\"mempool\", \"not keeping orphan with rejected parents %s\\n\",tx.GetHash().ToString());\n+                LogPrint(BCLog::MEMPOOL, \"not keeping orphan with rejected parents %s\\n\",tx.GetHash().ToString());\n                 // We will continue to reject this tx since it has rejected\n                 // parents so avoid re-requesting it from other peers.\n                 recentRejects->insert(tx.GetHash());\n@@ -1939,7 +1942,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         int nDoS = 0;\n         if (state.IsInvalid(nDoS))\n         {\n-            LogPrint(\"mempoolrej\", \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n+            LogPrint(BCLog::MEMPOOLREJ, \"%s from peer=%d was not accepted: %s\\n\", tx.GetHash().ToString(),\n                 pfrom->id,\n                 FormatStateMessage(state));\n             if (state.GetRejectCode() < REJECT_INTERNAL) // Never send AcceptToMemoryPool's internal codes over P2P\n@@ -2046,7 +2049,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                         (*queuedBlockIt)->partialBlock.reset(new PartiallyDownloadedBlock(&mempool));\n                     else {\n                         // The block was already in flight using compact blocks from the same peer\n-                        LogPrint(\"net\", \"Peer sent us compact block we were already syncing!\\n\");\n+                        LogPrint(BCLog::NET, \"Peer sent us compact block we were already syncing!\\n\");\n                         return true;\n                     }\n                 }\n@@ -2161,7 +2164,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             std::map<uint256, std::pair<NodeId, std::list<QueuedBlock>::iterator> >::iterator it = mapBlocksInFlight.find(resp.blockhash);\n             if (it == mapBlocksInFlight.end() || !it->second.second->partialBlock ||\n                     it->second.first != pfrom->GetId()) {\n-                LogPrint(\"net\", \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->id);\n+                LogPrint(BCLog::NET, \"Peer %d sent us block transactions for block we weren't expecting\\n\", pfrom->id);\n                 return true;\n             }\n \n@@ -2254,7 +2257,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         if (mapBlockIndex.find(headers[0].hashPrevBlock) == mapBlockIndex.end() && nCount < MAX_BLOCKS_TO_ANNOUNCE) {\n             nodestate->nUnconnectingHeaders++;\n             connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexBestHeader), uint256()));\n-            LogPrint(\"net\", \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n+            LogPrint(BCLog::NET, \"received header %s: missing prev block %s, sending getheaders (%d) to end (peer=%d, nUnconnectingHeaders=%d)\\n\",\n                     headers[0].GetHash().ToString(),\n                     headers[0].hashPrevBlock.ToString(),\n                     pindexBestHeader->nHeight,\n@@ -2296,7 +2299,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         LOCK(cs_main);\n         CNodeState *nodestate = State(pfrom->GetId());\n         if (nodestate->nUnconnectingHeaders > 0) {\n-            LogPrint(\"net\", \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->id, nodestate->nUnconnectingHeaders);\n+            LogPrint(BCLog::NET, \"peer=%d: resetting nUnconnectingHeaders (%d -> 0)\\n\", pfrom->id, nodestate->nUnconnectingHeaders);\n         }\n         nodestate->nUnconnectingHeaders = 0;\n \n@@ -2307,7 +2310,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // Headers message had its maximum size; the peer may have more headers.\n             // TODO: optimize: if pindexLast is an ancestor of chainActive.Tip or pindexBestHeader, continue\n             // from there instead.\n-            LogPrint(\"net\", \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->id, pfrom->nStartingHeight);\n+            LogPrint(BCLog::NET, \"more getheaders (%d) to end to peer=%d (startheight:%d)\\n\", pindexLast->nHeight, pfrom->id, pfrom->nStartingHeight);\n             connman.PushMessage(pfrom, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexLast), uint256()));\n         }\n \n@@ -2332,7 +2335,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n             // the main chain -- this shouldn't really happen.  Bail out on the\n             // direct fetch and rely on parallel download instead.\n             if (!chainActive.Contains(pindexWalk)) {\n-                LogPrint(\"net\", \"Large reorg, won't direct fetch to %s (%d)\\n\",\n+                LogPrint(BCLog::NET, \"Large reorg, won't direct fetch to %s (%d)\\n\",\n                         pindexLast->GetBlockHash().ToString(),\n                         pindexLast->nHeight);\n             } else {\n@@ -2346,11 +2349,11 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                     uint32_t nFetchFlags = GetFetchFlags(pfrom, pindex->pprev, chainparams.GetConsensus());\n                     vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n                     MarkBlockAsInFlight(pfrom->GetId(), pindex->GetBlockHash(), chainparams.GetConsensus(), pindex);\n-                    LogPrint(\"net\", \"Requesting block %s from  peer=%d\\n\",\n+                    LogPrint(BCLog::NET, \"Requesting block %s from  peer=%d\\n\",\n                             pindex->GetBlockHash().ToString(), pfrom->id);\n                 }\n                 if (vGetData.size() > 1) {\n-                    LogPrint(\"net\", \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\n+                    LogPrint(BCLog::NET, \"Downloading blocks toward %s (%d) via headers direct fetch\\n\",\n                             pindexLast->GetBlockHash().ToString(), pindexLast->nHeight);\n                 }\n                 if (vGetData.size() > 0) {\n@@ -2370,7 +2373,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         std::shared_ptr<CBlock> pblock = std::make_shared<CBlock>();\n         vRecv >> *pblock;\n \n-        LogPrint(\"net\", \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->id);\n+        LogPrint(BCLog::NET, \"received block %s peer=%d\\n\", pblock->GetHash().ToString(), pfrom->id);\n \n         // Process all blocks from whitelisted peers, even if not requested,\n         // unless we're still syncing with the network.\n@@ -2402,14 +2405,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         // Making nodes which are behind NAT and can only make outgoing connections ignore\n         // the getaddr message mitigates the attack.\n         if (!pfrom->fInbound) {\n-            LogPrint(\"net\", \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"Ignoring \\\"getaddr\\\" from outbound connection. peer=%d\\n\", pfrom->id);\n             return true;\n         }\n \n         // Only send one GetAddr response per connection to reduce resource waste\n         //  and discourage addr stamping of INV announcements.\n         if (pfrom->fSentAddr) {\n-            LogPrint(\"net\", \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom->id);\n+            LogPrint(BCLog::NET, \"Ignoring repeated \\\"getaddr\\\". peer=%d\\n\", pfrom->id);\n             return true;\n         }\n         pfrom->fSentAddr = true;\n@@ -2426,14 +2429,14 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n     {\n         if (!(pfrom->GetLocalServices() & NODE_BLOOM) && !pfrom->fWhitelisted)\n         {\n-            LogPrint(\"net\", \"mempool request with bloom filters disabled, disconnect peer=%d\\n\", pfrom->GetId());\n+            LogPrint(BCLog::NET, \"mempool request with bloom filters disabled, disconnect peer=%d\\n\", pfrom->GetId());\n             pfrom->fDisconnect = true;\n             return true;\n         }\n \n         if (connman.OutboundTargetReached(false) && !pfrom->fWhitelisted)\n         {\n-            LogPrint(\"net\", \"mempool request with bandwidth limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n+            LogPrint(BCLog::NET, \"mempool request with bandwidth limit reached, disconnect peer=%d\\n\", pfrom->GetId());\n             pfrom->fDisconnect = true;\n             return true;\n         }\n@@ -2509,7 +2512,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n         }\n \n         if (!(sProblem.empty())) {\n-            LogPrint(\"net\", \"pong peer=%d: %s, %x expected, %x received, %u bytes\\n\",\n+            LogPrint(BCLog::NET, \"pong peer=%d: %s, %x expected, %x received, %u bytes\\n\",\n                 pfrom->id,\n                 sProblem,\n                 pfrom->nPingNonceSent,\n@@ -2587,7 +2590,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n                 LOCK(pfrom->cs_feeFilter);\n                 pfrom->minFeeFilter = newFeeFilter;\n             }\n-            LogPrint(\"net\", \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->id);\n+            LogPrint(BCLog::NET, \"received: feefilter of %s from peer=%d\\n\", CFeeRate(newFeeFilter).ToString(), pfrom->id);\n         }\n     }\n \n@@ -2598,7 +2601,7 @@ bool static ProcessMessage(CNode* pfrom, const std::string& strCommand, CDataStr\n \n     else {\n         // Ignore unknown commands for extensibility\n-        LogPrint(\"net\", \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->id);\n+        LogPrint(BCLog::NET, \"Unknown command \\\"%s\\\" from peer=%d\\n\", SanitizeString(strCommand), pfrom->id);\n     }\n \n \n@@ -2876,7 +2879,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                    got back an empty response.  */\n                 if (pindexStart->pprev)\n                     pindexStart = pindexStart->pprev;\n-                LogPrint(\"net\", \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->id, pto->nStartingHeight);\n+                LogPrint(BCLog::NET, \"initial getheaders (%d) to peer=%d (startheight:%d)\\n\", pindexStart->nHeight, pto->id, pto->nStartingHeight);\n                 connman.PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, chainActive.GetLocator(pindexStart), uint256()));\n             }\n         }\n@@ -2960,7 +2963,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                 if (vHeaders.size() == 1 && state.fPreferHeaderAndIDs) {\n                     // We only send up to 1 block as header-and-ids, as otherwise\n                     // probably means we're doing an initial-ish-sync or they're slow\n-                    LogPrint(\"net\", \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n+                    LogPrint(BCLog::NET, \"%s sending header-and-ids %s to peer=%d\\n\", __func__,\n                             vHeaders.front().GetHash().ToString(), pto->id);\n \n                     int nSendFlags = state.fWantsCmpctWitness ? 0 : SERIALIZE_TRANSACTION_NO_WITNESS;\n@@ -2988,12 +2991,12 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     state.pindexBestHeaderSent = pBestIndex;\n                 } else if (state.fPreferHeaders) {\n                     if (vHeaders.size() > 1) {\n-                        LogPrint(\"net\", \"%s: %u headers, range (%s, %s), to peer=%d\\n\", __func__,\n+                        LogPrint(BCLog::NET, \"%s: %u headers, range (%s, %s), to peer=%d\\n\", __func__,\n                                 vHeaders.size(),\n                                 vHeaders.front().GetHash().ToString(),\n                                 vHeaders.back().GetHash().ToString(), pto->id);\n                     } else {\n-                        LogPrint(\"net\", \"%s: sending header %s to peer=%d\\n\", __func__,\n+                        LogPrint(BCLog::NET, \"%s: sending header %s to peer=%d\\n\", __func__,\n                                 vHeaders.front().GetHash().ToString(), pto->id);\n                     }\n                     connman.PushMessage(pto, msgMaker.Make(NetMsgType::HEADERS, vHeaders));\n@@ -3015,14 +3018,14 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                     // This should be very rare and could be optimized out.\n                     // Just log for now.\n                     if (chainActive[pindex->nHeight] != pindex) {\n-                        LogPrint(\"net\", \"Announcing block %s not on main chain (tip=%s)\\n\",\n+                        LogPrint(BCLog::NET, \"Announcing block %s not on main chain (tip=%s)\\n\",\n                             hashToAnnounce.ToString(), chainActive.Tip()->GetBlockHash().ToString());\n                     }\n \n                     // If the peer's chain has this block, don't inv it back.\n                     if (!PeerHasHeader(&state, pindex)) {\n                         pto->PushInventory(CInv(MSG_BLOCK, hashToAnnounce));\n-                        LogPrint(\"net\", \"%s: sending inv peer=%d hash=%s\\n\", __func__,\n+                        LogPrint(BCLog::NET, \"%s: sending inv peer=%d hash=%s\\n\", __func__,\n                             pto->id, hashToAnnounce.ToString());\n                     }\n                 }\n@@ -3201,13 +3204,13 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n                 uint32_t nFetchFlags = GetFetchFlags(pto, pindex->pprev, consensusParams);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n                 MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), consensusParams, pindex);\n-                LogPrint(\"net\", \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n+                LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->id);\n             }\n             if (state.nBlocksInFlight == 0 && staller != -1) {\n                 if (State(staller)->nStallingSince == 0) {\n                     State(staller)->nStallingSince = nNow;\n-                    LogPrint(\"net\", \"Stall started peer=%d\\n\", staller);\n+                    LogPrint(BCLog::NET, \"Stall started peer=%d\\n\", staller);\n                 }\n             }\n         }\n@@ -3220,8 +3223,7 @@ bool SendMessages(CNode* pto, CConnman& connman, const std::atomic<bool>& interr\n             const CInv& inv = (*pto->mapAskFor.begin()).second;\n             if (!AlreadyHave(inv))\n             {\n-                if (fDebug)\n-                    LogPrint(\"net\", \"Requesting %s peer=%d\\n\", inv.ToString(), pto->id);\n+                LogPrint(BCLog::NET, \"Requesting %s peer=%d\\n\", inv.ToString(), pto->id);\n                 vGetData.push_back(inv);\n                 if (vGetData.size() >= 1000)\n                 {"
      },
      {
        "sha": "bdc725359ac3220bfc6d49e102b00bd3df4f9f85",
        "filename": "src/netbase.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/netbase.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/netbase.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/netbase.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -281,7 +281,7 @@ std::string Socks5ErrorString(int err)\n static bool Socks5(const std::string& strDest, int port, const ProxyCredentials *auth, SOCKET& hSocket)\n {\n     IntrRecvError recvr;\n-    LogPrint(\"net\", \"SOCKS5 connecting %s\\n\", strDest);\n+    LogPrint(BCLog::NET, \"SOCKS5 connecting %s\\n\", strDest);\n     if (strDest.size() > 255) {\n         CloseSocket(hSocket);\n         return error(\"Hostname too long\");\n@@ -327,7 +327,7 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n             CloseSocket(hSocket);\n             return error(\"Error sending authentication to proxy\");\n         }\n-        LogPrint(\"proxy\", \"SOCKS5 sending proxy authentication %s:%s\\n\", auth->username, auth->password);\n+        LogPrint(BCLog::PROXY, \"SOCKS5 sending proxy authentication %s:%s\\n\", auth->username, auth->password);\n         char pchRetA[2];\n         if ((recvr = InterruptibleRecv(pchRetA, 2, SOCKS5_RECV_TIMEOUT, hSocket)) != IntrRecvError::OK) {\n             CloseSocket(hSocket);\n@@ -409,7 +409,7 @@ static bool Socks5(const std::string& strDest, int port, const ProxyCredentials\n         CloseSocket(hSocket);\n         return error(\"Error reading from proxy\");\n     }\n-    LogPrint(\"net\", \"SOCKS5 connected %s\\n\", strDest);\n+    LogPrint(BCLog::NET, \"SOCKS5 connected %s\\n\", strDest);\n     return true;\n }\n \n@@ -458,7 +458,7 @@ bool static ConnectSocketDirectly(const CService &addrConnect, SOCKET& hSocketRe\n             int nRet = select(hSocket + 1, NULL, &fdset, NULL, &timeout);\n             if (nRet == 0)\n             {\n-                LogPrint(\"net\", \"connection to %s timeout\\n\", addrConnect.ToString());\n+                LogPrint(BCLog::NET, \"connection to %s timeout\\n\", addrConnect.ToString());\n                 CloseSocket(hSocket);\n                 return false;\n             }"
      },
      {
        "sha": "38e07dc3450fa3e445bd8c8ae9e5275492c52973",
        "filename": "src/policy/fees.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 12,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/policy/fees.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/policy/fees.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -165,7 +165,7 @@ double TxConfirmStats::EstimateMedianVal(int confTarget, double sufficientTxVal,\n         }\n     }\n \n-    LogPrint(\"estimatefee\", \"%3d: For conf success %s %4.2f need feerate %s: %12.5g from buckets %8g - %8g  Cur Bucket stats %6.2f%%  %8.1f/(%.1f+%d mempool)\\n\",\n+    LogPrint(BCLog::ESTIMATEFEE, \"%3d: For conf success %s %4.2f need feerate %s: %12.5g from buckets %8g - %8g  Cur Bucket stats %6.2f%%  %8.1f/(%.1f+%d mempool)\\n\",\n              confTarget, requireGreater ? \">\" : \"<\", successBreakPoint,\n              requireGreater ? \">\" : \"<\", median, buckets[minBucket], buckets[maxBucket],\n              100 * nConf / (totalNum + extraNum), nConf, totalNum, extraNum);\n@@ -241,7 +241,7 @@ void TxConfirmStats::Read(CAutoFile& filein)\n     for (unsigned int i = 0; i < buckets.size(); i++)\n         bucketMap[buckets[i]] = i;\n \n-    LogPrint(\"estimatefee\", \"Reading estimates: %u buckets counting confirms up to %u blocks\\n\",\n+    LogPrint(BCLog::ESTIMATEFEE, \"Reading estimates: %u buckets counting confirms up to %u blocks\\n\",\n              numBuckets, maxConfirms);\n }\n \n@@ -260,24 +260,26 @@ void TxConfirmStats::removeTx(unsigned int entryHeight, unsigned int nBestSeenHe\n     if (nBestSeenHeight == 0)  // the BlockPolicyEstimator hasn't seen any blocks yet\n         blocksAgo = 0;\n     if (blocksAgo < 0) {\n-        LogPrint(\"estimatefee\", \"Blockpolicy error, blocks ago is negative for mempool tx\\n\");\n+        LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy error, blocks ago is negative for mempool tx\\n\");\n         return;  //This can't happen because we call this with our best seen height, no entries can have higher\n     }\n \n     if (blocksAgo >= (int)unconfTxs.size()) {\n-        if (oldUnconfTxs[bucketindex] > 0)\n+        if (oldUnconfTxs[bucketindex] > 0) {\n             oldUnconfTxs[bucketindex]--;\n-        else\n-            LogPrint(\"estimatefee\", \"Blockpolicy error, mempool tx removed from >25 blocks,bucketIndex=%u already\\n\",\n+        } else {\n+            LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy error, mempool tx removed from >25 blocks,bucketIndex=%u already\\n\",\n                      bucketindex);\n+        }\n     }\n     else {\n         unsigned int blockIndex = entryHeight % unconfTxs.size();\n-        if (unconfTxs[blockIndex][bucketindex] > 0)\n+        if (unconfTxs[blockIndex][bucketindex] > 0) {\n             unconfTxs[blockIndex][bucketindex]--;\n-        else\n-            LogPrint(\"estimatefee\", \"Blockpolicy error, mempool tx removed from blockIndex=%u,bucketIndex=%u already\\n\",\n+        } else {\n+            LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy error, mempool tx removed from blockIndex=%u,bucketIndex=%u already\\n\",\n                      blockIndex, bucketindex);\n+        }\n     }\n }\n \n@@ -316,7 +318,7 @@ void CBlockPolicyEstimator::processTransaction(const CTxMemPoolEntry& entry, boo\n     unsigned int txHeight = entry.GetHeight();\n     uint256 hash = entry.GetTx().GetHash();\n     if (mapMemPoolTxs.count(hash)) {\n-        LogPrint(\"estimatefee\", \"Blockpolicy error mempool tx %s already being tracked\\n\",\n+        LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy error mempool tx %s already being tracked\\n\",\n                  hash.ToString().c_str());\n \treturn;\n     }\n@@ -358,7 +360,7 @@ bool CBlockPolicyEstimator::processBlockTx(unsigned int nBlockHeight, const CTxM\n     if (blocksToConfirm <= 0) {\n         // This can't happen because we don't process transactions from a block with a height\n         // lower than our greatest seen height\n-        LogPrint(\"estimatefee\", \"Blockpolicy error Transaction had negative blocksToConfirm\\n\");\n+        LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy error Transaction had negative blocksToConfirm\\n\");\n         return false;\n     }\n \n@@ -399,7 +401,7 @@ void CBlockPolicyEstimator::processBlock(unsigned int nBlockHeight,\n     // Update all exponential averages with the current block state\n     feeStats.UpdateMovingAverages();\n \n-    LogPrint(\"estimatefee\", \"Blockpolicy after updating estimates for %u of %u txs in block, since last block %u of %u tracked, new mempool map size %u\\n\",\n+    LogPrint(BCLog::ESTIMATEFEE, \"Blockpolicy after updating estimates for %u of %u txs in block, since last block %u of %u tracked, new mempool map size %u\\n\",\n              countedTxs, entries.size(), trackedTxs, trackedTxs + untrackedTxs, mapMemPoolTxs.size());\n \n     trackedTxs = 0;"
      },
      {
        "sha": "05a3bd71fdc3f38632b9a73be38302cca3dcd1a8",
        "filename": "src/qt/bitcoin.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 4,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/qt/bitcoin.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/qt/bitcoin.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoin.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -152,15 +152,21 @@ static void initTranslations(QTranslator &qtTranslatorBase, QTranslator &qtTrans\n #if QT_VERSION < 0x050000\n void DebugMessageHandler(QtMsgType type, const char *msg)\n {\n-    const char *category = (type == QtDebugMsg) ? \"qt\" : NULL;\n-    LogPrint(category, \"GUI: %s\\n\", msg);\n+    if (type == QtDebugMsg) {\n+        LogPrint(BCLog::QT, \"GUI: %s\\n\", msg);\n+    } else {\n+        LogPrintf(\"GUI: %s\\n\", msg);\n+    }\n }\n #else\n void DebugMessageHandler(QtMsgType type, const QMessageLogContext& context, const QString &msg)\n {\n     Q_UNUSED(context);\n-    const char *category = (type == QtDebugMsg) ? \"qt\" : NULL;\n-    LogPrint(category, \"GUI: %s\\n\", msg.toStdString());\n+    if (type == QtDebugMsg) {\n+        LogPrint(BCLog::QT, \"GUI: %s\\n\", msg.toStdString());\n+    } else {\n+        LogPrintf(\"GUI: %s\\n\", msg.toStdString());\n+    }\n }\n #endif\n "
      },
      {
        "sha": "d81188895b82af6448627574d54fe848d26710df",
        "filename": "src/qt/transactiondesc.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/qt/transactiondesc.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/qt/transactiondesc.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/transactiondesc.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -273,7 +273,7 @@ QString TransactionDesc::toHTML(CWallet *wallet, CWalletTx &wtx, TransactionReco\n     //\n     // Debug view\n     //\n-    if (fDebug)\n+    if (logCategories != BCLog::NONE)\n     {\n         strHTML += \"<hr><br>\" + tr(\"Debug information\") + \"<br><br>\";\n         BOOST_FOREACH(const CTxIn& txin, wtx.tx->vin)"
      },
      {
        "sha": "6bcd0a70bae625eaa2389723ede3a028fa429f69",
        "filename": "src/random.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/random.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/random.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/random.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -91,7 +91,7 @@ static void RandAddSeedPerfmon()\n     if (ret == ERROR_SUCCESS) {\n         RAND_add(vData.data(), nSize, nSize / 100.0);\n         memory_cleanse(vData.data(), nSize);\n-        LogPrint(\"rand\", \"%s: %lu bytes\\n\", __func__, nSize);\n+        LogPrint(BCLog::RAND, \"%s: %lu bytes\\n\", __func__, nSize);\n     } else {\n         static bool warned = false; // Warn only once\n         if (!warned) {"
      },
      {
        "sha": "01066d0eb2e13925c3e050ccab06b90c497937a8",
        "filename": "src/rpc/blockchain.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/rpc/blockchain.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/rpc/blockchain.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/blockchain.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -855,7 +855,7 @@ UniValue pruneblockchain(const JSONRPCRequest& request)\n     else if (height > chainHeight)\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Blockchain is shorter than the attempted prune height.\");\n     else if (height > chainHeight - MIN_BLOCKS_TO_KEEP) {\n-        LogPrint(\"rpc\", \"Attempt to prune blocks close to the tip.  Retaining the minimum number of blocks.\");\n+        LogPrint(BCLog::RPC, \"Attempt to prune blocks close to the tip.  Retaining the minimum number of blocks.\");\n         height = chainHeight - MIN_BLOCKS_TO_KEEP;\n     }\n "
      },
      {
        "sha": "ef9fecd8fe0842c815406b6d4ea806d5998ee786",
        "filename": "src/rpc/server.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 6,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/rpc/server.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/rpc/server.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/server.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -305,22 +305,22 @@ bool CRPCTable::appendCommand(const std::string& name, const CRPCCommand* pcmd)\n \n bool StartRPC()\n {\n-    LogPrint(\"rpc\", \"Starting RPC\\n\");\n+    LogPrint(BCLog::RPC, \"Starting RPC\\n\");\n     fRPCRunning = true;\n     g_rpcSignals.Started();\n     return true;\n }\n \n void InterruptRPC()\n {\n-    LogPrint(\"rpc\", \"Interrupting RPC\\n\");\n+    LogPrint(BCLog::RPC, \"Interrupting RPC\\n\");\n     // Interrupt e.g. running longpolls\n     fRPCRunning = false;\n }\n \n void StopRPC()\n {\n-    LogPrint(\"rpc\", \"Stopping RPC\\n\");\n+    LogPrint(BCLog::RPC, \"Stopping RPC\\n\");\n     deadlineTimers.clear();\n     g_rpcSignals.Stopped();\n }\n@@ -368,8 +368,9 @@ void JSONRPCRequest::parse(const UniValue& valRequest)\n     if (!valMethod.isStr())\n         throw JSONRPCError(RPC_INVALID_REQUEST, \"Method must be a string\");\n     strMethod = valMethod.get_str();\n-    if (strMethod != \"getblocktemplate\")\n-        LogPrint(\"rpc\", \"ThreadRPCServer method=%s\\n\", SanitizeString(strMethod));\n+    if (strMethod != \"getblocktemplate\") {\n+        LogPrint(BCLog::RPC, \"ThreadRPCServer method=%s\\n\", SanitizeString(strMethod));\n+    }\n \n     // Parse params\n     UniValue valParams = find_value(request, \"params\");\n@@ -531,7 +532,7 @@ void RPCRunLater(const std::string& name, boost::function<void(void)> func, int6\n     if (!timerInterface)\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"No timer handler registered for RPC\");\n     deadlineTimers.erase(name);\n-    LogPrint(\"rpc\", \"queue run of timer %s in %i seconds (using %s)\\n\", name, nSeconds, timerInterface->Name());\n+    LogPrint(BCLog::RPC, \"queue run of timer %s in %i seconds (using %s)\\n\", name, nSeconds, timerInterface->Name());\n     deadlineTimers.emplace(name, std::unique_ptr<RPCTimerBase>(timerInterface->NewTimer(func, nSeconds*1000)));\n }\n "
      },
      {
        "sha": "ec749127032b643053fa88625f9a2e8fad2abe51",
        "filename": "src/timedata.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 7,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/timedata.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/timedata.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/timedata.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -58,7 +58,7 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n     // Add data\n     static CMedianFilter<int64_t> vTimeOffsets(BITCOIN_TIMEDATA_MAX_SAMPLES, 0);\n     vTimeOffsets.input(nOffsetSample);\n-    LogPrint(\"net\",\"added time data, samples %d, offset %+d (%+d minutes)\\n\", vTimeOffsets.size(), nOffsetSample, nOffsetSample/60);\n+    LogPrint(BCLog::NET,\"added time data, samples %d, offset %+d (%+d minutes)\\n\", vTimeOffsets.size(), nOffsetSample, nOffsetSample/60);\n \n     // There is a known issue here (see issue #4521):\n     //\n@@ -108,11 +108,14 @@ void AddTimeData(const CNetAddr& ip, int64_t nOffsetSample)\n                 }\n             }\n         }\n-        \n-        BOOST_FOREACH(int64_t n, vSorted)\n-            LogPrint(\"net\", \"%+d  \", n);\n-        LogPrint(\"net\", \"|  \");\n-        \n-        LogPrint(\"net\", \"nTimeOffset = %+d  (%+d minutes)\\n\", nTimeOffset, nTimeOffset/60);\n+\n+        if (LogAcceptCategory(BCLog::NET)) {\n+            BOOST_FOREACH(int64_t n, vSorted) {\n+                LogPrint(BCLog::NET, \"%+d  \", n);\n+            }\n+            LogPrint(BCLog::NET, \"|  \");\n+\n+            LogPrint(BCLog::NET, \"nTimeOffset = %+d  (%+d minutes)\\n\", nTimeOffset, nTimeOffset/60);\n+        }\n     }\n }"
      },
      {
        "sha": "4c88ebe1d5eace230be644ebbbefab943dc673fa",
        "filename": "src/torcontrol.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 18,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/torcontrol.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/torcontrol.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/torcontrol.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -163,7 +163,7 @@ void TorControlConnection::readcb(struct bufferevent *bev, void *ctx)\n                     self->reply_handlers.front()(*self, self->message);\n                     self->reply_handlers.pop_front();\n                 } else {\n-                    LogPrint(\"tor\", \"tor: Received unexpected sync reply %i\\n\", self->message.code);\n+                    LogPrint(BCLog::TOR, \"tor: Received unexpected sync reply %i\\n\", self->message.code);\n                 }\n             }\n             self->message.Clear();\n@@ -182,13 +182,14 @@ void TorControlConnection::eventcb(struct bufferevent *bev, short what, void *ct\n {\n     TorControlConnection *self = (TorControlConnection*)ctx;\n     if (what & BEV_EVENT_CONNECTED) {\n-        LogPrint(\"tor\", \"tor: Successfully connected!\\n\");\n+        LogPrint(BCLog::TOR, \"tor: Successfully connected!\\n\");\n         self->connected(*self);\n     } else if (what & (BEV_EVENT_EOF|BEV_EVENT_ERROR)) {\n-        if (what & BEV_EVENT_ERROR)\n-            LogPrint(\"tor\", \"tor: Error connecting to Tor control socket\\n\");\n-        else\n-            LogPrint(\"tor\", \"tor: End of stream\\n\");\n+        if (what & BEV_EVENT_ERROR) {\n+            LogPrint(BCLog::TOR, \"tor: Error connecting to Tor control socket\\n\");\n+        } else {\n+            LogPrint(BCLog::TOR, \"tor: End of stream\\n\");\n+        }\n         self->Disconnect();\n         self->disconnected(*self);\n     }\n@@ -410,7 +411,7 @@ TorController::TorController(struct event_base* _base, const std::string& _targe\n     // Read service private key if cached\n     std::pair<bool,std::string> pkf = ReadBinaryFile(GetPrivateKeyFile());\n     if (pkf.first) {\n-        LogPrint(\"tor\", \"tor: Reading cached private key from %s\\n\", GetPrivateKeyFile());\n+        LogPrint(BCLog::TOR, \"tor: Reading cached private key from %s\\n\", GetPrivateKeyFile());\n         private_key = pkf.second;\n     }\n }\n@@ -429,7 +430,7 @@ TorController::~TorController()\n void TorController::add_onion_cb(TorControlConnection& _conn, const TorControlReply& reply)\n {\n     if (reply.code == 250) {\n-        LogPrint(\"tor\", \"tor: ADD_ONION successful\\n\");\n+        LogPrint(BCLog::TOR, \"tor: ADD_ONION successful\\n\");\n         BOOST_FOREACH(const std::string &s, reply.lines) {\n             std::map<std::string,std::string> m = ParseTorReplyMapping(s);\n             std::map<std::string,std::string>::iterator i;\n@@ -441,7 +442,7 @@ void TorController::add_onion_cb(TorControlConnection& _conn, const TorControlRe\n         service = LookupNumeric(std::string(service_id+\".onion\").c_str(), GetListenPort());\n         LogPrintf(\"tor: Got service ID %s, advertising service %s\\n\", service_id, service.ToString());\n         if (WriteBinaryFile(GetPrivateKeyFile(), private_key)) {\n-            LogPrint(\"tor\", \"tor: Cached service private key to %s\\n\", GetPrivateKeyFile());\n+            LogPrint(BCLog::TOR, \"tor: Cached service private key to %s\\n\", GetPrivateKeyFile());\n         } else {\n             LogPrintf(\"tor: Error writing service private key to %s\\n\", GetPrivateKeyFile());\n         }\n@@ -457,7 +458,7 @@ void TorController::add_onion_cb(TorControlConnection& _conn, const TorControlRe\n void TorController::auth_cb(TorControlConnection& _conn, const TorControlReply& reply)\n {\n     if (reply.code == 250) {\n-        LogPrint(\"tor\", \"tor: Authentication successful\\n\");\n+        LogPrint(BCLog::TOR, \"tor: Authentication successful\\n\");\n \n         // Now that we know Tor is running setup the proxy for onion addresses\n         // if -onion isn't set to something else.\n@@ -511,13 +512,13 @@ static std::vector<uint8_t> ComputeResponse(const std::string &key, const std::v\n void TorController::authchallenge_cb(TorControlConnection& _conn, const TorControlReply& reply)\n {\n     if (reply.code == 250) {\n-        LogPrint(\"tor\", \"tor: SAFECOOKIE authentication challenge successful\\n\");\n+        LogPrint(BCLog::TOR, \"tor: SAFECOOKIE authentication challenge successful\\n\");\n         std::pair<std::string,std::string> l = SplitTorReplyLine(reply.lines[0]);\n         if (l.first == \"AUTHCHALLENGE\") {\n             std::map<std::string,std::string> m = ParseTorReplyMapping(l.second);\n             std::vector<uint8_t> serverHash = ParseHex(m[\"SERVERHASH\"]);\n             std::vector<uint8_t> serverNonce = ParseHex(m[\"SERVERNONCE\"]);\n-            LogPrint(\"tor\", \"tor: AUTHCHALLENGE ServerHash %s ServerNonce %s\\n\", HexStr(serverHash), HexStr(serverNonce));\n+            LogPrint(BCLog::TOR, \"tor: AUTHCHALLENGE ServerHash %s ServerNonce %s\\n\", HexStr(serverHash), HexStr(serverNonce));\n             if (serverNonce.size() != 32) {\n                 LogPrintf(\"tor: ServerNonce is not 32 bytes, as required by spec\\n\");\n                 return;\n@@ -562,12 +563,12 @@ void TorController::protocolinfo_cb(TorControlConnection& _conn, const TorContro\n                 std::map<std::string,std::string> m = ParseTorReplyMapping(l.second);\n                 std::map<std::string,std::string>::iterator i;\n                 if ((i = m.find(\"Tor\")) != m.end()) {\n-                    LogPrint(\"tor\", \"tor: Connected to Tor version %s\\n\", i->second);\n+                    LogPrint(BCLog::TOR, \"tor: Connected to Tor version %s\\n\", i->second);\n                 }\n             }\n         }\n         BOOST_FOREACH(const std::string &s, methods) {\n-            LogPrint(\"tor\", \"tor: Supported authentication method: %s\\n\", s);\n+            LogPrint(BCLog::TOR, \"tor: Supported authentication method: %s\\n\", s);\n         }\n         // Prefer NULL, otherwise SAFECOOKIE. If a password is provided, use HASHEDPASSWORD\n         /* Authentication:\n@@ -577,18 +578,18 @@ void TorController::protocolinfo_cb(TorControlConnection& _conn, const TorContro\n         std::string torpassword = GetArg(\"-torpassword\", \"\");\n         if (!torpassword.empty()) {\n             if (methods.count(\"HASHEDPASSWORD\")) {\n-                LogPrint(\"tor\", \"tor: Using HASHEDPASSWORD authentication\\n\");\n+                LogPrint(BCLog::TOR, \"tor: Using HASHEDPASSWORD authentication\\n\");\n                 boost::replace_all(torpassword, \"\\\"\", \"\\\\\\\"\");\n                 _conn.Command(\"AUTHENTICATE \\\"\" + torpassword + \"\\\"\", boost::bind(&TorController::auth_cb, this, _1, _2));\n             } else {\n                 LogPrintf(\"tor: Password provided with -torpassword, but HASHEDPASSWORD authentication is not available\\n\");\n             }\n         } else if (methods.count(\"NULL\")) {\n-            LogPrint(\"tor\", \"tor: Using NULL authentication\\n\");\n+            LogPrint(BCLog::TOR, \"tor: Using NULL authentication\\n\");\n             _conn.Command(\"AUTHENTICATE\", boost::bind(&TorController::auth_cb, this, _1, _2));\n         } else if (methods.count(\"SAFECOOKIE\")) {\n             // Cookie: hexdump -e '32/1 \"%02x\"\"\\n\"'  ~/.tor/control_auth_cookie\n-            LogPrint(\"tor\", \"tor: Using SAFECOOKIE authentication, reading cookie authentication from %s\\n\", cookiefile);\n+            LogPrint(BCLog::TOR, \"tor: Using SAFECOOKIE authentication, reading cookie authentication from %s\\n\", cookiefile);\n             std::pair<bool,std::string> status_cookie = ReadBinaryFile(cookiefile, TOR_COOKIE_SIZE);\n             if (status_cookie.first && status_cookie.second.size() == TOR_COOKIE_SIZE) {\n                 // _conn.Command(\"AUTHENTICATE \" + HexStr(status_cookie.second), boost::bind(&TorController::auth_cb, this, _1, _2));\n@@ -630,7 +631,7 @@ void TorController::disconnected_cb(TorControlConnection& _conn)\n     if (!reconnect)\n         return;\n \n-    LogPrint(\"tor\", \"tor: Not connected to Tor control port %s, trying to reconnect\\n\", target);\n+    LogPrint(BCLog::TOR, \"tor: Not connected to Tor control port %s, trying to reconnect\\n\", target);\n \n     // Single-shot timer for reconnect. Use exponential backoff.\n     struct timeval time = MillisToTimeval(int64_t(reconnect_timeout * 1000.0));"
      },
      {
        "sha": "a3889fdf79baeb7882afbdc603829b7b0bf5fe67",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -63,7 +63,7 @@ bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n     if (!hashBlock.IsNull())\n         batch.Write(DB_BEST_BLOCK, hashBlock);\n \n-    LogPrint(\"coindb\", \"Committing %u changed transactions (out of %u) to coin database...\\n\", (unsigned int)changed, (unsigned int)count);\n+    LogPrint(BCLog::COINDB, \"Committing %u changed transactions (out of %u) to coin database...\\n\", (unsigned int)changed, (unsigned int)count);\n     return db.WriteBatch(batch);\n }\n "
      },
      {
        "sha": "36a046ed2a6bb7b533e81381baecfb8b1b0da5cf",
        "filename": "src/txmempool.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 3,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/txmempool.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/txmempool.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txmempool.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -634,7 +634,7 @@ void CTxMemPool::check(const CCoinsViewCache *pcoins) const\n     if (GetRand(std::numeric_limits<uint32_t>::max()) >= nCheckFrequency)\n         return;\n \n-    LogPrint(\"mempool\", \"Checking mempool with %u transactions and %u inputs\\n\", (unsigned int)mapTx.size(), (unsigned int)mapNextTx.size());\n+    LogPrint(BCLog::MEMPOOL, \"Checking mempool with %u transactions and %u inputs\\n\", (unsigned int)mapTx.size(), (unsigned int)mapNextTx.size());\n \n     uint64_t checkTotal = 0;\n     uint64_t innerUsage = 0;\n@@ -1108,8 +1108,9 @@ void CTxMemPool::TrimToSize(size_t sizelimit, std::vector<uint256>* pvNoSpendsRe\n         }\n     }\n \n-    if (maxFeeRateRemoved > CFeeRate(0))\n-        LogPrint(\"mempool\", \"Removed %u txn, rolling minimum fee bumped to %s\\n\", nTxnRemoved, maxFeeRateRemoved.ToString());\n+    if (maxFeeRateRemoved > CFeeRate(0)) {\n+        LogPrint(BCLog::MEMPOOL, \"Removed %u txn, rolling minimum fee bumped to %s\\n\", nTxnRemoved, maxFeeRateRemoved.ToString());\n+    }\n }\n \n bool CTxMemPool::TransactionWithinChainLimit(const uint256& txid, size_t chainLimit) const {"
      },
      {
        "sha": "766826da49dac022202788c6cfe9de896b7ef4a4",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 64,
        "deletions": 28,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -110,7 +110,6 @@ CCriticalSection cs_args;\n std::map<std::string, std::string> mapArgs;\n static std::map<std::string, std::vector<std::string> > _mapMultiArgs;\n const std::map<std::string, std::vector<std::string> >& mapMultiArgs = _mapMultiArgs;\n-bool fDebug = false;\n bool fPrintToConsole = false;\n bool fPrintToDebugLog = true;\n \n@@ -120,6 +119,9 @@ bool fLogIPs = DEFAULT_LOGIPS;\n std::atomic<bool> fReopenDebugLog(false);\n CTranslationInterface translationInterface;\n \n+/** Log categories bitfield. Leveldb/libevent need special handling if their flags are changed at runtime. */\n+std::atomic<uint32_t> logCategories(0);\n+\n /** Init OpenSSL library multithreading support */\n static CCriticalSection** ppmutexOpenSSL;\n void locking_callback(int mode, int i, const char* file, int line) NO_THREAD_SAFETY_ANALYSIS\n@@ -231,36 +233,70 @@ void OpenDebugLog()\n     vMsgsBeforeOpenLog = NULL;\n }\n \n-bool LogAcceptCategory(const char* category)\n-{\n-    if (category != NULL)\n-    {\n-        if (!fDebug)\n-            return false;\n-\n-        // Give each thread quick access to -debug settings.\n-        // This helps prevent issues debugging global destructors,\n-        // where mapMultiArgs might be deleted before another\n-        // global destructor calls LogPrint()\n-        static boost::thread_specific_ptr<std::set<std::string> > ptrCategory;\n-        if (ptrCategory.get() == NULL)\n-        {\n-            if (mapMultiArgs.count(\"-debug\")) {\n-                const std::vector<std::string>& categories = mapMultiArgs.at(\"-debug\");\n-                ptrCategory.reset(new std::set<std::string>(categories.begin(), categories.end()));\n-                // thread_specific_ptr automatically deletes the set when the thread ends.\n-            } else\n-                ptrCategory.reset(new std::set<std::string>());\n+struct CLogCategoryDesc\n+{\n+    uint32_t flag;\n+    std::string category;\n+};\n+\n+const CLogCategoryDesc LogCategories[] =\n+{\n+    {BCLog::NONE, \"0\"},\n+    {BCLog::NET, \"net\"},\n+    {BCLog::TOR, \"tor\"},\n+    {BCLog::MEMPOOL, \"mempool\"},\n+    {BCLog::HTTP, \"http\"},\n+    {BCLog::BENCH, \"bench\"},\n+    {BCLog::ZMQ, \"zmq\"},\n+    {BCLog::DB, \"db\"},\n+    {BCLog::RPC, \"rpc\"},\n+    {BCLog::ESTIMATEFEE, \"estimatefee\"},\n+    {BCLog::ADDRMAN, \"addrman\"},\n+    {BCLog::SELECTCOINS, \"selectcoins\"},\n+    {BCLog::REINDEX, \"reindex\"},\n+    {BCLog::CMPCTBLOCK, \"cmpctblock\"},\n+    {BCLog::RAND, \"rand\"},\n+    {BCLog::PRUNE, \"prune\"},\n+    {BCLog::PROXY, \"proxy\"},\n+    {BCLog::MEMPOOLREJ, \"mempoolrej\"},\n+    {BCLog::LIBEVENT, \"libevent\"},\n+    {BCLog::COINDB, \"coindb\"},\n+    {BCLog::QT, \"qt\"},\n+    {BCLog::LEVELDB, \"leveldb\"},\n+    {BCLog::ALL, \"1\"},\n+    {BCLog::ALL, \"all\"},\n+};\n+\n+bool GetLogCategory(uint32_t *f, const std::string *str)\n+{\n+    if (f && str) {\n+        if (*str == \"\") {\n+            *f = BCLog::ALL;\n+            return true;\n         }\n-        const std::set<std::string>& setCategories = *ptrCategory;\n+        for (unsigned int i = 0; i < ARRAYLEN(LogCategories); i++) {\n+            if (LogCategories[i].category == *str) {\n+                *f = LogCategories[i].flag;\n+                return true;\n+            }\n+        }\n+    }\n+    return false;\n+}\n \n-        // if not debugging everything and not debugging specific category, LogPrint does nothing.\n-        if (setCategories.count(std::string(\"\")) == 0 &&\n-            setCategories.count(std::string(\"1\")) == 0 &&\n-            setCategories.count(std::string(category)) == 0)\n-            return false;\n+std::string ListLogCategories()\n+{\n+    std::string ret;\n+    int outcount = 0;\n+    for (unsigned int i = 0; i < ARRAYLEN(LogCategories); i++) {\n+        // Omit the special cases.\n+        if (LogCategories[i].flag != BCLog::NONE && LogCategories[i].flag != BCLog::ALL) {\n+            if (outcount != 0) ret += \", \";\n+            ret += LogCategories[i].category;\n+            outcount++;\n+        }\n     }\n-    return true;\n+    return ret;\n }\n \n /**"
      },
      {
        "sha": "09481bc01c30bf35abf51f4ae23128f709df7c0c",
        "filename": "src/util.h",
        "status": "modified",
        "additions": 40,
        "deletions": 2,
        "changes": 42,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.h?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -42,7 +42,6 @@ class CTranslationInterface\n };\n \n extern const std::map<std::string, std::vector<std::string> >& mapMultiArgs;\n-extern bool fDebug;\n extern bool fPrintToConsole;\n extern bool fPrintToDebugLog;\n \n@@ -55,6 +54,8 @@ extern CTranslationInterface translationInterface;\n extern const char * const BITCOIN_CONF_FILENAME;\n extern const char * const BITCOIN_PID_FILENAME;\n \n+extern std::atomic<uint32_t> logCategories;\n+\n /**\n  * Translation function: Call Translate signal on UI interface, which returns a boost::optional result.\n  * If no translation slot is registered, nothing is returned, and simply return the input.\n@@ -68,8 +69,45 @@ inline std::string _(const char* psz)\n void SetupEnvironment();\n bool SetupNetworking();\n \n+namespace BCLog {\n+    enum LogFlags : uint32_t {\n+        NONE        = 0,\n+        NET         = (1 <<  0),\n+        TOR         = (1 <<  1),\n+        MEMPOOL     = (1 <<  2),\n+        HTTP        = (1 <<  3),\n+        BENCH       = (1 <<  4),\n+        ZMQ         = (1 <<  5),\n+        DB          = (1 <<  6),\n+        RPC         = (1 <<  7),\n+        ESTIMATEFEE = (1 <<  8),\n+        ADDRMAN     = (1 <<  9),\n+        SELECTCOINS = (1 << 10),\n+        REINDEX     = (1 << 11),\n+        CMPCTBLOCK  = (1 << 12),\n+        RAND        = (1 << 13),\n+        PRUNE       = (1 << 14),\n+        PROXY       = (1 << 15),\n+        MEMPOOLREJ  = (1 << 16),\n+        LIBEVENT    = (1 << 17),\n+        COINDB      = (1 << 18),\n+        QT          = (1 << 19),\n+        LEVELDB     = (1 << 20),\n+        ALL         = ~(uint32_t)0,\n+    };\n+}\n /** Return true if log accepts specified category */\n-bool LogAcceptCategory(const char* category);\n+static inline bool LogAcceptCategory(uint32_t category)\n+{\n+    return (logCategories.load(std::memory_order_relaxed) & category) != 0;\n+}\n+\n+/** Returns a string with the supported log categories */\n+std::string ListLogCategories();\n+\n+/** Return true if str parses as a log category and set the flags in f */\n+bool GetLogCategory(uint32_t *f, const std::string *str);\n+\n /** Send a string to the log output */\n int LogPrintStr(const std::string &str);\n "
      },
      {
        "sha": "6ade633988ac945c168ccbd7b812ae49fa82bb47",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 20,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -540,8 +540,9 @@ bool CheckTransaction(const CTransaction& tx, CValidationState &state, bool fChe\n \n void LimitMempoolSize(CTxMemPool& pool, size_t limit, unsigned long age) {\n     int expired = pool.Expire(GetTime() - age);\n-    if (expired != 0)\n-        LogPrint(\"mempool\", \"Expired %i transactions from the memory pool\\n\", expired);\n+    if (expired != 0) {\n+        LogPrint(BCLog::MEMPOOL, \"Expired %i transactions from the memory pool\\n\", expired);\n+    }\n \n     std::vector<uint256> vNoSpendsRemaining;\n     pool.TrimToSize(limit, &vNoSpendsRemaining);\n@@ -955,7 +956,7 @@ bool AcceptToMemoryPoolWorker(CTxMemPool& pool, CValidationState& state, const C\n         // Remove conflicting transactions from the mempool\n         BOOST_FOREACH(const CTxMemPool::txiter it, allConflicting)\n         {\n-            LogPrint(\"mempool\", \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n+            LogPrint(BCLog::MEMPOOL, \"replacing tx %s with %s for %s BTC additional fees, %d delta bytes\\n\",\n                     it->GetTx().GetHash().ToString(),\n                     hash.ToString(),\n                     FormatMoney(nModifiedFees - nConflictingFees),\n@@ -1763,7 +1764,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     }\n \n     int64_t nTime1 = GetTimeMicros(); nTimeCheck += nTime1 - nTimeStart;\n-    LogPrint(\"bench\", \"    - Sanity checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime1 - nTimeStart), nTimeCheck * 0.000001);\n+    LogPrint(BCLog::BENCH, \"    - Sanity checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime1 - nTimeStart), nTimeCheck * 0.000001);\n \n     // Do not allow blocks that contain transactions which 'overwrite' older transactions,\n     // unless those are already completely spent.\n@@ -1830,7 +1831,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     }\n \n     int64_t nTime2 = GetTimeMicros(); nTimeForks += nTime2 - nTime1;\n-    LogPrint(\"bench\", \"    - Fork checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime2 - nTime1), nTimeForks * 0.000001);\n+    LogPrint(BCLog::BENCH, \"    - Fork checks: %.2fms [%.2fs]\\n\", 0.001 * (nTime2 - nTime1), nTimeForks * 0.000001);\n \n     CBlockUndo blockundo;\n \n@@ -1904,7 +1905,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n         pos.nTxOffset += ::GetSerializeSize(tx, SER_DISK, CLIENT_VERSION);\n     }\n     int64_t nTime3 = GetTimeMicros(); nTimeConnect += nTime3 - nTime2;\n-    LogPrint(\"bench\", \"      - Connect %u transactions: %.2fms (%.3fms/tx, %.3fms/txin) [%.2fs]\\n\", (unsigned)block.vtx.size(), 0.001 * (nTime3 - nTime2), 0.001 * (nTime3 - nTime2) / block.vtx.size(), nInputs <= 1 ? 0 : 0.001 * (nTime3 - nTime2) / (nInputs-1), nTimeConnect * 0.000001);\n+    LogPrint(BCLog::BENCH, \"      - Connect %u transactions: %.2fms (%.3fms/tx, %.3fms/txin) [%.2fs]\\n\", (unsigned)block.vtx.size(), 0.001 * (nTime3 - nTime2), 0.001 * (nTime3 - nTime2) / block.vtx.size(), nInputs <= 1 ? 0 : 0.001 * (nTime3 - nTime2) / (nInputs-1), nTimeConnect * 0.000001);\n \n     CAmount blockReward = nFees + GetBlockSubsidy(pindex->nHeight, chainparams.GetConsensus());\n     if (block.vtx[0]->GetValueOut() > blockReward)\n@@ -1916,7 +1917,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     if (!control.Wait())\n         return state.DoS(100, false);\n     int64_t nTime4 = GetTimeMicros(); nTimeVerify += nTime4 - nTime2;\n-    LogPrint(\"bench\", \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs]\\n\", nInputs - 1, 0.001 * (nTime4 - nTime2), nInputs <= 1 ? 0 : 0.001 * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * 0.000001);\n+    LogPrint(BCLog::BENCH, \"    - Verify %u txins: %.2fms (%.3fms/txin) [%.2fs]\\n\", nInputs - 1, 0.001 * (nTime4 - nTime2), nInputs <= 1 ? 0 : 0.001 * (nTime4 - nTime2) / (nInputs-1), nTimeVerify * 0.000001);\n \n     if (fJustCheck)\n         return true;\n@@ -1948,7 +1949,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n     view.SetBestBlock(pindex->GetBlockHash());\n \n     int64_t nTime5 = GetTimeMicros(); nTimeIndex += nTime5 - nTime4;\n-    LogPrint(\"bench\", \"    - Index writing: %.2fms [%.2fs]\\n\", 0.001 * (nTime5 - nTime4), nTimeIndex * 0.000001);\n+    LogPrint(BCLog::BENCH, \"    - Index writing: %.2fms [%.2fs]\\n\", 0.001 * (nTime5 - nTime4), nTimeIndex * 0.000001);\n \n     // Watch for changes to the previous coinbase transaction.\n     static uint256 hashPrevBestCoinBase;\n@@ -1957,7 +1958,7 @@ bool ConnectBlock(const CBlock& block, CValidationState& state, CBlockIndex* pin\n \n \n     int64_t nTime6 = GetTimeMicros(); nTimeCallbacks += nTime6 - nTime5;\n-    LogPrint(\"bench\", \"    - Callbacks: %.2fms [%.2fs]\\n\", 0.001 * (nTime6 - nTime5), nTimeCallbacks * 0.000001);\n+    LogPrint(BCLog::BENCH, \"    - Callbacks: %.2fms [%.2fs]\\n\", 0.001 * (nTime6 - nTime5), nTimeCallbacks * 0.000001);\n \n     return true;\n }\n@@ -2164,7 +2165,7 @@ bool static DisconnectTip(CValidationState& state, const CChainParams& chainpara\n         bool flushed = view.Flush();\n         assert(flushed);\n     }\n-    LogPrint(\"bench\", \"- Disconnect block: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n+    LogPrint(BCLog::BENCH, \"- Disconnect block: %.2fms\\n\", (GetTimeMicros() - nStart) * 0.001);\n     // Write the chain state to disk, if necessary.\n     if (!FlushStateToDisk(state, FLUSH_STATE_IF_NEEDED))\n         return false;\n@@ -2239,7 +2240,7 @@ bool static ConnectTip(CValidationState& state, const CChainParams& chainparams,\n     // Apply the block atomically to the chain state.\n     int64_t nTime2 = GetTimeMicros(); nTimeReadFromDisk += nTime2 - nTime1;\n     int64_t nTime3;\n-    LogPrint(\"bench\", \"  - Load block from disk: %.2fms [%.2fs]\\n\", (nTime2 - nTime1) * 0.001, nTimeReadFromDisk * 0.000001);\n+    LogPrint(BCLog::BENCH, \"  - Load block from disk: %.2fms [%.2fs]\\n\", (nTime2 - nTime1) * 0.001, nTimeReadFromDisk * 0.000001);\n     {\n         CCoinsViewCache view(pcoinsTip);\n         bool rv = ConnectBlock(blockConnecting, state, pindexNew, view, chainparams);\n@@ -2250,25 +2251,25 @@ bool static ConnectTip(CValidationState& state, const CChainParams& chainparams,\n             return error(\"ConnectTip(): ConnectBlock %s failed\", pindexNew->GetBlockHash().ToString());\n         }\n         nTime3 = GetTimeMicros(); nTimeConnectTotal += nTime3 - nTime2;\n-        LogPrint(\"bench\", \"  - Connect total: %.2fms [%.2fs]\\n\", (nTime3 - nTime2) * 0.001, nTimeConnectTotal * 0.000001);\n+        LogPrint(BCLog::BENCH, \"  - Connect total: %.2fms [%.2fs]\\n\", (nTime3 - nTime2) * 0.001, nTimeConnectTotal * 0.000001);\n         bool flushed = view.Flush();\n         assert(flushed);\n     }\n     int64_t nTime4 = GetTimeMicros(); nTimeFlush += nTime4 - nTime3;\n-    LogPrint(\"bench\", \"  - Flush: %.2fms [%.2fs]\\n\", (nTime4 - nTime3) * 0.001, nTimeFlush * 0.000001);\n+    LogPrint(BCLog::BENCH, \"  - Flush: %.2fms [%.2fs]\\n\", (nTime4 - nTime3) * 0.001, nTimeFlush * 0.000001);\n     // Write the chain state to disk, if necessary.\n     if (!FlushStateToDisk(state, FLUSH_STATE_IF_NEEDED))\n         return false;\n     int64_t nTime5 = GetTimeMicros(); nTimeChainState += nTime5 - nTime4;\n-    LogPrint(\"bench\", \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001);\n+    LogPrint(BCLog::BENCH, \"  - Writing chainstate: %.2fms [%.2fs]\\n\", (nTime5 - nTime4) * 0.001, nTimeChainState * 0.000001);\n     // Remove conflicting transactions from the mempool.;\n     mempool.removeForBlock(blockConnecting.vtx, pindexNew->nHeight);\n     // Update chainActive & related variables.\n     UpdateTip(pindexNew, chainparams);\n \n     int64_t nTime6 = GetTimeMicros(); nTimePostConnect += nTime6 - nTime5; nTimeTotal += nTime6 - nTime1;\n-    LogPrint(\"bench\", \"  - Connect postprocess: %.2fms [%.2fs]\\n\", (nTime6 - nTime5) * 0.001, nTimePostConnect * 0.000001);\n-    LogPrint(\"bench\", \"- Connect block: %.2fms [%.2fs]\\n\", (nTime6 - nTime1) * 0.001, nTimeTotal * 0.000001);\n+    LogPrint(BCLog::BENCH, \"  - Connect postprocess: %.2fms [%.2fs]\\n\", (nTime6 - nTime5) * 0.001, nTimePostConnect * 0.000001);\n+    LogPrint(BCLog::BENCH, \"- Connect block: %.2fms [%.2fs]\\n\", (nTime6 - nTime1) * 0.001, nTimeTotal * 0.000001);\n     return true;\n }\n \n@@ -3391,7 +3392,7 @@ void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight\n         }\n     }\n \n-    LogPrint(\"prune\", \"Prune: target=%dMiB actual=%dMiB diff=%dMiB max_prune_height=%d removed %d blk/rev pairs\\n\",\n+    LogPrint(BCLog::PRUNE, \"Prune: target=%dMiB actual=%dMiB diff=%dMiB max_prune_height=%d removed %d blk/rev pairs\\n\",\n            nPruneTarget/1024/1024, nCurrentUsage/1024/1024,\n            ((int64_t)nPruneTarget - (int64_t)nCurrentUsage)/1024/1024,\n            nLastBlockWeCanPrune, count);\n@@ -3885,7 +3886,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                 // detect out of order blocks, and store them for later\n                 uint256 hash = block.GetHash();\n                 if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex.find(block.hashPrevBlock) == mapBlockIndex.end()) {\n-                    LogPrint(\"reindex\", \"%s: Out of order block %s, parent %s not known\\n\", __func__, hash.ToString(),\n+                    LogPrint(BCLog::REINDEX, \"%s: Out of order block %s, parent %s not known\\n\", __func__, hash.ToString(),\n                             block.hashPrevBlock.ToString());\n                     if (dbp)\n                         mapBlocksUnknownParent.insert(std::make_pair(block.hashPrevBlock, *dbp));\n@@ -3901,7 +3902,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                     if (state.IsError())\n                         break;\n                 } else if (hash != chainparams.GetConsensus().hashGenesisBlock && mapBlockIndex[hash]->nHeight % 1000 == 0) {\n-                    LogPrint(\"reindex\", \"Block Import: already had block %s at height %d\\n\", hash.ToString(), mapBlockIndex[hash]->nHeight);\n+                    LogPrint(BCLog::REINDEX, \"Block Import: already had block %s at height %d\\n\", hash.ToString(), mapBlockIndex[hash]->nHeight);\n                 }\n \n                 // Activate the genesis block so normal node progress can continue\n@@ -3926,7 +3927,7 @@ bool LoadExternalBlockFile(const CChainParams& chainparams, FILE* fileIn, CDiskB\n                         std::shared_ptr<CBlock> pblockrecursive = std::make_shared<CBlock>();\n                         if (ReadBlockFromDisk(*pblockrecursive, it->second, chainparams.GetConsensus()))\n                         {\n-                            LogPrint(\"reindex\", \"%s: Processing out of order child %s of %s\\n\", __func__, pblockrecursive->GetHash().ToString(),\n+                            LogPrint(BCLog::REINDEX, \"%s: Processing out of order child %s of %s\\n\", __func__, pblockrecursive->GetHash().ToString(),\n                                     head.ToString());\n                             LOCK(cs_main);\n                             CValidationState dummy;"
      },
      {
        "sha": "d3333bf1ab8d9624c4739967820b4b72463352fe",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 9,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -118,7 +118,7 @@ void CDBEnv::MakeMock()\n \n     boost::this_thread::interruption_point();\n \n-    LogPrint(\"db\", \"CDBEnv::MakeMock\\n\");\n+    LogPrint(BCLog::DB, \"CDBEnv::MakeMock\\n\");\n \n     dbenv->set_cachesize(1, 0, 1);\n     dbenv->set_lg_bsize(10485760 * 4);\n@@ -560,7 +560,7 @@ void CDBEnv::Flush(bool fShutdown)\n {\n     int64_t nStart = GetTimeMillis();\n     // Flush log data to the actual data file on all files that are not in use\n-    LogPrint(\"db\", \"CDBEnv::Flush: Flush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\");\n+    LogPrint(BCLog::DB, \"CDBEnv::Flush: Flush(%s)%s\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\");\n     if (!fDbEnvInit)\n         return;\n     {\n@@ -569,21 +569,21 @@ void CDBEnv::Flush(bool fShutdown)\n         while (mi != mapFileUseCount.end()) {\n             std::string strFile = (*mi).first;\n             int nRefCount = (*mi).second;\n-            LogPrint(\"db\", \"CDBEnv::Flush: Flushing %s (refcount = %d)...\\n\", strFile, nRefCount);\n+            LogPrint(BCLog::DB, \"CDBEnv::Flush: Flushing %s (refcount = %d)...\\n\", strFile, nRefCount);\n             if (nRefCount == 0) {\n                 // Move log data to the dat file\n                 CloseDb(strFile);\n-                LogPrint(\"db\", \"CDBEnv::Flush: %s checkpoint\\n\", strFile);\n+                LogPrint(BCLog::DB, \"CDBEnv::Flush: %s checkpoint\\n\", strFile);\n                 dbenv->txn_checkpoint(0, 0, 0);\n-                LogPrint(\"db\", \"CDBEnv::Flush: %s detach\\n\", strFile);\n+                LogPrint(BCLog::DB, \"CDBEnv::Flush: %s detach\\n\", strFile);\n                 if (!fMockDb)\n                     dbenv->lsn_reset(strFile.c_str(), 0);\n-                LogPrint(\"db\", \"CDBEnv::Flush: %s closed\\n\", strFile);\n+                LogPrint(BCLog::DB, \"CDBEnv::Flush: %s closed\\n\", strFile);\n                 mapFileUseCount.erase(mi++);\n             } else\n                 mi++;\n         }\n-        LogPrint(\"db\", \"CDBEnv::Flush: Flush(%s)%s took %15dms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\", GetTimeMillis() - nStart);\n+        LogPrint(BCLog::DB, \"CDBEnv::Flush: Flush(%s)%s took %15dms\\n\", fShutdown ? \"true\" : \"false\", fDbEnvInit ? \"\" : \" database not started\", GetTimeMillis() - nStart);\n         if (fShutdown) {\n             char** listp;\n             if (mapFileUseCount.empty()) {\n@@ -617,15 +617,15 @@ bool CDB::PeriodicFlush(std::string strFile)\n             std::map<std::string, int>::iterator mi = bitdb.mapFileUseCount.find(strFile);\n             if (mi != bitdb.mapFileUseCount.end())\n             {\n-                LogPrint(\"db\", \"Flushing %s\\n\", strFile);\n+                LogPrint(BCLog::DB, \"Flushing %s\\n\", strFile);\n                 int64_t nStart = GetTimeMillis();\n \n                 // Flush wallet file so it's self contained\n                 bitdb.CloseDb(strFile);\n                 bitdb.CheckpointLSN(strFile);\n \n                 bitdb.mapFileUseCount.erase(mi++);\n-                LogPrint(\"db\", \"Flushed %s %dms\\n\", strFile, GetTimeMillis() - nStart);\n+                LogPrint(BCLog::DB, \"Flushed %s %dms\\n\", strFile, GetTimeMillis() - nStart);\n                 ret = true;\n             }\n         }"
      },
      {
        "sha": "ccb744c6b2886293be72159a0e8ae562068f5a9e",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -3028,7 +3028,7 @@ UniValue bumpfee(const JSONRPCRequest& request)\n     // If the output would become dust, discard it (converting the dust to fee)\n     poutput->nValue -= nDelta;\n     if (poutput->nValue <= poutput->GetDustThreshold(::dustRelayFee)) {\n-        LogPrint(\"rpc\", \"Bumping fee and discarding dust output\\n\");\n+        LogPrint(BCLog::RPC, \"Bumping fee and discarding dust output\\n\");\n         nNewFee += poutput->nValue;\n         tx.vout.erase(tx.vout.begin() + nOutput);\n     }"
      },
      {
        "sha": "68d4bc35ee27955c77180ba80150f43ccbacae4a",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 9,
        "deletions": 5,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -2172,11 +2172,15 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMin\n                 nValueRet += vValue[i].first;\n             }\n \n-        LogPrint(\"selectcoins\", \"SelectCoins() best subset: \");\n-        for (unsigned int i = 0; i < vValue.size(); i++)\n-            if (vfBest[i])\n-                LogPrint(\"selectcoins\", \"%s \", FormatMoney(vValue[i].first));\n-        LogPrint(\"selectcoins\", \"total %s\\n\", FormatMoney(nBest));\n+        if (LogAcceptCategory(BCLog::SELECTCOINS)) {\n+            LogPrint(BCLog::SELECTCOINS, \"SelectCoins() best subset: \");\n+            for (unsigned int i = 0; i < vValue.size(); i++) {\n+                if (vfBest[i]) {\n+                    LogPrint(BCLog::SELECTCOINS, \"%s \", FormatMoney(vValue[i].first));\n+                }\n+            }\n+            LogPrint(BCLog::SELECTCOINS, \"total %s\\n\", FormatMoney(nBest));\n+        }\n     }\n \n     return true;"
      },
      {
        "sha": "73d79eb45252609336cfd9e0fe73d3b163548e9f",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -745,7 +745,7 @@ DBErrors CWalletDB::ZapSelectTx(std::vector<uint256>& vTxHashIn, std::vector<uin\n         }\n         else if ((*it) == hash) {\n             if(!EraseTx(hash)) {\n-                LogPrint(\"db\", \"Transaction was found for deletion but returned database error: %s\\n\", hash.GetHex());\n+                LogPrint(BCLog::DB, \"Transaction was found for deletion but returned database error: %s\\n\", hash.GetHex());\n                 delerror = true;\n             }\n             vTxHashOut.push_back(hash);"
      },
      {
        "sha": "fac2a3c57a4fc372d3045e9adc0996050cecd59d",
        "filename": "src/zmq/zmqnotificationinterface.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/zmq/zmqnotificationinterface.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/zmq/zmqnotificationinterface.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqnotificationinterface.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -12,7 +12,7 @@\n \n void zmqError(const char *str)\n {\n-    LogPrint(\"zmq\", \"zmq: Error: %s, errno=%s\\n\", str, zmq_strerror(errno));\n+    LogPrint(BCLog::ZMQ, \"zmq: Error: %s, errno=%s\\n\", str, zmq_strerror(errno));\n }\n \n CZMQNotificationInterface::CZMQNotificationInterface() : pcontext(NULL)\n@@ -72,7 +72,7 @@ CZMQNotificationInterface* CZMQNotificationInterface::Create()\n // Called at startup to conditionally set up ZMQ socket(s)\n bool CZMQNotificationInterface::Initialize()\n {\n-    LogPrint(\"zmq\", \"zmq: Initialize notification interface\\n\");\n+    LogPrint(BCLog::ZMQ, \"zmq: Initialize notification interface\\n\");\n     assert(!pcontext);\n \n     pcontext = zmq_init(1);\n@@ -89,11 +89,11 @@ bool CZMQNotificationInterface::Initialize()\n         CZMQAbstractNotifier *notifier = *i;\n         if (notifier->Initialize(pcontext))\n         {\n-            LogPrint(\"zmq\", \"  Notifier %s ready (address = %s)\\n\", notifier->GetType(), notifier->GetAddress());\n+            LogPrint(BCLog::ZMQ, \"  Notifier %s ready (address = %s)\\n\", notifier->GetType(), notifier->GetAddress());\n         }\n         else\n         {\n-            LogPrint(\"zmq\", \"  Notifier %s failed (address = %s)\\n\", notifier->GetType(), notifier->GetAddress());\n+            LogPrint(BCLog::ZMQ, \"  Notifier %s failed (address = %s)\\n\", notifier->GetType(), notifier->GetAddress());\n             break;\n         }\n     }\n@@ -109,13 +109,13 @@ bool CZMQNotificationInterface::Initialize()\n // Called during shutdown sequence\n void CZMQNotificationInterface::Shutdown()\n {\n-    LogPrint(\"zmq\", \"zmq: Shutdown notification interface\\n\");\n+    LogPrint(BCLog::ZMQ, \"zmq: Shutdown notification interface\\n\");\n     if (pcontext)\n     {\n         for (std::list<CZMQAbstractNotifier*>::iterator i=notifiers.begin(); i!=notifiers.end(); ++i)\n         {\n             CZMQAbstractNotifier *notifier = *i;\n-            LogPrint(\"zmq\", \"   Shutdown notifier %s at %s\\n\", notifier->GetType(), notifier->GetAddress());\n+            LogPrint(BCLog::ZMQ, \"   Shutdown notifier %s at %s\\n\", notifier->GetType(), notifier->GetAddress());\n             notifier->Shutdown();\n         }\n         zmq_ctx_destroy(pcontext);"
      },
      {
        "sha": "b2963e9bded68684ef7eaa060ad1411933f12707",
        "filename": "src/zmq/zmqpublishnotifier.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/zmq/zmqpublishnotifier.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6b3bb3d9bae730d26ddd561b93efc667f5c8d499/src/zmq/zmqpublishnotifier.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/zmq/zmqpublishnotifier.cpp?ref=6b3bb3d9bae730d26ddd561b93efc667f5c8d499",
        "patch": "@@ -89,7 +89,7 @@ bool CZMQAbstractPublishNotifier::Initialize(void *pcontext)\n     }\n     else\n     {\n-        LogPrint(\"zmq\", \"zmq: Reusing socket for address %s\\n\", address);\n+        LogPrint(BCLog::ZMQ, \"zmq: Reusing socket for address %s\\n\", address);\n \n         psocket = i->second->psocket;\n         mapPublishNotifiers.insert(std::make_pair(address, this));\n@@ -119,7 +119,7 @@ void CZMQAbstractPublishNotifier::Shutdown()\n \n     if (count == 1)\n     {\n-        LogPrint(\"zmq\", \"Close socket at address %s\\n\", address);\n+        LogPrint(BCLog::ZMQ, \"Close socket at address %s\\n\", address);\n         int linger = 0;\n         zmq_setsockopt(psocket, ZMQ_LINGER, &linger, sizeof(linger));\n         zmq_close(psocket);\n@@ -148,7 +148,7 @@ bool CZMQAbstractPublishNotifier::SendMessage(const char *command, const void* d\n bool CZMQPublishHashBlockNotifier::NotifyBlock(const CBlockIndex *pindex)\n {\n     uint256 hash = pindex->GetBlockHash();\n-    LogPrint(\"zmq\", \"zmq: Publish hashblock %s\\n\", hash.GetHex());\n+    LogPrint(BCLog::ZMQ, \"zmq: Publish hashblock %s\\n\", hash.GetHex());\n     char data[32];\n     for (unsigned int i = 0; i < 32; i++)\n         data[31 - i] = hash.begin()[i];\n@@ -158,7 +158,7 @@ bool CZMQPublishHashBlockNotifier::NotifyBlock(const CBlockIndex *pindex)\n bool CZMQPublishHashTransactionNotifier::NotifyTransaction(const CTransaction &transaction)\n {\n     uint256 hash = transaction.GetHash();\n-    LogPrint(\"zmq\", \"zmq: Publish hashtx %s\\n\", hash.GetHex());\n+    LogPrint(BCLog::ZMQ, \"zmq: Publish hashtx %s\\n\", hash.GetHex());\n     char data[32];\n     for (unsigned int i = 0; i < 32; i++)\n         data[31 - i] = hash.begin()[i];\n@@ -167,7 +167,7 @@ bool CZMQPublishHashTransactionNotifier::NotifyTransaction(const CTransaction &t\n \n bool CZMQPublishRawBlockNotifier::NotifyBlock(const CBlockIndex *pindex)\n {\n-    LogPrint(\"zmq\", \"zmq: Publish rawblock %s\\n\", pindex->GetBlockHash().GetHex());\n+    LogPrint(BCLog::ZMQ, \"zmq: Publish rawblock %s\\n\", pindex->GetBlockHash().GetHex());\n \n     const Consensus::Params& consensusParams = Params().GetConsensus();\n     CDataStream ss(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());\n@@ -189,7 +189,7 @@ bool CZMQPublishRawBlockNotifier::NotifyBlock(const CBlockIndex *pindex)\n bool CZMQPublishRawTransactionNotifier::NotifyTransaction(const CTransaction &transaction)\n {\n     uint256 hash = transaction.GetHash();\n-    LogPrint(\"zmq\", \"zmq: Publish rawtx %s\\n\", hash.GetHex());\n+    LogPrint(BCLog::ZMQ, \"zmq: Publish rawtx %s\\n\", hash.GetHex());\n     CDataStream ss(SER_NETWORK, PROTOCOL_VERSION | RPCSerializationFlags());\n     ss << transaction;\n     return SendMessage(MSG_RAWTX, &(*ss.begin()), ss.size());"
      }
    ]
  }
]