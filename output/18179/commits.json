[
  {
    "sha": "46f4c3e5dd9e8ee21f5efbd1702798704383f832",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0NmY0YzNlNWRkOWU4ZWUyMWY1ZWZiZDE3MDI3OTg3MDQzODNmODMy",
    "commit": {
      "author": {
        "name": "Jeremy Rubin",
        "email": "j@rubin.io",
        "date": "2019-03-29T21:48:20Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-03T19:26:01Z"
      },
      "message": "Adds a rust library to bitcoin to demonstrate linking and building rust code.\n\nThe demonstration library compiles a rust hello world example and auto-generates\na header which can be included in C++ code.\n\nCo-Authored-By: Jeremy Rubin <j@rubin.io>\nCo-Authored-By: Cory Fields <cory-nospam-@coryfields.com>\nVarious changes by: Matt Corallo <git@bluematt.me>",
      "tree": {
        "sha": "20d2b62ca908dd2d4f0a4165f75c52c518dab79f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/20d2b62ca908dd2d4f0a4165f75c52c518dab79f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/46f4c3e5dd9e8ee21f5efbd1702798704383f832",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/46f4c3e5dd9e8ee21f5efbd1702798704383f832",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/46f4c3e5dd9e8ee21f5efbd1702798704383f832",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/46f4c3e5dd9e8ee21f5efbd1702798704383f832/comments",
    "author": {
      "login": "JeremyRubin",
      "id": 886523,
      "node_id": "MDQ6VXNlcjg4NjUyMw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/886523?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/JeremyRubin",
      "html_url": "https://github.com/JeremyRubin",
      "followers_url": "https://api.github.com/users/JeremyRubin/followers",
      "following_url": "https://api.github.com/users/JeremyRubin/following{/other_user}",
      "gists_url": "https://api.github.com/users/JeremyRubin/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/JeremyRubin/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/JeremyRubin/subscriptions",
      "organizations_url": "https://api.github.com/users/JeremyRubin/orgs",
      "repos_url": "https://api.github.com/users/JeremyRubin/repos",
      "events_url": "https://api.github.com/users/JeremyRubin/events{/privacy}",
      "received_events_url": "https://api.github.com/users/JeremyRubin/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "463eab5e1418a592036e7bf9bf46f66fe6462435",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/463eab5e1418a592036e7bf9bf46f66fe6462435",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/463eab5e1418a592036e7bf9bf46f66fe6462435"
      }
    ],
    "stats": {
      "total": 140,
      "additions": 132,
      "deletions": 8
    },
    "files": [
      {
        "sha": "aba4ccc29c0e80a81a8d45d07bb0dfd33887dd44",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46f4c3e5dd9e8ee21f5efbd1702798704383f832/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46f4c3e5dd9e8ee21f5efbd1702798704383f832/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=46f4c3e5dd9e8ee21f5efbd1702798704383f832",
        "patch": "@@ -211,6 +211,12 @@ AC_ARG_ENABLE([asm],\n   [use_asm=$enableval],\n   [use_asm=yes])\n \n+AC_ARG_ENABLE([rust],\n+  [AS_HELP_STRING([--enable-rust],\n+  [Enable rust code (default is yes)])],\n+  [use_rust=$enableval],\n+  [use_rust=yes])\n+\n if test \"x$use_asm\" = xyes; then\n   AC_DEFINE(USE_ASM, 1, [Define this symbol to build in assembly routines])\n fi\n@@ -476,6 +482,33 @@ AC_ARG_WITH([daemon],\n   [build_bitcoind=$withval],\n   [build_bitcoind=yes])\n \n+if test \"x$use_rust\" = xyes; then\n+  AC_PATH_PROG(RUSTC,rustc,none)\n+  if test x$RUSTC = xnone || test x$RUSTC = x; then\n+    use_rust=no\n+    AC_MSG_WARN(\"rustc required to enable rust support.\")\n+  else\n+    AC_DEFINE(ENABLE_RUSTY, 1, [Define this symbol to build in rust modules])\n+\n+    dnl Find the additional lib (if any) responsible for handling\n+    dnl dlopen/dlsym/etc.\n+    TEMP_LIBS=\"$LIBS\"\n+    LIBS=\n+    AC_SEARCH_LIBS([dlsym],[dl])\n+    DL_LIBS=\"$LIBS\"\n+    LIBS=\"$TEMP_LIBS\"\n+\n+    case $host in\n+      ${host_cpu}-w64-mingw*) RUST_TARGET=${host_cpu}-pc-windows-gnu ;;\n+      ${host_cpu}-pc-linux*) RUST_TARGET=\"${host_cpu}-unknown-${host_os}\" ;;\n+      ${host_cpu}-apple-darwin*) RUST_TARGET=${host_cpu}-apple-darwin ;;\n+      *) RUST_TARGET=\"${host}\" ;;\n+    esac\n+\n+    dnl TODO: create a rust test project and check host_alias as well as host.\n+  fi\n+fi\n+\n use_pkgconfig=yes\n case $host in\n   *mingw*)\n@@ -1530,6 +1563,7 @@ AM_CONDITIONAL([ENABLE_SSE41],[test x$enable_sse41 = xyes])\n AM_CONDITIONAL([ENABLE_AVX2],[test x$enable_avx2 = xyes])\n AM_CONDITIONAL([ENABLE_SHANI],[test x$enable_shani = xyes])\n AM_CONDITIONAL([USE_ASM],[test x$use_asm = xyes])\n+AM_CONDITIONAL([ENABLE_RUSTY], [test x$use_rust = xyes])\n \n AC_DEFINE(CLIENT_VERSION_MAJOR, _CLIENT_VERSION_MAJOR, [Major version])\n AC_DEFINE(CLIENT_VERSION_MINOR, _CLIENT_VERSION_MINOR, [Minor version])\n@@ -1589,6 +1623,8 @@ AC_SUBST(EVENT_LIBS)\n AC_SUBST(EVENT_PTHREADS_LIBS)\n AC_SUBST(ZMQ_LIBS)\n AC_SUBST(QR_LIBS)\n+AC_SUBST(DL_LIBS)\n+AC_SUBST(RUST_TARGET)\n AC_CONFIG_FILES([Makefile src/Makefile doc/man/Makefile share/setup.nsi share/qt/Info.plist test/config.ini])\n AC_CONFIG_FILES([contrib/devtools/split-debug.sh],[chmod +x contrib/devtools/split-debug.sh])\n AM_COND_IF([HAVE_DOXYGEN], [AC_CONFIG_FILES([doc/Doxyfile])])"
      },
      {
        "sha": "02272ebce1db0f7238b271b770e2ec3e345d3339",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 42,
        "deletions": 4,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=46f4c3e5dd9e8ee21f5efbd1702798704383f832",
        "patch": "@@ -9,6 +9,8 @@ AM_CXXFLAGS = $(DEBUG_CXXFLAGS) $(HARDENED_CXXFLAGS) $(WARN_CXXFLAGS) $(NOWARN_C\n AM_CPPFLAGS = $(DEBUG_CPPFLAGS) $(HARDENED_CPPFLAGS)\n AM_LIBTOOLFLAGS = --preserve-dup-deps\n EXTRA_LIBRARIES =\n+CLEANFILES =\n+LIBBITCOIN_RUST_LIBS =\n \n if EMBEDDED_UNIVALUE\n LIBUNIVALUE = univalue/libunivalue.la\n@@ -33,6 +35,9 @@ LIBBITCOIN_CRYPTO_BASE=crypto/libbitcoin_crypto_base.a\n LIBBITCOINQT=qt/libbitcoinqt.a\n LIBSECP256K1=secp256k1/libsecp256k1.la\n \n+if ENABLE_RUSTY\n+LIBBITCOIN_RUSTY = rusty/librusty.a\n+endif\n if ENABLE_ZMQ\n LIBBITCOIN_ZMQ=libbitcoin_zmq.a\n endif\n@@ -359,6 +364,22 @@ libbitcoin_wallet_tool_a_SOURCES = \\\n   wallet/wallettool.cpp \\\n   $(BITCOIN_CORE_H)\n \n+# rustc only reqires the main .rs file as input, but rustc must also be invoked\n+# if any of the other files change. List the main file first, then targets can\n+# depend on $(LIBBITCOIN_RUSTY_SRCS), but only build the first source file ($<).\n+LIBBITCOIN_RUSTY_SRCS= \\\n+  rusty/src/lib.rs\n+\n+# We force overflow checks on so that any integer overflows result in a panic\n+# instead of, eg, attempting to alloc 4GB of memory (though we will catch such\n+# an alloc and refuse it, generating a panic instead).\n+# Also force panics to unwind (instead of calling abort()) as we want to catch\n+# panics in the Rust threads and simply close the thread, instead of bringing\n+# down the rest of Bitcoin Core.\n+$(LIBBITCOIN_RUSTY): $(LIBBITCOIN_RUSTY_SRCS)\n+\t$(RUSTC) --crate-name rusty $< --target=$(RUST_TARGET) --crate-type=staticlib --emit=link -g -O -C overflow-checks=on -C panic=unwind --out-dir $(@D)\n+\ttouch $@\n+\n # crypto primitives library\n crypto_libbitcoin_crypto_base_a_CPPFLAGS = $(AM_CPPFLAGS)\n crypto_libbitcoin_crypto_base_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n@@ -563,7 +584,7 @@ bitcoind_LDADD = \\\n   $(LIBMEMENV) \\\n   $(LIBSECP256K1)\n \n-bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS)\n+bitcoind_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(ZMQ_LIBS) $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n \n # bitcoin-cli binary #\n bitcoin_cli_SOURCES = bitcoin-cli.cpp\n@@ -629,7 +650,7 @@ bitcoin_wallet_LDADD = \\\n   $(LIBSECP256K1) \\\n   $(LIBUNIVALUE)\n \n-bitcoin_wallet_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(CRYPTO_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(MINIUPNPC_LIBS) $(ZMQ_LIBS)\n+bitcoin_wallet_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(CRYPTO_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(MINIUPNPC_LIBS) $(ZMQ_LIBS) $(DL_LIBS)\n #\n \n # bitcoinconsensus library #\n@@ -655,7 +676,23 @@ CTAES_DIST += crypto/ctaes/ctaes.h\n CTAES_DIST += crypto/ctaes/README.md\n CTAES_DIST += crypto/ctaes/test.c\n \n-CLEANFILES = $(EXTRA_LIBRARIES)\n+BITCOIN_CORE_H += rusty/src/rust_bridge.h\n+\n+if ENABLE_RUSTY\n+LIBBITCOIN_RUST_LIBS += $(LIBBITCOIN_RUSTY)\n+\n+RUSTY_TEST_BIN=rusty/test_rusty\n+$(RUSTY_TEST_BIN): $(LIBBITCOIN_RUSTY_SRCS)\n+\t$(RUSTC) --crate-name test_rusty $< --target=$(RUST_TARGET) --emit=link --test -C debuginfo=2 -C overflow-checks=on --out-dir $(@D)\n+\n+## FIXME: always build RUSTY_TEST_BIN the same as we do test_bitcoin\n+RUSTY_CHECK=rusty-check\n+$(RUSTY_CHECK): $(RUSTY_TEST_BIN)\n+\t$(RUSTY_TEST_BIN)\n+\n+CLEANFILES += $(LIBBITCOIN_RUSTY)\n+endif\n+CLEANFILES += $(EXTRA_LIBRARIES)\n \n CLEANFILES += *.gcda *.gcno\n CLEANFILES += compat/*.gcda compat/*.gcno\n@@ -671,7 +708,7 @@ CLEANFILES += wallet/test/*.gcda wallet/test/*.gcno\n CLEANFILES += zmq/*.gcda zmq/*.gcno\n CLEANFILES += obj/build.h\n \n-EXTRA_DIST = $(CTAES_DIST)\n+EXTRA_DIST = $(CTAES_DIST) $(LIBBITCOIN_RUSTY_SRCS)\n \n \n config/bitcoin-config.h: config/stamp-h1\n@@ -684,6 +721,7 @@ $(top_srcdir)/$(subdir)/config/bitcoin-config.h.in:  $(am__configure_deps)\n clean-local:\n \t-$(MAKE) -C secp256k1 clean\n \t-$(MAKE) -C univalue clean\n+\t-rm -rf rusty/test_rusty rusty/test_rusty.dSYM\n \t-rm -f leveldb/*/*.gcda leveldb/*/*.gcno leveldb/helpers/memenv/*.gcda leveldb/helpers/memenv/*.gcno\n \t-rm -f config.h\n \t-rm -rf test/__pycache__"
      },
      {
        "sha": "293970488d4175de29e8e70a68df42ac06ec9b9d",
        "filename": "src/Makefile.bench.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/Makefile.bench.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/Makefile.bench.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.bench.include?ref=46f4c3e5dd9e8ee21f5efbd1702798704383f832",
        "patch": "@@ -76,7 +76,7 @@ bench_bench_bitcoin_SOURCES += bench/coin_selection.cpp\n bench_bench_bitcoin_SOURCES += bench/wallet_balance.cpp\n endif\n \n-bench_bench_bitcoin_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(CRYPTO_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(MINIUPNPC_LIBS)\n+bench_bench_bitcoin_LDADD += $(BOOST_LIBS) $(BDB_LIBS) $(CRYPTO_LIBS) $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(MINIUPNPC_LIBS) $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n bench_bench_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n \n CLEAN_BITCOIN_BENCH = bench/*.gcda bench/*.gcno $(GENERATED_BENCH_FILES)"
      },
      {
        "sha": "ebb4e90a3beb3160f5a0c7c1f4168da27e606289",
        "filename": "src/Makefile.qt.include",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/Makefile.qt.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/Makefile.qt.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qt.include?ref=46f4c3e5dd9e8ee21f5efbd1702798704383f832",
        "patch": "@@ -315,6 +315,7 @@ qt_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL)\n   $(BOOST_LIBS) $(QT_LIBS) $(QT_DBUS_LIBS) $(QR_LIBS) $(BDB_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n   $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n qt_bitcoin_qt_LDADD += $(CRYPTO_LIBS)\n+qt_bitcoin_qt_LDADD += $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n qt_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n qt_bitcoin_qt_LIBTOOLFLAGS = $(AM_LIBTOOLFLAGS) --tag CXX\n "
      },
      {
        "sha": "b39a0ee37ee3cc2b3081ff2cca585e1e38f93ce7",
        "filename": "src/Makefile.qttest.include",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/Makefile.qttest.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/Makefile.qttest.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.qttest.include?ref=46f4c3e5dd9e8ee21f5efbd1702798704383f832",
        "patch": "@@ -64,7 +64,7 @@ endif\n qt_test_test_bitcoin_qt_LDADD += $(LIBBITCOIN_CLI) $(LIBBITCOIN_COMMON) $(LIBBITCOIN_UTIL) $(LIBBITCOIN_CONSENSUS) $(LIBBITCOIN_CRYPTO) $(LIBUNIVALUE) $(LIBLEVELDB) \\\n   $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(QT_DBUS_LIBS) $(QT_TEST_LIBS) $(QT_LIBS) \\\n   $(QR_LIBS) $(BDB_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(LIBSECP256K1) \\\n-  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS)\n+  $(EVENT_PTHREADS_LIBS) $(EVENT_LIBS) $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n qt_test_test_bitcoin_qt_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(QT_LDFLAGS) $(LIBTOOL_APP_LDFLAGS)\n qt_test_test_bitcoin_qt_CXXFLAGS = $(AM_CXXFLAGS) $(QT_PIE_FLAGS)\n "
      },
      {
        "sha": "631b6ed4071fcfebb88cdb361a17bc47768a67a3",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=46f4c3e5dd9e8ee21f5efbd1702798704383f832",
        "patch": "@@ -196,7 +196,7 @@ test_test_bitcoin_LDADD += $(LIBBITCOIN_SERVER) $(LIBBITCOIN_CLI) $(LIBBITCOIN_C\n   $(LIBLEVELDB) $(LIBLEVELDB_SSE42) $(LIBMEMENV) $(BOOST_LIBS) $(BOOST_UNIT_TEST_FRAMEWORK_LIB) $(LIBSECP256K1) $(EVENT_LIBS) $(EVENT_PTHREADS_LIBS)\n test_test_bitcoin_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n \n-test_test_bitcoin_LDADD += $(BDB_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(RAPIDCHECK_LIBS)\n+test_test_bitcoin_LDADD += $(BDB_LIBS) $(CRYPTO_LIBS) $(MINIUPNPC_LIBS) $(RAPIDCHECK_LIBS) $(LIBBITCOIN_RUST_LIBS) $(DL_LIBS)\n test_test_bitcoin_LDFLAGS = $(RELDFLAGS) $(AM_LDFLAGS) $(LIBTOOL_APP_LDFLAGS) -static\n \n if ENABLE_ZMQ\n@@ -386,7 +386,7 @@ bitcoin_test_check: $(TEST_BINARY) FORCE\n bitcoin_test_clean : FORCE\n \trm -f $(CLEAN_BITCOIN_TEST) $(test_test_bitcoin_OBJECTS) $(TEST_BINARY)\n \n-check-local: $(BITCOIN_TESTS:.cpp=.cpp.test)\n+check-local: $(RUSTY_CHECK) $(BITCOIN_TESTS:.cpp=.cpp.test)\n if BUILD_BITCOIN_TX\n \t@echo \"Running test/util/bitcoin-util-test.py...\"\n \t$(PYTHON) $(top_builddir)/test/util/bitcoin-util-test.py"
      },
      {
        "sha": "21e6606d1d9e6107c12cd1ca16ef13ad9ca338f7",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=46f4c3e5dd9e8ee21f5efbd1702798704383f832",
        "patch": "@@ -336,8 +336,16 @@ static void OnRPCStopped()\n     LogPrint(BCLog::RPC, \"RPC stopped.\\n\");\n }\n \n+#if ENABLE_RUSTY\n+#include <rusty/src/rust_bridge.h>\n+#endif\n+\n void SetupServerArgs()\n {\n+#if ENABLE_RUSTY\n+    assert(rust_hello_world_example::RUST_CONSTANT == 43);\n+    rust_hello_world_example::hello_world();\n+#endif\n     SetupHelpOptions(gArgs);\n     gArgs.AddArg(\"-help-debug\", \"Print help message with debugging options and exit\", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST); // server-only for now\n "
      },
      {
        "sha": "855c7706ae1d8a5ec2367dee76c3550eb48b7ad1",
        "filename": "src/rusty/src/lib.rs",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/rusty/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/rusty/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/lib.rs?ref=46f4c3e5dd9e8ee21f5efbd1702798704383f832",
        "patch": "@@ -0,0 +1,15 @@\n+#[cfg(test)]\n+mod tests {\n+    #[test]\n+    fn it_works() {\n+        assert_eq!(2 + 2, 4);\n+    }\n+}\n+\n+#[no_mangle]\n+pub static RUST_CONSTANT: i32 = 43;\n+\n+#[no_mangle]\n+pub extern \"C\" fn hello_world() {\n+    println!(\"Hello World!\");\n+}"
      },
      {
        "sha": "a26f97cc783ea5b3cf52ea228d9fcb21f0346585",
        "filename": "src/rusty/src/rust_bridge.h",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/rusty/src/rust_bridge.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/46f4c3e5dd9e8ee21f5efbd1702798704383f832/src/rusty/src/rust_bridge.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/rust_bridge.h?ref=46f4c3e5dd9e8ee21f5efbd1702798704383f832",
        "patch": "@@ -0,0 +1,26 @@\n+// Rust functions which are exposed to C++ (ie are #[no_mangle] pub extern \"C\")\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_RUSTY_H\n+#define BITCOIN_RUSTY_H\n+\n+#include <cstdarg>\n+#include <cstdint>\n+#include <cstdlib>\n+#include <new>\n+\n+namespace rust_hello_world_example {\n+\n+extern \"C\" {\n+\n+extern int32_t RUST_CONSTANT;\n+\n+void hello_world();\n+\n+} // extern \"C\"\n+\n+} // namespace rust_hello_world_example\n+\n+#endif // BITCOIN_RUSTY_H"
      }
    ]
  },
  {
    "sha": "8c2ee655883ef3bad3c6dc1a01c46b8bf561a92e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YzJlZTY1NTg4M2VmM2JhZDNjNmRjMWEwMWM0NmI4YmY1NjFhOTJl",
    "commit": {
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2019-06-15T10:44:20Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-03T19:26:01Z"
      },
      "message": "build: show rust enabled in configure output",
      "tree": {
        "sha": "89ff2f1e9edd50d98211652ee67d772e0bff1469",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/89ff2f1e9edd50d98211652ee67d772e0bff1469"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8c2ee655883ef3bad3c6dc1a01c46b8bf561a92e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c2ee655883ef3bad3c6dc1a01c46b8bf561a92e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8c2ee655883ef3bad3c6dc1a01c46b8bf561a92e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c2ee655883ef3bad3c6dc1a01c46b8bf561a92e/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "46f4c3e5dd9e8ee21f5efbd1702798704383f832",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/46f4c3e5dd9e8ee21f5efbd1702798704383f832",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/46f4c3e5dd9e8ee21f5efbd1702798704383f832"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "1191601faca5b6b553b4eea987d568222c40c490",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8c2ee655883ef3bad3c6dc1a01c46b8bf561a92e/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8c2ee655883ef3bad3c6dc1a01c46b8bf561a92e/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=8c2ee655883ef3bad3c6dc1a01c46b8bf561a92e",
        "patch": "@@ -1693,6 +1693,7 @@ echo \"  sanitizers    = $use_sanitizers\"\n echo \"  debug enabled = $enable_debug\"\n echo \"  gprof enabled = $enable_gprof\"\n echo \"  werror        = $enable_werror\"\n+echo \"  rust enabled  = $use_rust\"\n echo\n echo \"  target os     = $TARGET_OS\"\n echo \"  build os      = $BUILD_OS\""
      }
    ]
  },
  {
    "sha": "8fd3b4a8fbebbb4e5ed3a8c2e0b01ad52b46f7a4",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZmQzYjRhOGZiZWJiYjRlNWVkM2E4YzJlMGIwMWFkNTJiNDZmN2E0",
    "commit": {
      "author": {
        "name": "fanquake",
        "email": "fanquake@gmail.com",
        "date": "2019-06-15T10:44:58Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-03T19:26:01Z"
      },
      "message": "build: gitignore src/rusty_test",
      "tree": {
        "sha": "b67a9e485ac2a53058b65aa8954e7e4372bb803f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b67a9e485ac2a53058b65aa8954e7e4372bb803f"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8fd3b4a8fbebbb4e5ed3a8c2e0b01ad52b46f7a4",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8fd3b4a8fbebbb4e5ed3a8c2e0b01ad52b46f7a4",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8fd3b4a8fbebbb4e5ed3a8c2e0b01ad52b46f7a4",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8fd3b4a8fbebbb4e5ed3a8c2e0b01ad52b46f7a4/comments",
    "author": {
      "login": "fanquake",
      "id": 863730,
      "node_id": "MDQ6VXNlcjg2MzczMA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/863730?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/fanquake",
      "html_url": "https://github.com/fanquake",
      "followers_url": "https://api.github.com/users/fanquake/followers",
      "following_url": "https://api.github.com/users/fanquake/following{/other_user}",
      "gists_url": "https://api.github.com/users/fanquake/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/fanquake/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/fanquake/subscriptions",
      "organizations_url": "https://api.github.com/users/fanquake/orgs",
      "repos_url": "https://api.github.com/users/fanquake/repos",
      "events_url": "https://api.github.com/users/fanquake/events{/privacy}",
      "received_events_url": "https://api.github.com/users/fanquake/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8c2ee655883ef3bad3c6dc1a01c46b8bf561a92e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8c2ee655883ef3bad3c6dc1a01c46b8bf561a92e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8c2ee655883ef3bad3c6dc1a01c46b8bf561a92e"
      }
    ],
    "stats": {
      "total": 1,
      "additions": 1,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7b20a3fb37236fa5bc7dbe242a81eb5506c98e80",
        "filename": ".gitignore",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8fd3b4a8fbebbb4e5ed3a8c2e0b01ad52b46f7a4/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8fd3b4a8fbebbb4e5ed3a8c2e0b01ad52b46f7a4/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.gitignore?ref=8fd3b4a8fbebbb4e5ed3a8c2e0b01ad52b46f7a4",
        "patch": "@@ -7,6 +7,7 @@ src/bitcoind\n src/bitcoin-cli\n src/bitcoin-tx\n src/bitcoin-wallet\n+src/rusty_test\n src/test/test_bitcoin\n src/test/test_bitcoin_fuzzy\n src/qt/test/test_bitcoin-qt"
      }
    ]
  },
  {
    "sha": "8e3f0238a2268e4bebaa785798a962562158a844",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4ZTNmMDIzOGEyMjY4ZTRiZWJhYTc4NTc5OGE5NjI1NjIxNThhODQ0",
    "commit": {
      "author": {
        "name": "Cory Fields",
        "email": "cory-nospam-@coryfields.com",
        "date": "2019-09-30T20:31:47Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-03T19:26:01Z"
      },
      "message": "Add basic ffi bindings for Rust header download\n\nAlso, break circular dependency with a new helper lib courtesy of\nCory Fields <cory-nospam-@coryfields.com>.",
      "tree": {
        "sha": "21206fe7d1ea1f913c79c7acee93996e12ffab55",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/21206fe7d1ea1f913c79c7acee93996e12ffab55"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8e3f0238a2268e4bebaa785798a962562158a844",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8e3f0238a2268e4bebaa785798a962562158a844",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8e3f0238a2268e4bebaa785798a962562158a844",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8e3f0238a2268e4bebaa785798a962562158a844/comments",
    "author": {
      "login": "theuni",
      "id": 417043,
      "node_id": "MDQ6VXNlcjQxNzA0Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/417043?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/theuni",
      "html_url": "https://github.com/theuni",
      "followers_url": "https://api.github.com/users/theuni/followers",
      "following_url": "https://api.github.com/users/theuni/following{/other_user}",
      "gists_url": "https://api.github.com/users/theuni/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/theuni/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/theuni/subscriptions",
      "organizations_url": "https://api.github.com/users/theuni/orgs",
      "repos_url": "https://api.github.com/users/theuni/repos",
      "events_url": "https://api.github.com/users/theuni/events{/privacy}",
      "received_events_url": "https://api.github.com/users/theuni/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8fd3b4a8fbebbb4e5ed3a8c2e0b01ad52b46f7a4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8fd3b4a8fbebbb4e5ed3a8c2e0b01ad52b46f7a4",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8fd3b4a8fbebbb4e5ed3a8c2e0b01ad52b46f7a4"
      }
    ],
    "stats": {
      "total": 225,
      "additions": 198,
      "deletions": 27
    },
    "files": [
      {
        "sha": "ee56e1065057de59aec1883b561abc4fb4fb5bbf",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 14,
        "deletions": 3,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8e3f0238a2268e4bebaa785798a962562158a844/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8e3f0238a2268e4bebaa785798a962562158a844/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=8e3f0238a2268e4bebaa785798a962562158a844",
        "patch": "@@ -37,6 +37,7 @@ LIBSECP256K1=secp256k1/libsecp256k1.la\n \n if ENABLE_RUSTY\n LIBBITCOIN_RUSTY = rusty/librusty.a\n+LIBBITCOIN_RUSTY_BRIDGE = libbitcoin_rustybridge.a\n endif\n if ENABLE_ZMQ\n LIBBITCOIN_ZMQ=libbitcoin_zmq.a\n@@ -77,6 +78,7 @@ EXTRA_LIBRARIES += \\\n   $(LIBBITCOIN_CLI) \\\n   $(LIBBITCOIN_WALLET) \\\n   $(LIBBITCOIN_WALLET_TOOL) \\\n+  $(LIBBITCOIN_RUSTY_BRIDGE) \\\n   $(LIBBITCOIN_ZMQ)\n \n lib_LTLIBRARIES = $(LIBBITCOINCONSENSUS)\n@@ -262,6 +264,10 @@ obj/build.h: FORCE\n \t  \"$(abs_top_srcdir)\"\n libbitcoin_util_a-clientversion.$(OBJEXT): obj/build.h\n \n+# libbitcoin_rustybridge should not need headers other than Core's internal ones.\n+libbitcoin_rustybridge_a_CPPFLAGS = $(AM_CPPFLAGS) -I$(builddir) $(LEVELDB_CPPFLAGS)\n+libbitcoin_rustybridge_a_CXXFLAGS = $(AM_CXXFLAGS) $(PIE_FLAGS)\n+libbitcoin_rustybridge_a_SOURCES = rusty/src/cpp_bridge.cpp\n # server: shared between bitcoind and bitcoin-qt\n # Contains code accessing mempool and chain state that is meant to be separated\n # from wallet and gui code (see node/README.md). Shared code should go in\n@@ -368,7 +374,11 @@ libbitcoin_wallet_tool_a_SOURCES = \\\n # if any of the other files change. List the main file first, then targets can\n # depend on $(LIBBITCOIN_RUSTY_SRCS), but only build the first source file ($<).\n LIBBITCOIN_RUSTY_SRCS= \\\n-  rusty/src/lib.rs\n+  rusty/src/lib.rs \\\n+  rusty/src/bridge.rs\n+\n+LIBBITCOIN_RUSTY_TEST_SRCS= \\\n+  rusty/src/test_bridge.rs\n \n # We force overflow checks on so that any integer overflows result in a panic\n # instead of, eg, attempting to alloc 4GB of memory (though we will catch such\n@@ -680,9 +690,10 @@ BITCOIN_CORE_H += rusty/src/rust_bridge.h\n \n if ENABLE_RUSTY\n LIBBITCOIN_RUST_LIBS += $(LIBBITCOIN_RUSTY)\n+LIBBITCOIN_RUST_LIBS += $(LIBBITCOIN_RUSTY_BRIDGE)\n \n RUSTY_TEST_BIN=rusty/test_rusty\n-$(RUSTY_TEST_BIN): $(LIBBITCOIN_RUSTY_SRCS)\n+$(RUSTY_TEST_BIN): $(LIBBITCOIN_RUSTY_SRCS) $(LIBBITCOIN_RUSTY_TEST_SRCS)\n \t$(RUSTC) --crate-name test_rusty $< --target=$(RUST_TARGET) --emit=link --test -C debuginfo=2 -C overflow-checks=on --out-dir $(@D)\n \n ## FIXME: always build RUSTY_TEST_BIN the same as we do test_bitcoin\n@@ -708,7 +719,7 @@ CLEANFILES += wallet/test/*.gcda wallet/test/*.gcno\n CLEANFILES += zmq/*.gcda zmq/*.gcno\n CLEANFILES += obj/build.h\n \n-EXTRA_DIST = $(CTAES_DIST) $(LIBBITCOIN_RUSTY_SRCS)\n+EXTRA_DIST = $(CTAES_DIST) $(LIBBITCOIN_RUSTY_SRCS) $(LIBBITCOIN_RUSTY_TEST_SRCS)\n \n \n config/bitcoin-config.h: config/stamp-h1"
      },
      {
        "sha": "2b0e2756b71b30fa8e3bb36cea244961dabff65e",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 4,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8e3f0238a2268e4bebaa785798a962562158a844/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8e3f0238a2268e4bebaa785798a962562158a844/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=8e3f0238a2268e4bebaa785798a962562158a844",
        "patch": "@@ -342,10 +342,6 @@ static void OnRPCStopped()\n \n void SetupServerArgs()\n {\n-#if ENABLE_RUSTY\n-    assert(rust_hello_world_example::RUST_CONSTANT == 43);\n-    rust_hello_world_example::hello_world();\n-#endif\n     SetupHelpOptions(gArgs);\n     gArgs.AddArg(\"-help-debug\", \"Print help message with debugging options and exit\", ArgsManager::ALLOW_ANY, OptionsCategory::DEBUG_TEST); // server-only for now\n "
      },
      {
        "sha": "ac46d409adb9db82178b33cc369663080eb5994c",
        "filename": "src/rusty/src/bridge.rs",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8e3f0238a2268e4bebaa785798a962562158a844/src/rusty/src/bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8e3f0238a2268e4bebaa785798a962562158a844/src/rusty/src/bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/bridge.rs?ref=8e3f0238a2268e4bebaa785798a962562158a844",
        "patch": "@@ -0,0 +1,44 @@\n+use std::ffi::c_void;\n+extern \"C\" {\n+    pub fn rusty_IsInitialBlockDownload() -> bool;\n+    pub fn rusty_ShutdownRequested() -> bool;\n+\n+    /// Connects count headers serialized in a block of memory, each stride bytes from each other.\n+    /// Returns the last header which was connected, if any (or NULL).\n+    fn rusty_ConnectHeaders(headers: *const u8, stride: usize, count: usize) -> *const c_void;\n+\n+    // Utilities to work with CBlockIndex pointers. Wrapped in a safe wrapper below.\n+\n+    /// Gets a CBlockIndex* pointer (casted to a c_void) representing the current tip.\n+    /// Guaranteed to never be NULL (but may be genesis)\n+    fn rusty_GetChainTip() -> *const c_void;\n+\n+    /// Gets the height of a given CBlockIndex* pointer\n+    fn rusty_IndexToHeight(index: *const c_void) -> i32;\n+}\n+\n+/// Connects the given array of (sorted, in chain order) headers (in serialized, 80-byte form).\n+/// Returns the last header which was connected, if any.\n+pub fn connect_headers_flat_bytes(headers: &[u8]) -> Option<BlockIndex> {\n+    if headers.len() % 80 != 0 { return None; }\n+    if headers.is_empty() { return None; }\n+    let index = unsafe { rusty_ConnectHeaders(headers.as_ptr(), 80, headers.len() / 80) };\n+    if index.is_null() { None } else { Some(BlockIndex { index }) }\n+}\n+\n+#[derive(PartialEq, Clone, Copy)]\n+pub struct BlockIndex {\n+    index: *const c_void,\n+}\n+\n+impl BlockIndex {\n+    pub fn tip() -> Self {\n+        Self {\n+            index: unsafe { rusty_GetChainTip() },\n+        }\n+    }\n+\n+    pub fn height(&self) -> i32 {\n+        unsafe { rusty_IndexToHeight(self.index) }\n+    }\n+}"
      },
      {
        "sha": "6d36eeea6342e6b1d28352f04b093fdfb1175838",
        "filename": "src/rusty/src/cpp_bridge.cpp",
        "status": "added",
        "additions": 88,
        "deletions": 0,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8e3f0238a2268e4bebaa785798a962562158a844/src/rusty/src/cpp_bridge.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8e3f0238a2268e4bebaa785798a962562158a844/src/rusty/src/cpp_bridge.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/cpp_bridge.cpp?ref=8e3f0238a2268e4bebaa785798a962562158a844",
        "patch": "@@ -0,0 +1,88 @@\n+#include <chainparams.h>\n+#include <validation.h>\n+#include <shutdown.h>\n+#include <serialize.h>\n+#include <consensus/validation.h>\n+\n+/** A class that deserializes a single thing one time. */\n+class InputStream\n+{\n+public:\n+    InputStream(int nTypeIn, int nVersionIn, const unsigned char *data, size_t datalen) :\n+    m_type(nTypeIn),\n+    m_version(nVersionIn),\n+    m_data(data),\n+    m_remaining(datalen)\n+    {}\n+\n+    void read(char* pch, size_t nSize)\n+    {\n+        if (nSize > m_remaining)\n+            throw std::ios_base::failure(std::string(__func__) + \": end of data\");\n+\n+        if (pch == nullptr)\n+            throw std::ios_base::failure(std::string(__func__) + \": bad destination buffer\");\n+\n+        if (m_data == nullptr)\n+            throw std::ios_base::failure(std::string(__func__) + \": bad source buffer\");\n+\n+        memcpy(pch, m_data, nSize);\n+        m_remaining -= nSize;\n+        m_data += nSize;\n+    }\n+\n+    template<typename T>\n+    InputStream& operator>>(T&& obj)\n+    {\n+        ::Unserialize(*this, obj);\n+        return *this;\n+    }\n+\n+    int GetVersion() const { return m_version; }\n+    int GetType() const { return m_type; }\n+private:\n+    const int m_type;\n+    const int m_version;\n+    const unsigned char* m_data;\n+    size_t m_remaining;\n+};\n+\n+extern \"C\" {\n+\n+bool rusty_IsInitialBlockDownload() {\n+    return ::ChainstateActive().IsInitialBlockDownload();\n+}\n+\n+bool rusty_ShutdownRequested() {\n+    return ShutdownRequested();\n+}\n+\n+const void* rusty_ConnectHeaders(const uint8_t* headers_data, size_t stride, size_t count) {\n+    std::vector<CBlockHeader> headers;\n+    for(size_t i = 0; i < count; i++) {\n+        CBlockHeader header;\n+        try {\n+            InputStream(SER_NETWORK, PROTOCOL_VERSION, headers_data + (stride * i), 80) >> header;\n+        } catch (...) {}\n+        headers.push_back(header);\n+    }\n+    BlockValidationState state_dummy;\n+    const CBlockIndex* last_index = nullptr;\n+    ProcessNewBlockHeaders(headers, state_dummy, ::Params(), &last_index);\n+    return last_index;\n+}\n+\n+const void* rusty_GetChainTip() {\n+    LOCK(cs_main);\n+    const CBlockIndex* tip = ::ChainActive().Tip();\n+    assert(tip != nullptr);\n+    return tip;\n+}\n+\n+int32_t rusty_IndexToHeight(const void* pindexvoid) {\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    assert(pindex != nullptr);\n+    return pindex->nHeight;\n+}\n+\n+}"
      },
      {
        "sha": "a43b2b707487282e14baca4c29e10810e97c61f0",
        "filename": "src/rusty/src/lib.rs",
        "status": "modified",
        "additions": 23,
        "deletions": 12,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8e3f0238a2268e4bebaa785798a962562158a844/src/rusty/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8e3f0238a2268e4bebaa785798a962562158a844/src/rusty/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/lib.rs?ref=8e3f0238a2268e4bebaa785798a962562158a844",
        "patch": "@@ -1,15 +1,26 @@\n-#[cfg(test)]\n-mod tests {\n-    #[test]\n-    fn it_works() {\n-        assert_eq!(2 + 2, 4);\n-    }\n-}\n+#[cfg(not(test))] mod bridge;\n+#[cfg(test)] pub mod test_bridge;\n+#[cfg(test)] pub use test_bridge as bridge;\n+use bridge::*;\n \n-#[no_mangle]\n-pub static RUST_CONSTANT: i32 = 43;\n+use std::time::{Duration, Instant};\n \n-#[no_mangle]\n-pub extern \"C\" fn hello_world() {\n-    println!(\"Hello World!\");\n+/// Waits for IBD to complete, to get stuck, or shutdown to be initiated. This should be called\n+/// prior to any background block fetchers initiating connections.\n+pub fn await_ibd_complete_or_stalled() {\n+    // Wait until we have finished IBD or aren't making any progress before kicking off\n+    // redundant sync.\n+    let mut last_tip = BlockIndex::tip();\n+    let mut last_tip_change = Instant::now();\n+    while unsafe { !rusty_ShutdownRequested() } {\n+        std::thread::sleep(Duration::from_millis(500));\n+        if unsafe { !rusty_IsInitialBlockDownload() } { break; }\n+        let new_tip = BlockIndex::tip();\n+        if new_tip != last_tip {\n+            last_tip = new_tip;\n+            last_tip_change = Instant::now();\n+        } else if (Instant::now() - last_tip_change) > Duration::from_secs(600) {\n+            break;\n+        }\n+    }\n }"
      },
      {
        "sha": "6c12a35813798ea5d4a480b11c77548f7e9460f0",
        "filename": "src/rusty/src/rust_bridge.h",
        "status": "modified",
        "additions": 5,
        "deletions": 8,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8e3f0238a2268e4bebaa785798a962562158a844/src/rusty/src/rust_bridge.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8e3f0238a2268e4bebaa785798a962562158a844/src/rusty/src/rust_bridge.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/rust_bridge.h?ref=8e3f0238a2268e4bebaa785798a962562158a844",
        "patch": "@@ -3,24 +3,21 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#ifndef BITCOIN_RUSTY_H\n-#define BITCOIN_RUSTY_H\n+#ifndef BITCOIN_RUSTY_SRC_RUST_BRIDGE_H\n+#define BITCOIN_RUSTY_SRC_RUST_BRIDGE_H\n \n #include <cstdarg>\n #include <cstdint>\n #include <cstdlib>\n #include <new>\n \n-namespace rust_hello_world_example {\n+namespace rust_block_fetch {\n \n extern \"C\" {\n \n-extern int32_t RUST_CONSTANT;\n-\n-void hello_world();\n \n } // extern \"C\"\n \n-} // namespace rust_hello_world_example\n+} // namespace rust_block_fetch\n \n-#endif // BITCOIN_RUSTY_H\n+#endif // BITCOIN_RUSTY_SRC_RUST_BRIDGE_H"
      },
      {
        "sha": "9553353a18fc294647a0622eb0ae30a5329d872d",
        "filename": "src/rusty/src/test_bridge.rs",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8e3f0238a2268e4bebaa785798a962562158a844/src/rusty/src/test_bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8e3f0238a2268e4bebaa785798a962562158a844/src/rusty/src/test_bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/test_bridge.rs?ref=8e3f0238a2268e4bebaa785798a962562158a844",
        "patch": "@@ -0,0 +1,24 @@\n+///! \"bridge\" to C++ code without any backing C++ code. Used for shimming in dummies for testing.\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn rusty_IsInitialBlockDownload() -> bool { unimplemented!(); }\n+\n+#[no_mangle]\n+pub unsafe extern \"C\" fn rusty_ShutdownRequested() -> bool { unimplemented!(); }\n+\n+pub fn connect_headers_flat_bytes(_headers: &[u8]) -> Option<BlockIndex> {\n+    unimplemented!();\n+}\n+\n+#[derive(PartialEq, Clone, Copy)]\n+pub struct BlockIndex { }\n+\n+impl BlockIndex {\n+    pub fn tip() -> Self {\n+        unimplemented!();\n+    }\n+\n+    pub fn height(&self) -> i32 {\n+        unimplemented!();\n+    }\n+}"
      }
    ]
  },
  {
    "sha": "61337eaa846c7ca8d7346a152007359678bb3f3e",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MTMzN2VhYTg0NmM3Y2E4ZDczNDZhMTUyMDA3MzU5Njc4YmIzZjNl",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-10T21:58:42Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:19Z"
      },
      "message": "Add headers-over-DNS fetcher in Rust",
      "tree": {
        "sha": "d580b7db887ae37ac154b44f86b945b371310155",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/d580b7db887ae37ac154b44f86b945b371310155"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/61337eaa846c7ca8d7346a152007359678bb3f3e",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61337eaa846c7ca8d7346a152007359678bb3f3e",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/61337eaa846c7ca8d7346a152007359678bb3f3e",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61337eaa846c7ca8d7346a152007359678bb3f3e/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8e3f0238a2268e4bebaa785798a962562158a844",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8e3f0238a2268e4bebaa785798a962562158a844",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8e3f0238a2268e4bebaa785798a962562158a844"
      }
    ],
    "stats": {
      "total": 159,
      "additions": 154,
      "deletions": 5
    },
    "files": [
      {
        "sha": "f8058dd88cd52f54fede7715463a7bf58620b4dd",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61337eaa846c7ca8d7346a152007359678bb3f3e/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61337eaa846c7ca8d7346a152007359678bb3f3e/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=61337eaa846c7ca8d7346a152007359678bb3f3e",
        "patch": "@@ -375,7 +375,8 @@ libbitcoin_wallet_tool_a_SOURCES = \\\n # depend on $(LIBBITCOIN_RUSTY_SRCS), but only build the first source file ($<).\n LIBBITCOIN_RUSTY_SRCS= \\\n   rusty/src/lib.rs \\\n-  rusty/src/bridge.rs\n+  rusty/src/bridge.rs \\\n+  rusty/src/dns_headers.rs\n \n LIBBITCOIN_RUSTY_TEST_SRCS= \\\n   rusty/src/test_bridge.rs"
      },
      {
        "sha": "d3bca4f6dbf331bca27662c9f29e808ecc2e8156",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 4,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61337eaa846c7ca8d7346a152007359678bb3f3e/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61337eaa846c7ca8d7346a152007359678bb3f3e/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=61337eaa846c7ca8d7346a152007359678bb3f3e",
        "patch": "@@ -77,6 +77,10 @@\n #include <zmq/zmqrpc.h>\n #endif\n \n+#if ENABLE_RUSTY\n+#include <rusty/src/rust_bridge.h>\n+#endif\n+\n static bool fFeeEstimatesInitialized = false;\n static const bool DEFAULT_PROXYRANDOMIZE = true;\n static const bool DEFAULT_REST_ENABLE = false;\n@@ -183,6 +187,10 @@ void Shutdown(NodeContext& node)\n     util::ThreadRename(\"shutoff\");\n     mempool.AddTransactionsUpdated(1);\n \n+#if ENABLE_RUSTY\n+    rust_block_fetch::stop_fetch_dns_headers();\n+#endif\n+\n     StopHTTPRPC();\n     StopREST();\n     StopRPC();\n@@ -336,10 +344,6 @@ static void OnRPCStopped()\n     LogPrint(BCLog::RPC, \"RPC stopped.\\n\");\n }\n \n-#if ENABLE_RUSTY\n-#include <rusty/src/rust_bridge.h>\n-#endif\n-\n void SetupServerArgs()\n {\n     SetupHelpOptions(gArgs);\n@@ -401,6 +405,9 @@ void SetupServerArgs()\n                  \" If <type> is not supplied or if <type> = 1, indexes for all known types are enabled.\",\n                  ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n \n+#if ENABLE_RUSTY\n+    gArgs.AddArg(\"-headersfetchdns=<domain>\", \"A domain name from which to fetch headers. eg bitcoinheaders.net\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n+#endif\n     gArgs.AddArg(\"-addnode=<ip>\", \"Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC command help for more info). This option can be specified multiple times to add multiple nodes.\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-banscore=<n>\", strprintf(\"Threshold for disconnecting misbehaving peers (default: %u)\", DEFAULT_BANSCORE_THRESHOLD), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-bantime=<n>\", strprintf(\"Number of seconds to keep misbehaving peers from reconnecting (default: %u)\", DEFAULT_MISBEHAVING_BANTIME), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n@@ -1826,5 +1833,13 @@ bool AppInitMain(NodeContext& node)\n         banman->DumpBanlist();\n     }, DUMP_BANS_INTERVAL * 1000);\n \n+    // ********************************************************* Step 14: kick off backup block downloaders\n+\n+#if ENABLE_RUSTY\n+    for (const std::string& domain : gArgs.GetArgs(\"-headersfetchdns\")) {\n+        rust_block_fetch::init_fetch_dns_headers(domain.c_str());\n+    }\n+#endif\n+\n     return true;\n }"
      },
      {
        "sha": "6e2ac53dd96419f5e0b3452647f82edcc198f4a2",
        "filename": "src/rusty/src/dns_headers.rs",
        "status": "added",
        "additions": 129,
        "deletions": 0,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61337eaa846c7ca8d7346a152007359678bb3f3e/src/rusty/src/dns_headers.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61337eaa846c7ca8d7346a152007359678bb3f3e/src/rusty/src/dns_headers.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/dns_headers.rs?ref=61337eaa846c7ca8d7346a152007359678bb3f3e",
        "patch": "@@ -0,0 +1,129 @@\n+use std::net::{IpAddr, Ipv6Addr, ToSocketAddrs};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use std::ffi::CStr;\n+use std::os::raw::c_char;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+/// Maps a set of six IPv6 addresses to an 80-byte Bitcoin header.\n+/// The first two bytes of each address are ignored.\n+/// The next 4 bits in each address indicate the ordering of the addresses\n+/// (as DNS resolvers/servers often shuffle the addresses)\n+/// The first 8 bits (ie the second half of the 3rd byte and first half of the 4th)\n+/// of the first address are interpreted as a version and must currently be 0.\n+/// The remaining bits are placed into the 80 byte result in order.\n+fn map_addrs_to_header(ips: &mut [Ipv6Addr]) -> [u8; 80] {\n+    let mut header = [0u8; 80];\n+    if ips.len() != 6 { return header; }\n+    ips.sort_unstable_by(|a, b| {\n+        // Sort based on the first 4 bits in the 3rd byte...\n+        (&(a.octets()[2] & 0xf0)).cmp(&(b.octets()[2] & 0xf0))\n+    });\n+    if ips.len() != 6 { unreachable!(); }\n+    let version = (ips[0].octets()[2] & 0x0f) | (ips[0].octets()[3] & 0xf0);\n+    if version != 0 { return header; }\n+\n+    let mut offs = 0; // in bytes * 2\n+    for (idx, ip) in ips.iter().enumerate() {\n+        for i in if idx == 0 { 3..14*2 } else { 1..14*2 } {\n+            if i % 2 == 1 {\n+                header[offs/2] |= (ip.octets()[i/2 + 2] & 0x0f) >> 0;\n+            } else {\n+                header[offs/2] |= (ip.octets()[i/2 + 2] & 0xf0) >> 4;\n+            }\n+            if offs % 2 == 0 {\n+                header[offs/2] <<= 4;\n+            }\n+            offs += 1;\n+        }\n+    }\n+    header\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_map_addrs() {\n+    use std::str::FromStr;\n+\n+    let mut ips = Vec::new();\n+    // The genesis header:\n+    ips.push(Ipv6Addr::from_str(\"2001:0000:1000:0000:0000:0000:0000:0000\").unwrap());\n+    ips.push(Ipv6Addr::from_str(\"2001:1000:0000:0000:0000:0000:0000:0000\").unwrap());\n+    ips.push(Ipv6Addr::from_str(\"2001:2000:0000:0000:0000:0000:03ba:3edf\").unwrap());\n+    ips.push(Ipv6Addr::from_str(\"2001:3d7a:7b12:b27a:c72c:3e67:768f:617f\").unwrap());\n+    ips.push(Ipv6Addr::from_str(\"2001:4c81:bc38:88a5:1323:a9fb:8aa4:b1e5\").unwrap());\n+    ips.push(Ipv6Addr::from_str(\"2001:5e4a:29ab:5f49:ffff:001d:1dac:2b7c\").unwrap());\n+\n+    assert_eq!(&map_addrs_to_header(&mut ips)[..],\n+        &[0x1, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x0, 0x3b, 0xa3, 0xed, 0xfd, 0x7a, 0x7b, 0x12, 0xb2, 0x7a, 0xc7, 0x2c, 0x3e, 0x67, 0x76, 0x8f, 0x61, 0x7f, 0xc8, 0x1b, 0xc3, 0x88, 0x8a, 0x51, 0x32, 0x3a, 0x9f, 0xb8, 0xaa, 0x4b, 0x1e, 0x5e, 0x4a, 0x29, 0xab, 0x5f, 0x49, 0xff, 0xff, 0x0, 0x1d, 0x1d, 0xac, 0x2b, 0x7c][..]);\n+}\n+\n+static THREAD_COUNT: AtomicUsize = AtomicUsize::new(0);\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_dns_headers(domain: *const c_char) -> bool {\n+    if let Err(_) = catch_unwind(move || {\n+        let domain_str: String = match unsafe { CStr::from_ptr(domain) }.to_str() {\n+            Ok(r) => r.to_string(),\n+            Err(_) => return false,\n+        };\n+        std::thread::spawn(move || {\n+            // Always catch panics so that even if we have some bug in our parser we don't take the\n+            // rest of Bitcoin Core down with us:\n+            THREAD_COUNT.fetch_add(1, Ordering::AcqRel);\n+            let _ = catch_unwind(move || {\n+                await_ibd_complete_or_stalled();\n+                let mut height = BlockIndex::tip().height();\n+                'dns_lookup: while unsafe { !rusty_ShutdownRequested() } {\n+                    let mut ips: Vec<_> = match (format!(\"{}.{}.{}\", height, height / 10000, domain_str).as_str(), 0u16).to_socket_addrs() {\n+                        Ok(ips) => ips,\n+                        Err(_) => {\n+                            std::thread::sleep(Duration::from_secs(5));\n+                            continue 'dns_lookup;\n+                        },\n+                    }.filter_map(|a| match a.ip() {\n+                        IpAddr::V6(a) => Some(a),\n+                        _ => None,\n+                    }).collect();\n+                    if ips.len() != 6 {\n+                        std::thread::sleep(Duration::from_secs(5));\n+                        continue 'dns_lookup;\n+                    }\n+\n+                    if unsafe { !rusty_ShutdownRequested() } {\n+                        match connect_headers_flat_bytes(&map_addrs_to_header(&mut ips)) {\n+                            Some(_) => {\n+                                height += 1;\n+                            },\n+                            None => {\n+                                // We couldn't connect the header, step back and try again\n+                                if height > 0 {\n+                                    height -= 1;\n+                                } else {\n+                                    std::thread::sleep(Duration::from_secs(5));\n+                                }\n+                            },\n+                        }\n+                    }\n+                }\n+            });\n+            THREAD_COUNT.fetch_sub(1, Ordering::AcqRel);\n+        });\n+        true\n+    }) {\n+        false\n+    } else {\n+        true\n+    }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn stop_fetch_dns_headers() {\n+    while THREAD_COUNT.load(Ordering::Acquire) != 0 {\n+        std::thread::sleep(Duration::from_millis(10));\n+    }\n+}"
      },
      {
        "sha": "535fecfa479b4e3c190ae3e3ed273fd95e0138af",
        "filename": "src/rusty/src/lib.rs",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61337eaa846c7ca8d7346a152007359678bb3f3e/src/rusty/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61337eaa846c7ca8d7346a152007359678bb3f3e/src/rusty/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/lib.rs?ref=61337eaa846c7ca8d7346a152007359678bb3f3e",
        "patch": "@@ -3,6 +3,8 @@\n #[cfg(test)] pub use test_bridge as bridge;\n use bridge::*;\n \n+mod dns_headers;\n+\n use std::time::{Duration, Instant};\n \n /// Waits for IBD to complete, to get stuck, or shutdown to be initiated. This should be called"
      },
      {
        "sha": "f4548ae59083e61f6294640e7f66e78c2ff2886d",
        "filename": "src/rusty/src/rust_bridge.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61337eaa846c7ca8d7346a152007359678bb3f3e/src/rusty/src/rust_bridge.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61337eaa846c7ca8d7346a152007359678bb3f3e/src/rusty/src/rust_bridge.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/rust_bridge.h?ref=61337eaa846c7ca8d7346a152007359678bb3f3e",
        "patch": "@@ -15,6 +15,8 @@ namespace rust_block_fetch {\n \n extern \"C\" {\n \n+bool init_fetch_dns_headers(const char *domain);\n+bool stop_fetch_dns_headers();\n \n } // extern \"C\"\n "
      }
    ]
  },
  {
    "sha": "b76d4f9d68ef15827f0d6fcfa7b532862dc37191",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpiNzZkNGY5ZDY4ZWYxNTgyN2YwZDZmY2ZhN2I1MzI4NjJkYzM3MTkx",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-06T16:16:14Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "Limit total memory allocated by all Rust code to 128MB",
      "tree": {
        "sha": "33c17314a359a468b29b4ab91b7d7f6c9bdf884e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/33c17314a359a468b29b4ab91b7d7f6c9bdf884e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/b76d4f9d68ef15827f0d6fcfa7b532862dc37191",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b76d4f9d68ef15827f0d6fcfa7b532862dc37191",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/b76d4f9d68ef15827f0d6fcfa7b532862dc37191",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b76d4f9d68ef15827f0d6fcfa7b532862dc37191/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "61337eaa846c7ca8d7346a152007359678bb3f3e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61337eaa846c7ca8d7346a152007359678bb3f3e",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/61337eaa846c7ca8d7346a152007359678bb3f3e"
      }
    ],
    "stats": {
      "total": 39,
      "additions": 39,
      "deletions": 0
    },
    "files": [
      {
        "sha": "097a39c0b54f5a25a20069fa083b80baad03fbad",
        "filename": "src/rusty/src/lib.rs",
        "status": "modified",
        "additions": 39,
        "deletions": 0,
        "changes": 39,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/b76d4f9d68ef15827f0d6fcfa7b532862dc37191/src/rusty/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/b76d4f9d68ef15827f0d6fcfa7b532862dc37191/src/rusty/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/lib.rs?ref=b76d4f9d68ef15827f0d6fcfa7b532862dc37191",
        "patch": "@@ -5,8 +5,47 @@ use bridge::*;\n \n mod dns_headers;\n \n+use std::alloc::{GlobalAlloc, Layout, System};\n+use std::ptr;\n+use std::sync::atomic::{AtomicUsize, Ordering};\n use std::time::{Duration, Instant};\n \n+// We keep track of all memory allocated by Rust code, refusing new allocations if it exceeds\n+// 128MB.\n+//\n+// Note that while Rust's std, in general, should panic in response to a null allocation, it\n+// is totally conceivable that some code will instead dereference this null pointer, which\n+// would violate our guarantees that Rust modules should never crash the entire application.\n+//\n+// In the future, as upstream Rust explores a safer allocation API (eg the Alloc API which\n+// returns Results instead of raw pointers, or redefining the GlobalAlloc API to allow\n+// panic!()s inside of alloc calls), we should switch to those, however these APIs are\n+// currently unstable.\n+const TOTAL_MEM_LIMIT_BYTES: usize = 128 * 1024 * 1024;\n+static TOTAL_MEM_ALLOCD: AtomicUsize = AtomicUsize::new(0);\n+struct MemoryLimitingAllocator;\n+unsafe impl GlobalAlloc for MemoryLimitingAllocator {\n+    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+        let len = layout.size();\n+        if len > TOTAL_MEM_LIMIT_BYTES {\n+            return ptr::null_mut();\n+        }\n+        if TOTAL_MEM_ALLOCD.fetch_add(len, Ordering::AcqRel) + len > TOTAL_MEM_LIMIT_BYTES {\n+            TOTAL_MEM_ALLOCD.fetch_sub(len, Ordering::AcqRel);\n+            return ptr::null_mut();\n+        }\n+        System.alloc(layout)\n+    }\n+\n+    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+        System.dealloc(ptr, layout);\n+        TOTAL_MEM_ALLOCD.fetch_sub(layout.size(), Ordering::AcqRel);\n+    }\n+}\n+\n+#[global_allocator]\n+static ALLOC: MemoryLimitingAllocator = MemoryLimitingAllocator;\n+\n /// Waits for IBD to complete, to get stuck, or shutdown to be initiated. This should be called\n /// prior to any background block fetchers initiating connections.\n pub fn await_ibd_complete_or_stalled() {"
      }
    ]
  },
  {
    "sha": "4b6e0b800d7a38646614ff5832a1f1dd1dda8788",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0YjZlMGI4MDBkN2EzODY0NjYxNGZmNTgzMmExZjFkZDFkZGE4Nzg4",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-10T22:28:27Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "Enable rustc building + testing on xenial Tsan Travis job",
      "tree": {
        "sha": "ab30a4ef94cbe1753d1e1694d5431c02731a6046",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ab30a4ef94cbe1753d1e1694d5431c02731a6046"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4b6e0b800d7a38646614ff5832a1f1dd1dda8788",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4b6e0b800d7a38646614ff5832a1f1dd1dda8788",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4b6e0b800d7a38646614ff5832a1f1dd1dda8788",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4b6e0b800d7a38646614ff5832a1f1dd1dda8788/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "b76d4f9d68ef15827f0d6fcfa7b532862dc37191",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/b76d4f9d68ef15827f0d6fcfa7b532862dc37191",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/b76d4f9d68ef15827f0d6fcfa7b532862dc37191"
      }
    ],
    "stats": {
      "total": 4,
      "additions": 2,
      "deletions": 2
    },
    "files": [
      {
        "sha": "b4c1c1ac5927dc3d923600ff64dd7f650e053807",
        "filename": ".travis.yml",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b6e0b800d7a38646614ff5832a1f1dd1dda8788/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b6e0b800d7a38646614ff5832a1f1dd1dda8788/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/.travis.yml?ref=4b6e0b800d7a38646614ff5832a1f1dd1dda8788",
        "patch": "@@ -119,7 +119,7 @@ jobs:\n         FILE_ENV=\"./ci/test/00_setup_env_amd64_trusty.sh\"\n \n     - stage: test\n-      name: 'x86_64 Linux  [GOAL: install]  [xenial]  [no depends, only system libs, sanitizers: thread (TSan), no wallet]'\n+      name: 'x86_64 Linux  [GOAL: install]  [xenial]  [no depends, only system libs, rust, sanitizers: thread (TSan), no wallet]'\n       env: >-\n         FILE_ENV=\"./ci/test/00_setup_env_amd64_tsan.sh\"\n         TEST_RUNNER_EXTRA=\"--exclude feature_block\"  # Not enough memory on travis machines"
      },
      {
        "sha": "b9d41ebe239557d7bed7da6d44cb150ce46c5ecd",
        "filename": "ci/test/00_setup_env_amd64_tsan.sh",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4b6e0b800d7a38646614ff5832a1f1dd1dda8788/ci/test/00_setup_env_amd64_tsan.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4b6e0b800d7a38646614ff5832a1f1dd1dda8788/ci/test/00_setup_env_amd64_tsan.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/ci/test/00_setup_env_amd64_tsan.sh?ref=4b6e0b800d7a38646614ff5832a1f1dd1dda8788",
        "patch": "@@ -8,7 +8,7 @@ export LC_ALL=C.UTF-8\n \n export HOST=x86_64-unknown-linux-gnu\n export DOCKER_NAME_TAG=ubuntu:16.04\n-export PACKAGES=\"clang llvm python3-zmq qtbase5-dev qttools5-dev-tools libssl-dev libevent-dev bsdmainutils libboost-system-dev libboost-filesystem-dev libboost-chrono-dev libboost-test-dev libboost-thread-dev libdb5.3++-dev libminiupnpc-dev libzmq3-dev libqrencode-dev\"\n+export PACKAGES=\"clang llvm python3-zmq qtbase5-dev qttools5-dev-tools libssl-dev libevent-dev bsdmainutils libboost-system-dev libboost-filesystem-dev libboost-chrono-dev libboost-test-dev libboost-thread-dev libdb5.3++-dev libminiupnpc-dev libzmq3-dev libqrencode-dev rustc\"\n export NO_DEPENDS=1\n export GOAL=\"install\"\n export BITCOIN_CONFIG=\"--enable-zmq --disable-wallet --with-gui=qt5 CPPFLAGS=-DDEBUG_LOCKORDER --with-sanitizers=thread --disable-hardening --disable-asm CC=clang CXX=clang++\""
      }
    ]
  },
  {
    "sha": "57ca92ac42a5dd263fdb32894d18075b5d83c54d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo1N2NhOTJhYzQyYTVkZDI2M2ZkYjMyODk0ZDE4MDc1YjVkODNjNTRk",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-21T20:25:04Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "Move CNode's FindNextBlocksToDownload state into its own strut\n\nThis starts the process of moving the last bits of\nvalidation-critical logic out of net_processing - the fallback\nlogic of which blocks to download is incredibly critical to\nvalidation and would likely also be used for any parallel block\nsync systems. Further, assumeutxo will require additional ability\nto select blocks for download, which is a validation-specific\nconcept and shouldn't really live in net_processing.\n\nThis moves a few responsibilities to the FindNextBlocksToDownload\ncallsite instead of passing in a CNodeId, but otherwise has no\nfunctional changes.",
      "tree": {
        "sha": "021786864fd22fff3274773967196b17994af353",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/021786864fd22fff3274773967196b17994af353"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/57ca92ac42a5dd263fdb32894d18075b5d83c54d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57ca92ac42a5dd263fdb32894d18075b5d83c54d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/57ca92ac42a5dd263fdb32894d18075b5d83c54d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57ca92ac42a5dd263fdb32894d18075b5d83c54d/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4b6e0b800d7a38646614ff5832a1f1dd1dda8788",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4b6e0b800d7a38646614ff5832a1f1dd1dda8788",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4b6e0b800d7a38646614ff5832a1f1dd1dda8788"
      }
    ],
    "stats": {
      "total": 96,
      "additions": 54,
      "deletions": 42
    },
    "files": [
      {
        "sha": "220ed47b4a282f4025302cb65fcbfa8e7b57cdab",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 54,
        "deletions": 42,
        "changes": 96,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/57ca92ac42a5dd263fdb32894d18075b5d83c54d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/57ca92ac42a5dd263fdb32894d18075b5d83c54d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=57ca92ac42a5dd263fdb32894d18075b5d83c54d",
        "patch": "@@ -194,6 +194,23 @@ namespace {\n } // namespace\n \n namespace {\n+/**\n+ * Information about a peer's available blocks, for the purpose of figuring out\n+ * what block(s) we may want to download from them.\n+ */\n+struct BlockProviderState {\n+    //! The best known block we know this peer has announced.\n+    const CBlockIndex *m_best_known_block;\n+    //! The last full block we both have.\n+    const CBlockIndex *m_last_common_block;\n+\n+    BlockProviderState() : m_best_known_block(nullptr), m_last_common_block(nullptr) {}\n+\n+    int GetLastCommonHeight() const {\n+        return m_last_common_block ? m_last_common_block->nHeight : -1;\n+    }\n+};\n+\n /**\n  * Maintain validation-specific state about nodes, protected by cs_main, instead\n  * by CNode's own locks. This simplifies asynchronous operation, where\n@@ -211,12 +228,11 @@ struct CNodeState {\n     bool fShouldBan;\n     //! String name of this peer (debugging/logging purposes).\n     const std::string name;\n-    //! The best known block we know this peer has announced.\n-    const CBlockIndex *pindexBestKnownBlock;\n     //! The hash of the last unknown block this peer has announced.\n     uint256 hashLastUnknownBlock;\n-    //! The last full block we both have.\n-    const CBlockIndex *pindexLastCommonBlock;\n+    //! The CBlockIndex*s representing which blocks this peer has available for\n+    //! us to download.\n+    BlockProviderState m_blocks_avail;\n     //! The best header we have sent our peer.\n     const CBlockIndex *pindexBestHeaderSent;\n     //! Length of current-streak of unconnecting headers announcements\n@@ -360,9 +376,7 @@ struct CNodeState {\n         fCurrentlyConnected = false;\n         nMisbehavior = 0;\n         fShouldBan = false;\n-        pindexBestKnownBlock = nullptr;\n         hashLastUnknownBlock.SetNull();\n-        pindexLastCommonBlock = nullptr;\n         pindexBestHeaderSent = nullptr;\n         nUnconnectingHeaders = 0;\n         fSyncStarted = false;\n@@ -498,8 +512,8 @@ static void ProcessBlockAvailability(NodeId nodeid) EXCLUSIVE_LOCKS_REQUIRED(cs_\n     if (!state->hashLastUnknownBlock.IsNull()) {\n         const CBlockIndex* pindex = LookupBlockIndex(state->hashLastUnknownBlock);\n         if (pindex && pindex->nChainWork > 0) {\n-            if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n-                state->pindexBestKnownBlock = pindex;\n+            if (state->m_blocks_avail.m_best_known_block == nullptr || pindex->nChainWork >= state->m_blocks_avail.m_best_known_block->nChainWork) {\n+                state->m_blocks_avail.m_best_known_block = pindex;\n             }\n             state->hashLastUnknownBlock.SetNull();\n         }\n@@ -516,8 +530,8 @@ static void UpdateBlockAvailability(NodeId nodeid, const uint256 &hash) EXCLUSIV\n     const CBlockIndex* pindex = LookupBlockIndex(hash);\n     if (pindex && pindex->nChainWork > 0) {\n         // An actually better block was announced.\n-        if (state->pindexBestKnownBlock == nullptr || pindex->nChainWork >= state->pindexBestKnownBlock->nChainWork) {\n-            state->pindexBestKnownBlock = pindex;\n+        if (state->m_blocks_avail.m_best_known_block == nullptr || pindex->nChainWork >= state->m_blocks_avail.m_best_known_block->nChainWork) {\n+            state->m_blocks_avail.m_best_known_block = pindex;\n         }\n     } else {\n         // An unknown block was announced; just assume that the latest one is the best one.\n@@ -583,7 +597,7 @@ static bool CanDirectFetch(const Consensus::Params &consensusParams) EXCLUSIVE_L\n \n static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n-    if (state->pindexBestKnownBlock && pindex == state->pindexBestKnownBlock->GetAncestor(pindex->nHeight))\n+    if (state->m_blocks_avail.m_best_known_block && pindex == state->m_blocks_avail.m_best_known_block->GetAncestor(pindex->nHeight))\n         return true;\n     if (state->pindexBestHeaderSent && pindex == state->pindexBestHeaderSent->GetAncestor(pindex->nHeight))\n         return true;\n@@ -592,50 +606,45 @@ static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIV\n \n /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n  *  at most count entries. */\n-static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+static void FindNextBlocksToDownload(BlockProviderState& state, bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     if (count == 0)\n         return;\n \n     vBlocks.reserve(vBlocks.size() + count);\n-    CNodeState *state = State(nodeid);\n-    assert(state != nullptr);\n-\n-    // Make sure pindexBestKnownBlock is up to date, we'll need it.\n-    ProcessBlockAvailability(nodeid);\n \n-    if (state->pindexBestKnownBlock == nullptr || state->pindexBestKnownBlock->nChainWork < ::ChainActive().Tip()->nChainWork || state->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n+    if (state.m_best_known_block == nullptr || state.m_best_known_block->nChainWork < ::ChainActive().Tip()->nChainWork || state.m_best_known_block->nChainWork < nMinimumChainWork) {\n         // This peer has nothing interesting.\n         return;\n     }\n \n-    if (state->pindexLastCommonBlock == nullptr) {\n+    if (state.m_last_common_block == nullptr) {\n         // Bootstrap quickly by guessing a parent of our best tip is the forking point.\n         // Guessing wrong in either direction is not a problem.\n-        state->pindexLastCommonBlock = ::ChainActive()[std::min(state->pindexBestKnownBlock->nHeight, ::ChainActive().Height())];\n+        state.m_last_common_block = ::ChainActive()[std::min(state.m_best_known_block->nHeight, ::ChainActive().Height())];\n     }\n \n     // If the peer reorganized, our previous pindexLastCommonBlock may not be an ancestor\n     // of its current tip anymore. Go back enough to fix that.\n-    state->pindexLastCommonBlock = LastCommonAncestor(state->pindexLastCommonBlock, state->pindexBestKnownBlock);\n-    if (state->pindexLastCommonBlock == state->pindexBestKnownBlock)\n+    state.m_last_common_block = LastCommonAncestor(state.m_last_common_block, state.m_best_known_block);\n+    if (state.m_last_common_block == state.m_best_known_block)\n         return;\n \n     std::vector<const CBlockIndex*> vToFetch;\n-    const CBlockIndex *pindexWalk = state->pindexLastCommonBlock;\n+    const CBlockIndex *pindexWalk = state.m_last_common_block;\n     // Never fetch further than the best block we know the peer has, or more than BLOCK_DOWNLOAD_WINDOW + 1 beyond the last\n     // linked block we have in common with this peer. The +1 is so we can detect stalling, namely if we would be able to\n     // download that next block if the window were 1 larger.\n-    int nWindowEnd = state->pindexLastCommonBlock->nHeight + BLOCK_DOWNLOAD_WINDOW;\n-    int nMaxHeight = std::min<int>(state->pindexBestKnownBlock->nHeight, nWindowEnd + 1);\n+    int nWindowEnd = state.m_last_common_block->nHeight + BLOCK_DOWNLOAD_WINDOW;\n+    int nMaxHeight = std::min<int>(state.m_best_known_block->nHeight, nWindowEnd + 1);\n     NodeId waitingfor = -1;\n     while (pindexWalk->nHeight < nMaxHeight) {\n         // Read up to 128 (or more, if more blocks than that are needed) successors of pindexWalk (towards\n         // pindexBestKnownBlock) into vToFetch. We fetch 128, because CBlockIndex::GetAncestor may be as expensive\n         // as iterating over ~100 CBlockIndex* entries anyway.\n         int nToFetch = std::min(nMaxHeight - pindexWalk->nHeight, std::max<int>(count - vBlocks.size(), 128));\n         vToFetch.resize(nToFetch);\n-        pindexWalk = state->pindexBestKnownBlock->GetAncestor(pindexWalk->nHeight + nToFetch);\n+        pindexWalk = state.m_best_known_block->GetAncestor(pindexWalk->nHeight + nToFetch);\n         vToFetch[nToFetch - 1] = pindexWalk;\n         for (unsigned int i = nToFetch - 1; i > 0; i--) {\n             vToFetch[i - 1] = vToFetch[i]->pprev;\n@@ -650,18 +659,18 @@ static void FindNextBlocksToDownload(NodeId nodeid, unsigned int count, std::vec\n                 // We consider the chain that this peer is on invalid.\n                 return;\n             }\n-            if (!State(nodeid)->fHaveWitness && IsWitnessEnabled(pindex->pprev, consensusParams)) {\n+            if (!provider_has_witness && IsWitnessEnabled(pindex->pprev, consensusParams)) {\n                 // We wouldn't download this block or its descendants from this peer.\n                 return;\n             }\n             if (pindex->nStatus & BLOCK_HAVE_DATA || ::ChainActive().Contains(pindex)) {\n                 if (pindex->HaveTxsDownloaded())\n-                    state->pindexLastCommonBlock = pindex;\n+                    state.m_last_common_block = pindex;\n             } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n                 // The block is not already downloaded, and not yet in flight.\n                 if (pindex->nHeight > nWindowEnd) {\n                     // We reached the end of the window.\n-                    if (vBlocks.size() == 0 && waitingfor != nodeid) {\n+                    if (vBlocks.size() == 0) {\n                         // We aren't able to fetch anything, but we would be if the download window was one larger.\n                         nodeStaller = waitingfor;\n                     }\n@@ -812,8 +821,8 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats) {\n     if (state == nullptr)\n         return false;\n     stats.nMisbehavior = state->nMisbehavior;\n-    stats.nSyncHeight = state->pindexBestKnownBlock ? state->pindexBestKnownBlock->nHeight : -1;\n-    stats.nCommonHeight = state->pindexLastCommonBlock ? state->pindexLastCommonBlock->nHeight : -1;\n+    stats.nSyncHeight = state->m_blocks_avail.m_best_known_block ? state->m_blocks_avail.m_best_known_block->nHeight : -1;\n+    stats.nCommonHeight = state->m_blocks_avail.GetLastCommonHeight();\n     for (const QueuedBlock& queue : state->vBlocksInFlight) {\n         if (queue.pindex)\n             stats.vHeightInFlight.push_back(queue.pindex->nHeight);\n@@ -1788,7 +1797,7 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n         if (::ChainstateActive().IsInitialBlockDownload() && nCount != MAX_HEADERS_RESULTS) {\n             // When nCount < MAX_HEADERS_RESULTS, we know we have no more\n             // headers to fetch from this peer.\n-            if (nodestate->pindexBestKnownBlock && nodestate->pindexBestKnownBlock->nChainWork < nMinimumChainWork) {\n+            if (nodestate->m_blocks_avail.m_best_known_block && nodestate->m_blocks_avail.m_best_known_block->nChainWork < nMinimumChainWork) {\n                 // This peer has too little work on their headers chain to help\n                 // us sync -- disconnect if using an outbound slot (unless\n                 // whitelisted or addnode).\n@@ -1804,12 +1813,12 @@ bool static ProcessHeadersMessage(CNode *pfrom, CConnman *connman, const std::ve\n             }\n         }\n \n-        if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->pindexBestKnownBlock != nullptr && pfrom->m_tx_relay != nullptr) {\n+        if (!pfrom->fDisconnect && IsOutboundDisconnectionCandidate(pfrom) && nodestate->m_blocks_avail.m_best_known_block != nullptr && pfrom->m_tx_relay != nullptr) {\n             // If this is an outbound full-relay peer, check to see if we should protect\n             // it from the bad/lagging chain logic.\n             // Note that block-relay-only peers are already implicitly protected, so we\n             // only consider setting m_protect for the full-relay peers.\n-            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->pindexBestKnownBlock->nChainWork >= ::ChainActive().Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n+            if (g_outbound_peers_with_protect_from_disconnect < MAX_OUTBOUND_PEERS_TO_PROTECT_FROM_DISCONNECT && nodestate->m_blocks_avail.m_best_known_block->nChainWork >= ::ChainActive().Tip()->nChainWork && !nodestate->m_chain_sync.m_protect) {\n                 LogPrint(BCLog::NET, \"Protecting outbound peer=%d from eviction\\n\", pfrom->GetId());\n                 nodestate->m_chain_sync.m_protect = true;\n                 ++g_outbound_peers_with_protect_from_disconnect;\n@@ -3385,13 +3394,13 @@ void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n         // their chain has more work than ours, we should sync to it,\n         // unless it's invalid, in which case we should find that out and\n         // disconnect from them elsewhere).\n-        if (state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= ::ChainActive().Tip()->nChainWork) {\n+        if (state.m_blocks_avail.m_best_known_block != nullptr && state.m_blocks_avail.m_best_known_block->nChainWork >= ::ChainActive().Tip()->nChainWork) {\n             if (state.m_chain_sync.m_timeout != 0) {\n                 state.m_chain_sync.m_timeout = 0;\n                 state.m_chain_sync.m_work_header = nullptr;\n                 state.m_chain_sync.m_sent_getheaders = false;\n             }\n-        } else if (state.m_chain_sync.m_timeout == 0 || (state.m_chain_sync.m_work_header != nullptr && state.pindexBestKnownBlock != nullptr && state.pindexBestKnownBlock->nChainWork >= state.m_chain_sync.m_work_header->nChainWork)) {\n+        } else if (state.m_chain_sync.m_timeout == 0 || (state.m_chain_sync.m_work_header != nullptr && state.m_blocks_avail.m_best_known_block != nullptr && state.m_blocks_avail.m_best_known_block->nChainWork >= state.m_chain_sync.m_work_header->nChainWork)) {\n             // Our best block known by this peer is behind our tip, and we're either noticing\n             // that for the first time, OR this peer was able to catch up to some earlier point\n             // where we checked against our tip.\n@@ -3405,18 +3414,18 @@ void PeerLogicValidation::ConsiderEviction(CNode *pto, int64_t time_in_seconds)\n             // message to give the peer a chance to update us.\n             if (state.m_chain_sync.m_sent_getheaders) {\n                 // They've run out of time to catch up!\n-                LogPrintf(\"Disconnecting outbound peer %d for old chain, best known block = %s\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\");\n+                LogPrintf(\"Disconnecting outbound peer %d for old chain, best known block = %s\\n\", pto->GetId(), state.m_blocks_avail.m_best_known_block != nullptr ? state.m_blocks_avail.m_best_known_block->GetBlockHash().ToString() : \"<none>\");\n                 pto->fDisconnect = true;\n             } else {\n                 assert(state.m_chain_sync.m_work_header);\n-                LogPrint(BCLog::NET, \"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\\n\", pto->GetId(), state.pindexBestKnownBlock != nullptr ? state.pindexBestKnownBlock->GetBlockHash().ToString() : \"<none>\", state.m_chain_sync.m_work_header->GetBlockHash().ToString());\n+                LogPrint(BCLog::NET, \"sending getheaders to outbound peer=%d to verify chain work (current best known block:%s, benchmark blockhash: %s)\\n\", pto->GetId(), state.m_blocks_avail.m_best_known_block != nullptr ? state.m_blocks_avail.m_best_known_block->GetBlockHash().ToString() : \"<none>\", state.m_chain_sync.m_work_header->GetBlockHash().ToString());\n                 connman->PushMessage(pto, msgMaker.Make(NetMsgType::GETHEADERS, ::ChainActive().GetLocator(state.m_chain_sync.m_work_header->pprev), uint256()));\n                 state.m_chain_sync.m_sent_getheaders = true;\n                 constexpr int64_t HEADERS_RESPONSE_TIME = 120; // 2 minutes\n                 // Bump the timeout to allow a response, which could clear the timeout\n                 // (if the response shows the peer has synced), reset the timeout (if\n                 // the peer syncs to the required work but not to our tip), or result\n-                // in disconnect (if we advance to the timeout and pindexBestKnownBlock\n+                // in disconnect (if we advance to the timeout and m_blocks_avail.m_best_known_block\n                 // has not sufficiently progressed)\n                 state.m_chain_sync.m_timeout = time_in_seconds + HEADERS_RESPONSE_TIME;\n             }\n@@ -3651,7 +3660,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n                                  (!state.fPreferHeaderAndIDs || pto->vBlockHashesToAnnounce.size() > 1)) ||\n                                 pto->vBlockHashesToAnnounce.size() > MAX_BLOCKS_TO_ANNOUNCE);\n             const CBlockIndex *pBestIndex = nullptr; // last header queued for delivery\n-            ProcessBlockAvailability(pto->GetId()); // ensure pindexBestKnownBlock is up-to-date\n+            ProcessBlockAvailability(pto->GetId()); // ensure m_blocks_avail.m_best_known_block is up-to-date\n \n             if (!fRevertToInv) {\n                 bool fFoundStartingHeader = false;\n@@ -3984,17 +3993,20 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n         //\n         std::vector<CInv> vGetData;\n         if (!pto->fClient && ((fFetch && !pto->m_limited_node) || !::ChainstateActive().IsInitialBlockDownload()) && state.nBlocksInFlight < MAX_BLOCKS_IN_TRANSIT_PER_PEER) {\n+            // Make sure pindexBestKnownBlock is up to date, we'll need it.\n+            ProcessBlockAvailability(pto->GetId());\n+\n             std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n-            FindNextBlocksToDownload(pto->GetId(), MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n+            FindNextBlocksToDownload(state.m_blocks_avail, state.fHaveWitness, MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n             for (const CBlockIndex *pindex : vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n                 MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->GetId());\n             }\n-            if (state.nBlocksInFlight == 0 && staller != -1) {\n+            if (state.nBlocksInFlight == 0 && staller != -1 && staller != pto->GetId()) {\n                 if (State(staller)->nStallingSince == 0) {\n                     State(staller)->nStallingSince = nNow;\n                     LogPrint(BCLog::NET, \"Stall started peer=%d\\n\", staller);"
      }
    ]
  },
  {
    "sha": "cd59d277bdd28a9a4ce9353f9a414d932f336a3d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjZDU5ZDI3N2JkZDI4YTlhNGNlOTM1M2Y5YTQxNGQ5MzJmMzM2YTNk",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-23T21:28:57Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "Make FindNextBlocksToDownload a member func on BlockProviderState",
      "tree": {
        "sha": "6b5632ce8752b9c70274de7d28a1529b5bff7127",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6b5632ce8752b9c70274de7d28a1529b5bff7127"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/cd59d277bdd28a9a4ce9353f9a414d932f336a3d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd59d277bdd28a9a4ce9353f9a414d932f336a3d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/cd59d277bdd28a9a4ce9353f9a414d932f336a3d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd59d277bdd28a9a4ce9353f9a414d932f336a3d/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "57ca92ac42a5dd263fdb32894d18075b5d83c54d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/57ca92ac42a5dd263fdb32894d18075b5d83c54d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/57ca92ac42a5dd263fdb32894d18075b5d83c54d"
      }
    ],
    "stats": {
      "total": 34,
      "additions": 19,
      "deletions": 15
    },
    "files": [
      {
        "sha": "54528d91e35bdf9010ae05abbad27e83b2ffc3d8",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 15,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/cd59d277bdd28a9a4ce9353f9a414d932f336a3d/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/cd59d277bdd28a9a4ce9353f9a414d932f336a3d/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=cd59d277bdd28a9a4ce9353f9a414d932f336a3d",
        "patch": "@@ -199,16 +199,20 @@ namespace {\n  * what block(s) we may want to download from them.\n  */\n struct BlockProviderState {\n-    //! The best known block we know this peer has announced.\n-    const CBlockIndex *m_best_known_block;\n+private:\n     //! The last full block we both have.\n     const CBlockIndex *m_last_common_block;\n+public:\n+    //! The best known block we know this peer has announced.\n+    const CBlockIndex *m_best_known_block;\n \n-    BlockProviderState() : m_best_known_block(nullptr), m_last_common_block(nullptr) {}\n+    BlockProviderState() : m_last_common_block(nullptr), m_best_known_block(nullptr) {}\n \n     int GetLastCommonHeight() const {\n         return m_last_common_block ? m_last_common_block->nHeight : -1;\n     }\n+\n+    void FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n };\n \n /**\n@@ -606,45 +610,45 @@ static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIV\n \n /** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n  *  at most count entries. */\n-static void FindNextBlocksToDownload(BlockProviderState& state, bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+void BlockProviderState::FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams)\n {\n     if (count == 0)\n         return;\n \n     vBlocks.reserve(vBlocks.size() + count);\n \n-    if (state.m_best_known_block == nullptr || state.m_best_known_block->nChainWork < ::ChainActive().Tip()->nChainWork || state.m_best_known_block->nChainWork < nMinimumChainWork) {\n+    if (m_best_known_block == nullptr || m_best_known_block->nChainWork < ::ChainActive().Tip()->nChainWork || m_best_known_block->nChainWork < nMinimumChainWork) {\n         // This peer has nothing interesting.\n         return;\n     }\n \n-    if (state.m_last_common_block == nullptr) {\n+    if (m_last_common_block == nullptr) {\n         // Bootstrap quickly by guessing a parent of our best tip is the forking point.\n         // Guessing wrong in either direction is not a problem.\n-        state.m_last_common_block = ::ChainActive()[std::min(state.m_best_known_block->nHeight, ::ChainActive().Height())];\n+        m_last_common_block = ::ChainActive()[std::min(m_best_known_block->nHeight, ::ChainActive().Height())];\n     }\n \n     // If the peer reorganized, our previous pindexLastCommonBlock may not be an ancestor\n     // of its current tip anymore. Go back enough to fix that.\n-    state.m_last_common_block = LastCommonAncestor(state.m_last_common_block, state.m_best_known_block);\n-    if (state.m_last_common_block == state.m_best_known_block)\n+    m_last_common_block = LastCommonAncestor(m_last_common_block, m_best_known_block);\n+    if (m_last_common_block == m_best_known_block)\n         return;\n \n     std::vector<const CBlockIndex*> vToFetch;\n-    const CBlockIndex *pindexWalk = state.m_last_common_block;\n+    const CBlockIndex *pindexWalk = m_last_common_block;\n     // Never fetch further than the best block we know the peer has, or more than BLOCK_DOWNLOAD_WINDOW + 1 beyond the last\n     // linked block we have in common with this peer. The +1 is so we can detect stalling, namely if we would be able to\n     // download that next block if the window were 1 larger.\n-    int nWindowEnd = state.m_last_common_block->nHeight + BLOCK_DOWNLOAD_WINDOW;\n-    int nMaxHeight = std::min<int>(state.m_best_known_block->nHeight, nWindowEnd + 1);\n+    int nWindowEnd = m_last_common_block->nHeight + BLOCK_DOWNLOAD_WINDOW;\n+    int nMaxHeight = std::min<int>(m_best_known_block->nHeight, nWindowEnd + 1);\n     NodeId waitingfor = -1;\n     while (pindexWalk->nHeight < nMaxHeight) {\n         // Read up to 128 (or more, if more blocks than that are needed) successors of pindexWalk (towards\n         // pindexBestKnownBlock) into vToFetch. We fetch 128, because CBlockIndex::GetAncestor may be as expensive\n         // as iterating over ~100 CBlockIndex* entries anyway.\n         int nToFetch = std::min(nMaxHeight - pindexWalk->nHeight, std::max<int>(count - vBlocks.size(), 128));\n         vToFetch.resize(nToFetch);\n-        pindexWalk = state.m_best_known_block->GetAncestor(pindexWalk->nHeight + nToFetch);\n+        pindexWalk = m_best_known_block->GetAncestor(pindexWalk->nHeight + nToFetch);\n         vToFetch[nToFetch - 1] = pindexWalk;\n         for (unsigned int i = nToFetch - 1; i > 0; i--) {\n             vToFetch[i - 1] = vToFetch[i]->pprev;\n@@ -665,7 +669,7 @@ static void FindNextBlocksToDownload(BlockProviderState& state, bool provider_ha\n             }\n             if (pindex->nStatus & BLOCK_HAVE_DATA || ::ChainActive().Contains(pindex)) {\n                 if (pindex->HaveTxsDownloaded())\n-                    state.m_last_common_block = pindex;\n+                    m_last_common_block = pindex;\n             } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n                 // The block is not already downloaded, and not yet in flight.\n                 if (pindex->nHeight > nWindowEnd) {\n@@ -3998,7 +4002,7 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n \n             std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n-            FindNextBlocksToDownload(state.m_blocks_avail, state.fHaveWitness, MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n+            state.m_blocks_avail.FindNextBlocksToDownload(state.fHaveWitness, MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n             for (const CBlockIndex *pindex : vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));"
      }
    ]
  },
  {
    "sha": "05519da346ba502bc58bb9160561e69818cccedb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNTUxOWRhMzQ2YmE1MDJiYzU4YmI5MTYwNTYxZTY5ODE4Y2NjZWRi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-23T22:00:36Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "Make FindNextBlocksToDownload not use mapBlockIndex for in-progress\n\nThis makes it more general than just net_processing",
      "tree": {
        "sha": "28fb923a400c7e11909e05af5058ef44c8fea5d5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/28fb923a400c7e11909e05af5058ef44c8fea5d5"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/05519da346ba502bc58bb9160561e69818cccedb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05519da346ba502bc58bb9160561e69818cccedb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/05519da346ba502bc58bb9160561e69818cccedb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05519da346ba502bc58bb9160561e69818cccedb/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "cd59d277bdd28a9a4ce9353f9a414d932f336a3d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/cd59d277bdd28a9a4ce9353f9a414d932f336a3d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/cd59d277bdd28a9a4ce9353f9a414d932f336a3d"
      }
    ],
    "stats": {
      "total": 33,
      "additions": 18,
      "deletions": 15
    },
    "files": [
      {
        "sha": "eed653ba6ece225709e0b99b99d599212853493e",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 15,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/05519da346ba502bc58bb9160561e69818cccedb/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/05519da346ba502bc58bb9160561e69818cccedb/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=05519da346ba502bc58bb9160561e69818cccedb",
        "patch": "@@ -212,7 +212,13 @@ struct BlockProviderState {\n         return m_last_common_block ? m_last_common_block->nHeight : -1;\n     }\n \n-    void FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+    /** Update last common height/block and add not-in-flight missing successors to vBlocks, until it has\n+     *  at most count entries.\n+\t *  Before being added to vBlocks, is_block_in_flight is called, and if it returns true, the block is\n+\t *  not added. Note that it is guaranteed to be called in the same order as the blocks appear in the\n+\t *  chain, ie the first call is the next block which is expected to be connected.\n+\t */\n+    void FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, const Consensus::Params& consensusParams, const std::function<bool (const uint256& block_hash)>& is_block_in_flight) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n };\n \n /**\n@@ -608,9 +614,7 @@ static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIV\n     return false;\n }\n \n-/** Update pindexLastCommonBlock and add not-in-flight missing successors to vBlocks, until it has\n- *  at most count entries. */\n-void BlockProviderState::FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, NodeId& nodeStaller, const Consensus::Params& consensusParams)\n+void BlockProviderState::FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, const Consensus::Params& consensusParams, const std::function<bool (const uint256& block_hash)>& is_block_in_flight)\n {\n     if (count == 0)\n         return;\n@@ -641,7 +645,6 @@ void BlockProviderState::FindNextBlocksToDownload(bool provider_has_witness, uns\n     // download that next block if the window were 1 larger.\n     int nWindowEnd = m_last_common_block->nHeight + BLOCK_DOWNLOAD_WINDOW;\n     int nMaxHeight = std::min<int>(m_best_known_block->nHeight, nWindowEnd + 1);\n-    NodeId waitingfor = -1;\n     while (pindexWalk->nHeight < nMaxHeight) {\n         // Read up to 128 (or more, if more blocks than that are needed) successors of pindexWalk (towards\n         // pindexBestKnownBlock) into vToFetch. We fetch 128, because CBlockIndex::GetAncestor may be as expensive\n@@ -670,23 +673,16 @@ void BlockProviderState::FindNextBlocksToDownload(bool provider_has_witness, uns\n             if (pindex->nStatus & BLOCK_HAVE_DATA || ::ChainActive().Contains(pindex)) {\n                 if (pindex->HaveTxsDownloaded())\n                     m_last_common_block = pindex;\n-            } else if (mapBlocksInFlight.count(pindex->GetBlockHash()) == 0) {\n+            } else if (!is_block_in_flight(pindex->GetBlockHash())) {\n                 // The block is not already downloaded, and not yet in flight.\n                 if (pindex->nHeight > nWindowEnd) {\n                     // We reached the end of the window.\n-                    if (vBlocks.size() == 0) {\n-                        // We aren't able to fetch anything, but we would be if the download window was one larger.\n-                        nodeStaller = waitingfor;\n-                    }\n                     return;\n                 }\n                 vBlocks.push_back(pindex);\n                 if (vBlocks.size() == count) {\n                     return;\n                 }\n-            } else if (waitingfor == -1) {\n-                // This is the first already-in-flight block.\n-                waitingfor = mapBlocksInFlight[pindex->GetBlockHash()].first;\n             }\n         }\n     }\n@@ -4002,15 +3998,22 @@ bool PeerLogicValidation::SendMessages(CNode* pto)\n \n             std::vector<const CBlockIndex*> vToDownload;\n             NodeId staller = -1;\n-            state.m_blocks_avail.FindNextBlocksToDownload(state.fHaveWitness, MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, staller, consensusParams);\n+            state.m_blocks_avail.FindNextBlocksToDownload(state.fHaveWitness, MAX_BLOCKS_IN_TRANSIT_PER_PEER - state.nBlocksInFlight, vToDownload, consensusParams,\n+                [&staller] (const uint256& block_hash) NO_THREAD_SAFETY_ANALYSIS { // We're holding cs_main outside, so this is fine\n+                    auto in_flight_it = mapBlocksInFlight.find(block_hash);\n+                    if (in_flight_it != mapBlocksInFlight.end()) {\n+                        staller = in_flight_it->second.first;\n+                    }\n+                    return in_flight_it != mapBlocksInFlight.end();\n+                });\n             for (const CBlockIndex *pindex : vToDownload) {\n                 uint32_t nFetchFlags = GetFetchFlags(pto);\n                 vGetData.push_back(CInv(MSG_BLOCK | nFetchFlags, pindex->GetBlockHash()));\n                 MarkBlockAsInFlight(pto->GetId(), pindex->GetBlockHash(), pindex);\n                 LogPrint(BCLog::NET, \"Requesting block %s (%d) peer=%d\\n\", pindex->GetBlockHash().ToString(),\n                     pindex->nHeight, pto->GetId());\n             }\n-            if (state.nBlocksInFlight == 0 && staller != -1 && staller != pto->GetId()) {\n+            if (state.nBlocksInFlight == 0 && staller != -1 && staller != pto->GetId() && vToDownload.empty()) {\n                 if (State(staller)->nStallingSince == 0) {\n                     State(staller)->nStallingSince = nNow;\n                     LogPrint(BCLog::NET, \"Stall started peer=%d\\n\", staller);"
      }
    ]
  },
  {
    "sha": "290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyOTBmOGY0N2ZkZjJhMmIyYTczNjhmOThjNjZkN2U4NWZkNTY1MWQ4",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-08-23T22:07:19Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "Move BlockProvider to validation.{h,cpp} from net_processing",
      "tree": {
        "sha": "7e1c83f21bfba6431072168a13702c56508dcf51",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7e1c83f21bfba6431072168a13702c56508dcf51"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "05519da346ba502bc58bb9160561e69818cccedb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/05519da346ba502bc58bb9160561e69818cccedb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/05519da346ba502bc58bb9160561e69818cccedb"
      }
    ],
    "stats": {
      "total": 202,
      "additions": 101,
      "deletions": 101
    },
    "files": [
      {
        "sha": "837110732b11c65ccbd8a43bfb4ea52352a2f710",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 101,
        "changes": 101,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8",
        "patch": "@@ -194,33 +194,6 @@ namespace {\n } // namespace\n \n namespace {\n-/**\n- * Information about a peer's available blocks, for the purpose of figuring out\n- * what block(s) we may want to download from them.\n- */\n-struct BlockProviderState {\n-private:\n-    //! The last full block we both have.\n-    const CBlockIndex *m_last_common_block;\n-public:\n-    //! The best known block we know this peer has announced.\n-    const CBlockIndex *m_best_known_block;\n-\n-    BlockProviderState() : m_last_common_block(nullptr), m_best_known_block(nullptr) {}\n-\n-    int GetLastCommonHeight() const {\n-        return m_last_common_block ? m_last_common_block->nHeight : -1;\n-    }\n-\n-    /** Update last common height/block and add not-in-flight missing successors to vBlocks, until it has\n-     *  at most count entries.\n-\t *  Before being added to vBlocks, is_block_in_flight is called, and if it returns true, the block is\n-\t *  not added. Note that it is guaranteed to be called in the same order as the blocks appear in the\n-\t *  chain, ie the first call is the next block which is expected to be connected.\n-\t */\n-    void FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, const Consensus::Params& consensusParams, const std::function<bool (const uint256& block_hash)>& is_block_in_flight) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n-};\n-\n /**\n  * Maintain validation-specific state about nodes, protected by cs_main, instead\n  * by CNode's own locks. This simplifies asynchronous operation, where\n@@ -614,80 +587,6 @@ static bool PeerHasHeader(CNodeState *state, const CBlockIndex *pindex) EXCLUSIV\n     return false;\n }\n \n-void BlockProviderState::FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, const Consensus::Params& consensusParams, const std::function<bool (const uint256& block_hash)>& is_block_in_flight)\n-{\n-    if (count == 0)\n-        return;\n-\n-    vBlocks.reserve(vBlocks.size() + count);\n-\n-    if (m_best_known_block == nullptr || m_best_known_block->nChainWork < ::ChainActive().Tip()->nChainWork || m_best_known_block->nChainWork < nMinimumChainWork) {\n-        // This peer has nothing interesting.\n-        return;\n-    }\n-\n-    if (m_last_common_block == nullptr) {\n-        // Bootstrap quickly by guessing a parent of our best tip is the forking point.\n-        // Guessing wrong in either direction is not a problem.\n-        m_last_common_block = ::ChainActive()[std::min(m_best_known_block->nHeight, ::ChainActive().Height())];\n-    }\n-\n-    // If the peer reorganized, our previous pindexLastCommonBlock may not be an ancestor\n-    // of its current tip anymore. Go back enough to fix that.\n-    m_last_common_block = LastCommonAncestor(m_last_common_block, m_best_known_block);\n-    if (m_last_common_block == m_best_known_block)\n-        return;\n-\n-    std::vector<const CBlockIndex*> vToFetch;\n-    const CBlockIndex *pindexWalk = m_last_common_block;\n-    // Never fetch further than the best block we know the peer has, or more than BLOCK_DOWNLOAD_WINDOW + 1 beyond the last\n-    // linked block we have in common with this peer. The +1 is so we can detect stalling, namely if we would be able to\n-    // download that next block if the window were 1 larger.\n-    int nWindowEnd = m_last_common_block->nHeight + BLOCK_DOWNLOAD_WINDOW;\n-    int nMaxHeight = std::min<int>(m_best_known_block->nHeight, nWindowEnd + 1);\n-    while (pindexWalk->nHeight < nMaxHeight) {\n-        // Read up to 128 (or more, if more blocks than that are needed) successors of pindexWalk (towards\n-        // pindexBestKnownBlock) into vToFetch. We fetch 128, because CBlockIndex::GetAncestor may be as expensive\n-        // as iterating over ~100 CBlockIndex* entries anyway.\n-        int nToFetch = std::min(nMaxHeight - pindexWalk->nHeight, std::max<int>(count - vBlocks.size(), 128));\n-        vToFetch.resize(nToFetch);\n-        pindexWalk = m_best_known_block->GetAncestor(pindexWalk->nHeight + nToFetch);\n-        vToFetch[nToFetch - 1] = pindexWalk;\n-        for (unsigned int i = nToFetch - 1; i > 0; i--) {\n-            vToFetch[i - 1] = vToFetch[i]->pprev;\n-        }\n-\n-        // Iterate over those blocks in vToFetch (in forward direction), adding the ones that\n-        // are not yet downloaded and not in flight to vBlocks. In the meantime, update\n-        // pindexLastCommonBlock as long as all ancestors are already downloaded, or if it's\n-        // already part of our chain (and therefore don't need it even if pruned).\n-        for (const CBlockIndex* pindex : vToFetch) {\n-            if (!pindex->IsValid(BLOCK_VALID_TREE)) {\n-                // We consider the chain that this peer is on invalid.\n-                return;\n-            }\n-            if (!provider_has_witness && IsWitnessEnabled(pindex->pprev, consensusParams)) {\n-                // We wouldn't download this block or its descendants from this peer.\n-                return;\n-            }\n-            if (pindex->nStatus & BLOCK_HAVE_DATA || ::ChainActive().Contains(pindex)) {\n-                if (pindex->HaveTxsDownloaded())\n-                    m_last_common_block = pindex;\n-            } else if (!is_block_in_flight(pindex->GetBlockHash())) {\n-                // The block is not already downloaded, and not yet in flight.\n-                if (pindex->nHeight > nWindowEnd) {\n-                    // We reached the end of the window.\n-                    return;\n-                }\n-                vBlocks.push_back(pindex);\n-                if (vBlocks.size() == count) {\n-                    return;\n-                }\n-            }\n-        }\n-    }\n-}\n-\n void EraseTxRequest(const uint256& txid) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     g_already_asked_for.erase(txid);"
      },
      {
        "sha": "0c9bfc9bbe71c9c8da49f5d55715f2df6468f3eb",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8",
        "patch": "@@ -1111,6 +1111,80 @@ bool GetTransaction(const uint256& hash, CTransactionRef& txOut, const Consensus\n // CBlock and CBlockIndex\n //\n \n+void BlockProviderState::FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, const Consensus::Params& consensusParams, const std::function<bool (const uint256& block_hash)>& is_block_in_flight)\n+{\n+    if (count == 0)\n+        return;\n+\n+    vBlocks.reserve(vBlocks.size() + count);\n+\n+    if (m_best_known_block == nullptr || m_best_known_block->nChainWork < ::ChainActive().Tip()->nChainWork || m_best_known_block->nChainWork < nMinimumChainWork) {\n+        // This peer has nothing interesting.\n+        return;\n+    }\n+\n+    if (m_last_common_block == nullptr) {\n+        // Bootstrap quickly by guessing a parent of our best tip is the forking point.\n+        // Guessing wrong in either direction is not a problem.\n+        m_last_common_block = ::ChainActive()[std::min(m_best_known_block->nHeight, ::ChainActive().Height())];\n+    }\n+\n+    // If the peer reorganized, our previous pindexLastCommonBlock may not be an ancestor\n+    // of its current tip anymore. Go back enough to fix that.\n+    m_last_common_block = LastCommonAncestor(m_last_common_block, m_best_known_block);\n+    if (m_last_common_block == m_best_known_block)\n+        return;\n+\n+    std::vector<const CBlockIndex*> vToFetch;\n+    const CBlockIndex *pindexWalk = m_last_common_block;\n+    // Never fetch further than the best block we know the peer has, or more than BLOCK_DOWNLOAD_WINDOW + 1 beyond the last\n+    // linked block we have in common with this peer. The +1 is so we can detect stalling, namely if we would be able to\n+    // download that next block if the window were 1 larger.\n+    int nWindowEnd = m_last_common_block->nHeight + BLOCK_DOWNLOAD_WINDOW;\n+    int nMaxHeight = std::min<int>(m_best_known_block->nHeight, nWindowEnd + 1);\n+    while (pindexWalk->nHeight < nMaxHeight) {\n+        // Read up to 128 (or more, if more blocks than that are needed) successors of pindexWalk (towards\n+        // pindexBestKnownBlock) into vToFetch. We fetch 128, because CBlockIndex::GetAncestor may be as expensive\n+        // as iterating over ~100 CBlockIndex* entries anyway.\n+        int nToFetch = std::min(nMaxHeight - pindexWalk->nHeight, std::max<int>(count - vBlocks.size(), 128));\n+        vToFetch.resize(nToFetch);\n+        pindexWalk = m_best_known_block->GetAncestor(pindexWalk->nHeight + nToFetch);\n+        vToFetch[nToFetch - 1] = pindexWalk;\n+        for (unsigned int i = nToFetch - 1; i > 0; i--) {\n+            vToFetch[i - 1] = vToFetch[i]->pprev;\n+        }\n+\n+        // Iterate over those blocks in vToFetch (in forward direction), adding the ones that\n+        // are not yet downloaded and not in flight to vBlocks. In the meantime, update\n+        // pindexLastCommonBlock as long as all ancestors are already downloaded, or if it's\n+        // already part of our chain (and therefore don't need it even if pruned).\n+        for (const CBlockIndex* pindex : vToFetch) {\n+            if (!pindex->IsValid(BLOCK_VALID_TREE)) {\n+                // We consider the chain that this peer is on invalid.\n+                return;\n+            }\n+            if (!provider_has_witness && IsWitnessEnabled(pindex->pprev, consensusParams)) {\n+                // We wouldn't download this block or its descendants from this peer.\n+                return;\n+            }\n+            if (pindex->nStatus & BLOCK_HAVE_DATA || ::ChainActive().Contains(pindex)) {\n+                if (pindex->HaveTxsDownloaded())\n+                    m_last_common_block = pindex;\n+            } else if (!is_block_in_flight(pindex->GetBlockHash())) {\n+                // The block is not already downloaded, and not yet in flight.\n+                if (pindex->nHeight > nWindowEnd) {\n+                    // We reached the end of the window.\n+                    return;\n+                }\n+                vBlocks.push_back(pindex);\n+                if (vBlocks.size() == count) {\n+                    return;\n+                }\n+            }\n+        }\n+    }\n+}\n+\n static bool WriteBlockToDisk(const CBlock& block, FlatFilePos& pos, const CMessageHeader::MessageStartChars& messageStart)\n {\n     // Open history file to append"
      },
      {
        "sha": "2694fccc13240d0259e46ccea0e0c938d87028da",
        "filename": "src/validation.h",
        "status": "modified",
        "additions": 27,
        "deletions": 0,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8/src/validation.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8/src/validation.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.h?ref=290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8",
        "patch": "@@ -733,6 +733,33 @@ class CChainState {\n     void EraseBlockData(CBlockIndex* index) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n };\n \n+/**\n+ * Information about a peer's available blocks, for the purpose of figuring out\n+ * what block(s) we may want to download from them.\n+ */\n+struct BlockProviderState {\n+private:\n+    //! The last full block we both have.\n+    const CBlockIndex *m_last_common_block;\n+public:\n+    //! The best known block we know this peer has announced.\n+    const CBlockIndex *m_best_known_block;\n+\n+    BlockProviderState() : m_last_common_block(nullptr), m_best_known_block(nullptr) {}\n+\n+    int GetLastCommonHeight() const {\n+        return m_last_common_block ? m_last_common_block->nHeight : -1;\n+    }\n+\n+    /** Update last common height/block and add not-in-flight missing successors to vBlocks, until it has\n+     *  at most count entries.\n+     *  Before being added to vBlocks, is_block_in_flight is called, and if it returns true, the block is\n+     *  not added. Note that it is guaranteed to be called in the same order as the blocks appear in the\n+     *  chain, ie the first call is the next block which is expected to be connected.\n+     */\n+    void FindNextBlocksToDownload(bool provider_has_witness, unsigned int count, std::vector<const CBlockIndex*>& vBlocks, const Consensus::Params& consensusParams, const std::function<bool (const uint256& block_hash)>& is_block_in_flight) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+};\n+\n /** Mark a block as precious and reorganize.\n  *\n  * May not be called in a"
      }
    ]
  },
  {
    "sha": "e105ea86ec7a763b57d0aa416acabdacdbee0e92",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplMTA1ZWE4NmVjN2E3NjNiNTdkMGFhNDE2YWNhYmRhY2RiZWUwZTky",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-12T04:53:41Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "Add ffis to access BlockProviderState and hand blocks to C++",
      "tree": {
        "sha": "7038b9fff3884b15182f9014456e6312c09560b0",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7038b9fff3884b15182f9014456e6312c09560b0"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e105ea86ec7a763b57d0aa416acabdacdbee0e92",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e105ea86ec7a763b57d0aa416acabdacdbee0e92",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e105ea86ec7a763b57d0aa416acabdacdbee0e92",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e105ea86ec7a763b57d0aa416acabdacdbee0e92/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/290f8f47fdf2a2b2a7368f98c66d7e85fd5651d8"
      }
    ],
    "stats": {
      "total": 191,
      "additions": 191,
      "deletions": 0
    },
    "files": [
      {
        "sha": "480e6204d3c9389803f6645f721505e19ecb378f",
        "filename": "src/rusty/src/bridge.rs",
        "status": "modified",
        "additions": 103,
        "deletions": 0,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e105ea86ec7a763b57d0aa416acabdacdbee0e92/src/rusty/src/bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e105ea86ec7a763b57d0aa416acabdacdbee0e92/src/rusty/src/bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/bridge.rs?ref=e105ea86ec7a763b57d0aa416acabdacdbee0e92",
        "patch": "@@ -3,6 +3,8 @@ extern \"C\" {\n     pub fn rusty_IsInitialBlockDownload() -> bool;\n     pub fn rusty_ShutdownRequested() -> bool;\n \n+    fn rusty_ProcessNewBlock(blockdata: *const u8, blockdatalen: usize, blockindex_requested: *const c_void);\n+\n     /// Connects count headers serialized in a block of memory, each stride bytes from each other.\n     /// Returns the last header which was connected, if any (or NULL).\n     fn rusty_ConnectHeaders(headers: *const u8, stride: usize, count: usize) -> *const c_void;\n@@ -13,8 +15,15 @@ extern \"C\" {\n     /// Guaranteed to never be NULL (but may be genesis)\n     fn rusty_GetChainTip() -> *const c_void;\n \n+    /// Gets a CBlockIndex* pointer (casted to a c_void) representing the genesis block.\n+    /// Guaranteed to never be NULL\n+    fn rusty_GetGenesisIndex() -> *const c_void;\n+\n     /// Gets the height of a given CBlockIndex* pointer\n     fn rusty_IndexToHeight(index: *const c_void) -> i32;\n+\n+    /// Gets the hash of a given CBlockIndex* pointer\n+    fn rusty_IndexToHash(index: *const c_void) -> *const u8;\n }\n \n /// Connects the given array of (sorted, in chain order) headers (in serialized, 80-byte form).\n@@ -26,6 +35,16 @@ pub fn connect_headers_flat_bytes(headers: &[u8]) -> Option<BlockIndex> {\n     if index.is_null() { None } else { Some(BlockIndex { index }) }\n }\n \n+/// Processes a new block, in serialized form.\n+/// blockindex_requested_by_state should be set *only* if the given BlockIndex was provided by\n+/// BlockProviderState::get_next_block_to_download(), and may be set to None always.\n+pub fn connect_block(blockdata: &[u8], blockindex_requested_by_state: Option<BlockIndex>) {\n+    let blockindex = match blockindex_requested_by_state { Some(index) => index.index, None => std::ptr::null(), };\n+    unsafe {\n+        rusty_ProcessNewBlock(blockdata.as_ptr(), blockdata.len(), blockindex);\n+    }\n+}\n+\n #[derive(PartialEq, Clone, Copy)]\n pub struct BlockIndex {\n     index: *const c_void,\n@@ -38,7 +57,91 @@ impl BlockIndex {\n         }\n     }\n \n+    pub fn genesis() -> Self {\n+        Self {\n+            index: unsafe { rusty_GetGenesisIndex() },\n+        }\n+    }\n+\n     pub fn height(&self) -> i32 {\n         unsafe { rusty_IndexToHeight(self.index) }\n     }\n+\n+    pub fn hash(&self) -> [u8; 32] {\n+        let hashptr = unsafe { rusty_IndexToHash(self.index) };\n+        if hashptr.is_null() { unreachable!(); }\n+        let mut res = [0u8; 32];\n+        unsafe { std::ptr::copy(hashptr, res.as_mut_ptr(), 32) };\n+        res\n+    }\n+\n+    /// Gets the hex formatted hash of this block, in byte-revered order (ie starting with the PoW\n+    /// 0s, as is commonly used in Bitcoin APIs).\n+    pub fn hash_hex(&self) -> String {\n+        let hash_bytes = self.hash();\n+        let mut res = String::with_capacity(64);\n+        for b in hash_bytes.iter().rev() {\n+            res.push(std::char::from_digit((b >> 4) as u32, 16).unwrap());\n+            res.push(std::char::from_digit((b & 0x0f) as u32, 16).unwrap());\n+        }\n+        res\n+    }\n+}\n+\n+extern \"C\" {\n+    // Utilities to work with BlockProviderState objects. Wrapped in a safe wrapper below.\n+\n+    /// Creates a new BlockProviderState with a given current best CBlockIndex*.\n+    /// Don't forget to de-allocate!\n+    fn rusty_ProviderStateInit(blockindex: *const c_void) -> *mut c_void;\n+    /// De-allocates a BlockProviderState.\n+    fn rusty_ProviderStateFree(provider_state: *mut c_void);\n+\n+    /// Sets the current best available CBlockIndex* for the given provider state.\n+    fn rusty_ProviderStateSetBest(provider_state: *mut c_void, blockindex: *const c_void);\n+\n+    /// Gets the next CBlockIndex* a given provider should download, or NULL\n+    fn rusty_ProviderStateGetNextDownloads(providerindexvoid: *mut c_void, has_witness: bool) -> *const c_void;\n+}\n+\n+pub struct BlockProviderState {\n+    // TODO: We should be smarter than to keep a copy of the current best pointer twice, but\n+    // crossing the FFI boundary just to look it up again sucks.\n+    current_best: BlockIndex,\n+    state: *mut c_void,\n+}\n+impl BlockProviderState {\n+    /// Initializes block provider state with a given current best header.\n+    /// Note that you can use a guess on the current best that moves backwards as you discover the\n+    /// providers' true chain state, though for efficiency you should try to avoid calling\n+    /// get_next_block_to_download in such a state.\n+    pub fn new_with_current_best(blockindex: BlockIndex) -> Self {\n+        Self {\n+            current_best: blockindex,\n+            state: unsafe { rusty_ProviderStateInit(blockindex.index) }\n+        }\n+    }\n+\n+    /// Sets the current best available blockindex to the given one on this state.\n+    pub fn set_current_best(&mut self, blockindex: BlockIndex) {\n+        self.current_best = blockindex;\n+        unsafe { rusty_ProviderStateSetBest(self.state, blockindex.index) };\n+    }\n+\n+    /// Gets the current best available blockindex as provided previously by set_current_best or\n+    /// new_with_current_best.\n+    pub fn get_current_best(&self) -> BlockIndex {\n+        self.current_best\n+    }\n+\n+    /// Gets the BlockIndex representing the next block which should be downloaded, if any.\n+    pub fn get_next_block_to_download(&mut self, has_witness: bool) -> Option<BlockIndex> {\n+        let index = unsafe { rusty_ProviderStateGetNextDownloads(self.state, has_witness) };\n+        if index.is_null() { None } else { Some(BlockIndex { index }) }\n+    }\n+}\n+impl Drop for BlockProviderState {\n+    fn drop(&mut self) {\n+        unsafe { rusty_ProviderStateFree(self.state) };\n+    }\n }"
      },
      {
        "sha": "e3a1501d5955c0f6b8bdbf241c21d4f859f52db8",
        "filename": "src/rusty/src/cpp_bridge.cpp",
        "status": "modified",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e105ea86ec7a763b57d0aa416acabdacdbee0e92/src/rusty/src/cpp_bridge.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e105ea86ec7a763b57d0aa416acabdacdbee0e92/src/rusty/src/cpp_bridge.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/cpp_bridge.cpp?ref=e105ea86ec7a763b57d0aa416acabdacdbee0e92",
        "patch": "@@ -57,6 +57,19 @@ bool rusty_ShutdownRequested() {\n     return ShutdownRequested();\n }\n \n+void rusty_ProcessNewBlock(const uint8_t* blockdata, size_t blocklen, const void* pindexvoid) {\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    CBlock block;\n+    try {\n+        InputStream(SER_NETWORK, PROTOCOL_VERSION, blockdata, blocklen) >> block;\n+    } catch (...) {}\n+    if (pindex && block.GetHash() == pindex->GetBlockHash()) {\n+        ProcessNewBlock(::Params(), std::make_shared<const CBlock>(block), true, nullptr);\n+    } else {\n+        ProcessNewBlock(::Params(), std::make_shared<const CBlock>(block), false, nullptr);\n+    }\n+}\n+\n const void* rusty_ConnectHeaders(const uint8_t* headers_data, size_t stride, size_t count) {\n     std::vector<CBlockHeader> headers;\n     for(size_t i = 0; i < count; i++) {\n@@ -79,10 +92,49 @@ const void* rusty_GetChainTip() {\n     return tip;\n }\n \n+const void* rusty_GetGenesisIndex() {\n+    LOCK(cs_main);\n+    const CBlockIndex* genesis = ::ChainActive().Genesis();\n+    assert(genesis != nullptr);\n+    return genesis;\n+}\n+\n int32_t rusty_IndexToHeight(const void* pindexvoid) {\n     const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n     assert(pindex != nullptr);\n     return pindex->nHeight;\n }\n \n+const uint8_t* rusty_IndexToHash(const void* pindexvoid) {\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    assert(pindex != nullptr);\n+    return pindex->phashBlock->begin();\n+}\n+\n+void* rusty_ProviderStateInit(const void* pindexvoid) {\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    BlockProviderState* state = new BlockProviderState;\n+    state->m_best_known_block = pindex;\n+    return state;\n+}\n+\n+void rusty_ProviderStateFree(void* providerindexvoid) {\n+    BlockProviderState* state = (BlockProviderState*) providerindexvoid;\n+    delete state;\n+}\n+\n+void rusty_ProviderStateSetBest(void* providerindexvoid, const void* pindexvoid) {\n+    BlockProviderState* state = (BlockProviderState*) providerindexvoid;\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    state->m_best_known_block = pindex;\n+}\n+\n+const void* rusty_ProviderStateGetNextDownloads(void* providerindexvoid, bool has_witness) {\n+    BlockProviderState* state = (BlockProviderState*) providerindexvoid;\n+    std::vector<const CBlockIndex*> blocks;\n+    LOCK(cs_main);\n+    state->FindNextBlocksToDownload(has_witness, 1, blocks, ::Params().GetConsensus(), [] (const uint256& block_hash) { return false; });\n+    return blocks.empty() ? nullptr : blocks[0];\n+}\n+\n }"
      },
      {
        "sha": "27e862c91d5bda426d839b23af9a7e5952befc37",
        "filename": "src/rusty/src/test_bridge.rs",
        "status": "modified",
        "additions": 36,
        "deletions": 0,
        "changes": 36,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e105ea86ec7a763b57d0aa416acabdacdbee0e92/src/rusty/src/test_bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e105ea86ec7a763b57d0aa416acabdacdbee0e92/src/rusty/src/test_bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/test_bridge.rs?ref=e105ea86ec7a763b57d0aa416acabdacdbee0e92",
        "patch": "@@ -10,6 +10,10 @@ pub fn connect_headers_flat_bytes(_headers: &[u8]) -> Option<BlockIndex> {\n     unimplemented!();\n }\n \n+pub fn connect_block(_blockdata: &[u8], _blockindex_requested_by_state: Option<BlockIndex>) {\n+    unimplemented!();\n+}\n+\n #[derive(PartialEq, Clone, Copy)]\n pub struct BlockIndex { }\n \n@@ -18,7 +22,39 @@ impl BlockIndex {\n         unimplemented!();\n     }\n \n+    pub fn genesis() -> Self {\n+        unimplemented!();\n+    }\n+\n     pub fn height(&self) -> i32 {\n         unimplemented!();\n     }\n+\n+    pub fn hash(&self) -> [u8; 32] {\n+        unimplemented!();\n+    }\n+\n+    pub fn hash_hex(&self) -> String {\n+        unimplemented!();\n+    }\n+}\n+\n+pub struct BlockProviderState { }\n+\n+impl BlockProviderState {\n+    pub fn new_with_current_best(_blockindex: BlockIndex) -> Self {\n+        unimplemented!();\n+    }\n+\n+    pub fn set_current_best(&mut self, _blockindex: BlockIndex) {\n+        unimplemented!();\n+    }\n+\n+    pub fn get_current_best(&self) -> BlockIndex {\n+        unimplemented!();\n+    }\n+\n+    pub fn get_next_block_to_download(&mut self, _has_witness: bool) -> Option<BlockIndex> {\n+        unimplemented!();\n+    }\n }"
      }
    ]
  },
  {
    "sha": "4e691f96023b60d257ec3d5deb0b0b5f92170377",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0ZTY5MWY5NjAyM2I2MGQyNTdlYzNkNWRlYjBiMGI1ZjkyMTcwMzc3",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-18T19:30:52Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "Add a rust-based backup over-REST block downloader",
      "tree": {
        "sha": "84fba04fbf0bd2c2d11a0d69e84b06a235240f70",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/84fba04fbf0bd2c2d11a0d69e84b06a235240f70"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/4e691f96023b60d257ec3d5deb0b0b5f92170377",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4e691f96023b60d257ec3d5deb0b0b5f92170377",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/4e691f96023b60d257ec3d5deb0b0b5f92170377",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4e691f96023b60d257ec3d5deb0b0b5f92170377/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e105ea86ec7a763b57d0aa416acabdacdbee0e92",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e105ea86ec7a763b57d0aa416acabdacdbee0e92",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e105ea86ec7a763b57d0aa416acabdacdbee0e92"
      }
    ],
    "stats": {
      "total": 356,
      "additions": 355,
      "deletions": 1
    },
    "files": [
      {
        "sha": "0a40462107fa3ab51cb17556f4d9da1e39245e32",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4e691f96023b60d257ec3d5deb0b0b5f92170377/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4e691f96023b60d257ec3d5deb0b0b5f92170377/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=4e691f96023b60d257ec3d5deb0b0b5f92170377",
        "patch": "@@ -376,7 +376,8 @@ libbitcoin_wallet_tool_a_SOURCES = \\\n LIBBITCOIN_RUSTY_SRCS= \\\n   rusty/src/lib.rs \\\n   rusty/src/bridge.rs \\\n-  rusty/src/dns_headers.rs\n+  rusty/src/dns_headers.rs \\\n+  rusty/src/rest_downloader.rs\n \n LIBBITCOIN_RUSTY_TEST_SRCS= \\\n   rusty/src/test_bridge.rs"
      },
      {
        "sha": "582a37508626eddecd937662c4a0603ee371e476",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4e691f96023b60d257ec3d5deb0b0b5f92170377/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4e691f96023b60d257ec3d5deb0b0b5f92170377/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=4e691f96023b60d257ec3d5deb0b0b5f92170377",
        "patch": "@@ -189,6 +189,7 @@ void Shutdown(NodeContext& node)\n \n #if ENABLE_RUSTY\n     rust_block_fetch::stop_fetch_dns_headers();\n+    rust_block_fetch::stop_fetch_rest_blocks();\n #endif\n \n     StopHTTPRPC();\n@@ -406,6 +407,7 @@ void SetupServerArgs()\n                  ArgsManager::ALLOW_ANY, OptionsCategory::OPTIONS);\n \n #if ENABLE_RUSTY\n+    gArgs.AddArg(\"-blockfetchrest=<uri>\", \"A REST endpoint from which to fetch blocks. Acts as a redundant backup for P2P connectivity. eg http://cloudflare.deanonymizingseed.com/rest/\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-headersfetchdns=<domain>\", \"A domain name from which to fetch headers. eg bitcoinheaders.net\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n #endif\n     gArgs.AddArg(\"-addnode=<ip>\", \"Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC command help for more info). This option can be specified multiple times to add multiple nodes.\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n@@ -1839,6 +1841,9 @@ bool AppInitMain(NodeContext& node)\n     for (const std::string& domain : gArgs.GetArgs(\"-headersfetchdns\")) {\n         rust_block_fetch::init_fetch_dns_headers(domain.c_str());\n     }\n+    for (const std::string& uri : gArgs.GetArgs(\"-blockfetchrest\")) {\n+        rust_block_fetch::init_fetch_rest_blocks(uri.c_str());\n+    }\n #endif\n \n     return true;"
      },
      {
        "sha": "891e4fd8678ce9d8378a6db374dab5cda7c09648",
        "filename": "src/rusty/src/lib.rs",
        "status": "modified",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4e691f96023b60d257ec3d5deb0b0b5f92170377/src/rusty/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4e691f96023b60d257ec3d5deb0b0b5f92170377/src/rusty/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/lib.rs?ref=4e691f96023b60d257ec3d5deb0b0b5f92170377",
        "patch": "@@ -1,9 +1,16 @@\n+// Rust has a tendency to try to force users onto the Latest And Greatest (tm)\n+// with incredibly verbose warnings. Sadly, we need to support users who use rustc\n+// as distributed by their linux distribution, so in generally cannot \"fix\" the\n+// warnings. Thus, we should disable such useless lints below.\n+#![allow(deprecated)]\n+\n #[cfg(not(test))] mod bridge;\n #[cfg(test)] pub mod test_bridge;\n #[cfg(test)] pub use test_bridge as bridge;\n use bridge::*;\n \n mod dns_headers;\n+mod rest_downloader;\n \n use std::alloc::{GlobalAlloc, Layout, System};\n use std::ptr;"
      },
      {
        "sha": "966a83933e4cb697d694f629c1725c82f2f294b5",
        "filename": "src/rusty/src/rest_downloader.rs",
        "status": "added",
        "additions": 339,
        "deletions": 0,
        "changes": 339,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4e691f96023b60d257ec3d5deb0b0b5f92170377/src/rusty/src/rest_downloader.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4e691f96023b60d257ec3d5deb0b0b5f92170377/src/rusty/src/rest_downloader.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/rest_downloader.rs?ref=4e691f96023b60d257ec3d5deb0b0b5f92170377",
        "patch": "@@ -0,0 +1,339 @@\n+use std::cmp;\n+use std::net::{TcpStream, ToSocketAddrs};\n+use std::io::{Read, Write};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::time::Duration;\n+use std::panic::catch_unwind;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+\n+use std::ffi::CStr;\n+use std::os::raw::c_char;\n+\n+/// Splits an HTTP URI into its component part - (is_ssl, hostname, port number, and HTTP path)\n+fn split_uri<'a>(uri: &'a str) -> Option<(bool, &'a str, u16, &'a str)> {\n+    let mut uri_iter = uri.splitn(2, \":\");\n+    let ssl = match uri_iter.next() {\n+        Some(\"http\") => false,\n+        Some(\"https\") => true,\n+        _ => return None,\n+    };\n+    let mut host_path = match uri_iter.next() {\n+        Some(r) => r,\n+        None => return None,\n+    };\n+    host_path = host_path.trim_left_matches(\"/\");\n+    let mut host_path_iter = host_path.splitn(2, \"/\");\n+    let (host_port_len, host, port) = match host_path_iter.next() {\n+        Some(r) if !r.is_empty() => {\n+            let is_v6_explicit = r.starts_with(\"[\");\n+            let mut iter = if is_v6_explicit {\n+                r[1..].splitn(2, \"]\")\n+            } else {\n+                r.splitn(2, \":\")\n+            };\n+            (r.len(), match iter.next() {\n+                Some(host) => host,\n+                None => return None,\n+            }, match iter.next() {\n+                Some(port) if !is_v6_explicit || !port.is_empty() => match if is_v6_explicit {\n+                    if port.as_bytes()[0] != ':' as u8 { return None; }\n+                    &port[1..]\n+                } else { port }\n+                .parse::<u16>() {\n+                    Ok(p) => p,\n+                    Err(_) => return None,\n+                },\n+                _ => if ssl { 443 } else { 80 },\n+            })\n+        },\n+        _ => return None,\n+    };\n+    let path = &host_path[host_port_len..];\n+\n+    Some((ssl, host, port, path))\n+}\n+\n+#[cfg(test)]\n+#[test]\n+fn test_split_uri() {\n+    assert_eq!(split_uri(\"http://example.com:8080/path\"), Some((false, \"example.com\", 8080, \"/path\")));\n+    assert_eq!(split_uri(\"http:example.com:8080/path/b\"), Some((false, \"example.com\", 8080, \"/path/b\")));\n+    assert_eq!(split_uri(\"https://0.0.0.0/\"), Some((true, \"0.0.0.0\", 443, \"/\")));\n+    assert_eq!(split_uri(\"http:[0:bad::43]:80/\"), Some((false, \"0:bad::43\", 80, \"/\")));\n+    assert_eq!(split_uri(\"http:[::]\"), Some((false, \"::\", 80, \"\")));\n+    assert_eq!(split_uri(\"http://\"), None);\n+    assert_eq!(split_uri(\"http://example.com:70000/\"), None);\n+    assert_eq!(split_uri(\"ftp://example.com:80/\"), None);\n+    assert_eq!(split_uri(\"http://example.com\"), Some((false, \"example.com\", 80, \"\")));\n+}\n+\n+fn read_http_resp(socket: &mut TcpStream, max_resp: usize) -> Option<Vec<u8>> {\n+    let mut resp = Vec::new();\n+    let mut bytes_read = 0;\n+    macro_rules! read_socket { () => { {\n+        if unsafe { rusty_ShutdownRequested() } { return None; }\n+        match socket.read(&mut resp[bytes_read..]) {\n+            Ok(0) => return None,\n+            Ok(b) => b,\n+            Err(_) => return None,\n+        }\n+    } } }\n+\n+    let mut actual_len = 0;\n+    let mut ok_found = false;\n+    let mut chunked = false;\n+    // We expect the HTTP headers to fit in 8KB, and use resp as a temporary buffer for headers\n+    // until we know our real length.\n+    resp.extend_from_slice(&[0; 8192]);\n+    'read_headers: loop {\n+        if bytes_read >= 8192 { return None; }\n+        bytes_read += read_socket!();\n+        for line in resp[..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8) {\n+            let content_header = b\"Content-Length: \";\n+            if line.len() > content_header.len() && line[..content_header.len()].eq_ignore_ascii_case(content_header) {\n+                actual_len = match match std::str::from_utf8(&line[content_header.len()..]){\n+                    Ok(s) => s, Err(_) => return None,\n+                }.parse() {\n+                    Ok(len) => len, Err(_) => return None,\n+                };\n+            }\n+            let http_resp_1 = b\"HTTP/1.1 200 \";\n+            let http_resp_0 = b\"HTTP/1.0 200 \";\n+            if line.len() > http_resp_1.len() && (line[..http_resp_1.len()].eq_ignore_ascii_case(http_resp_1) ||\n+                                                  line[..http_resp_0.len()].eq_ignore_ascii_case(http_resp_0)) {\n+                ok_found = true;\n+            }\n+            let transfer_encoding = b\"Transfer-Encoding: \";\n+            if line.len() > transfer_encoding.len() && line[..transfer_encoding.len()].eq_ignore_ascii_case(transfer_encoding) {\n+                match &*String::from_utf8_lossy(&line[transfer_encoding.len()..]).to_ascii_lowercase() {\n+                    \"chunked\" => chunked = true,\n+                    _ => return None, // Unsupported\n+                }\n+            }\n+        }\n+        let mut end_headers_pos = None;\n+        for (idx, window) in resp[..bytes_read].windows(4).enumerate() {\n+            if window[0..2] == *b\"\\n\\n\" || window[0..2] == *b\"\\r\\r\" {\n+                end_headers_pos = Some(idx + 2);\n+                break;\n+            } else if window[0..4] == *b\"\\r\\n\\r\\n\" {\n+                end_headers_pos = Some(idx + 4);\n+                break;\n+            }\n+        }\n+        if let Some(pos) = end_headers_pos {\n+            resp = resp.split_off(pos);\n+            resp.resize(bytes_read - pos, 0);\n+            break 'read_headers;\n+        }\n+    }\n+    if !ok_found || (!chunked && (actual_len == 0 || actual_len > max_resp)) { return None; } // Sorry, not implemented\n+    bytes_read = resp.len();\n+    if !chunked {\n+        resp.resize(actual_len, 0);\n+        while bytes_read < actual_len {\n+            bytes_read += read_socket!();\n+        }\n+        Some(resp)\n+    } else {\n+        actual_len = 0;\n+        let mut chunk_remaining = 0;\n+        'read_bytes: loop {\n+            if chunk_remaining == 0 {\n+                let mut bytes_skipped = 0;\n+                let mut finished_read = false;\n+                {\n+                    let mut lineiter = resp[actual_len..bytes_read].split(|c| *c == '\\n' as u8 || *c == '\\r' as u8).peekable();\n+                    loop {\n+                        let line = match lineiter.next() { Some(line) => line, None => break };\n+                        if lineiter.peek().is_none() { // We haven't yet read to the end of this line\n+                            if line.len() > 8 {\n+                                // No reason to ever have a chunk length line longer than 4 chars\n+                                return None;\n+                            }\n+                            break;\n+                        }\n+                        bytes_skipped += line.len() + 1;\n+                        if line.len() == 0 { continue; } // Probably between the \\r and \\n\n+                        match usize::from_str_radix(&match std::str::from_utf8(line) {\n+                            Ok(s) => s, Err(_) => return None,\n+                        }, 16) {\n+                            Ok(chunklen) => {\n+                                if chunklen == 0 { finished_read = true; }\n+                                chunk_remaining = chunklen;\n+                                match lineiter.next() {\n+                                    Some(l) if l.is_empty() => {\n+                                        // Drop \\r after \\n\n+                                        bytes_skipped += 1;\n+                                        if actual_len + bytes_skipped > bytes_read {\n+                                            // Go back and get more bytes so we can skip trailing \\n\n+                                            chunk_remaining = 0;\n+                                        }\n+                                    },\n+                                    Some(_) => {},\n+                                    None => {\n+                                        // Go back and get more bytes so we can skip trailing \\n\n+                                        chunk_remaining = 0;\n+                                    },\n+                                }\n+                                break;\n+                            },\n+                            Err(_) => return None,\n+                        }\n+                    }\n+                }\n+                if chunk_remaining != 0 {\n+                    bytes_read -= bytes_skipped;\n+                    resp.drain(actual_len..actual_len + bytes_skipped);\n+                    if actual_len + chunk_remaining > max_resp { return None; }\n+                    let already_in_chunk = cmp::min(bytes_read - actual_len, chunk_remaining);\n+                    actual_len += already_in_chunk;\n+                    chunk_remaining -= already_in_chunk;\n+                    continue 'read_bytes;\n+                } else {\n+                    if finished_read {\n+                        // Note that we may leave some extra \\r\\ns to be read, but that's OK,\n+                        // we'll ignore then when parsing headers for the next request.\n+                        resp.resize(actual_len, 0);\n+                        return Some(resp);\n+                    } else {\n+                        // Need to read more bytes to figure out chunk length\n+                    }\n+                }\n+            }\n+            resp.resize(bytes_read + cmp::max(10, chunk_remaining), 0);\n+            let avail = read_socket!();\n+            bytes_read += avail;\n+            if chunk_remaining != 0 {\n+                let chunk_read = cmp::min(chunk_remaining, avail);\n+                chunk_remaining -= chunk_read;\n+                actual_len += chunk_read;\n+            }\n+        }\n+    }\n+}\n+\n+static THREAD_COUNT: AtomicUsize = AtomicUsize::new(0);\n+#[no_mangle]\n+pub extern \"C\" fn init_fetch_rest_blocks(uri: *const c_char) -> bool {\n+    let uri_str: String = match unsafe { CStr::from_ptr(uri) }.to_str() {\n+        Ok(r) => r.to_string(),\n+        Err(_) => return false,\n+    };\n+    // Sadly only non-SSL is supported for now\n+    if let Some((false, _, _, _)) = split_uri(&uri_str) { } else { return false; }\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        THREAD_COUNT.fetch_add(1, Ordering::AcqRel);\n+        let _ = catch_unwind(move || {\n+            await_ibd_complete_or_stalled();\n+            let (ssl, host, port, path) = split_uri(&uri_str).unwrap();\n+            let mut provider_state = BlockProviderState::new_with_current_best(BlockIndex::tip());\n+            'reconnect: while unsafe { !rusty_ShutdownRequested() } {\n+                std::thread::sleep(Duration::from_secs(1));\n+                if unsafe { rusty_ShutdownRequested() } { return; }\n+\n+                let mut stream;\n+                macro_rules! reconnect {\n+                    () => { {\n+                        stream = match TcpStream::connect_timeout(&match (host, port).to_socket_addrs() {\n+                            Ok(mut sockaddrs) => match sockaddrs.next() { Some(sockaddr) => sockaddr, None => continue 'reconnect },\n+                            Err(_) => continue 'reconnect,\n+                        }, Duration::from_secs(1)) {\n+                            Ok(stream) => stream,\n+                            Err(_) => continue 'reconnect,\n+                        };\n+                        stream.set_write_timeout(Some(Duration::from_secs(1))).expect(\"Host kernel is uselessly old?\");\n+                        stream.set_read_timeout(Some(Duration::from_secs(10))).expect(\"Host kernel is uselessly old?\");\n+                        if ssl {\n+                            unimplemented!();\n+                        }\n+                    } }\n+                }\n+                reconnect!();\n+\n+                'header_sync: while unsafe { !rusty_ShutdownRequested() } {\n+                    let req = format!(\"GET {}/headers/2000/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, provider_state.get_current_best().hash_hex(), host);\n+                    match stream.write(req.as_bytes()) {\n+                        Ok(len) if len == req.len() => {},\n+                        _ => continue 'reconnect,\n+                    }\n+                    let headers = match read_http_resp(&mut stream, 80*2000) {\n+                        Some(h) => h,\n+                        None => continue 'reconnect,\n+                    };\n+                    if headers.len() == 80 {\n+                        // We got exactly the header we requested, ie it is *also* the tip for the\n+                        // remote node, go on to block fetching!\n+                        break 'header_sync;\n+                    } else if headers.len() == 0 {\n+                        let genesis_tip = BlockIndex::genesis();\n+                        if genesis_tip == provider_state.get_current_best() { // Maybe they're on a different network entirely?\n+                            continue 'reconnect;\n+                        }\n+                        // We are on a fork, but there's nothing in REST (currently) that lets us walk\n+                        // back until we find the fork point, so we just start downloading again from\n+                        // genesis, 2000 headers at a time.\n+                        provider_state.set_current_best(genesis_tip);\n+                        continue 'header_sync;\n+                    }\n+                    match connect_headers_flat_bytes(&headers) {\n+                        Some(new_best) => {\n+                            if new_best == provider_state.get_current_best() {\n+                                // We tried to connect > 1 header, but didn't move forward, reconnect\n+                                // and try again\n+                                continue 'reconnect;\n+                            }\n+                            provider_state.set_current_best(new_best);\n+                            continue 'header_sync;\n+                        },\n+                        None => {\n+                            // We consider their response bogus, reconnect and try again\n+                            continue 'reconnect;\n+                        },\n+                    }\n+                }\n+\n+                // We think we're caught up with their header chain!\n+                // Wait a little bit to give the regular (more efficient) P2P logic a chance to\n+                // download blocks, then check if we should download anything.\n+                for _ in 0..30 {\n+                    std::thread::sleep(Duration::from_secs(1));\n+                    if unsafe { rusty_ShutdownRequested() } { return; }\n+                }\n+\n+                reconnect!();\n+\n+                'block_fetch: while unsafe { !rusty_ShutdownRequested() } {\n+                    match provider_state.get_next_block_to_download(true) {\n+                        Some(to_fetch) => {\n+                            let req = format!(\"GET {}/block/{}.bin HTTP/1.1\\nHost: {}\\nConnection: keep-alive\\n\\n\", path, to_fetch.hash_hex(), host);\n+                            match stream.write(req.as_bytes()) {\n+                                Ok(len) if len == req.len() => {},\n+                                _ => continue 'reconnect,\n+                            }\n+                            let block = match read_http_resp(&mut stream, 4 * 1000 * 1000) {\n+                                Some(b) => b,\n+                                None => continue 'reconnect,\n+                            };\n+                            connect_block(&block, Some(to_fetch));\n+                        },\n+                        None => continue 'reconnect,\n+                    }\n+                }\n+            }\n+        });\n+        THREAD_COUNT.fetch_sub(1, Ordering::AcqRel);\n+    });\n+    true\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn stop_fetch_rest_blocks() {\n+    while THREAD_COUNT.load(Ordering::Acquire) != 0 {\n+        std::thread::sleep(Duration::from_millis(10));\n+    }\n+}"
      },
      {
        "sha": "166eee2d52b0ca6b63a26366027a845ee8603a5d",
        "filename": "src/rusty/src/rust_bridge.h",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/4e691f96023b60d257ec3d5deb0b0b5f92170377/src/rusty/src/rust_bridge.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/4e691f96023b60d257ec3d5deb0b0b5f92170377/src/rusty/src/rust_bridge.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/rust_bridge.h?ref=4e691f96023b60d257ec3d5deb0b0b5f92170377",
        "patch": "@@ -17,6 +17,8 @@ extern \"C\" {\n \n bool init_fetch_dns_headers(const char *domain);\n bool stop_fetch_dns_headers();\n+bool init_fetch_rest_blocks(const char *uri);\n+bool stop_fetch_rest_blocks();\n \n } // extern \"C\"\n "
      }
    ]
  },
  {
    "sha": "06f1de0406fceebf9b0c21aee50bbde98344559b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowNmYxZGUwNDA2ZmNlZWJmOWIwYzIxYWVlNTBiYmRlOTgzNDQ1NTli",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-09-26T22:02:31Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "Walk pindexBestHeader back to ChainActive().Tip() if it is invalid\n\nInstead of keeping pindexBestHeader set to the best header we've\never seen, reset it back to our validated tip if we find an ancestor\nof it turns out to be invalid. While the name is now a bit confusing,\nthis matches much better with how it is used in practice, see below.\nFurther, this opens up more use-cases for it in the future, namely\naggressively searching for new peers in case we have discovered\n(possibly via some covert channel) headers which we do not know to be\ninvalid, but which we cannot find block data for.\n\nPlaces pindexBestHeader is used:\n\n * Various GUI displays of the best header and getblockchaininfo[\"headers\"],\n   I don't think changing this is bad, and if anything this is less confusing\n   in the presence of an invalid block.\n * IsCurrentForFeeEstimation(): If anything I think ensuring pindexBestHeader\n   isn't some crazy invalid chain is better than the alternative, even in the\n   case where you are rejecting the current chain due to hardware error (since\n   hopefully in that case you won't get any new blocks anyway).\n * ConnectBlock assumevalid checks: We use pindexBestHeader to check that the\n   block we're connecting leads to something with nMinimumChainWork (preventing\n   a user-set assumevalid from having bogus work) and that the block we're\n   connecting leads to pindexBestHeader (I'm not too worried about this one -\n   it's nice to \"disable\" assumevalid if we have a long invalid headers chain,\n   but I don't see it as a critical protection).\n * BlockRequestAllowed() uses pindexBestHeader as its target to ensure the\n   requested block is within a month of the \"current chain\". I don't think this\n   is a meaningful difference, if we're rejecting the current tip we're\n   trivially fingerprintable anyway, and if the chain really does have a bunch\n   of invalid crap near the tip, using the best not-invalid header is likely a\n   better criteria.\n * ProcessGetBlockData uses pindexBestHeader as the \"current chain\" definition\n   of whether a block request is \"historical\" for the purpose of bandwidth\n   limiting. Similarly, I don't see why this is a meaningful change.\n * We use pindexBestHeader for requesting missing headers on receipt of a\n   headers/compact block message or block inv as well as for initial getheaders.\n   I think this is definitely wrong, using the best not-invalid header for such\n   requests is much better.\n * We use pindexBestHeader to define the \"current chain\" for deciding when\n   we're close to done with initial headers sync. I don't think this is a\n   meaningful change.\n * We use pindexBestHeader to decide if initial headers sync has timed out. If\n   we're rejecting the chain due to hardware error this may result in\n   additional cases where we ban a peer, but this is already true, so I think\n   its fine.",
      "tree": {
        "sha": "476a272c192173238b2fb71b5df975ba0e4bba43",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/476a272c192173238b2fb71b5df975ba0e4bba43"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/06f1de0406fceebf9b0c21aee50bbde98344559b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06f1de0406fceebf9b0c21aee50bbde98344559b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/06f1de0406fceebf9b0c21aee50bbde98344559b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06f1de0406fceebf9b0c21aee50bbde98344559b/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "4e691f96023b60d257ec3d5deb0b0b5f92170377",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/4e691f96023b60d257ec3d5deb0b0b5f92170377",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/4e691f96023b60d257ec3d5deb0b0b5f92170377"
      }
    ],
    "stats": {
      "total": 6,
      "additions": 6,
      "deletions": 0
    },
    "files": [
      {
        "sha": "fcb727916e5c4a0223441b3e73754124194e4f57",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/06f1de0406fceebf9b0c21aee50bbde98344559b/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/06f1de0406fceebf9b0c21aee50bbde98344559b/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=06f1de0406fceebf9b0c21aee50bbde98344559b",
        "patch": "@@ -1467,10 +1467,14 @@ static void CheckForkWarningConditionsOnNewFork(CBlockIndex* pindexNewForkTip) E\n     CheckForkWarningConditions();\n }\n \n+// Called both upon regular invalid block discovery *and* InvalidateBlock\n void static InvalidChainFound(CBlockIndex* pindexNew) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     if (!pindexBestInvalid || pindexNew->nChainWork > pindexBestInvalid->nChainWork)\n         pindexBestInvalid = pindexNew;\n+    if (pindexBestHeader != nullptr && pindexBestHeader->GetAncestor(pindexNew->nHeight) == pindexNew) {\n+        pindexBestHeader = ::ChainActive().Tip();\n+    }\n \n     LogPrintf(\"%s: invalid block=%s  height=%d  log2_work=%.8g  date=%s\\n\", __func__,\n       pindexNew->GetBlockHash().ToString(), pindexNew->nHeight,\n@@ -1483,6 +1487,8 @@ void static InvalidChainFound(CBlockIndex* pindexNew) EXCLUSIVE_LOCKS_REQUIRED(c\n     CheckForkWarningConditions();\n }\n \n+// Same as InvalidChainFound, above, except not called directly from InvalidateBlock,\n+// which does its own setBlockIndexCandidates manageent.\n void CChainState::InvalidBlockFound(CBlockIndex *pindex, const BlockValidationState &state) {\n     if (state.GetResult() != BlockValidationResult::BLOCK_MUTATED) {\n         pindex->nStatus |= BLOCK_FAILED_VALID;"
      }
    ]
  },
  {
    "sha": "99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5OWVhZjFmZTA5YmIxMGE5YTEwN2I2M2I4MTRlYTdlOWUzNThiODBm",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-01T20:10:33Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "(XXX: Use subtree merge instead): bump to latest upstream libsecp",
      "tree": {
        "sha": "2253f4fa6f34e6044760e22847c4c79a9dc1e1b8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2253f4fa6f34e6044760e22847c4c79a9dc1e1b8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "06f1de0406fceebf9b0c21aee50bbde98344559b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/06f1de0406fceebf9b0c21aee50bbde98344559b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/06f1de0406fceebf9b0c21aee50bbde98344559b"
      }
    ],
    "stats": {
      "total": 1505,
      "additions": 1053,
      "deletions": 452
    },
    "files": [
      {
        "sha": "e11c5ced234ee8b6327b64906509f707538f1ebe",
        "filename": "src/secp256k1/.travis.yml",
        "status": "modified",
        "additions": 4,
        "deletions": 2,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/.travis.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/.travis.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/.travis.yml?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -11,7 +11,7 @@ cache:\n   - src/java/guava/\n env:\n   global:\n-    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no  JNI=no\n+    - FIELD=auto  BIGNUM=auto  SCALAR=auto  ENDOMORPHISM=no  STATICPRECOMPUTATION=yes  ECMULTGENPRECISION=auto  ASM=no  BUILD=check  EXTRAFLAGS=  HOST=  ECDH=no  RECOVERY=no  EXPERIMENTAL=no  JNI=no\n     - GUAVA_URL=https://search.maven.org/remotecontent?filepath=com/google/guava/guava/18.0/guava-18.0.jar GUAVA_JAR=src/java/guava/guava-18.0.jar\n   matrix:\n     - SCALAR=32bit    RECOVERY=yes\n@@ -30,6 +30,8 @@ env:\n     - EXTRAFLAGS=CPPFLAGS=-DDETERMINISTIC\n     - EXTRAFLAGS=CFLAGS=-O0\n     - BUILD=check-java JNI=yes ECDH=yes EXPERIMENTAL=yes\n+    - ECMULTGENPRECISION=2\n+    - ECMULTGENPRECISION=8\n matrix:\n   fast_finish: true\n   include:\n@@ -65,4 +67,4 @@ before_script: ./autogen.sh\n script:\n  - if [ -n \"$HOST\" ]; then export USE_HOST=\"--host=$HOST\"; fi\n  - if [ \"x$HOST\" = \"xi686-linux-gnu\" ]; then export CC=\"$CC -m32\"; fi\n- - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY --enable-jni=$JNI $EXTRAFLAGS $USE_HOST && make -j2 $BUILD\n+ - ./configure --enable-experimental=$EXPERIMENTAL --enable-endomorphism=$ENDOMORPHISM --with-field=$FIELD --with-bignum=$BIGNUM --with-scalar=$SCALAR --enable-ecmult-static-precomputation=$STATICPRECOMPUTATION --with-ecmult-gen-precision=$ECMULTGENPRECISION --enable-module-ecdh=$ECDH --enable-module-recovery=$RECOVERY --enable-jni=$JNI $EXTRAFLAGS $USE_HOST && make -j2 $BUILD"
      },
      {
        "sha": "f420944e8fcfa006b6893d74a8dd9c6d3ec04ce9",
        "filename": "src/secp256k1/Makefile.am",
        "status": "modified",
        "additions": 3,
        "deletions": 2,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/Makefile.am?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -8,6 +8,7 @@ else\n JNI_LIB =\n endif\n include_HEADERS = include/secp256k1.h\n+include_HEADERS += include/secp256k1_preallocated.h\n noinst_HEADERS =\n noinst_HEADERS += src/scalar.h\n noinst_HEADERS += src/scalar_4x64.h\n@@ -150,11 +151,11 @@ endif\n endif\n \n if USE_ECMULT_STATIC_PRECOMPUTATION\n-CPPFLAGS_FOR_BUILD +=-I$(top_srcdir)\n+CPPFLAGS_FOR_BUILD +=-I$(top_srcdir) -I$(builddir)/src\n \n gen_context_OBJECTS = gen_context.o\n gen_context_BIN = gen_context$(BUILD_EXEEXT)\n-gen_%.o: src/gen_%.c\n+gen_%.o: src/gen_%.c src/libsecp256k1-config.h\n \t$(CC_FOR_BUILD) $(CPPFLAGS_FOR_BUILD) $(CFLAGS_FOR_BUILD) -c $< -o $@\n \n $(gen_context_BIN): $(gen_context_OBJECTS)"
      },
      {
        "sha": "84c0487902d0df0a65225e48f773aeb8d8fb2ada",
        "filename": "src/secp256k1/README.md",
        "status": "modified",
        "additions": 15,
        "deletions": 3,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/README.md?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -23,6 +23,7 @@ Implementation details\n   * Extensive testing infrastructure.\n   * Structured to facilitate review and analysis.\n   * Intended to be portable to any system with a C89 compiler and uint64_t support.\n+  * No use of floating types, except in benchmarks.\n   * Expose only higher level interfaces to minimize the API surface and improve application security. (\"Be difficult to use insecurely.\")\n * Field operations\n   * Optimized implementation of arithmetic modulo the curve's field size (2^256 - 0x1000003D1).\n@@ -45,8 +46,10 @@ Implementation details\n   * Optionally (off by default) use secp256k1's efficiently-computable endomorphism to split the P multiplicand into 2 half-sized ones.\n * Point multiplication for signing\n   * Use a precomputed table of multiples of powers of 16 multiplied with the generator, so general multiplication becomes a series of additions.\n-  * Access the table with branch-free conditional moves so memory access is uniform.\n-  * No data-dependent branches\n+  * Intended to be completely free of timing sidechannels for secret-key operations (on reasonable hardware/toolchains)\n+    * Access the table with branch-free conditional moves so memory access is uniform.\n+    * No data-dependent branches\n+  * Optional runtime blinding which attempts to frustrate differential power analysis.\n   * The precomputed tables add and eventually subtract points for which no known scalar (private key) is known, preventing even an attacker with control over the private key used to control the data internally.\n \n Build steps\n@@ -57,5 +60,14 @@ libsecp256k1 is built using autotools:\n     $ ./autogen.sh\n     $ ./configure\n     $ make\n-    $ ./tests\n+    $ make check\n     $ sudo make install  # optional\n+\n+Exhaustive tests\n+-----------\n+\n+    $ ./exhaustive_tests\n+\n+With valgrind, you might need to increase the max stack size:\n+\n+    $ valgrind --max-stackframe=2500000 ./exhaustive_tests"
      },
      {
        "sha": "2a8db0a51c607c41cb70c48c624f8f5671e77d93",
        "filename": "src/secp256k1/configure.ac",
        "status": "modified",
        "additions": 99,
        "deletions": 32,
        "changes": 131,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/configure.ac?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -85,42 +85,42 @@ AC_COMPILE_IFELSE([AC_LANG_SOURCE([[char foo;]])],\n     ])\n \n AC_ARG_ENABLE(benchmark,\n-    AS_HELP_STRING([--enable-benchmark],[compile benchmark (default is yes)]),\n+    AS_HELP_STRING([--enable-benchmark],[compile benchmark [default=yes]]),\n     [use_benchmark=$enableval],\n     [use_benchmark=yes])\n \n AC_ARG_ENABLE(coverage,\n-    AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis]),\n+    AS_HELP_STRING([--enable-coverage],[enable compiler flags to support kcov coverage analysis [default=no]]),\n     [enable_coverage=$enableval],\n     [enable_coverage=no])\n \n AC_ARG_ENABLE(tests,\n-    AS_HELP_STRING([--enable-tests],[compile tests (default is yes)]),\n+    AS_HELP_STRING([--enable-tests],[compile tests [default=yes]]),\n     [use_tests=$enableval],\n     [use_tests=yes])\n \n AC_ARG_ENABLE(openssl_tests,\n-    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests, if OpenSSL is available (default is auto)]),\n+    AS_HELP_STRING([--enable-openssl-tests],[enable OpenSSL tests [default=auto]]),\n     [enable_openssl_tests=$enableval],\n     [enable_openssl_tests=auto])\n \n AC_ARG_ENABLE(experimental,\n-    AS_HELP_STRING([--enable-experimental],[allow experimental configure options (default is no)]),\n+    AS_HELP_STRING([--enable-experimental],[allow experimental configure options [default=no]]),\n     [use_experimental=$enableval],\n     [use_experimental=no])\n \n AC_ARG_ENABLE(exhaustive_tests,\n-    AS_HELP_STRING([--enable-exhaustive-tests],[compile exhaustive tests (default is yes)]),\n+    AS_HELP_STRING([--enable-exhaustive-tests],[compile exhaustive tests [default=yes]]),\n     [use_exhaustive_tests=$enableval],\n     [use_exhaustive_tests=yes])\n \n AC_ARG_ENABLE(endomorphism,\n-    AS_HELP_STRING([--enable-endomorphism],[enable endomorphism (default is no)]),\n+    AS_HELP_STRING([--enable-endomorphism],[enable endomorphism [default=no]]),\n     [use_endomorphism=$enableval],\n     [use_endomorphism=no])\n \n AC_ARG_ENABLE(ecmult_static_precomputation,\n-    AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing (default is yes)]),\n+    AS_HELP_STRING([--enable-ecmult-static-precomputation],[enable precomputed ecmult table for signing [default=auto]]),\n     [use_ecmult_static_precomputation=$enableval],\n     [use_ecmult_static_precomputation=auto])\n \n@@ -130,33 +130,55 @@ AC_ARG_ENABLE(module_ecdh,\n     [enable_module_ecdh=no])\n \n AC_ARG_ENABLE(module_recovery,\n-    AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module (default is no)]),\n+    AS_HELP_STRING([--enable-module-recovery],[enable ECDSA pubkey recovery module [default=no]]),\n     [enable_module_recovery=$enableval],\n     [enable_module_recovery=no])\n \n+AC_ARG_ENABLE(external_default_callbacks,\n+    AS_HELP_STRING([--enable-external-default-callbacks],[enable external default callback functions [default=no]]),\n+    [use_external_default_callbacks=$enableval],\n+    [use_external_default_callbacks=no])\n+\n AC_ARG_ENABLE(jni,\n-    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni (default is no)]),\n+    AS_HELP_STRING([--enable-jni],[enable libsecp256k1_jni [default=no]]),\n     [use_jni=$enableval],\n     [use_jni=no])\n \n AC_ARG_WITH([field], [AS_HELP_STRING([--with-field=64bit|32bit|auto],\n-[Specify Field Implementation. Default is auto])],[req_field=$withval], [req_field=auto])\n+[finite field implementation to use [default=auto]])],[req_field=$withval], [req_field=auto])\n \n AC_ARG_WITH([bignum], [AS_HELP_STRING([--with-bignum=gmp|no|auto],\n-[Specify Bignum Implementation. Default is auto])],[req_bignum=$withval], [req_bignum=auto])\n+[bignum implementation to use [default=auto]])],[req_bignum=$withval], [req_bignum=auto])\n \n AC_ARG_WITH([scalar], [AS_HELP_STRING([--with-scalar=64bit|32bit|auto],\n-[Specify scalar implementation. Default is auto])],[req_scalar=$withval], [req_scalar=auto])\n-\n-AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto]\n-[Specify assembly optimizations to use. Default is auto (experimental: arm)])],[req_asm=$withval], [req_asm=auto])\n+[scalar implementation to use [default=auto]])],[req_scalar=$withval], [req_scalar=auto])\n+\n+AC_ARG_WITH([asm], [AS_HELP_STRING([--with-asm=x86_64|arm|no|auto],\n+[assembly optimizations to use\u00a0(experimental: arm) [default=auto]])],[req_asm=$withval], [req_asm=auto])\n+\n+AC_ARG_WITH([ecmult-window], [AS_HELP_STRING([--with-ecmult-window=SIZE|auto],\n+[window size for ecmult precomputation for verification, specified as integer in range [2..24].]\n+[Larger values result in possibly better performance at the cost of an exponentially larger precomputed table.]\n+[The table will store 2^(SIZE-2) * 64 bytes of data but can be larger in memory due to platform-specific padding and alignment.]\n+[If the endomorphism optimization is enabled, two tables of this size are used instead of only one.]\n+[\"auto\" is a reasonable setting for desktop machines (currently 15). [default=auto]]\n+)],\n+[req_ecmult_window=$withval], [req_ecmult_window=auto])\n+\n+AC_ARG_WITH([ecmult-gen-precision], [AS_HELP_STRING([--with-ecmult-gen-precision=2|4|8|auto],\n+[Precision bits to tune the precomputed table size for signing.]\n+[The size of the table is 32kB for 2 bits, 64kB for 4 bits, 512kB for 8 bits of precision.]\n+[A larger table size usually results in possible faster signing.]\n+[\"auto\" is a reasonable setting for desktop machines (currently 4). [default=auto]]\n+)],\n+[req_ecmult_gen_precision=$withval], [req_ecmult_gen_precision=auto])\n \n AC_CHECK_TYPES([__int128])\n \n if test x\"$enable_coverage\" = x\"yes\"; then\n     AC_DEFINE(COVERAGE, 1, [Define this symbol to compile out all VERIFY code])\n     CFLAGS=\"$CFLAGS -O0 --coverage\"\n-    LDFLAGS=\"--coverage\"\n+    LDFLAGS=\"$LDFLAGS --coverage\"\n else\n     CFLAGS=\"$CFLAGS -O3\"\n fi\n@@ -387,6 +409,44 @@ case $set_scalar in\n   ;;\n esac\n \n+#set ecmult window size\n+if test x\"$req_ecmult_window\" = x\"auto\"; then\n+  set_ecmult_window=15\n+else\n+  set_ecmult_window=$req_ecmult_window\n+fi\n+\n+error_window_size=['window size for ecmult precomputation not an integer in range [2..24] or \"auto\"']\n+case $set_ecmult_window in\n+''|*[[!0-9]]*)\n+  # no valid integer\n+  AC_MSG_ERROR($error_window_size)\n+  ;;\n+*)\n+  if test \"$set_ecmult_window\" -lt 2 -o \"$set_ecmult_window\" -gt 24 ; then\n+    # not in range\n+    AC_MSG_ERROR($error_window_size)\n+  fi\n+  AC_DEFINE_UNQUOTED(ECMULT_WINDOW_SIZE, $set_ecmult_window, [Set window size for ecmult precomputation])\n+  ;;\n+esac\n+\n+#set ecmult gen precision\n+if test x\"$req_ecmult_gen_precision\" = x\"auto\"; then\n+  set_ecmult_gen_precision=4\n+else\n+  set_ecmult_gen_precision=$req_ecmult_gen_precision\n+fi\n+\n+case $set_ecmult_gen_precision in\n+2|4|8)\n+  AC_DEFINE_UNQUOTED(ECMULT_GEN_PREC_BITS, $set_ecmult_gen_precision, [Set ecmult gen precision bits])\n+  ;;\n+*)\n+  AC_MSG_ERROR(['ecmult gen precision not 2, 4, 8 or \"auto\"'])\n+  ;;\n+esac\n+\n if test x\"$use_tests\" = x\"yes\"; then\n   SECP_OPENSSL_CHECK\n   if test x\"$has_openssl_ec\" = x\"yes\"; then\n@@ -462,6 +522,10 @@ if test x\"$use_external_asm\" = x\"yes\"; then\n   AC_DEFINE(USE_EXTERNAL_ASM, 1, [Define this symbol if an external (non-inline) assembly implementation is used])\n fi\n \n+if test x\"$use_external_default_callbacks\" = x\"yes\"; then\n+  AC_DEFINE(USE_EXTERNAL_DEFAULT_CALLBACKS, 1, [Define this symbol if an external implementation of the default callbacks is used])\n+fi\n+\n if test x\"$enable_experimental\" = x\"yes\"; then\n   AC_MSG_NOTICE([******])\n   AC_MSG_NOTICE([WARNING: experimental build])\n@@ -504,21 +568,24 @@ AC_OUTPUT\n \n echo\n echo \"Build Options:\"\n-echo \"  with endomorphism   = $use_endomorphism\"\n-echo \"  with ecmult precomp = $set_precomp\"\n-echo \"  with jni            = $use_jni\"\n-echo \"  with benchmarks     = $use_benchmark\"\n-echo \"  with coverage       = $enable_coverage\"\n-echo \"  module ecdh         = $enable_module_ecdh\"\n-echo \"  module recovery     = $enable_module_recovery\"\n+echo \"  with endomorphism       = $use_endomorphism\"\n+echo \"  with ecmult precomp     = $set_precomp\"\n+echo \"  with external callbacks = $use_external_default_callbacks\"\n+echo \"  with jni                = $use_jni\"\n+echo \"  with benchmarks         = $use_benchmark\"\n+echo \"  with coverage           = $enable_coverage\"\n+echo \"  module ecdh             = $enable_module_ecdh\"\n+echo \"  module recovery         = $enable_module_recovery\"\n echo\n-echo \"  asm                 = $set_asm\"\n-echo \"  bignum              = $set_bignum\"\n-echo \"  field               = $set_field\"\n-echo \"  scalar              = $set_scalar\"\n+echo \"  asm                     = $set_asm\"\n+echo \"  bignum                  = $set_bignum\"\n+echo \"  field                   = $set_field\"\n+echo \"  scalar                  = $set_scalar\"\n+echo \"  ecmult window size      = $set_ecmult_window\"\n+echo \"  ecmult gen prec. bits   = $set_ecmult_gen_precision\"\n echo\n-echo \"  CC                  = $CC\"\n-echo \"  CFLAGS              = $CFLAGS\"\n-echo \"  CPPFLAGS            = $CPPFLAGS\"\n-echo \"  LDFLAGS             = $LDFLAGS\"\n+echo \"  CC                      = $CC\"\n+echo \"  CFLAGS                  = $CFLAGS\"\n+echo \"  CPPFLAGS                = $CPPFLAGS\"\n+echo \"  LDFLAGS                 = $LDFLAGS\"\n echo"
      },
      {
        "sha": "e177a0562dd2d2525a095c1dc3922b0ad5241ca5",
        "filename": "src/secp256k1/contrib/lax_der_parsing.c",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/contrib/lax_der_parsing.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/contrib/lax_der_parsing.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/contrib/lax_der_parsing.c?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -32,7 +32,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     lenbyte = input[pos++];\n     if (lenbyte & 0x80) {\n         lenbyte -= 0x80;\n-        if (pos + lenbyte > inputlen) {\n+        if (lenbyte > inputlen - pos) {\n             return 0;\n         }\n         pos += lenbyte;\n@@ -51,7 +51,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     lenbyte = input[pos++];\n     if (lenbyte & 0x80) {\n         lenbyte -= 0x80;\n-        if (pos + lenbyte > inputlen) {\n+        if (lenbyte > inputlen - pos) {\n             return 0;\n         }\n         while (lenbyte > 0 && input[pos] == 0) {\n@@ -89,7 +89,7 @@ int ecdsa_signature_parse_der_lax(const secp256k1_context* ctx, secp256k1_ecdsa_\n     lenbyte = input[pos++];\n     if (lenbyte & 0x80) {\n         lenbyte -= 0x80;\n-        if (pos + lenbyte > inputlen) {\n+        if (lenbyte > inputlen - pos) {\n             return 0;\n         }\n         while (lenbyte > 0 && input[pos] == 0) {"
      },
      {
        "sha": "36020e516467782fc7e5f80ca07169c2851c963d",
        "filename": "src/secp256k1/include/secp256k1.h",
        "status": "modified",
        "additions": 60,
        "deletions": 18,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/include/secp256k1.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/include/secp256k1.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -33,9 +33,10 @@ extern \"C\" {\n  *  verification).\n  *\n  *  A constructed context can safely be used from multiple threads\n- *  simultaneously, but API call that take a non-const pointer to a context\n+ *  simultaneously, but API calls that take a non-const pointer to a context\n  *  need exclusive access to it. In particular this is the case for\n- *  secp256k1_context_destroy and secp256k1_context_randomize.\n+ *  secp256k1_context_destroy, secp256k1_context_preallocated_destroy,\n+ *  and secp256k1_context_randomize.\n  *\n  *  Regarding randomization, either do it once at creation time (in which case\n  *  you do not need any locking for the other calls), or use a read-write lock.\n@@ -163,12 +164,13 @@ typedef int (*secp256k1_nonce_function)(\n #define SECP256K1_FLAGS_BIT_CONTEXT_SIGN (1 << 9)\n #define SECP256K1_FLAGS_BIT_COMPRESSION (1 << 8)\n \n-/** Flags to pass to secp256k1_context_create. */\n+/** Flags to pass to secp256k1_context_create, secp256k1_context_preallocated_size, and\n+ *  secp256k1_context_preallocated_create. */\n #define SECP256K1_CONTEXT_VERIFY (SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_VERIFY)\n #define SECP256K1_CONTEXT_SIGN (SECP256K1_FLAGS_TYPE_CONTEXT | SECP256K1_FLAGS_BIT_CONTEXT_SIGN)\n #define SECP256K1_CONTEXT_NONE (SECP256K1_FLAGS_TYPE_CONTEXT)\n \n-/** Flag to pass to secp256k1_ec_pubkey_serialize and secp256k1_ec_privkey_export. */\n+/** Flag to pass to secp256k1_ec_pubkey_serialize. */\n #define SECP256K1_EC_COMPRESSED (SECP256K1_FLAGS_TYPE_COMPRESSION | SECP256K1_FLAGS_BIT_COMPRESSION)\n #define SECP256K1_EC_UNCOMPRESSED (SECP256K1_FLAGS_TYPE_COMPRESSION)\n \n@@ -186,7 +188,11 @@ typedef int (*secp256k1_nonce_function)(\n  */\n SECP256K1_API extern const secp256k1_context *secp256k1_context_no_precomp;\n \n-/** Create a secp256k1 context object.\n+/** Create a secp256k1 context object (in dynamically allocated memory).\n+ *\n+ *  This function uses malloc to allocate memory. It is guaranteed that malloc is\n+ *  called at most once for every call of this function. If you need to avoid dynamic\n+ *  memory allocation entirely, see the functions in secp256k1_preallocated.h.\n  *\n  *  Returns: a newly created context object.\n  *  In:      flags: which parts of the context to initialize.\n@@ -197,7 +203,11 @@ SECP256K1_API secp256k1_context* secp256k1_context_create(\n     unsigned int flags\n ) SECP256K1_WARN_UNUSED_RESULT;\n \n-/** Copies a secp256k1 context object.\n+/** Copy a secp256k1 context object (into dynamically allocated memory).\n+ *\n+ *  This function uses malloc to allocate memory. It is guaranteed that malloc is\n+ *  called at most once for every call of this function. If you need to avoid dynamic\n+ *  memory allocation entirely, see the functions in secp256k1_preallocated.h.\n  *\n  *  Returns: a newly created context object.\n  *  Args:    ctx: an existing context to copy (cannot be NULL)\n@@ -206,10 +216,18 @@ SECP256K1_API secp256k1_context* secp256k1_context_clone(\n     const secp256k1_context* ctx\n ) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;\n \n-/** Destroy a secp256k1 context object.\n+/** Destroy a secp256k1 context object (created in dynamically allocated memory).\n  *\n  *  The context pointer may not be used afterwards.\n- *  Args:   ctx: an existing context to destroy (cannot be NULL)\n+ *\n+ *  The context to destroy must have been created using secp256k1_context_create\n+ *  or secp256k1_context_clone. If the context has instead been created using\n+ *  secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone, the\n+ *  behaviour is undefined. In that case, secp256k1_context_preallocated_destroy must\n+ *  be used instead.\n+ *\n+ *  Args:   ctx: an existing context to destroy, constructed using\n+ *               secp256k1_context_create or secp256k1_context_clone\n  */\n SECP256K1_API void secp256k1_context_destroy(\n     secp256k1_context* ctx\n@@ -229,11 +247,28 @@ SECP256K1_API void secp256k1_context_destroy(\n  *  to cause a crash, though its return value and output arguments are\n  *  undefined.\n  *\n+ *  When this function has not been called (or called with fn==NULL), then the\n+ *  default handler will be used.\u00a0The library provides a default handler which\n+ *  writes the message to stderr and calls abort. This default handler can be\n+ *  replaced at link time if the preprocessor macro\n+ *  USE_EXTERNAL_DEFAULT_CALLBACKS is defined, which is the case if the build\n+ *  has been configured with --enable-external-default-callbacks. Then the\n+ *  following two symbols must be provided to link against:\n+ *   - void secp256k1_default_illegal_callback_fn(const char* message, void* data);\n+ *   - void secp256k1_default_error_callback_fn(const char* message, void* data);\n+ *  The library can call these default handlers even before a proper callback data\n+ *  pointer could have been set using secp256k1_context_set_illegal_callback or\n+ *  secp256k1_context_set_error_callback, e.g., when the creation of a context\n+ *  fails. In this case, the corresponding default handler will be called with\n+ *  the data pointer argument set to NULL.\n+ *\n  *  Args: ctx:  an existing context object (cannot be NULL)\n  *  In:   fun:  a pointer to a function to call when an illegal argument is\n- *              passed to the API, taking a message and an opaque pointer\n- *              (NULL restores a default handler that calls abort).\n+ *              passed to the API, taking a message and an opaque pointer.\n+ *              (NULL restores the default handler.)\n  *        data: the opaque pointer to pass to fun above.\n+ *\n+ *  See also secp256k1_context_set_error_callback.\n  */\n SECP256K1_API void secp256k1_context_set_illegal_callback(\n     secp256k1_context* ctx,\n@@ -253,9 +288,12 @@ SECP256K1_API void secp256k1_context_set_illegal_callback(\n  *\n  *  Args: ctx:  an existing context object (cannot be NULL)\n  *  In:   fun:  a pointer to a function to call when an internal error occurs,\n- *              taking a message and an opaque pointer (NULL restores a default\n- *              handler that calls abort).\n+ *              taking a message and an opaque pointer (NULL restores the\n+ *              default handler, see secp256k1_context_set_illegal_callback\n+ *              for details).\n  *        data: the opaque pointer to pass to fun above.\n+ *\n+ *  See also secp256k1_context_set_illegal_callback.\n  */\n SECP256K1_API void secp256k1_context_set_error_callback(\n     secp256k1_context* ctx,\n@@ -267,21 +305,24 @@ SECP256K1_API void secp256k1_context_set_error_callback(\n  *\n  *  Returns: a newly created scratch space.\n  *  Args: ctx:  an existing context object (cannot be NULL)\n- *  In:   max_size: maximum amount of memory to allocate\n+ *  In:   size: amount of memory to be available as scratch space. Some extra\n+ *              (<100 bytes) will be allocated for extra accounting.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT secp256k1_scratch_space* secp256k1_scratch_space_create(\n     const secp256k1_context* ctx,\n-    size_t max_size\n+    size_t size\n ) SECP256K1_ARG_NONNULL(1);\n \n /** Destroy a secp256k1 scratch space.\n  *\n  *  The pointer may not be used afterwards.\n- *  Args:   scratch: space to destroy\n+ *  Args:       ctx: a secp256k1 context object.\n+ *          scratch: space to destroy\n  */\n SECP256K1_API void secp256k1_scratch_space_destroy(\n+    const secp256k1_context* ctx,\n     secp256k1_scratch_space* scratch\n-);\n+) SECP256K1_ARG_NONNULL(1);\n \n /** Parse a variable-length public key into the pubkey object.\n  *\n@@ -605,7 +646,7 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_privkey_tweak_mul(\n  *          uniformly random 32-byte arrays, or equal to zero. 1 otherwise.\n  * Args:    ctx:    pointer to a context object initialized for validation\n  *                 (cannot be NULL).\n- * In/Out:  pubkey: pointer to a public key obkect.\n+ * In/Out:  pubkey: pointer to a public key object.\n  * In:      tweak:  pointer to a 32-byte tweak.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n@@ -636,7 +677,8 @@ SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_ec_pubkey_tweak_mul(\n  * contexts not initialized for signing; then it will have no effect and return 1.\n  *\n  * You should call this after secp256k1_context_create or\n- * secp256k1_context_clone, and may call this repeatedly afterwards.\n+ * secp256k1_context_clone (and secp256k1_context_preallocated_create or\n+ * secp256k1_context_clone, resp.), and you may call this repeatedly afterwards.\n  */\n SECP256K1_API SECP256K1_WARN_UNUSED_RESULT int secp256k1_context_randomize(\n     secp256k1_context* ctx,"
      },
      {
        "sha": "a9ae15d5ae8d80264c5dd1e44b17ccf81a2456a4",
        "filename": "src/secp256k1/include/secp256k1_preallocated.h",
        "status": "added",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/include/secp256k1_preallocated.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/include/secp256k1_preallocated.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/include/secp256k1_preallocated.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -0,0 +1,128 @@\n+#ifndef SECP256K1_PREALLOCATED_H\n+#define SECP256K1_PREALLOCATED_H\n+\n+#include \"secp256k1.h\"\n+\n+#ifdef __cplusplus\n+extern \"C\" {\n+#endif\n+\n+/* The module provided by this header file is intended for settings in which it\n+ * is not possible or desirable to rely on dynamic memory allocation. It provides\n+ * functions for creating, cloning, and destroying secp256k1 context objects in a\n+ * contiguous fixed-size block of memory provided by the caller.\n+ *\n+ * Context objects created by functions in this module can be used like contexts\n+ * objects created by functions in secp256k1.h, i.e., they can be passed to any\n+ * API function that expects a context object (see secp256k1.h for details). The\n+ * only exception is that context objects created by functions in this module\n+ * must be destroyed using secp256k1_context_preallocated_destroy (in this\n+ * module) instead of secp256k1_context_destroy (in secp256k1.h).\n+ *\n+ * It is guaranteed that functions in this module will not call malloc or its\n+ * friends realloc, calloc, and free.\n+ */\n+\n+/** Determine the memory size of a secp256k1 context object to be created in\n+ *  caller-provided memory.\n+ *\n+ *  The purpose of this function is to determine how much memory must be provided\n+ *  to secp256k1_context_preallocated_create.\n+ *\n+ *  Returns: the required size of the caller-provided memory block\n+ *  In:      flags:    which parts of the context to initialize.\n+ */\n+SECP256K1_API size_t secp256k1_context_preallocated_size(\n+    unsigned int flags\n+) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Create a secp256k1 context object in caller-provided memory.\n+ *\n+ *  The caller must provide a pointer to a rewritable contiguous block of memory\n+ *  of size at least secp256k1_context_preallocated_size(flags) bytes, suitably\n+ *  aligned to hold an object of any type.\n+ *\n+ *  The block of memory is exclusively owned by the created context object during\n+ *  the lifetime of this context object, which begins with the call to this\n+ *  function and ends when a call to secp256k1_context_preallocated_destroy\n+ *  (which destroys the context object again) returns. During the lifetime of the\n+ *  context object, the caller is obligated not to access this block of memory,\n+ *  i.e., the caller may not read or write the memory, e.g., by copying the memory\n+ *  contents to a different location or trying to create a second context object\n+ *  in the memory. In simpler words, the prealloc pointer (or any pointer derived\n+ *  from it) should not be used during the lifetime of the context object.\n+ *\n+ *  Returns: a newly created context object.\n+ *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n+ *                     size at least secp256k1_context_preallocated_size(flags)\n+ *                     bytes, as detailed above (cannot be NULL)\n+ *           flags:    which parts of the context to initialize.\n+ *\n+ *  See also secp256k1_context_randomize (in secp256k1.h)\n+ *  and secp256k1_context_preallocated_destroy.\n+ */\n+SECP256K1_API secp256k1_context* secp256k1_context_preallocated_create(\n+    void* prealloc,\n+    unsigned int flags\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Determine the memory size of a secp256k1 context object to be copied into\n+ *  caller-provided memory.\n+ *\n+ *  Returns: the required size of the caller-provided memory block.\n+ *  In:      ctx: an existing context to copy (cannot be NULL)\n+ */\n+SECP256K1_API size_t secp256k1_context_preallocated_clone_size(\n+    const secp256k1_context* ctx\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Copy a secp256k1 context object into caller-provided memory.\n+ *\n+ *  The caller must provide a pointer to a rewritable contiguous block of memory\n+ *  of size at least secp256k1_context_preallocated_size(flags) bytes, suitably\n+ *  aligned to hold an object of any type.\n+ *\n+ *  The block of memory is exclusively owned by the created context object during\n+ *  the lifetime of this context object, see the description of\n+ *  secp256k1_context_preallocated_create for details.\n+ *\n+ *  Returns: a newly created context object.\n+ *  Args:    ctx:      an existing context to copy (cannot be NULL)\n+ *  In:      prealloc: a pointer to a rewritable contiguous block of memory of\n+ *                     size at least secp256k1_context_preallocated_size(flags)\n+ *                     bytes, as detailed above (cannot be NULL)\n+ */\n+SECP256K1_API secp256k1_context* secp256k1_context_preallocated_clone(\n+    const secp256k1_context* ctx,\n+    void* prealloc\n+) SECP256K1_ARG_NONNULL(1) SECP256K1_ARG_NONNULL(2) SECP256K1_WARN_UNUSED_RESULT;\n+\n+/** Destroy a secp256k1 context object that has been created in\n+ *  caller-provided memory.\n+ *\n+ *  The context pointer may not be used afterwards.\n+ *\n+ *  The context to destroy must have been created using\n+ *  secp256k1_context_preallocated_create or secp256k1_context_preallocated_clone.\n+ *  If the context has instead been created using secp256k1_context_create or\n+ *  secp256k1_context_clone, the behaviour is undefined. In that case,\n+ *  secp256k1_context_destroy must be used instead.\n+ *\n+ *  If required, it is the responsibility of the caller to deallocate the block\n+ *  of memory properly after this function returns, e.g., by calling free on the\n+ *  preallocated pointer given to secp256k1_context_preallocated_create or\n+ *  secp256k1_context_preallocated_clone.\n+ *\n+ *  Args:   ctx: an existing context to destroy, constructed using\n+ *               secp256k1_context_preallocated_create or\n+ *               secp256k1_context_preallocated_clone (cannot be NULL)\n+ */\n+SECP256K1_API void secp256k1_context_preallocated_destroy(\n+    secp256k1_context* ctx\n+);\n+\n+#ifdef __cplusplus\n+}\n+#endif\n+\n+#endif /* SECP256K1_PREALLOCATED_H */"
      },
      {
        "sha": "9a5bd06721778da61e34ca16dcc60a10b0d20a36",
        "filename": "src/secp256k1/src/asm/field_10x26_arm.s",
        "status": "modified",
        "additions": 0,
        "deletions": 6,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/asm/field_10x26_arm.s",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/asm/field_10x26_arm.s",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/asm/field_10x26_arm.s?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -16,15 +16,9 @@ Note:\n */\n \n \t.syntax unified\n-\t.arch armv7-a\n \t@ eabi attributes - see readelf -A\n-\t.eabi_attribute 8, 1  @ Tag_ARM_ISA_use = yes\n-\t.eabi_attribute 9, 0  @ Tag_Thumb_ISA_use = no\n-\t.eabi_attribute 10, 0 @ Tag_FP_arch = none\n \t.eabi_attribute 24, 1 @ Tag_ABI_align_needed = 8-byte\n \t.eabi_attribute 25, 1 @ Tag_ABI_align_preserved = 8-byte, except leaf SP\n-\t.eabi_attribute 30, 2 @ Tag_ABI_optimization_goals = Aggressive Speed\n-\t.eabi_attribute 34, 1 @ Tag_CPU_unaligned_access = v6\n \t.text\n \n \t@ Field constants"
      },
      {
        "sha": "e9be39d4ca4d4eaacceef15c605a2a3fd8bb2813",
        "filename": "src/secp256k1/src/basic-config.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/basic-config.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/basic-config.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/basic-config.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -10,7 +10,10 @@\n #ifdef USE_BASIC_CONFIG\n \n #undef USE_ASM_X86_64\n+#undef USE_ECMULT_STATIC_PRECOMPUTATION\n #undef USE_ENDOMORPHISM\n+#undef USE_EXTERNAL_ASM\n+#undef USE_EXTERNAL_DEFAULT_CALLBACKS\n #undef USE_FIELD_10X26\n #undef USE_FIELD_5X52\n #undef USE_FIELD_INV_BUILTIN\n@@ -21,12 +24,14 @@\n #undef USE_SCALAR_8X32\n #undef USE_SCALAR_INV_BUILTIN\n #undef USE_SCALAR_INV_NUM\n+#undef ECMULT_WINDOW_SIZE\n \n #define USE_NUM_NONE 1\n #define USE_FIELD_INV_BUILTIN 1\n #define USE_SCALAR_INV_BUILTIN 1\n #define USE_FIELD_10X26 1\n #define USE_SCALAR_8X32 1\n+#define ECMULT_WINDOW_SIZE 15\n \n #endif /* USE_BASIC_CONFIG */\n "
      },
      {
        "sha": "7b5d185dce606b4d60a4d115a34cbbf7fd9432ee",
        "filename": "src/secp256k1/src/bench_ecmult.c",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/bench_ecmult.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/bench_ecmult.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_ecmult.c?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -64,7 +64,7 @@ static void bench_ecmult(void* arg) {\n     size_t iter;\n \n     for (iter = 0; iter < iters; ++iter) {\n-        data->ecmult_multi(&data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_callback, arg, count - includes_g);\n+        data->ecmult_multi(&data->ctx->error_callback, &data->ctx->ecmult_ctx, data->scratch, &data->output[iter], data->includes_g ? &data->scalars[data->offset1] : NULL, bench_callback, arg, count - includes_g);\n         data->offset1 = (data->offset1 + count) % POINTS;\n         data->offset2 = (data->offset2 + count - 1) % POINTS;\n     }\n@@ -154,7 +154,7 @@ int main(int argc, char **argv) {\n         } else if(have_flag(argc, argv, \"simple\")) {\n             printf(\"Using simple algorithm:\\n\");\n             data.ecmult_multi = secp256k1_ecmult_multi_var;\n-            secp256k1_scratch_space_destroy(data.scratch);\n+            secp256k1_scratch_space_destroy(data.ctx, data.scratch);\n             data.scratch = NULL;\n         } else {\n             fprintf(stderr, \"%s: unrecognized argument '%s'.\\n\", argv[0], argv[1]);\n@@ -193,10 +193,10 @@ int main(int argc, char **argv) {\n             run_test(&data, i << p, 1);\n         }\n     }\n-    secp256k1_context_destroy(data.ctx);\n     if (data.scratch != NULL) {\n-        secp256k1_scratch_space_destroy(data.scratch);\n+        secp256k1_scratch_space_destroy(data.ctx, data.scratch);\n     }\n+    secp256k1_context_destroy(data.ctx);\n     free(data.scalars);\n     free(data.pubkeys);\n     free(data.seckeys);"
      },
      {
        "sha": "a8f4e9e12f6d1b9a62789dcd3d5e764efa430b0d",
        "filename": "src/secp256k1/src/bench_internal.c",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/bench_internal.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/bench_internal.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/bench_internal.c?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -253,7 +253,7 @@ void bench_wnaf_const(void* arg) {\n     bench_inv *data = (bench_inv*)arg;\n \n     for (i = 0; i < 20000; i++) {\n-        secp256k1_wnaf_const(data->wnaf, data->scalar_x, WINDOW_A, 256);\n+        secp256k1_wnaf_const(data->wnaf, &data->scalar_x, WINDOW_A, 256);\n         secp256k1_scalar_add(&data->scalar_x, &data->scalar_x, &data->scalar_y);\n     }\n }"
      },
      {
        "sha": "eb099c87dc83fe0898814a8de5e4edaeeeb8f448",
        "filename": "src/secp256k1/src/ecdsa_impl.h",
        "status": "modified",
        "additions": 38,
        "deletions": 32,
        "changes": 70,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/ecdsa_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/ecdsa_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecdsa_impl.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -46,68 +46,73 @@ static const secp256k1_fe secp256k1_ecdsa_const_p_minus_order = SECP256K1_FE_CON\n     0, 0, 0, 1, 0x45512319UL, 0x50B75FC4UL, 0x402DA172UL, 0x2FC9BAEEUL\n );\n \n-static int secp256k1_der_read_len(const unsigned char **sigp, const unsigned char *sigend) {\n-    int lenleft, b1;\n-    size_t ret = 0;\n+static int secp256k1_der_read_len(size_t *len, const unsigned char **sigp, const unsigned char *sigend) {\n+    size_t lenleft;\n+    unsigned char b1;\n+    VERIFY_CHECK(len != NULL);\n+    *len = 0;\n     if (*sigp >= sigend) {\n-        return -1;\n+        return 0;\n     }\n     b1 = *((*sigp)++);\n     if (b1 == 0xFF) {\n         /* X.690-0207 8.1.3.5.c the value 0xFF shall not be used. */\n-        return -1;\n+        return 0;\n     }\n     if ((b1 & 0x80) == 0) {\n         /* X.690-0207 8.1.3.4 short form length octets */\n-        return b1;\n+        *len = b1;\n+        return 1;\n     }\n     if (b1 == 0x80) {\n         /* Indefinite length is not allowed in DER. */\n-        return -1;\n+        return 0;\n     }\n     /* X.690-207 8.1.3.5 long form length octets */\n-    lenleft = b1 & 0x7F;\n-    if (lenleft > sigend - *sigp) {\n-        return -1;\n+    lenleft = b1 & 0x7F; /* lenleft is at least 1 */\n+    if (lenleft > (size_t)(sigend - *sigp)) {\n+        return 0;\n     }\n     if (**sigp == 0) {\n         /* Not the shortest possible length encoding. */\n-        return -1;\n+        return 0;\n     }\n-    if ((size_t)lenleft > sizeof(size_t)) {\n+    if (lenleft > sizeof(size_t)) {\n         /* The resulting length would exceed the range of a size_t, so\n          * certainly longer than the passed array size.\n          */\n-        return -1;\n+        return 0;\n     }\n     while (lenleft > 0) {\n-        ret = (ret << 8) | **sigp;\n-        if (ret + lenleft > (size_t)(sigend - *sigp)) {\n-            /* Result exceeds the length of the passed array. */\n-            return -1;\n-        }\n+        *len = (*len << 8) | **sigp;\n         (*sigp)++;\n         lenleft--;\n     }\n-    if (ret < 128) {\n+    if (*len > (size_t)(sigend - *sigp)) {\n+        /* Result exceeds the length of the passed array. */\n+        return 0;\n+    }\n+    if (*len < 128) {\n         /* Not the shortest possible length encoding. */\n-        return -1;\n+        return 0;\n     }\n-    return ret;\n+    return 1;\n }\n \n static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char **sig, const unsigned char *sigend) {\n     int overflow = 0;\n     unsigned char ra[32] = {0};\n-    int rlen;\n+    size_t rlen;\n \n     if (*sig == sigend || **sig != 0x02) {\n         /* Not a primitive integer (X.690-0207 8.3.1). */\n         return 0;\n     }\n     (*sig)++;\n-    rlen = secp256k1_der_read_len(sig, sigend);\n-    if (rlen <= 0 || (*sig) + rlen > sigend) {\n+    if (secp256k1_der_read_len(&rlen, sig, sigend) == 0) {\n+        return 0;\n+    }\n+    if (rlen == 0 || *sig + rlen > sigend) {\n         /* Exceeds bounds or not at least length 1 (X.690-0207 8.3.1).  */\n         return 0;\n     }\n@@ -123,8 +128,11 @@ static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char\n         /* Negative. */\n         overflow = 1;\n     }\n-    while (rlen > 0 && **sig == 0) {\n-        /* Skip leading zero bytes */\n+    /* There is at most one leading zero byte:\n+     * if there were two leading zero bytes, we would have failed and returned 0\n+     * because of excessive 0x00 padding already. */\n+    if (rlen > 0 && **sig == 0) {\n+        /* Skip leading zero byte */\n         rlen--;\n         (*sig)++;\n     }\n@@ -144,18 +152,16 @@ static int secp256k1_der_parse_integer(secp256k1_scalar *r, const unsigned char\n \n static int secp256k1_ecdsa_sig_parse(secp256k1_scalar *rr, secp256k1_scalar *rs, const unsigned char *sig, size_t size) {\n     const unsigned char *sigend = sig + size;\n-    int rlen;\n+    size_t rlen;\n     if (sig == sigend || *(sig++) != 0x30) {\n         /* The encoding doesn't start with a constructed sequence (X.690-0207 8.9.1). */\n         return 0;\n     }\n-    rlen = secp256k1_der_read_len(&sig, sigend);\n-    if (rlen < 0 || sig + rlen > sigend) {\n-        /* Tuple exceeds bounds */\n+    if (secp256k1_der_read_len(&rlen, &sig, sigend) == 0) {\n         return 0;\n     }\n-    if (sig + rlen != sigend) {\n-        /* Garbage after tuple. */\n+    if (rlen != (size_t)(sigend - sig)) {\n+        /* Tuple exceeds bounds or garage after tuple. */\n         return 0;\n     }\n "
      },
      {
        "sha": "c9b198239d88974078443897b099851f94a6d395",
        "filename": "src/secp256k1/src/ecmult.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/ecmult.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/ecmult.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -20,10 +20,10 @@ typedef struct {\n #endif\n } secp256k1_ecmult_context;\n \n+static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx);\n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const secp256k1_callback *cb);\n-static void secp256k1_ecmult_context_clone(secp256k1_ecmult_context *dst,\n-                                           const secp256k1_ecmult_context *src, const secp256k1_callback *cb);\n+static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc);\n+static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src);\n static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx);\n static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx);\n \n@@ -43,6 +43,6 @@ typedef int (secp256k1_ecmult_multi_callback)(secp256k1_scalar *sc, secp256k1_ge\n  *          0 if there is not enough scratch space for a single point or\n  *          callback returns 0\n  */\n-static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n);\n \n #endif /* SECP256K1_ECMULT_H */"
      },
      {
        "sha": "03bb33257d532f8a7345bd4b8f7b090ddb346a92",
        "filename": "src/secp256k1/src/ecmult_const.h",
        "status": "modified",
        "additions": 5,
        "deletions": 2,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/ecmult_const.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/ecmult_const.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -10,8 +10,11 @@\n #include \"scalar.h\"\n #include \"group.h\"\n \n-/* Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n- * one because we internally sometimes add 2 to the number during the WNAF conversion. */\n+/**\n+ * Multiply: R = q*A (in constant-time)\n+ * Here `bits` should be set to the maximum bitlength of the _absolute value_ of `q`, plus\n+ * one because we internally sometimes add 2 to the number during the WNAF conversion.\n+ */\n static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, const secp256k1_scalar *q, int bits);\n \n #endif /* SECP256K1_ECMULT_CONST_H */"
      },
      {
        "sha": "aaa576ada4cc22bb2bb3a784d0c2514e8aeccead",
        "filename": "src/secp256k1/src/ecmult_const_impl.h",
        "status": "modified",
        "additions": 17,
        "deletions": 13,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/ecmult_const_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/ecmult_const_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_const_impl.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -48,7 +48,7 @@\n  *\n  *  Numbers reference steps of `Algorithm SPA-resistant Width-w NAF with Odd Scalar` on pp. 335\n  */\n-static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size) {\n+static int secp256k1_wnaf_const(int *wnaf, const secp256k1_scalar *scalar, int w, int size) {\n     int global_sign;\n     int skew = 0;\n     int word = 0;\n@@ -59,8 +59,12 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n \n     int flip;\n     int bit;\n-    secp256k1_scalar neg_s;\n+    secp256k1_scalar s;\n     int not_neg_one;\n+\n+    VERIFY_CHECK(w > 0);\n+    VERIFY_CHECK(size > 0);\n+\n     /* Note that we cannot handle even numbers by negating them to be odd, as is\n      * done in other implementations, since if our scalars were specified to have\n      * width < 256 for performance reasons, their negations would have width 256\n@@ -75,12 +79,13 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n      * {1, 2} we want to add to the scalar when ensuring that it's odd. Further\n      * complicating things, -1 interacts badly with `secp256k1_scalar_cadd_bit` and\n      * we need to special-case it in this logic. */\n-    flip = secp256k1_scalar_is_high(&s);\n+    flip = secp256k1_scalar_is_high(scalar);\n     /* We add 1 to even numbers, 2 to odd ones, noting that negation flips parity */\n-    bit = flip ^ !secp256k1_scalar_is_even(&s);\n+    bit = flip ^ !secp256k1_scalar_is_even(scalar);\n     /* We check for negative one, since adding 2 to it will cause an overflow */\n-    secp256k1_scalar_negate(&neg_s, &s);\n-    not_neg_one = !secp256k1_scalar_is_one(&neg_s);\n+    secp256k1_scalar_negate(&s, scalar);\n+    not_neg_one = !secp256k1_scalar_is_one(&s);\n+    s = *scalar;\n     secp256k1_scalar_cadd_bit(&s, bit, not_neg_one);\n     /* If we had negative one, flip == 1, s.d[0] == 0, bit == 1, so caller expects\n      * that we added two to it and flipped it. In fact for -1 these operations are\n@@ -93,7 +98,7 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n \n     /* 4 */\n     u_last = secp256k1_scalar_shr_int(&s, w);\n-    while (word * w < size) {\n+    do {\n         int sign;\n         int even;\n \n@@ -109,7 +114,7 @@ static int secp256k1_wnaf_const(int *wnaf, secp256k1_scalar s, int w, int size)\n         wnaf[word++] = u_last * global_sign;\n \n         u_last = u;\n-    }\n+    } while (word * w < size);\n     wnaf[word] = u * global_sign;\n \n     VERIFY_CHECK(secp256k1_scalar_is_zero(&s));\n@@ -132,21 +137,20 @@ static void secp256k1_ecmult_const(secp256k1_gej *r, const secp256k1_ge *a, cons\n     int wnaf_1[1 + WNAF_SIZE(WINDOW_A - 1)];\n \n     int i;\n-    secp256k1_scalar sc = *scalar;\n \n     /* build wnaf representation for q. */\n     int rsize = size;\n #ifdef USE_ENDOMORPHISM\n     if (size > 128) {\n         rsize = 128;\n         /* split q into q_1 and q_lam (where q = q_1 + q_lam*lambda, and q_1 and q_lam are ~128 bit) */\n-        secp256k1_scalar_split_lambda(&q_1, &q_lam, &sc);\n-        skew_1   = secp256k1_wnaf_const(wnaf_1,   q_1,   WINDOW_A - 1, 128);\n-        skew_lam = secp256k1_wnaf_const(wnaf_lam, q_lam, WINDOW_A - 1, 128);\n+        secp256k1_scalar_split_lambda(&q_1, &q_lam, scalar);\n+        skew_1   = secp256k1_wnaf_const(wnaf_1,   &q_1,   WINDOW_A - 1, 128);\n+        skew_lam = secp256k1_wnaf_const(wnaf_lam, &q_lam, WINDOW_A - 1, 128);\n     } else\n #endif\n     {\n-        skew_1   = secp256k1_wnaf_const(wnaf_1, sc, WINDOW_A - 1, size);\n+        skew_1   = secp256k1_wnaf_const(wnaf_1, scalar, WINDOW_A - 1, size);\n #ifdef USE_ENDOMORPHISM\n         skew_lam = 0;\n #endif"
      },
      {
        "sha": "30815e5aa10e7866a99ca4fe6a3b85795c3a2bd0",
        "filename": "src/secp256k1/src/ecmult_gen.h",
        "status": "modified",
        "additions": 18,
        "deletions": 11,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/ecmult_gen.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/ecmult_gen.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -10,28 +10,35 @@\n #include \"scalar.h\"\n #include \"group.h\"\n \n+#if ECMULT_GEN_PREC_BITS != 2 && ECMULT_GEN_PREC_BITS != 4 && ECMULT_GEN_PREC_BITS != 8\n+#  error \"Set ECMULT_GEN_PREC_BITS to 2, 4 or 8.\"\n+#endif\n+#define ECMULT_GEN_PREC_B ECMULT_GEN_PREC_BITS\n+#define ECMULT_GEN_PREC_G (1 << ECMULT_GEN_PREC_B)\n+#define ECMULT_GEN_PREC_N (256 / ECMULT_GEN_PREC_B)\n+\n typedef struct {\n     /* For accelerating the computation of a*G:\n      * To harden against timing attacks, use the following mechanism:\n-     * * Break up the multiplicand into groups of 4 bits, called n_0, n_1, n_2, ..., n_63.\n-     * * Compute sum(n_i * 16^i * G + U_i, i=0..63), where:\n-     *   * U_i = U * 2^i (for i=0..62)\n-     *   * U_i = U * (1-2^63) (for i=63)\n-     *   where U is a point with no known corresponding scalar. Note that sum(U_i, i=0..63) = 0.\n-     * For each i, and each of the 16 possible values of n_i, (n_i * 16^i * G + U_i) is\n-     * precomputed (call it prec(i, n_i)). The formula now becomes sum(prec(i, n_i), i=0..63).\n+     * * Break up the multiplicand into groups of PREC_B bits, called n_0, n_1, n_2, ..., n_(PREC_N-1).\n+     * * Compute sum(n_i * (PREC_G)^i * G + U_i, i=0 ... PREC_N-1), where:\n+     *   * U_i = U * 2^i, for i=0 ... PREC_N-2\n+     *   * U_i = U * (1-2^(PREC_N-1)), for i=PREC_N-1\n+     *   where U is a point with no known corresponding scalar. Note that sum(U_i, i=0 ... PREC_N-1) = 0.\n+     * For each i, and each of the PREC_G possible values of n_i, (n_i * (PREC_G)^i * G + U_i) is\n+     * precomputed (call it prec(i, n_i)). The formula now becomes sum(prec(i, n_i), i=0 ... PREC_N-1).\n      * None of the resulting prec group elements have a known scalar, and neither do any of\n      * the intermediate sums while computing a*G.\n      */\n-    secp256k1_ge_storage (*prec)[64][16]; /* prec[j][i] = 16^j * i * G + U_i */\n+    secp256k1_ge_storage (*prec)[ECMULT_GEN_PREC_N][ECMULT_GEN_PREC_G]; /* prec[j][i] = (PREC_G)^j * i * G + U_i */\n     secp256k1_scalar blind;\n     secp256k1_gej initial;\n } secp256k1_ecmult_gen_context;\n \n+static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context* ctx);\n-static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context* ctx, const secp256k1_callback* cb);\n-static void secp256k1_ecmult_gen_context_clone(secp256k1_ecmult_gen_context *dst,\n-                                               const secp256k1_ecmult_gen_context* src, const secp256k1_callback* cb);\n+static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context* ctx, void **prealloc);\n+static void secp256k1_ecmult_gen_context_finalize_memcpy(secp256k1_ecmult_gen_context *dst, const secp256k1_ecmult_gen_context* src);\n static void secp256k1_ecmult_gen_context_clear(secp256k1_ecmult_gen_context* ctx);\n static int secp256k1_ecmult_gen_context_is_built(const secp256k1_ecmult_gen_context* ctx);\n "
      },
      {
        "sha": "a1b96393939e2b99a9b0bd88c1024e3cbaa27459",
        "filename": "src/secp256k1/src/ecmult_gen_impl.h",
        "status": "modified",
        "additions": 40,
        "deletions": 39,
        "changes": 79,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/ecmult_gen_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/ecmult_gen_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_gen_impl.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -7,30 +7,40 @@\n #ifndef SECP256K1_ECMULT_GEN_IMPL_H\n #define SECP256K1_ECMULT_GEN_IMPL_H\n \n+#include \"util.h\"\n #include \"scalar.h\"\n #include \"group.h\"\n #include \"ecmult_gen.h\"\n #include \"hash_impl.h\"\n #ifdef USE_ECMULT_STATIC_PRECOMPUTATION\n #include \"ecmult_static_context.h\"\n #endif\n+\n+#ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n+    static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE = ROUND_TO_ALIGN(sizeof(*((secp256k1_ecmult_gen_context*) NULL)->prec));\n+#else\n+    static const size_t SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE = 0;\n+#endif\n+\n static void secp256k1_ecmult_gen_context_init(secp256k1_ecmult_gen_context *ctx) {\n     ctx->prec = NULL;\n }\n \n-static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx, const secp256k1_callback* cb) {\n+static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx, void **prealloc) {\n #ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-    secp256k1_ge prec[1024];\n+    secp256k1_ge prec[ECMULT_GEN_PREC_N * ECMULT_GEN_PREC_G];\n     secp256k1_gej gj;\n     secp256k1_gej nums_gej;\n     int i, j;\n+    size_t const prealloc_size = SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n+    void* const base = *prealloc;\n #endif\n \n     if (ctx->prec != NULL) {\n         return;\n     }\n #ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-    ctx->prec = (secp256k1_ge_storage (*)[64][16])checked_malloc(cb, sizeof(*ctx->prec));\n+    ctx->prec = (secp256k1_ge_storage (*)[ECMULT_GEN_PREC_N][ECMULT_GEN_PREC_G])manual_alloc(prealloc, prealloc_size, base, prealloc_size);\n \n     /* get the generator */\n     secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n@@ -54,39 +64,39 @@ static void secp256k1_ecmult_gen_context_build(secp256k1_ecmult_gen_context *ctx\n \n     /* compute prec. */\n     {\n-        secp256k1_gej precj[1024]; /* Jacobian versions of prec. */\n+        secp256k1_gej precj[ECMULT_GEN_PREC_N * ECMULT_GEN_PREC_G]; /* Jacobian versions of prec. */\n         secp256k1_gej gbase;\n         secp256k1_gej numsbase;\n-        gbase = gj; /* 16^j * G */\n+        gbase = gj; /* PREC_G^j * G */\n         numsbase = nums_gej; /* 2^j * nums. */\n-        for (j = 0; j < 64; j++) {\n-            /* Set precj[j*16 .. j*16+15] to (numsbase, numsbase + gbase, ..., numsbase + 15*gbase). */\n-            precj[j*16] = numsbase;\n-            for (i = 1; i < 16; i++) {\n-                secp256k1_gej_add_var(&precj[j*16 + i], &precj[j*16 + i - 1], &gbase, NULL);\n+        for (j = 0; j < ECMULT_GEN_PREC_N; j++) {\n+            /* Set precj[j*PREC_G .. j*PREC_G+(PREC_G-1)] to (numsbase, numsbase + gbase, ..., numsbase + (PREC_G-1)*gbase). */\n+            precj[j*ECMULT_GEN_PREC_G] = numsbase;\n+            for (i = 1; i < ECMULT_GEN_PREC_G; i++) {\n+                secp256k1_gej_add_var(&precj[j*ECMULT_GEN_PREC_G + i], &precj[j*ECMULT_GEN_PREC_G + i - 1], &gbase, NULL);\n             }\n-            /* Multiply gbase by 16. */\n-            for (i = 0; i < 4; i++) {\n+            /* Multiply gbase by PREC_G. */\n+            for (i = 0; i < ECMULT_GEN_PREC_B; i++) {\n                 secp256k1_gej_double_var(&gbase, &gbase, NULL);\n             }\n             /* Multiply numbase by 2. */\n             secp256k1_gej_double_var(&numsbase, &numsbase, NULL);\n-            if (j == 62) {\n+            if (j == ECMULT_GEN_PREC_N - 2) {\n                 /* In the last iteration, numsbase is (1 - 2^j) * nums instead. */\n                 secp256k1_gej_neg(&numsbase, &numsbase);\n                 secp256k1_gej_add_var(&numsbase, &numsbase, &nums_gej, NULL);\n             }\n         }\n-        secp256k1_ge_set_all_gej_var(prec, precj, 1024);\n+        secp256k1_ge_set_all_gej_var(prec, precj, ECMULT_GEN_PREC_N * ECMULT_GEN_PREC_G);\n     }\n-    for (j = 0; j < 64; j++) {\n-        for (i = 0; i < 16; i++) {\n-            secp256k1_ge_to_storage(&(*ctx->prec)[j][i], &prec[j*16 + i]);\n+    for (j = 0; j < ECMULT_GEN_PREC_N; j++) {\n+        for (i = 0; i < ECMULT_GEN_PREC_G; i++) {\n+            secp256k1_ge_to_storage(&(*ctx->prec)[j][i], &prec[j*ECMULT_GEN_PREC_G + i]);\n         }\n     }\n #else\n-    (void)cb;\n-    ctx->prec = (secp256k1_ge_storage (*)[64][16])secp256k1_ecmult_static_context;\n+    (void)prealloc;\n+    ctx->prec = (secp256k1_ge_storage (*)[ECMULT_GEN_PREC_N][ECMULT_GEN_PREC_G])secp256k1_ecmult_static_context;\n #endif\n     secp256k1_ecmult_gen_blind(ctx, NULL);\n }\n@@ -95,27 +105,18 @@ static int secp256k1_ecmult_gen_context_is_built(const secp256k1_ecmult_gen_cont\n     return ctx->prec != NULL;\n }\n \n-static void secp256k1_ecmult_gen_context_clone(secp256k1_ecmult_gen_context *dst,\n-                                               const secp256k1_ecmult_gen_context *src, const secp256k1_callback* cb) {\n-    if (src->prec == NULL) {\n-        dst->prec = NULL;\n-    } else {\n+static void secp256k1_ecmult_gen_context_finalize_memcpy(secp256k1_ecmult_gen_context *dst, const secp256k1_ecmult_gen_context *src) {\n #ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-        dst->prec = (secp256k1_ge_storage (*)[64][16])checked_malloc(cb, sizeof(*dst->prec));\n-        memcpy(dst->prec, src->prec, sizeof(*dst->prec));\n+    if (src->prec != NULL) {\n+        /* We cast to void* first to suppress a -Wcast-align warning. */\n+        dst->prec = (secp256k1_ge_storage (*)[ECMULT_GEN_PREC_N][ECMULT_GEN_PREC_G])(void*)((unsigned char*)dst + ((unsigned char*)src->prec - (unsigned char*)src));\n+    }\n #else\n-        (void)cb;\n-        dst->prec = src->prec;\n+    (void)dst, (void)src;\n #endif\n-        dst->initial = src->initial;\n-        dst->blind = src->blind;\n-    }\n }\n \n static void secp256k1_ecmult_gen_context_clear(secp256k1_ecmult_gen_context *ctx) {\n-#ifndef USE_ECMULT_STATIC_PRECOMPUTATION\n-    free(ctx->prec);\n-#endif\n     secp256k1_scalar_clear(&ctx->blind);\n     secp256k1_gej_clear(&ctx->initial);\n     ctx->prec = NULL;\n@@ -132,9 +133,9 @@ static void secp256k1_ecmult_gen(const secp256k1_ecmult_gen_context *ctx, secp25\n     /* Blind scalar/point multiplication by computing (n-b)G + bG instead of nG. */\n     secp256k1_scalar_add(&gnb, gn, &ctx->blind);\n     add.infinity = 0;\n-    for (j = 0; j < 64; j++) {\n-        bits = secp256k1_scalar_get_bits(&gnb, j * 4, 4);\n-        for (i = 0; i < 16; i++) {\n+    for (j = 0; j < ECMULT_GEN_PREC_N; j++) {\n+        bits = secp256k1_scalar_get_bits(&gnb, j * ECMULT_GEN_PREC_B, ECMULT_GEN_PREC_B);\n+        for (i = 0; i < ECMULT_GEN_PREC_G; i++) {\n             /** This uses a conditional move to avoid any secret data in array indexes.\n              *   _Any_ use of secret indexes has been demonstrated to result in timing\n              *   sidechannels, even when the cache-line access patterns are uniform.\n@@ -186,7 +187,7 @@ static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context *ctx, const\n     do {\n         secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n         retry = !secp256k1_fe_set_b32(&s, nonce32);\n-        retry |= secp256k1_fe_is_zero(&s);\n+        retry = retry || secp256k1_fe_is_zero(&s);\n     } while (retry); /* This branch true is cryptographically unreachable. Requires sha256_hmac output > Fp. */\n     /* Randomize the projection to defend against multiplier sidechannels. */\n     secp256k1_gej_rescale(&ctx->initial, &s);\n@@ -195,7 +196,7 @@ static void secp256k1_ecmult_gen_blind(secp256k1_ecmult_gen_context *ctx, const\n         secp256k1_rfc6979_hmac_sha256_generate(&rng, nonce32, 32);\n         secp256k1_scalar_set_b32(&b, nonce32, &retry);\n         /* A blinding value of 0 works, but would undermine the projection hardening. */\n-        retry |= secp256k1_scalar_is_zero(&b);\n+        retry = retry || secp256k1_scalar_is_zero(&b);\n     } while (retry); /* This branch true is cryptographically unreachable. Requires sha256_hmac output > order. */\n     secp256k1_rfc6979_hmac_sha256_finalize(&rng);\n     memset(nonce32, 0, 32);"
      },
      {
        "sha": "f03fa9469d73ba56be9486eee509fd95fac9d359",
        "filename": "src/secp256k1/src/ecmult_impl.h",
        "status": "modified",
        "additions": 109,
        "deletions": 74,
        "changes": 183,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/ecmult_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/ecmult_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/ecmult_impl.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -10,6 +10,7 @@\n #include <string.h>\n #include <stdint.h>\n \n+#include \"util.h\"\n #include \"group.h\"\n #include \"scalar.h\"\n #include \"ecmult.h\"\n@@ -30,16 +31,32 @@\n #  endif\n #else\n /* optimal for 128-bit and 256-bit exponents. */\n-#define WINDOW_A 5\n-/** larger numbers may result in slightly better performance, at the cost of\n-    exponentially larger precomputed tables. */\n-#ifdef USE_ENDOMORPHISM\n-/** Two tables for window size 15: 1.375 MiB. */\n-#define WINDOW_G 15\n-#else\n-/** One table for window size 16: 1.375 MiB. */\n-#define WINDOW_G 16\n+#  define WINDOW_A 5\n+/** Larger values for ECMULT_WINDOW_SIZE result in possibly better\n+ *  performance at the cost of an exponentially larger precomputed\n+ *  table. The exact table size is\n+ *      (1 << (WINDOW_G - 2)) * sizeof(secp256k1_ge_storage)  bytes,\n+ *  where sizeof(secp256k1_ge_storage) is typically 64 bytes but can\n+ *  be larger due to platform-specific padding and alignment.\n+ *  If the endomorphism optimization is enabled (USE_ENDOMORMPHSIM)\n+ *  two tables of this size are used instead of only one.\n+ */\n+#  define WINDOW_G ECMULT_WINDOW_SIZE\n #endif\n+\n+/* Noone will ever need more than a window size of 24. The code might\n+ * be correct for larger values of ECMULT_WINDOW_SIZE but this is not\n+ * not tested.\n+ *\n+ * The following limitations are known, and there are probably more:\n+ * If WINDOW_G > 27 and size_t has 32 bits, then the code is incorrect\n+ * because the size of the memory object that we allocate (in bytes)\n+ * will not fit in a size_t.\n+ * If WINDOW_G > 31 and int has 32 bits, then the code is incorrect\n+ * because certain expressions will overflow.\n+ */\n+#if ECMULT_WINDOW_SIZE < 2 || ECMULT_WINDOW_SIZE > 24\n+#  error Set ECMULT_WINDOW_SIZE to an integer in range [2..24].\n #endif\n \n #ifdef USE_ENDOMORPHISM\n@@ -121,7 +138,7 @@ static void secp256k1_ecmult_odd_multiples_table(int n, secp256k1_gej *prej, sec\n  *    It only operates on tables sized for WINDOW_A wnaf multiples.\n  *  - secp256k1_ecmult_odd_multiples_table_storage_var, which converts its\n  *    resulting point set to actually affine points, and stores those in pre.\n- *    It operates on tables of any size, but uses heap-allocated temporaries.\n+ *    It operates on tables of any size.\n  *\n  *  To compute a*P + b*G, we compute a table for P using the first function,\n  *  and for G using the second (which requires an inverse, but it only needs to\n@@ -294,15 +311,24 @@ static void secp256k1_ecmult_odd_multiples_table_storage_var(const int n, secp25\n     } \\\n } while(0)\n \n+static const size_t SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE =\n+    ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n+#ifdef USE_ENDOMORPHISM\n+    + ROUND_TO_ALIGN(sizeof((*((secp256k1_ecmult_context*) NULL)->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G))\n+#endif\n+    ;\n+\n static void secp256k1_ecmult_context_init(secp256k1_ecmult_context *ctx) {\n     ctx->pre_g = NULL;\n #ifdef USE_ENDOMORPHISM\n     ctx->pre_g_128 = NULL;\n #endif\n }\n \n-static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const secp256k1_callback *cb) {\n+static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, void **prealloc) {\n     secp256k1_gej gj;\n+    void* const base = *prealloc;\n+    size_t const prealloc_size = SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n \n     if (ctx->pre_g != NULL) {\n         return;\n@@ -311,7 +337,12 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n     /* get the generator */\n     secp256k1_gej_set_ge(&gj, &secp256k1_ge_const_g);\n \n-    ctx->pre_g = (secp256k1_ge_storage (*)[])checked_malloc(cb, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n+    {\n+        size_t size = sizeof((*ctx->pre_g)[0]) * ((size_t)ECMULT_TABLE_SIZE(WINDOW_G));\n+        /* check for overflow */\n+        VERIFY_CHECK(size / sizeof((*ctx->pre_g)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n+        ctx->pre_g = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n+    }\n \n     /* precompute the tables with odd multiples */\n     secp256k1_ecmult_odd_multiples_table_storage_var(ECMULT_TABLE_SIZE(WINDOW_G), *ctx->pre_g, &gj);\n@@ -321,7 +352,10 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n         secp256k1_gej g_128j;\n         int i;\n \n-        ctx->pre_g_128 = (secp256k1_ge_storage (*)[])checked_malloc(cb, sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G));\n+        size_t size = sizeof((*ctx->pre_g_128)[0]) * ((size_t) ECMULT_TABLE_SIZE(WINDOW_G));\n+        /* check for overflow */\n+        VERIFY_CHECK(size / sizeof((*ctx->pre_g_128)[0]) == ((size_t)ECMULT_TABLE_SIZE(WINDOW_G)));\n+        ctx->pre_g_128 = (secp256k1_ge_storage (*)[])manual_alloc(prealloc, sizeof((*ctx->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G), base, prealloc_size);\n \n         /* calculate 2^128*generator */\n         g_128j = gj;\n@@ -333,22 +367,14 @@ static void secp256k1_ecmult_context_build(secp256k1_ecmult_context *ctx, const\n #endif\n }\n \n-static void secp256k1_ecmult_context_clone(secp256k1_ecmult_context *dst,\n-                                           const secp256k1_ecmult_context *src, const secp256k1_callback *cb) {\n-    if (src->pre_g == NULL) {\n-        dst->pre_g = NULL;\n-    } else {\n-        size_t size = sizeof((*dst->pre_g)[0]) * ECMULT_TABLE_SIZE(WINDOW_G);\n-        dst->pre_g = (secp256k1_ge_storage (*)[])checked_malloc(cb, size);\n-        memcpy(dst->pre_g, src->pre_g, size);\n+static void secp256k1_ecmult_context_finalize_memcpy(secp256k1_ecmult_context *dst, const secp256k1_ecmult_context *src) {\n+    if (src->pre_g != NULL) {\n+        /* We cast to void* first to suppress a -Wcast-align warning. */\n+        dst->pre_g = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g) - (unsigned char*)src));\n     }\n #ifdef USE_ENDOMORPHISM\n-    if (src->pre_g_128 == NULL) {\n-        dst->pre_g_128 = NULL;\n-    } else {\n-        size_t size = sizeof((*dst->pre_g_128)[0]) * ECMULT_TABLE_SIZE(WINDOW_G);\n-        dst->pre_g_128 = (secp256k1_ge_storage (*)[])checked_malloc(cb, size);\n-        memcpy(dst->pre_g_128, src->pre_g_128, size);\n+    if (src->pre_g_128 != NULL) {\n+        dst->pre_g_128 = (secp256k1_ge_storage (*)[])(void*)((unsigned char*)dst + ((unsigned char*)(src->pre_g_128) - (unsigned char*)src));\n     }\n #endif\n }\n@@ -358,10 +384,6 @@ static int secp256k1_ecmult_context_is_built(const secp256k1_ecmult_context *ctx\n }\n \n static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n-    free(ctx->pre_g);\n-#ifdef USE_ENDOMORPHISM\n-    free(ctx->pre_g_128);\n-#endif\n     secp256k1_ecmult_context_init(ctx);\n }\n \n@@ -373,7 +395,7 @@ static void secp256k1_ecmult_context_clear(secp256k1_ecmult_context *ctx) {\n  *    than the number of bits in the (absolute value) of the input.\n  */\n static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a, int w) {\n-    secp256k1_scalar s = *a;\n+    secp256k1_scalar s;\n     int last_set_bit = -1;\n     int bit = 0;\n     int sign = 1;\n@@ -386,6 +408,7 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n \n     memset(wnaf, 0, len * sizeof(wnaf[0]));\n \n+    s = *a;\n     if (secp256k1_scalar_get_bits(&s, 255, 1)) {\n         secp256k1_scalar_negate(&s, &s);\n         sign = -1;\n@@ -418,7 +441,7 @@ static int secp256k1_ecmult_wnaf(int *wnaf, int len, const secp256k1_scalar *a,\n     CHECK(carry == 0);\n     while (bit < 256) {\n         CHECK(secp256k1_scalar_get_bits(&s, bit++, 1) == 0);\n-    } \n+    }\n #endif\n     return last_set_bit + 1;\n }\n@@ -626,52 +649,55 @@ static size_t secp256k1_strauss_scratch_size(size_t n_points) {\n     return n_points*point_size;\n }\n \n-static int secp256k1_ecmult_strauss_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_strauss_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n     secp256k1_gej* points;\n     secp256k1_scalar* scalars;\n     struct secp256k1_strauss_state state;\n     size_t i;\n+    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n \n     secp256k1_gej_set_infinity(r);\n     if (inp_g_sc == NULL && n_points == 0) {\n         return 1;\n     }\n \n-    if (!secp256k1_scratch_allocate_frame(scratch, secp256k1_strauss_scratch_size(n_points), STRAUSS_SCRATCH_OBJECTS)) {\n-        return 0;\n-    }\n-    points = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_gej));\n-    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(scratch, n_points * sizeof(secp256k1_scalar));\n-    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n-    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n+    points = (secp256k1_gej*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(secp256k1_gej));\n+    scalars = (secp256k1_scalar*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(secp256k1_scalar));\n+    state.prej = (secp256k1_gej*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_gej));\n+    state.zr = (secp256k1_fe*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_fe));\n #ifdef USE_ENDOMORPHISM\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * 2 * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n     state.pre_a_lam = state.pre_a + n_points * ECMULT_TABLE_SIZE(WINDOW_A);\n #else\n-    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n+    state.pre_a = (secp256k1_ge*)secp256k1_scratch_alloc(error_callback, scratch, n_points * ECMULT_TABLE_SIZE(WINDOW_A) * sizeof(secp256k1_ge));\n #endif\n-    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+    state.ps = (struct secp256k1_strauss_point_state*)secp256k1_scratch_alloc(error_callback, scratch, n_points * sizeof(struct secp256k1_strauss_point_state));\n+\n+    if (points == NULL || scalars == NULL || state.prej == NULL || state.zr == NULL || state.pre_a == NULL) {\n+        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n+        return 0;\n+    }\n \n     for (i = 0; i < n_points; i++) {\n         secp256k1_ge point;\n         if (!cb(&scalars[i], &point, i+cb_offset, cbdata)) {\n-            secp256k1_scratch_deallocate_frame(scratch);\n+            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n             return 0;\n         }\n         secp256k1_gej_set_ge(&points[i], &point);\n     }\n     secp256k1_ecmult_strauss_wnaf(ctx, &state, r, n_points, points, scalars, inp_g_sc);\n-    secp256k1_scratch_deallocate_frame(scratch);\n+    secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n     return 1;\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_strauss_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_strauss_batch(actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_strauss_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_strauss_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n-static size_t secp256k1_strauss_max_points(secp256k1_scratch *scratch) {\n-    return secp256k1_scratch_max_allocation(scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n+static size_t secp256k1_strauss_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n+    return secp256k1_scratch_max_allocation(error_callback, scratch, STRAUSS_SCRATCH_OBJECTS) / secp256k1_strauss_scratch_size(1);\n }\n \n /** Convert a number to WNAF notation.\n@@ -963,7 +989,8 @@ static size_t secp256k1_pippenger_scratch_size(size_t n_points, int bucket_windo\n     return (sizeof(secp256k1_gej) << bucket_window) + sizeof(struct secp256k1_pippenger_state) + entries * entry_size;\n }\n \n-static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+static int secp256k1_ecmult_pippenger_batch(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n_points, size_t cb_offset) {\n+    const size_t scratch_checkpoint = secp256k1_scratch_checkpoint(error_callback, scratch);\n     /* Use 2(n+1) with the endomorphism, n+1 without, when calculating batch\n      * sizes. The reason for +1 is that we add the G scalar to the list of\n      * other scalars. */\n@@ -988,15 +1015,21 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx,\n     }\n \n     bucket_window = secp256k1_pippenger_bucket_window(n_points);\n-    if (!secp256k1_scratch_allocate_frame(scratch, secp256k1_pippenger_scratch_size(n_points, bucket_window), PIPPENGER_SCRATCH_OBJECTS)) {\n+    points = (secp256k1_ge *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*points));\n+    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*scalars));\n+    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(error_callback, scratch, sizeof(*state_space));\n+    if (points == NULL || scalars == NULL || state_space == NULL) {\n+        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n+        return 0;\n+    }\n+\n+    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(error_callback, scratch, entries * sizeof(*state_space->ps));\n+    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(error_callback, scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n+    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(error_callback, scratch, (1<<bucket_window) * sizeof(*buckets));\n+    if (state_space->ps == NULL || state_space->wnaf_na == NULL || buckets == NULL) {\n+        secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n         return 0;\n     }\n-    points = (secp256k1_ge *) secp256k1_scratch_alloc(scratch, entries * sizeof(*points));\n-    scalars = (secp256k1_scalar *) secp256k1_scratch_alloc(scratch, entries * sizeof(*scalars));\n-    state_space = (struct secp256k1_pippenger_state *) secp256k1_scratch_alloc(scratch, sizeof(*state_space));\n-    state_space->ps = (struct secp256k1_pippenger_point_state *) secp256k1_scratch_alloc(scratch, entries * sizeof(*state_space->ps));\n-    state_space->wnaf_na = (int *) secp256k1_scratch_alloc(scratch, entries*(WNAF_SIZE(bucket_window+1)) * sizeof(int));\n-    buckets = (secp256k1_gej *) secp256k1_scratch_alloc(scratch, sizeof(*buckets) << bucket_window);\n \n     if (inp_g_sc != NULL) {\n         scalars[0] = *inp_g_sc;\n@@ -1010,7 +1043,7 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx,\n \n     while (point_idx < n_points) {\n         if (!cb(&scalars[idx], &points[idx], point_idx + cb_offset, cbdata)) {\n-            secp256k1_scratch_deallocate_frame(scratch);\n+            secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n             return 0;\n         }\n         idx++;\n@@ -1034,22 +1067,22 @@ static int secp256k1_ecmult_pippenger_batch(const secp256k1_ecmult_context *ctx,\n     for(i = 0; i < 1<<bucket_window; i++) {\n         secp256k1_gej_clear(&buckets[i]);\n     }\n-    secp256k1_scratch_deallocate_frame(scratch);\n+    secp256k1_scratch_apply_checkpoint(error_callback, scratch, scratch_checkpoint);\n     return 1;\n }\n \n /* Wrapper for secp256k1_ecmult_multi_func interface */\n-static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n-    return secp256k1_ecmult_pippenger_batch(actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n+static int secp256k1_ecmult_pippenger_batch_single(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *actx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+    return secp256k1_ecmult_pippenger_batch(error_callback, actx, scratch, r, inp_g_sc, cb, cbdata, n, 0);\n }\n \n /**\n  * Returns the maximum number of points in addition to G that can be used with\n  * a given scratch space. The function ensures that fewer points may also be\n  * used.\n  */\n-static size_t secp256k1_pippenger_max_points(secp256k1_scratch *scratch) {\n-    size_t max_alloc = secp256k1_scratch_max_allocation(scratch, PIPPENGER_SCRATCH_OBJECTS);\n+static size_t secp256k1_pippenger_max_points(const secp256k1_callback* error_callback, secp256k1_scratch *scratch) {\n+    size_t max_alloc = secp256k1_scratch_max_allocation(error_callback, scratch, PIPPENGER_SCRATCH_OBJECTS);\n     int bucket_window;\n     size_t res = 0;\n \n@@ -1131,11 +1164,11 @@ static int secp256k1_ecmult_multi_batch_size_helper(size_t *n_batches, size_t *n\n     return 1;\n }\n \n-typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n-static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n+typedef int (*secp256k1_ecmult_multi_func)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t);\n+static int secp256k1_ecmult_multi_var(const secp256k1_callback* error_callback, const secp256k1_ecmult_context *ctx, secp256k1_scratch *scratch, secp256k1_gej *r, const secp256k1_scalar *inp_g_sc, secp256k1_ecmult_multi_callback cb, void *cbdata, size_t n) {\n     size_t i;\n \n-    int (*f)(const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n+    int (*f)(const secp256k1_callback* error_callback, const secp256k1_ecmult_context*, secp256k1_scratch*, secp256k1_gej*, const secp256k1_scalar*, secp256k1_ecmult_multi_callback cb, void*, size_t, size_t);\n     size_t n_batches;\n     size_t n_batch_points;\n \n@@ -1152,24 +1185,26 @@ static int secp256k1_ecmult_multi_var(const secp256k1_ecmult_context *ctx, secp2\n         return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n     }\n \n-    /* Compute the batch sizes for pippenger given a scratch space. If it's greater than a threshold\n-     * use pippenger. Otherwise use strauss */\n-    if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(scratch), n)) {\n-        return 0;\n+    /* Compute the batch sizes for Pippenger's algorithm given a scratch space. If it's greater than\n+     * a threshold use Pippenger's algorithm. Otherwise use Strauss' algorithm.\n+     * As a first step check if there's enough space for Pippenger's algo (which requires less space\n+     * than Strauss' algo) and if not, use the simple algorithm. */\n+    if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_pippenger_max_points(error_callback, scratch), n)) {\n+        return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n     }\n     if (n_batch_points >= ECMULT_PIPPENGER_THRESHOLD) {\n         f = secp256k1_ecmult_pippenger_batch;\n     } else {\n-        if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(scratch), n)) {\n-            return 0;\n+        if (!secp256k1_ecmult_multi_batch_size_helper(&n_batches, &n_batch_points, secp256k1_strauss_max_points(error_callback, scratch), n)) {\n+            return secp256k1_ecmult_multi_simple_var(ctx, r, inp_g_sc, cb, cbdata, n);\n         }\n         f = secp256k1_ecmult_strauss_batch;\n     }\n     for(i = 0; i < n_batches; i++) {\n         size_t nbp = n < n_batch_points ? n : n_batch_points;\n         size_t offset = n_batch_points*i;\n         secp256k1_gej tmp;\n-        if (!f(ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n+        if (!f(error_callback, ctx, scratch, &tmp, i == 0 ? inp_g_sc : NULL, cb, cbdata, nbp, offset)) {\n             return 0;\n         }\n         secp256k1_gej_add_var(r, r, &tmp, NULL);"
      },
      {
        "sha": "539f574bfd0c690be1e939748bf86249305c981e",
        "filename": "src/secp256k1/src/gen_context.c",
        "status": "modified",
        "additions": 23,
        "deletions": 10,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/gen_context.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/gen_context.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/gen_context.c?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -4,10 +4,16 @@\n  * file COPYING or http://www.opensource.org/licenses/mit-license.php.*\n  **********************************************************************/\n \n+// Autotools creates libsecp256k1-config.h, of which ECMULT_GEN_PREC_BITS is needed.\n+// ifndef guard so downstream users can define their own if they do not use autotools.\n+#if !defined(ECMULT_GEN_PREC_BITS)\n+#include \"libsecp256k1-config.h\"\n+#endif\n #define USE_BASIC_CONFIG 1\n-\n #include \"basic-config.h\"\n+\n #include \"include/secp256k1.h\"\n+#include \"util.h\"\n #include \"field_impl.h\"\n #include \"scalar_impl.h\"\n #include \"group_impl.h\"\n@@ -26,6 +32,7 @@ static const secp256k1_callback default_error_callback = {\n \n int main(int argc, char **argv) {\n     secp256k1_ecmult_gen_context ctx;\n+    void *prealloc, *base;\n     int inner;\n     int outer;\n     FILE* fp;\n@@ -38,37 +45,43 @@ int main(int argc, char **argv) {\n         fprintf(stderr, \"Could not open src/ecmult_static_context.h for writing!\\n\");\n         return -1;\n     }\n-    \n+\n     fprintf(fp, \"#ifndef _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n     fprintf(fp, \"#define _SECP256K1_ECMULT_STATIC_CONTEXT_\\n\");\n     fprintf(fp, \"#include \\\"src/group.h\\\"\\n\");\n     fprintf(fp, \"#define SC SECP256K1_GE_STORAGE_CONST\\n\");\n-    fprintf(fp, \"static const secp256k1_ge_storage secp256k1_ecmult_static_context[64][16] = {\\n\");\n+    fprintf(fp, \"#if ECMULT_GEN_PREC_N != %d || ECMULT_GEN_PREC_G != %d\\n\", ECMULT_GEN_PREC_N, ECMULT_GEN_PREC_G);\n+    fprintf(fp, \"   #error configuration mismatch, invalid ECMULT_GEN_PREC_N, ECMULT_GEN_PREC_G. Try deleting ecmult_static_context.h before the build.\\n\");\n+    fprintf(fp, \"#endif\\n\");\n+    fprintf(fp, \"static const secp256k1_ge_storage secp256k1_ecmult_static_context[ECMULT_GEN_PREC_N][ECMULT_GEN_PREC_G] = {\\n\");\n \n+    base = checked_malloc(&default_error_callback, SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE);\n+    prealloc = base;\n     secp256k1_ecmult_gen_context_init(&ctx);\n-    secp256k1_ecmult_gen_context_build(&ctx, &default_error_callback);\n-    for(outer = 0; outer != 64; outer++) {\n+    secp256k1_ecmult_gen_context_build(&ctx, &prealloc);\n+    for(outer = 0; outer != ECMULT_GEN_PREC_N; outer++) {\n         fprintf(fp,\"{\\n\");\n-        for(inner = 0; inner != 16; inner++) {\n+        for(inner = 0; inner != ECMULT_GEN_PREC_G; inner++) {\n             fprintf(fp,\"    SC(%uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu, %uu)\", SECP256K1_GE_STORAGE_CONST_GET((*ctx.prec)[outer][inner]));\n-            if (inner != 15) {\n+            if (inner != ECMULT_GEN_PREC_G - 1) {\n                 fprintf(fp,\",\\n\");\n             } else {\n                 fprintf(fp,\"\\n\");\n             }\n         }\n-        if (outer != 63) {\n+        if (outer != ECMULT_GEN_PREC_N - 1) {\n             fprintf(fp,\"},\\n\");\n         } else {\n             fprintf(fp,\"}\\n\");\n         }\n     }\n     fprintf(fp,\"};\\n\");\n     secp256k1_ecmult_gen_context_clear(&ctx);\n-    \n+    free(base);\n+\n     fprintf(fp, \"#undef SC\\n\");\n     fprintf(fp, \"#endif\\n\");\n     fclose(fp);\n-    \n+\n     return 0;\n }"
      },
      {
        "sha": "782f97216c284eff353a339fdd544c49ab2a7911",
        "filename": "src/secp256k1/src/hash_impl.h",
        "status": "modified",
        "additions": 2,
        "deletions": 1,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/hash_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/hash_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/hash_impl.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -131,7 +131,8 @@ static void secp256k1_sha256_transform(uint32_t* s, const uint32_t* chunk) {\n static void secp256k1_sha256_write(secp256k1_sha256 *hash, const unsigned char *data, size_t len) {\n     size_t bufsize = hash->bytes & 0x3F;\n     hash->bytes += len;\n-    while (bufsize + len >= 64) {\n+    VERIFY_CHECK(hash->bytes >= len);\n+    while (len >= 64 - bufsize) {\n         /* Fill the buffer, and process it. */\n         size_t chunk_len = 64 - bufsize;\n         memcpy(((unsigned char*)hash->buf) + bufsize, data, chunk_len);"
      },
      {
        "sha": "710d9f0bbfef3e50388a247baa712dc5acc74f0a",
        "filename": "src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "status": "modified",
        "additions": 9,
        "deletions": 10,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org/bitcoin/NativeSecp256k1Test.java?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -3,7 +3,6 @@\n import com.google.common.io.BaseEncoding;\n import java.util.Arrays;\n import java.math.BigInteger;\n-import javax.xml.bind.DatatypeConverter;\n import static org.bitcoin.NativeSecp256k1Util.*;\n \n /**\n@@ -70,7 +69,7 @@ public static void testPubKeyCreatePos() throws AssertFailException{\n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n-        String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String pubkeyString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( pubkeyString , \"04C591A8FF19AC9C4E4E5793673B83123437E975285E7B442F4EE2654DFFCA5E2D2103ED494718C697AC9AEBCFD19612E224DB46661011863ED2FC54E71861E2A6\" , \"testPubKeyCreatePos\");\n     }\n \n@@ -81,7 +80,7 @@ public static void testPubKeyCreateNeg() throws AssertFailException{\n        byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n \n        byte[] resultArr = NativeSecp256k1.computePubkey( sec);\n-       String pubkeyString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+       String pubkeyString = BaseEncoding.base16().encode(resultArr);\n        assertEquals( pubkeyString, \"\" , \"testPubKeyCreateNeg\");\n     }\n \n@@ -94,7 +93,7 @@ public static void testSignPos() throws AssertFailException{\n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"67E56582298859DDAE725F972992A07C6C4FB9F62A8FFF58CE3CA926A1063530\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.sign(data, sec);\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString, \"30440220182A108E1448DC8F1FB467D06A0F3BB8EA0533584CB954EF8DA112F1D60E39A202201C66F36DA211C087F3AF88B50EDF4F9BDAA6CF5FD6817E74DCA34DB12390C6E9\" , \"testSignPos\");\n     }\n \n@@ -106,7 +105,7 @@ public static void testSignNeg() throws AssertFailException{\n         byte[] sec = BaseEncoding.base16().lowerCase().decode(\"FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.sign(data, sec);\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString, \"\" , \"testSignNeg\");\n     }\n \n@@ -118,7 +117,7 @@ public static void testPrivKeyTweakAdd_1() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.privKeyTweakAdd( sec , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString , \"A168571E189E6F9A7E2D657A4B53AE99B909F7E712D1C23CED28093CD57C88F3\" , \"testPrivKeyAdd_1\");\n     }\n \n@@ -130,7 +129,7 @@ public static void testPrivKeyTweakMul_1() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.privKeyTweakMul( sec , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString , \"97F8184235F101550F3C71C927507651BD3F1CDB4A5A33B8986ACF0DEE20FFFC\" , \"testPrivKeyMul_1\");\n     }\n \n@@ -142,7 +141,7 @@ public static void testPrivKeyTweakAdd_2() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.pubKeyTweakAdd( pub , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString , \"0411C6790F4B663CCE607BAAE08C43557EDC1A4D11D88DFCB3D841D0C6A941AF525A268E2A863C148555C48FB5FBA368E88718A46E205FABC3DBA2CCFFAB0796EF\" , \"testPrivKeyAdd_2\");\n     }\n \n@@ -154,7 +153,7 @@ public static void testPrivKeyTweakMul_2() throws AssertFailException {\n         byte[] data = BaseEncoding.base16().lowerCase().decode(\"3982F19BEF1615BCCFBB05E321C10E1D4CBA3DF0E841C2E41EEB6016347653C3\".toLowerCase()); //sha256hash of \"tweak\"\n \n         byte[] resultArr = NativeSecp256k1.pubKeyTweakMul( pub , data );\n-        String sigString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String sigString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( sigString , \"04E0FE6FE55EBCA626B98A807F6CAF654139E14E5E3698F01A9A658E21DC1D2791EC060D4F412A794D5370F672BC94B722640B5F76914151CFCA6E712CA48CC589\" , \"testPrivKeyMul_2\");\n     }\n \n@@ -173,7 +172,7 @@ public static void testCreateECDHSecret() throws AssertFailException{\n         byte[] pub = BaseEncoding.base16().lowerCase().decode(\"040A629506E1B65CD9D2E0BA9C75DF9C4FED0DB16DC9625ED14397F0AFC836FAE595DC53F8B0EFE61E703075BD9B143BAC75EC0E19F82A2208CAEB32BE53414C40\".toLowerCase());\n \n         byte[] resultArr = NativeSecp256k1.createECDHSecret(sec, pub);\n-        String ecdhString = javax.xml.bind.DatatypeConverter.printHexBinary(resultArr);\n+        String ecdhString = BaseEncoding.base16().encode(resultArr);\n         assertEquals( ecdhString, \"2A2A67007A926E6594AF3EB564FC74005B37A9C8AEF2033C4552051B5C87F043\" , \"testCreateECDHSecret\");\n     }\n "
      },
      {
        "sha": "b590256867c671372ab85ccb85383db592a4c775",
        "filename": "src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "status": "modified",
        "additions": 3,
        "deletions": 3,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/java/org_bitcoin_NativeSecp256k1.c?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -81,15 +81,15 @@ SECP256K1_API jobjectArray JNICALL Java_org_bitcoin_NativeSecp256k1_secp256k1_1e\n   jbyteArray sigArray, intsByteArray;\n   unsigned char intsarray[2];\n \n-  secp256k1_ecdsa_signature sig[72];\n+  secp256k1_ecdsa_signature sig;\n \n-  int ret = secp256k1_ecdsa_sign(ctx, sig, data, secKey, NULL, NULL);\n+  int ret = secp256k1_ecdsa_sign(ctx, &sig, data, secKey, NULL, NULL);\n \n   unsigned char outputSer[72];\n   size_t outputLen = 72;\n \n   if( ret ) {\n-    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, sig ); (void)ret2;\n+    int ret2 = secp256k1_ecdsa_signature_serialize_der(ctx,outputSer, &outputLen, &sig ); (void)ret2;\n   }\n \n   intsarray[0] = outputLen;"
      },
      {
        "sha": "ed356e53a5c8f7e6246a272765f290c49ebcc2f1",
        "filename": "src/secp256k1/src/modules/recovery/main_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/modules/recovery/main_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/modules/recovery/main_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/main_impl.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -147,7 +147,7 @@ int secp256k1_ecdsa_sign_recoverable(const secp256k1_context* ctx, secp256k1_ecd\n                 break;\n             }\n             secp256k1_scalar_set_b32(&non, nonce32, &overflow);\n-            if (!secp256k1_scalar_is_zero(&non) && !overflow) {\n+            if (!overflow && !secp256k1_scalar_is_zero(&non)) {\n                 if (secp256k1_ecdsa_sig_sign(&ctx->ecmult_gen_ctx, &r, &s, &sec, &msg, &non, &recid)) {\n                     break;\n                 }"
      },
      {
        "sha": "38a533a755fc9aada88ffc66e358aee2e505d419",
        "filename": "src/secp256k1/src/modules/recovery/tests_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/modules/recovery/tests_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/modules/recovery/tests_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/modules/recovery/tests_impl.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -215,7 +215,7 @@ void test_ecdsa_recovery_edge_cases(void) {\n     };\n     const unsigned char sig64[64] = {\n         /* Generated by signing the above message with nonce 'This is the nonce we will use...'\n-         * and secret key 0 (which is not valid), resulting in recid 0. */\n+         * and secret key 0 (which is not valid), resulting in recid 1. */\n         0x67, 0xCB, 0x28, 0x5F, 0x9C, 0xD1, 0x94, 0xE8,\n         0x40, 0xD6, 0x29, 0x39, 0x7A, 0xF5, 0x56, 0x96,\n         0x62, 0xFD, 0xE4, 0x46, 0x49, 0x99, 0x59, 0x63,"
      },
      {
        "sha": "6b336d9d1a66d9c70a8c636b6ddad8b154613299",
        "filename": "src/secp256k1/src/scalar_impl.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/scalar_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/scalar_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_impl.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -7,8 +7,8 @@\n #ifndef SECP256K1_SCALAR_IMPL_H\n #define SECP256K1_SCALAR_IMPL_H\n \n-#include \"group.h\"\n #include \"scalar.h\"\n+#include \"util.h\"\n \n #if defined HAVE_CONFIG_H\n #include \"libsecp256k1-config.h\""
      },
      {
        "sha": "910ce3f4933d9a8ceb18c4f09d017fe910c82534",
        "filename": "src/secp256k1/src/scalar_low_impl.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/scalar_low_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/scalar_low_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scalar_low_impl.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -38,8 +38,11 @@ static int secp256k1_scalar_add(secp256k1_scalar *r, const secp256k1_scalar *a,\n \n static void secp256k1_scalar_cadd_bit(secp256k1_scalar *r, unsigned int bit, int flag) {\n     if (flag && bit < 32)\n-        *r += (1 << bit);\n+        *r += ((uint32_t)1 << bit);\n #ifdef VERIFY\n+    VERIFY_CHECK(bit < 32);\n+    /* Verify that adding (1 << bit) will not overflow any in-range scalar *r by overflowing the underlying uint32_t. */\n+    VERIFY_CHECK(((uint32_t)1 << bit) - 1 <= UINT32_MAX - EXHAUSTIVE_TEST_ORDER);\n     VERIFY_CHECK(secp256k1_scalar_check_overflow(r) == 0);\n #endif\n }"
      },
      {
        "sha": "77b35d126bbe6b22c4a2e72311dd87f91039848e",
        "filename": "src/secp256k1/src/scratch.h",
        "status": "modified",
        "additions": 17,
        "deletions": 14,
        "changes": 31,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/scratch.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/scratch.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scratch.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -7,33 +7,36 @@\n #ifndef _SECP256K1_SCRATCH_\n #define _SECP256K1_SCRATCH_\n \n-#define SECP256K1_SCRATCH_MAX_FRAMES\t5\n-\n /* The typedef is used internally; the struct name is used in the public API\n  * (where it is exposed as a different typedef) */\n typedef struct secp256k1_scratch_space_struct {\n-    void *data[SECP256K1_SCRATCH_MAX_FRAMES];\n-    size_t offset[SECP256K1_SCRATCH_MAX_FRAMES];\n-    size_t frame_size[SECP256K1_SCRATCH_MAX_FRAMES];\n-    size_t frame;\n+    /** guard against interpreting this object as other types */\n+    unsigned char magic[8];\n+    /** actual allocated data */\n+    void *data;\n+    /** amount that has been allocated (i.e. `data + offset` is the next\n+     *  available pointer)  */\n+    size_t alloc_size;\n+    /** maximum size available to allocate */\n     size_t max_size;\n-    const secp256k1_callback* error_callback;\n } secp256k1_scratch;\n \n static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t max_size);\n \n-static void secp256k1_scratch_destroy(secp256k1_scratch* scratch);\n+static void secp256k1_scratch_destroy(const secp256k1_callback* error_callback, secp256k1_scratch* scratch);\n \n-/** Attempts to allocate a new stack frame with `n` available bytes. Returns 1 on success, 0 on failure */\n-static int secp256k1_scratch_allocate_frame(secp256k1_scratch* scratch, size_t n, size_t objects);\n+/** Returns an opaque object used to \"checkpoint\" a scratch space. Used\n+ *  with `secp256k1_scratch_apply_checkpoint` to undo allocations. */\n+static size_t secp256k1_scratch_checkpoint(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch);\n \n-/** Deallocates a stack frame */\n-static void secp256k1_scratch_deallocate_frame(secp256k1_scratch* scratch);\n+/** Applies a check point received from `secp256k1_scratch_checkpoint`,\n+ *  undoing all allocations since that point. */\n+static void secp256k1_scratch_apply_checkpoint(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t checkpoint);\n \n /** Returns the maximum allocation the scratch space will allow */\n-static size_t secp256k1_scratch_max_allocation(const secp256k1_scratch* scratch, size_t n_objects);\n+static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch, size_t n_objects);\n \n /** Returns a pointer into the most recently allocated frame, or NULL if there is insufficient available space */\n-static void *secp256k1_scratch_alloc(secp256k1_scratch* scratch, size_t n);\n+static void *secp256k1_scratch_alloc(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t n);\n \n #endif"
      },
      {
        "sha": "4cee70000147b7b84e5759f00b0275fb9ead9107",
        "filename": "src/secp256k1/src/scratch_impl.h",
        "status": "modified",
        "additions": 47,
        "deletions": 45,
        "changes": 92,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/scratch_impl.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/scratch_impl.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/scratch_impl.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -7,78 +7,80 @@\n #ifndef _SECP256K1_SCRATCH_IMPL_H_\n #define _SECP256K1_SCRATCH_IMPL_H_\n \n+#include \"util.h\"\n #include \"scratch.h\"\n \n-/* Using 16 bytes alignment because common architectures never have alignment\n- * requirements above 8 for any of the types we care about. In addition we\n- * leave some room because currently we don't care about a few bytes.\n- * TODO: Determine this at configure time. */\n-#define ALIGNMENT 16\n-\n-static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t max_size) {\n-    secp256k1_scratch* ret = (secp256k1_scratch*)checked_malloc(error_callback, sizeof(*ret));\n+static secp256k1_scratch* secp256k1_scratch_create(const secp256k1_callback* error_callback, size_t size) {\n+    const size_t base_alloc = ((sizeof(secp256k1_scratch) + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+    void *alloc = checked_malloc(error_callback, base_alloc + size);\n+    secp256k1_scratch* ret = (secp256k1_scratch *)alloc;\n     if (ret != NULL) {\n         memset(ret, 0, sizeof(*ret));\n-        ret->max_size = max_size;\n-        ret->error_callback = error_callback;\n+        memcpy(ret->magic, \"scratch\", 8);\n+        ret->data = (void *) ((char *) alloc + base_alloc);\n+        ret->max_size = size;\n     }\n     return ret;\n }\n \n-static void secp256k1_scratch_destroy(secp256k1_scratch* scratch) {\n+static void secp256k1_scratch_destroy(const secp256k1_callback* error_callback, secp256k1_scratch* scratch) {\n     if (scratch != NULL) {\n-        VERIFY_CHECK(scratch->frame == 0);\n+        VERIFY_CHECK(scratch->alloc_size == 0); /* all checkpoints should be applied */\n+        if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+            secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+            return;\n+        }\n+        memset(scratch->magic, 0, sizeof(scratch->magic));\n         free(scratch);\n     }\n }\n \n-static size_t secp256k1_scratch_max_allocation(const secp256k1_scratch* scratch, size_t objects) {\n-    size_t i = 0;\n-    size_t allocated = 0;\n-    for (i = 0; i < scratch->frame; i++) {\n-        allocated += scratch->frame_size[i];\n-    }\n-    if (scratch->max_size - allocated <= objects * ALIGNMENT) {\n+static size_t secp256k1_scratch_checkpoint(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch) {\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n         return 0;\n     }\n-    return scratch->max_size - allocated - objects * ALIGNMENT;\n+    return scratch->alloc_size;\n }\n \n-static int secp256k1_scratch_allocate_frame(secp256k1_scratch* scratch, size_t n, size_t objects) {\n-    VERIFY_CHECK(scratch->frame < SECP256K1_SCRATCH_MAX_FRAMES);\n-\n-    if (n <= secp256k1_scratch_max_allocation(scratch, objects)) {\n-        n += objects * ALIGNMENT;\n-        scratch->data[scratch->frame] = checked_malloc(scratch->error_callback, n);\n-        if (scratch->data[scratch->frame] == NULL) {\n-            return 0;\n-        }\n-        scratch->frame_size[scratch->frame] = n;\n-        scratch->offset[scratch->frame] = 0;\n-        scratch->frame++;\n-        return 1;\n-    } else {\n-        return 0;\n+static void secp256k1_scratch_apply_checkpoint(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t checkpoint) {\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+        return;\n+    }\n+    if (checkpoint > scratch->alloc_size) {\n+        secp256k1_callback_call(error_callback, \"invalid checkpoint\");\n+        return;\n     }\n+    scratch->alloc_size = checkpoint;\n }\n \n-static void secp256k1_scratch_deallocate_frame(secp256k1_scratch* scratch) {\n-    VERIFY_CHECK(scratch->frame > 0);\n-    scratch->frame -= 1;\n-    free(scratch->data[scratch->frame]);\n+static size_t secp256k1_scratch_max_allocation(const secp256k1_callback* error_callback, const secp256k1_scratch* scratch, size_t objects) {\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+        return 0;\n+    }\n+    if (scratch->max_size - scratch->alloc_size <= objects * (ALIGNMENT - 1)) {\n+        return 0;\n+    }\n+    return scratch->max_size - scratch->alloc_size - objects * (ALIGNMENT - 1);\n }\n \n-static void *secp256k1_scratch_alloc(secp256k1_scratch* scratch, size_t size) {\n+static void *secp256k1_scratch_alloc(const secp256k1_callback* error_callback, secp256k1_scratch* scratch, size_t size) {\n     void *ret;\n-    size_t frame = scratch->frame - 1;\n-    size = ((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+    size = ROUND_TO_ALIGN(size);\n+\n+    if (memcmp(scratch->magic, \"scratch\", 8) != 0) {\n+        secp256k1_callback_call(error_callback, \"invalid scratch space\");\n+        return NULL;\n+    }\n \n-    if (scratch->frame == 0 || size + scratch->offset[frame] > scratch->frame_size[frame]) {\n+    if (size > scratch->max_size - scratch->alloc_size) {\n         return NULL;\n     }\n-    ret = (void *) ((unsigned char *) scratch->data[frame] + scratch->offset[frame]);\n+    ret = (void *) ((char *) scratch->data + scratch->alloc_size);\n     memset(ret, 0, size);\n-    scratch->offset[frame] += size;\n+    scratch->alloc_size += size;\n \n     return ret;\n }"
      },
      {
        "sha": "a3f446e507e20985d3d3d1f912f4a0203b44cc09",
        "filename": "src/secp256k1/src/secp256k1.c",
        "status": "modified",
        "additions": 112,
        "deletions": 31,
        "changes": 143,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/secp256k1.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/secp256k1.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/secp256k1.c?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -5,6 +5,7 @@\n  **********************************************************************/\n \n #include \"include/secp256k1.h\"\n+#include \"include/secp256k1_preallocated.h\"\n \n #include \"util.h\"\n #include \"num_impl.h\"\n@@ -26,28 +27,39 @@\n     } \\\n } while(0)\n \n-static void default_illegal_callback_fn(const char* str, void* data) {\n+#define ARG_CHECK_NO_RETURN(cond) do { \\\n+    if (EXPECT(!(cond), 0)) { \\\n+        secp256k1_callback_call(&ctx->illegal_callback, #cond); \\\n+    } \\\n+} while(0)\n+\n+#ifndef USE_EXTERNAL_DEFAULT_CALLBACKS\n+#include <stdlib.h>\n+#include <stdio.h>\n+static void secp256k1_default_illegal_callback_fn(const char* str, void* data) {\n     (void)data;\n     fprintf(stderr, \"[libsecp256k1] illegal argument: %s\\n\", str);\n     abort();\n }\n-\n-static const secp256k1_callback default_illegal_callback = {\n-    default_illegal_callback_fn,\n-    NULL\n-};\n-\n-static void default_error_callback_fn(const char* str, void* data) {\n+static void secp256k1_default_error_callback_fn(const char* str, void* data) {\n     (void)data;\n     fprintf(stderr, \"[libsecp256k1] internal consistency check failed: %s\\n\", str);\n     abort();\n }\n+#else\n+void secp256k1_default_illegal_callback_fn(const char* str, void* data);\n+void secp256k1_default_error_callback_fn(const char* str, void* data);\n+#endif\n \n-static const secp256k1_callback default_error_callback = {\n-    default_error_callback_fn,\n+static const secp256k1_callback default_illegal_callback = {\n+    secp256k1_default_illegal_callback_fn,\n     NULL\n };\n \n+static const secp256k1_callback default_error_callback = {\n+    secp256k1_default_error_callback_fn,\n+    NULL\n+};\n \n struct secp256k1_context_struct {\n     secp256k1_ecmult_context ecmult_ctx;\n@@ -59,68 +71,135 @@ struct secp256k1_context_struct {\n static const secp256k1_context secp256k1_context_no_precomp_ = {\n     { 0 },\n     { 0 },\n-    { default_illegal_callback_fn, 0 },\n-    { default_error_callback_fn, 0 }\n+    { secp256k1_default_illegal_callback_fn, 0 },\n+    { secp256k1_default_error_callback_fn, 0 }\n };\n const secp256k1_context *secp256k1_context_no_precomp = &secp256k1_context_no_precomp_;\n \n-secp256k1_context* secp256k1_context_create(unsigned int flags) {\n-    secp256k1_context* ret = (secp256k1_context*)checked_malloc(&default_error_callback, sizeof(secp256k1_context));\n+size_t secp256k1_context_preallocated_size(unsigned int flags) {\n+    size_t ret = ROUND_TO_ALIGN(sizeof(secp256k1_context));\n+\n+    if (EXPECT((flags & SECP256K1_FLAGS_TYPE_MASK) != SECP256K1_FLAGS_TYPE_CONTEXT, 0)) {\n+            secp256k1_callback_call(&default_illegal_callback,\n+                                    \"Invalid flags\");\n+            return 0;\n+    }\n+\n+    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n+        ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n+        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    return ret;\n+}\n+\n+size_t secp256k1_context_preallocated_clone_size(const secp256k1_context* ctx) {\n+    size_t ret = ROUND_TO_ALIGN(sizeof(secp256k1_context));\n+    VERIFY_CHECK(ctx != NULL);\n+    if (secp256k1_ecmult_gen_context_is_built(&ctx->ecmult_gen_ctx)) {\n+        ret += SECP256K1_ECMULT_GEN_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    if (secp256k1_ecmult_context_is_built(&ctx->ecmult_ctx)) {\n+        ret += SECP256K1_ECMULT_CONTEXT_PREALLOCATED_SIZE;\n+    }\n+    return ret;\n+}\n+\n+secp256k1_context* secp256k1_context_preallocated_create(void* prealloc, unsigned int flags) {\n+    void* const base = prealloc;\n+    size_t prealloc_size;\n+    secp256k1_context* ret;\n+\n+    VERIFY_CHECK(prealloc != NULL);\n+    prealloc_size = secp256k1_context_preallocated_size(flags);\n+    ret = (secp256k1_context*)manual_alloc(&prealloc, sizeof(secp256k1_context), base, prealloc_size);\n     ret->illegal_callback = default_illegal_callback;\n     ret->error_callback = default_error_callback;\n \n     if (EXPECT((flags & SECP256K1_FLAGS_TYPE_MASK) != SECP256K1_FLAGS_TYPE_CONTEXT, 0)) {\n             secp256k1_callback_call(&ret->illegal_callback,\n                                     \"Invalid flags\");\n-            free(ret);\n             return NULL;\n     }\n \n     secp256k1_ecmult_context_init(&ret->ecmult_ctx);\n     secp256k1_ecmult_gen_context_init(&ret->ecmult_gen_ctx);\n \n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_SIGN) {\n-        secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &ret->error_callback);\n+        secp256k1_ecmult_gen_context_build(&ret->ecmult_gen_ctx, &prealloc);\n     }\n     if (flags & SECP256K1_FLAGS_BIT_CONTEXT_VERIFY) {\n-        secp256k1_ecmult_context_build(&ret->ecmult_ctx, &ret->error_callback);\n+        secp256k1_ecmult_context_build(&ret->ecmult_ctx, &prealloc);\n+    }\n+\n+    return (secp256k1_context*) ret;\n+}\n+\n+secp256k1_context* secp256k1_context_create(unsigned int flags) {\n+    size_t const prealloc_size = secp256k1_context_preallocated_size(flags);\n+    secp256k1_context* ctx = (secp256k1_context*)checked_malloc(&default_error_callback, prealloc_size);\n+    if (EXPECT(secp256k1_context_preallocated_create(ctx, flags) == NULL, 0)) {\n+        free(ctx);\n+        return NULL;\n     }\n \n+    return ctx;\n+}\n+\n+secp256k1_context* secp256k1_context_preallocated_clone(const secp256k1_context* ctx, void* prealloc) {\n+    size_t prealloc_size;\n+    secp256k1_context* ret;\n+    VERIFY_CHECK(ctx != NULL);\n+    ARG_CHECK(prealloc != NULL);\n+\n+    prealloc_size = secp256k1_context_preallocated_clone_size(ctx);\n+    ret = (secp256k1_context*)prealloc;\n+    memcpy(ret, ctx, prealloc_size);\n+    secp256k1_ecmult_gen_context_finalize_memcpy(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx);\n+    secp256k1_ecmult_context_finalize_memcpy(&ret->ecmult_ctx, &ctx->ecmult_ctx);\n     return ret;\n }\n \n secp256k1_context* secp256k1_context_clone(const secp256k1_context* ctx) {\n-    secp256k1_context* ret = (secp256k1_context*)checked_malloc(&ctx->error_callback, sizeof(secp256k1_context));\n-    ret->illegal_callback = ctx->illegal_callback;\n-    ret->error_callback = ctx->error_callback;\n-    secp256k1_ecmult_context_clone(&ret->ecmult_ctx, &ctx->ecmult_ctx, &ctx->error_callback);\n-    secp256k1_ecmult_gen_context_clone(&ret->ecmult_gen_ctx, &ctx->ecmult_gen_ctx, &ctx->error_callback);\n+    secp256k1_context* ret;\n+    size_t prealloc_size;\n+\n+    VERIFY_CHECK(ctx != NULL);\n+    prealloc_size = secp256k1_context_preallocated_clone_size(ctx);\n+    ret = (secp256k1_context*)checked_malloc(&ctx->error_callback, prealloc_size);\n+    ret = secp256k1_context_preallocated_clone(ctx, ret);\n     return ret;\n }\n \n-void secp256k1_context_destroy(secp256k1_context* ctx) {\n-    CHECK(ctx != secp256k1_context_no_precomp);\n+void secp256k1_context_preallocated_destroy(secp256k1_context* ctx) {\n+    ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (ctx != NULL) {\n         secp256k1_ecmult_context_clear(&ctx->ecmult_ctx);\n         secp256k1_ecmult_gen_context_clear(&ctx->ecmult_gen_ctx);\n+    }\n+}\n \n+void secp256k1_context_destroy(secp256k1_context* ctx) {\n+    if (ctx != NULL) {\n+        secp256k1_context_preallocated_destroy(ctx);\n         free(ctx);\n     }\n }\n \n void secp256k1_context_set_illegal_callback(secp256k1_context* ctx, void (*fun)(const char* message, void* data), const void* data) {\n-    CHECK(ctx != secp256k1_context_no_precomp);\n+    ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (fun == NULL) {\n-        fun = default_illegal_callback_fn;\n+        fun = secp256k1_default_illegal_callback_fn;\n     }\n     ctx->illegal_callback.fn = fun;\n     ctx->illegal_callback.data = data;\n }\n \n void secp256k1_context_set_error_callback(secp256k1_context* ctx, void (*fun)(const char* message, void* data), const void* data) {\n-    CHECK(ctx != secp256k1_context_no_precomp);\n+    ARG_CHECK_NO_RETURN(ctx != secp256k1_context_no_precomp);\n     if (fun == NULL) {\n-        fun = default_error_callback_fn;\n+        fun = secp256k1_default_error_callback_fn;\n     }\n     ctx->error_callback.fn = fun;\n     ctx->error_callback.data = data;\n@@ -131,8 +210,9 @@ secp256k1_scratch_space* secp256k1_scratch_space_create(const secp256k1_context*\n     return secp256k1_scratch_create(&ctx->error_callback, max_size);\n }\n \n-void secp256k1_scratch_space_destroy(secp256k1_scratch_space* scratch) {\n-    secp256k1_scratch_destroy(scratch);\n+void secp256k1_scratch_space_destroy(const secp256k1_context *ctx, secp256k1_scratch_space* scratch) {\n+    VERIFY_CHECK(ctx != NULL);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n }\n \n static int secp256k1_pubkey_load(const secp256k1_context* ctx, secp256k1_ge* ge, const secp256k1_pubkey* pubkey) {\n@@ -438,7 +518,7 @@ int secp256k1_ec_pubkey_create(const secp256k1_context* ctx, secp256k1_pubkey *p\n     ARG_CHECK(seckey != NULL);\n \n     secp256k1_scalar_set_b32(&sec, seckey, &overflow);\n-    ret = (!overflow) & (!secp256k1_scalar_is_zero(&sec));\n+    ret = !overflow && !secp256k1_scalar_is_zero(&sec);\n     if (ret) {\n         secp256k1_ecmult_gen(&ctx->ecmult_gen_ctx, &pj, &sec);\n         secp256k1_ge_set_gej(&p, &pj);\n@@ -457,6 +537,7 @@ int secp256k1_ec_privkey_negate(const secp256k1_context* ctx, unsigned char *sec\n     secp256k1_scalar_negate(&sec, &sec);\n     secp256k1_scalar_get_b32(seckey, &sec);\n \n+    secp256k1_scalar_clear(&sec);\n     return 1;\n }\n "
      },
      {
        "sha": "d408a5c30a48ac39114f952e5e86c54321a8c8f0",
        "filename": "src/secp256k1/src/tests.c",
        "status": "modified",
        "additions": 237,
        "deletions": 86,
        "changes": 323,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/tests.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/tests.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests.c?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -16,6 +16,7 @@\n \n #include \"secp256k1.c\"\n #include \"include/secp256k1.h\"\n+#include \"include/secp256k1_preallocated.h\"\n #include \"testrand_impl.h\"\n \n #ifdef ENABLE_OPENSSL_TESTS\n@@ -82,7 +83,9 @@ void random_field_element_magnitude(secp256k1_fe *fe) {\n     secp256k1_fe_negate(&zero, &zero, 0);\n     secp256k1_fe_mul_int(&zero, n - 1);\n     secp256k1_fe_add(fe, &zero);\n-    VERIFY_CHECK(fe->magnitude == n);\n+#ifdef VERIFY\n+    CHECK(fe->magnitude == n);\n+#endif\n }\n \n void random_group_element_test(secp256k1_ge *ge) {\n@@ -137,23 +140,47 @@ void random_scalar_order(secp256k1_scalar *num) {\n     } while(1);\n }\n \n-void run_context_tests(void) {\n+void run_context_tests(int use_prealloc) {\n     secp256k1_pubkey pubkey;\n     secp256k1_pubkey zero_pubkey;\n     secp256k1_ecdsa_signature sig;\n     unsigned char ctmp[32];\n     int32_t ecount;\n     int32_t ecount2;\n-    secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n-    secp256k1_context *sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n-    secp256k1_context *vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n-    secp256k1_context *both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    secp256k1_context *none;\n+    secp256k1_context *sign;\n+    secp256k1_context *vrfy;\n+    secp256k1_context *both;\n+    void *none_prealloc = NULL;\n+    void *sign_prealloc = NULL;\n+    void *vrfy_prealloc = NULL;\n+    void *both_prealloc = NULL;\n \n     secp256k1_gej pubj;\n     secp256k1_ge pub;\n     secp256k1_scalar msg, key, nonce;\n     secp256k1_scalar sigr, sigs;\n \n+    if (use_prealloc) {\n+        none_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE));\n+        sign_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN));\n+        vrfy_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY));\n+        both_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY));\n+        CHECK(none_prealloc != NULL);\n+        CHECK(sign_prealloc != NULL);\n+        CHECK(vrfy_prealloc != NULL);\n+        CHECK(both_prealloc != NULL);\n+        none = secp256k1_context_preallocated_create(none_prealloc, SECP256K1_CONTEXT_NONE);\n+        sign = secp256k1_context_preallocated_create(sign_prealloc, SECP256K1_CONTEXT_SIGN);\n+        vrfy = secp256k1_context_preallocated_create(vrfy_prealloc, SECP256K1_CONTEXT_VERIFY);\n+        both = secp256k1_context_preallocated_create(both_prealloc, SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    } else {\n+        none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n+        sign = secp256k1_context_create(SECP256K1_CONTEXT_SIGN);\n+        vrfy = secp256k1_context_create(SECP256K1_CONTEXT_VERIFY);\n+        both = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n+    }\n+\n     memset(&zero_pubkey, 0, sizeof(zero_pubkey));\n \n     ecount = 0;\n@@ -163,14 +190,57 @@ void run_context_tests(void) {\n     secp256k1_context_set_error_callback(sign, counting_illegal_callback_fn, NULL);\n     CHECK(vrfy->error_callback.fn != sign->error_callback.fn);\n \n+    /* check if sizes for cloning are consistent */\n+    CHECK(secp256k1_context_preallocated_clone_size(none) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE));\n+    CHECK(secp256k1_context_preallocated_clone_size(sign) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN));\n+    CHECK(secp256k1_context_preallocated_clone_size(vrfy) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY));\n+    CHECK(secp256k1_context_preallocated_clone_size(both) == secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY));\n+\n     /*** clone and destroy all of them to make sure cloning was complete ***/\n     {\n         secp256k1_context *ctx_tmp;\n \n-        ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_destroy(ctx_tmp);\n-        ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_destroy(ctx_tmp);\n-        ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_destroy(ctx_tmp);\n-        ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_destroy(ctx_tmp);\n+        if (use_prealloc) {\n+            /* clone into a non-preallocated context and then again into a new preallocated one. */\n+            ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(none_prealloc); none_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE)); CHECK(none_prealloc != NULL);\n+            ctx_tmp = none; none = secp256k1_context_preallocated_clone(none, none_prealloc); secp256k1_context_destroy(ctx_tmp);\n+\n+            ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(sign_prealloc); sign_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN)); CHECK(sign_prealloc != NULL);\n+            ctx_tmp = sign; sign = secp256k1_context_preallocated_clone(sign, sign_prealloc); secp256k1_context_destroy(ctx_tmp);\n+\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(vrfy_prealloc); vrfy_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY)); CHECK(vrfy_prealloc != NULL);\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_preallocated_clone(vrfy, vrfy_prealloc); secp256k1_context_destroy(ctx_tmp);\n+\n+            ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(both_prealloc); both_prealloc = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY)); CHECK(both_prealloc != NULL);\n+            ctx_tmp = both; both = secp256k1_context_preallocated_clone(both, both_prealloc); secp256k1_context_destroy(ctx_tmp);\n+        } else {\n+            /* clone into a preallocated context and then again into a new non-preallocated one. */\n+            void *prealloc_tmp;\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_NONE)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = none; none = secp256k1_context_preallocated_clone(none, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = none; none = secp256k1_context_clone(none); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = sign; sign = secp256k1_context_preallocated_clone(sign, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = sign; sign = secp256k1_context_clone(sign); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_VERIFY)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_preallocated_clone(vrfy, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = vrfy; vrfy = secp256k1_context_clone(vrfy); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+\n+            prealloc_tmp = malloc(secp256k1_context_preallocated_size(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY)); CHECK(prealloc_tmp != NULL);\n+            ctx_tmp = both; both = secp256k1_context_preallocated_clone(both, prealloc_tmp); secp256k1_context_destroy(ctx_tmp);\n+            ctx_tmp = both; both = secp256k1_context_clone(both); secp256k1_context_preallocated_destroy(ctx_tmp);\n+            free(prealloc_tmp);\n+        }\n     }\n \n     /* Verify that the error callback makes it across the clone. */\n@@ -229,10 +299,6 @@ void run_context_tests(void) {\n     secp256k1_context_set_illegal_callback(vrfy, NULL, NULL);\n     secp256k1_context_set_illegal_callback(sign, NULL, NULL);\n \n-    /* This shouldn't leak memory, due to already-set tests. */\n-    secp256k1_ecmult_gen_context_build(&sign->ecmult_gen_ctx, NULL);\n-    secp256k1_ecmult_context_build(&vrfy->ecmult_ctx, NULL);\n-\n     /* obtain a working nonce */\n     do {\n         random_scalar_order_test(&nonce);\n@@ -247,49 +313,95 @@ void run_context_tests(void) {\n     CHECK(secp256k1_ecdsa_sig_verify(&both->ecmult_ctx, &sigr, &sigs, &pub, &msg));\n \n     /* cleanup */\n-    secp256k1_context_destroy(none);\n-    secp256k1_context_destroy(sign);\n-    secp256k1_context_destroy(vrfy);\n-    secp256k1_context_destroy(both);\n+    if (use_prealloc) {\n+        secp256k1_context_preallocated_destroy(none);\n+        secp256k1_context_preallocated_destroy(sign);\n+        secp256k1_context_preallocated_destroy(vrfy);\n+        secp256k1_context_preallocated_destroy(both);\n+        free(none_prealloc);\n+        free(sign_prealloc);\n+        free(vrfy_prealloc);\n+        free(both_prealloc);\n+    } else {\n+        secp256k1_context_destroy(none);\n+        secp256k1_context_destroy(sign);\n+        secp256k1_context_destroy(vrfy);\n+        secp256k1_context_destroy(both);\n+    }\n     /* Defined as no-op. */\n     secp256k1_context_destroy(NULL);\n+    secp256k1_context_preallocated_destroy(NULL);\n+\n }\n \n void run_scratch_tests(void) {\n+    const size_t adj_alloc = ((500 + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT;\n+\n     int32_t ecount = 0;\n+    size_t checkpoint;\n+    size_t checkpoint_2;\n     secp256k1_context *none = secp256k1_context_create(SECP256K1_CONTEXT_NONE);\n     secp256k1_scratch_space *scratch;\n+    secp256k1_scratch_space local_scratch;\n \n     /* Test public API */\n     secp256k1_context_set_illegal_callback(none, counting_illegal_callback_fn, &ecount);\n+    secp256k1_context_set_error_callback(none, counting_illegal_callback_fn, &ecount);\n \n     scratch = secp256k1_scratch_space_create(none, 1000);\n     CHECK(scratch != NULL);\n     CHECK(ecount == 0);\n \n     /* Test internal API */\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 1) < 1000);\n-\n-    /* Allocating 500 bytes with no frame fails */\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n-\n-    /* ...but pushing a new stack frame does affect the max allocation */\n-    CHECK(secp256k1_scratch_allocate_frame(scratch, 500, 1 == 1));\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 1) < 500); /* 500 - ALIGNMENT */\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) != NULL);\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n-\n-    CHECK(secp256k1_scratch_allocate_frame(scratch, 500, 1) == 0);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - (ALIGNMENT - 1));\n+    CHECK(scratch->alloc_size == 0);\n+    CHECK(scratch->alloc_size % ALIGNMENT == 0);\n+\n+    /* Allocating 500 bytes succeeds */\n+    checkpoint = secp256k1_scratch_checkpoint(&none->error_callback, scratch);\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) != NULL);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000 - adj_alloc);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - adj_alloc - (ALIGNMENT - 1));\n+    CHECK(scratch->alloc_size != 0);\n+    CHECK(scratch->alloc_size % ALIGNMENT == 0);\n+\n+    /* Allocating another 500 bytes fails */\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) == NULL);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000 - adj_alloc);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 1) == 1000 - adj_alloc - (ALIGNMENT - 1));\n+    CHECK(scratch->alloc_size != 0);\n+    CHECK(scratch->alloc_size % ALIGNMENT == 0);\n+\n+    /* ...but it succeeds once we apply the checkpoint to undo it */\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, checkpoint);\n+    CHECK(scratch->alloc_size == 0);\n+    CHECK(secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0) == 1000);\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) != NULL);\n+    CHECK(scratch->alloc_size != 0);\n+\n+    /* try to apply a bad checkpoint */\n+    checkpoint_2 = secp256k1_scratch_checkpoint(&none->error_callback, scratch);\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, checkpoint);\n+    CHECK(ecount == 0);\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, checkpoint_2); /* checkpoint_2 is after checkpoint */\n+    CHECK(ecount == 1);\n+    secp256k1_scratch_apply_checkpoint(&none->error_callback, scratch, (size_t) -1); /* this is just wildly invalid */\n+    CHECK(ecount == 2);\n \n-    /* ...and this effect is undone by popping the frame */\n-    secp256k1_scratch_deallocate_frame(scratch);\n-    CHECK(secp256k1_scratch_max_allocation(scratch, 0) == 1000);\n-    CHECK(secp256k1_scratch_alloc(scratch, 500) == NULL);\n+    /* try to use badly initialized scratch space */\n+    secp256k1_scratch_space_destroy(none, scratch);\n+    memset(&local_scratch, 0, sizeof(local_scratch));\n+    scratch = &local_scratch;\n+    CHECK(!secp256k1_scratch_max_allocation(&none->error_callback, scratch, 0));\n+    CHECK(ecount == 3);\n+    CHECK(secp256k1_scratch_alloc(&none->error_callback, scratch, 500) == NULL);\n+    CHECK(ecount == 4);\n+    secp256k1_scratch_space_destroy(none, scratch);\n+    CHECK(ecount == 5);\n \n     /* cleanup */\n-    secp256k1_scratch_space_destroy(scratch);\n+    secp256k1_scratch_space_destroy(none, NULL); /* no-op */\n     secp256k1_context_destroy(none);\n }\n \n@@ -1709,24 +1821,32 @@ void run_field_misc(void) {\n         /* Test fe conditional move; z is not normalized here. */\n         q = x;\n         secp256k1_fe_cmov(&x, &z, 0);\n-        VERIFY_CHECK(!x.normalized && x.magnitude == z.magnitude);\n+#ifdef VERIFY\n+        CHECK(!x.normalized && x.magnitude == z.magnitude);\n+#endif\n         secp256k1_fe_cmov(&x, &x, 1);\n         CHECK(fe_memcmp(&x, &z) != 0);\n         CHECK(fe_memcmp(&x, &q) == 0);\n         secp256k1_fe_cmov(&q, &z, 1);\n-        VERIFY_CHECK(!q.normalized && q.magnitude == z.magnitude);\n+#ifdef VERIFY\n+        CHECK(!q.normalized && q.magnitude == z.magnitude);\n+#endif\n         CHECK(fe_memcmp(&q, &z) == 0);\n         secp256k1_fe_normalize_var(&x);\n         secp256k1_fe_normalize_var(&z);\n         CHECK(!secp256k1_fe_equal_var(&x, &z));\n         secp256k1_fe_normalize_var(&q);\n         secp256k1_fe_cmov(&q, &z, (i&1));\n-        VERIFY_CHECK(q.normalized && q.magnitude == 1);\n+#ifdef VERIFY\n+        CHECK(q.normalized && q.magnitude == 1);\n+#endif\n         for (j = 0; j < 6; j++) {\n             secp256k1_fe_negate(&z, &z, j+1);\n             secp256k1_fe_normalize_var(&q);\n             secp256k1_fe_cmov(&q, &z, (j&1));\n-            VERIFY_CHECK(!q.normalized && q.magnitude == (j+2));\n+#ifdef VERIFY\n+            CHECK(!q.normalized && q.magnitude == (j+2));\n+#endif\n         }\n         secp256k1_fe_normalize_var(&z);\n         /* Test storage conversion and conditional moves. */\n@@ -2120,7 +2240,7 @@ void test_ge(void) {\n     /* Test batch gej -> ge conversion with many infinities. */\n     for (i = 0; i < 4 * runs + 1; i++) {\n         random_group_element_test(&ge[i]);\n-        /* randomly set half the points to infinitiy */\n+        /* randomly set half the points to infinity */\n         if(secp256k1_fe_is_odd(&ge[i].x)) {\n             secp256k1_ge_set_infinity(&ge[i]);\n         }\n@@ -2572,14 +2692,13 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     secp256k1_gej r;\n     secp256k1_gej r2;\n     ecmult_multi_data data;\n-    secp256k1_scratch *scratch_empty;\n \n     data.sc = sc;\n     data.pt = pt;\n     secp256k1_scalar_set_int(&szero, 0);\n \n     /* No points to multiply */\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, NULL, ecmult_multi_callback, &data, 0));\n \n     /* Check 1- and 2-point multiplies against ecmult */\n     for (ncount = 0; ncount < count; ncount++) {\n@@ -2595,36 +2714,31 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n \n         /* only G scalar */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &szero, &sc[0]);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[0], ecmult_multi_callback, &data, 0));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 1-point */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n-        /* Try to multiply 1 point, but scratch space is empty */\n-        scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n-        CHECK(!ecmult_multi(&ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n-        secp256k1_scratch_destroy(scratch_empty);\n-\n         /* Try to multiply 1 point, but callback returns false */\n-        CHECK(!ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n+        CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_false_callback, &data, 1));\n \n         /* 2-point */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 2));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n \n         /* 2-point with G scalar */\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &ptgj, &sc[0], &sc[1]);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &sc[1], ecmult_multi_callback, &data, 1));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -2641,7 +2755,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 random_scalar_order(&sc[i]);\n                 secp256k1_ge_set_infinity(&pt[i]);\n             }\n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -2651,7 +2765,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[i] = ptg;\n                 secp256k1_scalar_set_int(&sc[i], 0);\n             }\n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -2664,7 +2778,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 pt[2 * i + 1] = ptg;\n             }\n \n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n \n             random_scalar_order(&sc[0]);\n@@ -2677,7 +2791,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                 secp256k1_ge_neg(&pt[2*i+1], &pt[2*i]);\n             }\n \n-            CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n+            CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, sizes[j]));\n             CHECK(secp256k1_gej_is_infinity(&r));\n         }\n \n@@ -2692,7 +2806,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n             secp256k1_scalar_negate(&sc[i], &sc[i]);\n         }\n \n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 32));\n         CHECK(secp256k1_gej_is_infinity(&r));\n     }\n \n@@ -2711,7 +2825,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n         }\n \n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &r, &sc[0], &szero);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -2734,7 +2848,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n \n         secp256k1_gej_set_ge(&p0j, &pt[0]);\n         secp256k1_ecmult(&ctx->ecmult_ctx, &r2, &p0j, &rs, &szero);\n-        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n         secp256k1_gej_neg(&r2, &r2);\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n@@ -2747,13 +2861,13 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     }\n \n     secp256k1_scalar_clear(&sc[0]);\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 20));\n     secp256k1_scalar_clear(&sc[1]);\n     secp256k1_scalar_clear(&sc[2]);\n     secp256k1_scalar_clear(&sc[3]);\n     secp256k1_scalar_clear(&sc[4]);\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n-    CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 6));\n+    CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &szero, ecmult_multi_callback, &data, 5));\n     CHECK(secp256k1_gej_is_infinity(&r));\n \n     /* Run through s0*(t0*P) + s1*(t1*P) exhaustively for many small values of s0, s1, t0, t1 */\n@@ -2798,7 +2912,7 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n                         secp256k1_scalar_add(&tmp1, &tmp1, &tmp2);\n \n                         secp256k1_ecmult(&ctx->ecmult_ctx, &expected, &ptgj, &tmp1, &szero);\n-                        CHECK(ecmult_multi(&ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n+                        CHECK(ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &actual, &szero, ecmult_multi_callback, &data, 2));\n                         secp256k1_gej_neg(&expected, &expected);\n                         secp256k1_gej_add_var(&actual, &actual, &expected, NULL);\n                         CHECK(secp256k1_gej_is_infinity(&actual));\n@@ -2809,6 +2923,24 @@ void test_ecmult_multi(secp256k1_scratch *scratch, secp256k1_ecmult_multi_func e\n     }\n }\n \n+void test_ecmult_multi_batch_single(secp256k1_ecmult_multi_func ecmult_multi) {\n+    secp256k1_scalar szero;\n+    secp256k1_scalar sc[32];\n+    secp256k1_ge pt[32];\n+    secp256k1_gej r;\n+    ecmult_multi_data data;\n+    secp256k1_scratch *scratch_empty;\n+\n+    data.sc = sc;\n+    data.pt = pt;\n+    secp256k1_scalar_set_int(&szero, 0);\n+\n+    /* Try to multiply 1 point, but scratch space is empty.*/\n+    scratch_empty = secp256k1_scratch_create(&ctx->error_callback, 0);\n+    CHECK(!ecmult_multi(&ctx->error_callback, &ctx->ecmult_ctx, scratch_empty, &r, &szero, ecmult_multi_callback, &data, 1));\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch_empty);\n+}\n+\n void test_secp256k1_pippenger_bucket_window_inv(void) {\n     int i;\n \n@@ -2839,17 +2971,27 @@ void test_ecmult_multi_pippenger_max_points(void) {\n     int bucket_window = 0;\n \n     for(; scratch_size < max_size; scratch_size+=256) {\n+        size_t i;\n+        size_t total_alloc;\n+        size_t checkpoint;\n         scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size);\n         CHECK(scratch != NULL);\n-        n_points_supported = secp256k1_pippenger_max_points(scratch);\n+        checkpoint = secp256k1_scratch_checkpoint(&ctx->error_callback, scratch);\n+        n_points_supported = secp256k1_pippenger_max_points(&ctx->error_callback, scratch);\n         if (n_points_supported == 0) {\n-            secp256k1_scratch_destroy(scratch);\n+            secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n             continue;\n         }\n         bucket_window = secp256k1_pippenger_bucket_window(n_points_supported);\n-        CHECK(secp256k1_scratch_allocate_frame(scratch, secp256k1_pippenger_scratch_size(n_points_supported, bucket_window), PIPPENGER_SCRATCH_OBJECTS));\n-        secp256k1_scratch_deallocate_frame(scratch);\n-        secp256k1_scratch_destroy(scratch);\n+        /* allocate `total_alloc` bytes over `PIPPENGER_SCRATCH_OBJECTS` many allocations */\n+        total_alloc = secp256k1_pippenger_scratch_size(n_points_supported, bucket_window);\n+        for (i = 0; i < PIPPENGER_SCRATCH_OBJECTS - 1; i++) {\n+            CHECK(secp256k1_scratch_alloc(&ctx->error_callback, scratch, 1));\n+            total_alloc--;\n+        }\n+        CHECK(secp256k1_scratch_alloc(&ctx->error_callback, scratch, total_alloc));\n+        secp256k1_scratch_apply_checkpoint(&ctx->error_callback, scratch, checkpoint);\n+        secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n     }\n     CHECK(bucket_window == PIPPENGER_MAX_BUCKET_WINDOW);\n }\n@@ -2932,19 +3074,25 @@ void test_ecmult_multi_batching(void) {\n     }\n     data.sc = sc;\n     data.pt = pt;\n+    secp256k1_gej_neg(&r2, &r2);\n \n-    /* Test with empty scratch space */\n+    /* Test with empty scratch space. It should compute the correct result using \n+     * ecmult_mult_simple algorithm which doesn't require a scratch space. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, 0);\n-    CHECK(!secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, 1));\n-    secp256k1_scratch_destroy(scratch);\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&r));\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n     /* Test with space for 1 point in pippenger. That's not enough because\n-     * ecmult_multi selects strauss which requires more memory. */\n+     * ecmult_multi selects strauss which requires more memory. It should\n+     * therefore select the simple algorithm. */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_pippenger_scratch_size(1, 1) + PIPPENGER_SCRATCH_OBJECTS*ALIGNMENT);\n-    CHECK(!secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, 1));\n-    secp256k1_scratch_destroy(scratch);\n+    CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+    secp256k1_gej_add_var(&r, &r, &r2, NULL);\n+    CHECK(secp256k1_gej_is_infinity(&r));\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n-    secp256k1_gej_neg(&r2, &r2);\n     for(i = 1; i <= n_points; i++) {\n         if (i > ECMULT_PIPPENGER_THRESHOLD) {\n             int bucket_window = secp256k1_pippenger_bucket_window(i);\n@@ -2954,10 +3102,10 @@ void test_ecmult_multi_batching(void) {\n             size_t scratch_size = secp256k1_strauss_scratch_size(i);\n             scratch = secp256k1_scratch_create(&ctx->error_callback, scratch_size + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n         }\n-        CHECK(secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n+        CHECK(secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &r, &scG, ecmult_multi_callback, &data, n_points));\n         secp256k1_gej_add_var(&r, &r, &r2, NULL);\n         CHECK(secp256k1_gej_is_infinity(&r));\n-        secp256k1_scratch_destroy(scratch);\n+        secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n     }\n     free(sc);\n     free(pt);\n@@ -2972,13 +3120,15 @@ void run_ecmult_multi_tests(void) {\n     test_ecmult_multi(scratch, secp256k1_ecmult_multi_var);\n     test_ecmult_multi(NULL, secp256k1_ecmult_multi_var);\n     test_ecmult_multi(scratch, secp256k1_ecmult_pippenger_batch_single);\n+    test_ecmult_multi_batch_single(secp256k1_ecmult_pippenger_batch_single);\n     test_ecmult_multi(scratch, secp256k1_ecmult_strauss_batch_single);\n-    secp256k1_scratch_destroy(scratch);\n+    test_ecmult_multi_batch_single(secp256k1_ecmult_strauss_batch_single);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n     /* Run test_ecmult_multi with space for exactly one point */\n     scratch = secp256k1_scratch_create(&ctx->error_callback, secp256k1_strauss_scratch_size(1) + STRAUSS_SCRATCH_OBJECTS*ALIGNMENT);\n     test_ecmult_multi(scratch, secp256k1_ecmult_multi_var);\n-    secp256k1_scratch_destroy(scratch);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n \n     test_ecmult_multi_batch_size_helper();\n     test_ecmult_multi_batching();\n@@ -3050,7 +3200,7 @@ void test_constant_wnaf(const secp256k1_scalar *number, int w) {\n     }\n     bits = 128;\n #endif\n-    skew = secp256k1_wnaf_const(wnaf, num, w, bits);\n+    skew = secp256k1_wnaf_const(wnaf, &num, w, bits);\n \n     for (i = WNAF_SIZE_BITS(bits, w); i >= 0; --i) {\n         secp256k1_scalar t;\n@@ -4315,7 +4465,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     if (valid_der) {\n         ret |= (!roundtrips_der_lax) << 12;\n         ret |= (len_der != len_der_lax) << 13;\n-        ret |= (memcmp(roundtrip_der_lax, roundtrip_der, len_der) != 0) << 14;\n+        ret |= ((len_der != len_der_lax) || (memcmp(roundtrip_der_lax, roundtrip_der, len_der) != 0)) << 14;\n     }\n     ret |= (roundtrips_der != roundtrips_der_lax) << 15;\n     if (parsed_der) {\n@@ -4356,7 +4506,7 @@ int test_ecdsa_der_parse(const unsigned char *sig, size_t siglen, int certainly_\n     ret |= (roundtrips_der != roundtrips_openssl) << 7;\n     if (roundtrips_openssl) {\n         ret |= (len_der != (size_t)len_openssl) << 8;\n-        ret |= (memcmp(roundtrip_der, roundtrip_openssl, len_der) != 0) << 9;\n+        ret |= ((len_der != (size_t)len_openssl) || (memcmp(roundtrip_der, roundtrip_openssl, len_der) != 0)) << 9;\n     }\n #endif\n     return ret;\n@@ -5030,7 +5180,7 @@ int main(int argc, char **argv) {\n         const char* ch = argv[2];\n         while (pos < 16 && ch[0] != 0 && ch[1] != 0) {\n             unsigned short sh;\n-            if (sscanf(ch, \"%2hx\", &sh)) {\n+            if ((sscanf(ch, \"%2hx\", &sh)) == 1) {\n                 seed16[pos] = sh;\n             } else {\n                 break;\n@@ -5062,7 +5212,8 @@ int main(int argc, char **argv) {\n     printf(\"random seed = %02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x%02x\\n\", seed16[0], seed16[1], seed16[2], seed16[3], seed16[4], seed16[5], seed16[6], seed16[7], seed16[8], seed16[9], seed16[10], seed16[11], seed16[12], seed16[13], seed16[14], seed16[15]);\n \n     /* initialize */\n-    run_context_tests();\n+    run_context_tests(0);\n+    run_context_tests(1);\n     run_scratch_tests();\n     ctx = secp256k1_context_create(SECP256K1_CONTEXT_SIGN | SECP256K1_CONTEXT_VERIFY);\n     if (secp256k1_rand_bits(1)) {"
      },
      {
        "sha": "b44e357cb69c742b1eccb94695412960c82e6385",
        "filename": "src/secp256k1/src/tests_exhaustive.c",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/tests_exhaustive.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/tests_exhaustive.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/tests_exhaustive.c?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -212,14 +212,14 @@ void test_exhaustive_ecmult_multi(const secp256k1_context *ctx, const secp256k1_\n                         data.pt[0] = group[x];\n                         data.pt[1] = group[y];\n \n-                        secp256k1_ecmult_multi_var(&ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n+                        secp256k1_ecmult_multi_var(&ctx->error_callback, &ctx->ecmult_ctx, scratch, &tmp, &g_sc, ecmult_multi_callback, &data, 2);\n                         ge_equals_gej(&group[(i * x + j * y + k) % order], &tmp);\n                     }\n                 }\n             }\n         }\n     }\n-    secp256k1_scratch_destroy(scratch);\n+    secp256k1_scratch_destroy(&ctx->error_callback, scratch);\n }\n \n void r_from_k(secp256k1_scalar *r, const secp256k1_ge *group, int k) {"
      },
      {
        "sha": "9deb61bc59d153c987ecc3a8fdca91962344e591",
        "filename": "src/secp256k1/src/util.h",
        "status": "modified",
        "additions": 41,
        "deletions": 0,
        "changes": 41,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/util.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f/src/secp256k1/src/util.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/secp256k1/src/util.h?ref=99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "patch": "@@ -84,6 +84,47 @@ static SECP256K1_INLINE void *checked_realloc(const secp256k1_callback* cb, void\n     return ret;\n }\n \n+#if defined(__BIGGEST_ALIGNMENT__)\n+#define ALIGNMENT __BIGGEST_ALIGNMENT__\n+#else\n+/* Using 16 bytes alignment because common architectures never have alignment\n+ * requirements above 8 for any of the types we care about. In addition we\n+ * leave some room because currently we don't care about a few bytes. */\n+#define ALIGNMENT 16\n+#endif\n+\n+#define ROUND_TO_ALIGN(size) (((size + ALIGNMENT - 1) / ALIGNMENT) * ALIGNMENT)\n+\n+/* Assume there is a contiguous memory object with bounds [base, base + max_size)\n+ * of which the memory range [base, *prealloc_ptr) is already allocated for usage,\n+ * where *prealloc_ptr is an aligned pointer. In that setting, this functions\n+ * reserves the subobject [*prealloc_ptr, *prealloc_ptr + alloc_size) of\n+ * alloc_size bytes by increasing *prealloc_ptr accordingly, taking into account\n+ * alignment requirements.\n+ *\n+ * The function returns an aligned pointer to the newly allocated subobject.\n+ *\n+ * This is useful for manual memory management: if we're simply given a block\n+ * [base, base + max_size), the caller can use this function to allocate memory\n+ * in this block and keep track of the current allocation state with *prealloc_ptr.\n+ *\n+ * It is VERIFY_CHECKed that there is enough space left in the memory object and\n+ * *prealloc_ptr is aligned relative to base.\n+ */\n+static SECP256K1_INLINE void *manual_alloc(void** prealloc_ptr, size_t alloc_size, void* base, size_t max_size) {\n+    size_t aligned_alloc_size = ROUND_TO_ALIGN(alloc_size);\n+    void* ret;\n+    VERIFY_CHECK(prealloc_ptr != NULL);\n+    VERIFY_CHECK(*prealloc_ptr != NULL);\n+    VERIFY_CHECK(base != NULL);\n+    VERIFY_CHECK((unsigned char*)*prealloc_ptr >= (unsigned char*)base);\n+    VERIFY_CHECK(((unsigned char*)*prealloc_ptr - (unsigned char*)base) % ALIGNMENT == 0);\n+    VERIFY_CHECK((unsigned char*)*prealloc_ptr - (unsigned char*)base + aligned_alloc_size <= max_size);\n+    ret = *prealloc_ptr;\n+    *((unsigned char**)prealloc_ptr) += aligned_alloc_size;\n+    return ret;\n+}\n+\n /* Macro for restrict, when available and not in a VERIFY build. */\n #if defined(SECP256K1_BUILD) && defined(VERIFY)\n # define SECP256K1_RESTRICT"
      }
    ]
  },
  {
    "sha": "ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpjYTNkZGRkYzA5ZmEzYmRjNWJjYTdlN2ZhMWFjODk4NTY3YWU5ZjBi",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-07T19:12:45Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "(XXX: subtree me) add libc as a dep",
      "tree": {
        "sha": "bf43541500c463824f607e60aa4bf37b63eb0e84",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bf43541500c463824f607e60aa4bf37b63eb0e84"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/99eaf1fe09bb10a9a107b63b814ea7e9e358b80f"
      }
    ],
    "stats": {
      "total": 74242,
      "additions": 74242,
      "deletions": 0
    },
    "files": [
      {
        "sha": "435bf35c66f572437d1787f9d0980e41fdbe1883",
        "filename": "src/rusty/libc/.github/issue_template.md",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/.github/issue_template.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/.github/issue_template.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/.github/issue_template.md?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,24 @@\n+<!-- \n+**Help us help you.**\n+\n+If you are reporting a bug, include:\n+\n+* a Minimum Working Example without any dependencies (except libc) that shows\n+  the issue and ideally reproduces in the Rust playground\n+* the target triple - libc supports many targets and many APIs\n+* instructions to reproduce, logs (e.g. build logs, links to Travis-CI logs,\n+  uploads to github gists, etc.).\n+\n+If you are requesting a new API, include:\n+\n+* the target triple\n+* link to the documentation of the API showing the type signatures, how to use\n+  it, etc.\n+\n+In general, just please consider that the people who can help you are all very\n+busy, they will be helping you in their free time, there are a lot of people in\n+need of help so they need to prioritize to which issues they devote their free\n+time, etc. So try to give most of the information upfront, be concise, show\n+small self-contained examples (nobody has time to create a new cargo project,\n+set up dependencies,...), etc. Help us help you.\n+-->"
      },
      {
        "sha": "bbbad4bc51532d2886bb38ec65881eb72bc7ec65",
        "filename": "src/rusty/libc/.gitignore",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/.gitignore?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,4 @@\n+target\n+Cargo.lock\n+*~\n+style"
      },
      {
        "sha": "052777f41617b705650c20de495899633874a8a3",
        "filename": "src/rusty/libc/CONTRIBUTING.md",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/CONTRIBUTING.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/CONTRIBUTING.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/CONTRIBUTING.md?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,66 @@\n+# Contributing to `libc`\n+\n+Welcome! If you are reading this document, it means you are interested in contributing\n+to the `libc` crate.\n+\n+## Adding an API\n+\n+Want to use an API which currently isn't bound in `libc`? It's quite easy to add\n+one!\n+\n+The internal structure of this crate is designed to minimize the number of\n+`#[cfg]` attributes in order to easily be able to add new items which apply\n+to all platforms in the future. As a result, the crate is organized\n+hierarchically based on platform. Each module has a number of `#[cfg]`'d\n+children, but only one is ever actually compiled. Each module then reexports all\n+the contents of its children.\n+\n+This means that for each platform that libc supports, the path from a\n+leaf module to the root will contain all bindings for the platform in question.\n+Consequently, this indicates where an API should be added! Adding an API at a\n+particular level in the hierarchy means that it is supported on all the child\n+platforms of that level. For example, when adding a Unix API it should be added\n+to `src/unix/mod.rs`, but when adding a Linux-only API it should be added to\n+`src/unix/linux_like/linux/mod.rs`.\n+\n+If you're not 100% sure at what level of the hierarchy an API should be added\n+at, fear not! This crate has CI support which tests any binding against all\n+platforms supported, so you'll see failures if an API is added at the wrong\n+level or has different signatures across platforms.\n+\n+With that in mind, the steps for adding a new API are:\n+\n+1. Determine where in the module hierarchy your API should be added.\n+2. Add the API.\n+3. Send a PR to this repo.\n+4. Wait for CI to pass, fixing errors.\n+5. Wait for a merge!\n+\n+### Test before you commit\n+\n+We have two automated tests running on [Azure Pipelines](https://dev.azure.com/rust-lang2/libc/_build?definitionId=1&_a=summary):\n+\n+1. [`libc-test`](https://github.com/gnzlbg/ctest)\n+  - `cd libc-test && cargo test`\n+  - Use the `skip_*()` functions in `build.rs` if you really need a workaround.\n+2. Style checker\n+  - `rustc ci/style.rs && ./style src`\n+\n+### Releasing your change to crates.io\n+\n+Now that you've done the amazing job of landing your new API or your new\n+platform in this crate, the next step is to get that sweet, sweet usage from\n+crates.io! The only next step is to bump the version of libc and then publish\n+it. If you'd like to get a release out ASAP you can follow these steps:\n+\n+1. Update the version number in `Cargo.toml`, you'll just be bumping the patch\n+   version number.\n+2. Run `cargo update` to regenerate the lockfile to encode your version bump in\n+   the lock file. You may pull in some other updated dependencies, that's ok.\n+3. Send a PR to this repository. It should [look like this][example], but it'd\n+   also be nice to fill out the description with a small rationale for the\n+   release (any rationale is ok though!)\n+4. Once merged the release will be tagged and published by one of the libc crate\n+   maintainers.\n+\n+[example]: https://github.com/rust-lang/libc/pull/583"
      },
      {
        "sha": "e48a34cdfe9a275c0a67549bdc1b2f35b7830fdd",
        "filename": "src/rusty/libc/Cargo.toml",
        "status": "added",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/Cargo.toml?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,35 @@\n+[package]\n+name = \"libc\"\n+version = \"0.2.64\"\n+authors = [\"The Rust Project Developers\"]\n+license = \"MIT OR Apache-2.0\"\n+readme = \"README.md\"\n+repository = \"https://github.com/rust-lang/libc\"\n+homepage = \"https://github.com/rust-lang/libc\"\n+documentation = \"http://doc.rust-lang.org/libc\"\n+keywords = [\"libc\", \"ffi\", \"bindings\", \"operating\", \"system\" ]\n+categories = [\"external-ffi-bindings\", \"no-std\", \"os\"]\n+build = \"build.rs\"\n+exclude = [\"/ci/*\", \"/azure-pipelines.yml\"]\n+description = \"\"\"\n+Raw FFI bindings to platform libraries like libc.\n+\"\"\"\n+\n+[badges]\n+travis-ci = { repository = \"rust-lang/libc\" }\n+appveyor = { repository = \"rust-lang/libc\", project_name = \"rust-lang-libs/libc\" }\n+\n+[dependencies]\n+rustc-std-workspace-core = { version = \"1.0.0\", optional = true }\n+\n+[features]\n+default = [\"std\"]\n+std = []\n+align = []\n+rustc-dep-of-std = ['align', 'rustc-std-workspace-core']\n+extra_traits = []\n+# use_std is deprecated, use `std` instead\n+use_std = [ 'std' ]\n+\n+[workspace]\n+members = [\"libc-test\"]"
      },
      {
        "sha": "16fe87b06e802f094b3fbb0894b137bca2b16ef1",
        "filename": "src/rusty/libc/LICENSE-APACHE",
        "status": "added",
        "additions": 201,
        "deletions": 0,
        "changes": 201,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/LICENSE-APACHE",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/LICENSE-APACHE",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/LICENSE-APACHE?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,201 @@\n+                              Apache License\n+                        Version 2.0, January 2004\n+                     http://www.apache.org/licenses/\n+\n+TERMS AND CONDITIONS FOR USE, REPRODUCTION, AND DISTRIBUTION\n+\n+1. Definitions.\n+\n+   \"License\" shall mean the terms and conditions for use, reproduction,\n+   and distribution as defined by Sections 1 through 9 of this document.\n+\n+   \"Licensor\" shall mean the copyright owner or entity authorized by\n+   the copyright owner that is granting the License.\n+\n+   \"Legal Entity\" shall mean the union of the acting entity and all\n+   other entities that control, are controlled by, or are under common\n+   control with that entity. For the purposes of this definition,\n+   \"control\" means (i) the power, direct or indirect, to cause the\n+   direction or management of such entity, whether by contract or\n+   otherwise, or (ii) ownership of fifty percent (50%) or more of the\n+   outstanding shares, or (iii) beneficial ownership of such entity.\n+\n+   \"You\" (or \"Your\") shall mean an individual or Legal Entity\n+   exercising permissions granted by this License.\n+\n+   \"Source\" form shall mean the preferred form for making modifications,\n+   including but not limited to software source code, documentation\n+   source, and configuration files.\n+\n+   \"Object\" form shall mean any form resulting from mechanical\n+   transformation or translation of a Source form, including but\n+   not limited to compiled object code, generated documentation,\n+   and conversions to other media types.\n+\n+   \"Work\" shall mean the work of authorship, whether in Source or\n+   Object form, made available under the License, as indicated by a\n+   copyright notice that is included in or attached to the work\n+   (an example is provided in the Appendix below).\n+\n+   \"Derivative Works\" shall mean any work, whether in Source or Object\n+   form, that is based on (or derived from) the Work and for which the\n+   editorial revisions, annotations, elaborations, or other modifications\n+   represent, as a whole, an original work of authorship. For the purposes\n+   of this License, Derivative Works shall not include works that remain\n+   separable from, or merely link (or bind by name) to the interfaces of,\n+   the Work and Derivative Works thereof.\n+\n+   \"Contribution\" shall mean any work of authorship, including\n+   the original version of the Work and any modifications or additions\n+   to that Work or Derivative Works thereof, that is intentionally\n+   submitted to Licensor for inclusion in the Work by the copyright owner\n+   or by an individual or Legal Entity authorized to submit on behalf of\n+   the copyright owner. For the purposes of this definition, \"submitted\"\n+   means any form of electronic, verbal, or written communication sent\n+   to the Licensor or its representatives, including but not limited to\n+   communication on electronic mailing lists, source code control systems,\n+   and issue tracking systems that are managed by, or on behalf of, the\n+   Licensor for the purpose of discussing and improving the Work, but\n+   excluding communication that is conspicuously marked or otherwise\n+   designated in writing by the copyright owner as \"Not a Contribution.\"\n+\n+   \"Contributor\" shall mean Licensor and any individual or Legal Entity\n+   on behalf of whom a Contribution has been received by Licensor and\n+   subsequently incorporated within the Work.\n+\n+2. Grant of Copyright License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   copyright license to reproduce, prepare Derivative Works of,\n+   publicly display, publicly perform, sublicense, and distribute the\n+   Work and such Derivative Works in Source or Object form.\n+\n+3. Grant of Patent License. Subject to the terms and conditions of\n+   this License, each Contributor hereby grants to You a perpetual,\n+   worldwide, non-exclusive, no-charge, royalty-free, irrevocable\n+   (except as stated in this section) patent license to make, have made,\n+   use, offer to sell, sell, import, and otherwise transfer the Work,\n+   where such license applies only to those patent claims licensable\n+   by such Contributor that are necessarily infringed by their\n+   Contribution(s) alone or by combination of their Contribution(s)\n+   with the Work to which such Contribution(s) was submitted. If You\n+   institute patent litigation against any entity (including a\n+   cross-claim or counterclaim in a lawsuit) alleging that the Work\n+   or a Contribution incorporated within the Work constitutes direct\n+   or contributory patent infringement, then any patent licenses\n+   granted to You under this License for that Work shall terminate\n+   as of the date such litigation is filed.\n+\n+4. Redistribution. You may reproduce and distribute copies of the\n+   Work or Derivative Works thereof in any medium, with or without\n+   modifications, and in Source or Object form, provided that You\n+   meet the following conditions:\n+\n+   (a) You must give any other recipients of the Work or\n+       Derivative Works a copy of this License; and\n+\n+   (b) You must cause any modified files to carry prominent notices\n+       stating that You changed the files; and\n+\n+   (c) You must retain, in the Source form of any Derivative Works\n+       that You distribute, all copyright, patent, trademark, and\n+       attribution notices from the Source form of the Work,\n+       excluding those notices that do not pertain to any part of\n+       the Derivative Works; and\n+\n+   (d) If the Work includes a \"NOTICE\" text file as part of its\n+       distribution, then any Derivative Works that You distribute must\n+       include a readable copy of the attribution notices contained\n+       within such NOTICE file, excluding those notices that do not\n+       pertain to any part of the Derivative Works, in at least one\n+       of the following places: within a NOTICE text file distributed\n+       as part of the Derivative Works; within the Source form or\n+       documentation, if provided along with the Derivative Works; or,\n+       within a display generated by the Derivative Works, if and\n+       wherever such third-party notices normally appear. The contents\n+       of the NOTICE file are for informational purposes only and\n+       do not modify the License. You may add Your own attribution\n+       notices within Derivative Works that You distribute, alongside\n+       or as an addendum to the NOTICE text from the Work, provided\n+       that such additional attribution notices cannot be construed\n+       as modifying the License.\n+\n+   You may add Your own copyright statement to Your modifications and\n+   may provide additional or different license terms and conditions\n+   for use, reproduction, or distribution of Your modifications, or\n+   for any such Derivative Works as a whole, provided Your use,\n+   reproduction, and distribution of the Work otherwise complies with\n+   the conditions stated in this License.\n+\n+5. Submission of Contributions. Unless You explicitly state otherwise,\n+   any Contribution intentionally submitted for inclusion in the Work\n+   by You to the Licensor shall be under the terms and conditions of\n+   this License, without any additional terms or conditions.\n+   Notwithstanding the above, nothing herein shall supersede or modify\n+   the terms of any separate license agreement you may have executed\n+   with Licensor regarding such Contributions.\n+\n+6. Trademarks. This License does not grant permission to use the trade\n+   names, trademarks, service marks, or product names of the Licensor,\n+   except as required for reasonable and customary use in describing the\n+   origin of the Work and reproducing the content of the NOTICE file.\n+\n+7. Disclaimer of Warranty. Unless required by applicable law or\n+   agreed to in writing, Licensor provides the Work (and each\n+   Contributor provides its Contributions) on an \"AS IS\" BASIS,\n+   WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or\n+   implied, including, without limitation, any warranties or conditions\n+   of TITLE, NON-INFRINGEMENT, MERCHANTABILITY, or FITNESS FOR A\n+   PARTICULAR PURPOSE. You are solely responsible for determining the\n+   appropriateness of using or redistributing the Work and assume any\n+   risks associated with Your exercise of permissions under this License.\n+\n+8. Limitation of Liability. In no event and under no legal theory,\n+   whether in tort (including negligence), contract, or otherwise,\n+   unless required by applicable law (such as deliberate and grossly\n+   negligent acts) or agreed to in writing, shall any Contributor be\n+   liable to You for damages, including any direct, indirect, special,\n+   incidental, or consequential damages of any character arising as a\n+   result of this License or out of the use or inability to use the\n+   Work (including but not limited to damages for loss of goodwill,\n+   work stoppage, computer failure or malfunction, or any and all\n+   other commercial damages or losses), even if such Contributor\n+   has been advised of the possibility of such damages.\n+\n+9. Accepting Warranty or Additional Liability. While redistributing\n+   the Work or Derivative Works thereof, You may choose to offer,\n+   and charge a fee for, acceptance of support, warranty, indemnity,\n+   or other liability obligations and/or rights consistent with this\n+   License. However, in accepting such obligations, You may act only\n+   on Your own behalf and on Your sole responsibility, not on behalf\n+   of any other Contributor, and only if You agree to indemnify,\n+   defend, and hold each Contributor harmless for any liability\n+   incurred by, or claims asserted against, such Contributor by reason\n+   of your accepting any such warranty or additional liability.\n+\n+END OF TERMS AND CONDITIONS\n+\n+APPENDIX: How to apply the Apache License to your work.\n+\n+   To apply the Apache License to your work, attach the following\n+   boilerplate notice, with the fields enclosed by brackets \"[]\"\n+   replaced with your own identifying information. (Don't include\n+   the brackets!)  The text should be enclosed in the appropriate\n+   comment syntax for the file format. We also recommend that a\n+   file or class name and description of purpose be included on the\n+   same \"printed page\" as the copyright notice for easier\n+   identification within third-party archives.\n+\n+Copyright [yyyy] [name of copyright owner]\n+\n+Licensed under the Apache License, Version 2.0 (the \"License\");\n+you may not use this file except in compliance with the License.\n+You may obtain a copy of the License at\n+\n+\thttp://www.apache.org/licenses/LICENSE-2.0\n+\n+Unless required by applicable law or agreed to in writing, software\n+distributed under the License is distributed on an \"AS IS\" BASIS,\n+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n+See the License for the specific language governing permissions and\n+limitations under the License."
      },
      {
        "sha": "39d4bdb5acd313c1a92dbeaa1c379aaf0596a315",
        "filename": "src/rusty/libc/LICENSE-MIT",
        "status": "added",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/LICENSE-MIT",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/LICENSE-MIT",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/LICENSE-MIT?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,25 @@\n+Copyright (c) 2014 The Rust Project Developers\n+\n+Permission is hereby granted, free of charge, to any\n+person obtaining a copy of this software and associated\n+documentation files (the \"Software\"), to deal in the\n+Software without restriction, including without\n+limitation the rights to use, copy, modify, merge,\n+publish, distribute, sublicense, and/or sell copies of\n+the Software, and to permit persons to whom the Software\n+is furnished to do so, subject to the following\n+conditions:\n+\n+The above copyright notice and this permission notice\n+shall be included in all copies or substantial portions\n+of the Software.\n+\n+THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF\n+ANY KIND, EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED\n+TO THE WARRANTIES OF MERCHANTABILITY, FITNESS FOR A\n+PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT\n+SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY\n+CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION\n+OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR\n+IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER\n+DEALINGS IN THE SOFTWARE."
      },
      {
        "sha": "4b860238bc11e681a3b2973936cd973e7c3011af",
        "filename": "src/rusty/libc/README.md",
        "status": "added",
        "additions": 103,
        "deletions": 0,
        "changes": 103,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/README.md?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,103 @@\n+[![Azure Status]][Azure] [![Cirrus-CI Status]][Cirrus-CI] [![Latest Version]][crates.io] [![Documentation]][docs.rs] ![License]\n+\n+libc - Raw FFI bindings to platforms' system libraries\n+====\n+\n+`libc` provides all of the definitions necessary to easily interoperate with C\n+code (or \"C-like\" code) on each of the platforms that Rust supports. This\n+includes type definitions (e.g. `c_int`), constants (e.g. `EINVAL`) as well as\n+function headers (e.g. `malloc`).\n+\n+This crate exports all underlying platform types, functions, and constants under\n+the crate root, so all items are accessible as `libc::foo`. The types and values\n+of all the exported APIs match the platform that libc is compiled for.\n+\n+More detailed information about the design of this library can be found in its\n+[associated RFC][rfc].\n+\n+[rfc]: https://github.com/rust-lang/rfcs/blob/master/text/1291-promote-libc.md\n+\n+## Usage\n+\n+Add the following to your `Cargo.toml`:\n+\n+```toml\n+[dependencies]\n+libc = \"0.2\"\n+```\n+\n+## Features\n+\n+* `std`: by default `libc` links to the standard library. Disable this\n+  feature remove this dependency and be able to use `libc` in `#![no_std]`\n+  crates.\n+\n+* `extra_traits`: all `struct`s implemented in `libc` are `Copy` and `Clone`.\n+  This feature derives `Debug`, `Eq`, `Hash`, and `PartialEq`.\n+\n+* **deprecated**: `use_std` is deprecated, and is equivalent to `std`.\n+\n+## Rust version support\n+\n+The minimum supported Rust toolchain version is **Rust 1.13.0** . APIs requiring\n+newer Rust features are only available on newer Rust toolchains:\n+\n+| Feature              | Version |\n+|----------------------|---------|\n+| `union`              |  1.19.0 |\n+| `const mem::size_of` |  1.24.0 |\n+| `repr(align)`        |  1.25.0 |\n+| `extra_traits`      |  1.25.0 |\n+| `core::ffi::c_void`  |  1.30.0 |\n+| `repr(packed(N))` |  1.33.0 |\n+\n+## Platform support\n+\n+[Platform-specific documentation (master branch)][docs.master].\n+\n+See\n+[`ci/build.sh`](https://github.com/rust-lang/libc/blob/master/ci/build.sh)\n+for the platforms on which `libc` is guaranteed to build for each Rust\n+toolchain. The test-matrix at [Travis-CI], [Appveyor], and [Cirrus-CI] show the\n+platforms in which `libc` tests are run.\n+\n+<div class=\"platform_docs\"></div>\n+\n+## License\n+\n+This project is licensed under either of\n+\n+* [Apache License, Version 2.0](http://www.apache.org/licenses/LICENSE-2.0)\n+  ([LICENSE-APACHE](LICENSE-APACHE))\n+\n+* [MIT License](http://opensource.org/licenses/MIT)\n+  ([LICENSE-MIT](LICENSE-MIT))\n+\n+at your option.\n+\n+## Contributing\n+\n+We welcome all people who want to contribute. Please see the [contributing\n+instructions] for more information.\n+\n+[contributing instructions]: CONTRIBUTING.md\n+\n+Contributions in any form (issues, pull requests, etc.) to this project\n+must adhere to Rust's [Code of Conduct].\n+\n+[Code of Conduct]: https://www.rust-lang.org/en-US/conduct.html\n+\n+Unless you explicitly state otherwise, any contribution intentionally submitted\n+for inclusion in `libc` by you, as defined in the Apache-2.0 license, shall be\n+dual licensed as above, without any additional terms or conditions.\n+\n+[Azure Status]: https://dev.azure.com/rust-lang2/libc/_apis/build/status/rust-lang.libc?branchName=master\n+[Azure]: https://dev.azure.com/rust-lang2/libc/_build/latest?definitionId=1&branchName=master\n+[Cirrus-CI]: https://cirrus-ci.com/github/rust-lang/libc\n+[Cirrus-CI Status]: https://api.cirrus-ci.com/github/rust-lang/libc.svg\n+[crates.io]: https://crates.io/crates/libc\n+[Latest Version]: https://img.shields.io/crates/v/libc.svg\n+[Documentation]: https://docs.rs/libc/badge.svg\n+[docs.rs]: https://docs.rs/libc\n+[License]: https://img.shields.io/crates/l/libc.svg\n+[docs.master]: https://rust-lang.github.io/libc/#platform-specific-documentation"
      },
      {
        "sha": "d5bcb5253a4c88453c701ce355fd36fb38cd0e9e",
        "filename": "src/rusty/libc/build.rs",
        "status": "added",
        "additions": 122,
        "deletions": 0,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/build.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/build.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/build.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,122 @@\n+use std::env;\n+use std::process::Command;\n+use std::str;\n+\n+fn main() {\n+    let rustc_minor_ver =\n+        rustc_minor_version().expect(\"Failed to get rustc version\");\n+    let rustc_dep_of_std = env::var(\"CARGO_FEATURE_RUSTC_DEP_OF_STD\").is_ok();\n+    let align_cargo_feature = env::var(\"CARGO_FEATURE_ALIGN\").is_ok();\n+    let libc_ci = env::var(\"LIBC_CI\").is_ok();\n+\n+    if env::var(\"CARGO_FEATURE_USE_STD\").is_ok() {\n+        println!(\n+            \"cargo:warning=\\\"libc's use_std cargo feature is deprecated since libc 0.2.55; \\\n+             please consider using the `std` cargo feature instead\\\"\"\n+        );\n+    }\n+\n+    // The ABI of libc used by libstd is backward compatible with FreeBSD 10.\n+    // The ABI of libc from crates.io is backward compatible with FreeBSD 11.\n+    //\n+    // On CI, we detect the actual FreeBSD version and match its ABI exactly,\n+    // running tests to ensure that the ABI is correct.\n+    match which_freebsd() {\n+        Some(10) if libc_ci || rustc_dep_of_std => {\n+            println!(\"cargo:rustc-cfg=freebsd10\")\n+        }\n+        Some(11) if libc_ci => println!(\"cargo:rustc-cfg=freebsd11\"),\n+        Some(12) if libc_ci => println!(\"cargo:rustc-cfg=freebsd12\"),\n+        Some(13) if libc_ci => println!(\"cargo:rustc-cfg=freebsd13\"),\n+        Some(_) | None => println!(\"cargo:rustc-cfg=freebsd11\"),\n+    }\n+\n+    // On CI: deny all warnings\n+    if libc_ci {\n+        println!(\"cargo:rustc-cfg=libc_deny_warnings\");\n+    }\n+\n+    // Rust >= 1.15 supports private module use:\n+    if rustc_minor_ver >= 15 || rustc_dep_of_std {\n+        println!(\"cargo:rustc-cfg=libc_priv_mod_use\");\n+    }\n+\n+    // Rust >= 1.19 supports unions:\n+    if rustc_minor_ver >= 19 || rustc_dep_of_std {\n+        println!(\"cargo:rustc-cfg=libc_union\");\n+    }\n+\n+    // Rust >= 1.24 supports const mem::size_of:\n+    if rustc_minor_ver >= 24 || rustc_dep_of_std {\n+        println!(\"cargo:rustc-cfg=libc_const_size_of\");\n+    }\n+\n+    // Rust >= 1.25 supports repr(align):\n+    if rustc_minor_ver >= 25 || rustc_dep_of_std || align_cargo_feature {\n+        println!(\"cargo:rustc-cfg=libc_align\");\n+    }\n+\n+    // Rust >= 1.30 supports `core::ffi::c_void`, so libc can just re-export it.\n+    // Otherwise, it defines an incompatible type to retaining\n+    // backwards-compatibility.\n+    if rustc_minor_ver >= 30 || rustc_dep_of_std {\n+        println!(\"cargo:rustc-cfg=libc_core_cvoid\");\n+    }\n+\n+    // Rust >= 1.33 supports repr(packed(N))\n+    if rustc_minor_ver >= 33 || rustc_dep_of_std {\n+        println!(\"cargo:rustc-cfg=libc_packedN\");\n+    }\n+\n+    // #[thread_local] is currently unstable\n+    if rustc_dep_of_std {\n+        println!(\"cargo:rustc-cfg=libc_thread_local\");\n+    }\n+}\n+\n+fn rustc_minor_version() -> Option<u32> {\n+    macro_rules! otry {\n+        ($e:expr) => {\n+            match $e {\n+                Some(e) => e,\n+                None => return None,\n+            }\n+        };\n+    }\n+\n+    let rustc = otry!(env::var_os(\"RUSTC\"));\n+    let output = otry!(Command::new(rustc).arg(\"--version\").output().ok());\n+    let version = otry!(str::from_utf8(&output.stdout).ok());\n+    let mut pieces = version.split('.');\n+\n+    if pieces.next() != Some(\"rustc 1\") {\n+        return None;\n+    }\n+\n+    otry!(pieces.next()).parse().ok()\n+}\n+\n+fn which_freebsd() -> Option<i32> {\n+    let output = std::process::Command::new(\"freebsd-version\").output().ok();\n+    if output.is_none() {\n+        return None;\n+    }\n+    let output = output.unwrap();\n+    if !output.status.success() {\n+        return None;\n+    }\n+\n+    let stdout = String::from_utf8(output.stdout).ok();\n+    if stdout.is_none() {\n+        return None;\n+    }\n+    let stdout = stdout.unwrap();\n+\n+    match &stdout {\n+        s if s.starts_with(\"10\") => Some(10),\n+        s if s.starts_with(\"11\") => Some(11),\n+        s if s.starts_with(\"12\") => Some(12),\n+        s if s.starts_with(\"13\") => Some(13),\n+        _ => None,\n+    }\n+}"
      },
      {
        "sha": "31235538071f84d2f15c6252f2d10ee3998917e2",
        "filename": "src/rusty/libc/ci/README.md",
        "status": "added",
        "additions": 236,
        "deletions": 0,
        "changes": 236,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/README.md?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,236 @@\n+The goal of the libc crate is to have CI running everywhere to have the\n+strongest guarantees about the definitions that this library contains, and as a\n+result the CI is pretty complicated and also pretty large! Hopefully this can\n+serve as a guide through the sea of scripts in this directory and elsewhere in\n+this project.\n+\n+# Files\n+\n+First up, let's talk about the files in this directory:\n+\n+* `run-docker.sh` - a shell script run by most builders, it will execute\n+  `run.sh` inside a Docker container configured for the target.\n+\n+* `run.sh` - the actual script which runs tests for a particular architecture.\n+\n+* `dox.sh` - build the documentation of the crate and publish it to gh-pages.\n+\n+* `landing-page-*.html` - used by `dox.sh` to generate a landing page for all\n+  architectures' documentation.\n+\n+* `run-qemu.sh` - see discussion about QEMU below\n+\n+* `mips`, `rumprun` - instructions to build the docker image for each respective\n+  CI target\n+\n+# CI Systems\n+\n+Currently this repository leverages a combination of Travis CI and AppVeyor for\n+running tests. The triples tested are:\n+\n+* AppVeyor\n+  * `{i686,x86_64}-pc-windows-{msvc,gnu}`\n+* Travis\n+  * `{i686,x86_64,mips,aarch64}-unknown-linux-gnu`\n+  * `{x86_64,aarch64}-unknown-linux-musl`\n+  * `arm-unknown-linux-gnueabihf`\n+  * `arm-linux-androideabi`\n+  * `{i686,x86_64}-apple-{darwin,ios}`\n+  * `x86_64-rumprun-netbsd`\n+  * `x86_64-unknown-freebsd`\n+  * `x86_64-unknown-openbsd`\n+\n+The Windows triples are all pretty standard, they just set up their environment\n+then run tests, no need for downloading any extra target libs (we just download\n+the right installer). The Intel Linux/OSX builds are similar in that we just\n+download the right target libs and run tests. Note that the Intel Linux/OSX\n+builds are run on stable/beta/nightly, but are the only ones that do so.\n+\n+The remaining architectures look like:\n+\n+* Android runs in a [docker image][android-docker] with an emulator, the NDK,\n+  and the SDK already set up. The entire build happens within the docker image.\n+* The MIPS, ARM, and AArch64 builds all use the QEMU userspace emulator to run\n+  the generated binary to actually verify the tests pass.\n+* The MUSL build just has to download a MUSL compiler and target libraries and\n+  then otherwise runs tests normally.\n+* iOS builds need an extra linker flag currently, but beyond that they're built\n+  as standard as everything else.\n+* The rumprun target builds an entire kernel from the test suite and then runs\n+  it inside QEMU using the serial console to test whether it succeeded or\n+  failed.\n+* The BSD builds, currently OpenBSD and FreeBSD, use QEMU to boot up a system\n+  and compile/run tests. More information on that below.\n+\n+[android-docker]: https://github.com/rust-lang/rust-buildbot/blob/master/slaves/android/Dockerfile\n+\n+## QEMU\n+\n+Lots of the architectures tested here use QEMU in the tests, so it's worth going\n+over all the crazy capabilities QEMU has and the various flavors in which we use\n+it!\n+\n+First up, QEMU has userspace emulation where it doesn't boot a full kernel, it\n+just runs a binary from another architecture (using the `qemu-<arch>` wrappers).\n+We provide it the runtime path for the dynamically loaded system libraries,\n+however. This strategy is used for all Linux architectures that aren't intel.\n+Note that one downside of this QEMU system is that threads are barely\n+implemented, so we're careful to not spawn many threads.\n+\n+For the rumprun target the only output is a kernel image, so we just use that\n+plus the `rumpbake` command to create a full kernel image which is then run from\n+within QEMU.\n+\n+Finally, the fun part, the BSDs. Quite a few hoops are jumped through to get CI\n+working for these platforms, but the gist of it looks like:\n+\n+* Cross compiling from Linux to any of the BSDs seems to be quite non-standard.\n+  We may be able to get it working but it might be difficult at that point to\n+  ensure that the libc definitions align with what you'd get on the BSD itself.\n+  As a result, we try to do compiles within the BSD distro.\n+* On Travis we can't run a VM-in-a-VM, so we resort to userspace emulation\n+  (QEMU).\n+* Unfortunately on Travis we also can't use KVM, so the emulation is super slow.\n+\n+With all that in mind, the way BSD is tested looks like:\n+\n+1. Download a pre-prepared image for the OS being tested.\n+2. Generate the tests for the OS being tested. This involves running the `ctest`\n+   library over libc to generate a Rust file and a C file which will then be\n+   compiled into the final test.\n+3. Generate a disk image which will later be mounted by the OS being tested.\n+   This image is mostly just the libc directory, but some modifications are made\n+   to compile the generated files from step 2.\n+4. The kernel is booted in QEMU, and it is configured to detect the libc-test\n+   image being available, run the test script, and then shut down afterwards.\n+5. Look for whether the tests passed in the serial console output of the kernel.\n+\n+There's some pretty specific instructions for setting up each image (detailed\n+below), but the main gist of this is that we must avoid a vanilla `cargo run`\n+inside of the `libc-test` directory (which is what it's intended for) because\n+that would compile `syntex_syntax`, a large library, with userspace emulation.\n+This invariably times out on Travis, so we can't do that.\n+\n+Once all those hoops are jumped through, however, we can be happy that we're\n+testing almost everything!\n+\n+Below are some details of how to set up the initial OS images which are\n+downloaded. Each image must be enabled have input/output over the serial\n+console, log in automatically at the serial console, detect if a second drive in\n+QEMU is available, and if so mount it, run a script (it'll specifically be\n+`run-qemu.sh` in this folder which is copied into the generated image talked\n+about above), and then shut down.\n+\n+### QEMU Setup - FreeBSD\n+\n+1. [Download the latest stable amd64-bootonly release ISO](https://www.freebsd.org/where.html).\n+   E.g. FreeBSD-11.1-RELEASE-amd64-bootonly.iso\n+2. Create the disk image: `qemu-img create -f qcow2 FreeBSD-11.1-RELEASE-amd64.qcow2 2G`\n+3. Boot the machine: `qemu-system-x86_64 -cdrom FreeBSD-11.1-RELEASE-amd64-bootonly.iso -drive if=virtio,file=FreeBSD-11.1-RELEASE-amd64.qcow2 -net nic,model=virtio -net user`\n+4. Run the installer, and install FreeBSD:\n+   1. Install\n+   1. Continue with default keymap\n+   1. Set Hostname: freebsd-ci\n+   1. Distribution Select:\n+      1. Uncheck lib32\n+      1. Uncheck ports\n+   1. Network Configuration: vtnet0\n+   1. Configure IPv4? Yes\n+   1. DHCP? Yes\n+   1. Configure IPv6? No\n+   1. Resolver Configuration: Ok\n+   1. Mirror Selection: Main Site\n+   1. Partitioning: Auto (UFS)\n+   1. Partition: Entire Disk\n+   1. Partition Scheme: MBR\n+   1. App Partition: Ok\n+   1. Partition Editor: Finish\n+   1. Confirmation: Commit\n+   1. Wait for sets to install\n+   1. Set the root password to nothing (press enter twice)\n+   1. Set time zone to UTC\n+   1. Set Date: Skip\n+   1. Set Time: Skip\n+   1. System Configuration:\n+      1. Disable sshd\n+      1. Disable dumpdev\n+   1. System Hardening\n+      1. Disable Sendmail service\n+   1. Add User Accounts: No\n+   1. Final Configuration: Exit\n+   1. Manual Configuration: Yes\n+   1. `echo 'console=\"comconsole\"' >> /boot/loader.conf`\n+   1. `echo 'autoboot_delay=\"0\"' >> /boot/loader.conf`\n+   1. `echo 'ext2fs_load=\"YES\"' >> /boot/loader.conf`\n+   1. Look at `/etc/ttys`, see what getty argument is for `ttyu0` (E.g. `3wire`)\n+   1. Edit `/etc/gettytab` (with `vi` for example), look for `ttyu0` argument,\n+      prepend `:al=root` to the line beneath to have the machine auto-login as\n+      root. E.g.\n+\n+          3wire:\\\n+                   :np:nc:sp#0:\n+      becomes:\n+\n+          3wire:\\\n+                   :al=root:np:nc:sp#0:\n+\n+   1. Edit `/root/.login` and put this in it:\n+\n+          [ -e /dev/vtbd1 ] || exit 0\n+          mount -t ext2fs /dev/vtbd1 /mnt\n+          sh /mnt/run.sh /mnt\n+          poweroff\n+\n+   1. Exit the post install shell: `exit`\n+   1. Back in in the installer choose Reboot\n+   1. If all went well the machine should reboot and show a login prompt.\n+      If you switch to the serial console by choosing View > serial0 in\n+      the qemu menu, you should be logged in as root.\n+   1. Shutdown the machine: `shutdown -p now`\n+\n+Helpful links\n+\n+* https://en.wikibooks.org/wiki/QEMU/Images\n+* https://blog.nekoconeko.nl/blog/2015/06/04/creating-an-openstack-freebsd-image.html\n+* https://www.freebsd.org/doc/handbook/serialconsole-setup.html\n+\n+\n+### QEMU setup - OpenBSD\n+\n+1. Download CD installer\n+2. `qemu-img create -f qcow2 foo.qcow2 2G`\n+3. `qemu -cdrom foo.iso -drive if=virtio,file=foo.qcow2 -net nic,model=virtio -net user`\n+4. run installer\n+5. `echo 'set tty com0' >> /etc/boot.conf`\n+6. `echo 'boot' >> /etc/boot.conf`\n+7. Modify /etc/ttys, change the `tty00` at the end from 'unknown off' to\n+   'vt220 on secure'\n+8. Modify same line in /etc/ttys to have `\"/root/foo.sh\"` as the shell\n+9. Add this script to `/root/foo.sh`\n+\n+```\n+#!/bin/sh\n+exec 1>/dev/tty00\n+exec 2>&1\n+\n+if mount -t ext2fs /dev/sd1c /mnt; then\n+  sh /mnt/run.sh /mnt\n+  shutdown -ph now\n+fi\n+\n+# limited shell...\n+exec /bin/sh < /dev/tty00\n+```\n+\n+10. `chmod +x /root/foo.sh`\n+\n+Helpful links:\n+\n+* https://en.wikibooks.org/wiki/QEMU/Images\n+* http://www.openbsd.org/faq/faq7.html#SerCon\n+\n+# Questions?\n+\n+Hopefully that's at least somewhat of an introduction to everything going on\n+here, and feel free to ping @alexcrichton with questions!\n+"
      },
      {
        "sha": "723e719054a14ceb6b318e1bdeebc83f3820aba0",
        "filename": "src/rusty/libc/ci/android-install-ndk.sh",
        "status": "added",
        "additions": 50,
        "deletions": 0,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/android-install-ndk.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/android-install-ndk.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/android-install-ndk.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,50 @@\n+#!/usr/bin/env sh\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+NDK=android-ndk-r19c\n+curl --retry 20 -O https://dl.google.com/android/repository/${NDK}-linux-x86_64.zip\n+unzip -q ${NDK}-linux-x86_64.zip\n+\n+case \"$1\" in\n+  arm)\n+    arch=arm\n+    api=24\n+    ;;\n+  armv7)\n+    arch=arm\n+    api=24\n+    ;;\n+  aarch64)\n+    arch=arm64\n+    api=24\n+    ;;\n+  i686)\n+    arch=x86\n+    api=28\n+    ;;\n+  x86_64)\n+    arch=x86_64\n+    api=28\n+    ;;\n+  *)\n+    echo \"invalid arch: $1\"\n+    exit 1\n+    ;;\n+esac;\n+\n+${NDK}/build/tools/make_standalone_toolchain.py \\\n+        --install-dir \"/android/ndk-${1}\" \\\n+        --arch \"${arch}\" \\\n+        --api ${api}\n+\n+rm -rf ./${NDK}-linux-x86_64.zip ./${NDK}"
      },
      {
        "sha": "7f2104000fdefc8911f346e9b75bf07dbdcc72b8",
        "filename": "src/rusty/libc/ci/android-install-sdk.sh",
        "status": "added",
        "additions": 73,
        "deletions": 0,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/android-install-sdk.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/android-install-sdk.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/android-install-sdk.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,73 @@\n+#!/usr/bin/env sh\n+# Copyright 2016 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+# Prep the SDK and emulator\n+#\n+# Note that the update process requires that we accept a bunch of licenses, and\n+# we can't just pipe `yes` into it for some reason, so we take the same strategy\n+# located in https://github.com/appunite/docker by just wrapping it in a script\n+# which apparently magically accepts the licenses.\n+\n+SDK=4333796\n+mkdir sdk\n+curl --retry 20 https://dl.google.com/android/repository/sdk-tools-linux-${SDK}.zip -O\n+unzip -q -d sdk sdk-tools-linux-${SDK}.zip\n+\n+case \"$1\" in\n+  arm | armv7)\n+    api=24\n+    image=\"system-images;android-${api};google_apis;armeabi-v7a\"\n+    ;;\n+  aarch64)\n+    api=24\n+    image=\"system-images;android-${api};google_apis;arm64-v8a\"\n+    ;;\n+  i686)\n+    api=28\n+    image=\"system-images;android-${api};default;x86\"\n+    ;;\n+  x86_64)\n+    api=28\n+    image=\"system-images;android-${api};default;x86_64\"\n+    ;;\n+  *)\n+    echo \"invalid arch: $1\"\n+    exit 1\n+    ;;\n+esac;\n+\n+# Try to fix warning about missing file.\n+# See https://askubuntu.com/a/1078784\n+mkdir -p /root/.android/\n+echo '### User Sources for Android SDK Manager' >> /root/.android/repositories.cfg\n+echo '#Fri Nov 03 10:11:27 CET 2017 count=0' >> /root/.android/repositories.cfg\n+\n+# Print all available packages\n+# yes | ./sdk/tools/bin/sdkmanager --list --verbose\n+\n+# --no_https avoids\n+# javax.net.ssl.SSLHandshakeException: sun.security.validator.ValidatorException: No trusted certificate found\n+#\n+# | grep -v = || true    removes the progress bar output from the sdkmanager\n+# which produces an insane amount of output.\n+yes | ./sdk/tools/bin/sdkmanager --licenses --no_https | grep -v = || true\n+yes | ./sdk/tools/bin/sdkmanager --no_https \\\n+        \"emulator\" \\\n+        \"platform-tools\" \\\n+        \"platforms;android-${api}\" \\\n+        \"${image}\" | grep -v = || true\n+\n+echo \"no\" |\n+    ./sdk/tools/bin/avdmanager create avd \\\n+        --name \"${1}\" \\\n+        --package \"${image}\" | grep -v = || true"
      },
      {
        "sha": "9eabd7c8d94f1021e36a39633e7da75e63778c3c",
        "filename": "src/rusty/libc/ci/android-sysimage.sh",
        "status": "added",
        "additions": 56,
        "deletions": 0,
        "changes": 56,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/android-sysimage.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/android-sysimage.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/android-sysimage.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,56 @@\n+#!/usr/bin/env bash\n+\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+URL=https://dl.google.com/android/repository/sys-img/android\n+\n+main() {\n+    local arch=\"${1}\"\n+    local name=\"${2}\"\n+    local dest=/system\n+    local td\n+    td=\"$(mktemp -d)\"\n+\n+    apt-get install --no-install-recommends e2tools\n+\n+    pushd \"${td}\"\n+    curl --retry 5 -O \"${URL}/${name}\"\n+    unzip -q \"${name}\"\n+\n+    local system\n+    system=\"$(find . -name system.img)\"\n+    mkdir -p ${dest}/{bin,lib,lib64}\n+\n+    # Extract android linker and libraries to /system\n+    # This allows android executables to be run directly (or with qemu)\n+    if [ \"${arch}\" = \"x86_64\" ] || [ \"${arch}\" = \"arm64\" ]; then\n+        e2cp -p \"${system}:/bin/linker64\" \"${dest}/bin/\"\n+        e2cp -p \"${system}:/lib64/libdl.so\" \"${dest}/lib64/\"\n+        e2cp -p \"${system}:/lib64/libc.so\" \"${dest}/lib64/\"\n+        e2cp -p \"${system}:/lib64/libm.so\" \"${dest}/lib64/\"\n+    else\n+        e2cp -p \"${system}:/bin/linker\" \"${dest}/bin/\"\n+        e2cp -p \"${system}:/lib/libdl.so\" \"${dest}/lib/\"\n+        e2cp -p \"${system}:/lib/libc.so\" \"${dest}/lib/\"\n+        e2cp -p \"${system}:/lib/libm.so\" \"${dest}/lib/\"\n+    fi\n+\n+    # clean up\n+    apt-get purge --auto-remove -y e2tools\n+\n+    popd\n+\n+    rm -rf \"${td}\"\n+}\n+\n+main \"${@}\""
      },
      {
        "sha": "87a41ec57d5f13f1ff47bd7804dafc3ef9260451",
        "filename": "src/rusty/libc/ci/azure-install-rust.yml",
        "status": "added",
        "additions": 78,
        "deletions": 0,
        "changes": 78,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/azure-install-rust.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/azure-install-rust.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/azure-install-rust.yml?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,78 @@\n+steps:\n+  - bash: |\n+      set -ex\n+      toolchain=$TOOLCHAIN\n+      if [ \"$toolchain\" = \"\" ]; then\n+        toolchain=nightly\n+      fi\n+      if command -v rustup; then\n+        rustup update $toolchain\n+        rustup default $toolchain\n+      else\n+        curl https://sh.rustup.rs -sSf | sh -s -- -y --default-toolchain $toolchain\n+        echo \"##vso[task.prependpath]$HOME/.cargo/bin\"\n+      fi\n+    displayName: Install rust (unix)\n+    condition: ne( variables['Agent.OS'], 'Windows_NT' )\n+  - script: |\n+      @echo on\n+      if not defined TOOLCHAIN set TOOLCHAIN=nightly\n+      rustup update --no-self-update %TOOLCHAIN%-%TARGET%\n+      rustup default %TOOLCHAIN%-%TARGET%\n+    displayName: Install rust (windows)\n+    condition: eq( variables['Agent.OS'], 'Windows_NT' )\n+  - script: |\n+      set -ex\n+      if [ -n \"${TARGET}\" ]; then\n+        rustup target add $TARGET\n+      fi\n+    condition: ne( variables['Agent.OS'], 'Windows_NT' )\n+    displayName: Install target (unix)\n+  - script: |\n+      @echo on\n+      if defined TARGET rustup target add %TARGET%\n+    condition: eq( variables['Agent.OS'], 'Windows_NT' )\n+    displayName: Install target (windows)\n+  - script: |\n+      @echo on\n+      if \"%ARCH%\" == \"i686\" choco install mingw --x86 --force\n+    condition: eq( variables['Agent.OS'], 'Windows_NT' )\n+    displayName: Install MinGW32 (windows)\n+  - bash: |\n+      set -ex\n+      gcc -print-search-dirs\n+      find \"C:\\ProgramData\\Chocolatey\" -name \"crt2*\"\n+      find \"C:\\ProgramData\\Chocolatey\" -name \"dllcrt2*\"\n+      find \"C:\\ProgramData\\Chocolatey\" -name \"libmsvcrt*\"\n+    condition: eq( variables['Agent.OS'], 'Windows_NT' )\t\n+    displayName: Find GCC libraries (windows)\n+  - bash: |\n+      set -ex\n+      if [[ -n ${ARCH_BITS} ]]; then\n+        for i in crt2.o dllcrt2.o libmingwex.a libmsvcrt.a ; do\n+          cp -f \"/C/ProgramData/Chocolatey/lib/mingw/tools/install/mingw${ARCH_BITS}/${ARCH}-w64-mingw32/lib/$i\" \"`rustc --print sysroot`/lib/rustlib/${TARGET}/lib\"\n+        done\n+      fi\n+    condition: eq( variables['Agent.OS'], 'Windows_NT' )\t\n+    displayName: Fix MinGW (windows)\n+  - bash: |\n+        set -ex\n+        rustc -Vv\n+        cargo -V\n+        rustup -Vv\n+        rustup show\n+        which rustc\n+        which cargo\n+        which rustup\n+    displayName: Query rust and cargo versions\n+  - script: |\n+      @echo on\n+      where gcc\n+    condition: eq( variables['Agent.OS'], 'Windows_NT' )\n+    displayName: Query gcc path\n+  - bash: |\n+      set -ex\n+      cargo generate-lockfile\n+      cargo generate-lockfile --manifest-path libc-test/Cargo.toml\n+    displayName: Generate lockfiles\n+"
      },
      {
        "sha": "97f13c9da35791abc794ca67c6a866cb979675f8",
        "filename": "src/rusty/libc/ci/azure.yml",
        "status": "added",
        "additions": 222,
        "deletions": 0,
        "changes": 222,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/azure.yml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/azure.yml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/azure.yml?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,222 @@\n+variables:\n+  - group: secrets\n+resources:\n+  repositories:\n+    - repository: rustinfra\n+      type: github\n+      name: rust-lang/simpleinfra\n+      endpoint: gnzlbg\n+trigger: [\"auto-libc\",\"try\"]\n+pr: [\"master\"]\n+\n+jobs:\n+  - job: DockerLinuxTier1\n+    pool:\n+      vmImage: ubuntu-16.04\n+    steps:\n+      - template: azure-install-rust.yml\n+      - bash: LIBC_CI=1 sh ./ci/run-docker.sh $TARGET\n+        displayName: Execute run-docker.sh\n+    strategy:\n+      matrix:\n+        i686-unknown-linux-gnu:\n+          TARGET: i686-unknown-linux-gnu\n+        x86_64-unknown-linux-gnu:\n+          TARGET: x86_64-unknown-linux-gnu\n+\n+  - job: DockerLinuxTier2\n+    #dependsOn: DockerLinuxTier1\n+    pool:\n+      vmImage: ubuntu-16.04\n+    steps:\n+      - template: azure-install-rust.yml\n+      - bash: LIBC_CI=1 sh ./ci/run-docker.sh $TARGET\n+        displayName: Execute run-docker.sh\n+    strategy:\n+      matrix:\n+        aarch64-unknown-linux-android:\n+          TARGET: aarch64-linux-android\n+        aarch64-unknown-linux-gnu:\n+          TARGET: aarch64-unknown-linux-gnu\n+        aarch64-unknown-linux-musl:\n+          TARGET: aarch64-unknown-linux-musl\n+        arm-linux-androideabi:\n+          TARGET: arm-linux-androideabi\n+        arm-unknown-linux-gnueabihf:\n+          TARGET: arm-unknown-linux-gnueabihf\n+        arm-unknown-linux-musleabihf:\n+          TARGET: arm-unknown-linux-musleabihf\n+        asmjs-unknown-emscripten:\n+          TARGET: asmjs-unknown-emscripten\n+        i686-linux-android:\n+          TARGET: i686-linux-android\n+        i686-unknown-linux-musl:\n+          TARGET: i686-unknown-linux-musl\n+        mips-unknown-linux-gnu:\n+          TARGET: mips-unknown-linux-gnu\n+        mips-unknown-linux-musl:\n+          TARGET: mips-unknown-linux-musl\n+        mips64-unknown-linux-gnuabi64:\n+          TARGET: mips64-unknown-linux-gnuabi64\n+        mips64el-unknown-linux-gnuabi64:\n+          TARGET: mips64el-unknown-linux-gnuabi64\n+        mipsel-unknown-linux-musl:\n+          TARGET: mipsel-unknown-linux-musl\n+        #powerpc-unknown-linux-gnu:\n+        #  TARGET: powerpc-unknown-linux-gnu\n+        powerpc64-unknown-linux-gnu:\n+          TARGET: powerpc64-unknown-linux-gnu\n+        powerpc64le-unknown-linux-gnu:\n+          TARGET: powerpc64le-unknown-linux-gnu\n+        #s390x-unknown-linux-gnu:\n+        #  TARGET: s390x-unknown-linux-gnu\n+        #wasm32-wasi\n+        #  TARGET: wasm32-wasi\n+        sparc64-unknown-linux-gnu:\n+          TARGET: sparc64-unknown-linux-gnu\n+        wasm32-unknown-emscripten:\n+          TARGET: wasm32-unknown-emscripten\n+        x86_64-linux-android:\n+          TARGET: x86_64-linux-android\n+        x86_64-unknown-linux-gnux32:\n+          TARGET: x86_64-unknown-linux-gnux32\n+        x86_64-unknown-linux-musl:\n+          TARGET: x86_64-unknown-linux-musl\n+\n+  - job: DockerOSX64\n+    pool:\n+      vmImage: macos-10.14\n+    steps:\n+      - template: azure-install-rust.yml\n+      - bash: LIBC_CI=1 sh ./ci/run.sh $TARGET\n+        displayName: Execute run.sh\n+    strategy:\n+      matrix:\n+        x86_64-apple-darwin:\n+          TARGET: x86_64-apple-darwin\n+\n+  - job: DockerOSX32\n+    pool:\n+      vmImage: macos-10.13\n+    steps:\n+      - template: azure-install-rust.yml\n+      - bash: LIBC_CI=1 sh ./ci/run.sh $TARGET\n+        displayName: Execute run.sh\n+    strategy:\n+      matrix:\n+        i686-apple-darwin:\n+          TARGET: i686-apple-darwin\n+\n+  - job: Windows\n+    pool:\n+      vmImage: vs2017-win2016\n+    steps:\n+      - template: azure-install-rust.yml\n+      - bash: LIBC_CI=1 sh ./ci/run.sh $TARGET\n+        displayName: Execute run.sh\n+    strategy:\n+      matrix:\n+        x86_64-pc-windows-gnu:\n+          TARGET: x86_64-pc-windows-gnu\n+          ARCH_BITS: 64\n+          ARCH: x86_64\n+        x86_64-pc-windows-msvc:\n+          TARGET: x86_64-pc-windows-msvc\n+        i686-pc-windows-gnu:\n+          TARGET: i686-pc-windows-gnu\n+          ARCH_BITS: 32\n+          ARCH: i686\n+        i686-pc-windows-msvc:\n+          TARGET: i686-pc-windows-msvc\n+\n+  - job: StyleAndDocs\n+    pool:\n+      vmImage: ubuntu-16.04\n+    steps:\n+      - template: azure-install-rust.yml\n+      - script: sh ci/style.sh\n+        displayName: Check style\n+      - script: LIBC_CI=1 sh ci/dox.sh\n+        displayName: Generate documentation\n+      - template: azure-configs/static-websites.yml@rustinfra\n+        parameters:\n+          deploy_dir: target/doc\n+\n+  # FIXME: re-enable these after the next release\n+  #- job: SemverLinux\n+  #  dependsOn: BuildChannelsLinux\n+  #  continueOnError: true\n+  #  pool:\n+  #    vmImage: ubuntu-16.04\n+  #  steps:\n+  #    - template: azure-install-rust.yml\n+  #    - script: sh ci/semver.sh linux\n+  #      displayName: Check breaking changes\n+\n+  #- job: SemverOSX\n+  #  dependsOn: BuildChannelsOSX\n+  #  continueOnError: true\n+  #  pool:\n+  #    vmImage: macos-10.14\n+  #  steps:\n+  #    - template: azure-install-rust.yml\n+  #    - script: sh ci/semver.sh osx\n+  #      displayName: Check breaking changes\n+\n+  - job: BuildChannelsLinux\n+    dependsOn: StyleAndDocs\n+    pool:\n+      vmImage: ubuntu-16.04\n+    steps:\n+      - template: azure-install-rust.yml\n+      - script: LIBC_CI=1 sh ./ci/build.sh\n+        displayName: Execute build.sh\n+    strategy:\n+      matrix:\n+        stable:\n+          TOOLCHAIN: stable\n+        beta:\n+          TOOLCHAIN: beta\n+        nightly:\n+          TOOLCHAIN: nightly\n+        1.13.0:\n+          TOOLCHAIN: 1.13.0\n+        1.19.0:\n+          TOOLCHAIN: 1.19.0\n+        1.24.0:\n+          TOOLCHAIN: 1.24.0\n+        1.25.0:\n+          TOOLCHAIN: 1.25.0\n+        1.30.0:\n+          TOOLCHAIN: 1.30.0\n+    variables:\n+      OS: linux\n+\n+  - job: BuildChannelsOSX\n+    dependsOn: StyleAndDocs\n+    pool:\n+      vmImage: macos-10.13\n+    steps:\n+      - template: azure-install-rust.yml\n+      - script: LIBC_CI=1 sh ./ci/build.sh\n+        displayName: Execute build.sh\n+    strategy:\n+      matrix:\n+        stable:\n+          TOOLCHAIN: stable\n+        beta:\n+          TOOLCHAIN: beta\n+        nightly:\n+          TOOLCHAIN: nightly\n+        1.13.0:\n+          TOOLCHAIN: 1.13.0\n+        1.19.0:\n+          TOOLCHAIN: 1.19.0\n+        1.24.0:\n+          TOOLCHAIN: 1.24.0\n+        1.25.0:\n+          TOOLCHAIN: 1.25.0\n+        1.30.0:\n+          TOOLCHAIN: 1.30.0\n+    variables:\n+      OS: osx"
      },
      {
        "sha": "64ff06d7a9560eb2cb1ce827f045e8590d57708a",
        "filename": "src/rusty/libc/ci/build.sh",
        "status": "added",
        "additions": 265,
        "deletions": 0,
        "changes": 265,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/build.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/build.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/build.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,265 @@\n+#!/usr/bin/env sh\n+\n+# Checks that libc builds properly for all supported targets on a particular\n+# Rust version:\n+# The FILTER environment variable can be used to select which target(s) to build.\n+# For example: set FILTER to vxworks to select the targets that has vxworks in name\n+\n+set -ex\n+\n+: \"${TOOLCHAIN?The TOOLCHAIN environment variable must be set.}\"\n+: \"${OS?The OS environment variable must be set.}\"\n+\n+RUST=${TOOLCHAIN}\n+\n+echo \"Testing Rust ${RUST} on ${OS}\"\n+\n+if [ \"${TOOLCHAIN}\" = \"nightly\" ] ; then\n+    cargo +nightly install cargo-xbuild -Z install-upgrade\n+    rustup component add rust-src\n+fi\n+\n+test_target() {\n+    BUILD_CMD=\"${1}\"\n+    TARGET=\"${2}\"\n+    NO_STD=\"${3}\"\n+\n+    opt=\n+    if [ \"${TARGET}\" = \"x86_64-unknown-linux-gnux32\" ]; then\n+        # FIXME: x86_64-unknown-linux-gnux32 fail to compile without\n+        # --release\n+        #\n+        # See https://github.com/rust-lang/rust/issues/45417\n+        opt=\"--release\"\n+    fi\n+    # FIXME: https://github.com/rust-lang/rust/issues/61174\n+    if [ \"${TARGET}\" = \"sparcv9-sun-solaris\" ] ||\n+       [ \"${TARGET}\" = \"x86_64-sun-solaris\" ]; then\n+        return 0\n+    fi\n+\n+    # If there is a std component, fetch it:\n+    if [ \"${NO_STD}\" != \"1\" ]; then\n+        # FIXME: rustup often fails to download some artifacts due to network\n+        # issues, so we retry this N times.\n+        N=5\n+        n=0\n+        until [ $n -ge $N ]\n+        do\n+            if rustup target add \"${TARGET}\" --toolchain \"${RUST}\" ; then\n+                break\n+            fi\n+            n=$((n+1))\n+            sleep 1\n+        done\n+    fi\n+\n+    # Test that libc builds without any default features (no libstd)\n+    cargo \"+${RUST}\" \"${BUILD_CMD}\" -vv $opt --no-default-features --target \"${TARGET}\"\n+\n+    # Test that libc builds with default features (e.g. libstd)\n+    # if the target supports libstd\n+    if [ \"$NO_STD\" != \"1\" ]; then\n+        cargo \"+${RUST}\" \"${BUILD_CMD}\" -vv $opt --target \"${TARGET}\"\n+    fi\n+\n+    # Test that libc builds with the `extra_traits` feature\n+    cargo \"+${RUST}\" \"${BUILD_CMD}\" -vv $opt --no-default-features --target \"${TARGET}\" \\\n+          --features extra_traits\n+\n+    # Also test that it builds with `extra_traits` and default features:\n+    if [ \"$NO_STD\" != \"1\" ]; then\n+        cargo \"+${RUST}\" \"${BUILD_CMD}\" -vv $opt --target \"${TARGET}\" \\\n+              --features extra_traits\n+    fi\n+}\n+\n+RUST_LINUX_TARGETS=\"\\\n+aarch64-linux-android \\\n+aarch64-unknown-linux-gnu \\\n+arm-linux-androideabi \\\n+arm-unknown-linux-gnueabi \\\n+arm-unknown-linux-gnueabihf \\\n+armv7-linux-androideabi \\\n+armv7-unknown-linux-gnueabihf \\\n+i586-unknown-linux-gnu \\\n+i686-linux-android \\\n+i686-unknown-freebsd \\\n+i686-unknown-linux-gnu \\\n+i686-unknown-linux-musl \\\n+mips-unknown-linux-gnu \\\n+mips-unknown-linux-musl \\\n+mips64-unknown-linux-gnuabi64 \\\n+mips64el-unknown-linux-gnuabi64 \\\n+mipsel-unknown-linux-gnu \\\n+mipsel-unknown-linux-gnu \\\n+mipsel-unknown-linux-musl \\\n+powerpc-unknown-linux-gnu \\\n+powerpc64-unknown-linux-gnu \\\n+powerpc64le-unknown-linux-gnu \\\n+s390x-unknown-linux-gnu \\\n+x86_64-unknown-freebsd \\\n+x86_64-unknown-linux-gnu \\\n+x86_64-unknown-linux-musl \\\n+x86_64-unknown-netbsd \\\n+\"\n+\n+RUST_GT_1_13_LINUX_TARGETS=\"\\\n+arm-unknown-linux-musleabi \\\n+arm-unknown-linux-musleabihf \\\n+armv7-unknown-linux-musleabihf \\\n+sparc64-unknown-linux-gnu \\\n+wasm32-unknown-emscripten \\\n+x86_64-linux-android \\\n+x86_64-rumprun-netbsd \\\n+\"\n+RUST_GT_1_19_LINUX_TARGETS=\"\\\n+aarch64-unknown-linux-musl \\\n+sparcv9-sun-solaris \\\n+wasm32-unknown-unknown \\\n+x86_64-sun-solaris \\\n+\"\n+RUST_GT_1_24_LINUX_TARGETS=\"\\\n+i586-unknown-linux-musl \\\n+x86_64-unknown-cloudabi \\\n+\"\n+\n+# FIXME: temporarirly disable the redox target\n+# https://github.com/rust-lang/libc/issues/1457\n+# x86_64-unknown-redox\n+RUST_NIGHTLY_LINUX_TARGETS=\"\\\n+aarch64-fuchsia \\\n+armv5te-unknown-linux-gnueabi \\\n+armv5te-unknown-linux-musleabi \\\n+i686-pc-windows-gnu \\\n+wasm32-wasi \\\n+x86_64-fortanix-unknown-sgx \\\n+x86_64-fuchsia \\\n+x86_64-pc-windows-gnu \\\n+x86_64-unknown-linux-gnux32 \\\n+\"\n+\n+RUST_OSX_TARGETS=\"\\\n+aarch64-apple-ios \\\n+armv7-apple-ios \\\n+armv7s-apple-ios \\\n+i386-apple-ios \\\n+i686-apple-darwin \\\n+x86_64-apple-darwin \\\n+x86_64-apple-ios \\\n+\"\n+\n+# The targets are listed here alphabetically\n+TARGETS=\"\"\n+case \"${OS}\" in\n+    linux*)\n+        TARGETS=\"${RUST_LINUX_TARGETS}\"\n+\n+        if [ \"${RUST}\" != \"1.13.0\" ]; then\n+            TARGETS=\"${TARGETS} ${RUST_GT_1_13_LINUX_TARGETS}\"\n+            if [ \"${RUST}\" != \"1.19.0\" ]; then\n+                TARGETS=\"${TARGETS} ${RUST_GT_1_19_LINUX_TARGETS}\"\n+                if [ \"${RUST}\" != \"1.24.0\" ]; then\n+                    TARGETS=\"${TARGETS} ${RUST_GT_1_24_LINUX_TARGETS}\"\n+                fi\n+            fi\n+        fi\n+\n+        if [ \"${RUST}\" = \"nightly\" ]; then\n+            TARGETS=\"${TARGETS} ${RUST_NIGHTLY_LINUX_TARGETS}\"\n+        fi\n+\n+        ;;\n+    osx*)\n+        TARGETS=\"${RUST_OSX_TARGETS}\"\n+        ;;\n+    *)\n+        ;;\n+esac\n+\n+for TARGET in $TARGETS; do\n+    if echo \"$TARGET\"|grep -q \"$FILTER\";then\n+        test_target build \"$TARGET\"\n+    fi\n+done\n+\n+# FIXME: https://github.com/rust-lang/rust/issues/58564\n+# sparc-unknown-linux-gnu\n+# FIXME: https://github.com/rust-lang/rust/issues/62932\n+# thumbv6m-none-eabi\n+RUST_LINUX_NO_CORE_TARGETS=\"\\\n+aarch64-pc-windows-msvc \\\n+aarch64-unknown-cloudabi \\\n+aarch64-unknown-freebsd \\\n+aarch64-unknown-hermit \\\n+aarch64-unknown-netbsd \\\n+aarch64-unknown-openbsd \\\n+armebv7r-none-eabi \\\n+armebv7r-none-eabihf \\\n+armv7-unknown-cloudabi-eabihf \\\n+armv7r-none-eabi \\\n+armv7r-none-eabihf \\\n+hexagon-unknown-linux-musl \\\n+i586-pc-windows-msvc \\\n+i686-pc-windows-msvc \\\n+i686-unknown-cloudabi \\\n+i686-unknown-haiku \\\n+i686-unknown-netbsd \\\n+i686-unknown-openbsd \\\n+mips-unknown-linux-uclibc \\\n+mipsel-unknown-linux-uclibc \\\n+mips64-unknown-linux-muslabi64 \\\n+mips64el-unknown-linux-muslabi64 \\\n+nvptx64-nvidia-cuda \\\n+powerpc-unknown-linux-gnuspe \\\n+powerpc-unknown-netbsd \\\n+powerpc64-unknown-freebsd \\\n+riscv32imac-unknown-none-elf \\\n+riscv32imc-unknown-none-elf \\\n+sparc64-unknown-netbsd \\\n+\n+thumbv7em-none-eabi \\\n+thumbv7em-none-eabihf \\\n+thumbv7m-none-eabi \\\n+thumbv7neon-linux-androideabi \\\n+thumbv7neon-unknown-linux-gnueabihf \\\n+thumbv8m.main-none-eabi \\\n+x86_64-pc-windows-msvc\n+x86_64-unknown-dragonfly \\\n+x86_64-unknown-haiku \\\n+x86_64-unknown-hermit \\\n+x86_64-unknown-l4re-uclibc \\\n+x86_64-unknown-openbsd \\\n+armv7-wrs-vxworks-eabihf \\\n+aarch64-wrs-vxworks \\\n+i686-wrs-vxworks \\\n+x86_64-wrs-vxworks \\\n+powerpc-wrs-vxworks \\\n+powerpc-wrs-vxworks-spe \\\n+powerpc64-wrs-vxworks \\\n+\"\n+\n+if [ \"${RUST}\" = \"nightly\" ] && [ \"${OS}\" = \"linux\" ]; then\n+    for TARGET in $RUST_LINUX_NO_CORE_TARGETS; do\n+        if echo \"$TARGET\"|grep -q \"$FILTER\";then\n+            test_target xbuild \"$TARGET\" 1\n+        fi\n+    done\n+\n+    # Nintendo switch\n+    cargo clean\n+    mkdir -p target\n+    (\n+        cd target\n+        wget https://github.com/devkitPro/pacman/releases/download/devkitpro-pacman-1.0.1/devkitpro-pacman.deb\n+        sudo dpkg -i devkitpro-pacman.deb\n+        sudo dkp-pacman -Sy\n+        sudo dkp-pacman -Syu\n+        sudo dkp-pacman -S -v --noconfirm switch-dev devkitA64\n+    )\n+    cp ci/switch.json switch.json\n+    PATH=\"$PATH:/opt/devkitpro/devkitA64/bin\"\n+    PATH=\"$PATH:/opt/devkitpro/tools/bin\"\n+    cargo xbuild --target switch.json\n+fi\n+"
      },
      {
        "sha": "6751dd93762d0bf96fd79ffcf4e383624c1d47e2",
        "filename": "src/rusty/libc/ci/docker/aarch64-linux-android/Dockerfile",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/aarch64-linux-android/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/aarch64-linux-android/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/aarch64-linux-android/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,45 @@\n+FROM ubuntu:19.04\n+\n+RUN dpkg --add-architecture i386 && \\\n+    apt-get update && \\\n+    apt-get install -y --no-install-recommends \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python \\\n+  unzip \\\n+  expect \\\n+  openjdk-8-jre \\\n+  libstdc++6:i386 \\\n+  libpulse0 \\\n+  gcc \\\n+  libc6-dev\n+\n+WORKDIR /android/\n+COPY android* /android/\n+\n+ENV ANDROID_ARCH=aarch64\n+ENV PATH=$PATH:/android/ndk-$ANDROID_ARCH/bin:/android/sdk/tools:/android/sdk/platform-tools\n+\n+RUN sh /android/android-install-ndk.sh $ANDROID_ARCH\n+RUN sh /android/android-install-sdk.sh $ANDROID_ARCH\n+RUN mv /root/.android /tmp\n+RUN chmod 777 -R /tmp/.android\n+RUN chmod 755 /android/sdk/tools/* /android/sdk/emulator/qemu/linux-x86_64/*\n+\n+ENV PATH=$PATH:/rust/bin \\\n+    CARGO_TARGET_AARCH64_LINUX_ANDROID_LINKER=aarch64-linux-android-gcc \\\n+    CARGO_TARGET_AARCH64_LINUX_ANDROID_RUNNER=/tmp/runtest \\\n+    HOME=/tmp\n+\n+ADD runtest-android.rs /tmp/runtest.rs\n+ENTRYPOINT [ \\\n+  \"bash\", \\\n+  \"-c\", \\\n+  # set SHELL so android can detect a 64bits system, see\n+  # http://stackoverflow.com/a/41789144\n+  \"SHELL=/bin/dash /android/sdk/emulator/emulator @aarch64 -no-window & \\\n+   rustc /tmp/runtest.rs -o /tmp/runtest && \\\n+   exec \\\"$@\\\"\", \\\n+  \"--\" \\\n+]"
      },
      {
        "sha": "716a445d346bf0f08d818943ae48c563d09f63ce",
        "filename": "src/rusty/libc/ci/docker/aarch64-unknown-linux-gnu/Dockerfile",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/aarch64-unknown-linux-gnu/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/aarch64-unknown-linux-gnu/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/aarch64-unknown-linux-gnu/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,7 @@\n+FROM ubuntu:19.04\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  gcc libc6-dev ca-certificates \\\n+  gcc-aarch64-linux-gnu libc6-dev-arm64-cross qemu-user\n+ENV CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_LINKER=aarch64-linux-gnu-gcc \\\n+    CARGO_TARGET_AARCH64_UNKNOWN_LINUX_GNU_RUNNER=\"qemu-aarch64 -L /usr/aarch64-linux-gnu\" \\\n+    PATH=$PATH:/rust/bin"
      },
      {
        "sha": "e9634bf3741db26399a70cec1616033d4aceb040",
        "filename": "src/rusty/libc/ci/docker/aarch64-unknown-linux-musl/Dockerfile",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/aarch64-unknown-linux-musl/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/aarch64-unknown-linux-musl/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/aarch64-unknown-linux-musl/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,15 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  gcc make libc6-dev git curl ca-certificates \\\n+  gcc-aarch64-linux-gnu qemu-user\n+\n+COPY install-musl.sh /\n+RUN sh /install-musl.sh aarch64\n+\n+# FIXME: shouldn't need the `-lgcc` here, shouldn't that be in libstd?\n+ENV PATH=$PATH:/musl-aarch64/bin:/rust/bin \\\n+    CC_aarch64_unknown_linux_musl=musl-gcc \\\n+    RUSTFLAGS='-Clink-args=-lgcc' \\\n+    CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_LINKER=musl-gcc \\\n+    CARGO_TARGET_AARCH64_UNKNOWN_LINUX_MUSL_RUNNER=\"qemu-aarch64 -L /musl-aarch64\""
      },
      {
        "sha": "544d1676e1b08d4495013dfa5fdb9d20a6706199",
        "filename": "src/rusty/libc/ci/docker/arm-linux-androideabi/Dockerfile",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/arm-linux-androideabi/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/arm-linux-androideabi/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/arm-linux-androideabi/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,45 @@\n+FROM ubuntu:19.04\n+\n+RUN dpkg --add-architecture i386 && \\\n+    apt-get update && \\\n+    apt-get install -y --no-install-recommends \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python \\\n+  unzip \\\n+  expect \\\n+  openjdk-8-jre \\\n+  libstdc++6:i386 \\\n+  libpulse0 \\\n+  gcc \\\n+  libc6-dev\n+\n+WORKDIR /android/\n+COPY android* /android/\n+\n+ENV ANDROID_ARCH=arm\n+ENV PATH=$PATH:/android/ndk-$ANDROID_ARCH/bin:/android/sdk/tools:/android/sdk/platform-tools\n+\n+RUN sh /android/android-install-ndk.sh $ANDROID_ARCH\n+RUN sh /android/android-install-sdk.sh $ANDROID_ARCH\n+RUN mv /root/.android /tmp\n+RUN chmod 777 -R /tmp/.android\n+RUN chmod 755 /android/sdk/tools/* /android/sdk/emulator/qemu/linux-x86_64/*\n+\n+ENV PATH=$PATH:/rust/bin \\\n+    CARGO_TARGET_ARM_LINUX_ANDROIDEABI_LINKER=arm-linux-androideabi-gcc \\\n+    CARGO_TARGET_ARM_LINUX_ANDROIDEABI_RUNNER=/tmp/runtest \\\n+    HOME=/tmp\n+\n+ADD runtest-android.rs /tmp/runtest.rs\n+ENTRYPOINT [ \\\n+  \"bash\", \\\n+  \"-c\", \\\n+  # set SHELL so android can detect a 64bits system, see\n+  # http://stackoverflow.com/a/41789144\n+  \"SHELL=/bin/dash /android/sdk/emulator/emulator @arm -no-window & \\\n+   rustc /tmp/runtest.rs -o /tmp/runtest && \\\n+   exec \\\"$@\\\"\", \\\n+  \"--\" \\\n+]"
      },
      {
        "sha": "bcdbb227f25ac58caf124a505920ef6cf8093567",
        "filename": "src/rusty/libc/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/arm-unknown-linux-gnueabihf/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,7 @@\n+FROM ubuntu:19.04\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  gcc libc6-dev ca-certificates \\\n+  gcc-arm-linux-gnueabihf libc6-dev-armhf-cross qemu-user\n+ENV CARGO_TARGET_ARM_UNKNOWN_LINUX_GNUEABIHF_LINKER=arm-linux-gnueabihf-gcc \\\n+    CARGO_TARGET_ARM_UNKNOWN_LINUX_GNUEABIHF_RUNNER=\"qemu-arm -L /usr/arm-linux-gnueabihf\" \\\n+    PATH=$PATH:/rust/bin"
      },
      {
        "sha": "639b141d4b3d38a4f86e61fe3a68aa05e911918e",
        "filename": "src/rusty/libc/ci/docker/arm-unknown-linux-musleabihf/Dockerfile",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/arm-unknown-linux-musleabihf/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/arm-unknown-linux-musleabihf/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/arm-unknown-linux-musleabihf/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,13 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  gcc make libc6-dev git curl ca-certificates \\\n+  gcc-arm-linux-gnueabihf qemu-user\n+\n+COPY install-musl.sh /\n+RUN sh /install-musl.sh arm\n+\n+ENV PATH=$PATH:/musl-arm/bin:/rust/bin \\\n+    CC_arm_unknown_linux_musleabihf=musl-gcc \\\n+    CARGO_TARGET_ARM_UNKNOWN_LINUX_MUSLEABIHF_LINKER=musl-gcc \\\n+    CARGO_TARGET_ARM_UNKNOWN_LINUX_MUSLEABIHF_RUNNER=\"qemu-arm -L /musl-arm\""
      },
      {
        "sha": "64f73aa6a00b9282faffcca8c1261ef865e0f93e",
        "filename": "src/rusty/libc/ci/docker/asmjs-unknown-emscripten/Dockerfile",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/asmjs-unknown-emscripten/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/asmjs-unknown-emscripten/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/asmjs-unknown-emscripten/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,21 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && \\\n+    apt-get install -y --no-install-recommends \\\n+    ca-certificates \\\n+    curl \\\n+    gcc \\\n+    git \\\n+    libc6-dev \\\n+    libxml2 \\\n+    python \\\n+    xz-utils\n+\n+COPY emscripten.sh /\n+RUN bash /emscripten.sh\n+\n+ENV PATH=$PATH:/rust/bin \\\n+    CARGO_TARGET_ASMJS_UNKNOWN_EMSCRIPTEN_RUNNER=node\n+\n+COPY emscripten-entry.sh /\n+ENTRYPOINT [\"/emscripten-entry.sh\"]"
      },
      {
        "sha": "540322055e449b7463ccd472c131608aa91216d1",
        "filename": "src/rusty/libc/ci/docker/i686-linux-android/Dockerfile",
        "status": "added",
        "additions": 45,
        "deletions": 0,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/i686-linux-android/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/i686-linux-android/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/i686-linux-android/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,45 @@\n+FROM ubuntu:19.04\n+\n+RUN dpkg --add-architecture i386 && \\\n+    apt-get update && \\\n+    apt-get install -y --no-install-recommends \\\n+  file \\\n+  curl \\\n+  ca-certificates \\\n+  python \\\n+  unzip \\\n+  expect \\\n+  openjdk-8-jre \\\n+  libstdc++6:i386 \\\n+  libpulse0 \\\n+  gcc \\\n+  libc6-dev\n+\n+WORKDIR /android/\n+COPY android* /android/\n+\n+ENV ANDROID_ARCH=i686\n+ENV PATH=$PATH:/android/ndk-$ANDROID_ARCH/bin:/android/sdk/tools:/android/sdk/platform-tools\n+\n+RUN sh /android/android-install-ndk.sh $ANDROID_ARCH\n+RUN sh /android/android-install-sdk.sh $ANDROID_ARCH\n+RUN mv /root/.android /tmp\n+RUN chmod 777 -R /tmp/.android\n+RUN chmod 755 /android/sdk/tools/* /android/sdk/emulator/qemu/linux-x86_64/*\n+\n+ENV PATH=$PATH:/rust/bin \\\n+    CARGO_TARGET_I686_LINUX_ANDROID_LINKER=i686-linux-android-gcc \\\n+    CARGO_TARGET_I686_LINUX_ANDROID_RUNNER=/tmp/runtest \\\n+    HOME=/tmp\n+\n+ADD runtest-android.rs /tmp/runtest.rs\n+ENTRYPOINT [ \\\n+  \"bash\", \\\n+  \"-c\", \\\n+  # set SHELL so android can detect a 64bits system, see\n+  # http://stackoverflow.com/a/41789144\n+  \"SHELL=/bin/dash /android/sdk/emulator/emulator @i686 -no-window -no-accel & \\\n+   rustc /tmp/runtest.rs -o /tmp/runtest && \\\n+   exec \\\"$@\\\"\", \\\n+  \"--\" \\\n+]"
      },
      {
        "sha": "5563a7b96b28395238aaa57a51dc220c541aad67",
        "filename": "src/rusty/libc/ci/docker/i686-unknown-linux-gnu/Dockerfile",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/i686-unknown-linux-gnu/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/i686-unknown-linux-gnu/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/i686-unknown-linux-gnu/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,5 @@\n+FROM ubuntu:19.04\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+  gcc-multilib libc6-dev ca-certificates\n+ENV PATH=$PATH:/rust/bin"
      },
      {
        "sha": "ac76a3269a5467ef680801cdf30495b4abc9d41f",
        "filename": "src/rusty/libc/ci/docker/i686-unknown-linux-musl/Dockerfile",
        "status": "added",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/i686-unknown-linux-musl/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/i686-unknown-linux-musl/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/i686-unknown-linux-musl/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,12 @@\n+FROM ubuntu:19.04\n+\n+RUN dpkg --add-architecture i386\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+  gcc-multilib make libc6-dev git curl ca-certificates libc6:i386\n+\n+COPY install-musl.sh /\n+RUN sh /install-musl.sh i686\n+\n+ENV PATH=$PATH:/musl-i686/bin:/rust/bin \\\n+    CC_i686_unknown_linux_musl=musl-gcc"
      },
      {
        "sha": "c8623a56bb3a8b06ebd066d5b296ae2ee5c1284c",
        "filename": "src/rusty/libc/ci/docker/mips-unknown-linux-gnu/Dockerfile",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/mips-unknown-linux-gnu/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/mips-unknown-linux-gnu/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/mips-unknown-linux-gnu/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,10 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+        gcc libc6-dev qemu-user ca-certificates \\\n+        gcc-mips-linux-gnu libc6-dev-mips-cross \\\n+        qemu-system-mips linux-headers-generic\n+\n+ENV CARGO_TARGET_MIPS_UNKNOWN_LINUX_GNU_LINKER=mips-linux-gnu-gcc \\\n+    CARGO_TARGET_MIPS_UNKNOWN_LINUX_GNU_RUNNER=\"qemu-mips -L /usr/mips-linux-gnu\" \\\n+    PATH=$PATH:/rust/bin"
      },
      {
        "sha": "50da684ae7b0855b4bc6c5b75bfcaac17ea619f6",
        "filename": "src/rusty/libc/ci/docker/mips-unknown-linux-musl/Dockerfile",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/mips-unknown-linux-musl/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/mips-unknown-linux-musl/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/mips-unknown-linux-musl/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,17 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+        gcc libc6-dev qemu-user ca-certificates qemu-system-mips curl \\\n+        bzip2\n+\n+RUN mkdir /toolchain\n+\n+# Note that this originally came from:\n+# https://downloads.openwrt.org/snapshots/trunk/ar71xx/generic/OpenWrt-SDK-ar71xx-generic_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\n+RUN curl --retry 5 -L https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/libc/OpenWrt-SDK-ar71xx-generic_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2 | \\\n+    tar xjf - -C /toolchain --strip-components=1\n+\n+ENV PATH=$PATH:/rust/bin:/toolchain/staging_dir/toolchain-mips_34kc_gcc-5.3.0_musl-1.1.15/bin \\\n+    CC_mips_unknown_linux_musl=mips-openwrt-linux-gcc \\\n+    CARGO_TARGET_MIPS_UNKNOWN_LINUX_MUSL_LINKER=mips-openwrt-linux-gcc \\\n+    CARGO_TARGET_MIPS_UNKNOWN_LINUX_MUSL_RUNNER=\"qemu-mips -L /toolchain/staging_dir/toolchain-mips_34kc_gcc-5.3.0_musl-1.1.15\""
      },
      {
        "sha": "d4b972d3ef28e6b76b6c280506a160cc5cb17a66",
        "filename": "src/rusty/libc/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/mips64-unknown-linux-gnuabi64/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,11 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+        gcc libc6-dev qemu-user ca-certificates \\\n+        gcc-mips64-linux-gnuabi64 libc6-dev-mips64-cross \\\n+        qemu-system-mips64 linux-headers-generic\n+\n+ENV CARGO_TARGET_MIPS64_UNKNOWN_LINUX_GNUABI64_LINKER=mips64-linux-gnuabi64-gcc \\\n+    CARGO_TARGET_MIPS64_UNKNOWN_LINUX_GNUABI64_RUNNER=\"qemu-mips64 -L /usr/mips64-linux-gnuabi64\" \\\n+    CC_mips64_unknown_linux_gnuabi64=mips64-linux-gnuabi64-gcc \\\n+    PATH=$PATH:/rust/bin"
      },
      {
        "sha": "8f63ade604b5bfa93c50538b9de7a0934c75cb67",
        "filename": "src/rusty/libc/ci/docker/mips64-unknown-linux-muslabi64/Dockerfile",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/mips64-unknown-linux-muslabi64/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/mips64-unknown-linux-muslabi64/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/mips64-unknown-linux-muslabi64/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,15 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  gcc make libc6-dev git curl ca-certificates \\\n+  gcc-mips64-linux-gnuabi64 qemu-user\n+\n+COPY install-musl.sh /\n+RUN sh /install-musl.sh mips64\n+\n+# FIXME: shouldn't need the `-lgcc` here, shouldn't that be in libstd?\n+ENV PATH=$PATH:/musl-mips64/bin:/rust/bin \\\n+    CC_mips64_unknown_linux_muslabi64=musl-gcc \\\n+    RUSTFLAGS='-Clink-args=-lgcc' \\\n+    CARGO_TARGET_MIPS64_UNKNOWN_LINUX_MUSLABI64_LINKER=musl-gcc \\\n+    CARGO_TARGET_MIPS64_UNKNOWN_LINUX_MUSLABI64_RUNNER=\"qemu-mips64 -L /musl-mips64\""
      },
      {
        "sha": "d0303dadcb261a940da153a10a23675f28626c8e",
        "filename": "src/rusty/libc/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/mips64el-unknown-linux-gnuabi64/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,11 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+        gcc libc6-dev qemu-user ca-certificates \\\n+        gcc-mips64el-linux-gnuabi64 libc6-dev-mips64el-cross \\\n+        qemu-system-mips64el linux-headers-generic\n+\n+ENV CARGO_TARGET_MIPS64EL_UNKNOWN_LINUX_GNUABI64_LINKER=mips64el-linux-gnuabi64-gcc \\\n+    CARGO_TARGET_MIPS64EL_UNKNOWN_LINUX_GNUABI64_RUNNER=\"qemu-mips64el -L /usr/mips64el-linux-gnuabi64\" \\\n+    CC_mips64el_unknown_linux_gnuabi64=mips64el-linux-gnuabi64-gcc \\\n+    PATH=$PATH:/rust/bin"
      },
      {
        "sha": "c42c2ba601001aefd8e1e2f930ae1d785746acfb",
        "filename": "src/rusty/libc/ci/docker/mips64el-unknown-linux-muslabi64/Dockerfile",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/mips64el-unknown-linux-muslabi64/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/mips64el-unknown-linux-muslabi64/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/mips64el-unknown-linux-muslabi64/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,15 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+  gcc make libc6-dev git curl ca-certificates \\\n+  gcc-mips64el-linux-gnuabi64 qemu-user\n+\n+COPY install-musl.sh /\n+RUN sh /install-musl.sh mips64el\n+\n+# FIXME: shouldn't need the `-lgcc` here, shouldn't that be in libstd?\n+ENV PATH=$PATH:/musl-mips64el/bin:/rust/bin \\\n+    CC_mips64el_unknown_linux_muslabi64=musl-gcc \\\n+    RUSTFLAGS='-Clink-args=-lgcc' \\\n+    CARGO_TARGET_MIPS64EL_UNKNOWN_LINUX_MUSLABI64_LINKER=musl-gcc \\\n+    CARGO_TARGET_MIPS64EL_UNKNOWN_LINUX_MUSLABI64_RUNNER=\"qemu-mips64el -L /musl-mips64el\""
      },
      {
        "sha": "91c00c250cab08f1b91495c5945766981a0e851b",
        "filename": "src/rusty/libc/ci/docker/mipsel-unknown-linux-musl/Dockerfile",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/mipsel-unknown-linux-musl/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/mipsel-unknown-linux-musl/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/mipsel-unknown-linux-musl/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,17 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+        gcc libc6-dev qemu-user ca-certificates qemu-system-mips curl \\\n+        bzip2\n+\n+RUN mkdir /toolchain\n+\n+# Note that this originally came from:\n+# https://downloads.openwrt.org/snapshots/trunk/malta/generic/OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2\n+RUN curl --retry 5 -L https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/libc/OpenWrt-Toolchain-malta-le_gcc-5.3.0_musl-1.1.15.Linux-x86_64.tar.bz2 | \\\n+      tar xjf - -C /toolchain --strip-components=2\n+\n+ENV PATH=$PATH:/rust/bin:/toolchain/bin \\\n+    CC_mipsel_unknown_linux_musl=mipsel-openwrt-linux-gcc \\\n+    CARGO_TARGET_MIPSEL_UNKNOWN_LINUX_MUSL_LINKER=mipsel-openwrt-linux-gcc \\\n+    CARGO_TARGET_MIPSEL_UNKNOWN_LINUX_MUSL_RUNNER=\"qemu-mipsel -L /toolchain\""
      },
      {
        "sha": "9fa05af12ed990b38f483075e656b0687fdc2302",
        "filename": "src/rusty/libc/ci/docker/powerpc-unknown-linux-gnu/Dockerfile",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/powerpc-unknown-linux-gnu/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/powerpc-unknown-linux-gnu/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/powerpc-unknown-linux-gnu/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,11 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+        gcc libc6-dev qemu-user ca-certificates \\\n+        gcc-powerpc-linux-gnu libc6-dev-powerpc-cross \\\n+        qemu-system-ppc\n+\n+ENV CARGO_TARGET_POWERPC_UNKNOWN_LINUX_GNU_LINKER=powerpc-linux-gnu-gcc \\\n+    CARGO_TARGET_POWERPC_UNKNOWN_LINUX_GNU_RUNNER=\"qemu-ppc -L /usr/powerpc-linux-gnu\" \\\n+    CC=powerpc-linux-gnu-gcc \\\n+    PATH=$PATH:/rust/bin"
      },
      {
        "sha": "ab40789755749c6c2daf589f4dc78f6eaf9ca633",
        "filename": "src/rusty/libc/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/powerpc64-unknown-linux-gnu/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,11 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+        gcc libc6-dev qemu-user ca-certificates \\\n+        gcc-powerpc64-linux-gnu libc6-dev-ppc64-cross \\\n+        qemu-system-ppc\n+\n+ENV CARGO_TARGET_POWERPC64_UNKNOWN_LINUX_GNU_LINKER=powerpc64-linux-gnu-gcc \\\n+    CARGO_TARGET_POWERPC64_UNKNOWN_LINUX_GNU_RUNNER=\"qemu-ppc64 -L /usr/powerpc64-linux-gnu\" \\\n+    CC=powerpc64-linux-gnu-gcc \\\n+    PATH=$PATH:/rust/bin"
      },
      {
        "sha": "4dcd632edde38d562a68e74262dc0aea5326c84b",
        "filename": "src/rusty/libc/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile",
        "status": "added",
        "additions": 11,
        "deletions": 0,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/powerpc64le-unknown-linux-gnu/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,11 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+        gcc libc6-dev qemu-user ca-certificates \\\n+        gcc-powerpc64le-linux-gnu libc6-dev-ppc64el-cross \\\n+        qemu-system-ppc\n+\n+ENV CARGO_TARGET_POWERPC64LE_UNKNOWN_LINUX_GNU_LINKER=powerpc64le-linux-gnu-gcc \\\n+    CARGO_TARGET_POWERPC64LE_UNKNOWN_LINUX_GNU_RUNNER=\"qemu-ppc64le -L /usr/powerpc64le-linux-gnu\" \\\n+    CC=powerpc64le-linux-gnu-gcc \\\n+    PATH=$PATH:/rust/bin"
      },
      {
        "sha": "75c11c11dca8ddaf10173c646d5361bad904195b",
        "filename": "src/rusty/libc/ci/docker/s390x-unknown-linux-gnu/Dockerfile",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/s390x-unknown-linux-gnu/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/s390x-unknown-linux-gnu/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/s390x-unknown-linux-gnu/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,18 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+        curl ca-certificates \\\n+        gcc libc6-dev \\\n+        gcc-s390x-linux-gnu libc6-dev-s390x-cross \\\n+        qemu-system-s390x \\\n+        cpio\n+\n+COPY linux-s390x.sh /\n+RUN bash /linux-s390x.sh\n+\n+COPY test-runner-linux /\n+\n+ENV CARGO_TARGET_S390X_UNKNOWN_LINUX_GNU_LINKER=s390x-linux-gnu-gcc \\\n+    CARGO_TARGET_S390X_UNKNOWN_LINUX_GNU_RUNNER=\"/test-runner-linux s390x\" \\\n+    CC_s390x_unknown_linux_gnu=s390x-linux-gnu-gcc \\\n+    PATH=$PATH:/rust/bin"
      },
      {
        "sha": "d1f4503d52d5a210c0a8d49885f4b878943d3e86",
        "filename": "src/rusty/libc/ci/docker/sparc64-unknown-linux-gnu/Dockerfile",
        "status": "added",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/sparc64-unknown-linux-gnu/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/sparc64-unknown-linux-gnu/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/sparc64-unknown-linux-gnu/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,18 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && apt-get install -y --no-install-recommends \\\n+        curl ca-certificates \\\n+        gcc libc6-dev \\\n+        gcc-sparc64-linux-gnu libc6-dev-sparc64-cross \\\n+        qemu-system-sparc64 openbios-sparc seabios ipxe-qemu \\\n+        p7zip-full cpio linux-libc-dev-sparc64-cross\n+\n+COPY linux-sparc64.sh /\n+RUN bash /linux-sparc64.sh\n+\n+COPY test-runner-linux /\n+\n+ENV CARGO_TARGET_SPARC64_UNKNOWN_LINUX_GNU_LINKER=sparc64-linux-gnu-gcc \\\n+    CARGO_TARGET_SPARC64_UNKNOWN_LINUX_GNU_RUNNER=\"/test-runner-linux sparc64\" \\\n+    CC_sparc64_unknown_linux_gnu=sparc64-linux-gnu-gcc \\\n+    PATH=$PATH:/rust/bin"
      },
      {
        "sha": "4de9e7475559d853213396f27e047e536347ec27",
        "filename": "src/rusty/libc/ci/docker/wasm32-unknown-emscripten/Dockerfile",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/wasm32-unknown-emscripten/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/wasm32-unknown-emscripten/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/wasm32-unknown-emscripten/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,28 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && \\\n+    apt-get install -y --no-install-recommends \\\n+    ca-certificates \\\n+    g++ \\\n+    make \\\n+    file \\\n+    curl \\\n+    gcc \\\n+    git \\\n+    libc6-dev \\\n+    libxml2 \\\n+    python \\\n+    cmake \\\n+    sudo \\\n+    gdb \\\n+    xz-utils\n+\n+COPY emscripten.sh /\n+RUN bash /emscripten.sh\n+\n+ENV PATH=$PATH:/rust/bin \\\n+    CARGO_TARGET_WASM32_UNKNOWN_EMSCRIPTEN_RUNNER=node-wrapper.sh\n+\n+COPY emscripten-entry.sh /\n+COPY docker/wasm32-unknown-emscripten/node-wrapper.sh /usr/local/bin/node-wrapper.sh\n+ENTRYPOINT [\"/emscripten-entry.sh\"]"
      },
      {
        "sha": "3122e2e23b41531323aa4981f24f27063c9997cd",
        "filename": "src/rusty/libc/ci/docker/wasm32-unknown-emscripten/node-wrapper.sh",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/wasm32-unknown-emscripten/node-wrapper.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/wasm32-unknown-emscripten/node-wrapper.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/wasm32-unknown-emscripten/node-wrapper.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,15 @@\n+#!/bin/sh\n+\n+set -e\n+\n+me=$1\n+shift\n+dir=$(dirname $me)\n+file=$(basename $me)\n+\n+if echo $file | grep -q wasm; then\n+  exit 0 # FIXME(rust-lang/cargo#4750)\n+fi\n+\n+cd $dir\n+exec node $file \"$@\""
      },
      {
        "sha": "eb3b5ff8b7739e46fc962cc4c502ab13d1301505",
        "filename": "src/rusty/libc/ci/docker/wasm32-wasi/Dockerfile",
        "status": "added",
        "additions": 93,
        "deletions": 0,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/wasm32-wasi/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/wasm32-wasi/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/wasm32-wasi/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,93 @@\n+# In the first container we want to assemble the `wasi-sysroot` by compiling it\n+# from source. This requires a clang 8.0+ compiler with enough wasm support and\n+# then we're just running a standard `make` inside of what we clone.\n+FROM ubuntu:18.04 as wasi-sysroot\n+\n+RUN apt-get update && \\\n+    apt-get install -y --no-install-recommends \\\n+    ca-certificates \\\n+    clang \\\n+    cmake \\\n+    curl \\\n+    g++ \\\n+    git \\\n+    libc6-dev \\\n+    libclang-dev \\\n+    make \\\n+    ssh \\\n+    xz-utils\n+\n+# Fetch clang 8.0+ which is used to compile the wasi target and link our\n+# programs together.\n+RUN curl http://releases.llvm.org/8.0.0/clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04.tar.xz | tar xJf -\n+RUN mv /clang+llvm-8.0.0-x86_64-linux-gnu-ubuntu-18.04 /wasmcc\n+\n+# Note that we're using `git reset --hard` to pin to a specific commit for\n+# verification for now. The sysroot is currently in somewhat of a state of flux\n+# and is expected to have breaking changes, so this is an attempt to mitigate\n+# those breaking changes on `libc`'s own CI\n+RUN git clone https://github.com/CraneStation/wasi-sysroot && \\\n+  cd wasi-sysroot && \\\n+  git reset --hard eee6ee7566e26f2535eb6088c8494a112ff423b9\n+RUN make -C wasi-sysroot install -j $(nproc) WASM_CC=/wasmcc/bin/clang INSTALL_DIR=/wasi-sysroot\n+\n+# This is a small wrapper script which executes the actual clang binary in\n+# `/wasmcc` and then is sure to pass the right `--sysroot` argument which we\n+# just built above.\n+COPY docker/wasm32-wasi/clang.sh /wasi-sysroot/bin/clang\n+\n+# In the second container we're going to build the `wasmtime` binary which is\n+# used to execute wasi executables. This is a standard Rust project so we're\n+# just checking out a known revision (which pairs with the sysroot one we\n+# downlaoded above) and then we're building it with Cargo\n+FROM ubuntu:18.04 as wasmtime\n+\n+RUN apt-get update && \\\n+    apt-get install -y --no-install-recommends \\\n+    ca-certificates \\\n+    clang \\\n+    cmake \\\n+    curl \\\n+    g++ \\\n+    git \\\n+    libclang-dev \\\n+    make \\\n+    ssh\n+\n+RUN curl -sSf https://sh.rustup.rs |  sh -s -- -y\n+ENV PATH=/root/.cargo/bin:$PATH\n+\n+RUN apt-get install -y --no-install-recommends python\n+RUN git clone --recursive https://github.com/CraneStation/wasmtime wasmtime && \\\n+  cd wasmtime && \\\n+  git reset --hard a2647878977726935c3d04c05cabad9607ec7606\n+RUN cargo build --release --manifest-path wasmtime/Cargo.toml\n+\n+# And finally in the last image we're going to assemble everything together.\n+# We'll install things needed at runtime for now and then copy over the\n+# sysroot/wasmtime artifacts into their final location.\n+FROM ubuntu:18.04\n+\n+RUN apt-get update && \\\n+    apt-get install -y --no-install-recommends \\\n+    gcc \\\n+    libc6-dev \\\n+    libxml2 \\\n+    ca-certificates\n+\n+# Copy over clang we downloaded to link executables ...\n+COPY --from=wasi-sysroot /wasmcc /wasmcc/\n+# ... and the sysroot we built to link executables against ...\n+COPY --from=wasi-sysroot /wasi-sysroot/ /wasi-sysroot/\n+# ... and finally wasmtime to actually execute binaries\n+COPY --from=wasmtime /wasmtime/target/release/wasmtime /usr/bin/\n+\n+# Of note here is our clang wrapper which just executes a normal clang\n+# executable with the right sysroot, and then we're sure to turn off the\n+# crt-static feature to ensure that the CRT that we're specifying with `clang`\n+# is used.\n+ENV CARGO_TARGET_WASM32_WASI_RUNNER=wasmtime \\\n+  CARGO_TARGET_WASM32_WASI_LINKER=/wasi-sysroot/bin/clang \\\n+  CC_wasm32_wasi=/wasi-sysroot/bin/clang \\\n+  PATH=$PATH:/rust/bin \\\n+  RUSTFLAGS=-Ctarget-feature=-crt-static"
      },
      {
        "sha": "6f298128ab8c342a6dc301622b8020aef12c26ee",
        "filename": "src/rusty/libc/ci/docker/wasm32-wasi/clang.sh",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/wasm32-wasi/clang.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/wasm32-wasi/clang.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/wasm32-wasi/clang.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,2 @@\n+#!/usr/bin/env sh\n+exec /wasmcc/bin/clang --target=wasm32-wasi --sysroot /wasi-sysroot \"$@\""
      },
      {
        "sha": "b0984c04585d88b89129dda0e831a4bcba73f1de",
        "filename": "src/rusty/libc/ci/docker/x86_64-linux-android/Dockerfile",
        "status": "added",
        "additions": 26,
        "deletions": 0,
        "changes": 26,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/x86_64-linux-android/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/x86_64-linux-android/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/x86_64-linux-android/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,26 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update && \\\n+    apt-get install -y --no-install-recommends \\\n+  ca-certificates \\\n+  curl \\\n+  gcc \\\n+  libc-dev \\\n+  python \\\n+  unzip\n+\n+WORKDIR /android/\n+ENV ANDROID_ARCH=x86_64\n+COPY android-install-ndk.sh /android/\n+RUN sh /android/android-install-ndk.sh $ANDROID_ARCH\n+\n+# We do not run x86_64-linux-android tests on an android emulator.\n+# See ci/android-sysimage.sh for informations about how tests are run.\n+COPY android-sysimage.sh /android/\n+RUN bash /android/android-sysimage.sh x86_64 x86_64-24_r07.zip\n+\n+ENV PATH=$PATH:/rust/bin:/android/ndk-$ANDROID_ARCH/bin \\\n+    CARGO_TARGET_X86_64_LINUX_ANDROID_LINKER=x86_64-linux-android-gcc \\\n+    CC_x86_64_linux_android=x86_64-linux-android-gcc \\\n+    CXX_x86_64_linux_android=x86_64-linux-android-g++ \\\n+    HOME=/tmp"
      },
      {
        "sha": "a486d05b2ebead094e9fc0511c03067ecc38f8b6",
        "filename": "src/rusty/libc/ci/docker/x86_64-rumprun-netbsd/Dockerfile",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/x86_64-rumprun-netbsd/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/x86_64-rumprun-netbsd/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/x86_64-rumprun-netbsd/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,10 @@\n+FROM mato/rumprun-toolchain-hw-x86_64\n+USER root\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+  qemu\n+ENV PATH=$PATH:/rust/bin \\\n+    CARGO_TARGET_X86_64_RUMPRUN_NETBSD_RUNNER=/tmp/runtest\n+\n+ADD docker/x86_64-rumprun-netbsd/runtest.rs /tmp/\n+ENTRYPOINT [\"sh\", \"-c\", \"rustc /tmp/runtest.rs -o /tmp/runtest && exec \\\"$@\\\"\", \"--\"]"
      },
      {
        "sha": "7e96fbfab442d2bd704e95f38644acbacef75ec5",
        "filename": "src/rusty/libc/ci/docker/x86_64-rumprun-netbsd/runtest.rs",
        "status": "added",
        "additions": 55,
        "deletions": 0,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/x86_64-rumprun-netbsd/runtest.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/x86_64-rumprun-netbsd/runtest.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/x86_64-rumprun-netbsd/runtest.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,55 @@\n+use std::env;\n+use std::process::{Command, Stdio};\n+use std::sync::mpsc;\n+use std::thread;\n+use std::time::Duration;\n+use std::io::{BufRead, BufReader, Read};\n+\n+fn main() {\n+    assert_eq!(env::args().len(), 2);\n+\n+    let status = Command::new(\"rumprun-bake\")\n+        .arg(\"hw_virtio\")\n+        .arg(\"/tmp/libc-test.img\")\n+        .arg(env::args().nth(1).unwrap())\n+        .status()\n+        .expect(\"failed to run rumprun-bake\");\n+    assert!(status.success());\n+\n+    let mut child = Command::new(\"qemu-system-x86_64\")\n+        .arg(\"-nographic\")\n+        .arg(\"-vga\").arg(\"none\")\n+        .arg(\"-m\").arg(\"64\")\n+        .arg(\"-kernel\").arg(\"/tmp/libc-test.img\")\n+        .stdout(Stdio::piped())\n+        .stderr(Stdio::piped())\n+        .spawn()\n+        .expect(\"failed to spawn qemu\");\n+\n+    let mut stdout = child.stdout.take().unwrap();\n+    let mut stderr = child.stderr.take().unwrap();\n+    let (tx, rx) = mpsc::channel();\n+    let tx2 = tx.clone();\n+    let t1 = thread::spawn(move || find_ok(&mut stdout, tx));\n+    let t2 = thread::spawn(move || find_ok(&mut stderr, tx2));\n+\n+    let res = rx.recv_timeout(Duration::new(5, 0));\n+    child.kill().unwrap();\n+    t1.join().unwrap();\n+    t2.join().unwrap();\n+\n+    if res.is_err() {\n+        panic!(\"didn't find success\");\n+    }\n+}\n+\n+fn find_ok(input: &mut Read, tx: mpsc::Sender<()>) {\n+    for line in BufReader::new(input).lines() {\n+        let line = line.unwrap();\n+        println!(\"{}\", line);\n+        if (line.starts_with(\"PASSED \") && line.contains(\" tests\")) ||\n+            line.starts_with(\"test result: ok\"){\n+            tx.send(()).unwrap();\n+        }\n+    }\n+}"
      },
      {
        "sha": "bfa2b170adea0585e5ef3066d8eefe60360375cf",
        "filename": "src/rusty/libc/ci/docker/x86_64-unknown-linux-gnu/Dockerfile",
        "status": "added",
        "additions": 9,
        "deletions": 0,
        "changes": 9,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/x86_64-unknown-linux-gnu/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/x86_64-unknown-linux-gnu/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/x86_64-unknown-linux-gnu/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,9 @@\n+FROM ubuntu:19.04\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+  gcc libc6-dev ca-certificates linux-headers-generic\n+\n+RUN apt search linux-headers\n+RUN ls /usr/src\n+\n+ENV PATH=$PATH:/rust/bin"
      },
      {
        "sha": "5563a7b96b28395238aaa57a51dc220c541aad67",
        "filename": "src/rusty/libc/ci/docker/x86_64-unknown-linux-gnux32/Dockerfile",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/x86_64-unknown-linux-gnux32/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/x86_64-unknown-linux-gnux32/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/x86_64-unknown-linux-gnux32/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,5 @@\n+FROM ubuntu:19.04\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+  gcc-multilib libc6-dev ca-certificates\n+ENV PATH=$PATH:/rust/bin"
      },
      {
        "sha": "06a081b751a6ba2b4f2d0bbcbdee60301f0e8b3b",
        "filename": "src/rusty/libc/ci/docker/x86_64-unknown-linux-musl/Dockerfile",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/x86_64-unknown-linux-musl/Dockerfile",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/docker/x86_64-unknown-linux-musl/Dockerfile",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/docker/x86_64-unknown-linux-musl/Dockerfile?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,10 @@\n+FROM ubuntu:19.04\n+\n+RUN apt-get update\n+RUN apt-get install -y --no-install-recommends \\\n+  gcc make libc6-dev git curl ca-certificates\n+\n+COPY install-musl.sh /\n+RUN sh /install-musl.sh x86_64\n+\n+ENV PATH=$PATH:/musl-x86_64/bin:/rust/bin"
      },
      {
        "sha": "febe18b35b83616b8029cdb4a4472b7deeb457c1",
        "filename": "src/rusty/libc/ci/dox.sh",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/dox.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/dox.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/dox.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,74 @@\n+#!/usr/bin/env sh\n+\n+# Builds documentation for all target triples that we have a registered URL for\n+# in liblibc. This scrapes the list of triples to document from `src/lib.rs`\n+# which has a bunch of `html_root_url` directives we pick up.\n+\n+set -ex\n+\n+TARGET_DOC_DIR=target/doc\n+README=README.md\n+PLATFORM_SUPPORT=platform-support.md\n+\n+rm -rf $TARGET_DOC_DIR\n+mkdir -p $TARGET_DOC_DIR\n+\n+if ! rustc --version | grep -E \"nightly\" ; then\n+    echo \"Building the documentation requires a nightly Rust toolchain\"\n+    exit 1\n+fi\n+\n+rustup component add rust-src\n+cargo +nightly install cargo-xbuild -Z install-upgrade\n+\n+# List all targets that do currently build successfully:\n+# shellcheck disable=SC1003\n+grep '[\\d|\\w|-]* \\\\' ci/build.sh > targets\n+sed -i.bak 's/ \\\\//g' targets\n+grep '^[_a-zA-Z0-9-]*$' targets > tmp && mv tmp targets\n+\n+# Create a markdown list of supported platforms in $PLATFORM_SUPPORT\n+rm $PLATFORM_SUPPORT || true\n+\n+printf '### Platform-specific documentation\\n' >> $PLATFORM_SUPPORT\n+\n+while read -r target; do\n+    echo \"documenting ${target}\"\n+\n+    case \"${target}\" in\n+        *apple*)\n+            # FIXME:\n+            # We can't build docs of apple targets from Linux yet.\n+            continue\n+            ;;\n+        *)\n+            ;;\n+    esac\n+\n+    rustup target add \"${target}\" || true\n+\n+    # Enable extra configuration flags:\n+    export RUSTDOCFLAGS=\"--cfg freebsd11\"\n+\n+    # If cargo doc fails, then try xargo:\n+    if ! cargo doc --target \"${target}\" \\\n+             --no-default-features  --features extra_traits ; then\n+        cargo xdoc --target \"${target}\" \\\n+              --no-default-features  --features extra_traits\n+    fi\n+\n+    cp -r \"target/${target}/doc\" \"${TARGET_DOC_DIR}/${target}\"\n+\n+    echo \"* [${target}](${target}/libc/index.html)\" >> $PLATFORM_SUPPORT\n+done < targets\n+\n+# Replace <div class=\"platform_support\"></div> with the contents of $PLATFORM_SUPPORT\n+cp $README $TARGET_DOC_DIR\n+line=$(grep -n '<div class=\"platform_docs\"></div>' $README | cut -d \":\" -f 1)\n+\n+set +x\n+{ head -n \"$((line-1))\" $README; cat $PLATFORM_SUPPORT; tail -n \"+$((line+1))\" $README; } > $TARGET_DOC_DIR/$README\n+set -x\n+\n+# Copy the licenses\n+cp LICENSE-* $TARGET_DOC_DIR/"
      },
      {
        "sha": "0016f5660b0eb13dc81e7317c96c0a348ea44695",
        "filename": "src/rusty/libc/ci/emscripten-entry.sh",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/emscripten-entry.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/emscripten-entry.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/emscripten-entry.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,20 @@\n+#!/usr/bin/env bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+# shellcheck disable=SC1091\n+source /emsdk-portable/emsdk_env.sh &> /dev/null\n+\n+# emsdk-portable provides a node binary, but we need version 8 to run wasm\n+export PATH=\"/node-v12.3.1-linux-x64/bin:$PATH\"\n+\n+exec \"$@\""
      },
      {
        "sha": "acec4ca26f87f7057630fc9a3db3f2c8a550c772",
        "filename": "src/rusty/libc/ci/emscripten.sh",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/emscripten.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/emscripten.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/emscripten.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,52 @@\n+#!/usr/bin/env bash\n+# Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+# file at the top-level directory of this distribution and at\n+# http://rust-lang.org/COPYRIGHT.\n+#\n+# Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+# http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+# <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+# option. This file may not be copied, modified, or distributed\n+# except according to those terms.\n+\n+set -ex\n+\n+hide_output() {\n+  set +x\n+  on_err=\"\n+echo ERROR: An error was encountered with the build.\n+cat /tmp/build.log\n+exit 1\n+\"\n+  trap '$on_err' ERR\n+  bash -c \"while true; do sleep 30; echo \\$(date) - building ...; done\" &\n+  PING_LOOP_PID=$!\n+  \"${@}\" &> /tmp/build.log\n+  trap - ERR\n+  kill $PING_LOOP_PID\n+  rm -f /tmp/build.log\n+  set -x\n+}\n+\n+git clone https://github.com/emscripten-core/emsdk.git /emsdk-portable\n+cd /emsdk-portable\n+# TODO: switch to an upstream install once\n+# https://github.com/rust-lang/rust/pull/63649 lands\n+hide_output ./emsdk install 1.38.42\n+./emsdk activate 1.38.42\n+\n+# Compile and cache libc\n+# shellcheck disable=SC1091\n+source ./emsdk_env.sh\n+echo \"main(){}\" > a.c\n+HOME=/emsdk-portable/ emcc a.c\n+rm -f a.*\n+\n+# Make emsdk usable by any user\n+cp /root/.emscripten /emsdk-portable\n+chmod a+rxw -R /emsdk-portable\n+\n+# node 8 is required to run wasm\n+cd /\n+curl --retry 5 -L https://nodejs.org/dist/v12.3.1/node-v12.3.1-linux-x64.tar.xz | \\\n+    tar -xJ"
      },
      {
        "sha": "d6ec17e60466d75d0240ddbeca334b1089bb7501",
        "filename": "src/rusty/libc/ci/install-musl.sh",
        "status": "added",
        "additions": 83,
        "deletions": 0,
        "changes": 83,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/install-musl.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/install-musl.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/install-musl.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,83 @@\n+#!/usr/bin/env sh\n+#\n+# Install musl and musl-sanitized linux kernel headers\n+# to musl-{$1} directory\n+\n+set -ex\n+\n+MUSL_VERSION=1.1.22\n+MUSL=\"musl-${MUSL_VERSION}\"\n+\n+# Download, configure, build, and install musl:\n+curl --retry 5 https://www.musl-libc.org/releases/${MUSL}.tar.gz | tar xzf -\n+\n+cd $MUSL\n+case ${1} in\n+    aarch64)\n+        musl_arch=aarch64\n+        kernel_arch=arm64\n+        CC=aarch64-linux-gnu-gcc \\\n+          ./configure --prefix=\"/musl-${musl_arch}\" --enable-wrapper=yes\n+        make install -j4\n+        ;;\n+    arm)\n+        musl_arch=arm\n+        kernel_arch=arm\n+        CC=arm-linux-gnueabihf-gcc CFLAGS=\"-march=armv6 -marm -mfpu=vfp\" \\\n+          ./configure --prefix=\"/musl-${musl_arch}\" --enable-wrapper=yes\n+        make install -j4\n+        ;;\n+    i686)\n+        # cross-compile musl for i686 using the system compiler on an x86_64\n+        # system.\n+        musl_arch=i686\n+        kernel_arch=i386\n+        # Specifically pass -m32 in CFLAGS and override CC when running\n+        # ./configure, since otherwise the script will fail to find a compiler.\n+        CC=gcc CFLAGS=\"-m32\" \\\n+          ./configure --prefix=\"/musl-${musl_arch}\" --disable-shared --target=i686\n+        # unset CROSS_COMPILE when running make; otherwise the makefile will\n+        # call the non-existent binary 'i686-ar'.\n+        make CROSS_COMPILE= install -j4\n+        ;;\n+    x86_64)\n+        musl_arch=x86_64\n+        kernel_arch=x86_64\n+        ./configure --prefix=\"/musl-${musl_arch}\"\n+        make install -j4\n+        ;;\n+    mips64)\n+        musl_arch=mips64\n+        kernel_arch=mips\n+        CC=mips64-linux-gnuabi64-gcc CFLAGS=\"-march=mips64r2 -mabi=64\" \\\n+          ./configure --prefix=\"/musl-${musl_arch}\" --enable-wrapper=yes\n+        make install -j4\n+        ;;\n+    mips64el)\n+        musl_arch=mips64el\n+        kernel_arch=mips\n+        CC=mips64el-linux-gnuabi64-gcc CFLAGS=\"-march=mips64r2 -mabi=64\" \\\n+          ./configure --prefix=\"/musl-${musl_arch}\" --enable-wrapper=yes\n+        make install -j4\n+        ;;\n+    *)\n+        echo \"Unknown target arch: \\\"${1}\\\"\"\n+        exit 1\n+        ;;\n+esac\n+\n+\n+# shellcheck disable=SC2103\n+cd ..\n+rm -rf $MUSL\n+\n+# Download, configure, build, and install musl-sanitized kernel headers:\n+KERNEL_HEADER_VER=\"4.4.2-2\"\n+curl --retry 5 -L \\\n+     \"https://github.com/sabotage-linux/kernel-headers/archive/v${KERNEL_HEADER_VER}.tar.gz\" | \\\n+    tar xzf -\n+(\n+    cd kernel-headers-${KERNEL_HEADER_VER}\n+    make ARCH=\"${kernel_arch}\" prefix=\"/musl-${musl_arch}\" install -j4\n+)\n+rm -rf kernel-headers-${KERNEL_HEADER_VER}"
      },
      {
        "sha": "2075be6d62007c726dfb4a48d9dc83bca64155e3",
        "filename": "src/rusty/libc/ci/ios/deploy_and_run_on_ios_simulator.rs",
        "status": "added",
        "additions": 175,
        "deletions": 0,
        "changes": 175,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/ios/deploy_and_run_on_ios_simulator.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/ios/deploy_and_run_on_ios_simulator.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/ios/deploy_and_run_on_ios_simulator.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,175 @@\n+// Copyright 2017 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// This is a script to deploy and execute a binary on an iOS simulator.\n+// The primary use of this is to be able to run unit tests on the simulator and\n+// retrieve the results.\n+//\n+// To do this through Cargo instead, use Dinghy\n+// (https://github.com/snipsco/dinghy): cargo dinghy install, then cargo dinghy\n+// test.\n+\n+use std::env;\n+use std::fs::{self, File};\n+use std::io::Write;\n+use std::path::Path;\n+use std::process;\n+use std::process::Command;\n+\n+macro_rules! t {\n+    ($e:expr) => (match $e {\n+        Ok(e) => e,\n+        Err(e) => panic!(\"{} failed with: {}\", stringify!($e), e),\n+    })\n+}\n+\n+// Step one: Wrap as an app\n+fn package_as_simulator_app(crate_name: &str, test_binary_path: &Path) {\n+    println!(\"Packaging simulator app\");\n+    drop(fs::remove_dir_all(\"ios_simulator_app\"));\n+    t!(fs::create_dir(\"ios_simulator_app\"));\n+    t!(fs::copy(test_binary_path,\n+                Path::new(\"ios_simulator_app\").join(crate_name)));\n+\n+    let mut f = t!(File::create(\"ios_simulator_app/Info.plist\"));\n+    t!(f.write_all(format!(r#\"\n+        <?xml version=\"1.0\" encoding=\"UTF-8\"?>\n+        <!DOCTYPE plist PUBLIC\n+                \"-//Apple//DTD PLIST 1.0//EN\"\n+                \"http://www.apple.com/DTDs/PropertyList-1.0.dtd\">\n+        <plist version=\"1.0\">\n+            <dict>\n+                <key>CFBundleExecutable</key>\n+                <string>{}</string>\n+                <key>CFBundleIdentifier</key>\n+                <string>com.rust.unittests</string>\n+            </dict>\n+        </plist>\n+    \"#, crate_name).as_bytes()));\n+}\n+\n+// Step two: Start the iOS simulator\n+fn start_simulator() {\n+    println!(\"Looking for iOS simulator\");\n+    let output = t!(Command::new(\"xcrun\").arg(\"simctl\").arg(\"list\").output());\n+    assert!(output.status.success());\n+    let mut simulator_exists = false;\n+    let mut simulator_booted = false;\n+    let mut found_rust_sim = false;\n+    let stdout = t!(String::from_utf8(output.stdout));\n+    for line in stdout.lines() {\n+        if line.contains(\"rust_ios\") {\n+            if found_rust_sim {\n+                panic!(\"Duplicate rust_ios simulators found. Please \\\n+                        double-check xcrun simctl list.\");\n+            }\n+            simulator_exists = true;\n+            simulator_booted = line.contains(\"(Booted)\");\n+            found_rust_sim = true;\n+        }\n+    }\n+\n+    if simulator_exists == false {\n+        println!(\"Creating iOS simulator\");\n+        Command::new(\"xcrun\")\n+                .arg(\"simctl\")\n+                .arg(\"create\")\n+                .arg(\"rust_ios\")\n+                .arg(\"com.apple.CoreSimulator.SimDeviceType.iPhone-SE\")\n+                .arg(\"com.apple.CoreSimulator.SimRuntime.iOS-10-2\")\n+                .check_status();\n+    } else if simulator_booted == true {\n+        println!(\"Shutting down already-booted simulator\");\n+        Command::new(\"xcrun\")\n+                .arg(\"simctl\")\n+                .arg(\"shutdown\")\n+                .arg(\"rust_ios\")\n+                .check_status();\n+    }\n+\n+    println!(\"Starting iOS simulator\");\n+    // We can't uninstall the app (if present) as that will hang if the\n+    // simulator isn't completely booted; just erase the simulator instead.\n+    Command::new(\"xcrun\").arg(\"simctl\").arg(\"erase\").arg(\"rust_ios\").check_status();\n+    Command::new(\"xcrun\").arg(\"simctl\").arg(\"boot\").arg(\"rust_ios\").check_status();\n+}\n+\n+// Step three: Install the app\n+fn install_app_to_simulator() {\n+    println!(\"Installing app to simulator\");\n+    Command::new(\"xcrun\")\n+            .arg(\"simctl\")\n+            .arg(\"install\")\n+            .arg(\"booted\")\n+            .arg(\"ios_simulator_app/\")\n+            .check_status();\n+}\n+\n+// Step four: Run the app\n+fn run_app_on_simulator() {\n+    println!(\"Running app\");\n+    let output = t!(Command::new(\"xcrun\")\n+                    .arg(\"simctl\")\n+                    .arg(\"launch\")\n+                    .arg(\"--console\")\n+                    .arg(\"booted\")\n+                    .arg(\"com.rust.unittests\")\n+                    .output());\n+\n+    println!(\"status: {}\", output.status);\n+    println!(\"stdout --\\n{}\\n\", String::from_utf8_lossy(&output.stdout));\n+    println!(\"stderr --\\n{}\\n\", String::from_utf8_lossy(&output.stderr));\n+\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    let passed = stdout.lines()\n+                       .find(|l|\n+                             (l.contains(\"PASSED\") &&\n+                              l.contains(\"tests\")) ||\n+                             l.contains(\"test result: ok\")\n+                        )\n+                       .unwrap_or(false);\n+\n+    println!(\"Shutting down simulator\");\n+    Command::new(\"xcrun\")\n+        .arg(\"simctl\")\n+        .arg(\"shutdown\")\n+        .arg(\"rust_ios\")\n+        .check_status();\n+    if !passed {\n+        panic!(\"tests didn't pass\");\n+    }\n+}\n+\n+trait CheckStatus {\n+    fn check_status(&mut self);\n+}\n+\n+impl CheckStatus for Command {\n+    fn check_status(&mut self) {\n+        println!(\"\\trunning: {:?}\", self);\n+        assert!(t!(self.status()).success());\n+    }\n+}\n+\n+fn main() {\n+    let args: Vec<String> = env::args().collect();\n+    if args.len() != 2 {\n+        println!(\"Usage: {} <executable>\", args[0]);\n+        process::exit(-1);\n+    }\n+\n+    let test_binary_path = Path::new(&args[1]);\n+    let crate_name = test_binary_path.file_name().unwrap();\n+\n+    package_as_simulator_app(crate_name.to_str().unwrap(), test_binary_path);\n+    start_simulator();\n+    install_app_to_simulator();\n+    run_app_on_simulator();\n+}"
      },
      {
        "sha": "00a7f88180b7240c92251b19224ff34e2dba650e",
        "filename": "src/rusty/libc/ci/linux-s390x.sh",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/linux-s390x.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/linux-s390x.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/linux-s390x.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,20 @@\n+#!/usr/bin/env sh\n+\n+set -ex\n+\n+mkdir -m 777 /qemu\n+cd /qemu\n+\n+curl --retry 5 -LO https://github.com/qemu/qemu/raw/master/pc-bios/s390-ccw.img\n+curl --retry 5 -LO http://ftp.debian.org/debian/dists/testing/main/installer-s390x/20190410/images/generic/kernel.debian\n+curl --retry 5 -LO http://ftp.debian.org/debian/dists/testing/main/installer-s390x/20190410/images/generic/initrd.debian\n+\n+mv kernel.debian kernel\n+mv initrd.debian initrd.gz\n+\n+mkdir init\n+cd init\n+gunzip -c ../initrd.gz | cpio -id\n+rm ../initrd.gz\n+cp /usr/s390x-linux-gnu/lib/libgcc_s.so.1 usr/lib/\n+chmod a+w ."
      },
      {
        "sha": "5580a0e3c30ea13cbec08e324e6446fd8f5f0864",
        "filename": "src/rusty/libc/ci/linux-sparc64.sh",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/linux-sparc64.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/linux-sparc64.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/linux-sparc64.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,19 @@\n+#!/usr/bin/env sh\n+\n+set -ex\n+\n+mkdir -m 777 /qemu\n+cd /qemu\n+\n+curl --retry 5 -LO https://cdimage.debian.org/cdimage/ports/10.0/sparc64/iso-cd/debian-10.0-sparc64-NETINST-1.iso\n+7z e debian-10.0-sparc64-NETINST-1.iso boot/initrd.gz\n+7z e debian-10.0-sparc64-NETINST-1.iso boot/sparc64\n+mv sparc64 kernel\n+rm debian-10.0-sparc64-NETINST-1.iso\n+\n+mkdir init\n+cd init\n+gunzip -c ../initrd.gz | cpio -id\n+rm ../initrd.gz\n+cp /usr/sparc64-linux-gnu/lib/libgcc_s.so.1 usr/lib/\n+chmod a+w ."
      },
      {
        "sha": "3c0736a265f7bdd042f3315d2dca6ce6085378e0",
        "filename": "src/rusty/libc/ci/run-docker.sh",
        "status": "added",
        "additions": 46,
        "deletions": 0,
        "changes": 46,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/run-docker.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/run-docker.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/run-docker.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,46 @@\n+#!/usr/bin/env sh\n+\n+# Small script to run tests for a target (or all targets) inside all the\n+# respective docker images.\n+\n+set -ex\n+\n+echo \"${HOME}\"\n+pwd\n+\n+run() {\n+    echo \"Building docker container for target ${1}\"\n+\n+    # use -f so we can use ci/ as build context\n+    docker build -t libc -f \"ci/docker/${1}/Dockerfile\" ci/\n+    mkdir -p target\n+    if [ -w /dev/kvm ]; then\n+        kvm=\"--volume /dev/kvm:/dev/kvm\"\n+    else\n+        kvm=\"\"\n+    fi\n+\n+    docker run \\\n+      --rm \\\n+      --user \"$(id -u)\":\"$(id -g)\" \\\n+      --env LIBC_CI \\\n+      --env CARGO_HOME=/cargo \\\n+      --env CARGO_TARGET_DIR=/checkout/target \\\n+      --volume \"$(dirname \"$(dirname \"$(command -v cargo)\")\")\":/cargo \\\n+      --volume \"$(rustc --print sysroot)\":/rust:ro \\\n+      --volume \"$(pwd)\":/checkout:ro \\\n+      --volume \"$(pwd)\"/target:/checkout/target \\\n+      $kvm \\\n+      --init \\\n+      --workdir /checkout \\\n+      libc \\\n+      sh -c \"HOME=/tmp PATH=\\$PATH:/rust/bin exec ci/run.sh ${1}\"\n+}\n+\n+if [ -z \"${1}\" ]; then\n+  for d in ci/docker/*; do\n+    run \"${d}\"\n+  done\n+else\n+  run \"${1}\"\n+fi"
      },
      {
        "sha": "6fba6298768f4b06606d62e602a137e095166c03",
        "filename": "src/rusty/libc/ci/run-qemu.sh",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/run-qemu.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/run-qemu.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/run-qemu.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,34 @@\n+#!/usr/bin/env sh\n+\n+# Initial script which is run inside of all qemu images. The first argument to\n+# this script (as arranged by the qemu image itself) is the path to where the\n+# libc crate is mounted.\n+#\n+# For qemu images we currently need to install Rust manually as this wasn't done\n+# by the initial run-travis.sh script\n+#\n+# FIXME: feels like run-travis.sh should be responsible for downloading the\n+#        compiler.\n+\n+set -ex\n+\n+ROOT=\"${1}\"\n+cp -r \"${ROOT}/libc\" /tmp/libc\n+cd /tmp/libc\n+\n+TARGET=\"$(cat \"${ROOT}/TARGET\")\"\n+export CARGO_TARGET_DIR=/tmp\n+\n+case $TARGET in\n+  *-openbsd)\n+    pkg_add cargo gcc%4.9 rust\n+    export CC=egcc\n+    ;;\n+\n+  *)\n+    echo \"Unknown target: ${TARGET}\"\n+    exit 1\n+    ;;\n+esac\n+\n+exec sh ci/run.sh \"${TARGET}\""
      },
      {
        "sha": "e863085d9a15e3e0517f76109165958c75b58490",
        "filename": "src/rusty/libc/ci/run.sh",
        "status": "added",
        "additions": 98,
        "deletions": 0,
        "changes": 98,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/run.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/run.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/run.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,98 @@\n+#!/usr/bin/env sh\n+\n+# Builds and runs tests for a particular target passed as an argument to this\n+# script.\n+\n+set -ex\n+\n+MIRRORS_URL=\"https://rust-lang-ci-mirrors.s3-us-west-1.amazonaws.com/libc\"\n+\n+TARGET=\"${1}\"\n+\n+# If we're going to run tests inside of a qemu image, then we don't need any of\n+# the scripts below. Instead, download the image, prepare a filesystem which has\n+# the current state of this repository, and then run the image.\n+#\n+# It's assume that all images, when run with two disks, will run the `run.sh`\n+# script from the second which we place inside.\n+if [ \"$QEMU\" != \"\" ]; then\n+  tmpdir=/tmp/qemu-img-creation\n+  mkdir -p \"${tmpdir}\"\n+\n+  if [ -z \"${QEMU#*.gz}\" ]; then\n+    # image is .gz : download and uncompress it\n+    qemufile=\"$(echo \"${QEMU%.gz}\" | sed 's/\\//__/g')\"\n+    if [ ! -f \"${tmpdir}/${qemufile}\" ]; then\n+      curl --retry 5 \"${MIRRORS_URL}/${QEMU}\" | \\\n+          gunzip -d > \"${tmpdir}/${qemufile}\"\n+    fi\n+  elif [ -z \"${QEMU#*.xz}\" ]; then\n+    # image is .xz : download and uncompress it\n+    qemufile=\"$(echo \"${QEMU%.xz}\" | sed 's/\\//__/g')\"\n+    if [ ! -f \"${tmpdir}/${qemufile}\" ]; then\n+      curl --retry 5 \"${MIRRORS_URL}/${QEMU}\" | \\\n+          unxz > \"${tmpdir}/${qemufile}\"\n+    fi\n+  else\n+    # plain qcow2 image: just download it\n+    qemufile=\"$(echo \"${QEMU}\" | sed 's/\\//__/g')\"\n+    if [ ! -f \"${tmpdir}/${qemufile}\" ]; then\n+      curl --retry 5 \"${MIRRORS_URL}/${QEMU}\" | \\\n+        > \"${tmpdir}/${qemufile}\"\n+    fi\n+  fi\n+\n+  # Create a mount a fresh new filesystem image that we'll later pass to QEMU.\n+  # This will have a `run.sh` script will which use the artifacts inside to run\n+  # on the host.\n+  rm -f \"${tmpdir}/libc-test.img\"\n+  mkdir \"${tmpdir}/mount\"\n+\n+  # Do the standard rigamarole of cross-compiling an executable and then the\n+  # script to run just executes the binary.\n+  cargo build \\\n+    --manifest-path libc-test/Cargo.toml \\\n+    --target \"${TARGET}\" \\\n+    --test main\n+  rm \"${CARGO_TARGET_DIR}/${TARGET}\"/debug/main-*.d\n+  cp \"${CARGO_TARGET_DIR}/${TARGET}\"/debug/main-* \"${tmpdir}\"/mount/libc-test\n+  # shellcheck disable=SC2016\n+  echo 'exec $1/libc-test' > \"${tmpdir}/mount/run.sh\"\n+\n+  du -sh \"${tmpdir}/mount\"\n+  genext2fs \\\n+      --root \"${tmpdir}/mount\" \\\n+      --size-in-blocks 100000 \\\n+      \"${tmpdir}/libc-test.img\"\n+\n+  # Pass -snapshot to prevent tampering with the disk images, this helps when\n+  # running this script in development. The two drives are then passed next,\n+  # first is the OS and second is the one we just made. Next the network is\n+  # configured to work (I'm not entirely sure how), and then finally we turn off\n+  # graphics and redirect the serial console output to out.log.\n+  qemu-system-x86_64 \\\n+    -m 1024 \\\n+    -snapshot \\\n+    -drive if=virtio,file=\"${tmpdir}/${qemufile}\" \\\n+    -drive if=virtio,file=\"${tmpdir}/libc-test.img\" \\\n+    -net nic,model=virtio \\\n+    -net user \\\n+    -nographic \\\n+    -vga none 2>&1 | tee \"${CARGO_TARGET_DIR}/out.log\"\n+  exec egrep \"^(PASSED)|(test result: ok)\" \"${CARGO_TARGET_DIR}/out.log\"\n+fi\n+\n+# FIXME: x86_64-unknown-linux-gnux32 fail to compile without --release\n+# See https://github.com/rust-lang/rust/issues/45417\n+opt=\n+if [ \"$TARGET\" = \"x86_64-unknown-linux-gnux32\" ]; then\n+  opt=\"--release\"\n+fi\n+\n+cargo test -vv $opt --no-default-features --manifest-path libc-test/Cargo.toml \\\n+      --target \"${TARGET}\"\n+\n+cargo test -vv $opt --manifest-path libc-test/Cargo.toml --target \"${TARGET}\"\n+\n+cargo test -vv $opt --features extra_traits --manifest-path libc-test/Cargo.toml \\\n+      --target \"${TARGET}\""
      },
      {
        "sha": "b8030c41a7f6fde9803bc99d1dda9947d6e1dbb8",
        "filename": "src/rusty/libc/ci/runtest-android.rs",
        "status": "added",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/runtest-android.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/runtest-android.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/runtest-android.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,47 @@\n+use std::env;\n+use std::process::Command;\n+use std::path::{Path, PathBuf};\n+\n+fn main() {\n+    let args = env::args_os()\n+        .skip(1)\n+        .filter(|arg| arg != \"--quiet\")\n+        .collect::<Vec<_>>();\n+    assert_eq!(args.len(), 1);\n+    let test = PathBuf::from(&args[0]);\n+    let dst = Path::new(\"/data/local/tmp\").join(test.file_name().unwrap());\n+\n+    let status = Command::new(\"adb\")\n+        .arg(\"wait-for-device\")\n+        .status()\n+        .expect(\"failed to run: adb wait-for-device\");\n+    assert!(status.success());\n+\n+    let status = Command::new(\"adb\")\n+        .arg(\"push\")\n+        .arg(&test)\n+        .arg(&dst)\n+        .status()\n+        .expect(\"failed to run: adb pushr\");\n+    assert!(status.success());\n+\n+    let output = Command::new(\"adb\")\n+        .arg(\"shell\")\n+        .arg(&dst)\n+        .output()\n+        .expect(\"failed to run: adb shell\");\n+    assert!(status.success());\n+\n+    println!(\"status: {}\\nstdout ---\\n{}\\nstderr ---\\n{}\",\n+             output.status,\n+             String::from_utf8_lossy(&output.stdout),\n+             String::from_utf8_lossy(&output.stderr));\n+\n+    let stdout = String::from_utf8_lossy(&output.stdout);\n+    stdout.lines().find(|l|\n+        (l.starts_with(\"PASSED \") && l.contains(\" tests\")) ||\n+        l.starts_with(\"test result: ok\")\n+    ).unwrap_or_else(|| {\n+        panic!(\"failed to find successful test run\");\n+    });\n+}"
      },
      {
        "sha": "3412501a7215b20b33d66b339781fa82a9cd2a16",
        "filename": "src/rusty/libc/ci/semver.sh",
        "status": "added",
        "additions": 77,
        "deletions": 0,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/semver.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/semver.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/semver.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,77 @@\n+#!/usr/bin/env sh\n+\n+# Checks that libc does not contain breaking changes for the following targets.\n+\n+set -ex\n+\n+OS=${1}\n+\n+echo \"Testing Semver on ${OS}\"\n+\n+if ! rustc --version | grep -E \"nightly\" ; then\n+    echo \"Building semverver requires a nightly Rust toolchain\"\n+    exit 1\n+fi\n+\n+cargo +nightly install semverver -Z install-upgrade\n+\n+TARGETS=\n+case \"${OS}\" in\n+    *linux*)\n+        TARGETS=\"\\\n+aarch64-fuchsia \\\n+aarch64-linux-android \\\n+aarch64-unknown-linux-gnu \\\n+aarch64-unknown-linux-musl \\\n+armv7-linux-androideabi \\\n+armv7-unknown-linux-gnueabihf \\\n+i586-unknown-linux-gnu \\\n+i586-unknown-linux-musl \\\n+i686-linux-android \\\n+i686-unknown-freebsd \\\n+i686-unknown-linux-gnu \\\n+i686-unknown-linux-musl \\\n+i686-pc-windows-gnu \\\n+x86_64-unknown-freebsd \\\n+x86_64-unknown-linux-gnu \\\n+x86_64-unknown-linux-musl \\\n+x86_64-unknown-netbsd \\\n+x86_64-unknown-cloudabi \\\n+x86_64-sun-solaris \\\n+x86_64-fuchsia \\\n+x86_64-pc-windows-gnu \\\n+x86_64-unknown-linux-gnux32 \\\n+x86_64-unknown-redox \\\n+x86_64-fortanix-unknown-sgx \\\n+wasm32-unknown-unknown \\\n+\"\n+    ;;\n+    *osx*)\n+        TARGETS=\"\\\n+aarch64-apple-ios \\\n+armv7-apple-ios \\\n+armv7s-apple-ios \\\n+i386-apple-ios \\\n+i686-apple-darwin \\\n+x86_64-apple-darwin \\\n+x86_64-apple-ios \\\n+\"\n+    ;;\n+esac\n+\n+for TARGET in $TARGETS; do\n+    # FIXME: rustup often fails to download some artifacts due to network\n+    # issues, so we retry this N times.\n+    N=5\n+    n=0\n+    until [ $n -ge $N ]\n+    do\n+        if rustup target add \"${TARGET}\" ; then\n+            break\n+        fi\n+        n=$((n+1))\n+        sleep 1\n+    done\n+\n+    cargo +nightly semver --api-guidelines --target=\"${TARGET}\"\n+done"
      },
      {
        "sha": "dcb3536ec30bab51411c6540a6f7c907a43599f7",
        "filename": "src/rusty/libc/ci/style.rs",
        "status": "added",
        "additions": 208,
        "deletions": 0,
        "changes": 208,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/style.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/style.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/style.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,208 @@\n+//! Simple script to verify the coding style of this library\n+//!\n+//! ## How to run\n+//!\n+//! The first argument to this script is the directory to run on, so running\n+//! this script should be as simple as:\n+//!\n+//! ```notrust\n+//! rustc ci/style.rs\n+//! ./style src\n+//! ```\n+//!\n+//! ## Guidelines\n+//!\n+//! The current style is:\n+//!\n+//! * No trailing whitespace\n+//! * No tabs\n+//! * 80-character lines\n+//! * Specific module layout:\n+//!     1. use directives\n+//!     2. typedefs\n+//!     3. structs\n+//!     4. constants\n+//!     5. f! { ... } functions\n+//!     6. extern functions\n+//!     7. modules + pub use\n+//!\n+//! Things not verified:\n+//!\n+//! * alignment\n+//! * 4-space tabs\n+//! * leading colons on paths\n+\n+use std::env;\n+use std::fs;\n+use std::io::prelude::*;\n+use std::path::Path;\n+\n+macro_rules! t {\n+    ($e:expr) => (match $e {\n+        Ok(e) => e,\n+        Err(e) => panic!(\"{} failed with {}\", stringify!($e), e),\n+    })\n+}\n+\n+fn main() {\n+    let arg = env::args().skip(1).next().unwrap_or(\".\".to_string());\n+\n+    let mut errors = Errors { errs: false };\n+    walk(Path::new(&arg), &mut errors);\n+\n+    if errors.errs {\n+        panic!(\"found some lint errors\");\n+    } else {\n+        println!(\"good style!\");\n+    }\n+}\n+\n+fn walk(path: &Path, err: &mut Errors) {\n+    for entry in t!(path.read_dir()).map(|e| t!(e)) {\n+        let path = entry.path();\n+        if t!(entry.file_type()).is_dir() {\n+            walk(&path, err);\n+            continue\n+        }\n+\n+        let name = entry.file_name().into_string().unwrap();\n+        match &name[..] {\n+            n if !n.ends_with(\".rs\") => continue,\n+\n+            \"dox.rs\" |\n+            \"lib.rs\" |\n+            \"ctypes.rs\" |\n+            \"libc.rs\" |\n+            \"macros.rs\" => continue,\n+\n+            _ => {}\n+        }\n+\n+        let mut contents = String::new();\n+        t!(t!(fs::File::open(&path)).read_to_string(&mut contents));\n+\n+        check_style(&contents, &path, err);\n+    }\n+}\n+\n+struct Errors {\n+    errs: bool,\n+}\n+\n+#[derive(Clone, Copy, PartialEq)]\n+enum State {\n+    Start,\n+    Imports,\n+    Typedefs,\n+    Structs,\n+    Constants,\n+    FunctionDefinitions,\n+    Functions,\n+    Modules,\n+}\n+\n+fn check_style(file: &str, path: &Path, err: &mut Errors) {\n+    let mut state = State::Start;\n+    let mut s_macros = 0;\n+    let mut f_macros = 0;\n+    let mut prev_blank = false;\n+\n+    for (i, line) in file.lines().enumerate() {\n+        if line == \"\" {\n+            if prev_blank {\n+                err.error(path, i, \"double blank line\");\n+            }\n+            prev_blank = true;\n+        } else {\n+            prev_blank = false;\n+        }\n+        if line != line.trim_end() {\n+            err.error(path, i, \"trailing whitespace\");\n+        }\n+        if line.contains(\"\\t\") {\n+            err.error(path, i, \"tab character\");\n+        }\n+        if line.len() > 80 {\n+            err.error(path, i, \"line longer than 80 chars\");\n+        }\n+        if line.contains(\"#[cfg(\") && !line.contains(\" if \")\n+            && !(line.contains(\"target_endian\") ||\n+                 line.contains(\"target_arch\"))\n+        {\n+            if state != State::Structs {\n+                err.error(path, i, \"use cfg_if! and submodules \\\n+                                    instead of #[cfg]\");\n+            }\n+        }\n+\n+        let line = line.trim_start();\n+        let is_pub = line.starts_with(\"pub \");\n+        let line = if is_pub {&line[4..]} else {line};\n+\n+        let line_state = if line.starts_with(\"use \") {\n+            if line.contains(\"c_void\") {\n+                continue;\n+            }\n+            if is_pub {\n+                State::Modules\n+            } else {\n+                State::Imports\n+            }\n+        } else if line.starts_with(\"const \") {\n+            State::Constants\n+        } else if line.starts_with(\"type \") {\n+            State::Typedefs\n+        } else if line.starts_with(\"s! {\") {\n+            s_macros += 1;\n+            State::Structs\n+        } else if line.starts_with(\"f! {\") {\n+            f_macros += 1;\n+            State::FunctionDefinitions\n+        } else if line.starts_with(\"extern \") {\n+            State::Functions\n+        } else if line.starts_with(\"mod \") {\n+            State::Modules\n+        } else {\n+            continue\n+        };\n+\n+        if state as usize > line_state as usize {\n+            err.error(path, i, &format!(\"{} found after {} when \\\n+                                         it belongs before\",\n+                                        line_state.desc(), state.desc()));\n+        }\n+\n+        if f_macros == 2 {\n+            f_macros += 1;\n+            err.error(path, i, \"multiple f! macros in one module\");\n+        }\n+        if s_macros == 2 {\n+            s_macros += 1;\n+            err.error(path, i, \"multiple s! macros in one module\");\n+        }\n+\n+        state = line_state;\n+    }\n+}\n+\n+impl State {\n+    fn desc(&self) -> &str {\n+        match *self {\n+            State::Start => \"start\",\n+            State::Imports => \"import\",\n+            State::Typedefs => \"typedef\",\n+            State::Structs => \"struct\",\n+            State::Constants => \"constant\",\n+            State::FunctionDefinitions => \"function definition\",\n+            State::Functions => \"extern function\",\n+            State::Modules => \"module\",\n+        }\n+    }\n+}\n+\n+impl Errors {\n+    fn error(&mut self, path: &Path, line: usize, msg: &str) {\n+        self.errs = true;\n+        println!(\"{}:{} - {}\", path.display(), line + 1, msg);\n+    }\n+}"
      },
      {
        "sha": "a6a00171019e4db82407f1ec128ebb584294a08a",
        "filename": "src/rusty/libc/ci/style.sh",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/style.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/style.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/style.sh?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,19 @@\n+#!/usr/bin/env sh\n+\n+set -ex\n+\n+rustc ci/style.rs && ./style src\n+\n+if rustup component add rustfmt-preview ; then\n+    which rustfmt\n+    rustfmt -V\n+    cargo fmt --all -- --check\n+fi\n+\n+if shellcheck --version ; then\n+    shellcheck -e SC2103 ci/*.sh\n+else\n+    echo \"shellcheck not found\"\n+    exit 1\n+fi\n+"
      },
      {
        "sha": "bc1894879d7f705d67f6f30074a47e11c19ba9b1",
        "filename": "src/rusty/libc/ci/switch.json",
        "status": "added",
        "additions": 37,
        "deletions": 0,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/switch.json",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/switch.json",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/switch.json?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,37 @@\n+{\n+  \"family\": \"unix\",\n+  \"env\": \"newlib\",\n+  \"target-env\": \"newlib\",\n+  \"target-family\": \"unix\",\n+  \"target-c-int-width\": \"32\",\n+  \"target-endian\": \"little\",\n+  \"target-pointer-width\": \"64\",\n+  \"os\": \"horizon\",\n+  \"arch\": \"aarch64\",\n+  \"panic-strategy\": \"unwind\",\n+  \"abi-blacklist\": [\n+      \"stdcall\",\n+      \"fastcall\",\n+      \"vectorcall\",\n+      \"thiscall\",\n+      \"win64\",\n+      \"sysv64\"\n+  ],\n+  \"dynamic-linking\" : false,\n+  \"features\": \"+a53,+strict-align\",\n+  \"data-layout\": \"e-m:e-i8:8:32-i16:16:32-i64:64-i128:128-n32:64-S128\",\n+  \"executables\": true,\n+  \"position-independent-executables\" : true,\n+  \"linker-flavor\": \"gcc\",\n+  \"llvm-target\": \"aarch64-unknown-none\",\n+  \"has-elf-tls\" : false,\n+  \"linker-is-gnu\" : true,\n+  \"disable-redzone\" : true,\n+  \"relocation-model\" : \"pic\",\n+  \"max-atomic-width\": 128,\n+  \"exe-suffix\": \".elf\",\n+  \"staticlib-suffix\" : \".a\",\n+  \"trap-unreachable\" : true,\n+  \"emit-debug-gdb-scripts\" : true,\n+  \"requires-uwtable\" : true\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "cad31ec4c0100a59308876587b52585652c2cbe8",
        "filename": "src/rusty/libc/ci/test-runner-linux",
        "status": "added",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/test-runner-linux",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/ci/test-runner-linux",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/ci/test-runner-linux?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,25 @@\n+#!/bin/sh\n+\n+set -e\n+\n+arch=$1\n+prog=$2\n+\n+cd /qemu/init\n+echo \"#!/bin/sh\\n/prog --color=never\" > run_prog.sh\n+chmod +x run_prog.sh\n+cp -f $2 prog\n+find . | cpio --create --format='newc' --quiet | gzip > ../initrd.gz\n+cd ..\n+\n+timeout 30s qemu-system-$arch \\\n+  -m 1024 \\\n+  -nographic \\\n+  -kernel kernel \\\n+  -initrd initrd.gz \\\n+  -append init=/run_prog.sh > output || true\n+\n+# remove kernel messages\n+tr -d '\\r' < output | egrep -v '^\\['\n+\n+egrep \"(PASSED)|(test result: ok)\" output > /dev/null"
      },
      {
        "sha": "8d2d9033308b7fb0ff42b0fec5b81e92877f0791",
        "filename": "src/rusty/libc/libc-test/Cargo.toml",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/libc-test/Cargo.toml?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,54 @@\n+[package]\n+name = \"libc-test\"\n+version = \"0.1.0\"\n+authors = [\"Alex Crichton <alex@alexcrichton.com>\"]\n+build = \"build.rs\"\n+\n+[dependencies.libc]\n+path = \"..\"\n+default-features = false\n+\n+[build-dependencies]\n+cc = \"1.0\"\n+ctest = \"0.2\"\n+\n+[features]\n+default = [ \"std\" ]\n+std = [ \"libc/std\" ]\n+align = [ \"libc/align\" ]\n+extra_traits = [ \"libc/extra_traits\" ]\n+\n+[[test]]\n+name = \"main\"\n+path = \"test/main.rs\"\n+harness = false\n+\n+[[test]]\n+name = \"linux-fcntl\"\n+path = \"test/linux_fcntl.rs\"\n+harness = false\n+\n+[[test]]\n+name = \"linux-ipv6\"\n+path = \"test/linux_ipv6.rs\"\n+harness = false\n+\n+[[test]]\n+name = \"linux-elf\"\n+path = \"test/linux_elf.rs\"\n+harness = false\n+\n+[[test]]\n+name = \"linux-strerror_r\"\n+path = \"test/linux_strerror_r.rs\"\n+harness = false\n+\n+[[test]]\n+name = \"linux-termios\"\n+path = \"test/linux_termios.rs\"\n+harness = false\n+\n+[[test]]\n+name = \"cmsg\"\n+path = \"test/cmsg.rs\"\n+harness = true"
      },
      {
        "sha": "d6982fc9525d8ba547d16669950dbf2972172704",
        "filename": "src/rusty/libc/libc-test/build.rs",
        "status": "added",
        "additions": 2537,
        "deletions": 0,
        "changes": 2537,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/build.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/build.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/libc-test/build.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,2537 @@\n+#![deny(warnings)]\n+\n+extern crate cc;\n+extern crate ctest;\n+\n+use std::env;\n+\n+fn do_cc() {\n+    let target = env::var(\"TARGET\").unwrap();\n+    if cfg!(unix) && !target.contains(\"wasi\") {\n+        cc::Build::new().file(\"src/cmsg.c\").compile(\"cmsg\");\n+    }\n+}\n+\n+fn do_ctest() {\n+    match &env::var(\"TARGET\").unwrap() {\n+        t if t.contains(\"android\") => return test_android(t),\n+        t if t.contains(\"apple\") => return test_apple(t),\n+        t if t.contains(\"cloudabi\") => return test_cloudabi(t),\n+        t if t.contains(\"dragonfly\") => return test_dragonflybsd(t),\n+        t if t.contains(\"emscripten\") => return test_emscripten(t),\n+        t if t.contains(\"freebsd\") => return test_freebsd(t),\n+        t if t.contains(\"linux\") => return test_linux(t),\n+        t if t.contains(\"netbsd\") => return test_netbsd(t),\n+        t if t.contains(\"openbsd\") => return test_openbsd(t),\n+        t if t.contains(\"redox\") => return test_redox(t),\n+        t if t.contains(\"solaris\") => return test_solaris(t),\n+        t if t.contains(\"wasi\") => return test_wasi(t),\n+        t if t.contains(\"windows\") => return test_windows(t),\n+        t => panic!(\"unknown target {}\", t),\n+    }\n+}\n+\n+fn ctest_cfg() -> ctest::TestGenerator {\n+    let mut cfg = ctest::TestGenerator::new();\n+    let libc_cfgs = [\n+        \"libc_priv_mod_use\",\n+        \"libc_union\",\n+        \"libc_const_size_of\",\n+        \"libc_align\",\n+        \"libc_core_cvoid\",\n+        \"libc_packedN\",\n+        \"libc_thread_local\",\n+    ];\n+    for f in &libc_cfgs {\n+        cfg.cfg(f, None);\n+    }\n+    cfg\n+}\n+\n+fn main() {\n+    do_cc();\n+    do_ctest();\n+}\n+\n+macro_rules! headers {\n+    ($cfg:ident: [$m:expr]: $header:literal) => {\n+        if $m {\n+            $cfg.header($header);\n+        }\n+    };\n+    ($cfg:ident: $header:literal) => {\n+        $cfg.header($header);\n+    };\n+    ($($cfg:ident: $([$c:expr]:)* $header:literal,)*) => {\n+        $(headers!($cfg: $([$c]:)* $header);)*\n+    };\n+    ($cfg:ident: $( $([$c:expr]:)* $header:literal,)*) => {\n+        headers!($($cfg: $([$c]:)* $header,)*);\n+    };\n+    ($cfg:ident: $( $([$c:expr]:)* $header:literal),*) => {\n+        headers!($($cfg: $([$c]:)* $header,)*);\n+    };\n+}\n+\n+fn test_apple(target: &str) {\n+    assert!(target.contains(\"apple\"));\n+    let x86_64 = target.contains(\"x86_64\");\n+    let i686 = target.contains(\"i686\");\n+\n+    let mut cfg = ctest_cfg();\n+    cfg.flag(\"-Wno-deprecated-declarations\");\n+    cfg.define(\"__APPLE_USE_RFC_3542\", None);\n+\n+    headers! { cfg:\n+        \"aio.h\",\n+        \"ctype.h\",\n+        \"dirent.h\",\n+        \"dlfcn.h\",\n+        \"errno.h\",\n+        \"execinfo.h\",\n+        \"fcntl.h\",\n+        \"glob.h\",\n+        \"grp.h\",\n+        \"ifaddrs.h\",\n+        \"langinfo.h\",\n+        \"limits.h\",\n+        \"locale.h\",\n+        \"mach-o/dyld.h\",\n+        \"mach/mach_time.h\",\n+        \"malloc/malloc.h\",\n+        \"net/bpf.h\",\n+        \"net/if.h\",\n+        \"net/if_arp.h\",\n+        \"net/if_dl.h\",\n+        \"net/if_utun.h\",\n+        \"net/route.h\",\n+        \"net/route.h\",\n+        \"netdb.h\",\n+        \"netinet/if_ether.h\",\n+        \"netinet/in.h\",\n+        \"netinet/in.h\",\n+        \"netinet/ip.h\",\n+        \"netinet/tcp.h\",\n+        \"netinet/udp.h\",\n+        \"poll.h\",\n+        \"pthread.h\",\n+        \"pwd.h\",\n+        \"resolv.h\",\n+        \"sched.h\",\n+        \"semaphore.h\",\n+        \"signal.h\",\n+        \"spawn.h\",\n+        \"stddef.h\",\n+        \"stdint.h\",\n+        \"stdio.h\",\n+        \"stdlib.h\",\n+        \"string.h\",\n+        \"sys/event.h\",\n+        \"sys/file.h\",\n+        \"sys/ioctl.h\",\n+        \"sys/ipc.h\",\n+        \"sys/kern_control.h\",\n+        \"sys/mman.h\",\n+        \"sys/mount.h\",\n+        \"sys/proc_info.h\",\n+        \"sys/ptrace.h\",\n+        \"sys/quota.h\",\n+        \"sys/resource.h\",\n+        \"sys/sem.h\",\n+        \"sys/shm.h\",\n+        \"sys/socket.h\",\n+        \"sys/stat.h\",\n+        \"sys/statvfs.h\",\n+        \"sys/sys_domain.h\",\n+        \"sys/sysctl.h\",\n+        \"sys/time.h\",\n+        \"sys/times.h\",\n+        \"sys/types.h\",\n+        \"sys/uio.h\",\n+        \"sys/un.h\",\n+        \"sys/utsname.h\",\n+        \"sys/wait.h\",\n+        \"sys/xattr.h\",\n+        \"syslog.h\",\n+        \"termios.h\",\n+        \"time.h\",\n+        \"unistd.h\",\n+        \"util.h\",\n+        \"utime.h\",\n+        \"utmpx.h\",\n+        \"wchar.h\",\n+        \"xlocale.h\",\n+        [x86_64]: \"crt_externs.h\",\n+    }\n+\n+    cfg.skip_struct(move |ty| {\n+        match ty {\n+            // FIXME: actually a union\n+            \"sigval\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_const(move |name| {\n+        match name {\n+            // These OSX constants are removed in Sierra.\n+            // https://developer.apple.com/library/content/releasenotes/General/APIDiffsMacOS10_12/Swift/Darwin.html\n+            \"KERN_KDENABLE_BG_TRACE\" | \"KERN_KDDISABLE_BG_TRACE\" => true,\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_fn(move |name| {\n+        // skip those that are manually verified\n+        match name {\n+            // FIXME: https://github.com/rust-lang/libc/issues/1272\n+            \"execv\" | \"execve\" | \"execvp\" => true,\n+\n+            // close calls the close_nocancel system call\n+            \"close\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_field_type(move |struct_, field| {\n+        match (struct_, field) {\n+            // FIXME: actually a union\n+            (\"sigevent\", \"sigev_value\") => true,\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.volatile_item(|i| {\n+        use ctest::VolatileItemKind::*;\n+        match i {\n+            StructField(ref n, ref f) if n == \"aiocb\" && f == \"aio_buf\" => {\n+                true\n+            }\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.type_name(move |ty, is_struct, is_union| {\n+        match ty {\n+            // Just pass all these through, no need for a \"struct\" prefix\n+            \"FILE\" | \"DIR\" | \"Dl_info\" => ty.to_string(),\n+\n+            // OSX calls this something else\n+            \"sighandler_t\" => \"sig_t\".to_string(),\n+\n+            t if is_union => format!(\"union {}\", t),\n+            t if t.ends_with(\"_t\") => t.to_string(),\n+            t if is_struct => format!(\"struct {}\", t),\n+            t => t.to_string(),\n+        }\n+    });\n+\n+    cfg.field_name(move |struct_, field| {\n+        match field {\n+            s if s.ends_with(\"_nsec\") && struct_.starts_with(\"stat\") => {\n+                s.replace(\"e_nsec\", \"espec.tv_nsec\")\n+            }\n+            // FIXME: sigaction actually contains a union with two variants:\n+            // a sa_sigaction with type: (*)(int, struct __siginfo *, void *)\n+            // a sa_handler with type sig_t\n+            \"sa_sigaction\" if struct_ == \"sigaction\" => {\n+                \"sa_handler\".to_string()\n+            }\n+            s => s.to_string(),\n+        }\n+    });\n+\n+    cfg.skip_roundtrip(move |s| match s {\n+        // FIXME: this type has the wrong ABI\n+        \"max_align_t\" if i686 => true,\n+        _ => false,\n+    });\n+    cfg.generate(\"../src/lib.rs\", \"main.rs\");\n+}\n+\n+fn test_openbsd(target: &str) {\n+    assert!(target.contains(\"openbsd\"));\n+\n+    let mut cfg = ctest_cfg();\n+    cfg.flag(\"-Wno-deprecated-declarations\");\n+\n+    headers! { cfg:\n+        \"errno.h\",\n+        \"fcntl.h\",\n+        \"limits.h\",\n+        \"locale.h\",\n+        \"stddef.h\",\n+        \"stdint.h\",\n+        \"stdio.h\",\n+        \"stdlib.h\",\n+        \"sys/stat.h\",\n+        \"sys/types.h\",\n+        \"time.h\",\n+        \"wchar.h\",\n+        \"ctype.h\",\n+        \"dirent.h\",\n+        \"sys/socket.h\",\n+        \"net/if.h\",\n+        \"net/route.h\",\n+        \"net/if_arp.h\",\n+        \"netdb.h\",\n+        \"netinet/in.h\",\n+        \"netinet/ip.h\",\n+        \"netinet/tcp.h\",\n+        \"netinet/udp.h\",\n+        \"net/bpf.h\",\n+        \"resolv.h\",\n+        \"pthread.h\",\n+        \"dlfcn.h\",\n+        \"signal.h\",\n+        \"string.h\",\n+        \"sys/file.h\",\n+        \"sys/ioctl.h\",\n+        \"sys/mman.h\",\n+        \"sys/resource.h\",\n+        \"sys/socket.h\",\n+        \"sys/time.h\",\n+        \"sys/un.h\",\n+        \"sys/wait.h\",\n+        \"unistd.h\",\n+        \"utime.h\",\n+        \"pwd.h\",\n+        \"grp.h\",\n+        \"sys/utsname.h\",\n+        \"sys/ptrace.h\",\n+        \"sys/mount.h\",\n+        \"sys/uio.h\",\n+        \"sched.h\",\n+        \"termios.h\",\n+        \"poll.h\",\n+        \"syslog.h\",\n+        \"semaphore.h\",\n+        \"sys/statvfs.h\",\n+        \"sys/times.h\",\n+        \"glob.h\",\n+        \"ifaddrs.h\",\n+        \"langinfo.h\",\n+        \"sys/sysctl.h\",\n+        \"utmp.h\",\n+        \"sys/event.h\",\n+        \"net/if_dl.h\",\n+        \"util.h\",\n+        \"ufs/ufs/quota.h\",\n+        \"pthread_np.h\",\n+        \"sys/syscall.h\",\n+    }\n+\n+    cfg.skip_struct(move |ty| {\n+        match ty {\n+            // FIXME: actually a union\n+            \"sigval\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_const(move |name| {\n+        match name {\n+            // Removed in OpenBSD 6.0\n+            \"KERN_USERMOUNT\" | \"KERN_ARND\" => true,\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_fn(move |name| {\n+        match name {\n+            // FIXME: https://github.com/rust-lang/libc/issues/1272\n+            \"execv\" | \"execve\" | \"execvp\" | \"execvpe\" => true,\n+\n+            // Removed in OpenBSD 6.5\n+            // https://marc.info/?l=openbsd-cvs&m=154723400730318\n+            \"mincore\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.type_name(move |ty, is_struct, is_union| {\n+        match ty {\n+            // Just pass all these through, no need for a \"struct\" prefix\n+            \"FILE\" | \"DIR\" | \"Dl_info\" => ty.to_string(),\n+\n+            // OSX calls this something else\n+            \"sighandler_t\" => \"sig_t\".to_string(),\n+\n+            t if is_union => format!(\"union {}\", t),\n+            t if t.ends_with(\"_t\") => t.to_string(),\n+            t if is_struct => format!(\"struct {}\", t),\n+            t => t.to_string(),\n+        }\n+    });\n+\n+    cfg.field_name(move |struct_, field| match field {\n+        \"st_birthtime\" if struct_.starts_with(\"stat\") => {\n+            \"__st_birthtime\".to_string()\n+        }\n+        \"st_birthtime_nsec\" if struct_.starts_with(\"stat\") => {\n+            \"__st_birthtimensec\".to_string()\n+        }\n+        s if s.ends_with(\"_nsec\") && struct_.starts_with(\"stat\") => {\n+            s.replace(\"e_nsec\", \".tv_nsec\")\n+        }\n+        \"sa_sigaction\" if struct_ == \"sigaction\" => \"sa_handler\".to_string(),\n+        s => s.to_string(),\n+    });\n+\n+    cfg.skip_field_type(move |struct_, field| {\n+        // type siginfo_t.si_addr changed from OpenBSD 6.0 to 6.1\n+        (struct_ == \"siginfo_t\" && field == \"si_addr\")\n+    });\n+\n+    cfg.generate(\"../src/lib.rs\", \"main.rs\");\n+}\n+\n+fn test_windows(target: &str) {\n+    assert!(target.contains(\"windows\"));\n+    let gnu = target.contains(\"gnu\");\n+\n+    let mut cfg = ctest_cfg();\n+    cfg.define(\"_WIN32_WINNT\", Some(\"0x8000\"));\n+\n+    headers! { cfg:\n+        \"direct.h\",\n+        \"errno.h\",\n+        \"fcntl.h\",\n+        \"io.h\",\n+        \"limits.h\",\n+        \"locale.h\",\n+        \"process.h\",\n+        \"signal.h\",\n+        \"stddef.h\",\n+        \"stdint.h\",\n+        \"stdio.h\",\n+        \"stdlib.h\",\n+        \"sys/stat.h\",\n+        \"sys/types.h\",\n+        \"sys/utime.h\",\n+        \"time.h\",\n+        \"wchar.h\",\n+        [gnu]: \"ws2tcpip.h\",\n+        [!gnu]: \"Winsock2.h\",\n+    }\n+\n+    cfg.type_name(move |ty, is_struct, is_union| {\n+        match ty {\n+            // Just pass all these through, no need for a \"struct\" prefix\n+            \"FILE\" | \"DIR\" | \"Dl_info\" => ty.to_string(),\n+\n+            // FIXME: these don't exist:\n+            \"time64_t\" => \"__time64_t\".to_string(),\n+            \"ssize_t\" => \"SSIZE_T\".to_string(),\n+\n+            \"sighandler_t\" if !gnu => \"_crt_signal_t\".to_string(),\n+            \"sighandler_t\" if gnu => \"__p_sig_fn_t\".to_string(),\n+\n+            t if is_union => format!(\"union {}\", t),\n+            t if t.ends_with(\"_t\") => t.to_string(),\n+\n+            // Windows uppercase structs don't have `struct` in front:\n+            t if is_struct => {\n+                if ty.clone().chars().next().unwrap().is_uppercase() {\n+                    t.to_string()\n+                } else if t == \"stat\" {\n+                    \"struct __stat64\".to_string()\n+                } else if t == \"utimbuf\" {\n+                    \"struct __utimbuf64\".to_string()\n+                } else {\n+                    // put `struct` in front of all structs:\n+                    format!(\"struct {}\", t)\n+                }\n+            }\n+            t => t.to_string(),\n+        }\n+    });\n+\n+    cfg.fn_cname(move |name, cname| cname.unwrap_or(name).to_string());\n+\n+    cfg.skip_type(move |name| match name {\n+        \"SSIZE_T\" if !gnu => true,\n+        \"ssize_t\" if !gnu => true,\n+        _ => false,\n+    });\n+\n+    cfg.skip_const(move |name| {\n+        match name {\n+            // FIXME: API error:\n+            // SIG_ERR type is \"void (*)(int)\", not \"int\"\n+            \"SIG_ERR\" => true,\n+            _ => false,\n+        }\n+    });\n+\n+    // FIXME: All functions point to the wrong addresses?\n+    cfg.skip_fn_ptrcheck(|_| true);\n+\n+    cfg.skip_signededness(move |c| {\n+        match c {\n+            // windows-isms\n+            n if n.starts_with(\"P\") => true,\n+            n if n.starts_with(\"H\") => true,\n+            n if n.starts_with(\"LP\") => true,\n+            \"sighandler_t\" if gnu => true,\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_fn(move |name| {\n+        match name {\n+            // FIXME: https://github.com/rust-lang/libc/issues/1272\n+            \"execv\" | \"execve\" | \"execvp\" | \"execvpe\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.generate(\"../src/lib.rs\", \"main.rs\");\n+}\n+\n+fn test_redox(target: &str) {\n+    assert!(target.contains(\"redox\"));\n+\n+    let mut cfg = ctest_cfg();\n+    cfg.flag(\"-Wno-deprecated-declarations\");\n+\n+    headers! {\n+        cfg:\n+        \"ctype.h\",\n+        \"dirent.h\",\n+        \"dlfcn.h\",\n+        \"errno.h\",\n+        \"execinfo.h\",\n+        \"fcntl.h\",\n+        \"glob.h\",\n+        \"grp.h\",\n+        \"ifaddrs.h\",\n+        \"langinfo.h\",\n+        \"limits.h\",\n+        \"locale.h\",\n+        \"net/if.h\",\n+        \"net/if_arp.h\",\n+        \"net/route.h\",\n+        \"netdb.h\",\n+        \"netinet/in.h\",\n+        \"netinet/ip.h\",\n+        \"netinet/tcp.h\",\n+        \"netinet/udp.h\",\n+        \"poll.h\",\n+        \"pthread.h\",\n+        \"pwd.h\",\n+        \"resolv.h\",\n+        \"sched.h\",\n+        \"semaphore.h\",\n+        \"string.h\",\n+        \"strings.h\",\n+        \"sys/file.h\",\n+        \"sys/ioctl.h\",\n+        \"sys/mman.h\",\n+        \"sys/mount.h\",\n+        \"sys/ptrace.h\",\n+        \"sys/quota.h\",\n+        \"sys/resource.h\",\n+        \"sys/socket.h\",\n+        \"sys/stat.h\",\n+        \"sys/statvfs.h\",\n+        \"sys/sysctl.h\",\n+        \"sys/time.h\",\n+        \"sys/times.h\",\n+        \"sys/types.h\",\n+        \"sys/uio.h\",\n+        \"sys/un.h\",\n+        \"sys/utsname.h\",\n+        \"sys/wait.h\",\n+        \"syslog.h\",\n+        \"termios.h\",\n+        \"time.h\",\n+        \"unistd.h\",\n+        \"utime.h\",\n+        \"utmpx.h\",\n+        \"wchar.h\",\n+    }\n+\n+    cfg.generate(\"../src/lib.rs\", \"main.rs\");\n+}\n+\n+fn test_cloudabi(target: &str) {\n+    assert!(target.contains(\"cloudabi\"));\n+\n+    let mut cfg = ctest_cfg();\n+    cfg.flag(\"-Wno-deprecated-declarations\");\n+\n+    headers! {\n+        cfg:\n+        \"execinfo.h\",\n+        \"glob.h\",\n+        \"ifaddrs.h\",\n+        \"langinfo.h\",\n+        \"sys/ptrace.h\",\n+        \"sys/quota.h\",\n+        \"sys/sysctl.h\",\n+        \"utmpx.h\",\n+        \"ctype.h\",\n+        \"dirent.h\",\n+        \"dlfcn.h\",\n+        \"errno.h\",\n+        \"fcntl.h\",\n+        \"grp.h\",\n+        \"limits.h\",\n+        \"locale.h\",\n+        \"net/if.h\",\n+        \"net/if_arp.h\",\n+        \"net/route.h\",\n+        \"netdb.h\",\n+        \"netinet/in.h\",\n+        \"netinet/ip.h\",\n+        \"netinet/tcp.h\",\n+        \"netinet/udp.h\",\n+        \"poll.h\",\n+        \"pthread.h\",\n+        \"pwd.h\",\n+        \"resolv.h\",\n+        \"sched.h\",\n+        \"semaphore.h\",\n+        \"signal.h\",\n+        \"stddef.h\",\n+        \"stdint.h\",\n+        \"stdio.h\",\n+        \"stdlib.h\",\n+        \"string.h\",\n+        \"strings.h\",\n+        \"sys/file.h\",\n+        \"sys/ioctl.h\",\n+        \"sys/mman.h\",\n+        \"sys/mount.h\",\n+        \"sys/resource.h\",\n+        \"sys/socket.h\",\n+        \"sys/stat.h\",\n+        \"sys/statvfs.h\",\n+        \"sys/time.h\",\n+        \"sys/times.h\",\n+        \"sys/types.h\",\n+        \"sys/uio.h\",\n+        \"sys/un.h\",\n+        \"sys/utsname.h\",\n+        \"sys/wait.h\",\n+        \"syslog.h\",\n+        \"termios.h\",\n+        \"time.h\",\n+        \"unistd.h\",\n+        \"utime.h\",\n+        \"wchar.h\",\n+    }\n+\n+    cfg.generate(\"../src/lib.rs\", \"main.rs\");\n+}\n+\n+fn test_solaris(target: &str) {\n+    assert!(target.contains(\"solaris\"));\n+\n+    let mut cfg = ctest_cfg();\n+    cfg.flag(\"-Wno-deprecated-declarations\");\n+\n+    cfg.define(\"_XOPEN_SOURCE\", Some(\"700\"));\n+    cfg.define(\"__EXTENSIONS__\", None);\n+    cfg.define(\"_LCONV_C99\", None);\n+\n+    headers! {\n+        cfg:\n+        \"ctype.h\",\n+        \"dirent.h\",\n+        \"dlfcn.h\",\n+        \"errno.h\",\n+        \"execinfo.h\",\n+        \"fcntl.h\",\n+        \"glob.h\",\n+        \"grp.h\",\n+        \"ifaddrs.h\",\n+        \"langinfo.h\",\n+        \"limits.h\",\n+        \"locale.h\",\n+        \"net/if.h\",\n+        \"net/if_arp.h\",\n+        \"net/route.h\",\n+        \"netdb.h\",\n+        \"netinet/in.h\",\n+        \"netinet/ip.h\",\n+        \"netinet/tcp.h\",\n+        \"netinet/udp.h\",\n+        \"poll.h\",\n+        \"port.h\",\n+        \"pthread.h\",\n+        \"pwd.h\",\n+        \"resolv.h\",\n+        \"sched.h\",\n+        \"semaphore.h\",\n+        \"signal.h\",\n+        \"stddef.h\",\n+        \"stdint.h\",\n+        \"stdio.h\",\n+        \"stdlib.h\",\n+        \"string.h\",\n+        \"sys/epoll.h\",\n+        \"sys/file.h\",\n+        \"sys/filio.h\",\n+        \"sys/ioctl.h\",\n+        \"sys/loadavg.h\",\n+        \"sys/mman.h\",\n+        \"sys/mount.h\",\n+        \"sys/resource.h\",\n+        \"sys/socket.h\",\n+        \"sys/stat.h\",\n+        \"sys/statvfs.h\",\n+        \"sys/time.h\",\n+        \"sys/times.h\",\n+        \"sys/types.h\",\n+        \"sys/uio.h\",\n+        \"sys/un.h\",\n+        \"sys/utsname.h\",\n+        \"sys/wait.h\",\n+        \"syslog.h\",\n+        \"termios.h\",\n+        \"time.h\",\n+        \"ucontext.h\",\n+        \"unistd.h\",\n+        \"utime.h\",\n+        \"utmpx.h\",\n+        \"wchar.h\",\n+    }\n+\n+    cfg.skip_const(move |name| match name {\n+        \"DT_FIFO\" | \"DT_CHR\" | \"DT_DIR\" | \"DT_BLK\" | \"DT_REG\" | \"DT_LNK\"\n+        | \"DT_SOCK\" | \"USRQUOTA\" | \"GRPQUOTA\" | \"PRIO_MIN\" | \"PRIO_MAX\" => {\n+            true\n+        }\n+\n+        _ => false,\n+    });\n+\n+    cfg.skip_fn(move |name| {\n+        // skip those that are manually verified\n+        match name {\n+            // const-ness only added recently\n+            \"dladdr\" => true,\n+\n+            // Definition of those functions as changed since unified headers\n+            // from NDK r14b These changes imply some API breaking changes but\n+            // are still ABI compatible. We can wait for the next major release\n+            // to be compliant with the new API.\n+            //\n+            // FIXME: unskip these for next major release\n+            \"setpriority\" | \"personality\" => true,\n+\n+            // signal is defined with sighandler_t, so ignore\n+            \"signal\" => true,\n+\n+            \"cfmakeraw\" | \"cfsetspeed\" => true,\n+\n+            // FIXME: mincore is defined with caddr_t on Solaris.\n+            \"mincore\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.generate(\"../src/lib.rs\", \"main.rs\");\n+}\n+\n+fn test_netbsd(target: &str) {\n+    assert!(target.contains(\"netbsd\"));\n+    let rumprun = target.contains(\"rumprun\");\n+    let mut cfg = ctest_cfg();\n+\n+    cfg.flag(\"-Wno-deprecated-declarations\");\n+    cfg.define(\"_NETBSD_SOURCE\", Some(\"1\"));\n+\n+    headers! {\n+        cfg:\n+        \"errno.h\",\n+        \"fcntl.h\",\n+        \"limits.h\",\n+        \"locale.h\",\n+        \"stddef.h\",\n+        \"stdint.h\",\n+        \"stdio.h\",\n+        \"stdlib.h\",\n+        \"sys/stat.h\",\n+        \"sys/types.h\",\n+        \"time.h\",\n+        \"wchar.h\",\n+        \"aio.h\",\n+        \"ctype.h\",\n+        \"dirent.h\",\n+        \"dlfcn.h\",\n+        \"glob.h\",\n+        \"grp.h\",\n+        \"ifaddrs.h\",\n+        \"langinfo.h\",\n+        \"net/if.h\",\n+        \"net/if_arp.h\",\n+        \"net/if_dl.h\",\n+        \"net/route.h\",\n+        \"netdb.h\",\n+        \"netinet/in.h\",\n+        \"netinet/ip.h\",\n+        \"netinet/tcp.h\",\n+        \"netinet/udp.h\",\n+        \"poll.h\",\n+        \"pthread.h\",\n+        \"pwd.h\",\n+        \"resolv.h\",\n+        \"sched.h\",\n+        \"semaphore.h\",\n+        \"signal.h\",\n+        \"string.h\",\n+        \"sys/extattr.h\",\n+        \"sys/file.h\",\n+        \"sys/ioctl.h\",\n+        \"sys/ioctl_compat.h\",\n+        \"sys/mman.h\",\n+        \"sys/mount.h\",\n+        \"sys/ptrace.h\",\n+        \"sys/resource.h\",\n+        \"sys/socket.h\",\n+        \"sys/statvfs.h\",\n+        \"sys/sysctl.h\",\n+        \"sys/time.h\",\n+        \"sys/times.h\",\n+        \"sys/uio.h\",\n+        \"sys/un.h\",\n+        \"sys/utsname.h\",\n+        \"sys/wait.h\",\n+        \"syslog.h\",\n+        \"termios.h\",\n+        \"ufs/ufs/quota.h\",\n+        \"ufs/ufs/quota1.h\",\n+        \"unistd.h\",\n+        \"util.h\",\n+        \"utime.h\",\n+        \"mqueue.h\",\n+        \"netinet/dccp.h\",\n+        \"sys/event.h\",\n+        \"sys/quota.h\",\n+    }\n+\n+    cfg.type_name(move |ty, is_struct, is_union| {\n+        match ty {\n+            // Just pass all these through, no need for a \"struct\" prefix\n+            \"FILE\" | \"fd_set\" | \"Dl_info\" | \"DIR\" | \"Elf32_Phdr\"\n+            | \"Elf64_Phdr\" | \"Elf32_Shdr\" | \"Elf64_Shdr\" | \"Elf32_Sym\"\n+            | \"Elf64_Sym\" | \"Elf32_Ehdr\" | \"Elf64_Ehdr\" | \"Elf32_Chdr\"\n+            | \"Elf64_Chdr\" => ty.to_string(),\n+\n+            // OSX calls this something else\n+            \"sighandler_t\" => \"sig_t\".to_string(),\n+\n+            t if is_union => format!(\"union {}\", t),\n+\n+            t if t.ends_with(\"_t\") => t.to_string(),\n+\n+            // put `struct` in front of all structs:.\n+            t if is_struct => format!(\"struct {}\", t),\n+\n+            t => t.to_string(),\n+        }\n+    });\n+\n+    cfg.field_name(move |struct_, field| {\n+        match field {\n+            // Our stat *_nsec fields normally don't actually exist but are part\n+            // of a timeval struct\n+            s if s.ends_with(\"_nsec\") && struct_.starts_with(\"stat\") => {\n+                s.replace(\"e_nsec\", \".tv_nsec\")\n+            }\n+            \"u64\" if struct_ == \"epoll_event\" => \"data.u64\".to_string(),\n+            s => s.to_string(),\n+        }\n+    });\n+\n+    cfg.skip_type(move |ty| {\n+        match ty {\n+            // FIXME: sighandler_t is crazy across platforms\n+            \"sighandler_t\" => true,\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_struct(move |ty| {\n+        match ty {\n+            // This is actually a union, not a struct\n+            \"sigval\" => true,\n+            // These are tested as part of the linux_fcntl tests since there are\n+            // header conflicts when including them with all the other structs.\n+            \"termios2\" => true,\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_signededness(move |c| {\n+        match c {\n+            \"LARGE_INTEGER\" | \"float\" | \"double\" => true,\n+            n if n.starts_with(\"pthread\") => true,\n+            // sem_t is a struct or pointer\n+            \"sem_t\" => true,\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_const(move |name| {\n+        match name {\n+            \"SIG_DFL\" | \"SIG_ERR\" | \"SIG_IGN\" => true, // sighandler_t weirdness\n+            \"SIGUNUSED\" => true,                       // removed in glibc 2.26\n+\n+            // weird signed extension or something like that?\n+            \"MS_NOUSER\" => true,\n+            \"MS_RMT_MASK\" => true, // updated in glibc 2.22 and musl 1.1.13\n+            \"BOTHER\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_fn(move |name| {\n+        match name {\n+            // FIXME: https://github.com/rust-lang/libc/issues/1272\n+            \"execv\" | \"execve\" | \"execvp\" => true,\n+\n+            \"getrlimit\" | \"getrlimit64\" |    // non-int in 1st arg\n+            \"setrlimit\" | \"setrlimit64\" |    // non-int in 1st arg\n+            \"prlimit\" | \"prlimit64\" |        // non-int in 2nd arg\n+\n+            // These functions presumably exist on netbsd but don't look like\n+            // they're implemented on rumprun yet, just let them slide for now.\n+            // Some of them look like they have headers but then don't have\n+            // corresponding actual definitions either...\n+            \"shm_open\" |\n+            \"shm_unlink\" |\n+            \"syscall\" |\n+            \"mq_open\" |\n+            \"mq_close\" |\n+            \"mq_getattr\" |\n+            \"mq_notify\" |\n+            \"mq_receive\" |\n+            \"mq_send\" |\n+            \"mq_setattr\" |\n+            \"mq_timedreceive\" |\n+            \"mq_timedsend\" |\n+            \"mq_unlink\" |\n+            \"ptrace\" |\n+            \"sigaltstack\" if rumprun => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_field_type(move |struct_, field| {\n+        // This is a weird union, don't check the type.\n+        (struct_ == \"ifaddrs\" && field == \"ifa_ifu\") ||\n+        // sighandler_t type is super weird\n+        (struct_ == \"sigaction\" && field == \"sa_sigaction\") ||\n+        // sigval is actually a union, but we pretend it's a struct\n+        (struct_ == \"sigevent\" && field == \"sigev_value\") ||\n+        // aio_buf is \"volatile void*\" and Rust doesn't understand volatile\n+        (struct_ == \"aiocb\" && field == \"aio_buf\")\n+    });\n+\n+    cfg.generate(\"../src/lib.rs\", \"main.rs\");\n+}\n+\n+fn test_dragonflybsd(target: &str) {\n+    assert!(target.contains(\"dragonfly\"));\n+    let mut cfg = ctest_cfg();\n+    cfg.flag(\"-Wno-deprecated-declarations\");\n+\n+    headers! {\n+        cfg:\n+        \"aio.h\",\n+        \"ctype.h\",\n+        \"dirent.h\",\n+        \"dlfcn.h\",\n+        \"errno.h\",\n+        \"execinfo.h\",\n+        \"fcntl.h\",\n+        \"glob.h\",\n+        \"grp.h\",\n+        \"ifaddrs.h\",\n+        \"langinfo.h\",\n+        \"limits.h\",\n+        \"locale.h\",\n+        \"mqueue.h\",\n+        \"net/if.h\",\n+        \"net/if_arp.h\",\n+        \"net/if_dl.h\",\n+        \"net/route.h\",\n+        \"netdb.h\",\n+        \"netinet/in.h\",\n+        \"netinet/ip.h\",\n+        \"netinet/tcp.h\",\n+        \"netinet/udp.h\",\n+        \"poll.h\",\n+        \"pthread.h\",\n+        \"pthread_np.h\",\n+        \"pwd.h\",\n+        \"resolv.h\",\n+        \"sched.h\",\n+        \"semaphore.h\",\n+        \"signal.h\",\n+        \"stddef.h\",\n+        \"stdint.h\",\n+        \"stdio.h\",\n+        \"stdlib.h\",\n+        \"string.h\",\n+        \"sys/event.h\",\n+        \"sys/file.h\",\n+        \"sys/ioctl.h\",\n+        \"sys/mman.h\",\n+        \"sys/mount.h\",\n+        \"sys/ptrace.h\",\n+        \"sys/resource.h\",\n+        \"sys/rtprio.h\",\n+        \"sys/socket.h\",\n+        \"sys/stat.h\",\n+        \"sys/statvfs.h\",\n+        \"sys/sysctl.h\",\n+        \"sys/time.h\",\n+        \"sys/times.h\",\n+        \"sys/types.h\",\n+        \"sys/uio.h\",\n+        \"sys/un.h\",\n+        \"sys/utsname.h\",\n+        \"sys/wait.h\",\n+        \"syslog.h\",\n+        \"termios.h\",\n+        \"time.h\",\n+        \"ufs/ufs/quota.h\",\n+        \"unistd.h\",\n+        \"util.h\",\n+        \"utime.h\",\n+        \"utmpx.h\",\n+        \"wchar.h\",\n+    }\n+\n+    cfg.type_name(move |ty, is_struct, is_union| {\n+        match ty {\n+            // Just pass all these through, no need for a \"struct\" prefix\n+            \"FILE\" | \"fd_set\" | \"Dl_info\" | \"DIR\" | \"Elf32_Phdr\"\n+            | \"Elf64_Phdr\" | \"Elf32_Shdr\" | \"Elf64_Shdr\" | \"Elf32_Sym\"\n+            | \"Elf64_Sym\" | \"Elf32_Ehdr\" | \"Elf64_Ehdr\" | \"Elf32_Chdr\"\n+            | \"Elf64_Chdr\" => ty.to_string(),\n+\n+            // FIXME: OSX calls this something else\n+            \"sighandler_t\" => \"sig_t\".to_string(),\n+\n+            t if is_union => format!(\"union {}\", t),\n+\n+            t if t.ends_with(\"_t\") => t.to_string(),\n+\n+            // put `struct` in front of all structs:.\n+            t if is_struct => format!(\"struct {}\", t),\n+\n+            t => t.to_string(),\n+        }\n+    });\n+\n+    cfg.field_name(move |struct_, field| {\n+        match field {\n+            // Our stat *_nsec fields normally don't actually exist but are part\n+            // of a timeval struct\n+            s if s.ends_with(\"_nsec\") && struct_.starts_with(\"stat\") => {\n+                s.replace(\"e_nsec\", \".tv_nsec\")\n+            }\n+            \"u64\" if struct_ == \"epoll_event\" => \"data.u64\".to_string(),\n+            // Field is named `type` in C but that is a Rust keyword,\n+            // so these fields are translated to `type_` in the bindings.\n+            \"type_\" if struct_ == \"rtprio\" => \"type\".to_string(),\n+            s => s.to_string(),\n+        }\n+    });\n+\n+    cfg.skip_type(move |ty| {\n+        match ty {\n+            // sighandler_t is crazy across platforms\n+            \"sighandler_t\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_struct(move |ty| {\n+        match ty {\n+            // This is actually a union, not a struct\n+            \"sigval\" => true,\n+\n+            // FIXME: These are tested as part of the linux_fcntl tests since\n+            // there are header conflicts when including them with all the other\n+            // structs.\n+            \"termios2\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_signededness(move |c| {\n+        match c {\n+            \"LARGE_INTEGER\" | \"float\" | \"double\" => true,\n+            // uuid_t is a struct, not an integer.\n+            \"uuid_t\" => true,\n+            n if n.starts_with(\"pthread\") => true,\n+            // sem_t is a struct or pointer\n+            \"sem_t\" => true,\n+            // mqd_t is a pointer on DragonFly\n+            \"mqd_t\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_const(move |name| {\n+        match name {\n+            \"SIG_DFL\" | \"SIG_ERR\" | \"SIG_IGN\" => true, // sighandler_t weirdness\n+\n+            // weird signed extension or something like that?\n+            \"MS_NOUSER\" => true,\n+            \"MS_RMT_MASK\" => true, // updated in glibc 2.22 and musl 1.1.13\n+\n+            // These are defined for Solaris 11, but the crate is tested on\n+            // illumos, where they are currently not defined\n+            \"EADI\"\n+            | \"PORT_SOURCE_POSTWAIT\"\n+            | \"PORT_SOURCE_SIGNAL\"\n+            | \"PTHREAD_STACK_MIN\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_fn(move |name| {\n+        // skip those that are manually verified\n+        match name {\n+            // FIXME: https://github.com/rust-lang/libc/issues/1272\n+            \"execv\" | \"execve\" | \"execvp\" => true,\n+\n+            \"getrlimit\" | \"getrlimit64\" |    // non-int in 1st arg\n+            \"setrlimit\" | \"setrlimit64\" |    // non-int in 1st arg\n+            \"prlimit\" | \"prlimit64\"        // non-int in 2nd arg\n+             => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_field_type(move |struct_, field| {\n+        // This is a weird union, don't check the type.\n+        (struct_ == \"ifaddrs\" && field == \"ifa_ifu\") ||\n+        // sighandler_t type is super weird\n+        (struct_ == \"sigaction\" && field == \"sa_sigaction\") ||\n+        // sigval is actually a union, but we pretend it's a struct\n+        (struct_ == \"sigevent\" && field == \"sigev_value\") ||\n+        // aio_buf is \"volatile void*\" and Rust doesn't understand volatile\n+        (struct_ == \"aiocb\" && field == \"aio_buf\")\n+    });\n+\n+    cfg.skip_field(move |struct_, field| {\n+        // this is actually a union on linux, so we can't represent it well and\n+        // just insert some padding.\n+        (struct_ == \"siginfo_t\" && field == \"_pad\") ||\n+        // sigev_notify_thread_id is actually part of a sigev_un union\n+        (struct_ == \"sigevent\" && field == \"sigev_notify_thread_id\")\n+    });\n+\n+    cfg.generate(\"../src/lib.rs\", \"main.rs\");\n+}\n+\n+fn test_wasi(target: &str) {\n+    assert!(target.contains(\"wasi\"));\n+\n+    let mut cfg = ctest_cfg();\n+    cfg.define(\"_GNU_SOURCE\", None);\n+\n+    headers! { cfg:\n+        \"ctype.h\",\n+        \"dirent.h\",\n+        \"errno.h\",\n+        \"fcntl.h\",\n+        \"limits.h\",\n+        \"locale.h\",\n+        \"malloc.h\",\n+        \"poll.h\",\n+        \"sched.h\",\n+        \"stdbool.h\",\n+        \"stddef.h\",\n+        \"stdint.h\",\n+        \"stdio.h\",\n+        \"stdlib.h\",\n+        \"string.h\",\n+        \"sys/resource.h\",\n+        \"sys/select.h\",\n+        \"sys/socket.h\",\n+        \"sys/stat.h\",\n+        \"sys/times.h\",\n+        \"sys/types.h\",\n+        \"sys/uio.h\",\n+        \"sys/utsname.h\",\n+        \"time.h\",\n+        \"unistd.h\",\n+        \"wasi/core.h\",\n+        \"wasi/libc.h\",\n+        \"wasi/libc-find-relpath.h\",\n+        \"wchar.h\",\n+    }\n+\n+    cfg.type_name(move |ty, is_struct, is_union| match ty {\n+        \"FILE\" | \"fd_set\" | \"DIR\" => ty.to_string(),\n+        t if is_union => format!(\"union {}\", t),\n+        t if t.starts_with(\"__wasi\") && t.ends_with(\"_u\") => {\n+            format!(\"union {}\", t)\n+        }\n+        t if t.starts_with(\"__wasi\") && is_struct => format!(\"struct {}\", t),\n+        t if t.ends_with(\"_t\") => t.to_string(),\n+        t if is_struct => format!(\"struct {}\", t),\n+        t => t.to_string(),\n+    });\n+\n+    cfg.field_name(move |_struct, field| {\n+        match field {\n+            // deal with fields as rust keywords\n+            \"type_\" => \"type\".to_string(),\n+            s => s.to_string(),\n+        }\n+    });\n+\n+    // Looks like LLD doesn't merge duplicate imports, so if the Rust\n+    // code imports from a module and the C code also imports from a\n+    // module we end up with two imports of function pointers which\n+    // import the same thing but have different function pointers\n+    cfg.skip_fn_ptrcheck(|f| f.starts_with(\"__wasi\"));\n+\n+    // d_name is declared as a flexible array in WASI libc, so it\n+    // doesn't support sizeof.\n+    cfg.skip_field(|s, field| s == \"dirent\" && field == \"d_name\");\n+\n+    cfg.generate(\"../src/lib.rs\", \"main.rs\");\n+}\n+\n+fn test_android(target: &str) {\n+    assert!(target.contains(\"android\"));\n+    let target_pointer_width = match target {\n+        t if t.contains(\"aarch64\") || t.contains(\"x86_64\") => 64,\n+        t if t.contains(\"i686\") || t.contains(\"arm\") => 32,\n+        t => panic!(\"unsupported target: {}\", t),\n+    };\n+    let x86 = target.contains(\"i686\") || target.contains(\"x86_64\");\n+\n+    let mut cfg = ctest_cfg();\n+    cfg.define(\"_GNU_SOURCE\", None);\n+\n+    headers! { cfg:\n+               \"arpa/inet.h\",\n+               \"asm/mman.h\",\n+               \"ctype.h\",\n+               \"dirent.h\",\n+               \"dlfcn.h\",\n+               \"errno.h\",\n+               \"fcntl.h\",\n+               \"grp.h\",\n+               \"ifaddrs.h\",\n+               \"limits.h\",\n+               \"linux/dccp.h\",\n+               \"linux/futex.h\",\n+               \"linux/fs.h\",\n+               \"linux/genetlink.h\",\n+               \"linux/if_alg.h\",\n+               \"linux/if_ether.h\",\n+               \"linux/if_tun.h\",\n+               \"linux/magic.h\",\n+               \"linux/memfd.h\",\n+               \"linux/module.h\",\n+               \"linux/net_tstamp.h\",\n+               \"linux/netfilter/nf_tables.h\",\n+               \"linux/netfilter_ipv4.h\",\n+               \"linux/netfilter_ipv6.h\",\n+               \"linux/netlink.h\",\n+               \"linux/quota.h\",\n+               \"linux/reboot.h\",\n+               \"linux/seccomp.h\",\n+               \"linux/sockios.h\",\n+               \"locale.h\",\n+               \"malloc.h\",\n+               \"net/ethernet.h\",\n+               \"net/if.h\",\n+               \"net/if_arp.h\",\n+               \"net/route.h\",\n+               \"netdb.h\",\n+               \"netinet/in.h\",\n+               \"netinet/ip.h\",\n+               \"netinet/tcp.h\",\n+               \"netinet/udp.h\",\n+               \"netpacket/packet.h\",\n+               \"poll.h\",\n+               \"pthread.h\",\n+               \"pty.h\",\n+               \"pwd.h\",\n+               \"resolv.h\",\n+               \"sched.h\",\n+               \"semaphore.h\",\n+               \"signal.h\",\n+               \"stddef.h\",\n+               \"stdint.h\",\n+               \"stdio.h\",\n+               \"stdlib.h\",\n+               \"string.h\",\n+               \"sys/epoll.h\",\n+               \"sys/eventfd.h\",\n+               \"sys/file.h\",\n+               \"sys/fsuid.h\",\n+               \"sys/inotify.h\",\n+               \"sys/ioctl.h\",\n+               \"sys/mman.h\",\n+               \"sys/mount.h\",\n+               \"sys/personality.h\",\n+               \"sys/prctl.h\",\n+               \"sys/ptrace.h\",\n+               \"sys/random.h\",\n+               \"sys/reboot.h\",\n+               \"sys/resource.h\",\n+               \"sys/sendfile.h\",\n+               \"sys/signalfd.h\",\n+               \"sys/socket.h\",\n+               \"sys/stat.h\",\n+               \"sys/statvfs.h\",\n+               \"sys/swap.h\",\n+               \"sys/syscall.h\",\n+               \"sys/sysinfo.h\",\n+               \"sys/time.h\",\n+               \"sys/times.h\",\n+               \"sys/types.h\",\n+               \"sys/uio.h\",\n+               \"sys/un.h\",\n+               \"sys/utsname.h\",\n+               \"sys/vfs.h\",\n+               \"sys/xattr.h\",\n+               \"sys/wait.h\",\n+               \"syslog.h\",\n+               \"termios.h\",\n+               \"time.h\",\n+               \"unistd.h\",\n+               \"utime.h\",\n+               \"utmp.h\",\n+               \"wchar.h\",\n+               \"xlocale.h\",\n+               // time64_t is not defined for 64-bit targets If included it will\n+               // generate the error 'Your time_t is already 64-bit'\n+               [target_pointer_width == 32]: \"time64.h\",\n+               [x86]: \"sys/reg.h\",\n+    }\n+\n+    cfg.type_name(move |ty, is_struct, is_union| {\n+        match ty {\n+            // Just pass all these through, no need for a \"struct\" prefix\n+            \"FILE\" | \"fd_set\" | \"Dl_info\" => ty.to_string(),\n+\n+            t if is_union => format!(\"union {}\", t),\n+\n+            t if t.ends_with(\"_t\") => t.to_string(),\n+\n+            // sigval is a struct in Rust, but a union in C:\n+            \"sigval\" => format!(\"union sigval\"),\n+\n+            // put `struct` in front of all structs:.\n+            t if is_struct => format!(\"struct {}\", t),\n+\n+            t => t.to_string(),\n+        }\n+    });\n+\n+    cfg.field_name(move |struct_, field| {\n+        match field {\n+            // Our stat *_nsec fields normally don't actually exist but are part\n+            // of a timeval struct\n+            s if s.ends_with(\"_nsec\") && struct_.starts_with(\"stat\") => {\n+                s.to_string()\n+            }\n+            // FIXME: appears that `epoll_event.data` is an union\n+            \"u64\" if struct_ == \"epoll_event\" => \"data.u64\".to_string(),\n+            s => s.to_string(),\n+        }\n+    });\n+\n+    cfg.skip_type(move |ty| {\n+        match ty {\n+            // FIXME: `sighandler_t` type is incorrect, see:\n+            // https://github.com/rust-lang/libc/issues/1359\n+            \"sighandler_t\" => true,\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_struct(move |ty| {\n+        match ty {\n+            // These are tested as part of the linux_fcntl tests since there are\n+            // header conflicts when including them with all the other structs.\n+            \"termios2\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_const(move |name| {\n+        match name {\n+            // FIXME: deprecated: not available in any header\n+            // See: https://github.com/rust-lang/libc/issues/1356\n+            \"ENOATTR\" => true,\n+\n+            // FIXME: still necessary?\n+            \"SIG_DFL\" | \"SIG_ERR\" | \"SIG_IGN\" => true, // sighandler_t weirdness\n+            // FIXME: deprecated - removed in glibc 2.26\n+            \"SIGUNUSED\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_fn(move |name| {\n+        // skip those that are manually verified\n+        match name {\n+            // FIXME: https://github.com/rust-lang/libc/issues/1272\n+            \"execv\" | \"execve\" | \"execvp\" | \"execvpe\" | \"fexecve\" => true,\n+\n+            // There are two versions of the sterror_r function, see\n+            //\n+            // https://linux.die.net/man/3/strerror_r\n+            //\n+            // An XSI-compliant version provided if:\n+            //\n+            // (_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600) && ! _GNU_SOURCE\n+            //\n+            // and a GNU specific version provided if _GNU_SOURCE is defined.\n+            //\n+            // libc provides bindings for the XSI-compliant version, which is\n+            // preferred for portable applications.\n+            //\n+            // We skip the test here since here _GNU_SOURCE is defined, and\n+            // test the XSI version below.\n+            \"strerror_r\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_field_type(move |struct_, field| {\n+        // This is a weird union, don't check the type.\n+        (struct_ == \"ifaddrs\" && field == \"ifa_ifu\") ||\n+        // sigval is actually a union, but we pretend it's a struct\n+        (struct_ == \"sigevent\" && field == \"sigev_value\")\n+    });\n+\n+    cfg.skip_field(move |struct_, field| {\n+        // this is actually a union on linux, so we can't represent it well and\n+        // just insert some padding.\n+        (struct_ == \"siginfo_t\" && field == \"_pad\") ||\n+        // FIXME: `sa_sigaction` has type `sighandler_t` but that type is\n+        // incorrect, see: https://github.com/rust-lang/libc/issues/1359\n+        (struct_ == \"sigaction\" && field == \"sa_sigaction\") ||\n+        // sigev_notify_thread_id is actually part of a sigev_un union\n+        (struct_ == \"sigevent\" && field == \"sigev_notify_thread_id\") ||\n+        // signalfd had SIGSYS fields added in Android 4.19, but CI does not have that version yet.\n+        (struct_ == \"signalfd_siginfo\" && (field == \"ssi_syscall\" ||\n+                                           field == \"ssi_call_addr\" ||\n+                                           field == \"ssi_arch\"))\n+    });\n+\n+    cfg.generate(\"../src/lib.rs\", \"main.rs\");\n+\n+    test_linux_like_apis(target);\n+}\n+\n+fn test_freebsd(target: &str) {\n+    assert!(target.contains(\"freebsd\"));\n+    let mut cfg = ctest_cfg();\n+\n+    let freebsd_ver = which_freebsd();\n+\n+    match freebsd_ver {\n+        Some(10) => cfg.cfg(\"freebsd10\", None),\n+        Some(11) => cfg.cfg(\"freebsd11\", None),\n+        Some(12) => cfg.cfg(\"freebsd12\", None),\n+        Some(13) => cfg.cfg(\"freebsd13\", None),\n+        _ => &mut cfg,\n+    };\n+\n+    // Required for `getline`:\n+    cfg.define(\"_WITH_GETLINE\", None);\n+    // Required for making freebsd11_stat available in the headers\n+    match freebsd_ver {\n+        Some(10) => &mut cfg,\n+        _ => cfg.define(\"_WANT_FREEBSD11_STAT\", None),\n+    };\n+\n+    headers! { cfg:\n+                \"aio.h\",\n+                \"arpa/inet.h\",\n+                \"ctype.h\",\n+                \"dirent.h\",\n+                \"dlfcn.h\",\n+                \"errno.h\",\n+                \"fcntl.h\",\n+                \"glob.h\",\n+                \"grp.h\",\n+                \"ifaddrs.h\",\n+                \"langinfo.h\",\n+                \"libutil.h\",\n+                \"limits.h\",\n+                \"locale.h\",\n+                \"mqueue.h\",\n+                \"net/bpf.h\",\n+                \"net/if.h\",\n+                \"net/if_arp.h\",\n+                \"net/if_dl.h\",\n+                \"net/route.h\",\n+                \"netdb.h\",\n+                \"netinet/ip.h\",\n+                \"netinet/in.h\",\n+                \"netinet/tcp.h\",\n+                \"netinet/udp.h\",\n+                \"poll.h\",\n+                \"pthread.h\",\n+                \"pthread_np.h\",\n+                \"pwd.h\",\n+                \"resolv.h\",\n+                \"sched.h\",\n+                \"semaphore.h\",\n+                \"signal.h\",\n+                \"spawn.h\",\n+                \"stddef.h\",\n+                \"stdint.h\",\n+                \"stdio.h\",\n+                \"stdlib.h\",\n+                \"string.h\",\n+                \"sys/event.h\",\n+                \"sys/extattr.h\",\n+                \"sys/file.h\",\n+                \"sys/ioctl.h\",\n+                \"sys/ipc.h\",\n+                \"sys/jail.h\",\n+                \"sys/mman.h\",\n+                \"sys/mount.h\",\n+                \"sys/msg.h\",\n+                \"sys/procdesc.h\",\n+                \"sys/ptrace.h\",\n+                \"sys/resource.h\",\n+                \"sys/rtprio.h\",\n+                \"sys/shm.h\",\n+                \"sys/socket.h\",\n+                \"sys/stat.h\",\n+                \"sys/statvfs.h\",\n+                \"sys/sysctl.h\",\n+                \"sys/time.h\",\n+                \"sys/times.h\",\n+                \"sys/types.h\",\n+                \"sys/uio.h\",\n+                \"sys/un.h\",\n+                \"sys/utsname.h\",\n+                \"sys/wait.h\",\n+                \"syslog.h\",\n+                \"termios.h\",\n+                \"time.h\",\n+                \"ufs/ufs/quota.h\",\n+                \"unistd.h\",\n+                \"utime.h\",\n+                \"utmpx.h\",\n+                \"wchar.h\",\n+    }\n+\n+    cfg.type_name(move |ty, is_struct, is_union| {\n+        match ty {\n+            // Just pass all these through, no need for a \"struct\" prefix\n+            \"FILE\" | \"fd_set\" | \"Dl_info\" | \"DIR\" => ty.to_string(),\n+\n+            // FIXME: https://github.com/rust-lang/libc/issues/1273\n+            \"sighandler_t\" => \"sig_t\".to_string(),\n+\n+            t if is_union => format!(\"union {}\", t),\n+\n+            t if t.ends_with(\"_t\") => t.to_string(),\n+\n+            // sigval is a struct in Rust, but a union in C:\n+            \"sigval\" => format!(\"union sigval\"),\n+\n+            // put `struct` in front of all structs:.\n+            t if is_struct => format!(\"struct {}\", t),\n+\n+            t => t.to_string(),\n+        }\n+    });\n+\n+    cfg.field_name(move |struct_, field| {\n+        match field {\n+            // Our stat *_nsec fields normally don't actually exist but are part\n+            // of a timeval struct\n+            s if s.ends_with(\"_nsec\") && struct_.starts_with(\"stat\") => {\n+                s.replace(\"e_nsec\", \".tv_nsec\")\n+            }\n+            // Field is named `type` in C but that is a Rust keyword,\n+            // so these fields are translated to `type_` in the bindings.\n+            \"type_\" if struct_ == \"rtprio\" => \"type\".to_string(),\n+            s => s.to_string(),\n+        }\n+    });\n+\n+    cfg.skip_const(move |name| {\n+        match name {\n+            // These constants were introduced in FreeBSD 12:\n+            \"SF_USER_READAHEAD\"\n+            | \"EVFILT_EMPTY\"\n+            | \"SO_REUSEPORT_LB\"\n+            | \"IP_ORIGDSTADDR\"\n+            | \"IP_RECVORIGDSTADDR\"\n+            | \"IPV6_ORIGDSTADDR\"\n+            | \"IPV6_RECVORIGDSTADDR\"\n+                if Some(11) == freebsd_ver =>\n+            {\n+                true\n+            }\n+\n+            // These constants were introduced in FreeBSD 11:\n+            \"SF_USER_READAHEAD\"\n+            | \"SF_NOCACHE\"\n+            | \"RLIMIT_KQUEUES\"\n+            | \"RLIMIT_UMTXP\"\n+            | \"EVFILT_PROCDESC\"\n+            | \"EVFILT_SENDFILE\"\n+            | \"EVFILT_EMPTY\"\n+            | \"SO_REUSEPORT_LB\"\n+            | \"TCP_CCALGOOPT\"\n+            | \"TCP_PCAP_OUT\"\n+            | \"TCP_PCAP_IN\"\n+            | \"IP_BINDMULTI\"\n+            | \"IP_ORIGDSTADDR\"\n+            | \"IP_RECVORIGDSTADDR\"\n+            | \"IPV6_ORIGDSTADDR\"\n+            | \"IPV6_RECVORIGDSTADDR\"\n+            | \"PD_CLOEXEC\"\n+            | \"PD_ALLOWED_AT_FORK\"\n+            | \"IP_RSS_LISTEN_BUCKET\"\n+                if Some(10) == freebsd_ver =>\n+            {\n+                true\n+            }\n+\n+            // FIXME: This constant has a different value in FreeBSD 10:\n+            \"RLIM_NLIMITS\" if Some(10) == freebsd_ver => true,\n+\n+            // FIXME: There are deprecated - remove in a couple of releases.\n+            // These constants were removed in FreeBSD 11 (svn r273250) but will\n+            // still be accepted and ignored at runtime.\n+            \"MAP_RENAME\" | \"MAP_NORESERVE\" if Some(10) != freebsd_ver => true,\n+\n+            // FIXME: There are deprecated - remove in a couple of releases.\n+            // These constants were removed in FreeBSD 11 (svn r262489),\n+            // and they've never had any legitimate use outside of the\n+            // base system anyway.\n+            \"CTL_MAXID\" | \"KERN_MAXID\" | \"HW_MAXID\" | \"USER_MAXID\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_struct(move |ty| {\n+        match ty {\n+            // `mmsghdr` is not available in FreeBSD 10\n+            \"mmsghdr\" if Some(10) == freebsd_ver => true,\n+\n+            // `max_align_t` is not available in FreeBSD 10\n+            \"max_align_t\" if Some(10) == freebsd_ver => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_fn(move |name| {\n+        // skip those that are manually verified\n+        match name {\n+            // FIXME: https://github.com/rust-lang/libc/issues/1272\n+            \"execv\" | \"execve\" | \"execvp\" | \"execvpe\" | \"fexecve\" => true,\n+\n+            // These functions were added in FreeBSD 11:\n+            \"fdatasync\" | \"mq_getfd_np\" | \"sendmmsg\" | \"recvmmsg\"\n+                if Some(10) == freebsd_ver =>\n+            {\n+                true\n+            }\n+\n+            // This function changed its return type from `int` in FreeBSD10 to\n+            // `ssize_t` in FreeBSD11:\n+            \"aio_waitcomplete\" if Some(10) == freebsd_ver => true,\n+\n+            // The `uname` function in the `utsname.h` FreeBSD header is a C\n+            // inline function (has no symbol) that calls the `__xuname` symbol.\n+            // Therefore the function pointer comparison does not make sense for it.\n+            \"uname\" => true,\n+\n+            // FIXME: Our API is unsound. The Rust API allows aliasing\n+            // pointers, but the C API requires pointers not to alias.\n+            // We should probably be at least using `&`/`&mut` here, see:\n+            // https://github.com/gnzlbg/ctest/issues/68\n+            \"lio_listio\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_signededness(move |c| {\n+        match c {\n+            // FIXME: has a different sign in FreeBSD10\n+            \"blksize_t\" if Some(10) == freebsd_ver => true,\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.volatile_item(|i| {\n+        use ctest::VolatileItemKind::*;\n+        match i {\n+            // aio_buf is a volatile void** but since we cannot express that in\n+            // Rust types, we have to explicitly tell the checker about it here:\n+            StructField(ref n, ref f) if n == \"aiocb\" && f == \"aio_buf\" => {\n+                true\n+            }\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_field(move |struct_, field| {\n+        match (struct_, field) {\n+            // FIXME: `sa_sigaction` has type `sighandler_t` but that type is\n+            // incorrect, see: https://github.com/rust-lang/libc/issues/1359\n+            (\"sigaction\", \"sa_sigaction\") => true,\n+\n+            // FIXME: in FreeBSD10 this field has type `char*` instead of\n+            // `void*`:\n+            (\"stack_t\", \"ss_sp\") if Some(10) == freebsd_ver => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.generate(\"../src/lib.rs\", \"main.rs\");\n+}\n+\n+fn test_emscripten(target: &str) {\n+    assert!(target.contains(\"emscripten\"));\n+\n+    let mut cfg = ctest_cfg();\n+    cfg.define(\"_GNU_SOURCE\", None); // FIXME: ??\n+\n+    headers! { cfg:\n+               \"aio.h\",\n+               \"ctype.h\",\n+               \"dirent.h\",\n+               \"dlfcn.h\",\n+               \"errno.h\",\n+               \"fcntl.h\",\n+               \"glob.h\",\n+               \"grp.h\",\n+               \"ifaddrs.h\",\n+               \"langinfo.h\",\n+               \"limits.h\",\n+               \"locale.h\",\n+               \"malloc.h\",\n+               \"mntent.h\",\n+               \"mqueue.h\",\n+               \"net/ethernet.h\",\n+               \"net/if.h\",\n+               \"net/if_arp.h\",\n+               \"net/route.h\",\n+               \"netdb.h\",\n+               \"netinet/in.h\",\n+               \"netinet/ip.h\",\n+               \"netinet/tcp.h\",\n+               \"netinet/udp.h\",\n+               \"netpacket/packet.h\",\n+               \"poll.h\",\n+               \"pthread.h\",\n+               \"pty.h\",\n+               \"pwd.h\",\n+               \"resolv.h\",\n+               \"sched.h\",\n+               \"sched.h\",\n+               \"semaphore.h\",\n+               \"shadow.h\",\n+               \"signal.h\",\n+               \"stddef.h\",\n+               \"stdint.h\",\n+               \"stdio.h\",\n+               \"stdlib.h\",\n+               \"string.h\",\n+               \"sys/epoll.h\",\n+               \"sys/eventfd.h\",\n+               \"sys/file.h\",\n+               \"sys/ioctl.h\",\n+               \"sys/ipc.h\",\n+               \"sys/mman.h\",\n+               \"sys/mount.h\",\n+               \"sys/msg.h\",\n+               \"sys/personality.h\",\n+               \"sys/prctl.h\",\n+               \"sys/ptrace.h\",\n+               \"sys/quota.h\",\n+               \"sys/reboot.h\",\n+               \"sys/resource.h\",\n+               \"sys/sem.h\",\n+               \"sys/sendfile.h\",\n+               \"sys/shm.h\",\n+               \"sys/signalfd.h\",\n+               \"sys/socket.h\",\n+               \"sys/stat.h\",\n+               \"sys/statvfs.h\",\n+               \"sys/swap.h\",\n+               \"sys/syscall.h\",\n+               \"sys/sysctl.h\",\n+               \"sys/sysinfo.h\",\n+               \"sys/time.h\",\n+               \"sys/timerfd.h\",\n+               \"sys/times.h\",\n+               \"sys/types.h\",\n+               \"sys/uio.h\",\n+               \"sys/un.h\",\n+               \"sys/user.h\",\n+               \"sys/utsname.h\",\n+               \"sys/vfs.h\",\n+               \"sys/wait.h\",\n+               \"sys/xattr.h\",\n+               \"syslog.h\",\n+               \"termios.h\",\n+               \"time.h\",\n+               \"ucontext.h\",\n+               \"unistd.h\",\n+               \"utime.h\",\n+               \"utmp.h\",\n+               \"utmpx.h\",\n+               \"wchar.h\",\n+    }\n+\n+    cfg.type_name(move |ty, is_struct, is_union| {\n+        match ty {\n+            // Just pass all these through, no need for a \"struct\" prefix\n+            \"FILE\" | \"fd_set\" | \"Dl_info\" | \"DIR\" => ty.to_string(),\n+\n+            t if is_union => format!(\"union {}\", t),\n+\n+            t if t.ends_with(\"_t\") => t.to_string(),\n+\n+            // put `struct` in front of all structs:.\n+            t if is_struct => format!(\"struct {}\", t),\n+\n+            t => t.to_string(),\n+        }\n+    });\n+\n+    cfg.field_name(move |struct_, field| {\n+        match field {\n+            // Our stat *_nsec fields normally don't actually exist but are part\n+            // of a timeval struct\n+            s if s.ends_with(\"_nsec\") && struct_.starts_with(\"stat\") => {\n+                s.replace(\"e_nsec\", \".tv_nsec\")\n+            }\n+            // FIXME: appears that `epoll_event.data` is an union\n+            \"u64\" if struct_ == \"epoll_event\" => \"data.u64\".to_string(),\n+            s => s.to_string(),\n+        }\n+    });\n+\n+    cfg.skip_type(move |ty| {\n+        match ty {\n+            // sighandler_t is crazy across platforms\n+            // FIXME: is this necessary?\n+            \"sighandler_t\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_struct(move |ty| {\n+        match ty {\n+            // This is actually a union, not a struct\n+            // FIXME: is this necessary?\n+            \"sigval\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_fn(move |name| {\n+        match name {\n+            // FIXME: https://github.com/rust-lang/libc/issues/1272\n+            \"execv\" | \"execve\" | \"execvp\" | \"execvpe\" | \"fexecve\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_const(move |name| {\n+        match name {\n+            // FIXME: deprecated - SIGNUNUSED was removed in glibc 2.26\n+            // users should use SIGSYS instead\n+            \"SIGUNUSED\" => true,\n+\n+            // FIXME: emscripten uses different constants to constructs these\n+            n if n.contains(\"__SIZEOF_PTHREAD\") => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_field_type(move |struct_, field| {\n+        // This is a weird union, don't check the type.\n+        // FIXME: is this necessary?\n+        (struct_ == \"ifaddrs\" && field == \"ifa_ifu\") ||\n+        // sighandler_t type is super weird\n+        // FIXME: is this necessary?\n+        (struct_ == \"sigaction\" && field == \"sa_sigaction\") ||\n+        // sigval is actually a union, but we pretend it's a struct\n+        // FIXME: is this necessary?\n+        (struct_ == \"sigevent\" && field == \"sigev_value\") ||\n+        // aio_buf is \"volatile void*\" and Rust doesn't understand volatile\n+        // FIXME: is this necessary?\n+        (struct_ == \"aiocb\" && field == \"aio_buf\")\n+    });\n+\n+    cfg.skip_field(move |struct_, field| {\n+        // this is actually a union on linux, so we can't represent it well and\n+        // just insert some padding.\n+        // FIXME: is this necessary?\n+        (struct_ == \"siginfo_t\" && field == \"_pad\") ||\n+        // musl names this __dummy1 but it's still there\n+        // FIXME: is this necessary?\n+        (struct_ == \"glob_t\" && field == \"gl_flags\") ||\n+        // musl seems to define this as an *anonymous* bitfield\n+        // FIXME: is this necessary?\n+        (struct_ == \"statvfs\" && field == \"__f_unused\") ||\n+        // sigev_notify_thread_id is actually part of a sigev_un union\n+        (struct_ == \"sigevent\" && field == \"sigev_notify_thread_id\") ||\n+        // signalfd had SIGSYS fields added in Linux 4.18, but no libc release has them yet.\n+        (struct_ == \"signalfd_siginfo\" && (field == \"ssi_addr_lsb\" ||\n+                                           field == \"_pad2\" ||\n+                                           field == \"ssi_syscall\" ||\n+                                           field == \"ssi_call_addr\" ||\n+                                           field == \"ssi_arch\"))\n+    });\n+\n+    // FIXME: test linux like\n+    cfg.generate(\"../src/lib.rs\", \"main.rs\");\n+}\n+\n+fn test_linux(target: &str) {\n+    assert!(target.contains(\"linux\"));\n+\n+    // target_env\n+    let gnu = target.contains(\"gnu\");\n+    let musl = target.contains(\"musl\");\n+    let uclibc = target.contains(\"uclibc\");\n+\n+    match (gnu, musl, uclibc) {\n+        (true, false, false) => (),\n+        (false, true, false) => (),\n+        (false, false, true) => (),\n+        (_, _, _) => panic!(\n+            \"linux target lib is gnu: {}, musl: {}, uclibc: {}\",\n+            gnu, musl, uclibc\n+        ),\n+    }\n+\n+    let arm = target.contains(\"arm\");\n+    let i686 = target.contains(\"i686\");\n+    let mips = target.contains(\"mips\");\n+    let mips32 = mips && !target.contains(\"64\");\n+    let mips32_musl = mips32 && musl;\n+    let mips64 = mips && target.contains(\"64\");\n+    let ppc64 = target.contains(\"powerpc64\");\n+    let s390x = target.contains(\"s390x\");\n+    let sparc64 = target.contains(\"sparc64\");\n+    let x32 = target.contains(\"x32\");\n+    let x86_32 = target.contains(\"i686\");\n+    let x86_64 = target.contains(\"x86_64\");\n+\n+    let mut cfg = ctest_cfg();\n+    cfg.define(\"_GNU_SOURCE\", None);\n+    // This macro re-deifnes fscanf,scanf,sscanf to link to the symbols that are\n+    // deprecated since glibc >= 2.29. This allows Rust binaries to link against\n+    // glibc versions older than 2.29.\n+    cfg.define(\"__GLIBC_USE_DEPRECATED_SCANF\", None);\n+\n+    headers! { cfg:\n+               \"ctype.h\",\n+               \"dirent.h\",\n+               \"dlfcn.h\",\n+               \"elf.h\",\n+               \"fcntl.h\",\n+               \"glob.h\",\n+               \"grp.h\",\n+               \"ifaddrs.h\",\n+               \"langinfo.h\",\n+               \"limits.h\",\n+               \"link.h\",\n+               \"locale.h\",\n+               \"malloc.h\",\n+               \"mntent.h\",\n+               \"mqueue.h\",\n+               \"net/ethernet.h\",\n+               \"net/if.h\",\n+               \"net/if_arp.h\",\n+               \"net/route.h\",\n+               \"netdb.h\",\n+               \"netinet/in.h\",\n+               \"netinet/ip.h\",\n+               \"netinet/tcp.h\",\n+               \"netinet/udp.h\",\n+               \"netpacket/packet.h\",\n+               \"poll.h\",\n+               \"pthread.h\",\n+               \"pty.h\",\n+               \"pwd.h\",\n+               \"resolv.h\",\n+               \"sched.h\",\n+               \"semaphore.h\",\n+               \"shadow.h\",\n+               \"signal.h\",\n+               \"spawn.h\",\n+               \"stddef.h\",\n+               \"stdint.h\",\n+               \"stdio.h\",\n+               \"stdlib.h\",\n+               \"string.h\",\n+               \"sys/epoll.h\",\n+               \"sys/eventfd.h\",\n+               \"sys/file.h\",\n+               \"sys/fsuid.h\",\n+               \"sys/inotify.h\",\n+               \"sys/ioctl.h\",\n+               \"sys/ipc.h\",\n+               \"sys/mman.h\",\n+               \"sys/mount.h\",\n+               \"sys/msg.h\",\n+               \"sys/personality.h\",\n+               \"sys/prctl.h\",\n+               \"sys/ptrace.h\",\n+               \"sys/quota.h\",\n+               // FIXME: the mips-musl CI build jobs use ancient musl 1.0.15:\n+               [!mips32_musl]: \"sys/random.h\",\n+               \"sys/reboot.h\",\n+               \"sys/resource.h\",\n+               \"sys/sem.h\",\n+               \"sys/sendfile.h\",\n+               \"sys/shm.h\",\n+               \"sys/signalfd.h\",\n+               \"sys/socket.h\",\n+               \"sys/stat.h\",\n+               \"sys/statvfs.h\",\n+               \"sys/swap.h\",\n+               \"sys/syscall.h\",\n+               \"sys/time.h\",\n+               \"sys/timerfd.h\",\n+               \"sys/times.h\",\n+               \"sys/types.h\",\n+               \"sys/uio.h\",\n+               \"sys/un.h\",\n+               \"sys/user.h\",\n+               \"sys/utsname.h\",\n+               \"sys/vfs.h\",\n+               \"sys/wait.h\",\n+               \"syslog.h\",\n+               \"termios.h\",\n+               \"time.h\",\n+               \"ucontext.h\",\n+               \"unistd.h\",\n+               \"utime.h\",\n+               \"utmp.h\",\n+               \"utmpx.h\",\n+               \"wchar.h\",\n+               \"errno.h\",\n+               // `sys/io.h` is only available on x86*, Alpha, IA64, and 32-bit\n+               // ARM: https://bugzilla.redhat.com/show_bug.cgi?id=1116162\n+               [x86_64 || x86_32 || arm]: \"sys/io.h\",\n+               // `sys/reg.h` is only available on x86 and x86_64\n+               [x86_64 || x86_32]: \"sys/reg.h\",\n+               // sysctl system call is deprecated and not available on musl\n+               // It is also unsupported in x32:\n+               [!(x32 || musl)]: \"sys/sysctl.h\",\n+               // <execinfo.h> is not supported by musl:\n+               // https://www.openwall.com/lists/musl/2015/04/09/3\n+               [!musl]: \"execinfo.h\",\n+    }\n+\n+    // Include linux headers at the end:\n+    headers! {\n+        cfg:\n+        \"asm/mman.h\",\n+        \"linux/dccp.h\",\n+        \"linux/falloc.h\",\n+        \"linux/fs.h\",\n+        \"linux/futex.h\",\n+        \"linux/genetlink.h\",\n+        // FIXME: musl version 1.0.15 used by mips build jobs is ancient\n+        [!mips32_musl]: \"linux/if.h\",\n+        \"linux/if_addr.h\",\n+        \"linux/if_alg.h\",\n+        \"linux/if_ether.h\",\n+        \"linux/if_tun.h\",\n+        \"linux/input.h\",\n+        \"linux/magic.h\",\n+        \"linux/memfd.h\",\n+        \"linux/module.h\",\n+        \"linux/net_tstamp.h\",\n+        \"linux/netfilter/nf_tables.h\",\n+        \"linux/netfilter_ipv4.h\",\n+        \"linux/netfilter_ipv6.h\",\n+        \"linux/netlink.h\",\n+        \"linux/quota.h\",\n+        \"linux/random.h\",\n+        \"linux/reboot.h\",\n+        \"linux/rtnetlink.h\",\n+        \"linux/seccomp.h\",\n+        \"linux/sockios.h\",\n+        \"linux/vm_sockets.h\",\n+        \"sys/auxv.h\",\n+    }\n+\n+    // note: aio.h must be included before sys/mount.h\n+    headers! {\n+        cfg:\n+        \"sys/xattr.h\",\n+        \"sys/sysinfo.h\",\n+        \"aio.h\",\n+    }\n+\n+    cfg.type_name(move |ty, is_struct, is_union| {\n+        match ty {\n+            // Just pass all these through, no need for a \"struct\" prefix\n+            \"FILE\" | \"fd_set\" | \"Dl_info\" | \"DIR\" | \"Elf32_Phdr\"\n+            | \"Elf64_Phdr\" | \"Elf32_Shdr\" | \"Elf64_Shdr\" | \"Elf32_Sym\"\n+            | \"Elf64_Sym\" | \"Elf32_Ehdr\" | \"Elf64_Ehdr\" | \"Elf32_Chdr\"\n+            | \"Elf64_Chdr\" => ty.to_string(),\n+\n+            t if is_union => format!(\"union {}\", t),\n+\n+            t if t.ends_with(\"_t\") => t.to_string(),\n+\n+            // put `struct` in front of all structs:.\n+            t if is_struct => format!(\"struct {}\", t),\n+\n+            t => t.to_string(),\n+        }\n+    });\n+\n+    cfg.field_name(move |struct_, field| {\n+        match field {\n+            // Our stat *_nsec fields normally don't actually exist but are part\n+            // of a timeval struct\n+            s if s.ends_with(\"_nsec\") && struct_.starts_with(\"stat\") => {\n+                s.replace(\"e_nsec\", \".tv_nsec\")\n+            }\n+            // FIXME: epoll_event.data is actuall a union in C, but in Rust\n+            // it is only a u64 because we only expose one field\n+            // http://man7.org/linux/man-pages/man2/epoll_wait.2.html\n+            \"u64\" if struct_ == \"epoll_event\" => \"data.u64\".to_string(),\n+            // The following structs have a field called `type` in C,\n+            // but `type` is a Rust keyword, so these fields are translated\n+            // to `type_` in Rust.\n+            \"type_\"\n+                if struct_ == \"input_event\"\n+                    || struct_ == \"input_mask\"\n+                    || struct_ == \"ff_effect\" =>\n+            {\n+                \"type\".to_string()\n+            }\n+\n+            s => s.to_string(),\n+        }\n+    });\n+\n+    cfg.skip_type(move |ty| {\n+        match ty {\n+            // FIXME: `sighandler_t` type is incorrect, see:\n+            // https://github.com/rust-lang/libc/issues/1359\n+            \"sighandler_t\" => true,\n+\n+            // These cannot be tested when \"resolv.h\" is included and are tested\n+            // in the `linux_elf.rs` file.\n+            \"Elf64_Phdr\" | \"Elf32_Phdr\" => true,\n+\n+            // This type is private on Linux. It is implemented as a C `enum`\n+            // (`c_uint`) and this clashes with the type of the `rlimit` APIs\n+            // which expect a `c_int` even though both are ABI compatible.\n+            \"__rlimit_resource_t\" => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_struct(move |ty| {\n+        match ty {\n+            // These cannot be tested when \"resolv.h\" is included and are tested\n+            // in the `linux_elf.rs` file.\n+            \"Elf64_Phdr\" | \"Elf32_Phdr\" => true,\n+\n+            // On Linux, the type of `ut_tv` field of `struct utmpx`\n+            // can be an anonymous struct, so an extra struct,\n+            // which is absent in glibc, has to be defined.\n+            \"__timeval\" => true,\n+\n+            // FIXME: This is actually a union, not a struct\n+            \"sigval\" => true,\n+\n+            // This type is tested in the `linux_termios.rs` file since there\n+            // are header conflicts when including them with all the other\n+            // structs.\n+            \"termios2\" => true,\n+\n+            // FIXME: musl version using by mips build jobs 1.0.15 is ancient:\n+            \"ifmap\" | \"ifreq\" | \"ifconf\" if mips32_musl => true,\n+\n+            // FIXME: remove once Ubuntu 20.04 LTS is released, somewhere in 2020.\n+            // ucontext_t added a new field as of glibc 2.28; our struct definition is\n+            // conservative and omits the field, but that means the size doesn't match for newer\n+            // glibcs (see https://github.com/rust-lang/libc/issues/1410)\n+            \"ucontext_t\" if gnu => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_const(move |name| {\n+        match name {\n+            // These constants are not available if gnu headers have been included\n+            // and can therefore not be tested here\n+            //\n+            // The IPV6 constants are tested in the `linux_ipv6.rs` tests:\n+            | \"IPV6_FLOWINFO\"\n+            | \"IPV6_FLOWLABEL_MGR\"\n+            | \"IPV6_FLOWINFO_SEND\"\n+            | \"IPV6_FLOWINFO_FLOWLABEL\"\n+            | \"IPV6_FLOWINFO_PRIORITY\"\n+            // The F_ fnctl constants are tested in the `linux_fnctl.rs` tests:\n+            | \"F_CANCELLK\"\n+            | \"F_ADD_SEALS\"\n+            | \"F_GET_SEALS\"\n+            | \"F_SEAL_SEAL\"\n+            | \"F_SEAL_SHRINK\"\n+            | \"F_SEAL_GROW\"\n+            | \"F_SEAL_WRITE\" => true,\n+\n+            // The musl-sanitized kernel headers used in CI\n+            // target the Linux kernel 4.4 and do not contain the\n+            // following constants:\n+            //\n+            // Requires Linux kernel 4.9\n+            | \"FALLOC_FL_UNSHARE_RANGE\"\n+            //\n+            // Require Linux kernel 5.x:\n+            | \"MSG_COPY\"\n+               if musl  => true,\n+            // Require Linux kernel 5.1:\n+            \"F_SEAL_FUTURE_WRITE\" => true,\n+\n+            // The musl version 1.0.22 used in CI does not\n+            // contain these glibc constants yet:\n+            | \"RLIMIT_RTTIME\" // should be in `resource.h`\n+            | \"TCP_COOKIE_TRANSACTIONS\"  // should be in the `netinet/tcp.h` header\n+                if musl => true,\n+\n+            // FIXME: deprecated: not available in any header\n+            // See: https://github.com/rust-lang/libc/issues/1356\n+            \"ENOATTR\" => true,\n+\n+            // FIXME: SIGUNUSED was removed in glibc 2.26\n+            // Users should use SIGSYS instead.\n+            \"SIGUNUSED\" => true,\n+\n+            // FIXME: conflicts with glibc headers and is tested in\n+            // `linux_termios.rs` below:\n+            \"BOTHER\" => true,\n+\n+            // FIXME: on musl the pthread types are defined a little differently\n+            // - these constants are used by the glibc implementation.\n+            n if musl && n.contains(\"__SIZEOF_PTHREAD\") => true,\n+\n+            // FIXME: musl version 1.0.15 used by mips build jobs is ancient\n+            t if mips32_musl && t.starts_with(\"IFF\") => true,\n+            \"MFD_HUGETLB\" | \"AF_XDP\" | \"PF_XDP\" if mips32_musl => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_fn(move |name| {\n+        // skip those that are manually verified\n+        match name {\n+            // FIXME: https://github.com/rust-lang/libc/issues/1272\n+            \"execv\" | \"execve\" | \"execvp\" | \"execvpe\" | \"fexecve\" => true,\n+\n+            // There are two versions of the sterror_r function, see\n+            //\n+            // https://linux.die.net/man/3/strerror_r\n+            //\n+            // An XSI-compliant version provided if:\n+            //\n+            // (_POSIX_C_SOURCE >= 200112L || _XOPEN_SOURCE >= 600)\n+            //  && ! _GNU_SOURCE\n+            //\n+            // and a GNU specific version provided if _GNU_SOURCE is defined.\n+            //\n+            // libc provides bindings for the XSI-compliant version, which is\n+            // preferred for portable applications.\n+            //\n+            // We skip the test here since here _GNU_SOURCE is defined, and\n+            // test the XSI version below.\n+            \"strerror_r\" => true,\n+\n+            // FIXME: Our API is unsound. The Rust API allows aliasing\n+            // pointers, but the C API requires pointers not to alias.\n+            // We should probably be at least using `&`/`&mut` here, see:\n+            // https://github.com/gnzlbg/ctest/issues/68\n+            \"lio_listio\" if musl => true,\n+\n+            // FIXME: the glibc version used by the Sparc64 build jobs\n+            // which use Debian 10.0 is too old.\n+            \"statx\" if sparc64 => true,\n+\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_field_type(move |struct_, field| {\n+        // This is a weird union, don't check the type.\n+        (struct_ == \"ifaddrs\" && field == \"ifa_ifu\") ||\n+        // sighandler_t type is super weird\n+        (struct_ == \"sigaction\" && field == \"sa_sigaction\") ||\n+        // __timeval type is a patch which doesn't exist in glibc\n+        (struct_ == \"utmpx\" && field == \"ut_tv\") ||\n+        // sigval is actually a union, but we pretend it's a struct\n+        (struct_ == \"sigevent\" && field == \"sigev_value\") ||\n+        // this one is an anonymous union\n+        (struct_ == \"ff_effect\" && field == \"u\")\n+    });\n+\n+    cfg.volatile_item(|i| {\n+        use ctest::VolatileItemKind::*;\n+        match i {\n+            // aio_buf is a volatile void** but since we cannot express that in\n+            // Rust types, we have to explicitly tell the checker about it here:\n+            StructField(ref n, ref f) if n == \"aiocb\" && f == \"aio_buf\" => {\n+                true\n+            }\n+            _ => false,\n+        }\n+    });\n+\n+    cfg.skip_field(move |struct_, field| {\n+        // this is actually a union on linux, so we can't represent it well and\n+        // just insert some padding.\n+        (struct_ == \"siginfo_t\" && field == \"_pad\") ||\n+        // musl names this __dummy1 but it's still there\n+        (musl && struct_ == \"glob_t\" && field == \"gl_flags\") ||\n+        // musl seems to define this as an *anonymous* bitfield\n+        (musl && struct_ == \"statvfs\" && field == \"__f_unused\") ||\n+        // sigev_notify_thread_id is actually part of a sigev_un union\n+        (struct_ == \"sigevent\" && field == \"sigev_notify_thread_id\") ||\n+        // signalfd had SIGSYS fields added in Linux 4.18, but no libc release\n+        // has them yet.\n+        (struct_ == \"signalfd_siginfo\" && (field == \"ssi_addr_lsb\" ||\n+                                           field == \"_pad2\" ||\n+                                           field == \"ssi_syscall\" ||\n+                                           field == \"ssi_call_addr\" ||\n+                                           field == \"ssi_arch\"))\n+    });\n+\n+    cfg.skip_roundtrip(move |s| match s {\n+        // FIXME:\n+        \"utsname\" if mips32 || mips64 => true,\n+        // FIXME:\n+        \"mcontext_t\" if s390x => true,\n+\n+        \"sockaddr_un\" | \"sembuf\" | \"ff_constant_effect\"\n+            if mips32 && (gnu || musl) =>\n+        {\n+            true\n+        }\n+        \"ipv6_mreq\"\n+        | \"sockaddr_in6\"\n+        | \"sockaddr_ll\"\n+        | \"in_pktinfo\"\n+        | \"arpreq\"\n+        | \"arpreq_old\"\n+        | \"sockaddr_un\"\n+        | \"ff_constant_effect\"\n+        | \"ff_ramp_effect\"\n+        | \"ff_condition_effect\"\n+        | \"Elf32_Ehdr\"\n+        | \"Elf32_Chdr\"\n+        | \"ucred\"\n+        | \"in6_pktinfo\"\n+        | \"sockaddr_nl\"\n+        | \"termios\"\n+        | \"nlmsgerr\"\n+            if (mips64 || sparc64) && gnu =>\n+        {\n+            true\n+        }\n+\n+        // FIXME: the call ABI of max_align_t is incorrect on these platforms:\n+        \"max_align_t\" if i686 || mips64 || ppc64 => true,\n+\n+        _ => false,\n+    });\n+\n+    cfg.generate(\"../src/lib.rs\", \"main.rs\");\n+\n+    test_linux_like_apis(target);\n+}\n+\n+// This function tests APIs that are incompatible to test when other APIs\n+// are included (e.g. because including both sets of headers clashes)\n+fn test_linux_like_apis(target: &str) {\n+    let musl = target.contains(\"musl\");\n+    let linux = target.contains(\"linux\");\n+    let emscripten = target.contains(\"emscripten\");\n+    let android = target.contains(\"android\");\n+    assert!(linux || android || emscripten);\n+\n+    if linux || android || emscripten {\n+        // test strerror_r from the `string.h` header\n+        let mut cfg = ctest_cfg();\n+        cfg.skip_type(|_| true).skip_static(|_| true);\n+\n+        headers! { cfg: \"string.h\" }\n+        cfg.skip_fn(|f| match f {\n+            \"strerror_r\" => false,\n+            _ => true,\n+        })\n+        .skip_const(|_| true)\n+        .skip_struct(|_| true);\n+        cfg.generate(\"../src/lib.rs\", \"linux_strerror_r.rs\");\n+    }\n+\n+    if linux || android || emscripten {\n+        // test fcntl - see:\n+        // http://man7.org/linux/man-pages/man2/fcntl.2.html\n+        let mut cfg = ctest_cfg();\n+\n+        if musl {\n+            cfg.header(\"fcntl.h\");\n+        } else {\n+            cfg.header(\"linux/fcntl.h\");\n+        }\n+\n+        cfg.skip_type(|_| true)\n+            .skip_static(|_| true)\n+            .skip_struct(|_| true)\n+            .skip_fn(|_| true)\n+            .skip_const(move |name| match name {\n+                // test fcntl constants:\n+                \"F_CANCELLK\" | \"F_ADD_SEALS\" | \"F_GET_SEALS\"\n+                | \"F_SEAL_SEAL\" | \"F_SEAL_SHRINK\" | \"F_SEAL_GROW\"\n+                | \"F_SEAL_WRITE\" => false,\n+                _ => true,\n+            })\n+            .type_name(move |ty, is_struct, is_union| match ty {\n+                t if is_struct => format!(\"struct {}\", t),\n+                t if is_union => format!(\"union {}\", t),\n+                t => t.to_string(),\n+            });\n+\n+        cfg.generate(\"../src/lib.rs\", \"linux_fcntl.rs\");\n+    }\n+\n+    if linux || android {\n+        // test termios\n+        let mut cfg = ctest_cfg();\n+        cfg.header(\"asm/termbits.h\");\n+        cfg.skip_type(|_| true)\n+            .skip_static(|_| true)\n+            .skip_fn(|_| true)\n+            .skip_const(|c| c != \"BOTHER\")\n+            .skip_struct(|s| s != \"termios2\")\n+            .type_name(move |ty, is_struct, is_union| match ty {\n+                t if is_struct => format!(\"struct {}\", t),\n+                t if is_union => format!(\"union {}\", t),\n+                t => t.to_string(),\n+            });\n+        cfg.generate(\"../src/lib.rs\", \"linux_termios.rs\");\n+    }\n+\n+    if linux || android {\n+        // test IPV6_ constants:\n+        let mut cfg = ctest_cfg();\n+        headers! {\n+            cfg:\n+            \"linux/in6.h\"\n+        }\n+        cfg.skip_type(|_| true)\n+            .skip_static(|_| true)\n+            .skip_fn(|_| true)\n+            .skip_const(|_| true)\n+            .skip_struct(|_| true)\n+            .skip_const(move |name| match name {\n+                \"IPV6_FLOWINFO\"\n+                | \"IPV6_FLOWLABEL_MGR\"\n+                | \"IPV6_FLOWINFO_SEND\"\n+                | \"IPV6_FLOWINFO_FLOWLABEL\"\n+                | \"IPV6_FLOWINFO_PRIORITY\" => false,\n+                _ => true,\n+            })\n+            .type_name(move |ty, is_struct, is_union| match ty {\n+                t if is_struct => format!(\"struct {}\", t),\n+                t if is_union => format!(\"union {}\", t),\n+                t => t.to_string(),\n+            });\n+        cfg.generate(\"../src/lib.rs\", \"linux_ipv6.rs\");\n+    }\n+\n+    if linux || android {\n+        // Test Elf64_Phdr and Elf32_Phdr\n+        // These types have a field called `p_type`, but including\n+        // \"resolve.h\" defines a `p_type` macro that expands to `__p_type`\n+        // making the tests for these fails when both are included.\n+        let mut cfg = ctest_cfg();\n+        cfg.header(\"elf.h\");\n+        cfg.skip_fn(|_| true)\n+            .skip_static(|_| true)\n+            .skip_fn(|_| true)\n+            .skip_const(|_| true)\n+            .type_name(move |ty, _is_struct, _is_union| ty.to_string())\n+            .skip_struct(move |ty| match ty {\n+                \"Elf64_Phdr\" | \"Elf32_Phdr\" => false,\n+                _ => true,\n+            })\n+            .skip_type(move |ty| match ty {\n+                \"Elf64_Phdr\" | \"Elf32_Phdr\" => false,\n+                _ => true,\n+            });\n+        cfg.generate(\"../src/lib.rs\", \"linux_elf.rs\");\n+    }\n+}\n+\n+fn which_freebsd() -> Option<i32> {\n+    let output = std::process::Command::new(\"freebsd-version\")\n+        .output()\n+        .ok()?;\n+    if !output.status.success() {\n+        return None;\n+    }\n+\n+    let stdout = String::from_utf8(output.stdout).ok()?;\n+\n+    match &stdout {\n+        s if s.starts_with(\"10\") => Some(10),\n+        s if s.starts_with(\"11\") => Some(11),\n+        s if s.starts_with(\"12\") => Some(12),\n+        s if s.starts_with(\"13\") => Some(13),\n+        _ => None,\n+    }\n+}"
      },
      {
        "sha": "a8b1c371736c84f55e46210e0644225b2b909f66",
        "filename": "src/rusty/libc/libc-test/src/cmsg.c",
        "status": "added",
        "additions": 28,
        "deletions": 0,
        "changes": 28,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/src/cmsg.c",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/src/cmsg.c",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/libc-test/src/cmsg.c?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,28 @@\n+#include <sys/param.h>\n+#include <sys/socket.h>\n+\n+// Since the cmsg(3) macros are macros instead of functions, they aren't\n+// available to FFI.  libc must reimplement them, which is error-prone.  This\n+// file provides FFI access to the actual macros so they can be tested against\n+// the Rust reimplementations.\n+\n+struct cmsghdr *cmsg_firsthdr(struct msghdr *msgh) {\n+\treturn CMSG_FIRSTHDR(msgh);\n+}\n+\n+struct cmsghdr *cmsg_nxthdr(struct msghdr *msgh, struct cmsghdr *cmsg) {\n+\treturn CMSG_NXTHDR(msgh, cmsg);\n+}\n+\n+size_t cmsg_space(size_t length) {\n+\treturn CMSG_SPACE(length);\n+}\n+\n+size_t cmsg_len(size_t length) {\n+\treturn CMSG_LEN(length);\n+}\n+\n+unsigned char *cmsg_data(struct cmsghdr *cmsg) {\n+\treturn CMSG_DATA(cmsg);\n+}\n+"
      },
      {
        "sha": "38a8ce15089011dd7748af93dc9bc56f64632f43",
        "filename": "src/rusty/libc/libc-test/test/cmsg.rs",
        "status": "added",
        "additions": 100,
        "deletions": 0,
        "changes": 100,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/test/cmsg.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/test/cmsg.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/libc-test/test/cmsg.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,100 @@\n+//! Compare libc's CMSG(3) family of functions against the actual C macros, for\n+//! various inputs.\n+\n+extern crate libc;\n+\n+#[cfg(unix)]\n+mod t {\n+\n+    use libc::{self, c_uchar, c_uint, c_void, cmsghdr, msghdr};\n+    use std::mem;\n+\n+    extern \"C\" {\n+        pub fn cmsg_firsthdr(msgh: *const msghdr) -> *mut cmsghdr;\n+        pub fn cmsg_nxthdr(\n+            mhdr: *const msghdr,\n+            cmsg: *const cmsghdr,\n+        ) -> *mut cmsghdr;\n+        pub fn cmsg_space(length: c_uint) -> usize;\n+        pub fn cmsg_len(length: c_uint) -> usize;\n+        pub fn cmsg_data(cmsg: *const cmsghdr) -> *mut c_uchar;\n+    }\n+\n+    #[test]\n+    fn test_cmsg_data() {\n+        for l in 0..128 {\n+            let pcmsghdr = l as *const cmsghdr;\n+            unsafe {\n+                assert_eq!(libc::CMSG_DATA(pcmsghdr), cmsg_data(pcmsghdr));\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_cmsg_firsthdr() {\n+        let mut mhdr: msghdr = unsafe { mem::zeroed() };\n+        mhdr.msg_control = 0xdeadbeef as *mut c_void;\n+        let pmhdr = &mhdr as *const msghdr;\n+        for l in 0..128 {\n+            mhdr.msg_controllen = l;\n+            unsafe {\n+                assert_eq!(libc::CMSG_FIRSTHDR(pmhdr), cmsg_firsthdr(pmhdr));\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_cmsg_len() {\n+        for l in 0..128 {\n+            unsafe {\n+                assert_eq!(libc::CMSG_LEN(l) as usize, cmsg_len(l));\n+            }\n+        }\n+    }\n+\n+    // Skip on sparc64\n+    // https://github.com/rust-lang/libc/issues/1239\n+    #[cfg(not(target_arch = \"sparc64\"))]\n+    #[test]\n+    fn test_cmsg_nxthdr() {\n+        use std::ptr;\n+\n+        let mut buffer = [0u8; 256];\n+        let mut mhdr: msghdr = unsafe { mem::zeroed() };\n+        let pmhdr = &mhdr as *const msghdr;\n+        for start_ofs in 0..64 {\n+            let pcmsghdr = &mut buffer[start_ofs] as *mut u8 as *mut cmsghdr;\n+            mhdr.msg_control = pcmsghdr as *mut c_void;\n+            mhdr.msg_controllen = (160 - start_ofs) as _;\n+            for cmsg_len in 0..64 {\n+                for next_cmsg_len in 0..32 {\n+                    for i in buffer[start_ofs..].iter_mut() {\n+                        *i = 0;\n+                    }\n+                    unsafe {\n+                        (*pcmsghdr).cmsg_len = cmsg_len;\n+                        let libc_next = libc::CMSG_NXTHDR(pmhdr, pcmsghdr);\n+                        let next = cmsg_nxthdr(pmhdr, pcmsghdr);\n+                        assert_eq!(libc_next, next);\n+\n+                        if libc_next != ptr::null_mut() {\n+                            (*libc_next).cmsg_len = next_cmsg_len;\n+                            let libc_next = libc::CMSG_NXTHDR(pmhdr, pcmsghdr);\n+                            let next = cmsg_nxthdr(pmhdr, pcmsghdr);\n+                            assert_eq!(libc_next, next);\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn test_cmsg_space() {\n+        unsafe {\n+            for l in 0..128 {\n+                assert_eq!(libc::CMSG_SPACE(l) as usize, cmsg_space(l));\n+            }\n+        }\n+    }\n+}"
      },
      {
        "sha": "d149c9aaff38e043bc437120cf5263f4983e19ec",
        "filename": "src/rusty/libc/libc-test/test/linux_elf.rs",
        "status": "added",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/test/linux_elf.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/test/linux_elf.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/libc-test/test/linux_elf.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,12 @@\n+#![allow(bad_style, improper_ctypes, unused, deprecated)]\n+\n+extern crate libc;\n+use libc::*;\n+\n+#[cfg(target_os = \"linux\")]\n+include!(concat!(env!(\"OUT_DIR\"), \"/linux_elf.rs\"));\n+\n+#[cfg(not(target_os = \"linux\"))]\n+fn main() {\n+    println!(\"PASSED 0 tests\");\n+}"
      },
      {
        "sha": "49c06cc4f6517a114e11e12756d0bfa0fbab2990",
        "filename": "src/rusty/libc/libc-test/test/linux_fcntl.rs",
        "status": "added",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/test/linux_fcntl.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/test/linux_fcntl.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/libc-test/test/linux_fcntl.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,12 @@\n+#![allow(bad_style, improper_ctypes, unused, deprecated)]\n+\n+extern crate libc;\n+use libc::*;\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+include!(concat!(env!(\"OUT_DIR\"), \"/linux_fcntl.rs\"));\n+\n+#[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+fn main() {\n+    println!(\"PASSED 0 tests\");\n+}"
      },
      {
        "sha": "83c389ce16a0345fbc2204871c390115bcb312c9",
        "filename": "src/rusty/libc/libc-test/test/linux_ipv6.rs",
        "status": "added",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/test/linux_ipv6.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/test/linux_ipv6.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/libc-test/test/linux_ipv6.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,12 @@\n+#![allow(bad_style, improper_ctypes, unused, deprecated)]\n+\n+extern crate libc;\n+use libc::*;\n+\n+#[cfg(target_os = \"linux\")]\n+include!(concat!(env!(\"OUT_DIR\"), \"/linux_ipv6.rs\"));\n+\n+#[cfg(not(target_os = \"linux\"))]\n+fn main() {\n+    println!(\"PASSED 0 tests\");\n+}"
      },
      {
        "sha": "17db959d8cb933edc21f6165bc1c5be225ac1174",
        "filename": "src/rusty/libc/libc-test/test/linux_strerror_r.rs",
        "status": "added",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/test/linux_strerror_r.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/test/linux_strerror_r.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/libc-test/test/linux_strerror_r.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,12 @@\n+#![allow(bad_style, improper_ctypes, unused, deprecated)]\n+\n+extern crate libc;\n+use libc::*;\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+include!(concat!(env!(\"OUT_DIR\"), \"/linux_strerror_r.rs\"));\n+\n+#[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+fn main() {\n+    println!(\"PASSED 0 tests\");\n+}"
      },
      {
        "sha": "703a9b9b25b0d721ab76c201256dacc8802c1911",
        "filename": "src/rusty/libc/libc-test/test/linux_termios.rs",
        "status": "added",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/test/linux_termios.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/test/linux_termios.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/libc-test/test/linux_termios.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,12 @@\n+#![allow(bad_style, improper_ctypes, unused, deprecated)]\n+\n+extern crate libc;\n+use libc::*;\n+\n+#[cfg(any(target_os = \"linux\", target_os = \"android\"))]\n+include!(concat!(env!(\"OUT_DIR\"), \"/linux_termios.rs\"));\n+\n+#[cfg(not(any(target_os = \"linux\", target_os = \"android\")))]\n+fn main() {\n+    println!(\"PASSED 0 tests\");\n+}"
      },
      {
        "sha": "62a587cf5868fa7120c3d69b7bdc6e516015afa7",
        "filename": "src/rusty/libc/libc-test/test/main.rs",
        "status": "added",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/test/main.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/libc-test/test/main.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/libc-test/test/main.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,6 @@\n+#![allow(bad_style, improper_ctypes, deprecated)]\n+extern crate libc;\n+\n+use libc::*;\n+\n+include!(concat!(env!(\"OUT_DIR\"), \"/main.rs\"));"
      },
      {
        "sha": "7ecc610f330a477d0ed5e2941964deb413068b9b",
        "filename": "src/rusty/libc/rustfmt.toml",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/rustfmt.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/rustfmt.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/rustfmt.toml?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,3 @@\n+max_width = 79\n+comment_width = 79\n+error_on_line_overflow = true\n\\ No newline at end of file"
      },
      {
        "sha": "4caa6d7bbcf474fea1f5202eeb71a4fd2efe4c76",
        "filename": "src/rusty/libc/src/cloudabi/aarch64.rs",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/cloudabi/aarch64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/cloudabi/aarch64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/cloudabi/aarch64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,4 @@\n+pub type c_char = u8;\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type wchar_t = u32;"
      },
      {
        "sha": "eca5360744127fb21cdf6047cdbb98817e916655",
        "filename": "src/rusty/libc/src/cloudabi/arm.rs",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/cloudabi/arm.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/cloudabi/arm.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/cloudabi/arm.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,4 @@\n+pub type c_char = u8;\n+pub type c_long = i32;\n+pub type c_ulong = u32;\n+pub type wchar_t = u32;"
      },
      {
        "sha": "b3065d7237383978f8a722e66db9b09bf9b2b689",
        "filename": "src/rusty/libc/src/cloudabi/mod.rs",
        "status": "added",
        "additions": 374,
        "deletions": 0,
        "changes": 374,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/cloudabi/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/cloudabi/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/cloudabi/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,374 @@\n+pub type c_schar = i8;\n+pub type c_uchar = u8;\n+pub type c_short = i16;\n+pub type c_ushort = u16;\n+pub type c_int = i32;\n+pub type c_uint = u32;\n+pub type c_float = f32;\n+pub type c_double = f64;\n+pub type c_longlong = i64;\n+pub type c_ulonglong = u64;\n+pub type intmax_t = i64;\n+pub type uintmax_t = u64;\n+\n+pub type size_t = usize;\n+pub type ptrdiff_t = isize;\n+pub type intptr_t = isize;\n+pub type uintptr_t = usize;\n+pub type ssize_t = isize;\n+\n+pub type in_addr_t = u32;\n+pub type in_port_t = u16;\n+pub type pthread_key_t = usize;\n+pub type pthread_t = usize;\n+pub type sa_family_t = u8;\n+pub type socklen_t = usize;\n+pub type time_t = i64;\n+\n+s! {\n+    pub struct addrinfo {\n+        pub ai_flags: ::c_int,\n+        pub ai_family: ::c_int,\n+        pub ai_socktype: ::c_int,\n+        pub ai_protocol: ::c_int,\n+        pub ai_addrlen: ::socklen_t,\n+        pub ai_addr: *mut ::sockaddr,\n+        pub ai_canonname: *mut ::c_char,\n+        pub ai_next: *mut addrinfo,\n+    }\n+\n+    pub struct in_addr {\n+        pub s_addr: in_addr_t,\n+    }\n+\n+    pub struct in6_addr {\n+        pub s6_addr: [u8; 16],\n+    }\n+\n+    pub struct pthread_attr_t {\n+        __detachstate: ::c_int,\n+        __stacksize: usize,\n+    }\n+\n+    pub struct sockaddr {\n+        pub sa_family: sa_family_t,\n+        pub sa_data: [::c_char; 0],\n+    }\n+\n+    pub struct sockaddr_in {\n+        pub sin_family: ::sa_family_t,\n+        pub sin_port: ::in_port_t,\n+        pub sin_addr: ::in_addr,\n+    }\n+\n+    pub struct sockaddr_in6 {\n+        pub sin6_family: sa_family_t,\n+        pub sin6_port: ::in_port_t,\n+        pub sin6_flowinfo: u32,\n+        pub sin6_addr: ::in6_addr,\n+        pub sin6_scope_id: u32,\n+    }\n+\n+    pub struct sockaddr_storage {\n+        pub ss_family: ::sa_family_t,\n+        __ss_data: [u8; 32],\n+    }\n+}\n+\n+pub const INT_MIN: c_int = -2147483648;\n+pub const INT_MAX: c_int = 2147483647;\n+\n+pub const _SC_NPROCESSORS_ONLN: ::c_int = 52;\n+pub const _SC_PAGESIZE: ::c_int = 54;\n+\n+pub const AF_INET: ::c_int = 1;\n+pub const AF_INET6: ::c_int = 2;\n+\n+pub const EACCES: ::c_int = 2;\n+pub const EADDRINUSE: ::c_int = 3;\n+pub const EADDRNOTAVAIL: ::c_int = 4;\n+pub const EAGAIN: ::c_int = 6;\n+pub const ECONNABORTED: ::c_int = 13;\n+pub const ECONNREFUSED: ::c_int = 14;\n+pub const ECONNRESET: ::c_int = 15;\n+pub const EEXIST: ::c_int = 20;\n+pub const EINTR: ::c_int = 27;\n+pub const EINVAL: ::c_int = 28;\n+pub const ENOENT: ::c_int = 44;\n+pub const ENOTCONN: ::c_int = 53;\n+pub const EPERM: ::c_int = 63;\n+pub const EPIPE: ::c_int = 64;\n+pub const ETIMEDOUT: ::c_int = 73;\n+pub const EWOULDBLOCK: ::c_int = EAGAIN;\n+\n+pub const EAI_SYSTEM: ::c_int = 9;\n+\n+pub const EXIT_FAILURE: ::c_int = 1;\n+pub const EXIT_SUCCESS: ::c_int = 0;\n+\n+pub const PTHREAD_STACK_MIN: ::size_t = 1024;\n+\n+pub const SOCK_DGRAM: ::c_int = 128;\n+pub const SOCK_STREAM: ::c_int = 130;\n+\n+#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\n+pub enum FILE {}\n+impl ::Copy for FILE {}\n+impl ::Clone for FILE {\n+    fn clone(&self) -> FILE {\n+        *self\n+    }\n+}\n+#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\n+pub enum fpos_t {} // TODO: fill this out with a struct\n+impl ::Copy for fpos_t {}\n+impl ::Clone for fpos_t {\n+    fn clone(&self) -> fpos_t {\n+        *self\n+    }\n+}\n+\n+extern \"C\" {\n+    pub fn isalnum(c: c_int) -> c_int;\n+    pub fn isalpha(c: c_int) -> c_int;\n+    pub fn iscntrl(c: c_int) -> c_int;\n+    pub fn isdigit(c: c_int) -> c_int;\n+    pub fn isgraph(c: c_int) -> c_int;\n+    pub fn islower(c: c_int) -> c_int;\n+    pub fn isprint(c: c_int) -> c_int;\n+    pub fn ispunct(c: c_int) -> c_int;\n+    pub fn isspace(c: c_int) -> c_int;\n+    pub fn isupper(c: c_int) -> c_int;\n+    pub fn isxdigit(c: c_int) -> c_int;\n+    pub fn isblank(c: c_int) -> c_int;\n+    pub fn tolower(c: c_int) -> c_int;\n+    pub fn toupper(c: c_int) -> c_int;\n+    pub fn fopen(filename: *const c_char, mode: *const c_char) -> *mut FILE;\n+    pub fn freopen(\n+        filename: *const c_char,\n+        mode: *const c_char,\n+        file: *mut FILE,\n+    ) -> *mut FILE;\n+    pub fn fflush(file: *mut FILE) -> c_int;\n+    pub fn fclose(file: *mut FILE) -> c_int;\n+    pub fn remove(filename: *const c_char) -> c_int;\n+    pub fn rename(oldname: *const c_char, newname: *const c_char) -> c_int;\n+    pub fn tmpfile() -> *mut FILE;\n+    pub fn setvbuf(\n+        stream: *mut FILE,\n+        buffer: *mut c_char,\n+        mode: c_int,\n+        size: size_t,\n+    ) -> c_int;\n+    pub fn setbuf(stream: *mut FILE, buf: *mut c_char);\n+    pub fn getchar() -> c_int;\n+    pub fn putchar(c: c_int) -> c_int;\n+    pub fn fgetc(stream: *mut FILE) -> c_int;\n+    pub fn fgets(buf: *mut c_char, n: c_int, stream: *mut FILE)\n+        -> *mut c_char;\n+    pub fn fputc(c: c_int, stream: *mut FILE) -> c_int;\n+    pub fn fputs(s: *const c_char, stream: *mut FILE) -> c_int;\n+    pub fn puts(s: *const c_char) -> c_int;\n+    pub fn ungetc(c: c_int, stream: *mut FILE) -> c_int;\n+    pub fn fread(\n+        ptr: *mut c_void,\n+        size: size_t,\n+        nobj: size_t,\n+        stream: *mut FILE,\n+    ) -> size_t;\n+    pub fn fwrite(\n+        ptr: *const c_void,\n+        size: size_t,\n+        nobj: size_t,\n+        stream: *mut FILE,\n+    ) -> size_t;\n+    pub fn fseek(stream: *mut FILE, offset: c_long, whence: c_int) -> c_int;\n+    pub fn ftell(stream: *mut FILE) -> c_long;\n+    pub fn rewind(stream: *mut FILE);\n+    pub fn fgetpos(stream: *mut FILE, ptr: *mut fpos_t) -> c_int;\n+    pub fn fsetpos(stream: *mut FILE, ptr: *const fpos_t) -> c_int;\n+    pub fn feof(stream: *mut FILE) -> c_int;\n+    pub fn ferror(stream: *mut FILE) -> c_int;\n+    pub fn perror(s: *const c_char);\n+    pub fn atoi(s: *const c_char) -> c_int;\n+    pub fn strtod(s: *const c_char, endp: *mut *mut c_char) -> c_double;\n+    pub fn strtol(\n+        s: *const c_char,\n+        endp: *mut *mut c_char,\n+        base: c_int,\n+    ) -> c_long;\n+    pub fn strtoul(\n+        s: *const c_char,\n+        endp: *mut *mut c_char,\n+        base: c_int,\n+    ) -> c_ulong;\n+    pub fn calloc(nobj: size_t, size: size_t) -> *mut c_void;\n+    pub fn malloc(size: size_t) -> *mut c_void;\n+    pub fn realloc(p: *mut c_void, size: size_t) -> *mut c_void;\n+    pub fn free(p: *mut c_void);\n+    pub fn abort() -> !;\n+    pub fn exit(status: c_int) -> !;\n+    pub fn _exit(status: c_int) -> !;\n+    pub fn atexit(cb: extern \"C\" fn()) -> c_int;\n+    pub fn system(s: *const c_char) -> c_int;\n+    pub fn getenv(s: *const c_char) -> *mut c_char;\n+    pub fn getline(\n+        lineptr: *mut *mut c_char,\n+        n: *mut size_t,\n+        stream: *mut FILE,\n+    ) -> ssize_t;\n+\n+    pub fn strcpy(dst: *mut c_char, src: *const c_char) -> *mut c_char;\n+    pub fn strncpy(\n+        dst: *mut c_char,\n+        src: *const c_char,\n+        n: size_t,\n+    ) -> *mut c_char;\n+    pub fn strcat(s: *mut c_char, ct: *const c_char) -> *mut c_char;\n+    pub fn strncat(\n+        s: *mut c_char,\n+        ct: *const c_char,\n+        n: size_t,\n+    ) -> *mut c_char;\n+    pub fn strcmp(cs: *const c_char, ct: *const c_char) -> c_int;\n+    pub fn strncmp(cs: *const c_char, ct: *const c_char, n: size_t) -> c_int;\n+    pub fn strcoll(cs: *const c_char, ct: *const c_char) -> c_int;\n+    pub fn strchr(cs: *const c_char, c: c_int) -> *mut c_char;\n+    pub fn strrchr(cs: *const c_char, c: c_int) -> *mut c_char;\n+    pub fn strspn(cs: *const c_char, ct: *const c_char) -> size_t;\n+    pub fn strcspn(cs: *const c_char, ct: *const c_char) -> size_t;\n+    pub fn strdup(cs: *const c_char) -> *mut c_char;\n+    pub fn strpbrk(cs: *const c_char, ct: *const c_char) -> *mut c_char;\n+    pub fn strstr(cs: *const c_char, ct: *const c_char) -> *mut c_char;\n+    pub fn strcasecmp(s1: *const c_char, s2: *const c_char) -> c_int;\n+    pub fn strncasecmp(\n+        s1: *const c_char,\n+        s2: *const c_char,\n+        n: size_t,\n+    ) -> c_int;\n+    pub fn strlen(cs: *const c_char) -> size_t;\n+    pub fn strnlen(cs: *const c_char, maxlen: size_t) -> size_t;\n+    pub fn strerror(n: c_int) -> *mut c_char;\n+    pub fn strtok(s: *mut c_char, t: *const c_char) -> *mut c_char;\n+    pub fn strxfrm(s: *mut c_char, ct: *const c_char, n: size_t) -> size_t;\n+    pub fn wcslen(buf: *const wchar_t) -> size_t;\n+    pub fn wcstombs(\n+        dest: *mut c_char,\n+        src: *const wchar_t,\n+        n: size_t,\n+    ) -> ::size_t;\n+\n+    pub fn memchr(cx: *const c_void, c: c_int, n: size_t) -> *mut c_void;\n+    pub fn memcmp(cx: *const c_void, ct: *const c_void, n: size_t) -> c_int;\n+    pub fn memcpy(\n+        dest: *mut c_void,\n+        src: *const c_void,\n+        n: size_t,\n+    ) -> *mut c_void;\n+    pub fn memmove(\n+        dest: *mut c_void,\n+        src: *const c_void,\n+        n: size_t,\n+    ) -> *mut c_void;\n+    pub fn memset(dest: *mut c_void, c: c_int, n: size_t) -> *mut c_void;\n+\n+    pub fn abs(i: c_int) -> c_int;\n+    pub fn atof(s: *const c_char) -> c_double;\n+    pub fn labs(i: c_long) -> c_long;\n+    pub fn rand() -> c_int;\n+    pub fn srand(seed: c_uint);\n+\n+    pub fn arc4random_buf(buf: *const ::c_void, len: ::size_t);\n+    pub fn freeaddrinfo(res: *mut addrinfo);\n+    pub fn gai_strerror(errcode: ::c_int) -> *const ::c_char;\n+    pub fn getaddrinfo(\n+        node: *const c_char,\n+        service: *const c_char,\n+        hints: *const addrinfo,\n+        res: *mut *mut addrinfo,\n+    ) -> ::c_int;\n+    pub fn getsockopt(\n+        sockfd: ::c_int,\n+        level: ::c_int,\n+        optname: ::c_int,\n+        optval: *mut ::c_void,\n+        optlen: *mut ::socklen_t,\n+    ) -> ::c_int;\n+    pub fn posix_memalign(\n+        memptr: *mut *mut ::c_void,\n+        align: ::size_t,\n+        size: ::size_t,\n+    ) -> ::c_int;\n+    pub fn pthread_attr_destroy(attr: *mut ::pthread_attr_t) -> ::c_int;\n+    pub fn pthread_attr_init(attr: *mut ::pthread_attr_t) -> ::c_int;\n+    pub fn pthread_attr_setstacksize(\n+        attr: *mut ::pthread_attr_t,\n+        stack_size: ::size_t,\n+    ) -> ::c_int;\n+    pub fn pthread_create(\n+        native: *mut ::pthread_t,\n+        attr: *const ::pthread_attr_t,\n+        f: extern \"C\" fn(*mut ::c_void) -> *mut ::c_void,\n+        value: *mut ::c_void,\n+    ) -> ::c_int;\n+    pub fn pthread_detach(thread: ::pthread_t) -> ::c_int;\n+    pub fn pthread_getspecific(key: pthread_key_t) -> *mut ::c_void;\n+    pub fn pthread_join(\n+        native: ::pthread_t,\n+        value: *mut *mut ::c_void,\n+    ) -> ::c_int;\n+    pub fn pthread_key_create(\n+        key: *mut pthread_key_t,\n+        dtor: ::Option<unsafe extern \"C\" fn(*mut ::c_void)>,\n+    ) -> ::c_int;\n+    pub fn pthread_key_delete(key: pthread_key_t) -> ::c_int;\n+    pub fn pthread_setspecific(\n+        key: pthread_key_t,\n+        value: *const ::c_void,\n+    ) -> ::c_int;\n+    pub fn send(\n+        socket: ::c_int,\n+        buf: *const ::c_void,\n+        len: ::size_t,\n+        flags: ::c_int,\n+    ) -> ::ssize_t;\n+    pub fn sysconf(name: ::c_int) -> ::c_long;\n+}\n+\n+cfg_if! {\n+    if #[cfg(target_arch = \"aarch64\")] {\n+        mod aarch64;\n+        pub use self::aarch64::*;\n+    } else if #[cfg(any(target_arch = \"arm\"))] {\n+        mod arm;\n+        pub use self::arm::*;\n+    } else if #[cfg(any(target_arch = \"x86\"))] {\n+        mod x86;\n+        pub use self::x86::*;\n+    } else if #[cfg(any(target_arch = \"x86_64\"))] {\n+        mod x86_64;\n+        pub use self::x86_64::*;\n+    } else {\n+        // Unknown target_arch\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(libc_core_cvoid)] {\n+        pub use ::ffi::c_void;\n+    } else {\n+        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help\n+        // enable more optimization opportunities around it recognizing things\n+        // like malloc/free.\n+        #[repr(u8)]\n+        #[allow(missing_copy_implementations)]\n+        #[allow(missing_debug_implementations)]\n+        pub enum c_void {\n+            // Two dummy variants so the #[repr] attribute can be used.\n+            #[doc(hidden)]\n+            __variant1,\n+            #[doc(hidden)]\n+            __variant2,\n+        }\n+    }\n+}"
      },
      {
        "sha": "2f9f39c9b9ec356fd2761544aab398929b201b2d",
        "filename": "src/rusty/libc/src/cloudabi/x86.rs",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/cloudabi/x86.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/cloudabi/x86.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/cloudabi/x86.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,4 @@\n+pub type c_char = i8;\n+pub type c_long = i32;\n+pub type c_ulong = u32;\n+pub type wchar_t = i32;"
      },
      {
        "sha": "bb17624b1dd7892bcd6abb4a61a0fa8dd9978f9f",
        "filename": "src/rusty/libc/src/cloudabi/x86_64.rs",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/cloudabi/x86_64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/cloudabi/x86_64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/cloudabi/x86_64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,4 @@\n+pub type c_char = i8;\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type wchar_t = i32;"
      },
      {
        "sha": "014640855fa309d78eb864d5a9755b243c3d27c5",
        "filename": "src/rusty/libc/src/fixed_width_ints.rs",
        "status": "added",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/fixed_width_ints.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/fixed_width_ints.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/fixed_width_ints.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,20 @@\n+//! This module contains type aliases for C's fixed-width integer types .\n+//!\n+//! These aliases are deprecated: use the Rust types instead.\n+\n+#[deprecated(since = \"0.2.55\", note = \"Use i8 instead.\")]\n+pub type int8_t = i8;\n+#[deprecated(since = \"0.2.55\", note = \"Use i16 instead.\")]\n+pub type int16_t = i16;\n+#[deprecated(since = \"0.2.55\", note = \"Use i32 instead.\")]\n+pub type int32_t = i32;\n+#[deprecated(since = \"0.2.55\", note = \"Use i64 instead.\")]\n+pub type int64_t = i64;\n+#[deprecated(since = \"0.2.55\", note = \"Use u8 instead.\")]\n+pub type uint8_t = u8;\n+#[deprecated(since = \"0.2.55\", note = \"Use u16 instead.\")]\n+pub type uint16_t = u16;\n+#[deprecated(since = \"0.2.55\", note = \"Use u32 instead.\")]\n+pub type uint32_t = u32;\n+#[deprecated(since = \"0.2.55\", note = \"Use u64 instead.\")]\n+pub type uint64_t = u64;"
      },
      {
        "sha": "259893c0fa84d9e8d705490a9eebdc24d38edae7",
        "filename": "src/rusty/libc/src/fuchsia/aarch64.rs",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/fuchsia/aarch64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/fuchsia/aarch64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/fuchsia/aarch64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,66 @@\n+pub type c_char = u8;\n+pub type __u64 = ::c_ulonglong;\n+pub type wchar_t = u32;\n+pub type nlink_t = ::c_ulong;\n+pub type blksize_t = ::c_long;\n+\n+s! {\n+    pub struct stat {\n+        pub st_dev: ::dev_t,\n+        pub st_ino: ::ino_t,\n+        pub st_mode: ::mode_t,\n+        pub st_nlink: ::nlink_t,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        pub st_rdev: ::dev_t,\n+        __pad0: ::c_ulong,\n+        pub st_size: ::off_t,\n+        pub st_blksize: ::blksize_t,\n+        __pad1: ::c_int,\n+        pub st_blocks: ::blkcnt_t,\n+        pub st_atime: ::time_t,\n+        pub st_atime_nsec: ::c_long,\n+        pub st_mtime: ::time_t,\n+        pub st_mtime_nsec: ::c_long,\n+        pub st_ctime: ::time_t,\n+        pub st_ctime_nsec: ::c_long,\n+        __unused: [::c_uint; 2],\n+    }\n+\n+    pub struct stat64 {\n+        pub st_dev: ::dev_t,\n+        pub st_ino: ::ino_t,\n+        pub st_mode: ::mode_t,\n+        pub st_nlink: ::nlink_t,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        pub st_rdev: ::dev_t,\n+        __pad0: ::c_ulong,\n+        pub st_size: ::off_t,\n+        pub st_blksize: ::blksize_t,\n+        __pad1: ::c_int,\n+        pub st_blocks: ::blkcnt_t,\n+        pub st_atime: ::time_t,\n+        pub st_atime_nsec: ::c_long,\n+        pub st_mtime: ::time_t,\n+        pub st_mtime_nsec: ::c_long,\n+        pub st_ctime: ::time_t,\n+        pub st_ctime_nsec: ::c_long,\n+        __unused: [::c_uint; 2],\n+    }\n+\n+    pub struct ipc_perm {\n+        pub __ipc_perm_key: ::key_t,\n+        pub uid: ::uid_t,\n+        pub gid: ::gid_t,\n+        pub cuid: ::uid_t,\n+        pub cgid: ::gid_t,\n+        pub mode: ::mode_t,\n+        pub __seq: ::c_ushort,\n+        __unused1: ::c_ulong,\n+        __unused2: ::c_ulong,\n+    }\n+}\n+\n+pub const MINSIGSTKSZ: ::size_t = 6144;\n+pub const SIGSTKSZ: ::size_t = 12288;"
      },
      {
        "sha": "3409bf0c6195534cb6ed020153270851e32f458f",
        "filename": "src/rusty/libc/src/fuchsia/align.rs",
        "status": "added",
        "additions": 142,
        "deletions": 0,
        "changes": 142,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/fuchsia/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/fuchsia/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/fuchsia/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,142 @@\n+macro_rules! expand_align {\n+    () => {\n+        s! {\n+            #[cfg_attr(\n+                any(\n+                    target_pointer_width = \"32\",\n+                    target_arch = \"x86_64\"\n+                ),\n+                repr(align(4)))]\n+            #[cfg_attr(\n+                not(any(\n+                    target_pointer_width = \"32\",\n+                    target_arch = \"x86_64\"\n+                )),\n+                repr(align(8)))]\n+            pub struct pthread_mutexattr_t {\n+                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],\n+            }\n+\n+            #[cfg_attr(target_pointer_width = \"32\",\n+                       repr(align(4)))]\n+            #[cfg_attr(target_pointer_width = \"64\",\n+                       repr(align(8)))]\n+            pub struct pthread_rwlockattr_t {\n+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCKATTR_T],\n+            }\n+\n+            #[repr(align(4))]\n+            pub struct pthread_condattr_t {\n+                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],\n+            }\n+        }\n+\n+        s_no_extra_traits! {\n+            #[cfg_attr(all(target_pointer_width = \"32\",\n+                           any(target_arch = \"arm\",\n+                               target_arch = \"x86_64\")),\n+                       repr(align(4)))]\n+            #[cfg_attr(any(target_pointer_width = \"64\",\n+                           not(any(target_arch = \"arm\",\n+                                   target_arch = \"x86_64\"))),\n+                       repr(align(8)))]\n+            pub struct pthread_mutex_t {\n+                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],\n+            }\n+\n+            #[cfg_attr(all(target_pointer_width = \"32\",\n+                           any(target_arch = \"arm\",\n+                               target_arch = \"x86_64\")),\n+                       repr(align(4)))]\n+            #[cfg_attr(any(target_pointer_width = \"64\",\n+                           not(any(target_arch = \"arm\",\n+                                   target_arch = \"x86_64\"))),\n+                       repr(align(8)))]\n+            pub struct pthread_rwlock_t {\n+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],\n+            }\n+\n+            #[cfg_attr(target_pointer_width = \"32\",\n+                       repr(align(4)))]\n+            #[cfg_attr(target_pointer_width = \"64\",\n+                       repr(align(8)))]\n+            #[cfg_attr(target_arch = \"x86\",\n+                       repr(align(4)))]\n+            #[cfg_attr(not(target_arch = \"x86\"),\n+                       repr(align(8)))]\n+            pub struct pthread_cond_t {\n+                size: [u8; ::__SIZEOF_PTHREAD_COND_T],\n+            }\n+        }\n+\n+        cfg_if! {\n+            if #[cfg(feature = \"extra_traits\")] {\n+                impl PartialEq for pthread_cond_t {\n+                    fn eq(&self, other: &pthread_cond_t) -> bool {\n+                        self.size\n+                            .iter()\n+                            .zip(other.size.iter())\n+                            .all(|(a,b)| a == b)\n+                    }\n+                }\n+                impl Eq for pthread_cond_t {}\n+                impl ::fmt::Debug for pthread_cond_t {\n+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                        f.debug_struct(\"pthread_cond_t\")\n+                            // FIXME: .field(\"size\", &self.size)\n+                            .finish()\n+                    }\n+                }\n+                impl ::hash::Hash for pthread_cond_t {\n+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                        self.size.hash(state);\n+                    }\n+                }\n+\n+                impl PartialEq for pthread_mutex_t {\n+                    fn eq(&self, other: &pthread_mutex_t) -> bool {\n+                        self.size\n+                            .iter()\n+                            .zip(other.size.iter())\n+                            .all(|(a,b)| a == b)\n+                    }\n+                }\n+                impl Eq for pthread_mutex_t {}\n+                impl ::fmt::Debug for pthread_mutex_t {\n+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                        f.debug_struct(\"pthread_mutex_t\")\n+                            // FIXME: .field(\"size\", &self.size)\n+                            .finish()\n+                    }\n+                }\n+                impl ::hash::Hash for pthread_mutex_t {\n+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                        self.size.hash(state);\n+                    }\n+                }\n+\n+                impl PartialEq for pthread_rwlock_t {\n+                    fn eq(&self, other: &pthread_rwlock_t) -> bool {\n+                        self.size\n+                            .iter()\n+                            .zip(other.size.iter())\n+                            .all(|(a,b)| a == b)\n+                    }\n+                }\n+                impl Eq for pthread_rwlock_t {}\n+                impl ::fmt::Debug for pthread_rwlock_t {\n+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                        f.debug_struct(\"pthread_rwlock_t\")\n+                            // FIXME: .field(\"size\", &self.size)\n+                            .finish()\n+                    }\n+                }\n+                impl ::hash::Hash for pthread_rwlock_t {\n+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                        self.size.hash(state);\n+                    }\n+                }\n+            }\n+        }\n+    };\n+}"
      },
      {
        "sha": "7d23e67106f3eb18c4fe43e7a320b19aeb20cc3c",
        "filename": "src/rusty/libc/src/fuchsia/mod.rs",
        "status": "added",
        "additions": 4571,
        "deletions": 0,
        "changes": 4571,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/fuchsia/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/fuchsia/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/fuchsia/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "7ca90e0e48a39940e4222f8a65bbf969751e74b6",
        "filename": "src/rusty/libc/src/fuchsia/no_align.rs",
        "status": "added",
        "additions": 129,
        "deletions": 0,
        "changes": 129,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/fuchsia/no_align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/fuchsia/no_align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/fuchsia/no_align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,129 @@\n+macro_rules! expand_align {\n+    () => {\n+        s! {\n+            pub struct pthread_mutexattr_t {\n+                #[cfg(target_arch = \"x86_64\")]\n+                __align: [::c_int; 0],\n+                #[cfg(not(target_arch = \"x86_64\"))]\n+                __align: [::c_long; 0],\n+                size: [u8; ::__SIZEOF_PTHREAD_MUTEXATTR_T],\n+            }\n+\n+            pub struct pthread_rwlockattr_t {\n+                __align: [::c_long; 0],\n+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCKATTR_T],\n+            }\n+\n+            pub struct pthread_condattr_t {\n+                __align: [::c_int; 0],\n+                size: [u8; ::__SIZEOF_PTHREAD_CONDATTR_T],\n+            }\n+        }\n+\n+        s_no_extra_traits! {\n+            pub struct pthread_mutex_t {\n+                #[cfg(any(target_arch = \"arm\",\n+                          all(target_arch = \"x86_64\",\n+                              target_pointer_width = \"32\")))]\n+                __align: [::c_long; 0],\n+                #[cfg(not(any(target_arch = \"arm\",\n+                              all(target_arch = \"x86_64\",\n+                                  target_pointer_width = \"32\"))))]\n+                __align: [::c_longlong; 0],\n+                size: [u8; ::__SIZEOF_PTHREAD_MUTEX_T],\n+            }\n+\n+            pub struct pthread_rwlock_t {\n+                __align: [::c_long; 0],\n+                __align: [::c_longlong; 0],\n+                size: [u8; ::__SIZEOF_PTHREAD_RWLOCK_T],\n+            }\n+\n+            pub struct pthread_cond_t {\n+                __align: [*const ::c_void; 0],\n+                #[cfg(not(target_env = \"musl\"))]\n+                __align: [::c_longlong; 0],\n+                size: [u8; ::__SIZEOF_PTHREAD_COND_T],\n+            }\n+        }\n+\n+        cfg_if! {\n+            if #[cfg(feature = \"extra_traits\")] {\n+                impl PartialEq for pthread_cond_t {\n+                    fn eq(&self, other: &pthread_cond_t) -> bool {\n+                        // Ignore __align field\n+                        self.size\n+                            .iter()\n+                            .zip(other.size.iter())\n+                            .all(|(a,b)| a == b)\n+                    }\n+                }\n+                impl Eq for pthread_cond_t {}\n+                impl ::fmt::Debug for pthread_cond_t {\n+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                        f.debug_struct(\"pthread_cond_t\")\n+                            // Ignore __align field\n+                            // FIXME: .field(\"size\", &self.size)\n+                            .finish()\n+                    }\n+                }\n+                impl ::hash::Hash for pthread_cond_t {\n+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                        // Ignore __align field\n+                        self.size.hash(state);\n+                    }\n+                }\n+\n+                impl PartialEq for pthread_mutex_t {\n+                    fn eq(&self, other: &pthread_mutex_t) -> bool {\n+                        // Ignore __align field\n+                        self.size\n+                            .iter()\n+                            .zip(other.size.iter())\n+                            .all(|(a,b)| a == b)\n+                    }\n+                }\n+                impl Eq for pthread_mutex_t {}\n+                impl ::fmt::Debug for pthread_mutex_t {\n+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                        f.debug_struct(\"pthread_mutex_t\")\n+                            // Ignore __align field\n+                            // FIXME: .field(\"size\", &self.size)\n+                            .finish()\n+                    }\n+                }\n+                impl ::hash::Hash for pthread_mutex_t {\n+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                        // Ignore __align field\n+                        self.size.hash(state);\n+                    }\n+                }\n+\n+                impl PartialEq for pthread_rwlock_t {\n+                    fn eq(&self, other: &pthread_rwlock_t) -> bool {\n+                        // Ignore __align field\n+                        self.size\n+                            .iter()\n+                            .zip(other.size.iter())\n+                            .all(|(a,b)| a == b)\n+                    }\n+                }\n+                impl Eq for pthread_rwlock_t {}\n+                impl ::fmt::Debug for pthread_rwlock_t {\n+                    fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                        f.debug_struct(\"pthread_rwlock_t\")\n+                            // Ignore __align field\n+                            // FIXME: .field(\"size\", &self.size)\n+                            .finish()\n+                    }\n+                }\n+                impl ::hash::Hash for pthread_rwlock_t {\n+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                        // Ignore __align field\n+                        self.size.hash(state);\n+                    }\n+                }\n+            }\n+        }\n+    };\n+}"
      },
      {
        "sha": "dca3c247d8b8345825cef01304d93d02d2cf3072",
        "filename": "src/rusty/libc/src/fuchsia/x86_64.rs",
        "status": "added",
        "additions": 152,
        "deletions": 0,
        "changes": 152,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/fuchsia/x86_64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/fuchsia/x86_64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/fuchsia/x86_64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,152 @@\n+pub type c_char = i8;\n+pub type wchar_t = i32;\n+pub type nlink_t = u64;\n+pub type blksize_t = ::c_long;\n+pub type __u64 = ::c_ulonglong;\n+\n+s! {\n+    pub struct stat {\n+        pub st_dev: ::dev_t,\n+        pub st_ino: ::ino_t,\n+        pub st_nlink: ::nlink_t,\n+        pub st_mode: ::mode_t,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        __pad0: ::c_int,\n+        pub st_rdev: ::dev_t,\n+        pub st_size: ::off_t,\n+        pub st_blksize: ::blksize_t,\n+        pub st_blocks: ::blkcnt_t,\n+        pub st_atime: ::time_t,\n+        pub st_atime_nsec: ::c_long,\n+        pub st_mtime: ::time_t,\n+        pub st_mtime_nsec: ::c_long,\n+        pub st_ctime: ::time_t,\n+        pub st_ctime_nsec: ::c_long,\n+        __unused: [::c_long; 3],\n+    }\n+\n+    pub struct stat64 {\n+        pub st_dev: ::dev_t,\n+        pub st_ino: ::ino64_t,\n+        pub st_nlink: ::nlink_t,\n+        pub st_mode: ::mode_t,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        __pad0: ::c_int,\n+        pub st_rdev: ::dev_t,\n+        pub st_size: ::off_t,\n+        pub st_blksize: ::blksize_t,\n+        pub st_blocks: ::blkcnt64_t,\n+        pub st_atime: ::time_t,\n+        pub st_atime_nsec: ::c_long,\n+        pub st_mtime: ::time_t,\n+        pub st_mtime_nsec: ::c_long,\n+        pub st_ctime: ::time_t,\n+        pub st_ctime_nsec: ::c_long,\n+        __reserved: [::c_long; 3],\n+    }\n+\n+    pub struct mcontext_t {\n+        __private: [u64; 32],\n+    }\n+\n+    pub struct ipc_perm {\n+        pub __ipc_perm_key: ::key_t,\n+        pub uid: ::uid_t,\n+        pub gid: ::gid_t,\n+        pub cuid: ::uid_t,\n+        pub cgid: ::gid_t,\n+        pub mode: ::mode_t,\n+        pub __seq: ::c_int,\n+        __unused1: ::c_long,\n+        __unused2: ::c_long\n+    }\n+}\n+\n+s_no_extra_traits! {\n+    pub struct ucontext_t {\n+        pub uc_flags: ::c_ulong,\n+        pub uc_link: *mut ucontext_t,\n+        pub uc_stack: ::stack_t,\n+        pub uc_mcontext: mcontext_t,\n+        pub uc_sigmask: ::sigset_t,\n+        __private: [u8; 512],\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(feature = \"extra_traits\")] {\n+        impl PartialEq for ucontext_t {\n+            fn eq(&self, other: &ucontext_t) -> bool {\n+                self.uc_flags == other.uc_flags\n+                    && self.uc_link == other.uc_link\n+                    && self.uc_stack == other.uc_stack\n+                    && self.uc_mcontext == other.uc_mcontext\n+                    && self.uc_sigmask == other.uc_sigmask\n+                    && self\n+                    .__private\n+                    .iter()\n+                    .zip(other.__private.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for ucontext_t {}\n+        impl ::fmt::Debug for ucontext_t {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"ucontext_t\")\n+                    .field(\"uc_flags\", &self.uc_flags)\n+                    .field(\"uc_link\", &self.uc_link)\n+                    .field(\"uc_stack\", &self.uc_stack)\n+                    .field(\"uc_mcontext\", &self.uc_mcontext)\n+                    .field(\"uc_sigmask\", &self.uc_sigmask)\n+                    // FIXME: .field(\"__private\", &self.__private)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for ucontext_t {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.uc_flags.hash(state);\n+                self.uc_link.hash(state);\n+                self.uc_stack.hash(state);\n+                self.uc_mcontext.hash(state);\n+                self.uc_sigmask.hash(state);\n+                self.__private.hash(state);\n+            }\n+        }\n+    }\n+}\n+\n+// offsets in user_regs_structs, from sys/reg.h\n+pub const R15: ::c_int = 0;\n+pub const R14: ::c_int = 1;\n+pub const R13: ::c_int = 2;\n+pub const R12: ::c_int = 3;\n+pub const RBP: ::c_int = 4;\n+pub const RBX: ::c_int = 5;\n+pub const R11: ::c_int = 6;\n+pub const R10: ::c_int = 7;\n+pub const R9: ::c_int = 8;\n+pub const R8: ::c_int = 9;\n+pub const RAX: ::c_int = 10;\n+pub const RCX: ::c_int = 11;\n+pub const RDX: ::c_int = 12;\n+pub const RSI: ::c_int = 13;\n+pub const RDI: ::c_int = 14;\n+pub const ORIG_RAX: ::c_int = 15;\n+pub const RIP: ::c_int = 16;\n+pub const CS: ::c_int = 17;\n+pub const EFLAGS: ::c_int = 18;\n+pub const RSP: ::c_int = 19;\n+pub const SS: ::c_int = 20;\n+pub const FS_BASE: ::c_int = 21;\n+pub const GS_BASE: ::c_int = 22;\n+pub const DS: ::c_int = 23;\n+pub const ES: ::c_int = 24;\n+pub const FS: ::c_int = 25;\n+pub const GS: ::c_int = 26;\n+\n+pub const MAP_32BIT: ::c_int = 0x0040;\n+\n+pub const SIGSTKSZ: ::size_t = 8192;\n+pub const MINSIGSTKSZ: ::size_t = 2048;"
      },
      {
        "sha": "1a92e3b4fa3412169caf35628d91ccfae399d6e9",
        "filename": "src/rusty/libc/src/hermit/aarch64.rs",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/hermit/aarch64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/hermit/aarch64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/hermit/aarch64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,2 @@\n+pub type c_char = u8;\n+pub type wchar_t = u32;"
      },
      {
        "sha": "9880b50723e946b2b4f20d9eced17f889e3cfc3f",
        "filename": "src/rusty/libc/src/hermit/mod.rs",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/hermit/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/hermit/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/hermit/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,74 @@\n+// Copyright 2018 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+\n+// libc port for HermitCore (https://hermitcore.org)\n+//\n+// Ported by Colin Fink <colin.finck@rwth-aachen.de>\n+//       and Stefan Lankes <slankes@eonerc.rwth-aachen.de>\n+\n+pub type c_schar = i8;\n+pub type c_uchar = u8;\n+pub type c_short = i16;\n+pub type c_ushort = u16;\n+pub type c_int = i32;\n+pub type c_uint = u32;\n+pub type c_float = f32;\n+pub type c_double = f64;\n+pub type c_longlong = i64;\n+pub type c_ulonglong = u64;\n+pub type intmax_t = i64;\n+pub type uintmax_t = u64;\n+\n+pub type size_t = usize;\n+pub type ptrdiff_t = isize;\n+pub type intptr_t = isize;\n+pub type uintptr_t = usize;\n+pub type ssize_t = isize;\n+\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+\n+pub type wint_t = u32;\n+pub type wctype_t = i64;\n+\n+pub type regoff_t = size_t;\n+pub type off_t = c_long;\n+\n+cfg_if! {\n+    if #[cfg(target_arch = \"aarch64\")] {\n+        mod aarch64;\n+        pub use self::aarch64::*;\n+    } else if #[cfg(target_arch = \"x86_64\")] {\n+        mod x86_64;\n+        pub use self::x86_64::*;\n+    } else {\n+        // Unknown target_arch\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(libc_core_cvoid)] {\n+        pub use ::ffi::c_void;\n+    } else {\n+        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help\n+        // enable more optimization opportunities around it recognizing things\n+        // like malloc/free.\n+        #[repr(u8)]\n+        #[allow(missing_copy_implementations)]\n+        #[allow(missing_debug_implementations)]\n+        pub enum c_void {\n+            // Two dummy variants so the #[repr] attribute can be used.\n+            #[doc(hidden)]\n+            __variant1,\n+            #[doc(hidden)]\n+            __variant2,\n+        }\n+    }\n+}"
      },
      {
        "sha": "76ec3ce823e8fedfc49c9e9118285af65b5d86fb",
        "filename": "src/rusty/libc/src/hermit/x86_64.rs",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/hermit/x86_64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/hermit/x86_64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/hermit/x86_64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,2 @@\n+pub type c_char = i8;\n+pub type wchar_t = i32;"
      },
      {
        "sha": "3255303e5a9b0e0237425a086b12530b44849089",
        "filename": "src/rusty/libc/src/lib.rs",
        "status": "added",
        "additions": 156,
        "deletions": 0,
        "changes": 156,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/lib.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,156 @@\n+// Copyright 2012-2015 The Rust Project Developers. See the COPYRIGHT\n+// file at the top-level directory of this distribution and at\n+// http://rust-lang.org/COPYRIGHT.\n+//\n+// Licensed under the Apache License, Version 2.0 <LICENSE-APACHE or\n+// http://www.apache.org/licenses/LICENSE-2.0> or the MIT license\n+// <LICENSE-MIT or http://opensource.org/licenses/MIT>, at your\n+// option. This file may not be copied, modified, or distributed\n+// except according to those terms.\n+//! libc - Raw FFI bindings to platforms' system libraries\n+//!\n+//! [Documentation for other platforms][pd].\n+//!\n+//! [pd]: https://rust-lang.github.io/libc/#platform-specific-documentation\n+#![crate_name = \"libc\"]\n+#![crate_type = \"rlib\"]\n+#![cfg_attr(libc_deny_warnings, deny(warnings))]\n+#![allow(\n+    bad_style,\n+    overflowing_literals,\n+    improper_ctypes,\n+    unknown_lints,\n+    redundant_semicolon\n+)]\n+// Attributes needed when building as part of the standard library\n+#![cfg_attr(\n+    feature = \"rustc-dep-of-std\",\n+    feature(cfg_target_vendor, link_cfg, no_core)\n+)]\n+#![cfg_attr(libc_thread_local, feature(thread_local))]\n+// Enable extra lints:\n+#![cfg_attr(feature = \"extra_traits\", deny(missing_debug_implementations))]\n+#![deny(missing_copy_implementations, safe_packed_borrows)]\n+#![no_std]\n+#![cfg_attr(feature = \"rustc-dep-of-std\", no_core)]\n+#![cfg_attr(target_os = \"redox\", feature(static_nobundle))]\n+\n+#[macro_use]\n+mod macros;\n+\n+cfg_if! {\n+    if #[cfg(feature = \"rustc-dep-of-std\")] {\n+        extern crate rustc_std_workspace_core as core;\n+        #[allow(unused_imports)]\n+        use core::iter;\n+        #[allow(unused_imports)]\n+        use core::option;\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(libc_priv_mod_use)] {\n+        #[cfg(libc_core_cvoid)]\n+        #[allow(unused_imports)]\n+        use core::ffi;\n+        #[allow(unused_imports)]\n+        use core::fmt;\n+        #[allow(unused_imports)]\n+        use core::hash;\n+        #[allow(unused_imports)]\n+        use core::num;\n+        #[allow(unused_imports)]\n+        use core::mem;\n+        #[doc(hidden)]\n+        #[allow(unused_imports)]\n+        use core::clone::Clone;\n+        #[doc(hidden)]\n+        #[allow(unused_imports)]\n+        use core::marker::Copy;\n+        #[doc(hidden)]\n+        #[allow(unused_imports)]\n+        use core::option::Option;\n+    } else {\n+        #[doc(hidden)]\n+        #[allow(unused_imports)]\n+        pub use core::fmt;\n+        #[doc(hidden)]\n+        #[allow(unused_imports)]\n+        pub use core::hash;\n+        #[doc(hidden)]\n+        #[allow(unused_imports)]\n+        pub use core::num;\n+        #[doc(hidden)]\n+        #[allow(unused_imports)]\n+        pub use core::mem;\n+        #[doc(hidden)]\n+        #[allow(unused_imports)]\n+        pub use core::clone::Clone;\n+        #[doc(hidden)]\n+        #[allow(unused_imports)]\n+        pub use core::marker::Copy;\n+        #[doc(hidden)]\n+        #[allow(unused_imports)]\n+        pub use core::option::Option;\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(windows)] {\n+        mod fixed_width_ints;\n+        pub use fixed_width_ints::*;\n+\n+        mod windows;\n+        pub use windows::*;\n+    } else if #[cfg(target_os = \"cloudabi\")] {\n+        mod fixed_width_ints;\n+        pub use fixed_width_ints::*;\n+\n+        mod cloudabi;\n+        pub use cloudabi::*;\n+    } else if #[cfg(target_os = \"fuchsia\")] {\n+        mod fixed_width_ints;\n+        pub use fixed_width_ints::*;\n+\n+        mod fuchsia;\n+        pub use fuchsia::*;\n+    } else if #[cfg(target_os = \"switch\")] {\n+        mod fixed_width_ints;\n+        pub use fixed_width_ints::*;\n+\n+        mod switch;\n+        pub use switch::*;\n+    } else if #[cfg(target_os = \"vxworks\")] {\n+        mod fixed_width_ints;\n+        pub use fixed_width_ints::*;\n+\n+        mod vxworks;\n+        pub use vxworks::*;\n+    } else if #[cfg(unix)] {\n+        mod fixed_width_ints;\n+        pub use fixed_width_ints::*;\n+\n+        mod unix;\n+        pub use unix::*;\n+    } else if #[cfg(target_os = \"hermit\")] {\n+        mod fixed_width_ints;\n+        pub use fixed_width_ints::*;\n+\n+        mod hermit;\n+        pub use hermit::*;\n+    } else if #[cfg(all(target_env = \"sgx\", target_vendor = \"fortanix\"))] {\n+        mod fixed_width_ints;\n+        pub use fixed_width_ints::*;\n+\n+        mod sgx;\n+        pub use sgx::*;\n+    } else if #[cfg(any(target_env = \"wasi\", target_os = \"wasi\"))] {\n+        mod fixed_width_ints;\n+        pub use fixed_width_ints::*;\n+\n+        mod wasi;\n+        pub use wasi::*;\n+    } else {\n+        // non-supported targets: empty...\n+    }\n+}"
      },
      {
        "sha": "14a28046640c6808e9a475047c91223af2f2e848",
        "filename": "src/rusty/libc/src/macros.rs",
        "status": "added",
        "additions": 195,
        "deletions": 0,
        "changes": 195,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/macros.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/macros.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/macros.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,195 @@\n+/// A macro for defining #[cfg] if-else statements.\n+///\n+/// This is similar to the `if/elif` C preprocessor macro by allowing definition\n+/// of a cascade of `#[cfg]` cases, emitting the implementation which matches\n+/// first.\n+///\n+/// This allows you to conveniently provide a long list #[cfg]'d blocks of code\n+/// without having to rewrite each clause multiple times.\n+#[allow(unused_macros)]\n+macro_rules! cfg_if {\n+    // match if/else chains with a final `else`\n+    ($(\n+        if #[cfg($($meta:meta),*)] { $($it:item)* }\n+    ) else * else {\n+        $($it2:item)*\n+    }) => {\n+        cfg_if! {\n+            @__items\n+            () ;\n+            $( ( ($($meta),*) ($($it)*) ), )*\n+            ( () ($($it2)*) ),\n+        }\n+    };\n+\n+    // match if/else chains lacking a final `else`\n+    (\n+        if #[cfg($($i_met:meta),*)] { $($i_it:item)* }\n+        $(\n+            else if #[cfg($($e_met:meta),*)] { $($e_it:item)* }\n+        )*\n+    ) => {\n+        cfg_if! {\n+            @__items\n+            () ;\n+            ( ($($i_met),*) ($($i_it)*) ),\n+            $( ( ($($e_met),*) ($($e_it)*) ), )*\n+            ( () () ),\n+        }\n+    };\n+\n+    // Internal and recursive macro to emit all the items\n+    //\n+    // Collects all the negated cfgs in a list at the beginning and after the\n+    // semicolon is all the remaining items\n+    (@__items ($($not:meta,)*) ; ) => {};\n+    (@__items ($($not:meta,)*) ; ( ($($m:meta),*) ($($it:item)*) ),\n+     $($rest:tt)*) => {\n+        // Emit all items within one block, applying an approprate #[cfg]. The\n+        // #[cfg] will require all `$m` matchers specified and must also negate\n+        // all previous matchers.\n+        cfg_if! { @__apply cfg(all($($m,)* not(any($($not),*)))), $($it)* }\n+\n+        // Recurse to emit all other items in `$rest`, and when we do so add all\n+        // our `$m` matchers to the list of `$not` matchers as future emissions\n+        // will have to negate everything we just matched as well.\n+        cfg_if! { @__items ($($not,)* $($m,)*) ; $($rest)* }\n+    };\n+\n+    // Internal macro to Apply a cfg attribute to a list of items\n+    (@__apply $m:meta, $($it:item)*) => {\n+        $(#[$m] $it)*\n+    };\n+}\n+\n+#[allow(unused_macros)]\n+macro_rules! s {\n+    ($($(#[$attr:meta])* pub $t:ident $i:ident { $($field:tt)* })*) => ($(\n+        s!(it: $(#[$attr])* pub $t $i { $($field)* });\n+    )*);\n+    (it: $(#[$attr:meta])* pub union $i:ident { $($field:tt)* }) => (\n+        compile_error!(\"unions cannot derive extra traits, use s_no_extra_traits instead\");\n+    );\n+    (it: $(#[$attr:meta])* pub struct $i:ident { $($field:tt)* }) => (\n+        __item! {\n+            #[repr(C)]\n+            #[cfg_attr(feature = \"extra_traits\", derive(Debug, Eq, Hash, PartialEq))]\n+            #[allow(deprecated)]\n+            $(#[$attr])*\n+            pub struct $i { $($field)* }\n+        }\n+        #[allow(deprecated)]\n+        impl ::Copy for $i {}\n+        #[allow(deprecated)]\n+        impl ::Clone for $i {\n+            fn clone(&self) -> $i { *self }\n+        }\n+    );\n+}\n+\n+#[allow(unused_macros)]\n+macro_rules! s_no_extra_traits {\n+    ($($(#[$attr:meta])* pub $t:ident $i:ident { $($field:tt)* })*) => ($(\n+        s_no_extra_traits!(it: $(#[$attr])* pub $t $i { $($field)* });\n+    )*);\n+    (it: $(#[$attr:meta])* pub union $i:ident { $($field:tt)* }) => (\n+        cfg_if! {\n+            if #[cfg(libc_union)] {\n+                __item! {\n+                    #[repr(C)]\n+                    $(#[$attr])*\n+                    pub union $i { $($field)* }\n+                }\n+\n+                impl ::Copy for $i {}\n+                impl ::Clone for $i {\n+                    fn clone(&self) -> $i { *self }\n+                }\n+            }\n+        }\n+    );\n+    (it: $(#[$attr:meta])* pub struct $i:ident { $($field:tt)* }) => (\n+        __item! {\n+            #[repr(C)]\n+            $(#[$attr])*\n+            pub struct $i { $($field)* }\n+        }\n+        impl ::Copy for $i {}\n+        impl ::Clone for $i {\n+            fn clone(&self) -> $i { *self }\n+        }\n+    );\n+}\n+\n+#[allow(unused_macros)]\n+macro_rules! f {\n+    ($(pub fn $i:ident($($arg:ident: $argty:ty),*) -> $ret:ty {\n+        $($body:stmt);*\n+    })*) => ($(\n+        #[inline]\n+        pub unsafe extern fn $i($($arg: $argty),*) -> $ret {\n+            $($body);*\n+        }\n+    )*)\n+}\n+\n+#[allow(unused_macros)]\n+macro_rules! __item {\n+    ($i:item) => {\n+        $i\n+    };\n+}\n+\n+#[allow(unused_macros)]\n+macro_rules! align_const {\n+    ($($(#[$attr:meta])*\n+       pub const $name:ident : $t1:ty\n+       = $t2:ident { $($field:tt)* };)*) => ($(\n+        #[cfg(libc_align)]\n+        $(#[$attr])*\n+        pub const $name : $t1 = $t2 {\n+            $($field)*\n+        };\n+        #[cfg(not(libc_align))]\n+        $(#[$attr])*\n+        pub const $name : $t1 = $t2 {\n+            $($field)*\n+            __align: [],\n+        };\n+    )*)\n+}\n+\n+// This macro is used to deprecate items that should be accessed via the mach crate\n+#[allow(unused_macros)]\n+macro_rules! deprecated_mach {\n+    (pub const $id:ident: $ty:ty = $expr:expr;) => {\n+        #[deprecated(\n+            since = \"0.2.55\",\n+            note = \"Use the `mach` crate instead\",\n+        )]\n+        #[allow(deprecated)]\n+        pub const $id: $ty = $expr;\n+    };\n+    ($(pub const $id:ident: $ty:ty = $expr:expr;)*) => {\n+        $(\n+            deprecated_mach!(\n+                pub const $id: $ty = $expr;\n+            );\n+        )*\n+    };\n+    (pub type $id:ident = $ty:ty;) => {\n+        #[deprecated(\n+            since = \"0.2.55\",\n+            note = \"Use the `mach` crate instead\",\n+        )]\n+        #[allow(deprecated)]\n+        pub type $id = $ty;\n+    };\n+    ($(pub type $id:ident = $ty:ty;)*) => {\n+        $(\n+            deprecated_mach!(\n+                pub type $id = $ty;\n+            );\n+        )*\n+    }\n+}"
      },
      {
        "sha": "7da6269399d9e5d598fc91412932e9dd78e24057",
        "filename": "src/rusty/libc/src/sgx.rs",
        "status": "added",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/sgx.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/sgx.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/sgx.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,47 @@\n+//! SGX C types definition\n+\n+pub type c_schar = i8;\n+pub type c_uchar = u8;\n+pub type c_short = i16;\n+pub type c_ushort = u16;\n+pub type c_int = i32;\n+pub type c_uint = u32;\n+pub type c_float = f32;\n+pub type c_double = f64;\n+pub type c_longlong = i64;\n+pub type c_ulonglong = u64;\n+pub type intmax_t = i64;\n+pub type uintmax_t = u64;\n+\n+pub type size_t = usize;\n+pub type ptrdiff_t = isize;\n+pub type intptr_t = isize;\n+pub type uintptr_t = usize;\n+pub type ssize_t = isize;\n+\n+pub type c_char = i8;\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+\n+pub const INT_MIN: c_int = -2147483648;\n+pub const INT_MAX: c_int = 2147483647;\n+\n+cfg_if! {\n+    if #[cfg(libc_core_cvoid)] {\n+        pub use ::ffi::c_void;\n+    } else {\n+        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help\n+        // enable more optimization opportunities around it recognizing things\n+        // like malloc/free.\n+        #[repr(u8)]\n+        #[allow(missing_copy_implementations)]\n+        #[allow(missing_debug_implementations)]\n+        pub enum c_void {\n+            // Two dummy variants so the #[repr] attribute can be used.\n+            #[doc(hidden)]\n+            __variant1,\n+            #[doc(hidden)]\n+            __variant2,\n+        }\n+    }\n+}"
      },
      {
        "sha": "030ab20d7bd8e7e2b3d06f76619b57145f33e860",
        "filename": "src/rusty/libc/src/switch.rs",
        "status": "added",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/switch.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/switch.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/switch.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,49 @@\n+//! Switch C type definitions\n+\n+pub type c_schar = i8;\n+pub type c_uchar = u8;\n+pub type c_short = i16;\n+pub type c_ushort = u16;\n+pub type c_int = i32;\n+pub type c_uint = u32;\n+pub type c_float = f32;\n+pub type c_double = f64;\n+pub type c_longlong = i64;\n+pub type c_ulonglong = u64;\n+pub type intmax_t = i64;\n+pub type uintmax_t = u64;\n+\n+pub type size_t = usize;\n+pub type ptrdiff_t = isize;\n+pub type intptr_t = isize;\n+pub type uintptr_t = usize;\n+pub type ssize_t = isize;\n+\n+pub type off_t = i64;\n+pub type c_char = u8;\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type wchar_t = u32;\n+\n+pub const INT_MIN: c_int = -2147483648;\n+pub const INT_MAX: c_int = 2147483647;\n+\n+cfg_if! {\n+    if #[cfg(libc_core_cvoid)] {\n+        pub use ::ffi::c_void;\n+    } else {\n+        // Use repr(u8) as LLVM expects `void*` to be the same as `i8*` to help\n+        // enable more optimization opportunities around it recognizing things\n+        // like malloc/free.\n+        #[repr(u8)]\n+        #[allow(missing_copy_implementations)]\n+        #[allow(missing_debug_implementations)]\n+        pub enum c_void {\n+            // Two dummy variants so the #[repr] attribute can be used.\n+            #[doc(hidden)]\n+            __variant1,\n+            #[doc(hidden)]\n+            __variant2,\n+        }\n+    }\n+}"
      },
      {
        "sha": "4fdba9a6aba6927d096c0cbc506b1f7ad94da0d0",
        "filename": "src/rusty/libc/src/unix/align.rs",
        "status": "added",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,6 @@\n+s! {\n+    #[repr(align(4))]\n+    pub struct in6_addr {\n+        pub s6_addr: [u8; 16],\n+    }\n+}"
      },
      {
        "sha": "ca1fe1ce299442531bef79be18ad7caada5b2503",
        "filename": "src/rusty/libc/src/unix/bsd/apple/b32/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/apple/b32/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/apple/b32/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/apple/b32/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,7 @@\n+s_no_extra_traits! {\n+    #[allow(missing_debug_implementations)]\n+    #[repr(align(16))]\n+    pub struct max_align_t {\n+        priv_: [f64; 2]\n+    }\n+}"
      },
      {
        "sha": "9248e3adf2853e5012e80b31b6aee9bc8cfead91",
        "filename": "src/rusty/libc/src/unix/bsd/apple/b32/mod.rs",
        "status": "added",
        "additions": 115,
        "deletions": 0,
        "changes": 115,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/apple/b32/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/apple/b32/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/apple/b32/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,115 @@\n+//! 32-bit specific Apple (ios/darwin) definitions\n+\n+pub type c_long = i32;\n+pub type c_ulong = u32;\n+pub type boolean_t = ::c_int;\n+\n+s! {\n+    pub struct if_data {\n+        pub ifi_type: ::c_uchar,\n+        pub ifi_typelen: ::c_uchar,\n+        pub ifi_physical: ::c_uchar,\n+        pub ifi_addrlen: ::c_uchar,\n+        pub ifi_hdrlen: ::c_uchar,\n+        pub ifi_recvquota: ::c_uchar,\n+        pub ifi_xmitquota: ::c_uchar,\n+        pub ifi_unused1: ::c_uchar,\n+        pub ifi_mtu: u32,\n+        pub ifi_metric: u32,\n+        pub ifi_baudrate: u32,\n+        pub ifi_ipackets: u32,\n+        pub ifi_ierrors: u32,\n+        pub ifi_opackets: u32,\n+        pub ifi_oerrors: u32,\n+        pub ifi_collisions: u32,\n+        pub ifi_ibytes: u32,\n+        pub ifi_obytes: u32,\n+        pub ifi_imcasts: u32,\n+        pub ifi_omcasts: u32,\n+        pub ifi_iqdrops: u32,\n+        pub ifi_noproto: u32,\n+        pub ifi_recvtiming: u32,\n+        pub ifi_xmittiming: u32,\n+        pub ifi_lastchange: ::timeval,\n+        pub ifi_unused2: u32,\n+        pub ifi_hwassist: u32,\n+        pub ifi_reserved1: u32,\n+        pub ifi_reserved2: u32,\n+    }\n+\n+    pub struct bpf_hdr {\n+        pub bh_tstamp: ::timeval,\n+        pub bh_caplen: u32,\n+        pub bh_datalen: u32,\n+        pub bh_hdrlen: ::c_ushort,\n+    }\n+}\n+\n+s_no_extra_traits! {\n+    pub struct pthread_attr_t {\n+        __sig: c_long,\n+        __opaque: [::c_char; 36]\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(feature = \"extra_traits\")] {\n+        impl PartialEq for pthread_attr_t {\n+            fn eq(&self, other: &pthread_attr_t) -> bool {\n+                self.__sig == other.__sig\n+                    && self.__opaque\n+                    .iter()\n+                    .zip(other.__opaque.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for pthread_attr_t {}\n+        impl ::fmt::Debug for pthread_attr_t {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"pthread_attr_t\")\n+                    .field(\"__sig\", &self.__sig)\n+                // FIXME: .field(\"__opaque\", &self.__opaque)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for pthread_attr_t {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.__sig.hash(state);\n+                self.__opaque.hash(state);\n+            }\n+        }\n+    }\n+}\n+\n+#[doc(hidden)]\n+#[deprecated(since = \"0.2.55\")]\n+pub const NET_RT_MAXID: ::c_int = 10;\n+\n+pub const __PTHREAD_MUTEX_SIZE__: usize = 40;\n+pub const __PTHREAD_COND_SIZE__: usize = 24;\n+pub const __PTHREAD_CONDATTR_SIZE__: usize = 4;\n+pub const __PTHREAD_RWLOCK_SIZE__: usize = 124;\n+pub const __PTHREAD_RWLOCKATTR_SIZE__: usize = 12;\n+\n+pub const TIOCTIMESTAMP: ::c_ulong = 0x40087459;\n+pub const TIOCDCDTIMESTAMP: ::c_ulong = 0x40087458;\n+\n+pub const BIOCSETF: ::c_ulong = 0x80084267;\n+pub const BIOCSRTIMEOUT: ::c_ulong = 0x8008426d;\n+pub const BIOCGRTIMEOUT: ::c_ulong = 0x4008426e;\n+pub const BIOCSETFNR: ::c_ulong = 0x8008427e;\n+\n+extern \"C\" {\n+    pub fn exchangedata(\n+        path1: *const ::c_char,\n+        path2: *const ::c_char,\n+        options: ::c_ulong,\n+    ) -> ::c_int;\n+}\n+\n+cfg_if! {\n+    if #[cfg(libc_align)] {\n+        mod align;\n+        pub use self::align::*;\n+    }\n+}"
      },
      {
        "sha": "ca1fe1ce299442531bef79be18ad7caada5b2503",
        "filename": "src/rusty/libc/src/unix/bsd/apple/b64/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/apple/b64/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/apple/b64/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/apple/b64/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,7 @@\n+s_no_extra_traits! {\n+    #[allow(missing_debug_implementations)]\n+    #[repr(align(16))]\n+    pub struct max_align_t {\n+        priv_: [f64; 2]\n+    }\n+}"
      },
      {
        "sha": "7f7008387b81dcb6cfb53afb850ef72b3ba42e43",
        "filename": "src/rusty/libc/src/unix/bsd/apple/b64/mod.rs",
        "status": "added",
        "additions": 120,
        "deletions": 0,
        "changes": 120,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/apple/b64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/apple/b64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/apple/b64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,120 @@\n+//! 64-bit specific Apple (ios/darwin) definitions\n+\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type boolean_t = ::c_uint;\n+\n+s! {\n+    pub struct timeval32 {\n+        pub tv_sec: i32,\n+        pub tv_usec: i32,\n+    }\n+\n+    pub struct if_data {\n+        pub ifi_type: ::c_uchar,\n+        pub ifi_typelen: ::c_uchar,\n+        pub ifi_physical: ::c_uchar,\n+        pub ifi_addrlen: ::c_uchar,\n+        pub ifi_hdrlen: ::c_uchar,\n+        pub ifi_recvquota: ::c_uchar,\n+        pub ifi_xmitquota: ::c_uchar,\n+        pub ifi_unused1: ::c_uchar,\n+        pub ifi_mtu: u32,\n+        pub ifi_metric: u32,\n+        pub ifi_baudrate: u32,\n+        pub ifi_ipackets: u32,\n+        pub ifi_ierrors: u32,\n+        pub ifi_opackets: u32,\n+        pub ifi_oerrors: u32,\n+        pub ifi_collisions: u32,\n+        pub ifi_ibytes: u32,\n+        pub ifi_obytes: u32,\n+        pub ifi_imcasts: u32,\n+        pub ifi_omcasts: u32,\n+        pub ifi_iqdrops: u32,\n+        pub ifi_noproto: u32,\n+        pub ifi_recvtiming: u32,\n+        pub ifi_xmittiming: u32,\n+        pub ifi_lastchange: timeval32,\n+        pub ifi_unused2: u32,\n+        pub ifi_hwassist: u32,\n+        pub ifi_reserved1: u32,\n+        pub ifi_reserved2: u32,\n+    }\n+\n+    pub struct bpf_hdr {\n+        pub bh_tstamp: ::timeval32,\n+        pub bh_caplen: u32,\n+        pub bh_datalen: u32,\n+        pub bh_hdrlen: ::c_ushort,\n+    }\n+}\n+\n+s_no_extra_traits! {\n+    pub struct pthread_attr_t {\n+        __sig: c_long,\n+        __opaque: [::c_char; 56]\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(feature = \"extra_traits\")] {\n+        impl PartialEq for pthread_attr_t {\n+            fn eq(&self, other: &pthread_attr_t) -> bool {\n+                self.__sig == other.__sig\n+                    && self.__opaque\n+                    .iter()\n+                    .zip(other.__opaque.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for pthread_attr_t {}\n+        impl ::fmt::Debug for pthread_attr_t {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"pthread_attr_t\")\n+                    .field(\"__sig\", &self.__sig)\n+                // FIXME: .field(\"__opaque\", &self.__opaque)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for pthread_attr_t {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.__sig.hash(state);\n+                self.__opaque.hash(state);\n+            }\n+        }\n+    }\n+}\n+\n+#[doc(hidden)]\n+#[deprecated(since = \"0.2.55\")]\n+pub const NET_RT_MAXID: ::c_int = 11;\n+\n+pub const __PTHREAD_MUTEX_SIZE__: usize = 56;\n+pub const __PTHREAD_COND_SIZE__: usize = 40;\n+pub const __PTHREAD_CONDATTR_SIZE__: usize = 8;\n+pub const __PTHREAD_RWLOCK_SIZE__: usize = 192;\n+pub const __PTHREAD_RWLOCKATTR_SIZE__: usize = 16;\n+\n+pub const TIOCTIMESTAMP: ::c_ulong = 0x40107459;\n+pub const TIOCDCDTIMESTAMP: ::c_ulong = 0x40107458;\n+\n+pub const BIOCSETF: ::c_ulong = 0x80104267;\n+pub const BIOCSRTIMEOUT: ::c_ulong = 0x8010426d;\n+pub const BIOCGRTIMEOUT: ::c_ulong = 0x4010426e;\n+pub const BIOCSETFNR: ::c_ulong = 0x8010427e;\n+\n+extern \"C\" {\n+    pub fn exchangedata(\n+        path1: *const ::c_char,\n+        path2: *const ::c_char,\n+        options: ::c_uint,\n+    ) -> ::c_int;\n+}\n+\n+cfg_if! {\n+    if #[cfg(libc_align)] {\n+        mod align;\n+        pub use self::align::*;\n+    }\n+}"
      },
      {
        "sha": "fa3ba81b0bd9f121ad5dd2b9cdd018d98e05acac",
        "filename": "src/rusty/libc/src/unix/bsd/apple/mod.rs",
        "status": "added",
        "additions": 3538,
        "deletions": 0,
        "changes": 3538,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/apple/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/apple/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/apple/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "e9ad63b86bb2d15eb96e0816de892834e4bd1487",
        "filename": "src/rusty/libc/src/unix/bsd/freebsdlike/dragonfly/errno.rs",
        "status": "added",
        "additions": 12,
        "deletions": 0,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/dragonfly/errno.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/dragonfly/errno.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/freebsdlike/dragonfly/errno.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,12 @@\n+// DragonFlyBSD's __error function is declared with \"static inline\", so it must\n+// be implemented in the libc crate, as a pointer to a static thread_local.\n+f! {\n+    pub fn __error() -> *mut ::c_int {\n+        &mut errno\n+    }\n+}\n+\n+extern \"C\" {\n+    #[thread_local]\n+    pub static mut errno: ::c_int;\n+}"
      },
      {
        "sha": "63ca4db082b34aa498ef8d41d330c4c4fbd35f0b",
        "filename": "src/rusty/libc/src/unix/bsd/freebsdlike/dragonfly/mod.rs",
        "status": "added",
        "additions": 1096,
        "deletions": 0,
        "changes": 1096,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/dragonfly/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/dragonfly/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/freebsdlike/dragonfly/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,1096 @@\n+pub type dev_t = u32;\n+pub type c_char = i8;\n+pub type clock_t = u64;\n+pub type ino_t = u64;\n+pub type lwpid_t = i32;\n+pub type nlink_t = u32;\n+pub type blksize_t = i64;\n+pub type clockid_t = ::c_ulong;\n+\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type time_t = i64;\n+pub type suseconds_t = i64;\n+\n+pub type uuid_t = ::uuid;\n+\n+pub type fsblkcnt_t = u64;\n+pub type fsfilcnt_t = u64;\n+\n+pub type mqd_t = ::c_int;\n+pub type sem_t = *mut sem;\n+\n+#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\n+pub enum sem {}\n+impl ::Copy for sem {}\n+impl ::Clone for sem {\n+    fn clone(&self) -> sem {\n+        *self\n+    }\n+}\n+\n+s! {\n+    pub struct kevent {\n+        pub ident: ::uintptr_t,\n+        pub filter: ::c_short,\n+        pub flags: ::c_ushort,\n+        pub fflags: ::c_uint,\n+        pub data: ::intptr_t,\n+        pub udata: *mut ::c_void,\n+    }\n+\n+    pub struct exit_status {\n+        pub e_termination: u16,\n+        pub e_exit: u16\n+    }\n+\n+    pub struct aiocb {\n+        pub aio_fildes: ::c_int,\n+        pub aio_offset: ::off_t,\n+        pub aio_buf: *mut ::c_void,\n+        pub aio_nbytes: ::size_t,\n+        pub aio_sigevent: sigevent,\n+        pub aio_lio_opcode: ::c_int,\n+        pub aio_reqprio: ::c_int,\n+        _aio_val: ::c_int,\n+        _aio_err: ::c_int\n+    }\n+\n+    pub struct uuid {\n+        pub time_low: u32,\n+        pub time_mid: u16,\n+        pub time_hi_and_version: u16,\n+        pub clock_seq_hi_and_reserved: u8,\n+        pub clock_seq_low: u8,\n+        pub node: [u8; 6],\n+    }\n+\n+    pub struct mq_attr {\n+        pub mq_flags: ::c_long,\n+        pub mq_maxmsg: ::c_long,\n+        pub mq_msgsize: ::c_long,\n+        pub mq_curmsgs: ::c_long,\n+    }\n+\n+    pub struct statvfs {\n+        pub f_bsize: ::c_ulong,\n+        pub f_frsize: ::c_ulong,\n+        pub f_blocks: ::fsblkcnt_t,\n+        pub f_bfree: ::fsblkcnt_t,\n+        pub f_bavail: ::fsblkcnt_t,\n+        pub f_files: ::fsfilcnt_t,\n+        pub f_ffree: ::fsfilcnt_t,\n+        pub f_favail: ::fsfilcnt_t,\n+        pub f_fsid: ::c_ulong,\n+        pub f_flag: ::c_ulong,\n+        pub f_namemax: ::c_ulong,\n+        pub f_owner: ::uid_t,\n+        pub f_type: ::c_uint,\n+        pub f_syncreads: u64,\n+        pub f_syncwrites: u64,\n+        pub f_asyncreads: u64,\n+        pub f_asyncwrites: u64,\n+        pub f_fsid_uuid: ::uuid_t,\n+        pub f_uid_uuid: ::uuid_t,\n+    }\n+\n+    pub struct stat {\n+        pub st_ino: ::ino_t,\n+        pub st_nlink: ::nlink_t,\n+        pub st_dev: ::dev_t,\n+        pub st_mode: ::mode_t,\n+        pub st_padding1: u16,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        pub st_rdev: ::dev_t,\n+        pub st_atime: ::time_t,\n+        pub st_atime_nsec: ::c_long,\n+        pub st_mtime: ::time_t,\n+        pub st_mtime_nsec: ::c_long,\n+        pub st_ctime: ::time_t,\n+        pub st_ctime_nsec: ::c_long,\n+        pub st_size: ::off_t,\n+        pub st_blocks: i64,\n+        pub st_blksize: u32,\n+        pub st_flags: u32,\n+        pub st_gen: u32,\n+        pub st_lspare: i32,\n+        pub st_qspare1: i64,\n+        pub st_qspare2: i64,\n+    }\n+\n+    pub struct if_data {\n+        pub ifi_type: ::c_uchar,\n+        pub ifi_physical: ::c_uchar,\n+        pub ifi_addrlen: ::c_uchar,\n+        pub ifi_hdrlen: ::c_uchar,\n+        pub ifi_recvquota: ::c_uchar,\n+        pub ifi_xmitquota: ::c_uchar,\n+        pub ifi_mtu: ::c_ulong,\n+        pub ifi_metric: ::c_ulong,\n+        pub ifi_link_state: ::c_ulong,\n+        pub ifi_baudrate: u64,\n+        pub ifi_ipackets: ::c_ulong,\n+        pub ifi_ierrors: ::c_ulong,\n+        pub ifi_opackets: ::c_ulong,\n+        pub ifi_oerrors: ::c_ulong,\n+        pub ifi_collisions: ::c_ulong,\n+        pub ifi_ibytes: ::c_ulong,\n+        pub ifi_obytes: ::c_ulong,\n+        pub ifi_imcasts: ::c_ulong,\n+        pub ifi_omcasts: ::c_ulong,\n+        pub ifi_iqdrops: ::c_ulong,\n+        pub ifi_noproto: ::c_ulong,\n+        pub ifi_hwassist: ::c_ulong,\n+        pub ifi_oqdrops: ::c_ulong,\n+        pub ifi_lastchange: ::timeval,\n+    }\n+\n+    pub struct if_msghdr {\n+        pub ifm_msglen: ::c_ushort,\n+        pub ifm_version: ::c_uchar,\n+        pub ifm_type: ::c_uchar,\n+        pub ifm_addrs: ::c_int,\n+        pub ifm_flags: ::c_int,\n+        pub ifm_index: ::c_ushort,\n+        pub ifm_data: if_data,\n+    }\n+\n+    pub struct sockaddr_dl {\n+        pub sdl_len: ::c_uchar,\n+        pub sdl_family: ::c_uchar,\n+        pub sdl_index: ::c_ushort,\n+        pub sdl_type: ::c_uchar,\n+        pub sdl_nlen: ::c_uchar,\n+        pub sdl_alen: ::c_uchar,\n+        pub sdl_slen: ::c_uchar,\n+        pub sdl_data: [::c_char; 12],\n+        pub sdl_rcf: ::c_ushort,\n+        pub sdl_route: [::c_ushort; 16],\n+    }\n+\n+    pub struct stack_t {\n+        pub ss_sp: *mut ::c_char,\n+        pub ss_size: ::size_t,\n+        pub ss_flags: ::c_int,\n+    }\n+}\n+\n+s_no_extra_traits! {\n+    pub struct utmpx {\n+        pub ut_name: [::c_char; 32],\n+        pub ut_id: [::c_char; 4],\n+\n+        pub ut_line: [::c_char; 32],\n+        pub ut_host: [::c_char; 256],\n+\n+        pub ut_unused: [u8; 16],\n+        pub ut_session: u16,\n+        pub ut_type: u16,\n+        pub ut_pid: ::pid_t,\n+        ut_exit: exit_status,\n+        ut_ss: ::sockaddr_storage,\n+        pub ut_tv: ::timeval,\n+        pub ut_unused2: [u8; 16],\n+    }\n+\n+    pub struct dirent {\n+        pub d_fileno: ::ino_t,\n+        pub d_namlen: u16,\n+        pub d_type: u8,\n+        __unused1: u8,\n+        __unused2: u32,\n+        pub d_name: [::c_char; 256],\n+    }\n+\n+    pub struct statfs {\n+        pub f_bsize: ::c_long,\n+        pub f_iosize: ::c_long,\n+        pub f_blocks: ::c_long,\n+        pub f_bfree: ::c_long,\n+        pub f_bavail: ::c_long,\n+        pub f_files: ::c_long,\n+        pub f_ffree: ::c_long,\n+        pub f_fsid: ::fsid_t,\n+        pub f_owner: ::uid_t,\n+        pub f_type: i32,\n+        pub f_flags: i32,\n+        pub f_syncwrites: ::c_long,\n+        pub f_asyncwrites: ::c_long,\n+        pub f_fstypename: [::c_char; 16],\n+        pub f_mntonname: [::c_char; 90],\n+        pub f_syncreads: ::c_long,\n+        pub f_asyncreads: ::c_long,\n+        pub f_mntfromname: [::c_char; 90],\n+    }\n+\n+    pub struct sigevent {\n+        pub sigev_notify: ::c_int,\n+        // The union is 8-byte in size, so it is aligned at a 8-byte offset.\n+        #[cfg(target_pointer_width = \"64\")]\n+        __unused1: ::c_int,\n+        pub sigev_signo: ::c_int,       //actually a union\n+        // pad the union\n+        #[cfg(target_pointer_width = \"64\")]\n+        __unused2: ::c_int,\n+        pub sigev_value: ::sigval,\n+        __unused3: *mut ::c_void        //actually a function pointer\n+    }\n+\n+}\n+\n+cfg_if! {\n+    if #[cfg(feature = \"extra_traits\")] {\n+        impl PartialEq for utmpx {\n+            fn eq(&self, other: &utmpx) -> bool {\n+                self.ut_name == other.ut_name\n+                    && self.ut_id == other.ut_id\n+                    && self.ut_line == other.ut_line\n+                    && self\n+                    .ut_host\n+                    .iter()\n+                    .zip(other.ut_host.iter())\n+                    .all(|(a,b)| a == b)\n+                    && self.ut_unused == other.ut_unused\n+                    && self.ut_session == other.ut_session\n+                    && self.ut_type == other.ut_type\n+                    && self.ut_pid == other.ut_pid\n+                    && self.ut_exit == other.ut_exit\n+                    && self.ut_ss == other.ut_ss\n+                    && self.ut_tv == other.ut_tv\n+                    && self.ut_unused2 == other.ut_unused2\n+            }\n+        }\n+        impl Eq for utmpx {}\n+        impl ::fmt::Debug for utmpx {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"utmpx\")\n+                    .field(\"ut_name\", &self.ut_name)\n+                    .field(\"ut_id\", &self.ut_id)\n+                    .field(\"ut_line\", &self.ut_line)\n+                    // FIXME: .field(\"ut_host\", &self.ut_host)\n+                    .field(\"ut_unused\", &self.ut_unused)\n+                    .field(\"ut_session\", &self.ut_session)\n+                    .field(\"ut_type\", &self.ut_type)\n+                    .field(\"ut_pid\", &self.ut_pid)\n+                    .field(\"ut_exit\", &self.ut_exit)\n+                    .field(\"ut_ss\", &self.ut_ss)\n+                    .field(\"ut_tv\", &self.ut_tv)\n+                    .field(\"ut_unused2\", &self.ut_unused2)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for utmpx {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.ut_name.hash(state);\n+                self.ut_id.hash(state);\n+                self.ut_line.hash(state);\n+                self.ut_host.hash(state);\n+                self.ut_unused.hash(state);\n+                self.ut_session.hash(state);\n+                self.ut_type.hash(state);\n+                self.ut_pid.hash(state);\n+                self.ut_exit.hash(state);\n+                self.ut_ss.hash(state);\n+                self.ut_tv.hash(state);\n+                self.ut_unused2.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for dirent {\n+            fn eq(&self, other: &dirent) -> bool {\n+                self.d_fileno == other.d_fileno\n+                    && self.d_namlen == other.d_namlen\n+                    && self.d_type == other.d_type\n+                    // Ignore __unused1\n+                    // Ignore __unused2\n+                    && self\n+                    .d_name\n+                    .iter()\n+                    .zip(other.d_name.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for dirent {}\n+        impl ::fmt::Debug for dirent {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"dirent\")\n+                    .field(\"d_fileno\", &self.d_fileno)\n+                    .field(\"d_namlen\", &self.d_namlen)\n+                    .field(\"d_type\", &self.d_type)\n+                    // Ignore __unused1\n+                    // Ignore __unused2\n+                    // FIXME: .field(\"d_name\", &self.d_name)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for dirent {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.d_fileno.hash(state);\n+                self.d_namlen.hash(state);\n+                self.d_type.hash(state);\n+                    // Ignore __unused1\n+                    // Ignore __unused2\n+                self.d_name.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for statfs {\n+            fn eq(&self, other: &statfs) -> bool {\n+                self.f_bsize == other.f_bsize\n+                    && self.f_iosize == other.f_iosize\n+                    && self.f_blocks == other.f_blocks\n+                    && self.f_bfree == other.f_bfree\n+                    && self.f_bavail == other.f_bavail\n+                    && self.f_files == other.f_files\n+                    && self.f_ffree == other.f_ffree\n+                    && self.f_fsid == other.f_fsid\n+                    && self.f_owner == other.f_owner\n+                    && self.f_type == other.f_type\n+                    && self.f_flags == other.f_flags\n+                    && self.f_syncwrites == other.f_syncwrites\n+                    && self.f_asyncwrites == other.f_asyncwrites\n+                    && self.f_fstypename == other.f_fstypename\n+                    && self\n+                    .f_mntonname\n+                    .iter()\n+                    .zip(other.f_mntonname.iter())\n+                    .all(|(a,b)| a == b)\n+                    && self.f_syncreads == other.f_syncreads\n+                    && self.f_asyncreads == other.f_asyncreads\n+                    && self\n+                    .f_mntfromname\n+                    .iter()\n+                    .zip(other.f_mntfromname.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for statfs {}\n+        impl ::fmt::Debug for statfs {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"statfs\")\n+                    .field(\"f_bsize\", &self.f_bsize)\n+                    .field(\"f_iosize\", &self.f_iosize)\n+                    .field(\"f_blocks\", &self.f_blocks)\n+                    .field(\"f_bfree\", &self.f_bfree)\n+                    .field(\"f_bavail\", &self.f_bavail)\n+                    .field(\"f_files\", &self.f_files)\n+                    .field(\"f_ffree\", &self.f_ffree)\n+                    .field(\"f_fsid\", &self.f_fsid)\n+                    .field(\"f_owner\", &self.f_owner)\n+                    .field(\"f_type\", &self.f_type)\n+                    .field(\"f_flags\", &self.f_flags)\n+                    .field(\"f_syncwrites\", &self.f_syncwrites)\n+                    .field(\"f_asyncwrites\", &self.f_asyncwrites)\n+                    // FIXME: .field(\"f_mntonname\", &self.f_mntonname)\n+                    .field(\"f_syncreads\", &self.f_syncreads)\n+                    .field(\"f_asyncreads\", &self.f_asyncreads)\n+                    // FIXME: .field(\"f_mntfromname\", &self.f_mntfromname)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for statfs {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.f_bsize.hash(state);\n+                self.f_iosize.hash(state);\n+                self.f_blocks.hash(state);\n+                self.f_bfree.hash(state);\n+                self.f_bavail.hash(state);\n+                self.f_files.hash(state);\n+                self.f_ffree.hash(state);\n+                self.f_fsid.hash(state);\n+                self.f_owner.hash(state);\n+                self.f_type.hash(state);\n+                self.f_flags.hash(state);\n+                self.f_syncwrites.hash(state);\n+                self.f_asyncwrites.hash(state);\n+                self.f_fstypename.hash(state);\n+                self.f_mntonname.hash(state);\n+                self.f_syncreads.hash(state);\n+                self.f_asyncreads.hash(state);\n+                self.f_mntfromname.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for sigevent {\n+            fn eq(&self, other: &sigevent) -> bool {\n+                self.sigev_notify == other.sigev_notify\n+                    && self.sigev_signo == other.sigev_signo\n+                    && self.sigev_value == other.sigev_value\n+            }\n+        }\n+        impl Eq for sigevent {}\n+        impl ::fmt::Debug for sigevent {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"sigevent\")\n+                    .field(\"sigev_notify\", &self.sigev_notify)\n+                    .field(\"sigev_signo\", &self.sigev_signo)\n+                    .field(\"sigev_value\", &self.sigev_value)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for sigevent {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.sigev_notify.hash(state);\n+                self.sigev_signo.hash(state);\n+                self.sigev_value.hash(state);\n+            }\n+        }\n+    }\n+}\n+\n+pub const RAND_MAX: ::c_int = 0x7fff_ffff;\n+pub const PTHREAD_STACK_MIN: ::size_t = 16384;\n+pub const SIGSTKSZ: ::size_t = 40960;\n+pub const MADV_INVAL: ::c_int = 10;\n+pub const MADV_SETMAP: ::c_int = 11;\n+pub const O_CLOEXEC: ::c_int = 0x00020000;\n+pub const O_DIRECTORY: ::c_int = 0x08000000;\n+pub const F_GETLK: ::c_int = 7;\n+pub const F_SETLK: ::c_int = 8;\n+pub const F_SETLKW: ::c_int = 9;\n+pub const ENOMEDIUM: ::c_int = 93;\n+pub const EASYNC: ::c_int = 99;\n+pub const ELAST: ::c_int = 99;\n+pub const RLIMIT_POSIXLOCKS: ::c_int = 11;\n+#[deprecated(since = \"0.2.64\", note = \"Not stable across OS versions\")]\n+pub const RLIM_NLIMITS: ::rlim_t = 12;\n+\n+pub const Q_GETQUOTA: ::c_int = 0x300;\n+pub const Q_SETQUOTA: ::c_int = 0x400;\n+\n+pub const CLOCK_REALTIME: ::clockid_t = 0;\n+pub const CLOCK_VIRTUAL: ::clockid_t = 1;\n+pub const CLOCK_PROF: ::clockid_t = 2;\n+pub const CLOCK_MONOTONIC: ::clockid_t = 4;\n+pub const CLOCK_UPTIME: ::clockid_t = 5;\n+pub const CLOCK_UPTIME_PRECISE: ::clockid_t = 7;\n+pub const CLOCK_UPTIME_FAST: ::clockid_t = 8;\n+pub const CLOCK_REALTIME_PRECISE: ::clockid_t = 9;\n+pub const CLOCK_REALTIME_FAST: ::clockid_t = 10;\n+pub const CLOCK_MONOTONIC_PRECISE: ::clockid_t = 11;\n+pub const CLOCK_MONOTONIC_FAST: ::clockid_t = 12;\n+pub const CLOCK_SECOND: ::clockid_t = 13;\n+pub const CLOCK_THREAD_CPUTIME_ID: ::clockid_t = 14;\n+pub const CLOCK_PROCESS_CPUTIME_ID: ::clockid_t = 15;\n+\n+pub const CTL_UNSPEC: ::c_int = 0;\n+pub const CTL_KERN: ::c_int = 1;\n+pub const CTL_VM: ::c_int = 2;\n+pub const CTL_VFS: ::c_int = 3;\n+pub const CTL_NET: ::c_int = 4;\n+pub const CTL_DEBUG: ::c_int = 5;\n+pub const CTL_HW: ::c_int = 6;\n+pub const CTL_MACHDEP: ::c_int = 7;\n+pub const CTL_USER: ::c_int = 8;\n+pub const CTL_P1003_1B: ::c_int = 9;\n+pub const CTL_LWKT: ::c_int = 10;\n+pub const CTL_MAXID: ::c_int = 11;\n+pub const KERN_OSTYPE: ::c_int = 1;\n+pub const KERN_OSRELEASE: ::c_int = 2;\n+pub const KERN_OSREV: ::c_int = 3;\n+pub const KERN_VERSION: ::c_int = 4;\n+pub const KERN_MAXVNODES: ::c_int = 5;\n+pub const KERN_MAXPROC: ::c_int = 6;\n+pub const KERN_MAXFILES: ::c_int = 7;\n+pub const KERN_ARGMAX: ::c_int = 8;\n+pub const KERN_SECURELVL: ::c_int = 9;\n+pub const KERN_HOSTNAME: ::c_int = 10;\n+pub const KERN_HOSTID: ::c_int = 11;\n+pub const KERN_CLOCKRATE: ::c_int = 12;\n+pub const KERN_VNODE: ::c_int = 13;\n+pub const KERN_PROC: ::c_int = 14;\n+pub const KERN_FILE: ::c_int = 15;\n+pub const KERN_PROF: ::c_int = 16;\n+pub const KERN_POSIX1: ::c_int = 17;\n+pub const KERN_NGROUPS: ::c_int = 18;\n+pub const KERN_JOB_CONTROL: ::c_int = 19;\n+pub const KERN_SAVED_IDS: ::c_int = 20;\n+pub const KERN_BOOTTIME: ::c_int = 21;\n+pub const KERN_NISDOMAINNAME: ::c_int = 22;\n+pub const KERN_UPDATEINTERVAL: ::c_int = 23;\n+pub const KERN_OSRELDATE: ::c_int = 24;\n+pub const KERN_NTP_PLL: ::c_int = 25;\n+pub const KERN_BOOTFILE: ::c_int = 26;\n+pub const KERN_MAXFILESPERPROC: ::c_int = 27;\n+pub const KERN_MAXPROCPERUID: ::c_int = 28;\n+pub const KERN_DUMPDEV: ::c_int = 29;\n+pub const KERN_IPC: ::c_int = 30;\n+pub const KERN_DUMMY: ::c_int = 31;\n+pub const KERN_PS_STRINGS: ::c_int = 32;\n+pub const KERN_USRSTACK: ::c_int = 33;\n+pub const KERN_LOGSIGEXIT: ::c_int = 34;\n+pub const KERN_IOV_MAX: ::c_int = 35;\n+pub const KERN_MAXPOSIXLOCKSPERUID: ::c_int = 36;\n+pub const KERN_MAXID: ::c_int = 37;\n+pub const KERN_PROC_ALL: ::c_int = 0;\n+pub const KERN_PROC_PID: ::c_int = 1;\n+pub const KERN_PROC_PGRP: ::c_int = 2;\n+pub const KERN_PROC_SESSION: ::c_int = 3;\n+pub const KERN_PROC_TTY: ::c_int = 4;\n+pub const KERN_PROC_UID: ::c_int = 5;\n+pub const KERN_PROC_RUID: ::c_int = 6;\n+pub const KERN_PROC_ARGS: ::c_int = 7;\n+pub const KERN_PROC_CWD: ::c_int = 8;\n+pub const KERN_PROC_PATHNAME: ::c_int = 9;\n+pub const KERN_PROC_FLAGMASK: ::c_int = 0x10;\n+pub const KERN_PROC_FLAG_LWP: ::c_int = 0x10;\n+pub const KIPC_MAXSOCKBUF: ::c_int = 1;\n+pub const KIPC_SOCKBUF_WASTE: ::c_int = 2;\n+pub const KIPC_SOMAXCONN: ::c_int = 3;\n+pub const KIPC_MAX_LINKHDR: ::c_int = 4;\n+pub const KIPC_MAX_PROTOHDR: ::c_int = 5;\n+pub const KIPC_MAX_HDR: ::c_int = 6;\n+pub const KIPC_MAX_DATALEN: ::c_int = 7;\n+pub const KIPC_MBSTAT: ::c_int = 8;\n+pub const KIPC_NMBCLUSTERS: ::c_int = 9;\n+pub const HW_MACHINE: ::c_int = 1;\n+pub const HW_MODEL: ::c_int = 2;\n+pub const HW_NCPU: ::c_int = 3;\n+pub const HW_BYTEORDER: ::c_int = 4;\n+pub const HW_PHYSMEM: ::c_int = 5;\n+pub const HW_USERMEM: ::c_int = 6;\n+pub const HW_PAGESIZE: ::c_int = 7;\n+pub const HW_DISKNAMES: ::c_int = 8;\n+pub const HW_DISKSTATS: ::c_int = 9;\n+pub const HW_FLOATINGPT: ::c_int = 10;\n+pub const HW_MACHINE_ARCH: ::c_int = 11;\n+pub const HW_MACHINE_PLATFORM: ::c_int = 12;\n+pub const HW_SENSORS: ::c_int = 13;\n+pub const HW_MAXID: ::c_int = 14;\n+pub const USER_CS_PATH: ::c_int = 1;\n+pub const USER_BC_BASE_MAX: ::c_int = 2;\n+pub const USER_BC_DIM_MAX: ::c_int = 3;\n+pub const USER_BC_SCALE_MAX: ::c_int = 4;\n+pub const USER_BC_STRING_MAX: ::c_int = 5;\n+pub const USER_COLL_WEIGHTS_MAX: ::c_int = 6;\n+pub const USER_EXPR_NEST_MAX: ::c_int = 7;\n+pub const USER_LINE_MAX: ::c_int = 8;\n+pub const USER_RE_DUP_MAX: ::c_int = 9;\n+pub const USER_POSIX2_VERSION: ::c_int = 10;\n+pub const USER_POSIX2_C_BIND: ::c_int = 11;\n+pub const USER_POSIX2_C_DEV: ::c_int = 12;\n+pub const USER_POSIX2_CHAR_TERM: ::c_int = 13;\n+pub const USER_POSIX2_FORT_DEV: ::c_int = 14;\n+pub const USER_POSIX2_FORT_RUN: ::c_int = 15;\n+pub const USER_POSIX2_LOCALEDEF: ::c_int = 16;\n+pub const USER_POSIX2_SW_DEV: ::c_int = 17;\n+pub const USER_POSIX2_UPE: ::c_int = 18;\n+pub const USER_STREAM_MAX: ::c_int = 19;\n+pub const USER_TZNAME_MAX: ::c_int = 20;\n+pub const USER_MAXID: ::c_int = 21;\n+pub const CTL_P1003_1B_ASYNCHRONOUS_IO: ::c_int = 1;\n+pub const CTL_P1003_1B_MAPPED_FILES: ::c_int = 2;\n+pub const CTL_P1003_1B_MEMLOCK: ::c_int = 3;\n+pub const CTL_P1003_1B_MEMLOCK_RANGE: ::c_int = 4;\n+pub const CTL_P1003_1B_MEMORY_PROTECTION: ::c_int = 5;\n+pub const CTL_P1003_1B_MESSAGE_PASSING: ::c_int = 6;\n+pub const CTL_P1003_1B_PRIORITIZED_IO: ::c_int = 7;\n+pub const CTL_P1003_1B_PRIORITY_SCHEDULING: ::c_int = 8;\n+pub const CTL_P1003_1B_REALTIME_SIGNALS: ::c_int = 9;\n+pub const CTL_P1003_1B_SEMAPHORES: ::c_int = 10;\n+pub const CTL_P1003_1B_FSYNC: ::c_int = 11;\n+pub const CTL_P1003_1B_SHARED_MEMORY_OBJECTS: ::c_int = 12;\n+pub const CTL_P1003_1B_SYNCHRONIZED_IO: ::c_int = 13;\n+pub const CTL_P1003_1B_TIMERS: ::c_int = 14;\n+pub const CTL_P1003_1B_AIO_LISTIO_MAX: ::c_int = 15;\n+pub const CTL_P1003_1B_AIO_MAX: ::c_int = 16;\n+pub const CTL_P1003_1B_AIO_PRIO_DELTA_MAX: ::c_int = 17;\n+pub const CTL_P1003_1B_DELAYTIMER_MAX: ::c_int = 18;\n+pub const CTL_P1003_1B_UNUSED1: ::c_int = 19;\n+pub const CTL_P1003_1B_PAGESIZE: ::c_int = 20;\n+pub const CTL_P1003_1B_RTSIG_MAX: ::c_int = 21;\n+pub const CTL_P1003_1B_SEM_NSEMS_MAX: ::c_int = 22;\n+pub const CTL_P1003_1B_SEM_VALUE_MAX: ::c_int = 23;\n+pub const CTL_P1003_1B_SIGQUEUE_MAX: ::c_int = 24;\n+pub const CTL_P1003_1B_TIMER_MAX: ::c_int = 25;\n+pub const CTL_P1003_1B_MAXID: ::c_int = 26;\n+\n+pub const EVFILT_READ: i16 = -1;\n+pub const EVFILT_WRITE: i16 = -2;\n+pub const EVFILT_AIO: i16 = -3;\n+pub const EVFILT_VNODE: i16 = -4;\n+pub const EVFILT_PROC: i16 = -5;\n+pub const EVFILT_SIGNAL: i16 = -6;\n+pub const EVFILT_TIMER: i16 = -7;\n+pub const EVFILT_EXCEPT: i16 = -8;\n+pub const EVFILT_USER: i16 = -9;\n+pub const EVFILT_FS: i16 = -10;\n+\n+pub const EV_ADD: u16 = 0x1;\n+pub const EV_DELETE: u16 = 0x2;\n+pub const EV_ENABLE: u16 = 0x4;\n+pub const EV_DISABLE: u16 = 0x8;\n+pub const EV_ONESHOT: u16 = 0x10;\n+pub const EV_CLEAR: u16 = 0x20;\n+pub const EV_RECEIPT: u16 = 0x40;\n+pub const EV_DISPATCH: u16 = 0x80;\n+pub const EV_NODATA: u16 = 0x1000;\n+pub const EV_FLAG1: u16 = 0x2000;\n+pub const EV_ERROR: u16 = 0x4000;\n+pub const EV_EOF: u16 = 0x8000;\n+pub const EV_SYSFLAGS: u16 = 0xf000;\n+\n+pub const NOTE_TRIGGER: u32 = 0x01000000;\n+pub const NOTE_FFNOP: u32 = 0x00000000;\n+pub const NOTE_FFAND: u32 = 0x40000000;\n+pub const NOTE_FFOR: u32 = 0x80000000;\n+pub const NOTE_FFCOPY: u32 = 0xc0000000;\n+pub const NOTE_FFCTRLMASK: u32 = 0xc0000000;\n+pub const NOTE_FFLAGSMASK: u32 = 0x00ffffff;\n+pub const NOTE_LOWAT: u32 = 0x00000001;\n+pub const NOTE_OOB: u32 = 0x00000002;\n+pub const NOTE_DELETE: u32 = 0x00000001;\n+pub const NOTE_WRITE: u32 = 0x00000002;\n+pub const NOTE_EXTEND: u32 = 0x00000004;\n+pub const NOTE_ATTRIB: u32 = 0x00000008;\n+pub const NOTE_LINK: u32 = 0x00000010;\n+pub const NOTE_RENAME: u32 = 0x00000020;\n+pub const NOTE_REVOKE: u32 = 0x00000040;\n+pub const NOTE_EXIT: u32 = 0x80000000;\n+pub const NOTE_FORK: u32 = 0x40000000;\n+pub const NOTE_EXEC: u32 = 0x20000000;\n+pub const NOTE_PDATAMASK: u32 = 0x000fffff;\n+pub const NOTE_PCTRLMASK: u32 = 0xf0000000;\n+pub const NOTE_TRACK: u32 = 0x00000001;\n+pub const NOTE_TRACKERR: u32 = 0x00000002;\n+pub const NOTE_CHILD: u32 = 0x00000004;\n+\n+pub const SO_SNDSPACE: ::c_int = 0x100a;\n+pub const SO_CPUHINT: ::c_int = 0x1030;\n+\n+pub const PT_FIRSTMACH: ::c_int = 32;\n+\n+// https://github.com/DragonFlyBSD/DragonFlyBSD/blob/master/sys/net/if.h#L101\n+pub const IFF_UP: ::c_int = 0x1; // interface is up\n+pub const IFF_BROADCAST: ::c_int = 0x2; // broadcast address valid\n+pub const IFF_DEBUG: ::c_int = 0x4; // turn on debugging\n+pub const IFF_LOOPBACK: ::c_int = 0x8; // is a loopback net\n+pub const IFF_POINTOPOINT: ::c_int = 0x10; // interface is point-to-point link\n+pub const IFF_SMART: ::c_int = 0x20; // interface manages own routes\n+pub const IFF_RUNNING: ::c_int = 0x40; // resources allocated\n+pub const IFF_NOARP: ::c_int = 0x80; // no address resolution protocol\n+pub const IFF_PROMISC: ::c_int = 0x100; // receive all packets\n+pub const IFF_ALLMULTI: ::c_int = 0x200; // receive all multicast packets\n+pub const IFF_OACTIVE_COMPAT: ::c_int = 0x400; // was transmission in progress\n+pub const IFF_SIMPLEX: ::c_int = 0x800; // can't hear own transmissions\n+pub const IFF_LINK0: ::c_int = 0x1000; // per link layer defined bit\n+pub const IFF_LINK1: ::c_int = 0x2000; // per link layer defined bit\n+pub const IFF_LINK2: ::c_int = 0x4000; // per link layer defined bit\n+pub const IFF_ALTPHYS: ::c_int = IFF_LINK2; // use alternate physical connection\n+pub const IFF_MULTICAST: ::c_int = 0x8000; // supports multicast\n+                                           // was interface is in polling mode\n+pub const IFF_POLLING_COMPAT: ::c_int = 0x10000;\n+pub const IFF_PPROMISC: ::c_int = 0x20000; // user-requested promisc mode\n+pub const IFF_MONITOR: ::c_int = 0x40000; // user-requested monitor mode\n+pub const IFF_STATICARP: ::c_int = 0x80000; // static ARP\n+pub const IFF_NPOLLING: ::c_int = 0x100000; // interface is in polling mode\n+pub const IFF_IDIRECT: ::c_int = 0x200000; // direct input\n+\n+//\n+// sys/netinet/in.h\n+// Protocols (RFC 1700)\n+// NOTE: These are in addition to the constants defined in src/unix/mod.rs\n+\n+// IPPROTO_IP defined in src/unix/mod.rs\n+/// IP6 hop-by-hop options\n+pub const IPPROTO_HOPOPTS: ::c_int = 0;\n+// IPPROTO_ICMP defined in src/unix/mod.rs\n+/// group mgmt protocol\n+pub const IPPROTO_IGMP: ::c_int = 2;\n+/// gateway^2 (deprecated)\n+pub const IPPROTO_GGP: ::c_int = 3;\n+/// for compatibility\n+pub const IPPROTO_IPIP: ::c_int = 4;\n+// IPPROTO_TCP defined in src/unix/mod.rs\n+/// Stream protocol II.\n+pub const IPPROTO_ST: ::c_int = 7;\n+/// exterior gateway protocol\n+pub const IPPROTO_EGP: ::c_int = 8;\n+/// private interior gateway\n+pub const IPPROTO_PIGP: ::c_int = 9;\n+/// BBN RCC Monitoring\n+pub const IPPROTO_RCCMON: ::c_int = 10;\n+/// network voice protocol\n+pub const IPPROTO_NVPII: ::c_int = 11;\n+/// pup\n+pub const IPPROTO_PUP: ::c_int = 12;\n+/// Argus\n+pub const IPPROTO_ARGUS: ::c_int = 13;\n+/// EMCON\n+pub const IPPROTO_EMCON: ::c_int = 14;\n+/// Cross Net Debugger\n+pub const IPPROTO_XNET: ::c_int = 15;\n+/// Chaos\n+pub const IPPROTO_CHAOS: ::c_int = 16;\n+// IPPROTO_UDP defined in src/unix/mod.rs\n+/// Multiplexing\n+pub const IPPROTO_MUX: ::c_int = 18;\n+/// DCN Measurement Subsystems\n+pub const IPPROTO_MEAS: ::c_int = 19;\n+/// Host Monitoring\n+pub const IPPROTO_HMP: ::c_int = 20;\n+/// Packet Radio Measurement\n+pub const IPPROTO_PRM: ::c_int = 21;\n+/// xns idp\n+pub const IPPROTO_IDP: ::c_int = 22;\n+/// Trunk-1\n+pub const IPPROTO_TRUNK1: ::c_int = 23;\n+/// Trunk-2\n+pub const IPPROTO_TRUNK2: ::c_int = 24;\n+/// Leaf-1\n+pub const IPPROTO_LEAF1: ::c_int = 25;\n+/// Leaf-2\n+pub const IPPROTO_LEAF2: ::c_int = 26;\n+/// Reliable Data\n+pub const IPPROTO_RDP: ::c_int = 27;\n+/// Reliable Transaction\n+pub const IPPROTO_IRTP: ::c_int = 28;\n+/// tp-4 w/ class negotiation\n+pub const IPPROTO_TP: ::c_int = 29;\n+/// Bulk Data Transfer\n+pub const IPPROTO_BLT: ::c_int = 30;\n+/// Network Services\n+pub const IPPROTO_NSP: ::c_int = 31;\n+/// Merit Internodal\n+pub const IPPROTO_INP: ::c_int = 32;\n+/// Sequential Exchange\n+pub const IPPROTO_SEP: ::c_int = 33;\n+/// Third Party Connect\n+pub const IPPROTO_3PC: ::c_int = 34;\n+/// InterDomain Policy Routing\n+pub const IPPROTO_IDPR: ::c_int = 35;\n+/// XTP\n+pub const IPPROTO_XTP: ::c_int = 36;\n+/// Datagram Delivery\n+pub const IPPROTO_DDP: ::c_int = 37;\n+/// Control Message Transport\n+pub const IPPROTO_CMTP: ::c_int = 38;\n+/// TP++ Transport\n+pub const IPPROTO_TPXX: ::c_int = 39;\n+/// IL transport protocol\n+pub const IPPROTO_IL: ::c_int = 40;\n+// IPPROTO_IPV6 defined in src/unix/mod.rs\n+/// Source Demand Routing\n+pub const IPPROTO_SDRP: ::c_int = 42;\n+/// IP6 routing header\n+pub const IPPROTO_ROUTING: ::c_int = 43;\n+/// IP6 fragmentation header\n+pub const IPPROTO_FRAGMENT: ::c_int = 44;\n+/// InterDomain Routing\n+pub const IPPROTO_IDRP: ::c_int = 45;\n+/// resource reservation\n+pub const IPPROTO_RSVP: ::c_int = 46;\n+/// General Routing Encap.\n+pub const IPPROTO_GRE: ::c_int = 47;\n+/// Mobile Host Routing\n+pub const IPPROTO_MHRP: ::c_int = 48;\n+/// BHA\n+pub const IPPROTO_BHA: ::c_int = 49;\n+/// IP6 Encap Sec. Payload\n+pub const IPPROTO_ESP: ::c_int = 50;\n+/// IP6 Auth Header\n+pub const IPPROTO_AH: ::c_int = 51;\n+/// Integ. Net Layer Security\n+pub const IPPROTO_INLSP: ::c_int = 52;\n+/// IP with encryption\n+pub const IPPROTO_SWIPE: ::c_int = 53;\n+/// Next Hop Resolution\n+pub const IPPROTO_NHRP: ::c_int = 54;\n+/// IP Mobility\n+pub const IPPROTO_MOBILE: ::c_int = 55;\n+/// Transport Layer Security\n+pub const IPPROTO_TLSP: ::c_int = 56;\n+/// SKIP\n+pub const IPPROTO_SKIP: ::c_int = 57;\n+// IPPROTO_ICMPV6 defined in src/unix/mod.rs\n+/// IP6 no next header\n+pub const IPPROTO_NONE: ::c_int = 59;\n+/// IP6 destination option\n+pub const IPPROTO_DSTOPTS: ::c_int = 60;\n+/// any host internal protocol\n+pub const IPPROTO_AHIP: ::c_int = 61;\n+/// CFTP\n+pub const IPPROTO_CFTP: ::c_int = 62;\n+/// \"hello\" routing protocol\n+pub const IPPROTO_HELLO: ::c_int = 63;\n+/// SATNET/Backroom EXPAK\n+pub const IPPROTO_SATEXPAK: ::c_int = 64;\n+/// Kryptolan\n+pub const IPPROTO_KRYPTOLAN: ::c_int = 65;\n+/// Remote Virtual Disk\n+pub const IPPROTO_RVD: ::c_int = 66;\n+/// Pluribus Packet Core\n+pub const IPPROTO_IPPC: ::c_int = 67;\n+/// Any distributed FS\n+pub const IPPROTO_ADFS: ::c_int = 68;\n+/// Satnet Monitoring\n+pub const IPPROTO_SATMON: ::c_int = 69;\n+/// VISA Protocol\n+pub const IPPROTO_VISA: ::c_int = 70;\n+/// Packet Core Utility\n+pub const IPPROTO_IPCV: ::c_int = 71;\n+/// Comp. Prot. Net. Executive\n+pub const IPPROTO_CPNX: ::c_int = 72;\n+/// Comp. Prot. HeartBeat\n+pub const IPPROTO_CPHB: ::c_int = 73;\n+/// Wang Span Network\n+pub const IPPROTO_WSN: ::c_int = 74;\n+/// Packet Video Protocol\n+pub const IPPROTO_PVP: ::c_int = 75;\n+/// BackRoom SATNET Monitoring\n+pub const IPPROTO_BRSATMON: ::c_int = 76;\n+/// Sun net disk proto (temp.)\n+pub const IPPROTO_ND: ::c_int = 77;\n+/// WIDEBAND Monitoring\n+pub const IPPROTO_WBMON: ::c_int = 78;\n+/// WIDEBAND EXPAK\n+pub const IPPROTO_WBEXPAK: ::c_int = 79;\n+/// ISO cnlp\n+pub const IPPROTO_EON: ::c_int = 80;\n+/// VMTP\n+pub const IPPROTO_VMTP: ::c_int = 81;\n+/// Secure VMTP\n+pub const IPPROTO_SVMTP: ::c_int = 82;\n+/// Banyon VINES\n+pub const IPPROTO_VINES: ::c_int = 83;\n+/// TTP\n+pub const IPPROTO_TTP: ::c_int = 84;\n+/// NSFNET-IGP\n+pub const IPPROTO_IGP: ::c_int = 85;\n+/// dissimilar gateway prot.\n+pub const IPPROTO_DGP: ::c_int = 86;\n+/// TCF\n+pub const IPPROTO_TCF: ::c_int = 87;\n+/// Cisco/GXS IGRP\n+pub const IPPROTO_IGRP: ::c_int = 88;\n+/// OSPFIGP\n+pub const IPPROTO_OSPFIGP: ::c_int = 89;\n+/// Strite RPC protocol\n+pub const IPPROTO_SRPC: ::c_int = 90;\n+/// Locus Address Resoloution\n+pub const IPPROTO_LARP: ::c_int = 91;\n+/// Multicast Transport\n+pub const IPPROTO_MTP: ::c_int = 92;\n+/// AX.25 Frames\n+pub const IPPROTO_AX25: ::c_int = 93;\n+/// IP encapsulated in IP\n+pub const IPPROTO_IPEIP: ::c_int = 94;\n+/// Mobile Int.ing control\n+pub const IPPROTO_MICP: ::c_int = 95;\n+/// Semaphore Comm. security\n+pub const IPPROTO_SCCSP: ::c_int = 96;\n+/// Ethernet IP encapsulation\n+pub const IPPROTO_ETHERIP: ::c_int = 97;\n+/// encapsulation header\n+pub const IPPROTO_ENCAP: ::c_int = 98;\n+/// any private encr. scheme\n+pub const IPPROTO_APES: ::c_int = 99;\n+/// GMTP\n+pub const IPPROTO_GMTP: ::c_int = 100;\n+/// payload compression (IPComp)\n+pub const IPPROTO_IPCOMP: ::c_int = 108;\n+\n+/* 101-254: Partly Unassigned */\n+/// Protocol Independent Mcast\n+pub const IPPROTO_PIM: ::c_int = 103;\n+/// CARP\n+pub const IPPROTO_CARP: ::c_int = 112;\n+/// PGM\n+pub const IPPROTO_PGM: ::c_int = 113;\n+/// PFSYNC\n+pub const IPPROTO_PFSYNC: ::c_int = 240;\n+\n+/* 255: Reserved */\n+/* BSD Private, local use, namespace incursion, no longer used */\n+/// divert pseudo-protocol\n+pub const IPPROTO_DIVERT: ::c_int = 254;\n+pub const IPPROTO_MAX: ::c_int = 256;\n+/// last return value of *_input(), meaning \"all job for this pkt is done\".\n+pub const IPPROTO_DONE: ::c_int = 257;\n+\n+/// Used by RSS: the layer3 protocol is unknown\n+pub const IPPROTO_UNKNOWN: ::c_int = 258;\n+\n+// sys/netinet/tcp.h\n+pub const TCP_SIGNATURE_ENABLE: ::c_int = 16;\n+pub const TCP_KEEPINIT: ::c_int = 32;\n+pub const TCP_FASTKEEP: ::c_int = 128;\n+\n+pub const AF_BLUETOOTH: ::c_int = 33;\n+pub const AF_MPLS: ::c_int = 34;\n+pub const AF_IEEE80211: ::c_int = 35;\n+\n+pub const PF_BLUETOOTH: ::c_int = AF_BLUETOOTH;\n+\n+pub const NET_RT_DUMP: ::c_int = 1;\n+pub const NET_RT_FLAGS: ::c_int = 2;\n+pub const NET_RT_IFLIST: ::c_int = 3;\n+pub const NET_RT_MAXID: ::c_int = 4;\n+\n+pub const SOMAXOPT_SIZE: ::c_int = 65536;\n+\n+pub const MSG_UNUSED09: ::c_int = 0x00000200;\n+pub const MSG_NOSIGNAL: ::c_int = 0x00000400;\n+pub const MSG_SYNC: ::c_int = 0x00000800;\n+pub const MSG_CMSG_CLOEXEC: ::c_int = 0x00001000;\n+pub const MSG_FBLOCKING: ::c_int = 0x00010000;\n+pub const MSG_FNONBLOCKING: ::c_int = 0x00020000;\n+pub const MSG_FMASK: ::c_int = 0xFFFF0000;\n+\n+// utmpx entry types\n+pub const EMPTY: ::c_short = 0;\n+pub const RUN_LVL: ::c_short = 1;\n+pub const BOOT_TIME: ::c_short = 2;\n+pub const OLD_TIME: ::c_short = 3;\n+pub const NEW_TIME: ::c_short = 4;\n+pub const INIT_PROCESS: ::c_short = 5;\n+pub const LOGIN_PROCESS: ::c_short = 6;\n+pub const USER_PROCESS: ::c_short = 7;\n+pub const DEAD_PROCESS: ::c_short = 8;\n+pub const ACCOUNTING: ::c_short = 9;\n+pub const SIGNATURE: ::c_short = 10;\n+pub const DOWNTIME: ::c_short = 11;\n+// utmpx database types\n+pub const UTX_DB_UTMPX: ::c_uint = 0;\n+pub const UTX_DB_WTMPX: ::c_uint = 1;\n+pub const UTX_DB_LASTLOG: ::c_uint = 2;\n+\n+pub const LC_COLLATE_MASK: ::c_int = (1 << 0);\n+pub const LC_CTYPE_MASK: ::c_int = (1 << 1);\n+pub const LC_MONETARY_MASK: ::c_int = (1 << 2);\n+pub const LC_NUMERIC_MASK: ::c_int = (1 << 3);\n+pub const LC_TIME_MASK: ::c_int = (1 << 4);\n+pub const LC_MESSAGES_MASK: ::c_int = (1 << 5);\n+pub const LC_ALL_MASK: ::c_int = LC_COLLATE_MASK\n+    | LC_CTYPE_MASK\n+    | LC_MESSAGES_MASK\n+    | LC_MONETARY_MASK\n+    | LC_NUMERIC_MASK\n+    | LC_TIME_MASK;\n+\n+pub const TIOCSIG: ::c_uint = 0x2000745f;\n+pub const BTUARTDISC: ::c_int = 0x7;\n+pub const TIOCDCDTIMESTAMP: ::c_uint = 0x40107458;\n+pub const TIOCISPTMASTER: ::c_uint = 0x20007455;\n+pub const TIOCMODG: ::c_uint = 0x40047403;\n+pub const TIOCMODS: ::c_ulong = 0x80047404;\n+pub const TIOCREMOTE: ::c_ulong = 0x80047469;\n+\n+// Constants used by \"at\" family of system calls.\n+pub const AT_FDCWD: ::c_int = 0xFFFAFDCD; // invalid file descriptor\n+pub const AT_SYMLINK_NOFOLLOW: ::c_int = 1;\n+pub const AT_REMOVEDIR: ::c_int = 2;\n+pub const AT_EACCESS: ::c_int = 4;\n+pub const AT_SYMLINK_FOLLOW: ::c_int = 8;\n+\n+pub const VCHECKPT: usize = 19;\n+\n+pub const _PC_2_SYMLINKS: ::c_int = 22;\n+pub const _PC_TIMESTAMP_RESOLUTION: ::c_int = 23;\n+\n+pub const _SC_V7_ILP32_OFF32: ::c_int = 122;\n+pub const _SC_V7_ILP32_OFFBIG: ::c_int = 123;\n+pub const _SC_V7_LP64_OFF64: ::c_int = 124;\n+pub const _SC_V7_LPBIG_OFFBIG: ::c_int = 125;\n+pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::c_int = 126;\n+pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::c_int = 127;\n+\n+pub const WCONTINUED: ::c_int = 4;\n+pub const WSTOPPED: ::c_int = 0o177;\n+\n+// Values for struct rtprio (type_ field)\n+pub const RTP_PRIO_REALTIME: ::c_ushort = 0;\n+pub const RTP_PRIO_NORMAL: ::c_ushort = 1;\n+pub const RTP_PRIO_IDLE: ::c_ushort = 2;\n+pub const RTP_PRIO_THREAD: ::c_ushort = 3;\n+\n+// Flags for chflags(2)\n+pub const UF_NOHISTORY: ::c_ulong = 0x00000040;\n+pub const UF_CACHE: ::c_ulong = 0x00000080;\n+pub const UF_XLINK: ::c_ulong = 0x00000100;\n+pub const SF_NOHISTORY: ::c_ulong = 0x00400000;\n+pub const SF_CACHE: ::c_ulong = 0x00800000;\n+pub const SF_XLINK: ::c_ulong = 0x01000000;\n+\n+// timespec constants\n+pub const UTIME_OMIT: c_long = -2;\n+pub const UTIME_NOW: c_long = -1;\n+\n+fn _CMSG_ALIGN(n: usize) -> usize {\n+    (n + 3) & !3\n+}\n+\n+f! {\n+    pub fn CMSG_DATA(cmsg: *const ::cmsghdr) -> *mut ::c_uchar {\n+        (cmsg as *mut ::c_uchar)\n+            .offset(_CMSG_ALIGN(::mem::size_of::<::cmsghdr>()) as isize)\n+    }\n+\n+    pub fn CMSG_LEN(length: ::c_uint) -> ::c_uint {\n+        (_CMSG_ALIGN(::mem::size_of::<::cmsghdr>()) + length as usize)\n+            as ::c_uint\n+    }\n+\n+    pub fn CMSG_NXTHDR(mhdr: *const ::msghdr, cmsg: *const ::cmsghdr)\n+        -> *mut ::cmsghdr\n+    {\n+        let next = cmsg as usize + _CMSG_ALIGN((*cmsg).cmsg_len as usize)\n+            + _CMSG_ALIGN(::mem::size_of::<::cmsghdr>());\n+        let max = (*mhdr).msg_control as usize\n+            + (*mhdr).msg_controllen as usize;\n+        if next <= max {\n+            (cmsg as usize + _CMSG_ALIGN((*cmsg).cmsg_len as usize))\n+                as *mut ::cmsghdr\n+        } else {\n+            0 as *mut ::cmsghdr\n+        }\n+    }\n+\n+    pub fn CMSG_SPACE(length: ::c_uint) -> ::c_uint {\n+        (_CMSG_ALIGN(::mem::size_of::<::cmsghdr>()) +\n+            _CMSG_ALIGN(length as usize)) as ::c_uint\n+    }\n+}\n+\n+extern \"C\" {\n+    pub fn setgrent();\n+    pub fn mprotect(\n+        addr: *mut ::c_void,\n+        len: ::size_t,\n+        prot: ::c_int,\n+    ) -> ::c_int;\n+    pub fn clock_getres(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;\n+    pub fn clock_gettime(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;\n+    pub fn clock_settime(\n+        clk_id: ::clockid_t,\n+        tp: *const ::timespec,\n+    ) -> ::c_int;\n+\n+    pub fn setutxdb(_type: ::c_uint, file: *mut ::c_char) -> ::c_int;\n+\n+    pub fn aio_waitcomplete(\n+        iocbp: *mut *mut aiocb,\n+        timeout: *mut ::timespec,\n+    ) -> ::c_int;\n+\n+    pub fn freelocale(loc: ::locale_t);\n+\n+    pub fn lwp_rtprio(\n+        function: ::c_int,\n+        pid: ::pid_t,\n+        lwpid: lwpid_t,\n+        rtp: *mut super::rtprio,\n+    ) -> ::c_int;\n+\n+    pub fn statfs(path: *const ::c_char, buf: *mut statfs) -> ::c_int;\n+    pub fn fstatfs(fd: ::c_int, buf: *mut statfs) -> ::c_int;\n+    pub fn uname(buf: *mut ::utsname) -> ::c_int;\n+}\n+\n+cfg_if! {\n+    if #[cfg(libc_thread_local)] {\n+        mod errno;\n+        pub use self::errno::*;\n+    }\n+}"
      },
      {
        "sha": "22fd2b84f9d02dd1c8c906433e6d6296b03f9169",
        "filename": "src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/aarch64.rs",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/aarch64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/aarch64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/aarch64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,44 @@\n+pub type c_char = u8;\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type time_t = i64;\n+pub type suseconds_t = i64;\n+\n+s! {\n+    pub struct stat {\n+        pub st_dev: ::dev_t,\n+        pub st_ino: ::ino_t,\n+        pub st_mode: ::mode_t,\n+        pub st_nlink: ::nlink_t,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        pub st_rdev: ::dev_t,\n+        pub st_atime: ::time_t,\n+        pub st_atime_nsec: ::c_long,\n+        pub st_mtime: ::time_t,\n+        pub st_mtime_nsec: ::c_long,\n+        pub st_ctime: ::time_t,\n+        pub st_ctime_nsec: ::c_long,\n+        pub st_size: ::off_t,\n+        pub st_blocks: ::blkcnt_t,\n+        pub st_blksize: ::blksize_t,\n+        pub st_flags: ::fflags_t,\n+        pub st_gen: u32,\n+        pub st_lspare: i32,\n+        pub st_birthtime: ::time_t,\n+        pub st_birthtime_nsec: ::c_long,\n+    }\n+}\n+\n+// should be pub(crate), but that requires Rust 1.18.0\n+cfg_if! {\n+    if #[cfg(libc_const_size_of)] {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_longlong>() - 1;\n+    } else {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = 8 - 1;\n+    }\n+}\n+\n+pub const MAP_32BIT: ::c_int = 0x00080000;"
      },
      {
        "sha": "b7480aa78b956d2e8f882159b081883c52f364ad",
        "filename": "src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/arm.rs",
        "status": "added",
        "additions": 47,
        "deletions": 0,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/arm.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/arm.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/arm.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,47 @@\n+pub type c_char = u8;\n+pub type c_long = i32;\n+pub type c_ulong = u32;\n+pub type time_t = i64;\n+pub type suseconds_t = i32;\n+\n+s! {\n+    pub struct stat {\n+        pub st_dev: ::dev_t,\n+        pub st_ino: ::ino_t,\n+        pub st_mode: ::mode_t,\n+        pub st_nlink: ::nlink_t,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        pub st_rdev: ::dev_t,\n+        pub st_atime: ::time_t,\n+        pub st_atime_nsec: ::c_long,\n+        pub st_atime_pad: ::c_long,\n+        pub st_mtime: ::time_t,\n+        pub st_mtime_nsec: ::c_long,\n+        pub st_mtime_pad: ::c_long,\n+        pub st_ctime: ::time_t,\n+        pub st_ctime_nsec: ::c_long,\n+        pub st_ctime_pad: ::c_long,\n+        pub st_size: ::off_t,\n+        pub st_blocks: ::blkcnt_t,\n+        pub st_blksize: ::blksize_t,\n+        pub st_flags: ::fflags_t,\n+        pub st_gen: u32,\n+        pub st_lspare: i32,\n+        pub st_birthtime: ::time_t,\n+        pub st_birthtime_nsec: ::c_long,\n+        pub st_birthtime_pad: ::c_long,\n+    }\n+}\n+\n+// should be pub(crate), but that requires Rust 1.18.0\n+cfg_if! {\n+    if #[cfg(libc_const_size_of)] {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_int>() - 1;\n+    } else {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = 4 - 1;\n+    }\n+}\n+pub const MAP_32BIT: ::c_int = 0x00080000;"
      },
      {
        "sha": "79a152fc858346b0f4d789ead9c0acabc5af9d34",
        "filename": "src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd11/mod.rs",
        "status": "added",
        "additions": 224,
        "deletions": 0,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd11/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd11/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd11/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,224 @@\n+// APIs that had breaking changes after FreeBSD 11\n+\n+// The type of `nlink_t` changed from `u16` to `u64` in FreeBSD 12:\n+pub type nlink_t = u16;\n+// Type of `dev_t` changed from `u32` to `u64` in FreeBSD 12:\n+pub type dev_t = u32;\n+// Type of `ino_t` changed from `unsigned int` to `unsigned long` in FreeBSD 12:\n+pub type ino_t = u32;\n+\n+s! {\n+    pub struct kevent {\n+        pub ident: ::uintptr_t,\n+        pub filter: ::c_short,\n+        pub flags: ::c_ushort,\n+        pub fflags: ::c_uint,\n+        pub data: ::intptr_t,\n+        pub udata: *mut ::c_void,\n+    }\n+\n+    pub struct shmid_ds {\n+        pub shm_perm: ::ipc_perm,\n+        pub shm_segsz: ::size_t,\n+        pub shm_lpid: ::pid_t,\n+        pub shm_cpid: ::pid_t,\n+        // Type of shm_nattc changed from `int` to `shmatt_t` (aka `unsigned\n+        // int`) in FreeBSD 12:\n+        pub shm_nattch: ::c_int,\n+        pub shm_atime: ::time_t,\n+        pub shm_dtime: ::time_t,\n+        pub shm_ctime: ::time_t,\n+    }\n+}\n+\n+s_no_extra_traits! {\n+    pub struct dirent {\n+        pub d_fileno: ::ino_t,\n+        pub d_reclen: u16,\n+        pub d_type: u8,\n+        // Type of `d_namlen` changed from `char` to `u16` in FreeBSD 12:\n+        pub d_namlen: u8,\n+        pub d_name: [::c_char; 256],\n+    }\n+\n+    pub struct statfs {\n+        pub f_version: u32,\n+        pub f_type: u32,\n+        pub f_flags: u64,\n+        pub f_bsize: u64,\n+        pub f_iosize: u64,\n+        pub f_blocks: u64,\n+        pub f_bfree: u64,\n+        pub f_bavail: i64,\n+        pub f_files: u64,\n+        pub f_ffree: i64,\n+        pub f_syncwrites: u64,\n+        pub f_asyncwrites: u64,\n+        pub f_syncreads: u64,\n+        pub f_asyncreads: u64,\n+        f_spare: [u64; 10],\n+        pub f_namemax: u32,\n+        pub f_owner: ::uid_t,\n+        pub f_fsid: ::fsid_t,\n+        f_charspare: [::c_char; 80],\n+        pub f_fstypename: [::c_char; 16],\n+        // Array length changed from 88 to 1024 in FreeBSD 12:\n+        pub f_mntfromname: [::c_char; 88],\n+        // Array length changed from 88 to 1024 in FreeBSD 12:\n+        pub f_mntonname: [::c_char; 88],\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(feature = \"extra_traits\")] {\n+        impl PartialEq for statfs {\n+            fn eq(&self, other: &statfs) -> bool {\n+                self.f_version == other.f_version\n+                    && self.f_type == other.f_type\n+                    && self.f_flags == other.f_flags\n+                    && self.f_bsize == other.f_bsize\n+                    && self.f_iosize == other.f_iosize\n+                    && self.f_blocks == other.f_blocks\n+                    && self.f_bfree == other.f_bfree\n+                    && self.f_bavail == other.f_bavail\n+                    && self.f_files == other.f_files\n+                    && self.f_ffree == other.f_ffree\n+                    && self.f_syncwrites == other.f_syncwrites\n+                    && self.f_asyncwrites == other.f_asyncwrites\n+                    && self.f_syncreads == other.f_syncreads\n+                    && self.f_asyncreads == other.f_asyncreads\n+                    && self.f_namemax == other.f_namemax\n+                    && self.f_owner == other.f_owner\n+                    && self.f_fsid == other.f_fsid\n+                    && self.f_fstypename == other.f_fstypename\n+                    && self\n+                    .f_mntfromname\n+                    .iter()\n+                    .zip(other.f_mntfromname.iter())\n+                    .all(|(a,b)| a == b)\n+                    && self\n+                    .f_mntonname\n+                    .iter()\n+                    .zip(other.f_mntonname.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for statfs {}\n+        impl ::fmt::Debug for statfs {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"statfs\")\n+                    .field(\"f_bsize\", &self.f_bsize)\n+                    .field(\"f_iosize\", &self.f_iosize)\n+                    .field(\"f_blocks\", &self.f_blocks)\n+                    .field(\"f_bfree\", &self.f_bfree)\n+                    .field(\"f_bavail\", &self.f_bavail)\n+                    .field(\"f_files\", &self.f_files)\n+                    .field(\"f_ffree\", &self.f_ffree)\n+                    .field(\"f_syncwrites\", &self.f_syncwrites)\n+                    .field(\"f_asyncwrites\", &self.f_asyncwrites)\n+                    .field(\"f_syncreads\", &self.f_syncreads)\n+                    .field(\"f_asyncreads\", &self.f_asyncreads)\n+                    .field(\"f_namemax\", &self.f_namemax)\n+                    .field(\"f_owner\", &self.f_owner)\n+                    .field(\"f_fsid\", &self.f_fsid)\n+                    .field(\"f_fstypename\", &self.f_fstypename)\n+                    .field(\"f_mntfromname\", &&self.f_mntfromname[..])\n+                    .field(\"f_mntonname\", &&self.f_mntonname[..])\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for statfs {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.f_version.hash(state);\n+                self.f_type.hash(state);\n+                self.f_flags.hash(state);\n+                self.f_bsize.hash(state);\n+                self.f_iosize.hash(state);\n+                self.f_blocks.hash(state);\n+                self.f_bfree.hash(state);\n+                self.f_bavail.hash(state);\n+                self.f_files.hash(state);\n+                self.f_ffree.hash(state);\n+                self.f_syncwrites.hash(state);\n+                self.f_asyncwrites.hash(state);\n+                self.f_syncreads.hash(state);\n+                self.f_asyncreads.hash(state);\n+                self.f_namemax.hash(state);\n+                self.f_owner.hash(state);\n+                self.f_fsid.hash(state);\n+                self.f_fstypename.hash(state);\n+                self.f_mntfromname.hash(state);\n+                self.f_mntonname.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for dirent {\n+            fn eq(&self, other: &dirent) -> bool {\n+                self.d_fileno == other.d_fileno\n+                    && self.d_reclen == other.d_reclen\n+                    && self.d_type == other.d_type\n+                    && self.d_namlen == other.d_namlen\n+                    && self\n+                    .d_name[..self.d_namlen as _]\n+                    .iter()\n+                    .zip(other.d_name.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for dirent {}\n+        impl ::fmt::Debug for dirent {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"dirent\")\n+                    .field(\"d_fileno\", &self.d_fileno)\n+                    .field(\"d_reclen\", &self.d_reclen)\n+                    .field(\"d_type\", &self.d_type)\n+                    .field(\"d_namlen\", &self.d_namlen)\n+                    .field(\"d_name\", &&self.d_name[..self.d_namlen as _])\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for dirent {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.d_fileno.hash(state);\n+                self.d_reclen.hash(state);\n+                self.d_type.hash(state);\n+                self.d_namlen.hash(state);\n+                self.d_name[..self.d_namlen as _].hash(state);\n+            }\n+        }\n+    }\n+}\n+\n+pub const ELAST: ::c_int = 96;\n+\n+extern \"C\" {\n+    // Return type ::c_int was removed in FreeBSD 12\n+    pub fn setgrent() -> ::c_int;\n+\n+    // Type of `addr` argument changed from `const void*` to `void*`\n+    // in FreeBSD 12\n+    pub fn mprotect(\n+        addr: *const ::c_void,\n+        len: ::size_t,\n+        prot: ::c_int,\n+    ) -> ::c_int;\n+\n+    // Return type ::c_int was removed in FreeBSD 12\n+    pub fn freelocale(loc: ::locale_t) -> ::c_int;\n+\n+    // Return type ::c_int changed to ::ssize_t in FreeBSD 12:\n+    pub fn msgrcv(\n+        msqid: ::c_int,\n+        msgp: *mut ::c_void,\n+        msgsz: ::size_t,\n+        msgtyp: ::c_long,\n+        msgflg: ::c_int,\n+    ) -> ::c_int;\n+}\n+\n+cfg_if! {\n+    if #[cfg(target_arch = \"x86_64\")] {\n+        mod x86_64;\n+        pub use self::x86_64::*;\n+    }\n+}"
      },
      {
        "sha": "f32128f7755747219a16ed8aa38bb6a2efc9e51c",
        "filename": "src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd11/x86_64.rs",
        "status": "added",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd11/x86_64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd11/x86_64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd11/x86_64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,32 @@\n+#[repr(C)]\n+#[cfg_attr(feature = \"extra_traits\", derive(Debug, Eq, Hash, PartialEq))]\n+pub struct stat {\n+    pub st_dev: ::dev_t,\n+    pub st_ino: ::ino_t,\n+    pub st_mode: ::mode_t,\n+    pub st_nlink: ::nlink_t,\n+    pub st_uid: ::uid_t,\n+    pub st_gid: ::gid_t,\n+    pub st_rdev: ::dev_t,\n+    pub st_atime: ::time_t,\n+    pub st_atime_nsec: ::c_long,\n+    pub st_mtime: ::time_t,\n+    pub st_mtime_nsec: ::c_long,\n+    pub st_ctime: ::time_t,\n+    pub st_ctime_nsec: ::c_long,\n+    pub st_size: ::off_t,\n+    pub st_blocks: ::blkcnt_t,\n+    pub st_blksize: ::blksize_t,\n+    pub st_flags: ::fflags_t,\n+    pub st_gen: u32,\n+    pub st_lspare: i32,\n+    pub st_birthtime: ::time_t,\n+    pub st_birthtime_nsec: ::c_long,\n+}\n+\n+impl ::Copy for ::stat {}\n+impl ::Clone for ::stat {\n+    fn clone(&self) -> ::stat {\n+        *self\n+    }\n+}"
      },
      {
        "sha": "6bf7f957e692ee320409794cf5047d1e86fdd98d",
        "filename": "src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd12/mod.rs",
        "status": "added",
        "additions": 224,
        "deletions": 0,
        "changes": 224,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd12/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd12/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd12/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,224 @@\n+// APIs that changed in FreeBSD12\n+\n+pub type nlink_t = u64;\n+pub type dev_t = u64;\n+pub type ino_t = ::c_ulong;\n+pub type shmatt_t = ::c_uint;\n+\n+s! {\n+    pub struct shmid_ds {\n+        pub shm_perm: ::ipc_perm,\n+        pub shm_segsz: ::size_t,\n+        pub shm_lpid: ::pid_t,\n+        pub shm_cpid: ::pid_t,\n+        pub shm_nattch: ::shmatt_t,\n+        pub shm_atime: ::time_t,\n+        pub shm_dtime: ::time_t,\n+        pub shm_ctime: ::time_t,\n+    }\n+\n+    pub struct kevent {\n+        pub ident: ::uintptr_t,\n+        pub filter: ::c_short,\n+        pub flags: ::c_ushort,\n+        pub fflags: ::c_uint,\n+        pub data: ::intptr_t,\n+        pub udata: *mut ::c_void,\n+        pub ext: [u64; 4],\n+    }\n+}\n+\n+s_no_extra_traits! {\n+    pub struct dirent {\n+        pub d_fileno: ::ino_t,\n+        pub d_off: ::off_t,\n+        pub d_reclen: u16,\n+        pub d_type: u8,\n+        d_pad0: u8,\n+        pub d_namlen: u16,\n+        d_pad1: u16,\n+        pub d_name: [::c_char; 256],\n+    }\n+\n+    pub struct statfs {\n+        pub f_version: u32,\n+        pub f_type: u32,\n+        pub f_flags: u64,\n+        pub f_bsize: u64,\n+        pub f_iosize: u64,\n+        pub f_blocks: u64,\n+        pub f_bfree: u64,\n+        pub f_bavail: i64,\n+        pub f_files: u64,\n+        pub f_ffree: i64,\n+        pub f_syncwrites: u64,\n+        pub f_asyncwrites: u64,\n+        pub f_syncreads: u64,\n+        pub f_asyncreads: u64,\n+        f_spare: [u64; 10],\n+        pub f_namemax: u32,\n+        pub f_owner: ::uid_t,\n+        pub f_fsid: ::fsid_t,\n+        f_charspare: [::c_char; 80],\n+        pub f_fstypename: [::c_char; 16],\n+        pub f_mntfromname: [::c_char; 1024],\n+        pub f_mntonname: [::c_char; 1024],\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(feature = \"extra_traits\")] {\n+        impl PartialEq for statfs {\n+            fn eq(&self, other: &statfs) -> bool {\n+                self.f_version == other.f_version\n+                    && self.f_type == other.f_type\n+                    && self.f_flags == other.f_flags\n+                    && self.f_bsize == other.f_bsize\n+                    && self.f_iosize == other.f_iosize\n+                    && self.f_blocks == other.f_blocks\n+                    && self.f_bfree == other.f_bfree\n+                    && self.f_bavail == other.f_bavail\n+                    && self.f_files == other.f_files\n+                    && self.f_ffree == other.f_ffree\n+                    && self.f_syncwrites == other.f_syncwrites\n+                    && self.f_asyncwrites == other.f_asyncwrites\n+                    && self.f_syncreads == other.f_syncreads\n+                    && self.f_asyncreads == other.f_asyncreads\n+                    && self.f_namemax == other.f_namemax\n+                    && self.f_owner == other.f_owner\n+                    && self.f_fsid == other.f_fsid\n+                    && self.f_fstypename == other.f_fstypename\n+                    && self\n+                    .f_mntfromname\n+                    .iter()\n+                    .zip(other.f_mntfromname.iter())\n+                    .all(|(a,b)| a == b)\n+                    && self\n+                    .f_mntonname\n+                    .iter()\n+                    .zip(other.f_mntonname.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for statfs {}\n+        impl ::fmt::Debug for statfs {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"statfs\")\n+                    .field(\"f_bsize\", &self.f_bsize)\n+                    .field(\"f_iosize\", &self.f_iosize)\n+                    .field(\"f_blocks\", &self.f_blocks)\n+                    .field(\"f_bfree\", &self.f_bfree)\n+                    .field(\"f_bavail\", &self.f_bavail)\n+                    .field(\"f_files\", &self.f_files)\n+                    .field(\"f_ffree\", &self.f_ffree)\n+                    .field(\"f_syncwrites\", &self.f_syncwrites)\n+                    .field(\"f_asyncwrites\", &self.f_asyncwrites)\n+                    .field(\"f_syncreads\", &self.f_syncreads)\n+                    .field(\"f_asyncreads\", &self.f_asyncreads)\n+                    .field(\"f_namemax\", &self.f_namemax)\n+                    .field(\"f_owner\", &self.f_owner)\n+                    .field(\"f_fsid\", &self.f_fsid)\n+                    .field(\"f_fstypename\", &self.f_fstypename)\n+                    .field(\"f_mntfromname\", &&self.f_mntfromname[..])\n+                    .field(\"f_mntonname\", &&self.f_mntonname[..])\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for statfs {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.f_version.hash(state);\n+                self.f_type.hash(state);\n+                self.f_flags.hash(state);\n+                self.f_bsize.hash(state);\n+                self.f_iosize.hash(state);\n+                self.f_blocks.hash(state);\n+                self.f_bfree.hash(state);\n+                self.f_bavail.hash(state);\n+                self.f_files.hash(state);\n+                self.f_ffree.hash(state);\n+                self.f_syncwrites.hash(state);\n+                self.f_asyncwrites.hash(state);\n+                self.f_syncreads.hash(state);\n+                self.f_asyncreads.hash(state);\n+                self.f_namemax.hash(state);\n+                self.f_owner.hash(state);\n+                self.f_fsid.hash(state);\n+                self.f_charspare.hash(state);\n+                self.f_fstypename.hash(state);\n+                self.f_mntfromname.hash(state);\n+                self.f_mntonname.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for dirent {\n+            fn eq(&self, other: &dirent) -> bool {\n+                self.d_fileno == other.d_fileno\n+                    && self.d_off == other.d_off\n+                    && self.d_reclen == other.d_reclen\n+                    && self.d_type == other.d_type\n+                    && self.d_namlen == other.d_namlen\n+                    && self\n+                    .d_name[..self.d_namlen as _]\n+                    .iter()\n+                    .zip(other.d_name.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for dirent {}\n+        impl ::fmt::Debug for dirent {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"dirent\")\n+                    .field(\"d_fileno\", &self.d_fileno)\n+                    .field(\"d_off\", &self.d_off)\n+                    .field(\"d_reclen\", &self.d_reclen)\n+                    .field(\"d_type\", &self.d_type)\n+                    .field(\"d_namlen\", &self.d_namlen)\n+                    .field(\"d_name\", &&self.d_name[..self.d_namlen as _])\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for dirent {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.d_fileno.hash(state);\n+                self.d_off.hash(state);\n+                self.d_reclen.hash(state);\n+                self.d_type.hash(state);\n+                self.d_namlen.hash(state);\n+                self.d_name[..self.d_namlen as _].hash(state);\n+            }\n+        }\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(not(freebsd13))] {\n+        pub const ELAST: ::c_int = 96;\n+    } else {\n+        pub const EINTEGRITY: ::c_int = 97;\n+        pub const ELAST: ::c_int = 97;\n+    }\n+}\n+\n+extern \"C\" {\n+    pub fn setgrent();\n+    pub fn mprotect(\n+        addr: *mut ::c_void,\n+        len: ::size_t,\n+        prot: ::c_int,\n+    ) -> ::c_int;\n+    pub fn freelocale(loc: ::locale_t);\n+    pub fn msgrcv(\n+        msqid: ::c_int,\n+        msgp: *mut ::c_void,\n+        msgsz: ::size_t,\n+        msgtyp: ::c_long,\n+        msgflg: ::c_int,\n+    ) -> ::ssize_t;\n+}\n+\n+cfg_if! {\n+    if #[cfg(target_arch = \"x86_64\")] {\n+        mod x86_64;\n+        pub use self::x86_64::*;\n+    }\n+}"
      },
      {
        "sha": "80c6fa16845308f929843e6d493807c49754d27d",
        "filename": "src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd12/x86_64.rs",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd12/x86_64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd12/x86_64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/freebsd12/x86_64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,34 @@\n+#[repr(C)]\n+#[cfg_attr(feature = \"extra_traits\", derive(Debug, Eq, Hash, PartialEq))]\n+pub struct stat {\n+    pub st_dev: ::dev_t,\n+    pub st_ino: ::ino_t,\n+    pub st_nlink: ::nlink_t,\n+    pub st_mode: ::mode_t,\n+    st_padding0: i16,\n+    pub st_uid: ::uid_t,\n+    pub st_gid: ::gid_t,\n+    st_padding1: i32,\n+    pub st_rdev: ::dev_t,\n+    pub st_atime: ::time_t,\n+    pub st_atime_nsec: ::c_long,\n+    pub st_mtime: ::time_t,\n+    pub st_mtime_nsec: ::c_long,\n+    pub st_ctime: ::time_t,\n+    pub st_ctime_nsec: ::c_long,\n+    pub st_birthtime: ::time_t,\n+    pub st_birthtime_nsec: ::c_long,\n+    pub st_size: ::off_t,\n+    pub st_blocks: ::blkcnt_t,\n+    pub st_blksize: ::blksize_t,\n+    pub st_flags: ::fflags_t,\n+    pub st_gen: u64,\n+    pub st_spare: [u64; 10],\n+}\n+\n+impl ::Copy for ::stat {}\n+impl ::Clone for ::stat {\n+    fn clone(&self) -> ::stat {\n+        *self\n+    }\n+}"
      },
      {
        "sha": "980caf225765d609440a313c17aa58047c94c882",
        "filename": "src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/mod.rs",
        "status": "added",
        "additions": 1486,
        "deletions": 0,
        "changes": 1486,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,1486 @@\n+pub type fflags_t = u32;\n+pub type clock_t = i32;\n+\n+pub type lwpid_t = i32;\n+pub type blksize_t = i32;\n+pub type clockid_t = ::c_int;\n+pub type sem_t = _sem;\n+\n+pub type fsblkcnt_t = u64;\n+pub type fsfilcnt_t = u64;\n+pub type idtype_t = ::c_uint;\n+\n+pub type key_t = ::c_long;\n+pub type msglen_t = ::c_ulong;\n+pub type msgqnum_t = ::c_ulong;\n+\n+pub type mqd_t = *mut ::c_void;\n+pub type posix_spawnattr_t = *mut ::c_void;\n+pub type posix_spawn_file_actions_t = *mut ::c_void;\n+\n+s! {\n+    pub struct aiocb {\n+        pub aio_fildes: ::c_int,\n+        pub aio_offset: ::off_t,\n+        pub aio_buf: *mut ::c_void,\n+        pub aio_nbytes: ::size_t,\n+        __unused1: [::c_int; 2],\n+        __unused2: *mut ::c_void,\n+        pub aio_lio_opcode: ::c_int,\n+        pub aio_reqprio: ::c_int,\n+        // unused 3 through 5 are the __aiocb_private structure\n+        __unused3: ::c_long,\n+        __unused4: ::c_long,\n+        __unused5: *mut ::c_void,\n+        pub aio_sigevent: sigevent\n+    }\n+\n+    pub struct jail {\n+        pub version: u32,\n+        pub path: *mut ::c_char,\n+        pub hostname: *mut ::c_char,\n+        pub jailname: *mut ::c_char,\n+        pub ip4s: ::c_uint,\n+        pub ip6s: ::c_uint,\n+        pub ip4: *mut ::in_addr,\n+        pub ip6: *mut ::in6_addr,\n+    }\n+\n+    pub struct statvfs {\n+        pub f_bavail: ::fsblkcnt_t,\n+        pub f_bfree: ::fsblkcnt_t,\n+        pub f_blocks: ::fsblkcnt_t,\n+        pub f_favail: ::fsfilcnt_t,\n+        pub f_ffree: ::fsfilcnt_t,\n+        pub f_files: ::fsfilcnt_t,\n+        pub f_bsize: ::c_ulong,\n+        pub f_flag: ::c_ulong,\n+        pub f_frsize: ::c_ulong,\n+        pub f_fsid: ::c_ulong,\n+        pub f_namemax: ::c_ulong,\n+    }\n+\n+    // internal structure has changed over time\n+    pub struct _sem {\n+        data: [u32; 4],\n+    }\n+\n+    pub struct ipc_perm {\n+        pub cuid: ::uid_t,\n+        pub cgid: ::gid_t,\n+        pub uid: ::uid_t,\n+        pub gid: ::gid_t,\n+        pub mode: ::mode_t,\n+        pub seq: ::c_ushort,\n+        pub key: ::key_t,\n+    }\n+\n+    pub struct msqid_ds {\n+        pub msg_perm: ::ipc_perm,\n+        __unused1: *mut ::c_void,\n+        __unused2: *mut ::c_void,\n+        pub msg_cbytes: ::msglen_t,\n+        pub msg_qnum: ::msgqnum_t,\n+        pub msg_qbytes: ::msglen_t,\n+        pub msg_lspid: ::pid_t,\n+        pub msg_lrpid: ::pid_t,\n+        pub msg_stime: ::time_t,\n+        pub msg_rtime: ::time_t,\n+        pub msg_ctime: ::time_t,\n+    }\n+\n+    pub struct xucred {\n+        pub cr_version: ::c_uint,\n+        pub cr_uid: ::uid_t,\n+        pub cr_ngroups: ::c_short,\n+        pub cr_groups: [::gid_t;16],\n+        __cr_unused1: *mut ::c_void,\n+    }\n+\n+    pub struct stack_t {\n+        pub ss_sp: *mut ::c_void,\n+        pub ss_size: ::size_t,\n+        pub ss_flags: ::c_int,\n+    }\n+\n+    pub struct mmsghdr {\n+        pub msg_hdr: ::msghdr,\n+        pub msg_len: ::ssize_t,\n+    }\n+}\n+\n+s_no_extra_traits! {\n+    pub struct utmpx {\n+        pub ut_type: ::c_short,\n+        pub ut_tv: ::timeval,\n+        pub ut_id: [::c_char; 8],\n+        pub ut_pid: ::pid_t,\n+        pub ut_user: [::c_char; 32],\n+        pub ut_line: [::c_char; 16],\n+        pub ut_host: [::c_char; 128],\n+        pub __ut_spare: [::c_char; 64],\n+    }\n+\n+    pub struct sockaddr_dl {\n+        pub sdl_len: ::c_uchar,\n+        pub sdl_family: ::c_uchar,\n+        pub sdl_index: ::c_ushort,\n+        pub sdl_type: ::c_uchar,\n+        pub sdl_nlen: ::c_uchar,\n+        pub sdl_alen: ::c_uchar,\n+        pub sdl_slen: ::c_uchar,\n+        pub sdl_data: [::c_char; 46],\n+    }\n+\n+    pub struct mq_attr {\n+        pub mq_flags: ::c_long,\n+        pub mq_maxmsg: ::c_long,\n+        pub mq_msgsize: ::c_long,\n+        pub mq_curmsgs: ::c_long,\n+        __reserved: [::c_long; 4]\n+    }\n+\n+    pub struct sigevent {\n+        pub sigev_notify: ::c_int,\n+        pub sigev_signo: ::c_int,\n+        pub sigev_value: ::sigval,\n+        //The rest of the structure is actually a union.  We expose only\n+        //sigev_notify_thread_id because it's the most useful union member.\n+        pub sigev_notify_thread_id: ::lwpid_t,\n+        #[cfg(target_pointer_width = \"64\")]\n+        __unused1: ::c_int,\n+        __unused2: [::c_long; 7]\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(feature = \"extra_traits\")] {\n+        impl PartialEq for utmpx {\n+            fn eq(&self, other: &utmpx) -> bool {\n+                self.ut_type == other.ut_type\n+                    && self.ut_tv == other.ut_tv\n+                    && self.ut_id == other.ut_id\n+                    && self.ut_pid == other.ut_pid\n+                    && self.ut_user == other.ut_user\n+                    && self.ut_line == other.ut_line\n+                    && self\n+                    .ut_host\n+                    .iter()\n+                    .zip(other.ut_host.iter())\n+                    .all(|(a,b)| a == b)\n+                    && self\n+                    .__ut_spare\n+                    .iter()\n+                    .zip(other.__ut_spare.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for utmpx {}\n+        impl ::fmt::Debug for utmpx {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"utmpx\")\n+                    .field(\"ut_type\", &self.ut_type)\n+                    .field(\"ut_tv\", &self.ut_tv)\n+                    .field(\"ut_id\", &self.ut_id)\n+                    .field(\"ut_pid\", &self.ut_pid)\n+                    .field(\"ut_user\", &self.ut_user)\n+                    .field(\"ut_line\", &self.ut_line)\n+                    // FIXME: .field(\"ut_host\", &self.ut_host)\n+                    // FIXME: .field(\"__ut_spare\", &self.__ut_spare)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for utmpx {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.ut_type.hash(state);\n+                self.ut_tv.hash(state);\n+                self.ut_id.hash(state);\n+                self.ut_pid.hash(state);\n+                self.ut_user.hash(state);\n+                self.ut_line.hash(state);\n+                self.ut_host.hash(state);\n+                self.__ut_spare.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for sockaddr_dl {\n+            fn eq(&self, other: &sockaddr_dl) -> bool {\n+                self.sdl_len == other.sdl_len\n+                    && self.sdl_family == other.sdl_family\n+                    && self.sdl_index == other.sdl_index\n+                    && self.sdl_type == other.sdl_type\n+                    && self.sdl_nlen == other.sdl_nlen\n+                    && self.sdl_alen == other.sdl_alen\n+                    && self.sdl_slen == other.sdl_slen\n+                    && self\n+                    .sdl_data\n+                    .iter()\n+                    .zip(other.sdl_data.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for sockaddr_dl {}\n+        impl ::fmt::Debug for sockaddr_dl {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"sockaddr_dl\")\n+                    .field(\"sdl_len\", &self.sdl_len)\n+                    .field(\"sdl_family\", &self.sdl_family)\n+                    .field(\"sdl_index\", &self.sdl_index)\n+                    .field(\"sdl_type\", &self.sdl_type)\n+                    .field(\"sdl_nlen\", &self.sdl_nlen)\n+                    .field(\"sdl_alen\", &self.sdl_alen)\n+                    .field(\"sdl_slen\", &self.sdl_slen)\n+                    // FIXME: .field(\"sdl_data\", &self.sdl_data)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for sockaddr_dl {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.sdl_len.hash(state);\n+                self.sdl_family.hash(state);\n+                self.sdl_index.hash(state);\n+                self.sdl_type.hash(state);\n+                self.sdl_nlen.hash(state);\n+                self.sdl_alen.hash(state);\n+                self.sdl_slen.hash(state);\n+                self.sdl_data.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for mq_attr {\n+            fn eq(&self, other: &mq_attr) -> bool {\n+                self.mq_flags == other.mq_flags &&\n+                self.mq_maxmsg == other.mq_maxmsg &&\n+                self.mq_msgsize == other.mq_msgsize &&\n+                self.mq_curmsgs == other.mq_curmsgs\n+            }\n+        }\n+        impl Eq for mq_attr {}\n+        impl ::fmt::Debug for mq_attr {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"mq_attr\")\n+                    .field(\"mq_flags\", &self.mq_flags)\n+                    .field(\"mq_maxmsg\", &self.mq_maxmsg)\n+                    .field(\"mq_msgsize\", &self.mq_msgsize)\n+                    .field(\"mq_curmsgs\", &self.mq_curmsgs)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for mq_attr {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.mq_flags.hash(state);\n+                self.mq_maxmsg.hash(state);\n+                self.mq_msgsize.hash(state);\n+                self.mq_curmsgs.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for sigevent {\n+            fn eq(&self, other: &sigevent) -> bool {\n+                self.sigev_notify == other.sigev_notify\n+                    && self.sigev_signo == other.sigev_signo\n+                    && self.sigev_value == other.sigev_value\n+                    && self.sigev_notify_thread_id\n+                        == other.sigev_notify_thread_id\n+            }\n+        }\n+        impl Eq for sigevent {}\n+        impl ::fmt::Debug for sigevent {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"sigevent\")\n+                    .field(\"sigev_notify\", &self.sigev_notify)\n+                    .field(\"sigev_signo\", &self.sigev_signo)\n+                    .field(\"sigev_value\", &self.sigev_value)\n+                    .field(\"sigev_notify_thread_id\",\n+                           &self.sigev_notify_thread_id)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for sigevent {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.sigev_notify.hash(state);\n+                self.sigev_signo.hash(state);\n+                self.sigev_value.hash(state);\n+                self.sigev_notify_thread_id.hash(state);\n+            }\n+        }\n+    }\n+}\n+\n+pub const SIGEV_THREAD_ID: ::c_int = 4;\n+\n+pub const EXTATTR_NAMESPACE_EMPTY: ::c_int = 0;\n+pub const EXTATTR_NAMESPACE_USER: ::c_int = 1;\n+pub const EXTATTR_NAMESPACE_SYSTEM: ::c_int = 2;\n+\n+pub const RAND_MAX: ::c_int = 0x7fff_fffd;\n+pub const PTHREAD_STACK_MIN: ::size_t = 2048;\n+pub const PTHREAD_MUTEX_ADAPTIVE_NP: ::c_int = 4;\n+pub const SIGSTKSZ: ::size_t = 34816;\n+pub const SF_NODISKIO: ::c_int = 0x00000001;\n+pub const SF_MNOWAIT: ::c_int = 0x00000002;\n+pub const SF_SYNC: ::c_int = 0x00000004;\n+pub const SF_USER_READAHEAD: ::c_int = 0x00000008;\n+pub const SF_NOCACHE: ::c_int = 0x00000010;\n+pub const O_CLOEXEC: ::c_int = 0x00100000;\n+pub const O_DIRECTORY: ::c_int = 0x00020000;\n+pub const O_EXEC: ::c_int = 0x00040000;\n+pub const O_TTY_INIT: ::c_int = 0x00080000;\n+pub const F_GETLK: ::c_int = 11;\n+pub const F_SETLK: ::c_int = 12;\n+pub const F_SETLKW: ::c_int = 13;\n+pub const ENOTCAPABLE: ::c_int = 93;\n+pub const ECAPMODE: ::c_int = 94;\n+pub const ENOTRECOVERABLE: ::c_int = 95;\n+pub const EOWNERDEAD: ::c_int = 96;\n+pub const RLIMIT_NPTS: ::c_int = 11;\n+pub const RLIMIT_SWAP: ::c_int = 12;\n+pub const RLIMIT_KQUEUES: ::c_int = 13;\n+pub const RLIMIT_UMTXP: ::c_int = 14;\n+#[deprecated(since = \"0.2.64\", note = \"Not stable across OS versions\")]\n+pub const RLIM_NLIMITS: ::rlim_t = 15;\n+\n+pub const Q_GETQUOTA: ::c_int = 0x700;\n+pub const Q_SETQUOTA: ::c_int = 0x800;\n+\n+pub const POSIX_FADV_NORMAL: ::c_int = 0;\n+pub const POSIX_FADV_RANDOM: ::c_int = 1;\n+pub const POSIX_FADV_SEQUENTIAL: ::c_int = 2;\n+pub const POSIX_FADV_WILLNEED: ::c_int = 3;\n+pub const POSIX_FADV_DONTNEED: ::c_int = 4;\n+pub const POSIX_FADV_NOREUSE: ::c_int = 5;\n+\n+pub const POLLINIGNEOF: ::c_short = 0x2000;\n+\n+pub const EVFILT_READ: i16 = -1;\n+pub const EVFILT_WRITE: i16 = -2;\n+pub const EVFILT_AIO: i16 = -3;\n+pub const EVFILT_VNODE: i16 = -4;\n+pub const EVFILT_PROC: i16 = -5;\n+pub const EVFILT_SIGNAL: i16 = -6;\n+pub const EVFILT_TIMER: i16 = -7;\n+pub const EVFILT_PROCDESC: i16 = -8;\n+pub const EVFILT_FS: i16 = -9;\n+pub const EVFILT_LIO: i16 = -10;\n+pub const EVFILT_USER: i16 = -11;\n+pub const EVFILT_SENDFILE: i16 = -12;\n+pub const EVFILT_EMPTY: i16 = -13;\n+\n+pub const EV_ADD: u16 = 0x1;\n+pub const EV_DELETE: u16 = 0x2;\n+pub const EV_ENABLE: u16 = 0x4;\n+pub const EV_DISABLE: u16 = 0x8;\n+pub const EV_ONESHOT: u16 = 0x10;\n+pub const EV_CLEAR: u16 = 0x20;\n+pub const EV_RECEIPT: u16 = 0x40;\n+pub const EV_DISPATCH: u16 = 0x80;\n+pub const EV_DROP: u16 = 0x1000;\n+pub const EV_FLAG1: u16 = 0x2000;\n+pub const EV_ERROR: u16 = 0x4000;\n+pub const EV_EOF: u16 = 0x8000;\n+pub const EV_SYSFLAGS: u16 = 0xf000;\n+\n+pub const NOTE_TRIGGER: u32 = 0x01000000;\n+pub const NOTE_FFNOP: u32 = 0x00000000;\n+pub const NOTE_FFAND: u32 = 0x40000000;\n+pub const NOTE_FFOR: u32 = 0x80000000;\n+pub const NOTE_FFCOPY: u32 = 0xc0000000;\n+pub const NOTE_FFCTRLMASK: u32 = 0xc0000000;\n+pub const NOTE_FFLAGSMASK: u32 = 0x00ffffff;\n+pub const NOTE_LOWAT: u32 = 0x00000001;\n+pub const NOTE_DELETE: u32 = 0x00000001;\n+pub const NOTE_WRITE: u32 = 0x00000002;\n+pub const NOTE_EXTEND: u32 = 0x00000004;\n+pub const NOTE_ATTRIB: u32 = 0x00000008;\n+pub const NOTE_LINK: u32 = 0x00000010;\n+pub const NOTE_RENAME: u32 = 0x00000020;\n+pub const NOTE_REVOKE: u32 = 0x00000040;\n+pub const NOTE_EXIT: u32 = 0x80000000;\n+pub const NOTE_FORK: u32 = 0x40000000;\n+pub const NOTE_EXEC: u32 = 0x20000000;\n+pub const NOTE_PDATAMASK: u32 = 0x000fffff;\n+pub const NOTE_PCTRLMASK: u32 = 0xf0000000;\n+pub const NOTE_TRACK: u32 = 0x00000001;\n+pub const NOTE_TRACKERR: u32 = 0x00000002;\n+pub const NOTE_CHILD: u32 = 0x00000004;\n+pub const NOTE_SECONDS: u32 = 0x00000001;\n+pub const NOTE_MSECONDS: u32 = 0x00000002;\n+pub const NOTE_USECONDS: u32 = 0x00000004;\n+pub const NOTE_NSECONDS: u32 = 0x00000008;\n+\n+pub const MADV_PROTECT: ::c_int = 10;\n+pub const RUSAGE_THREAD: ::c_int = 1;\n+\n+pub const CLOCK_REALTIME: ::clockid_t = 0;\n+pub const CLOCK_VIRTUAL: ::clockid_t = 1;\n+pub const CLOCK_PROF: ::clockid_t = 2;\n+pub const CLOCK_MONOTONIC: ::clockid_t = 4;\n+pub const CLOCK_UPTIME: ::clockid_t = 5;\n+pub const CLOCK_UPTIME_PRECISE: ::clockid_t = 7;\n+pub const CLOCK_UPTIME_FAST: ::clockid_t = 8;\n+pub const CLOCK_REALTIME_PRECISE: ::clockid_t = 9;\n+pub const CLOCK_REALTIME_FAST: ::clockid_t = 10;\n+pub const CLOCK_MONOTONIC_PRECISE: ::clockid_t = 11;\n+pub const CLOCK_MONOTONIC_FAST: ::clockid_t = 12;\n+pub const CLOCK_SECOND: ::clockid_t = 13;\n+pub const CLOCK_THREAD_CPUTIME_ID: ::clockid_t = 14;\n+pub const CLOCK_PROCESS_CPUTIME_ID: ::clockid_t = 15;\n+\n+pub const CTL_UNSPEC: ::c_int = 0;\n+pub const CTL_KERN: ::c_int = 1;\n+pub const CTL_VM: ::c_int = 2;\n+pub const CTL_VFS: ::c_int = 3;\n+pub const CTL_NET: ::c_int = 4;\n+pub const CTL_DEBUG: ::c_int = 5;\n+pub const CTL_HW: ::c_int = 6;\n+pub const CTL_MACHDEP: ::c_int = 7;\n+pub const CTL_USER: ::c_int = 8;\n+pub const CTL_P1003_1B: ::c_int = 9;\n+pub const KERN_OSTYPE: ::c_int = 1;\n+pub const KERN_OSRELEASE: ::c_int = 2;\n+pub const KERN_OSREV: ::c_int = 3;\n+pub const KERN_VERSION: ::c_int = 4;\n+pub const KERN_MAXVNODES: ::c_int = 5;\n+pub const KERN_MAXPROC: ::c_int = 6;\n+pub const KERN_MAXFILES: ::c_int = 7;\n+pub const KERN_ARGMAX: ::c_int = 8;\n+pub const KERN_SECURELVL: ::c_int = 9;\n+pub const KERN_HOSTNAME: ::c_int = 10;\n+pub const KERN_HOSTID: ::c_int = 11;\n+pub const KERN_CLOCKRATE: ::c_int = 12;\n+pub const KERN_VNODE: ::c_int = 13;\n+pub const KERN_PROC: ::c_int = 14;\n+pub const KERN_FILE: ::c_int = 15;\n+pub const KERN_PROF: ::c_int = 16;\n+pub const KERN_POSIX1: ::c_int = 17;\n+pub const KERN_NGROUPS: ::c_int = 18;\n+pub const KERN_JOB_CONTROL: ::c_int = 19;\n+pub const KERN_SAVED_IDS: ::c_int = 20;\n+pub const KERN_BOOTTIME: ::c_int = 21;\n+pub const KERN_NISDOMAINNAME: ::c_int = 22;\n+pub const KERN_UPDATEINTERVAL: ::c_int = 23;\n+pub const KERN_OSRELDATE: ::c_int = 24;\n+pub const KERN_NTP_PLL: ::c_int = 25;\n+pub const KERN_BOOTFILE: ::c_int = 26;\n+pub const KERN_MAXFILESPERPROC: ::c_int = 27;\n+pub const KERN_MAXPROCPERUID: ::c_int = 28;\n+pub const KERN_DUMPDEV: ::c_int = 29;\n+pub const KERN_IPC: ::c_int = 30;\n+pub const KERN_DUMMY: ::c_int = 31;\n+pub const KERN_PS_STRINGS: ::c_int = 32;\n+pub const KERN_USRSTACK: ::c_int = 33;\n+pub const KERN_LOGSIGEXIT: ::c_int = 34;\n+pub const KERN_IOV_MAX: ::c_int = 35;\n+pub const KERN_HOSTUUID: ::c_int = 36;\n+pub const KERN_ARND: ::c_int = 37;\n+pub const KERN_PROC_ALL: ::c_int = 0;\n+pub const KERN_PROC_PID: ::c_int = 1;\n+pub const KERN_PROC_PGRP: ::c_int = 2;\n+pub const KERN_PROC_SESSION: ::c_int = 3;\n+pub const KERN_PROC_TTY: ::c_int = 4;\n+pub const KERN_PROC_UID: ::c_int = 5;\n+pub const KERN_PROC_RUID: ::c_int = 6;\n+pub const KERN_PROC_ARGS: ::c_int = 7;\n+pub const KERN_PROC_PROC: ::c_int = 8;\n+pub const KERN_PROC_SV_NAME: ::c_int = 9;\n+pub const KERN_PROC_RGID: ::c_int = 10;\n+pub const KERN_PROC_GID: ::c_int = 11;\n+pub const KERN_PROC_PATHNAME: ::c_int = 12;\n+pub const KERN_PROC_OVMMAP: ::c_int = 13;\n+pub const KERN_PROC_OFILEDESC: ::c_int = 14;\n+pub const KERN_PROC_KSTACK: ::c_int = 15;\n+pub const KERN_PROC_INC_THREAD: ::c_int = 0x10;\n+pub const KERN_PROC_VMMAP: ::c_int = 32;\n+pub const KERN_PROC_FILEDESC: ::c_int = 33;\n+pub const KERN_PROC_GROUPS: ::c_int = 34;\n+pub const KERN_PROC_ENV: ::c_int = 35;\n+pub const KERN_PROC_AUXV: ::c_int = 36;\n+pub const KERN_PROC_RLIMIT: ::c_int = 37;\n+pub const KERN_PROC_PS_STRINGS: ::c_int = 38;\n+pub const KERN_PROC_UMASK: ::c_int = 39;\n+pub const KERN_PROC_OSREL: ::c_int = 40;\n+pub const KERN_PROC_SIGTRAMP: ::c_int = 41;\n+pub const KIPC_MAXSOCKBUF: ::c_int = 1;\n+pub const KIPC_SOCKBUF_WASTE: ::c_int = 2;\n+pub const KIPC_SOMAXCONN: ::c_int = 3;\n+pub const KIPC_MAX_LINKHDR: ::c_int = 4;\n+pub const KIPC_MAX_PROTOHDR: ::c_int = 5;\n+pub const KIPC_MAX_HDR: ::c_int = 6;\n+pub const KIPC_MAX_DATALEN: ::c_int = 7;\n+pub const HW_MACHINE: ::c_int = 1;\n+pub const HW_MODEL: ::c_int = 2;\n+pub const HW_NCPU: ::c_int = 3;\n+pub const HW_BYTEORDER: ::c_int = 4;\n+pub const HW_PHYSMEM: ::c_int = 5;\n+pub const HW_USERMEM: ::c_int = 6;\n+pub const HW_PAGESIZE: ::c_int = 7;\n+pub const HW_DISKNAMES: ::c_int = 8;\n+pub const HW_DISKSTATS: ::c_int = 9;\n+pub const HW_FLOATINGPT: ::c_int = 10;\n+pub const HW_MACHINE_ARCH: ::c_int = 11;\n+pub const HW_REALMEM: ::c_int = 12;\n+pub const USER_CS_PATH: ::c_int = 1;\n+pub const USER_BC_BASE_MAX: ::c_int = 2;\n+pub const USER_BC_DIM_MAX: ::c_int = 3;\n+pub const USER_BC_SCALE_MAX: ::c_int = 4;\n+pub const USER_BC_STRING_MAX: ::c_int = 5;\n+pub const USER_COLL_WEIGHTS_MAX: ::c_int = 6;\n+pub const USER_EXPR_NEST_MAX: ::c_int = 7;\n+pub const USER_LINE_MAX: ::c_int = 8;\n+pub const USER_RE_DUP_MAX: ::c_int = 9;\n+pub const USER_POSIX2_VERSION: ::c_int = 10;\n+pub const USER_POSIX2_C_BIND: ::c_int = 11;\n+pub const USER_POSIX2_C_DEV: ::c_int = 12;\n+pub const USER_POSIX2_CHAR_TERM: ::c_int = 13;\n+pub const USER_POSIX2_FORT_DEV: ::c_int = 14;\n+pub const USER_POSIX2_FORT_RUN: ::c_int = 15;\n+pub const USER_POSIX2_LOCALEDEF: ::c_int = 16;\n+pub const USER_POSIX2_SW_DEV: ::c_int = 17;\n+pub const USER_POSIX2_UPE: ::c_int = 18;\n+pub const USER_STREAM_MAX: ::c_int = 19;\n+pub const USER_TZNAME_MAX: ::c_int = 20;\n+pub const CTL_P1003_1B_ASYNCHRONOUS_IO: ::c_int = 1;\n+pub const CTL_P1003_1B_MAPPED_FILES: ::c_int = 2;\n+pub const CTL_P1003_1B_MEMLOCK: ::c_int = 3;\n+pub const CTL_P1003_1B_MEMLOCK_RANGE: ::c_int = 4;\n+pub const CTL_P1003_1B_MEMORY_PROTECTION: ::c_int = 5;\n+pub const CTL_P1003_1B_MESSAGE_PASSING: ::c_int = 6;\n+pub const CTL_P1003_1B_PRIORITIZED_IO: ::c_int = 7;\n+pub const CTL_P1003_1B_PRIORITY_SCHEDULING: ::c_int = 8;\n+pub const CTL_P1003_1B_REALTIME_SIGNALS: ::c_int = 9;\n+pub const CTL_P1003_1B_SEMAPHORES: ::c_int = 10;\n+pub const CTL_P1003_1B_FSYNC: ::c_int = 11;\n+pub const CTL_P1003_1B_SHARED_MEMORY_OBJECTS: ::c_int = 12;\n+pub const CTL_P1003_1B_SYNCHRONIZED_IO: ::c_int = 13;\n+pub const CTL_P1003_1B_TIMERS: ::c_int = 14;\n+pub const CTL_P1003_1B_AIO_LISTIO_MAX: ::c_int = 15;\n+pub const CTL_P1003_1B_AIO_MAX: ::c_int = 16;\n+pub const CTL_P1003_1B_AIO_PRIO_DELTA_MAX: ::c_int = 17;\n+pub const CTL_P1003_1B_DELAYTIMER_MAX: ::c_int = 18;\n+pub const CTL_P1003_1B_MQ_OPEN_MAX: ::c_int = 19;\n+pub const CTL_P1003_1B_PAGESIZE: ::c_int = 20;\n+pub const CTL_P1003_1B_RTSIG_MAX: ::c_int = 21;\n+pub const CTL_P1003_1B_SEM_NSEMS_MAX: ::c_int = 22;\n+pub const CTL_P1003_1B_SEM_VALUE_MAX: ::c_int = 23;\n+pub const CTL_P1003_1B_SIGQUEUE_MAX: ::c_int = 24;\n+pub const CTL_P1003_1B_TIMER_MAX: ::c_int = 25;\n+pub const TIOCGPTN: ::c_uint = 0x4004740f;\n+pub const TIOCPTMASTER: ::c_uint = 0x2000741c;\n+pub const TIOCSIG: ::c_uint = 0x2004745f;\n+pub const TIOCM_DCD: ::c_int = 0x40;\n+pub const H4DISC: ::c_int = 0x7;\n+\n+pub const BIOCSETFNR: ::c_ulong = 0x80104282;\n+\n+pub const FIONWRITE: ::c_ulong = 0x40046677;\n+pub const FIONSPACE: ::c_ulong = 0x40046676;\n+pub const FIOSEEKDATA: ::c_ulong = 0xc0086661;\n+pub const FIOSEEKHOLE: ::c_ulong = 0xc0086662;\n+\n+pub const JAIL_API_VERSION: u32 = 2;\n+pub const JAIL_CREATE: ::c_int = 0x01;\n+pub const JAIL_UPDATE: ::c_int = 0x02;\n+pub const JAIL_ATTACH: ::c_int = 0x04;\n+pub const JAIL_DYING: ::c_int = 0x08;\n+pub const JAIL_SET_MASK: ::c_int = 0x0f;\n+pub const JAIL_GET_MASK: ::c_int = 0x08;\n+pub const JAIL_SYS_DISABLE: ::c_int = 0;\n+pub const JAIL_SYS_NEW: ::c_int = 1;\n+pub const JAIL_SYS_INHERIT: ::c_int = 2;\n+\n+pub const SO_BINTIME: ::c_int = 0x2000;\n+pub const SO_NO_OFFLOAD: ::c_int = 0x4000;\n+pub const SO_NO_DDP: ::c_int = 0x8000;\n+pub const SO_REUSEPORT_LB: ::c_int = 0x10000;\n+pub const SO_LABEL: ::c_int = 0x1009;\n+pub const SO_PEERLABEL: ::c_int = 0x1010;\n+pub const SO_LISTENQLIMIT: ::c_int = 0x1011;\n+pub const SO_LISTENQLEN: ::c_int = 0x1012;\n+pub const SO_LISTENINCQLEN: ::c_int = 0x1013;\n+pub const SO_SETFIB: ::c_int = 0x1014;\n+pub const SO_USER_COOKIE: ::c_int = 0x1015;\n+pub const SO_PROTOCOL: ::c_int = 0x1016;\n+pub const SO_PROTOTYPE: ::c_int = SO_PROTOCOL;\n+pub const SO_VENDOR: ::c_int = 0x80000000;\n+\n+pub const LOCAL_PEERCRED: ::c_int = 1;\n+pub const LOCAL_CREDS: ::c_int = 2;\n+pub const LOCAL_CONNWAIT: ::c_int = 4;\n+pub const LOCAL_VENDOR: ::c_int = SO_VENDOR;\n+\n+pub const PT_LWPINFO: ::c_int = 13;\n+pub const PT_GETNUMLWPS: ::c_int = 14;\n+pub const PT_GETLWPLIST: ::c_int = 15;\n+pub const PT_CLEARSTEP: ::c_int = 16;\n+pub const PT_SETSTEP: ::c_int = 17;\n+pub const PT_SUSPEND: ::c_int = 18;\n+pub const PT_RESUME: ::c_int = 19;\n+pub const PT_TO_SCE: ::c_int = 20;\n+pub const PT_TO_SCX: ::c_int = 21;\n+pub const PT_SYSCALL: ::c_int = 22;\n+pub const PT_FOLLOW_FORK: ::c_int = 23;\n+pub const PT_LWP_EVENTS: ::c_int = 24;\n+pub const PT_GET_EVENT_MASK: ::c_int = 25;\n+pub const PT_SET_EVENT_MASK: ::c_int = 26;\n+pub const PT_GETREGS: ::c_int = 33;\n+pub const PT_SETREGS: ::c_int = 34;\n+pub const PT_GETFPREGS: ::c_int = 35;\n+pub const PT_SETFPREGS: ::c_int = 36;\n+pub const PT_GETDBREGS: ::c_int = 37;\n+pub const PT_SETDBREGS: ::c_int = 38;\n+pub const PT_VM_TIMESTAMP: ::c_int = 40;\n+pub const PT_VM_ENTRY: ::c_int = 41;\n+pub const PT_FIRSTMACH: ::c_int = 64;\n+\n+pub const PTRACE_EXEC: ::c_int = 0x0001;\n+pub const PTRACE_SCE: ::c_int = 0x0002;\n+pub const PTRACE_SCX: ::c_int = 0x0004;\n+pub const PTRACE_SYSCALL: ::c_int = PTRACE_SCE | PTRACE_SCX;\n+pub const PTRACE_FORK: ::c_int = 0x0008;\n+pub const PTRACE_LWP: ::c_int = 0x0010;\n+pub const PTRACE_VFORK: ::c_int = 0x0020;\n+pub const PTRACE_DEFAULT: ::c_int = PTRACE_EXEC;\n+\n+pub const AF_SLOW: ::c_int = 33;\n+pub const AF_SCLUSTER: ::c_int = 34;\n+pub const AF_ARP: ::c_int = 35;\n+pub const AF_BLUETOOTH: ::c_int = 36;\n+pub const AF_IEEE80211: ::c_int = 37;\n+pub const AF_INET_SDP: ::c_int = 40;\n+pub const AF_INET6_SDP: ::c_int = 42;\n+\n+// https://github.com/freebsd/freebsd/blob/master/sys/net/if.h#L140\n+pub const IFF_UP: ::c_int = 0x1; // (n) interface is up\n+pub const IFF_BROADCAST: ::c_int = 0x2; // (i) broadcast address valid\n+pub const IFF_DEBUG: ::c_int = 0x4; // (n) turn on debugging\n+pub const IFF_LOOPBACK: ::c_int = 0x8; // (i) is a loopback net\n+pub const IFF_POINTOPOINT: ::c_int = 0x10; // (i) is a point-to-point link\n+                                           // 0x20           was IFF_SMART\n+pub const IFF_RUNNING: ::c_int = 0x40; // (d) resources allocated\n+#[doc(hidden)]\n+#[deprecated(\n+    since = \"0.2.54\",\n+    note = \"IFF_DRV_RUNNING is deprecated. Use the portable IFF_RUNNING instead\"\n+)]\n+pub const IFF_DRV_RUNNING: ::c_int = 0x40;\n+pub const IFF_NOARP: ::c_int = 0x80; // (n) no address resolution protocol\n+pub const IFF_PROMISC: ::c_int = 0x100; // (n) receive all packets\n+pub const IFF_ALLMULTI: ::c_int = 0x200; // (n) receive all multicast packets\n+pub const IFF_OACTIVE: ::c_int = 0x400; // (d) tx hardware queue is full\n+#[doc(hidden)]\n+#[deprecated(\n+    since = \"0.2.54\",\n+    note = \"Use the portable `IFF_OACTIVE` instead\"\n+)]\n+pub const IFF_DRV_OACTIVE: ::c_int = 0x400;\n+pub const IFF_SIMPLEX: ::c_int = 0x800; // (i) can't hear own transmissions\n+pub const IFF_LINK0: ::c_int = 0x1000; // per link layer defined bit\n+pub const IFF_LINK1: ::c_int = 0x2000; // per link layer defined bit\n+pub const IFF_LINK2: ::c_int = 0x4000; // per link layer defined bit\n+pub const IFF_ALTPHYS: ::c_int = IFF_LINK2; // use alternate physical connection\n+pub const IFF_MULTICAST: ::c_int = 0x8000; // (i) supports multicast\n+                                           // (i) unconfigurable using ioctl(2)\n+pub const IFF_CANTCONFIG: ::c_int = 0x10000;\n+pub const IFF_PPROMISC: ::c_int = 0x20000; // (n) user-requested promisc mode\n+pub const IFF_MONITOR: ::c_int = 0x40000; // (n) user-requested monitor mode\n+pub const IFF_STATICARP: ::c_int = 0x80000; // (n) static ARP\n+pub const IFF_DYING: ::c_int = 0x200000; // (n) interface is winding down\n+pub const IFF_RENAMING: ::c_int = 0x400000; // (n) interface is being renamed\n+\n+// sys/netinet/in.h\n+// Protocols (RFC 1700)\n+// NOTE: These are in addition to the constants defined in src/unix/mod.rs\n+\n+// IPPROTO_IP defined in src/unix/mod.rs\n+/// IP6 hop-by-hop options\n+pub const IPPROTO_HOPOPTS: ::c_int = 0;\n+// IPPROTO_ICMP defined in src/unix/mod.rs\n+/// group mgmt protocol\n+pub const IPPROTO_IGMP: ::c_int = 2;\n+/// gateway^2 (deprecated)\n+pub const IPPROTO_GGP: ::c_int = 3;\n+/// for compatibility\n+pub const IPPROTO_IPIP: ::c_int = 4;\n+// IPPROTO_TCP defined in src/unix/mod.rs\n+/// Stream protocol II.\n+pub const IPPROTO_ST: ::c_int = 7;\n+/// exterior gateway protocol\n+pub const IPPROTO_EGP: ::c_int = 8;\n+/// private interior gateway\n+pub const IPPROTO_PIGP: ::c_int = 9;\n+/// BBN RCC Monitoring\n+pub const IPPROTO_RCCMON: ::c_int = 10;\n+/// network voice protocol\n+pub const IPPROTO_NVPII: ::c_int = 11;\n+/// pup\n+pub const IPPROTO_PUP: ::c_int = 12;\n+/// Argus\n+pub const IPPROTO_ARGUS: ::c_int = 13;\n+/// EMCON\n+pub const IPPROTO_EMCON: ::c_int = 14;\n+/// Cross Net Debugger\n+pub const IPPROTO_XNET: ::c_int = 15;\n+/// Chaos\n+pub const IPPROTO_CHAOS: ::c_int = 16;\n+// IPPROTO_UDP defined in src/unix/mod.rs\n+/// Multiplexing\n+pub const IPPROTO_MUX: ::c_int = 18;\n+/// DCN Measurement Subsystems\n+pub const IPPROTO_MEAS: ::c_int = 19;\n+/// Host Monitoring\n+pub const IPPROTO_HMP: ::c_int = 20;\n+/// Packet Radio Measurement\n+pub const IPPROTO_PRM: ::c_int = 21;\n+/// xns idp\n+pub const IPPROTO_IDP: ::c_int = 22;\n+/// Trunk-1\n+pub const IPPROTO_TRUNK1: ::c_int = 23;\n+/// Trunk-2\n+pub const IPPROTO_TRUNK2: ::c_int = 24;\n+/// Leaf-1\n+pub const IPPROTO_LEAF1: ::c_int = 25;\n+/// Leaf-2\n+pub const IPPROTO_LEAF2: ::c_int = 26;\n+/// Reliable Data\n+pub const IPPROTO_RDP: ::c_int = 27;\n+/// Reliable Transaction\n+pub const IPPROTO_IRTP: ::c_int = 28;\n+/// tp-4 w/ class negotiation\n+pub const IPPROTO_TP: ::c_int = 29;\n+/// Bulk Data Transfer\n+pub const IPPROTO_BLT: ::c_int = 30;\n+/// Network Services\n+pub const IPPROTO_NSP: ::c_int = 31;\n+/// Merit Internodal\n+pub const IPPROTO_INP: ::c_int = 32;\n+/// Sequential Exchange\n+pub const IPPROTO_SEP: ::c_int = 33;\n+/// Third Party Connect\n+pub const IPPROTO_3PC: ::c_int = 34;\n+/// InterDomain Policy Routing\n+pub const IPPROTO_IDPR: ::c_int = 35;\n+/// XTP\n+pub const IPPROTO_XTP: ::c_int = 36;\n+/// Datagram Delivery\n+pub const IPPROTO_DDP: ::c_int = 37;\n+/// Control Message Transport\n+pub const IPPROTO_CMTP: ::c_int = 38;\n+/// TP++ Transport\n+pub const IPPROTO_TPXX: ::c_int = 39;\n+/// IL transport protocol\n+pub const IPPROTO_IL: ::c_int = 40;\n+// IPPROTO_IPV6 defined in src/unix/mod.rs\n+/// Source Demand Routing\n+pub const IPPROTO_SDRP: ::c_int = 42;\n+/// IP6 routing header\n+pub const IPPROTO_ROUTING: ::c_int = 43;\n+/// IP6 fragmentation header\n+pub const IPPROTO_FRAGMENT: ::c_int = 44;\n+/// InterDomain Routing\n+pub const IPPROTO_IDRP: ::c_int = 45;\n+/// resource reservation\n+pub const IPPROTO_RSVP: ::c_int = 46;\n+/// General Routing Encap.\n+pub const IPPROTO_GRE: ::c_int = 47;\n+/// Mobile Host Routing\n+pub const IPPROTO_MHRP: ::c_int = 48;\n+/// BHA\n+pub const IPPROTO_BHA: ::c_int = 49;\n+/// IP6 Encap Sec. Payload\n+pub const IPPROTO_ESP: ::c_int = 50;\n+/// IP6 Auth Header\n+pub const IPPROTO_AH: ::c_int = 51;\n+/// Integ. Net Layer Security\n+pub const IPPROTO_INLSP: ::c_int = 52;\n+/// IP with encryption\n+pub const IPPROTO_SWIPE: ::c_int = 53;\n+/// Next Hop Resolution\n+pub const IPPROTO_NHRP: ::c_int = 54;\n+/// IP Mobility\n+pub const IPPROTO_MOBILE: ::c_int = 55;\n+/// Transport Layer Security\n+pub const IPPROTO_TLSP: ::c_int = 56;\n+/// SKIP\n+pub const IPPROTO_SKIP: ::c_int = 57;\n+// IPPROTO_ICMPV6 defined in src/unix/mod.rs\n+/// IP6 no next header\n+pub const IPPROTO_NONE: ::c_int = 59;\n+/// IP6 destination option\n+pub const IPPROTO_DSTOPTS: ::c_int = 60;\n+/// any host internal protocol\n+pub const IPPROTO_AHIP: ::c_int = 61;\n+/// CFTP\n+pub const IPPROTO_CFTP: ::c_int = 62;\n+/// \"hello\" routing protocol\n+pub const IPPROTO_HELLO: ::c_int = 63;\n+/// SATNET/Backroom EXPAK\n+pub const IPPROTO_SATEXPAK: ::c_int = 64;\n+/// Kryptolan\n+pub const IPPROTO_KRYPTOLAN: ::c_int = 65;\n+/// Remote Virtual Disk\n+pub const IPPROTO_RVD: ::c_int = 66;\n+/// Pluribus Packet Core\n+pub const IPPROTO_IPPC: ::c_int = 67;\n+/// Any distributed FS\n+pub const IPPROTO_ADFS: ::c_int = 68;\n+/// Satnet Monitoring\n+pub const IPPROTO_SATMON: ::c_int = 69;\n+/// VISA Protocol\n+pub const IPPROTO_VISA: ::c_int = 70;\n+/// Packet Core Utility\n+pub const IPPROTO_IPCV: ::c_int = 71;\n+/// Comp. Prot. Net. Executive\n+pub const IPPROTO_CPNX: ::c_int = 72;\n+/// Comp. Prot. HeartBeat\n+pub const IPPROTO_CPHB: ::c_int = 73;\n+/// Wang Span Network\n+pub const IPPROTO_WSN: ::c_int = 74;\n+/// Packet Video Protocol\n+pub const IPPROTO_PVP: ::c_int = 75;\n+/// BackRoom SATNET Monitoring\n+pub const IPPROTO_BRSATMON: ::c_int = 76;\n+/// Sun net disk proto (temp.)\n+pub const IPPROTO_ND: ::c_int = 77;\n+/// WIDEBAND Monitoring\n+pub const IPPROTO_WBMON: ::c_int = 78;\n+/// WIDEBAND EXPAK\n+pub const IPPROTO_WBEXPAK: ::c_int = 79;\n+/// ISO cnlp\n+pub const IPPROTO_EON: ::c_int = 80;\n+/// VMTP\n+pub const IPPROTO_VMTP: ::c_int = 81;\n+/// Secure VMTP\n+pub const IPPROTO_SVMTP: ::c_int = 82;\n+/// Banyon VINES\n+pub const IPPROTO_VINES: ::c_int = 83;\n+/// TTP\n+pub const IPPROTO_TTP: ::c_int = 84;\n+/// NSFNET-IGP\n+pub const IPPROTO_IGP: ::c_int = 85;\n+/// dissimilar gateway prot.\n+pub const IPPROTO_DGP: ::c_int = 86;\n+/// TCF\n+pub const IPPROTO_TCF: ::c_int = 87;\n+/// Cisco/GXS IGRP\n+pub const IPPROTO_IGRP: ::c_int = 88;\n+/// OSPFIGP\n+pub const IPPROTO_OSPFIGP: ::c_int = 89;\n+/// Strite RPC protocol\n+pub const IPPROTO_SRPC: ::c_int = 90;\n+/// Locus Address Resoloution\n+pub const IPPROTO_LARP: ::c_int = 91;\n+/// Multicast Transport\n+pub const IPPROTO_MTP: ::c_int = 92;\n+/// AX.25 Frames\n+pub const IPPROTO_AX25: ::c_int = 93;\n+/// IP encapsulated in IP\n+pub const IPPROTO_IPEIP: ::c_int = 94;\n+/// Mobile Int.ing control\n+pub const IPPROTO_MICP: ::c_int = 95;\n+/// Semaphore Comm. security\n+pub const IPPROTO_SCCSP: ::c_int = 96;\n+/// Ethernet IP encapsulation\n+pub const IPPROTO_ETHERIP: ::c_int = 97;\n+/// encapsulation header\n+pub const IPPROTO_ENCAP: ::c_int = 98;\n+/// any private encr. scheme\n+pub const IPPROTO_APES: ::c_int = 99;\n+/// GMTP\n+pub const IPPROTO_GMTP: ::c_int = 100;\n+/// payload compression (IPComp)\n+pub const IPPROTO_IPCOMP: ::c_int = 108;\n+/// SCTP\n+pub const IPPROTO_SCTP: ::c_int = 132;\n+/// IPv6 Mobility Header\n+pub const IPPROTO_MH: ::c_int = 135;\n+/// UDP-Lite\n+pub const IPPROTO_UDPLITE: ::c_int = 136;\n+/// IP6 Host Identity Protocol\n+pub const IPPROTO_HIP: ::c_int = 139;\n+/// IP6 Shim6 Protocol\n+pub const IPPROTO_SHIM6: ::c_int = 140;\n+\n+/* 101-254: Partly Unassigned */\n+/// Protocol Independent Mcast\n+pub const IPPROTO_PIM: ::c_int = 103;\n+/// CARP\n+pub const IPPROTO_CARP: ::c_int = 112;\n+/// PGM\n+pub const IPPROTO_PGM: ::c_int = 113;\n+/// MPLS-in-IP\n+pub const IPPROTO_MPLS: ::c_int = 137;\n+/// PFSYNC\n+pub const IPPROTO_PFSYNC: ::c_int = 240;\n+\n+/* 255: Reserved */\n+/* BSD Private, local use, namespace incursion, no longer used */\n+/// OLD divert pseudo-proto\n+pub const IPPROTO_OLD_DIVERT: ::c_int = 254;\n+pub const IPPROTO_MAX: ::c_int = 256;\n+/// last return value of *_input(), meaning \"all job for this pkt is done\".\n+pub const IPPROTO_DONE: ::c_int = 257;\n+\n+/* Only used internally, so can be outside the range of valid IP protocols. */\n+/// divert pseudo-protocol\n+pub const IPPROTO_DIVERT: ::c_int = 258;\n+/// SeND pseudo-protocol\n+pub const IPPROTO_SEND: ::c_int = 259;\n+\n+// sys/netinet/TCP.h\n+pub const TCP_MD5SIG: ::c_int = 16;\n+pub const TCP_INFO: ::c_int = 32;\n+pub const TCP_CONGESTION: ::c_int = 64;\n+pub const TCP_CCALGOOPT: ::c_int = 65;\n+pub const TCP_KEEPINIT: ::c_int = 128;\n+pub const TCP_FASTOPEN: ::c_int = 1025;\n+pub const TCP_PCAP_OUT: ::c_int = 2048;\n+pub const TCP_PCAP_IN: ::c_int = 4096;\n+\n+pub const IP_BINDANY: ::c_int = 24;\n+pub const IP_BINDMULTI: ::c_int = 25;\n+pub const IP_RSS_LISTEN_BUCKET: ::c_int = 26;\n+pub const IP_ORIGDSTADDR: ::c_int = 27;\n+pub const IP_RECVORIGDSTADDR: ::c_int = IP_ORIGDSTADDR;\n+\n+pub const IP_RECVTOS: ::c_int = 68;\n+\n+pub const IPV6_ORIGDSTADDR: ::c_int = 72;\n+pub const IPV6_RECVORIGDSTADDR: ::c_int = IPV6_ORIGDSTADDR;\n+\n+pub const PF_SLOW: ::c_int = AF_SLOW;\n+pub const PF_SCLUSTER: ::c_int = AF_SCLUSTER;\n+pub const PF_ARP: ::c_int = AF_ARP;\n+pub const PF_BLUETOOTH: ::c_int = AF_BLUETOOTH;\n+pub const PF_IEEE80211: ::c_int = AF_IEEE80211;\n+pub const PF_INET_SDP: ::c_int = AF_INET_SDP;\n+pub const PF_INET6_SDP: ::c_int = AF_INET6_SDP;\n+\n+pub const NET_RT_DUMP: ::c_int = 1;\n+pub const NET_RT_FLAGS: ::c_int = 2;\n+pub const NET_RT_IFLIST: ::c_int = 3;\n+pub const NET_RT_IFMALIST: ::c_int = 4;\n+pub const NET_RT_IFLISTL: ::c_int = 5;\n+\n+// System V IPC\n+pub const IPC_PRIVATE: ::key_t = 0;\n+pub const IPC_CREAT: ::c_int = 0o1000;\n+pub const IPC_EXCL: ::c_int = 0o2000;\n+pub const IPC_NOWAIT: ::c_int = 0o4000;\n+pub const IPC_RMID: ::c_int = 0;\n+pub const IPC_SET: ::c_int = 1;\n+pub const IPC_STAT: ::c_int = 2;\n+pub const IPC_INFO: ::c_int = 3;\n+pub const IPC_R: ::c_int = 0o400;\n+pub const IPC_W: ::c_int = 0o200;\n+pub const IPC_M: ::c_int = 0o10000;\n+pub const MSG_NOERROR: ::c_int = 0o10000;\n+pub const SHM_RDONLY: ::c_int = 0o10000;\n+pub const SHM_RND: ::c_int = 0o20000;\n+pub const SHM_R: ::c_int = 0o400;\n+pub const SHM_W: ::c_int = 0o200;\n+pub const SHM_LOCK: ::c_int = 11;\n+pub const SHM_UNLOCK: ::c_int = 12;\n+pub const SHM_STAT: ::c_int = 13;\n+pub const SHM_INFO: ::c_int = 14;\n+pub const SHM_ANON: *mut ::c_char = 1 as *mut ::c_char;\n+\n+// The *_MAXID constants never should've been used outside of the\n+// FreeBSD base system.  And with the exception of CTL_P1003_1B_MAXID,\n+// they were all removed in svn r262489.  They remain here for backwards\n+// compatibility only, and are scheduled to be removed in libc 1.0.0.\n+#[doc(hidden)]\n+#[deprecated(since = \"0.2.54\", note = \"Removed in FreeBSD 11\")]\n+pub const CTL_MAXID: ::c_int = 10;\n+#[doc(hidden)]\n+#[deprecated(since = \"0.2.54\", note = \"Removed in FreeBSD 11\")]\n+pub const KERN_MAXID: ::c_int = 38;\n+#[doc(hidden)]\n+#[deprecated(since = \"0.2.54\", note = \"Removed in FreeBSD 11\")]\n+pub const HW_MAXID: ::c_int = 13;\n+#[doc(hidden)]\n+#[deprecated(since = \"0.2.54\", note = \"Removed in FreeBSD 11\")]\n+pub const USER_MAXID: ::c_int = 21;\n+#[doc(hidden)]\n+pub const CTL_P1003_1B_MAXID: ::c_int = 26;\n+\n+pub const MSG_NOTIFICATION: ::c_int = 0x00002000;\n+pub const MSG_NBIO: ::c_int = 0x00004000;\n+pub const MSG_COMPAT: ::c_int = 0x00008000;\n+pub const MSG_CMSG_CLOEXEC: ::c_int = 0x00040000;\n+pub const MSG_NOSIGNAL: ::c_int = 0x20000;\n+\n+// utmpx entry types\n+pub const EMPTY: ::c_short = 0;\n+pub const BOOT_TIME: ::c_short = 1;\n+pub const OLD_TIME: ::c_short = 2;\n+pub const NEW_TIME: ::c_short = 3;\n+pub const USER_PROCESS: ::c_short = 4;\n+pub const INIT_PROCESS: ::c_short = 5;\n+pub const LOGIN_PROCESS: ::c_short = 6;\n+pub const DEAD_PROCESS: ::c_short = 7;\n+pub const SHUTDOWN_TIME: ::c_short = 8;\n+// utmp database types\n+pub const UTXDB_ACTIVE: ::c_int = 0;\n+pub const UTXDB_LASTLOGIN: ::c_int = 1;\n+pub const UTXDB_LOG: ::c_int = 2;\n+\n+pub const LC_COLLATE_MASK: ::c_int = (1 << 0);\n+pub const LC_CTYPE_MASK: ::c_int = (1 << 1);\n+pub const LC_MONETARY_MASK: ::c_int = (1 << 2);\n+pub const LC_NUMERIC_MASK: ::c_int = (1 << 3);\n+pub const LC_TIME_MASK: ::c_int = (1 << 4);\n+pub const LC_MESSAGES_MASK: ::c_int = (1 << 5);\n+pub const LC_ALL_MASK: ::c_int = LC_COLLATE_MASK\n+    | LC_CTYPE_MASK\n+    | LC_MESSAGES_MASK\n+    | LC_MONETARY_MASK\n+    | LC_NUMERIC_MASK\n+    | LC_TIME_MASK;\n+\n+pub const WSTOPPED: ::c_int = 2; // same as WUNTRACED\n+pub const WCONTINUED: ::c_int = 4;\n+pub const WNOWAIT: ::c_int = 8;\n+pub const WEXITED: ::c_int = 16;\n+pub const WTRAPPED: ::c_int = 32;\n+\n+// FreeBSD defines a great many more of these, we only expose the\n+// standardized ones.\n+pub const P_PID: idtype_t = 0;\n+pub const P_PGID: idtype_t = 2;\n+pub const P_ALL: idtype_t = 7;\n+\n+pub const UTIME_OMIT: c_long = -2;\n+pub const UTIME_NOW: c_long = -1;\n+\n+pub const B460800: ::speed_t = 460800;\n+pub const B921600: ::speed_t = 921600;\n+\n+pub const AT_FDCWD: ::c_int = -100;\n+pub const AT_EACCESS: ::c_int = 0x100;\n+pub const AT_SYMLINK_NOFOLLOW: ::c_int = 0x200;\n+pub const AT_SYMLINK_FOLLOW: ::c_int = 0x400;\n+pub const AT_REMOVEDIR: ::c_int = 0x800;\n+\n+pub const TABDLY: ::tcflag_t = 0x00000004;\n+pub const TAB0: ::tcflag_t = 0x00000000;\n+pub const TAB3: ::tcflag_t = 0x00000004;\n+\n+pub const _PC_ACL_NFS4: ::c_int = 64;\n+\n+pub const _SC_CPUSET_SIZE: ::c_int = 122;\n+\n+pub const XU_NGROUPS: ::c_int = 16;\n+pub const XUCRED_VERSION: ::c_uint = 0;\n+\n+// Flags which can be passed to pdfork(2)\n+pub const PD_DAEMON: ::c_int = 0x00000001;\n+pub const PD_CLOEXEC: ::c_int = 0x00000002;\n+pub const PD_ALLOWED_AT_FORK: ::c_int = PD_DAEMON | PD_CLOEXEC;\n+\n+// Values for struct rtprio (type_ field)\n+pub const RTP_PRIO_REALTIME: ::c_ushort = 2;\n+pub const RTP_PRIO_NORMAL: ::c_ushort = 3;\n+pub const RTP_PRIO_IDLE: ::c_ushort = 4;\n+\n+pub const POSIX_SPAWN_RESETIDS: ::c_int = 0x01;\n+pub const POSIX_SPAWN_SETPGROUP: ::c_int = 0x02;\n+pub const POSIX_SPAWN_SETSCHEDPARAM: ::c_int = 0x04;\n+pub const POSIX_SPAWN_SETSCHEDULER: ::c_int = 0x08;\n+pub const POSIX_SPAWN_SETSIGDEF: ::c_int = 0x10;\n+pub const POSIX_SPAWN_SETSIGMASK: ::c_int = 0x20;\n+\n+// Flags for chflags(2)\n+pub const UF_SYSTEM: ::c_ulong = 0x00000080;\n+pub const UF_SPARSE: ::c_ulong = 0x00000100;\n+pub const UF_OFFLINE: ::c_ulong = 0x00000200;\n+pub const UF_REPARSE: ::c_ulong = 0x00000400;\n+pub const UF_ARCHIVE: ::c_ulong = 0x00000800;\n+pub const UF_READONLY: ::c_ulong = 0x00001000;\n+pub const UF_HIDDEN: ::c_ulong = 0x00008000;\n+pub const SF_SNAPSHOT: ::c_ulong = 0x00200000;\n+\n+fn _ALIGN(p: usize) -> usize {\n+    (p + _ALIGNBYTES) & !_ALIGNBYTES\n+}\n+\n+f! {\n+    pub fn CMSG_DATA(cmsg: *const ::cmsghdr) -> *mut ::c_uchar {\n+        (cmsg as *mut ::c_uchar)\n+            .offset(_ALIGN(::mem::size_of::<::cmsghdr>()) as isize)\n+    }\n+\n+    pub fn CMSG_LEN(length: ::c_uint) -> ::c_uint {\n+        _ALIGN(::mem::size_of::<::cmsghdr>()) as ::c_uint + length\n+    }\n+\n+    pub fn CMSG_NXTHDR(mhdr: *const ::msghdr, cmsg: *const ::cmsghdr)\n+        -> *mut ::cmsghdr\n+    {\n+        if cmsg.is_null() {\n+            return ::CMSG_FIRSTHDR(mhdr);\n+        };\n+        let next = cmsg as usize + _ALIGN((*cmsg).cmsg_len as usize)\n+            + _ALIGN(::mem::size_of::<::cmsghdr>());\n+        let max = (*mhdr).msg_control as usize\n+            + (*mhdr).msg_controllen as usize;\n+        if next > max {\n+            0 as *mut ::cmsghdr\n+        } else {\n+            (cmsg as usize + _ALIGN((*cmsg).cmsg_len as usize))\n+                as *mut ::cmsghdr\n+        }\n+    }\n+\n+    pub fn CMSG_SPACE(length: ::c_uint) -> ::c_uint {\n+        (_ALIGN(::mem::size_of::<::cmsghdr>()) + _ALIGN(length as usize))\n+            as ::c_uint\n+    }\n+\n+    pub fn uname(buf: *mut ::utsname) -> ::c_int {\n+        __xuname(256, buf as *mut ::c_void)\n+    }\n+}\n+\n+extern \"C\" {\n+    pub fn __error() -> *mut ::c_int;\n+\n+    pub fn clock_getres(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;\n+    pub fn clock_gettime(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;\n+    pub fn clock_settime(\n+        clk_id: ::clockid_t,\n+        tp: *const ::timespec,\n+    ) -> ::c_int;\n+\n+    pub fn extattr_delete_fd(\n+        fd: ::c_int,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+    ) -> ::c_int;\n+    pub fn extattr_delete_file(\n+        path: *const ::c_char,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+    ) -> ::c_int;\n+    pub fn extattr_delete_link(\n+        path: *const ::c_char,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+    ) -> ::c_int;\n+    pub fn extattr_get_fd(\n+        fd: ::c_int,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+        data: *mut ::c_void,\n+        nbytes: ::size_t,\n+    ) -> ::ssize_t;\n+    pub fn extattr_get_file(\n+        path: *const ::c_char,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+        data: *mut ::c_void,\n+        nbytes: ::size_t,\n+    ) -> ::ssize_t;\n+    pub fn extattr_get_link(\n+        path: *const ::c_char,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+        data: *mut ::c_void,\n+        nbytes: ::size_t,\n+    ) -> ::ssize_t;\n+    pub fn extattr_list_fd(\n+        fd: ::c_int,\n+        attrnamespace: ::c_int,\n+        data: *mut ::c_void,\n+        nbytes: ::size_t,\n+    ) -> ::ssize_t;\n+    pub fn extattr_list_file(\n+        path: *const ::c_char,\n+        attrnamespace: ::c_int,\n+        data: *mut ::c_void,\n+        nbytes: ::size_t,\n+    ) -> ::ssize_t;\n+    pub fn extattr_list_link(\n+        path: *const ::c_char,\n+        attrnamespace: ::c_int,\n+        data: *mut ::c_void,\n+        nbytes: ::size_t,\n+    ) -> ::ssize_t;\n+    pub fn extattr_set_fd(\n+        fd: ::c_int,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+        data: *const ::c_void,\n+        nbytes: ::size_t,\n+    ) -> ::ssize_t;\n+    pub fn extattr_set_file(\n+        path: *const ::c_char,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+        data: *const ::c_void,\n+        nbytes: ::size_t,\n+    ) -> ::ssize_t;\n+    pub fn extattr_set_link(\n+        path: *const ::c_char,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+        data: *const ::c_void,\n+        nbytes: ::size_t,\n+    ) -> ::ssize_t;\n+\n+    pub fn jail(jail: *mut ::jail) -> ::c_int;\n+    pub fn jail_attach(jid: ::c_int) -> ::c_int;\n+    pub fn jail_remove(jid: ::c_int) -> ::c_int;\n+    pub fn jail_get(\n+        iov: *mut ::iovec,\n+        niov: ::c_uint,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+    pub fn jail_set(\n+        iov: *mut ::iovec,\n+        niov: ::c_uint,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+\n+    pub fn fdatasync(fd: ::c_int) -> ::c_int;\n+    pub fn posix_fallocate(\n+        fd: ::c_int,\n+        offset: ::off_t,\n+        len: ::off_t,\n+    ) -> ::c_int;\n+    pub fn posix_fadvise(\n+        fd: ::c_int,\n+        offset: ::off_t,\n+        len: ::off_t,\n+        advise: ::c_int,\n+    ) -> ::c_int;\n+    pub fn mkostemp(template: *mut ::c_char, flags: ::c_int) -> ::c_int;\n+    pub fn mkostemps(\n+        template: *mut ::c_char,\n+        suffixlen: ::c_int,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+\n+    pub fn getutxuser(user: *const ::c_char) -> *mut utmpx;\n+    pub fn setutxdb(_type: ::c_int, file: *const ::c_char) -> ::c_int;\n+\n+    pub fn aio_waitcomplete(\n+        iocbp: *mut *mut aiocb,\n+        timeout: *mut ::timespec,\n+    ) -> ::ssize_t;\n+    pub fn mq_getfd_np(mqd: ::mqd_t) -> ::c_int;\n+\n+    pub fn waitid(\n+        idtype: idtype_t,\n+        id: ::id_t,\n+        infop: *mut ::siginfo_t,\n+        options: ::c_int,\n+    ) -> ::c_int;\n+\n+    pub fn ftok(pathname: *const ::c_char, proj_id: ::c_int) -> ::key_t;\n+    pub fn shmget(key: ::key_t, size: ::size_t, shmflg: ::c_int) -> ::c_int;\n+    pub fn shmat(\n+        shmid: ::c_int,\n+        shmaddr: *const ::c_void,\n+        shmflg: ::c_int,\n+    ) -> *mut ::c_void;\n+    pub fn shmdt(shmaddr: *const ::c_void) -> ::c_int;\n+    pub fn shmctl(\n+        shmid: ::c_int,\n+        cmd: ::c_int,\n+        buf: *mut ::shmid_ds,\n+    ) -> ::c_int;\n+    pub fn msgctl(\n+        msqid: ::c_int,\n+        cmd: ::c_int,\n+        buf: *mut ::msqid_ds,\n+    ) -> ::c_int;\n+    pub fn msgget(key: ::key_t, msgflg: ::c_int) -> ::c_int;\n+    pub fn msgsnd(\n+        msqid: ::c_int,\n+        msgp: *const ::c_void,\n+        msgsz: ::size_t,\n+        msgflg: ::c_int,\n+    ) -> ::c_int;\n+    pub fn cfmakesane(termios: *mut ::termios);\n+    pub fn fexecve(\n+        fd: ::c_int,\n+        argv: *const *const ::c_char,\n+        envp: *const *const ::c_char,\n+    ) -> ::c_int;\n+\n+    pub fn pdfork(fdp: *mut ::c_int, flags: ::c_int) -> ::pid_t;\n+    pub fn pdgetpid(fd: ::c_int, pidp: *mut ::pid_t) -> ::c_int;\n+    pub fn pdkill(fd: ::c_int, signum: ::c_int) -> ::c_int;\n+\n+    pub fn rtprio_thread(\n+        function: ::c_int,\n+        lwpid: ::lwpid_t,\n+        rtp: *mut super::rtprio,\n+    ) -> ::c_int;\n+\n+    pub fn posix_spawn(\n+        pid: *mut ::pid_t,\n+        path: *const ::c_char,\n+        file_actions: *const ::posix_spawn_file_actions_t,\n+        attrp: *const ::posix_spawnattr_t,\n+        argv: *const *mut ::c_char,\n+        envp: *const *mut ::c_char,\n+    ) -> ::c_int;\n+    pub fn posix_spawnp(\n+        pid: *mut ::pid_t,\n+        file: *const ::c_char,\n+        file_actions: *const ::posix_spawn_file_actions_t,\n+        attrp: *const ::posix_spawnattr_t,\n+        argv: *const *mut ::c_char,\n+        envp: *const *mut ::c_char,\n+    ) -> ::c_int;\n+    pub fn posix_spawnattr_init(attr: *mut posix_spawnattr_t) -> ::c_int;\n+    pub fn posix_spawnattr_destroy(attr: *mut posix_spawnattr_t) -> ::c_int;\n+    pub fn posix_spawnattr_getsigdefault(\n+        attr: *const posix_spawnattr_t,\n+        default: *mut ::sigset_t,\n+    ) -> ::c_int;\n+    pub fn posix_spawnattr_setsigdefault(\n+        attr: *mut posix_spawnattr_t,\n+        default: *const ::sigset_t,\n+    ) -> ::c_int;\n+    pub fn posix_spawnattr_getsigmask(\n+        attr: *const posix_spawnattr_t,\n+        default: *mut ::sigset_t,\n+    ) -> ::c_int;\n+    pub fn posix_spawnattr_setsigmask(\n+        attr: *mut posix_spawnattr_t,\n+        default: *const ::sigset_t,\n+    ) -> ::c_int;\n+    pub fn posix_spawnattr_getflags(\n+        attr: *const posix_spawnattr_t,\n+        flags: *mut ::c_short,\n+    ) -> ::c_int;\n+    pub fn posix_spawnattr_setflags(\n+        attr: *mut posix_spawnattr_t,\n+        flags: ::c_short,\n+    ) -> ::c_int;\n+    pub fn posix_spawnattr_getpgroup(\n+        attr: *const posix_spawnattr_t,\n+        flags: *mut ::pid_t,\n+    ) -> ::c_int;\n+    pub fn posix_spawnattr_setpgroup(\n+        attr: *mut posix_spawnattr_t,\n+        flags: ::pid_t,\n+    ) -> ::c_int;\n+    pub fn posix_spawnattr_getschedpolicy(\n+        attr: *const posix_spawnattr_t,\n+        flags: *mut ::c_int,\n+    ) -> ::c_int;\n+    pub fn posix_spawnattr_setschedpolicy(\n+        attr: *mut posix_spawnattr_t,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+    pub fn posix_spawnattr_getschedparam(\n+        attr: *const posix_spawnattr_t,\n+        param: *mut ::sched_param,\n+    ) -> ::c_int;\n+    pub fn posix_spawnattr_setschedparam(\n+        attr: *mut posix_spawnattr_t,\n+        param: *const ::sched_param,\n+    ) -> ::c_int;\n+\n+    pub fn posix_spawn_file_actions_init(\n+        actions: *mut posix_spawn_file_actions_t,\n+    ) -> ::c_int;\n+    pub fn posix_spawn_file_actions_destroy(\n+        actions: *mut posix_spawn_file_actions_t,\n+    ) -> ::c_int;\n+    pub fn posix_spawn_file_actions_addopen(\n+        actions: *mut posix_spawn_file_actions_t,\n+        fd: ::c_int,\n+        path: *const ::c_char,\n+        oflag: ::c_int,\n+        mode: ::mode_t,\n+    ) -> ::c_int;\n+    pub fn posix_spawn_file_actions_addclose(\n+        actions: *mut posix_spawn_file_actions_t,\n+        fd: ::c_int,\n+    ) -> ::c_int;\n+    pub fn posix_spawn_file_actions_adddup2(\n+        actions: *mut posix_spawn_file_actions_t,\n+        fd: ::c_int,\n+        newfd: ::c_int,\n+    ) -> ::c_int;\n+\n+    #[cfg_attr(\n+        all(target_os = \"freebsd\", freebsd11),\n+        link_name = \"statfs@FBSD_1.0\"\n+    )]\n+    pub fn statfs(path: *const ::c_char, buf: *mut statfs) -> ::c_int;\n+    #[cfg_attr(\n+        all(target_os = \"freebsd\", freebsd11),\n+        link_name = \"fstatfs@FBSD_1.0\"\n+    )]\n+    pub fn fstatfs(fd: ::c_int, buf: *mut statfs) -> ::c_int;\n+\n+    pub fn dup3(src: ::c_int, dst: ::c_int, flags: ::c_int) -> ::c_int;\n+    pub fn __xuname(nmln: ::c_int, buf: *mut ::c_void) -> ::c_int;\n+\n+    pub fn sendmmsg(\n+        sockfd: ::c_int,\n+        msgvec: *mut ::mmsghdr,\n+        vlen: ::size_t,\n+        flags: ::c_int,\n+    ) -> ::ssize_t;\n+    pub fn recvmmsg(\n+        sockfd: ::c_int,\n+        msgvec: *mut ::mmsghdr,\n+        vlen: ::size_t,\n+        flags: ::c_int,\n+        timeout: *const ::timespec,\n+    ) -> ::ssize_t;\n+}\n+\n+#[link(name = \"util\")]\n+extern \"C\" {\n+    pub fn extattr_namespace_to_string(\n+        attrnamespace: ::c_int,\n+        string: *mut *mut ::c_char,\n+    ) -> ::c_int;\n+    pub fn extattr_string_to_namespace(\n+        string: *const ::c_char,\n+        attrnamespace: *mut ::c_int,\n+    ) -> ::c_int;\n+}\n+\n+cfg_if! {\n+    if #[cfg(freebsd12)] {\n+        mod freebsd12;\n+        pub use self::freebsd12::*;\n+    } else if #[cfg(freebsd13)] {\n+        mod freebsd12;\n+        pub use self::freebsd12::*;\n+    } else if #[cfg(any(freebsd10, freebsd11))] {\n+        mod freebsd11;\n+        pub use self::freebsd11::*;\n+    } else {\n+        // Unknown freebsd version\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(target_arch = \"x86\")] {\n+        mod x86;\n+        pub use self::x86::*;\n+    } else if #[cfg(target_arch = \"x86_64\")] {\n+        mod x86_64;\n+        pub use self::x86_64::*;\n+    } else if #[cfg(target_arch = \"aarch64\")] {\n+        mod aarch64;\n+        pub use self::aarch64::*;\n+    } else if #[cfg(target_arch = \"arm\")] {\n+        mod arm;\n+        pub use self::arm::*;\n+    } else if #[cfg(target_arch = \"powerpc64\")] {\n+        mod powerpc64;\n+        pub use self::powerpc64::*;\n+    } else {\n+        // Unknown target_arch\n+    }\n+}"
      },
      {
        "sha": "5c0c6e7f32631ef6ab6d4f94844a64f0ef391c34",
        "filename": "src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/powerpc64.rs",
        "status": "added",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/powerpc64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/powerpc64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/powerpc64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,44 @@\n+pub type c_char = u8;\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type time_t = i64;\n+pub type suseconds_t = i64;\n+\n+s! {\n+    pub struct stat {\n+        pub st_dev: ::dev_t,\n+        pub st_ino: ::ino_t,\n+        pub st_mode: ::mode_t,\n+        pub st_nlink: ::nlink_t,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        pub st_rdev: ::dev_t,\n+        pub st_atime: ::time_t,\n+        pub st_atime_nsec: ::c_long,\n+        pub st_mtime: ::time_t,\n+        pub st_mtime_nsec: ::c_long,\n+        pub st_ctime: ::time_t,\n+        pub st_ctime_nsec: ::c_long,\n+        pub st_size: ::off_t,\n+        pub st_blocks: ::blkcnt_t,\n+        pub st_blksize: ::blksize_t,\n+        pub st_flags: ::fflags_t,\n+        pub st_gen: u32,\n+        pub st_lspare: i32,\n+        pub st_birthtime: ::time_t,\n+        pub st_birthtime_nsec: ::c_long,\n+    }\n+}\n+\n+// should be pub(crate), but that requires Rust 1.18.0\n+cfg_if! {\n+    if #[cfg(libc_const_size_of)] {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_long>() - 1;\n+    } else {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = 8 - 1;\n+    }\n+}\n+\n+pub const MAP_32BIT: ::c_int = 0x00080000;"
      },
      {
        "sha": "adec88cb54639e3ec34a56293a57944f92f95529",
        "filename": "src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/x86.rs",
        "status": "added",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/x86.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/x86.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/x86.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,43 @@\n+pub type c_char = i8;\n+pub type c_long = i32;\n+pub type c_ulong = u32;\n+pub type time_t = i32;\n+pub type suseconds_t = i32;\n+\n+s! {\n+    pub struct stat {\n+        pub st_dev: ::dev_t,\n+        pub st_ino: ::ino_t,\n+        pub st_mode: ::mode_t,\n+        pub st_nlink: ::nlink_t,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        pub st_rdev: ::dev_t,\n+        pub st_atime: ::time_t,\n+        pub st_atime_nsec: ::c_long,\n+        pub st_mtime: ::time_t,\n+        pub st_mtime_nsec: ::c_long,\n+        pub st_ctime: ::time_t,\n+        pub st_ctime_nsec: ::c_long,\n+        pub st_size: ::off_t,\n+        pub st_blocks: ::blkcnt_t,\n+        pub st_blksize: ::blksize_t,\n+        pub st_flags: ::fflags_t,\n+        pub st_gen: u32,\n+        pub st_lspare: i32,\n+        pub st_birthtime: ::time_t,\n+        pub st_birthtime_nsec: ::c_long,\n+        __unused: [u8; 8],\n+    }\n+}\n+\n+// should be pub(crate), but that requires Rust 1.18.0\n+cfg_if! {\n+    if #[cfg(libc_const_size_of)] {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_long>() - 1;\n+    } else {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = 8 - 1;\n+    }\n+}"
      },
      {
        "sha": "7ca870fd02b71e31e44439e3fabdf1386eb75bb9",
        "filename": "src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/x86_64/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/x86_64/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/x86_64/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/x86_64/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,7 @@\n+s_no_extra_traits! {\n+    #[allow(missing_debug_implementations)]\n+    #[repr(align(16))]\n+    pub struct max_align_t {\n+        priv_: [f64; 4]\n+    }\n+}"
      },
      {
        "sha": "0769a22f88c7e4dfe44234c3227a1fc9e3e9841b",
        "filename": "src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/x86_64/mod.rs",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/x86_64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/x86_64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/freebsdlike/freebsd/x86_64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,24 @@\n+pub type c_char = i8;\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type time_t = i64;\n+pub type suseconds_t = i64;\n+\n+// should be pub(crate), but that requires Rust 1.18.0\n+cfg_if! {\n+    if #[cfg(libc_const_size_of)] {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_long>() - 1;\n+    } else {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = 8 - 1;\n+    }\n+}\n+pub const MAP_32BIT: ::c_int = 0x00080000;\n+\n+cfg_if! {\n+    if #[cfg(libc_align)] {\n+        mod align;\n+        pub use self::align::*;\n+    }\n+}"
      },
      {
        "sha": "1b7804cb279620c3837ee3db4a9620fb960d96af",
        "filename": "src/rusty/libc/src/unix/bsd/freebsdlike/mod.rs",
        "status": "added",
        "additions": 1466,
        "deletions": 0,
        "changes": 1466,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/freebsdlike/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/freebsdlike/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,1466 @@\n+pub type mode_t = u16;\n+pub type pthread_attr_t = *mut ::c_void;\n+pub type rlim_t = i64;\n+pub type pthread_mutex_t = *mut ::c_void;\n+pub type pthread_mutexattr_t = *mut ::c_void;\n+pub type pthread_cond_t = *mut ::c_void;\n+pub type pthread_condattr_t = *mut ::c_void;\n+pub type pthread_rwlock_t = *mut ::c_void;\n+pub type pthread_rwlockattr_t = *mut ::c_void;\n+pub type pthread_key_t = ::c_int;\n+pub type tcflag_t = ::c_uint;\n+pub type speed_t = ::c_uint;\n+pub type nl_item = ::c_int;\n+pub type id_t = i64;\n+pub type vm_size_t = ::uintptr_t;\n+\n+#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\n+pub enum timezone {}\n+impl ::Copy for timezone {}\n+impl ::Clone for timezone {\n+    fn clone(&self) -> timezone {\n+        *self\n+    }\n+}\n+\n+impl siginfo_t {\n+    pub unsafe fn si_addr(&self) -> *mut ::c_void {\n+        self.si_addr\n+    }\n+\n+    pub unsafe fn si_value(&self) -> ::sigval {\n+        self.si_value\n+    }\n+}\n+\n+s! {\n+    pub struct in_addr {\n+        pub s_addr: ::in_addr_t,\n+    }\n+\n+    pub struct ip_mreq {\n+        pub imr_multiaddr: in_addr,\n+        pub imr_interface: in_addr,\n+    }\n+\n+    pub struct glob_t {\n+        pub gl_pathc:  ::size_t,\n+        pub gl_matchc: ::size_t,\n+        pub gl_offs:   ::size_t,\n+        pub gl_flags:  ::c_int,\n+        pub gl_pathv:  *mut *mut ::c_char,\n+        __unused3: *mut ::c_void,\n+        __unused4: *mut ::c_void,\n+        __unused5: *mut ::c_void,\n+        __unused6: *mut ::c_void,\n+        __unused7: *mut ::c_void,\n+        __unused8: *mut ::c_void,\n+    }\n+\n+    pub struct addrinfo {\n+        pub ai_flags: ::c_int,\n+        pub ai_family: ::c_int,\n+        pub ai_socktype: ::c_int,\n+        pub ai_protocol: ::c_int,\n+        pub ai_addrlen: ::socklen_t,\n+        pub ai_canonname: *mut ::c_char,\n+        pub ai_addr: *mut ::sockaddr,\n+        pub ai_next: *mut addrinfo,\n+    }\n+\n+    pub struct sigset_t {\n+        bits: [u32; 4],\n+    }\n+\n+    pub struct siginfo_t {\n+        pub si_signo: ::c_int,\n+        pub si_errno: ::c_int,\n+        pub si_code: ::c_int,\n+        pub si_pid: ::pid_t,\n+        pub si_uid: ::uid_t,\n+        pub si_status: ::c_int,\n+        pub si_addr: *mut ::c_void,\n+        pub si_value: ::sigval,\n+        _pad1: ::c_long,\n+        _pad2: [::c_int; 7],\n+    }\n+\n+    pub struct sigaction {\n+        pub sa_sigaction: ::sighandler_t,\n+        pub sa_flags: ::c_int,\n+        pub sa_mask: sigset_t,\n+    }\n+\n+    pub struct sched_param {\n+        pub sched_priority: ::c_int,\n+    }\n+\n+    pub struct Dl_info {\n+        pub dli_fname: *const ::c_char,\n+        pub dli_fbase: *mut ::c_void,\n+        pub dli_sname: *const ::c_char,\n+        pub dli_saddr: *mut ::c_void,\n+    }\n+\n+    pub struct sockaddr_in {\n+        pub sin_len: u8,\n+        pub sin_family: ::sa_family_t,\n+        pub sin_port: ::in_port_t,\n+        pub sin_addr: ::in_addr,\n+        pub sin_zero: [::c_char; 8],\n+    }\n+\n+    pub struct termios {\n+        pub c_iflag: ::tcflag_t,\n+        pub c_oflag: ::tcflag_t,\n+        pub c_cflag: ::tcflag_t,\n+        pub c_lflag: ::tcflag_t,\n+        pub c_cc: [::cc_t; ::NCCS],\n+        pub c_ispeed: ::speed_t,\n+        pub c_ospeed: ::speed_t,\n+    }\n+\n+    pub struct flock {\n+        pub l_start: ::off_t,\n+        pub l_len: ::off_t,\n+        pub l_pid: ::pid_t,\n+        pub l_type: ::c_short,\n+        pub l_whence: ::c_short,\n+        #[cfg(not(target_os = \"dragonfly\"))]\n+        pub l_sysid: ::c_int,\n+    }\n+\n+    pub struct sf_hdtr {\n+        pub headers: *mut ::iovec,\n+        pub hdr_cnt: ::c_int,\n+        pub trailers: *mut ::iovec,\n+        pub trl_cnt: ::c_int,\n+    }\n+\n+    pub struct lconv {\n+        pub decimal_point: *mut ::c_char,\n+        pub thousands_sep: *mut ::c_char,\n+        pub grouping: *mut ::c_char,\n+        pub int_curr_symbol: *mut ::c_char,\n+        pub currency_symbol: *mut ::c_char,\n+        pub mon_decimal_point: *mut ::c_char,\n+        pub mon_thousands_sep: *mut ::c_char,\n+        pub mon_grouping: *mut ::c_char,\n+        pub positive_sign: *mut ::c_char,\n+        pub negative_sign: *mut ::c_char,\n+        pub int_frac_digits: ::c_char,\n+        pub frac_digits: ::c_char,\n+        pub p_cs_precedes: ::c_char,\n+        pub p_sep_by_space: ::c_char,\n+        pub n_cs_precedes: ::c_char,\n+        pub n_sep_by_space: ::c_char,\n+        pub p_sign_posn: ::c_char,\n+        pub n_sign_posn: ::c_char,\n+        pub int_p_cs_precedes: ::c_char,\n+        pub int_n_cs_precedes: ::c_char,\n+        pub int_p_sep_by_space: ::c_char,\n+        pub int_n_sep_by_space: ::c_char,\n+        pub int_p_sign_posn: ::c_char,\n+        pub int_n_sign_posn: ::c_char,\n+    }\n+\n+    pub struct cmsgcred {\n+        pub cmcred_pid: ::pid_t,\n+        pub cmcred_uid: ::uid_t,\n+        pub cmcred_euid: ::uid_t,\n+        pub cmcred_gid: ::gid_t,\n+        pub cmcred_ngroups: ::c_short,\n+        pub cmcred_groups: [::gid_t; CMGROUP_MAX],\n+    }\n+\n+    pub struct rtprio {\n+        pub type_: ::c_ushort,\n+        pub prio: ::c_ushort,\n+    }\n+\n+    pub struct in6_pktinfo {\n+        pub ipi6_addr: ::in6_addr,\n+        pub ipi6_ifindex: ::c_uint,\n+    }\n+\n+    pub struct arphdr {\n+        pub ar_hrd: u16,\n+        pub ar_pro: u16,\n+        pub ar_hln: u8,\n+        pub ar_pln: u8,\n+        pub ar_op: u16,\n+    }\n+}\n+\n+s_no_extra_traits! {\n+    pub struct sockaddr_storage {\n+        pub ss_len: u8,\n+        pub ss_family: ::sa_family_t,\n+        __ss_pad1: [u8; 6],\n+        __ss_align: i64,\n+        __ss_pad2: [u8; 112],\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(feature = \"extra_traits\")] {\n+        impl PartialEq for sockaddr_storage {\n+            fn eq(&self, other: &sockaddr_storage) -> bool {\n+                self.ss_len == other.ss_len\n+                    && self.ss_family == other.ss_family\n+                    && self.__ss_pad1 == other.__ss_pad1\n+                    && self.__ss_align == other.__ss_align\n+                    && self\n+                    .__ss_pad2\n+                    .iter()\n+                    .zip(other.__ss_pad2.iter())\n+                    .all(|(a, b)| a == b)\n+            }\n+        }\n+        impl Eq for sockaddr_storage {}\n+        impl ::fmt::Debug for sockaddr_storage {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"sockaddr_storage\")\n+                    .field(\"ss_len\", &self.ss_len)\n+                    .field(\"ss_family\", &self.ss_family)\n+                    .field(\"__ss_pad1\", &self.__ss_pad1)\n+                    .field(\"__ss_align\", &self.__ss_align)\n+                    // FIXME: .field(\"__ss_pad2\", &self.__ss_pad2)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for sockaddr_storage {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.ss_len.hash(state);\n+                self.ss_family.hash(state);\n+                self.__ss_pad1.hash(state);\n+                self.__ss_align.hash(state);\n+                self.__ss_pad2.hash(state);\n+            }\n+        }\n+    }\n+}\n+\n+#[deprecated(\n+    since = \"0.2.64\",\n+    note = \"Can vary at runtime.  Use sysconf(3) instead\"\n+)]\n+pub const AIO_LISTIO_MAX: ::c_int = 16;\n+pub const AIO_CANCELED: ::c_int = 1;\n+pub const AIO_NOTCANCELED: ::c_int = 2;\n+pub const AIO_ALLDONE: ::c_int = 3;\n+pub const LIO_NOP: ::c_int = 0;\n+pub const LIO_WRITE: ::c_int = 1;\n+pub const LIO_READ: ::c_int = 2;\n+pub const LIO_WAIT: ::c_int = 1;\n+pub const LIO_NOWAIT: ::c_int = 0;\n+\n+pub const SIGEV_NONE: ::c_int = 0;\n+pub const SIGEV_SIGNAL: ::c_int = 1;\n+pub const SIGEV_THREAD: ::c_int = 2;\n+pub const SIGEV_KEVENT: ::c_int = 3;\n+\n+pub const CODESET: ::nl_item = 0;\n+pub const D_T_FMT: ::nl_item = 1;\n+pub const D_FMT: ::nl_item = 2;\n+pub const T_FMT: ::nl_item = 3;\n+pub const T_FMT_AMPM: ::nl_item = 4;\n+pub const AM_STR: ::nl_item = 5;\n+pub const PM_STR: ::nl_item = 6;\n+\n+pub const DAY_1: ::nl_item = 7;\n+pub const DAY_2: ::nl_item = 8;\n+pub const DAY_3: ::nl_item = 9;\n+pub const DAY_4: ::nl_item = 10;\n+pub const DAY_5: ::nl_item = 11;\n+pub const DAY_6: ::nl_item = 12;\n+pub const DAY_7: ::nl_item = 13;\n+\n+pub const ABDAY_1: ::nl_item = 14;\n+pub const ABDAY_2: ::nl_item = 15;\n+pub const ABDAY_3: ::nl_item = 16;\n+pub const ABDAY_4: ::nl_item = 17;\n+pub const ABDAY_5: ::nl_item = 18;\n+pub const ABDAY_6: ::nl_item = 19;\n+pub const ABDAY_7: ::nl_item = 20;\n+\n+pub const MON_1: ::nl_item = 21;\n+pub const MON_2: ::nl_item = 22;\n+pub const MON_3: ::nl_item = 23;\n+pub const MON_4: ::nl_item = 24;\n+pub const MON_5: ::nl_item = 25;\n+pub const MON_6: ::nl_item = 26;\n+pub const MON_7: ::nl_item = 27;\n+pub const MON_8: ::nl_item = 28;\n+pub const MON_9: ::nl_item = 29;\n+pub const MON_10: ::nl_item = 30;\n+pub const MON_11: ::nl_item = 31;\n+pub const MON_12: ::nl_item = 32;\n+\n+pub const ABMON_1: ::nl_item = 33;\n+pub const ABMON_2: ::nl_item = 34;\n+pub const ABMON_3: ::nl_item = 35;\n+pub const ABMON_4: ::nl_item = 36;\n+pub const ABMON_5: ::nl_item = 37;\n+pub const ABMON_6: ::nl_item = 38;\n+pub const ABMON_7: ::nl_item = 39;\n+pub const ABMON_8: ::nl_item = 40;\n+pub const ABMON_9: ::nl_item = 41;\n+pub const ABMON_10: ::nl_item = 42;\n+pub const ABMON_11: ::nl_item = 43;\n+pub const ABMON_12: ::nl_item = 44;\n+\n+pub const ERA: ::nl_item = 45;\n+pub const ERA_D_FMT: ::nl_item = 46;\n+pub const ERA_D_T_FMT: ::nl_item = 47;\n+pub const ERA_T_FMT: ::nl_item = 48;\n+pub const ALT_DIGITS: ::nl_item = 49;\n+\n+pub const RADIXCHAR: ::nl_item = 50;\n+pub const THOUSEP: ::nl_item = 51;\n+\n+pub const YESEXPR: ::nl_item = 52;\n+pub const NOEXPR: ::nl_item = 53;\n+\n+pub const YESSTR: ::nl_item = 54;\n+pub const NOSTR: ::nl_item = 55;\n+\n+pub const CRNCYSTR: ::nl_item = 56;\n+\n+pub const D_MD_ORDER: ::nl_item = 57;\n+\n+pub const ALTMON_1: ::nl_item = 58;\n+pub const ALTMON_2: ::nl_item = 59;\n+pub const ALTMON_3: ::nl_item = 60;\n+pub const ALTMON_4: ::nl_item = 61;\n+pub const ALTMON_5: ::nl_item = 62;\n+pub const ALTMON_6: ::nl_item = 63;\n+pub const ALTMON_7: ::nl_item = 64;\n+pub const ALTMON_8: ::nl_item = 65;\n+pub const ALTMON_9: ::nl_item = 66;\n+pub const ALTMON_10: ::nl_item = 67;\n+pub const ALTMON_11: ::nl_item = 68;\n+pub const ALTMON_12: ::nl_item = 69;\n+\n+pub const EXIT_FAILURE: ::c_int = 1;\n+pub const EXIT_SUCCESS: ::c_int = 0;\n+pub const EOF: ::c_int = -1;\n+pub const SEEK_SET: ::c_int = 0;\n+pub const SEEK_CUR: ::c_int = 1;\n+pub const SEEK_END: ::c_int = 2;\n+pub const SEEK_DATA: ::c_int = 3;\n+pub const SEEK_HOLE: ::c_int = 4;\n+pub const _IOFBF: ::c_int = 0;\n+pub const _IONBF: ::c_int = 2;\n+pub const _IOLBF: ::c_int = 1;\n+pub const BUFSIZ: ::c_uint = 1024;\n+pub const FOPEN_MAX: ::c_uint = 20;\n+pub const FILENAME_MAX: ::c_uint = 1024;\n+pub const L_tmpnam: ::c_uint = 1024;\n+pub const TMP_MAX: ::c_uint = 308915776;\n+\n+pub const O_NOCTTY: ::c_int = 32768;\n+pub const O_DIRECT: ::c_int = 0x00010000;\n+\n+pub const S_IFIFO: mode_t = 4096;\n+pub const S_IFCHR: mode_t = 8192;\n+pub const S_IFBLK: mode_t = 24576;\n+pub const S_IFDIR: mode_t = 16384;\n+pub const S_IFREG: mode_t = 32768;\n+pub const S_IFLNK: mode_t = 40960;\n+pub const S_IFSOCK: mode_t = 49152;\n+pub const S_IFMT: mode_t = 61440;\n+pub const S_IEXEC: mode_t = 64;\n+pub const S_IWRITE: mode_t = 128;\n+pub const S_IREAD: mode_t = 256;\n+pub const S_IRWXU: mode_t = 448;\n+pub const S_IXUSR: mode_t = 64;\n+pub const S_IWUSR: mode_t = 128;\n+pub const S_IRUSR: mode_t = 256;\n+pub const S_IRWXG: mode_t = 56;\n+pub const S_IXGRP: mode_t = 8;\n+pub const S_IWGRP: mode_t = 16;\n+pub const S_IRGRP: mode_t = 32;\n+pub const S_IRWXO: mode_t = 7;\n+pub const S_IXOTH: mode_t = 1;\n+pub const S_IWOTH: mode_t = 2;\n+pub const S_IROTH: mode_t = 4;\n+pub const F_OK: ::c_int = 0;\n+pub const R_OK: ::c_int = 4;\n+pub const W_OK: ::c_int = 2;\n+pub const X_OK: ::c_int = 1;\n+pub const STDIN_FILENO: ::c_int = 0;\n+pub const STDOUT_FILENO: ::c_int = 1;\n+pub const STDERR_FILENO: ::c_int = 2;\n+pub const F_LOCK: ::c_int = 1;\n+pub const F_TEST: ::c_int = 3;\n+pub const F_TLOCK: ::c_int = 2;\n+pub const F_ULOCK: ::c_int = 0;\n+pub const F_DUPFD_CLOEXEC: ::c_int = 17;\n+pub const SIGHUP: ::c_int = 1;\n+pub const SIGINT: ::c_int = 2;\n+pub const SIGQUIT: ::c_int = 3;\n+pub const SIGILL: ::c_int = 4;\n+pub const SIGABRT: ::c_int = 6;\n+pub const SIGEMT: ::c_int = 7;\n+pub const SIGFPE: ::c_int = 8;\n+pub const SIGKILL: ::c_int = 9;\n+pub const SIGSEGV: ::c_int = 11;\n+pub const SIGPIPE: ::c_int = 13;\n+pub const SIGALRM: ::c_int = 14;\n+pub const SIGTERM: ::c_int = 15;\n+\n+pub const PROT_NONE: ::c_int = 0;\n+pub const PROT_READ: ::c_int = 1;\n+pub const PROT_WRITE: ::c_int = 2;\n+pub const PROT_EXEC: ::c_int = 4;\n+\n+pub const MAP_FILE: ::c_int = 0x0000;\n+pub const MAP_SHARED: ::c_int = 0x0001;\n+pub const MAP_PRIVATE: ::c_int = 0x0002;\n+pub const MAP_FIXED: ::c_int = 0x0010;\n+pub const MAP_ANON: ::c_int = 0x1000;\n+pub const MAP_ANONYMOUS: ::c_int = MAP_ANON;\n+\n+pub const MAP_FAILED: *mut ::c_void = !0 as *mut ::c_void;\n+\n+pub const MCL_CURRENT: ::c_int = 0x0001;\n+pub const MCL_FUTURE: ::c_int = 0x0002;\n+\n+pub const MS_SYNC: ::c_int = 0x0000;\n+pub const MS_ASYNC: ::c_int = 0x0001;\n+pub const MS_INVALIDATE: ::c_int = 0x0002;\n+\n+pub const EPERM: ::c_int = 1;\n+pub const ENOENT: ::c_int = 2;\n+pub const ESRCH: ::c_int = 3;\n+pub const EINTR: ::c_int = 4;\n+pub const EIO: ::c_int = 5;\n+pub const ENXIO: ::c_int = 6;\n+pub const E2BIG: ::c_int = 7;\n+pub const ENOEXEC: ::c_int = 8;\n+pub const EBADF: ::c_int = 9;\n+pub const ECHILD: ::c_int = 10;\n+pub const EDEADLK: ::c_int = 11;\n+pub const ENOMEM: ::c_int = 12;\n+pub const EACCES: ::c_int = 13;\n+pub const EFAULT: ::c_int = 14;\n+pub const ENOTBLK: ::c_int = 15;\n+pub const EBUSY: ::c_int = 16;\n+pub const EEXIST: ::c_int = 17;\n+pub const EXDEV: ::c_int = 18;\n+pub const ENODEV: ::c_int = 19;\n+pub const ENOTDIR: ::c_int = 20;\n+pub const EISDIR: ::c_int = 21;\n+pub const EINVAL: ::c_int = 22;\n+pub const ENFILE: ::c_int = 23;\n+pub const EMFILE: ::c_int = 24;\n+pub const ENOTTY: ::c_int = 25;\n+pub const ETXTBSY: ::c_int = 26;\n+pub const EFBIG: ::c_int = 27;\n+pub const ENOSPC: ::c_int = 28;\n+pub const ESPIPE: ::c_int = 29;\n+pub const EROFS: ::c_int = 30;\n+pub const EMLINK: ::c_int = 31;\n+pub const EPIPE: ::c_int = 32;\n+pub const EDOM: ::c_int = 33;\n+pub const ERANGE: ::c_int = 34;\n+pub const EAGAIN: ::c_int = 35;\n+pub const EWOULDBLOCK: ::c_int = 35;\n+pub const EINPROGRESS: ::c_int = 36;\n+pub const EALREADY: ::c_int = 37;\n+pub const ENOTSOCK: ::c_int = 38;\n+pub const EDESTADDRREQ: ::c_int = 39;\n+pub const EMSGSIZE: ::c_int = 40;\n+pub const EPROTOTYPE: ::c_int = 41;\n+pub const ENOPROTOOPT: ::c_int = 42;\n+pub const EPROTONOSUPPORT: ::c_int = 43;\n+pub const ESOCKTNOSUPPORT: ::c_int = 44;\n+pub const EOPNOTSUPP: ::c_int = 45;\n+pub const ENOTSUP: ::c_int = EOPNOTSUPP;\n+pub const EPFNOSUPPORT: ::c_int = 46;\n+pub const EAFNOSUPPORT: ::c_int = 47;\n+pub const EADDRINUSE: ::c_int = 48;\n+pub const EADDRNOTAVAIL: ::c_int = 49;\n+pub const ENETDOWN: ::c_int = 50;\n+pub const ENETUNREACH: ::c_int = 51;\n+pub const ENETRESET: ::c_int = 52;\n+pub const ECONNABORTED: ::c_int = 53;\n+pub const ECONNRESET: ::c_int = 54;\n+pub const ENOBUFS: ::c_int = 55;\n+pub const EISCONN: ::c_int = 56;\n+pub const ENOTCONN: ::c_int = 57;\n+pub const ESHUTDOWN: ::c_int = 58;\n+pub const ETOOMANYREFS: ::c_int = 59;\n+pub const ETIMEDOUT: ::c_int = 60;\n+pub const ECONNREFUSED: ::c_int = 61;\n+pub const ELOOP: ::c_int = 62;\n+pub const ENAMETOOLONG: ::c_int = 63;\n+pub const EHOSTDOWN: ::c_int = 64;\n+pub const EHOSTUNREACH: ::c_int = 65;\n+pub const ENOTEMPTY: ::c_int = 66;\n+pub const EPROCLIM: ::c_int = 67;\n+pub const EUSERS: ::c_int = 68;\n+pub const EDQUOT: ::c_int = 69;\n+pub const ESTALE: ::c_int = 70;\n+pub const EREMOTE: ::c_int = 71;\n+pub const EBADRPC: ::c_int = 72;\n+pub const ERPCMISMATCH: ::c_int = 73;\n+pub const EPROGUNAVAIL: ::c_int = 74;\n+pub const EPROGMISMATCH: ::c_int = 75;\n+pub const EPROCUNAVAIL: ::c_int = 76;\n+pub const ENOLCK: ::c_int = 77;\n+pub const ENOSYS: ::c_int = 78;\n+pub const EFTYPE: ::c_int = 79;\n+pub const EAUTH: ::c_int = 80;\n+pub const ENEEDAUTH: ::c_int = 81;\n+pub const EIDRM: ::c_int = 82;\n+pub const ENOMSG: ::c_int = 83;\n+pub const EOVERFLOW: ::c_int = 84;\n+pub const ECANCELED: ::c_int = 85;\n+pub const EILSEQ: ::c_int = 86;\n+pub const ENOATTR: ::c_int = 87;\n+pub const EDOOFUS: ::c_int = 88;\n+pub const EBADMSG: ::c_int = 89;\n+pub const EMULTIHOP: ::c_int = 90;\n+pub const ENOLINK: ::c_int = 91;\n+pub const EPROTO: ::c_int = 92;\n+\n+pub const POLLSTANDARD: ::c_short = ::POLLIN\n+    | ::POLLPRI\n+    | ::POLLOUT\n+    | ::POLLRDNORM\n+    | ::POLLRDBAND\n+    | ::POLLWRBAND\n+    | ::POLLERR\n+    | ::POLLHUP\n+    | ::POLLNVAL;\n+\n+pub const EAI_AGAIN: ::c_int = 2;\n+pub const EAI_BADFLAGS: ::c_int = 3;\n+pub const EAI_FAIL: ::c_int = 4;\n+pub const EAI_FAMILY: ::c_int = 5;\n+pub const EAI_MEMORY: ::c_int = 6;\n+pub const EAI_NONAME: ::c_int = 8;\n+pub const EAI_SERVICE: ::c_int = 9;\n+pub const EAI_SOCKTYPE: ::c_int = 10;\n+pub const EAI_SYSTEM: ::c_int = 11;\n+pub const EAI_OVERFLOW: ::c_int = 14;\n+\n+pub const F_DUPFD: ::c_int = 0;\n+pub const F_GETFD: ::c_int = 1;\n+pub const F_SETFD: ::c_int = 2;\n+pub const F_GETFL: ::c_int = 3;\n+pub const F_SETFL: ::c_int = 4;\n+\n+pub const SIGTRAP: ::c_int = 5;\n+\n+pub const GLOB_APPEND: ::c_int = 0x0001;\n+pub const GLOB_DOOFFS: ::c_int = 0x0002;\n+pub const GLOB_ERR: ::c_int = 0x0004;\n+pub const GLOB_MARK: ::c_int = 0x0008;\n+pub const GLOB_NOCHECK: ::c_int = 0x0010;\n+pub const GLOB_NOSORT: ::c_int = 0x0020;\n+pub const GLOB_NOESCAPE: ::c_int = 0x2000;\n+\n+pub const GLOB_NOSPACE: ::c_int = -1;\n+pub const GLOB_ABORTED: ::c_int = -2;\n+pub const GLOB_NOMATCH: ::c_int = -3;\n+\n+pub const POSIX_MADV_NORMAL: ::c_int = 0;\n+pub const POSIX_MADV_RANDOM: ::c_int = 1;\n+pub const POSIX_MADV_SEQUENTIAL: ::c_int = 2;\n+pub const POSIX_MADV_WILLNEED: ::c_int = 3;\n+pub const POSIX_MADV_DONTNEED: ::c_int = 4;\n+\n+pub const PTHREAD_PROCESS_PRIVATE: ::c_int = 0;\n+pub const PTHREAD_PROCESS_SHARED: ::c_int = 1;\n+pub const PTHREAD_CREATE_JOINABLE: ::c_int = 0;\n+pub const PTHREAD_CREATE_DETACHED: ::c_int = 1;\n+\n+pub const RLIMIT_CPU: ::c_int = 0;\n+pub const RLIMIT_FSIZE: ::c_int = 1;\n+pub const RLIMIT_DATA: ::c_int = 2;\n+pub const RLIMIT_STACK: ::c_int = 3;\n+pub const RLIMIT_CORE: ::c_int = 4;\n+pub const RLIMIT_RSS: ::c_int = 5;\n+pub const RLIMIT_MEMLOCK: ::c_int = 6;\n+pub const RLIMIT_NPROC: ::c_int = 7;\n+pub const RLIMIT_NOFILE: ::c_int = 8;\n+pub const RLIMIT_SBSIZE: ::c_int = 9;\n+pub const RLIMIT_VMEM: ::c_int = 10;\n+pub const RLIMIT_AS: ::c_int = RLIMIT_VMEM;\n+pub const RLIM_INFINITY: rlim_t = 0x7fff_ffff_ffff_ffff;\n+\n+pub const RUSAGE_SELF: ::c_int = 0;\n+pub const RUSAGE_CHILDREN: ::c_int = -1;\n+\n+pub const MADV_NORMAL: ::c_int = 0;\n+pub const MADV_RANDOM: ::c_int = 1;\n+pub const MADV_SEQUENTIAL: ::c_int = 2;\n+pub const MADV_WILLNEED: ::c_int = 3;\n+pub const MADV_DONTNEED: ::c_int = 4;\n+pub const MADV_FREE: ::c_int = 5;\n+pub const MADV_NOSYNC: ::c_int = 6;\n+pub const MADV_AUTOSYNC: ::c_int = 7;\n+pub const MADV_NOCORE: ::c_int = 8;\n+pub const MADV_CORE: ::c_int = 9;\n+\n+pub const MINCORE_INCORE: ::c_int = 0x1;\n+pub const MINCORE_REFERENCED: ::c_int = 0x2;\n+pub const MINCORE_MODIFIED: ::c_int = 0x4;\n+pub const MINCORE_REFERENCED_OTHER: ::c_int = 0x8;\n+pub const MINCORE_MODIFIED_OTHER: ::c_int = 0x10;\n+pub const MINCORE_SUPER: ::c_int = 0x20;\n+\n+pub const AF_UNSPEC: ::c_int = 0;\n+pub const AF_LOCAL: ::c_int = 1;\n+pub const AF_UNIX: ::c_int = AF_LOCAL;\n+pub const AF_INET: ::c_int = 2;\n+pub const AF_IMPLINK: ::c_int = 3;\n+pub const AF_PUP: ::c_int = 4;\n+pub const AF_CHAOS: ::c_int = 5;\n+pub const AF_NETBIOS: ::c_int = 6;\n+pub const AF_ISO: ::c_int = 7;\n+pub const AF_OSI: ::c_int = AF_ISO;\n+pub const AF_ECMA: ::c_int = 8;\n+pub const AF_DATAKIT: ::c_int = 9;\n+pub const AF_CCITT: ::c_int = 10;\n+pub const AF_SNA: ::c_int = 11;\n+pub const AF_DECnet: ::c_int = 12;\n+pub const AF_DLI: ::c_int = 13;\n+pub const AF_LAT: ::c_int = 14;\n+pub const AF_HYLINK: ::c_int = 15;\n+pub const AF_APPLETALK: ::c_int = 16;\n+pub const AF_ROUTE: ::c_int = 17;\n+pub const AF_LINK: ::c_int = 18;\n+pub const pseudo_AF_XTP: ::c_int = 19;\n+pub const AF_COIP: ::c_int = 20;\n+pub const AF_CNT: ::c_int = 21;\n+pub const pseudo_AF_RTIP: ::c_int = 22;\n+pub const AF_IPX: ::c_int = 23;\n+pub const AF_SIP: ::c_int = 24;\n+pub const pseudo_AF_PIP: ::c_int = 25;\n+pub const AF_ISDN: ::c_int = 26;\n+pub const AF_E164: ::c_int = AF_ISDN;\n+pub const pseudo_AF_KEY: ::c_int = 27;\n+pub const AF_INET6: ::c_int = 28;\n+pub const AF_NATM: ::c_int = 29;\n+pub const AF_ATM: ::c_int = 30;\n+pub const pseudo_AF_HDRCMPLT: ::c_int = 31;\n+pub const AF_NETGRAPH: ::c_int = 32;\n+\n+pub const PF_UNSPEC: ::c_int = AF_UNSPEC;\n+pub const PF_LOCAL: ::c_int = AF_LOCAL;\n+pub const PF_UNIX: ::c_int = PF_LOCAL;\n+pub const PF_INET: ::c_int = AF_INET;\n+pub const PF_IMPLINK: ::c_int = AF_IMPLINK;\n+pub const PF_PUP: ::c_int = AF_PUP;\n+pub const PF_CHAOS: ::c_int = AF_CHAOS;\n+pub const PF_NETBIOS: ::c_int = AF_NETBIOS;\n+pub const PF_ISO: ::c_int = AF_ISO;\n+pub const PF_OSI: ::c_int = AF_ISO;\n+pub const PF_ECMA: ::c_int = AF_ECMA;\n+pub const PF_DATAKIT: ::c_int = AF_DATAKIT;\n+pub const PF_CCITT: ::c_int = AF_CCITT;\n+pub const PF_SNA: ::c_int = AF_SNA;\n+pub const PF_DECnet: ::c_int = AF_DECnet;\n+pub const PF_DLI: ::c_int = AF_DLI;\n+pub const PF_LAT: ::c_int = AF_LAT;\n+pub const PF_HYLINK: ::c_int = AF_HYLINK;\n+pub const PF_APPLETALK: ::c_int = AF_APPLETALK;\n+pub const PF_ROUTE: ::c_int = AF_ROUTE;\n+pub const PF_LINK: ::c_int = AF_LINK;\n+pub const PF_XTP: ::c_int = pseudo_AF_XTP;\n+pub const PF_COIP: ::c_int = AF_COIP;\n+pub const PF_CNT: ::c_int = AF_CNT;\n+pub const PF_SIP: ::c_int = AF_SIP;\n+pub const PF_IPX: ::c_int = AF_IPX;\n+pub const PF_RTIP: ::c_int = pseudo_AF_RTIP;\n+pub const PF_PIP: ::c_int = pseudo_AF_PIP;\n+pub const PF_ISDN: ::c_int = AF_ISDN;\n+pub const PF_KEY: ::c_int = pseudo_AF_KEY;\n+pub const PF_INET6: ::c_int = AF_INET6;\n+pub const PF_NATM: ::c_int = AF_NATM;\n+pub const PF_ATM: ::c_int = AF_ATM;\n+pub const PF_NETGRAPH: ::c_int = AF_NETGRAPH;\n+\n+pub const PT_TRACE_ME: ::c_int = 0;\n+pub const PT_READ_I: ::c_int = 1;\n+pub const PT_READ_D: ::c_int = 2;\n+pub const PT_WRITE_I: ::c_int = 4;\n+pub const PT_WRITE_D: ::c_int = 5;\n+pub const PT_CONTINUE: ::c_int = 7;\n+pub const PT_KILL: ::c_int = 8;\n+pub const PT_STEP: ::c_int = 9;\n+pub const PT_ATTACH: ::c_int = 10;\n+pub const PT_DETACH: ::c_int = 11;\n+pub const PT_IO: ::c_int = 12;\n+\n+pub const SOMAXCONN: ::c_int = 128;\n+\n+pub const MSG_OOB: ::c_int = 0x00000001;\n+pub const MSG_PEEK: ::c_int = 0x00000002;\n+pub const MSG_DONTROUTE: ::c_int = 0x00000004;\n+pub const MSG_EOR: ::c_int = 0x00000008;\n+pub const MSG_TRUNC: ::c_int = 0x00000010;\n+pub const MSG_CTRUNC: ::c_int = 0x00000020;\n+pub const MSG_WAITALL: ::c_int = 0x00000040;\n+pub const MSG_DONTWAIT: ::c_int = 0x00000080;\n+pub const MSG_EOF: ::c_int = 0x00000100;\n+\n+pub const SCM_TIMESTAMP: ::c_int = 0x02;\n+\n+pub const SOCK_STREAM: ::c_int = 1;\n+pub const SOCK_DGRAM: ::c_int = 2;\n+pub const SOCK_RAW: ::c_int = 3;\n+pub const SOCK_RDM: ::c_int = 4;\n+pub const SOCK_SEQPACKET: ::c_int = 5;\n+pub const SOCK_CLOEXEC: ::c_int = 0x10000000;\n+pub const SOCK_NONBLOCK: ::c_int = 0x20000000;\n+pub const SOCK_MAXADDRLEN: ::c_int = 255;\n+pub const IP_TTL: ::c_int = 4;\n+pub const IP_HDRINCL: ::c_int = 2;\n+pub const IP_RECVDSTADDR: ::c_int = 7;\n+pub const IP_SENDSRCADDR: ::c_int = IP_RECVDSTADDR;\n+pub const IP_ADD_MEMBERSHIP: ::c_int = 12;\n+pub const IP_DROP_MEMBERSHIP: ::c_int = 13;\n+pub const IP_RECVIF: ::c_int = 20;\n+pub const IPV6_JOIN_GROUP: ::c_int = 12;\n+pub const IPV6_LEAVE_GROUP: ::c_int = 13;\n+pub const IPV6_RECVPKTINFO: ::c_int = 36;\n+pub const IPV6_PKTINFO: ::c_int = 46;\n+pub const IPV6_RECVTCLASS: ::c_int = 57;\n+pub const IPV6_TCLASS: ::c_int = 61;\n+\n+pub const TCP_NOPUSH: ::c_int = 4;\n+pub const TCP_NOOPT: ::c_int = 8;\n+pub const TCP_KEEPIDLE: ::c_int = 256;\n+pub const TCP_KEEPINTVL: ::c_int = 512;\n+pub const TCP_KEEPCNT: ::c_int = 1024;\n+\n+pub const SOL_SOCKET: ::c_int = 0xffff;\n+pub const SO_DEBUG: ::c_int = 0x01;\n+pub const SO_ACCEPTCONN: ::c_int = 0x0002;\n+pub const SO_REUSEADDR: ::c_int = 0x0004;\n+pub const SO_KEEPALIVE: ::c_int = 0x0008;\n+pub const SO_DONTROUTE: ::c_int = 0x0010;\n+pub const SO_BROADCAST: ::c_int = 0x0020;\n+pub const SO_USELOOPBACK: ::c_int = 0x0040;\n+pub const SO_LINGER: ::c_int = 0x0080;\n+pub const SO_OOBINLINE: ::c_int = 0x0100;\n+pub const SO_REUSEPORT: ::c_int = 0x0200;\n+pub const SO_TIMESTAMP: ::c_int = 0x0400;\n+pub const SO_NOSIGPIPE: ::c_int = 0x0800;\n+pub const SO_ACCEPTFILTER: ::c_int = 0x1000;\n+pub const SO_SNDBUF: ::c_int = 0x1001;\n+pub const SO_RCVBUF: ::c_int = 0x1002;\n+pub const SO_SNDLOWAT: ::c_int = 0x1003;\n+pub const SO_RCVLOWAT: ::c_int = 0x1004;\n+pub const SO_SNDTIMEO: ::c_int = 0x1005;\n+pub const SO_RCVTIMEO: ::c_int = 0x1006;\n+pub const SO_ERROR: ::c_int = 0x1007;\n+pub const SO_TYPE: ::c_int = 0x1008;\n+\n+pub const SHUT_RD: ::c_int = 0;\n+pub const SHUT_WR: ::c_int = 1;\n+pub const SHUT_RDWR: ::c_int = 2;\n+\n+pub const LOCK_SH: ::c_int = 1;\n+pub const LOCK_EX: ::c_int = 2;\n+pub const LOCK_NB: ::c_int = 4;\n+pub const LOCK_UN: ::c_int = 8;\n+\n+pub const MAP_COPY: ::c_int = 0x0002;\n+#[doc(hidden)]\n+#[deprecated(since = \"0.2.54\", note = \"Removed in FreeBSD 11\")]\n+pub const MAP_RENAME: ::c_int = 0x0020;\n+#[doc(hidden)]\n+#[deprecated(since = \"0.2.54\", note = \"Removed in FreeBSD 11\")]\n+pub const MAP_NORESERVE: ::c_int = 0x0040;\n+pub const MAP_HASSEMAPHORE: ::c_int = 0x0200;\n+pub const MAP_STACK: ::c_int = 0x0400;\n+pub const MAP_NOSYNC: ::c_int = 0x0800;\n+pub const MAP_NOCORE: ::c_int = 0x020000;\n+\n+pub const IPPROTO_RAW: ::c_int = 255;\n+\n+pub const _PC_LINK_MAX: ::c_int = 1;\n+pub const _PC_MAX_CANON: ::c_int = 2;\n+pub const _PC_MAX_INPUT: ::c_int = 3;\n+pub const _PC_NAME_MAX: ::c_int = 4;\n+pub const _PC_PATH_MAX: ::c_int = 5;\n+pub const _PC_PIPE_BUF: ::c_int = 6;\n+pub const _PC_CHOWN_RESTRICTED: ::c_int = 7;\n+pub const _PC_NO_TRUNC: ::c_int = 8;\n+pub const _PC_VDISABLE: ::c_int = 9;\n+pub const _PC_ALLOC_SIZE_MIN: ::c_int = 10;\n+pub const _PC_FILESIZEBITS: ::c_int = 12;\n+pub const _PC_REC_INCR_XFER_SIZE: ::c_int = 14;\n+pub const _PC_REC_MAX_XFER_SIZE: ::c_int = 15;\n+pub const _PC_REC_MIN_XFER_SIZE: ::c_int = 16;\n+pub const _PC_REC_XFER_ALIGN: ::c_int = 17;\n+pub const _PC_SYMLINK_MAX: ::c_int = 18;\n+pub const _PC_MIN_HOLE_SIZE: ::c_int = 21;\n+pub const _PC_ASYNC_IO: ::c_int = 53;\n+pub const _PC_PRIO_IO: ::c_int = 54;\n+pub const _PC_SYNC_IO: ::c_int = 55;\n+pub const _PC_ACL_EXTENDED: ::c_int = 59;\n+pub const _PC_ACL_PATH_MAX: ::c_int = 60;\n+pub const _PC_CAP_PRESENT: ::c_int = 61;\n+pub const _PC_INF_PRESENT: ::c_int = 62;\n+pub const _PC_MAC_PRESENT: ::c_int = 63;\n+\n+pub const _SC_ARG_MAX: ::c_int = 1;\n+pub const _SC_CHILD_MAX: ::c_int = 2;\n+pub const _SC_CLK_TCK: ::c_int = 3;\n+pub const _SC_NGROUPS_MAX: ::c_int = 4;\n+pub const _SC_OPEN_MAX: ::c_int = 5;\n+pub const _SC_JOB_CONTROL: ::c_int = 6;\n+pub const _SC_SAVED_IDS: ::c_int = 7;\n+pub const _SC_VERSION: ::c_int = 8;\n+pub const _SC_BC_BASE_MAX: ::c_int = 9;\n+pub const _SC_BC_DIM_MAX: ::c_int = 10;\n+pub const _SC_BC_SCALE_MAX: ::c_int = 11;\n+pub const _SC_BC_STRING_MAX: ::c_int = 12;\n+pub const _SC_COLL_WEIGHTS_MAX: ::c_int = 13;\n+pub const _SC_EXPR_NEST_MAX: ::c_int = 14;\n+pub const _SC_LINE_MAX: ::c_int = 15;\n+pub const _SC_RE_DUP_MAX: ::c_int = 16;\n+pub const _SC_2_VERSION: ::c_int = 17;\n+pub const _SC_2_C_BIND: ::c_int = 18;\n+pub const _SC_2_C_DEV: ::c_int = 19;\n+pub const _SC_2_CHAR_TERM: ::c_int = 20;\n+pub const _SC_2_FORT_DEV: ::c_int = 21;\n+pub const _SC_2_FORT_RUN: ::c_int = 22;\n+pub const _SC_2_LOCALEDEF: ::c_int = 23;\n+pub const _SC_2_SW_DEV: ::c_int = 24;\n+pub const _SC_2_UPE: ::c_int = 25;\n+pub const _SC_STREAM_MAX: ::c_int = 26;\n+pub const _SC_TZNAME_MAX: ::c_int = 27;\n+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 28;\n+pub const _SC_MAPPED_FILES: ::c_int = 29;\n+pub const _SC_MEMLOCK: ::c_int = 30;\n+pub const _SC_MEMLOCK_RANGE: ::c_int = 31;\n+pub const _SC_MEMORY_PROTECTION: ::c_int = 32;\n+pub const _SC_MESSAGE_PASSING: ::c_int = 33;\n+pub const _SC_PRIORITIZED_IO: ::c_int = 34;\n+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 35;\n+pub const _SC_REALTIME_SIGNALS: ::c_int = 36;\n+pub const _SC_SEMAPHORES: ::c_int = 37;\n+pub const _SC_FSYNC: ::c_int = 38;\n+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 39;\n+pub const _SC_SYNCHRONIZED_IO: ::c_int = 40;\n+pub const _SC_TIMERS: ::c_int = 41;\n+pub const _SC_AIO_LISTIO_MAX: ::c_int = 42;\n+pub const _SC_AIO_MAX: ::c_int = 43;\n+pub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 44;\n+pub const _SC_DELAYTIMER_MAX: ::c_int = 45;\n+pub const _SC_MQ_OPEN_MAX: ::c_int = 46;\n+pub const _SC_PAGESIZE: ::c_int = 47;\n+pub const _SC_PAGE_SIZE: ::c_int = _SC_PAGESIZE;\n+pub const _SC_RTSIG_MAX: ::c_int = 48;\n+pub const _SC_SEM_NSEMS_MAX: ::c_int = 49;\n+pub const _SC_SEM_VALUE_MAX: ::c_int = 50;\n+pub const _SC_SIGQUEUE_MAX: ::c_int = 51;\n+pub const _SC_TIMER_MAX: ::c_int = 52;\n+pub const _SC_IOV_MAX: ::c_int = 56;\n+pub const _SC_NPROCESSORS_CONF: ::c_int = 57;\n+pub const _SC_2_PBS: ::c_int = 59;\n+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 60;\n+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 61;\n+pub const _SC_2_PBS_LOCATE: ::c_int = 62;\n+pub const _SC_2_PBS_MESSAGE: ::c_int = 63;\n+pub const _SC_2_PBS_TRACK: ::c_int = 64;\n+pub const _SC_ADVISORY_INFO: ::c_int = 65;\n+pub const _SC_BARRIERS: ::c_int = 66;\n+pub const _SC_CLOCK_SELECTION: ::c_int = 67;\n+pub const _SC_CPUTIME: ::c_int = 68;\n+pub const _SC_FILE_LOCKING: ::c_int = 69;\n+pub const _SC_NPROCESSORS_ONLN: ::c_int = 58;\n+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 70;\n+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 71;\n+pub const _SC_HOST_NAME_MAX: ::c_int = 72;\n+pub const _SC_LOGIN_NAME_MAX: ::c_int = 73;\n+pub const _SC_MONOTONIC_CLOCK: ::c_int = 74;\n+pub const _SC_MQ_PRIO_MAX: ::c_int = 75;\n+pub const _SC_READER_WRITER_LOCKS: ::c_int = 76;\n+pub const _SC_REGEXP: ::c_int = 77;\n+pub const _SC_SHELL: ::c_int = 78;\n+pub const _SC_SPAWN: ::c_int = 79;\n+pub const _SC_SPIN_LOCKS: ::c_int = 80;\n+pub const _SC_SPORADIC_SERVER: ::c_int = 81;\n+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 82;\n+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 83;\n+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 85;\n+pub const _SC_THREAD_KEYS_MAX: ::c_int = 86;\n+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 87;\n+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 88;\n+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 89;\n+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 90;\n+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 91;\n+pub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 92;\n+pub const _SC_THREAD_STACK_MIN: ::c_int = 93;\n+pub const _SC_THREAD_THREADS_MAX: ::c_int = 94;\n+pub const _SC_TIMEOUTS: ::c_int = 95;\n+pub const _SC_THREADS: ::c_int = 96;\n+pub const _SC_TRACE: ::c_int = 97;\n+pub const _SC_TRACE_EVENT_FILTER: ::c_int = 98;\n+pub const _SC_TRACE_INHERIT: ::c_int = 99;\n+pub const _SC_TRACE_LOG: ::c_int = 100;\n+pub const _SC_TTY_NAME_MAX: ::c_int = 101;\n+pub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 102;\n+pub const _SC_V6_ILP32_OFF32: ::c_int = 103;\n+pub const _SC_V6_ILP32_OFFBIG: ::c_int = 104;\n+pub const _SC_V6_LP64_OFF64: ::c_int = 105;\n+pub const _SC_V6_LPBIG_OFFBIG: ::c_int = 106;\n+pub const _SC_ATEXIT_MAX: ::c_int = 107;\n+pub const _SC_XOPEN_CRYPT: ::c_int = 108;\n+pub const _SC_XOPEN_ENH_I18N: ::c_int = 109;\n+pub const _SC_XOPEN_LEGACY: ::c_int = 110;\n+pub const _SC_XOPEN_REALTIME: ::c_int = 111;\n+pub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 112;\n+pub const _SC_XOPEN_SHM: ::c_int = 113;\n+pub const _SC_XOPEN_STREAMS: ::c_int = 114;\n+pub const _SC_XOPEN_UNIX: ::c_int = 115;\n+pub const _SC_XOPEN_VERSION: ::c_int = 116;\n+pub const _SC_XOPEN_XCU_VERSION: ::c_int = 117;\n+pub const _SC_IPV6: ::c_int = 118;\n+pub const _SC_RAW_SOCKETS: ::c_int = 119;\n+pub const _SC_SYMLOOP_MAX: ::c_int = 120;\n+pub const _SC_PHYS_PAGES: ::c_int = 121;\n+\n+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = 0 as *mut _;\n+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = 0 as *mut _;\n+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = 0 as *mut _;\n+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 1;\n+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 2;\n+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 3;\n+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_ERRORCHECK;\n+\n+pub const SCHED_FIFO: ::c_int = 1;\n+pub const SCHED_OTHER: ::c_int = 2;\n+pub const SCHED_RR: ::c_int = 3;\n+\n+pub const FD_SETSIZE: usize = 1024;\n+\n+pub const ST_NOSUID: ::c_ulong = 2;\n+\n+pub const NI_MAXHOST: ::size_t = 1025;\n+\n+pub const RTLD_LOCAL: ::c_int = 0;\n+pub const RTLD_NODELETE: ::c_int = 0x1000;\n+pub const RTLD_NOLOAD: ::c_int = 0x2000;\n+pub const RTLD_GLOBAL: ::c_int = 0x100;\n+\n+pub const LOG_NTP: ::c_int = 12 << 3;\n+pub const LOG_SECURITY: ::c_int = 13 << 3;\n+pub const LOG_CONSOLE: ::c_int = 14 << 3;\n+pub const LOG_NFACILITIES: ::c_int = 24;\n+\n+pub const TIOCEXCL: ::c_uint = 0x2000740d;\n+pub const TIOCNXCL: ::c_uint = 0x2000740e;\n+pub const TIOCFLUSH: ::c_ulong = 0x80047410;\n+pub const TIOCGETA: ::c_uint = 0x402c7413;\n+pub const TIOCSETA: ::c_ulong = 0x802c7414;\n+pub const TIOCSETAW: ::c_ulong = 0x802c7415;\n+pub const TIOCSETAF: ::c_ulong = 0x802c7416;\n+pub const TIOCGETD: ::c_uint = 0x4004741a;\n+pub const TIOCSETD: ::c_ulong = 0x8004741b;\n+pub const TIOCGDRAINWAIT: ::c_uint = 0x40047456;\n+pub const TIOCSDRAINWAIT: ::c_ulong = 0x80047457;\n+pub const TIOCTIMESTAMP: ::c_uint = 0x40107459;\n+pub const TIOCMGDTRWAIT: ::c_uint = 0x4004745a;\n+pub const TIOCMSDTRWAIT: ::c_ulong = 0x8004745b;\n+pub const TIOCDRAIN: ::c_uint = 0x2000745e;\n+pub const TIOCEXT: ::c_ulong = 0x80047460;\n+pub const TIOCSCTTY: ::c_uint = 0x20007461;\n+pub const TIOCCONS: ::c_ulong = 0x80047462;\n+pub const TIOCGSID: ::c_uint = 0x40047463;\n+pub const TIOCSTAT: ::c_uint = 0x20007465;\n+pub const TIOCUCNTL: ::c_ulong = 0x80047466;\n+pub const TIOCSWINSZ: ::c_ulong = 0x80087467;\n+pub const TIOCGWINSZ: ::c_uint = 0x40087468;\n+pub const TIOCMGET: ::c_uint = 0x4004746a;\n+pub const TIOCM_LE: ::c_int = 0x1;\n+pub const TIOCM_DTR: ::c_int = 0x2;\n+pub const TIOCM_RTS: ::c_int = 0x4;\n+pub const TIOCM_ST: ::c_int = 0x8;\n+pub const TIOCM_SR: ::c_int = 0x10;\n+pub const TIOCM_CTS: ::c_int = 0x20;\n+pub const TIOCM_RI: ::c_int = 0x80;\n+pub const TIOCM_DSR: ::c_int = 0x100;\n+pub const TIOCM_CD: ::c_int = 0x40;\n+pub const TIOCM_CAR: ::c_int = 0x40;\n+pub const TIOCM_RNG: ::c_int = 0x80;\n+pub const TIOCMBIC: ::c_ulong = 0x8004746b;\n+pub const TIOCMBIS: ::c_ulong = 0x8004746c;\n+pub const TIOCMSET: ::c_ulong = 0x8004746d;\n+pub const TIOCSTART: ::c_uint = 0x2000746e;\n+pub const TIOCSTOP: ::c_uint = 0x2000746f;\n+pub const TIOCPKT: ::c_ulong = 0x80047470;\n+pub const TIOCPKT_DATA: ::c_int = 0x0;\n+pub const TIOCPKT_FLUSHREAD: ::c_int = 0x1;\n+pub const TIOCPKT_FLUSHWRITE: ::c_int = 0x2;\n+pub const TIOCPKT_STOP: ::c_int = 0x4;\n+pub const TIOCPKT_START: ::c_int = 0x8;\n+pub const TIOCPKT_NOSTOP: ::c_int = 0x10;\n+pub const TIOCPKT_DOSTOP: ::c_int = 0x20;\n+pub const TIOCPKT_IOCTL: ::c_int = 0x40;\n+pub const TIOCNOTTY: ::c_uint = 0x20007471;\n+pub const TIOCSTI: ::c_ulong = 0x80017472;\n+pub const TIOCOUTQ: ::c_uint = 0x40047473;\n+pub const TIOCSPGRP: ::c_ulong = 0x80047476;\n+pub const TIOCGPGRP: ::c_uint = 0x40047477;\n+pub const TIOCCDTR: ::c_uint = 0x20007478;\n+pub const TIOCSDTR: ::c_uint = 0x20007479;\n+pub const TIOCCBRK: ::c_uint = 0x2000747a;\n+pub const TIOCSBRK: ::c_uint = 0x2000747b;\n+pub const TTYDISC: ::c_int = 0x0;\n+pub const SLIPDISC: ::c_int = 0x4;\n+pub const PPPDISC: ::c_int = 0x5;\n+pub const NETGRAPHDISC: ::c_int = 0x6;\n+\n+pub const BIOCGRSIG: ::c_ulong = 0x40044272;\n+pub const BIOCSRSIG: ::c_ulong = 0x80044273;\n+pub const BIOCSDLT: ::c_ulong = 0x80044278;\n+pub const BIOCGSEESENT: ::c_ulong = 0x40044276;\n+pub const BIOCSSEESENT: ::c_ulong = 0x80044277;\n+pub const BIOCSETF: ::c_ulong = 0x80104267;\n+pub const BIOCGDLTLIST: ::c_ulong = 0xc0104279;\n+pub const BIOCSRTIMEOUT: ::c_ulong = 0x8010426d;\n+pub const BIOCGRTIMEOUT: ::c_ulong = 0x4010426e;\n+\n+pub const FIODTYPE: ::c_ulong = 0x4004667a;\n+pub const FIOGETLBA: ::c_ulong = 0x40046679;\n+pub const FIODGNAME: ::c_ulong = 0x80106678;\n+\n+pub const B0: speed_t = 0;\n+pub const B50: speed_t = 50;\n+pub const B75: speed_t = 75;\n+pub const B110: speed_t = 110;\n+pub const B134: speed_t = 134;\n+pub const B150: speed_t = 150;\n+pub const B200: speed_t = 200;\n+pub const B300: speed_t = 300;\n+pub const B600: speed_t = 600;\n+pub const B1200: speed_t = 1200;\n+pub const B1800: speed_t = 1800;\n+pub const B2400: speed_t = 2400;\n+pub const B4800: speed_t = 4800;\n+pub const B9600: speed_t = 9600;\n+pub const B19200: speed_t = 19200;\n+pub const B38400: speed_t = 38400;\n+pub const B7200: speed_t = 7200;\n+pub const B14400: speed_t = 14400;\n+pub const B28800: speed_t = 28800;\n+pub const B57600: speed_t = 57600;\n+pub const B76800: speed_t = 76800;\n+pub const B115200: speed_t = 115200;\n+pub const B230400: speed_t = 230400;\n+pub const EXTA: speed_t = 19200;\n+pub const EXTB: speed_t = 38400;\n+\n+pub const SEM_FAILED: *mut sem_t = 0 as *mut sem_t;\n+\n+pub const CRTSCTS: ::tcflag_t = 0x00030000;\n+pub const CCTS_OFLOW: ::tcflag_t = 0x00010000;\n+pub const CRTS_IFLOW: ::tcflag_t = 0x00020000;\n+pub const CDTR_IFLOW: ::tcflag_t = 0x00040000;\n+pub const CDSR_OFLOW: ::tcflag_t = 0x00080000;\n+pub const CCAR_OFLOW: ::tcflag_t = 0x00100000;\n+pub const VERASE2: usize = 7;\n+pub const OCRNL: ::tcflag_t = 0x10;\n+pub const ONOCR: ::tcflag_t = 0x20;\n+pub const ONLRET: ::tcflag_t = 0x40;\n+\n+pub const CMGROUP_MAX: usize = 16;\n+\n+// https://github.com/freebsd/freebsd/blob/master/sys/net/bpf.h\n+// sizeof(long)\n+pub const BPF_ALIGNMENT: ::c_int = 8;\n+\n+// Values for rtprio struct (prio field) and syscall (function argument)\n+pub const RTP_PRIO_MIN: ::c_ushort = 0;\n+pub const RTP_PRIO_MAX: ::c_ushort = 31;\n+pub const RTP_LOOKUP: ::c_int = 0;\n+pub const RTP_SET: ::c_int = 1;\n+\n+// Flags for chflags(2)\n+pub const UF_SETTABLE: ::c_ulong = 0x0000ffff;\n+pub const UF_NODUMP: ::c_ulong = 0x00000001;\n+pub const UF_IMMUTABLE: ::c_ulong = 0x00000002;\n+pub const UF_APPEND: ::c_ulong = 0x00000004;\n+pub const UF_OPAQUE: ::c_ulong = 0x00000008;\n+pub const UF_NOUNLINK: ::c_ulong = 0x00000010;\n+pub const SF_SETTABLE: ::c_ulong = 0xffff0000;\n+pub const SF_ARCHIVED: ::c_ulong = 0x00010000;\n+pub const SF_IMMUTABLE: ::c_ulong = 0x00020000;\n+pub const SF_APPEND: ::c_ulong = 0x00040000;\n+pub const SF_NOUNLINK: ::c_ulong = 0x00100000;\n+\n+pub const TIMER_ABSTIME: ::c_int = 1;\n+\n+f! {\n+    pub fn WIFCONTINUED(status: ::c_int) -> bool {\n+        status == 0x13\n+    }\n+\n+    pub fn WSTOPSIG(status: ::c_int) -> ::c_int {\n+        status >> 8\n+    }\n+\n+    pub fn WIFSIGNALED(status: ::c_int) -> bool {\n+        (status & 0o177) != 0o177 && (status & 0o177) != 0\n+    }\n+\n+    pub fn WIFSTOPPED(status: ::c_int) -> bool {\n+        (status & 0o177) == 0o177\n+    }\n+}\n+\n+extern \"C\" {\n+    pub fn sem_destroy(sem: *mut sem_t) -> ::c_int;\n+    pub fn sem_init(\n+        sem: *mut sem_t,\n+        pshared: ::c_int,\n+        value: ::c_uint,\n+    ) -> ::c_int;\n+\n+    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;\n+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::timezone) -> ::c_int;\n+    pub fn accept4(\n+        s: ::c_int,\n+        addr: *mut ::sockaddr,\n+        addrlen: *mut ::socklen_t,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+    pub fn aio_read(aiocbp: *mut aiocb) -> ::c_int;\n+    pub fn aio_write(aiocbp: *mut aiocb) -> ::c_int;\n+    pub fn aio_fsync(op: ::c_int, aiocbp: *mut aiocb) -> ::c_int;\n+    pub fn aio_error(aiocbp: *const aiocb) -> ::c_int;\n+    pub fn aio_return(aiocbp: *mut aiocb) -> ::ssize_t;\n+    pub fn aio_suspend(\n+        aiocb_list: *const *const aiocb,\n+        nitems: ::c_int,\n+        timeout: *const ::timespec,\n+    ) -> ::c_int;\n+    pub fn aio_cancel(fd: ::c_int, aiocbp: *mut aiocb) -> ::c_int;\n+    pub fn chflags(path: *const ::c_char, flags: ::c_ulong) -> ::c_int;\n+    pub fn chflagsat(\n+        fd: ::c_int,\n+        path: *const ::c_char,\n+        flags: ::c_ulong,\n+        atflag: ::c_int,\n+    ) -> ::c_int;\n+    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;\n+    pub fn duplocale(base: ::locale_t) -> ::locale_t;\n+    pub fn endutxent();\n+    pub fn fchflags(fd: ::c_int, flags: ::c_ulong) -> ::c_int;\n+    pub fn futimens(fd: ::c_int, times: *const ::timespec) -> ::c_int;\n+    pub fn getdomainname(name: *mut ::c_char, len: ::c_int) -> ::c_int;\n+    pub fn getgrent_r(\n+        grp: *mut ::group,\n+        buf: *mut ::c_char,\n+        buflen: ::size_t,\n+        result: *mut *mut ::group,\n+    ) -> ::c_int;\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__getpwent_r50\")]\n+    pub fn getpwent_r(\n+        pwd: *mut ::passwd,\n+        buf: *mut ::c_char,\n+        buflen: ::size_t,\n+        result: *mut *mut ::passwd,\n+    ) -> ::c_int;\n+    pub fn getgrouplist(\n+        name: *const ::c_char,\n+        basegid: ::gid_t,\n+        groups: *mut ::gid_t,\n+        ngroups: *mut ::c_int,\n+    ) -> ::c_int;\n+    pub fn getnameinfo(\n+        sa: *const ::sockaddr,\n+        salen: ::socklen_t,\n+        host: *mut ::c_char,\n+        hostlen: ::size_t,\n+        serv: *mut ::c_char,\n+        servlen: ::size_t,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+    pub fn getpriority(which: ::c_int, who: ::c_int) -> ::c_int;\n+    pub fn getutxent() -> *mut utmpx;\n+    pub fn getutxid(ut: *const utmpx) -> *mut utmpx;\n+    pub fn getutxline(ut: *const utmpx) -> *mut utmpx;\n+    pub fn initgroups(name: *const ::c_char, basegid: ::gid_t) -> ::c_int;\n+    #[cfg_attr(\n+        all(target_os = \"freebsd\", any(freebsd11, freebsd10)),\n+        link_name = \"kevent@FBSD_1.0\"\n+    )]\n+    pub fn kevent(\n+        kq: ::c_int,\n+        changelist: *const ::kevent,\n+        nchanges: ::c_int,\n+        eventlist: *mut ::kevent,\n+        nevents: ::c_int,\n+        timeout: *const ::timespec,\n+    ) -> ::c_int;\n+    pub fn lchflags(path: *const ::c_char, flags: ::c_ulong) -> ::c_int;\n+    pub fn lio_listio(\n+        mode: ::c_int,\n+        aiocb_list: *const *mut aiocb,\n+        nitems: ::c_int,\n+        sevp: *mut sigevent,\n+    ) -> ::c_int;\n+    pub fn lutimes(file: *const ::c_char, times: *const ::timeval) -> ::c_int;\n+    pub fn memrchr(\n+        cx: *const ::c_void,\n+        c: ::c_int,\n+        n: ::size_t,\n+    ) -> *mut ::c_void;\n+    pub fn mkfifoat(\n+        dirfd: ::c_int,\n+        pathname: *const ::c_char,\n+        mode: ::mode_t,\n+    ) -> ::c_int;\n+    #[cfg_attr(\n+        all(target_os = \"freebsd\", any(freebsd11, freebsd10)),\n+        link_name = \"mknodat@FBSD_1.1\"\n+    )]\n+    pub fn mknodat(\n+        dirfd: ::c_int,\n+        pathname: *const ::c_char,\n+        mode: ::mode_t,\n+        dev: dev_t,\n+    ) -> ::c_int;\n+    pub fn mq_close(mqd: ::mqd_t) -> ::c_int;\n+    pub fn mq_getattr(mqd: ::mqd_t, attr: *mut ::mq_attr) -> ::c_int;\n+    pub fn mq_notify(mqd: ::mqd_t, notification: *const ::sigevent)\n+        -> ::c_int;\n+    pub fn mq_open(name: *const ::c_char, oflag: ::c_int, ...) -> ::mqd_t;\n+    pub fn mq_receive(\n+        mqd: ::mqd_t,\n+        msg_ptr: *mut ::c_char,\n+        msg_len: ::size_t,\n+        msg_prio: *mut ::c_uint,\n+    ) -> ::ssize_t;\n+    pub fn mq_send(\n+        mqd: ::mqd_t,\n+        msg_ptr: *const ::c_char,\n+        msg_len: ::size_t,\n+        msg_prio: ::c_uint,\n+    ) -> ::c_int;\n+    pub fn mq_setattr(\n+        mqd: ::mqd_t,\n+        newattr: *const ::mq_attr,\n+        oldattr: *mut ::mq_attr,\n+    ) -> ::c_int;\n+    pub fn mq_timedreceive(\n+        mqd: ::mqd_t,\n+        msg_ptr: *mut ::c_char,\n+        msg_len: ::size_t,\n+        msg_prio: *mut ::c_uint,\n+        abs_timeout: *const ::timespec,\n+    ) -> ::ssize_t;\n+    pub fn mq_timedsend(\n+        mqd: ::mqd_t,\n+        msg_ptr: *const ::c_char,\n+        msg_len: ::size_t,\n+        msg_prio: ::c_uint,\n+        abs_timeout: *const ::timespec,\n+    ) -> ::c_int;\n+    pub fn mq_unlink(name: *const ::c_char) -> ::c_int;\n+    pub fn mincore(\n+        addr: *const ::c_void,\n+        len: ::size_t,\n+        vec: *mut ::c_char,\n+    ) -> ::c_int;\n+    pub fn newlocale(\n+        mask: ::c_int,\n+        locale: *const ::c_char,\n+        base: ::locale_t,\n+    ) -> ::locale_t;\n+    pub fn nl_langinfo_l(item: ::nl_item, locale: ::locale_t)\n+        -> *mut ::c_char;\n+    pub fn pipe2(fds: *mut ::c_int, flags: ::c_int) -> ::c_int;\n+    pub fn ppoll(\n+        fds: *mut ::pollfd,\n+        nfds: ::nfds_t,\n+        timeout: *const ::timespec,\n+        sigmask: *const sigset_t,\n+    ) -> ::c_int;\n+    pub fn preadv(\n+        fd: ::c_int,\n+        iov: *const ::iovec,\n+        iovcnt: ::c_int,\n+        offset: ::off_t,\n+    ) -> ::ssize_t;\n+    pub fn pthread_attr_get_np(\n+        tid: ::pthread_t,\n+        attr: *mut ::pthread_attr_t,\n+    ) -> ::c_int;\n+    pub fn pthread_attr_getguardsize(\n+        attr: *const ::pthread_attr_t,\n+        guardsize: *mut ::size_t,\n+    ) -> ::c_int;\n+    pub fn pthread_attr_getstack(\n+        attr: *const ::pthread_attr_t,\n+        stackaddr: *mut *mut ::c_void,\n+        stacksize: *mut ::size_t,\n+    ) -> ::c_int;\n+    pub fn pthread_condattr_getclock(\n+        attr: *const pthread_condattr_t,\n+        clock_id: *mut clockid_t,\n+    ) -> ::c_int;\n+    pub fn pthread_condattr_getpshared(\n+        attr: *const pthread_condattr_t,\n+        pshared: *mut ::c_int,\n+    ) -> ::c_int;\n+    pub fn pthread_condattr_setclock(\n+        attr: *mut pthread_condattr_t,\n+        clock_id: ::clockid_t,\n+    ) -> ::c_int;\n+    pub fn pthread_condattr_setpshared(\n+        attr: *mut pthread_condattr_t,\n+        pshared: ::c_int,\n+    ) -> ::c_int;\n+    pub fn pthread_main_np() -> ::c_int;\n+    pub fn pthread_mutex_timedlock(\n+        lock: *mut pthread_mutex_t,\n+        abstime: *const ::timespec,\n+    ) -> ::c_int;\n+    pub fn pthread_mutexattr_getpshared(\n+        attr: *const pthread_mutexattr_t,\n+        pshared: *mut ::c_int,\n+    ) -> ::c_int;\n+    pub fn pthread_mutexattr_setpshared(\n+        attr: *mut pthread_mutexattr_t,\n+        pshared: ::c_int,\n+    ) -> ::c_int;\n+    pub fn pthread_rwlockattr_getpshared(\n+        attr: *const pthread_rwlockattr_t,\n+        val: *mut ::c_int,\n+    ) -> ::c_int;\n+    pub fn pthread_rwlockattr_setpshared(\n+        attr: *mut pthread_rwlockattr_t,\n+        val: ::c_int,\n+    ) -> ::c_int;\n+    pub fn pthread_set_name_np(tid: ::pthread_t, name: *const ::c_char);\n+    pub fn ptrace(\n+        request: ::c_int,\n+        pid: ::pid_t,\n+        addr: *mut ::c_char,\n+        data: ::c_int,\n+    ) -> ::c_int;\n+    pub fn pututxline(ut: *const utmpx) -> *mut utmpx;\n+    pub fn pwritev(\n+        fd: ::c_int,\n+        iov: *const ::iovec,\n+        iovcnt: ::c_int,\n+        offset: ::off_t,\n+    ) -> ::ssize_t;\n+    pub fn querylocale(mask: ::c_int, loc: ::locale_t) -> *const ::c_char;\n+    pub fn rtprio(\n+        function: ::c_int,\n+        pid: ::pid_t,\n+        rtp: *mut rtprio,\n+    ) -> ::c_int;\n+    pub fn sched_getscheduler(pid: ::pid_t) -> ::c_int;\n+    pub fn sched_setscheduler(\n+        pid: ::pid_t,\n+        policy: ::c_int,\n+        param: *const ::sched_param,\n+    ) -> ::c_int;\n+    pub fn sem_getvalue(sem: *mut sem_t, sval: *mut ::c_int) -> ::c_int;\n+    pub fn sem_timedwait(\n+        sem: *mut sem_t,\n+        abstime: *const ::timespec,\n+    ) -> ::c_int;\n+    pub fn sendfile(\n+        fd: ::c_int,\n+        s: ::c_int,\n+        offset: ::off_t,\n+        nbytes: ::size_t,\n+        hdtr: *mut ::sf_hdtr,\n+        sbytes: *mut ::off_t,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+    pub fn setdomainname(name: *const ::c_char, len: ::c_int) -> ::c_int;\n+    pub fn sethostname(name: *const ::c_char, len: ::c_int) -> ::c_int;\n+    pub fn setpriority(which: ::c_int, who: ::c_int, prio: ::c_int)\n+        -> ::c_int;\n+    pub fn setresgid(rgid: ::gid_t, egid: ::gid_t, sgid: ::gid_t) -> ::c_int;\n+    pub fn setresuid(ruid: ::uid_t, euid: ::uid_t, suid: ::uid_t) -> ::c_int;\n+    pub fn settimeofday(\n+        tv: *const ::timeval,\n+        tz: *const ::timezone,\n+    ) -> ::c_int;\n+    pub fn setutxent();\n+    pub fn shm_open(\n+        name: *const ::c_char,\n+        oflag: ::c_int,\n+        mode: ::mode_t,\n+    ) -> ::c_int;\n+    pub fn sigtimedwait(\n+        set: *const sigset_t,\n+        info: *mut siginfo_t,\n+        timeout: *const ::timespec,\n+    ) -> ::c_int;\n+    pub fn sigwaitinfo(set: *const sigset_t, info: *mut siginfo_t) -> ::c_int;\n+    pub fn sysctl(\n+        name: *const ::c_int,\n+        namelen: ::c_uint,\n+        oldp: *mut ::c_void,\n+        oldlenp: *mut ::size_t,\n+        newp: *const ::c_void,\n+        newlen: ::size_t,\n+    ) -> ::c_int;\n+    pub fn sysctlbyname(\n+        name: *const ::c_char,\n+        oldp: *mut ::c_void,\n+        oldlenp: *mut ::size_t,\n+        newp: *const ::c_void,\n+        newlen: ::size_t,\n+    ) -> ::c_int;\n+    pub fn sysctlnametomib(\n+        name: *const ::c_char,\n+        mibp: *mut ::c_int,\n+        sizep: *mut ::size_t,\n+    ) -> ::c_int;\n+    pub fn uselocale(loc: ::locale_t) -> ::locale_t;\n+    pub fn utimensat(\n+        dirfd: ::c_int,\n+        path: *const ::c_char,\n+        times: *const ::timespec,\n+        flag: ::c_int,\n+    ) -> ::c_int;\n+}\n+\n+#[link(name = \"util\")]\n+extern \"C\" {\n+    pub fn openpty(\n+        amaster: *mut ::c_int,\n+        aslave: *mut ::c_int,\n+        name: *mut ::c_char,\n+        termp: *mut termios,\n+        winp: *mut ::winsize,\n+    ) -> ::c_int;\n+    pub fn forkpty(\n+        amaster: *mut ::c_int,\n+        name: *mut ::c_char,\n+        termp: *mut termios,\n+        winp: *mut ::winsize,\n+    ) -> ::pid_t;\n+    pub fn login_tty(fd: ::c_int) -> ::c_int;\n+}\n+\n+cfg_if! {\n+    if #[cfg(target_os = \"freebsd\")] {\n+        mod freebsd;\n+        pub use self::freebsd::*;\n+    } else if #[cfg(target_os = \"dragonfly\")] {\n+        mod dragonfly;\n+        pub use self::dragonfly::*;\n+    } else {\n+        // ...\n+    }\n+}"
      },
      {
        "sha": "cf9f59e9b3c025fcc552961cfe60edcc176858ba",
        "filename": "src/rusty/libc/src/unix/bsd/mod.rs",
        "status": "added",
        "additions": 794,
        "deletions": 0,
        "changes": 794,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,794 @@\n+pub type wchar_t = i32;\n+pub type off_t = i64;\n+pub type useconds_t = u32;\n+pub type blkcnt_t = i64;\n+pub type socklen_t = u32;\n+pub type sa_family_t = u8;\n+pub type pthread_t = ::uintptr_t;\n+pub type nfds_t = ::c_uint;\n+\n+s! {\n+    pub struct sockaddr {\n+        pub sa_len: u8,\n+        pub sa_family: sa_family_t,\n+        pub sa_data: [::c_char; 14],\n+    }\n+\n+    pub struct sockaddr_in6 {\n+        pub sin6_len: u8,\n+        pub sin6_family: sa_family_t,\n+        pub sin6_port: ::in_port_t,\n+        pub sin6_flowinfo: u32,\n+        pub sin6_addr: ::in6_addr,\n+        pub sin6_scope_id: u32,\n+    }\n+\n+    pub struct passwd {\n+        pub pw_name: *mut ::c_char,\n+        pub pw_passwd: *mut ::c_char,\n+        pub pw_uid: ::uid_t,\n+        pub pw_gid: ::gid_t,\n+        pub pw_change: ::time_t,\n+        pub pw_class: *mut ::c_char,\n+        pub pw_gecos: *mut ::c_char,\n+        pub pw_dir: *mut ::c_char,\n+        pub pw_shell: *mut ::c_char,\n+        pub pw_expire: ::time_t,\n+\n+        #[cfg(not(any(target_os = \"macos\",\n+                      target_os = \"ios\",\n+                      target_os = \"netbsd\",\n+                      target_os = \"openbsd\")))]\n+        pub pw_fields: ::c_int,\n+    }\n+\n+    pub struct ifaddrs {\n+        pub ifa_next: *mut ifaddrs,\n+        pub ifa_name: *mut ::c_char,\n+        pub ifa_flags: ::c_uint,\n+        pub ifa_addr: *mut ::sockaddr,\n+        pub ifa_netmask: *mut ::sockaddr,\n+        pub ifa_dstaddr: *mut ::sockaddr,\n+        pub ifa_data: *mut ::c_void,\n+        #[cfg(target_os = \"netbsd\")]\n+        pub ifa_addrflags: ::c_uint\n+    }\n+\n+    pub struct fd_set {\n+        #[cfg(all(target_pointer_width = \"64\",\n+                  any(target_os = \"freebsd\", target_os = \"dragonfly\")))]\n+        fds_bits: [i64; FD_SETSIZE / 64],\n+        #[cfg(not(all(target_pointer_width = \"64\",\n+                      any(target_os = \"freebsd\", target_os = \"dragonfly\"))))]\n+        fds_bits: [i32; FD_SETSIZE / 32],\n+    }\n+\n+    pub struct tm {\n+        pub tm_sec: ::c_int,\n+        pub tm_min: ::c_int,\n+        pub tm_hour: ::c_int,\n+        pub tm_mday: ::c_int,\n+        pub tm_mon: ::c_int,\n+        pub tm_year: ::c_int,\n+        pub tm_wday: ::c_int,\n+        pub tm_yday: ::c_int,\n+        pub tm_isdst: ::c_int,\n+        pub tm_gmtoff: ::c_long,\n+        pub tm_zone: *mut ::c_char,\n+    }\n+\n+    pub struct msghdr {\n+        pub msg_name: *mut ::c_void,\n+        pub msg_namelen: ::socklen_t,\n+        pub msg_iov: *mut ::iovec,\n+        pub msg_iovlen: ::c_int,\n+        pub msg_control: *mut ::c_void,\n+        pub msg_controllen: ::socklen_t,\n+        pub msg_flags: ::c_int,\n+    }\n+\n+    pub struct cmsghdr {\n+        pub cmsg_len: ::socklen_t,\n+        pub cmsg_level: ::c_int,\n+        pub cmsg_type: ::c_int,\n+    }\n+\n+    pub struct fsid_t {\n+        __fsid_val: [i32; 2],\n+    }\n+\n+    pub struct if_nameindex {\n+        pub if_index: ::c_uint,\n+        pub if_name: *mut ::c_char,\n+    }\n+}\n+\n+s_no_extra_traits! {\n+    pub struct sockaddr_un {\n+        pub sun_len: u8,\n+        pub sun_family: sa_family_t,\n+        pub sun_path: [c_char; 104]\n+    }\n+\n+    pub struct utsname {\n+        #[cfg(not(target_os = \"dragonfly\"))]\n+        pub sysname: [::c_char; 256],\n+        #[cfg(target_os = \"dragonfly\")]\n+        pub sysname: [::c_char; 32],\n+        #[cfg(not(target_os = \"dragonfly\"))]\n+        pub nodename: [::c_char; 256],\n+        #[cfg(target_os = \"dragonfly\")]\n+        pub nodename: [::c_char; 32],\n+        #[cfg(not(target_os = \"dragonfly\"))]\n+        pub release: [::c_char; 256],\n+        #[cfg(target_os = \"dragonfly\")]\n+        pub release: [::c_char; 32],\n+        #[cfg(not(target_os = \"dragonfly\"))]\n+        pub version: [::c_char; 256],\n+        #[cfg(target_os = \"dragonfly\")]\n+        pub version: [::c_char; 32],\n+        #[cfg(not(target_os = \"dragonfly\"))]\n+        pub machine: [::c_char; 256],\n+        #[cfg(target_os = \"dragonfly\")]\n+        pub machine: [::c_char; 32],\n+    }\n+\n+}\n+\n+cfg_if! {\n+    if #[cfg(feature = \"extra_traits\")] {\n+        impl PartialEq for sockaddr_un {\n+            fn eq(&self, other: &sockaddr_un) -> bool {\n+                self.sun_len == other.sun_len\n+                    && self.sun_family == other.sun_family\n+                    && self\n+                    .sun_path\n+                    .iter()\n+                    .zip(other.sun_path.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+\n+        impl Eq for sockaddr_un {}\n+\n+        impl ::fmt::Debug for sockaddr_un {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"sockaddr_un\")\n+                    .field(\"sun_len\", &self.sun_len)\n+                    .field(\"sun_family\", &self.sun_family)\n+                // FIXME: .field(\"sun_path\", &self.sun_path)\n+                    .finish()\n+            }\n+        }\n+\n+        impl ::hash::Hash for sockaddr_un {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.sun_len.hash(state);\n+                self.sun_family.hash(state);\n+                self.sun_path.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for utsname {\n+            fn eq(&self, other: &utsname) -> bool {\n+                self.sysname\n+                    .iter()\n+                    .zip(other.sysname.iter())\n+                    .all(|(a,b)| a == b)\n+                    && self\n+                    .nodename\n+                    .iter()\n+                    .zip(other.nodename.iter())\n+                    .all(|(a,b)| a == b)\n+                    && self\n+                    .release\n+                    .iter()\n+                    .zip(other.release.iter())\n+                    .all(|(a,b)| a == b)\n+                    && self\n+                    .version\n+                    .iter()\n+                    .zip(other.version.iter())\n+                    .all(|(a,b)| a == b)\n+                    && self\n+                    .machine\n+                    .iter()\n+                    .zip(other.machine.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+\n+        impl Eq for utsname {}\n+\n+        impl ::fmt::Debug for utsname {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"utsname\")\n+                // FIXME: .field(\"sysname\", &self.sysname)\n+                // FIXME: .field(\"nodename\", &self.nodename)\n+                // FIXME: .field(\"release\", &self.release)\n+                // FIXME: .field(\"version\", &self.version)\n+                // FIXME: .field(\"machine\", &self.machine)\n+                    .finish()\n+            }\n+        }\n+\n+        impl ::hash::Hash for utsname {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.sysname.hash(state);\n+                self.nodename.hash(state);\n+                self.release.hash(state);\n+                self.version.hash(state);\n+                self.machine.hash(state);\n+            }\n+        }\n+    }\n+}\n+\n+pub const LC_ALL: ::c_int = 0;\n+pub const LC_COLLATE: ::c_int = 1;\n+pub const LC_CTYPE: ::c_int = 2;\n+pub const LC_MONETARY: ::c_int = 3;\n+pub const LC_NUMERIC: ::c_int = 4;\n+pub const LC_TIME: ::c_int = 5;\n+pub const LC_MESSAGES: ::c_int = 6;\n+\n+pub const FIOCLEX: ::c_ulong = 0x20006601;\n+pub const FIONCLEX: ::c_ulong = 0x20006602;\n+pub const FIONREAD: ::c_ulong = 0x4004667f;\n+pub const FIONBIO: ::c_ulong = 0x8004667e;\n+pub const FIOASYNC: ::c_ulong = 0x8004667d;\n+pub const FIOSETOWN: ::c_ulong = 0x8004667c;\n+pub const FIOGETOWN: ::c_ulong = 0x4004667b;\n+\n+pub const PATH_MAX: ::c_int = 1024;\n+\n+pub const SA_ONSTACK: ::c_int = 0x0001;\n+pub const SA_SIGINFO: ::c_int = 0x0040;\n+pub const SA_RESTART: ::c_int = 0x0002;\n+pub const SA_RESETHAND: ::c_int = 0x0004;\n+pub const SA_NOCLDSTOP: ::c_int = 0x0008;\n+pub const SA_NODEFER: ::c_int = 0x0010;\n+pub const SA_NOCLDWAIT: ::c_int = 0x0020;\n+\n+pub const SS_ONSTACK: ::c_int = 1;\n+pub const SS_DISABLE: ::c_int = 4;\n+\n+pub const SIGCHLD: ::c_int = 20;\n+pub const SIGBUS: ::c_int = 10;\n+pub const SIGUSR1: ::c_int = 30;\n+pub const SIGUSR2: ::c_int = 31;\n+pub const SIGCONT: ::c_int = 19;\n+pub const SIGSTOP: ::c_int = 17;\n+pub const SIGTSTP: ::c_int = 18;\n+pub const SIGURG: ::c_int = 16;\n+pub const SIGIO: ::c_int = 23;\n+pub const SIGSYS: ::c_int = 12;\n+pub const SIGTTIN: ::c_int = 21;\n+pub const SIGTTOU: ::c_int = 22;\n+pub const SIGXCPU: ::c_int = 24;\n+pub const SIGXFSZ: ::c_int = 25;\n+pub const SIGVTALRM: ::c_int = 26;\n+pub const SIGPROF: ::c_int = 27;\n+pub const SIGWINCH: ::c_int = 28;\n+pub const SIGINFO: ::c_int = 29;\n+\n+pub const SIG_SETMASK: ::c_int = 3;\n+pub const SIG_BLOCK: ::c_int = 0x1;\n+pub const SIG_UNBLOCK: ::c_int = 0x2;\n+\n+pub const IP_TOS: ::c_int = 3;\n+pub const IP_MULTICAST_IF: ::c_int = 9;\n+pub const IP_MULTICAST_TTL: ::c_int = 10;\n+pub const IP_MULTICAST_LOOP: ::c_int = 11;\n+\n+pub const IPV6_UNICAST_HOPS: ::c_int = 4;\n+pub const IPV6_MULTICAST_IF: ::c_int = 9;\n+pub const IPV6_MULTICAST_HOPS: ::c_int = 10;\n+pub const IPV6_MULTICAST_LOOP: ::c_int = 11;\n+pub const IPV6_V6ONLY: ::c_int = 27;\n+\n+pub const IPTOS_ECN_NOTECT: u8 = 0x00;\n+pub const IPTOS_ECN_MASK: u8 = 0x03;\n+pub const IPTOS_ECN_ECT1: u8 = 0x01;\n+pub const IPTOS_ECN_ECT0: u8 = 0x02;\n+pub const IPTOS_ECN_CE: u8 = 0x03;\n+\n+pub const ST_RDONLY: ::c_ulong = 1;\n+\n+pub const SCM_RIGHTS: ::c_int = 0x01;\n+\n+pub const NCCS: usize = 20;\n+\n+pub const O_ACCMODE: ::c_int = 0x3;\n+pub const O_RDONLY: ::c_int = 0;\n+pub const O_WRONLY: ::c_int = 1;\n+pub const O_RDWR: ::c_int = 2;\n+pub const O_APPEND: ::c_int = 8;\n+pub const O_CREAT: ::c_int = 512;\n+pub const O_TRUNC: ::c_int = 1024;\n+pub const O_EXCL: ::c_int = 2048;\n+pub const O_ASYNC: ::c_int = 0x40;\n+pub const O_SYNC: ::c_int = 0x80;\n+pub const O_NONBLOCK: ::c_int = 0x4;\n+pub const O_NOFOLLOW: ::c_int = 0x100;\n+pub const O_SHLOCK: ::c_int = 0x10;\n+pub const O_EXLOCK: ::c_int = 0x20;\n+pub const O_FSYNC: ::c_int = O_SYNC;\n+pub const O_NDELAY: ::c_int = O_NONBLOCK;\n+\n+pub const F_GETOWN: ::c_int = 5;\n+pub const F_SETOWN: ::c_int = 6;\n+\n+pub const F_RDLCK: ::c_short = 1;\n+pub const F_UNLCK: ::c_short = 2;\n+pub const F_WRLCK: ::c_short = 3;\n+\n+pub const MNT_FORCE: ::c_int = 0x80000;\n+\n+pub const Q_SYNC: ::c_int = 0x600;\n+pub const Q_QUOTAON: ::c_int = 0x100;\n+pub const Q_QUOTAOFF: ::c_int = 0x200;\n+\n+pub const TCIOFF: ::c_int = 3;\n+pub const TCION: ::c_int = 4;\n+pub const TCOOFF: ::c_int = 1;\n+pub const TCOON: ::c_int = 2;\n+pub const TCIFLUSH: ::c_int = 1;\n+pub const TCOFLUSH: ::c_int = 2;\n+pub const TCIOFLUSH: ::c_int = 3;\n+pub const TCSANOW: ::c_int = 0;\n+pub const TCSADRAIN: ::c_int = 1;\n+pub const TCSAFLUSH: ::c_int = 2;\n+pub const VEOF: usize = 0;\n+pub const VEOL: usize = 1;\n+pub const VEOL2: usize = 2;\n+pub const VERASE: usize = 3;\n+pub const VWERASE: usize = 4;\n+pub const VKILL: usize = 5;\n+pub const VREPRINT: usize = 6;\n+pub const VINTR: usize = 8;\n+pub const VQUIT: usize = 9;\n+pub const VSUSP: usize = 10;\n+pub const VDSUSP: usize = 11;\n+pub const VSTART: usize = 12;\n+pub const VSTOP: usize = 13;\n+pub const VLNEXT: usize = 14;\n+pub const VDISCARD: usize = 15;\n+pub const VMIN: usize = 16;\n+pub const VTIME: usize = 17;\n+pub const VSTATUS: usize = 18;\n+pub const _POSIX_VDISABLE: ::cc_t = 0xff;\n+pub const IGNBRK: ::tcflag_t = 0x00000001;\n+pub const BRKINT: ::tcflag_t = 0x00000002;\n+pub const IGNPAR: ::tcflag_t = 0x00000004;\n+pub const PARMRK: ::tcflag_t = 0x00000008;\n+pub const INPCK: ::tcflag_t = 0x00000010;\n+pub const ISTRIP: ::tcflag_t = 0x00000020;\n+pub const INLCR: ::tcflag_t = 0x00000040;\n+pub const IGNCR: ::tcflag_t = 0x00000080;\n+pub const ICRNL: ::tcflag_t = 0x00000100;\n+pub const IXON: ::tcflag_t = 0x00000200;\n+pub const IXOFF: ::tcflag_t = 0x00000400;\n+pub const IXANY: ::tcflag_t = 0x00000800;\n+pub const IMAXBEL: ::tcflag_t = 0x00002000;\n+pub const OPOST: ::tcflag_t = 0x1;\n+pub const ONLCR: ::tcflag_t = 0x2;\n+pub const OXTABS: ::tcflag_t = 0x4;\n+pub const ONOEOT: ::tcflag_t = 0x8;\n+pub const CIGNORE: ::tcflag_t = 0x00000001;\n+pub const CSIZE: ::tcflag_t = 0x00000300;\n+pub const CS5: ::tcflag_t = 0x00000000;\n+pub const CS6: ::tcflag_t = 0x00000100;\n+pub const CS7: ::tcflag_t = 0x00000200;\n+pub const CS8: ::tcflag_t = 0x00000300;\n+pub const CSTOPB: ::tcflag_t = 0x00000400;\n+pub const CREAD: ::tcflag_t = 0x00000800;\n+pub const PARENB: ::tcflag_t = 0x00001000;\n+pub const PARODD: ::tcflag_t = 0x00002000;\n+pub const HUPCL: ::tcflag_t = 0x00004000;\n+pub const CLOCAL: ::tcflag_t = 0x00008000;\n+pub const ECHOKE: ::tcflag_t = 0x00000001;\n+pub const ECHOE: ::tcflag_t = 0x00000002;\n+pub const ECHOK: ::tcflag_t = 0x00000004;\n+pub const ECHO: ::tcflag_t = 0x00000008;\n+pub const ECHONL: ::tcflag_t = 0x00000010;\n+pub const ECHOPRT: ::tcflag_t = 0x00000020;\n+pub const ECHOCTL: ::tcflag_t = 0x00000040;\n+pub const ISIG: ::tcflag_t = 0x00000080;\n+pub const ICANON: ::tcflag_t = 0x00000100;\n+pub const ALTWERASE: ::tcflag_t = 0x00000200;\n+pub const IEXTEN: ::tcflag_t = 0x00000400;\n+pub const EXTPROC: ::tcflag_t = 0x00000800;\n+pub const TOSTOP: ::tcflag_t = 0x00400000;\n+pub const FLUSHO: ::tcflag_t = 0x00800000;\n+pub const NOKERNINFO: ::tcflag_t = 0x02000000;\n+pub const PENDIN: ::tcflag_t = 0x20000000;\n+pub const NOFLSH: ::tcflag_t = 0x80000000;\n+pub const MDMBUF: ::tcflag_t = 0x00100000;\n+\n+pub const WNOHANG: ::c_int = 0x00000001;\n+pub const WUNTRACED: ::c_int = 0x00000002;\n+\n+pub const RTLD_LAZY: ::c_int = 0x1;\n+pub const RTLD_NOW: ::c_int = 0x2;\n+pub const RTLD_NEXT: *mut ::c_void = -1isize as *mut ::c_void;\n+pub const RTLD_DEFAULT: *mut ::c_void = -2isize as *mut ::c_void;\n+pub const RTLD_SELF: *mut ::c_void = -3isize as *mut ::c_void;\n+\n+pub const LOG_CRON: ::c_int = 9 << 3;\n+pub const LOG_AUTHPRIV: ::c_int = 10 << 3;\n+pub const LOG_FTP: ::c_int = 11 << 3;\n+pub const LOG_PERROR: ::c_int = 0x20;\n+\n+pub const TCP_NODELAY: ::c_int = 1;\n+pub const TCP_MAXSEG: ::c_int = 2;\n+\n+pub const PIPE_BUF: usize = 512;\n+\n+pub const POLLIN: ::c_short = 0x1;\n+pub const POLLPRI: ::c_short = 0x2;\n+pub const POLLOUT: ::c_short = 0x4;\n+pub const POLLERR: ::c_short = 0x8;\n+pub const POLLHUP: ::c_short = 0x10;\n+pub const POLLNVAL: ::c_short = 0x20;\n+pub const POLLRDNORM: ::c_short = 0x040;\n+pub const POLLWRNORM: ::c_short = 0x004;\n+pub const POLLRDBAND: ::c_short = 0x080;\n+pub const POLLWRBAND: ::c_short = 0x100;\n+\n+pub const BIOCGBLEN: ::c_ulong = 0x40044266;\n+pub const BIOCSBLEN: ::c_ulong = 0xc0044266;\n+pub const BIOCFLUSH: ::c_uint = 0x20004268;\n+pub const BIOCPROMISC: ::c_uint = 0x20004269;\n+pub const BIOCGDLT: ::c_ulong = 0x4004426a;\n+pub const BIOCGETIF: ::c_ulong = 0x4020426b;\n+pub const BIOCSETIF: ::c_ulong = 0x8020426c;\n+pub const BIOCGSTATS: ::c_ulong = 0x4008426f;\n+pub const BIOCIMMEDIATE: ::c_ulong = 0x80044270;\n+pub const BIOCVERSION: ::c_ulong = 0x40044271;\n+pub const BIOCGHDRCMPLT: ::c_ulong = 0x40044274;\n+pub const BIOCSHDRCMPLT: ::c_ulong = 0x80044275;\n+pub const SIOCGIFADDR: ::c_ulong = 0xc0206921;\n+\n+f! {\n+    pub fn CMSG_FIRSTHDR(mhdr: *const ::msghdr) -> *mut ::cmsghdr {\n+        if (*mhdr).msg_controllen as usize >= ::mem::size_of::<::cmsghdr>() {\n+            (*mhdr).msg_control as *mut ::cmsghdr\n+        } else {\n+            0 as *mut ::cmsghdr\n+        }\n+    }\n+\n+    pub fn FD_CLR(fd: ::c_int, set: *mut fd_set) -> () {\n+        let bits = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;\n+        let fd = fd as usize;\n+        (*set).fds_bits[fd / bits] &= !(1 << (fd % bits));\n+        return\n+    }\n+\n+    pub fn FD_ISSET(fd: ::c_int, set: *mut fd_set) -> bool {\n+        let bits = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;\n+        let fd = fd as usize;\n+        return ((*set).fds_bits[fd / bits] & (1 << (fd % bits))) != 0\n+    }\n+\n+    pub fn FD_SET(fd: ::c_int, set: *mut fd_set) -> () {\n+        let bits = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;\n+        let fd = fd as usize;\n+        (*set).fds_bits[fd / bits] |= 1 << (fd % bits);\n+        return\n+    }\n+\n+    pub fn FD_ZERO(set: *mut fd_set) -> () {\n+        for slot in (*set).fds_bits.iter_mut() {\n+            *slot = 0;\n+        }\n+    }\n+\n+    pub fn WTERMSIG(status: ::c_int) -> ::c_int {\n+        status & 0o177\n+    }\n+\n+    pub fn WIFEXITED(status: ::c_int) -> bool {\n+        (status & 0o177) == 0\n+    }\n+\n+    pub fn WEXITSTATUS(status: ::c_int) -> ::c_int {\n+        status >> 8\n+    }\n+\n+    pub fn WCOREDUMP(status: ::c_int) -> bool {\n+        (status & 0o200) != 0\n+    }\n+\n+    pub fn QCMD(cmd: ::c_int, type_: ::c_int) -> ::c_int {\n+        (cmd << 8) | (type_ & 0x00ff)\n+    }\n+}\n+\n+extern \"C\" {\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"getrlimit$UNIX2003\"\n+    )]\n+    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"setrlimit$UNIX2003\"\n+    )]\n+    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;\n+\n+    pub fn strerror_r(\n+        errnum: ::c_int,\n+        buf: *mut c_char,\n+        buflen: ::size_t,\n+    ) -> ::c_int;\n+    pub fn abs(i: ::c_int) -> ::c_int;\n+    pub fn atof(s: *const ::c_char) -> ::c_double;\n+    pub fn labs(i: ::c_long) -> ::c_long;\n+    pub fn rand() -> ::c_int;\n+    pub fn srand(seed: ::c_uint);\n+\n+    pub fn getifaddrs(ifap: *mut *mut ::ifaddrs) -> ::c_int;\n+    pub fn freeifaddrs(ifa: *mut ::ifaddrs);\n+    pub fn setgroups(ngroups: ::c_int, ptr: *const ::gid_t) -> ::c_int;\n+    pub fn ioctl(fd: ::c_int, request: ::c_ulong, ...) -> ::c_int;\n+    pub fn kqueue() -> ::c_int;\n+    pub fn unmount(target: *const ::c_char, arg: ::c_int) -> ::c_int;\n+    pub fn syscall(num: ::c_int, ...) -> ::c_int;\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__getpwent50\")]\n+    pub fn getpwent() -> *mut passwd;\n+    pub fn setpwent();\n+    pub fn endpwent();\n+    pub fn endgrent();\n+    pub fn getgrent() -> *mut ::group;\n+\n+    pub fn getprogname() -> *const ::c_char;\n+    pub fn setprogname(name: *const ::c_char);\n+    pub fn getloadavg(loadavg: *mut ::c_double, nelem: ::c_int) -> ::c_int;\n+    pub fn if_nameindex() -> *mut if_nameindex;\n+    pub fn if_freenameindex(ptr: *mut if_nameindex);\n+\n+    pub fn getpeereid(\n+        socket: ::c_int,\n+        euid: *mut ::uid_t,\n+        egid: *mut ::gid_t,\n+    ) -> ::c_int;\n+\n+    #[cfg_attr(target_os = \"macos\", link_name = \"glob$INODE64\")]\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__glob30\")]\n+    #[cfg_attr(\n+        all(target_os = \"freebsd\", any(freebsd11, freebsd10)),\n+        link_name = \"glob@FBSD_1.0\"\n+    )]\n+    pub fn glob(\n+        pattern: *const ::c_char,\n+        flags: ::c_int,\n+        errfunc: ::Option<\n+            extern \"C\" fn(epath: *const ::c_char, errno: ::c_int) -> ::c_int,\n+        >,\n+        pglob: *mut ::glob_t,\n+    ) -> ::c_int;\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__globfree30\")]\n+    #[cfg_attr(\n+        all(target_os = \"freebsd\", any(freebsd11, freebsd10)),\n+        link_name = \"globfree@FBSD_1.0\"\n+    )]\n+    pub fn globfree(pglob: *mut ::glob_t);\n+\n+    pub fn posix_madvise(\n+        addr: *mut ::c_void,\n+        len: ::size_t,\n+        advice: ::c_int,\n+    ) -> ::c_int;\n+\n+    pub fn shm_unlink(name: *const ::c_char) -> ::c_int;\n+\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86_64\"),\n+        link_name = \"seekdir$INODE64\"\n+    )]\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"seekdir$INODE64$UNIX2003\"\n+    )]\n+    pub fn seekdir(dirp: *mut ::DIR, loc: ::c_long);\n+\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86_64\"),\n+        link_name = \"telldir$INODE64\"\n+    )]\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"telldir$INODE64$UNIX2003\"\n+    )]\n+    pub fn telldir(dirp: *mut ::DIR) -> ::c_long;\n+    pub fn madvise(\n+        addr: *mut ::c_void,\n+        len: ::size_t,\n+        advice: ::c_int,\n+    ) -> ::c_int;\n+\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"msync$UNIX2003\"\n+    )]\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__msync13\")]\n+    pub fn msync(\n+        addr: *mut ::c_void,\n+        len: ::size_t,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"recvfrom$UNIX2003\"\n+    )]\n+    pub fn recvfrom(\n+        socket: ::c_int,\n+        buf: *mut ::c_void,\n+        len: ::size_t,\n+        flags: ::c_int,\n+        addr: *mut ::sockaddr,\n+        addrlen: *mut ::socklen_t,\n+    ) -> ::ssize_t;\n+    pub fn mkstemps(template: *mut ::c_char, suffixlen: ::c_int) -> ::c_int;\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__futimes50\")]\n+    pub fn futimes(fd: ::c_int, times: *const ::timeval) -> ::c_int;\n+    pub fn nl_langinfo(item: ::nl_item) -> *mut ::c_char;\n+\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"bind$UNIX2003\"\n+    )]\n+    pub fn bind(\n+        socket: ::c_int,\n+        address: *const ::sockaddr,\n+        address_len: ::socklen_t,\n+    ) -> ::c_int;\n+\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"writev$UNIX2003\"\n+    )]\n+    pub fn writev(\n+        fd: ::c_int,\n+        iov: *const ::iovec,\n+        iovcnt: ::c_int,\n+    ) -> ::ssize_t;\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"readv$UNIX2003\"\n+    )]\n+    pub fn readv(\n+        fd: ::c_int,\n+        iov: *const ::iovec,\n+        iovcnt: ::c_int,\n+    ) -> ::ssize_t;\n+\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"sendmsg$UNIX2003\"\n+    )]\n+    pub fn sendmsg(\n+        fd: ::c_int,\n+        msg: *const ::msghdr,\n+        flags: ::c_int,\n+    ) -> ::ssize_t;\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"recvmsg$UNIX2003\"\n+    )]\n+    pub fn recvmsg(\n+        fd: ::c_int,\n+        msg: *mut ::msghdr,\n+        flags: ::c_int,\n+    ) -> ::ssize_t;\n+\n+    pub fn sync();\n+    #[cfg_attr(target_os = \"solaris\", link_name = \"__posix_getgrgid_r\")]\n+    pub fn getgrgid_r(\n+        gid: ::gid_t,\n+        grp: *mut ::group,\n+        buf: *mut ::c_char,\n+        buflen: ::size_t,\n+        result: *mut *mut ::group,\n+    ) -> ::c_int;\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"sigaltstack$UNIX2003\"\n+    )]\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaltstack14\")]\n+    pub fn sigaltstack(ss: *const stack_t, oss: *mut stack_t) -> ::c_int;\n+    pub fn sem_close(sem: *mut sem_t) -> ::c_int;\n+    pub fn getdtablesize() -> ::c_int;\n+    #[cfg_attr(target_os = \"solaris\", link_name = \"__posix_getgrnam_r\")]\n+    pub fn getgrnam_r(\n+        name: *const ::c_char,\n+        grp: *mut ::group,\n+        buf: *mut ::c_char,\n+        buflen: ::size_t,\n+        result: *mut *mut ::group,\n+    ) -> ::c_int;\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"pthread_sigmask$UNIX2003\"\n+    )]\n+    pub fn pthread_sigmask(\n+        how: ::c_int,\n+        set: *const sigset_t,\n+        oldset: *mut sigset_t,\n+    ) -> ::c_int;\n+    pub fn sem_open(name: *const ::c_char, oflag: ::c_int, ...) -> *mut sem_t;\n+    pub fn getgrnam(name: *const ::c_char) -> *mut ::group;\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"pthread_cancel$UNIX2003\"\n+    )]\n+    pub fn pthread_cancel(thread: ::pthread_t) -> ::c_int;\n+    pub fn pthread_kill(thread: ::pthread_t, sig: ::c_int) -> ::c_int;\n+    pub fn sem_unlink(name: *const ::c_char) -> ::c_int;\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__getpwnam_r50\")]\n+    #[cfg_attr(target_os = \"solaris\", link_name = \"__posix_getpwnam_r\")]\n+    pub fn getpwnam_r(\n+        name: *const ::c_char,\n+        pwd: *mut passwd,\n+        buf: *mut ::c_char,\n+        buflen: ::size_t,\n+        result: *mut *mut passwd,\n+    ) -> ::c_int;\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__getpwuid_r50\")]\n+    #[cfg_attr(target_os = \"solaris\", link_name = \"__posix_getpwuid_r\")]\n+    pub fn getpwuid_r(\n+        uid: ::uid_t,\n+        pwd: *mut passwd,\n+        buf: *mut ::c_char,\n+        buflen: ::size_t,\n+        result: *mut *mut passwd,\n+    ) -> ::c_int;\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"sigwait$UNIX2003\"\n+    )]\n+    #[cfg_attr(target_os = \"solaris\", link_name = \"__posix_sigwait\")]\n+    pub fn sigwait(set: *const sigset_t, sig: *mut ::c_int) -> ::c_int;\n+    pub fn pthread_atfork(\n+        prepare: ::Option<unsafe extern \"C\" fn()>,\n+        parent: ::Option<unsafe extern \"C\" fn()>,\n+        child: ::Option<unsafe extern \"C\" fn()>,\n+    ) -> ::c_int;\n+    pub fn getgrgid(gid: ::gid_t) -> *mut ::group;\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"popen$UNIX2003\"\n+    )]\n+    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut ::FILE;\n+    pub fn faccessat(\n+        dirfd: ::c_int,\n+        pathname: *const ::c_char,\n+        mode: ::c_int,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+    pub fn pthread_create(\n+        native: *mut ::pthread_t,\n+        attr: *const ::pthread_attr_t,\n+        f: extern \"C\" fn(*mut ::c_void) -> *mut ::c_void,\n+        value: *mut ::c_void,\n+    ) -> ::c_int;\n+    pub fn acct(filename: *const ::c_char) -> ::c_int;\n+}\n+\n+cfg_if! {\n+    if #[cfg(any(target_os = \"macos\", target_os = \"ios\"))] {\n+        mod apple;\n+        pub use self::apple::*;\n+    } else if #[cfg(any(target_os = \"openbsd\", target_os = \"netbsd\"))] {\n+        mod netbsdlike;\n+        pub use self::netbsdlike::*;\n+    } else if #[cfg(any(target_os = \"freebsd\", target_os = \"dragonfly\"))] {\n+        mod freebsdlike;\n+        pub use self::freebsdlike::*;\n+    } else {\n+        // Unknown target_os\n+    }\n+}"
      },
      {
        "sha": "5ce68e2c17fa676960261080b21f4ee22999af54",
        "filename": "src/rusty/libc/src/unix/bsd/netbsdlike/mod.rs",
        "status": "added",
        "additions": 730,
        "deletions": 0,
        "changes": 730,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/netbsdlike/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,730 @@\n+pub type time_t = i64;\n+pub type mode_t = u32;\n+pub type nlink_t = u32;\n+pub type ino_t = u64;\n+pub type pthread_key_t = ::c_int;\n+pub type rlim_t = u64;\n+pub type speed_t = ::c_uint;\n+pub type tcflag_t = ::c_uint;\n+pub type nl_item = c_long;\n+pub type clockid_t = ::c_int;\n+pub type id_t = u32;\n+pub type sem_t = *mut sem;\n+\n+#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\n+pub enum timezone {}\n+impl ::Copy for timezone {}\n+impl ::Clone for timezone {\n+    fn clone(&self) -> timezone {\n+        *self\n+    }\n+}\n+#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\n+pub enum sem {}\n+impl ::Copy for sem {}\n+impl ::Clone for sem {\n+    fn clone(&self) -> sem {\n+        *self\n+    }\n+}\n+\n+s! {\n+    pub struct sigaction {\n+        pub sa_sigaction: ::sighandler_t,\n+        pub sa_mask: ::sigset_t,\n+        pub sa_flags: ::c_int,\n+    }\n+\n+    pub struct stack_t {\n+        pub ss_sp: *mut ::c_void,\n+        pub ss_size: ::size_t,\n+        pub ss_flags: ::c_int,\n+    }\n+\n+    pub struct in6_pktinfo {\n+        pub ipi6_addr: ::in6_addr,\n+        pub ipi6_ifindex: ::c_uint,\n+    }\n+\n+    pub struct termios {\n+        pub c_iflag: ::tcflag_t,\n+        pub c_oflag: ::tcflag_t,\n+        pub c_cflag: ::tcflag_t,\n+        pub c_lflag: ::tcflag_t,\n+        pub c_cc: [::cc_t; ::NCCS],\n+        pub c_ispeed: ::c_int,\n+        pub c_ospeed: ::c_int,\n+    }\n+\n+    pub struct flock {\n+        pub l_start: ::off_t,\n+        pub l_len: ::off_t,\n+        pub l_pid: ::pid_t,\n+        pub l_type: ::c_short,\n+        pub l_whence: ::c_short,\n+    }\n+}\n+\n+pub const D_T_FMT: ::nl_item = 0;\n+pub const D_FMT: ::nl_item = 1;\n+pub const T_FMT: ::nl_item = 2;\n+pub const T_FMT_AMPM: ::nl_item = 3;\n+pub const AM_STR: ::nl_item = 4;\n+pub const PM_STR: ::nl_item = 5;\n+\n+pub const DAY_1: ::nl_item = 6;\n+pub const DAY_2: ::nl_item = 7;\n+pub const DAY_3: ::nl_item = 8;\n+pub const DAY_4: ::nl_item = 9;\n+pub const DAY_5: ::nl_item = 10;\n+pub const DAY_6: ::nl_item = 11;\n+pub const DAY_7: ::nl_item = 12;\n+\n+pub const ABDAY_1: ::nl_item = 13;\n+pub const ABDAY_2: ::nl_item = 14;\n+pub const ABDAY_3: ::nl_item = 15;\n+pub const ABDAY_4: ::nl_item = 16;\n+pub const ABDAY_5: ::nl_item = 17;\n+pub const ABDAY_6: ::nl_item = 18;\n+pub const ABDAY_7: ::nl_item = 19;\n+\n+pub const MON_1: ::nl_item = 20;\n+pub const MON_2: ::nl_item = 21;\n+pub const MON_3: ::nl_item = 22;\n+pub const MON_4: ::nl_item = 23;\n+pub const MON_5: ::nl_item = 24;\n+pub const MON_6: ::nl_item = 25;\n+pub const MON_7: ::nl_item = 26;\n+pub const MON_8: ::nl_item = 27;\n+pub const MON_9: ::nl_item = 28;\n+pub const MON_10: ::nl_item = 29;\n+pub const MON_11: ::nl_item = 30;\n+pub const MON_12: ::nl_item = 31;\n+\n+pub const ABMON_1: ::nl_item = 32;\n+pub const ABMON_2: ::nl_item = 33;\n+pub const ABMON_3: ::nl_item = 34;\n+pub const ABMON_4: ::nl_item = 35;\n+pub const ABMON_5: ::nl_item = 36;\n+pub const ABMON_6: ::nl_item = 37;\n+pub const ABMON_7: ::nl_item = 38;\n+pub const ABMON_8: ::nl_item = 39;\n+pub const ABMON_9: ::nl_item = 40;\n+pub const ABMON_10: ::nl_item = 41;\n+pub const ABMON_11: ::nl_item = 42;\n+pub const ABMON_12: ::nl_item = 43;\n+\n+pub const RADIXCHAR: ::nl_item = 44;\n+pub const THOUSEP: ::nl_item = 45;\n+pub const YESSTR: ::nl_item = 46;\n+pub const YESEXPR: ::nl_item = 47;\n+pub const NOSTR: ::nl_item = 48;\n+pub const NOEXPR: ::nl_item = 49;\n+pub const CRNCYSTR: ::nl_item = 50;\n+\n+pub const CODESET: ::nl_item = 51;\n+\n+pub const EXIT_FAILURE: ::c_int = 1;\n+pub const EXIT_SUCCESS: ::c_int = 0;\n+pub const RAND_MAX: ::c_int = 2147483647;\n+pub const EOF: ::c_int = -1;\n+pub const SEEK_SET: ::c_int = 0;\n+pub const SEEK_CUR: ::c_int = 1;\n+pub const SEEK_END: ::c_int = 2;\n+pub const _IOFBF: ::c_int = 0;\n+pub const _IONBF: ::c_int = 2;\n+pub const _IOLBF: ::c_int = 1;\n+pub const BUFSIZ: ::c_uint = 1024;\n+pub const FOPEN_MAX: ::c_uint = 20;\n+pub const FILENAME_MAX: ::c_uint = 1024;\n+pub const L_tmpnam: ::c_uint = 1024;\n+pub const O_NOCTTY: ::c_int = 32768;\n+pub const S_IFIFO: mode_t = 4096;\n+pub const S_IFCHR: mode_t = 8192;\n+pub const S_IFBLK: mode_t = 24576;\n+pub const S_IFDIR: mode_t = 16384;\n+pub const S_IFREG: mode_t = 32768;\n+pub const S_IFLNK: mode_t = 40960;\n+pub const S_IFSOCK: mode_t = 49152;\n+pub const S_IFMT: mode_t = 61440;\n+pub const S_IEXEC: mode_t = 64;\n+pub const S_IWRITE: mode_t = 128;\n+pub const S_IREAD: mode_t = 256;\n+pub const S_IRWXU: mode_t = 448;\n+pub const S_IXUSR: mode_t = 64;\n+pub const S_IWUSR: mode_t = 128;\n+pub const S_IRUSR: mode_t = 256;\n+pub const S_IRWXG: mode_t = 56;\n+pub const S_IXGRP: mode_t = 8;\n+pub const S_IWGRP: mode_t = 16;\n+pub const S_IRGRP: mode_t = 32;\n+pub const S_IRWXO: mode_t = 7;\n+pub const S_IXOTH: mode_t = 1;\n+pub const S_IWOTH: mode_t = 2;\n+pub const S_IROTH: mode_t = 4;\n+pub const F_OK: ::c_int = 0;\n+pub const R_OK: ::c_int = 4;\n+pub const W_OK: ::c_int = 2;\n+pub const X_OK: ::c_int = 1;\n+pub const STDIN_FILENO: ::c_int = 0;\n+pub const STDOUT_FILENO: ::c_int = 1;\n+pub const STDERR_FILENO: ::c_int = 2;\n+pub const F_LOCK: ::c_int = 1;\n+pub const F_TEST: ::c_int = 3;\n+pub const F_TLOCK: ::c_int = 2;\n+pub const F_ULOCK: ::c_int = 0;\n+pub const F_GETLK: ::c_int = 7;\n+pub const F_SETLK: ::c_int = 8;\n+pub const F_SETLKW: ::c_int = 9;\n+pub const SIGHUP: ::c_int = 1;\n+pub const SIGINT: ::c_int = 2;\n+pub const SIGQUIT: ::c_int = 3;\n+pub const SIGILL: ::c_int = 4;\n+pub const SIGABRT: ::c_int = 6;\n+pub const SIGEMT: ::c_int = 7;\n+pub const SIGFPE: ::c_int = 8;\n+pub const SIGKILL: ::c_int = 9;\n+pub const SIGSEGV: ::c_int = 11;\n+pub const SIGPIPE: ::c_int = 13;\n+pub const SIGALRM: ::c_int = 14;\n+pub const SIGTERM: ::c_int = 15;\n+\n+pub const PROT_NONE: ::c_int = 0;\n+pub const PROT_READ: ::c_int = 1;\n+pub const PROT_WRITE: ::c_int = 2;\n+pub const PROT_EXEC: ::c_int = 4;\n+\n+pub const MAP_FILE: ::c_int = 0x0000;\n+pub const MAP_SHARED: ::c_int = 0x0001;\n+pub const MAP_PRIVATE: ::c_int = 0x0002;\n+pub const MAP_FIXED: ::c_int = 0x0010;\n+pub const MAP_ANON: ::c_int = 0x1000;\n+\n+pub const MAP_FAILED: *mut ::c_void = !0 as *mut ::c_void;\n+\n+pub const MCL_CURRENT: ::c_int = 0x0001;\n+pub const MCL_FUTURE: ::c_int = 0x0002;\n+\n+pub const MS_ASYNC: ::c_int = 0x0001;\n+\n+pub const EPERM: ::c_int = 1;\n+pub const ENOENT: ::c_int = 2;\n+pub const ESRCH: ::c_int = 3;\n+pub const EINTR: ::c_int = 4;\n+pub const EIO: ::c_int = 5;\n+pub const ENXIO: ::c_int = 6;\n+pub const E2BIG: ::c_int = 7;\n+pub const ENOEXEC: ::c_int = 8;\n+pub const EBADF: ::c_int = 9;\n+pub const ECHILD: ::c_int = 10;\n+pub const EDEADLK: ::c_int = 11;\n+pub const ENOMEM: ::c_int = 12;\n+pub const EACCES: ::c_int = 13;\n+pub const EFAULT: ::c_int = 14;\n+pub const ENOTBLK: ::c_int = 15;\n+pub const EBUSY: ::c_int = 16;\n+pub const EEXIST: ::c_int = 17;\n+pub const EXDEV: ::c_int = 18;\n+pub const ENODEV: ::c_int = 19;\n+pub const ENOTDIR: ::c_int = 20;\n+pub const EISDIR: ::c_int = 21;\n+pub const EINVAL: ::c_int = 22;\n+pub const ENFILE: ::c_int = 23;\n+pub const EMFILE: ::c_int = 24;\n+pub const ENOTTY: ::c_int = 25;\n+pub const ETXTBSY: ::c_int = 26;\n+pub const EFBIG: ::c_int = 27;\n+pub const ENOSPC: ::c_int = 28;\n+pub const ESPIPE: ::c_int = 29;\n+pub const EROFS: ::c_int = 30;\n+pub const EMLINK: ::c_int = 31;\n+pub const EPIPE: ::c_int = 32;\n+pub const EDOM: ::c_int = 33;\n+pub const ERANGE: ::c_int = 34;\n+pub const EAGAIN: ::c_int = 35;\n+pub const EWOULDBLOCK: ::c_int = 35;\n+pub const EINPROGRESS: ::c_int = 36;\n+pub const EALREADY: ::c_int = 37;\n+pub const ENOTSOCK: ::c_int = 38;\n+pub const EDESTADDRREQ: ::c_int = 39;\n+pub const EMSGSIZE: ::c_int = 40;\n+pub const EPROTOTYPE: ::c_int = 41;\n+pub const ENOPROTOOPT: ::c_int = 42;\n+pub const EPROTONOSUPPORT: ::c_int = 43;\n+pub const ESOCKTNOSUPPORT: ::c_int = 44;\n+pub const EOPNOTSUPP: ::c_int = 45;\n+pub const EPFNOSUPPORT: ::c_int = 46;\n+pub const EAFNOSUPPORT: ::c_int = 47;\n+pub const EADDRINUSE: ::c_int = 48;\n+pub const EADDRNOTAVAIL: ::c_int = 49;\n+pub const ENETDOWN: ::c_int = 50;\n+pub const ENETUNREACH: ::c_int = 51;\n+pub const ENETRESET: ::c_int = 52;\n+pub const ECONNABORTED: ::c_int = 53;\n+pub const ECONNRESET: ::c_int = 54;\n+pub const ENOBUFS: ::c_int = 55;\n+pub const EISCONN: ::c_int = 56;\n+pub const ENOTCONN: ::c_int = 57;\n+pub const ESHUTDOWN: ::c_int = 58;\n+pub const ETOOMANYREFS: ::c_int = 59;\n+pub const ETIMEDOUT: ::c_int = 60;\n+pub const ECONNREFUSED: ::c_int = 61;\n+pub const ELOOP: ::c_int = 62;\n+pub const ENAMETOOLONG: ::c_int = 63;\n+pub const EHOSTDOWN: ::c_int = 64;\n+pub const EHOSTUNREACH: ::c_int = 65;\n+pub const ENOTEMPTY: ::c_int = 66;\n+pub const EPROCLIM: ::c_int = 67;\n+pub const EUSERS: ::c_int = 68;\n+pub const EDQUOT: ::c_int = 69;\n+pub const ESTALE: ::c_int = 70;\n+pub const EREMOTE: ::c_int = 71;\n+pub const EBADRPC: ::c_int = 72;\n+pub const ERPCMISMATCH: ::c_int = 73;\n+pub const EPROGUNAVAIL: ::c_int = 74;\n+pub const EPROGMISMATCH: ::c_int = 75;\n+pub const EPROCUNAVAIL: ::c_int = 76;\n+pub const ENOLCK: ::c_int = 77;\n+pub const ENOSYS: ::c_int = 78;\n+pub const EFTYPE: ::c_int = 79;\n+pub const EAUTH: ::c_int = 80;\n+pub const ENEEDAUTH: ::c_int = 81;\n+\n+pub const F_DUPFD: ::c_int = 0;\n+pub const F_GETFD: ::c_int = 1;\n+pub const F_SETFD: ::c_int = 2;\n+pub const F_GETFL: ::c_int = 3;\n+pub const F_SETFL: ::c_int = 4;\n+\n+pub const SIGTRAP: ::c_int = 5;\n+\n+pub const GLOB_APPEND: ::c_int = 0x0001;\n+pub const GLOB_DOOFFS: ::c_int = 0x0002;\n+pub const GLOB_ERR: ::c_int = 0x0004;\n+pub const GLOB_MARK: ::c_int = 0x0008;\n+pub const GLOB_NOCHECK: ::c_int = 0x0010;\n+pub const GLOB_NOSORT: ::c_int = 0x0020;\n+pub const GLOB_NOESCAPE: ::c_int = 0x1000;\n+\n+pub const GLOB_NOSPACE: ::c_int = -1;\n+pub const GLOB_ABORTED: ::c_int = -2;\n+pub const GLOB_NOMATCH: ::c_int = -3;\n+pub const GLOB_NOSYS: ::c_int = -4;\n+\n+pub const POSIX_MADV_NORMAL: ::c_int = 0;\n+pub const POSIX_MADV_RANDOM: ::c_int = 1;\n+pub const POSIX_MADV_SEQUENTIAL: ::c_int = 2;\n+pub const POSIX_MADV_WILLNEED: ::c_int = 3;\n+pub const POSIX_MADV_DONTNEED: ::c_int = 4;\n+\n+pub const PTHREAD_CREATE_JOINABLE: ::c_int = 0;\n+pub const PTHREAD_CREATE_DETACHED: ::c_int = 1;\n+\n+pub const PT_TRACE_ME: ::c_int = 0;\n+pub const PT_READ_I: ::c_int = 1;\n+pub const PT_READ_D: ::c_int = 2;\n+pub const PT_WRITE_I: ::c_int = 4;\n+pub const PT_WRITE_D: ::c_int = 5;\n+pub const PT_CONTINUE: ::c_int = 7;\n+pub const PT_KILL: ::c_int = 8;\n+pub const PT_ATTACH: ::c_int = 9;\n+pub const PT_DETACH: ::c_int = 10;\n+pub const PT_IO: ::c_int = 11;\n+\n+// http://man.openbsd.org/OpenBSD-current/man2/clock_getres.2\n+// The man page says clock_gettime(3) can accept various values as clockid_t but\n+// http://fxr.watson.org/fxr/source/kern/kern_time.c?v=OPENBSD;im=excerpts#L161\n+// the implementation rejects anything other than the below two\n+//\n+// http://netbsd.gw.com/cgi-bin/man-cgi?clock_gettime\n+// https://github.com/jsonn/src/blob/HEAD/sys/kern/subr_time.c#L222\n+// Basically the same goes for NetBSD\n+pub const CLOCK_REALTIME: ::clockid_t = 0;\n+pub const CLOCK_MONOTONIC: ::clockid_t = 3;\n+\n+pub const RLIMIT_CPU: ::c_int = 0;\n+pub const RLIMIT_FSIZE: ::c_int = 1;\n+pub const RLIMIT_DATA: ::c_int = 2;\n+pub const RLIMIT_STACK: ::c_int = 3;\n+pub const RLIMIT_CORE: ::c_int = 4;\n+pub const RLIMIT_RSS: ::c_int = 5;\n+pub const RLIMIT_MEMLOCK: ::c_int = 6;\n+pub const RLIMIT_NPROC: ::c_int = 7;\n+pub const RLIMIT_NOFILE: ::c_int = 8;\n+\n+pub const RLIM_INFINITY: rlim_t = 0x7fff_ffff_ffff_ffff;\n+pub const RLIM_SAVED_MAX: rlim_t = RLIM_INFINITY;\n+pub const RLIM_SAVED_CUR: rlim_t = RLIM_INFINITY;\n+\n+pub const RUSAGE_SELF: ::c_int = 0;\n+pub const RUSAGE_CHILDREN: ::c_int = -1;\n+\n+pub const MADV_NORMAL: ::c_int = 0;\n+pub const MADV_RANDOM: ::c_int = 1;\n+pub const MADV_SEQUENTIAL: ::c_int = 2;\n+pub const MADV_WILLNEED: ::c_int = 3;\n+pub const MADV_DONTNEED: ::c_int = 4;\n+pub const MADV_FREE: ::c_int = 6;\n+\n+pub const AF_UNSPEC: ::c_int = 0;\n+pub const AF_LOCAL: ::c_int = 1;\n+pub const AF_UNIX: ::c_int = AF_LOCAL;\n+pub const AF_INET: ::c_int = 2;\n+pub const AF_IMPLINK: ::c_int = 3;\n+pub const AF_PUP: ::c_int = 4;\n+pub const AF_CHAOS: ::c_int = 5;\n+pub const AF_NS: ::c_int = 6;\n+pub const AF_ISO: ::c_int = 7;\n+pub const AF_OSI: ::c_int = AF_ISO;\n+pub const AF_DATAKIT: ::c_int = 9;\n+pub const AF_CCITT: ::c_int = 10;\n+pub const AF_SNA: ::c_int = 11;\n+pub const AF_DECnet: ::c_int = 12;\n+pub const AF_DLI: ::c_int = 13;\n+pub const AF_LAT: ::c_int = 14;\n+pub const AF_HYLINK: ::c_int = 15;\n+pub const AF_APPLETALK: ::c_int = 16;\n+pub const AF_LINK: ::c_int = 18;\n+pub const pseudo_AF_XTP: ::c_int = 19;\n+pub const AF_COIP: ::c_int = 20;\n+pub const AF_CNT: ::c_int = 21;\n+pub const pseudo_AF_RTIP: ::c_int = 22;\n+pub const AF_IPX: ::c_int = 23;\n+pub const AF_INET6: ::c_int = 24;\n+pub const pseudo_AF_PIP: ::c_int = 25;\n+pub const AF_ISDN: ::c_int = 26;\n+pub const AF_E164: ::c_int = AF_ISDN;\n+pub const AF_NATM: ::c_int = 27;\n+\n+pub const PF_UNSPEC: ::c_int = AF_UNSPEC;\n+pub const PF_LOCAL: ::c_int = AF_LOCAL;\n+pub const PF_UNIX: ::c_int = PF_LOCAL;\n+pub const PF_INET: ::c_int = AF_INET;\n+pub const PF_IMPLINK: ::c_int = AF_IMPLINK;\n+pub const PF_PUP: ::c_int = AF_PUP;\n+pub const PF_CHAOS: ::c_int = AF_CHAOS;\n+pub const PF_NS: ::c_int = AF_NS;\n+pub const PF_ISO: ::c_int = AF_ISO;\n+pub const PF_OSI: ::c_int = AF_ISO;\n+pub const PF_DATAKIT: ::c_int = AF_DATAKIT;\n+pub const PF_CCITT: ::c_int = AF_CCITT;\n+pub const PF_SNA: ::c_int = AF_SNA;\n+pub const PF_DECnet: ::c_int = AF_DECnet;\n+pub const PF_DLI: ::c_int = AF_DLI;\n+pub const PF_LAT: ::c_int = AF_LAT;\n+pub const PF_HYLINK: ::c_int = AF_HYLINK;\n+pub const PF_APPLETALK: ::c_int = AF_APPLETALK;\n+pub const PF_LINK: ::c_int = AF_LINK;\n+pub const PF_XTP: ::c_int = pseudo_AF_XTP;\n+pub const PF_COIP: ::c_int = AF_COIP;\n+pub const PF_CNT: ::c_int = AF_CNT;\n+pub const PF_IPX: ::c_int = AF_IPX;\n+pub const PF_INET6: ::c_int = AF_INET6;\n+pub const PF_RTIP: ::c_int = pseudo_AF_RTIP;\n+pub const PF_PIP: ::c_int = pseudo_AF_PIP;\n+pub const PF_ISDN: ::c_int = AF_ISDN;\n+pub const PF_NATM: ::c_int = AF_NATM;\n+\n+pub const SOCK_STREAM: ::c_int = 1;\n+pub const SOCK_DGRAM: ::c_int = 2;\n+pub const SOCK_RAW: ::c_int = 3;\n+pub const SOCK_RDM: ::c_int = 4;\n+pub const SOCK_SEQPACKET: ::c_int = 5;\n+pub const IP_TTL: ::c_int = 4;\n+pub const IP_HDRINCL: ::c_int = 2;\n+pub const IP_ADD_MEMBERSHIP: ::c_int = 12;\n+pub const IP_DROP_MEMBERSHIP: ::c_int = 13;\n+pub const IPV6_RECVPKTINFO: ::c_int = 36;\n+pub const IPV6_PKTINFO: ::c_int = 46;\n+pub const IPV6_RECVTCLASS: ::c_int = 57;\n+pub const IPV6_TCLASS: ::c_int = 61;\n+\n+pub const SOL_SOCKET: ::c_int = 0xffff;\n+pub const SO_DEBUG: ::c_int = 0x01;\n+pub const SO_ACCEPTCONN: ::c_int = 0x0002;\n+pub const SO_REUSEADDR: ::c_int = 0x0004;\n+pub const SO_KEEPALIVE: ::c_int = 0x0008;\n+pub const SO_DONTROUTE: ::c_int = 0x0010;\n+pub const SO_BROADCAST: ::c_int = 0x0020;\n+pub const SO_USELOOPBACK: ::c_int = 0x0040;\n+pub const SO_LINGER: ::c_int = 0x0080;\n+pub const SO_OOBINLINE: ::c_int = 0x0100;\n+pub const SO_REUSEPORT: ::c_int = 0x0200;\n+pub const SO_SNDBUF: ::c_int = 0x1001;\n+pub const SO_RCVBUF: ::c_int = 0x1002;\n+pub const SO_SNDLOWAT: ::c_int = 0x1003;\n+pub const SO_RCVLOWAT: ::c_int = 0x1004;\n+pub const SO_ERROR: ::c_int = 0x1007;\n+pub const SO_TYPE: ::c_int = 0x1008;\n+\n+pub const SOMAXCONN: ::c_int = 128;\n+\n+pub const MSG_OOB: ::c_int = 0x1;\n+pub const MSG_PEEK: ::c_int = 0x2;\n+pub const MSG_DONTROUTE: ::c_int = 0x4;\n+pub const MSG_EOR: ::c_int = 0x8;\n+pub const MSG_TRUNC: ::c_int = 0x10;\n+pub const MSG_CTRUNC: ::c_int = 0x20;\n+pub const MSG_WAITALL: ::c_int = 0x40;\n+pub const MSG_DONTWAIT: ::c_int = 0x80;\n+pub const MSG_BCAST: ::c_int = 0x100;\n+pub const MSG_MCAST: ::c_int = 0x200;\n+pub const MSG_NOSIGNAL: ::c_int = 0x400;\n+pub const MSG_CMSG_CLOEXEC: ::c_int = 0x800;\n+\n+pub const SHUT_RD: ::c_int = 0;\n+pub const SHUT_WR: ::c_int = 1;\n+pub const SHUT_RDWR: ::c_int = 2;\n+\n+pub const LOCK_SH: ::c_int = 1;\n+pub const LOCK_EX: ::c_int = 2;\n+pub const LOCK_NB: ::c_int = 4;\n+pub const LOCK_UN: ::c_int = 8;\n+\n+pub const IPPROTO_RAW: ::c_int = 255;\n+\n+pub const _SC_ARG_MAX: ::c_int = 1;\n+pub const _SC_CHILD_MAX: ::c_int = 2;\n+pub const _SC_NGROUPS_MAX: ::c_int = 4;\n+pub const _SC_OPEN_MAX: ::c_int = 5;\n+pub const _SC_JOB_CONTROL: ::c_int = 6;\n+pub const _SC_SAVED_IDS: ::c_int = 7;\n+pub const _SC_VERSION: ::c_int = 8;\n+pub const _SC_BC_BASE_MAX: ::c_int = 9;\n+pub const _SC_BC_DIM_MAX: ::c_int = 10;\n+pub const _SC_BC_SCALE_MAX: ::c_int = 11;\n+pub const _SC_BC_STRING_MAX: ::c_int = 12;\n+pub const _SC_COLL_WEIGHTS_MAX: ::c_int = 13;\n+pub const _SC_EXPR_NEST_MAX: ::c_int = 14;\n+pub const _SC_LINE_MAX: ::c_int = 15;\n+pub const _SC_RE_DUP_MAX: ::c_int = 16;\n+pub const _SC_2_VERSION: ::c_int = 17;\n+pub const _SC_2_C_BIND: ::c_int = 18;\n+pub const _SC_2_C_DEV: ::c_int = 19;\n+pub const _SC_2_CHAR_TERM: ::c_int = 20;\n+pub const _SC_2_FORT_DEV: ::c_int = 21;\n+pub const _SC_2_FORT_RUN: ::c_int = 22;\n+pub const _SC_2_LOCALEDEF: ::c_int = 23;\n+pub const _SC_2_SW_DEV: ::c_int = 24;\n+pub const _SC_2_UPE: ::c_int = 25;\n+pub const _SC_STREAM_MAX: ::c_int = 26;\n+pub const _SC_TZNAME_MAX: ::c_int = 27;\n+pub const _SC_PAGESIZE: ::c_int = 28;\n+pub const _SC_PAGE_SIZE: ::c_int = _SC_PAGESIZE;\n+pub const _SC_FSYNC: ::c_int = 29;\n+pub const _SC_XOPEN_SHM: ::c_int = 30;\n+\n+pub const Q_GETQUOTA: ::c_int = 0x300;\n+pub const Q_SETQUOTA: ::c_int = 0x400;\n+\n+pub const RTLD_GLOBAL: ::c_int = 0x100;\n+\n+pub const LOG_NFACILITIES: ::c_int = 24;\n+\n+pub const HW_NCPU: ::c_int = 3;\n+\n+pub const B0: speed_t = 0;\n+pub const B50: speed_t = 50;\n+pub const B75: speed_t = 75;\n+pub const B110: speed_t = 110;\n+pub const B134: speed_t = 134;\n+pub const B150: speed_t = 150;\n+pub const B200: speed_t = 200;\n+pub const B300: speed_t = 300;\n+pub const B600: speed_t = 600;\n+pub const B1200: speed_t = 1200;\n+pub const B1800: speed_t = 1800;\n+pub const B2400: speed_t = 2400;\n+pub const B4800: speed_t = 4800;\n+pub const B9600: speed_t = 9600;\n+pub const B19200: speed_t = 19200;\n+pub const B38400: speed_t = 38400;\n+pub const B7200: speed_t = 7200;\n+pub const B14400: speed_t = 14400;\n+pub const B28800: speed_t = 28800;\n+pub const B57600: speed_t = 57600;\n+pub const B76800: speed_t = 76800;\n+pub const B115200: speed_t = 115200;\n+pub const B230400: speed_t = 230400;\n+pub const EXTA: speed_t = 19200;\n+pub const EXTB: speed_t = 38400;\n+\n+pub const SEM_FAILED: *mut sem_t = 0 as *mut sem_t;\n+\n+pub const CRTSCTS: ::tcflag_t = 0x00010000;\n+pub const CRTS_IFLOW: ::tcflag_t = CRTSCTS;\n+pub const CCTS_OFLOW: ::tcflag_t = CRTSCTS;\n+pub const OCRNL: ::tcflag_t = 0x10;\n+\n+pub const TIOCEXCL: ::c_ulong = 0x2000740d;\n+pub const TIOCNXCL: ::c_ulong = 0x2000740e;\n+pub const TIOCFLUSH: ::c_ulong = 0x80047410;\n+pub const TIOCGETA: ::c_ulong = 0x402c7413;\n+pub const TIOCSETA: ::c_ulong = 0x802c7414;\n+pub const TIOCSETAW: ::c_ulong = 0x802c7415;\n+pub const TIOCSETAF: ::c_ulong = 0x802c7416;\n+pub const TIOCGETD: ::c_ulong = 0x4004741a;\n+pub const TIOCSETD: ::c_ulong = 0x8004741b;\n+pub const TIOCMGET: ::c_ulong = 0x4004746a;\n+pub const TIOCMBIC: ::c_ulong = 0x8004746b;\n+pub const TIOCMBIS: ::c_ulong = 0x8004746c;\n+pub const TIOCMSET: ::c_ulong = 0x8004746d;\n+pub const TIOCSTART: ::c_ulong = 0x2000746e;\n+pub const TIOCSTOP: ::c_ulong = 0x2000746f;\n+pub const TIOCSCTTY: ::c_ulong = 0x20007461;\n+pub const TIOCGWINSZ: ::c_ulong = 0x40087468;\n+pub const TIOCSWINSZ: ::c_ulong = 0x80087467;\n+pub const TIOCM_LE: ::c_int = 0o0001;\n+pub const TIOCM_DTR: ::c_int = 0o0002;\n+pub const TIOCM_RTS: ::c_int = 0o0004;\n+pub const TIOCM_ST: ::c_int = 0o0010;\n+pub const TIOCM_SR: ::c_int = 0o0020;\n+pub const TIOCM_CTS: ::c_int = 0o0040;\n+pub const TIOCM_CAR: ::c_int = 0o0100;\n+pub const TIOCM_RNG: ::c_int = 0o0200;\n+pub const TIOCM_DSR: ::c_int = 0o0400;\n+pub const TIOCM_CD: ::c_int = TIOCM_CAR;\n+pub const TIOCM_RI: ::c_int = TIOCM_RNG;\n+\n+// Flags for chflags(2)\n+pub const UF_SETTABLE: ::c_ulong = 0x0000ffff;\n+pub const UF_NODUMP: ::c_ulong = 0x00000001;\n+pub const UF_IMMUTABLE: ::c_ulong = 0x00000002;\n+pub const UF_APPEND: ::c_ulong = 0x00000004;\n+pub const UF_OPAQUE: ::c_ulong = 0x00000008;\n+pub const SF_SETTABLE: ::c_ulong = 0xffff0000;\n+pub const SF_ARCHIVED: ::c_ulong = 0x00010000;\n+pub const SF_IMMUTABLE: ::c_ulong = 0x00020000;\n+pub const SF_APPEND: ::c_ulong = 0x00040000;\n+\n+pub const TIMER_ABSTIME: ::c_int = 1;\n+\n+#[link(name = \"util\")]\n+extern \"C\" {\n+    pub fn setgrent();\n+    pub fn sem_destroy(sem: *mut sem_t) -> ::c_int;\n+    pub fn sem_init(\n+        sem: *mut sem_t,\n+        pshared: ::c_int,\n+        value: ::c_uint,\n+    ) -> ::c_int;\n+\n+    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;\n+    pub fn mincore(\n+        addr: *mut ::c_void,\n+        len: ::size_t,\n+        vec: *mut ::c_char,\n+    ) -> ::c_int;\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__clock_getres50\")]\n+    pub fn clock_getres(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__clock_gettime50\")]\n+    pub fn clock_gettime(clk_id: ::clockid_t, tp: *mut ::timespec) -> ::c_int;\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__clock_settime50\")]\n+    pub fn clock_settime(\n+        clk_id: ::clockid_t,\n+        tp: *const ::timespec,\n+    ) -> ::c_int;\n+    pub fn __errno() -> *mut ::c_int;\n+    pub fn shm_open(\n+        name: *const ::c_char,\n+        oflag: ::c_int,\n+        mode: ::mode_t,\n+    ) -> ::c_int;\n+    pub fn memrchr(\n+        cx: *const ::c_void,\n+        c: ::c_int,\n+        n: ::size_t,\n+    ) -> *mut ::c_void;\n+    pub fn mkostemp(template: *mut ::c_char, flags: ::c_int) -> ::c_int;\n+    pub fn mkostemps(\n+        template: *mut ::c_char,\n+        suffixlen: ::c_int,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+    pub fn pwritev(\n+        fd: ::c_int,\n+        iov: *const ::iovec,\n+        iovcnt: ::c_int,\n+        offset: ::off_t,\n+    ) -> ::ssize_t;\n+    pub fn preadv(\n+        fd: ::c_int,\n+        iov: *const ::iovec,\n+        iovcnt: ::c_int,\n+        offset: ::off_t,\n+    ) -> ::ssize_t;\n+    pub fn futimens(fd: ::c_int, times: *const ::timespec) -> ::c_int;\n+    pub fn utimensat(\n+        dirfd: ::c_int,\n+        path: *const ::c_char,\n+        times: *const ::timespec,\n+        flag: ::c_int,\n+    ) -> ::c_int;\n+    pub fn fdatasync(fd: ::c_int) -> ::c_int;\n+    pub fn openpty(\n+        amaster: *mut ::c_int,\n+        aslave: *mut ::c_int,\n+        name: *mut ::c_char,\n+        termp: *mut termios,\n+        winp: *mut ::winsize,\n+    ) -> ::c_int;\n+    pub fn forkpty(\n+        amaster: *mut ::c_int,\n+        name: *mut ::c_char,\n+        termp: *mut termios,\n+        winp: *mut ::winsize,\n+    ) -> ::pid_t;\n+    pub fn login_tty(fd: ::c_int) -> ::c_int;\n+    pub fn getpriority(which: ::c_int, who: ::id_t) -> ::c_int;\n+    pub fn setpriority(which: ::c_int, who: ::id_t, prio: ::c_int) -> ::c_int;\n+\n+    pub fn mknodat(\n+        dirfd: ::c_int,\n+        pathname: *const ::c_char,\n+        mode: ::mode_t,\n+        dev: dev_t,\n+    ) -> ::c_int;\n+    pub fn mkfifoat(\n+        dirfd: ::c_int,\n+        pathname: *const ::c_char,\n+        mode: ::mode_t,\n+    ) -> ::c_int;\n+    pub fn sem_timedwait(\n+        sem: *mut sem_t,\n+        abstime: *const ::timespec,\n+    ) -> ::c_int;\n+    pub fn sem_getvalue(sem: *mut sem_t, sval: *mut ::c_int) -> ::c_int;\n+    pub fn pthread_condattr_setclock(\n+        attr: *mut pthread_condattr_t,\n+        clock_id: ::clockid_t,\n+    ) -> ::c_int;\n+    pub fn sethostname(name: *const ::c_char, len: ::size_t) -> ::c_int;\n+    pub fn pthread_mutex_timedlock(\n+        lock: *mut pthread_mutex_t,\n+        abstime: *const ::timespec,\n+    ) -> ::c_int;\n+    pub fn pipe2(fds: *mut ::c_int, flags: ::c_int) -> ::c_int;\n+\n+    pub fn getgrouplist(\n+        name: *const ::c_char,\n+        basegid: ::gid_t,\n+        groups: *mut ::gid_t,\n+        ngroups: *mut ::c_int,\n+    ) -> ::c_int;\n+    pub fn initgroups(name: *const ::c_char, basegid: ::gid_t) -> ::c_int;\n+    pub fn getdomainname(name: *mut ::c_char, len: ::size_t) -> ::c_int;\n+    pub fn setdomainname(name: *const ::c_char, len: ::size_t) -> ::c_int;\n+    pub fn uname(buf: *mut ::utsname) -> ::c_int;\n+}\n+\n+cfg_if! {\n+    if #[cfg(target_os = \"netbsd\")] {\n+        mod netbsd;\n+        pub use self::netbsd::*;\n+    } else if #[cfg(target_os = \"openbsd\")] {\n+        mod openbsd;\n+        pub use self::openbsd::*;\n+    } else {\n+        // Unknown target_os\n+    }\n+}"
      },
      {
        "sha": "58c4cf7c4552639f2e6defc6a00e510f13be308c",
        "filename": "src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/aarch64.rs",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/aarch64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/aarch64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/aarch64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,22 @@\n+use PT_FIRSTMACH;\n+\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type c_char = u8;\n+pub type __cpu_simple_lock_nv_t = ::c_uchar;\n+\n+// should be pub(crate), but that requires Rust 1.18.0\n+cfg_if! {\n+    if #[cfg(libc_const_size_of)] {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_int>() - 1;\n+    } else {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = 4 - 1;\n+    }\n+}\n+\n+pub const PT_GETREGS: ::c_int = PT_FIRSTMACH + 0;\n+pub const PT_SETREGS: ::c_int = PT_FIRSTMACH + 1;\n+pub const PT_GETFPREGS: ::c_int = PT_FIRSTMACH + 2;\n+pub const PT_SETFPREGS: ::c_int = PT_FIRSTMACH + 3;"
      },
      {
        "sha": "4bf3ccd02b2c4cdc091f4238df920cfa37c1c78d",
        "filename": "src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/arm.rs",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/arm.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/arm.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/arm.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,22 @@\n+use PT_FIRSTMACH;\n+\n+pub type c_long = i32;\n+pub type c_ulong = u32;\n+pub type c_char = u8;\n+pub type __cpu_simple_lock_nv_t = ::c_int;\n+\n+// should be pub(crate), but that requires Rust 1.18.0\n+cfg_if! {\n+    if #[cfg(libc_const_size_of)] {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_longlong>() - 1;\n+    } else {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = 8 - 1;\n+    }\n+}\n+\n+pub const PT_GETREGS: ::c_int = PT_FIRSTMACH + 1;\n+pub const PT_SETREGS: ::c_int = PT_FIRSTMACH + 2;\n+pub const PT_GETFPREGS: ::c_int = PT_FIRSTMACH + 3;\n+pub const PT_SETFPREGS: ::c_int = PT_FIRSTMACH + 4;"
      },
      {
        "sha": "97e2634ad8ecc8325b6248789cbbe007774eee3f",
        "filename": "src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/mod.rs",
        "status": "added",
        "additions": 1761,
        "deletions": 0,
        "changes": 1761,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,1761 @@\n+pub type clock_t = ::c_uint;\n+pub type suseconds_t = ::c_int;\n+pub type dev_t = u64;\n+pub type blksize_t = i32;\n+pub type fsblkcnt_t = u64;\n+pub type fsfilcnt_t = u64;\n+pub type idtype_t = ::c_int;\n+pub type mqd_t = ::c_int;\n+type __pthread_spin_t = __cpu_simple_lock_nv_t;\n+pub type vm_size_t = ::uintptr_t;\n+pub type lwpid_t = ::c_uint;\n+\n+impl siginfo_t {\n+    pub unsafe fn si_value(&self) -> ::sigval {\n+        #[repr(C)]\n+        struct siginfo_timer {\n+            _si_signo: ::c_int,\n+            _si_errno: ::c_int,\n+            _si_code: ::c_int,\n+            __pad1: ::c_int,\n+            _pid: ::pid_t,\n+            _uid: ::uid_t,\n+            value: ::sigval,\n+        }\n+        (*(self as *const siginfo_t as *const siginfo_timer)).value\n+    }\n+}\n+\n+s! {\n+    pub struct aiocb {\n+        pub aio_offset: ::off_t,\n+        pub aio_buf: *mut ::c_void,\n+        pub aio_nbytes: ::size_t,\n+        pub aio_fildes: ::c_int,\n+        pub aio_lio_opcode: ::c_int,\n+        pub aio_reqprio: ::c_int,\n+        pub aio_sigevent: ::sigevent,\n+        _state: ::c_int,\n+        _errno: ::c_int,\n+        _retval: ::ssize_t\n+    }\n+\n+    pub struct glob_t {\n+        pub gl_pathc:   ::size_t,\n+        pub gl_matchc:  ::size_t,\n+        pub gl_offs:    ::size_t,\n+        pub gl_flags:   ::c_int,\n+        pub gl_pathv:   *mut *mut ::c_char,\n+\n+        __unused3: *mut ::c_void,\n+\n+        __unused4: *mut ::c_void,\n+        __unused5: *mut ::c_void,\n+        __unused6: *mut ::c_void,\n+        __unused7: *mut ::c_void,\n+        __unused8: *mut ::c_void,\n+    }\n+\n+    pub struct mq_attr {\n+        pub mq_flags: ::c_long,\n+        pub mq_maxmsg: ::c_long,\n+        pub mq_msgsize: ::c_long,\n+        pub mq_curmsgs: ::c_long,\n+    }\n+\n+    pub struct sigset_t {\n+        __bits: [u32; 4],\n+    }\n+\n+    pub struct stat {\n+        pub st_dev: ::dev_t,\n+        pub st_mode: ::mode_t,\n+        pub st_ino: ::ino_t,\n+        pub st_nlink: ::nlink_t,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        pub st_rdev: ::dev_t,\n+        pub st_atime: ::time_t,\n+        pub st_atimensec: ::c_long,\n+        pub st_mtime: ::time_t,\n+        pub st_mtimensec: ::c_long,\n+        pub st_ctime: ::time_t,\n+        pub st_ctimensec: ::c_long,\n+        pub st_birthtime: ::time_t,\n+        pub st_birthtimensec: ::c_long,\n+        pub st_size: ::off_t,\n+        pub st_blocks: ::blkcnt_t,\n+        pub st_blksize: ::blksize_t,\n+        pub st_flags: u32,\n+        pub st_gen: u32,\n+        pub st_spare: [u32; 2],\n+    }\n+\n+     pub struct addrinfo {\n+        pub ai_flags: ::c_int,\n+        pub ai_family: ::c_int,\n+        pub ai_socktype: ::c_int,\n+        pub ai_protocol: ::c_int,\n+        pub ai_addrlen: ::socklen_t,\n+        pub ai_canonname: *mut ::c_char,\n+        pub ai_addr: *mut ::sockaddr,\n+        pub ai_next: *mut ::addrinfo,\n+    }\n+\n+    pub struct siginfo_t {\n+        pub si_signo: ::c_int,\n+        pub si_code: ::c_int,\n+        pub si_errno: ::c_int,\n+        __pad1: ::c_int,\n+        pub si_addr: *mut ::c_void,\n+        __pad2: [u64; 13],\n+    }\n+\n+    pub struct pthread_attr_t {\n+        pta_magic: ::c_uint,\n+        pta_flags: ::c_int,\n+        pta_private: *mut ::c_void,\n+    }\n+\n+    pub struct pthread_mutex_t {\n+        ptm_magic: ::c_uint,\n+        ptm_errorcheck: __pthread_spin_t,\n+        #[cfg(any(target_arch = \"sparc\", target_arch = \"sparc64\",\n+                  target_arch = \"x86\", target_arch = \"x86_64\"))]\n+        ptm_pad1: [u8; 3],\n+        // actually a union with a non-unused, 0-initialized field\n+        ptm_unused: __pthread_spin_t,\n+        #[cfg(any(target_arch = \"sparc\", target_arch = \"sparc64\",\n+                  target_arch = \"x86\", target_arch = \"x86_64\"))]\n+        ptm_pad2: [u8; 3],\n+        ptm_owner: ::pthread_t,\n+        ptm_waiters: *mut u8,\n+        ptm_recursed: ::c_uint,\n+        ptm_spare2: *mut ::c_void,\n+    }\n+\n+    pub struct pthread_mutexattr_t {\n+        ptma_magic: ::c_uint,\n+        ptma_private: *mut ::c_void,\n+    }\n+\n+    pub struct pthread_rwlockattr_t {\n+        ptra_magic: ::c_uint,\n+        ptra_private: *mut ::c_void,\n+    }\n+\n+    pub struct pthread_cond_t {\n+        ptc_magic: ::c_uint,\n+        ptc_lock: __pthread_spin_t,\n+        ptc_waiters_first: *mut u8,\n+        ptc_waiters_last: *mut u8,\n+        ptc_mutex: *mut ::pthread_mutex_t,\n+        ptc_private: *mut ::c_void,\n+    }\n+\n+    pub struct pthread_condattr_t {\n+        ptca_magic: ::c_uint,\n+        ptca_private: *mut ::c_void,\n+    }\n+\n+    pub struct pthread_rwlock_t {\n+        ptr_magic: ::c_uint,\n+        ptr_interlock: __pthread_spin_t,\n+        ptr_rblocked_first: *mut u8,\n+        ptr_rblocked_last: *mut u8,\n+        ptr_wblocked_first: *mut u8,\n+        ptr_wblocked_last: *mut u8,\n+        ptr_nreaders: ::c_uint,\n+        ptr_owner: ::pthread_t,\n+        ptr_private: *mut ::c_void,\n+    }\n+\n+    pub struct kevent {\n+        pub ident: ::uintptr_t,\n+        pub filter: u32,\n+        pub flags: u32,\n+        pub fflags: u32,\n+        pub data: i64,\n+        pub udata: ::intptr_t,\n+    }\n+\n+    pub struct dqblk {\n+        pub dqb_bhardlimit: u32,\n+        pub dqb_bsoftlimit: u32,\n+        pub dqb_curblocks: u32,\n+        pub dqb_ihardlimit: u32,\n+        pub dqb_isoftlimit: u32,\n+        pub dqb_curinodes: u32,\n+        pub dqb_btime: i32,\n+        pub dqb_itime: i32,\n+    }\n+\n+    pub struct Dl_info {\n+        pub dli_fname: *const ::c_char,\n+        pub dli_fbase: *mut ::c_void,\n+        pub dli_sname: *const ::c_char,\n+        pub dli_saddr: *const ::c_void,\n+    }\n+\n+    pub struct lconv {\n+        pub decimal_point: *mut ::c_char,\n+        pub thousands_sep: *mut ::c_char,\n+        pub grouping: *mut ::c_char,\n+        pub int_curr_symbol: *mut ::c_char,\n+        pub currency_symbol: *mut ::c_char,\n+        pub mon_decimal_point: *mut ::c_char,\n+        pub mon_thousands_sep: *mut ::c_char,\n+        pub mon_grouping: *mut ::c_char,\n+        pub positive_sign: *mut ::c_char,\n+        pub negative_sign: *mut ::c_char,\n+        pub int_frac_digits: ::c_char,\n+        pub frac_digits: ::c_char,\n+        pub p_cs_precedes: ::c_char,\n+        pub p_sep_by_space: ::c_char,\n+        pub n_cs_precedes: ::c_char,\n+        pub n_sep_by_space: ::c_char,\n+        pub p_sign_posn: ::c_char,\n+        pub n_sign_posn: ::c_char,\n+        pub int_p_cs_precedes: ::c_char,\n+        pub int_n_cs_precedes: ::c_char,\n+        pub int_p_sep_by_space: ::c_char,\n+        pub int_n_sep_by_space: ::c_char,\n+        pub int_p_sign_posn: ::c_char,\n+        pub int_n_sign_posn: ::c_char,\n+    }\n+\n+    pub struct if_data {\n+        pub ifi_type: ::c_uchar,\n+        pub ifi_addrlen: ::c_uchar,\n+        pub ifi_hdrlen: ::c_uchar,\n+        pub ifi_link_state: ::c_int,\n+        pub ifi_mtu: u64,\n+        pub ifi_metric: u64,\n+        pub ifi_baudrate: u64,\n+        pub ifi_ipackets: u64,\n+        pub ifi_ierrors: u64,\n+        pub ifi_opackets: u64,\n+        pub ifi_oerrors: u64,\n+        pub ifi_collisions: u64,\n+        pub ifi_ibytes: u64,\n+        pub ifi_obytes: u64,\n+        pub ifi_imcasts: u64,\n+        pub ifi_omcasts: u64,\n+        pub ifi_iqdrops: u64,\n+        pub ifi_noproto: u64,\n+        pub ifi_lastchange: ::timespec,\n+    }\n+\n+    pub struct if_msghdr {\n+        pub ifm_msglen: ::c_ushort,\n+        pub ifm_version: ::c_uchar,\n+        pub ifm_type: ::c_uchar,\n+        pub ifm_addrs: ::c_int,\n+        pub ifm_flags: ::c_int,\n+        pub ifm_index: ::c_ushort,\n+        pub ifm_data: if_data,\n+    }\n+\n+    pub struct sockcred {\n+        pub sc_pid: ::pid_t,\n+        pub sc_uid: ::uid_t,\n+        pub sc_euid: ::uid_t,\n+        pub sc_gid: ::gid_t,\n+        pub sc_egid: ::gid_t,\n+        pub sc_ngroups: ::c_int,\n+        pub sc_groups: [::gid_t; 1],\n+    }\n+\n+    pub struct sockaddr_dl {\n+        pub sdl_len: ::c_uchar,\n+        pub sdl_family: ::c_uchar,\n+        pub sdl_index: ::c_ushort,\n+        pub sdl_type: u8,\n+        pub sdl_nlen: u8,\n+        pub sdl_alen: u8,\n+        pub sdl_slen: u8,\n+        pub sdl_data: [::c_char; 12],\n+    }\n+\n+    pub struct mmsghdr {\n+        pub msg_hdr: ::msghdr,\n+        pub msg_len: ::c_uint,\n+    }\n+}\n+\n+s_no_extra_traits! {\n+    pub struct in_pktinfo {\n+        pub ipi_addr: ::in_addr,\n+        pub ipi_ifindex: ::c_uint,\n+    }\n+\n+    #[repr(packed)]\n+    pub struct arphdr {\n+        pub ar_hrd: u16,\n+        pub ar_pro: u16,\n+        pub ar_hln: u8,\n+        pub ar_pln: u8,\n+        pub ar_op: u16,\n+    }\n+\n+    #[repr(packed)]\n+    pub struct in_addr {\n+        pub s_addr: ::in_addr_t,\n+    }\n+\n+    pub struct ip_mreq {\n+        pub imr_multiaddr: in_addr,\n+        pub imr_interface: in_addr,\n+    }\n+\n+    pub struct sockaddr_in {\n+        pub sin_len: u8,\n+        pub sin_family: ::sa_family_t,\n+        pub sin_port: ::in_port_t,\n+        pub sin_addr: ::in_addr,\n+        pub sin_zero: [i8; 8],\n+    }\n+\n+    pub struct dirent {\n+        pub d_fileno: ::ino_t,\n+        pub d_reclen: u16,\n+        pub d_namlen: u16,\n+        pub d_type: u8,\n+        pub d_name: [::c_char; 512],\n+    }\n+\n+    pub struct statvfs {\n+        pub f_flag: ::c_ulong,\n+        pub f_bsize: ::c_ulong,\n+        pub f_frsize: ::c_ulong,\n+        pub f_iosize: ::c_ulong,\n+\n+        pub f_blocks: ::fsblkcnt_t,\n+        pub f_bfree: ::fsblkcnt_t,\n+        pub f_bavail: ::fsblkcnt_t,\n+        pub f_bresvd: ::fsblkcnt_t,\n+\n+        pub f_files: ::fsfilcnt_t,\n+        pub f_ffree: ::fsfilcnt_t,\n+        pub f_favail: ::fsfilcnt_t,\n+        pub f_fresvd: ::fsfilcnt_t,\n+\n+        pub f_syncreads: u64,\n+        pub f_syncwrites: u64,\n+\n+        pub f_asyncreads: u64,\n+        pub f_asyncwrites: u64,\n+\n+        pub f_fsidx: ::fsid_t,\n+        pub f_fsid: ::c_ulong,\n+        pub f_namemax: ::c_ulong,\n+        pub f_owner: ::uid_t,\n+\n+        pub f_spare: [u32; 4],\n+\n+        pub f_fstypename: [::c_char; 32],\n+        pub f_mntonname: [::c_char; 1024],\n+        pub f_mntfromname: [::c_char; 1024],\n+    }\n+\n+    pub struct sockaddr_storage {\n+        pub ss_len: u8,\n+        pub ss_family: ::sa_family_t,\n+        __ss_pad1: [u8; 6],\n+        __ss_pad2: i64,\n+        __ss_pad3: [u8; 112],\n+    }\n+\n+    pub struct sigevent {\n+        pub sigev_notify: ::c_int,\n+        pub sigev_signo: ::c_int,\n+        pub sigev_value: ::sigval,\n+        __unused1: *mut ::c_void,       //actually a function pointer\n+        pub sigev_notify_attributes: *mut ::c_void\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(feature = \"extra_traits\")] {\n+        impl PartialEq for in_pktinfo {\n+            fn eq(&self, other: &in_pktinfo) -> bool {\n+                self.ipi_addr == other.ipi_addr\n+                    && self.ipi_ifindex == other.ipi_ifindex\n+            }\n+        }\n+        impl Eq for in_pktinfo {}\n+        impl ::fmt::Debug for in_pktinfo {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"in_pktinfo\")\n+                    .field(\"ipi_addr\", &self.ipi_addr)\n+                    .field(\"ipi_ifindex\", &self.ipi_ifindex)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for in_pktinfo {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.ipi_addr.hash(state);\n+                self.ipi_ifindex.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for arphdr {\n+            fn eq(&self, other: &arphdr) -> bool {\n+                self.ar_hrd == other.ar_hrd\n+                    && self.ar_pro == other.ar_pro\n+                    && self.ar_hln == other.ar_hln\n+                    && self.ar_pln == other.ar_pln\n+                    && self.ar_op == other.ar_op\n+            }\n+        }\n+        impl Eq for arphdr {}\n+        impl ::fmt::Debug for arphdr {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                let ar_hrd = self.ar_hrd;\n+                let ar_pro = self.ar_pro;\n+                let ar_op = self.ar_op;\n+                f.debug_struct(\"arphdr\")\n+                    .field(\"ar_hrd\", &ar_hrd)\n+                    .field(\"ar_pro\", &ar_pro)\n+                    .field(\"ar_hln\", &self.ar_hln)\n+                    .field(\"ar_pln\", &self.ar_pln)\n+                    .field(\"ar_op\", &ar_op)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for arphdr {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                let ar_hrd = self.ar_hrd;\n+                let ar_pro = self.ar_pro;\n+                let ar_op = self.ar_op;\n+                ar_hrd.hash(state);\n+                ar_pro.hash(state);\n+                self.ar_hln.hash(state);\n+                self.ar_pln.hash(state);\n+                ar_op.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for in_addr {\n+            fn eq(&self, other: &in_addr) -> bool {\n+                self.s_addr == other.s_addr\n+            }\n+        }\n+        impl Eq for in_addr {}\n+        impl ::fmt::Debug for in_addr {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                let s_addr = self.s_addr;\n+                f.debug_struct(\"in_addr\")\n+                    .field(\"s_addr\", &s_addr)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for in_addr {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                let s_addr = self.s_addr;\n+                s_addr.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for ip_mreq {\n+            fn eq(&self, other: &ip_mreq) -> bool {\n+                self.imr_multiaddr == other.imr_multiaddr\n+                    && self.imr_interface == other.imr_interface\n+            }\n+        }\n+        impl Eq for ip_mreq {}\n+        impl ::fmt::Debug for ip_mreq {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"ip_mreq\")\n+                    .field(\"imr_multiaddr\", &self.imr_multiaddr)\n+                    .field(\"imr_interface\", &self.imr_interface)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for ip_mreq {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.imr_multiaddr.hash(state);\n+                self.imr_interface.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for sockaddr_in {\n+            fn eq(&self, other: &sockaddr_in) -> bool {\n+                self.sin_len == other.sin_len\n+                    && self.sin_family == other.sin_family\n+                    && self.sin_port == other.sin_port\n+                    && self.sin_addr == other.sin_addr\n+                    && self.sin_zero == other.sin_zero\n+            }\n+        }\n+        impl Eq for sockaddr_in {}\n+        impl ::fmt::Debug for sockaddr_in {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"sockaddr_in\")\n+                    .field(\"sin_len\", &self.sin_len)\n+                    .field(\"sin_family\", &self.sin_family)\n+                    .field(\"sin_port\", &self.sin_port)\n+                    .field(\"sin_addr\", &self.sin_addr)\n+                    .field(\"sin_zero\", &self.sin_zero)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for sockaddr_in {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.sin_len.hash(state);\n+                self.sin_family.hash(state);\n+                self.sin_port.hash(state);\n+                self.sin_addr.hash(state);\n+                self.sin_zero.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for dirent {\n+            fn eq(&self, other: &dirent) -> bool {\n+                self.d_fileno == other.d_fileno\n+                    && self.d_reclen == other.d_reclen\n+                    && self.d_namlen == other.d_namlen\n+                    && self.d_type == other.d_type\n+                    && self\n+                    .d_name\n+                    .iter()\n+                    .zip(other.d_name.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for dirent {}\n+        impl ::fmt::Debug for dirent {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"dirent\")\n+                    .field(\"d_fileno\", &self.d_fileno)\n+                    .field(\"d_reclen\", &self.d_reclen)\n+                    .field(\"d_namlen\", &self.d_namlen)\n+                    .field(\"d_type\", &self.d_type)\n+                    // FIXME: .field(\"d_name\", &self.d_name)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for dirent {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.d_fileno.hash(state);\n+                self.d_reclen.hash(state);\n+                self.d_namlen.hash(state);\n+                self.d_type.hash(state);\n+                self.d_name.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for statvfs {\n+            fn eq(&self, other: &statvfs) -> bool {\n+                self.f_flag == other.f_flag\n+                    && self.f_bsize == other.f_bsize\n+                    && self.f_frsize == other.f_frsize\n+                    && self.f_iosize == other.f_iosize\n+                    && self.f_blocks == other.f_blocks\n+                    && self.f_bfree == other.f_bfree\n+                    && self.f_bavail == other.f_bavail\n+                    && self.f_bresvd == other.f_bresvd\n+                    && self.f_files == other.f_files\n+                    && self.f_ffree == other.f_ffree\n+                    && self.f_favail == other.f_favail\n+                    && self.f_fresvd == other.f_fresvd\n+                    && self.f_syncreads == other.f_syncreads\n+                    && self.f_syncwrites == other.f_syncwrites\n+                    && self.f_asyncreads == other.f_asyncreads\n+                    && self.f_asyncwrites == other.f_asyncwrites\n+                    && self.f_fsidx == other.f_fsidx\n+                    && self.f_fsid == other.f_fsid\n+                    && self.f_namemax == other.f_namemax\n+                    && self.f_owner == other.f_owner\n+                    && self.f_spare == other.f_spare\n+                    && self.f_fstypename == other.f_fstypename\n+                    && self\n+                    .f_mntonname\n+                    .iter()\n+                    .zip(other.f_mntonname.iter())\n+                    .all(|(a,b)| a == b)\n+                    && self\n+                    .f_mntfromname\n+                    .iter()\n+                    .zip(other.f_mntfromname.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for statvfs {}\n+        impl ::fmt::Debug for statvfs {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"statvfs\")\n+                    .field(\"f_flag\", &self.f_flag)\n+                    .field(\"f_bsize\", &self.f_bsize)\n+                    .field(\"f_frsize\", &self.f_frsize)\n+                    .field(\"f_iosize\", &self.f_iosize)\n+                    .field(\"f_blocks\", &self.f_blocks)\n+                    .field(\"f_bfree\", &self.f_bfree)\n+                    .field(\"f_bavail\", &self.f_bavail)\n+                    .field(\"f_bresvd\", &self.f_bresvd)\n+                    .field(\"f_files\", &self.f_files)\n+                    .field(\"f_ffree\", &self.f_ffree)\n+                    .field(\"f_favail\", &self.f_favail)\n+                    .field(\"f_fresvd\", &self.f_fresvd)\n+                    .field(\"f_syncreads\", &self.f_syncreads)\n+                    .field(\"f_syncwrites\", &self.f_syncwrites)\n+                    .field(\"f_asyncreads\", &self.f_asyncreads)\n+                    .field(\"f_asyncwrites\", &self.f_asyncwrites)\n+                    .field(\"f_fsidx\", &self.f_fsidx)\n+                    .field(\"f_fsid\", &self.f_fsid)\n+                    .field(\"f_namemax\", &self.f_namemax)\n+                    .field(\"f_owner\", &self.f_owner)\n+                    .field(\"f_spare\", &self.f_spare)\n+                    .field(\"f_fstypename\", &self.f_fstypename)\n+                    // FIXME: .field(\"f_mntonname\", &self.f_mntonname)\n+                    // FIXME: .field(\"f_mntfromname\", &self.f_mntfromname)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for statvfs {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.f_flag.hash(state);\n+                self.f_bsize.hash(state);\n+                self.f_frsize.hash(state);\n+                self.f_iosize.hash(state);\n+                self.f_blocks.hash(state);\n+                self.f_bfree.hash(state);\n+                self.f_bavail.hash(state);\n+                self.f_bresvd.hash(state);\n+                self.f_files.hash(state);\n+                self.f_ffree.hash(state);\n+                self.f_favail.hash(state);\n+                self.f_fresvd.hash(state);\n+                self.f_syncreads.hash(state);\n+                self.f_syncwrites.hash(state);\n+                self.f_asyncreads.hash(state);\n+                self.f_asyncwrites.hash(state);\n+                self.f_fsidx.hash(state);\n+                self.f_fsid.hash(state);\n+                self.f_namemax.hash(state);\n+                self.f_owner.hash(state);\n+                self.f_spare.hash(state);\n+                self.f_fstypename.hash(state);\n+                self.f_mntonname.hash(state);\n+                self.f_mntfromname.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for sockaddr_storage {\n+            fn eq(&self, other: &sockaddr_storage) -> bool {\n+                self.ss_len == other.ss_len\n+                    && self.ss_family == other.ss_family\n+                    && self.__ss_pad1 == other.__ss_pad1\n+                    && self.__ss_pad2 == other.__ss_pad2\n+                    && self\n+                    .__ss_pad3\n+                    .iter()\n+                    .zip(other.__ss_pad3.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for sockaddr_storage {}\n+        impl ::fmt::Debug for sockaddr_storage {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"sockaddr_storage\")\n+                    .field(\"ss_len\", &self.ss_len)\n+                    .field(\"ss_family\", &self.ss_family)\n+                    .field(\"__ss_pad1\", &self.__ss_pad1)\n+                    .field(\"__ss_pad2\", &self.__ss_pad2)\n+                    // FIXME: .field(\"__ss_pad3\", &self.__ss_pad3)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for sockaddr_storage {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.ss_len.hash(state);\n+                self.ss_family.hash(state);\n+                self.__ss_pad1.hash(state);\n+                self.__ss_pad2.hash(state);\n+                self.__ss_pad3.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for sigevent {\n+            fn eq(&self, other: &sigevent) -> bool {\n+                self.sigev_notify == other.sigev_notify\n+                    && self.sigev_signo == other.sigev_signo\n+                    && self.sigev_value == other.sigev_value\n+                    && self.sigev_notify_attributes\n+                        == other.sigev_notify_attributes\n+            }\n+        }\n+        impl Eq for sigevent {}\n+        impl ::fmt::Debug for sigevent {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"sigevent\")\n+                    .field(\"sigev_notify\", &self.sigev_notify)\n+                    .field(\"sigev_signo\", &self.sigev_signo)\n+                    .field(\"sigev_value\", &self.sigev_value)\n+                    .field(\"sigev_notify_attributes\",\n+                           &self.sigev_notify_attributes)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for sigevent {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.sigev_notify.hash(state);\n+                self.sigev_signo.hash(state);\n+                self.sigev_value.hash(state);\n+                self.sigev_notify_attributes.hash(state);\n+            }\n+        }\n+    }\n+}\n+\n+pub const AT_FDCWD: ::c_int = -100;\n+pub const AT_EACCESS: ::c_int = 0x100;\n+pub const AT_SYMLINK_NOFOLLOW: ::c_int = 0x200;\n+pub const AT_SYMLINK_FOLLOW: ::c_int = 0x400;\n+pub const AT_REMOVEDIR: ::c_int = 0x800;\n+\n+pub const EXTATTR_NAMESPACE_USER: ::c_int = 1;\n+pub const EXTATTR_NAMESPACE_SYSTEM: ::c_int = 2;\n+\n+pub const LC_COLLATE_MASK: ::c_int = (1 << ::LC_COLLATE);\n+pub const LC_CTYPE_MASK: ::c_int = (1 << ::LC_CTYPE);\n+pub const LC_MONETARY_MASK: ::c_int = (1 << ::LC_MONETARY);\n+pub const LC_NUMERIC_MASK: ::c_int = (1 << ::LC_NUMERIC);\n+pub const LC_TIME_MASK: ::c_int = (1 << ::LC_TIME);\n+pub const LC_MESSAGES_MASK: ::c_int = (1 << ::LC_MESSAGES);\n+pub const LC_ALL_MASK: ::c_int = !0;\n+\n+pub const ERA: ::nl_item = 52;\n+pub const ERA_D_FMT: ::nl_item = 53;\n+pub const ERA_D_T_FMT: ::nl_item = 54;\n+pub const ERA_T_FMT: ::nl_item = 55;\n+pub const ALT_DIGITS: ::nl_item = 56;\n+\n+pub const O_CLOEXEC: ::c_int = 0x400000;\n+pub const O_ALT_IO: ::c_int = 0x40000;\n+pub const O_NOSIGPIPE: ::c_int = 0x1000000;\n+pub const O_SEARCH: ::c_int = 0x800000;\n+pub const O_DIRECTORY: ::c_int = 0x200000;\n+pub const O_DIRECT: ::c_int = 0x00080000;\n+pub const O_RSYNC: ::c_int = 0x00020000;\n+\n+pub const MS_SYNC: ::c_int = 0x4;\n+pub const MS_INVALIDATE: ::c_int = 0x2;\n+\n+#[deprecated(since = \"0.2.64\", note = \"Not stable across OS versions\")]\n+pub const RLIM_NLIMITS: ::c_int = 12;\n+\n+pub const EIDRM: ::c_int = 82;\n+pub const ENOMSG: ::c_int = 83;\n+pub const EOVERFLOW: ::c_int = 84;\n+pub const EILSEQ: ::c_int = 85;\n+pub const ENOTSUP: ::c_int = 86;\n+pub const ECANCELED: ::c_int = 87;\n+pub const EBADMSG: ::c_int = 88;\n+pub const ENODATA: ::c_int = 89;\n+pub const ENOSR: ::c_int = 90;\n+pub const ENOSTR: ::c_int = 91;\n+pub const ETIME: ::c_int = 92;\n+pub const ENOATTR: ::c_int = 93;\n+pub const EMULTIHOP: ::c_int = 94;\n+pub const ENOLINK: ::c_int = 95;\n+pub const EPROTO: ::c_int = 96;\n+pub const ELAST: ::c_int = 96;\n+\n+pub const F_DUPFD_CLOEXEC: ::c_int = 12;\n+pub const F_CLOSEM: ::c_int = 10;\n+pub const F_GETNOSIGPIPE: ::c_int = 13;\n+pub const F_SETNOSIGPIPE: ::c_int = 14;\n+pub const F_MAXFD: ::c_int = 11;\n+\n+pub const IP_RECVDSTADDR: ::c_int = 7;\n+pub const IP_SENDSRCADDR: ::c_int = IP_RECVDSTADDR;\n+pub const IP_RECVIF: ::c_int = 20;\n+pub const IP_PKTINFO: ::c_int = 25;\n+pub const IP_RECVPKTINFO: ::c_int = 26;\n+pub const IPV6_JOIN_GROUP: ::c_int = 12;\n+pub const IPV6_LEAVE_GROUP: ::c_int = 13;\n+\n+pub const TCP_KEEPIDLE: ::c_int = 3;\n+pub const TCP_KEEPINTVL: ::c_int = 5;\n+pub const TCP_KEEPCNT: ::c_int = 6;\n+pub const TCP_KEEPINIT: ::c_int = 7;\n+pub const TCP_INFO: ::c_int = 9;\n+pub const TCP_MD5SIG: ::c_int = 0x10;\n+pub const TCP_CONGCTL: ::c_int = 0x20;\n+\n+pub const SOCK_CONN_DGRAM: ::c_int = 6;\n+pub const SOCK_DCCP: ::c_int = SOCK_CONN_DGRAM;\n+pub const SOCK_NOSIGPIPE: ::c_int = 0x40000000;\n+pub const SOCK_FLAGS_MASK: ::c_int = 0xf0000000;\n+\n+pub const SO_SNDTIMEO: ::c_int = 0x100b;\n+pub const SO_RCVTIMEO: ::c_int = 0x100c;\n+pub const SO_ACCEPTFILTER: ::c_int = 0x1000;\n+pub const SO_TIMESTAMP: ::c_int = 0x2000;\n+pub const SO_OVERFLOWED: ::c_int = 0x1009;\n+pub const SO_NOHEADER: ::c_int = 0x100a;\n+\n+// https://github.com/NetBSD/src/blob/trunk/sys/net/if.h#L373\n+pub const IFF_UP: ::c_int = 0x0001; // interface is up\n+pub const IFF_BROADCAST: ::c_int = 0x0002; // broadcast address valid\n+pub const IFF_DEBUG: ::c_int = 0x0004; // turn on debugging\n+pub const IFF_LOOPBACK: ::c_int = 0x0008; // is a loopback net\n+pub const IFF_POINTOPOINT: ::c_int = 0x0010; // interface is point-to-point link\n+pub const IFF_NOTRAILERS: ::c_int = 0x0020; // avoid use of trailers\n+pub const IFF_RUNNING: ::c_int = 0x0040; // resources allocated\n+pub const IFF_NOARP: ::c_int = 0x0080; // no address resolution protocol\n+pub const IFF_PROMISC: ::c_int = 0x0100; // receive all packets\n+pub const IFF_ALLMULTI: ::c_int = 0x0200; // receive all multicast packets\n+pub const IFF_OACTIVE: ::c_int = 0x0400; // transmission in progress\n+pub const IFF_SIMPLEX: ::c_int = 0x0800; // can't hear own transmissions\n+pub const IFF_LINK0: ::c_int = 0x1000; // per link layer defined bit\n+pub const IFF_LINK1: ::c_int = 0x2000; // per link layer defined bit\n+pub const IFF_LINK2: ::c_int = 0x4000; // per link layer defined bit\n+pub const IFF_MULTICAST: ::c_int = 0x8000; // supports multicast\n+\n+// sys/netinet/in.h\n+// Protocols (RFC 1700)\n+// NOTE: These are in addition to the constants defined in src/unix/mod.rs\n+\n+// IPPROTO_IP defined in src/unix/mod.rs\n+/// Hop-by-hop option header\n+pub const IPPROTO_HOPOPTS: ::c_int = 0;\n+// IPPROTO_ICMP defined in src/unix/mod.rs\n+/// group mgmt protocol\n+pub const IPPROTO_IGMP: ::c_int = 2;\n+/// gateway^2 (deprecated)\n+pub const IPPROTO_GGP: ::c_int = 3;\n+/// for compatibility\n+pub const IPPROTO_IPIP: ::c_int = 4;\n+// IPPROTO_TCP defined in src/unix/mod.rs\n+/// exterior gateway protocol\n+pub const IPPROTO_EGP: ::c_int = 8;\n+/// pup\n+pub const IPPROTO_PUP: ::c_int = 12;\n+// IPPROTO_UDP defined in src/unix/mod.rs\n+/// xns idp\n+pub const IPPROTO_IDP: ::c_int = 22;\n+/// tp-4 w/ class negotiation\n+pub const IPPROTO_TP: ::c_int = 29;\n+/// DCCP\n+pub const IPPROTO_DCCP: ::c_int = 33;\n+// IPPROTO_IPV6 defined in src/unix/mod.rs\n+/// IP6 routing header\n+pub const IPPROTO_ROUTING: ::c_int = 43;\n+/// IP6 fragmentation header\n+pub const IPPROTO_FRAGMENT: ::c_int = 44;\n+/// resource reservation\n+pub const IPPROTO_RSVP: ::c_int = 46;\n+/// General Routing Encap.\n+pub const IPPROTO_GRE: ::c_int = 47;\n+/// IP6 Encap Sec. Payload\n+pub const IPPROTO_ESP: ::c_int = 50;\n+/// IP6 Auth Header\n+pub const IPPROTO_AH: ::c_int = 51;\n+/// IP Mobility RFC 2004\n+pub const IPPROTO_MOBILE: ::c_int = 55;\n+/// IPv6 ICMP\n+pub const IPPROTO_IPV6_ICMP: ::c_int = 58;\n+// IPPROTO_ICMPV6 defined in src/unix/mod.rs\n+/// IP6 no next header\n+pub const IPPROTO_NONE: ::c_int = 59;\n+/// IP6 destination option\n+pub const IPPROTO_DSTOPTS: ::c_int = 60;\n+/// ISO cnlp\n+pub const IPPROTO_EON: ::c_int = 80;\n+/// Ethernet-in-IP\n+pub const IPPROTO_ETHERIP: ::c_int = 97;\n+/// encapsulation header\n+pub const IPPROTO_ENCAP: ::c_int = 98;\n+/// Protocol indep. multicast\n+pub const IPPROTO_PIM: ::c_int = 103;\n+/// IP Payload Comp. Protocol\n+pub const IPPROTO_IPCOMP: ::c_int = 108;\n+/// VRRP RFC 2338\n+pub const IPPROTO_VRRP: ::c_int = 112;\n+/// Common Address Resolution Protocol\n+pub const IPPROTO_CARP: ::c_int = 112;\n+/// L2TPv3\n+// TEMP: Disabled for now; this constant was added to NetBSD on 2017-02-16,\n+// but isn't yet supported by the NetBSD rumprun kernel image used for\n+// libc testing.\n+//pub const IPPROTO_L2TP: ::c_int = 115;\n+/// SCTP\n+pub const IPPROTO_SCTP: ::c_int = 132;\n+/// PFSYNC\n+pub const IPPROTO_PFSYNC: ::c_int = 240;\n+pub const IPPROTO_MAX: ::c_int = 256;\n+\n+/// last return value of *_input(), meaning \"all job for this pkt is done\".\n+pub const IPPROTO_DONE: ::c_int = 257;\n+\n+/// sysctl placeholder for (FAST_)IPSEC\n+pub const CTL_IPPROTO_IPSEC: ::c_int = 258;\n+\n+pub const AF_OROUTE: ::c_int = 17;\n+pub const AF_ARP: ::c_int = 28;\n+pub const pseudo_AF_KEY: ::c_int = 29;\n+pub const pseudo_AF_HDRCMPLT: ::c_int = 30;\n+pub const AF_BLUETOOTH: ::c_int = 31;\n+pub const AF_IEEE80211: ::c_int = 32;\n+pub const AF_MPLS: ::c_int = 33;\n+pub const AF_ROUTE: ::c_int = 34;\n+pub const NET_RT_DUMP: ::c_int = 1;\n+pub const NET_RT_FLAGS: ::c_int = 2;\n+pub const NET_RT_OOOIFLIST: ::c_int = 3;\n+pub const NET_RT_OOIFLIST: ::c_int = 4;\n+pub const NET_RT_OIFLIST: ::c_int = 5;\n+pub const NET_RT_IFLIST: ::c_int = 6;\n+pub const NET_RT_MAXID: ::c_int = 7;\n+\n+pub const PF_OROUTE: ::c_int = AF_OROUTE;\n+pub const PF_ARP: ::c_int = AF_ARP;\n+pub const PF_KEY: ::c_int = pseudo_AF_KEY;\n+pub const PF_BLUETOOTH: ::c_int = AF_BLUETOOTH;\n+pub const PF_MPLS: ::c_int = AF_MPLS;\n+pub const PF_ROUTE: ::c_int = AF_ROUTE;\n+\n+pub const MSG_NBIO: ::c_int = 0x1000;\n+pub const MSG_WAITFORONE: ::c_int = 0x2000;\n+pub const MSG_NOTIFICATION: ::c_int = 0x4000;\n+\n+pub const SCM_TIMESTAMP: ::c_int = 0x08;\n+pub const SCM_CREDS: ::c_int = 0x10;\n+\n+pub const O_DSYNC: ::c_int = 0x10000;\n+\n+pub const MAP_RENAME: ::c_int = 0x20;\n+pub const MAP_NORESERVE: ::c_int = 0x40;\n+pub const MAP_HASSEMAPHORE: ::c_int = 0x200;\n+pub const MAP_WIRED: ::c_int = 0x800;\n+\n+pub const DCCP_TYPE_REQUEST: ::c_int = 0;\n+pub const DCCP_TYPE_RESPONSE: ::c_int = 1;\n+pub const DCCP_TYPE_DATA: ::c_int = 2;\n+pub const DCCP_TYPE_ACK: ::c_int = 3;\n+pub const DCCP_TYPE_DATAACK: ::c_int = 4;\n+pub const DCCP_TYPE_CLOSEREQ: ::c_int = 5;\n+pub const DCCP_TYPE_CLOSE: ::c_int = 6;\n+pub const DCCP_TYPE_RESET: ::c_int = 7;\n+pub const DCCP_TYPE_MOVE: ::c_int = 8;\n+\n+pub const DCCP_FEATURE_CC: ::c_int = 1;\n+pub const DCCP_FEATURE_ECN: ::c_int = 2;\n+pub const DCCP_FEATURE_ACKRATIO: ::c_int = 3;\n+pub const DCCP_FEATURE_ACKVECTOR: ::c_int = 4;\n+pub const DCCP_FEATURE_MOBILITY: ::c_int = 5;\n+pub const DCCP_FEATURE_LOSSWINDOW: ::c_int = 6;\n+pub const DCCP_FEATURE_CONN_NONCE: ::c_int = 8;\n+pub const DCCP_FEATURE_IDENTREG: ::c_int = 7;\n+\n+pub const DCCP_OPT_PADDING: ::c_int = 0;\n+pub const DCCP_OPT_DATA_DISCARD: ::c_int = 1;\n+pub const DCCP_OPT_SLOW_RECV: ::c_int = 2;\n+pub const DCCP_OPT_BUF_CLOSED: ::c_int = 3;\n+pub const DCCP_OPT_CHANGE_L: ::c_int = 32;\n+pub const DCCP_OPT_CONFIRM_L: ::c_int = 33;\n+pub const DCCP_OPT_CHANGE_R: ::c_int = 34;\n+pub const DCCP_OPT_CONFIRM_R: ::c_int = 35;\n+pub const DCCP_OPT_INIT_COOKIE: ::c_int = 36;\n+pub const DCCP_OPT_NDP_COUNT: ::c_int = 37;\n+pub const DCCP_OPT_ACK_VECTOR0: ::c_int = 38;\n+pub const DCCP_OPT_ACK_VECTOR1: ::c_int = 39;\n+pub const DCCP_OPT_RECV_BUF_DROPS: ::c_int = 40;\n+pub const DCCP_OPT_TIMESTAMP: ::c_int = 41;\n+pub const DCCP_OPT_TIMESTAMP_ECHO: ::c_int = 42;\n+pub const DCCP_OPT_ELAPSEDTIME: ::c_int = 43;\n+pub const DCCP_OPT_DATACHECKSUM: ::c_int = 44;\n+\n+pub const DCCP_REASON_UNSPEC: ::c_int = 0;\n+pub const DCCP_REASON_CLOSED: ::c_int = 1;\n+pub const DCCP_REASON_INVALID: ::c_int = 2;\n+pub const DCCP_REASON_OPTION_ERR: ::c_int = 3;\n+pub const DCCP_REASON_FEA_ERR: ::c_int = 4;\n+pub const DCCP_REASON_CONN_REF: ::c_int = 5;\n+pub const DCCP_REASON_BAD_SNAME: ::c_int = 6;\n+pub const DCCP_REASON_BAD_COOKIE: ::c_int = 7;\n+pub const DCCP_REASON_INV_MOVE: ::c_int = 8;\n+pub const DCCP_REASON_UNANSW_CH: ::c_int = 10;\n+pub const DCCP_REASON_FRUITLESS_NEG: ::c_int = 11;\n+\n+pub const DCCP_CCID: ::c_int = 1;\n+pub const DCCP_CSLEN: ::c_int = 2;\n+pub const DCCP_MAXSEG: ::c_int = 4;\n+pub const DCCP_SERVICE: ::c_int = 8;\n+\n+pub const DCCP_NDP_LIMIT: ::c_int = 16;\n+pub const DCCP_SEQ_NUM_LIMIT: ::c_int = 16777216;\n+pub const DCCP_MAX_OPTIONS: ::c_int = 32;\n+pub const DCCP_MAX_PKTS: ::c_int = 100;\n+\n+pub const _PC_LINK_MAX: ::c_int = 1;\n+pub const _PC_MAX_CANON: ::c_int = 2;\n+pub const _PC_MAX_INPUT: ::c_int = 3;\n+pub const _PC_NAME_MAX: ::c_int = 4;\n+pub const _PC_PATH_MAX: ::c_int = 5;\n+pub const _PC_PIPE_BUF: ::c_int = 6;\n+pub const _PC_CHOWN_RESTRICTED: ::c_int = 7;\n+pub const _PC_NO_TRUNC: ::c_int = 8;\n+pub const _PC_VDISABLE: ::c_int = 9;\n+pub const _PC_SYNC_IO: ::c_int = 10;\n+pub const _PC_FILESIZEBITS: ::c_int = 11;\n+pub const _PC_SYMLINK_MAX: ::c_int = 12;\n+pub const _PC_2_SYMLINKS: ::c_int = 13;\n+pub const _PC_ACL_EXTENDED: ::c_int = 14;\n+pub const _PC_MIN_HOLE_SIZE: ::c_int = 15;\n+\n+pub const _SC_SYNCHRONIZED_IO: ::c_int = 31;\n+pub const _SC_IOV_MAX: ::c_int = 32;\n+pub const _SC_MAPPED_FILES: ::c_int = 33;\n+pub const _SC_MEMLOCK: ::c_int = 34;\n+pub const _SC_MEMLOCK_RANGE: ::c_int = 35;\n+pub const _SC_MEMORY_PROTECTION: ::c_int = 36;\n+pub const _SC_LOGIN_NAME_MAX: ::c_int = 37;\n+pub const _SC_MONOTONIC_CLOCK: ::c_int = 38;\n+pub const _SC_CLK_TCK: ::c_int = 39;\n+pub const _SC_ATEXIT_MAX: ::c_int = 40;\n+pub const _SC_THREADS: ::c_int = 41;\n+pub const _SC_SEMAPHORES: ::c_int = 42;\n+pub const _SC_BARRIERS: ::c_int = 43;\n+pub const _SC_TIMERS: ::c_int = 44;\n+pub const _SC_SPIN_LOCKS: ::c_int = 45;\n+pub const _SC_READER_WRITER_LOCKS: ::c_int = 46;\n+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 47;\n+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 48;\n+pub const _SC_CLOCK_SELECTION: ::c_int = 49;\n+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 50;\n+pub const _SC_AIO_LISTIO_MAX: ::c_int = 51;\n+pub const _SC_AIO_MAX: ::c_int = 52;\n+pub const _SC_MESSAGE_PASSING: ::c_int = 53;\n+pub const _SC_MQ_OPEN_MAX: ::c_int = 54;\n+pub const _SC_MQ_PRIO_MAX: ::c_int = 55;\n+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 56;\n+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 57;\n+pub const _SC_THREAD_KEYS_MAX: ::c_int = 58;\n+pub const _SC_THREAD_STACK_MIN: ::c_int = 59;\n+pub const _SC_THREAD_THREADS_MAX: ::c_int = 60;\n+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 61;\n+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 62;\n+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 63;\n+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 64;\n+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 65;\n+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 66;\n+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 67;\n+pub const _SC_TTY_NAME_MAX: ::c_int = 68;\n+pub const _SC_HOST_NAME_MAX: ::c_int = 69;\n+pub const _SC_PASS_MAX: ::c_int = 70;\n+pub const _SC_REGEXP: ::c_int = 71;\n+pub const _SC_SHELL: ::c_int = 72;\n+pub const _SC_SYMLOOP_MAX: ::c_int = 73;\n+pub const _SC_V6_ILP32_OFF32: ::c_int = 74;\n+pub const _SC_V6_ILP32_OFFBIG: ::c_int = 75;\n+pub const _SC_V6_LP64_OFF64: ::c_int = 76;\n+pub const _SC_V6_LPBIG_OFFBIG: ::c_int = 77;\n+pub const _SC_2_PBS: ::c_int = 80;\n+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 81;\n+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 82;\n+pub const _SC_2_PBS_LOCATE: ::c_int = 83;\n+pub const _SC_2_PBS_MESSAGE: ::c_int = 84;\n+pub const _SC_2_PBS_TRACK: ::c_int = 85;\n+pub const _SC_SPAWN: ::c_int = 86;\n+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 87;\n+pub const _SC_TIMER_MAX: ::c_int = 88;\n+pub const _SC_SEM_NSEMS_MAX: ::c_int = 89;\n+pub const _SC_CPUTIME: ::c_int = 90;\n+pub const _SC_THREAD_CPUTIME: ::c_int = 91;\n+pub const _SC_DELAYTIMER_MAX: ::c_int = 92;\n+// These two variables will be supported in NetBSD 8.0\n+// pub const _SC_SIGQUEUE_MAX : ::c_int = 93;\n+// pub const _SC_REALTIME_SIGNALS : ::c_int = 94;\n+pub const _SC_PHYS_PAGES: ::c_int = 121;\n+pub const _SC_NPROCESSORS_CONF: ::c_int = 1001;\n+pub const _SC_NPROCESSORS_ONLN: ::c_int = 1002;\n+pub const _SC_SCHED_RT_TS: ::c_int = 2001;\n+pub const _SC_SCHED_PRI_MIN: ::c_int = 2002;\n+pub const _SC_SCHED_PRI_MAX: ::c_int = 2003;\n+\n+pub const FD_SETSIZE: usize = 0x100;\n+\n+pub const ST_NOSUID: ::c_ulong = 8;\n+\n+pub const BIOCGRSIG: ::c_ulong = 0x40044272;\n+pub const BIOCSRSIG: ::c_ulong = 0x80044273;\n+pub const BIOCSDLT: ::c_ulong = 0x80044278;\n+pub const BIOCGSEESENT: ::c_ulong = 0x40044276;\n+pub const BIOCSSEESENT: ::c_ulong = 0x80044277;\n+\n+cfg_if! {\n+    if #[cfg(any(target_arch = \"sparc\", target_arch = \"sparc64\",\n+                 target_arch = \"x86\", target_arch = \"x86_64\"))] {\n+        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t\n+          = pthread_mutex_t {\n+            ptm_magic: 0x33330003,\n+            ptm_errorcheck: 0,\n+            ptm_pad1: [0; 3],\n+            ptm_unused: 0,\n+            ptm_pad2: [0; 3],\n+            ptm_waiters: 0 as *mut _,\n+            ptm_owner: 0,\n+            ptm_recursed: 0,\n+            ptm_spare2: 0 as *mut _,\n+        };\n+    } else {\n+        pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t\n+          = pthread_mutex_t {\n+            ptm_magic: 0x33330003,\n+            ptm_errorcheck: 0,\n+            ptm_unused: 0,\n+            ptm_waiters: 0 as *mut _,\n+            ptm_owner: 0,\n+            ptm_recursed: 0,\n+            ptm_spare2: 0 as *mut _,\n+        };\n+    }\n+}\n+\n+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n+    ptc_magic: 0x55550005,\n+    ptc_lock: 0,\n+    ptc_waiters_first: 0 as *mut _,\n+    ptc_waiters_last: 0 as *mut _,\n+    ptc_mutex: 0 as *mut _,\n+    ptc_private: 0 as *mut _,\n+};\n+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n+    ptr_magic: 0x99990009,\n+    ptr_interlock: 0,\n+    ptr_rblocked_first: 0 as *mut _,\n+    ptr_rblocked_last: 0 as *mut _,\n+    ptr_wblocked_first: 0 as *mut _,\n+    ptr_wblocked_last: 0 as *mut _,\n+    ptr_nreaders: 0,\n+    ptr_owner: 0,\n+    ptr_private: 0 as *mut _,\n+};\n+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 0;\n+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 1;\n+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 2;\n+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_NORMAL;\n+\n+pub const EVFILT_AIO: u32 = 2;\n+pub const EVFILT_PROC: u32 = 4;\n+pub const EVFILT_READ: u32 = 0;\n+pub const EVFILT_SIGNAL: u32 = 5;\n+pub const EVFILT_TIMER: u32 = 6;\n+pub const EVFILT_VNODE: u32 = 3;\n+pub const EVFILT_WRITE: u32 = 1;\n+\n+pub const EV_ADD: u32 = 0x1;\n+pub const EV_DELETE: u32 = 0x2;\n+pub const EV_ENABLE: u32 = 0x4;\n+pub const EV_DISABLE: u32 = 0x8;\n+pub const EV_ONESHOT: u32 = 0x10;\n+pub const EV_CLEAR: u32 = 0x20;\n+pub const EV_RECEIPT: u32 = 0x40;\n+pub const EV_DISPATCH: u32 = 0x80;\n+pub const EV_FLAG1: u32 = 0x2000;\n+pub const EV_ERROR: u32 = 0x4000;\n+pub const EV_EOF: u32 = 0x8000;\n+pub const EV_SYSFLAGS: u32 = 0xf000;\n+\n+pub const NOTE_LOWAT: u32 = 0x00000001;\n+pub const NOTE_DELETE: u32 = 0x00000001;\n+pub const NOTE_WRITE: u32 = 0x00000002;\n+pub const NOTE_EXTEND: u32 = 0x00000004;\n+pub const NOTE_ATTRIB: u32 = 0x00000008;\n+pub const NOTE_LINK: u32 = 0x00000010;\n+pub const NOTE_RENAME: u32 = 0x00000020;\n+pub const NOTE_REVOKE: u32 = 0x00000040;\n+pub const NOTE_EXIT: u32 = 0x80000000;\n+pub const NOTE_FORK: u32 = 0x40000000;\n+pub const NOTE_EXEC: u32 = 0x20000000;\n+pub const NOTE_PDATAMASK: u32 = 0x000fffff;\n+pub const NOTE_PCTRLMASK: u32 = 0xf0000000;\n+pub const NOTE_TRACK: u32 = 0x00000001;\n+pub const NOTE_TRACKERR: u32 = 0x00000002;\n+pub const NOTE_CHILD: u32 = 0x00000004;\n+\n+pub const TMP_MAX: ::c_uint = 308915776;\n+\n+pub const NI_MAXHOST: ::socklen_t = 1025;\n+\n+pub const RTLD_NOLOAD: ::c_int = 0x2000;\n+pub const RTLD_LOCAL: ::c_int = 0x200;\n+\n+pub const CTL_MAXNAME: ::c_int = 12;\n+pub const SYSCTL_NAMELEN: ::c_int = 32;\n+pub const SYSCTL_DEFSIZE: ::c_int = 8;\n+pub const CTLTYPE_NODE: ::c_int = 1;\n+pub const CTLTYPE_INT: ::c_int = 2;\n+pub const CTLTYPE_STRING: ::c_int = 3;\n+pub const CTLTYPE_QUAD: ::c_int = 4;\n+pub const CTLTYPE_STRUCT: ::c_int = 5;\n+pub const CTLTYPE_BOOL: ::c_int = 6;\n+pub const CTLFLAG_READONLY: ::c_int = 0x00000000;\n+pub const CTLFLAG_READWRITE: ::c_int = 0x00000070;\n+pub const CTLFLAG_ANYWRITE: ::c_int = 0x00000080;\n+pub const CTLFLAG_PRIVATE: ::c_int = 0x00000100;\n+pub const CTLFLAG_PERMANENT: ::c_int = 0x00000200;\n+pub const CTLFLAG_OWNDATA: ::c_int = 0x00000400;\n+pub const CTLFLAG_IMMEDIATE: ::c_int = 0x00000800;\n+pub const CTLFLAG_HEX: ::c_int = 0x00001000;\n+pub const CTLFLAG_ROOT: ::c_int = 0x00002000;\n+pub const CTLFLAG_ANYNUMBER: ::c_int = 0x00004000;\n+pub const CTLFLAG_HIDDEN: ::c_int = 0x00008000;\n+pub const CTLFLAG_ALIAS: ::c_int = 0x00010000;\n+pub const CTLFLAG_MMAP: ::c_int = 0x00020000;\n+pub const CTLFLAG_OWNDESC: ::c_int = 0x00040000;\n+pub const CTLFLAG_UNSIGNED: ::c_int = 0x00080000;\n+pub const SYSCTL_VERS_MASK: ::c_int = 0xff000000;\n+pub const SYSCTL_VERS_0: ::c_int = 0x00000000;\n+pub const SYSCTL_VERS_1: ::c_int = 0x01000000;\n+pub const SYSCTL_VERSION: ::c_int = SYSCTL_VERS_1;\n+pub const CTL_EOL: ::c_int = -1;\n+pub const CTL_QUERY: ::c_int = -2;\n+pub const CTL_CREATE: ::c_int = -3;\n+pub const CTL_CREATESYM: ::c_int = -4;\n+pub const CTL_DESTROY: ::c_int = -5;\n+pub const CTL_MMAP: ::c_int = -6;\n+pub const CTL_DESCRIBE: ::c_int = -7;\n+pub const CTL_UNSPEC: ::c_int = 0;\n+pub const CTL_KERN: ::c_int = 1;\n+pub const CTL_VM: ::c_int = 2;\n+pub const CTL_VFS: ::c_int = 3;\n+pub const CTL_NET: ::c_int = 4;\n+pub const CTL_DEBUG: ::c_int = 5;\n+pub const CTL_HW: ::c_int = 6;\n+pub const CTL_MACHDEP: ::c_int = 7;\n+pub const CTL_USER: ::c_int = 8;\n+pub const CTL_DDB: ::c_int = 9;\n+pub const CTL_PROC: ::c_int = 10;\n+pub const CTL_VENDOR: ::c_int = 11;\n+pub const CTL_EMUL: ::c_int = 12;\n+pub const CTL_SECURITY: ::c_int = 13;\n+pub const CTL_MAXID: ::c_int = 14;\n+pub const KERN_OSTYPE: ::c_int = 1;\n+pub const KERN_OSRELEASE: ::c_int = 2;\n+pub const KERN_OSREV: ::c_int = 3;\n+pub const KERN_VERSION: ::c_int = 4;\n+pub const KERN_MAXVNODES: ::c_int = 5;\n+pub const KERN_MAXPROC: ::c_int = 6;\n+pub const KERN_MAXFILES: ::c_int = 7;\n+pub const KERN_ARGMAX: ::c_int = 8;\n+pub const KERN_SECURELVL: ::c_int = 9;\n+pub const KERN_HOSTNAME: ::c_int = 10;\n+pub const KERN_HOSTID: ::c_int = 11;\n+pub const KERN_CLOCKRATE: ::c_int = 12;\n+pub const KERN_VNODE: ::c_int = 13;\n+pub const KERN_PROC: ::c_int = 14;\n+pub const KERN_FILE: ::c_int = 15;\n+pub const KERN_PROF: ::c_int = 16;\n+pub const KERN_POSIX1: ::c_int = 17;\n+pub const KERN_NGROUPS: ::c_int = 18;\n+pub const KERN_JOB_CONTROL: ::c_int = 19;\n+pub const KERN_SAVED_IDS: ::c_int = 20;\n+pub const KERN_OBOOTTIME: ::c_int = 21;\n+pub const KERN_DOMAINNAME: ::c_int = 22;\n+pub const KERN_MAXPARTITIONS: ::c_int = 23;\n+pub const KERN_RAWPARTITION: ::c_int = 24;\n+pub const KERN_NTPTIME: ::c_int = 25;\n+pub const KERN_TIMEX: ::c_int = 26;\n+pub const KERN_AUTONICETIME: ::c_int = 27;\n+pub const KERN_AUTONICEVAL: ::c_int = 28;\n+pub const KERN_RTC_OFFSET: ::c_int = 29;\n+pub const KERN_ROOT_DEVICE: ::c_int = 30;\n+pub const KERN_MSGBUFSIZE: ::c_int = 31;\n+pub const KERN_FSYNC: ::c_int = 32;\n+pub const KERN_OLDSYSVMSG: ::c_int = 33;\n+pub const KERN_OLDSYSVSEM: ::c_int = 34;\n+pub const KERN_OLDSYSVSHM: ::c_int = 35;\n+pub const KERN_OLDSHORTCORENAME: ::c_int = 36;\n+pub const KERN_SYNCHRONIZED_IO: ::c_int = 37;\n+pub const KERN_IOV_MAX: ::c_int = 38;\n+pub const KERN_MBUF: ::c_int = 39;\n+pub const KERN_MAPPED_FILES: ::c_int = 40;\n+pub const KERN_MEMLOCK: ::c_int = 41;\n+pub const KERN_MEMLOCK_RANGE: ::c_int = 42;\n+pub const KERN_MEMORY_PROTECTION: ::c_int = 43;\n+pub const KERN_LOGIN_NAME_MAX: ::c_int = 44;\n+pub const KERN_DEFCORENAME: ::c_int = 45;\n+pub const KERN_LOGSIGEXIT: ::c_int = 46;\n+pub const KERN_PROC2: ::c_int = 47;\n+pub const KERN_PROC_ARGS: ::c_int = 48;\n+pub const KERN_FSCALE: ::c_int = 49;\n+pub const KERN_CCPU: ::c_int = 50;\n+pub const KERN_CP_TIME: ::c_int = 51;\n+pub const KERN_OLDSYSVIPC_INFO: ::c_int = 52;\n+pub const KERN_MSGBUF: ::c_int = 53;\n+pub const KERN_CONSDEV: ::c_int = 54;\n+pub const KERN_MAXPTYS: ::c_int = 55;\n+pub const KERN_PIPE: ::c_int = 56;\n+pub const KERN_MAXPHYS: ::c_int = 57;\n+pub const KERN_SBMAX: ::c_int = 58;\n+pub const KERN_TKSTAT: ::c_int = 59;\n+pub const KERN_MONOTONIC_CLOCK: ::c_int = 60;\n+pub const KERN_URND: ::c_int = 61;\n+pub const KERN_LABELSECTOR: ::c_int = 62;\n+pub const KERN_LABELOFFSET: ::c_int = 63;\n+pub const KERN_LWP: ::c_int = 64;\n+pub const KERN_FORKFSLEEP: ::c_int = 65;\n+pub const KERN_POSIX_THREADS: ::c_int = 66;\n+pub const KERN_POSIX_SEMAPHORES: ::c_int = 67;\n+pub const KERN_POSIX_BARRIERS: ::c_int = 68;\n+pub const KERN_POSIX_TIMERS: ::c_int = 69;\n+pub const KERN_POSIX_SPIN_LOCKS: ::c_int = 70;\n+pub const KERN_POSIX_READER_WRITER_LOCKS: ::c_int = 71;\n+pub const KERN_DUMP_ON_PANIC: ::c_int = 72;\n+pub const KERN_SOMAXKVA: ::c_int = 73;\n+pub const KERN_ROOT_PARTITION: ::c_int = 74;\n+pub const KERN_DRIVERS: ::c_int = 75;\n+pub const KERN_BUF: ::c_int = 76;\n+pub const KERN_FILE2: ::c_int = 77;\n+pub const KERN_VERIEXEC: ::c_int = 78;\n+pub const KERN_CP_ID: ::c_int = 79;\n+pub const KERN_HARDCLOCK_TICKS: ::c_int = 80;\n+pub const KERN_ARND: ::c_int = 81;\n+pub const KERN_SYSVIPC: ::c_int = 82;\n+pub const KERN_BOOTTIME: ::c_int = 83;\n+pub const KERN_EVCNT: ::c_int = 84;\n+pub const KERN_MAXID: ::c_int = 85;\n+pub const KERN_PROC_ALL: ::c_int = 0;\n+pub const KERN_PROC_PID: ::c_int = 1;\n+pub const KERN_PROC_PGRP: ::c_int = 2;\n+pub const KERN_PROC_SESSION: ::c_int = 3;\n+pub const KERN_PROC_TTY: ::c_int = 4;\n+pub const KERN_PROC_UID: ::c_int = 5;\n+pub const KERN_PROC_RUID: ::c_int = 6;\n+pub const KERN_PROC_GID: ::c_int = 7;\n+pub const KERN_PROC_RGID: ::c_int = 8;\n+pub const KERN_PROC_ARGV: ::c_int = 1;\n+pub const KERN_PROC_NARGV: ::c_int = 2;\n+pub const KERN_PROC_ENV: ::c_int = 3;\n+pub const KERN_PROC_NENV: ::c_int = 4;\n+pub const KERN_PROC_PATHNAME: ::c_int = 5;\n+\n+pub const EAI_AGAIN: ::c_int = 2;\n+pub const EAI_BADFLAGS: ::c_int = 3;\n+pub const EAI_FAIL: ::c_int = 4;\n+pub const EAI_FAMILY: ::c_int = 5;\n+pub const EAI_MEMORY: ::c_int = 6;\n+pub const EAI_NODATA: ::c_int = 7;\n+pub const EAI_NONAME: ::c_int = 8;\n+pub const EAI_SERVICE: ::c_int = 9;\n+pub const EAI_SOCKTYPE: ::c_int = 10;\n+pub const EAI_SYSTEM: ::c_int = 11;\n+pub const EAI_OVERFLOW: ::c_int = 14;\n+\n+pub const AIO_CANCELED: ::c_int = 1;\n+pub const AIO_NOTCANCELED: ::c_int = 2;\n+pub const AIO_ALLDONE: ::c_int = 3;\n+pub const LIO_NOP: ::c_int = 0;\n+pub const LIO_WRITE: ::c_int = 1;\n+pub const LIO_READ: ::c_int = 2;\n+pub const LIO_WAIT: ::c_int = 1;\n+pub const LIO_NOWAIT: ::c_int = 0;\n+\n+pub const SIGEV_NONE: ::c_int = 0;\n+pub const SIGEV_SIGNAL: ::c_int = 1;\n+pub const SIGEV_THREAD: ::c_int = 2;\n+\n+pub const WSTOPPED: ::c_int = 0x00000002; // same as WUNTRACED\n+pub const WCONTINUED: ::c_int = 0x00000010;\n+pub const WEXITED: ::c_int = 0x000000020;\n+pub const WNOWAIT: ::c_int = 0x00010000;\n+\n+pub const P_ALL: idtype_t = 0;\n+pub const P_PID: idtype_t = 1;\n+pub const P_PGID: idtype_t = 4;\n+\n+pub const UTIME_OMIT: c_long = 1073741822;\n+pub const UTIME_NOW: c_long = 1073741823;\n+\n+pub const B460800: ::speed_t = 460800;\n+pub const B921600: ::speed_t = 921600;\n+\n+pub const ONOCR: ::tcflag_t = 0x20;\n+pub const ONLRET: ::tcflag_t = 0x40;\n+pub const CDTRCTS: ::tcflag_t = 0x00020000;\n+pub const CHWFLOW: ::tcflag_t = ::MDMBUF | ::CRTSCTS | ::CDTRCTS;\n+\n+pub const SOCK_CLOEXEC: ::c_int = 0x10000000;\n+pub const SOCK_NONBLOCK: ::c_int = 0x20000000;\n+\n+// Uncomment on next NetBSD release\n+// pub const FIOSEEKDATA: ::c_ulong = 0xc0086661;\n+// pub const FIOSEEKHOLE: ::c_ulong = 0xc0086662;\n+pub const OFIOGETBMAP: ::c_ulong = 0xc004667a;\n+pub const FIOGETBMAP: ::c_ulong = 0xc008667a;\n+pub const FIONWRITE: ::c_ulong = 0x40046679;\n+pub const FIONSPACE: ::c_ulong = 0x40046678;\n+pub const FIBMAP: ::c_ulong = 0xc008667a;\n+\n+pub const SIGSTKSZ: ::size_t = 40960;\n+\n+pub const PT_DUMPCORE: ::c_int = 12;\n+pub const PT_LWPINFO: ::c_int = 13;\n+pub const PT_SYSCALL: ::c_int = 14;\n+pub const PT_SYSCALLEMU: ::c_int = 15;\n+pub const PT_SET_EVENT_MASK: ::c_int = 16;\n+pub const PT_GET_EVENT_MASK: ::c_int = 17;\n+pub const PT_GET_PROCESS_STATE: ::c_int = 18;\n+pub const PT_FIRSTMACH: ::c_int = 32;\n+\n+// Flags for chflags(2)\n+pub const SF_SNAPSHOT: ::c_ulong = 0x00200000;\n+pub const SF_LOG: ::c_ulong = 0x00400000;\n+pub const SF_SNAPINVAL: ::c_ulong = 0x00800000;\n+\n+fn _ALIGN(p: usize) -> usize {\n+    (p + _ALIGNBYTES) & !_ALIGNBYTES\n+}\n+\n+f! {\n+    pub fn CMSG_DATA(cmsg: *const ::cmsghdr) -> *mut ::c_uchar {\n+        (cmsg as *mut ::c_uchar)\n+            .offset(_ALIGN(::mem::size_of::<::cmsghdr>()) as isize)\n+    }\n+\n+    pub fn CMSG_LEN(length: ::c_uint) -> ::c_uint {\n+        _ALIGN(::mem::size_of::<::cmsghdr>()) as ::c_uint + length\n+    }\n+\n+    pub fn CMSG_NXTHDR(mhdr: *const ::msghdr, cmsg: *const ::cmsghdr)\n+        -> *mut ::cmsghdr\n+    {\n+        if cmsg.is_null() {\n+            return ::CMSG_FIRSTHDR(mhdr);\n+        };\n+        let next = cmsg as usize + _ALIGN((*cmsg).cmsg_len as usize)\n+            + _ALIGN(::mem::size_of::<::cmsghdr>());\n+        let max = (*mhdr).msg_control as usize\n+            + (*mhdr).msg_controllen as usize;\n+        if next > max {\n+            0 as *mut ::cmsghdr\n+        } else {\n+            (cmsg as usize + _ALIGN((*cmsg).cmsg_len as usize))\n+                as *mut ::cmsghdr\n+        }\n+    }\n+\n+    pub fn CMSG_SPACE(length: ::c_uint) -> ::c_uint {\n+        (_ALIGN(::mem::size_of::<::cmsghdr>()) + _ALIGN(length as usize))\n+            as ::c_uint\n+    }\n+\n+    pub fn WSTOPSIG(status: ::c_int) -> ::c_int {\n+        status >> 8\n+    }\n+\n+    pub fn WIFSIGNALED(status: ::c_int) -> bool {\n+        (status & 0o177) != 0o177 && (status & 0o177) != 0\n+    }\n+\n+    pub fn WIFSTOPPED(status: ::c_int) -> bool {\n+        (status & 0o177) == 0o177\n+    }\n+\n+    // dirfd() is a macro on netbsd to access\n+    // the first field of the struct where dirp points to:\n+    // http://cvsweb.netbsd.org/bsdweb.cgi/src/include/dirent.h?rev=1.36\n+    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int {\n+        *(dirp as *const ::c_int)\n+    }\n+\n+    pub fn WIFCONTINUED(status: ::c_int) -> bool {\n+        status == 0xffff\n+    }\n+\n+    pub fn SOCKCREDSIZE(ngrps: usize) -> usize {\n+        let ngrps = if ngrps > 0 {\n+            ngrps - 1\n+        } else {\n+            0\n+        };\n+        ::mem::size_of::<sockcred>() + ::mem::size_of::<::gid_t>() * ngrps\n+    }\n+}\n+\n+#[link(name = \"rt\")]\n+extern \"C\" {\n+    pub fn aio_read(aiocbp: *mut aiocb) -> ::c_int;\n+    pub fn aio_write(aiocbp: *mut aiocb) -> ::c_int;\n+    pub fn aio_fsync(op: ::c_int, aiocbp: *mut aiocb) -> ::c_int;\n+    pub fn aio_error(aiocbp: *const aiocb) -> ::c_int;\n+    pub fn aio_return(aiocbp: *mut aiocb) -> ::ssize_t;\n+    #[link_name = \"__aio_suspend50\"]\n+    pub fn aio_suspend(\n+        aiocb_list: *const *const aiocb,\n+        nitems: ::c_int,\n+        timeout: *const ::timespec,\n+    ) -> ::c_int;\n+    pub fn aio_cancel(fd: ::c_int, aiocbp: *mut aiocb) -> ::c_int;\n+    pub fn lio_listio(\n+        mode: ::c_int,\n+        aiocb_list: *const *mut aiocb,\n+        nitems: ::c_int,\n+        sevp: *mut sigevent,\n+    ) -> ::c_int;\n+}\n+\n+extern \"C\" {\n+    pub fn chflags(path: *const ::c_char, flags: ::c_ulong) -> ::c_int;\n+    pub fn fchflags(fd: ::c_int, flags: ::c_ulong) -> ::c_int;\n+    pub fn lchflags(path: *const ::c_char, flags: ::c_ulong) -> ::c_int;\n+\n+    pub fn extattr_delete_fd(\n+        fd: ::c_int,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+    ) -> ::c_int;\n+    pub fn extattr_delete_file(\n+        path: *const ::c_char,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+    ) -> ::c_int;\n+    pub fn extattr_delete_link(\n+        path: *const ::c_char,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+    ) -> ::c_int;\n+    pub fn extattr_get_fd(\n+        fd: ::c_int,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+        data: *mut ::c_void,\n+        nbytes: ::size_t,\n+    ) -> ::ssize_t;\n+    pub fn extattr_get_file(\n+        path: *const ::c_char,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+        data: *mut ::c_void,\n+        nbytes: ::size_t,\n+    ) -> ::ssize_t;\n+    pub fn extattr_get_link(\n+        path: *const ::c_char,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+        data: *mut ::c_void,\n+        nbytes: ::size_t,\n+    ) -> ::ssize_t;\n+    pub fn extattr_namespace_to_string(\n+        attrnamespace: ::c_int,\n+        string: *mut *mut ::c_char,\n+    ) -> ::c_int;\n+    pub fn extattr_set_fd(\n+        fd: ::c_int,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+        data: *const ::c_void,\n+        nbytes: ::size_t,\n+    ) -> ::c_int;\n+    pub fn extattr_set_file(\n+        path: *const ::c_char,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+        data: *const ::c_void,\n+        nbytes: ::size_t,\n+    ) -> ::c_int;\n+    pub fn extattr_set_link(\n+        path: *const ::c_char,\n+        attrnamespace: ::c_int,\n+        attrname: *const ::c_char,\n+        data: *const ::c_void,\n+        nbytes: ::size_t,\n+    ) -> ::c_int;\n+    pub fn extattr_string_to_namespace(\n+        string: *const ::c_char,\n+        attrnamespace: *mut ::c_int,\n+    ) -> ::c_int;\n+\n+    #[link_name = \"__lutimes50\"]\n+    pub fn lutimes(file: *const ::c_char, times: *const ::timeval) -> ::c_int;\n+    #[link_name = \"__gettimeofday50\"]\n+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;\n+    pub fn getnameinfo(\n+        sa: *const ::sockaddr,\n+        salen: ::socklen_t,\n+        host: *mut ::c_char,\n+        hostlen: ::socklen_t,\n+        serv: *mut ::c_char,\n+        sevlen: ::socklen_t,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+    pub fn mprotect(\n+        addr: *mut ::c_void,\n+        len: ::size_t,\n+        prot: ::c_int,\n+    ) -> ::c_int;\n+    pub fn sysctl(\n+        name: *const ::c_int,\n+        namelen: ::c_uint,\n+        oldp: *mut ::c_void,\n+        oldlenp: *mut ::size_t,\n+        newp: *const ::c_void,\n+        newlen: ::size_t,\n+    ) -> ::c_int;\n+    pub fn sysctlbyname(\n+        name: *const ::c_char,\n+        oldp: *mut ::c_void,\n+        oldlenp: *mut ::size_t,\n+        newp: *const ::c_void,\n+        newlen: ::size_t,\n+    ) -> ::c_int;\n+    #[link_name = \"__kevent50\"]\n+    pub fn kevent(\n+        kq: ::c_int,\n+        changelist: *const ::kevent,\n+        nchanges: ::size_t,\n+        eventlist: *mut ::kevent,\n+        nevents: ::size_t,\n+        timeout: *const ::timespec,\n+    ) -> ::c_int;\n+    #[link_name = \"__mount50\"]\n+    pub fn mount(\n+        src: *const ::c_char,\n+        target: *const ::c_char,\n+        flags: ::c_int,\n+        data: *mut ::c_void,\n+        size: ::size_t,\n+    ) -> ::c_int;\n+    pub fn mq_open(name: *const ::c_char, oflag: ::c_int, ...) -> ::mqd_t;\n+    pub fn mq_close(mqd: ::mqd_t) -> ::c_int;\n+    pub fn mq_getattr(mqd: ::mqd_t, attr: *mut ::mq_attr) -> ::c_int;\n+    pub fn mq_notify(mqd: ::mqd_t, notification: *const ::sigevent)\n+        -> ::c_int;\n+    pub fn mq_receive(\n+        mqd: ::mqd_t,\n+        msg_ptr: *mut ::c_char,\n+        msg_len: ::size_t,\n+        msg_prio: *mut ::c_uint,\n+    ) -> ::ssize_t;\n+    pub fn mq_send(\n+        mqd: ::mqd_t,\n+        msg_ptr: *const ::c_char,\n+        msg_len: ::size_t,\n+        msg_prio: ::c_uint,\n+    ) -> ::c_int;\n+    pub fn mq_setattr(\n+        mqd: ::mqd_t,\n+        newattr: *const ::mq_attr,\n+        oldattr: *mut ::mq_attr,\n+    ) -> ::c_int;\n+    #[link_name = \"__mq_timedreceive50\"]\n+    pub fn mq_timedreceive(\n+        mqd: ::mqd_t,\n+        msg_ptr: *mut ::c_char,\n+        msg_len: ::size_t,\n+        msg_prio: *mut ::c_uint,\n+        abs_timeout: *const ::timespec,\n+    ) -> ::ssize_t;\n+    #[link_name = \"__mq_timedsend50\"]\n+    pub fn mq_timedsend(\n+        mqd: ::mqd_t,\n+        msg_ptr: *const ::c_char,\n+        msg_len: ::size_t,\n+        msg_prio: ::c_uint,\n+        abs_timeout: *const ::timespec,\n+    ) -> ::c_int;\n+    pub fn mq_unlink(name: *const ::c_char) -> ::c_int;\n+    pub fn ptrace(\n+        request: ::c_int,\n+        pid: ::pid_t,\n+        addr: *mut ::c_void,\n+        data: ::c_int,\n+    ) -> ::c_int;\n+    pub fn pthread_setname_np(\n+        t: ::pthread_t,\n+        name: *const ::c_char,\n+        arg: *mut ::c_void,\n+    ) -> ::c_int;\n+    pub fn pthread_getattr_np(\n+        native: ::pthread_t,\n+        attr: *mut ::pthread_attr_t,\n+    ) -> ::c_int;\n+    pub fn pthread_attr_getguardsize(\n+        attr: *const ::pthread_attr_t,\n+        guardsize: *mut ::size_t,\n+    ) -> ::c_int;\n+    pub fn pthread_attr_getstack(\n+        attr: *const ::pthread_attr_t,\n+        stackaddr: *mut *mut ::c_void,\n+        stacksize: *mut ::size_t,\n+    ) -> ::c_int;\n+    #[link_name = \"__sigtimedwait50\"]\n+    pub fn sigtimedwait(\n+        set: *const sigset_t,\n+        info: *mut siginfo_t,\n+        timeout: *const ::timespec,\n+    ) -> ::c_int;\n+    pub fn sigwaitinfo(set: *const sigset_t, info: *mut siginfo_t) -> ::c_int;\n+    pub fn duplocale(base: ::locale_t) -> ::locale_t;\n+    pub fn freelocale(loc: ::locale_t);\n+    pub fn localeconv_l(loc: ::locale_t) -> *mut lconv;\n+    pub fn newlocale(\n+        mask: ::c_int,\n+        locale: *const ::c_char,\n+        base: ::locale_t,\n+    ) -> ::locale_t;\n+    #[link_name = \"__settimeofday50\"]\n+    pub fn settimeofday(tv: *const ::timeval, tz: *const ::c_void) -> ::c_int;\n+\n+    pub fn dup3(src: ::c_int, dst: ::c_int, flags: ::c_int) -> ::c_int;\n+\n+    pub fn sendmmsg(\n+        sockfd: ::c_int,\n+        msgvec: *mut ::mmsghdr,\n+        vlen: ::c_uint,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+    pub fn recvmmsg(\n+        sockfd: ::c_int,\n+        msgvec: *mut ::mmsghdr,\n+        vlen: ::c_uint,\n+        flags: ::c_int,\n+        timeout: *mut ::timespec,\n+    ) -> ::c_int;\n+\n+    pub fn _lwp_self() -> lwpid_t;\n+}\n+\n+#[link(name = \"util\")]\n+extern \"C\" {\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__getpwent_r50\")]\n+    pub fn getpwent_r(\n+        pwd: *mut ::passwd,\n+        buf: *mut ::c_char,\n+        buflen: ::size_t,\n+        result: *mut *mut ::passwd,\n+    ) -> ::c_int;\n+    pub fn getgrent_r(\n+        grp: *mut ::group,\n+        buf: *mut ::c_char,\n+        buflen: ::size_t,\n+        result: *mut *mut ::group,\n+    ) -> ::c_int;\n+}\n+\n+cfg_if! {\n+    if #[cfg(target_arch = \"aarch64\")] {\n+        mod aarch64;\n+        pub use self::aarch64::*;\n+    } else if #[cfg(target_arch = \"arm\")] {\n+        mod arm;\n+        pub use self::arm::*;\n+    } else if #[cfg(target_arch = \"powerpc\")] {\n+        mod powerpc;\n+        pub use self::powerpc::*;\n+    } else if #[cfg(target_arch = \"sparc64\")] {\n+        mod sparc64;\n+        pub use self::sparc64::*;\n+    } else if #[cfg(target_arch = \"x86_64\")] {\n+        mod x86_64;\n+        pub use self::x86_64::*;\n+    } else if #[cfg(target_arch = \"x86\")] {\n+        mod x86;\n+        pub use self::x86::*;\n+    } else {\n+        // Unknown target_arch\n+    }\n+}"
      },
      {
        "sha": "e12fd5e11233279d7cec5debf4f939ea859b353e",
        "filename": "src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/powerpc.rs",
        "status": "added",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/powerpc.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/powerpc.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/powerpc.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,21 @@\n+use PT_FIRSTMACH;\n+\n+pub type c_long = i32;\n+pub type c_ulong = u32;\n+pub type c_char = u8;\n+pub type __cpu_simple_lock_nv_t = ::c_int;\n+\n+// should be pub(crate), but that requires Rust 1.18.0\n+cfg_if! {\n+    if #[cfg(libc_const_size_of)] {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_double>() - 1;\n+    } else {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = 8 - 1;\n+    }\n+}\n+\n+pub const PT_STEP: ::c_int = PT_FIRSTMACH + 0;\n+pub const PT_GETREGS: ::c_int = PT_FIRSTMACH + 1;\n+pub const PT_SETREGS: ::c_int = PT_FIRSTMACH + 2;"
      },
      {
        "sha": "6a86759e07e76955017539c619678f46da29471a",
        "filename": "src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/sparc64.rs",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/sparc64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/sparc64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/sparc64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,8 @@\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type c_char = i8;\n+pub type __cpu_simple_lock_nv_t = ::c_uchar;\n+\n+// should be pub(crate), but that requires Rust 1.18.0\n+#[doc(hidden)]\n+pub const _ALIGNBYTES: usize = 0xf;"
      },
      {
        "sha": "daa89a11a67cbc9c6fa363c0bc5055faa46cd8ed",
        "filename": "src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/x86.rs",
        "status": "added",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/x86.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/x86.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/x86.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,15 @@\n+pub type c_long = i32;\n+pub type c_ulong = u32;\n+pub type c_char = i8;\n+pub type __cpu_simple_lock_nv_t = ::c_uchar;\n+\n+// should be pub(crate), but that requires Rust 1.18.0\n+cfg_if! {\n+    if #[cfg(libc_const_size_of)] {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_int>() - 1;\n+    } else {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = 4 - 1;\n+    }\n+}"
      },
      {
        "sha": "0860d4f6c7b57e3f0e073cc4d2a23fdb7ceab723",
        "filename": "src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/x86_64.rs",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/x86_64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/x86_64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/netbsdlike/netbsd/x86_64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,23 @@\n+use PT_FIRSTMACH;\n+\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type c_char = i8;\n+pub type __cpu_simple_lock_nv_t = ::c_uchar;\n+\n+// should be pub(crate), but that requires Rust 1.18.0\n+cfg_if! {\n+    if #[cfg(libc_const_size_of)] {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_long>() - 1;\n+    } else {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = 8 - 1;\n+    }\n+}\n+\n+pub const PT_STEP: ::c_int = PT_FIRSTMACH + 0;\n+pub const PT_GETREGS: ::c_int = PT_FIRSTMACH + 1;\n+pub const PT_SETREGS: ::c_int = PT_FIRSTMACH + 2;\n+pub const PT_GETFPREGS: ::c_int = PT_FIRSTMACH + 3;\n+pub const PT_SETFPREGS: ::c_int = PT_FIRSTMACH + 4;"
      },
      {
        "sha": "99350ec8dc3d464e360e5b8cab37425905f88e3f",
        "filename": "src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/aarch64.rs",
        "status": "added",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/aarch64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/aarch64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/aarch64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,16 @@\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type c_char = u8;\n+\n+// should be pub(crate), but that requires Rust 1.18.0\n+cfg_if! {\n+    if #[cfg(libc_const_size_of)] {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_long>() - 1;\n+    } else {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = 8 - 1;\n+    }\n+}\n+\n+pub const _MAX_PAGE_SHIFT: u32 = 12;"
      },
      {
        "sha": "d82c3273e67edbf2d547fa01613b439636a3c30a",
        "filename": "src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/mod.rs",
        "status": "added",
        "additions": 1481,
        "deletions": 0,
        "changes": 1481,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,1481 @@\n+use unix::bsd::O_SYNC;\n+\n+pub type clock_t = i64;\n+pub type suseconds_t = ::c_long;\n+pub type dev_t = i32;\n+pub type sigset_t = ::c_uint;\n+pub type blksize_t = i32;\n+pub type fsblkcnt_t = u64;\n+pub type fsfilcnt_t = u64;\n+pub type pthread_attr_t = *mut ::c_void;\n+pub type pthread_mutex_t = *mut ::c_void;\n+pub type pthread_mutexattr_t = *mut ::c_void;\n+pub type pthread_cond_t = *mut ::c_void;\n+pub type pthread_condattr_t = *mut ::c_void;\n+pub type pthread_rwlock_t = *mut ::c_void;\n+pub type pthread_rwlockattr_t = *mut ::c_void;\n+pub type caddr_t = *mut ::c_char;\n+\n+s! {\n+    pub struct glob_t {\n+        pub gl_pathc:   ::size_t,\n+        pub gl_matchc:  ::size_t,\n+        pub gl_offs:    ::size_t,\n+        pub gl_flags:   ::c_int,\n+        pub gl_pathv:   *mut *mut ::c_char,\n+        __unused1: *mut ::c_void,\n+        __unused2: *mut ::c_void,\n+        __unused3: *mut ::c_void,\n+        __unused4: *mut ::c_void,\n+        __unused5: *mut ::c_void,\n+        __unused6: *mut ::c_void,\n+        __unused7: *mut ::c_void,\n+    }\n+\n+    pub struct lconv {\n+        pub decimal_point: *mut ::c_char,\n+        pub thousands_sep: *mut ::c_char,\n+        pub grouping: *mut ::c_char,\n+        pub int_curr_symbol: *mut ::c_char,\n+        pub currency_symbol: *mut ::c_char,\n+        pub mon_decimal_point: *mut ::c_char,\n+        pub mon_thousands_sep: *mut ::c_char,\n+        pub mon_grouping: *mut ::c_char,\n+        pub positive_sign: *mut ::c_char,\n+        pub negative_sign: *mut ::c_char,\n+        pub int_frac_digits: ::c_char,\n+        pub frac_digits: ::c_char,\n+        pub p_cs_precedes: ::c_char,\n+        pub p_sep_by_space: ::c_char,\n+        pub n_cs_precedes: ::c_char,\n+        pub n_sep_by_space: ::c_char,\n+        pub p_sign_posn: ::c_char,\n+        pub n_sign_posn: ::c_char,\n+        pub int_p_cs_precedes: ::c_char,\n+        pub int_p_sep_by_space: ::c_char,\n+        pub int_n_cs_precedes: ::c_char,\n+        pub int_n_sep_by_space: ::c_char,\n+        pub int_p_sign_posn: ::c_char,\n+        pub int_n_sign_posn: ::c_char,\n+    }\n+\n+    pub struct ufs_args {\n+        pub fspec: *mut ::c_char,\n+        pub export_info: export_args,\n+    }\n+\n+    pub struct mfs_args {\n+        pub fspec: *mut ::c_char,\n+        pub export_info: export_args,\n+        // https://github.com/openbsd/src/blob/master/sys/sys/types.h#L134\n+        pub base: *mut ::c_char,\n+        pub size: ::c_ulong,\n+    }\n+\n+    pub struct iso_args {\n+        pub fspec: *mut ::c_char,\n+        pub export_info: export_args,\n+        pub flags: ::c_int,\n+        pub sess: ::c_int,\n+    }\n+\n+    pub struct nfs_args {\n+        pub version: ::c_int,\n+        pub addr: *mut ::sockaddr,\n+        pub addrlen: ::c_int,\n+        pub sotype: ::c_int,\n+        pub proto: ::c_int,\n+        pub fh: *mut ::c_uchar,\n+        pub fhsize: ::c_int,\n+        pub flags: ::c_int,\n+        pub wsize: ::c_int,\n+        pub rsize: ::c_int,\n+        pub readdirsize: ::c_int,\n+        pub timeo: ::c_int,\n+        pub retrans: ::c_int,\n+        pub maxgrouplist: ::c_int,\n+        pub readahead: ::c_int,\n+        pub leaseterm: ::c_int,\n+        pub deadthresh: ::c_int,\n+        pub hostname: *mut ::c_char,\n+        pub acregmin: ::c_int,\n+        pub acregmax: ::c_int,\n+        pub acdirmin: ::c_int,\n+        pub acdirmax: ::c_int,\n+    }\n+\n+    pub struct msdosfs_args {\n+        pub fspec: *mut ::c_char,\n+        pub export_info: export_args,\n+        pub uid: ::uid_t,\n+        pub gid: ::gid_t,\n+        pub mask: ::mode_t,\n+        pub flags: ::c_int,\n+    }\n+\n+    pub struct ntfs_args {\n+        pub fspec: *mut ::c_char,\n+        pub export_info: export_args,\n+        pub uid: ::uid_t,\n+        pub gid: ::gid_t,\n+        pub mode: ::mode_t,\n+        pub flag: ::c_ulong,\n+    }\n+\n+    pub struct udf_args {\n+        pub fspec: *mut ::c_char,\n+        pub lastblock: u32,\n+    }\n+\n+    pub struct tmpfs_args {\n+        pub ta_version: ::c_int,\n+        pub ta_nodes_max: ::ino_t,\n+        pub ta_size_max: ::off_t,\n+        pub ta_root_uid: ::uid_t,\n+        pub ta_root_gid: ::gid_t,\n+        pub ta_root_mode: ::mode_t,\n+    }\n+\n+    pub struct fusefs_args {\n+        pub name: *mut ::c_char,\n+        pub fd: ::c_int,\n+        pub max_read: ::c_int,\n+        pub allow_other: ::c_int,\n+    }\n+\n+    pub struct xucred {\n+        pub cr_uid: ::uid_t,\n+        pub cr_gid: ::gid_t,\n+        pub cr_ngroups: ::c_short,\n+        //https://github.com/openbsd/src/blob/master/sys/sys/syslimits.h#L44\n+        pub cr_groups: [::gid_t; 16],\n+    }\n+\n+    pub struct export_args {\n+        pub ex_flags: ::c_int,\n+        pub ex_root: ::uid_t,\n+        pub ex_anon: xucred,\n+        pub ex_addr: *mut ::sockaddr,\n+        pub ex_addrlen: ::c_int,\n+        pub ex_mask: *mut ::sockaddr,\n+        pub ex_masklen: ::c_int,\n+    }\n+\n+    pub struct ip_mreq {\n+        pub imr_multiaddr: in_addr,\n+        pub imr_interface: in_addr,\n+    }\n+\n+    pub struct in_addr {\n+        pub s_addr: ::in_addr_t,\n+    }\n+\n+    pub struct sockaddr_in {\n+        pub sin_len: u8,\n+        pub sin_family: ::sa_family_t,\n+        pub sin_port: ::in_port_t,\n+        pub sin_addr: ::in_addr,\n+        pub sin_zero: [i8; 8],\n+    }\n+\n+    pub struct kevent {\n+        pub ident: ::uintptr_t,\n+        pub filter: ::c_short,\n+        pub flags: ::c_ushort,\n+        pub fflags: ::c_uint,\n+        pub data: i64,\n+        pub udata: *mut ::c_void,\n+    }\n+\n+    pub struct stat {\n+        pub st_mode: ::mode_t,\n+        pub st_dev: ::dev_t,\n+        pub st_ino: ::ino_t,\n+        pub st_nlink: ::nlink_t,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        pub st_rdev: ::dev_t,\n+        pub st_atime: ::time_t,\n+        pub st_atime_nsec: ::c_long,\n+        pub st_mtime: ::time_t,\n+        pub st_mtime_nsec: ::c_long,\n+        pub st_ctime: ::time_t,\n+        pub st_ctime_nsec: ::c_long,\n+        pub st_size: ::off_t,\n+        pub st_blocks: ::blkcnt_t,\n+        pub st_blksize: ::blksize_t,\n+        pub st_flags: u32,\n+        pub st_gen: u32,\n+        pub st_birthtime: ::time_t,\n+        pub st_birthtime_nsec: ::c_long,\n+    }\n+\n+    pub struct statvfs {\n+        pub f_bsize: ::c_ulong,\n+        pub f_frsize: ::c_ulong,\n+        pub f_blocks: ::fsblkcnt_t,\n+        pub f_bfree: ::fsblkcnt_t,\n+        pub f_bavail: ::fsblkcnt_t,\n+        pub f_files: ::fsfilcnt_t,\n+        pub f_ffree: ::fsfilcnt_t,\n+        pub f_favail: ::fsfilcnt_t,\n+        pub f_fsid: ::c_ulong,\n+        pub f_flag: ::c_ulong,\n+        pub f_namemax: ::c_ulong,\n+    }\n+\n+    pub struct addrinfo {\n+        pub ai_flags: ::c_int,\n+        pub ai_family: ::c_int,\n+        pub ai_socktype: ::c_int,\n+        pub ai_protocol: ::c_int,\n+        pub ai_addrlen: ::socklen_t,\n+        pub ai_addr: *mut ::sockaddr,\n+        pub ai_canonname: *mut ::c_char,\n+        pub ai_next: *mut ::addrinfo,\n+    }\n+\n+    pub struct Dl_info {\n+        pub dli_fname: *const ::c_char,\n+        pub dli_fbase: *mut ::c_void,\n+        pub dli_sname: *const ::c_char,\n+        pub dli_saddr: *mut ::c_void,\n+    }\n+\n+    pub struct if_data {\n+        pub ifi_type: ::c_uchar,\n+        pub ifi_addrlen: ::c_uchar,\n+        pub ifi_hdrlen: ::c_uchar,\n+        pub ifi_link_state: ::c_uchar,\n+        pub ifi_mtu: u32,\n+        pub ifi_metric: u32,\n+        pub ifi_rdomain: u32,\n+        pub ifi_baudrate: u64,\n+        pub ifi_ipackets: u64,\n+        pub ifi_ierrors: u64,\n+        pub ifi_opackets: u64,\n+        pub ifi_oerrors: u64,\n+        pub ifi_collisions: u64,\n+        pub ifi_ibytes: u64,\n+        pub ifi_obytes: u64,\n+        pub ifi_imcasts: u64,\n+        pub ifi_omcasts: u64,\n+        pub ifi_iqdrops: u64,\n+        pub ifi_oqdrops: u64,\n+        pub ifi_noproto: u64,\n+        pub ifi_capabilities: u32,\n+        pub ifi_lastchange: ::timeval,\n+    }\n+\n+    pub struct if_msghdr {\n+        pub ifm_msglen: ::c_ushort,\n+        pub ifm_version: ::c_uchar,\n+        pub ifm_type: ::c_uchar,\n+        pub ifm_hdrlen: ::c_ushort,\n+        pub ifm_index: ::c_ushort,\n+        pub ifm_tableid: ::c_ushort,\n+        pub ifm_pad1: ::c_uchar,\n+        pub ifm_pad2: ::c_uchar,\n+        pub ifm_addrs: ::c_int,\n+        pub ifm_flags: ::c_int,\n+        pub ifm_xflags: ::c_int,\n+        pub ifm_data: if_data,\n+    }\n+\n+    pub struct sockaddr_dl {\n+        pub sdl_len: ::c_uchar,\n+        pub sdl_family: ::c_uchar,\n+        pub sdl_index: ::c_ushort,\n+        pub sdl_type: ::c_uchar,\n+        pub sdl_nlen: ::c_uchar,\n+        pub sdl_alen: ::c_uchar,\n+        pub sdl_slen: ::c_uchar,\n+        pub sdl_data: [::c_char; 24],\n+    }\n+\n+    pub struct sockpeercred {\n+        pub uid: ::uid_t,\n+        pub gid: ::gid_t,\n+        pub pid: ::pid_t,\n+    }\n+\n+    pub struct arphdr {\n+        pub ar_hrd: u16,\n+        pub ar_pro: u16,\n+        pub ar_hln: u8,\n+        pub ar_pln: u8,\n+        pub ar_op: u16,\n+    }\n+}\n+\n+impl siginfo_t {\n+    pub unsafe fn si_value(&self) -> ::sigval {\n+        #[repr(C)]\n+        struct siginfo_timer {\n+            _si_signo: ::c_int,\n+            _si_errno: ::c_int,\n+            _si_code: ::c_int,\n+            _pid: ::pid_t,\n+            _uid: ::uid_t,\n+            value: ::sigval,\n+        }\n+        (*(self as *const siginfo_t as *const siginfo_timer)).value\n+    }\n+}\n+\n+s_no_extra_traits! {\n+    pub struct dirent {\n+        pub d_fileno: ::ino_t,\n+        pub d_off: ::off_t,\n+        pub d_reclen: u16,\n+        pub d_type: u8,\n+        pub d_namlen: u8,\n+        __d_padding: [u8; 4],\n+        pub d_name: [::c_char; 256],\n+    }\n+\n+    pub struct sockaddr_storage {\n+        pub ss_len: u8,\n+        pub ss_family: ::sa_family_t,\n+        __ss_pad1: [u8; 6],\n+        __ss_pad2: i64,\n+        __ss_pad3: [u8; 240],\n+    }\n+\n+    pub struct siginfo_t {\n+        pub si_signo: ::c_int,\n+        pub si_code: ::c_int,\n+        pub si_errno: ::c_int,\n+        pub si_addr: *mut ::c_char,\n+        #[cfg(target_pointer_width = \"32\")]\n+        __pad: [u8; 112],\n+        #[cfg(target_pointer_width = \"64\")]\n+        __pad: [u8; 108],\n+    }\n+\n+    pub struct lastlog {\n+        ll_time: ::time_t,\n+        ll_line: [::c_char; UT_LINESIZE],\n+        ll_host: [::c_char; UT_HOSTSIZE],\n+    }\n+\n+    pub struct utmp {\n+        pub ut_line: [::c_char; UT_LINESIZE],\n+        pub ut_name: [::c_char; UT_NAMESIZE],\n+        pub ut_host: [::c_char; UT_HOSTSIZE],\n+        pub ut_time: ::time_t,\n+    }\n+\n+    pub union mount_info {\n+        pub ufs_args: ufs_args,\n+        pub mfs_args: mfs_args,\n+        pub nfs_args: nfs_args,\n+        pub iso_args: iso_args,\n+        pub msdosfs_args: msdosfs_args,\n+        pub ntfs_args: ntfs_args,\n+        pub tmpfs_args: tmpfs_args,\n+        align: [::c_char; 160],\n+    }\n+\n+}\n+\n+cfg_if! {\n+    if #[cfg(feature = \"extra_traits\")] {\n+        impl PartialEq for dirent {\n+            fn eq(&self, other: &dirent) -> bool {\n+                self.d_fileno == other.d_fileno\n+                    && self.d_off == other.d_off\n+                    && self.d_reclen == other.d_reclen\n+                    && self.d_type == other.d_type\n+                    && self.d_namlen == other.d_namlen\n+                    && self\n+                    .d_name\n+                    .iter()\n+                    .zip(other.d_name.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+\n+        impl Eq for dirent {}\n+\n+        impl ::fmt::Debug for dirent {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"dirent\")\n+                    .field(\"d_fileno\", &self.d_fileno)\n+                    .field(\"d_off\", &self.d_off)\n+                    .field(\"d_reclen\", &self.d_reclen)\n+                    .field(\"d_type\", &self.d_type)\n+                    .field(\"d_namlen\", &self.d_namlen)\n+                // FIXME: .field(\"d_name\", &self.d_name)\n+                    .finish()\n+            }\n+        }\n+\n+        impl ::hash::Hash for dirent {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.d_fileno.hash(state);\n+                self.d_off.hash(state);\n+                self.d_reclen.hash(state);\n+                self.d_type.hash(state);\n+                self.d_namlen.hash(state);\n+                self.d_name.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for sockaddr_storage {\n+            fn eq(&self, other: &sockaddr_storage) -> bool {\n+                self.ss_len == other.ss_len\n+                    && self.ss_family == other.ss_family\n+            }\n+        }\n+\n+        impl Eq for sockaddr_storage {}\n+\n+        impl ::fmt::Debug for sockaddr_storage {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"sockaddr_storage\")\n+                    .field(\"ss_len\", &self.ss_len)\n+                    .field(\"ss_family\", &self.ss_family)\n+                    .finish()\n+            }\n+        }\n+\n+        impl ::hash::Hash for sockaddr_storage {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.ss_len.hash(state);\n+                self.ss_family.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for siginfo_t {\n+            fn eq(&self, other: &siginfo_t) -> bool {\n+                self.si_signo == other.si_signo\n+                    && self.si_code == other.si_code\n+                    && self.si_errno == other.si_errno\n+                    && self.si_addr == other.si_addr\n+            }\n+        }\n+\n+        impl Eq for siginfo_t {}\n+\n+        impl ::fmt::Debug for siginfo_t {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"siginfo_t\")\n+                    .field(\"si_signo\", &self.si_signo)\n+                    .field(\"si_code\", &self.si_code)\n+                    .field(\"si_errno\", &self.si_errno)\n+                    .field(\"si_addr\", &self.si_addr)\n+                    .finish()\n+            }\n+        }\n+\n+        impl ::hash::Hash for siginfo_t {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.si_signo.hash(state);\n+                self.si_code.hash(state);\n+                self.si_errno.hash(state);\n+                self.si_addr.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for lastlog {\n+            fn eq(&self, other: &lastlog) -> bool {\n+                self.ll_time == other.ll_time\n+                    && self\n+                    .ll_line\n+                    .iter()\n+                    .zip(other.ll_line.iter())\n+                    .all(|(a,b)| a == b)\n+                    && self\n+                    .ll_host\n+                    .iter()\n+                    .zip(other.ll_host.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+\n+        impl Eq for lastlog {}\n+\n+        impl ::fmt::Debug for lastlog {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"lastlog\")\n+                    .field(\"ll_time\", &self.ll_time)\n+                // FIXME: .field(\"ll_line\", &self.ll_line)\n+                // FIXME: .field(\"ll_host\", &self.ll_host)\n+                    .finish()\n+            }\n+        }\n+\n+        impl ::hash::Hash for lastlog {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.ll_time.hash(state);\n+                self.ll_line.hash(state);\n+                self.ll_host.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for utmp {\n+            fn eq(&self, other: &utmp) -> bool {\n+                self.ut_time == other.ut_time\n+                    && self\n+                    .ut_line\n+                    .iter()\n+                    .zip(other.ut_line.iter())\n+                    .all(|(a,b)| a == b)\n+                    && self\n+                    .ut_name\n+                    .iter()\n+                    .zip(other.ut_name.iter())\n+                    .all(|(a,b)| a == b)\n+                    && self\n+                    .ut_host\n+                    .iter()\n+                    .zip(other.ut_host.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+\n+        impl Eq for utmp {}\n+\n+        impl ::fmt::Debug for utmp {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"utmp\")\n+                // FIXME: .field(\"ut_line\", &self.ut_line)\n+                // FIXME: .field(\"ut_name\", &self.ut_name)\n+                // FIXME: .field(\"ut_host\", &self.ut_host)\n+                    .field(\"ut_time\", &self.ut_time)\n+                    .finish()\n+            }\n+        }\n+\n+        impl ::hash::Hash for utmp {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.ut_line.hash(state);\n+                self.ut_name.hash(state);\n+                self.ut_host.hash(state);\n+                self.ut_time.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for mount_info {\n+            fn eq(&self, other: &mount_info) -> bool {\n+                unsafe {\n+                    self.align\n+                        .iter()\n+                        .zip(other.align.iter())\n+                        .all(|(a,b)| a == b)\n+                }\n+            }\n+        }\n+\n+        impl Eq for mount_info { }\n+\n+        impl ::fmt::Debug for mount_info {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"mount_info\")\n+                // FIXME: .field(\"align\", &self.align)\n+                    .finish()\n+            }\n+        }\n+\n+        impl ::hash::Hash for mount_info {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                unsafe { self.align.hash(state) };\n+            }\n+        }\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(libc_union)] {\n+        s_no_extra_traits! {\n+            // This type uses the union mount_info:\n+            pub struct statfs {\n+                pub f_flags: u32,\n+                pub f_bsize: u32,\n+                pub f_iosize: u32,\n+                pub f_blocks: u64,\n+                pub f_bfree: u64,\n+                pub f_bavail: i64,\n+                pub f_files: u64,\n+                pub f_ffree: u64,\n+                pub f_favail: i64,\n+                pub f_syncwrites: u64,\n+                pub f_syncreads: u64,\n+                pub f_asyncwrites: u64,\n+                pub f_asyncreads: u64,\n+                pub f_fsid: ::fsid_t,\n+                pub f_namemax: u32,\n+                pub f_owner: ::uid_t,\n+                pub f_ctime: u64,\n+                pub f_fstypename: [::c_char; 16],\n+                pub f_mntonname: [::c_char; 90],\n+                pub f_mntfromname: [::c_char; 90],\n+                pub f_mntfromspec: [::c_char; 90],\n+                pub mount_info: mount_info,\n+            }\n+        }\n+\n+        cfg_if! {\n+            if #[cfg(feature = \"extra_traits\")] {\n+                impl PartialEq for statfs {\n+                    fn eq(&self, other: &statfs) -> bool {\n+                        self.f_flags == other.f_flags\n+                            && self.f_bsize == other.f_bsize\n+                            && self.f_iosize == other.f_iosize\n+                            && self.f_blocks == other.f_blocks\n+                            && self.f_bfree == other.f_bfree\n+                            && self.f_bavail == other.f_bavail\n+                            && self.f_files == other.f_files\n+                            && self.f_ffree == other.f_ffree\n+                            && self.f_favail == other.f_favail\n+                            && self.f_syncwrites == other.f_syncwrites\n+                            && self.f_syncreads == other.f_syncreads\n+                            && self.f_asyncwrites == other.f_asyncwrites\n+                            && self.f_asyncreads == other.f_asyncreads\n+                            && self.f_fsid == other.f_fsid\n+                            && self.f_namemax == other.f_namemax\n+                            && self.f_owner == other.f_owner\n+                            && self.f_ctime == other.f_ctime\n+                            && self.f_fstypename\n+                            .iter()\n+                            .zip(other.f_fstypename.iter())\n+                            .all(|(a,b)| a == b)\n+                            && self.f_mntonname\n+                            .iter()\n+                            .zip(other.f_mntonname.iter())\n+                            .all(|(a,b)| a == b)\n+                            && self.f_mntfromname\n+                            .iter()\n+                            .zip(other.f_mntfromname.iter())\n+                            .all(|(a,b)| a == b)\n+                            && self.f_mntfromspec\n+                            .iter()\n+                            .zip(other.f_mntfromspec.iter())\n+                            .all(|(a,b)| a == b)\n+                            && self.mount_info == other.mount_info\n+                    }\n+                }\n+\n+                impl Eq for statfs { }\n+\n+                impl ::fmt::Debug for statfs {\n+                    fn fmt(&self, f: &mut ::fmt::Formatter)\n+                           -> ::fmt::Result {\n+                        f.debug_struct(\"statfs\")\n+                            .field(\"f_flags\", &self.f_flags)\n+                            .field(\"f_bsize\", &self.f_bsize)\n+                            .field(\"f_iosize\", &self.f_iosize)\n+                            .field(\"f_blocks\", &self.f_blocks)\n+                            .field(\"f_bfree\", &self.f_bfree)\n+                            .field(\"f_bavail\", &self.f_bavail)\n+                            .field(\"f_files\", &self.f_files)\n+                            .field(\"f_ffree\", &self.f_ffree)\n+                            .field(\"f_favail\", &self.f_favail)\n+                            .field(\"f_syncwrites\", &self.f_syncwrites)\n+                            .field(\"f_syncreads\", &self.f_syncreads)\n+                            .field(\"f_asyncwrites\", &self.f_asyncwrites)\n+                            .field(\"f_asyncreads\", &self.f_asyncreads)\n+                            .field(\"f_fsid\", &self.f_fsid)\n+                            .field(\"f_namemax\", &self.f_namemax)\n+                            .field(\"f_owner\", &self.f_owner)\n+                            .field(\"f_ctime\", &self.f_ctime)\n+                        // FIXME: .field(\"f_fstypename\", &self.f_fstypename)\n+                        // FIXME: .field(\"f_mntonname\", &self.f_mntonname)\n+                        // FIXME: .field(\"f_mntfromname\", &self.f_mntfromname)\n+                        // FIXME: .field(\"f_mntfromspec\", &self.f_mntfromspec)\n+                            .field(\"mount_info\", &self.mount_info)\n+                            .finish()\n+                    }\n+                }\n+\n+                impl ::hash::Hash for statfs {\n+                    fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                        self.f_flags.hash(state);\n+                        self.f_bsize.hash(state);\n+                        self.f_iosize.hash(state);\n+                        self.f_blocks.hash(state);\n+                        self.f_bfree.hash(state);\n+                        self.f_bavail.hash(state);\n+                        self.f_files.hash(state);\n+                        self.f_ffree.hash(state);\n+                        self.f_favail.hash(state);\n+                        self.f_syncwrites.hash(state);\n+                        self.f_syncreads.hash(state);\n+                        self.f_asyncwrites.hash(state);\n+                        self.f_asyncreads.hash(state);\n+                        self.f_fsid.hash(state);\n+                        self.f_namemax.hash(state);\n+                        self.f_owner.hash(state);\n+                        self.f_ctime.hash(state);\n+                        self.f_fstypename.hash(state);\n+                        self.f_mntonname.hash(state);\n+                        self.f_mntfromname.hash(state);\n+                        self.f_mntfromspec.hash(state);\n+                        self.mount_info.hash(state);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+pub const UT_NAMESIZE: usize = 32;\n+pub const UT_LINESIZE: usize = 8;\n+pub const UT_HOSTSIZE: usize = 256;\n+\n+pub const O_CLOEXEC: ::c_int = 0x10000;\n+pub const O_DIRECTORY: ::c_int = 0x20000;\n+pub const O_RSYNC: ::c_int = O_SYNC;\n+\n+pub const MS_SYNC: ::c_int = 0x0002;\n+pub const MS_INVALIDATE: ::c_int = 0x0004;\n+\n+pub const POLLNORM: ::c_short = ::POLLRDNORM;\n+\n+pub const ENOATTR: ::c_int = 83;\n+pub const EILSEQ: ::c_int = 84;\n+pub const EOVERFLOW: ::c_int = 87;\n+pub const ECANCELED: ::c_int = 88;\n+pub const EIDRM: ::c_int = 89;\n+pub const ENOMSG: ::c_int = 90;\n+pub const ENOTSUP: ::c_int = 91;\n+pub const EBADMSG: ::c_int = 92;\n+pub const ENOTRECOVERABLE: ::c_int = 93;\n+pub const EOWNERDEAD: ::c_int = 94;\n+pub const EPROTO: ::c_int = 95;\n+pub const ELAST: ::c_int = 95;\n+\n+pub const F_DUPFD_CLOEXEC: ::c_int = 10;\n+\n+pub const UTIME_OMIT: c_long = -1;\n+pub const UTIME_NOW: c_long = -2;\n+\n+pub const AT_FDCWD: ::c_int = -100;\n+pub const AT_EACCESS: ::c_int = 0x01;\n+pub const AT_SYMLINK_NOFOLLOW: ::c_int = 0x02;\n+pub const AT_SYMLINK_FOLLOW: ::c_int = 0x04;\n+pub const AT_REMOVEDIR: ::c_int = 0x08;\n+\n+#[deprecated(since = \"0.2.64\", note = \"Not stable across OS versions\")]\n+pub const RLIM_NLIMITS: ::c_int = 9;\n+\n+pub const SO_TIMESTAMP: ::c_int = 0x0800;\n+pub const SO_SNDTIMEO: ::c_int = 0x1005;\n+pub const SO_RCVTIMEO: ::c_int = 0x1006;\n+pub const SO_BINDANY: ::c_int = 0x1000;\n+pub const SO_NETPROC: ::c_int = 0x1020;\n+pub const SO_RTABLE: ::c_int = 0x1021;\n+pub const SO_PEERCRED: ::c_int = 0x1022;\n+pub const SO_SPLICE: ::c_int = 0x1023;\n+\n+// sys/netinet/in.h\n+// Protocols (RFC 1700)\n+// NOTE: These are in addition to the constants defined in src/unix/mod.rs\n+\n+// IPPROTO_IP defined in src/unix/mod.rs\n+/// Hop-by-hop option header\n+pub const IPPROTO_HOPOPTS: ::c_int = 0;\n+// IPPROTO_ICMP defined in src/unix/mod.rs\n+/// group mgmt protocol\n+pub const IPPROTO_IGMP: ::c_int = 2;\n+/// gateway^2 (deprecated)\n+pub const IPPROTO_GGP: ::c_int = 3;\n+/// for compatibility\n+pub const IPPROTO_IPIP: ::c_int = 4;\n+// IPPROTO_TCP defined in src/unix/mod.rs\n+/// exterior gateway protocol\n+pub const IPPROTO_EGP: ::c_int = 8;\n+/// pup\n+pub const IPPROTO_PUP: ::c_int = 12;\n+// IPPROTO_UDP defined in src/unix/mod.rs\n+/// xns idp\n+pub const IPPROTO_IDP: ::c_int = 22;\n+/// tp-4 w/ class negotiation\n+pub const IPPROTO_TP: ::c_int = 29;\n+// IPPROTO_IPV6 defined in src/unix/mod.rs\n+/// IP6 routing header\n+pub const IPPROTO_ROUTING: ::c_int = 43;\n+/// IP6 fragmentation header\n+pub const IPPROTO_FRAGMENT: ::c_int = 44;\n+/// resource reservation\n+pub const IPPROTO_RSVP: ::c_int = 46;\n+/// General Routing Encap.\n+pub const IPPROTO_GRE: ::c_int = 47;\n+/// IP6 Encap Sec. Payload\n+pub const IPPROTO_ESP: ::c_int = 50;\n+/// IP6 Auth Header\n+pub const IPPROTO_AH: ::c_int = 51;\n+/// IP Mobility RFC 2004\n+pub const IPPROTO_MOBILE: ::c_int = 55;\n+// IPPROTO_ICMPV6 defined in src/unix/mod.rs\n+/// IP6 no next header\n+pub const IPPROTO_NONE: ::c_int = 59;\n+/// IP6 destination option\n+pub const IPPROTO_DSTOPTS: ::c_int = 60;\n+/// ISO cnlp\n+pub const IPPROTO_EON: ::c_int = 80;\n+/// Ethernet-in-IP\n+pub const IPPROTO_ETHERIP: ::c_int = 97;\n+/// encapsulation header\n+pub const IPPROTO_ENCAP: ::c_int = 98;\n+/// Protocol indep. multicast\n+pub const IPPROTO_PIM: ::c_int = 103;\n+/// IP Payload Comp. Protocol\n+pub const IPPROTO_IPCOMP: ::c_int = 108;\n+/// CARP\n+pub const IPPROTO_CARP: ::c_int = 112;\n+/// unicast MPLS packet\n+pub const IPPROTO_MPLS: ::c_int = 137;\n+/// PFSYNC\n+pub const IPPROTO_PFSYNC: ::c_int = 240;\n+pub const IPPROTO_MAX: ::c_int = 256;\n+\n+// Only used internally, so it can be outside the range of valid IP protocols\n+pub const IPPROTO_DIVERT: ::c_int = 258;\n+\n+pub const IP_RECVDSTADDR: ::c_int = 7;\n+pub const IP_SENDSRCADDR: ::c_int = IP_RECVDSTADDR;\n+pub const IP_RECVIF: ::c_int = 30;\n+\n+// sys/netinet/in.h\n+pub const TCP_MD5SIG: ::c_int = 0x04;\n+pub const TCP_NOPUSH: ::c_int = 0x10;\n+\n+pub const AF_ECMA: ::c_int = 8;\n+pub const AF_ROUTE: ::c_int = 17;\n+pub const AF_ENCAP: ::c_int = 28;\n+pub const AF_SIP: ::c_int = 29;\n+pub const AF_KEY: ::c_int = 30;\n+pub const pseudo_AF_HDRCMPLT: ::c_int = 31;\n+pub const AF_BLUETOOTH: ::c_int = 32;\n+pub const AF_MPLS: ::c_int = 33;\n+pub const pseudo_AF_PFLOW: ::c_int = 34;\n+pub const pseudo_AF_PIPEX: ::c_int = 35;\n+pub const NET_RT_DUMP: ::c_int = 1;\n+pub const NET_RT_FLAGS: ::c_int = 2;\n+pub const NET_RT_IFLIST: ::c_int = 3;\n+pub const NET_RT_STATS: ::c_int = 4;\n+pub const NET_RT_TABLE: ::c_int = 5;\n+pub const NET_RT_IFNAMES: ::c_int = 6;\n+#[doc(hidden)]\n+pub const NET_RT_MAXID: ::c_int = 7;\n+\n+pub const IPV6_JOIN_GROUP: ::c_int = 12;\n+pub const IPV6_LEAVE_GROUP: ::c_int = 13;\n+\n+pub const PF_ROUTE: ::c_int = AF_ROUTE;\n+pub const PF_ECMA: ::c_int = AF_ECMA;\n+pub const PF_ENCAP: ::c_int = AF_ENCAP;\n+pub const PF_SIP: ::c_int = AF_SIP;\n+pub const PF_KEY: ::c_int = AF_KEY;\n+pub const PF_BPF: ::c_int = pseudo_AF_HDRCMPLT;\n+pub const PF_BLUETOOTH: ::c_int = AF_BLUETOOTH;\n+pub const PF_MPLS: ::c_int = AF_MPLS;\n+pub const PF_PFLOW: ::c_int = pseudo_AF_PFLOW;\n+pub const PF_PIPEX: ::c_int = pseudo_AF_PIPEX;\n+\n+pub const SCM_TIMESTAMP: ::c_int = 0x04;\n+\n+pub const O_DSYNC: ::c_int = 128;\n+\n+pub const MAP_RENAME: ::c_int = 0x0000;\n+pub const MAP_NORESERVE: ::c_int = 0x0000;\n+pub const MAP_HASSEMAPHORE: ::c_int = 0x0000;\n+\n+pub const EIPSEC: ::c_int = 82;\n+pub const ENOMEDIUM: ::c_int = 85;\n+pub const EMEDIUMTYPE: ::c_int = 86;\n+\n+pub const EAI_BADFLAGS: ::c_int = -1;\n+pub const EAI_NONAME: ::c_int = -2;\n+pub const EAI_AGAIN: ::c_int = -3;\n+pub const EAI_FAIL: ::c_int = -4;\n+pub const EAI_NODATA: ::c_int = -5;\n+pub const EAI_FAMILY: ::c_int = -6;\n+pub const EAI_SOCKTYPE: ::c_int = -7;\n+pub const EAI_SERVICE: ::c_int = -8;\n+pub const EAI_MEMORY: ::c_int = -10;\n+pub const EAI_SYSTEM: ::c_int = -11;\n+pub const EAI_OVERFLOW: ::c_int = -14;\n+\n+pub const RUSAGE_THREAD: ::c_int = 1;\n+\n+pub const MAP_COPY: ::c_int = 0x0002;\n+pub const MAP_NOEXTEND: ::c_int = 0x0000;\n+\n+pub const _PC_LINK_MAX: ::c_int = 1;\n+pub const _PC_MAX_CANON: ::c_int = 2;\n+pub const _PC_MAX_INPUT: ::c_int = 3;\n+pub const _PC_NAME_MAX: ::c_int = 4;\n+pub const _PC_PATH_MAX: ::c_int = 5;\n+pub const _PC_PIPE_BUF: ::c_int = 6;\n+pub const _PC_CHOWN_RESTRICTED: ::c_int = 7;\n+pub const _PC_NO_TRUNC: ::c_int = 8;\n+pub const _PC_VDISABLE: ::c_int = 9;\n+pub const _PC_2_SYMLINKS: ::c_int = 10;\n+pub const _PC_ALLOC_SIZE_MIN: ::c_int = 11;\n+pub const _PC_ASYNC_IO: ::c_int = 12;\n+pub const _PC_FILESIZEBITS: ::c_int = 13;\n+pub const _PC_PRIO_IO: ::c_int = 14;\n+pub const _PC_REC_INCR_XFER_SIZE: ::c_int = 15;\n+pub const _PC_REC_MAX_XFER_SIZE: ::c_int = 16;\n+pub const _PC_REC_MIN_XFER_SIZE: ::c_int = 17;\n+pub const _PC_REC_XFER_ALIGN: ::c_int = 18;\n+pub const _PC_SYMLINK_MAX: ::c_int = 19;\n+pub const _PC_SYNC_IO: ::c_int = 20;\n+pub const _PC_TIMESTAMP_RESOLUTION: ::c_int = 21;\n+\n+pub const _SC_CLK_TCK: ::c_int = 3;\n+pub const _SC_SEM_NSEMS_MAX: ::c_int = 31;\n+pub const _SC_SEM_VALUE_MAX: ::c_int = 32;\n+pub const _SC_HOST_NAME_MAX: ::c_int = 33;\n+pub const _SC_MONOTONIC_CLOCK: ::c_int = 34;\n+pub const _SC_2_PBS: ::c_int = 35;\n+pub const _SC_2_PBS_ACCOUNTING: ::c_int = 36;\n+pub const _SC_2_PBS_CHECKPOINT: ::c_int = 37;\n+pub const _SC_2_PBS_LOCATE: ::c_int = 38;\n+pub const _SC_2_PBS_MESSAGE: ::c_int = 39;\n+pub const _SC_2_PBS_TRACK: ::c_int = 40;\n+pub const _SC_ADVISORY_INFO: ::c_int = 41;\n+pub const _SC_AIO_LISTIO_MAX: ::c_int = 42;\n+pub const _SC_AIO_MAX: ::c_int = 43;\n+pub const _SC_AIO_PRIO_DELTA_MAX: ::c_int = 44;\n+pub const _SC_ASYNCHRONOUS_IO: ::c_int = 45;\n+pub const _SC_ATEXIT_MAX: ::c_int = 46;\n+pub const _SC_BARRIERS: ::c_int = 47;\n+pub const _SC_CLOCK_SELECTION: ::c_int = 48;\n+pub const _SC_CPUTIME: ::c_int = 49;\n+pub const _SC_DELAYTIMER_MAX: ::c_int = 50;\n+pub const _SC_IOV_MAX: ::c_int = 51;\n+pub const _SC_IPV6: ::c_int = 52;\n+pub const _SC_MAPPED_FILES: ::c_int = 53;\n+pub const _SC_MEMLOCK: ::c_int = 54;\n+pub const _SC_MEMLOCK_RANGE: ::c_int = 55;\n+pub const _SC_MEMORY_PROTECTION: ::c_int = 56;\n+pub const _SC_MESSAGE_PASSING: ::c_int = 57;\n+pub const _SC_MQ_OPEN_MAX: ::c_int = 58;\n+pub const _SC_MQ_PRIO_MAX: ::c_int = 59;\n+pub const _SC_PRIORITIZED_IO: ::c_int = 60;\n+pub const _SC_PRIORITY_SCHEDULING: ::c_int = 61;\n+pub const _SC_RAW_SOCKETS: ::c_int = 62;\n+pub const _SC_READER_WRITER_LOCKS: ::c_int = 63;\n+pub const _SC_REALTIME_SIGNALS: ::c_int = 64;\n+pub const _SC_REGEXP: ::c_int = 65;\n+pub const _SC_RTSIG_MAX: ::c_int = 66;\n+pub const _SC_SEMAPHORES: ::c_int = 67;\n+pub const _SC_SHARED_MEMORY_OBJECTS: ::c_int = 68;\n+pub const _SC_SHELL: ::c_int = 69;\n+pub const _SC_SIGQUEUE_MAX: ::c_int = 70;\n+pub const _SC_SPAWN: ::c_int = 71;\n+pub const _SC_SPIN_LOCKS: ::c_int = 72;\n+pub const _SC_SPORADIC_SERVER: ::c_int = 73;\n+pub const _SC_SS_REPL_MAX: ::c_int = 74;\n+pub const _SC_SYNCHRONIZED_IO: ::c_int = 75;\n+pub const _SC_SYMLOOP_MAX: ::c_int = 76;\n+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 77;\n+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 78;\n+pub const _SC_THREAD_CPUTIME: ::c_int = 79;\n+pub const _SC_THREAD_DESTRUCTOR_ITERATIONS: ::c_int = 80;\n+pub const _SC_THREAD_KEYS_MAX: ::c_int = 81;\n+pub const _SC_THREAD_PRIO_INHERIT: ::c_int = 82;\n+pub const _SC_THREAD_PRIO_PROTECT: ::c_int = 83;\n+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 84;\n+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 85;\n+pub const _SC_THREAD_ROBUST_PRIO_INHERIT: ::c_int = 86;\n+pub const _SC_THREAD_ROBUST_PRIO_PROTECT: ::c_int = 87;\n+pub const _SC_THREAD_SPORADIC_SERVER: ::c_int = 88;\n+pub const _SC_THREAD_STACK_MIN: ::c_int = 89;\n+pub const _SC_THREAD_THREADS_MAX: ::c_int = 90;\n+pub const _SC_THREADS: ::c_int = 91;\n+pub const _SC_TIMEOUTS: ::c_int = 92;\n+pub const _SC_TIMER_MAX: ::c_int = 93;\n+pub const _SC_TIMERS: ::c_int = 94;\n+pub const _SC_TRACE: ::c_int = 95;\n+pub const _SC_TRACE_EVENT_FILTER: ::c_int = 96;\n+pub const _SC_TRACE_EVENT_NAME_MAX: ::c_int = 97;\n+pub const _SC_TRACE_INHERIT: ::c_int = 98;\n+pub const _SC_TRACE_LOG: ::c_int = 99;\n+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 100;\n+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 101;\n+pub const _SC_LOGIN_NAME_MAX: ::c_int = 102;\n+pub const _SC_THREAD_SAFE_FUNCTIONS: ::c_int = 103;\n+pub const _SC_TRACE_NAME_MAX: ::c_int = 104;\n+pub const _SC_TRACE_SYS_MAX: ::c_int = 105;\n+pub const _SC_TRACE_USER_EVENT_MAX: ::c_int = 106;\n+pub const _SC_TTY_NAME_MAX: ::c_int = 107;\n+pub const _SC_TYPED_MEMORY_OBJECTS: ::c_int = 108;\n+pub const _SC_V6_ILP32_OFF32: ::c_int = 109;\n+pub const _SC_V6_ILP32_OFFBIG: ::c_int = 110;\n+pub const _SC_V6_LP64_OFF64: ::c_int = 111;\n+pub const _SC_V6_LPBIG_OFFBIG: ::c_int = 112;\n+pub const _SC_V7_ILP32_OFF32: ::c_int = 113;\n+pub const _SC_V7_ILP32_OFFBIG: ::c_int = 114;\n+pub const _SC_V7_LP64_OFF64: ::c_int = 115;\n+pub const _SC_V7_LPBIG_OFFBIG: ::c_int = 116;\n+pub const _SC_XOPEN_CRYPT: ::c_int = 117;\n+pub const _SC_XOPEN_ENH_I18N: ::c_int = 118;\n+pub const _SC_XOPEN_LEGACY: ::c_int = 119;\n+pub const _SC_XOPEN_REALTIME: ::c_int = 120;\n+pub const _SC_XOPEN_REALTIME_THREADS: ::c_int = 121;\n+pub const _SC_XOPEN_STREAMS: ::c_int = 122;\n+pub const _SC_XOPEN_UNIX: ::c_int = 123;\n+pub const _SC_XOPEN_UUCP: ::c_int = 124;\n+pub const _SC_XOPEN_VERSION: ::c_int = 125;\n+pub const _SC_PHYS_PAGES: ::c_int = 500;\n+pub const _SC_AVPHYS_PAGES: ::c_int = 501;\n+pub const _SC_NPROCESSORS_CONF: ::c_int = 502;\n+pub const _SC_NPROCESSORS_ONLN: ::c_int = 503;\n+\n+pub const FD_SETSIZE: usize = 1024;\n+\n+pub const ST_NOSUID: ::c_ulong = 2;\n+\n+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = 0 as *mut _;\n+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = 0 as *mut _;\n+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = 0 as *mut _;\n+\n+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 1;\n+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 2;\n+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 3;\n+pub const PTHREAD_MUTEX_STRICT_NP: ::c_int = 4;\n+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = PTHREAD_MUTEX_STRICT_NP;\n+\n+pub const EVFILT_AIO: i16 = -3;\n+pub const EVFILT_PROC: i16 = -5;\n+pub const EVFILT_READ: i16 = -1;\n+pub const EVFILT_SIGNAL: i16 = -6;\n+pub const EVFILT_TIMER: i16 = -7;\n+pub const EVFILT_VNODE: i16 = -4;\n+pub const EVFILT_WRITE: i16 = -2;\n+\n+pub const EV_ADD: u16 = 0x1;\n+pub const EV_DELETE: u16 = 0x2;\n+pub const EV_ENABLE: u16 = 0x4;\n+pub const EV_DISABLE: u16 = 0x8;\n+pub const EV_ONESHOT: u16 = 0x10;\n+pub const EV_CLEAR: u16 = 0x20;\n+pub const EV_RECEIPT: u16 = 0x40;\n+pub const EV_DISPATCH: u16 = 0x80;\n+pub const EV_FLAG1: u16 = 0x2000;\n+pub const EV_ERROR: u16 = 0x4000;\n+pub const EV_EOF: u16 = 0x8000;\n+pub const EV_SYSFLAGS: u16 = 0xf000;\n+\n+pub const NOTE_LOWAT: u32 = 0x00000001;\n+pub const NOTE_EOF: u32 = 0x00000002;\n+pub const NOTE_DELETE: u32 = 0x00000001;\n+pub const NOTE_WRITE: u32 = 0x00000002;\n+pub const NOTE_EXTEND: u32 = 0x00000004;\n+pub const NOTE_ATTRIB: u32 = 0x00000008;\n+pub const NOTE_LINK: u32 = 0x00000010;\n+pub const NOTE_RENAME: u32 = 0x00000020;\n+pub const NOTE_REVOKE: u32 = 0x00000040;\n+pub const NOTE_TRUNCATE: u32 = 0x00000080;\n+pub const NOTE_EXIT: u32 = 0x80000000;\n+pub const NOTE_FORK: u32 = 0x40000000;\n+pub const NOTE_EXEC: u32 = 0x20000000;\n+pub const NOTE_PDATAMASK: u32 = 0x000fffff;\n+pub const NOTE_PCTRLMASK: u32 = 0xf0000000;\n+pub const NOTE_TRACK: u32 = 0x00000001;\n+pub const NOTE_TRACKERR: u32 = 0x00000002;\n+pub const NOTE_CHILD: u32 = 0x00000004;\n+\n+pub const TMP_MAX: ::c_uint = 0x7fffffff;\n+\n+pub const NI_MAXHOST: ::size_t = 256;\n+\n+pub const RTLD_LOCAL: ::c_int = 0;\n+\n+pub const CTL_MAXNAME: ::c_int = 12;\n+\n+pub const CTLTYPE_NODE: ::c_int = 1;\n+pub const CTLTYPE_INT: ::c_int = 2;\n+pub const CTLTYPE_STRING: ::c_int = 3;\n+pub const CTLTYPE_QUAD: ::c_int = 4;\n+pub const CTLTYPE_STRUCT: ::c_int = 5;\n+\n+pub const CTL_UNSPEC: ::c_int = 0;\n+pub const CTL_KERN: ::c_int = 1;\n+pub const CTL_VM: ::c_int = 2;\n+pub const CTL_FS: ::c_int = 3;\n+pub const CTL_NET: ::c_int = 4;\n+pub const CTL_DEBUG: ::c_int = 5;\n+pub const CTL_HW: ::c_int = 6;\n+pub const CTL_MACHDEP: ::c_int = 7;\n+pub const CTL_DDB: ::c_int = 9;\n+pub const CTL_VFS: ::c_int = 10;\n+pub const CTL_MAXID: ::c_int = 11;\n+\n+pub const HW_NCPUONLINE: ::c_int = 25;\n+\n+pub const KERN_OSTYPE: ::c_int = 1;\n+pub const KERN_OSRELEASE: ::c_int = 2;\n+pub const KERN_OSREV: ::c_int = 3;\n+pub const KERN_VERSION: ::c_int = 4;\n+pub const KERN_MAXVNODES: ::c_int = 5;\n+pub const KERN_MAXPROC: ::c_int = 6;\n+pub const KERN_MAXFILES: ::c_int = 7;\n+pub const KERN_ARGMAX: ::c_int = 8;\n+pub const KERN_SECURELVL: ::c_int = 9;\n+pub const KERN_HOSTNAME: ::c_int = 10;\n+pub const KERN_HOSTID: ::c_int = 11;\n+pub const KERN_CLOCKRATE: ::c_int = 12;\n+pub const KERN_PROF: ::c_int = 16;\n+pub const KERN_POSIX1: ::c_int = 17;\n+pub const KERN_NGROUPS: ::c_int = 18;\n+pub const KERN_JOB_CONTROL: ::c_int = 19;\n+pub const KERN_SAVED_IDS: ::c_int = 20;\n+pub const KERN_BOOTTIME: ::c_int = 21;\n+pub const KERN_DOMAINNAME: ::c_int = 22;\n+pub const KERN_MAXPARTITIONS: ::c_int = 23;\n+pub const KERN_RAWPARTITION: ::c_int = 24;\n+pub const KERN_MAXTHREAD: ::c_int = 25;\n+pub const KERN_NTHREADS: ::c_int = 26;\n+pub const KERN_OSVERSION: ::c_int = 27;\n+pub const KERN_SOMAXCONN: ::c_int = 28;\n+pub const KERN_SOMINCONN: ::c_int = 29;\n+pub const KERN_USERMOUNT: ::c_int = 30;\n+pub const KERN_NOSUIDCOREDUMP: ::c_int = 32;\n+pub const KERN_FSYNC: ::c_int = 33;\n+pub const KERN_SYSVMSG: ::c_int = 34;\n+pub const KERN_SYSVSEM: ::c_int = 35;\n+pub const KERN_SYSVSHM: ::c_int = 36;\n+pub const KERN_ARND: ::c_int = 37;\n+pub const KERN_MSGBUFSIZE: ::c_int = 38;\n+pub const KERN_MALLOCSTATS: ::c_int = 39;\n+pub const KERN_CPTIME: ::c_int = 40;\n+pub const KERN_NCHSTATS: ::c_int = 41;\n+pub const KERN_FORKSTAT: ::c_int = 42;\n+pub const KERN_NSELCOLL: ::c_int = 43;\n+pub const KERN_TTY: ::c_int = 44;\n+pub const KERN_CCPU: ::c_int = 45;\n+pub const KERN_FSCALE: ::c_int = 46;\n+pub const KERN_NPROCS: ::c_int = 47;\n+pub const KERN_MSGBUF: ::c_int = 48;\n+pub const KERN_POOL: ::c_int = 49;\n+pub const KERN_STACKGAPRANDOM: ::c_int = 50;\n+pub const KERN_SYSVIPC_INFO: ::c_int = 51;\n+pub const KERN_SPLASSERT: ::c_int = 54;\n+pub const KERN_PROC_ARGS: ::c_int = 55;\n+pub const KERN_NFILES: ::c_int = 56;\n+pub const KERN_TTYCOUNT: ::c_int = 57;\n+pub const KERN_NUMVNODES: ::c_int = 58;\n+pub const KERN_MBSTAT: ::c_int = 59;\n+pub const KERN_SEMINFO: ::c_int = 61;\n+pub const KERN_SHMINFO: ::c_int = 62;\n+pub const KERN_INTRCNT: ::c_int = 63;\n+pub const KERN_WATCHDOG: ::c_int = 64;\n+pub const KERN_PROC: ::c_int = 66;\n+pub const KERN_MAXCLUSTERS: ::c_int = 67;\n+pub const KERN_EVCOUNT: ::c_int = 68;\n+pub const KERN_TIMECOUNTER: ::c_int = 69;\n+pub const KERN_MAXLOCKSPERUID: ::c_int = 70;\n+pub const KERN_CPTIME2: ::c_int = 71;\n+pub const KERN_CACHEPCT: ::c_int = 72;\n+pub const KERN_FILE: ::c_int = 73;\n+pub const KERN_CONSDEV: ::c_int = 75;\n+pub const KERN_NETLIVELOCKS: ::c_int = 76;\n+pub const KERN_POOL_DEBUG: ::c_int = 77;\n+pub const KERN_PROC_CWD: ::c_int = 78;\n+pub const KERN_PROC_NOBROADCASTKILL: ::c_int = 79;\n+pub const KERN_PROC_VMMAP: ::c_int = 80;\n+pub const KERN_GLOBAL_PTRACE: ::c_int = 81;\n+pub const KERN_CONSBUFSIZE: ::c_int = 82;\n+pub const KERN_CONSBUF: ::c_int = 83;\n+pub const KERN_AUDIO: ::c_int = 84;\n+pub const KERN_CPUSTATS: ::c_int = 85;\n+pub const KERN_PFSTATUS: ::c_int = 86;\n+pub const KERN_TIMEOUT_STATS: ::c_int = 87;\n+pub const KERN_MAXID: ::c_int = 88;\n+\n+pub const KERN_PROC_ALL: ::c_int = 0;\n+pub const KERN_PROC_PID: ::c_int = 1;\n+pub const KERN_PROC_PGRP: ::c_int = 2;\n+pub const KERN_PROC_SESSION: ::c_int = 3;\n+pub const KERN_PROC_TTY: ::c_int = 4;\n+pub const KERN_PROC_UID: ::c_int = 5;\n+pub const KERN_PROC_RUID: ::c_int = 6;\n+pub const KERN_PROC_KTHREAD: ::c_int = 7;\n+pub const KERN_PROC_SHOW_THREADS: ::c_int = 0x40000000;\n+\n+pub const KERN_SYSVIPC_MSG_INFO: ::c_int = 1;\n+pub const KERN_SYSVIPC_SEM_INFO: ::c_int = 2;\n+pub const KERN_SYSVIPC_SHM_INFO: ::c_int = 3;\n+\n+pub const KERN_PROC_ARGV: ::c_int = 1;\n+pub const KERN_PROC_NARGV: ::c_int = 2;\n+pub const KERN_PROC_ENV: ::c_int = 3;\n+pub const KERN_PROC_NENV: ::c_int = 4;\n+\n+pub const KI_NGROUPS: ::c_int = 16;\n+pub const KI_MAXCOMLEN: ::c_int = 24;\n+pub const KI_WMESGLEN: ::c_int = 8;\n+pub const KI_MAXLOGNAME: ::c_int = 32;\n+pub const KI_EMULNAMELEN: ::c_int = 8;\n+\n+pub const CHWFLOW: ::tcflag_t = ::MDMBUF | ::CRTSCTS;\n+pub const OLCUC: ::tcflag_t = 0x20;\n+pub const ONOCR: ::tcflag_t = 0x40;\n+pub const ONLRET: ::tcflag_t = 0x80;\n+\n+//https://github.com/openbsd/src/blob/master/sys/sys/mount.h\n+pub const ISOFSMNT_NORRIP: ::c_int = 0x1; // disable Rock Ridge Ext\n+pub const ISOFSMNT_GENS: ::c_int = 0x2; // enable generation numbers\n+pub const ISOFSMNT_EXTATT: ::c_int = 0x4; // enable extended attr\n+pub const ISOFSMNT_NOJOLIET: ::c_int = 0x8; // disable Joliet Ext\n+pub const ISOFSMNT_SESS: ::c_int = 0x10; // use iso_args.sess\n+\n+pub const NFS_ARGSVERSION: ::c_int = 4; // change when nfs_args changes\n+\n+pub const NFSMNT_RESVPORT: ::c_int = 0; // always use reserved ports\n+pub const NFSMNT_SOFT: ::c_int = 0x1; // soft mount (hard is default)\n+pub const NFSMNT_WSIZE: ::c_int = 0x2; // set write size\n+pub const NFSMNT_RSIZE: ::c_int = 0x4; // set read size\n+pub const NFSMNT_TIMEO: ::c_int = 0x8; // set initial timeout\n+pub const NFSMNT_RETRANS: ::c_int = 0x10; // set number of request retries\n+pub const NFSMNT_MAXGRPS: ::c_int = 0x20; // set maximum grouplist size\n+pub const NFSMNT_INT: ::c_int = 0x40; // allow interrupts on hard mount\n+pub const NFSMNT_NOCONN: ::c_int = 0x80; // Don't Connect the socket\n+pub const NFSMNT_NQNFS: ::c_int = 0x100; // Use Nqnfs protocol\n+pub const NFSMNT_NFSV3: ::c_int = 0x200; // Use NFS Version 3 protocol\n+pub const NFSMNT_KERB: ::c_int = 0x400; // Use Kerberos authentication\n+pub const NFSMNT_DUMBTIMR: ::c_int = 0x800; // Don't estimate rtt dynamically\n+pub const NFSMNT_LEASETERM: ::c_int = 0x1000; // set lease term (nqnfs)\n+pub const NFSMNT_READAHEAD: ::c_int = 0x2000; // set read ahead\n+pub const NFSMNT_DEADTHRESH: ::c_int = 0x4000; // set dead server retry thresh\n+pub const NFSMNT_NOAC: ::c_int = 0x8000; // disable attribute cache\n+pub const NFSMNT_RDIRPLUS: ::c_int = 0x10000; // Use Readdirplus for V3\n+pub const NFSMNT_READDIRSIZE: ::c_int = 0x20000; // Set readdir size\n+\n+/* Flags valid only in mount syscall arguments */\n+pub const NFSMNT_ACREGMIN: ::c_int = 0x40000; // acregmin field valid\n+pub const NFSMNT_ACREGMAX: ::c_int = 0x80000; // acregmax field valid\n+pub const NFSMNT_ACDIRMIN: ::c_int = 0x100000; // acdirmin field valid\n+pub const NFSMNT_ACDIRMAX: ::c_int = 0x200000; // acdirmax field valid\n+\n+/* Flags valid only in kernel */\n+pub const NFSMNT_INTERNAL: ::c_int = 0xfffc0000; // Bits set internally\n+pub const NFSMNT_HASWRITEVERF: ::c_int = 0x40000; // Has write verifier for V3\n+pub const NFSMNT_GOTPATHCONF: ::c_int = 0x80000; // Got the V3 pathconf info\n+pub const NFSMNT_GOTFSINFO: ::c_int = 0x100000; // Got the V3 fsinfo\n+pub const NFSMNT_MNTD: ::c_int = 0x200000; // Mnt server for mnt point\n+pub const NFSMNT_DISMINPROG: ::c_int = 0x400000; // Dismount in progress\n+pub const NFSMNT_DISMNT: ::c_int = 0x800000; // Dismounted\n+pub const NFSMNT_SNDLOCK: ::c_int = 0x1000000; // Send socket lock\n+pub const NFSMNT_WANTSND: ::c_int = 0x2000000; // Want above\n+pub const NFSMNT_RCVLOCK: ::c_int = 0x4000000; // Rcv socket lock\n+pub const NFSMNT_WANTRCV: ::c_int = 0x8000000; // Want above\n+pub const NFSMNT_WAITAUTH: ::c_int = 0x10000000; // Wait for authentication\n+pub const NFSMNT_HASAUTH: ::c_int = 0x20000000; // Has authenticator\n+pub const NFSMNT_WANTAUTH: ::c_int = 0x40000000; // Wants an authenticator\n+pub const NFSMNT_AUTHERR: ::c_int = 0x80000000; // Authentication error\n+\n+pub const MSDOSFSMNT_SHORTNAME: ::c_int = 0x1; // Force old DOS short names only\n+pub const MSDOSFSMNT_LONGNAME: ::c_int = 0x2; // Force Win'95 long names\n+pub const MSDOSFSMNT_NOWIN95: ::c_int = 0x4; // Completely ignore Win95 entries\n+\n+pub const NTFS_MFLAG_CASEINS: ::c_int = 0x1;\n+pub const NTFS_MFLAG_ALLNAMES: ::c_int = 0x2;\n+\n+pub const TMPFS_ARGS_VERSION: ::c_int = 1;\n+\n+pub const MAP_STACK: ::c_int = 0x4000;\n+\n+// https://github.com/openbsd/src/blob/master/sys/net/if.h#L187\n+pub const IFF_UP: ::c_int = 0x1; // interface is up\n+pub const IFF_BROADCAST: ::c_int = 0x2; // broadcast address valid\n+pub const IFF_DEBUG: ::c_int = 0x4; // turn on debugging\n+pub const IFF_LOOPBACK: ::c_int = 0x8; // is a loopback net\n+pub const IFF_POINTOPOINT: ::c_int = 0x10; // interface is point-to-point link\n+pub const IFF_STATICARP: ::c_int = 0x20; // only static ARP\n+pub const IFF_RUNNING: ::c_int = 0x40; // resources allocated\n+pub const IFF_NOARP: ::c_int = 0x80; // no address resolution protocol\n+pub const IFF_PROMISC: ::c_int = 0x100; // receive all packets\n+pub const IFF_ALLMULTI: ::c_int = 0x200; // receive all multicast packets\n+pub const IFF_OACTIVE: ::c_int = 0x400; // transmission in progress\n+pub const IFF_SIMPLEX: ::c_int = 0x800; // can't hear own transmissions\n+pub const IFF_LINK0: ::c_int = 0x1000; // per link layer defined bit\n+pub const IFF_LINK1: ::c_int = 0x2000; // per link layer defined bit\n+pub const IFF_LINK2: ::c_int = 0x4000; // per link layer defined bit\n+pub const IFF_MULTICAST: ::c_int = 0x8000; // supports multicast\n+\n+pub const PTHREAD_STACK_MIN: ::size_t = (1_usize << _MAX_PAGE_SHIFT);\n+pub const MINSIGSTKSZ: ::size_t = (3_usize << _MAX_PAGE_SHIFT);\n+pub const SIGSTKSZ: ::size_t = MINSIGSTKSZ + (1_usize << _MAX_PAGE_SHIFT) * 4;\n+\n+pub const PT_FIRSTMACH: ::c_int = 32;\n+\n+pub const SOCK_CLOEXEC: ::c_int = 0x8000;\n+pub const SOCK_NONBLOCK: ::c_int = 0x4000;\n+pub const SOCK_DNS: ::c_int = 0x1000;\n+\n+pub const BIOCGRSIG: ::c_ulong = 0x40044273;\n+pub const BIOCSRSIG: ::c_ulong = 0x80044272;\n+pub const BIOCSDLT: ::c_ulong = 0x8004427a;\n+\n+pub const PTRACE_FORK: ::c_int = 0x0002;\n+\n+pub const WCONTINUED: ::c_int = 8;\n+\n+fn _ALIGN(p: usize) -> usize {\n+    (p + _ALIGNBYTES) & !_ALIGNBYTES\n+}\n+\n+f! {\n+    pub fn WIFCONTINUED(status: ::c_int) -> bool {\n+        status & 0o177777 == 0o177777\n+    }\n+\n+        pub fn CMSG_DATA(cmsg: *const ::cmsghdr) -> *mut ::c_uchar {\n+        (cmsg as *mut ::c_uchar)\n+            .offset(_ALIGN(::mem::size_of::<::cmsghdr>()) as isize)\n+    }\n+\n+    pub fn CMSG_LEN(length: ::c_uint) -> ::c_uint {\n+        _ALIGN(::mem::size_of::<::cmsghdr>()) as ::c_uint + length\n+    }\n+\n+    pub fn CMSG_NXTHDR(mhdr: *const ::msghdr, cmsg: *const ::cmsghdr)\n+        -> *mut ::cmsghdr\n+    {\n+        if cmsg.is_null() {\n+            return ::CMSG_FIRSTHDR(mhdr);\n+        };\n+        let next = cmsg as usize + _ALIGN((*cmsg).cmsg_len as usize)\n+            + _ALIGN(::mem::size_of::<::cmsghdr>());\n+        let max = (*mhdr).msg_control as usize\n+            + (*mhdr).msg_controllen as usize;\n+        if next > max {\n+            0 as *mut ::cmsghdr\n+        } else {\n+            (cmsg as usize + _ALIGN((*cmsg).cmsg_len as usize))\n+                as *mut ::cmsghdr\n+        }\n+    }\n+\n+    pub fn CMSG_SPACE(length: ::c_uint) -> ::c_uint {\n+        (_ALIGN(::mem::size_of::<::cmsghdr>()) + _ALIGN(length as usize))\n+            as ::c_uint\n+    }\n+\n+    pub fn WSTOPSIG(status: ::c_int) -> ::c_int {\n+        status >> 8\n+    }\n+\n+    pub fn WIFSIGNALED(status: ::c_int) -> bool {\n+        (status & 0o177) != 0o177 && (status & 0o177) != 0\n+    }\n+\n+    pub fn WIFSTOPPED(status: ::c_int) -> bool {\n+        (status & 0o177) == 0o177\n+    }\n+}\n+\n+extern \"C\" {\n+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::timezone) -> ::c_int;\n+    pub fn accept4(\n+        s: ::c_int,\n+        addr: *mut ::sockaddr,\n+        addrlen: *mut ::socklen_t,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+    pub fn execvpe(\n+        file: *const ::c_char,\n+        argv: *const *const ::c_char,\n+        envp: *const *const ::c_char,\n+    ) -> ::c_int;\n+    pub fn pledge(\n+        promises: *const ::c_char,\n+        execpromises: *const ::c_char,\n+    ) -> ::c_int;\n+    pub fn strtonum(\n+        nptr: *const ::c_char,\n+        minval: ::c_longlong,\n+        maxval: ::c_longlong,\n+        errstr: *mut *const ::c_char,\n+    ) -> ::c_longlong;\n+    pub fn dup3(src: ::c_int, dst: ::c_int, flags: ::c_int) -> ::c_int;\n+    pub fn chflags(path: *const ::c_char, flags: ::c_uint) -> ::c_int;\n+    pub fn fchflags(fd: ::c_int, flags: ::c_uint) -> ::c_int;\n+    pub fn chflagsat(\n+        fd: ::c_int,\n+        path: *const ::c_char,\n+        flags: ::c_uint,\n+        atflag: ::c_int,\n+    ) -> ::c_int;\n+    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;\n+    pub fn getnameinfo(\n+        sa: *const ::sockaddr,\n+        salen: ::socklen_t,\n+        host: *mut ::c_char,\n+        hostlen: ::size_t,\n+        serv: *mut ::c_char,\n+        servlen: ::size_t,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+    pub fn kevent(\n+        kq: ::c_int,\n+        changelist: *const ::kevent,\n+        nchanges: ::c_int,\n+        eventlist: *mut ::kevent,\n+        nevents: ::c_int,\n+        timeout: *const ::timespec,\n+    ) -> ::c_int;\n+    pub fn mprotect(\n+        addr: *mut ::c_void,\n+        len: ::size_t,\n+        prot: ::c_int,\n+    ) -> ::c_int;\n+    pub fn pthread_main_np() -> ::c_int;\n+    pub fn pthread_set_name_np(tid: ::pthread_t, name: *const ::c_char);\n+    pub fn pthread_stackseg_np(\n+        thread: ::pthread_t,\n+        sinfo: *mut ::stack_t,\n+    ) -> ::c_int;\n+    pub fn sysctl(\n+        name: *const ::c_int,\n+        namelen: ::c_uint,\n+        oldp: *mut ::c_void,\n+        oldlenp: *mut ::size_t,\n+        newp: *mut ::c_void,\n+        newlen: ::size_t,\n+    ) -> ::c_int;\n+    pub fn getentropy(buf: *mut ::c_void, buflen: ::size_t) -> ::c_int;\n+    pub fn setresgid(rgid: ::gid_t, egid: ::gid_t, sgid: ::gid_t) -> ::c_int;\n+    pub fn setresuid(ruid: ::uid_t, euid: ::uid_t, suid: ::uid_t) -> ::c_int;\n+    pub fn ptrace(\n+        request: ::c_int,\n+        pid: ::pid_t,\n+        addr: caddr_t,\n+        data: ::c_int,\n+    ) -> ::c_int;\n+}\n+\n+cfg_if! {\n+    if #[cfg(libc_union)] {\n+        extern {\n+            // these functions use statfs which uses the union mount_info:\n+            pub fn statfs(path: *const ::c_char, buf: *mut statfs) -> ::c_int;\n+            pub fn fstatfs(fd: ::c_int, buf: *mut statfs) -> ::c_int;\n+        }\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(target_arch = \"x86\")] {\n+        mod x86;\n+        pub use self::x86::*;\n+    } else if #[cfg(target_arch = \"x86_64\")] {\n+        mod x86_64;\n+        pub use self::x86_64::*;\n+    } else if #[cfg(target_arch = \"aarch64\")] {\n+        mod aarch64;\n+        pub use self::aarch64::*;\n+    } else if #[cfg(target_arch = \"sparc64\")] {\n+        mod sparc64;\n+        pub use self::sparc64::*;\n+    } else {\n+        // Unknown target_arch\n+    }\n+}"
      },
      {
        "sha": "070fc9385f6c9fb046b4ca60102303acb3fb2153",
        "filename": "src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/sparc64.rs",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/sparc64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/sparc64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/sparc64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,8 @@\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type c_char = i8;\n+\n+#[doc(hidden)]\n+pub const _ALIGNBYTES: usize = 0xf;\n+\n+pub const _MAX_PAGE_SHIFT: u32 = 13;"
      },
      {
        "sha": "e87d0ff1e7d5d20bf8fe916ed95b68ecc221cb7d",
        "filename": "src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/x86.rs",
        "status": "added",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/x86.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/x86.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/x86.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,16 @@\n+pub type c_long = i32;\n+pub type c_ulong = u32;\n+pub type c_char = i8;\n+\n+// should be pub(crate), but that requires Rust 1.18.0\n+cfg_if! {\n+    if #[cfg(libc_const_size_of)] {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_int>() - 1;\n+    } else {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = 4 - 1;\n+    }\n+}\n+\n+pub const _MAX_PAGE_SHIFT: u32 = 12;"
      },
      {
        "sha": "263b6e13a2d724866b802192e4f060184ee8ec6e",
        "filename": "src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/x86_64.rs",
        "status": "added",
        "additions": 24,
        "deletions": 0,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/x86_64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/x86_64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/bsd/netbsdlike/openbsd/x86_64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,24 @@\n+use PT_FIRSTMACH;\n+\n+pub type c_long = i64;\n+pub type c_ulong = u64;\n+pub type c_char = i8;\n+\n+// should be pub(crate), but that requires Rust 1.18.0\n+cfg_if! {\n+    if #[cfg(libc_const_size_of)] {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = ::mem::size_of::<::c_long>() - 1;\n+    } else {\n+        #[doc(hidden)]\n+        pub const _ALIGNBYTES: usize = 8 - 1;\n+    }\n+}\n+\n+pub const _MAX_PAGE_SHIFT: u32 = 12;\n+\n+pub const PT_STEP: ::c_int = PT_FIRSTMACH + 0;\n+pub const PT_GETREGS: ::c_int = PT_FIRSTMACH + 1;\n+pub const PT_SETREGS: ::c_int = PT_FIRSTMACH + 2;\n+pub const PT_GETFPREGS: ::c_int = PT_FIRSTMACH + 3;\n+pub const PT_SETFPREGS: ::c_int = PT_FIRSTMACH + 4;"
      },
      {
        "sha": "cce8864883a1a2cffa1549d35178e8595f068d11",
        "filename": "src/rusty/libc/src/unix/haiku/b32.rs",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/haiku/b32.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/haiku/b32.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/haiku/b32.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,3 @@\n+pub type c_long = i32;\n+pub type c_ulong = u32;\n+pub type time_t = i32;"
      },
      {
        "sha": "3e66f14c92a6f372bfaaba8bc9c931bb5f248a69",
        "filename": "src/rusty/libc/src/unix/haiku/b64.rs",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/haiku/b64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/haiku/b64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/haiku/b64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,3 @@\n+pub type c_ulong = u64;\n+pub type c_long = i64;\n+pub type time_t = i64;"
      },
      {
        "sha": "fb206c9a9ea08f36959efe45bdd2741826f6ba50",
        "filename": "src/rusty/libc/src/unix/haiku/mod.rs",
        "status": "added",
        "additions": 1531,
        "deletions": 0,
        "changes": 1531,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/haiku/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/haiku/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/haiku/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,1531 @@\n+pub type rlim_t = ::uintptr_t;\n+pub type sa_family_t = u8;\n+pub type pthread_key_t = ::c_int;\n+pub type nfds_t = ::c_long;\n+pub type tcflag_t = ::c_uint;\n+pub type speed_t = ::c_uint;\n+pub type c_char = i8;\n+pub type clock_t = i32;\n+pub type clockid_t = i32;\n+pub type suseconds_t = i32;\n+pub type wchar_t = i32;\n+pub type off_t = i64;\n+pub type ino_t = i64;\n+pub type blkcnt_t = i64;\n+pub type blksize_t = i32;\n+pub type dev_t = i32;\n+pub type mode_t = u32;\n+pub type nlink_t = i32;\n+pub type useconds_t = u32;\n+pub type socklen_t = u32;\n+pub type pthread_t = ::uintptr_t;\n+pub type pthread_mutexattr_t = ::uintptr_t;\n+pub type pthread_rwlockattr_t = ::uintptr_t;\n+pub type sigset_t = u64;\n+pub type fsblkcnt_t = i64;\n+pub type fsfilcnt_t = i64;\n+pub type pthread_attr_t = *mut ::c_void;\n+pub type nl_item = ::c_int;\n+pub type id_t = i32;\n+pub type idtype_t = ::c_uint;\n+\n+#[cfg_attr(feature = \"extra_traits\", derive(Debug))]\n+pub enum timezone {}\n+impl ::Copy for timezone {}\n+impl ::Clone for timezone {\n+    fn clone(&self) -> timezone {\n+        *self\n+    }\n+}\n+\n+s! {\n+    pub struct in_addr {\n+        pub s_addr: ::in_addr_t,\n+    }\n+\n+    pub struct ip_mreq {\n+        pub imr_multiaddr: in_addr,\n+        pub imr_interface: in_addr,\n+    }\n+\n+    pub struct sockaddr {\n+        pub sa_len: u8,\n+        pub sa_family: sa_family_t,\n+        pub sa_data: [::c_char; 30],\n+    }\n+\n+    pub struct sockaddr_in {\n+        pub sin_len: u8,\n+        pub sin_family: sa_family_t,\n+        pub sin_port: ::in_port_t,\n+        pub sin_addr: ::in_addr,\n+        pub sin_zero: [u8; 24],\n+    }\n+\n+    pub struct sockaddr_in6 {\n+        pub sin6_len: u8,\n+        pub sin6_family: sa_family_t,\n+        pub sin6_port: ::in_port_t,\n+        pub sin6_flowinfo: u32,\n+        pub sin6_addr: ::in6_addr,\n+        pub sin6_scope_id: u32,\n+    }\n+\n+    pub struct addrinfo {\n+        pub ai_flags: ::c_int,\n+        pub ai_family: ::c_int,\n+        pub ai_socktype: ::c_int,\n+        pub ai_protocol: ::c_int,\n+        pub ai_addrlen: socklen_t,\n+        pub ai_canonname: *mut c_char,\n+        pub ai_addr: *mut ::sockaddr,\n+        pub ai_next: *mut addrinfo,\n+    }\n+\n+    pub struct fd_set {\n+        fds_bits: [c_ulong; FD_SETSIZE / ULONG_SIZE],\n+    }\n+\n+    pub struct tm {\n+        pub tm_sec: ::c_int,\n+        pub tm_min: ::c_int,\n+        pub tm_hour: ::c_int,\n+        pub tm_mday: ::c_int,\n+        pub tm_mon: ::c_int,\n+        pub tm_year: ::c_int,\n+        pub tm_wday: ::c_int,\n+        pub tm_yday: ::c_int,\n+        pub tm_isdst: ::c_int,\n+        pub tm_gmtoff: ::c_long,\n+        pub tm_zone: *const ::c_char,\n+    }\n+\n+    pub struct utsname {\n+        pub sysname: [::c_char; 32],\n+        pub nodename: [::c_char; 32],\n+        pub release: [::c_char; 32],\n+        pub version: [::c_char; 32],\n+        pub machine: [::c_char; 32],\n+    }\n+\n+    pub struct lconv {\n+        pub decimal_point: *mut ::c_char,\n+        pub thousands_sep: *mut ::c_char,\n+        pub grouping: *mut ::c_char,\n+        pub int_curr_symbol: *mut ::c_char,\n+        pub currency_symbol: *mut ::c_char,\n+        pub mon_decimal_point: *mut ::c_char,\n+        pub mon_thousands_sep: *mut ::c_char,\n+        pub mon_grouping: *mut ::c_char,\n+        pub positive_sign: *mut ::c_char,\n+        pub negative_sign: *mut ::c_char,\n+        pub int_frac_digits: ::c_char,\n+        pub frac_digits: ::c_char,\n+        pub p_cs_precedes: ::c_char,\n+        pub p_sep_by_space: ::c_char,\n+        pub n_cs_precedes: ::c_char,\n+        pub n_sep_by_space: ::c_char,\n+        pub p_sign_posn: ::c_char,\n+        pub n_sign_posn: ::c_char,\n+        pub int_p_cs_precedes: ::c_char,\n+        pub int_p_sep_by_space: ::c_char,\n+        pub int_n_cs_precedes: ::c_char,\n+        pub int_n_sep_by_space: ::c_char,\n+        pub int_p_sign_posn: ::c_char,\n+        pub int_n_sign_posn: ::c_char,\n+    }\n+\n+    pub struct msghdr {\n+        pub msg_name: *mut ::c_void,\n+        pub msg_namelen: ::socklen_t,\n+        pub msg_iov: *mut ::iovec,\n+        pub msg_iovlen: ::c_int,\n+        pub msg_control: *mut ::c_void,\n+        pub msg_controllen: ::socklen_t,\n+        pub msg_flags: ::c_int,\n+    }\n+\n+    pub struct cmsghdr {\n+        pub cmsg_len: ::size_t,\n+        pub cmsg_level: ::c_int,\n+        pub cmsg_type: ::c_int,\n+    }\n+\n+    pub struct Dl_info {\n+        pub dli_fname: *const ::c_char,\n+        pub dli_fbase: *mut ::c_void,\n+        pub dli_sname: *const ::c_char,\n+        pub dli_saddr: *mut ::c_void,\n+    }\n+\n+    pub struct termios {\n+        pub c_iflag: ::tcflag_t,\n+        pub c_oflag: ::tcflag_t,\n+        pub c_cflag: ::tcflag_t,\n+        pub c_lflag: ::tcflag_t,\n+        pub c_line:  ::c_char,\n+        pub c_ispeed: ::speed_t,\n+        pub c_ospeed: ::speed_t,\n+        pub c_cc: [::cc_t; ::NCCS],\n+    }\n+\n+    pub struct flock {\n+        pub l_type: ::c_short,\n+        pub l_whence: ::c_short,\n+        pub l_start: ::off_t,\n+        pub l_len: ::off_t,\n+        pub l_pid: ::pid_t,\n+    }\n+\n+    pub struct stat {\n+        pub st_dev: dev_t,\n+        pub st_ino: ino_t,\n+        pub st_mode: mode_t,\n+        pub st_nlink: nlink_t,\n+        pub st_uid: ::uid_t,\n+        pub st_gid: ::gid_t,\n+        pub st_size: off_t,\n+        pub st_rdev: dev_t,\n+        pub st_blksize: blksize_t,\n+        pub st_atime: time_t,\n+        pub st_atime_nsec: c_long,\n+        pub st_mtime: time_t,\n+        pub st_mtime_nsec: c_long,\n+        pub st_ctime: time_t,\n+        pub st_ctime_nsec: c_long,\n+        pub st_crtime: time_t,\n+        pub st_crtime_nsec: c_long,\n+        pub st_type: u32,\n+        pub st_blocks: blkcnt_t,\n+    }\n+\n+    pub struct glob_t {\n+        pub gl_pathc: ::size_t,\n+        __unused1: ::size_t,\n+        pub gl_offs: ::size_t,\n+        __unused2: ::size_t,\n+        pub gl_pathv: *mut *mut c_char,\n+\n+        __unused3: *mut ::c_void,\n+        __unused4: *mut ::c_void,\n+        __unused5: *mut ::c_void,\n+        __unused6: *mut ::c_void,\n+        __unused7: *mut ::c_void,\n+        __unused8: *mut ::c_void,\n+    }\n+\n+    pub struct pthread_mutex_t {\n+        flags: u32,\n+        lock: i32,\n+        unused: i32,\n+        owner: i32,\n+        owner_count: i32,\n+    }\n+\n+    pub struct pthread_cond_t {\n+        flags: u32,\n+        unused: i32,\n+        mutex: *mut ::c_void,\n+        waiter_count: i32,\n+        lock: i32,\n+    }\n+\n+    pub struct pthread_rwlock_t {\n+        flags: u32,\n+        owner: i32,\n+        lock_sem: i32,      // this is actually a union\n+        lock_count: i32,\n+        reader_count: i32,\n+        writer_count: i32,\n+        waiters: [*mut ::c_void; 2],\n+    }\n+\n+    pub struct passwd {\n+        pub pw_name: *mut ::c_char,\n+        pub pw_passwd: *mut ::c_char,\n+        pub pw_uid: ::uid_t,\n+        pub pw_gid: ::gid_t,\n+        pub pw_dir: *mut ::c_char,\n+        pub pw_shell: *mut ::c_char,\n+        pub pw_gecos: *mut ::c_char,\n+    }\n+\n+    pub struct statvfs {\n+        pub f_bsize: ::c_ulong,\n+        pub f_frsize: ::c_ulong,\n+        pub f_blocks: ::fsblkcnt_t,\n+        pub f_bfree: ::fsblkcnt_t,\n+        pub f_bavail: ::fsblkcnt_t,\n+        pub f_files: ::fsfilcnt_t,\n+        pub f_ffree: ::fsfilcnt_t,\n+        pub f_favail: ::fsfilcnt_t,\n+        pub f_fsid: ::c_ulong,\n+        pub f_flag: ::c_ulong,\n+        pub f_namemax: ::c_ulong,\n+    }\n+\n+    pub struct stack_t {\n+        pub ss_sp: *mut ::c_void,\n+        pub ss_size: ::size_t,\n+        pub ss_flags: ::c_int,\n+    }\n+\n+    pub struct siginfo_t {\n+        pub si_signo: ::c_int,\n+        pub si_code: ::c_int,\n+        pub si_errno: ::c_int,\n+        pub si_pid: ::pid_t,\n+        pub si_uid: ::uid_t,\n+        pub si_addr: *mut ::c_void,\n+        pub si_status: ::c_int,\n+        pub si_band: c_long,\n+        pub sigval: *mut ::c_void,\n+    }\n+\n+    pub struct sigaction {\n+        pub sa_sigaction: ::sighandler_t,\n+        pub sa_mask: ::sigset_t,\n+        pub sa_flags: ::c_int,\n+        sa_userdata: *mut ::c_void,\n+    }\n+\n+    pub struct sem_t {\n+        pub se_type: i32,\n+        pub se_named_id: i32, // this is actually a union\n+        pub se_unnamed: i32,\n+        pub se_padding: [i32; 4],\n+    }\n+\n+    pub struct pthread_condattr_t {\n+        pub process_shared: bool,\n+        pub clock_id: i32,\n+    }\n+}\n+\n+s_no_extra_traits! {\n+    pub struct sockaddr_un {\n+        pub sun_len: u8,\n+        pub sun_family: sa_family_t,\n+        pub sun_path: [::c_char; 126]\n+    }\n+    pub struct sockaddr_storage {\n+        pub ss_len: u8,\n+        pub ss_family: sa_family_t,\n+        __ss_pad1: [u8; 6],\n+        __ss_pad2: u64,\n+        __ss_pad3: [u8; 112],\n+    }\n+    pub struct dirent {\n+        pub d_dev: dev_t,\n+        pub d_pdev: dev_t,\n+        pub d_ino: ino_t,\n+        pub d_pino: i64,\n+        pub d_reclen: ::c_ushort,\n+        pub d_name: [::c_char; 1024], // Max length is _POSIX_PATH_MAX\n+    }\n+\n+    pub struct sigevent {\n+        pub sigev_notify: ::c_int,\n+        pub sigev_signo: ::c_int,\n+        pub sigev_value: ::sigval,\n+        __unused1: *mut ::c_void, // actually a function pointer\n+        pub sigev_notify_attributes: *mut ::pthread_attr_t,\n+    }\n+}\n+\n+cfg_if! {\n+    if #[cfg(feature = \"extra_traits\")] {\n+        impl PartialEq for sockaddr_un {\n+            fn eq(&self, other: &sockaddr_un) -> bool {\n+                self.sun_len == other.sun_len\n+                    && self.sun_family == other.sun_family\n+                    && self\n+                    .sun_path\n+                    .iter()\n+                    .zip(other.sun_path.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for sockaddr_un {}\n+        impl ::fmt::Debug for sockaddr_un {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"sockaddr_un\")\n+                    .field(\"sun_len\", &self.sun_len)\n+                    .field(\"sun_family\", &self.sun_family)\n+                    // FIXME: .field(\"sun_path\", &self.sun_path)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for sockaddr_un {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.sun_len.hash(state);\n+                self.sun_family.hash(state);\n+                self.sun_path.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for sockaddr_storage {\n+            fn eq(&self, other: &sockaddr_storage) -> bool {\n+                self.ss_len == other.ss_len\n+                    && self.ss_family == other.ss_family\n+                    && self\n+                    .__ss_pad1\n+                    .iter()\n+                    .zip(other.__ss_pad1.iter())\n+                    .all(|(a, b)| a == b)\n+                    && self.__ss_pad2 == other.__ss_pad2\n+                    && self\n+                    .__ss_pad3\n+                    .iter()\n+                    .zip(other.__ss_pad3.iter())\n+                    .all(|(a, b)| a == b)\n+            }\n+        }\n+        impl Eq for sockaddr_storage {}\n+        impl ::fmt::Debug for sockaddr_storage {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"sockaddr_storage\")\n+                    .field(\"ss_len\", &self.ss_len)\n+                    .field(\"ss_family\", &self.ss_family)\n+                    .field(\"__ss_pad1\", &self.__ss_pad1)\n+                    .field(\"__ss_pad2\", &self.__ss_pad2)\n+                    // FIXME: .field(\"__ss_pad3\", &self.__ss_pad3)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for sockaddr_storage {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.ss_len.hash(state);\n+                self.ss_family.hash(state);\n+                self.__ss_pad1.hash(state);\n+                self.__ss_pad2.hash(state);\n+                self.__ss_pad3.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for dirent {\n+            fn eq(&self, other: &dirent) -> bool {\n+                self.d_dev == other.d_dev\n+                    && self.d_pdev == other.d_pdev\n+                    && self.d_ino == other.d_ino\n+                    && self.d_pino == other.d_pino\n+                    && self.d_reclen == other.d_reclen\n+                    && self\n+                    .d_name\n+                    .iter()\n+                    .zip(other.d_name.iter())\n+                    .all(|(a,b)| a == b)\n+            }\n+        }\n+        impl Eq for dirent {}\n+        impl ::fmt::Debug for dirent {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"dirent\")\n+                    .field(\"d_dev\", &self.d_dev)\n+                    .field(\"d_pdev\", &self.d_pdev)\n+                    .field(\"d_ino\", &self.d_ino)\n+                    .field(\"d_pino\", &self.d_pino)\n+                    .field(\"d_reclen\", &self.d_reclen)\n+                    // FIXME: .field(\"d_name\", &self.d_name)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for dirent {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.d_dev.hash(state);\n+                self.d_pdev.hash(state);\n+                self.d_ino.hash(state);\n+                self.d_pino.hash(state);\n+                self.d_reclen.hash(state);\n+                self.d_name.hash(state);\n+            }\n+        }\n+\n+        impl PartialEq for sigevent {\n+            fn eq(&self, other: &sigevent) -> bool {\n+                self.sigev_notify == other.sigev_notify\n+                    && self.sigev_signo == other.sigev_signo\n+                    && self.sigev_value == other.sigev_value\n+                    && self.sigev_notify_attributes\n+                        == other.sigev_notify_attributes\n+            }\n+        }\n+        impl Eq for sigevent {}\n+        impl ::fmt::Debug for sigevent {\n+            fn fmt(&self, f: &mut ::fmt::Formatter) -> ::fmt::Result {\n+                f.debug_struct(\"sigevent\")\n+                    .field(\"sigev_notify\", &self.sigev_notify)\n+                    .field(\"sigev_signo\", &self.sigev_signo)\n+                    .field(\"sigev_value\", &self.sigev_value)\n+                    .field(\"sigev_notify_attributes\",\n+                           &self.sigev_notify_attributes)\n+                    .finish()\n+            }\n+        }\n+        impl ::hash::Hash for sigevent {\n+            fn hash<H: ::hash::Hasher>(&self, state: &mut H) {\n+                self.sigev_notify.hash(state);\n+                self.sigev_signo.hash(state);\n+                self.sigev_value.hash(state);\n+                self.sigev_notify_attributes.hash(state);\n+            }\n+        }\n+    }\n+}\n+\n+// intentionally not public, only used for fd_set\n+cfg_if! {\n+    if #[cfg(target_pointer_width = \"32\")] {\n+        const ULONG_SIZE: usize = 32;\n+    } else if #[cfg(target_pointer_width = \"64\")] {\n+        const ULONG_SIZE: usize = 64;\n+    } else {\n+        // Unknown target_pointer_width\n+    }\n+}\n+\n+pub const EXIT_FAILURE: ::c_int = 1;\n+pub const EXIT_SUCCESS: ::c_int = 0;\n+pub const RAND_MAX: ::c_int = 2147483647;\n+pub const EOF: ::c_int = -1;\n+pub const SEEK_SET: ::c_int = 0;\n+pub const SEEK_CUR: ::c_int = 1;\n+pub const SEEK_END: ::c_int = 2;\n+pub const _IOFBF: ::c_int = 0;\n+pub const _IONBF: ::c_int = 2;\n+pub const _IOLBF: ::c_int = 1;\n+\n+pub const F_DUPFD: ::c_int = 0x0001;\n+pub const F_GETFD: ::c_int = 0x0002;\n+pub const F_SETFD: ::c_int = 0x0004;\n+pub const F_GETFL: ::c_int = 0x0008;\n+pub const F_SETFL: ::c_int = 0x0010;\n+pub const F_GETLK: ::c_int = 0x0020;\n+pub const F_SETLK: ::c_int = 0x0080;\n+pub const F_SETLKW: ::c_int = 0x0100;\n+pub const F_DUPFD_CLOEXEC: ::c_int = 0x0200;\n+\n+pub const F_RDLCK: ::c_int = 0x0040;\n+pub const F_UNLCK: ::c_int = 0x0200;\n+pub const F_WRLCK: ::c_int = 0x0400;\n+\n+pub const AT_FDCWD: ::c_int = -1;\n+pub const AT_SYMLINK_NOFOLLOW: ::c_int = 0x01;\n+pub const AT_SYMLINK_FOLLOW: ::c_int = 0x02;\n+pub const AT_REMOVEDIR: ::c_int = 0x04;\n+pub const AT_EACCESS: ::c_int = 0x08;\n+\n+pub const POLLIN: ::c_short = 0x0001;\n+pub const POLLOUT: ::c_short = 0x0002;\n+pub const POLLRDNORM: ::c_short = POLLIN;\n+pub const POLLWRNORM: ::c_short = POLLOUT;\n+pub const POLLRDBAND: ::c_short = 0x0008;\n+pub const POLLWRBAND: ::c_short = 0x0010;\n+pub const POLLPRI: ::c_short = 0x0020;\n+pub const POLLERR: ::c_short = 0x0004;\n+pub const POLLHUP: ::c_short = 0x0080;\n+pub const POLLNVAL: ::c_short = 0x1000;\n+\n+pub const PTHREAD_CREATE_JOINABLE: ::c_int = 0;\n+pub const PTHREAD_CREATE_DETACHED: ::c_int = 1;\n+\n+pub const CLOCK_REALTIME: ::c_int = -1;\n+pub const CLOCK_MONOTONIC: ::c_int = 0;\n+\n+pub const RLIMIT_CORE: ::c_int = 0;\n+pub const RLIMIT_CPU: ::c_int = 1;\n+pub const RLIMIT_DATA: ::c_int = 2;\n+pub const RLIMIT_FSIZE: ::c_int = 3;\n+pub const RLIMIT_NOFILE: ::c_int = 4;\n+pub const RLIMIT_STACK: ::c_int = 5;\n+pub const RLIMIT_AS: ::c_int = 6;\n+// Haiku specific\n+pub const RLIMIT_NOVMON: ::c_int = 7;\n+pub const RLIMIT_NLIMITS: ::c_int = 8;\n+\n+pub const RUSAGE_SELF: ::c_int = 0;\n+\n+pub const RTLD_LAZY: ::c_int = 0;\n+\n+pub const NCCS: usize = 11;\n+\n+pub const O_RDONLY: ::c_int = 0x0000;\n+pub const O_WRONLY: ::c_int = 0x0001;\n+pub const O_RDWR: ::c_int = 0x0002;\n+pub const O_ACCMODE: ::c_int = 0x0003;\n+\n+pub const O_EXCL: ::c_int = 0x0100;\n+pub const O_CREAT: ::c_int = 0x0200;\n+pub const O_TRUNC: ::c_int = 0x0400;\n+pub const O_NOCTTY: ::c_int = 0x1000;\n+pub const O_NOTRAVERSE: ::c_int = 0x2000;\n+\n+pub const O_CLOEXEC: ::c_int = 0x00000040;\n+pub const O_NONBLOCK: ::c_int = 0x00000080;\n+pub const O_APPEND: ::c_int = 0x00000800;\n+pub const O_SYNC: ::c_int = 0x00010000;\n+pub const O_RSYNC: ::c_int = 0x00020000;\n+pub const O_DSYNC: ::c_int = 0x00040000;\n+pub const O_NOFOLLOW: ::c_int = 0x00080000;\n+pub const O_NOCACHE: ::c_int = 0x00100000;\n+pub const O_DIRECTORY: ::c_int = 0x00200000;\n+\n+pub const S_IFIFO: ::mode_t = 61440;\n+pub const S_IFCHR: ::mode_t = 49152;\n+pub const S_IFBLK: ::mode_t = 24576;\n+pub const S_IFDIR: ::mode_t = 16384;\n+pub const S_IFREG: ::mode_t = 32768;\n+pub const S_IFLNK: ::mode_t = 40960;\n+pub const S_IFSOCK: ::mode_t = 49152;\n+pub const S_IFMT: ::mode_t = 61440;\n+pub const S_IRWXU: ::mode_t = 448;\n+pub const S_IXUSR: ::mode_t = 64;\n+pub const S_IWUSR: ::mode_t = 128;\n+pub const S_IRUSR: ::mode_t = 256;\n+pub const S_IRWXG: ::mode_t = 70;\n+pub const S_IXGRP: ::mode_t = 10;\n+pub const S_IWGRP: ::mode_t = 20;\n+pub const S_IRGRP: ::mode_t = 40;\n+pub const S_IRWXO: ::mode_t = 7;\n+pub const S_IXOTH: ::mode_t = 1;\n+pub const S_IWOTH: ::mode_t = 2;\n+pub const S_IROTH: ::mode_t = 4;\n+pub const F_OK: ::c_int = 0;\n+pub const R_OK: ::c_int = 4;\n+pub const W_OK: ::c_int = 2;\n+pub const X_OK: ::c_int = 1;\n+pub const STDIN_FILENO: ::c_int = 0;\n+pub const STDOUT_FILENO: ::c_int = 1;\n+pub const STDERR_FILENO: ::c_int = 2;\n+\n+pub const SIGHUP: ::c_int = 1;\n+pub const SIGINT: ::c_int = 2;\n+pub const SIGQUIT: ::c_int = 3;\n+pub const SIGILL: ::c_int = 4;\n+pub const SIGCHLD: ::c_int = 5;\n+pub const SIGABRT: ::c_int = 6;\n+pub const SIGPIPE: ::c_int = 7;\n+pub const SIGFPE: ::c_int = 8;\n+pub const SIGKILL: ::c_int = 9;\n+pub const SIGSTOP: ::c_int = 10;\n+pub const SIGSEGV: ::c_int = 11;\n+pub const SIGCONT: ::c_int = 12;\n+pub const SIGTSTP: ::c_int = 13;\n+pub const SIGALRM: ::c_int = 14;\n+pub const SIGTERM: ::c_int = 15;\n+pub const SIGTTIN: ::c_int = 16;\n+pub const SIGTTOU: ::c_int = 17;\n+pub const SIGUSR1: ::c_int = 18;\n+pub const SIGUSR2: ::c_int = 19;\n+pub const SIGWINCH: ::c_int = 20;\n+pub const SIGKILLTHR: ::c_int = 21;\n+pub const SIGTRAP: ::c_int = 22;\n+pub const SIGPOLL: ::c_int = 23;\n+pub const SIGPROF: ::c_int = 24;\n+pub const SIGSYS: ::c_int = 25;\n+pub const SIGURG: ::c_int = 26;\n+pub const SIGVTALRM: ::c_int = 27;\n+pub const SIGXCPU: ::c_int = 28;\n+pub const SIGXFSZ: ::c_int = 29;\n+pub const SIGBUS: ::c_int = 30;\n+\n+pub const SIG_BLOCK: ::c_int = 1;\n+pub const SIG_UNBLOCK: ::c_int = 2;\n+pub const SIG_SETMASK: ::c_int = 3;\n+\n+pub const SIGEV_NONE: ::c_int = 0;\n+pub const SIGEV_SIGNAL: ::c_int = 1;\n+pub const SIGEV_THREAD: ::c_int = 2;\n+\n+pub const EAI_AGAIN: ::c_int = 2;\n+pub const EAI_BADFLAGS: ::c_int = 3;\n+pub const EAI_FAIL: ::c_int = 4;\n+pub const EAI_FAMILY: ::c_int = 5;\n+pub const EAI_MEMORY: ::c_int = 6;\n+pub const EAI_NODATA: ::c_int = 7;\n+pub const EAI_NONAME: ::c_int = 8;\n+pub const EAI_SERVICE: ::c_int = 9;\n+pub const EAI_SOCKTYPE: ::c_int = 10;\n+pub const EAI_SYSTEM: ::c_int = 11;\n+pub const EAI_OVERFLOW: ::c_int = 14;\n+\n+pub const PROT_NONE: ::c_int = 0;\n+pub const PROT_READ: ::c_int = 1;\n+pub const PROT_WRITE: ::c_int = 2;\n+pub const PROT_EXEC: ::c_int = 4;\n+\n+pub const LC_ALL: ::c_int = 0;\n+pub const LC_COLLATE: ::c_int = 1;\n+pub const LC_CTYPE: ::c_int = 2;\n+pub const LC_MONETARY: ::c_int = 3;\n+pub const LC_NUMERIC: ::c_int = 4;\n+pub const LC_TIME: ::c_int = 5;\n+pub const LC_MESSAGES: ::c_int = 6;\n+\n+// TODO: Haiku does not have MAP_FILE, but libstd/os.rs requires it\n+pub const MAP_FILE: ::c_int = 0x00;\n+pub const MAP_SHARED: ::c_int = 0x01;\n+pub const MAP_PRIVATE: ::c_int = 0x02;\n+pub const MAP_FIXED: ::c_int = 0x04;\n+pub const MAP_ANONYMOUS: ::c_int = 0x08;\n+pub const MAP_ANON: ::c_int = MAP_ANONYMOUS;\n+\n+pub const MAP_FAILED: *mut ::c_void = !0 as *mut ::c_void;\n+\n+pub const MS_ASYNC: ::c_int = 0x01;\n+pub const MS_INVALIDATE: ::c_int = 0x04;\n+pub const MS_SYNC: ::c_int = 0x02;\n+\n+pub const E2BIG: ::c_int = -2147454975;\n+pub const ECHILD: ::c_int = -2147454974;\n+pub const EDEADLK: ::c_int = -2147454973;\n+pub const EFBIG: ::c_int = -2147454972;\n+pub const EMLINK: ::c_int = -2147454971;\n+pub const ENFILE: ::c_int = -2147454970;\n+pub const ENODEV: ::c_int = -2147454969;\n+pub const ENOLCK: ::c_int = -2147454968;\n+pub const ENOSYS: ::c_int = -2147454967;\n+pub const ENOTTY: ::c_int = -2147454966;\n+pub const ENXIO: ::c_int = -2147454965;\n+pub const ESPIPE: ::c_int = -2147454964;\n+pub const ESRCH: ::c_int = -2147454963;\n+pub const EFPOS: ::c_int = -2147457962;\n+pub const ESIGPARM: ::c_int = -2147457961;\n+pub const EDOM: ::c_int = -2147454960;\n+pub const ERANGE: ::c_int = -2147454959;\n+pub const EPROTOTYPE: ::c_int = -2147454958;\n+pub const EPROTONOSUPPORT: ::c_int = -2147454957;\n+pub const EPFNOSUPPORT: ::c_int = -2147454956;\n+pub const EAFNOSUPPORT: ::c_int = -2147454955;\n+pub const EADDRINUSE: ::c_int = -2147454954;\n+pub const EADDRNOTAVAIL: ::c_int = -2147454953;\n+pub const ENETDOWN: ::c_int = -2147454952;\n+pub const ENETUNREACH: ::c_int = -2147454951;\n+pub const ENETRESET: ::c_int = -2147454950;\n+pub const ECONNABORTED: ::c_int = -2147454949;\n+pub const ECONNRESET: ::c_int = -2147454948;\n+pub const EISCONN: ::c_int = -2147454947;\n+pub const ENOTCONN: ::c_int = -2147454946;\n+pub const ESHUTDOWN: ::c_int = -2147454945;\n+pub const ECONNREFUSED: ::c_int = -2147454944;\n+pub const EHOSTUNREACH: ::c_int = -2147454943;\n+pub const ENOPROTOOPT: ::c_int = -2147454942;\n+pub const ENOBUFS: ::c_int = -2147454941;\n+pub const EINPROGRESS: ::c_int = -2147454940;\n+pub const EALREADY: ::c_int = -2147454939;\n+pub const EILSEQ: ::c_int = -2147454938;\n+pub const ENOMSG: ::c_int = -2147454937;\n+pub const ESTALE: ::c_int = -2147454936;\n+pub const EOVERFLOW: ::c_int = -2147454935;\n+pub const EMSGSIZE: ::c_int = -2147454934;\n+pub const EOPNOTSUPP: ::c_int = -2147454933;\n+pub const ENOTSOCK: ::c_int = -2147454932;\n+pub const EHOSTDOWN: ::c_int = -2147454931;\n+pub const EBADMSG: ::c_int = -2147454930;\n+pub const ECANCELED: ::c_int = -2147454929;\n+pub const EDESTADDRREQ: ::c_int = -2147454928;\n+pub const EDQUOT: ::c_int = -2147454927;\n+pub const EIDRM: ::c_int = -2147454926;\n+pub const EMULTIHOP: ::c_int = -2147454925;\n+pub const ENODATA: ::c_int = -2147454924;\n+pub const ENOLINK: ::c_int = -2147454923;\n+pub const ENOSR: ::c_int = -2147454922;\n+pub const ENOSTR: ::c_int = -2147454921;\n+pub const ENOTSUP: ::c_int = -2147454920;\n+pub const EPROTO: ::c_int = -2147454919;\n+pub const ETIME: ::c_int = -2147454918;\n+pub const ETXTBSY: ::c_int = -2147454917;\n+pub const ENOATTR: ::c_int = -2147454916;\n+\n+// INT_MIN\n+pub const ENOMEM: ::c_int = -2147454976;\n+\n+// POSIX errors that can be mapped to BeOS error codes\n+pub const EACCES: ::c_int = -2147483646;\n+pub const EINTR: ::c_int = -2147483638;\n+pub const EIO: ::c_int = -2147483647;\n+pub const EBUSY: ::c_int = -2147483634;\n+pub const EFAULT: ::c_int = -2147478783;\n+pub const ETIMEDOUT: ::c_int = -2147483639;\n+pub const EAGAIN: ::c_int = -2147483637;\n+pub const EWOULDBLOCK: ::c_int = -2147483637;\n+pub const EBADF: ::c_int = -2147459072;\n+pub const EEXIST: ::c_int = -2147459070;\n+pub const EINVAL: ::c_int = -2147483643;\n+pub const ENAMETOOLONG: ::c_int = -2147459068;\n+pub const ENOENT: ::c_int = -2147459069;\n+pub const EPERM: ::c_int = -2147483633;\n+pub const ENOTDIR: ::c_int = -2147459067;\n+pub const EISDIR: ::c_int = -2147459063;\n+pub const ENOTEMPTY: ::c_int = -2147459066;\n+pub const ENOSPC: ::c_int = -2147459065;\n+pub const EROFS: ::c_int = -2147459064;\n+pub const EMFILE: ::c_int = -2147459062;\n+pub const EXDEV: ::c_int = -2147459061;\n+pub const ELOOP: ::c_int = -2147459060;\n+pub const ENOEXEC: ::c_int = -2147478782;\n+pub const EPIPE: ::c_int = -2147459059;\n+\n+pub const IPPROTO_RAW: ::c_int = 255;\n+\n+// These are prefixed with POSIX_ on Haiku\n+pub const MADV_NORMAL: ::c_int = 1;\n+pub const MADV_SEQUENTIAL: ::c_int = 2;\n+pub const MADV_RANDOM: ::c_int = 3;\n+pub const MADV_WILLNEED: ::c_int = 4;\n+pub const MADV_DONTNEED: ::c_int = 5;\n+\n+// https://github.com/haiku/haiku/blob/master/headers/posix/net/if.h#L80\n+pub const IFF_UP: ::c_int = 0x0001;\n+pub const IFF_BROADCAST: ::c_int = 0x0002; // valid broadcast address\n+pub const IFF_LOOPBACK: ::c_int = 0x0008;\n+pub const IFF_POINTOPOINT: ::c_int = 0x0010; // point-to-point link\n+pub const IFF_NOARP: ::c_int = 0x0040; // no address resolution\n+pub const IFF_AUTOUP: ::c_int = 0x0080; // auto dial\n+pub const IFF_PROMISC: ::c_int = 0x0100; // receive all packets\n+pub const IFF_ALLMULTI: ::c_int = 0x0200; // receive all multicast packets\n+pub const IFF_SIMPLEX: ::c_int = 0x0800; // doesn't receive own transmissions\n+pub const IFF_LINK: ::c_int = 0x1000; // has link\n+pub const IFF_AUTO_CONFIGURED: ::c_int = 0x2000;\n+pub const IFF_CONFIGURING: ::c_int = 0x4000;\n+pub const IFF_MULTICAST: ::c_int = 0x8000; // supports multicast\n+\n+pub const AF_UNSEC: ::c_int = 0;\n+pub const AF_INET: ::c_int = 1;\n+pub const AF_APPLETALK: ::c_int = 2;\n+pub const AF_ROUTE: ::c_int = 3;\n+pub const AF_LINK: ::c_int = 4;\n+pub const AF_INET6: ::c_int = 5;\n+pub const AF_DLI: ::c_int = 6;\n+pub const AF_IPX: ::c_int = 7;\n+pub const AF_NOTIFY: ::c_int = 8;\n+pub const AF_LOCAL: ::c_int = 9;\n+pub const AF_UNIX: ::c_int = AF_LOCAL;\n+pub const AF_BLUETOOTH: ::c_int = 10;\n+\n+pub const IP_OPTIONS: ::c_int = 1;\n+pub const IP_HDRINCL: ::c_int = 2;\n+pub const IP_TOS: ::c_int = 3;\n+pub const IP_TTL: ::c_int = 4;\n+pub const IP_RECVOPTS: ::c_int = 5;\n+pub const IP_RECVRETOPTS: ::c_int = 6;\n+pub const IP_RECVDSTADDR: ::c_int = 7;\n+pub const IP_RETOPTS: ::c_int = 8;\n+pub const IP_MULTICAST_IF: ::c_int = 9;\n+pub const IP_MULTICAST_TTL: ::c_int = 10;\n+pub const IP_MULTICAST_LOOP: ::c_int = 11;\n+pub const IP_ADD_MEMBERSHIP: ::c_int = 12;\n+pub const IP_DROP_MEMBERSHIP: ::c_int = 13;\n+pub const IP_BLOCK_SOURCE: ::c_int = 14;\n+pub const IP_UNBLOCK_SOURCE: ::c_int = 15;\n+pub const IP_ADD_SOURCE_MEMBERSHIP: ::c_int = 16;\n+pub const IP_DROP_SOURCE_MEMBERSHIP: ::c_int = 17;\n+\n+pub const TCP_NODELAY: ::c_int = 0x01;\n+pub const TCP_MAXSEG: ::c_int = 0x02;\n+pub const TCP_NOPUSH: ::c_int = 0x04;\n+pub const TCP_NOOPT: ::c_int = 0x08;\n+\n+pub const IPV6_MULTICAST_IF: ::c_int = 24;\n+pub const IPV6_MULTICAST_HOPS: ::c_int = 25;\n+pub const IPV6_MULTICAST_LOOP: ::c_int = 26;\n+pub const IPV6_UNICAST_HOPS: ::c_int = 27;\n+pub const IPV6_JOIN_GROUP: ::c_int = 28;\n+pub const IPV6_LEAVE_GROUP: ::c_int = 29;\n+pub const IPV6_V6ONLY: ::c_int = 30;\n+pub const IPV6_PKTINFO: ::c_int = 31;\n+pub const IPV6_RECVPKTINFO: ::c_int = 32;\n+pub const IPV6_HOPLIMIT: ::c_int = 33;\n+pub const IPV6_REVCHOPLIMIT: ::c_int = 34;\n+pub const IPV6_HOPOPTS: ::c_int = 35;\n+pub const IPV6_DSTOPTS: ::c_int = 36;\n+pub const IPV6_RTHDR: ::c_int = 37;\n+\n+pub const MSG_OOB: ::c_int = 0x0001;\n+pub const MSG_PEEK: ::c_int = 0x0002;\n+pub const MSG_DONTROUTE: ::c_int = 0x0004;\n+pub const MSG_EOR: ::c_int = 0x0008;\n+pub const MSG_TRUNC: ::c_int = 0x0010;\n+pub const MSG_CTRUNC: ::c_int = 0x0020;\n+pub const MSG_WAITALL: ::c_int = 0x0040;\n+pub const MSG_DONTWAIT: ::c_int = 0x0080;\n+pub const MSG_BCAST: ::c_int = 0x0100;\n+pub const MSG_MCAST: ::c_int = 0x0200;\n+pub const MSG_EOF: ::c_int = 0x0400;\n+pub const MSG_NOSIGNAL: ::c_int = 0x0800;\n+\n+pub const SHUT_RD: ::c_int = 0;\n+pub const SHUT_WR: ::c_int = 1;\n+pub const SHUT_RDWR: ::c_int = 2;\n+\n+pub const LOCK_SH: ::c_int = 0x01;\n+pub const LOCK_EX: ::c_int = 0x02;\n+pub const LOCK_NB: ::c_int = 0x04;\n+pub const LOCK_UN: ::c_int = 0x08;\n+\n+pub const SIGSTKSZ: ::size_t = 16384;\n+\n+pub const PATH_MAX: ::c_int = 1024;\n+\n+pub const SA_NOCLDSTOP: ::c_int = 0x01;\n+pub const SA_NOCLDWAIT: ::c_int = 0x02;\n+pub const SA_RESETHAND: ::c_int = 0x04;\n+pub const SA_NODEFER: ::c_int = 0x08;\n+pub const SA_RESTART: ::c_int = 0x10;\n+pub const SA_ONSTACK: ::c_int = 0x20;\n+pub const SA_SIGINFO: ::c_int = 0x40;\n+pub const SA_NOMASK: ::c_int = SA_NODEFER;\n+pub const SA_STACK: ::c_int = SA_ONSTACK;\n+pub const SA_ONESHOT: ::c_int = SA_RESETHAND;\n+\n+pub const FD_SETSIZE: usize = 1024;\n+\n+pub const RTLD_LOCAL: ::c_int = 0x0;\n+pub const RTLD_NOW: ::c_int = 0x1;\n+pub const RTLD_GLOBAL: ::c_int = 0x2;\n+pub const RTLD_DEFAULT: *mut ::c_void = 0isize as *mut ::c_void;\n+\n+pub const BUFSIZ: ::c_uint = 8192;\n+pub const FILENAME_MAX: ::c_uint = 256;\n+pub const FOPEN_MAX: ::c_uint = 128;\n+pub const L_tmpnam: ::c_uint = 512;\n+pub const TMP_MAX: ::c_uint = 32768;\n+\n+pub const _PC_CHOWN_RESTRICTED: ::c_int = 1;\n+pub const _PC_MAX_CANON: ::c_int = 2;\n+pub const _PC_MAX_INPUT: ::c_int = 3;\n+pub const _PC_NAME_MAX: ::c_int = 4;\n+pub const _PC_NO_TRUNC: ::c_int = 5;\n+pub const _PC_PATH_MAX: ::c_int = 6;\n+pub const _PC_PIPE_BUF: ::c_int = 7;\n+pub const _PC_VDISABLE: ::c_int = 8;\n+pub const _PC_LINK_MAX: ::c_int = 25;\n+pub const _PC_SYNC_IO: ::c_int = 26;\n+pub const _PC_ASYNC_IO: ::c_int = 27;\n+pub const _PC_PRIO_IO: ::c_int = 28;\n+pub const _PC_SOCK_MAXBUF: ::c_int = 29;\n+pub const _PC_FILESIZEBITS: ::c_int = 30;\n+pub const _PC_REC_INCR_XFER_SIZE: ::c_int = 31;\n+pub const _PC_REC_MAX_XFER_SIZE: ::c_int = 32;\n+pub const _PC_REC_MIN_XFER_SIZE: ::c_int = 33;\n+pub const _PC_REC_XFER_ALIGN: ::c_int = 34;\n+pub const _PC_ALLOC_SIZE_MIN: ::c_int = 35;\n+pub const _PC_SYMLINK_MAX: ::c_int = 36;\n+pub const _PC_2_SYMLINKS: ::c_int = 37;\n+pub const _PC_XATTR_EXISTS: ::c_int = 38;\n+pub const _PC_XATTR_ENABLED: ::c_int = 39;\n+\n+pub const FIONBIO: ::c_int = 0xbe000000;\n+\n+pub const _SC_ARG_MAX: ::c_int = 15;\n+pub const _SC_CHILD_MAX: ::c_int = 16;\n+pub const _SC_CLK_TCK: ::c_int = 17;\n+pub const _SC_JOB_CONTROL: ::c_int = 18;\n+pub const _SC_NGROUPS_MAX: ::c_int = 19;\n+pub const _SC_OPEN_MAX: ::c_int = 20;\n+pub const _SC_SAVED_IDS: ::c_int = 21;\n+pub const _SC_STREAM_MAX: ::c_int = 22;\n+pub const _SC_TZNAME_MAX: ::c_int = 23;\n+pub const _SC_VERSION: ::c_int = 24;\n+pub const _SC_GETGR_R_SIZE_MAX: ::c_int = 25;\n+pub const _SC_GETPW_R_SIZE_MAX: ::c_int = 26;\n+pub const _SC_PAGESIZE: ::c_int = 27;\n+pub const _SC_PAGE_SIZE: ::c_int = 27;\n+pub const _SC_SEM_NSEMS_MAX: ::c_int = 28;\n+pub const _SC_SEM_VALUE_MAX: ::c_int = 29;\n+pub const _SC_SEMAPHORES: ::c_int = 30;\n+pub const _SC_THREADS: ::c_int = 31;\n+pub const _SC_IOV_MAX: ::c_int = 32;\n+pub const _SC_UIO_MAXIOV: ::c_int = 32;\n+pub const _SC_NPROCESSORS_CONF: ::c_int = 34;\n+pub const _SC_NPROCESSORS_ONLN: ::c_int = 35;\n+pub const _SC_ATEXIT_MAX: ::c_int = 37;\n+pub const _SC_PASS_MAX: ::c_int = 39;\n+pub const _SC_PHYS_PAGES: ::c_int = 40;\n+pub const _SC_AVPHYS_PAGES: ::c_int = 41;\n+pub const _SC_PIPE: ::c_int = 42;\n+pub const _SC_SELECT: ::c_int = 43;\n+pub const _SC_POLL: ::c_int = 44;\n+pub const _SC_MAPPED_FILES: ::c_int = 45;\n+pub const _SC_THREAD_PROCESS_SHARED: ::c_int = 46;\n+pub const _SC_THREAD_STACK_MIN: ::c_int = 47;\n+pub const _SC_THREAD_ATTR_STACKADDR: ::c_int = 48;\n+pub const _SC_THREAD_ATTR_STACKSIZE: ::c_int = 49;\n+pub const _SC_THREAD_PRIORITY_SCHEDULING: ::c_int = 50;\n+pub const _SC_REALTIME_SIGNALS: ::c_int = 51;\n+pub const _SC_MEMORY_PROTECTION: ::c_int = 52;\n+pub const _SC_SIGQUEUE_MAX: ::c_int = 53;\n+pub const _SC_RTSIG_MAX: ::c_int = 54;\n+pub const _SC_MONOTONIC_CLOCK: ::c_int = 55;\n+pub const _SC_DELAYTIMER_MAX: ::c_int = 56;\n+pub const _SC_TIMER_MAX: ::c_int = 57;\n+pub const _SC_TIMERS: ::c_int = 58;\n+pub const _SC_CPUTIME: ::c_int = 59;\n+pub const _SC_THREAD_CPUTIME: ::c_int = 60;\n+\n+pub const PTHREAD_STACK_MIN: ::size_t = 8192;\n+\n+pub const PTHREAD_MUTEX_INITIALIZER: pthread_mutex_t = pthread_mutex_t {\n+    flags: 0,\n+    lock: 0,\n+    unused: -42,\n+    owner: -1,\n+    owner_count: 0,\n+};\n+pub const PTHREAD_COND_INITIALIZER: pthread_cond_t = pthread_cond_t {\n+    flags: 0,\n+    unused: -42,\n+    mutex: 0 as *mut _,\n+    waiter_count: 0,\n+    lock: 0,\n+};\n+pub const PTHREAD_RWLOCK_INITIALIZER: pthread_rwlock_t = pthread_rwlock_t {\n+    flags: 0,\n+    owner: -1,\n+    lock_sem: 0,\n+    lock_count: 0,\n+    reader_count: 0,\n+    writer_count: 0,\n+    waiters: [0 as *mut _; 2],\n+};\n+\n+pub const PTHREAD_MUTEX_DEFAULT: ::c_int = 0;\n+pub const PTHREAD_MUTEX_NORMAL: ::c_int = 1;\n+pub const PTHREAD_MUTEX_ERRORCHECK: ::c_int = 2;\n+pub const PTHREAD_MUTEX_RECURSIVE: ::c_int = 3;\n+\n+pub const FIOCLEX: c_ulong = 0; // TODO: does not exist on Haiku!\n+\n+pub const RUSAGE_CHILDREN: ::c_int = -1;\n+\n+pub const SOCK_STREAM: ::c_int = 1;\n+pub const SOCK_DGRAM: ::c_int = 2;\n+pub const SOCK_RAW: ::c_int = 3;\n+pub const SOCK_SEQPACKET: ::c_int = 5;\n+\n+pub const SOL_SOCKET: ::c_int = -1;\n+pub const SO_ACCEPTCONN: ::c_int = 0x00000001;\n+pub const SO_BROADCAST: ::c_int = 0x00000002;\n+pub const SO_DEBUG: ::c_int = 0x00000004;\n+pub const SO_DONTROUTE: ::c_int = 0x00000008;\n+pub const SO_KEEPALIVE: ::c_int = 0x00000010;\n+pub const SO_OOBINLINE: ::c_int = 0x00000020;\n+pub const SO_REUSEADDR: ::c_int = 0x00000040;\n+pub const SO_REUSEPORT: ::c_int = 0x00000080;\n+pub const SO_USELOOPBACK: ::c_int = 0x00000100;\n+pub const SO_LINGER: ::c_int = 0x00000200;\n+pub const SO_SNDBUF: ::c_int = 0x40000001;\n+pub const SO_SNDLOWAT: ::c_int = 0x40000002;\n+pub const SO_SNDTIMEO: ::c_int = 0x40000003;\n+pub const SO_RCVBUF: ::c_int = 0x40000004;\n+pub const SO_RCVLOWAT: ::c_int = 0x40000005;\n+pub const SO_RCVTIMEO: ::c_int = 0x40000006;\n+pub const SO_ERROR: ::c_int = 0x40000007;\n+pub const SO_TYPE: ::c_int = 0x40000008;\n+pub const SO_NONBLOCK: ::c_int = 0x40000009;\n+pub const SO_BINDTODEVICE: ::c_int = 0x4000000a;\n+pub const SO_PEERCRED: ::c_int = 0x4000000b;\n+\n+pub const SCM_RIGHTS: ::c_int = 0x01;\n+\n+pub const NI_MAXHOST: ::size_t = 1025;\n+\n+pub const WNOHANG: ::c_int = 0x01;\n+pub const WUNTRACED: ::c_int = 0x02;\n+pub const WCONTINUED: ::c_int = 0x04;\n+pub const WEXITED: ::c_int = 0x08;\n+pub const WSTOPPED: ::c_int = 0x10;\n+pub const WNOWAIT: ::c_int = 0x20;\n+\n+pub const P_ALL: idtype_t = 0;\n+pub const P_PID: idtype_t = 1;\n+pub const P_PGID: idtype_t = 2;\n+\n+pub const UTIME_OMIT: c_long = 1000000001;\n+pub const UTIME_NOW: c_long = 1000000000;\n+\n+pub const VINTR: usize = 0;\n+pub const VQUIT: usize = 1;\n+pub const VERASE: usize = 2;\n+pub const VKILL: usize = 3;\n+pub const VEOF: usize = 4;\n+pub const VEOL: usize = 5;\n+pub const VMIN: usize = 4;\n+pub const VTIME: usize = 5;\n+pub const VEOL2: usize = 6;\n+pub const VSWTCH: usize = 7;\n+pub const VSTART: usize = 8;\n+pub const VSTOP: usize = 9;\n+pub const VSUSP: usize = 10;\n+\n+pub const IGNBRK: ::tcflag_t = 0x01;\n+pub const BRKINT: ::tcflag_t = 0x02;\n+pub const IGNPAR: ::tcflag_t = 0x04;\n+pub const PARMRK: ::tcflag_t = 0x08;\n+pub const INPCK: ::tcflag_t = 0x10;\n+pub const ISTRIP: ::tcflag_t = 0x20;\n+pub const INLCR: ::tcflag_t = 0x40;\n+pub const IGNCR: ::tcflag_t = 0x80;\n+pub const ICRNL: ::tcflag_t = 0x100;\n+pub const IUCLC: ::tcflag_t = 0x200;\n+pub const IXON: ::tcflag_t = 0x400;\n+pub const IXANY: ::tcflag_t = 0x800;\n+pub const IXOFF: ::tcflag_t = 0x1000;\n+\n+pub const OPOST: ::tcflag_t = 0x00000001;\n+pub const OLCUC: ::tcflag_t = 0x00000002;\n+pub const ONLCR: ::tcflag_t = 0x00000004;\n+pub const OCRNL: ::tcflag_t = 0x00000008;\n+pub const ONOCR: ::tcflag_t = 0x00000010;\n+pub const ONLRET: ::tcflag_t = 0x00000020;\n+pub const OFILL: ::tcflag_t = 0x00000040;\n+pub const OFDEL: ::tcflag_t = 0x00000080;\n+pub const NLDLY: ::tcflag_t = 0x00000100;\n+pub const NL0: ::tcflag_t = 0x00000000;\n+pub const NL1: ::tcflag_t = 0x00000100;\n+pub const CRDLY: ::tcflag_t = 0x00000600;\n+pub const CR0: ::tcflag_t = 0x00000000;\n+pub const CR1: ::tcflag_t = 0x00000200;\n+pub const CR2: ::tcflag_t = 0x00000400;\n+pub const CR3: ::tcflag_t = 0x00000600;\n+pub const TABDLY: ::tcflag_t = 0x00001800;\n+pub const TAB0: ::tcflag_t = 0x00000000;\n+pub const TAB1: ::tcflag_t = 0x00000800;\n+pub const TAB2: ::tcflag_t = 0x00001000;\n+pub const TAB3: ::tcflag_t = 0x00001800;\n+pub const BSDLY: ::tcflag_t = 0x00002000;\n+pub const BS0: ::tcflag_t = 0x00000000;\n+pub const BS1: ::tcflag_t = 0x00002000;\n+pub const VTDLY: ::tcflag_t = 0x00004000;\n+pub const VT0: ::tcflag_t = 0x00000000;\n+pub const VT1: ::tcflag_t = 0x00004000;\n+pub const FFDLY: ::tcflag_t = 0x00008000;\n+pub const FF0: ::tcflag_t = 0x00000000;\n+pub const FF1: ::tcflag_t = 0x00008000;\n+\n+pub const CSIZE: ::tcflag_t = 0x00000020;\n+pub const CS5: ::tcflag_t = 0x00000000;\n+pub const CS6: ::tcflag_t = 0x00000000;\n+pub const CS7: ::tcflag_t = 0x00000000;\n+pub const CS8: ::tcflag_t = 0x00000020;\n+pub const CSTOPB: ::tcflag_t = 0x00000040;\n+pub const CREAD: ::tcflag_t = 0x00000080;\n+pub const PARENB: ::tcflag_t = 0x00000100;\n+pub const PARODD: ::tcflag_t = 0x00000200;\n+pub const HUPCL: ::tcflag_t = 0x00000400;\n+pub const CLOCAL: ::tcflag_t = 0x00000800;\n+pub const XLOBLK: ::tcflag_t = 0x00001000;\n+pub const CTSFLOW: ::tcflag_t = 0x00002000;\n+pub const RTSFLOW: ::tcflag_t = 0x00004000;\n+pub const CRTSCTS: ::tcflag_t = RTSFLOW | CTSFLOW;\n+\n+pub const ISIG: ::tcflag_t = 0x00000001;\n+pub const ICANON: ::tcflag_t = 0x00000002;\n+pub const XCASE: ::tcflag_t = 0x00000004;\n+pub const ECHO: ::tcflag_t = 0x00000008;\n+pub const ECHOE: ::tcflag_t = 0x00000010;\n+pub const ECHOK: ::tcflag_t = 0x00000020;\n+pub const ECHONL: ::tcflag_t = 0x00000040;\n+pub const NOFLSH: ::tcflag_t = 0x00000080;\n+pub const TOSTOP: ::tcflag_t = 0x00000100;\n+pub const IEXTEN: ::tcflag_t = 0x00000200;\n+pub const ECHOCTL: ::tcflag_t = 0x00000400;\n+pub const ECHOPRT: ::tcflag_t = 0x00000800;\n+pub const ECHOKE: ::tcflag_t = 0x00001000;\n+pub const FLUSHO: ::tcflag_t = 0x00002000;\n+pub const PENDIN: ::tcflag_t = 0x00004000;\n+\n+pub const TCGB_CTS: ::c_int = 0x01;\n+pub const TCGB_DSR: ::c_int = 0x02;\n+pub const TCGB_RI: ::c_int = 0x04;\n+pub const TCGB_DCD: ::c_int = 0x08;\n+pub const TIOCM_CTS: ::c_int = TCGB_CTS;\n+pub const TIOCM_CD: ::c_int = TCGB_DCD;\n+pub const TIOCM_CAR: ::c_int = TIOCM_CD;\n+pub const TIOCM_RI: ::c_int = TCGB_RI;\n+pub const TIOCM_DSR: ::c_int = TCGB_DSR;\n+pub const TIOCM_DTR: ::c_int = 0x10;\n+pub const TIOCM_RTS: ::c_int = 0x20;\n+\n+pub const B0: speed_t = 0x00;\n+pub const B50: speed_t = 0x01;\n+pub const B75: speed_t = 0x02;\n+pub const B110: speed_t = 0x03;\n+pub const B134: speed_t = 0x04;\n+pub const B150: speed_t = 0x05;\n+pub const B200: speed_t = 0x06;\n+pub const B300: speed_t = 0x07;\n+pub const B600: speed_t = 0x08;\n+pub const B1200: speed_t = 0x09;\n+pub const B1800: speed_t = 0x0A;\n+pub const B2400: speed_t = 0x0B;\n+pub const B4800: speed_t = 0x0C;\n+pub const B9600: speed_t = 0x0D;\n+pub const B19200: speed_t = 0x0E;\n+pub const B38400: speed_t = 0x0F;\n+pub const B57600: speed_t = 0x10;\n+pub const B115200: speed_t = 0x11;\n+pub const B230400: speed_t = 0x12;\n+pub const B31250: speed_t = 0x13;\n+\n+pub const TCSANOW: ::c_int = 0x01;\n+pub const TCSADRAIN: ::c_int = 0x02;\n+pub const TCSAFLUSH: ::c_int = 0x04;\n+\n+pub const TCOOFF: ::c_int = 0x01;\n+pub const TCOON: ::c_int = 0x02;\n+pub const TCIOFF: ::c_int = 0x04;\n+pub const TCION: ::c_int = 0x08;\n+\n+pub const TCIFLUSH: ::c_int = 0x01;\n+pub const TCOFLUSH: ::c_int = 0x02;\n+pub const TCIOFLUSH: ::c_int = 0x03;\n+\n+pub const TCGETA: ::c_int = 0x8000;\n+pub const TCSETA: ::c_int = TCGETA + 1;\n+pub const TCSETAF: ::c_int = TCGETA + 2;\n+pub const TCSETAW: ::c_int = TCGETA + 3;\n+pub const TCWAITEVENT: ::c_int = TCGETA + 4;\n+pub const TCSBRK: ::c_int = TCGETA + 5;\n+pub const TCFLSH: ::c_int = TCGETA + 6;\n+pub const TCXONC: ::c_int = TCGETA + 7;\n+pub const TCQUERYCONNECTED: ::c_int = TCGETA + 8;\n+pub const TCGETBITS: ::c_int = TCGETA + 9;\n+pub const TCSETDTR: ::c_int = TCGETA + 10;\n+pub const TCSETRTS: ::c_int = TCGETA + 11;\n+pub const TIOCGWINSZ: ::c_int = TCGETA + 12;\n+pub const TIOCSWINSZ: ::c_int = TCGETA + 13;\n+pub const TCVTIME: ::c_int = TCGETA + 14;\n+pub const TIOCGPGRP: ::c_int = TCGETA + 15;\n+pub const TIOCSPGRP: ::c_int = TCGETA + 16;\n+pub const TIOCSCTTY: ::c_int = TCGETA + 17;\n+pub const TIOCMGET: ::c_int = TCGETA + 18;\n+pub const TIOCMSET: ::c_int = TCGETA + 19;\n+pub const TIOCSBRK: ::c_int = TCGETA + 20;\n+pub const TIOCCBRK: ::c_int = TCGETA + 21;\n+pub const TIOCMBIS: ::c_int = TCGETA + 22;\n+pub const TIOCMBIC: ::c_int = TCGETA + 23;\n+\n+f! {\n+    pub fn FD_CLR(fd: ::c_int, set: *mut fd_set) -> () {\n+        let fd = fd as usize;\n+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;\n+        (*set).fds_bits[fd / size] &= !(1 << (fd % size));\n+        return\n+    }\n+\n+    pub fn FD_ISSET(fd: ::c_int, set: *mut fd_set) -> bool {\n+        let fd = fd as usize;\n+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;\n+        return ((*set).fds_bits[fd / size] & (1 << (fd % size))) != 0\n+    }\n+\n+    pub fn FD_SET(fd: ::c_int, set: *mut fd_set) -> () {\n+        let fd = fd as usize;\n+        let size = ::mem::size_of_val(&(*set).fds_bits[0]) * 8;\n+        (*set).fds_bits[fd / size] |= 1 << (fd % size);\n+        return\n+    }\n+\n+    pub fn FD_ZERO(set: *mut fd_set) -> () {\n+        for slot in (*set).fds_bits.iter_mut() {\n+            *slot = 0;\n+        }\n+    }\n+\n+    pub fn WIFEXITED(status: ::c_int) -> bool {\n+        (status & !0xff) == 0\n+    }\n+\n+    pub fn WEXITSTATUS(status: ::c_int) -> ::c_int {\n+        (status & 0xff)\n+    }\n+\n+    pub fn WIFSIGNALED(status: ::c_int) -> bool {\n+        ((status >> 8) & 0xff) != 0\n+    }\n+\n+    pub fn WTERMSIG(status: ::c_int) -> ::c_int {\n+        (status >> 8) & 0xff\n+    }\n+\n+    pub fn WIFSTOPPED(status: ::c_int) -> bool {\n+        ((status >> 16) & 0xff) != 0\n+    }\n+\n+    pub fn WSTOPSIG(status: ::c_int) -> ::c_int {\n+        (status >> 16) & 0xff\n+    }\n+\n+    // actually WIFCORED, but this is used everywhere else\n+    pub fn WCOREDUMP(status: ::c_int) -> bool {\n+        (status & 0x10000) != 0\n+    }\n+\n+    pub fn WIFCONTINUED(status: ::c_int) -> bool {\n+        (status & 0x20000) != 0\n+    }\n+}\n+\n+extern \"C\" {\n+    pub fn getrlimit(resource: ::c_int, rlim: *mut ::rlimit) -> ::c_int;\n+    pub fn setrlimit(resource: ::c_int, rlim: *const ::rlimit) -> ::c_int;\n+    pub fn strerror_r(\n+        errnum: ::c_int,\n+        buf: *mut c_char,\n+        buflen: ::size_t,\n+    ) -> ::c_int;\n+    pub fn _errnop() -> *mut ::c_int;\n+\n+    pub fn abs(i: ::c_int) -> ::c_int;\n+    pub fn atof(s: *const ::c_char) -> ::c_double;\n+    pub fn labs(i: ::c_long) -> ::c_long;\n+    pub fn rand() -> ::c_int;\n+    pub fn srand(seed: ::c_uint);\n+}\n+\n+#[link(name = \"bsd\")]\n+extern \"C\" {\n+    pub fn sem_destroy(sem: *mut sem_t) -> ::c_int;\n+    pub fn sem_init(\n+        sem: *mut sem_t,\n+        pshared: ::c_int,\n+        value: ::c_uint,\n+    ) -> ::c_int;\n+\n+    pub fn clock_gettime(clk_id: ::c_int, tp: *mut ::timespec) -> ::c_int;\n+    pub fn clock_settime(clk_id: ::c_int, tp: *const ::timespec) -> ::c_int;\n+    pub fn pthread_create(\n+        thread: *mut ::pthread_t,\n+        attr: *const ::pthread_attr_t,\n+        f: extern \"C\" fn(*mut ::c_void) -> *mut ::c_void,\n+        value: *mut ::c_void,\n+    ) -> ::c_int;\n+    pub fn pthread_attr_getguardsize(\n+        attr: *const ::pthread_attr_t,\n+        guardsize: *mut ::size_t,\n+    ) -> ::c_int;\n+    pub fn pthread_attr_getstack(\n+        attr: *const ::pthread_attr_t,\n+        stackaddr: *mut *mut ::c_void,\n+        stacksize: *mut ::size_t,\n+    ) -> ::c_int;\n+    pub fn pthread_condattr_getclock(\n+        attr: *const pthread_condattr_t,\n+        clock_id: *mut clockid_t,\n+    ) -> ::c_int;\n+    pub fn pthread_condattr_setclock(\n+        attr: *mut pthread_condattr_t,\n+        clock_id: ::clockid_t,\n+    ) -> ::c_int;\n+    pub fn memalign(align: ::size_t, size: ::size_t) -> *mut ::c_void;\n+    pub fn setgroups(ngroups: ::size_t, ptr: *const ::gid_t) -> ::c_int;\n+    pub fn ioctl(fd: ::c_int, request: ::c_int, ...) -> ::c_int;\n+    pub fn mprotect(\n+        addr: *const ::c_void,\n+        len: ::size_t,\n+        prot: ::c_int,\n+    ) -> ::c_int;\n+    pub fn dirfd(dirp: *mut ::DIR) -> ::c_int;\n+    pub fn getnameinfo(\n+        sa: *const ::sockaddr,\n+        salen: ::socklen_t,\n+        host: *mut ::c_char,\n+        hostlen: ::size_t,\n+        serv: *mut ::c_char,\n+        sevlen: ::size_t,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+    pub fn pthread_mutex_timedlock(\n+        lock: *mut pthread_mutex_t,\n+        abstime: *const ::timespec,\n+    ) -> ::c_int;\n+    pub fn waitid(\n+        idtype: idtype_t,\n+        id: id_t,\n+        infop: *mut ::siginfo_t,\n+        options: ::c_int,\n+    ) -> ::c_int;\n+\n+    pub fn glob(\n+        pattern: *const ::c_char,\n+        flags: ::c_int,\n+        errfunc: ::Option<\n+            extern \"C\" fn(epath: *const ::c_char, errno: ::c_int) -> ::c_int,\n+        >,\n+        pglob: *mut ::glob_t,\n+    ) -> ::c_int;\n+    pub fn globfree(pglob: *mut ::glob_t);\n+    pub fn gettimeofday(tp: *mut ::timeval, tz: *mut ::c_void) -> ::c_int;\n+    pub fn posix_madvise(\n+        addr: *mut ::c_void,\n+        len: ::size_t,\n+        advice: ::c_int,\n+    ) -> ::c_int;\n+\n+    pub fn shm_open(\n+        name: *const ::c_char,\n+        oflag: ::c_int,\n+        mode: ::mode_t,\n+    ) -> ::c_int;\n+    pub fn shm_unlink(name: *const ::c_char) -> ::c_int;\n+\n+    pub fn seekdir(dirp: *mut ::DIR, loc: ::c_long);\n+\n+    pub fn telldir(dirp: *mut ::DIR) -> ::c_long;\n+    pub fn madvise(\n+        addr: *mut ::c_void,\n+        len: ::size_t,\n+        advice: ::c_int,\n+    ) -> ::c_int;\n+\n+    pub fn msync(\n+        addr: *mut ::c_void,\n+        len: ::size_t,\n+        flags: ::c_int,\n+    ) -> ::c_int;\n+\n+    pub fn recvfrom(\n+        socket: ::c_int,\n+        buf: *mut ::c_void,\n+        len: ::size_t,\n+        flags: ::c_int,\n+        addr: *mut ::sockaddr,\n+        addrlen: *mut ::socklen_t,\n+    ) -> ::ssize_t;\n+    pub fn mkstemps(template: *mut ::c_char, suffixlen: ::c_int) -> ::c_int;\n+    pub fn futimes(fd: ::c_int, times: *const ::timeval) -> ::c_int;\n+    pub fn lutimes(file: *const ::c_char, times: *const ::timeval) -> ::c_int;\n+    pub fn nl_langinfo(item: ::nl_item) -> *mut ::c_char;\n+\n+    pub fn bind(\n+        socket: ::c_int,\n+        address: *const ::sockaddr,\n+        address_len: ::socklen_t,\n+    ) -> ::c_int;\n+\n+    pub fn writev(\n+        fd: ::c_int,\n+        iov: *const ::iovec,\n+        iovcnt: ::c_int,\n+    ) -> ::ssize_t;\n+    pub fn readv(\n+        fd: ::c_int,\n+        iov: *const ::iovec,\n+        iovcnt: ::c_int,\n+    ) -> ::ssize_t;\n+\n+    pub fn sendmsg(\n+        fd: ::c_int,\n+        msg: *const ::msghdr,\n+        flags: ::c_int,\n+    ) -> ::ssize_t;\n+    pub fn recvmsg(\n+        fd: ::c_int,\n+        msg: *mut ::msghdr,\n+        flags: ::c_int,\n+    ) -> ::ssize_t;\n+    pub fn execvpe(\n+        file: *const ::c_char,\n+        argv: *const *const ::c_char,\n+        environment: *const *const ::c_char,\n+    ) -> ::c_int;\n+    #[cfg_attr(target_os = \"solaris\", link_name = \"__posix_getgrgid_r\")]\n+    pub fn getgrgid_r(\n+        gid: ::gid_t,\n+        grp: *mut ::group,\n+        buf: *mut ::c_char,\n+        buflen: ::size_t,\n+        result: *mut *mut ::group,\n+    ) -> ::c_int;\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"sigaltstack$UNIX2003\"\n+    )]\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__sigaltstack14\")]\n+    pub fn sigaltstack(ss: *const stack_t, oss: *mut stack_t) -> ::c_int;\n+    pub fn sem_close(sem: *mut sem_t) -> ::c_int;\n+    pub fn getdtablesize() -> ::c_int;\n+    #[cfg_attr(target_os = \"solaris\", link_name = \"__posix_getgrnam_r\")]\n+    pub fn getgrnam_r(\n+        name: *const ::c_char,\n+        grp: *mut ::group,\n+        buf: *mut ::c_char,\n+        buflen: ::size_t,\n+        result: *mut *mut ::group,\n+    ) -> ::c_int;\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"pthread_sigmask$UNIX2003\"\n+    )]\n+    pub fn pthread_sigmask(\n+        how: ::c_int,\n+        set: *const sigset_t,\n+        oldset: *mut sigset_t,\n+    ) -> ::c_int;\n+    pub fn sem_open(name: *const ::c_char, oflag: ::c_int, ...) -> *mut sem_t;\n+    pub fn getgrnam(name: *const ::c_char) -> *mut ::group;\n+    pub fn pthread_kill(thread: ::pthread_t, sig: ::c_int) -> ::c_int;\n+    pub fn sem_unlink(name: *const ::c_char) -> ::c_int;\n+    pub fn daemon(nochdir: ::c_int, noclose: ::c_int) -> ::c_int;\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__getpwnam_r50\")]\n+    #[cfg_attr(target_os = \"solaris\", link_name = \"__posix_getpwnam_r\")]\n+    pub fn getpwnam_r(\n+        name: *const ::c_char,\n+        pwd: *mut passwd,\n+        buf: *mut ::c_char,\n+        buflen: ::size_t,\n+        result: *mut *mut passwd,\n+    ) -> ::c_int;\n+    #[cfg_attr(target_os = \"netbsd\", link_name = \"__getpwuid_r50\")]\n+    #[cfg_attr(target_os = \"solaris\", link_name = \"__posix_getpwuid_r\")]\n+    pub fn getpwuid_r(\n+        uid: ::uid_t,\n+        pwd: *mut passwd,\n+        buf: *mut ::c_char,\n+        buflen: ::size_t,\n+        result: *mut *mut passwd,\n+    ) -> ::c_int;\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"sigwait$UNIX2003\"\n+    )]\n+    #[cfg_attr(target_os = \"solaris\", link_name = \"__posix_sigwait\")]\n+    pub fn sigwait(set: *const sigset_t, sig: *mut ::c_int) -> ::c_int;\n+    pub fn pthread_atfork(\n+        prepare: ::Option<unsafe extern \"C\" fn()>,\n+        parent: ::Option<unsafe extern \"C\" fn()>,\n+        child: ::Option<unsafe extern \"C\" fn()>,\n+    ) -> ::c_int;\n+    pub fn getgrgid(gid: ::gid_t) -> *mut ::group;\n+    #[cfg_attr(\n+        all(target_os = \"macos\", target_arch = \"x86\"),\n+        link_name = \"popen$UNIX2003\"\n+    )]\n+    pub fn popen(command: *const c_char, mode: *const c_char) -> *mut ::FILE;\n+    pub fn openpty(\n+        amaster: *mut ::c_int,\n+        aslave: *mut ::c_int,\n+        name: *mut ::c_char,\n+        termp: *mut termios,\n+        winp: *mut ::winsize,\n+    ) -> ::c_int;\n+    pub fn forkpty(\n+        amaster: *mut ::c_int,\n+        name: *mut ::c_char,\n+        termp: *mut termios,\n+        winp: *mut ::winsize,\n+    ) -> ::pid_t;\n+    pub fn sethostname(name: *const ::c_char, len: ::size_t) -> ::c_int;\n+    pub fn uname(buf: *mut ::utsname) -> ::c_int;\n+}\n+\n+cfg_if! {\n+    if #[cfg(target_pointer_width = \"64\")] {\n+        mod b64;\n+        pub use self::b64::*;\n+    } else {\n+        mod b32;\n+        pub use self::b32::*;\n+    }\n+}"
      },
      {
        "sha": "1a92e3b4fa3412169caf35628d91ccfae399d6e9",
        "filename": "src/rusty/libc/src/unix/hermit/aarch64.rs",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/hermit/aarch64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/hermit/aarch64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/hermit/aarch64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "patch": "@@ -0,0 +1,2 @@\n+pub type c_char = u8;\n+pub type wchar_t = u32;"
      },
      {
        "sha": "83e064e71f980b9a9a66e8135cc4a5c8623976f2",
        "filename": "src/rusty/libc/src/unix/hermit/mod.rs",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/hermit/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/hermit/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/hermit/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "76ec3ce823e8fedfc49c9e9118285af65b5d86fb",
        "filename": "src/rusty/libc/src/unix/hermit/x86_64.rs",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/hermit/x86_64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/hermit/x86_64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/hermit/x86_64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "1320b16ab21c893553c642c4faadc6a33bfd235d",
        "filename": "src/rusty/libc/src/unix/linux_like/android/b32/arm.rs",
        "status": "added",
        "additions": 357,
        "deletions": 0,
        "changes": 357,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b32/arm.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b32/arm.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/android/b32/arm.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "e5c97e9e002f33e72db19d70635e336c3ad4a88d",
        "filename": "src/rusty/libc/src/unix/linux_like/android/b32/mod.rs",
        "status": "added",
        "additions": 221,
        "deletions": 0,
        "changes": 221,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b32/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b32/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/android/b32/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "04df4a05d19b71c0f18360daf8b8dcd0ce5a4d41",
        "filename": "src/rusty/libc/src/unix/linux_like/android/b32/x86/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b32/x86/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b32/x86/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/android/b32/x86/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "101bf2d51a2d27d9f799d4a72096f0665f0658ae",
        "filename": "src/rusty/libc/src/unix/linux_like/android/b32/x86/mod.rs",
        "status": "added",
        "additions": 422,
        "deletions": 0,
        "changes": 422,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b32/x86/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b32/x86/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/android/b32/x86/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "8e949963a637fb4b171c1a3649cf6c2ef8d30a1d",
        "filename": "src/rusty/libc/src/unix/linux_like/android/b64/aarch64/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b64/aarch64/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b64/aarch64/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/android/b64/aarch64/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "b2b91889a2b2af9350e285e7e311925071ded948",
        "filename": "src/rusty/libc/src/unix/linux_like/android/b64/aarch64/mod.rs",
        "status": "added",
        "additions": 332,
        "deletions": 0,
        "changes": 332,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b64/aarch64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b64/aarch64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/android/b64/aarch64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "9826bb9e38caaae19fd1611b0b1836aeb8de510a",
        "filename": "src/rusty/libc/src/unix/linux_like/android/b64/mod.rs",
        "status": "added",
        "additions": 281,
        "deletions": 0,
        "changes": 281,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/android/b64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "7ca870fd02b71e31e44439e3fabdf1386eb75bb9",
        "filename": "src/rusty/libc/src/unix/linux_like/android/b64/x86_64/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b64/x86_64/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b64/x86_64/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/android/b64/x86_64/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "f5b8b16ea32b596621b3f5db256283fe75c212d7",
        "filename": "src/rusty/libc/src/unix/linux_like/android/b64/x86_64/mod.rs",
        "status": "added",
        "additions": 427,
        "deletions": 0,
        "changes": 427,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b64/x86_64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/b64/x86_64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/android/b64/x86_64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "74c64e5ec73c6640eeaff182a78e394f73552626",
        "filename": "src/rusty/libc/src/unix/linux_like/android/mod.rs",
        "status": "added",
        "additions": 2320,
        "deletions": 0,
        "changes": 2320,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/android/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/android/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "141570f88ffb9c0aa216745722353039ba5dabc7",
        "filename": "src/rusty/libc/src/unix/linux_like/emscripten/align.rs",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/emscripten/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/emscripten/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/emscripten/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "d062b98f41c473968bb32cbab670e387f18d6621",
        "filename": "src/rusty/libc/src/unix/linux_like/emscripten/mod.rs",
        "status": "added",
        "additions": 1909,
        "deletions": 0,
        "changes": 1909,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/emscripten/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/emscripten/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/emscripten/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "768dc73a434f6c5394c360c2561d41b8d5873a83",
        "filename": "src/rusty/libc/src/unix/linux_like/emscripten/no_align.rs",
        "status": "added",
        "additions": 63,
        "deletions": 0,
        "changes": 63,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/emscripten/no_align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/emscripten/no_align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/emscripten/no_align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "440a8415fbec6ca3e7c9fcd1be3922a8377b20af",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/align.rs",
        "status": "added",
        "additions": 102,
        "deletions": 0,
        "changes": 102,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "4a0e07460ebb10fe101ee84406726a5a2ac065a1",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/align.rs",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "825546be90a916c52fa04ba22cb9c7a168daa628",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b32/arm/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/arm/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/arm/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/arm/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "f74b41e315671941d196a81770a8c6b04b74f180",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b32/arm/mod.rs",
        "status": "added",
        "additions": 868,
        "deletions": 0,
        "changes": 868,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/arm/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/arm/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/arm/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "8c228ebab72cec19c6359b5b51d508c21f4f9000",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b32/mips/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/mips/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/mips/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/mips/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "23b0160bffa01082048c654ca27173645188c21d",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b32/mips/mod.rs",
        "status": "added",
        "additions": 900,
        "deletions": 0,
        "changes": 900,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/mips/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/mips/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/mips/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "6f39c208c31d24083ec39abdfef59794fc40025e",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b32/mod.rs",
        "status": "added",
        "additions": 268,
        "deletions": 0,
        "changes": 268,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "92e52333cad18d577aac5df8d6df3ad0088a8252",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b32/powerpc.rs",
        "status": "added",
        "additions": 865,
        "deletions": 0,
        "changes": 865,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/powerpc.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/powerpc.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/powerpc.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "96634749f53b2a7c2f5e21113d5dbd8a92b7f550",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b32/x86/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/x86/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/x86/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/x86/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "05e876067dd89b420de0caacf400771df45b2100",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b32/x86/mod.rs",
        "status": "added",
        "additions": 1156,
        "deletions": 0,
        "changes": 1156,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/x86/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/x86/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b32/x86/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "8e949963a637fb4b171c1a3649cf6c2ef8d30a1d",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b64/aarch64/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/aarch64/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/aarch64/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/aarch64/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "b980a11b191104004b03fb4850e42457f92cc2f4",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b64/aarch64/mod.rs",
        "status": "added",
        "additions": 945,
        "deletions": 0,
        "changes": 945,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/aarch64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/aarch64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/aarch64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "7ca870fd02b71e31e44439e3fabdf1386eb75bb9",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b64/mips64/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/mips64/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/mips64/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/mips64/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "5b3da3cb2dc9093e4438abfa06ee7219d28ff1a2",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b64/mips64/mod.rs",
        "status": "added",
        "additions": 1008,
        "deletions": 0,
        "changes": 1008,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/mips64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/mips64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/mips64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "c91da0d98d1caf01731e1448f82654d6ab7f630b",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b64/mod.rs",
        "status": "added",
        "additions": 84,
        "deletions": 0,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "29d1e1c7b8a5558fcfa3b8ac333cee3fa9784163",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b64/powerpc64/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/powerpc64/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/powerpc64/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/powerpc64/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "bd9089543afdff6ecd0376cca8212ee6de6caef0",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b64/powerpc64/mod.rs",
        "status": "added",
        "additions": 1044,
        "deletions": 0,
        "changes": 1044,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/powerpc64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/powerpc64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/powerpc64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "ac3170416024d1d9dbfa27d9df8d68258b830956",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b64/s390x.rs",
        "status": "added",
        "additions": 1020,
        "deletions": 0,
        "changes": 1020,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/s390x.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/s390x.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/s390x.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "29d1e1c7b8a5558fcfa3b8ac333cee3fa9784163",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b64/sparc64/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/sparc64/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/sparc64/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/sparc64/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "93b1fa53491791faa63ebe25cbfe3aa666b4570c",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b64/sparc64/mod.rs",
        "status": "added",
        "additions": 979,
        "deletions": 0,
        "changes": 979,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/sparc64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/sparc64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/sparc64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "7ca870fd02b71e31e44439e3fabdf1386eb75bb9",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "d1a2294380961e3b086d2402a04bda1d1278e0ce",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/mod.rs",
        "status": "added",
        "additions": 915,
        "deletions": 0,
        "changes": 915,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "64a6de9c67098562fcb73ca37a9c1547d15cecc9",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/not_x32.rs",
        "status": "added",
        "additions": 423,
        "deletions": 0,
        "changes": 423,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/not_x32.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/not_x32.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/not_x32.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "37468818afb85779e6cc74bd727a8dd434cb1f57",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/x32.rs",
        "status": "added",
        "additions": 375,
        "deletions": 0,
        "changes": 375,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/x32.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/x32.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/b64/x86_64/x32.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "6473a041ee6ad6d53846a7c5c1c53875281f602c",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/mod.rs",
        "status": "added",
        "additions": 1050,
        "deletions": 0,
        "changes": 1050,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "e32bf673d140e27b412196ccc9b9554b594e2ea8",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/gnu/no_align.rs",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/no_align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/gnu/no_align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/gnu/no_align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "8e8223cda2933f29cc54bae675f5e403c4c60705",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/mod.rs",
        "status": "added",
        "additions": 3078,
        "deletions": 0,
        "changes": 3078,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "aedbf7a99eb1b18a3f99ffb1746228f2c8d36179",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b32/arm/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/arm/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/arm/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b32/arm/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "fd1e259fc3b5f1b3254b4c11f41d45a23b06c408",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b32/arm/mod.rs",
        "status": "added",
        "additions": 844,
        "deletions": 0,
        "changes": 844,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/arm/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/arm/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b32/arm/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "0e6cc148fab34a14087b5bae2c596500e3cf2b4f",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b32/hexagon.rs",
        "status": "added",
        "additions": 796,
        "deletions": 0,
        "changes": 796,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/hexagon.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/hexagon.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b32/hexagon.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "8c228ebab72cec19c6359b5b51d508c21f4f9000",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b32/mips/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/mips/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/mips/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b32/mips/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "7fdd121a7ac4ba4b474207aa8a3ba503c8997962",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b32/mips/mod.rs",
        "status": "added",
        "additions": 845,
        "deletions": 0,
        "changes": 845,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/mips/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/mips/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b32/mips/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "7cf6da913f9b8b22dabcfbd324a406d879082ded",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b32/mod.rs",
        "status": "added",
        "additions": 65,
        "deletions": 0,
        "changes": 65,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b32/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "6181b1cdc137e4057900e0b93f1524c04725c37e",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b32/powerpc.rs",
        "status": "added",
        "additions": 863,
        "deletions": 0,
        "changes": 863,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/powerpc.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/powerpc.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b32/powerpc.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "79544176a88c92012772362fd005c65a954e7369",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b32/x86/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/x86/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/x86/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b32/x86/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "fb5569200c2d7d9365a0fd6aa52a0da0fbbe0577",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b32/x86/mod.rs",
        "status": "added",
        "additions": 952,
        "deletions": 0,
        "changes": 952,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/x86/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b32/x86/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b32/x86/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "8e949963a637fb4b171c1a3649cf6c2ef8d30a1d",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b64/aarch64/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b64/aarch64/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b64/aarch64/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b64/aarch64/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "8c286d83ccd21f62dcfbcf7d3afd3e79e8ce006a",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b64/aarch64/mod.rs",
        "status": "added",
        "additions": 654,
        "deletions": 0,
        "changes": 654,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b64/aarch64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b64/aarch64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b64/aarch64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "bbdc0105fbf97d74ed56751bf2118021a484adc6",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b64/mips64.rs",
        "status": "added",
        "additions": 753,
        "deletions": 0,
        "changes": 753,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b64/mips64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b64/mips64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b64/mips64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "e6a8fc81fe289d4b28bf9ec400f67fe970a13b4e",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b64/mod.rs",
        "status": "added",
        "additions": 169,
        "deletions": 0,
        "changes": 169,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "5c068feae8cbf0c98abb03efd8aa152187cebc6d",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b64/powerpc64.rs",
        "status": "added",
        "additions": 738,
        "deletions": 0,
        "changes": 738,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b64/powerpc64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b64/powerpc64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b64/powerpc64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "7ca870fd02b71e31e44439e3fabdf1386eb75bb9",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b64/x86_64/align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b64/x86_64/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b64/x86_64/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b64/x86_64/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "e4741a3a19830688cd2d7c29483ffeec6363d7b9",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/b64/x86_64/mod.rs",
        "status": "added",
        "additions": 926,
        "deletions": 0,
        "changes": 926,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b64/x86_64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/b64/x86_64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/b64/x86_64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "7f10a0b39fb0932615945a6b055ddf301caee907",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/musl/mod.rs",
        "status": "added",
        "additions": 434,
        "deletions": 0,
        "changes": 434,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/musl/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/musl/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "016712a9322635f3ab89018fc81a3c4a881f4b12",
        "filename": "src/rusty/libc/src/unix/linux_like/linux/no_align.rs",
        "status": "added",
        "additions": 80,
        "deletions": 0,
        "changes": 80,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/no_align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/linux/no_align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/linux/no_align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "1568e4f8369f1e27e4f4d80c1a094d21bc560270",
        "filename": "src/rusty/libc/src/unix/linux_like/mod.rs",
        "status": "added",
        "additions": 1539,
        "deletions": 0,
        "changes": 1539,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/linux_like/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/linux_like/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "238da24b51e3d111e8135d2ae108813f01eddf55",
        "filename": "src/rusty/libc/src/unix/mod.rs",
        "status": "added",
        "additions": 1552,
        "deletions": 0,
        "changes": 1552,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "7e1b2bb70eb52cf5a0743ee7dd985f603baf3b26",
        "filename": "src/rusty/libc/src/unix/newlib/aarch64/mod.rs",
        "status": "added",
        "additions": 33,
        "deletions": 0,
        "changes": 33,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/newlib/aarch64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/newlib/aarch64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/newlib/aarch64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "db9beb83523c24bdfc693ac3fb187db9c02234bf",
        "filename": "src/rusty/libc/src/unix/newlib/align.rs",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/newlib/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/newlib/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/newlib/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "39cb425fe7f46258247dd282860cef9150cd54b5",
        "filename": "src/rusty/libc/src/unix/newlib/arm/mod.rs",
        "status": "added",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/newlib/arm/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/newlib/arm/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/newlib/arm/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "bd9a10798342ddf7c04da41a4d751f6e4023100a",
        "filename": "src/rusty/libc/src/unix/newlib/mod.rs",
        "status": "added",
        "additions": 725,
        "deletions": 0,
        "changes": 725,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/newlib/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/newlib/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/newlib/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "316c464ed59a89e5bb143723b81f094d45cacf3c",
        "filename": "src/rusty/libc/src/unix/newlib/no_align.rs",
        "status": "added",
        "additions": 51,
        "deletions": 0,
        "changes": 51,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/newlib/no_align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/newlib/no_align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/newlib/no_align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "f6b9f4c12d4bab7e069ff89b08f878362b31d98e",
        "filename": "src/rusty/libc/src/unix/no_align.rs",
        "status": "added",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/no_align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/no_align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/no_align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "b00a191c9b9550fbcda247898a7279bb5800946e",
        "filename": "src/rusty/libc/src/unix/redox/mod.rs",
        "status": "added",
        "additions": 1114,
        "deletions": 0,
        "changes": 1114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/redox/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/redox/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/redox/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "a33645211ce37381d5891e024f8605aab359a33e",
        "filename": "src/rusty/libc/src/unix/solarish/compat.rs",
        "status": "added",
        "additions": 32,
        "deletions": 0,
        "changes": 32,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/solarish/compat.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/solarish/compat.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/solarish/compat.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "eaa43fe9001608c3aafbe88277c30d1c398c5f75",
        "filename": "src/rusty/libc/src/unix/solarish/mod.rs",
        "status": "added",
        "additions": 2301,
        "deletions": 0,
        "changes": 2301,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/solarish/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/solarish/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/solarish/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "76b524d0c08294d66675d1d541ddaa18d62803a4",
        "filename": "src/rusty/libc/src/unix/uclibc/align.rs",
        "status": "added",
        "additions": 66,
        "deletions": 0,
        "changes": 66,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "4a0e07460ebb10fe101ee84406726a5a2ac065a1",
        "filename": "src/rusty/libc/src/unix/uclibc/arm/align.rs",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/arm/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/arm/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/arm/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "41dd7100dfec539fcba551a576fe544ae255af1d",
        "filename": "src/rusty/libc/src/unix/uclibc/arm/mod.rs",
        "status": "added",
        "additions": 1053,
        "deletions": 0,
        "changes": 1053,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/arm/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/arm/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/arm/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "e32bf673d140e27b412196ccc9b9554b594e2ea8",
        "filename": "src/rusty/libc/src/unix/uclibc/arm/no_align.rs",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/arm/no_align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/arm/no_align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/arm/no_align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "4a0e07460ebb10fe101ee84406726a5a2ac065a1",
        "filename": "src/rusty/libc/src/unix/uclibc/mips/mips32/align.rs",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mips/mips32/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mips/mips32/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/mips/mips32/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "31bca589ef2be35b2e3d09efb733af15451b0222",
        "filename": "src/rusty/libc/src/unix/uclibc/mips/mips32/mod.rs",
        "status": "added",
        "additions": 633,
        "deletions": 0,
        "changes": 633,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mips/mips32/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mips/mips32/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/mips/mips32/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "e32bf673d140e27b412196ccc9b9554b594e2ea8",
        "filename": "src/rusty/libc/src/unix/uclibc/mips/mips32/no_align.rs",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mips/mips32/no_align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mips/mips32/no_align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/mips/mips32/no_align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "21e21907d4a70f03de850a8d11f4c093aab1d622",
        "filename": "src/rusty/libc/src/unix/uclibc/mips/mips64/align.rs",
        "status": "added",
        "additions": 10,
        "deletions": 0,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mips/mips64/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mips/mips64/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/mips/mips64/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "735eb851ef7d45435fe4da79d7f5248379a30ef1",
        "filename": "src/rusty/libc/src/unix/uclibc/mips/mips64/mod.rs",
        "status": "added",
        "additions": 213,
        "deletions": 0,
        "changes": 213,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mips/mips64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mips/mips64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/mips/mips64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "8909114cdfa42f6063b2423ce0d7a53d0a943c29",
        "filename": "src/rusty/libc/src/unix/uclibc/mips/mips64/no_align.rs",
        "status": "added",
        "additions": 7,
        "deletions": 0,
        "changes": 7,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mips/mips64/no_align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mips/mips64/no_align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/mips/mips64/no_align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "6a9b41c9f0be954f81da2b92569089d3f39de6d0",
        "filename": "src/rusty/libc/src/unix/uclibc/mips/mod.rs",
        "status": "added",
        "additions": 479,
        "deletions": 0,
        "changes": 479,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mips/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mips/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/mips/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "986b05ca0b527887266a26bb72b0d2ddf940b0ab",
        "filename": "src/rusty/libc/src/unix/uclibc/mod.rs",
        "status": "added",
        "additions": 2273,
        "deletions": 0,
        "changes": 2273,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "a73dbded57ac710d2a78d6ee2cbd141147ae6352",
        "filename": "src/rusty/libc/src/unix/uclibc/no_align.rs",
        "status": "added",
        "additions": 53,
        "deletions": 0,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/no_align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/no_align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/no_align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "583a278d66a0e457bf1e3ace54378126a765ea44",
        "filename": "src/rusty/libc/src/unix/uclibc/x86_64/align.rs",
        "status": "added",
        "additions": 77,
        "deletions": 0,
        "changes": 77,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/x86_64/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/x86_64/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/x86_64/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "16ec0ef9664730fc582b8b9cbf335934214b70d8",
        "filename": "src/rusty/libc/src/unix/uclibc/x86_64/l4re.rs",
        "status": "added",
        "additions": 48,
        "deletions": 0,
        "changes": 48,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/x86_64/l4re.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/x86_64/l4re.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/x86_64/l4re.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "a8bb0794aa1de40e8b2c603f17f095675f457419",
        "filename": "src/rusty/libc/src/unix/uclibc/x86_64/mod.rs",
        "status": "added",
        "additions": 312,
        "deletions": 0,
        "changes": 312,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/x86_64/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/x86_64/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/x86_64/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "422d78fac25caec31a84677e36839c8b749cffbc",
        "filename": "src/rusty/libc/src/unix/uclibc/x86_64/no_align.rs",
        "status": "added",
        "additions": 59,
        "deletions": 0,
        "changes": 59,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/x86_64/no_align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/x86_64/no_align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/x86_64/no_align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "481577cfc27ff0afc18686be60986cff8cff4d50",
        "filename": "src/rusty/libc/src/unix/uclibc/x86_64/other.rs",
        "status": "added",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/x86_64/other.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/unix/uclibc/x86_64/other.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/unix/uclibc/x86_64/other.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "4032488b6c0d5b1128fad52fabe5faaf80add3c4",
        "filename": "src/rusty/libc/src/vxworks/aarch64.rs",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/vxworks/aarch64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/vxworks/aarch64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/vxworks/aarch64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "55240068aa08eb7992d9adc49739f44679207b8b",
        "filename": "src/rusty/libc/src/vxworks/arm.rs",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/vxworks/arm.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/vxworks/arm.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/vxworks/arm.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "cc7525c31ccf8103b1424533175a8558cf33d6b4",
        "filename": "src/rusty/libc/src/vxworks/mod.rs",
        "status": "added",
        "additions": 2226,
        "deletions": 0,
        "changes": 2226,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/vxworks/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/vxworks/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/vxworks/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "55240068aa08eb7992d9adc49739f44679207b8b",
        "filename": "src/rusty/libc/src/vxworks/powerpc.rs",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/vxworks/powerpc.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/vxworks/powerpc.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/vxworks/powerpc.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "4032488b6c0d5b1128fad52fabe5faaf80add3c4",
        "filename": "src/rusty/libc/src/vxworks/powerpc64.rs",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/vxworks/powerpc64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/vxworks/powerpc64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/vxworks/powerpc64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "e617bb83c6ce342761d36dade9d591486f264521",
        "filename": "src/rusty/libc/src/vxworks/x86.rs",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/vxworks/x86.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/vxworks/x86.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/vxworks/x86.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "5e95ea2567ddfe80fd88feb2aaecf70697f06d99",
        "filename": "src/rusty/libc/src/vxworks/x86_64.rs",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/vxworks/x86_64.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/vxworks/x86_64.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/vxworks/x86_64.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "2e0914dcadcb1b53ffcad29f8299b377217b26fe",
        "filename": "src/rusty/libc/src/wasi.rs",
        "status": "added",
        "additions": 743,
        "deletions": 0,
        "changes": 743,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/wasi.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/wasi.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/wasi.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "3af99e3ca149bf53fa803e05bb15f02f6f60a6e1",
        "filename": "src/rusty/libc/src/windows/gnu/align.rs",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/windows/gnu/align.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/windows/gnu/align.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/windows/gnu/align.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "e74628b981e2fe750cb4d0c34c2151446f413fc1",
        "filename": "src/rusty/libc/src/windows/gnu/mod.rs",
        "status": "added",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/windows/gnu/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/windows/gnu/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/windows/gnu/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "ba80e0ca0f6c8caec667f9e330fc92d4ff296788",
        "filename": "src/rusty/libc/src/windows/mod.rs",
        "status": "added",
        "additions": 554,
        "deletions": 0,
        "changes": 554,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/windows/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/windows/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/windows/mod.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      },
      {
        "sha": "27333ae2ecd993687a689317dcf52983f907e3cb",
        "filename": "src/rusty/libc/src/windows/msvc.rs",
        "status": "added",
        "additions": 13,
        "deletions": 0,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/windows/msvc.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b/src/rusty/libc/src/windows/msvc.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/libc/src/windows/msvc.rs?ref=ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      }
    ]
  },
  {
    "sha": "6bbb67abdddab9ca453baa0778f06472a31435e1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2YmJiNjdhYmRkZGFiOWNhNDUzYmFhMDc3OGYwNjQ3MmEzMTQzNWUx",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-17T21:55:28Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "(XXX: subtree me) Add rust-bitcoin and deps",
      "tree": {
        "sha": "1184204197a141111990dce9c835acefdc1f42cb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/1184204197a141111990dce9c835acefdc1f42cb"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6bbb67abdddab9ca453baa0778f06472a31435e1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6bbb67abdddab9ca453baa0778f06472a31435e1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6bbb67abdddab9ca453baa0778f06472a31435e1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6bbb67abdddab9ca453baa0778f06472a31435e1/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/ca3ddddc09fa3bdc5bca7e7fa1ac898567ae9f0b"
      }
    ],
    "stats": {
      "total": 51476,
      "additions": 51476,
      "deletions": 0
    },
    "files": [
      {
        "sha": "9c7fe81ce70d80fc2755753fcef226394027fc57",
        "filename": "src/rusty/bitcoin_hashes/CHANGELOG.md",
        "status": "added",
        "additions": 53,
        "deletions": 0,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/CHANGELOG.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/CHANGELOG.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/CHANGELOG.md?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,53 @@\n+# 0.7.0 - 2019-07-19\n+\n+* Add `hex::Error` type for errors generated by the `hex` module.\n+\n+# 0.6.0 - 2019-07-10\n+\n+* Add `no_std` support, rearrange traits to not depend on `io::Write`\n+\n+# 0.5.0 - 2019-06-28\n+\n+* Fix panic when parsing hashes that contain multibyte characters\n+* Add `FromStr` to all hashes which hex-parses them\n+\n+# 0.4.0 - 2019-06-23\n+\n+* [Add `from_inner` method](https://github.com/rust-bitcoin/bitcoin_hashes/pull/20) to all hashes\n+* [Update `FromHex` trait](https://github.com/rust-bitcoin/bitcoin_hashes/pull/40) to require `from_byte_iter` method rather than `from_hex` be implemented\n+* Make `Hmac` midstate [an actual HMAC midstate](https://github.com/rust-bitcoin/bitcoin_hashes/pull/43)\n+* Allow `Display` [of truncated hashes](https://github.com/rust-bitcoin/bitcoin_hashes/pull/9)\n+* Require [using a constructor for `HexIterator`](https://github.com/rust-bitcoin/bitcoin_hashes/pull/44) and then [clean up the internals](https://github.com/rust-bitcoin/bitcoin_hashes/pull/47)\n+* [Strongly type `sha256::Midstate`](https://github.com/rust-bitcoin/bitcoin_hashes/pull/39) to allow independent serialization\n+* Add [siphash24 module](https://github.com/rust-bitcoin/bitcoin_hashes/pull/46)\n+\n+# 0.3.2 - 2019-03-20\n+\n+* Implement the `FromHex` trait on [many more types](https://github.com/rust-bitcoin/bitcoin_hashes/pull/38)\n+\n+# 0.3.1 - 2019-03-04\n+\n+* [Fix serde serialization](https://github.com/rust-bitcoin/bitcoin_hashes/pull/36)\n+\n+# 0.3.0 - 2019-01-23\n+\n+* Bump minimum required rustc version to 1.22.0\n+* Fixed serde deserialization into owned string that previously caused panics\n+  when doing round-trip (de)serialization\n+* `HashEngine::block_size()` and `Hash::len()` are now associated constants\n+  `HashEngine::BLOCK_SIZE` and `Hash::LEN`\n+* Removed `block_size()` method from `Hash` trait. It is still available as\n+  `<T as Hash>::Engine::BLOCK_SIZE`\n+\n+# 0.2.0 - 2019-01-15\n+\n+* Add a constant-time comparison function\n+* Simplify `io::Write::write` implementations by having them do only partial writes\n+* Add fuzzing support\n+* Allow `Hash`es to be borrowed as `[u8]`\n+* Replace public `Hash` inners with `into_inner` method\n+\n+# 0.1.0 - 2018-12-08\n+\n+* Initial release\n+"
      },
      {
        "sha": "23d920ebc3bfe5c500d854a4c310091ebd2b46dc",
        "filename": "src/rusty/bitcoin_hashes/Cargo.toml",
        "status": "added",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/Cargo.toml?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,30 @@\n+[package]\n+name = \"bitcoin_hashes\"\n+version = \"0.7.0\"\n+authors = [\"Andrew Poelstra <apoelstra@wpsoftware.net>\"]\n+license = \"CC0-1.0\"\n+description = \"Hash functions used by rust-bitcoin which support rustc 1.14.0\"\n+documentation = \"https://docs.rs/bitcoin_hashes/\"\n+keywords = [ \"crypto\", \"bitcoin\", \"hash\", \"digest\" ]\n+readme = \"README.md\"\n+\n+[lib]\n+name = \"bitcoin_hashes\"\n+path = \"src/lib.rs\"\n+\n+[features]\n+default = [ \"std\" ]\n+std = []\n+serde-std = [\"serde/std\"]\n+unstable = []  # for benchmarking\n+fuzztarget = [] # used by other rust-bitcoin projects to make hashes almost-noops, DON'T USE THIS\n+\n+[dev-dependencies]\n+serde_test = \"1.0\"\n+\n+[dependencies]\n+\n+[dependencies.serde]\n+version = \"1.0\"\n+optional = true\n+default-features = false"
      },
      {
        "sha": "6ca207ef004cb69d03041e7e5c288a2be4968045",
        "filename": "src/rusty/bitcoin_hashes/LICENSE",
        "status": "added",
        "additions": 122,
        "deletions": 0,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/LICENSE",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/LICENSE",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/LICENSE?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,122 @@\n+Creative Commons Legal Code\n+\n+CC0 1.0 Universal\n+\n+    CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE\n+    LEGAL SERVICES. DISTRIBUTION OF THIS DOCUMENT DOES NOT CREATE AN\n+    ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS\n+    INFORMATION ON AN \"AS-IS\" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES\n+    REGARDING THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS\n+    PROVIDED HEREUNDER, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM\n+    THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS PROVIDED\n+    HEREUNDER.\n+\n+Statement of Purpose\n+\n+The laws of most jurisdictions throughout the world automatically confer\n+exclusive Copyright and Related Rights (defined below) upon the creator\n+and subsequent owner(s) (each and all, an \"owner\") of an original work of\n+authorship and/or a database (each, a \"Work\").\n+\n+Certain owners wish to permanently relinquish those rights to a Work for\n+the purpose of contributing to a commons of creative, cultural and\n+scientific works (\"Commons\") that the public can reliably and without fear\n+of later claims of infringement build upon, modify, incorporate in other\n+works, reuse and redistribute as freely as possible in any form whatsoever\n+and for any purposes, including without limitation commercial purposes.\n+These owners may contribute to the Commons to promote the ideal of a free\n+culture and the further production of creative, cultural and scientific\n+works, or to gain reputation or greater distribution for their Work in\n+part through the use and efforts of others.\n+\n+For these and/or other purposes and motivations, and without any\n+expectation of additional consideration or compensation, the person\n+associating CC0 with a Work (the \"Affirmer\"), to the extent that he or she\n+is an owner of Copyright and Related Rights in the Work, voluntarily\n+elects to apply CC0 to the Work and publicly distribute the Work under its\n+terms, with knowledge of his or her Copyright and Related Rights in the\n+Work and the meaning and intended legal effect of CC0 on those rights.\n+\n+1. Copyright and Related Rights. A Work made available under CC0 may be\n+protected by copyright and related or neighboring rights (\"Copyright and\n+Related Rights\"). Copyright and Related Rights include, but are not\n+limited to, the following:\n+\n+  i. the right to reproduce, adapt, distribute, perform, display,\n+     communicate, and translate a Work;\n+ ii. moral rights retained by the original author(s) and/or performer(s);\n+iii. publicity and privacy rights pertaining to a person's image or\n+     likeness depicted in a Work;\n+ iv. rights protecting against unfair competition in regards to a Work,\n+     subject to the limitations in paragraph 4(a), below;\n+  v. rights protecting the extraction, dissemination, use and reuse of data\n+     in a Work;\n+ vi. database rights (such as those arising under Directive 96/9/EC of the\n+     European Parliament and of the Council of 11 March 1996 on the legal\n+     protection of databases, and under any national implementation\n+     thereof, including any amended or successor version of such\n+     directive); and\n+vii. other similar, equivalent or corresponding rights throughout the\n+     world based on applicable law or treaty, and any national\n+     implementations thereof.\n+\n+2. Waiver. To the greatest extent permitted by, but not in contravention\n+of, applicable law, Affirmer hereby overtly, fully, permanently,\n+irrevocably and unconditionally waives, abandons, and surrenders all of\n+Affirmer's Copyright and Related Rights and associated claims and causes\n+of action, whether now known or unknown (including existing as well as\n+future claims and causes of action), in the Work (i) in all territories\n+worldwide, (ii) for the maximum duration provided by applicable law or\n+treaty (including future time extensions), (iii) in any current or future\n+medium and for any number of copies, and (iv) for any purpose whatsoever,\n+including without limitation commercial, advertising or promotional\n+purposes (the \"Waiver\"). Affirmer makes the Waiver for the benefit of each\n+member of the public at large and to the detriment of Affirmer's heirs and\n+successors, fully intending that such Waiver shall not be subject to\n+revocation, rescission, cancellation, termination, or any other legal or\n+equitable action to disrupt the quiet enjoyment of the Work by the public\n+as contemplated by Affirmer's express Statement of Purpose.\n+\n+3. Public License Fallback. Should any part of the Waiver for any reason\n+be judged legally invalid or ineffective under applicable law, then the\n+Waiver shall be preserved to the maximum extent permitted taking into\n+account Affirmer's express Statement of Purpose. In addition, to the\n+extent the Waiver is so judged Affirmer hereby grants to each affected\n+person a royalty-free, non transferable, non sublicensable, non exclusive,\n+irrevocable and unconditional license to exercise Affirmer's Copyright and\n+Related Rights in the Work (i) in all territories worldwide, (ii) for the\n+maximum duration provided by applicable law or treaty (including future\n+time extensions), (iii) in any current or future medium and for any number\n+of copies, and (iv) for any purpose whatsoever, including without\n+limitation commercial, advertising or promotional purposes (the\n+\"License\"). The License shall be deemed effective as of the date CC0 was\n+applied by Affirmer to the Work. Should any part of the License for any\n+reason be judged legally invalid or ineffective under applicable law, such\n+partial invalidity or ineffectiveness shall not invalidate the remainder\n+of the License, and in such case Affirmer hereby affirms that he or she\n+will not (i) exercise any of his or her remaining Copyright and Related\n+Rights in the Work or (ii) assert any associated claims and causes of\n+action with respect to the Work, in either case contrary to Affirmer's\n+express Statement of Purpose.\n+\n+4. Limitations and Disclaimers.\n+\n+ a. No trademark or patent rights held by Affirmer are waived, abandoned,\n+    surrendered, licensed or otherwise affected by this document.\n+ b. Affirmer offers the Work as-is and makes no representations or\n+    warranties of any kind concerning the Work, express, implied,\n+    statutory or otherwise, including without limitation warranties of\n+    title, merchantability, fitness for a particular purpose, non\n+    infringement, or the absence of latent or other defects, accuracy, or\n+    the present or absence of errors, whether or not discoverable, all to\n+    the greatest extent permissible under applicable law.\n+ c. Affirmer disclaims responsibility for clearing rights of other persons\n+    that may apply to the Work or any use thereof, including without\n+    limitation any person's Copyright and Related Rights in the Work.\n+    Further, Affirmer disclaims responsibility for obtaining any necessary\n+    consents, permissions or other rights required for any use of the\n+    Work.\n+ d. Affirmer understands and acknowledges that Creative Commons is not a\n+    party to this document and has no duty or obligation with respect to\n+    this CC0 or use of the Work.\n+"
      },
      {
        "sha": "a97c04a417e1e253c12a5c48b43af8c54c07cf1e",
        "filename": "src/rusty/bitcoin_hashes/README.md",
        "status": "added",
        "additions": 17,
        "deletions": 0,
        "changes": 17,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/README.md?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,17 @@\n+[![Status](https://travis-ci.org/rust-bitcoin/bitcoin_hashes.png?branch=master)](https://travis-ci.org/rust-bitcoin/bitcoin_hashes)\n+\n+# Bitcoin Hashes Library\n+\n+This is a simple, no-dependency library which implements the hash functions\n+needed by Bitcoin. These are SHA1, SHA256, SHA256d, and RIPEMD160. As an\n+ancilliary thing, it exposes hexadecimal serialization and deserialization,\n+since these are needed to display hashes anway.\n+\n+Ok, there is one dependency -- `byteorder` -- which is used to manage endianness.\n+\n+[Documentation](https://docs.rs/bitcoin_hashes/)\n+\n+## Contributions\n+\n+Contributions are welcome, including additional hash function implementations.\n+"
      },
      {
        "sha": "506ae0a46b76f17b52d56a22208aea97c455041e",
        "filename": "src/rusty/bitcoin_hashes/fuzz/Cargo.toml",
        "status": "added",
        "additions": 50,
        "deletions": 0,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/fuzz/Cargo.toml?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,50 @@\n+[package]\n+name = \"bitcoin_hashes-fuzz\"\n+version = \"0.0.1\"\n+authors = [\"copied from rust-bitcoin\"]\n+publish = false\n+\n+[package.metadata]\n+cargo-fuzz = true\n+\n+[features]\n+honggfuzz_fuzz = [\"honggfuzz\"]\n+\n+[dependencies]\n+honggfuzz = { version = \"0.5\", optional = true }\n+bitcoin_hashes = { path = \"..\", features = [\"serde\"] }\n+rust-crypto = \"0.2\"\n+\n+serde = \"1.0\"\n+serde_derive = \"1.0\"\n+serde_json = \"1.0\"\n+serde_cbor = \"0.9\"\n+\n+# Prevent this from interfering with workspaces\n+[workspace]\n+members = [\".\"]\n+\n+[[bin]]\n+name = \"sha1\"\n+path = \"fuzz_targets/sha1.rs\"\n+\n+[[bin]]\n+name = \"ripemd160\"\n+path = \"fuzz_targets/ripemd160.rs\"\n+\n+[[bin]]\n+name = \"sha256\"\n+path = \"fuzz_targets/sha256.rs\"\n+\n+[[bin]]\n+name = \"sha512\"\n+path = \"fuzz_targets/sha512.rs\"\n+\n+[[bin]]\n+name = \"cbor\"\n+path = \"fuzz_targets/cbor.rs\"\n+\n+[[bin]]\n+name = \"json\"\n+path = \"fuzz_targets/json.rs\"\n+"
      },
      {
        "sha": "50b04cb8999607d800a18d34f34ccb179433bb21",
        "filename": "src/rusty/bitcoin_hashes/fuzz/fuzz_targets/cbor.rs",
        "status": "added",
        "additions": 67,
        "deletions": 0,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/cbor.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/cbor.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/cbor.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,67 @@\n+\n+extern crate serde;\n+#[macro_use] extern crate serde_derive;\n+extern crate bitcoin_hashes;\n+extern crate serde_cbor;\n+\n+use bitcoin_hashes::Hmac;\n+use bitcoin_hashes::{sha1, sha512, ripemd160, sha256d};\n+\n+#[derive(Deserialize, Serialize)]\n+struct Hmacs {\n+    sha1: Hmac<sha1::Hash>,\n+    sha512: Hmac<sha512::Hash>,\n+}\n+\n+#[derive(Deserialize, Serialize)]\n+struct Main {\n+    hmacs: Hmacs,\n+    ripemd: ripemd160::Hash,\n+    sha2d: sha256d::Hash,\n+}\n+\n+fn do_test(data: &[u8]) {\n+    if let Ok(m) = serde_cbor::from_slice::<Main>(data) {\n+        let vec = serde_cbor::to_vec(&m).unwrap();\n+        assert_eq!(data, &vec[..]);\n+    }\n+}\n+\n+#[cfg(feature=\"honggfuzz\")]\n+#[macro_use]\n+extern crate honggfuzz;\n+\n+#[cfg(feature=\"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|d| { do_test(d) });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"00000\", &mut a);\n+        super::do_test(&a);\n+    }\n+}\n+"
      },
      {
        "sha": "3b45c783a63e1a2cc0222489ac805686a62bac98",
        "filename": "src/rusty/bitcoin_hashes/fuzz/fuzz_targets/json.rs",
        "status": "added",
        "additions": 67,
        "deletions": 0,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/json.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/json.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/json.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,67 @@\n+\n+extern crate serde;\n+#[macro_use] extern crate serde_derive;\n+extern crate bitcoin_hashes;\n+extern crate serde_json;\n+\n+use bitcoin_hashes::Hmac;\n+use bitcoin_hashes::{sha1, sha512, ripemd160, sha256d};\n+\n+#[derive(Deserialize, Serialize)]\n+struct Hmacs {\n+    sha1: Hmac<sha1::Hash>,\n+    sha512: Hmac<sha512::Hash>,\n+}\n+\n+#[derive(Deserialize, Serialize)]\n+struct Main {\n+    hmacs: Hmacs,\n+    ripemd: ripemd160::Hash,\n+    sha2d: sha256d::Hash,\n+}\n+\n+fn do_test(data: &[u8]) {\n+    if let Ok(m) = serde_json::from_slice::<Main>(data) {\n+        let vec = serde_json::to_vec(&m).unwrap();\n+        assert_eq!(data, &vec[..]);\n+    }\n+}\n+\n+#[cfg(feature=\"honggfuzz\")]\n+#[macro_use]\n+extern crate honggfuzz;\n+\n+#[cfg(feature=\"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|d| { do_test(d) });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"00000\", &mut a);\n+        super::do_test(&a);\n+    }\n+}\n+"
      },
      {
        "sha": "f4a4606a8f86f57f2dd812e1dd7de202c5818e6c",
        "filename": "src/rusty/bitcoin_hashes/fuzz/fuzz_targets/ripemd160.rs",
        "status": "added",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/ripemd160.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/ripemd160.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/ripemd160.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,58 @@\n+\n+extern crate bitcoin_hashes;\n+extern crate crypto;\n+\n+use bitcoin_hashes::Hash;\n+use bitcoin_hashes::ripemd160;\n+use crypto::digest::Digest;\n+use crypto::ripemd160::Ripemd160;\n+\n+fn do_test(data: &[u8]) {\n+    let our_hash = ripemd160::Hash::hash(data);\n+\n+    let mut rc_hash = [0u8; 20];\n+    let mut rc_engine = Ripemd160::new();\n+    rc_engine.input(data);\n+    rc_engine.result(&mut rc_hash);\n+\n+    assert_eq!(&our_hash[..], &rc_hash[..]);\n+}\n+\n+#[cfg(feature=\"honggfuzz\")]\n+#[macro_use]\n+extern crate honggfuzz;\n+\n+#[cfg(feature=\"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|d| { do_test(d) });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"00000\", &mut a);\n+        super::do_test(&a);\n+    }\n+}\n+"
      },
      {
        "sha": "8b570594704bf84c0a84a82bf56456b6e9590096",
        "filename": "src/rusty/bitcoin_hashes/fuzz/fuzz_targets/sha1.rs",
        "status": "added",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/sha1.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/sha1.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/sha1.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,58 @@\n+\n+extern crate bitcoin_hashes;\n+extern crate crypto;\n+\n+use bitcoin_hashes::Hash;\n+use bitcoin_hashes::sha1;\n+use crypto::digest::Digest;\n+use crypto::sha1::Sha1;\n+\n+fn do_test(data: &[u8]) {\n+    let our_hash = sha1::Hash::hash(data);\n+\n+    let mut rc_hash = [0u8; 20];\n+    let mut rc_sha1 = Sha1::new();\n+    rc_sha1.input(data);\n+    rc_sha1.result(&mut rc_hash);\n+\n+    assert_eq!(&our_hash[..], &rc_hash[..]);\n+}\n+\n+#[cfg(feature=\"honggfuzz\")]\n+#[macro_use]\n+extern crate honggfuzz;\n+\n+#[cfg(feature=\"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|d| { do_test(d) });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"00000\", &mut a);\n+        super::do_test(&a);\n+    }\n+}\n+"
      },
      {
        "sha": "c4d1852c8b9488e95dae43f80ce0f56015110444",
        "filename": "src/rusty/bitcoin_hashes/fuzz/fuzz_targets/sha256.rs",
        "status": "added",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/sha256.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/sha256.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/sha256.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,58 @@\n+\n+extern crate bitcoin_hashes;\n+extern crate crypto;\n+\n+use bitcoin_hashes::Hash;\n+use bitcoin_hashes::sha256;\n+use crypto::digest::Digest;\n+use crypto::sha2::Sha256;\n+\n+fn do_test(data: &[u8]) {\n+    let our_hash = sha256::Hash::hash(data);\n+\n+    let mut rc_hash = [0u8; 32];\n+    let mut rc_engine = Sha256::new();\n+    rc_engine.input(data);\n+    rc_engine.result(&mut rc_hash);\n+\n+    assert_eq!(&our_hash[..], &rc_hash[..]);\n+}\n+\n+#[cfg(feature=\"honggfuzz\")]\n+#[macro_use]\n+extern crate honggfuzz;\n+\n+#[cfg(feature=\"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|d| { do_test(d) });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"00000\", &mut a);\n+        super::do_test(&a);\n+    }\n+}\n+"
      },
      {
        "sha": "a0799d246fc66577c6792342a98cb544d580b909",
        "filename": "src/rusty/bitcoin_hashes/fuzz/fuzz_targets/sha512.rs",
        "status": "added",
        "additions": 58,
        "deletions": 0,
        "changes": 58,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/sha512.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/sha512.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/fuzz/fuzz_targets/sha512.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,58 @@\n+\n+extern crate bitcoin_hashes;\n+extern crate crypto;\n+\n+use bitcoin_hashes::Hash;\n+use bitcoin_hashes::sha512;\n+use crypto::digest::Digest;\n+use crypto::sha2::Sha512;\n+\n+fn do_test(data: &[u8]) {\n+    let our_hash = sha512::Hash::hash(data);\n+\n+    let mut rc_hash = [0u8; 64];\n+    let mut rc_engine = Sha512::new();\n+    rc_engine.input(data);\n+    rc_engine.result(&mut rc_hash);\n+\n+    assert_eq!(&our_hash[..], &rc_hash[..]);\n+}\n+\n+#[cfg(feature=\"honggfuzz\")]\n+#[macro_use]\n+extern crate honggfuzz;\n+\n+#[cfg(feature=\"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|d| { do_test(d) });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"00000\", &mut a);\n+        super::do_test(&a);\n+    }\n+}\n+"
      },
      {
        "sha": "aebd1aa4623c61c3751c4d51eb15e4f09e35e3c0",
        "filename": "src/rusty/bitcoin_hashes/fuzz/travis-fuzz.sh",
        "status": "added",
        "additions": 22,
        "deletions": 0,
        "changes": 22,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/travis-fuzz.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/fuzz/travis-fuzz.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/fuzz/travis-fuzz.sh?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,22 @@\n+#!/bin/bash\n+set -e\n+cargo install --force honggfuzz\n+for TARGET in fuzz_targets/*; do\n+    FILENAME=$(basename $TARGET)\n+\tFILE=\"${FILENAME%.*}\"\n+\tif [ -d hfuzz_input/$FILE ]; then\n+\t    HFUZZ_INPUT_ARGS=\"-f hfuzz_input/$FILE/input\"\n+\tfi\n+\n+        rm -f hfuzz_workspace/$FILE/HONGGFUZZ.REPORT.TXT\n+\n+\tHFUZZ_BUILD_ARGS=\"--features honggfuzz_fuzz\" HFUZZ_RUN_ARGS=\"-N1000000 --exit_upon_crash -v $HFUZZ_INPUT_ARGS\" cargo hfuzz run $FILE\n+\n+\tif [ -f hfuzz_workspace/$FILE/HONGGFUZZ.REPORT.TXT ]; then\n+\t\tcat hfuzz_workspace/$FILE/HONGGFUZZ.REPORT.TXT\n+\t\tfor CASE in hfuzz_workspace/$FILE/SIG*; do\n+\t\t\tcat $CASE | xxd -p\n+\t\tdone\n+\t\texit 1\n+\tfi\n+done"
      },
      {
        "sha": "6a37119328fe94d4de11b0a665a9491b48be56c8",
        "filename": "src/rusty/bitcoin_hashes/src/cmp.rs",
        "status": "added",
        "additions": 162,
        "deletions": 0,
        "changes": 162,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/cmp.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/cmp.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/src/cmp.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,162 @@\n+//! Useful comparison functions.\n+\n+/// Compare two slices for equality in fixed time. Panics if the slices are of non-equal length.\n+///\n+/// This works by XOR'ing each byte of the two inputs together and keeping an OR counter of the\n+/// results.\n+///\n+/// Instead of doing fancy bit twiddling to try to outsmart the compiler and prevent early exits,\n+/// which is not guaranteed to remain stable as compilers get ever smarter, we take the hit of\n+/// writing each intermediate value to memory with a volatile write and then re-reading it with a\n+/// volatile read. This should remain stable across compiler upgrades, but is much slower.\n+///\n+/// As of rust 1.31.0 disassembly looks completely within reason for this, see\n+/// https://godbolt.org/z/mMbGQv\n+pub fn fixed_time_eq(a: &[u8], b: &[u8]) -> bool {\n+    assert!(a.len() == b.len());\n+    let count = a.len();\n+    let lhs = &a[..count];\n+    let rhs = &b[..count];\n+\n+    let mut r: u8 = 0;\n+    for i in 0..count {\n+        let mut rs = unsafe { ::core::ptr::read_volatile(&r) };\n+        rs |= lhs[i] ^ rhs[i];\n+        unsafe { ::core::ptr::write_volatile(&mut r, rs); }\n+    }\n+    {\n+        let mut t = unsafe { ::core::ptr::read_volatile(&r) };\n+        t |= t >> 4;\n+        unsafe { ::core::ptr::write_volatile(&mut r, t); }\n+    }\n+    {\n+        let mut t = unsafe { ::core::ptr::read_volatile(&r) };\n+        t |= t >> 2;\n+        unsafe { ::core::ptr::write_volatile(&mut r, t); }\n+    }\n+    {\n+        let mut t = unsafe { ::core::ptr::read_volatile(&r) };\n+        t |= t >> 1;\n+        unsafe { ::core::ptr::write_volatile(&mut r, t); }\n+    }\n+    unsafe { (::core::ptr::read_volatile(&r) & 1) == 0 }\n+}\n+\n+#[test]\n+fn eq_test() {\n+    assert!( fixed_time_eq(&[0b00000000], &[0b00000000]));\n+    assert!( fixed_time_eq(&[0b00000001], &[0b00000001]));\n+    assert!( fixed_time_eq(&[0b00000010], &[0b00000010]));\n+    assert!( fixed_time_eq(&[0b00000100], &[0b00000100]));\n+    assert!( fixed_time_eq(&[0b00001000], &[0b00001000]));\n+    assert!( fixed_time_eq(&[0b00010000], &[0b00010000]));\n+    assert!( fixed_time_eq(&[0b00100000], &[0b00100000]));\n+    assert!( fixed_time_eq(&[0b01000000], &[0b01000000]));\n+    assert!( fixed_time_eq(&[0b10000000], &[0b10000000]));\n+    assert!( fixed_time_eq(&[0b11111111], &[0b11111111]));\n+\n+    assert!(!fixed_time_eq(&[0b00000001], &[0b00000000]));\n+    assert!(!fixed_time_eq(&[0b00000001], &[0b11111111]));\n+    assert!(!fixed_time_eq(&[0b00000010], &[0b00000000]));\n+    assert!(!fixed_time_eq(&[0b00000010], &[0b11111111]));\n+    assert!(!fixed_time_eq(&[0b00000100], &[0b00000000]));\n+    assert!(!fixed_time_eq(&[0b00000100], &[0b11111111]));\n+    assert!(!fixed_time_eq(&[0b00001000], &[0b00000000]));\n+    assert!(!fixed_time_eq(&[0b00001000], &[0b11111111]));\n+    assert!(!fixed_time_eq(&[0b00010000], &[0b00000000]));\n+    assert!(!fixed_time_eq(&[0b00010000], &[0b11111111]));\n+    assert!(!fixed_time_eq(&[0b00100000], &[0b00000000]));\n+    assert!(!fixed_time_eq(&[0b00100000], &[0b11111111]));\n+    assert!(!fixed_time_eq(&[0b01000000], &[0b00000000]));\n+    assert!(!fixed_time_eq(&[0b01000000], &[0b11111111]));\n+    assert!(!fixed_time_eq(&[0b10000000], &[0b00000000]));\n+    assert!(!fixed_time_eq(&[0b10000000], &[0b11111111]));\n+\n+    assert!( fixed_time_eq(&[0b00000000, 0b00000000], &[0b00000000, 0b00000000]));\n+    assert!(!fixed_time_eq(&[0b00000001, 0b00000000], &[0b00000000, 0b00000000]));\n+    assert!(!fixed_time_eq(&[0b00000000, 0b00000001], &[0b00000000, 0b00000000]));\n+    assert!(!fixed_time_eq(&[0b00000000, 0b00000000], &[0b00000001, 0b00000000]));\n+    assert!(!fixed_time_eq(&[0b00000000, 0b00000000], &[0b00000001, 0b00000001]));\n+}\n+\n+#[cfg(all(test, feature=\"unstable\"))]\n+mod benches {\n+    use test::Bencher;\n+\n+    use sha256;\n+    use sha512;\n+    use Hash;\n+    use cmp::fixed_time_eq;\n+\n+    #[bench]\n+    fn bench_32b_constant_time_cmp_ne(bh: &mut Bencher) {\n+        let hash_a = sha256::Hash::hash(&[0; 1]);\n+        let hash_b = sha256::Hash::hash(&[1; 1]);\n+        bh.iter(|| {\n+            fixed_time_eq(&hash_a[..], &hash_b[..])\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_32b_slice_cmp_ne(bh: &mut Bencher) {\n+        let hash_a = sha256::Hash::hash(&[0; 1]);\n+        let hash_b = sha256::Hash::hash(&[1; 1]);\n+        bh.iter(|| {\n+            &hash_a[..] == &hash_b[..]\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_32b_constant_time_cmp_eq(bh: &mut Bencher) {\n+        let hash_a = sha256::Hash::hash(&[0; 1]);\n+        let hash_b = sha256::Hash::hash(&[0; 1]);\n+        bh.iter(|| {\n+            fixed_time_eq(&hash_a[..], &hash_b[..])\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_32b_slice_cmp_eq(bh: &mut Bencher) {\n+        let hash_a = sha256::Hash::hash(&[0; 1]);\n+        let hash_b = sha256::Hash::hash(&[0; 1]);\n+        bh.iter(|| {\n+            &hash_a[..] == &hash_b[..]\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_64b_constant_time_cmp_ne(bh: &mut Bencher) {\n+        let hash_a = sha512::Hash::hash(&[0; 1]);\n+        let hash_b = sha512::Hash::hash(&[1; 1]);\n+        bh.iter(|| {\n+            fixed_time_eq(&hash_a[..], &hash_b[..])\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_64b_slice_cmp_ne(bh: &mut Bencher) {\n+        let hash_a = sha512::Hash::hash(&[0; 1]);\n+        let hash_b = sha512::Hash::hash(&[1; 1]);\n+        bh.iter(|| {\n+            &hash_a[..] == &hash_b[..]\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_64b_constant_time_cmp_eq(bh: &mut Bencher) {\n+        let hash_a = sha512::Hash::hash(&[0; 1]);\n+        let hash_b = sha512::Hash::hash(&[0; 1]);\n+        bh.iter(|| {\n+            fixed_time_eq(&hash_a[..], &hash_b[..])\n+        })\n+    }\n+\n+    #[bench]\n+    fn bench_64b_slice_cmp_eq(bh: &mut Bencher) {\n+        let hash_a = sha512::Hash::hash(&[0; 1]);\n+        let hash_b = sha512::Hash::hash(&[0; 1]);\n+        bh.iter(|| {\n+            &hash_a[..] == &hash_b[..]\n+        })\n+    }\n+}"
      },
      {
        "sha": "2d033291d36dc02d0cc91263d7a02e74a6f14d00",
        "filename": "src/rusty/bitcoin_hashes/src/error.rs",
        "status": "added",
        "additions": 34,
        "deletions": 0,
        "changes": 34,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/error.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/error.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/src/error.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,34 @@\n+// Bitcoin Hashes Library\n+// Written in 2018 by\n+//   Andrew Poelstra <apoelstra@wpsoftware.net>\n+//\n+// To the extent possible under law, the author(s) have dedicated all\n+// copyright and related and neighboring rights to this software to\n+// the public domain worldwide. This software is distributed without\n+// any warranty.\n+//\n+// You should have received a copy of the CC0 Public Domain Dedication\n+// along with this software.\n+// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n+//\n+\n+//! # Error Type\n+//!\n+\n+use core::fmt;\n+\n+/// [bitcoin_hashes] error.\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum Error {\n+    /// Tried to create a fixed-length hash from a slice with the wrong size (expected, got).\n+    InvalidLength(usize, usize),\n+}\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Error::InvalidLength(ell, ell2) => write!(f, \"bad slice length {} (expected {})\", ell2, ell),\n+        }\n+    }\n+}\n+"
      },
      {
        "sha": "c1a73c1c6f7d51e94f0b98e2c7b6114040381c0a",
        "filename": "src/rusty/bitcoin_hashes/src/hash160.rs",
        "status": "added",
        "additions": 198,
        "deletions": 0,
        "changes": 198,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/hash160.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/hash160.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/src/hash160.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,198 @@\n+// Bitcoin Hashes Library\n+// Written in 2018 by\n+//   Andrew Poelstra <apoelstra@wpsoftware.net>\n+//\n+// To the extent possible under law, the author(s) have dedicated all\n+// copyright and related and neighboring rights to this software to\n+// the public domain worldwide. This software is distributed without\n+// any warranty.\n+//\n+// You should have received a copy of the CC0 Public Domain Dedication\n+// along with this software.\n+// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n+//\n+\n+// This module is largely copied from the rust-crypto ripemd.rs file;\n+// while rust-crypto is licensed under Apache, that file specifically\n+// was written entirely by Andrew Poelstra, who is re-licensing its\n+// contents here as CC0.\n+\n+//! # HASH160 (SHA256 then RIPEMD160)\n+\n+use core::str;\n+\n+use sha256;\n+use ripemd160;\n+use Hash as HashTrait;\n+use Error;\n+\n+/// Output of the Bitcoin HASH160 hash function\n+#[derive(Copy, Clone, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n+pub struct Hash([u8; 20]);\n+\n+hex_fmt_impl!(Debug, Hash);\n+hex_fmt_impl!(Display, Hash);\n+hex_fmt_impl!(LowerHex, Hash);\n+index_impl!(Hash);\n+serde_impl!(Hash, 20);\n+borrow_slice_impl!(Hash);\n+\n+impl str::FromStr for Hash {\n+    type Err = ::hex::Error;\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        ::hex::FromHex::from_hex(s)\n+    }\n+}\n+\n+impl HashTrait for Hash {\n+    type Engine = sha256::HashEngine;\n+    type Inner = [u8; 20];\n+\n+    fn engine() -> sha256::HashEngine {\n+        sha256::Hash::engine()\n+    }\n+\n+    fn from_engine(e: sha256::HashEngine) -> Hash {\n+        let sha2 = sha256::Hash::from_engine(e);\n+        let rmd = ripemd160::Hash::hash(&sha2[..]);\n+\n+        let mut ret = [0; 20];\n+        ret.copy_from_slice(&rmd[..]);\n+        Hash(ret)\n+    }\n+\n+    const LEN: usize = 20;\n+\n+    fn from_slice(sl: &[u8]) -> Result<Hash, Error> {\n+        if sl.len() != 20 {\n+            Err(Error::InvalidLength(Self::LEN, sl.len()))\n+        } else {\n+            let mut ret = [0; 20];\n+            ret.copy_from_slice(sl);\n+            Ok(Hash(ret))\n+        }\n+    }\n+\n+    fn into_inner(self) -> Self::Inner {\n+        self.0\n+    }\n+\n+    fn from_inner(inner: Self::Inner) -> Self {\n+        Hash(inner)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use hash160;\n+    use hex::{FromHex, ToHex};\n+    use Hash;\n+    use HashEngine;\n+\n+    #[derive(Clone)]\n+    struct Test {\n+        input: Vec<u8>,\n+        output: Vec<u8>,\n+        output_str: &'static str,\n+    }\n+\n+    #[test]\n+    fn test() {\n+        let tests = vec![\n+            // Uncompressed pubkey obtained from Bitcoin key; data from validateaddress\n+            Test {\n+                input: vec![\n+                    0x04, 0xa1, 0x49, 0xd7, 0x6c, 0x5d, 0xe2, 0x7a, 0x2d,\n+                    0xdb, 0xfa, 0xa1, 0x24, 0x6c, 0x4a, 0xdc, 0xd2, 0xb6,\n+                    0xf7, 0xaa, 0x29, 0x54, 0xc2, 0xe2, 0x53, 0x03, 0xf5,\n+                    0x51, 0x54, 0xca, 0xad, 0x91, 0x52, 0xe4, 0xf7, 0xe4,\n+                    0xb8, 0x5d, 0xf1, 0x69, 0xc1, 0x8a, 0x3c, 0x69, 0x7f,\n+                    0xbb, 0x2d, 0xc4, 0xec, 0xef, 0x94, 0xac, 0x55, 0xfe,\n+                    0x81, 0x64, 0xcc, 0xf9, 0x82, 0xa1, 0x38, 0x69, 0x1a,\n+                    0x55, 0x19,\n+                ],\n+                output: vec![\n+                    0xda, 0x0b, 0x34, 0x52, 0xb0, 0x6f, 0xe3, 0x41,\n+                    0x62, 0x6a, 0xd0, 0x94, 0x9c, 0x18, 0x3f, 0xbd,\n+                    0xa5, 0x67, 0x68, 0x26,\n+                ],\n+                output_str: \"da0b3452b06fe341626ad0949c183fbda5676826\",\n+            },\n+        ];\n+\n+        for test in tests {\n+            // Hash through high-level API, check hex encoding/decoding\n+            let hash = hash160::Hash::hash(&test.input[..]);\n+            assert_eq!(hash, hash160::Hash::from_hex(test.output_str).expect(\"parse hex\"));\n+            assert_eq!(&hash[..], &test.output[..]);\n+            assert_eq!(&hash.to_hex(), &test.output_str);\n+\n+            // Hash through engine, checking that we can input byte by byte\n+            let mut engine = hash160::Hash::engine();\n+            for ch in test.input {\n+                engine.input(&[ch]);\n+            }\n+            let manual_hash = Hash::from_engine(engine);\n+            assert_eq!(hash, manual_hash);\n+            assert_eq!(hash.into_inner()[..].as_ref(), test.output.as_slice());\n+        }\n+    }\n+\n+    #[cfg(feature=\"serde\")]\n+    #[test]\n+    fn ripemd_serde() {\n+        use serde_test::{Configure, Token, assert_tokens};\n+\n+        static HASH_BYTES: [u8; 20] = [\n+            0x13, 0x20, 0x72, 0xdf,\n+            0x69, 0x09, 0x33, 0x83,\n+            0x5e, 0xb8, 0xb6, 0xad,\n+            0x0b, 0x77, 0xe7, 0xb6,\n+            0xf1, 0x4a, 0xca, 0xd7,\n+        ];\n+\n+        let hash = hash160::Hash::from_slice(&HASH_BYTES).expect(\"right number of bytes\");\n+        assert_tokens(&hash.compact(), &[Token::BorrowedBytes(&HASH_BYTES[..])]);\n+        assert_tokens(&hash.readable(), &[Token::Str(\"132072df690933835eb8b6ad0b77e7b6f14acad7\")]);\n+    }\n+}\n+\n+#[cfg(all(test, feature=\"unstable\"))]\n+mod benches {\n+    use test::Bencher;\n+\n+    use hash160;\n+    use Hash;\n+    use HashEngine;\n+\n+    #[bench]\n+    pub fn hash160_10(bh: & mut Bencher) {\n+        let mut engine = hash160::Hash::engine();\n+        let bytes = [1u8; 10];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn hash160_1k(bh: & mut Bencher) {\n+        let mut engine = hash160::Hash::engine();\n+        let bytes = [1u8; 1024];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn hash160_64k(bh: & mut Bencher) {\n+        let mut engine = hash160::Hash::engine();\n+        let bytes = [1u8; 65536];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+}"
      },
      {
        "sha": "34c4586b7b7ad1e67c6f2f3c358c76b939db0c39",
        "filename": "src/rusty/bitcoin_hashes/src/hex.rs",
        "status": "added",
        "additions": 368,
        "deletions": 0,
        "changes": 368,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/hex.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/hex.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/src/hex.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,368 @@\n+// Bitcoin Hashes Library\n+// Written in 2018 by\n+//   Andrew Poelstra <apoelstra@wpsoftware.net>\n+//\n+// To the extent possible under law, the author(s) have dedicated all\n+// copyright and related and neighboring rights to this software to\n+// the public domain worldwide. This software is distributed without\n+// any warranty.\n+//\n+// You should have received a copy of the CC0 Public Domain Dedication\n+// along with this software.\n+// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n+//\n+\n+//! # Hex encoding and decoding\n+//!\n+\n+use core::{fmt, str};\n+use Hash;\n+\n+/// Hex decoding error\n+#[derive(Debug, Copy, Clone, PartialEq, Eq)]\n+pub enum Error {\n+    /// non-hexadecimal character\n+    InvalidChar(u8),\n+    /// purported hex string had odd length\n+    OddLengthString(usize),\n+    /// tried to parse fixed-length hash from a string with the wrong type (expected, got)\n+    InvalidLength(usize, usize),\n+}\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Error::InvalidChar(ch) => write!(f, \"invalid hex character {}\", ch),\n+            Error::OddLengthString(ell) => write!(f, \"odd hex string length {}\", ell),\n+            Error::InvalidLength(ell, ell2) => write!(f, \"bad hex string length {} (expected {})\", ell2, ell),\n+        }\n+    }\n+}\n+\n+/// Trait for objects that can be serialized as hex strings\n+#[cfg(any(test, feature = \"std\"))]\n+pub trait ToHex {\n+    /// Hex representation of the object\n+    fn to_hex(&self) -> String;\n+}\n+\n+/// Trait for objects that can be deserialized from hex strings\n+pub trait FromHex: Sized {\n+    /// Produce an object from a byte iterator\n+    fn from_byte_iter<I>(iter: I) -> Result<Self, Error>\n+        where I: Iterator<Item=Result<u8, Error>> +\n+            ExactSizeIterator +\n+            DoubleEndedIterator;\n+\n+    /// Produce an object from a hex string\n+    fn from_hex(s: &str) -> Result<Self, Error> {\n+        Self::from_byte_iter(HexIterator::new(s)?)\n+    }\n+}\n+\n+#[cfg(any(test, feature = \"std\"))]\n+impl<T: fmt::LowerHex> ToHex for T {\n+    /// Outputs the hash in hexadecimal form\n+    fn to_hex(&self) -> String {\n+        format!(\"{:x}\", self)\n+    }\n+}\n+\n+impl<T: Hash> FromHex for T {\n+    fn from_byte_iter<I>(iter: I) -> Result<Self, Error>\n+        where I: Iterator<Item=Result<u8, Error>> +\n+            ExactSizeIterator +\n+            DoubleEndedIterator,\n+    {\n+        let inner;\n+        if Self::DISPLAY_BACKWARD {\n+            inner = T::Inner::from_byte_iter(iter.rev())?;\n+        } else {\n+            inner = T::Inner::from_byte_iter(iter)?;\n+        }\n+        Ok(Hash::from_inner(inner))\n+    }\n+}\n+\n+/// Iterator over a hex-encoded string slice which decodes hex and yields bytes.\n+pub struct HexIterator<'a> {\n+    /// The `Bytes` iterator whose next two bytes will be decoded to yield\n+    /// the next byte.\n+    iter: str::Bytes<'a>,\n+}\n+\n+impl<'a> HexIterator<'a> {\n+    /// Constructs a new `HexIterator` from a string slice. If the string is of\n+    /// odd length it returns an error.\n+    pub fn new(s: &'a str) -> Result<HexIterator<'a>, Error> {\n+        if s.len() % 2 != 0 {\n+            Err(Error::OddLengthString(s.len()))\n+        } else {\n+            Ok(HexIterator { iter: s.bytes() })\n+        }\n+    }\n+}\n+\n+fn chars_to_hex(hi: u8, lo: u8) -> Result<u8, Error> {\n+    let hih = (hi as char)\n+        .to_digit(16)\n+        .ok_or(Error::InvalidChar(hi))?;\n+    let loh = (lo as char)\n+        .to_digit(16)\n+        .ok_or(Error::InvalidChar(lo))?;\n+\n+    let ret = (hih << 4) + loh;\n+    Ok(ret as u8)\n+}\n+\n+impl<'a> Iterator for HexIterator<'a> {\n+    type Item = Result<u8, Error>;\n+\n+    fn next(&mut self) -> Option<Result<u8, Error>> {\n+        let hi = self.iter.next()?;\n+        let lo = self.iter.next().unwrap();\n+        Some(chars_to_hex(hi, lo))\n+    }\n+\n+    fn size_hint(&self) -> (usize, Option<usize>) {\n+        let (min, max) = self.iter.size_hint();\n+        (min / 2, max.map(|x| x /2))\n+    }\n+}\n+\n+impl<'a> DoubleEndedIterator for HexIterator<'a> {\n+    fn next_back(&mut self) -> Option<Result<u8, Error>> {\n+        let lo = self.iter.next_back()?;\n+        let hi = self.iter.next_back().unwrap();\n+        Some(chars_to_hex(hi, lo))\n+    }\n+}\n+\n+impl<'a> ExactSizeIterator for HexIterator<'a> {}\n+\n+/// Output hex into an object implementing `fmt::Write`, which is usually more\n+/// efficient than going through a `String` using `ToHex`.\n+pub fn format_hex(data: &[u8], f: &mut fmt::Formatter) -> fmt::Result {\n+    let prec = f.precision().unwrap_or(2 * data.len());\n+    let width = f.width().unwrap_or(2 * data.len());\n+    for _ in (2 * data.len())..width {\n+        f.write_str(\"0\")?;\n+    }\n+    for ch in data.iter().take(prec / 2) {\n+        write!(f, \"{:02x}\", *ch)?;\n+    }\n+    if prec < 2 * data.len() && prec % 2 == 1 {\n+        write!(f, \"{:x}\", data[prec / 2] / 16)?;\n+    }\n+    Ok(())\n+}\n+\n+/// Output hex in reverse order; used for Sha256dHash whose standard hex encoding\n+/// has the bytes reversed.\n+pub fn format_hex_reverse(data: &[u8], f: &mut fmt::Formatter) -> fmt::Result {\n+    let prec = f.precision().unwrap_or(2 * data.len());\n+    let width = f.width().unwrap_or(2 * data.len());\n+    for _ in (2 * data.len())..width {\n+        f.write_str(\"0\")?;\n+    }\n+    for ch in data.iter().rev().take(prec / 2) {\n+        write!(f, \"{:02x}\", *ch)?;\n+    }\n+    if prec < 2 * data.len() && prec % 2 == 1 {\n+        write!(f, \"{:x}\", data[data.len() - 1 - prec / 2] / 16)?;\n+    }\n+    Ok(())\n+}\n+\n+#[cfg(any(test, feature = \"std\"))]\n+impl ToHex for [u8] {\n+    fn to_hex(&self) -> String {\n+        use core::fmt::Write;\n+        let mut ret = String::with_capacity(2 * self.len());\n+        for ch in self {\n+            write!(ret, \"{:02x}\", ch).expect(\"writing to string\");\n+        }\n+        ret\n+    }\n+}\n+\n+#[cfg(any(test, feature = \"std\"))]\n+impl FromHex for Vec<u8> {\n+    fn from_byte_iter<I>(iter: I) -> Result<Self, Error>\n+        where I: Iterator<Item=Result<u8, Error>> +\n+            ExactSizeIterator +\n+            DoubleEndedIterator,\n+    {\n+        iter.collect()\n+    }\n+}\n+\n+macro_rules! impl_fromhex_array {\n+    ($len:expr) => {\n+        impl FromHex for [u8; $len] {\n+            fn from_byte_iter<I>(iter: I) -> Result<Self, Error>\n+                where I: Iterator<Item=Result<u8, Error>> +\n+                    ExactSizeIterator +\n+                    DoubleEndedIterator,\n+            {\n+                if iter.len() == $len {\n+                    let mut ret = [0; $len];\n+                    for (n, byte) in iter.enumerate() {\n+                        ret[n] = byte?;\n+                    }\n+                    Ok(ret)\n+                } else {\n+                    Err(Error::InvalidLength(2 * $len, 2 * iter.len()))\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+impl_fromhex_array!(2);\n+impl_fromhex_array!(4);\n+impl_fromhex_array!(6);\n+impl_fromhex_array!(8);\n+impl_fromhex_array!(10);\n+impl_fromhex_array!(12);\n+impl_fromhex_array!(14);\n+impl_fromhex_array!(16);\n+impl_fromhex_array!(20);\n+impl_fromhex_array!(24);\n+impl_fromhex_array!(28);\n+impl_fromhex_array!(32);\n+impl_fromhex_array!(33);\n+impl_fromhex_array!(64);\n+impl_fromhex_array!(65);\n+impl_fromhex_array!(128);\n+impl_fromhex_array!(256);\n+impl_fromhex_array!(384);\n+impl_fromhex_array!(512);\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    use core::fmt;\n+\n+    #[test]\n+    fn hex_roundtrip() {\n+        let expected = \"0123456789abcdef\";\n+        let expected_up = \"0123456789ABCDEF\";\n+\n+        let parse: Vec<u8> = FromHex::from_hex(expected).expect(\"parse lowercase string\");\n+        assert_eq!(parse, vec![0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);\n+        let ser = parse.to_hex();\n+        assert_eq!(ser, expected);\n+\n+        let parse: Vec<u8> = FromHex::from_hex(expected_up).expect(\"parse uppercase string\");\n+        assert_eq!(parse, vec![0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);\n+        let ser = parse.to_hex();\n+        assert_eq!(ser, expected);\n+\n+        let parse: [u8; 8] = FromHex::from_hex(expected_up).expect(\"parse uppercase string\");\n+        assert_eq!(parse, [0x01, 0x23, 0x45, 0x67, 0x89, 0xab, 0xcd, 0xef]);\n+        let ser = parse.to_hex();\n+        assert_eq!(ser, expected);\n+    }\n+\n+    #[test]\n+    fn hex_truncate() {\n+        struct HexBytes(Vec<u8>);\n+        impl fmt::LowerHex for HexBytes {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                format_hex(&self.0, f)\n+            }\n+        }\n+\n+        let bytes = HexBytes(vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+\n+        assert_eq!(\n+            format!(\"{:x}\", bytes),\n+            \"0102030405060708090a\"\n+        );\n+\n+        for i in 0..20 {\n+            assert_eq!(\n+                format!(\"{:.prec$x}\", bytes, prec = i),\n+                &\"0102030405060708090a\"[0..i]\n+            );\n+        }\n+\n+        assert_eq!(\n+            format!(\"{:25x}\", bytes),\n+            \"000000102030405060708090a\"\n+        );\n+        assert_eq!(\n+            format!(\"{:26x}\", bytes),\n+            \"0000000102030405060708090a\"\n+        );\n+    }\n+\n+    #[test]\n+    fn hex_truncate_rev() {\n+        struct HexBytes(Vec<u8>);\n+        impl fmt::LowerHex for HexBytes {\n+            fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+                format_hex_reverse(&self.0, f)\n+            }\n+        }\n+\n+        let bytes = HexBytes(vec![1u8, 2, 3, 4, 5, 6, 7, 8, 9, 10]);\n+\n+        assert_eq!(\n+            format!(\"{:x}\", bytes),\n+            \"0a090807060504030201\"\n+        );\n+\n+        for i in 0..20 {\n+            assert_eq!(\n+                format!(\"{:.prec$x}\", bytes, prec = i),\n+                &\"0a090807060504030201\"[0..i]\n+            );\n+        }\n+\n+        assert_eq!(\n+            format!(\"{:25x}\", bytes),\n+            \"000000a090807060504030201\"\n+        );\n+        assert_eq!(\n+            format!(\"{:26x}\", bytes),\n+            \"0000000a090807060504030201\"\n+        );\n+    }\n+\n+    #[test]\n+    fn hex_error() {\n+        let oddlen = \"0123456789abcdef0\";\n+        let badchar1 = \"Z123456789abcdef\";\n+        let badchar2 = \"012Y456789abcdeb\";\n+        let badchar3 = \"\u00ab23456789abcdef\";\n+\n+        assert_eq!(\n+            Vec::<u8>::from_hex(oddlen),\n+            Err(Error::OddLengthString(17))\n+        );\n+        assert_eq!(\n+            <[u8; 4]>::from_hex(oddlen),\n+            Err(Error::OddLengthString(17))\n+        );\n+        assert_eq!(\n+            <[u8; 8]>::from_hex(oddlen),\n+            Err(Error::OddLengthString(17))\n+        );\n+        assert_eq!(\n+            Vec::<u8>::from_hex(badchar1),\n+            Err(Error::InvalidChar(b'Z'))\n+        );\n+        assert_eq!(\n+            Vec::<u8>::from_hex(badchar2),\n+            Err(Error::InvalidChar(b'Y'))\n+        );\n+        assert_eq!(\n+            Vec::<u8>::from_hex(badchar3),\n+            Err(Error::InvalidChar(194))\n+        );\n+    }\n+}\n+"
      },
      {
        "sha": "6034250585720448b38191e2515d66dc9c1637c2",
        "filename": "src/rusty/bitcoin_hashes/src/hmac.rs",
        "status": "added",
        "additions": 409,
        "deletions": 0,
        "changes": 409,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/hmac.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/hmac.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/src/hmac.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,409 @@\n+// Bitcoin Hashes Library\n+// Written in 2018 by\n+//   Andrew Poelstra <apoelstra@wpsoftware.net>\n+//\n+// To the extent possible under law, the author(s) have dedicated all\n+// copyright and related and neighboring rights to this software to\n+// the public domain worldwide. This software is distributed without\n+// any warranty.\n+//\n+// You should have received a copy of the CC0 Public Domain Dedication\n+// along with this software.\n+// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n+//\n+\n+// This module is largely copied from the rust-crypto ripemd.rs file;\n+// while rust-crypto is licensed under Apache, that file specifically\n+// was written entirely by Andrew Poelstra, who is re-licensing its\n+// contents here as CC0.\n+\n+//! # HMAC support\n+\n+use core::{borrow, fmt, ops, str};\n+#[cfg(feature=\"serde\")]\n+use serde::{Serialize, Serializer, Deserialize, Deserializer};\n+\n+use HashEngine as EngineTrait;\n+use Hash as HashTrait;\n+use Error;\n+\n+/// A hash computed from a RFC 2104 HMAC. Parameterized by the underlying hash function.\n+#[derive(Copy, Clone, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n+pub struct Hmac<T: HashTrait>(T);\n+\n+impl<T: HashTrait + str::FromStr> str::FromStr for Hmac<T> {\n+    type Err = <T as str::FromStr>::Err;\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        Ok(Hmac(str::FromStr::from_str(s)?))\n+    }\n+}\n+\n+/// Pair of underlying hash midstates which represent the current state\n+/// of an `HmacEngine`\n+pub struct HmacMidState<T: HashTrait> {\n+    /// Midstate of the inner hash engine\n+    pub inner: <T::Engine as EngineTrait>::MidState,\n+    /// Midstate of the outer hash engine\n+    pub outer: <T::Engine as EngineTrait>::MidState,\n+}\n+\n+/// Pair of underyling hash engines, used for the inner and outer hash of HMAC\n+#[derive(Clone)]\n+pub struct HmacEngine<T: HashTrait> {\n+    iengine: T::Engine,\n+    oengine: T::Engine,\n+}\n+\n+impl<T: HashTrait> Default for HmacEngine<T> {\n+    fn default() -> Self {\n+        HmacEngine::new(&[])\n+    }\n+}\n+\n+impl<T: HashTrait> HmacEngine<T> {\n+    /// Construct a new keyed HMAC with the given key. We only support underlying hashes\n+    /// whose block sizes are \u2264 128 bytes; larger hashes will result in panics.\n+    pub fn new(key: &[u8]) -> HmacEngine<T> {\n+        debug_assert!(T::Engine::BLOCK_SIZE <= 128);\n+\n+        let mut ipad = [0x36u8; 128];\n+        let mut opad = [0x5cu8; 128];\n+        let mut ret = HmacEngine {\n+            iengine: <T as HashTrait>::engine(),\n+            oengine: <T as HashTrait>::engine(),\n+        };\n+\n+        if key.len() > T::Engine::BLOCK_SIZE {\n+            let hash = <T as HashTrait>::hash(key);\n+            for (b_i, b_h) in ipad.iter_mut().zip(&hash[..]) {\n+                *b_i ^= *b_h;\n+            }\n+            for (b_o, b_h) in opad.iter_mut().zip(&hash[..]) {\n+                *b_o ^= *b_h;\n+            }\n+        } else {\n+            for (b_i, b_h) in ipad.iter_mut().zip(&key[..]) {\n+                *b_i ^= *b_h;\n+            }\n+            for (b_o, b_h) in opad.iter_mut().zip(&key[..]) {\n+                *b_o ^= *b_h;\n+            }\n+        };\n+\n+        EngineTrait::input(&mut ret.iengine, &ipad[..T::Engine::BLOCK_SIZE]);\n+        EngineTrait::input(&mut ret.oengine, &opad[..T::Engine::BLOCK_SIZE]);\n+        ret\n+    }\n+}\n+\n+impl<T: HashTrait> EngineTrait for HmacEngine<T> {\n+    type MidState = HmacMidState<T>;\n+\n+    fn midstate(&self) -> Self::MidState {\n+        HmacMidState {\n+            inner: self.iengine.midstate(),\n+            outer: self.oengine.midstate(),\n+        }\n+    }\n+\n+    const BLOCK_SIZE: usize = T::Engine::BLOCK_SIZE;\n+    \n+    fn input(&mut self, buf: &[u8]) {\n+        self.iengine.input(buf)\n+    }\n+}\n+\n+impl<T: HashTrait> fmt::Debug for Hmac<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Debug::fmt(&self.0, f)\n+    }\n+}\n+\n+impl<T: HashTrait> fmt::Display for Hmac<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::Display::fmt(&self.0, f)\n+    }\n+}\n+\n+impl<T: HashTrait> fmt::LowerHex for Hmac<T> {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        fmt::LowerHex::fmt(&self.0, f)\n+    }\n+}\n+\n+impl<T: HashTrait> ops::Index<usize> for Hmac<T> {\n+    type Output = u8;\n+    fn index(&self, index: usize) -> &u8 {\n+        &self.0[index]\n+    }\n+}\n+\n+impl<T: HashTrait> ops::Index<ops::Range<usize>> for Hmac<T> {\n+    type Output = [u8];\n+    fn index(&self, index: ops::Range<usize>) -> &[u8] {\n+        &self.0[index]\n+    }\n+}\n+\n+impl<T: HashTrait> ops::Index<ops::RangeFrom<usize>> for Hmac<T> {\n+    type Output = [u8];\n+    fn index(&self, index: ops::RangeFrom<usize>) -> &[u8] {\n+        &self.0[index]\n+    }\n+}\n+\n+impl<T: HashTrait> ops::Index<ops::RangeTo<usize>> for Hmac<T> {\n+    type Output = [u8];\n+    fn index(&self, index: ops::RangeTo<usize>) -> &[u8] {\n+        &self.0[index]\n+    }\n+}\n+\n+impl<T: HashTrait> ops::Index<ops::RangeFull> for Hmac<T> {\n+    type Output = [u8];\n+    fn index(&self, index: ops::RangeFull) -> &[u8] {\n+        &self.0[index]\n+    }\n+}\n+\n+impl<T: HashTrait> borrow::Borrow<[u8]> for Hmac<T> {\n+    fn borrow(&self) -> &[u8] {\n+        &self[..]\n+    }\n+}\n+\n+impl<T: HashTrait> HashTrait for Hmac<T> {\n+    type Engine = HmacEngine<T>;\n+    type Inner = T::Inner;\n+\n+    fn from_engine(mut e: HmacEngine<T>) -> Hmac<T> {\n+        let ihash = T::from_engine(e.iengine);\n+        e.oengine.input(&ihash[..]);\n+        let ohash = T::from_engine(e.oengine);\n+        Hmac(ohash)\n+    }\n+\n+    const LEN: usize = T::LEN;\n+\n+    fn from_slice(sl: &[u8]) -> Result<Hmac<T>, Error> {\n+        T::from_slice(sl).map(Hmac)\n+    }\n+\n+    fn into_inner(self) -> Self::Inner {\n+        self.0.into_inner()\n+    }\n+\n+    fn from_inner(inner: T::Inner) -> Self {\n+        Hmac(T::from_inner(inner))\n+    }\n+}\n+\n+#[cfg(feature=\"serde\")]\n+impl<T: HashTrait + Serialize> Serialize for Hmac<T> {\n+    fn serialize<S: Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {\n+        Serialize::serialize(&self.0, s)\n+    }\n+}\n+\n+#[cfg(feature=\"serde\")]\n+impl<'de, T: HashTrait + Deserialize<'de>> Deserialize<'de> for Hmac<T> {\n+    fn deserialize<D: Deserializer<'de>>(d: D) -> Result<Hmac<T>, D::Error> {\n+        let inner = Deserialize::deserialize(d)?;\n+        Ok(Hmac(inner))\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use sha256;\n+    #[cfg(feature=\"serde\")] use sha512;\n+    use {Hash, HashEngine, Hmac, HmacEngine};\n+\n+    #[derive(Clone)]\n+    struct Test {\n+        key: Vec<u8>,\n+        input: Vec<u8>,\n+        output: Vec<u8>,\n+    }\n+\n+    #[test]\n+    fn test() {\n+        let tests = vec![\n+            // Test vectors copied from libsecp256k1\n+            // Sadly the RFC2104 test vectors all use MD5 as their underlying hash function,\n+            // which of course this library does not support.\n+            Test {\n+                key: vec![ 0x0b; 20],\n+                input: vec![0x48, 0x69, 0x20, 0x54, 0x68, 0x65, 0x72, 0x65],\n+                output: vec![\n+                    0xb0, 0x34, 0x4c, 0x61, 0xd8, 0xdb, 0x38, 0x53,\n+                    0x5c, 0xa8, 0xaf, 0xce, 0xaf, 0x0b, 0xf1, 0x2b,\n+                    0x88, 0x1d, 0xc2, 0x00, 0xc9, 0x83, 0x3d, 0xa7,\n+                    0x26, 0xe9, 0x37, 0x6c, 0x2e, 0x32, 0xcf, 0xf7,\n+                ],\n+            },\n+            Test {\n+                key: vec![ 0x4a, 0x65, 0x66, 0x65 ],\n+                input: vec![\n+                    0x77, 0x68, 0x61, 0x74, 0x20, 0x64, 0x6f, 0x20,\n+                    0x79, 0x61, 0x20, 0x77, 0x61, 0x6e, 0x74, 0x20,\n+                    0x66, 0x6f, 0x72, 0x20, 0x6e, 0x6f, 0x74, 0x68,\n+                    0x69, 0x6e, 0x67, 0x3f,\n+                ],\n+                output: vec![\n+                    0x5b, 0xdc, 0xc1, 0x46, 0xbf, 0x60, 0x75, 0x4e,\n+                    0x6a, 0x04, 0x24, 0x26, 0x08, 0x95, 0x75, 0xc7,\n+                    0x5a, 0x00, 0x3f, 0x08, 0x9d, 0x27, 0x39, 0x83,\n+                    0x9d, 0xec, 0x58, 0xb9, 0x64, 0xec, 0x38, 0x43,\n+                ],\n+            },\n+            Test {\n+                key: vec![ 0xaa; 20 ],\n+                input: vec![ 0xdd; 50 ],\n+                output: vec![\n+                    0x77, 0x3e, 0xa9, 0x1e, 0x36, 0x80, 0x0e, 0x46,\n+                    0x85, 0x4d, 0xb8, 0xeb, 0xd0, 0x91, 0x81, 0xa7,\n+                    0x29, 0x59, 0x09, 0x8b, 0x3e, 0xf8, 0xc1, 0x22,\n+                    0xd9, 0x63, 0x55, 0x14, 0xce, 0xd5, 0x65, 0xfe,\n+                ],\n+            },\n+            Test {\n+                key: vec![\n+                    0x01, 0x02, 0x03, 0x04, 0x05, 0x06, 0x07, 0x08,\n+                    0x09, 0x0a, 0x0b, 0x0c, 0x0d, 0x0e, 0x0f, 0x10,\n+                    0x11, 0x12, 0x13, 0x14, 0x15, 0x16, 0x17, 0x18,\n+                    0x19\n+                ],\n+                input: vec![ 0xcd; 50 ],\n+                output: vec![\n+                    0x82, 0x55, 0x8a, 0x38, 0x9a, 0x44, 0x3c, 0x0e,\n+                    0xa4, 0xcc, 0x81, 0x98, 0x99, 0xf2, 0x08, 0x3a,\n+                    0x85, 0xf0, 0xfa, 0xa3, 0xe5, 0x78, 0xf8, 0x07,\n+                    0x7a, 0x2e, 0x3f, 0xf4, 0x67, 0x29, 0x66, 0x5b,\n+                ],\n+            },\n+            Test {\n+                key: vec! [ 0xaa; 131 ],\n+                input: vec![\n+                    0x54, 0x65, 0x73, 0x74, 0x20, 0x55, 0x73, 0x69,\n+                    0x6e, 0x67, 0x20, 0x4c, 0x61, 0x72, 0x67, 0x65,\n+                    0x72, 0x20, 0x54, 0x68, 0x61, 0x6e, 0x20, 0x42,\n+                    0x6c, 0x6f, 0x63, 0x6b, 0x2d, 0x53, 0x69, 0x7a,\n+                    0x65, 0x20, 0x4b, 0x65, 0x79, 0x20, 0x2d, 0x20,\n+                    0x48, 0x61, 0x73, 0x68, 0x20, 0x4b, 0x65, 0x79,\n+                    0x20, 0x46, 0x69, 0x72, 0x73, 0x74,\n+                ],\n+                output: vec![\n+                    0x60, 0xe4, 0x31, 0x59, 0x1e, 0xe0, 0xb6, 0x7f,\n+                    0x0d, 0x8a, 0x26, 0xaa, 0xcb, 0xf5, 0xb7, 0x7f,\n+                    0x8e, 0x0b, 0xc6, 0x21, 0x37, 0x28, 0xc5, 0x14,\n+                    0x05, 0x46, 0x04, 0x0f, 0x0e, 0xe3, 0x7f, 0x54,\n+                ],\n+            },\n+            Test {\n+                key: vec! [ 0xaa; 131 ],\n+                input: vec![\n+                    0x54, 0x68, 0x69, 0x73, 0x20, 0x69, 0x73, 0x20,\n+                    0x61, 0x20, 0x74, 0x65, 0x73, 0x74, 0x20, 0x75,\n+                    0x73, 0x69, 0x6e, 0x67, 0x20, 0x61, 0x20, 0x6c,\n+                    0x61, 0x72, 0x67, 0x65, 0x72, 0x20, 0x74, 0x68,\n+                    0x61, 0x6e, 0x20, 0x62, 0x6c, 0x6f, 0x63, 0x6b,\n+                    0x2d, 0x73, 0x69, 0x7a, 0x65, 0x20, 0x6b, 0x65,\n+                    0x79, 0x20, 0x61, 0x6e, 0x64, 0x20, 0x61, 0x20,\n+                    0x6c, 0x61, 0x72, 0x67, 0x65, 0x72, 0x20, 0x74,\n+                    0x68, 0x61, 0x6e, 0x20, 0x62, 0x6c, 0x6f, 0x63,\n+                    0x6b, 0x2d, 0x73, 0x69, 0x7a, 0x65, 0x20, 0x64,\n+                    0x61, 0x74, 0x61, 0x2e, 0x20, 0x54, 0x68, 0x65,\n+                    0x20, 0x6b, 0x65, 0x79, 0x20, 0x6e, 0x65, 0x65,\n+                    0x64, 0x73, 0x20, 0x74, 0x6f, 0x20, 0x62, 0x65,\n+                    0x20, 0x68, 0x61, 0x73, 0x68, 0x65, 0x64, 0x20,\n+                    0x62, 0x65, 0x66, 0x6f, 0x72, 0x65, 0x20, 0x62,\n+                    0x65, 0x69, 0x6e, 0x67, 0x20, 0x75, 0x73, 0x65,\n+                    0x64, 0x20, 0x62, 0x79, 0x20, 0x74, 0x68, 0x65,\n+                    0x20, 0x48, 0x4d, 0x41, 0x43, 0x20, 0x61, 0x6c,\n+                    0x67, 0x6f, 0x72, 0x69, 0x74, 0x68, 0x6d, 0x2e,\n+                ],\n+                output: vec![\n+                    0x9b, 0x09, 0xff, 0xa7, 0x1b, 0x94, 0x2f, 0xcb,\n+                    0x27, 0x63, 0x5f, 0xbc, 0xd5, 0xb0, 0xe9, 0x44,\n+                    0xbf, 0xdc, 0x63, 0x64, 0x4f, 0x07, 0x13, 0x93,\n+                    0x8a, 0x7f, 0x51, 0x53, 0x5c, 0x3a, 0x35, 0xe2,\n+                ],\n+            },\n+        ];\n+\n+        for test in tests {\n+            let mut engine = HmacEngine::<sha256::Hash>::new(&test.key);\n+            engine.input(&test.input);\n+            let hash = Hmac::<sha256::Hash>::from_engine(engine);\n+            assert_eq!(&hash[..], &test.output[..]);\n+            assert_eq!(hash.into_inner()[..].as_ref(), test.output.as_slice());\n+        }\n+    }\n+\n+    #[cfg(feature=\"serde\")]\n+    #[test]\n+    fn hmac_sha512_serde() {\n+        use serde_test::{Configure, Token, assert_tokens};\n+\n+        static HASH_BYTES: [u8; 64] = [\n+            0x8b, 0x41, 0xe1, 0xb7, 0x8a, 0xd1, 0x15, 0x21,\n+            0x11, 0x3c, 0x52, 0xff, 0x18, 0x2a, 0x1b, 0x8e,\n+            0x0a, 0x19, 0x57, 0x54, 0xaa, 0x52, 0x7f, 0xcd,\n+            0x00, 0xa4, 0x11, 0x62, 0x0b, 0x46, 0xf2, 0x0f,\n+            0xff, 0xfb, 0x80, 0x88, 0xcc, 0xf8, 0x54, 0x97,\n+            0x12, 0x1a, 0xd4, 0x49, 0x9e, 0x08, 0x45, 0xb8,\n+            0x76, 0xf6, 0xdd, 0x66, 0x40, 0x08, 0x8a, 0x2f,\n+            0x0b, 0x2d, 0x8a, 0x60, 0x0b, 0xdf, 0x4c, 0x0c,\n+        ];\n+\n+        let hash = Hmac::<sha512::Hash>::from_slice(&HASH_BYTES).expect(\"right number of bytes\");\n+        assert_tokens(&hash.compact(), &[Token::BorrowedBytes(&HASH_BYTES[..])]);\n+        assert_tokens(\n+            &hash.readable(),\n+            &[Token::Str(\n+                \"8b41e1b78ad11521113c52ff182a1b8e0a195754aa527fcd00a411620b46f20f\\\n+                 fffb8088ccf85497121ad4499e0845b876f6dd6640088a2f0b2d8a600bdf4c0c\"\n+            )],\n+        );\n+    }\n+}\n+\n+#[cfg(all(test, feature=\"unstable\"))]\n+mod benches {\n+    use test::Bencher;\n+\n+    use sha256;\n+    use {Hmac, Hash, HashEngine};\n+\n+    #[bench]\n+    pub fn hmac_sha256_10(bh: & mut Bencher) {\n+        let mut engine = Hmac::<sha256::Hash>::engine();\n+        let bytes = [1u8; 10];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn hmac_sha256_1k(bh: & mut Bencher) {\n+        let mut engine = Hmac::<sha256::Hash>::engine();\n+        let bytes = [1u8; 1024];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn hmac_sha256_64k(bh: & mut Bencher) {\n+        let mut engine = Hmac::<sha256::Hash>::engine();\n+        let bytes = [1u8; 65536];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+}"
      },
      {
        "sha": "9f00721d3bafc59182e70937a65fcede0f2f5e12",
        "filename": "src/rusty/bitcoin_hashes/src/lib.rs",
        "status": "added",
        "additions": 125,
        "deletions": 0,
        "changes": 125,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/src/lib.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,125 @@\n+// Bitcoin Hashes Library\n+// Written in 2018 by\n+//   Andrew Poelstra <apoelstra@wpsoftware.net>\n+//\n+// To the extent possible under law, the author(s) have dedicated all\n+// copyright and related and neighboring rights to this software to\n+// the public domain worldwide. This software is distributed without\n+// any warranty.\n+//\n+// You should have received a copy of the CC0 Public Domain Dedication\n+// along with this software.\n+// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n+//\n+\n+//! # Rust Hashes Library\n+//!\n+//! This is a simple, no-dependency library which implements the hash functions\n+//! needed by Bitcoin. These are SHA256, SHA256d, and RIPEMD160. As an ancillary\n+//! thing, it exposes hexadecimal serialization and deserialization, since these\n+//! are needed to display hashes anway.\n+//!\n+\n+// Coding conventions\n+#![deny(non_upper_case_globals)]\n+#![deny(non_camel_case_types)]\n+#![deny(non_snake_case)]\n+#![deny(unused_mut)]\n+#![deny(missing_docs)]\n+\n+#![cfg_attr(all(not(test), not(feature = \"std\")), no_std)]\n+#![cfg_attr(all(test, feature = \"unstable\"), feature(test))]\n+#[cfg(all(test, feature = \"unstable\"))] extern crate test;\n+\n+#[cfg(any(test, feature=\"std\"))] extern crate core;\n+#[cfg(feature=\"serde\")] extern crate serde;\n+#[cfg(all(test,feature=\"serde\"))] extern crate serde_test;\n+\n+#[macro_use] mod util;\n+#[macro_use] mod serde_macros;\n+#[cfg(any(test, feature = \"std\"))] mod std_impls;\n+pub mod error;\n+pub mod hex;\n+pub mod hash160;\n+pub mod hmac;\n+pub mod ripemd160;\n+pub mod sha1;\n+pub mod sha256;\n+pub mod sha512;\n+pub mod sha256d;\n+pub mod siphash24;\n+pub mod cmp;\n+\n+use core::{borrow, fmt, hash, ops};\n+\n+pub use hmac::{Hmac, HmacEngine};\n+pub use error::Error;\n+\n+/// A hashing engine which bytes can be serialized into. It is expected\n+/// to implement the `io::Write` trait, but to never return errors under\n+/// any conditions.\n+pub trait HashEngine: Clone + Default {\n+    /// Byte array representing the internal state of the hash engine\n+    type MidState;\n+\n+    /// Outputs the midstate of the hash engine. This function should not be\n+    /// used directly unless you really know what you're doing.\n+    fn midstate(&self) -> Self::MidState;\n+\n+    /// Length of the hash's internal block size, in bytes\n+    const BLOCK_SIZE: usize;\n+\n+    /// Add data to the hash engine\n+    fn input(&mut self, data: &[u8]);\n+}\n+\n+/// Trait which applies to hashes of all types\n+pub trait Hash: Copy + Clone + PartialEq + Eq + Default + PartialOrd + Ord +\n+    hash::Hash + fmt::Debug + fmt::Display + fmt::LowerHex +\n+    ops::Index<ops::RangeFull, Output = [u8]> +\n+    ops::Index<ops::RangeFrom<usize>, Output = [u8]> +\n+    ops::Index<ops::RangeTo<usize>, Output = [u8]> +\n+    ops::Index<ops::Range<usize>, Output = [u8]> +\n+    ops::Index<usize, Output = u8> +\n+    borrow::Borrow<[u8]>\n+{\n+    /// A hashing engine which bytes can be serialized into. It is expected\n+    /// to implement the `io::Write` trait, and to never return errors under\n+    /// any conditions.\n+    type Engine: HashEngine;\n+\n+    /// The byte array that represents the hash internally\n+    type Inner: hex::FromHex;\n+\n+    /// Construct a new engine\n+    fn engine() -> Self::Engine {\n+        Self::Engine::default()\n+    }\n+\n+    /// Produce a hash from the current state of a given engine\n+    fn from_engine(e: Self::Engine) -> Self;\n+\n+    /// Length of the hash, in bytes\n+    const LEN: usize;\n+\n+    /// Copies a byte slice into a hash object\n+    fn from_slice(sl: &[u8]) -> Result<Self, Error>;\n+\n+    /// Hashes some bytes\n+    fn hash(data: &[u8]) -> Self {\n+        let mut engine = Self::engine();\n+        engine.input(data);\n+        Self::from_engine(engine)\n+    }\n+\n+    /// Flag indicating whether user-visible serializations of this hash\n+    /// should be backward. For some reason Satoshi decided this should be\n+    /// true for `Sha256dHash`, so here we are.\n+    const DISPLAY_BACKWARD: bool = false;\n+\n+    /// Unwraps the hash and returns the underlying byte array\n+    fn into_inner(self) -> Self::Inner;\n+\n+    /// Constructs a hash from the underlying byte array\n+    fn from_inner(inner: Self::Inner) -> Self;\n+}"
      },
      {
        "sha": "c5e4f571428c4e06cb43ffe1de35bfaf1ba2b247",
        "filename": "src/rusty/bitcoin_hashes/src/ripemd160.rs",
        "status": "added",
        "additions": 577,
        "deletions": 0,
        "changes": 577,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/ripemd160.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/ripemd160.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/src/ripemd160.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,577 @@\n+// Bitcoin Hashes Library\n+// Written in 2018 by\n+//   Andrew Poelstra <apoelstra@wpsoftware.net>\n+//\n+// To the extent possible under law, the author(s) have dedicated all\n+// copyright and related and neighboring rights to this software to\n+// the public domain worldwide. This software is distributed without\n+// any warranty.\n+//\n+// You should have received a copy of the CC0 Public Domain Dedication\n+// along with this software.\n+// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n+//\n+\n+// This module is largely copied from the rust-crypto ripemd.rs file;\n+// while rust-crypto is licensed under Apache, that file specifically\n+// was written entirely by Andrew Poelstra, who is re-licensing its\n+// contents here as CC0.\n+\n+//! # RIPEMD160\n+\n+use core::{cmp, str};\n+\n+use HashEngine as EngineTrait;\n+use Hash as HashTrait;\n+use Error;\n+use util;\n+\n+const BLOCK_SIZE: usize = 64;\n+\n+/// Engine to compute RIPEMD160 hash function\n+#[derive(Clone)]\n+pub struct HashEngine {\n+    buffer: [u8; BLOCK_SIZE],\n+    h: [u32; 5],\n+    length: usize,\n+}\n+\n+impl Default for HashEngine {\n+    fn default() -> Self {\n+        HashEngine {\n+            h: [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0],\n+            length: 0,\n+            buffer: [0; BLOCK_SIZE],\n+        }\n+    }\n+}\n+\n+impl EngineTrait for HashEngine {\n+    type MidState = [u8; 20];\n+\n+    #[cfg(not(feature = \"fuzztarget\"))]\n+    fn midstate(&self) -> [u8; 20] {\n+        let mut ret = [0; 20];\n+        for (val, ret_bytes) in self.h.iter().zip(ret.chunks_mut(4)) {\n+            ret_bytes.copy_from_slice(&util::u32_to_array_le(*val));\n+        }\n+        ret\n+    }\n+\n+    #[cfg(feature = \"fuzztarget\")]\n+    fn midstate(&self) -> [u8; 20] {\n+        let mut ret = [0; 20];\n+        ret.copy_from_slice(&self.buffer[..20]);\n+        ret\n+    }\n+\n+    const BLOCK_SIZE: usize = 64;\n+\n+    engine_input_impl!();\n+}\n+\n+/// Output of the RIPEMD160 hash function\n+#[derive(Copy, Clone, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n+pub struct Hash([u8; 20]);\n+\n+hex_fmt_impl!(Debug, Hash);\n+hex_fmt_impl!(Display, Hash);\n+hex_fmt_impl!(LowerHex, Hash);\n+index_impl!(Hash);\n+serde_impl!(Hash, 20);\n+borrow_slice_impl!(Hash);\n+\n+impl str::FromStr for Hash {\n+    type Err = ::hex::Error;\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        ::hex::FromHex::from_hex(s)\n+    }\n+}\n+\n+impl HashTrait for Hash {\n+    type Engine = HashEngine;\n+    type Inner = [u8; 20];\n+\n+    #[cfg(not(feature = \"fuzztarget\"))]\n+    fn from_engine(mut e: HashEngine) -> Hash {\n+        // pad buffer with a single 1-bit then all 0s, until there are exactly 8 bytes remaining\n+        let data_len = e.length as u64;\n+\n+        let zeroes = [0; BLOCK_SIZE - 8];\n+        e.input(&[0x80]);\n+        if e.length % BLOCK_SIZE > zeroes.len() {\n+            e.input(&zeroes);\n+        }\n+        let pad_length = zeroes.len() - (e.length % BLOCK_SIZE);\n+        e.input(&zeroes[..pad_length]);\n+        debug_assert_eq!(e.length % BLOCK_SIZE, zeroes.len());\n+\n+        e.input(&util::u64_to_array_le(8 * data_len));\n+        debug_assert_eq!(e.length % BLOCK_SIZE, 0);\n+\n+        Hash(e.midstate())\n+    }\n+\n+    #[cfg(feature = \"fuzztarget\")]\n+    fn from_engine(e: HashEngine) -> Hash {\n+        let mut res = e.midstate();\n+        res[0] ^= (e.length & 0xff) as u8;\n+        Hash(res)\n+    }\n+\n+    const LEN: usize = 20;\n+\n+    fn from_slice(sl: &[u8]) -> Result<Hash, Error> {\n+        if sl.len() != 20 {\n+            Err(Error::InvalidLength(Self::LEN, sl.len()))\n+        } else {\n+            let mut ret = [0; 20];\n+            ret.copy_from_slice(sl);\n+            Ok(Hash(ret))\n+        }\n+    }\n+\n+    fn into_inner(self) -> Self::Inner {\n+        self.0\n+    }\n+\n+    fn from_inner(inner: Self::Inner) -> Self {\n+        Hash(inner)\n+    }\n+}\n+\n+macro_rules! round(\n+    ($a:expr, $b:expr, $c:expr, $d:expr, $e:expr,\n+     $x:expr, $bits:expr, $add:expr, $round:expr) => ({\n+        $a = $a.wrapping_add($round).wrapping_add($x).wrapping_add($add);\n+        $a = circular_lshift32!($bits, $a).wrapping_add($e);\n+        $c = circular_lshift32!(10, $c);\n+    });\n+);\n+\n+macro_rules! process_block(\n+    ($h:expr, $data:expr,\n+     $( round1: h_ordering $f0:expr, $f1:expr, $f2:expr, $f3:expr, $f4:expr;\n+                data_index $data_index1:expr; roll_shift $bits1:expr; )*\n+     $( round2: h_ordering $g0:expr, $g1:expr, $g2:expr, $g3:expr, $g4:expr;\n+                data_index $data_index2:expr; roll_shift $bits2:expr; )*\n+     $( round3: h_ordering $h0:expr, $h1:expr, $h2:expr, $h3:expr, $h4:expr;\n+                data_index $data_index3:expr; roll_shift $bits3:expr; )*\n+     $( round4: h_ordering $i0:expr, $i1:expr, $i2:expr, $i3:expr, $i4:expr;\n+                data_index $data_index4:expr; roll_shift $bits4:expr; )*\n+     $( round5: h_ordering $j0:expr, $j1:expr, $j2:expr, $j3:expr, $j4:expr;\n+                data_index $data_index5:expr; roll_shift $bits5:expr; )*\n+     $( par_round1: h_ordering $pj0:expr, $pj1:expr, $pj2:expr, $pj3:expr, $pj4:expr;\n+                    data_index $pdata_index1:expr; roll_shift $pbits1:expr; )*\n+     $( par_round2: h_ordering $pi0:expr, $pi1:expr, $pi2:expr, $pi3:expr, $pi4:expr;\n+                    data_index $pdata_index2:expr; roll_shift $pbits2:expr; )*\n+     $( par_round3: h_ordering $ph0:expr, $ph1:expr, $ph2:expr, $ph3:expr, $ph4:expr;\n+                    data_index $pdata_index3:expr; roll_shift $pbits3:expr; )*\n+     $( par_round4: h_ordering $pg0:expr, $pg1:expr, $pg2:expr, $pg3:expr, $pg4:expr;\n+                    data_index $pdata_index4:expr; roll_shift $pbits4:expr; )*\n+     $( par_round5: h_ordering $pf0:expr, $pf1:expr, $pf2:expr, $pf3:expr, $pf4:expr;\n+                    data_index $pdata_index5:expr; roll_shift $pbits5:expr; )*\n+    ) => ({\n+        let mut bb = $h;\n+        let mut bbb = $h;\n+\n+        // Round 1\n+        $( round!(bb[$f0], bb[$f1], bb[$f2], bb[$f3], bb[$f4],\n+                  $data[$data_index1], $bits1, 0x00000000,\n+                  bb[$f1] ^ bb[$f2] ^ bb[$f3]); )*\n+\n+        // Round 2\n+        $( round!(bb[$g0], bb[$g1], bb[$g2], bb[$g3], bb[$g4],\n+                  $data[$data_index2], $bits2, 0x5a827999,\n+                  (bb[$g1] & bb[$g2]) | (!bb[$g1] & bb[$g3])); )*\n+\n+        // Round 3\n+        $( round!(bb[$h0], bb[$h1], bb[$h2], bb[$h3], bb[$h4],\n+                  $data[$data_index3], $bits3, 0x6ed9eba1,\n+                  (bb[$h1] | !bb[$h2]) ^ bb[$h3]); )*\n+\n+        // Round 4\n+        $( round!(bb[$i0], bb[$i1], bb[$i2], bb[$i3], bb[$i4],\n+                  $data[$data_index4], $bits4, 0x8f1bbcdc,\n+                  (bb[$i1] & bb[$i3]) | (bb[$i2] & !bb[$i3])); )*\n+\n+        // Round 5\n+        $( round!(bb[$j0], bb[$j1], bb[$j2], bb[$j3], bb[$j4],\n+                  $data[$data_index5], $bits5, 0xa953fd4e,\n+                  bb[$j1] ^ (bb[$j2] | !bb[$j3])); )*\n+\n+        // Parallel rounds: these are the same as the previous five\n+        // rounds except that the constants have changed, we work\n+        // with the other buffer, and they are applied in reverse\n+        // order.\n+\n+        // Parallel Round 1\n+        $( round!(bbb[$pj0], bbb[$pj1], bbb[$pj2], bbb[$pj3], bbb[$pj4],\n+                  $data[$pdata_index1], $pbits1, 0x50a28be6,\n+                  bbb[$pj1] ^ (bbb[$pj2] | !bbb[$pj3])); )*\n+\n+        // Porallel Round 2\n+        $( round!(bbb[$pi0], bbb[$pi1], bbb[$pi2], bbb[$pi3], bbb[$pi4],\n+                  $data[$pdata_index2], $pbits2, 0x5c4dd124,\n+                  (bbb[$pi1] & bbb[$pi3]) | (bbb[$pi2] & !bbb[$pi3])); )*\n+\n+        // Parallel Round 3\n+        $( round!(bbb[$ph0], bbb[$ph1], bbb[$ph2], bbb[$ph3], bbb[$ph4],\n+                  $data[$pdata_index3], $pbits3, 0x6d703ef3,\n+                  (bbb[$ph1] | !bbb[$ph2]) ^ bbb[$ph3]); )*\n+\n+        // Parallel Round 4\n+        $( round!(bbb[$pg0], bbb[$pg1], bbb[$pg2], bbb[$pg3], bbb[$pg4],\n+                  $data[$pdata_index4], $pbits4, 0x7a6d76e9,\n+                  (bbb[$pg1] & bbb[$pg2]) | (!bbb[$pg1] & bbb[$pg3])); )*\n+\n+        // Parallel Round 5\n+        $( round!(bbb[$pf0], bbb[$pf1], bbb[$pf2], bbb[$pf3], bbb[$pf4],\n+                  $data[$pdata_index5], $pbits5, 0x00000000,\n+                  bbb[$pf1] ^ bbb[$pf2] ^ bbb[$pf3]); )*\n+\n+        // Combine results\n+        bbb[3] = bbb[3].wrapping_add($h[1]).wrapping_add(bb[2]);\n+        $h[1]  =  $h[2].wrapping_add(bb[3]).wrapping_add(bbb[4]);\n+        $h[2]  =  $h[3].wrapping_add(bb[4]).wrapping_add(bbb[0]);\n+        $h[3]  =  $h[4].wrapping_add(bb[0]).wrapping_add(bbb[1]);\n+        $h[4]  =  $h[0].wrapping_add(bb[1]).wrapping_add(bbb[2]);\n+        $h[0]  =                                         bbb[3];\n+    });\n+);\n+\n+impl HashEngine {\n+    fn process_block(&mut self) {\n+        debug_assert_eq!(self.buffer.len(), BLOCK_SIZE);\n+\n+        let mut w = [0u32; 16];\n+        for (w_val, buff_bytes) in w.iter_mut().zip(self.buffer.chunks(4)) {\n+            *w_val = util::slice_to_u32_le(buff_bytes);\n+        }\n+\n+        process_block!(self.h, w,\n+            // Round 1\n+            round1: h_ordering 0, 1, 2, 3, 4; data_index  0; roll_shift 11;\n+            round1: h_ordering 4, 0, 1, 2, 3; data_index  1; roll_shift 14;\n+            round1: h_ordering 3, 4, 0, 1, 2; data_index  2; roll_shift 15;\n+            round1: h_ordering 2, 3, 4, 0, 1; data_index  3; roll_shift 12;\n+            round1: h_ordering 1, 2, 3, 4, 0; data_index  4; roll_shift  5;\n+            round1: h_ordering 0, 1, 2, 3, 4; data_index  5; roll_shift  8;\n+            round1: h_ordering 4, 0, 1, 2, 3; data_index  6; roll_shift  7;\n+            round1: h_ordering 3, 4, 0, 1, 2; data_index  7; roll_shift  9;\n+            round1: h_ordering 2, 3, 4, 0, 1; data_index  8; roll_shift 11;\n+            round1: h_ordering 1, 2, 3, 4, 0; data_index  9; roll_shift 13;\n+            round1: h_ordering 0, 1, 2, 3, 4; data_index 10; roll_shift 14;\n+            round1: h_ordering 4, 0, 1, 2, 3; data_index 11; roll_shift 15;\n+            round1: h_ordering 3, 4, 0, 1, 2; data_index 12; roll_shift  6;\n+            round1: h_ordering 2, 3, 4, 0, 1; data_index 13; roll_shift  7;\n+            round1: h_ordering 1, 2, 3, 4, 0; data_index 14; roll_shift  9;\n+            round1: h_ordering 0, 1, 2, 3, 4; data_index 15; roll_shift  8;\n+\n+            // Round 2\n+            round2: h_ordering 4, 0, 1, 2, 3; data_index  7; roll_shift  7;\n+            round2: h_ordering 3, 4, 0, 1, 2; data_index  4; roll_shift  6;\n+            round2: h_ordering 2, 3, 4, 0, 1; data_index 13; roll_shift  8;\n+            round2: h_ordering 1, 2, 3, 4, 0; data_index  1; roll_shift 13;\n+            round2: h_ordering 0, 1, 2, 3, 4; data_index 10; roll_shift 11;\n+            round2: h_ordering 4, 0, 1, 2, 3; data_index  6; roll_shift  9;\n+            round2: h_ordering 3, 4, 0, 1, 2; data_index 15; roll_shift  7;\n+            round2: h_ordering 2, 3, 4, 0, 1; data_index  3; roll_shift 15;\n+            round2: h_ordering 1, 2, 3, 4, 0; data_index 12; roll_shift  7;\n+            round2: h_ordering 0, 1, 2, 3, 4; data_index  0; roll_shift 12;\n+            round2: h_ordering 4, 0, 1, 2, 3; data_index  9; roll_shift 15;\n+            round2: h_ordering 3, 4, 0, 1, 2; data_index  5; roll_shift  9;\n+            round2: h_ordering 2, 3, 4, 0, 1; data_index  2; roll_shift 11;\n+            round2: h_ordering 1, 2, 3, 4, 0; data_index 14; roll_shift  7;\n+            round2: h_ordering 0, 1, 2, 3, 4; data_index 11; roll_shift 13;\n+            round2: h_ordering 4, 0, 1, 2, 3; data_index  8; roll_shift 12;\n+\n+            // Round 3\n+            round3: h_ordering 3, 4, 0, 1, 2; data_index  3; roll_shift 11;\n+            round3: h_ordering 2, 3, 4, 0, 1; data_index 10; roll_shift 13;\n+            round3: h_ordering 1, 2, 3, 4, 0; data_index 14; roll_shift  6;\n+            round3: h_ordering 0, 1, 2, 3, 4; data_index  4; roll_shift  7;\n+            round3: h_ordering 4, 0, 1, 2, 3; data_index  9; roll_shift 14;\n+            round3: h_ordering 3, 4, 0, 1, 2; data_index 15; roll_shift  9;\n+            round3: h_ordering 2, 3, 4, 0, 1; data_index  8; roll_shift 13;\n+            round3: h_ordering 1, 2, 3, 4, 0; data_index  1; roll_shift 15;\n+            round3: h_ordering 0, 1, 2, 3, 4; data_index  2; roll_shift 14;\n+            round3: h_ordering 4, 0, 1, 2, 3; data_index  7; roll_shift  8;\n+            round3: h_ordering 3, 4, 0, 1, 2; data_index  0; roll_shift 13;\n+            round3: h_ordering 2, 3, 4, 0, 1; data_index  6; roll_shift  6;\n+            round3: h_ordering 1, 2, 3, 4, 0; data_index 13; roll_shift  5;\n+            round3: h_ordering 0, 1, 2, 3, 4; data_index 11; roll_shift 12;\n+            round3: h_ordering 4, 0, 1, 2, 3; data_index  5; roll_shift  7;\n+            round3: h_ordering 3, 4, 0, 1, 2; data_index 12; roll_shift  5;\n+\n+            // Round 4\n+            round4: h_ordering 2, 3, 4, 0, 1; data_index  1; roll_shift 11;\n+            round4: h_ordering 1, 2, 3, 4, 0; data_index  9; roll_shift 12;\n+            round4: h_ordering 0, 1, 2, 3, 4; data_index 11; roll_shift 14;\n+            round4: h_ordering 4, 0, 1, 2, 3; data_index 10; roll_shift 15;\n+            round4: h_ordering 3, 4, 0, 1, 2; data_index  0; roll_shift 14;\n+            round4: h_ordering 2, 3, 4, 0, 1; data_index  8; roll_shift 15;\n+            round4: h_ordering 1, 2, 3, 4, 0; data_index 12; roll_shift  9;\n+            round4: h_ordering 0, 1, 2, 3, 4; data_index  4; roll_shift  8;\n+            round4: h_ordering 4, 0, 1, 2, 3; data_index 13; roll_shift  9;\n+            round4: h_ordering 3, 4, 0, 1, 2; data_index  3; roll_shift 14;\n+            round4: h_ordering 2, 3, 4, 0, 1; data_index  7; roll_shift  5;\n+            round4: h_ordering 1, 2, 3, 4, 0; data_index 15; roll_shift  6;\n+            round4: h_ordering 0, 1, 2, 3, 4; data_index 14; roll_shift  8;\n+            round4: h_ordering 4, 0, 1, 2, 3; data_index  5; roll_shift  6;\n+            round4: h_ordering 3, 4, 0, 1, 2; data_index  6; roll_shift  5;\n+            round4: h_ordering 2, 3, 4, 0, 1; data_index  2; roll_shift 12;\n+\n+            // Round 5\n+            round5: h_ordering 1, 2, 3, 4, 0; data_index  4; roll_shift  9;\n+            round5: h_ordering 0, 1, 2, 3, 4; data_index  0; roll_shift 15;\n+            round5: h_ordering 4, 0, 1, 2, 3; data_index  5; roll_shift  5;\n+            round5: h_ordering 3, 4, 0, 1, 2; data_index  9; roll_shift 11;\n+            round5: h_ordering 2, 3, 4, 0, 1; data_index  7; roll_shift  6;\n+            round5: h_ordering 1, 2, 3, 4, 0; data_index 12; roll_shift  8;\n+            round5: h_ordering 0, 1, 2, 3, 4; data_index  2; roll_shift 13;\n+            round5: h_ordering 4, 0, 1, 2, 3; data_index 10; roll_shift 12;\n+            round5: h_ordering 3, 4, 0, 1, 2; data_index 14; roll_shift  5;\n+            round5: h_ordering 2, 3, 4, 0, 1; data_index  1; roll_shift 12;\n+            round5: h_ordering 1, 2, 3, 4, 0; data_index  3; roll_shift 13;\n+            round5: h_ordering 0, 1, 2, 3, 4; data_index  8; roll_shift 14;\n+            round5: h_ordering 4, 0, 1, 2, 3; data_index 11; roll_shift 11;\n+            round5: h_ordering 3, 4, 0, 1, 2; data_index  6; roll_shift  8;\n+            round5: h_ordering 2, 3, 4, 0, 1; data_index 15; roll_shift  5;\n+            round5: h_ordering 1, 2, 3, 4, 0; data_index 13; roll_shift  6;\n+\n+            // Porallel Round 1;\n+            par_round1: h_ordering 0, 1, 2, 3, 4; data_index  5; roll_shift  8;\n+            par_round1: h_ordering 4, 0, 1, 2, 3; data_index 14; roll_shift  9;\n+            par_round1: h_ordering 3, 4, 0, 1, 2; data_index  7; roll_shift  9;\n+            par_round1: h_ordering 2, 3, 4, 0, 1; data_index  0; roll_shift 11;\n+            par_round1: h_ordering 1, 2, 3, 4, 0; data_index  9; roll_shift 13;\n+            par_round1: h_ordering 0, 1, 2, 3, 4; data_index  2; roll_shift 15;\n+            par_round1: h_ordering 4, 0, 1, 2, 3; data_index 11; roll_shift 15;\n+            par_round1: h_ordering 3, 4, 0, 1, 2; data_index  4; roll_shift  5;\n+            par_round1: h_ordering 2, 3, 4, 0, 1; data_index 13; roll_shift  7;\n+            par_round1: h_ordering 1, 2, 3, 4, 0; data_index  6; roll_shift  7;\n+            par_round1: h_ordering 0, 1, 2, 3, 4; data_index 15; roll_shift  8;\n+            par_round1: h_ordering 4, 0, 1, 2, 3; data_index  8; roll_shift 11;\n+            par_round1: h_ordering 3, 4, 0, 1, 2; data_index  1; roll_shift 14;\n+            par_round1: h_ordering 2, 3, 4, 0, 1; data_index 10; roll_shift 14;\n+            par_round1: h_ordering 1, 2, 3, 4, 0; data_index  3; roll_shift 12;\n+            par_round1: h_ordering 0, 1, 2, 3, 4; data_index 12; roll_shift  6;\n+\n+            // Parallel Round 2\n+            par_round2: h_ordering 4, 0, 1, 2, 3; data_index  6; roll_shift  9;\n+            par_round2: h_ordering 3, 4, 0, 1, 2; data_index 11; roll_shift 13;\n+            par_round2: h_ordering 2, 3, 4, 0, 1; data_index  3; roll_shift 15;\n+            par_round2: h_ordering 1, 2, 3, 4, 0; data_index  7; roll_shift  7;\n+            par_round2: h_ordering 0, 1, 2, 3, 4; data_index  0; roll_shift 12;\n+            par_round2: h_ordering 4, 0, 1, 2, 3; data_index 13; roll_shift  8;\n+            par_round2: h_ordering 3, 4, 0, 1, 2; data_index  5; roll_shift  9;\n+            par_round2: h_ordering 2, 3, 4, 0, 1; data_index 10; roll_shift 11;\n+            par_round2: h_ordering 1, 2, 3, 4, 0; data_index 14; roll_shift  7;\n+            par_round2: h_ordering 0, 1, 2, 3, 4; data_index 15; roll_shift  7;\n+            par_round2: h_ordering 4, 0, 1, 2, 3; data_index  8; roll_shift 12;\n+            par_round2: h_ordering 3, 4, 0, 1, 2; data_index 12; roll_shift  7;\n+            par_round2: h_ordering 2, 3, 4, 0, 1; data_index  4; roll_shift  6;\n+            par_round2: h_ordering 1, 2, 3, 4, 0; data_index  9; roll_shift 15;\n+            par_round2: h_ordering 0, 1, 2, 3, 4; data_index  1; roll_shift 13;\n+            par_round2: h_ordering 4, 0, 1, 2, 3; data_index  2; roll_shift 11;\n+\n+            // Parallel Round 3\n+            par_round3: h_ordering 3, 4, 0, 1, 2; data_index 15; roll_shift  9;\n+            par_round3: h_ordering 2, 3, 4, 0, 1; data_index  5; roll_shift  7;\n+            par_round3: h_ordering 1, 2, 3, 4, 0; data_index  1; roll_shift 15;\n+            par_round3: h_ordering 0, 1, 2, 3, 4; data_index  3; roll_shift 11;\n+            par_round3: h_ordering 4, 0, 1, 2, 3; data_index  7; roll_shift  8;\n+            par_round3: h_ordering 3, 4, 0, 1, 2; data_index 14; roll_shift  6;\n+            par_round3: h_ordering 2, 3, 4, 0, 1; data_index  6; roll_shift  6;\n+            par_round3: h_ordering 1, 2, 3, 4, 0; data_index  9; roll_shift 14;\n+            par_round3: h_ordering 0, 1, 2, 3, 4; data_index 11; roll_shift 12;\n+            par_round3: h_ordering 4, 0, 1, 2, 3; data_index  8; roll_shift 13;\n+            par_round3: h_ordering 3, 4, 0, 1, 2; data_index 12; roll_shift  5;\n+            par_round3: h_ordering 2, 3, 4, 0, 1; data_index  2; roll_shift 14;\n+            par_round3: h_ordering 1, 2, 3, 4, 0; data_index 10; roll_shift 13;\n+            par_round3: h_ordering 0, 1, 2, 3, 4; data_index  0; roll_shift 13;\n+            par_round3: h_ordering 4, 0, 1, 2, 3; data_index  4; roll_shift  7;\n+            par_round3: h_ordering 3, 4, 0, 1, 2; data_index 13; roll_shift  5;\n+\n+            // Parallel Round 4\n+            par_round4: h_ordering 2, 3, 4, 0, 1; data_index  8; roll_shift 15;\n+            par_round4: h_ordering 1, 2, 3, 4, 0; data_index  6; roll_shift  5;\n+            par_round4: h_ordering 0, 1, 2, 3, 4; data_index  4; roll_shift  8;\n+            par_round4: h_ordering 4, 0, 1, 2, 3; data_index  1; roll_shift 11;\n+            par_round4: h_ordering 3, 4, 0, 1, 2; data_index  3; roll_shift 14;\n+            par_round4: h_ordering 2, 3, 4, 0, 1; data_index 11; roll_shift 14;\n+            par_round4: h_ordering 1, 2, 3, 4, 0; data_index 15; roll_shift  6;\n+            par_round4: h_ordering 0, 1, 2, 3, 4; data_index  0; roll_shift 14;\n+            par_round4: h_ordering 4, 0, 1, 2, 3; data_index  5; roll_shift  6;\n+            par_round4: h_ordering 3, 4, 0, 1, 2; data_index 12; roll_shift  9;\n+            par_round4: h_ordering 2, 3, 4, 0, 1; data_index  2; roll_shift 12;\n+            par_round4: h_ordering 1, 2, 3, 4, 0; data_index 13; roll_shift  9;\n+            par_round4: h_ordering 0, 1, 2, 3, 4; data_index  9; roll_shift 12;\n+            par_round4: h_ordering 4, 0, 1, 2, 3; data_index  7; roll_shift  5;\n+            par_round4: h_ordering 3, 4, 0, 1, 2; data_index 10; roll_shift 15;\n+            par_round4: h_ordering 2, 3, 4, 0, 1; data_index 14; roll_shift  8;\n+\n+            // Parallel Round 5\n+            par_round5: h_ordering 1, 2, 3, 4, 0; data_index 12; roll_shift  8;\n+            par_round5: h_ordering 0, 1, 2, 3, 4; data_index 15; roll_shift  5;\n+            par_round5: h_ordering 4, 0, 1, 2, 3; data_index 10; roll_shift 12;\n+            par_round5: h_ordering 3, 4, 0, 1, 2; data_index  4; roll_shift  9;\n+            par_round5: h_ordering 2, 3, 4, 0, 1; data_index  1; roll_shift 12;\n+            par_round5: h_ordering 1, 2, 3, 4, 0; data_index  5; roll_shift  5;\n+            par_round5: h_ordering 0, 1, 2, 3, 4; data_index  8; roll_shift 14;\n+            par_round5: h_ordering 4, 0, 1, 2, 3; data_index  7; roll_shift  6;\n+            par_round5: h_ordering 3, 4, 0, 1, 2; data_index  6; roll_shift  8;\n+            par_round5: h_ordering 2, 3, 4, 0, 1; data_index  2; roll_shift 13;\n+            par_round5: h_ordering 1, 2, 3, 4, 0; data_index 13; roll_shift  6;\n+            par_round5: h_ordering 0, 1, 2, 3, 4; data_index 14; roll_shift  5;\n+            par_round5: h_ordering 4, 0, 1, 2, 3; data_index  0; roll_shift 15;\n+            par_round5: h_ordering 3, 4, 0, 1, 2; data_index  3; roll_shift 13;\n+            par_round5: h_ordering 2, 3, 4, 0, 1; data_index  9; roll_shift 11;\n+            par_round5: h_ordering 1, 2, 3, 4, 0; data_index 11; roll_shift 11;\n+        );\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use ripemd160;\n+    use hex::{FromHex, ToHex};\n+    use Hash;\n+    use HashEngine;\n+\n+    #[derive(Clone)]\n+    struct Test {\n+        input: &'static str,\n+        output: Vec<u8>,\n+        output_str: &'static str,\n+    }\n+\n+    #[test]\n+    fn test() {\n+        let tests = vec![\n+            // Test messages from FIPS 180-1\n+            Test {\n+                input: \"abc\",\n+                output: vec![\n+                    0x8e, 0xb2, 0x08, 0xf7,\n+                    0xe0, 0x5d, 0x98, 0x7a,\n+                    0x9b, 0x04, 0x4a, 0x8e,\n+                    0x98, 0xc6, 0xb0, 0x87,\n+                    0xf1, 0x5a, 0x0b, 0xfc,\n+                ],\n+                output_str: \"8eb208f7e05d987a9b044a8e98c6b087f15a0bfc\"\n+            },\n+            Test {\n+                input:\n+                     \"abcdbcdecdefdefgefghfghighijhijkijkljklmklmnlmnomnopnopq\",\n+                output: vec![\n+                    0x12, 0xa0, 0x53, 0x38,\n+                    0x4a, 0x9c, 0x0c, 0x88,\n+                    0xe4, 0x05, 0xa0, 0x6c,\n+                    0x27, 0xdc, 0xf4, 0x9a,\n+                    0xda, 0x62, 0xeb, 0x2b,\n+                ],\n+                output_str: \"12a053384a9c0c88e405a06c27dcf49ada62eb2b\"\n+            },\n+            // Examples from wikipedia\n+            Test {\n+                input: \"The quick brown fox jumps over the lazy dog\",\n+                output: vec![\n+                    0x37, 0xf3, 0x32, 0xf6,\n+                    0x8d, 0xb7, 0x7b, 0xd9,\n+                    0xd7, 0xed, 0xd4, 0x96,\n+                    0x95, 0x71, 0xad, 0x67,\n+                    0x1c, 0xf9, 0xdd, 0x3b,\n+                ],\n+                output_str: \"37f332f68db77bd9d7edd4969571ad671cf9dd3b\",\n+            },\n+            Test {\n+                input: \"The quick brown fox jumps over the lazy cog\",\n+                output: vec![\n+                    0x13, 0x20, 0x72, 0xdf,\n+                    0x69, 0x09, 0x33, 0x83,\n+                    0x5e, 0xb8, 0xb6, 0xad,\n+                    0x0b, 0x77, 0xe7, 0xb6,\n+                    0xf1, 0x4a, 0xca, 0xd7,\n+                ],\n+                output_str: \"132072df690933835eb8b6ad0b77e7b6f14acad7\",\n+            },\n+        ];\n+\n+        for test in tests {\n+            // Hash through high-level API, check hex encoding/decoding\n+            let hash = ripemd160::Hash::hash(&test.input.as_bytes());\n+            assert_eq!(hash, ripemd160::Hash::from_hex(test.output_str).expect(\"parse hex\"));\n+            assert_eq!(&hash[..], &test.output[..]);\n+            assert_eq!(&hash.to_hex(), &test.output_str);\n+\n+            // Hash through engine, checking that we can input byte by byte\n+            let mut engine = ripemd160::Hash::engine();\n+            for ch in test.input.as_bytes() {\n+                engine.input(&[*ch]);\n+            }\n+            let manual_hash = ripemd160::Hash::from_engine(engine);\n+            assert_eq!(hash, manual_hash);\n+            assert_eq!(hash.into_inner()[..].as_ref(), test.output.as_slice());\n+        }\n+    }\n+\n+    #[cfg(feature=\"serde\")]\n+    #[test]\n+    fn ripemd_serde() {\n+        use serde_test::{Configure, Token, assert_tokens};\n+\n+        static HASH_BYTES: [u8; 20] = [\n+            0x13, 0x20, 0x72, 0xdf,\n+            0x69, 0x09, 0x33, 0x83,\n+            0x5e, 0xb8, 0xb6, 0xad,\n+            0x0b, 0x77, 0xe7, 0xb6,\n+            0xf1, 0x4a, 0xca, 0xd7,\n+        ];\n+\n+        let hash = ripemd160::Hash::from_slice(&HASH_BYTES).expect(\"right number of bytes\");\n+        assert_tokens(&hash.compact(), &[Token::BorrowedBytes(&HASH_BYTES[..])]);\n+        assert_tokens(&hash.readable(), &[Token::Str(\"132072df690933835eb8b6ad0b77e7b6f14acad7\")]);\n+    }\n+}\n+\n+#[cfg(all(test, feature=\"unstable\"))]\n+mod benches {\n+    use test::Bencher;\n+\n+    use ripemd160;\n+    use Hash;\n+    use HashEngine;\n+\n+    #[bench]\n+    pub fn ripemd160_10(bh: & mut Bencher) {\n+        let mut engine = ripemd160::Hash::engine();\n+        let bytes = [1u8; 10];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn ripemd160_1k(bh: & mut Bencher) {\n+        let mut engine = ripemd160::Hash::engine();\n+        let bytes = [1u8; 1024];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn ripemd160_64k(bh: & mut Bencher) {\n+        let mut engine = ripemd160::Hash::engine();\n+        let bytes = [1u8; 65536];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+}"
      },
      {
        "sha": "922fa240ca6f8cbe10fb2a5d9940091a1e732d37",
        "filename": "src/rusty/bitcoin_hashes/src/serde_macros.rs",
        "status": "added",
        "additions": 86,
        "deletions": 0,
        "changes": 86,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/serde_macros.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/serde_macros.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/src/serde_macros.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,86 @@\n+\n+#[cfg(feature=\"serde\")]\n+/// Implements `Serialize` and `Deserialize` for a type `$t` which\n+/// represents a newtype over a byte-slice over length `$len`.\n+macro_rules! serde_impl(\n+    ($t:ident, $len:expr) => (\n+        impl ::serde::Serialize for $t {\n+            fn serialize<S: ::serde::Serializer>(&self, s: S) -> Result<S::Ok, S::Error> {\n+                use hex::ToHex;\n+                if s.is_human_readable() {\n+                    s.serialize_str(&self.to_hex())\n+                } else {\n+                    s.serialize_bytes(&self[..])\n+                }\n+            }\n+        }\n+\n+        impl<'de> ::serde::Deserialize<'de> for $t {\n+            fn deserialize<D: ::serde::Deserializer<'de>>(d: D) -> Result<$t, D::Error> {\n+                use hex::FromHex;\n+\n+                if d.is_human_readable() {\n+                    struct HexVisitor;\n+\n+                    impl<'de> ::serde::de::Visitor<'de> for HexVisitor {\n+                        type Value = $t;\n+\n+                        fn expecting(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+                            formatter.write_str(\"an ASCII hex string\")\n+                        }\n+\n+                        fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n+                        where\n+                            E: ::serde::de::Error,\n+                        {\n+                            if let Ok(hex) = ::std::str::from_utf8(v) {\n+                                $t::from_hex(hex).map_err(E::custom)\n+                            } else {\n+                                return Err(E::invalid_value(::serde::de::Unexpected::Bytes(v), &self));\n+                            }\n+                        }\n+\n+                        fn visit_str<E>(self, v: &str) -> Result<Self::Value, E>\n+                        where\n+                            E: ::serde::de::Error,\n+                        {\n+                            $t::from_hex(v).map_err(E::custom)\n+                        }\n+                    }\n+\n+                    d.deserialize_str(HexVisitor)\n+                } else {\n+                    struct BytesVisitor;\n+\n+                    impl<'de> ::serde::de::Visitor<'de> for BytesVisitor {\n+                        type Value = $t;\n+\n+                        fn expecting(&self, formatter: &mut ::std::fmt::Formatter) -> ::std::fmt::Result {\n+                            formatter.write_str(\"a bytestring\")\n+                        }\n+\n+                        fn visit_bytes<E>(self, v: &[u8]) -> Result<Self::Value, E>\n+                        where\n+                            E: ::serde::de::Error,\n+                        {\n+                            if v.len() != $t::LEN {\n+                                Err(E::invalid_length(v.len(), &stringify!($len)))\n+                            } else {\n+                                let mut ret = [0; $len];\n+                                ret.copy_from_slice(v);\n+                                Ok($t(ret))\n+                            }\n+                        }\n+                    }\n+\n+                    d.deserialize_bytes(BytesVisitor)\n+                }\n+            }\n+        }\n+    )\n+);\n+\n+#[cfg(not(feature=\"serde\"))]\n+macro_rules! serde_impl(\n+    ($t:ident, $len:expr) => ()\n+);"
      },
      {
        "sha": "cbfe658d44a9fcc145bdc64adb6ef9fe4aa8acc1",
        "filename": "src/rusty/bitcoin_hashes/src/sha1.rs",
        "status": "added",
        "additions": 302,
        "deletions": 0,
        "changes": 302,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/sha1.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/sha1.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/src/sha1.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,302 @@\n+// Bitcoin Hashes Library\n+// Written in 2018 by\n+//   Andrew Poelstra <apoelstra@wpsoftware.net>\n+//\n+// To the extent possible under law, the author(s) have dedicated all\n+// copyright and related and neighboring rights to this software to\n+// the public domain worldwide. This software is distributed without\n+// any warranty.\n+//\n+// You should have received a copy of the CC0 Public Domain Dedication\n+// along with this software.\n+// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n+//\n+\n+//! # SHA1\n+\n+use core::{cmp, str};\n+\n+use HashEngine as EngineTrait;\n+use Hash as HashTrait;\n+use Error;\n+use util;\n+\n+const BLOCK_SIZE: usize = 64;\n+\n+/// Engine to compute SHA1 hash function\n+#[derive(Clone)]\n+pub struct HashEngine {\n+    buffer: [u8; BLOCK_SIZE],\n+    h: [u32; 5],\n+    length: usize,\n+}\n+\n+impl Default for HashEngine {\n+    fn default() -> Self {\n+        HashEngine {\n+            h: [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476, 0xc3d2e1f0],\n+            length: 0,\n+            buffer: [0; BLOCK_SIZE],\n+        }\n+    }\n+}\n+\n+impl EngineTrait for HashEngine {\n+    type MidState = [u8; 20];\n+\n+    #[cfg(not(feature = \"fuzztarget\"))]\n+    fn midstate(&self) -> [u8; 20] {\n+        let mut ret = [0; 20];\n+        for (val, ret_bytes) in self.h.iter().zip(ret.chunks_mut(4)) {\n+            ret_bytes.copy_from_slice(&util::u32_to_array_be(*val));\n+        }\n+        ret\n+    }\n+\n+    #[cfg(feature = \"fuzztarget\")]\n+    fn midstate(&self) -> [u8; 20] {\n+        let mut ret = [0; 20];\n+        ret.copy_from_slice(&self.buffer[..20]);\n+        ret\n+    }\n+\n+    const BLOCK_SIZE: usize = 64;\n+\n+    engine_input_impl!();\n+}\n+\n+/// Output of the SHA1 hash function\n+#[derive(Copy, Clone, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n+pub struct Hash([u8; 20]);\n+\n+hex_fmt_impl!(Debug, Hash);\n+hex_fmt_impl!(Display, Hash);\n+hex_fmt_impl!(LowerHex, Hash);\n+index_impl!(Hash);\n+serde_impl!(Hash, 20);\n+borrow_slice_impl!(Hash);\n+\n+impl str::FromStr for Hash {\n+    type Err = ::hex::Error;\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        ::hex::FromHex::from_hex(s)\n+    }\n+}\n+\n+impl HashTrait for Hash {\n+    type Engine = HashEngine;\n+    type Inner = [u8; 20];\n+\n+    fn from_engine(mut e: HashEngine) -> Hash {\n+        // pad buffer with a single 1-bit then all 0s, until there are exactly 8 bytes remaining\n+        let data_len = e.length as u64;\n+\n+        let zeroes = [0; BLOCK_SIZE - 8];\n+        e.input(&[0x80]);\n+        if e.length % BLOCK_SIZE > zeroes.len() {\n+            e.input(&zeroes);\n+        }\n+        let pad_length = zeroes.len() - (e.length % BLOCK_SIZE);\n+        e.input(&zeroes[..pad_length]);\n+        debug_assert_eq!(e.length % BLOCK_SIZE, zeroes.len());\n+        \n+        e.input(&util::u64_to_array_be(8 * data_len));\n+        debug_assert_eq!(e.length % BLOCK_SIZE, 0);\n+\n+        Hash(e.midstate())\n+    }\n+\n+    const LEN: usize = 20;\n+\n+    fn from_slice(sl: &[u8]) -> Result<Hash, Error> {\n+        if sl.len() != 20 {\n+            Err(Error::InvalidLength(Self::LEN, sl.len()))\n+        } else {\n+            let mut ret = [0; 20];\n+            ret.copy_from_slice(sl);\n+            Ok(Hash(ret))\n+        }\n+    }\n+\n+    fn into_inner(self) -> Self::Inner {\n+        self.0\n+    }\n+\n+    fn from_inner(inner: Self::Inner) -> Self {\n+        Hash(inner)\n+    }\n+}\n+\n+impl HashEngine {\n+    // Basic unoptimized algorithm from Wikipedia\n+    fn process_block(&mut self) {\n+        debug_assert_eq!(self.buffer.len(), BLOCK_SIZE);\n+\n+        let mut w = [0u32; 80];\n+        for (w_val, buff_bytes) in w.iter_mut().zip(self.buffer.chunks(4)) {\n+            *w_val = util::slice_to_u32_be(buff_bytes);\n+        }\n+        for i in 16..80 {\n+            w[i] = circular_lshift32!(1, w[i - 3] ^ w[i - 8] ^ w[i - 14] ^ w[i - 16]);\n+        }\n+\n+        let mut a = self.h[0];\n+        let mut b = self.h[1];\n+        let mut c = self.h[2];\n+        let mut d = self.h[3];\n+        let mut e = self.h[4];\n+\n+        for (i, &wi) in w.iter().enumerate() {\n+            let (f, k) = match i {\n+                 0...19 => ((b & c) | (!b & d), 0x5a827999),\n+                20...39 => (b ^ c ^ d, 0x6ed9eba1),\n+                40...59 => ((b & c) | (b & d) | (c & d), 0x8f1bbcdc),\n+                60...79 => (b ^ c ^ d, 0xca62c1d6),\n+                _ => unreachable!()\n+            };\n+\n+            let new_a = circular_lshift32!(5, a).wrapping_add(f).wrapping_add(e).wrapping_add(k).wrapping_add(wi);\n+            e = d;\n+            d = c;\n+            c = circular_lshift32!(30, b);\n+            b = a;\n+            a = new_a;\n+        }\n+\n+        self.h[0] = self.h[0].wrapping_add(a);\n+        self.h[1] = self.h[1].wrapping_add(b);\n+        self.h[2] = self.h[2].wrapping_add(c);\n+        self.h[3] = self.h[3].wrapping_add(d);\n+        self.h[4] = self.h[4].wrapping_add(e);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use sha1;\n+    use hex::{FromHex, ToHex};\n+    use Hash;\n+    use HashEngine;\n+\n+    #[derive(Clone)]\n+    struct Test {\n+        input: &'static str,\n+        output: Vec<u8>,\n+        output_str: &'static str,\n+    }\n+\n+    #[test]\n+    fn test() {\n+        let tests = vec![\n+            // Examples from wikipedia\n+            Test {\n+                input: \"\",\n+                output: vec![\n+                    0xda, 0x39, 0xa3, 0xee,\n+                    0x5e, 0x6b, 0x4b, 0x0d,\n+                    0x32, 0x55, 0xbf, 0xef,\n+                    0x95, 0x60, 0x18, 0x90,\n+                    0xaf, 0xd8, 0x07, 0x09,\n+                ],\n+                output_str: \"da39a3ee5e6b4b0d3255bfef95601890afd80709\"\n+            },\n+            Test {\n+                input: \"The quick brown fox jumps over the lazy dog\",\n+                output: vec![\n+                    0x2f, 0xd4, 0xe1, 0xc6,\n+                    0x7a, 0x2d, 0x28, 0xfc,\n+                    0xed, 0x84, 0x9e, 0xe1,\n+                    0xbb, 0x76, 0xe7, 0x39,\n+                    0x1b, 0x93, 0xeb, 0x12,\n+                ],\n+                output_str: \"2fd4e1c67a2d28fced849ee1bb76e7391b93eb12\",\n+            },\n+            Test {\n+                input: \"The quick brown fox jumps over the lazy cog\",\n+                output: vec![\n+                    0xde, 0x9f, 0x2c, 0x7f,\n+                    0xd2, 0x5e, 0x1b, 0x3a,\n+                    0xfa, 0xd3, 0xe8, 0x5a,\n+                    0x0b, 0xd1, 0x7d, 0x9b,\n+                    0x10, 0x0d, 0xb4, 0xb3,\n+                ],\n+                output_str: \"de9f2c7fd25e1b3afad3e85a0bd17d9b100db4b3\",\n+            },\n+        ];\n+\n+        for test in tests {\n+            // Hash through high-level API, check hex encoding/decoding\n+            let hash = sha1::Hash::hash(&test.input.as_bytes());\n+            assert_eq!(hash, sha1::Hash::from_hex(test.output_str).expect(\"parse hex\"));\n+            assert_eq!(&hash[..], &test.output[..]);\n+            assert_eq!(&hash.to_hex(), &test.output_str);\n+\n+            // Hash through engine, checking that we can input byte by byte\n+            let mut engine = sha1::Hash::engine();\n+            for ch in test.input.as_bytes() {\n+                engine.input(&[*ch]);\n+            }\n+            let manual_hash = sha1::Hash::from_engine(engine);\n+            assert_eq!(hash, manual_hash);\n+            assert_eq!(hash.into_inner()[..].as_ref(), test.output.as_slice());\n+        }\n+    }\n+\n+    #[cfg(feature=\"serde\")]\n+    #[test]\n+    fn sha1_serde() {\n+        use serde_test::{Configure, Token, assert_tokens};\n+\n+        static HASH_BYTES: [u8; 20] = [\n+            0x13, 0x20, 0x72, 0xdf,\n+            0x69, 0x09, 0x33, 0x83,\n+            0x5e, 0xb8, 0xb6, 0xad,\n+            0x0b, 0x77, 0xe7, 0xb6,\n+            0xf1, 0x4a, 0xca, 0xd7,\n+        ];\n+\n+        let hash = sha1::Hash::from_slice(&HASH_BYTES).expect(\"right number of bytes\");\n+        assert_tokens(&hash.compact(), &[Token::BorrowedBytes(&HASH_BYTES[..])]);\n+        assert_tokens(&hash.readable(), &[Token::Str(\"132072df690933835eb8b6ad0b77e7b6f14acad7\")]);\n+    }\n+}\n+\n+#[cfg(all(test, feature=\"unstable\"))]\n+mod benches {\n+    use test::Bencher;\n+\n+    use sha1;\n+    use Hash;\n+    use HashEngine;\n+\n+    #[bench]\n+    pub fn sha1_10(bh: & mut Bencher) {\n+        let mut engine = sha1::Hash::engine();\n+        let bytes = [1u8; 10];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha1_1k(bh: & mut Bencher) {\n+        let mut engine = sha1::Hash::engine();\n+        let bytes = [1u8; 1024];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha1_64k(bh: & mut Bencher) {\n+        let mut engine = sha1::Hash::engine();\n+        let bytes = [1u8; 65536];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+}"
      },
      {
        "sha": "848f34c7062cb3fac1681e0a79b326c9fa7f4c68",
        "filename": "src/rusty/bitcoin_hashes/src/sha256.rs",
        "status": "added",
        "additions": 526,
        "deletions": 0,
        "changes": 526,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/sha256.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/sha256.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/src/sha256.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,526 @@\n+// Bitcoin Hashes Library\n+// Written in 2018 by\n+//   Andrew Poelstra <apoelstra@wpsoftware.net>\n+//\n+// To the extent possible under law, the author(s) have dedicated all\n+// copyright and related and neighboring rights to this software to\n+// the public domain worldwide. This software is distributed without\n+// any warranty.\n+//\n+// You should have received a copy of the CC0 Public Domain Dedication\n+// along with this software.\n+// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n+//\n+\n+//! # SHA256\n+\n+use core::{cmp, str};\n+\n+use hex;\n+use HashEngine as EngineTrait;\n+use Hash as HashTrait;\n+use Error;\n+use util;\n+\n+const BLOCK_SIZE: usize = 64;\n+\n+/// Engine to compute SHA256 hash function\n+#[derive(Clone)]\n+pub struct HashEngine {\n+    buffer: [u8; BLOCK_SIZE],\n+    h: [u32; 8],\n+    length: usize,\n+}\n+\n+impl Default for HashEngine {\n+    fn default() -> Self {\n+        HashEngine {\n+            h: [0x6a09e667, 0xbb67ae85, 0x3c6ef372, 0xa54ff53a, 0x510e527f, 0x9b05688c, 0x1f83d9ab, 0x5be0cd19],\n+            length: 0,\n+            buffer: [0; BLOCK_SIZE],\n+        }\n+    }\n+}\n+\n+impl EngineTrait for HashEngine {\n+    type MidState = Midstate;\n+\n+    #[cfg(not(feature = \"fuzztarget\"))]\n+    fn midstate(&self) -> Midstate {\n+        let mut ret = [0; 32];\n+        for (val, ret_bytes) in self.h.iter().zip(ret.chunks_mut(4)) {\n+            ret_bytes.copy_from_slice(&util::u32_to_array_be(*val));\n+        }\n+        Midstate(ret)\n+    }\n+\n+    #[cfg(feature = \"fuzztarget\")]\n+    fn midstate(&self) -> Midstate {\n+        let mut ret = [0; 32];\n+        ret.copy_from_slice(&self.buffer[..32]);\n+        Midstate(ret)\n+    }\n+\n+    const BLOCK_SIZE: usize = 64;\n+\n+    engine_input_impl!();\n+}\n+\n+/// Output of the SHA256 hash function\n+#[derive(Copy, Clone, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n+pub struct Hash([u8; 32]);\n+\n+impl str::FromStr for Hash {\n+    type Err = ::hex::Error;\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        ::hex::FromHex::from_hex(s)\n+    }\n+}\n+\n+hex_fmt_impl!(Debug, Hash);\n+hex_fmt_impl!(Display, Hash);\n+hex_fmt_impl!(LowerHex, Hash);\n+index_impl!(Hash);\n+serde_impl!(Hash, 32);\n+borrow_slice_impl!(Hash);\n+\n+impl HashTrait for Hash {\n+    type Engine = HashEngine;\n+    type Inner = [u8; 32];\n+\n+    #[cfg(not(feature = \"fuzztarget\"))]\n+    fn from_engine(mut e: HashEngine) -> Hash {\n+        // pad buffer with a single 1-bit then all 0s, until there are exactly 8 bytes remaining\n+        let data_len = e.length as u64;\n+\n+        let zeroes = [0; BLOCK_SIZE - 8];\n+        e.input(&[0x80]);\n+        if e.length % BLOCK_SIZE > zeroes.len() {\n+            e.input(&zeroes);\n+        }\n+        let pad_length = zeroes.len() - (e.length % BLOCK_SIZE);\n+        e.input(&zeroes[..pad_length]);\n+        debug_assert_eq!(e.length % BLOCK_SIZE, zeroes.len());\n+\n+        e.input(&util::u64_to_array_be(8 * data_len));\n+        debug_assert_eq!(e.length % BLOCK_SIZE, 0);\n+\n+        Hash(e.midstate().into_inner())\n+    }\n+\n+    #[cfg(feature = \"fuzztarget\")]\n+    fn from_engine(e: HashEngine) -> Hash {\n+        Hash(e.midstate().into_inner())\n+    }\n+\n+    const LEN: usize = 32;\n+\n+    fn from_slice(sl: &[u8]) -> Result<Hash, Error> {\n+        if sl.len() != 32 {\n+            Err(Error::InvalidLength(Self::LEN, sl.len()))\n+        } else {\n+            let mut ret = [0; 32];\n+            ret.copy_from_slice(sl);\n+            Ok(Hash(ret))\n+        }\n+    }\n+\n+    fn into_inner(self) -> Self::Inner {\n+        self.0\n+    }\n+\n+    fn from_inner(inner: Self::Inner) -> Self {\n+        Hash(inner)\n+    }\n+}\n+\n+/// Output of the SHA256 hash function\n+#[derive(Copy, Clone, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n+pub struct Midstate([u8; 32]);\n+\n+hex_fmt_impl!(Debug, Midstate);\n+hex_fmt_impl!(Display, Midstate);\n+hex_fmt_impl!(LowerHex, Midstate);\n+index_impl!(Midstate);\n+serde_impl!(Midstate, 32);\n+borrow_slice_impl!(Midstate);\n+\n+impl Midstate {\n+    /// Length of the midstate, in bytes.\n+    const LEN: usize = 32;\n+\n+    /// Flag indicating whether user-visible serializations of this hash\n+    /// should be backward. For some reason Satoshi decided this should be\n+    /// true for `Sha256dHash`, so here we are.\n+    const DISPLAY_BACKWARD: bool = true;\n+\n+    /// Construct a new midstate from the inner value.\n+    pub fn from_inner(inner: [u8; 32]) -> Self {\n+        Midstate(inner)\n+    }\n+\n+    /// Copies a byte slice into the [Midstate] object.\n+    pub fn from_slice(sl: &[u8]) -> Result<Midstate, Error> {\n+        if sl.len() != Self::LEN {\n+            Err(Error::InvalidLength(Self::LEN, sl.len()))\n+        } else {\n+            let mut ret = [0; 32];\n+            ret.copy_from_slice(sl);\n+            Ok(Midstate(ret))\n+        }\n+    }\n+\n+    /// Unwraps the [Midstate] and returns the underlying byte array.\n+    pub fn into_inner(self) -> [u8; 32] {\n+        self.0\n+    }\n+}\n+\n+impl hex::FromHex for Midstate {\n+    fn from_byte_iter<I>(iter: I) -> Result<Self, hex::Error>\n+        where I: Iterator<Item=Result<u8, hex::Error>> +\n+            ExactSizeIterator +\n+            DoubleEndedIterator,\n+    {\n+        // DISPLAY_BACKWARD is true\n+        Ok(Midstate::from_inner(hex::FromHex::from_byte_iter(iter.rev())?))\n+    }\n+}\n+\n+macro_rules! Ch( ($x:expr, $y:expr, $z:expr) => ($z ^ ($x & ($y ^ $z))) );\n+macro_rules! Maj( ($x:expr, $y:expr, $z:expr) => (($x & $y) | ($z & ($x | $y))) );\n+macro_rules! Sigma0( ($x:expr) => (circular_lshift32!(30, $x) ^ circular_lshift32!(19, $x) ^ circular_lshift32!(10, $x)) ); macro_rules! Sigma1( ($x:expr) => (circular_lshift32!(26, $x) ^ circular_lshift32!(21, $x) ^ circular_lshift32!(7, $x)) );\n+macro_rules! sigma0( ($x:expr) => (circular_lshift32!(25, $x) ^ circular_lshift32!(14, $x) ^ ($x >> 3)) );\n+macro_rules! sigma1( ($x:expr) => (circular_lshift32!(15, $x) ^ circular_lshift32!(13, $x) ^ ($x >> 10)) );\n+\n+macro_rules! round(\n+    // first round\n+    ($a:expr, $b:expr, $c:expr, $d:expr, $e:expr, $f:expr, $g:expr, $h:expr, $k:expr, $w:expr) => (\n+        let t1 = $h.wrapping_add(Sigma1!($e)).wrapping_add(Ch!($e, $f, $g)).wrapping_add($k).wrapping_add($w);\n+        let t2 = Sigma0!($a).wrapping_add(Maj!($a, $b, $c));\n+        $d = $d.wrapping_add(t1);\n+        $h = t1.wrapping_add(t2);\n+    );\n+    // later rounds we reassign $w before doing the first-round computation\n+    ($a:expr, $b:expr, $c:expr, $d:expr, $e:expr, $f:expr, $g:expr, $h:expr, $k:expr, $w:expr, $w1:expr, $w2:expr, $w3:expr) => (\n+        $w = $w.wrapping_add(sigma1!($w1)).wrapping_add($w2).wrapping_add(sigma0!($w3));\n+        round!($a, $b, $c, $d, $e, $f, $g, $h, $k, $w);\n+    )\n+);\n+\n+impl HashEngine {\n+    /// Create a new [HashEngine] from a midstate.\n+    ///\n+    /// Be aware that this method panics when [length] is\n+    /// not a multiple of the block size.\n+    pub fn from_midstate(midstate: Midstate, length: usize) -> HashEngine {\n+        assert!(length % BLOCK_SIZE == 0, \"length is no multiple of the block size\");\n+\n+        let mut ret = [0; 8];\n+        for (ret_val, midstate_bytes) in ret.iter_mut().zip(midstate[..].chunks(4)) {\n+            *ret_val = util::slice_to_u32_be(midstate_bytes);\n+        }\n+\n+        HashEngine {\n+            buffer: [0; BLOCK_SIZE],\n+            h: ret,\n+            length: length,\n+        }\n+    }\n+\n+    // Algorithm copied from libsecp256k1\n+    fn process_block(&mut self) {\n+        debug_assert_eq!(self.buffer.len(), BLOCK_SIZE);\n+\n+        let mut w = [0u32; 16];\n+        for (w_val, buff_bytes) in w.iter_mut().zip(self.buffer.chunks(4)) {\n+            *w_val = util::slice_to_u32_be(buff_bytes);\n+        }\n+\n+        let mut a = self.h[0];\n+        let mut b = self.h[1];\n+        let mut c = self.h[2];\n+        let mut d = self.h[3];\n+        let mut e = self.h[4];\n+        let mut f = self.h[5];\n+        let mut g = self.h[6];\n+        let mut h = self.h[7];\n+\n+        round!(a, b, c, d, e, f, g, h, 0x428a2f98, w[0]);\n+        round!(h, a, b, c, d, e, f, g, 0x71374491, w[1]);\n+        round!(g, h, a, b, c, d, e, f, 0xb5c0fbcf, w[2]);\n+        round!(f, g, h, a, b, c, d, e, 0xe9b5dba5, w[3]);\n+        round!(e, f, g, h, a, b, c, d, 0x3956c25b, w[4]);\n+        round!(d, e, f, g, h, a, b, c, 0x59f111f1, w[5]);\n+        round!(c, d, e, f, g, h, a, b, 0x923f82a4, w[6]);\n+        round!(b, c, d, e, f, g, h, a, 0xab1c5ed5, w[7]);\n+        round!(a, b, c, d, e, f, g, h, 0xd807aa98, w[8]);\n+        round!(h, a, b, c, d, e, f, g, 0x12835b01, w[9]);\n+        round!(g, h, a, b, c, d, e, f, 0x243185be, w[10]);\n+        round!(f, g, h, a, b, c, d, e, 0x550c7dc3, w[11]);\n+        round!(e, f, g, h, a, b, c, d, 0x72be5d74, w[12]);\n+        round!(d, e, f, g, h, a, b, c, 0x80deb1fe, w[13]);\n+        round!(c, d, e, f, g, h, a, b, 0x9bdc06a7, w[14]);\n+        round!(b, c, d, e, f, g, h, a, 0xc19bf174, w[15]);\n+\n+        round!(a, b, c, d, e, f, g, h, 0xe49b69c1, w[0], w[14], w[9], w[1]);\n+        round!(h, a, b, c, d, e, f, g, 0xefbe4786, w[1], w[15], w[10], w[2]);\n+        round!(g, h, a, b, c, d, e, f, 0x0fc19dc6, w[2], w[0], w[11], w[3]);\n+        round!(f, g, h, a, b, c, d, e, 0x240ca1cc, w[3], w[1], w[12], w[4]);\n+        round!(e, f, g, h, a, b, c, d, 0x2de92c6f, w[4], w[2], w[13], w[5]);\n+        round!(d, e, f, g, h, a, b, c, 0x4a7484aa, w[5], w[3], w[14], w[6]);\n+        round!(c, d, e, f, g, h, a, b, 0x5cb0a9dc, w[6], w[4], w[15], w[7]);\n+        round!(b, c, d, e, f, g, h, a, 0x76f988da, w[7], w[5], w[0], w[8]);\n+        round!(a, b, c, d, e, f, g, h, 0x983e5152, w[8], w[6], w[1], w[9]);\n+        round!(h, a, b, c, d, e, f, g, 0xa831c66d, w[9], w[7], w[2], w[10]);\n+        round!(g, h, a, b, c, d, e, f, 0xb00327c8, w[10], w[8], w[3], w[11]);\n+        round!(f, g, h, a, b, c, d, e, 0xbf597fc7, w[11], w[9], w[4], w[12]);\n+        round!(e, f, g, h, a, b, c, d, 0xc6e00bf3, w[12], w[10], w[5], w[13]);\n+        round!(d, e, f, g, h, a, b, c, 0xd5a79147, w[13], w[11], w[6], w[14]);\n+        round!(c, d, e, f, g, h, a, b, 0x06ca6351, w[14], w[12], w[7], w[15]);\n+        round!(b, c, d, e, f, g, h, a, 0x14292967, w[15], w[13], w[8], w[0]);\n+\n+        round!(a, b, c, d, e, f, g, h, 0x27b70a85, w[0], w[14], w[9], w[1]);\n+        round!(h, a, b, c, d, e, f, g, 0x2e1b2138, w[1], w[15], w[10], w[2]);\n+        round!(g, h, a, b, c, d, e, f, 0x4d2c6dfc, w[2], w[0], w[11], w[3]);\n+        round!(f, g, h, a, b, c, d, e, 0x53380d13, w[3], w[1], w[12], w[4]);\n+        round!(e, f, g, h, a, b, c, d, 0x650a7354, w[4], w[2], w[13], w[5]);\n+        round!(d, e, f, g, h, a, b, c, 0x766a0abb, w[5], w[3], w[14], w[6]);\n+        round!(c, d, e, f, g, h, a, b, 0x81c2c92e, w[6], w[4], w[15], w[7]);\n+        round!(b, c, d, e, f, g, h, a, 0x92722c85, w[7], w[5], w[0], w[8]);\n+        round!(a, b, c, d, e, f, g, h, 0xa2bfe8a1, w[8], w[6], w[1], w[9]);\n+        round!(h, a, b, c, d, e, f, g, 0xa81a664b, w[9], w[7], w[2], w[10]);\n+        round!(g, h, a, b, c, d, e, f, 0xc24b8b70, w[10], w[8], w[3], w[11]);\n+        round!(f, g, h, a, b, c, d, e, 0xc76c51a3, w[11], w[9], w[4], w[12]);\n+        round!(e, f, g, h, a, b, c, d, 0xd192e819, w[12], w[10], w[5], w[13]);\n+        round!(d, e, f, g, h, a, b, c, 0xd6990624, w[13], w[11], w[6], w[14]);\n+        round!(c, d, e, f, g, h, a, b, 0xf40e3585, w[14], w[12], w[7], w[15]);\n+        round!(b, c, d, e, f, g, h, a, 0x106aa070, w[15], w[13], w[8], w[0]);\n+\n+        round!(a, b, c, d, e, f, g, h, 0x19a4c116, w[0], w[14], w[9], w[1]);\n+        round!(h, a, b, c, d, e, f, g, 0x1e376c08, w[1], w[15], w[10], w[2]);\n+        round!(g, h, a, b, c, d, e, f, 0x2748774c, w[2], w[0], w[11], w[3]);\n+        round!(f, g, h, a, b, c, d, e, 0x34b0bcb5, w[3], w[1], w[12], w[4]);\n+        round!(e, f, g, h, a, b, c, d, 0x391c0cb3, w[4], w[2], w[13], w[5]);\n+        round!(d, e, f, g, h, a, b, c, 0x4ed8aa4a, w[5], w[3], w[14], w[6]);\n+        round!(c, d, e, f, g, h, a, b, 0x5b9cca4f, w[6], w[4], w[15], w[7]);\n+        round!(b, c, d, e, f, g, h, a, 0x682e6ff3, w[7], w[5], w[0], w[8]);\n+        round!(a, b, c, d, e, f, g, h, 0x748f82ee, w[8], w[6], w[1], w[9]);\n+        round!(h, a, b, c, d, e, f, g, 0x78a5636f, w[9], w[7], w[2], w[10]);\n+        round!(g, h, a, b, c, d, e, f, 0x84c87814, w[10], w[8], w[3], w[11]);\n+        round!(f, g, h, a, b, c, d, e, 0x8cc70208, w[11], w[9], w[4], w[12]);\n+        round!(e, f, g, h, a, b, c, d, 0x90befffa, w[12], w[10], w[5], w[13]);\n+        round!(d, e, f, g, h, a, b, c, 0xa4506ceb, w[13], w[11], w[6], w[14]);\n+        round!(c, d, e, f, g, h, a, b, 0xbef9a3f7, w[14], w[12], w[7], w[15]);\n+        round!(b, c, d, e, f, g, h, a, 0xc67178f2, w[15], w[13], w[8], w[0]);\n+\n+        self.h[0] = self.h[0].wrapping_add(a);\n+        self.h[1] = self.h[1].wrapping_add(b);\n+        self.h[2] = self.h[2].wrapping_add(c);\n+        self.h[3] = self.h[3].wrapping_add(d);\n+        self.h[4] = self.h[4].wrapping_add(e);\n+        self.h[5] = self.h[5].wrapping_add(f);\n+        self.h[6] = self.h[6].wrapping_add(g);\n+        self.h[7] = self.h[7].wrapping_add(h);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use sha256;\n+    use hex::{FromHex, ToHex};\n+    use {Hash, HashEngine};\n+\n+    #[derive(Clone)]\n+    struct Test {\n+        input: &'static str,\n+        output: Vec<u8>,\n+        output_str: &'static str,\n+    }\n+\n+    #[test]\n+    fn test() {\n+        let tests = vec![\n+            // Examples from wikipedia\n+            Test {\n+                input: \"\",\n+                output: vec![\n+                    0xe3, 0xb0, 0xc4, 0x42, 0x98, 0xfc, 0x1c, 0x14,\n+                    0x9a, 0xfb, 0xf4, 0xc8, 0x99, 0x6f, 0xb9, 0x24,\n+                    0x27, 0xae, 0x41, 0xe4, 0x64, 0x9b, 0x93, 0x4c,\n+                    0xa4, 0x95, 0x99, 0x1b, 0x78, 0x52, 0xb8, 0x55,\n+                ],\n+                output_str: \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\"\n+            },\n+            Test {\n+                input: \"The quick brown fox jumps over the lazy dog\",\n+                output: vec![\n+                    0xd7, 0xa8, 0xfb, 0xb3, 0x07, 0xd7, 0x80, 0x94,\n+                    0x69, 0xca, 0x9a, 0xbc, 0xb0, 0x08, 0x2e, 0x4f,\n+                    0x8d, 0x56, 0x51, 0xe4, 0x6d, 0x3c, 0xdb, 0x76,\n+                    0x2d, 0x02, 0xd0, 0xbf, 0x37, 0xc9, 0xe5, 0x92,\n+                ],\n+                output_str: \"d7a8fbb307d7809469ca9abcb0082e4f8d5651e46d3cdb762d02d0bf37c9e592\",\n+            },\n+            Test {\n+                input: \"The quick brown fox jumps over the lazy dog.\",\n+                output: vec![\n+                    0xef, 0x53, 0x7f, 0x25, 0xc8, 0x95, 0xbf, 0xa7,\n+                    0x82, 0x52, 0x65, 0x29, 0xa9, 0xb6, 0x3d, 0x97,\n+                    0xaa, 0x63, 0x15, 0x64, 0xd5, 0xd7, 0x89, 0xc2,\n+                    0xb7, 0x65, 0x44, 0x8c, 0x86, 0x35, 0xfb, 0x6c,\n+                ],\n+                output_str: \"ef537f25c895bfa782526529a9b63d97aa631564d5d789c2b765448c8635fb6c\",\n+            },\n+        ];\n+\n+        for test in tests {\n+            // Hash through high-level API, check hex encoding/decoding\n+            let hash = sha256::Hash::hash(&test.input.as_bytes());\n+            assert_eq!(hash, sha256::Hash::from_hex(test.output_str).expect(\"parse hex\"));\n+            assert_eq!(&hash[..], &test.output[..]);\n+            assert_eq!(&hash.to_hex(), &test.output_str);\n+\n+            // Hash through engine, checking that we can input byte by byte\n+            let mut engine = sha256::Hash::engine();\n+            for ch in test.input.as_bytes() {\n+                engine.input(&[*ch]);\n+            }\n+            let manual_hash = sha256::Hash::from_engine(engine);\n+            assert_eq!(hash, manual_hash);\n+            assert_eq!(hash.into_inner()[..].as_ref(), test.output.as_slice());\n+        }\n+    }\n+\n+    #[test]\n+    fn midstate() {\n+        // Test vector obtained by doing an asset issuance on Elements\n+        let mut engine = sha256::Hash::engine();\n+        // sha256dhash of outpoint\n+        // 73828cbc65fd68ab78dc86992b76ae50ae2bf8ceedbe8de0483172f0886219f7:0\n+        engine.input(&[\n+            0x9d, 0xd0, 0x1b, 0x56, 0xb1, 0x56, 0x45, 0x14,\n+            0x3e, 0xad, 0x15, 0x8d, 0xec, 0x19, 0xf8, 0xce,\n+            0xa9, 0x0b, 0xd0, 0xa9, 0xb2, 0xf8, 0x1d, 0x21,\n+            0xff, 0xa3, 0xa4, 0xc6, 0x44, 0x81, 0xd4, 0x1c,\n+        ]);\n+        // 32 bytes of zeroes representing \"new asset\"\n+        engine.input(&[0; 32]);\n+        assert_eq!(\n+            engine.midstate(),\n+            // RPC output\n+            sha256::Midstate::from_inner([\n+                0x0b, 0xcf, 0xe0, 0xe5, 0x4e, 0x6c, 0xc7, 0xd3,\n+                0x4f, 0x4f, 0x7c, 0x1d, 0xf0, 0xb0, 0xf5, 0x03,\n+                0xf2, 0xf7, 0x12, 0x91, 0x2a, 0x06, 0x05, 0xb4,\n+                0x14, 0xed, 0x33, 0x7f, 0x7f, 0x03, 0x2e, 0x03,\n+            ])\n+        );\n+    }\n+\n+    #[test]\n+    fn engine_with_state() {\n+        let mut engine = sha256::Hash::engine();\n+        let midstate_engine = sha256::HashEngine::from_midstate(engine.midstate(), 0);\n+        // Fresh engine and engine initialized with fresh state should have same state\n+        assert_eq!(engine.h, midstate_engine.h);\n+\n+        // Midstate changes after writing 64 bytes\n+        engine.input(&[1; 63]);\n+        assert_eq!(engine.h, midstate_engine.h);\n+        engine.input(&[2; 1]);\n+        assert_ne!(engine.h, midstate_engine.h);\n+\n+        // Initializing an engine with midstate from another engine should result in\n+        // both engines producing the same hashes\n+        let data_vec = vec![vec![3; 1], vec![4; 63], vec![5; 65], vec![6; 66]];\n+        for data in data_vec {\n+            let mut engine = engine.clone();\n+            let mut midstate_engine =\n+                sha256::HashEngine::from_midstate(engine.midstate(), engine.length);\n+            assert_eq!(engine.h, midstate_engine.h);\n+            assert_eq!(engine.length, midstate_engine.length);\n+            engine.input(&data);\n+            midstate_engine.input(&data);\n+            assert_eq!(engine.h, midstate_engine.h);\n+            let hash1 = sha256::Hash::from_engine(engine);\n+            let hash2 = sha256::Hash::from_engine(midstate_engine);\n+            assert_eq!(hash1, hash2);\n+        }\n+\n+        // Test that a specific midstate results in a specific hash. Midstate was\n+        // obtained by applying sha256 to sha256(\"MuSig coefficient\")||sha256(\"MuSig\n+        // coefficient\").\n+        static MIDSTATE: [u8; 32] = [\n+            0x0f, 0xd0, 0x69, 0x0c, 0xfe, 0xfe, 0xae, 0x97, 0x99, 0x6e, 0xac, 0x7f, 0x5c, 0x30,\n+            0xd8, 0x64, 0x8c, 0x4a, 0x05, 0x73, 0xac, 0xa1, 0xa2, 0x2f, 0x6f, 0x43, 0xb8, 0x01,\n+            0x85, 0xce, 0x27, 0xcd,\n+        ];\n+        static HASH_EXPECTED: [u8; 32] = [\n+            0x18, 0x84, 0xe4, 0x72, 0x40, 0x4e, 0xf4, 0x5a, 0xb4, 0x9c, 0x4e, 0xa4, 0x9a, 0xe6,\n+            0x23, 0xa8, 0x88, 0x52, 0x7f, 0x7d, 0x8a, 0x06, 0x94, 0x20, 0x8f, 0xf1, 0xf7, 0xa9,\n+            0xd5, 0x69, 0x09, 0x59,\n+        ];\n+        let midstate_engine =\n+            sha256::HashEngine::from_midstate(sha256::Midstate::from_inner(MIDSTATE), 64);\n+        let hash = sha256::Hash::from_engine(midstate_engine);\n+        assert_eq!(hash, sha256::Hash(HASH_EXPECTED));\n+    }\n+\n+    #[cfg(feature=\"serde\")]\n+    #[test]\n+    fn sha256_serde() {\n+        use serde_test::{Configure, Token, assert_tokens};\n+\n+        static HASH_BYTES: [u8; 32] = [\n+            0xef, 0x53, 0x7f, 0x25, 0xc8, 0x95, 0xbf, 0xa7,\n+            0x82, 0x52, 0x65, 0x29, 0xa9, 0xb6, 0x3d, 0x97,\n+            0xaa, 0x63, 0x15, 0x64, 0xd5, 0xd7, 0x89, 0xc2,\n+            0xb7, 0x65, 0x44, 0x8c, 0x86, 0x35, 0xfb, 0x6c,\n+        ];\n+\n+        let hash = sha256::Hash::from_slice(&HASH_BYTES).expect(\"right number of bytes\");\n+        assert_tokens(&hash.compact(), &[Token::BorrowedBytes(&HASH_BYTES[..])]);\n+        assert_tokens(&hash.readable(), &[Token::Str(\"ef537f25c895bfa782526529a9b63d97aa631564d5d789c2b765448c8635fb6c\")]);\n+    }\n+}\n+\n+#[cfg(all(test, feature=\"unstable\"))]\n+mod benches {\n+    use test::Bencher;\n+\n+    use sha256;\n+    use Hash;\n+    use HashEngine;\n+\n+    #[bench]\n+    pub fn sha256_10(bh: & mut Bencher) {\n+        let mut engine = sha256::Hash::engine();\n+        let bytes = [1u8; 10];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha256_1k(bh: & mut Bencher) {\n+        let mut engine = sha256::Hash::engine();\n+        let bytes = [1u8; 1024];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha256_64k(bh: & mut Bencher) {\n+        let mut engine = sha256::Hash::engine();\n+        let bytes = [1u8; 65536];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+}"
      },
      {
        "sha": "2d3e9d6a57673f84471679a5723b873eaa78c620",
        "filename": "src/rusty/bitcoin_hashes/src/sha256d.rs",
        "status": "added",
        "additions": 184,
        "deletions": 0,
        "changes": 184,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/sha256d.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/sha256d.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/src/sha256d.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,184 @@\n+// Bitcoin Hashes Library\n+// Written in 2018 by\n+//   Andrew Poelstra <apoelstra@wpsoftware.net>\n+//\n+// To the extent possible under law, the author(s) have dedicated all\n+// copyright and related and neighboring rights to this software to\n+// the public domain worldwide. This software is distributed without\n+// any warranty.\n+//\n+// You should have received a copy of the CC0 Public Domain Dedication\n+// along with this software.\n+// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n+//\n+\n+//! # SHA256d\n+\n+use core::str;\n+\n+use sha256;\n+use Hash as HashTrait;\n+use Error;\n+\n+/// Output of the SHA256d hash function\n+#[derive(Copy, Clone, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n+pub struct Hash([u8; 32]);\n+\n+hex_fmt_impl!(Debug, Hash);\n+hex_fmt_impl!(Display, Hash);\n+hex_fmt_impl!(LowerHex, Hash);\n+index_impl!(Hash);\n+serde_impl!(Hash, 32);\n+borrow_slice_impl!(Hash);\n+\n+impl str::FromStr for Hash {\n+    type Err = ::hex::Error;\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        ::hex::FromHex::from_hex(s)\n+    }\n+}\n+\n+impl HashTrait for Hash {\n+    type Engine = sha256::HashEngine;\n+    type Inner = [u8; 32];\n+\n+    fn engine() -> sha256::HashEngine {\n+        sha256::Hash::engine()\n+    }\n+\n+    fn from_engine(e: sha256::HashEngine) -> Hash {\n+        let sha2 = sha256::Hash::from_engine(e);\n+        let sha2d = sha256::Hash::hash(&sha2[..]);\n+\n+        let mut ret = [0; 32];\n+        ret.copy_from_slice(&sha2d[..]);\n+        Hash(ret)\n+    }\n+\n+    const LEN: usize = 32;\n+\n+    fn from_slice(sl: &[u8]) -> Result<Hash, Error> {\n+        if sl.len() != 32 {\n+            Err(Error::InvalidLength(Self::LEN, sl.len()))\n+        } else {\n+            let mut ret = [0; 32];\n+            ret.copy_from_slice(sl);\n+            Ok(Hash(ret))\n+        }\n+    }\n+\n+    const DISPLAY_BACKWARD: bool = true;\n+\n+    fn into_inner(self) -> Self::Inner {\n+        self.0\n+    }\n+\n+    fn from_inner(inner: Self::Inner) -> Self {\n+        Hash(inner)\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use sha256d;\n+    use hex::{FromHex, ToHex};\n+    use Hash;\n+    use HashEngine;\n+\n+#[derive(Clone)]\n+    struct Test {\n+input: &'static str,\n+           output: Vec<u8>,\n+           output_str: &'static str,\n+    }\n+\n+#[test]\n+    fn test() {\n+        let tests = vec![\n+            // Test vector copied out of rust-bitcoin\n+            Test {\n+                input: \"\",\n+                output: vec![\n+                    0x5d, 0xf6, 0xe0, 0xe2, 0x76, 0x13, 0x59, 0xd3,\n+                    0x0a, 0x82, 0x75, 0x05, 0x8e, 0x29, 0x9f, 0xcc,\n+                    0x03, 0x81, 0x53, 0x45, 0x45, 0xf5, 0x5c, 0xf4,\n+                    0x3e, 0x41, 0x98, 0x3f, 0x5d, 0x4c, 0x94, 0x56,\n+                ],\n+                output_str: \"56944c5d3f98413ef45cf54545538103cc9f298e0575820ad3591376e2e0f65d\",\n+            },\n+        ];\n+\n+        for test in tests {\n+            // Hash through high-level API, check hex encoding/decoding\n+            let hash = sha256d::Hash::hash(&test.input.as_bytes());\n+            assert_eq!(hash, sha256d::Hash::from_hex(test.output_str).expect(\"parse hex\"));\n+            assert_eq!(&hash[..], &test.output[..]);\n+            assert_eq!(&hash.to_hex(), &test.output_str);\n+\n+            // Hash through engine, checking that we can input byte by byte\n+            let mut engine = sha256d::Hash::engine();\n+            for ch in test.input.as_bytes() {\n+                engine.input(&[*ch]);\n+            }\n+            let manual_hash = sha256d::Hash::from_engine(engine);\n+            assert_eq!(hash, manual_hash);\n+            assert_eq!(hash.into_inner()[..].as_ref(), test.output.as_slice());\n+        }\n+    }\n+\n+    #[cfg(feature=\"serde\")]\n+    #[test]\n+    fn sha256_serde() {\n+        use serde_test::{Configure, Token, assert_tokens};\n+\n+        static HASH_BYTES: [u8; 32] = [\n+            0xef, 0x53, 0x7f, 0x25, 0xc8, 0x95, 0xbf, 0xa7,\n+            0x82, 0x52, 0x65, 0x29, 0xa9, 0xb6, 0x3d, 0x97,\n+            0xaa, 0x63, 0x15, 0x64, 0xd5, 0xd7, 0x89, 0xc2,\n+            0xb7, 0x65, 0x44, 0x8c, 0x86, 0x35, 0xfb, 0x6c,\n+        ];\n+\n+        let hash = sha256d::Hash::from_slice(&HASH_BYTES).expect(\"right number of bytes\");\n+        assert_tokens(&hash.compact(), &[Token::BorrowedBytes(&HASH_BYTES[..])]);\n+        assert_tokens(&hash.readable(), &[Token::Str(\"6cfb35868c4465b7c289d7d5641563aa973db6a929655282a7bf95c8257f53ef\")]);\n+    }\n+}\n+\n+#[cfg(all(test, feature=\"unstable\"))]\n+mod benches {\n+    use test::Bencher;\n+\n+    use sha256d;\n+    use Hash;\n+    use HashEngine;\n+\n+    #[bench]\n+    pub fn sha256d_10(bh: & mut Bencher) {\n+        let mut engine = sha256d::Hash::engine();\n+        let bytes = [1u8; 10];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha256d_1k(bh: & mut Bencher) {\n+        let mut engine = sha256d::Hash::engine();\n+        let bytes = [1u8; 1024];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha256d_64k(bh: & mut Bencher) {\n+        let mut engine = sha256d::Hash::engine();\n+        let bytes = [1u8; 65536];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+}"
      },
      {
        "sha": "4d8d678a37f710d18a4cb9a96e5ba68f306f52a5",
        "filename": "src/rusty/bitcoin_hashes/src/sha512.rs",
        "status": "added",
        "additions": 471,
        "deletions": 0,
        "changes": 471,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/sha512.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/sha512.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/src/sha512.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,471 @@\n+// Bitcoin Hashes Library\n+// Written in 2018 by\n+//   Andrew Poelstra <apoelstra@wpsoftware.net>\n+//\n+// To the extent possible under law, the author(s) have dedicated all\n+// copyright and related and neighboring rights to this software to\n+// the public domain worldwide. This software is distributed without\n+// any warranty.\n+//\n+// You should have received a copy of the CC0 Public Domain Dedication\n+// along with this software.\n+// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n+//\n+\n+// This module is largely copied from the rust-crypto ripemd.rs file;\n+// while rust-crypto is licensed under Apache, that file specifically\n+// was written entirely by Andrew Poelstra, who is re-licensing its\n+// contents here as CC0.\n+\n+//! # SHA512\n+\n+use core::{cmp, hash, str};\n+\n+use HashEngine as EngineTrait;\n+use Hash as HashTrait;\n+use Error;\n+use util;\n+\n+const BLOCK_SIZE: usize = 128;\n+\n+/// Engine to compute SHA512 hash function\n+#[derive(Clone)]\n+pub struct HashEngine {\n+    h: [u64; 8],\n+    length: usize,\n+    buffer: [u8; BLOCK_SIZE],\n+}\n+\n+impl Default for HashEngine {\n+    fn default() -> Self {\n+        HashEngine {\n+            h: [\n+                0x6a09e667f3bcc908, 0xbb67ae8584caa73b, 0x3c6ef372fe94f82b, 0xa54ff53a5f1d36f1,\n+                0x510e527fade682d1, 0x9b05688c2b3e6c1f, 0x1f83d9abfb41bd6b, 0x5be0cd19137e2179,\n+            ],\n+            length: 0,\n+            buffer: [0; BLOCK_SIZE],\n+        }\n+    }\n+}\n+\n+impl EngineTrait for HashEngine {\n+    type MidState = [u8; 64];\n+\n+    #[cfg(not(feature = \"fuzztarget\"))]\n+    fn midstate(&self) -> [u8; 64] {\n+        let mut ret = [0; 64];\n+        for (val, ret_bytes) in self.h.iter().zip(ret.chunks_mut(8)) {\n+            ret_bytes.copy_from_slice(&util::u64_to_array_be(*val));\n+        }\n+        ret\n+    }\n+\n+    #[cfg(feature = \"fuzztarget\")]\n+    fn midstate(&self) -> [u8; 64] {\n+        let mut ret = [0; 64];\n+        ret.copy_from_slice(&self.buffer[..64]);\n+        ret\n+    }\n+\n+    const BLOCK_SIZE: usize = 128;\n+\n+    engine_input_impl!();\n+}\n+\n+/// Output of the SHA256 hash function\n+pub struct Hash([u8; 64]);\n+\n+impl Copy for Hash {}\n+\n+impl Clone for Hash {\n+    fn clone(&self) -> Hash {\n+        let mut ret = [0; 64];\n+        ret.copy_from_slice(&self.0);\n+        Hash(ret)\n+    }\n+}\n+\n+impl PartialEq for Hash {\n+    fn eq(&self, other: &Hash) -> bool {\n+        self.0[..] == other.0[..]\n+    }\n+}\n+\n+impl Eq for Hash {}\n+\n+impl Default for Hash {\n+    fn default() -> Hash {\n+        Hash([0; 64])\n+    }\n+}\n+\n+impl PartialOrd for Hash {\n+    fn partial_cmp(&self, other: &Hash) -> Option<cmp::Ordering> {\n+        (&self.0).partial_cmp(&other.0)\n+    }\n+}\n+\n+impl Ord for Hash {\n+    fn cmp(&self, other: &Hash) -> cmp::Ordering {\n+        (&self.0).cmp(&other.0)\n+    }\n+}\n+\n+impl hash::Hash for Hash {\n+    fn hash<H: hash::Hasher>(&self, state: &mut H) {\n+        (&self.0).hash(state)\n+    }\n+}\n+\n+impl str::FromStr for Hash {\n+    type Err = ::hex::Error;\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        ::hex::FromHex::from_hex(s)\n+    }\n+}\n+\n+hex_fmt_impl!(Debug, Hash);\n+hex_fmt_impl!(Display, Hash);\n+hex_fmt_impl!(LowerHex, Hash);\n+index_impl!(Hash);\n+serde_impl!(Hash, 64);\n+borrow_slice_impl!(Hash);\n+\n+impl HashTrait for Hash {\n+    type Engine = HashEngine;\n+    type Inner = [u8; 64];\n+\n+    #[cfg(not(feature = \"fuzztarget\"))]\n+    fn from_engine(mut e: HashEngine) -> Hash {\n+        // pad buffer with a single 1-bit then all 0s, until there are exactly 16 bytes remaining\n+        let data_len = e.length as u64;\n+\n+        let zeroes = [0; BLOCK_SIZE - 16];\n+        e.input(&[0x80]);\n+        if e.length % BLOCK_SIZE > zeroes.len() {\n+            e.input(&zeroes);\n+        }\n+        let pad_length = zeroes.len() - (e.length % BLOCK_SIZE);\n+        e.input(&zeroes[..pad_length]);\n+        debug_assert_eq!(e.length % BLOCK_SIZE, zeroes.len());\n+\n+        e.input(&[0; 8]);\n+        e.input(&util::u64_to_array_be(8 * data_len));\n+        debug_assert_eq!(e.length % BLOCK_SIZE, 0);\n+\n+        Hash(e.midstate())\n+    }\n+\n+    #[cfg(feature = \"fuzztarget\")]\n+    fn from_engine(e: HashEngine) -> Hash {\n+        let mut hash = e.midstate();\n+        hash[0] ^= 0xff; // Make this distinct from SHA-256\n+        Hash(hash)\n+    }\n+\n+    const LEN: usize = 64;\n+\n+    fn from_slice(sl: &[u8]) -> Result<Hash, Error> {\n+        if sl.len() != 64 {\n+            Err(Error::InvalidLength(Self::LEN, sl.len()))\n+        } else {\n+            let mut ret = [0; 64];\n+            ret.copy_from_slice(sl);\n+            Ok(Hash(ret))\n+        }\n+    }\n+\n+    fn into_inner(self) -> Self::Inner {\n+        self.0\n+    }\n+\n+    fn from_inner(inner: Self::Inner) -> Self {\n+        Hash(inner)\n+    }\n+}\n+\n+macro_rules! Ch( ($x:expr, $y:expr, $z:expr) => ($z ^ ($x & ($y ^ $z))) );\n+macro_rules! Maj( ($x:expr, $y:expr, $z:expr) => (($x & $y) | ($z & ($x | $y))) );\n+macro_rules! Sigma0( ($x:expr) => (circular_lshift64!(36, $x) ^ circular_lshift64!(30, $x) ^ circular_lshift64!(25, $x)) );\n+macro_rules! Sigma1( ($x:expr) => (circular_lshift64!(50, $x) ^ circular_lshift64!(46, $x) ^ circular_lshift64!(23, $x)) );\n+macro_rules! sigma0( ($x:expr) => (circular_lshift64!(63, $x) ^ circular_lshift64!(56, $x) ^ ($x >> 7)) );\n+macro_rules! sigma1( ($x:expr) => (circular_lshift64!(45, $x) ^ circular_lshift64!(3, $x) ^ ($x >> 6)) );\n+\n+macro_rules! round(\n+    // first round\n+    ($a:expr, $b:expr, $c:expr, $d:expr, $e:expr, $f:expr, $g:expr, $h:expr, $k:expr, $w:expr) => (\n+        let t1 = $h.wrapping_add(Sigma1!($e)).wrapping_add(Ch!($e, $f, $g)).wrapping_add($k).wrapping_add($w);\n+        let t2 = Sigma0!($a).wrapping_add(Maj!($a, $b, $c));\n+        $d = $d.wrapping_add(t1);\n+        $h = t1.wrapping_add(t2);\n+    );\n+    // later rounds we reassign $w before doing the first-round computation\n+    ($a:expr, $b:expr, $c:expr, $d:expr, $e:expr, $f:expr, $g:expr, $h:expr, $k:expr, $w:expr, $w1:expr, $w2:expr, $w3:expr) => (\n+        $w = $w.wrapping_add(sigma1!($w1)).wrapping_add($w2).wrapping_add(sigma0!($w3));\n+        round!($a, $b, $c, $d, $e, $f, $g, $h, $k, $w);\n+    )\n+);\n+\n+impl HashEngine {\n+    // Algorithm copied from libsecp256k1\n+    fn process_block(&mut self) {\n+        debug_assert_eq!(self.buffer.len(), BLOCK_SIZE);\n+\n+        let mut w = [0u64; 16];\n+        for (w_val, buff_bytes) in w.iter_mut().zip(self.buffer.chunks(8)) {\n+            *w_val = util::slice_to_u64_be(buff_bytes);\n+        }\n+\n+        let mut a = self.h[0];\n+        let mut b = self.h[1];\n+        let mut c = self.h[2];\n+        let mut d = self.h[3];\n+        let mut e = self.h[4];\n+        let mut f = self.h[5];\n+        let mut g = self.h[6];\n+        let mut h = self.h[7];\n+\n+        round!(a, b, c, d, e, f, g, h, 0x428a2f98d728ae22, w[0]);\n+        round!(h, a, b, c, d, e, f, g, 0x7137449123ef65cd, w[1]);\n+        round!(g, h, a, b, c, d, e, f, 0xb5c0fbcfec4d3b2f, w[2]);\n+        round!(f, g, h, a, b, c, d, e, 0xe9b5dba58189dbbc, w[3]);\n+        round!(e, f, g, h, a, b, c, d, 0x3956c25bf348b538, w[4]);\n+        round!(d, e, f, g, h, a, b, c, 0x59f111f1b605d019, w[5]);\n+        round!(c, d, e, f, g, h, a, b, 0x923f82a4af194f9b, w[6]);\n+        round!(b, c, d, e, f, g, h, a, 0xab1c5ed5da6d8118, w[7]);\n+        round!(a, b, c, d, e, f, g, h, 0xd807aa98a3030242, w[8]);\n+        round!(h, a, b, c, d, e, f, g, 0x12835b0145706fbe, w[9]);\n+        round!(g, h, a, b, c, d, e, f, 0x243185be4ee4b28c, w[10]);\n+        round!(f, g, h, a, b, c, d, e, 0x550c7dc3d5ffb4e2, w[11]);\n+        round!(e, f, g, h, a, b, c, d, 0x72be5d74f27b896f, w[12]);\n+        round!(d, e, f, g, h, a, b, c, 0x80deb1fe3b1696b1, w[13]);\n+        round!(c, d, e, f, g, h, a, b, 0x9bdc06a725c71235, w[14]);\n+        round!(b, c, d, e, f, g, h, a, 0xc19bf174cf692694, w[15]);\n+\n+        round!(a, b, c, d, e, f, g, h, 0xe49b69c19ef14ad2, w[0], w[14], w[9], w[1]);\n+        round!(h, a, b, c, d, e, f, g, 0xefbe4786384f25e3, w[1], w[15], w[10], w[2]);\n+        round!(g, h, a, b, c, d, e, f, 0x0fc19dc68b8cd5b5, w[2], w[0], w[11], w[3]);\n+        round!(f, g, h, a, b, c, d, e, 0x240ca1cc77ac9c65, w[3], w[1], w[12], w[4]);\n+        round!(e, f, g, h, a, b, c, d, 0x2de92c6f592b0275, w[4], w[2], w[13], w[5]);\n+        round!(d, e, f, g, h, a, b, c, 0x4a7484aa6ea6e483, w[5], w[3], w[14], w[6]);\n+        round!(c, d, e, f, g, h, a, b, 0x5cb0a9dcbd41fbd4, w[6], w[4], w[15], w[7]);\n+        round!(b, c, d, e, f, g, h, a, 0x76f988da831153b5, w[7], w[5], w[0], w[8]);\n+        round!(a, b, c, d, e, f, g, h, 0x983e5152ee66dfab, w[8], w[6], w[1], w[9]);\n+        round!(h, a, b, c, d, e, f, g, 0xa831c66d2db43210, w[9], w[7], w[2], w[10]);\n+        round!(g, h, a, b, c, d, e, f, 0xb00327c898fb213f, w[10], w[8], w[3], w[11]);\n+        round!(f, g, h, a, b, c, d, e, 0xbf597fc7beef0ee4, w[11], w[9], w[4], w[12]);\n+        round!(e, f, g, h, a, b, c, d, 0xc6e00bf33da88fc2, w[12], w[10], w[5], w[13]);\n+        round!(d, e, f, g, h, a, b, c, 0xd5a79147930aa725, w[13], w[11], w[6], w[14]);\n+        round!(c, d, e, f, g, h, a, b, 0x06ca6351e003826f, w[14], w[12], w[7], w[15]);\n+        round!(b, c, d, e, f, g, h, a, 0x142929670a0e6e70, w[15], w[13], w[8], w[0]);\n+\n+        round!(a, b, c, d, e, f, g, h, 0x27b70a8546d22ffc, w[0], w[14], w[9], w[1]);\n+        round!(h, a, b, c, d, e, f, g, 0x2e1b21385c26c926, w[1], w[15], w[10], w[2]);\n+        round!(g, h, a, b, c, d, e, f, 0x4d2c6dfc5ac42aed, w[2], w[0], w[11], w[3]);\n+        round!(f, g, h, a, b, c, d, e, 0x53380d139d95b3df, w[3], w[1], w[12], w[4]);\n+        round!(e, f, g, h, a, b, c, d, 0x650a73548baf63de, w[4], w[2], w[13], w[5]);\n+        round!(d, e, f, g, h, a, b, c, 0x766a0abb3c77b2a8, w[5], w[3], w[14], w[6]);\n+        round!(c, d, e, f, g, h, a, b, 0x81c2c92e47edaee6, w[6], w[4], w[15], w[7]);\n+        round!(b, c, d, e, f, g, h, a, 0x92722c851482353b, w[7], w[5], w[0], w[8]);\n+        round!(a, b, c, d, e, f, g, h, 0xa2bfe8a14cf10364, w[8], w[6], w[1], w[9]);\n+        round!(h, a, b, c, d, e, f, g, 0xa81a664bbc423001, w[9], w[7], w[2], w[10]);\n+        round!(g, h, a, b, c, d, e, f, 0xc24b8b70d0f89791, w[10], w[8], w[3], w[11]);\n+        round!(f, g, h, a, b, c, d, e, 0xc76c51a30654be30, w[11], w[9], w[4], w[12]);\n+        round!(e, f, g, h, a, b, c, d, 0xd192e819d6ef5218, w[12], w[10], w[5], w[13]);\n+        round!(d, e, f, g, h, a, b, c, 0xd69906245565a910, w[13], w[11], w[6], w[14]);\n+        round!(c, d, e, f, g, h, a, b, 0xf40e35855771202a, w[14], w[12], w[7], w[15]);\n+        round!(b, c, d, e, f, g, h, a, 0x106aa07032bbd1b8, w[15], w[13], w[8], w[0]);\n+\n+        round!(a, b, c, d, e, f, g, h, 0x19a4c116b8d2d0c8, w[0], w[14], w[9], w[1]);\n+        round!(h, a, b, c, d, e, f, g, 0x1e376c085141ab53, w[1], w[15], w[10], w[2]);\n+        round!(g, h, a, b, c, d, e, f, 0x2748774cdf8eeb99, w[2], w[0], w[11], w[3]);\n+        round!(f, g, h, a, b, c, d, e, 0x34b0bcb5e19b48a8, w[3], w[1], w[12], w[4]);\n+        round!(e, f, g, h, a, b, c, d, 0x391c0cb3c5c95a63, w[4], w[2], w[13], w[5]);\n+        round!(d, e, f, g, h, a, b, c, 0x4ed8aa4ae3418acb, w[5], w[3], w[14], w[6]);\n+        round!(c, d, e, f, g, h, a, b, 0x5b9cca4f7763e373, w[6], w[4], w[15], w[7]);\n+        round!(b, c, d, e, f, g, h, a, 0x682e6ff3d6b2b8a3, w[7], w[5], w[0], w[8]);\n+        round!(a, b, c, d, e, f, g, h, 0x748f82ee5defb2fc, w[8], w[6], w[1], w[9]);\n+        round!(h, a, b, c, d, e, f, g, 0x78a5636f43172f60, w[9], w[7], w[2], w[10]);\n+        round!(g, h, a, b, c, d, e, f, 0x84c87814a1f0ab72, w[10], w[8], w[3], w[11]);\n+        round!(f, g, h, a, b, c, d, e, 0x8cc702081a6439ec, w[11], w[9], w[4], w[12]);\n+        round!(e, f, g, h, a, b, c, d, 0x90befffa23631e28, w[12], w[10], w[5], w[13]);\n+        round!(d, e, f, g, h, a, b, c, 0xa4506cebde82bde9, w[13], w[11], w[6], w[14]);\n+        round!(c, d, e, f, g, h, a, b, 0xbef9a3f7b2c67915, w[14], w[12], w[7], w[15]);\n+        round!(b, c, d, e, f, g, h, a, 0xc67178f2e372532b, w[15], w[13], w[8], w[0]);\n+\n+        round!(a, b, c, d, e, f, g, h, 0xca273eceea26619c, w[0], w[14], w[9], w[1]);\n+        round!(h, a, b, c, d, e, f, g, 0xd186b8c721c0c207, w[1], w[15], w[10], w[2]);\n+        round!(g, h, a, b, c, d, e, f, 0xeada7dd6cde0eb1e, w[2], w[0], w[11], w[3]);\n+        round!(f, g, h, a, b, c, d, e, 0xf57d4f7fee6ed178, w[3], w[1], w[12], w[4]);\n+        round!(e, f, g, h, a, b, c, d, 0x06f067aa72176fba, w[4], w[2], w[13], w[5]);\n+        round!(d, e, f, g, h, a, b, c, 0x0a637dc5a2c898a6, w[5], w[3], w[14], w[6]);\n+        round!(c, d, e, f, g, h, a, b, 0x113f9804bef90dae, w[6], w[4], w[15], w[7]);\n+        round!(b, c, d, e, f, g, h, a, 0x1b710b35131c471b, w[7], w[5], w[0], w[8]);\n+        round!(a, b, c, d, e, f, g, h, 0x28db77f523047d84, w[8], w[6], w[1], w[9]);\n+        round!(h, a, b, c, d, e, f, g, 0x32caab7b40c72493, w[9], w[7], w[2], w[10]);\n+        round!(g, h, a, b, c, d, e, f, 0x3c9ebe0a15c9bebc, w[10], w[8], w[3], w[11]);\n+        round!(f, g, h, a, b, c, d, e, 0x431d67c49c100d4c, w[11], w[9], w[4], w[12]);\n+        round!(e, f, g, h, a, b, c, d, 0x4cc5d4becb3e42b6, w[12], w[10], w[5], w[13]);\n+        round!(d, e, f, g, h, a, b, c, 0x597f299cfc657e2a, w[13], w[11], w[6], w[14]);\n+        round!(c, d, e, f, g, h, a, b, 0x5fcb6fab3ad6faec, w[14], w[12], w[7], w[15]);\n+        round!(b, c, d, e, f, g, h, a, 0x6c44198c4a475817, w[15], w[13], w[8], w[0]);\n+\n+        self.h[0] = self.h[0].wrapping_add(a);\n+        self.h[1] = self.h[1].wrapping_add(b);\n+        self.h[2] = self.h[2].wrapping_add(c);\n+        self.h[3] = self.h[3].wrapping_add(d);\n+        self.h[4] = self.h[4].wrapping_add(e);\n+        self.h[5] = self.h[5].wrapping_add(f);\n+        self.h[6] = self.h[6].wrapping_add(g);\n+        self.h[7] = self.h[7].wrapping_add(h);\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use sha512;\n+    use hex::{FromHex, ToHex};\n+    use Hash;\n+    use HashEngine;\n+\n+    #[derive(Clone)]\n+    struct Test {\n+        input: &'static str,\n+        output: Vec<u8>,\n+        output_str: &'static str,\n+    }\n+\n+    #[test]\n+    fn test() {\n+        let tests = vec![\n+            // Test vectors computed with `sha512sum`\n+            Test {\n+                input: \"\",\n+                output: vec![\n+                    0xcf, 0x83, 0xe1, 0x35, 0x7e, 0xef, 0xb8, 0xbd,\n+                    0xf1, 0x54, 0x28, 0x50, 0xd6, 0x6d, 0x80, 0x07,\n+                    0xd6, 0x20, 0xe4, 0x05, 0x0b, 0x57, 0x15, 0xdc,\n+                    0x83, 0xf4, 0xa9, 0x21, 0xd3, 0x6c, 0xe9, 0xce,\n+                    0x47, 0xd0, 0xd1, 0x3c, 0x5d, 0x85, 0xf2, 0xb0,\n+                    0xff, 0x83, 0x18, 0xd2, 0x87, 0x7e, 0xec, 0x2f,\n+                    0x63, 0xb9, 0x31, 0xbd, 0x47, 0x41, 0x7a, 0x81,\n+                    0xa5, 0x38, 0x32, 0x7a, 0xf9, 0x27, 0xda, 0x3e,\n+                ],\n+                output_str: \"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\"\n+            },\n+            Test {\n+                input: \"The quick brown fox jumps over the lazy dog\",\n+                output: vec![\n+                    0x07, 0xe5, 0x47, 0xd9, 0x58, 0x6f, 0x6a, 0x73,\n+                    0xf7, 0x3f, 0xba, 0xc0, 0x43, 0x5e, 0xd7, 0x69,\n+                    0x51, 0x21, 0x8f, 0xb7, 0xd0, 0xc8, 0xd7, 0x88,\n+                    0xa3, 0x09, 0xd7, 0x85, 0x43, 0x6b, 0xbb, 0x64,\n+                    0x2e, 0x93, 0xa2, 0x52, 0xa9, 0x54, 0xf2, 0x39,\n+                    0x12, 0x54, 0x7d, 0x1e, 0x8a, 0x3b, 0x5e, 0xd6,\n+                    0xe1, 0xbf, 0xd7, 0x09, 0x78, 0x21, 0x23, 0x3f,\n+                    0xa0, 0x53, 0x8f, 0x3d, 0xb8, 0x54, 0xfe, 0xe6,\n+                ],\n+                output_str: \"07e547d9586f6a73f73fbac0435ed76951218fb7d0c8d788a309d785436bbb642e93a252a954f23912547d1e8a3b5ed6e1bfd7097821233fa0538f3db854fee6\",\n+            },\n+            Test {\n+                input: \"The quick brown fox jumps over the lazy dog.\",\n+                output: vec![\n+                    0x91, 0xea, 0x12, 0x45, 0xf2, 0x0d, 0x46, 0xae,\n+                    0x9a, 0x03, 0x7a, 0x98, 0x9f, 0x54, 0xf1, 0xf7,\n+                    0x90, 0xf0, 0xa4, 0x76, 0x07, 0xee, 0xb8, 0xa1,\n+                    0x4d, 0x12, 0x89, 0x0c, 0xea, 0x77, 0xa1, 0xbb,\n+                    0xc6, 0xc7, 0xed, 0x9c, 0xf2, 0x05, 0xe6, 0x7b,\n+                    0x7f, 0x2b, 0x8f, 0xd4, 0xc7, 0xdf, 0xd3, 0xa7,\n+                    0xa8, 0x61, 0x7e, 0x45, 0xf3, 0xc4, 0x63, 0xd4,\n+                    0x81, 0xc7, 0xe5, 0x86, 0xc3, 0x9a, 0xc1, 0xed,\n+                ],\n+                output_str: \"91ea1245f20d46ae9a037a989f54f1f790f0a47607eeb8a14d12890cea77a1bbc6c7ed9cf205e67b7f2b8fd4c7dfd3a7a8617e45f3c463d481c7e586c39ac1ed\",\n+            },\n+        ];\n+\n+        for test in tests {\n+            // Hash through high-level API, check hex encoding/decoding\n+            let hash = sha512::Hash::hash(&test.input.as_bytes());\n+            assert_eq!(hash, sha512::Hash::from_hex(test.output_str).expect(\"parse hex\"));\n+            assert_eq!(&hash[..], &test.output[..]);\n+            assert_eq!(&hash.to_hex(), &test.output_str);\n+\n+            // Hash through engine, checking that we can input byte by byte\n+            let mut engine = sha512::Hash::engine();\n+            for ch in test.input.as_bytes() {\n+                engine.input(&[*ch]);\n+            }\n+            let manual_hash = sha512::Hash::from_engine(engine);\n+            assert_eq!(hash, manual_hash);\n+            assert_eq!(hash.into_inner()[..].as_ref(), test.output.as_slice());\n+        }\n+    }\n+\n+    #[cfg(feature=\"serde\")]\n+    #[test]\n+    fn sha512_serde() {\n+        use serde_test::{Configure, Token, assert_tokens};\n+\n+        static HASH_BYTES: [u8; 64] = [\n+            0x8b, 0x41, 0xe1, 0xb7, 0x8a, 0xd1, 0x15, 0x21,\n+            0x11, 0x3c, 0x52, 0xff, 0x18, 0x2a, 0x1b, 0x8e,\n+            0x0a, 0x19, 0x57, 0x54, 0xaa, 0x52, 0x7f, 0xcd,\n+            0x00, 0xa4, 0x11, 0x62, 0x0b, 0x46, 0xf2, 0x0f,\n+            0xff, 0xfb, 0x80, 0x88, 0xcc, 0xf8, 0x54, 0x97,\n+            0x12, 0x1a, 0xd4, 0x49, 0x9e, 0x08, 0x45, 0xb8,\n+            0x76, 0xf6, 0xdd, 0x66, 0x40, 0x08, 0x8a, 0x2f,\n+            0x0b, 0x2d, 0x8a, 0x60, 0x0b, 0xdf, 0x4c, 0x0c,\n+        ];\n+\n+        let hash = sha512::Hash::from_slice(&HASH_BYTES).expect(\"right number of bytes\");\n+        assert_tokens(&hash.compact(), &[Token::BorrowedBytes(&HASH_BYTES[..])]);\n+        assert_tokens(\n+            &hash.readable(),\n+            &[Token::Str(\n+                \"8b41e1b78ad11521113c52ff182a1b8e0a195754aa527fcd00a411620b46f20f\\\n+                 fffb8088ccf85497121ad4499e0845b876f6dd6640088a2f0b2d8a600bdf4c0c\"\n+            )],\n+        );\n+    }\n+}\n+\n+#[cfg(all(test, feature=\"unstable\"))]\n+mod benches {\n+    use test::Bencher;\n+\n+    use sha512;\n+    use Hash;\n+    use HashEngine;\n+\n+    #[bench]\n+    pub fn sha512_10(bh: & mut Bencher) {\n+        let mut engine = sha512::Hash::engine();\n+        let bytes = [1u8; 10];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha512_1k(bh: & mut Bencher) {\n+        let mut engine = sha512::Hash::engine();\n+        let bytes = [1u8; 1024];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn sha512_64k(bh: & mut Bencher) {\n+        let mut engine = sha512::Hash::engine();\n+        let bytes = [1u8; 65536];\n+        bh.iter( || {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+}"
      },
      {
        "sha": "fe25b31b207611d826e17d367ce9febc5eb513ac",
        "filename": "src/rusty/bitcoin_hashes/src/siphash24.rs",
        "status": "added",
        "additions": 454,
        "deletions": 0,
        "changes": 454,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/siphash24.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/siphash24.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/src/siphash24.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,454 @@\n+// Bitcoin Hashes Library\n+// Written in 2019 by\n+//   The rust-bitcoin developers\n+//\n+// To the extent possible under law, the author(s) have dedicated all\n+// copyright and related and neighboring rights to this software to\n+// the public domain worldwide. This software is distributed without\n+// any warranty.\n+//\n+// You should have received a copy of the CC0 Public Domain Dedication\n+// along with this software.\n+// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n+//\n+\n+// This module is largely copied from the rust-siphash sip.rs file;\n+// while rust-siphash is licensed under Apache, that file specifically\n+// was written entirely by Steven Roose, who is re-licensing its\n+// contents here as CC0.\n+\n+//! # SipHash 2-4\n+\n+use core::{cmp, mem, ptr, str};\n+\n+use Error;\n+use Hash as HashTrait;\n+use HashEngine as EngineTrait;\n+use util;\n+\n+macro_rules! compress {\n+    ($state:expr) => {{\n+        compress!($state.v0, $state.v1, $state.v2, $state.v3)\n+    }};\n+    ($v0:expr, $v1:expr, $v2:expr, $v3:expr) => {{\n+        $v0 = $v0.wrapping_add($v1);\n+        $v1 = $v1.rotate_left(13);\n+        $v1 ^= $v0;\n+        $v0 = $v0.rotate_left(32);\n+        $v2 = $v2.wrapping_add($v3);\n+        $v3 = $v3.rotate_left(16);\n+        $v3 ^= $v2;\n+        $v0 = $v0.wrapping_add($v3);\n+        $v3 = $v3.rotate_left(21);\n+        $v3 ^= $v0;\n+        $v2 = $v2.wrapping_add($v1);\n+        $v1 = $v1.rotate_left(17);\n+        $v1 ^= $v2;\n+        $v2 = $v2.rotate_left(32);\n+    }};\n+}\n+\n+/// Load an integer of the desired type from a byte stream, in LE order. Uses\n+/// `copy_nonoverlapping` to let the compiler generate the most efficient way\n+/// to load it from a possibly unaligned address.\n+///\n+/// Unsafe because: unchecked indexing at `i..i+size_of(int_ty)`\n+macro_rules! load_int_le {\n+    ($buf:expr, $i:expr, $int_ty:ident) => {{\n+        debug_assert!($i + mem::size_of::<$int_ty>() <= $buf.len());\n+        let mut data = 0 as $int_ty;\n+        ptr::copy_nonoverlapping(\n+            $buf.get_unchecked($i),\n+            &mut data as *mut _ as *mut u8,\n+            mem::size_of::<$int_ty>(),\n+        );\n+        data.to_le()\n+    }};\n+}\n+\n+/// Internal state of the [HashEngine].\n+#[derive(Debug, Clone)]\n+pub struct State {\n+    // v0, v2 and v1, v3 show up in pairs in the algorithm,\n+    // and simd implementations of SipHash will use vectors\n+    // of v02 and v13. By placing them in this order in the struct,\n+    // the compiler can pick up on just a few simd optimizations by itself.\n+    v0: u64,\n+    v2: u64,\n+    v1: u64,\n+    v3: u64,\n+}\n+\n+/// Engine to compute SipHash24 hash function.\n+#[derive(Debug, Clone)]\n+pub struct HashEngine {\n+    k0: u64,\n+    k1: u64,\n+    length: usize, // how many bytes we've processed\n+    state: State,  // hash State\n+    tail: u64,     // unprocessed bytes le\n+    ntail: usize,  // how many bytes in tail are valid\n+}\n+\n+impl HashEngine {\n+    /// Create a new SipHash24 engine with keys.\n+    pub fn with_keys(k0: u64, k1: u64) -> HashEngine {\n+        HashEngine {\n+            k0: k0,\n+            k1: k1,\n+            length: 0,\n+            state: State {\n+                v0: k0 ^ 0x736f6d6570736575,\n+                v1: k1 ^ 0x646f72616e646f6d,\n+                v2: k0 ^ 0x6c7967656e657261,\n+                v3: k1 ^ 0x7465646279746573,\n+            },\n+            tail: 0,\n+            ntail: 0,\n+        }\n+    }\n+\n+    /// Create a new SipHash24 engine.\n+    pub fn new() -> HashEngine {\n+        HashEngine::with_keys(0, 0)\n+    }\n+\n+    /// Retrieve the keys of this engine.\n+    pub fn keys(&self) -> (u64, u64) {\n+        (self.k0, self.k1)\n+    }\n+\n+    #[inline]\n+    fn c_rounds(state: &mut State) {\n+        compress!(state);\n+        compress!(state);\n+    }\n+\n+    #[inline]\n+    fn d_rounds(state: &mut State) {\n+        compress!(state);\n+        compress!(state);\n+        compress!(state);\n+        compress!(state);\n+    }\n+}\n+\n+impl Default for HashEngine {\n+    fn default() -> Self {\n+        HashEngine::new()\n+    }\n+}\n+\n+impl EngineTrait for HashEngine {\n+    type MidState = State;\n+\n+    fn midstate(&self) -> State {\n+        self.state.clone()\n+    }\n+\n+    const BLOCK_SIZE: usize = 8;\n+\n+    #[inline]\n+    fn input(&mut self, msg: &[u8]) {\n+        let length = msg.len();\n+        self.length += length;\n+\n+        let mut needed = 0;\n+\n+        if self.ntail != 0 {\n+            needed = 8 - self.ntail;\n+            self.tail |= unsafe { u8to64_le(msg, 0, cmp::min(length, needed)) } << (8 * self.ntail);\n+            if length < needed {\n+                self.ntail += length;\n+                return;\n+            } else {\n+                self.state.v3 ^= self.tail;\n+                HashEngine::c_rounds(&mut self.state);\n+                self.state.v0 ^= self.tail;\n+                self.ntail = 0;\n+            }\n+        }\n+\n+        // Buffered tail is now flushed, process new input.\n+        let len = length - needed;\n+        let left = len & 0x7;\n+\n+        let mut i = needed;\n+        while i < len - left {\n+            let mi = unsafe { load_int_le!(msg, i, u64) };\n+\n+            self.state.v3 ^= mi;\n+            HashEngine::c_rounds(&mut self.state);\n+            self.state.v0 ^= mi;\n+\n+            i += 8;\n+        }\n+\n+        self.tail = unsafe { u8to64_le(msg, i, left) };\n+        self.ntail = left;\n+    }\n+}\n+\n+/// Output of the SipHash24 hash function.\n+#[derive(Copy, Clone, PartialEq, Eq, Default, PartialOrd, Ord, Hash)]\n+pub struct Hash([u8; 8]);\n+\n+hex_fmt_impl!(Debug, Hash);\n+hex_fmt_impl!(Display, Hash);\n+hex_fmt_impl!(LowerHex, Hash);\n+index_impl!(Hash);\n+serde_impl!(Hash, 8);\n+borrow_slice_impl!(Hash);\n+\n+impl str::FromStr for Hash {\n+    type Err = ::hex::Error;\n+    fn from_str(s: &str) -> Result<Self, Self::Err> {\n+        ::hex::FromHex::from_hex(s)\n+    }\n+}\n+\n+impl Hash {\n+    /// Hash the given data with an engine with the provided keys.\n+    pub fn hash_with_keys(k0: u64, k1: u64, data: &[u8]) -> Hash {\n+        let mut engine = HashEngine::with_keys(k0, k1);\n+        engine.input(data);\n+        Hash::from_engine(engine)\n+    }\n+\n+    /// Hash the given data directly to u64 with an engine with the provided keys.\n+    pub fn hash_to_u64_with_keys(k0: u64, k1: u64, data: &[u8]) -> u64 {\n+        let mut engine = HashEngine::with_keys(k0, k1);\n+        engine.input(data);\n+        Hash::from_engine_to_u64(engine)\n+    }\n+\n+    /// Produce a hash as u64 from the current state of a given engine\n+    #[inline]\n+    pub fn from_engine_to_u64(e: HashEngine) -> u64 {\n+        let mut state = e.state;\n+\n+        let b: u64 = ((e.length as u64 & 0xff) << 56) | e.tail;\n+\n+        state.v3 ^= b;\n+        HashEngine::c_rounds(&mut state);\n+        state.v0 ^= b;\n+\n+        state.v2 ^= 0xff;\n+        HashEngine::d_rounds(&mut state);\n+\n+        state.v0 ^ state.v1 ^ state.v2 ^ state.v3\n+    }\n+\n+    /// Returns the (little endian) 64-bit integer representation of the hash value.\n+    pub fn as_u64(&self) -> u64 {\n+        util::slice_to_u64_le(&self.0[..])\n+    }\n+\n+    /// Create a hash from its (little endian) 64-bit integer representation.\n+    pub fn from_u64(hash: u64) -> Hash {\n+        Hash(util::u64_to_array_le(hash))\n+    }\n+}\n+\n+impl HashTrait for Hash {\n+    type Engine = HashEngine;\n+    type Inner = [u8; 8];\n+\n+    #[cfg(not(feature = \"fuzztarget\"))]\n+    fn from_engine(e: HashEngine) -> Hash {\n+        Hash::from_u64(Hash::from_engine_to_u64(e))\n+    }\n+\n+    #[cfg(feature = \"fuzztarget\")]\n+    fn from_engine(e: HashEngine) -> Hash {\n+        let state = e.midstate();\n+        Hash::from_u64(state.v0 ^ state.v1 ^ state.v2 ^ state.v3)\n+    }\n+\n+    const LEN: usize = 8;\n+\n+    fn from_slice(sl: &[u8]) -> Result<Hash, Error> {\n+        if sl.len() != 8 {\n+            Err(Error::InvalidLength(Self::LEN, sl.len()))\n+        } else {\n+            let mut ret = [0; 8];\n+            ret.copy_from_slice(sl);\n+            Ok(Hash(ret))\n+        }\n+    }\n+\n+    fn into_inner(self) -> Self::Inner {\n+        self.0\n+    }\n+\n+    fn from_inner(inner: Self::Inner) -> Self {\n+        Hash(inner)\n+    }\n+}\n+\n+/// Load an u64 using up to 7 bytes of a byte slice.\n+///\n+/// Unsafe because: unchecked indexing at start..start+len\n+#[inline]\n+unsafe fn u8to64_le(buf: &[u8], start: usize, len: usize) -> u64 {\n+    debug_assert!(len < 8);\n+    let mut i = 0; // current byte index (from LSB) in the output u64\n+    let mut out = 0;\n+    if i + 3 < len {\n+        out = u64::from(load_int_le!(buf, start + i, u32));\n+        i += 4;\n+    }\n+    if i + 1 < len {\n+        out |= u64::from(load_int_le!(buf, start + i, u16)) << (i * 8);\n+        i += 2\n+    }\n+    if i < len {\n+        out |= u64::from(*buf.get_unchecked(start + i)) << (i * 8);\n+        i += 1;\n+    }\n+    debug_assert_eq!(i, len);\n+    out\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+    use Hash as HashTrait;\n+\n+    #[test]\n+    fn test_siphash_2_4() {\n+        let vecs: [[u8; 8]; 64] = [\n+            [0x31, 0x0e, 0x0e, 0xdd, 0x47, 0xdb, 0x6f, 0x72],\n+            [0xfd, 0x67, 0xdc, 0x93, 0xc5, 0x39, 0xf8, 0x74],\n+            [0x5a, 0x4f, 0xa9, 0xd9, 0x09, 0x80, 0x6c, 0x0d],\n+            [0x2d, 0x7e, 0xfb, 0xd7, 0x96, 0x66, 0x67, 0x85],\n+            [0xb7, 0x87, 0x71, 0x27, 0xe0, 0x94, 0x27, 0xcf],\n+            [0x8d, 0xa6, 0x99, 0xcd, 0x64, 0x55, 0x76, 0x18],\n+            [0xce, 0xe3, 0xfe, 0x58, 0x6e, 0x46, 0xc9, 0xcb],\n+            [0x37, 0xd1, 0x01, 0x8b, 0xf5, 0x00, 0x02, 0xab],\n+            [0x62, 0x24, 0x93, 0x9a, 0x79, 0xf5, 0xf5, 0x93],\n+            [0xb0, 0xe4, 0xa9, 0x0b, 0xdf, 0x82, 0x00, 0x9e],\n+            [0xf3, 0xb9, 0xdd, 0x94, 0xc5, 0xbb, 0x5d, 0x7a],\n+            [0xa7, 0xad, 0x6b, 0x22, 0x46, 0x2f, 0xb3, 0xf4],\n+            [0xfb, 0xe5, 0x0e, 0x86, 0xbc, 0x8f, 0x1e, 0x75],\n+            [0x90, 0x3d, 0x84, 0xc0, 0x27, 0x56, 0xea, 0x14],\n+            [0xee, 0xf2, 0x7a, 0x8e, 0x90, 0xca, 0x23, 0xf7],\n+            [0xe5, 0x45, 0xbe, 0x49, 0x61, 0xca, 0x29, 0xa1],\n+            [0xdb, 0x9b, 0xc2, 0x57, 0x7f, 0xcc, 0x2a, 0x3f],\n+            [0x94, 0x47, 0xbe, 0x2c, 0xf5, 0xe9, 0x9a, 0x69],\n+            [0x9c, 0xd3, 0x8d, 0x96, 0xf0, 0xb3, 0xc1, 0x4b],\n+            [0xbd, 0x61, 0x79, 0xa7, 0x1d, 0xc9, 0x6d, 0xbb],\n+            [0x98, 0xee, 0xa2, 0x1a, 0xf2, 0x5c, 0xd6, 0xbe],\n+            [0xc7, 0x67, 0x3b, 0x2e, 0xb0, 0xcb, 0xf2, 0xd0],\n+            [0x88, 0x3e, 0xa3, 0xe3, 0x95, 0x67, 0x53, 0x93],\n+            [0xc8, 0xce, 0x5c, 0xcd, 0x8c, 0x03, 0x0c, 0xa8],\n+            [0x94, 0xaf, 0x49, 0xf6, 0xc6, 0x50, 0xad, 0xb8],\n+            [0xea, 0xb8, 0x85, 0x8a, 0xde, 0x92, 0xe1, 0xbc],\n+            [0xf3, 0x15, 0xbb, 0x5b, 0xb8, 0x35, 0xd8, 0x17],\n+            [0xad, 0xcf, 0x6b, 0x07, 0x63, 0x61, 0x2e, 0x2f],\n+            [0xa5, 0xc9, 0x1d, 0xa7, 0xac, 0xaa, 0x4d, 0xde],\n+            [0x71, 0x65, 0x95, 0x87, 0x66, 0x50, 0xa2, 0xa6],\n+            [0x28, 0xef, 0x49, 0x5c, 0x53, 0xa3, 0x87, 0xad],\n+            [0x42, 0xc3, 0x41, 0xd8, 0xfa, 0x92, 0xd8, 0x32],\n+            [0xce, 0x7c, 0xf2, 0x72, 0x2f, 0x51, 0x27, 0x71],\n+            [0xe3, 0x78, 0x59, 0xf9, 0x46, 0x23, 0xf3, 0xa7],\n+            [0x38, 0x12, 0x05, 0xbb, 0x1a, 0xb0, 0xe0, 0x12],\n+            [0xae, 0x97, 0xa1, 0x0f, 0xd4, 0x34, 0xe0, 0x15],\n+            [0xb4, 0xa3, 0x15, 0x08, 0xbe, 0xff, 0x4d, 0x31],\n+            [0x81, 0x39, 0x62, 0x29, 0xf0, 0x90, 0x79, 0x02],\n+            [0x4d, 0x0c, 0xf4, 0x9e, 0xe5, 0xd4, 0xdc, 0xca],\n+            [0x5c, 0x73, 0x33, 0x6a, 0x76, 0xd8, 0xbf, 0x9a],\n+            [0xd0, 0xa7, 0x04, 0x53, 0x6b, 0xa9, 0x3e, 0x0e],\n+            [0x92, 0x59, 0x58, 0xfc, 0xd6, 0x42, 0x0c, 0xad],\n+            [0xa9, 0x15, 0xc2, 0x9b, 0xc8, 0x06, 0x73, 0x18],\n+            [0x95, 0x2b, 0x79, 0xf3, 0xbc, 0x0a, 0xa6, 0xd4],\n+            [0xf2, 0x1d, 0xf2, 0xe4, 0x1d, 0x45, 0x35, 0xf9],\n+            [0x87, 0x57, 0x75, 0x19, 0x04, 0x8f, 0x53, 0xa9],\n+            [0x10, 0xa5, 0x6c, 0xf5, 0xdf, 0xcd, 0x9a, 0xdb],\n+            [0xeb, 0x75, 0x09, 0x5c, 0xcd, 0x98, 0x6c, 0xd0],\n+            [0x51, 0xa9, 0xcb, 0x9e, 0xcb, 0xa3, 0x12, 0xe6],\n+            [0x96, 0xaf, 0xad, 0xfc, 0x2c, 0xe6, 0x66, 0xc7],\n+            [0x72, 0xfe, 0x52, 0x97, 0x5a, 0x43, 0x64, 0xee],\n+            [0x5a, 0x16, 0x45, 0xb2, 0x76, 0xd5, 0x92, 0xa1],\n+            [0xb2, 0x74, 0xcb, 0x8e, 0xbf, 0x87, 0x87, 0x0a],\n+            [0x6f, 0x9b, 0xb4, 0x20, 0x3d, 0xe7, 0xb3, 0x81],\n+            [0xea, 0xec, 0xb2, 0xa3, 0x0b, 0x22, 0xa8, 0x7f],\n+            [0x99, 0x24, 0xa4, 0x3c, 0xc1, 0x31, 0x57, 0x24],\n+            [0xbd, 0x83, 0x8d, 0x3a, 0xaf, 0xbf, 0x8d, 0xb7],\n+            [0x0b, 0x1a, 0x2a, 0x32, 0x65, 0xd5, 0x1a, 0xea],\n+            [0x13, 0x50, 0x79, 0xa3, 0x23, 0x1c, 0xe6, 0x60],\n+            [0x93, 0x2b, 0x28, 0x46, 0xe4, 0xd7, 0x06, 0x66],\n+            [0xe1, 0x91, 0x5f, 0x5c, 0xb1, 0xec, 0xa4, 0x6c],\n+            [0xf3, 0x25, 0x96, 0x5c, 0xa1, 0x6d, 0x62, 0x9f],\n+            [0x57, 0x5f, 0xf2, 0x8e, 0x60, 0x38, 0x1b, 0xe5],\n+            [0x72, 0x45, 0x06, 0xeb, 0x4c, 0x32, 0x8a, 0x95],\n+        ];\n+\n+        let k0 = 0x_07_06_05_04_03_02_01_00;\n+        let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n+        let mut vin = [0u8; 64];\n+        let mut state_inc = HashEngine::with_keys(k0, k1);\n+\n+        for i in 0..64 {\n+            vin[i] = i as u8;\n+            let vec = Hash::from_slice(&vecs[i][..]).unwrap();\n+            let out = Hash::hash_with_keys(k0, k1, &vin[0..i]);\n+            assert_eq!(vec, out, \"vec #{}\", i);\n+\n+            let inc = Hash::from_engine(state_inc.clone());\n+            assert_eq!(vec, inc, \"vec #{}\", i);\n+            state_inc.input(&[i as u8]);\n+        }\n+    }\n+}\n+\n+#[cfg(all(test, feature = \"unstable\"))]\n+mod benches {\n+    use test::Bencher;\n+\n+    use siphash24;\n+    use Hash;\n+    use HashEngine;\n+\n+    #[bench]\n+    pub fn siphash24_1ki(bh: &mut Bencher) {\n+        let mut engine = siphash24::Hash::engine();\n+        let bytes = [1u8; 1024];\n+        bh.iter(|| {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn siphash24_64ki(bh: &mut Bencher) {\n+        let mut engine = siphash24::Hash::engine();\n+        let bytes = [1u8; 65536];\n+        bh.iter(|| {\n+            engine.input(&bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn siphash24_1ki_hash(bh: &mut Bencher) {\n+        let k0 = 0x_07_06_05_04_03_02_01_00;\n+        let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n+        let bytes = [1u8; 1024];\n+        bh.iter(|| {\n+            let _ = siphash24::Hash::hash_with_keys(k0, k1, &bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+\n+    #[bench]\n+    pub fn siphash24_1ki_hash_u64(bh: &mut Bencher) {\n+        let k0 = 0x_07_06_05_04_03_02_01_00;\n+        let k1 = 0x_0f_0e_0d_0c_0b_0a_09_08;\n+        let bytes = [1u8; 1024];\n+        bh.iter(|| {\n+            let _ = siphash24::Hash::hash_to_u64_with_keys(k0, k1, &bytes);\n+        });\n+        bh.bytes = bytes.len() as u64;\n+    }\n+}"
      },
      {
        "sha": "aa87c304f66461ca5deb44ceb983876183d52364",
        "filename": "src/rusty/bitcoin_hashes/src/std_impls.rs",
        "status": "added",
        "additions": 166,
        "deletions": 0,
        "changes": 166,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/std_impls.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/std_impls.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/src/std_impls.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,166 @@\n+// Bitcoin Hashes Library\n+// Written in 2019 by\n+//   Andrew Poelstra <apoelstra@wpsoftware.net>\n+//\n+// To the extent possible under law, the author(s) have dedicated all\n+// copyright and related and neighboring rights to this software to\n+// the public domain worldwide. This software is distributed without\n+// any warranty.\n+//\n+// You should have received a copy of the CC0 Public Domain Dedication\n+// along with this software.\n+// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n+//\n+\n+//! `std` Impls\n+//!\n+//! impls of traits defined in `std` and not `core`\n+\n+use std::{error, io};\n+\n+use {hex, sha1, sha256, sha512, ripemd160, siphash24};\n+use HashEngine;\n+use Error;\n+\n+impl error::Error for Error {\n+    fn cause(&self) -> Option<&error::Error> { None }\n+    fn description(&self) -> &str { \"`std::error::description` is deprecated\" }\n+}\n+\n+impl error::Error for hex::Error {\n+    fn cause(&self) -> Option<&error::Error> { None }\n+    fn description(&self) -> &str { \"`std::error::description` is deprecated\" }\n+}\n+\n+impl io::Write for sha1::HashEngine {\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.input(buf);\n+        Ok(buf.len())\n+    }\n+}\n+\n+impl io::Write for sha256::HashEngine {\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.input(buf);\n+        Ok(buf.len())\n+    }\n+}\n+\n+impl io::Write for sha512::HashEngine {\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.input(buf);\n+        Ok(buf.len())\n+    }\n+}\n+\n+impl io::Write for ripemd160::HashEngine {\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.input(buf);\n+        Ok(buf.len())\n+    }\n+}\n+\n+impl io::Write for siphash24::HashEngine {\n+    fn flush(&mut self) -> io::Result<()> { Ok(()) }\n+\n+    fn write(&mut self, buf: &[u8]) -> io::Result<usize> {\n+        self.input(buf);\n+        Ok(buf.len())\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use std::io::Write;\n+\n+    use {sha1, sha256, sha256d, sha512, ripemd160, hash160, siphash24};\n+    use Hash;\n+\n+    macro_rules! write_test {\n+        ($mod:ident, $exp_empty:expr, $exp_256:expr, $exp_64k:expr,) => {\n+            #[test]\n+            fn $mod() {\n+                let mut engine = $mod::Hash::engine();\n+                engine.write_all(&[]).unwrap();\n+                assert_eq!(\n+                    format!(\"{}\", $mod::Hash::from_engine(engine)),\n+                    $exp_empty\n+                );\n+\n+                let mut engine = $mod::Hash::engine();\n+                engine.write_all(&[1; 256]).unwrap();\n+                assert_eq!(\n+                    format!(\"{}\", $mod::Hash::from_engine(engine)),\n+                    $exp_256\n+                );\n+\n+                let mut engine = $mod::Hash::engine();\n+                engine.write_all(&[99; 64000]).unwrap();\n+                assert_eq!(\n+                    format!(\"{}\", $mod::Hash::from_engine(engine)),\n+                    $exp_64k\n+                );\n+            }\n+        }\n+    }\n+\n+    write_test!(\n+        sha1,\n+        \"da39a3ee5e6b4b0d3255bfef95601890afd80709\",\n+        \"ac458b067c6b021c7e9358229b636e9d1e4cb154\",\n+        \"e4b66838f9f7b6f91e5be32a02ae78094df402e7\",\n+    );\n+\n+    write_test!(\n+        sha256,\n+        \"e3b0c44298fc1c149afbf4c8996fb92427ae41e4649b934ca495991b7852b855\",\n+        \"2661920f2409dd6c8adeb0c44972959f232b6429afa913845d0fd95e7e768234\",\n+        \"5c5e904f5d4fd587c7a906bf846e08a927286f388c54c39213a4884695271bbc\",\n+    );\n+\n+    write_test!(\n+        sha256d,\n+        \"56944c5d3f98413ef45cf54545538103cc9f298e0575820ad3591376e2e0f65d\",\n+        \"374000d830c75d10d9417e493a7652920f30efbd300e3fb092f24c28c20baf64\",\n+        \"0050d4148ad7a0437ca0643fad5bf4614cd95d9ba21fde52370b37dcc3f03307\",\n+    );\n+\n+    write_test!(\n+        sha512,\n+        \"cf83e1357eefb8bdf1542850d66d8007d620e4050b5715dc83f4a921d36ce9ce\\\n+         47d0d13c5d85f2b0ff8318d2877eec2f63b931bd47417a81a538327af927da3e\",\n+        \"57ecf739d3a7ca647639adae80a05f4f361304bfcbfa1ceba93296b096e74287\\\n+         45fc10c142cecdd3bb587a3dba598c072f6f78b31cc0a06a3da0105ee51f75d6\",\n+        \"dd28f78c53f3bc9bd0c2dca9642a1ad402a70412f985c1f6e54fadb98ce9c458\\\n+         4761df8d04ed04bb734ba48dd2106bb9ea54524f1394cdd18e6da3166e71c3ee\",\n+    );\n+\n+    write_test!(\n+        ripemd160,\n+        \"9c1185a5c5e9fc54612808977ee8f548b2258d31\",\n+        \"e571a1ca5b780aa52bafdb9ec852544ffca418ba\",\n+        \"ddd2ecce739e823629c7d46ab18918e9c4a51c75\",\n+    );\n+\n+    write_test!(\n+        hash160,\n+        \"b472a266d0bd89c13706a4132ccfb16f7c3b9fcb\",\n+        \"671356a1a874695ad3bc20cae440f4360835bd5a\",\n+        \"a9608c952c8dbcc20c53803d2ca5ad31d64d9313\",\n+    );\n+\n+    write_test!(\n+        siphash24,\n+        \"d70077739d4b921e\",\n+        \"3a3ccefde9b5b1e3\",\n+        \"ce456e4e4ecbc5bf\",\n+    );\n+}"
      },
      {
        "sha": "8843fea5d2a835a29e198c367be04045f1f7e520",
        "filename": "src/rusty/bitcoin_hashes/src/util.rs",
        "status": "added",
        "additions": 234,
        "deletions": 0,
        "changes": 234,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/util.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/bitcoin_hashes/src/util.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/bitcoin_hashes/src/util.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,234 @@\n+// Bitcoin Hashes Library\n+// Written in 2018 by\n+//   Andrew Poelstra <apoelstra@wpsoftware.net>\n+//\n+// To the extent possible under law, the author(s) have dedicated all\n+// copyright and related and neighboring rights to this software to\n+// the public domain worldwide. This software is distributed without\n+// any warranty.\n+//\n+// You should have received a copy of the CC0 Public Domain Dedication\n+// along with this software.\n+// If not, see <http://creativecommons.org/publicdomain/zero/1.0/>.\n+//\n+\n+/// Circular left-shift a 32-bit word\n+macro_rules! circular_lshift32 (\n+    ($shift:expr, $w:expr) => (($w << $shift) | ($w >> (32 - $shift)))\n+);\n+\n+macro_rules! circular_lshift64 (\n+    ($shift:expr, $w:expr) => (($w << $shift) | ($w >> (64 - $shift)))\n+);\n+\n+macro_rules! hex_fmt_impl(\n+    ($imp:ident, $ty:ident) => (\n+        impl ::core::fmt::$imp for $ty {\n+            fn fmt(&self, f: &mut ::core::fmt::Formatter) -> ::core::fmt::Result {\n+                use hex::{format_hex, format_hex_reverse};\n+                if $ty::DISPLAY_BACKWARD {\n+                    format_hex_reverse(&self.0, f)\n+                } else {\n+                    format_hex(&self.0, f)\n+                }\n+            }\n+        }\n+    )\n+);\n+\n+macro_rules! index_impl(\n+    ($ty:ty) => (\n+        impl ::core::ops::Index<usize> for $ty {\n+            type Output = u8;\n+            fn index(&self, index: usize) -> &u8 {\n+                &self.0[index]\n+            }\n+        }\n+\n+        impl ::core::ops::Index<::core::ops::Range<usize>> for $ty {\n+            type Output = [u8];\n+            fn index(&self, index: ::core::ops::Range<usize>) -> &[u8] {\n+                &self.0[index]\n+            }\n+        }\n+\n+        impl ::core::ops::Index<::core::ops::RangeFrom<usize>> for $ty {\n+            type Output = [u8];\n+            fn index(&self, index: ::core::ops::RangeFrom<usize>) -> &[u8] {\n+                &self.0[index]\n+            }\n+        }\n+\n+        impl ::core::ops::Index<::core::ops::RangeTo<usize>> for $ty {\n+            type Output = [u8];\n+            fn index(&self, index: ::core::ops::RangeTo<usize>) -> &[u8] {\n+                &self.0[index]\n+            }\n+        }\n+\n+        impl ::core::ops::Index<::core::ops::RangeFull> for $ty {\n+            type Output = [u8];\n+            fn index(&self, index: ::core::ops::RangeFull) -> &[u8] {\n+                &self.0[index]\n+            }\n+        }\n+    )\n+);\n+\n+macro_rules! borrow_slice_impl(\n+    ($ty:ty) => (\n+        impl ::core::borrow::Borrow<[u8]> for $ty {\n+            fn borrow(&self) -> &[u8] {\n+                &self[..]\n+            }\n+        }\n+\n+        impl ::core::convert::AsRef<[u8]> for $ty {\n+            fn as_ref(&self) -> &[u8] {\n+                &self[..]\n+            }\n+        }\n+\n+        impl ::core::ops::Deref for $ty {\n+            type Target = [u8];\n+\n+            fn deref(&self) -> &Self::Target {\n+                &self.0\n+            }\n+        }\n+    )\n+);\n+\n+macro_rules! engine_input_impl(\n+    () => (\n+        #[cfg(not(feature = \"fuzztarget\"))]\n+        fn input(&mut self, mut inp: &[u8]) {\n+            while !inp.is_empty() {\n+                let buf_idx = self.length % <Self as EngineTrait>::BLOCK_SIZE;\n+                let rem_len = <Self as EngineTrait>::BLOCK_SIZE - buf_idx;\n+                let write_len = cmp::min(rem_len, inp.len());\n+\n+                self.buffer[buf_idx..buf_idx + write_len]\n+                    .copy_from_slice(&inp[..write_len]);\n+                self.length += write_len;\n+                if self.length % <Self as EngineTrait>::BLOCK_SIZE == 0 {\n+                    self.process_block();\n+                }\n+                inp = &inp[write_len..];\n+            }\n+        }\n+\n+        #[cfg(feature = \"fuzztarget\")]\n+        fn input(&mut self, inp: &[u8]) {\n+            for c in inp {\n+                self.buffer[0] ^= *c;\n+            }\n+            self.length += inp.len();\n+        }\n+    )\n+);\n+\n+#[inline]\n+pub fn slice_to_u32_be(slice: &[u8]) -> u32 {\n+    assert_eq!(slice.len(), 4);\n+    (slice[0] as u32) << 3*8 |\n+    (slice[1] as u32) << 2*8 |\n+    (slice[2] as u32) << 1*8 |\n+    (slice[3] as u32) << 0*8\n+}\n+\n+#[inline]\n+pub fn u32_to_array_be(val: u32) -> [u8; 4] {\n+    [\n+        ((val >> 3*8) & 0xff) as u8,\n+        ((val >> 2*8) & 0xff) as u8,\n+        ((val >> 1*8) & 0xff) as u8,\n+        ((val >> 0*8) & 0xff) as u8,\n+    ]\n+}\n+\n+#[inline]\n+pub fn slice_to_u64_be(slice: &[u8]) -> u64 {\n+    assert_eq!(slice.len(), 8);\n+    (slice[0] as u64) << 7*8 |\n+    (slice[1] as u64) << 6*8 |\n+    (slice[2] as u64) << 5*8 |\n+    (slice[3] as u64) << 4*8 |\n+    (slice[4] as u64) << 3*8 |\n+    (slice[5] as u64) << 2*8 |\n+    (slice[6] as u64) << 1*8 |\n+    (slice[7] as u64) << 0*8\n+}\n+\n+#[inline]\n+pub fn u64_to_array_be(val: u64) -> [u8; 8] {\n+    [\n+        ((val >> 7*8) & 0xff) as u8,\n+        ((val >> 6*8) & 0xff) as u8,\n+        ((val >> 5*8) & 0xff) as u8,\n+        ((val >> 4*8) & 0xff) as u8,\n+        ((val >> 3*8) & 0xff) as u8,\n+        ((val >> 2*8) & 0xff) as u8,\n+        ((val >> 1*8) & 0xff) as u8,\n+        ((val >> 0*8) & 0xff) as u8,\n+    ]\n+}\n+\n+#[inline]\n+pub fn slice_to_u32_le(slice: &[u8]) -> u32 {\n+    assert_eq!(slice.len(), 4);\n+    (slice[0] as u32) << 0*8 |\n+    (slice[1] as u32) << 1*8 |\n+    (slice[2] as u32) << 2*8 |\n+    (slice[3] as u32) << 3*8\n+}\n+\n+#[inline]\n+pub fn u32_to_array_le(val: u32) -> [u8; 4] {\n+    [\n+        ((val >> 0*8) & 0xff) as u8,\n+        ((val >> 1*8) & 0xff) as u8,\n+        ((val >> 2*8) & 0xff) as u8,\n+        ((val >> 3*8) & 0xff) as u8,\n+    ]\n+}\n+\n+#[inline]\n+pub fn slice_to_u64_le(slice: &[u8]) -> u64 {\n+    assert_eq!(slice.len(), 8);\n+    (slice[0] as u64) << 0*8 |\n+    (slice[1] as u64) << 1*8 |\n+    (slice[2] as u64) << 2*8 |\n+    (slice[3] as u64) << 3*8 |\n+    (slice[4] as u64) << 4*8 |\n+    (slice[5] as u64) << 5*8 |\n+    (slice[6] as u64) << 6*8 |\n+    (slice[7] as u64) << 7*8\n+}\n+\n+#[inline]\n+pub fn u64_to_array_le(val: u64) -> [u8; 8] {\n+    [\n+        ((val >> 0*8) & 0xff) as u8,\n+        ((val >> 1*8) & 0xff) as u8,\n+        ((val >> 2*8) & 0xff) as u8,\n+        ((val >> 3*8) & 0xff) as u8,\n+        ((val >> 4*8) & 0xff) as u8,\n+        ((val >> 5*8) & 0xff) as u8,\n+        ((val >> 6*8) & 0xff) as u8,\n+        ((val >> 7*8) & 0xff) as u8,\n+    ]\n+}\n+\n+#[cfg(test)]\n+mod test {\n+    use Hash;\n+    use sha256;\n+\n+    #[test]\n+    fn borrow_slice_impl_to_vec() {\n+        // Test that the borrow_slice_impl macro gives to_vec.\n+        let hash = sha256::Hash::hash(&[3, 50]);\n+        assert_eq!(hash.to_vec().len(), sha256::Hash::LEN);\n+    }\n+}"
      },
      {
        "sha": "a73eb091108f2bed392c5bed286e5e58468d1250",
        "filename": "src/rusty/rust-bech32/Cargo.toml",
        "status": "added",
        "additions": 16,
        "deletions": 0,
        "changes": 16,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bech32/Cargo.toml?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,16 @@\n+[package]\n+name = \"bech32\"\n+version = \"0.7.1\"\n+authors = [\"Clark Moody\"]\n+repository = \"https://github.com/rust-bitcoin/rust-bech32\"\n+description = \"Encodes and decodes the Bech32 format\"\n+readme = \"README.md\"\n+keywords = [\"base32\", \"encoding\", \"bech32\"]\n+categories = [\"encoding\"]\n+license = \"MIT\"\n+\n+[features]\n+# Only for CI to make all warnings errors, do not activate otherwise (may break forward compatibility)\n+strict = []\n+\n+[dependencies]"
      },
      {
        "sha": "d10a7649aa6ba7a727f0c40b3b7e47d47da293ed",
        "filename": "src/rusty/rust-bech32/README.md",
        "status": "added",
        "additions": 8,
        "deletions": 0,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bech32/README.md?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,8 @@\n+# Bech32 Rust\n+[![Docs.rs badge](https://docs.rs/bech32/badge.svg)](https://docs.rs/bech32/)\n+[![Build Status](https://travis-ci.org/rust-bitcoin/rust-bech32.svg?branch=master)](https://travis-ci.org/rust-bitcoin/rust-bech32)\n+\n+Rust implementation of the Bech32 encoding format described in [BIP-0173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki).\n+You can find some usage examples in the [documentation](https://docs.rs/bech32/).\n+\n+Bitcoin-specific address encoding is handled by the `bitcoin-bech32` crate."
      },
      {
        "sha": "978cc773286dfbcace9c5f9882471f48e9246585",
        "filename": "src/rusty/rust-bech32/fuzz/.gitignore",
        "status": "added",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/fuzz/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/fuzz/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bech32/fuzz/.gitignore?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,3 @@\n+target\n+hfuzz_*\n+Cargo.lock\n\\ No newline at end of file"
      },
      {
        "sha": "c661ef6ec349c33f95ce87bf0040bd5c9716fd87",
        "filename": "src/rusty/rust-bech32/fuzz/Cargo.toml",
        "status": "added",
        "additions": 30,
        "deletions": 0,
        "changes": 30,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/fuzz/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/fuzz/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bech32/fuzz/Cargo.toml?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,30 @@\n+[package]\n+name = \"bech32-fuzz\"\n+version = \"0.0.1\"\n+authors = [\"Automatically generated\"]\n+publish = false\n+\n+[package.metadata]\n+cargo-fuzz = true\n+\n+[features]\n+afl_fuzz = [\"afl\"]\n+honggfuzz_fuzz = [\"honggfuzz\"]\n+\n+[dependencies]\n+honggfuzz = { version = \"0.5\", optional = true }\n+afl = { version = \"0.3\", optional = true }\n+libc = \"0.2\"\n+bech32 = { path = \"..\" }\n+\n+# Prevent this from interfering with workspaces\n+[workspace]\n+members = [\".\"]\n+\n+[[bin]]\n+name = \"decode_rnd\"\n+path = \"fuzz_targets/decode_rnd.rs\"\n+\n+[[bin]]\n+name = \"encode_decode\"\n+path = \"fuzz_targets/encode_decode.rs\"\n\\ No newline at end of file"
      },
      {
        "sha": "cc8eea3b02e34e7d246cd00f4d8b915cf22eda76",
        "filename": "src/rusty/rust-bech32/fuzz/fuzz_targets/decode_rnd.rs",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/fuzz/fuzz_targets/decode_rnd.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/fuzz/fuzz_targets/decode_rnd.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bech32/fuzz/fuzz_targets/decode_rnd.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,61 @@\n+extern crate bech32;\n+\n+use std::str::FromStr;\n+\n+fn do_test(data: &[u8]) {\n+    let data_str = String::from_utf8_lossy(data);\n+    let decoded = bech32::decode(&data_str);\n+    let b32 = match decoded {\n+        Ok(b32) => b32,\n+        Err(_) => return,\n+    };\n+\n+    assert_eq!(bech32::encode(&b32.0, b32.1).unwrap(), data_str);\n+}\n+\n+#[cfg(feature = \"afl\")]\n+extern crate afl;\n+#[cfg(feature = \"afl\")]\n+fn main() {\n+    afl::read_stdio_bytes(|data| {\n+        do_test(&data);\n+    });\n+}\n+\n+#[cfg(feature = \"honggfuzz\")]\n+#[macro_use] extern crate honggfuzz;\n+#[cfg(feature = \"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|data| {\n+            do_test(data);\n+        });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"00000000\", &mut a);\n+        super::do_test(&a);\n+    }\n+}"
      },
      {
        "sha": "cce3e7b629fda6ba64e37c2e71f051712798d62d",
        "filename": "src/rusty/rust-bech32/fuzz/fuzz_targets/encode_decode.rs",
        "status": "added",
        "additions": 76,
        "deletions": 0,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/fuzz/fuzz_targets/encode_decode.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/fuzz/fuzz_targets/encode_decode.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bech32/fuzz/fuzz_targets/encode_decode.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,76 @@\n+extern crate bech32;\n+\n+use std::str::FromStr;\n+\n+fn do_test(data: &[u8]) {\n+    if data.len() < 1 {\n+        return;\n+    }\n+\n+    let hrp_end = (data[0] as usize) + 1;\n+\n+    if data.len() < hrp_end {\n+        return;\n+    }\n+\n+    let hrp = String::from_utf8_lossy(&data[1..hrp_end]).to_lowercase().to_string();\n+\n+    let dp = data[hrp_end..]\n+        .iter()\n+        .map(|b| bech32::u5::try_from_u8(b % 32).unwrap())\n+        .collect::<Vec<_>>();\n+\n+    if let Ok(data_str) = bech32::encode(&hrp, &dp).map(|b32| b32.to_string()) {\n+        let decoded = bech32::decode(&data_str);\n+        let b32 = decoded.expect(\"should be able to decode own encoding\");\n+\n+        assert_eq!(bech32::encode(&b32.0, &b32.1).unwrap(), data_str);\n+    }\n+}\n+\n+#[cfg(feature = \"afl\")]\n+extern crate afl;\n+#[cfg(feature = \"afl\")]\n+fn main() {\n+    afl::read_stdio_bytes(|data| {\n+        do_test(&data);\n+    });\n+}\n+\n+#[cfg(feature = \"honggfuzz\")]\n+#[macro_use] extern crate honggfuzz;\n+#[cfg(feature = \"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|data| {\n+            do_test(data);\n+        });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().filter(|&&c| c != b'\\n').enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"ff6c2d\", &mut a);\n+        super::do_test(&a);\n+    }\n+}"
      },
      {
        "sha": "ae85ea91301283a5a6765949f361deaba9986304",
        "filename": "src/rusty/rust-bech32/fuzz/travis-fuzz.sh",
        "status": "added",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/fuzz/travis-fuzz.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/fuzz/travis-fuzz.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bech32/fuzz/travis-fuzz.sh?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,19 @@\n+#!/bin/bash\n+set -e\n+cargo install --force honggfuzz\n+for TARGET in fuzz_targets/*; do\n+    FILENAME=$(basename $TARGET)\n+\tFILE=\"${FILENAME%.*}\"\n+\tif [ -d hfuzz_input/$FILE ]; then\n+\t    HFUZZ_INPUT_ARGS=\"-f hfuzz_input/$FILE/input\"\n+\tfi\n+\tHFUZZ_BUILD_ARGS=\"--features honggfuzz_fuzz\" HFUZZ_RUN_ARGS=\"-N1000000 --exit_upon_crash -v $HFUZZ_INPUT_ARGS\" cargo hfuzz run $FILE\n+\n+\tif [ -f hfuzz_workspace/$FILE/HONGGFUZZ.REPORT.TXT ]; then\n+\t\tcat hfuzz_workspace/$FILE/HONGGFUZZ.REPORT.TXT\n+\t\tfor CASE in hfuzz_workspace/$FILE/SIG*; do\n+\t\t\tcat $CASE | xxd -p\n+\t\tdone\n+\t\texit 1\n+\tfi\n+done"
      },
      {
        "sha": "54ff43080026350cc7f3d65694713fbbb4ceb675",
        "filename": "src/rusty/rust-bech32/src/lib.rs",
        "status": "added",
        "additions": 843,
        "deletions": 0,
        "changes": 843,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bech32/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bech32/src/lib.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,843 @@\n+// Copyright (c) 2017 Clark Moody\n+//\n+// Permission is hereby granted, free of charge, to any person obtaining a copy\n+// of this software and associated documentation files (the \"Software\"), to deal\n+// in the Software without restriction, including without limitation the rights\n+// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\n+// copies of the Software, and to permit persons to whom the Software is\n+// furnished to do so, subject to the following conditions:\n+//\n+// The above copyright notice and this permission notice shall be included in\n+// all copies or substantial portions of the Software.\n+//\n+// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\n+// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\n+// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\n+// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\n+// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\n+// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\n+// THE SOFTWARE.\n+\n+//! Encoding and decoding Bech32 format\n+//!\n+//! Bech32 is a 5-bit (base-32) encoding scheme that produces strings that comprise\n+//! a human-readable part, a separator, a data part, and a checksum. The encoding\n+//! implements a BCH code that guarantees error detection of up to four characters\n+//! with less than 1 in 1 billion chance of failing to detect more errors.\n+//!\n+//! The Bech32 encoding was originally formulated in [BIP-0173](https://github.com/bitcoin/bips/blob/master/bip-0173.mediawiki)\n+//!\n+//! # Examples\n+//!\n+//! ```rust\n+//! use bech32::{self, FromBase32, ToBase32};\n+//!\n+//! let encoded = bech32::encode(\"bech32\", vec![0x00, 0x01, 0x02].to_base32()).unwrap();\n+//! assert_eq!(encoded, \"bech321qqqsyrhqy2a\".to_string());\n+//!\n+//! let (hrp, data) = bech32::decode(&encoded).unwrap();\n+//! assert_eq!(hrp, \"bech32\");\n+//! assert_eq!(Vec::<u8>::from_base32(&data).unwrap(), vec![0x00, 0x01, 0x02]);\n+//! ```\n+//!\n+\n+// Allow trait objects without dyn on nightly and make 1.22 ignore the unknown lint\n+#![allow(unknown_lints)]\n+#![allow(bare_trait_objects)]\n+\n+#![deny(missing_docs)]\n+#![deny(non_upper_case_globals)]\n+#![deny(non_camel_case_types)]\n+#![deny(non_snake_case)]\n+#![deny(unused_mut)]\n+#![cfg_attr(feature = \"strict\", deny(warnings))]\n+\n+use std::{error, fmt};\n+\n+// AsciiExt is needed for Rust 1.14 but not for newer versions\n+#[allow(unused_imports, deprecated)]\n+use std::ascii::AsciiExt;\n+\n+/// Integer in the range `0..32`\n+#[derive(PartialEq, Eq, Debug, Copy, Clone, Default, PartialOrd, Ord, Hash)]\n+#[allow(non_camel_case_types)]\n+pub struct u5(u8);\n+\n+impl u5 {\n+    /// Convert a `u8` to `u5` if in range, return `Error` otherwise\n+    pub fn try_from_u8(value: u8) -> Result<u5, Error> {\n+        if value > 31 {\n+            Err(Error::InvalidData(value))\n+        } else {\n+            Ok(u5(value))\n+        }\n+    }\n+\n+    /// Returns a copy of the underlying `u8` value\n+    pub fn to_u8(&self) -> u8 {\n+        self.0\n+    }\n+\n+    /// Get char representing this 5 bit value as defined in BIP173\n+    pub fn to_char(&self) -> char {\n+        CHARSET[self.to_u8() as usize]\n+    }\n+}\n+\n+impl Into<u8> for u5 {\n+    fn into(self) -> u8 {\n+        self.0\n+    }\n+}\n+\n+impl AsRef<u8> for u5 {\n+    fn as_ref(&self) -> &u8 {\n+        &self.0\n+    }\n+}\n+\n+/// Interface to write `u5`s into a sink\n+pub trait WriteBase32 {\n+    /// Write error\n+    type Err: fmt::Debug;\n+\n+    /// Write a `u5` slice\n+    fn write(&mut self, data: &[u5]) -> Result<(), Self::Err> {\n+        for b in data {\n+            self.write_u5(*b)?;\n+        }\n+        Ok(())\n+    }\n+\n+    /// Write a single `u5`\n+    fn write_u5(&mut self, data: u5) -> Result<(), Self::Err>;\n+}\n+\n+/// Allocationless Bech32 writer that accumulates the checksum data internally and writes them out\n+/// in the end.\n+pub struct Bech32Writer<'a> {\n+    formatter: &'a mut fmt::Write,\n+    chk: u32,\n+}\n+\n+impl<'a> Bech32Writer<'a> {\n+    /// Creates a new writer that can write a bech32 string without allocating itself.\n+    ///\n+    /// This is a rather low-level API and doesn't check the HRP or data length for standard\n+    /// compliance.\n+    pub fn new(hrp: &str, fmt: &'a mut fmt::Write) -> Result<Bech32Writer<'a>, fmt::Error> {\n+        let mut writer = Bech32Writer {\n+            formatter: fmt,\n+            chk: 1,\n+        };\n+\n+        writer.formatter.write_str(hrp)?;\n+        writer.formatter.write_char(SEP)?;\n+\n+        // expand HRP\n+        for b in hrp.bytes() {\n+            writer.polymod_step(u5(b >> 5));\n+        }\n+        writer.polymod_step(u5(0));\n+        for b in hrp.bytes() {\n+            writer.polymod_step(u5(b & 0x1f));\n+        }\n+\n+        Ok(writer)\n+    }\n+\n+    fn polymod_step(&mut self, v: u5) {\n+        let b = (self.chk >> 25) as u8;\n+        self.chk = (self.chk & 0x1ffffff) << 5 ^ (u32::from(*v.as_ref()));\n+        for i in 0..5 {\n+            if (b >> i) & 1 == 1 {\n+                self.chk ^= GEN[i]\n+            }\n+        }\n+    }\n+\n+    /// Write out the checksum at the end. If this method isn't called this will happen on drop.\n+    pub fn finalize(mut self) -> fmt::Result {\n+        self.inner_finalize()?;\n+        std::mem::forget(self);\n+        Ok(())\n+    }\n+\n+    fn inner_finalize(&mut self) -> fmt::Result {\n+        // Pad with 6 zeros\n+        for _ in 0..6 {\n+            self.polymod_step(u5(0))\n+        }\n+\n+        let plm: u32 = self.chk ^ 1;\n+\n+        for p in 0..6 {\n+            self.formatter.write_char(\n+                u5(((plm >> (5 * (5 - p))) & 0x1f) as u8).to_char()\n+            )?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+impl<'a> WriteBase32 for Bech32Writer<'a> {\n+    type Err = fmt::Error;\n+\n+    /// Writes a single 5 bit value of the data part\n+    fn write_u5(&mut self, data: u5) -> fmt::Result {\n+        self.polymod_step(data);\n+        self.formatter.write_char(data.to_char())\n+    }\n+}\n+\n+impl<'a> Drop for Bech32Writer<'a> {\n+    fn drop(&mut self) {\n+        self.inner_finalize().expect(\"Unhandled error writing the checksum on drop.\")\n+    }\n+}\n+\n+/// Parse/convert base32 slice to `Self`. It is the reciprocal of\n+/// `ToBase32`.\n+pub trait FromBase32: Sized {\n+    /// The associated error which can be returned from parsing (e.g. because of bad padding).\n+    type Err;\n+\n+    /// Convert a base32 slice to `Self`.\n+    fn from_base32(b32: &[u5]) -> Result<Self, Self::Err>;\n+}\n+\n+impl WriteBase32 for Vec<u5> {\n+    type Err = ();\n+\n+    fn write(&mut self, data: &[u5]) -> Result<(), Self::Err> {\n+        self.extend_from_slice(data);\n+        Ok(())\n+    }\n+\n+    fn write_u5(&mut self, data: u5) -> Result<(), Self::Err> {\n+        self.push(data);\n+        Ok(())\n+    }\n+}\n+\n+impl FromBase32 for Vec<u8> {\n+    type Err = Error;\n+\n+    /// Convert base32 to base256, removes null-padding if present, returns\n+    /// `Err(Error::InvalidPadding)` if padding bits are unequal `0`\n+    fn from_base32(b32: &[u5]) -> Result<Self, Self::Err> {\n+        convert_bits(b32, 5, 8, false)\n+    }\n+}\n+\n+/// A trait for converting a value to a type `T` that represents a `u5` slice.\n+pub trait ToBase32 {\n+    /// Convert `Self` to base32 vector\n+    fn to_base32(&self) -> Vec<u5> {\n+        let mut vec = Vec::new();\n+        self.write_base32(&mut vec).unwrap();\n+        vec\n+    }\n+\n+    /// Encode as base32 and write it to the supplied writer\n+    /// Implementations shouldn't allocate.\n+    fn write_base32<W: WriteBase32>(&self, writer: &mut W) -> Result<(), <W as WriteBase32>::Err>;\n+}\n+\n+/// Interface to calculate the length of the base32 representation before actually serializing\n+pub trait Base32Len : ToBase32 {\n+    /// Calculate the base32 serialized length\n+    fn base32_len(&self) -> usize;\n+}\n+\n+impl<T: AsRef<[u8]>> ToBase32 for T {\n+    fn write_base32<W: WriteBase32>(&self, writer: &mut W) -> Result<(), <W as WriteBase32>::Err> {\n+        // Amount of bits left over from last round, stored in buffer.\n+        let mut buffer_bits = 0u32;\n+        // Holds all unwritten bits left over from last round. The bits are stored beginning from\n+        // the most significant bit. E.g. if buffer_bits=3, then the byte with bits a, b and c will\n+        // look as follows: [a, b, c, 0, 0, 0, 0, 0]\n+        let mut buffer: u8 = 0;\n+\n+        for &b in self.as_ref() {\n+            // Write first u5 if we have to write two u5s this round. That only happens if the\n+            // buffer holds too many bits, so we don't have to combine buffer bits with new bits\n+            // from this rounds byte.\n+            if buffer_bits >= 5 {\n+                writer.write_u5(u5((buffer & 0b11111000) >> 3 ))?;\n+                buffer = buffer << 5;\n+                buffer_bits -= 5;\n+            }\n+\n+            // Combine all bits from buffer with enough bits from this rounds byte so that they fill\n+            // a u5. Save reamining bits from byte to buffer.\n+            let from_buffer = buffer >> 3;\n+            let from_byte = b >> (3 + buffer_bits); // buffer_bits <= 4\n+\n+            writer.write_u5(u5(from_buffer | from_byte))?;\n+            buffer = b << (5 - buffer_bits);\n+            buffer_bits = 3 + buffer_bits;\n+        }\n+\n+        // There can be at most two u5s left in the buffer after processing all bytes, write them.\n+        if buffer_bits >= 5 {\n+            writer.write_u5(u5((buffer & 0b11111000) >> 3))?;\n+            buffer = buffer << 5;\n+            buffer_bits -= 5;\n+        }\n+\n+        if buffer_bits != 0 {\n+            writer.write_u5(u5(buffer >> 3))?;\n+        }\n+\n+        Ok(())\n+    }\n+}\n+\n+impl<T: AsRef<[u8]>> Base32Len for T {\n+    fn base32_len(&self) -> usize {\n+        let bits = self.as_ref().len() * 8;\n+        if bits % 5 == 0 {\n+            bits / 5\n+        } else {\n+            bits / 5 + 1\n+        }\n+    }\n+}\n+\n+/// A trait to convert between u8 arrays and u5 arrays without changing the content of the elements,\n+/// but checking that they are in range.\n+pub trait CheckBase32<T: AsRef<[u5]>> {\n+    /// Error type if conversion fails\n+    type Err;\n+\n+    /// Check if all values are in range and return array-like struct of `u5` values\n+    fn check_base32(self) -> Result<T, Self::Err>;\n+}\n+\n+impl<'f, T: AsRef<[u8]>> CheckBase32<Vec<u5>> for T {\n+    type Err = Error;\n+\n+    fn check_base32(self) -> Result<Vec<u5>, Self::Err> {\n+        self.as_ref().iter().map(|x| u5::try_from_u8(*x)).collect::<Result<Vec<u5>, Error>>()\n+    }\n+}\n+\n+#[derive(Clone, Copy, PartialEq, Eq)]\n+enum Case {\n+    Upper,\n+    Lower,\n+    None,\n+}\n+\n+/// Check if the HRP is valid. Returns the case of the HRP, if any.\n+/// True for uppercase, false for lowercase, None for only digits.\n+///\n+/// # Errors\n+/// * **MixedCase**: If the HRP contains both uppercase and lowercase characters.\n+/// * **InvalidChar**: If the HRP contains any non-ASCII characters (outside 33..=126).\n+/// * **InvalidLength**: If the HRP is outside 1..83 characters long.\n+fn check_hrp(hrp: &str) -> Result<Case, Error> {\n+    if hrp.is_empty() || hrp.len() > 83 {\n+        return Err(Error::InvalidLength);\n+    }\n+\n+    let mut has_lower: bool = false;\n+    let mut has_upper: bool = false;\n+    for b in hrp.bytes() {\n+        // Valid subset of ASCII\n+        if b < 33 || b > 126 {\n+            return Err(Error::InvalidChar(b as char));\n+        }\n+\n+        if b >= b'a' && b <= b'z' {\n+            has_lower = true;\n+        } else if b >= b'A' && b <= b'Z' {\n+            has_upper = true;\n+        };\n+\n+        if has_lower && has_upper {\n+            return Err(Error::MixedCase);\n+        }\n+    }\n+\n+    Ok(match (has_upper, has_lower) {\n+        (true, false) => Case::Upper,\n+        (false, true) => Case::Lower,\n+        (false, false) => Case::None,\n+        (true, true) => unreachable!(),\n+    })\n+}\n+\n+/// Encode a bech32 payload to an [fmt::Write].\n+/// This method is intended for implementing traits from [std::fmt].\n+///\n+/// # Errors\n+/// * If [check_hrp] returns an error for the given HRP.\n+/// # Deviations from standard\n+/// * No length limits are enforced for the data part\n+pub fn encode_to_fmt<T: AsRef<[u5]>>(\n+    fmt: &mut fmt::Write,\n+    hrp: &str,\n+    data: T,\n+) -> Result<fmt::Result, Error> {\n+    check_hrp(&hrp)?;\n+    match Bech32Writer::new(hrp, fmt) {\n+        Ok(mut writer) => {\n+            Ok(writer.write(data.as_ref()).and_then(|_| {\n+                // Finalize manually to avoid panic on drop if write fails\n+                writer.finalize()\n+            }))\n+        },\n+        Err(e) => Ok(Err(e)),\n+    }\n+}\n+\n+/// Encode a bech32 payload to string.\n+///\n+/// # Errors\n+/// * If [check_hrp] returns an error for the given HRP.\n+/// # Deviations from standard\n+/// * No length limits are enforced for the data part\n+pub fn encode<T: AsRef<[u5]>>(hrp: &str, data: T) -> Result<String, Error> {\n+    let mut buf = String::new();\n+    encode_to_fmt(&mut buf, hrp, data)?.unwrap();\n+    Ok(buf)\n+}\n+\n+/// Decode a bech32 string into the raw HRP and the data bytes.\n+///\n+/// Returns the HRP in lowercase..\n+pub fn decode(s: &str) -> Result<(String, Vec<u5>), Error> {\n+    // Ensure overall length is within bounds\n+    if s.len() < 8 {\n+        return Err(Error::InvalidLength);\n+    }\n+\n+    // Split at separator and check for two pieces\n+    let (raw_hrp, raw_data) = match s.rfind(SEP) {\n+        None => return Err(Error::MissingSeparator),\n+        Some(sep) => {\n+            let (hrp, data) = s.split_at(sep);\n+            (hrp, &data[1..])\n+        }\n+    };\n+    if raw_data.len() < 6 {\n+        return Err(Error::InvalidLength);\n+    }\n+\n+    let mut case = check_hrp(&raw_hrp)?;\n+    let hrp_lower = match case {\n+        Case::Upper => raw_hrp.to_lowercase(),\n+        // already lowercase\n+        Case::Lower | Case::None => String::from(raw_hrp),\n+    };\n+\n+    // Check data payload\n+    let mut data = raw_data\n+        .chars()\n+        .map(|c| {\n+            // Only check if c is in the ASCII range, all invalid ASCII\n+            // characters have the value -1 in CHARSET_REV (which covers\n+            // the whole ASCII range) and will be filtered out later.\n+            if !c.is_ascii() {\n+                return Err(Error::InvalidChar(c));\n+            }\n+\n+            if c.is_lowercase() {\n+                match case {\n+                    Case::Upper => return Err(Error::MixedCase),\n+                    Case::None => case = Case::Lower,\n+                    Case::Lower => {}\n+                }\n+            } else if c.is_uppercase() {\n+                match case {\n+                    Case::Lower => return Err(Error::MixedCase),\n+                    Case::None => case = Case::Upper,\n+                    Case::Upper => {}\n+                }\n+            }\n+\n+            // c should be <128 since it is in the ASCII range, CHARSET_REV.len() == 128\n+            let num_value = CHARSET_REV[c as usize];\n+\n+            if num_value > 31 || num_value < 0 {\n+                return Err(Error::InvalidChar(c));\n+            }\n+\n+            Ok(u5::try_from_u8(num_value as u8).expect(\"range checked above, num_value <= 31\"))\n+        })\n+        .collect::<Result<Vec<u5>, Error>>()?;\n+\n+    // Ensure checksum\n+    if !verify_checksum(&hrp_lower.as_bytes(), &data) {\n+        return Err(Error::InvalidChecksum);\n+    }\n+\n+    // Remove checksum from data payload\n+    let dbl: usize = data.len();\n+    data.truncate(dbl - 6);\n+\n+    Ok((hrp_lower, data))\n+}\n+\n+fn verify_checksum(hrp: &[u8], data: &[u5]) -> bool {\n+    let mut exp = hrp_expand(hrp);\n+    exp.extend_from_slice(data);\n+    polymod(&exp) == 1u32\n+}\n+\n+fn hrp_expand(hrp: &[u8]) -> Vec<u5> {\n+    let mut v: Vec<u5> = Vec::new();\n+    for b in hrp {\n+        v.push(u5::try_from_u8(*b >> 5).expect(\"can't be out of range, max. 7\"));\n+    }\n+    v.push(u5::try_from_u8(0).unwrap());\n+    for b in hrp {\n+        v.push(u5::try_from_u8(*b & 0x1f).expect(\"can't be out of range, max. 31\"));\n+    }\n+    v\n+}\n+\n+fn polymod(values: &[u5]) -> u32 {\n+    let mut chk: u32 = 1;\n+    let mut b: u8;\n+    for v in values {\n+        b = (chk >> 25) as u8;\n+        chk = (chk & 0x1ffffff) << 5 ^ (u32::from(*v.as_ref()));\n+        for i in 0..5 {\n+            if (b >> i) & 1 == 1 {\n+                chk ^= GEN[i]\n+            }\n+        }\n+    }\n+    chk\n+}\n+\n+/// Human-readable part and data part separator\n+const SEP: char = '1';\n+\n+/// Encoding character set. Maps data value -> char\n+const CHARSET: [char; 32] = [\n+    'q','p','z','r','y','9','x','8',\n+    'g','f','2','t','v','d','w','0',\n+    's','3','j','n','5','4','k','h',\n+    'c','e','6','m','u','a','7','l'\n+];\n+\n+/// Reverse character set. Maps ASCII byte -> CHARSET index on [0,31]\n+const CHARSET_REV: [i8; 128] = [\n+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+    -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1, -1,\n+    15, -1, 10, 17, 21, 20, 26, 30,  7,  5, -1, -1, -1, -1, -1, -1,\n+    -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,\n+     1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1,\n+    -1, 29, -1, 24, 13, 25,  9,  8, 23, -1, 18, 22, 31, 27, 19, -1,\n+    1,  0,  3, 16, 11, 28, 12, 14,  6,  4,  2, -1, -1, -1, -1, -1\n+];\n+\n+/// Generator coefficients\n+const GEN: [u32; 5] = [0x3b6a57b2, 0x26508e6d, 0x1ea119fa, 0x3d4233dd, 0x2a1462b3];\n+\n+/// Error types for Bech32 encoding / decoding\n+#[derive(Copy, Clone, PartialEq, Debug)]\n+pub enum Error {\n+    /// String does not contain the separator character\n+    MissingSeparator,\n+    /// The checksum does not match the rest of the data\n+    InvalidChecksum,\n+    /// The data or human-readable part is too long or too short\n+    InvalidLength,\n+    /// Some part of the string contains an invalid character\n+    InvalidChar(char),\n+    /// Some part of the data has an invalid value\n+    InvalidData(u8),\n+    /// The bit conversion failed due to a padding issue\n+    InvalidPadding,\n+    /// The whole string must be of one case\n+    MixedCase,\n+}\n+\n+impl fmt::Display for Error {\n+    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n+        match *self {\n+            Error::MissingSeparator => write!(f, \"missing human-readable separator, \\\"{}\\\"\", SEP),\n+            Error::InvalidChecksum => write!(f, \"invalid checksum\"),\n+            Error::InvalidLength => write!(f, \"invalid length\"),\n+            Error::InvalidChar(n) => write!(f, \"invalid character (code={})\", n),\n+            Error::InvalidData(n) => write!(f, \"invalid data point ({})\", n),\n+            Error::InvalidPadding => write!(f, \"invalid padding\"),\n+            Error::MixedCase => write!(f, \"mixed-case strings not allowed\"),\n+        }\n+    }\n+}\n+\n+impl error::Error for Error {\n+    fn description(&self) -> &str {\n+        match *self {\n+            Error::MissingSeparator => \"missing human-readable separator\",\n+            Error::InvalidChecksum => \"invalid checksum\",\n+            Error::InvalidLength => \"invalid length\",\n+            Error::InvalidChar(_) => \"invalid character\",\n+            Error::InvalidData(_) => \"invalid data point\",\n+            Error::InvalidPadding => \"invalid padding\",\n+            Error::MixedCase => \"mixed-case strings not allowed\",\n+        }\n+    }\n+}\n+\n+/// Convert between bit sizes\n+///\n+/// # Errors\n+/// * `Error::InvalidData` if any element of `data` is out of range\n+/// * `Error::InvalidPadding` if `pad == false` and the padding bits are not `0`\n+///\n+/// # Panics\n+/// Function will panic if attempting to convert `from` or `to` a bit size that\n+/// is 0 or larger than 8 bits.\n+///\n+/// # Examples\n+///\n+/// ```rust\n+/// use bech32::convert_bits;\n+/// let base5 = convert_bits(&[0xff], 8, 5, true);\n+/// assert_eq!(base5.unwrap(), vec![0x1f, 0x1c]);\n+/// ```\n+pub fn convert_bits<T>(data: &[T], from: u32, to: u32, pad: bool) -> Result<Vec<u8>, Error>\n+where\n+    T: Into<u8> + Copy,\n+{\n+    if from > 8 || to > 8 || from == 0 || to == 0 {\n+        panic!(\"convert_bits `from` and `to` parameters 0 or greater than 8\");\n+    }\n+    let mut acc: u32 = 0;\n+    let mut bits: u32 = 0;\n+    let mut ret: Vec<u8> = Vec::new();\n+    let maxv: u32 = (1 << to) - 1;\n+    for value in data {\n+        let v: u32 = u32::from(Into::<u8>::into(*value));\n+        if (v >> from) != 0 {\n+            // Input value exceeds `from` bit size\n+            return Err(Error::InvalidData(v as u8));\n+        }\n+        acc = (acc << from) | v;\n+        bits += from;\n+        while bits >= to {\n+            bits -= to;\n+            ret.push(((acc >> bits) & maxv) as u8);\n+        }\n+    }\n+    if pad {\n+        if bits > 0 {\n+            ret.push(((acc << (to - bits)) & maxv) as u8);\n+        }\n+    } else if bits >= from || ((acc << (to - bits)) & maxv) != 0 {\n+        return Err(Error::InvalidPadding);\n+    }\n+    Ok(ret)\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    use super::*;\n+\n+    #[test]\n+    fn getters() {\n+        let decoded = decode(\"BC1SW50QA3JX3S\").unwrap();\n+        let data = [16, 14, 20, 15, 0].check_base32().unwrap();\n+        assert_eq!(&decoded.0, \"bc\");\n+        assert_eq!(decoded.1, data.as_slice());\n+    }\n+\n+    #[test]\n+    fn valid_checksum() {\n+        let strings: Vec<&str> = vec!(\n+            \"A12UEL5L\",\n+            \"an83characterlonghumanreadablepartthatcontainsthenumber1andtheexcludedcharactersbio1tt5tgs\",\n+            \"abcdef1qpzry9x8gf2tvdw0s3jn54khce6mua7lmqqqxw\",\n+            \"11qqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqqc8247j\",\n+            \"split1checkupstagehandshakeupstreamerranterredcaperred2y9e3w\",\n+        );\n+        for s in strings {\n+            let decode_result = decode(s);\n+            if !decode_result.is_ok() {\n+                panic!(\"Did not decode: {:?} Reason: {:?}\", s, decode_result.unwrap_err());\n+            }\n+            assert!(decode_result.is_ok());\n+            let decoded = decode_result.unwrap();\n+            let encode_result = encode(&decoded.0, decoded.1).unwrap();\n+            assert_eq!(s.to_lowercase(), encode_result.to_lowercase());\n+        }\n+    }\n+\n+    #[test]\n+    fn invalid_strings() {\n+        let pairs: Vec<(&str, Error)> = vec!(\n+            (\" 1nwldj5\",\n+                Error::InvalidChar(' ')),\n+            (\"abc1\\u{2192}axkwrx\",\n+                Error::InvalidChar('\\u{2192}')),\n+            (\"an84characterslonghumanreadablepartthatcontainsthenumber1andtheexcludedcharactersbio1569pvx\",\n+                Error::InvalidLength),\n+            (\"pzry9x0s0muk\",\n+                Error::MissingSeparator),\n+            (\"1pzry9x0s0muk\",\n+                Error::InvalidLength),\n+            (\"x1b4n0q5v\",\n+                Error::InvalidChar('b')),\n+            (\"ABC1DEFGOH\",\n+                Error::InvalidChar('O')),\n+            (\"li1dgmt3\",\n+                Error::InvalidLength),\n+            (\"de1lg7wt\\u{ff}\",\n+                Error::InvalidChar('\\u{ff}')),\n+        );\n+        for p in pairs {\n+            let (s, expected_error) = p;\n+            let dec_result = decode(s);\n+            if dec_result.is_ok() {\n+                println!(\"{:?}\", dec_result.unwrap());\n+                panic!(\"Should be invalid: {:?}\", s);\n+            }\n+            assert_eq!(dec_result.unwrap_err(), expected_error, \"testing input '{}'\", s);\n+        }\n+    }\n+\n+    #[test]\n+    fn valid_conversion() {\n+        // Set of [data, from_bits, to_bits, pad, result]\n+        let tests: Vec<(Vec<u8>, u32, u32, bool, Vec<u8>)> = vec![\n+            (vec![0x01], 1, 1, true, vec![0x01]),\n+            (vec![0x01, 0x01], 1, 1, true, vec![0x01, 0x01]),\n+            (vec![0x01], 8, 8, true, vec![0x01]),\n+            (vec![0x01], 8, 4, true, vec![0x00, 0x01]),\n+            (vec![0x01], 8, 2, true, vec![0x00, 0x00, 0x00, 0x01]),\n+            (vec![0x01], 8, 1, true, vec![0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x01]),\n+            (vec![0xff], 8, 5, true, vec![0x1f, 0x1c]),\n+            (vec![0x1f, 0x1c], 5, 8, false, vec![0xff]),\n+        ];\n+        for t in tests {\n+            let (data, from_bits, to_bits, pad, expected_result) = t;\n+            let result = convert_bits(&data, from_bits, to_bits, pad);\n+            assert!(result.is_ok());\n+            assert_eq!(result.unwrap(), expected_result);\n+        }\n+    }\n+\n+    #[test]\n+    fn invalid_conversion() {\n+        // Set of [data, from_bits, to_bits, pad, expected error]\n+        let tests: Vec<(Vec<u8>, u32, u32, bool, Error)> = vec![\n+            (vec![0xff], 8, 5, false, Error::InvalidPadding),\n+            (vec![0x02], 1, 1, true, Error::InvalidData(0x02)),\n+        ];\n+        for t in tests {\n+            let (data, from_bits, to_bits, pad, expected_error) = t;\n+            let result = convert_bits(&data, from_bits, to_bits, pad);\n+            assert!(result.is_err());\n+            assert_eq!(result.unwrap_err(), expected_error);\n+        }\n+    }\n+\n+    #[test]\n+    fn convert_bits_invalid_bit_size() {\n+        use std::panic::{catch_unwind, set_hook, take_hook};\n+\n+        let invalid = &[(0, 8), (5, 0), (9, 5), (8, 10), (0, 16)];\n+\n+        for &(from, to) in invalid {\n+            set_hook(Box::new(|_| {}));\n+            let result = catch_unwind(|| {\n+                let _ = convert_bits(&[0], from, to, true);\n+            });\n+            let _ = take_hook();\n+            assert!(result.is_err());\n+        }\n+    }\n+\n+    #[test]\n+    fn check_base32() {\n+        assert!([0u8, 1, 2, 30, 31].check_base32().is_ok());\n+        assert!([0u8, 1, 2, 30, 31, 32].check_base32().is_err());\n+        assert!([0u8, 1, 2, 30, 31, 255].check_base32().is_err());\n+\n+        assert!([1u8, 2, 3, 4].check_base32().is_ok());\n+        assert_eq!([30u8, 31, 35, 20].check_base32(), Err(Error::InvalidData(35)));\n+    }\n+\n+    #[test]\n+    fn test_encode() {\n+        assert_eq!(\n+            encode(\"\", vec![1u8, 2, 3, 4].check_base32().unwrap()),\n+            Err(Error::InvalidLength)\n+        );\n+    }\n+\n+    #[test]\n+    fn from_base32() {\n+        use FromBase32;\n+        assert_eq!(Vec::from_base32(&[0x1f, 0x1c].check_base32().unwrap()), Ok(vec![0xff]));\n+        assert_eq!(\n+            Vec::from_base32(&[0x1f, 0x1f].check_base32().unwrap()),\n+            Err(Error::InvalidPadding)\n+        );\n+    }\n+\n+    #[test]\n+    fn to_base32() {\n+        use ToBase32;\n+        assert_eq!([0xffu8].to_base32(), [0x1f, 0x1c].check_base32().unwrap());\n+    }\n+\n+    #[test]\n+    fn reverse_charset() {\n+        use CHARSET_REV;\n+\n+        fn get_char_value(c: char) -> i8 {\n+            let charset = \"qpzry9x8gf2tvdw0s3jn54khce6mua7l\";\n+            match charset.find(c.to_ascii_lowercase()) {\n+                Some(x) => x as i8,\n+                None => -1,\n+            }\n+        }\n+\n+        let expected_rev_charset =\n+            (0u8..128).map(|i| get_char_value(i as char)).collect::<Vec<_>>();\n+\n+        assert_eq!(&(CHARSET_REV[..]), expected_rev_charset.as_slice());\n+    }\n+\n+    #[test]\n+    fn writer() {\n+        let hrp = \"lnbc\";\n+        let data = \"Hello World!\".as_bytes().to_base32();\n+\n+        let mut written_str = String::new();\n+        {\n+            let mut writer = Bech32Writer::new(hrp, &mut written_str).unwrap();\n+            writer.write(&data).unwrap();\n+            writer.finalize().unwrap();\n+        }\n+\n+        let encoded_str = encode(hrp, data).unwrap();\n+\n+        assert_eq!(encoded_str, written_str);\n+    }\n+\n+    #[test]\n+    fn write_on_drop() {\n+        let hrp = \"lntb\";\n+        let data = \"Hello World!\".as_bytes().to_base32();\n+\n+        let mut written_str = String::new();\n+        {\n+            let mut writer = Bech32Writer::new(hrp, &mut written_str).unwrap();\n+            writer.write(&data).unwrap();\n+        }\n+\n+        let encoded_str = encode(hrp, data).unwrap();\n+\n+        assert_eq!(encoded_str, written_str);\n+    }\n+}"
      },
      {
        "sha": "eb0768ca820cf475954433c3bedefa240c61e138",
        "filename": "src/rusty/rust-bitcoin/CHANGELOG.md",
        "status": "added",
        "additions": 156,
        "deletions": 0,
        "changes": 156,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/CHANGELOG.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/CHANGELOG.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/CHANGELOG.md?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,156 @@\n+\n+# 0.21.0 - 2019-10-02\n+\n+* Add [serde to `BlockHeader` and `Block`](https://github.com/rust-bitcoin/rust-bitcoin/pull/321)\n+* [Clean up `StreamReader` API](https://github.com/rust-bitcoin/rust-bitcoin/pull/318) (breaking change)\n+* Add [reject message](https://github.com/rust-bitcoin/rust-bitcoin/pull/323) to p2p messages\n+\n+# 0.20.0 - 2019-08-23\n+\n+* Update `secp256k1` 0.15 and `bitcoinconsensus` 0.17\n+\n+# 0.19.0 - 2019-08-16\n+\n+* Add `Amount` and `SignedAmount` types.\n+* Add BIP-158 support with `BlockFilter` and related types.\n+* Add `util::misc::signed_msg_hash()` for signing messages.\n+* Add `MerkleBlock` and `PartialMerkleTree` types.\n+* bip32: Support serde serializaton for types and add some utility methods:\n+    * `ChildNumber::increment`\n+    * `DerivationPath::children_from`\n+    * `DerivationPath::normal_children`\n+    * `DerivationPath::hardened_children`\n+* Add `blockdata::script::Builder::push_verify` to verify-ify an opcode.\n+* Add `sendheaders` network message.\n+* Add `OutPoint::new()` method and JSON-serialize as `<txid>:<vout>`.\n+* Refactor `Address` type:\n+    * Now supports segwit addresses with version >0.\n+    * Add `Address::from_script` constructor.\n+    * Add `Address::address_type` inspector.\n+    * Parsing now returns an `address::Error` instead of `encode::Error`.\n+    * Removed `bitcoin_bech32` dependency for bech32 payloads.\n+* bip143: Rename `witness_script` to `script_code`\n+* Rename `BlockHeader::spv_validate` to `validate_pow`\n+* Rename `OP_NOP2` and `OP_NOP3` to `OP_CLTV` and `OP_CSV`\n+* psbt: Use `BTreeMap` instead of `HashMap` to ensure serialization roundtrips.\n+* Drop `Decimal` type.\n+* Drop `LoneHeaders` type.\n+* Replace `strason` dependency with (optional) `serde_json`.\n+* Export the `bitcoin_hashes` and `secp256k1` dependent crates.\n+* Updated `bitcoin_hashes` dependency to v0.7.\n+* Removed `rand` and `serde_test` dependencies.\n+* Internal improvements to consensus encoding logic.\n+\n+# 0.18.0 - 2019-03-21\n+\n+* Update `bitcoin-bech32` version to 0.9\n+* add `to_bytes` method for `util::key` types\n+* add serde impls for `util::key` types\n+* contracthash: minor cleanups, use `util::key` types instead of `secp256k1` types\n+\n+# 0.17.1 - 2019-03-04\n+\n+* Add some trait impls to `PublicKey` for miniscript interoperability\n+\n+# 0.17.0 - 2019-02-28 - ``The PSBT Release''\n+\n+* **Update minimum rustc version to 1.22**.\n+* [Replace `rust-crypto` with `bitcoin_hashes`; refactor hash types](https://github.com/rust-bitcoin/rust-bitcoin/pull/215)\n+* [Remove `Address::p2pk`](https://github.com/rust-bitcoin/rust-bitcoin/pull/222/)\n+* Remove misleading blanket `MerkleRoot` implementation; [it is now only defined for `Block`](https://github.com/rust-bitcoin/rust-bitcoin/pull/218)\n+* [Add BIP157](https://github.com/rust-bitcoin/rust-bitcoin/pull/215) (client-side block filtering messages)\n+* Allow network messages [to be deserialized even across multiple packets](https://github.com/rust-bitcoin/rust-bitcoin/pull/231)\n+* [Replace all key types](https://github.com/rust-bitcoin/rust-bitcoin/pull/183) to better match abstractions needed for PSBT\n+* [Clean up BIP32](https://github.com/rust-bitcoin/rust-bitcoin/pull/233) in preparation for PSBT; [use new native key types rather than `secp256k1` ones](https://github.com/rust-bitcoin/rust-bitcoin/pull/238/)\n+* Remove [apparently-used `Option` serialization](https://github.com/rust-bitcoin/rust-bitcoin/pull/236#event-2158116421) code\n+* Finally merge [PSBT](https://github.com/rust-bitcoin/rust-bitcoin/pull/103) after nearly nine months\n+\n+# 0.16.0 - 2019-01-15\n+\n+* Reorganize opcode types to eliminate unsafe code\n+* Un-expose some macros that were unintentionally exported\n+* Update rust-secp256k1 dependency to 0.12\n+* Remove `util::iter::Pair` type which does not belong in this library\n+* Minor bugfixes and optimizations\n+\n+# 0.15.1 - 2018-11-08\n+\n+* [Detect p2pk addresses with compressed keys](https://github.com/rust-bitcoin/rust-bitcoin/pull/189)\n+\n+# 0.15.0 - 2018-11-03\n+\n+* [Significant API overhaul](https://github.com/rust-bitcoin/rust-bitcoin/pull/156):\n+    * Remove `nu_select` macro and low-level networking support\n+    * Move `network::consensus_params` to `consensus::params`\n+    * Move many other things into `consensus::params`\n+    * Move `BitcoinHash` from `network::serialize` to `util::hash`; remove impl for `Vec<u8>`\n+    * Rename/restructure error types\n+    * Rename `Consensus{De,En}coder` to `consensus::{De,En}coder`\n+    * Replace `Raw{De,En}coder` with blanket impls of `consensus::{De,En}coder` on `io::Read` and `io::Write`\n+    * make `serialize` and `serialize_hex` infallible\n+* Make 0-input transaction de/serialization [always use segwit](https://github.com/rust-bitcoin/rust-bitcoin/pull/153)\n+* Implement `FromStr` and `Display` for many more types\n+\n+# 0.14.2 - 2018-09-11\n+\n+* Add serde support for `Address`\n+\n+# 0.14.1 - 2018-08-28\n+\n+* Reject non-compact `VarInt`s on various types\n+* Expose many types at the top level of the crate\n+* Add `Ord`, `PartialOrd` impls for `Script`\n+\n+# 0.14.0 - 2018-08-22\n+\n+* Add [regtest network](https://github.com/rust-bitcoin/rust-bitcoin/pull/84) to `Network` enum\n+* Add [`Script::is_op_return()`](https://github.com/rust-bitcoin/rust-bitcoin/pull/101/) which is more specific than\n+  `Script::is_provably_unspendable()`\n+* Update to bech32 0.8.0; [add Regtest bech32 address support](https://github.com/rust-bitcoin/rust-bitcoin/pull/110)\n+* [Replace rustc-serialize dependency with hex](https://github.com/rust-bitcoin/rust-bitcoin/pull/107) as a stopgap\n+  toward eliminating any extra dependencies for this; clean up the many independent hex encoders and decoders\n+  throughout the codebase.\n+* [Add conversions between `ChildNumber` and `u32`](https://github.com/rust-bitcoin/rust-bitcoin/pull/126); make\n+  representation non-public; fix documentation\n+* [Add several derivation convenience](https://github.com/rust-bitcoin/rust-bitcoin/pull/129) to `bip32` extended keys\n+* Make `deserialize::deserialize()` [enforce no trailing bytes](https://github.com/rust-bitcoin/rust-bitcoin/pull/129)\n+* Replace `TxOutRef` with `OutPoint`; use it in `TxIn` struct.\n+* Use modern `as_` `to_` `into_` conventions for array-wrapping types; impl `Display` rather than `ToString` for most types\n+* Change `script::Instructions` iterator [to allow rejecting non-minimal pushes](https://github.com/rust-bitcoin/rust-bitcoin/pull/136);\n+  fix bug where errors would iterate forever.\n+* Overhaul `util::Error`; introduce `serialize::Error` [and use it for `SimpleDecoder` and `SimpleDecoder` rather\n+  than parameterizing these over their error type](https://github.com/rust-bitcoin/rust-bitcoin/pull/137).\n+* Overhaul `UDecimal` and `Decimal` serialization and parsing [and fix many lingering parsing bugs](https://github.com/rust-bitcoin/rust-bitcoin/pull/142)\n+* [Update to serde 1.0 and strason 0.4](https://github.com/rust-bitcoin/rust-bitcoin/pull/125)\n+* Update to secp256k1 0.11.0\n+* Many, many documentation and test improvements.\n+\n+# 0.13.1\n+\n+* Add `Display` trait to uints, `FromStr` trait to `Network` enum\n+* Add witness inv types to inv enum, constants for Bitcoin regtest network, `is_coin_base` accessor for tx inputs\n+* Expose `merkleroot(Vec<Sha256dHash>)`\n+\n+# 0.13\n+\n+* Move witnesses inside the `TxIn` structure\n+* Add `Transaction::get_weight()`\n+* Update bip143 `sighash_all` API to be more ergonomic\n+\n+# 0.12\n+\n+* The in-memory blockchain was moved into a dedicated project rust-bitcoin-chain.\n+* Removed old script interpreter\n+* A new optional feature \"bitcoinconsensus\" lets this library use Bitcoin Core's native\n+script verifier, wrappend into Rust by the rust-bitcoinconsenus project.\n+See `Transaction::verify` and `Script::verify` methods.\n+* Replaced Base58 traits with `encode_slice`, `check_encode_slice`, from and `from_check` functions in the base58 module.\n+* Un-reversed the Debug output for Sha256dHash\n+* Add bech32 support\n+* Support segwit address types\n+\n+### 0.11\n+\n+* Remove `num` dependency at Matt's request; agree this is obnoxious to require all\n+downstream users to also have a `num` dependency just so they can use `Uint256::from_u64`.\n+"
      },
      {
        "sha": "c50e150f0cbfe6987268f82ca842e385c2a25876",
        "filename": "src/rusty/rust-bitcoin/Cargo.toml",
        "status": "added",
        "additions": 35,
        "deletions": 0,
        "changes": 35,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/Cargo.toml?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,35 @@\n+[package]\n+name = \"bitcoin\"\n+version = \"0.21.0\"\n+authors = [\"Andrew Poelstra <apoelstra@wpsoftware.net>\"]\n+license = \"CC0-1.0\"\n+homepage = \"https://github.com/rust-bitcoin/rust-bitcoin/\"\n+repository = \"https://github.com/rust-bitcoin/rust-bitcoin/\"\n+documentation = \"https://docs.rs/bitcoin/\"\n+description = \"General purpose library for using and interoperating with Bitcoin and other cryptocurrencies.\"\n+keywords = [ \"crypto\", \"bitcoin\" ]\n+readme = \"README.md\"\n+\n+[lib]\n+name = \"bitcoin\"\n+path = \"src/lib.rs\"\n+\n+[features]\n+fuzztarget = [\"secp256k1/fuzztarget\", \"bitcoin_hashes/fuzztarget\"]\n+unstable = []\n+use-serde = [\"hex\", \"serde\", \"bitcoin_hashes/serde\"]\n+\n+[dependencies]\n+bech32 = \"0.7.1\"\n+bitcoin_hashes = \"0.7\"\n+bitcoinconsensus = { version = \"0.17\", optional = true }\n+serde = { version = \"1\", optional = true }\n+hex = { version = \"=0.3.2\", optional = true }\n+secp256k1 = \"0.15\"\n+\n+[dev-dependencies]\n+hex = \"=0.3.2\"\n+serde_derive = \"<1.0.99\"\n+serde_json = \"1\"\n+serde_test = \"1\"\n+secp256k1 = { version = \"0.15\", features = [\"rand\"] }"
      },
      {
        "sha": "6ca207ef004cb69d03041e7e5c288a2be4968045",
        "filename": "src/rusty/rust-bitcoin/LICENSE",
        "status": "added",
        "additions": 122,
        "deletions": 0,
        "changes": 122,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/LICENSE",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/LICENSE",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/LICENSE?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,122 @@\n+Creative Commons Legal Code\n+\n+CC0 1.0 Universal\n+\n+    CREATIVE COMMONS CORPORATION IS NOT A LAW FIRM AND DOES NOT PROVIDE\n+    LEGAL SERVICES. DISTRIBUTION OF THIS DOCUMENT DOES NOT CREATE AN\n+    ATTORNEY-CLIENT RELATIONSHIP. CREATIVE COMMONS PROVIDES THIS\n+    INFORMATION ON AN \"AS-IS\" BASIS. CREATIVE COMMONS MAKES NO WARRANTIES\n+    REGARDING THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS\n+    PROVIDED HEREUNDER, AND DISCLAIMS LIABILITY FOR DAMAGES RESULTING FROM\n+    THE USE OF THIS DOCUMENT OR THE INFORMATION OR WORKS PROVIDED\n+    HEREUNDER.\n+\n+Statement of Purpose\n+\n+The laws of most jurisdictions throughout the world automatically confer\n+exclusive Copyright and Related Rights (defined below) upon the creator\n+and subsequent owner(s) (each and all, an \"owner\") of an original work of\n+authorship and/or a database (each, a \"Work\").\n+\n+Certain owners wish to permanently relinquish those rights to a Work for\n+the purpose of contributing to a commons of creative, cultural and\n+scientific works (\"Commons\") that the public can reliably and without fear\n+of later claims of infringement build upon, modify, incorporate in other\n+works, reuse and redistribute as freely as possible in any form whatsoever\n+and for any purposes, including without limitation commercial purposes.\n+These owners may contribute to the Commons to promote the ideal of a free\n+culture and the further production of creative, cultural and scientific\n+works, or to gain reputation or greater distribution for their Work in\n+part through the use and efforts of others.\n+\n+For these and/or other purposes and motivations, and without any\n+expectation of additional consideration or compensation, the person\n+associating CC0 with a Work (the \"Affirmer\"), to the extent that he or she\n+is an owner of Copyright and Related Rights in the Work, voluntarily\n+elects to apply CC0 to the Work and publicly distribute the Work under its\n+terms, with knowledge of his or her Copyright and Related Rights in the\n+Work and the meaning and intended legal effect of CC0 on those rights.\n+\n+1. Copyright and Related Rights. A Work made available under CC0 may be\n+protected by copyright and related or neighboring rights (\"Copyright and\n+Related Rights\"). Copyright and Related Rights include, but are not\n+limited to, the following:\n+\n+  i. the right to reproduce, adapt, distribute, perform, display,\n+     communicate, and translate a Work;\n+ ii. moral rights retained by the original author(s) and/or performer(s);\n+iii. publicity and privacy rights pertaining to a person's image or\n+     likeness depicted in a Work;\n+ iv. rights protecting against unfair competition in regards to a Work,\n+     subject to the limitations in paragraph 4(a), below;\n+  v. rights protecting the extraction, dissemination, use and reuse of data\n+     in a Work;\n+ vi. database rights (such as those arising under Directive 96/9/EC of the\n+     European Parliament and of the Council of 11 March 1996 on the legal\n+     protection of databases, and under any national implementation\n+     thereof, including any amended or successor version of such\n+     directive); and\n+vii. other similar, equivalent or corresponding rights throughout the\n+     world based on applicable law or treaty, and any national\n+     implementations thereof.\n+\n+2. Waiver. To the greatest extent permitted by, but not in contravention\n+of, applicable law, Affirmer hereby overtly, fully, permanently,\n+irrevocably and unconditionally waives, abandons, and surrenders all of\n+Affirmer's Copyright and Related Rights and associated claims and causes\n+of action, whether now known or unknown (including existing as well as\n+future claims and causes of action), in the Work (i) in all territories\n+worldwide, (ii) for the maximum duration provided by applicable law or\n+treaty (including future time extensions), (iii) in any current or future\n+medium and for any number of copies, and (iv) for any purpose whatsoever,\n+including without limitation commercial, advertising or promotional\n+purposes (the \"Waiver\"). Affirmer makes the Waiver for the benefit of each\n+member of the public at large and to the detriment of Affirmer's heirs and\n+successors, fully intending that such Waiver shall not be subject to\n+revocation, rescission, cancellation, termination, or any other legal or\n+equitable action to disrupt the quiet enjoyment of the Work by the public\n+as contemplated by Affirmer's express Statement of Purpose.\n+\n+3. Public License Fallback. Should any part of the Waiver for any reason\n+be judged legally invalid or ineffective under applicable law, then the\n+Waiver shall be preserved to the maximum extent permitted taking into\n+account Affirmer's express Statement of Purpose. In addition, to the\n+extent the Waiver is so judged Affirmer hereby grants to each affected\n+person a royalty-free, non transferable, non sublicensable, non exclusive,\n+irrevocable and unconditional license to exercise Affirmer's Copyright and\n+Related Rights in the Work (i) in all territories worldwide, (ii) for the\n+maximum duration provided by applicable law or treaty (including future\n+time extensions), (iii) in any current or future medium and for any number\n+of copies, and (iv) for any purpose whatsoever, including without\n+limitation commercial, advertising or promotional purposes (the\n+\"License\"). The License shall be deemed effective as of the date CC0 was\n+applied by Affirmer to the Work. Should any part of the License for any\n+reason be judged legally invalid or ineffective under applicable law, such\n+partial invalidity or ineffectiveness shall not invalidate the remainder\n+of the License, and in such case Affirmer hereby affirms that he or she\n+will not (i) exercise any of his or her remaining Copyright and Related\n+Rights in the Work or (ii) assert any associated claims and causes of\n+action with respect to the Work, in either case contrary to Affirmer's\n+express Statement of Purpose.\n+\n+4. Limitations and Disclaimers.\n+\n+ a. No trademark or patent rights held by Affirmer are waived, abandoned,\n+    surrendered, licensed or otherwise affected by this document.\n+ b. Affirmer offers the Work as-is and makes no representations or\n+    warranties of any kind concerning the Work, express, implied,\n+    statutory or otherwise, including without limitation warranties of\n+    title, merchantability, fitness for a particular purpose, non\n+    infringement, or the absence of latent or other defects, accuracy, or\n+    the present or absence of errors, whether or not discoverable, all to\n+    the greatest extent permissible under applicable law.\n+ c. Affirmer disclaims responsibility for clearing rights of other persons\n+    that may apply to the Work or any use thereof, including without\n+    limitation any person's Copyright and Related Rights in the Work.\n+    Further, Affirmer disclaims responsibility for obtaining any necessary\n+    consents, permissions or other rights required for any use of the\n+    Work.\n+ d. Affirmer understands and acknowledges that Creative Commons is not a\n+    party to this document and has no duty or obligation with respect to\n+    this CC0 or use of the Work.\n+"
      },
      {
        "sha": "dbc48940ad393d134cfd9c585d9faf41daa23193",
        "filename": "src/rusty/rust-bitcoin/README.md",
        "status": "added",
        "additions": 107,
        "deletions": 0,
        "changes": 107,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/README.md",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/README.md",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/README.md?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,107 @@\n+[![Status](https://travis-ci.org/rust-bitcoin/rust-bitcoin.png?branch=master)](https://travis-ci.org/rust-bitcoin/rust-bitcoin)\n+[![Safety Dance](https://img.shields.io/badge/unsafe-forbidden-success.svg)](https://github.com/rust-secure-code/safety-dance/)\n+\n+# Rust Bitcoin Library\n+\n+Library with support for de/serialization, parsing and executing on data\n+structures and network messages related to Bitcoin.\n+\n+[Documentation](https://docs.rs/bitcoin/)\n+\n+Supports (or should support)\n+\n+* De/serialization of Bitcoin protocol network messages\n+* De/serialization of blocks and transactions\n+* Script de/serialization\n+* Private keys and address creation, de/serialization and validation (including full BIP32 support)\n+* PSBT creation, manipulation, merging and finalization\n+* Pay-to-contract support as in Appendix A of the [Blockstream sidechains whitepaper](https://www.blockstream.com/sidechains.pdf)\n+\n+For JSONRPC interaction with Bitcoin Core, it is recommended to use\n+[rust-bitcoincore-rpc](https://github.com/rust-bitcoin/rust-bitcoincore-rpc).\n+\n+# Known limitations\n+\n+## Consensus\n+\n+This library **must not** be used for consensus code (i.e. fully validating\n+blockchain data). It technically supports doing this, but doing so is very\n+ill-advised because there are many deviations, known and unknown, between\n+this library and the Bitcoin Core reference implementation. In a consensus\n+based cryptocurrency such as Bitcoin it is critical that all parties are\n+using the same rules to validate data, and this library is simply unable\n+to implement the same rules as Core.\n+\n+Given the complexity of both C++ and Rust, it is unlikely that this will\n+ever be fixed, and there are no plans to do so. Of course, patches to\n+fix specific consensus incompatibilities are welcome.\n+\n+## Documentation\n+\n+Currently can be found on [docs.rs/bitcoin](https://docs.rs/bitcoin/).\n+Patches to add usage examples and to expand on existing docs would be extremely\n+appreciated.\n+\n+# Contributing\n+Contributions are generally welcome. If you intend to make larger changes please\n+discuss them in an issue before PRing them to avoid duplicate work and\n+architectural mismatches. If you have any questions or ideas you want to discuss\n+please join us in\n+[#rust-bitcoin](http://webchat.freenode.net/?channels=%23rust-bitcoin) on\n+freenode.\n+\n+## Installing Rust\n+Rust can be installed using your package manager of choice or\n+[rustup.rs](https://rustup.rs). The former way is considered more secure since\n+it typically doesn't involve trust in the CA system. But you should be aware\n+that the version of Rust shipped by your distribution might be out of date.\n+Generally this isn't a problem for `rust-bitcoin` since we support much older\n+versions (>=1.22) than the current stable one.\n+\n+## Building\n+The library can be built and tested using [`cargo`](https://github.com/rust-lang/cargo/):\n+\n+```\n+git clone git@github.com:rust-bitcoin/rust-bitcoin.git\n+cd rust-bitcoin\n+cargo build\n+```\n+\n+You can run tests with:\n+\n+```\n+cargo test\n+```\n+\n+Please refer to the [`cargo` documentation](https://doc.rust-lang.org/stable/cargo/) for more detailed instructions. \n+\n+## Pull Requests\n+Every PR needs at least two reviews to get merged. During the review phase\n+maintainers and contributors are likely to leave comments and request changes.\n+Please try to address them, otherwise your PR might get closed without merging\n+after a longer time of inactivity. If your PR isn't ready for review yet please\n+mark it by prefixing the title with `WIP: `.\n+\n+## Policy on Altcoins/Altchains\n+\n+Patches which add support for non-Bitcoin cryptocurrencies by adding constants\n+to existing enums (e.g. to set the network message magic-byte sequence) are\n+welcome. Anything more involved will be considered on a case-by-case basis,\n+as the altcoin landscape includes projects which [frequently appear and\n+disappear, and are poorly designed anyway](https://download.wpsoftware.net/bitcoin/alts.pdf)\n+and keeping the codebase maintainable is a large priority.\n+\n+In general, things that improve cross-chain compatibility (e.g. support for\n+cross-chain atomic swaps) are more likely to be accepted than things which\n+support only a single blockchain.\n+\n+\n+# Release Notes\n+\n+See CHANGELOG.md\n+\n+\n+# Licensing\n+\n+The code in this project is licensed under the Creative Commons CC0 1.0\n+Universal license."
      },
      {
        "sha": "7c5ed1e75998a43bafc005c90ef0a8c3a7ba7eca",
        "filename": "src/rusty/rust-bitcoin/contrib/test.sh",
        "status": "added",
        "additions": 49,
        "deletions": 0,
        "changes": 49,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/contrib/test.sh",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/contrib/test.sh",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/contrib/test.sh?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,49 @@\n+#!/bin/sh -ex\n+\n+FEATURES=\"bitcoinconsensus use-serde\"\n+\n+if [ \"$DO_COV\" = true ]\n+then\n+    export RUSTFLAGS=\"-C link-dead-code\"\n+fi\n+\n+\n+# Use toolchain if explicitly specified\n+if [ -n \"$TOOLCHAIN\" ]\n+then\n+    alias cargo=\"cargo +$TOOLCHAIN\"\n+fi\n+\n+# Test without any features first\n+cargo test --verbose\n+\n+# Test each feature\n+for feature in ${FEATURES}\n+do\n+    cargo test --verbose --features=\"$feature\"\n+done\n+\n+# Fuzz if told to\n+if [ \"$DO_FUZZ\" = true ]\n+then\n+    (\n+        cd fuzz\n+        cargo test --verbose\n+        ./travis-fuzz.sh\n+    )\n+fi\n+\n+# Bench if told to\n+if [ \"$DO_BENCH\" = true ]\n+then\n+    cargo bench --features unstable\n+fi\n+\n+# Use as dependency if told to\n+if [ -n \"$AS_DEPENDENCY\" ]\n+then\n+    cargo new dep_test\n+    cd dep_test\n+    echo 'bitcoin = { path = \"..\", features = [\"use-serde\"] }' >> Cargo.toml\n+    cargo test --verbose\n+fi"
      },
      {
        "sha": "572e03bdf321b6cc3a99488183436905cefd086d",
        "filename": "src/rusty/rust-bitcoin/fuzz/.gitignore",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/.gitignore",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/.gitignore",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/.gitignore?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,4 @@\n+\n+target\n+corpus\n+artifacts"
      },
      {
        "sha": "4b3941daad50bc9136f9dedbc92f62feb92fce36",
        "filename": "src/rusty/rust-bitcoin/fuzz/Cargo.toml",
        "status": "added",
        "additions": 53,
        "deletions": 0,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/Cargo.toml",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/Cargo.toml",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/Cargo.toml?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,53 @@\n+[package]\n+name = \"bitcoin-fuzz\"\n+version = \"0.0.1\"\n+authors = [\"Automatically generated\"]\n+publish = false\n+\n+[package.metadata]\n+cargo-fuzz = true\n+\n+[features]\n+afl_fuzz = [\"afl\"]\n+honggfuzz_fuzz = [\"honggfuzz\"]\n+\n+[dependencies]\n+honggfuzz = { version = \"0.5\", optional = true }\n+afl = { version = \"0.4\", optional = true }\n+bitcoin = { path = \"..\", features = [\"fuzztarget\"] }\n+\n+# Prevent this from interfering with workspaces\n+[workspace]\n+members = [\".\"]\n+\n+[[bin]]\n+name = \"deserialize_block\"\n+path = \"fuzz_targets/deserialize_block.rs\"\n+\n+[[bin]]\n+name = \"deserialize_script\"\n+path = \"fuzz_targets/deserialize_script.rs\"\n+\n+[[bin]]\n+name = \"deserialize_transaction\"\n+path = \"fuzz_targets/deserialize_transaction.rs\"\n+\n+[[bin]]\n+name = \"deserialize_address\"\n+path = \"fuzz_targets/deserialize_address.rs\"\n+\n+[[bin]]\n+name = \"deserialize_amount\"\n+path = \"fuzz_targets/deserialize_amount.rs\"\n+\n+[[bin]]\n+name = \"outpoint_string\"\n+path = \"fuzz_targets/outpoint_string.rs\"\n+\n+[[bin]]\n+name = \"deserialize_psbt\"\n+path = \"fuzz_targets/deserialize_psbt.rs\"\n+\n+[[bin]]\n+name = \"deser_net_msg\"\n+path = \"fuzz_targets/deser_net_msg.rs\""
      },
      {
        "sha": "e2c1a0a7655dbfb0caa6ed7a7a84ba99043c4cea",
        "filename": "src/rusty/rust-bitcoin/fuzz/fuzz_targets/deser_net_msg.rs",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deser_net_msg.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deser_net_msg.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deser_net_msg.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,52 @@\n+extern crate bitcoin;\n+\n+fn do_test(data: &[u8]) {\n+    let _: Result<bitcoin::network::message::RawNetworkMessage, _> = bitcoin::consensus::encode::deserialize(data);\n+}\n+\n+#[cfg(feature = \"afl\")]\n+#[macro_use] extern crate afl;\n+#[cfg(feature = \"afl\")]\n+fn main() {\n+    fuzz!(|data| {\n+        do_test(&data);\n+    });\n+}\n+\n+#[cfg(feature = \"honggfuzz\")]\n+#[macro_use] extern crate honggfuzz;\n+#[cfg(feature = \"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|data| {\n+            do_test(data);\n+        });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"00\", &mut a);\n+        super::do_test(&a);\n+    }\n+}"
      },
      {
        "sha": "4a26a20c0abbc6743ebf9ded7f9ba4b572d05a5b",
        "filename": "src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_address.rs",
        "status": "added",
        "additions": 57,
        "deletions": 0,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_address.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_address.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_address.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,57 @@\n+extern crate bitcoin;\n+use std::str::FromStr;\n+fn do_test(data: &[u8]) {\n+    let data_str = String::from_utf8_lossy(data);\n+    let addr = match bitcoin::util::address::Address::from_str(&data_str) {\n+        Ok(addr) => addr,\n+        Err(_) => return,\n+    };\n+    assert_eq!(addr.to_string(), data_str);\n+}\n+\n+#[cfg(feature = \"afl\")]\n+#[macro_use] extern crate afl;\n+#[cfg(feature = \"afl\")]\n+fn main() {\n+    fuzz!(|data| {\n+        do_test(&data);\n+    });\n+}\n+\n+#[cfg(feature = \"honggfuzz\")]\n+#[macro_use] extern crate honggfuzz;\n+#[cfg(feature = \"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|data| {\n+            do_test(data);\n+        });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"00000000\", &mut a);\n+        super::do_test(&a);\n+    }\n+}"
      },
      {
        "sha": "6c396da4e906b2b639012e7f9a6ac8e1936750d9",
        "filename": "src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_amount.rs",
        "status": "added",
        "additions": 74,
        "deletions": 0,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_amount.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_amount.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_amount.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,74 @@\n+extern crate bitcoin;\n+use std::str::FromStr;\n+fn do_test(data: &[u8]) {\n+    let data_str = String::from_utf8_lossy(data);\n+\n+    // signed\n+    let samt = match bitcoin::util::amount::SignedAmount::from_str(&data_str) {\n+        Ok(amt) => amt,\n+        Err(_) => return,\n+    };\n+    let samt_roundtrip = match bitcoin::util::amount::SignedAmount::from_str(&samt.to_string()) {\n+        Ok(amt) => amt,\n+        Err(_) => return,\n+    };\n+    assert_eq!(samt, samt_roundtrip);\n+\n+    // unsigned\n+    let amt = match bitcoin::util::amount::Amount::from_str(&data_str) {\n+        Ok(amt) => amt,\n+        Err(_) => return,\n+    };\n+    let amt_roundtrip = match bitcoin::util::amount::Amount::from_str(&amt.to_string()) {\n+        Ok(amt) => amt,\n+        Err(_) => return,\n+    };\n+    assert_eq!(amt, amt_roundtrip);\n+}\n+\n+#[cfg(feature = \"afl\")]\n+#[macro_use] extern crate afl;\n+#[cfg(feature = \"afl\")]\n+fn main() {\n+    fuzz!(|data| {\n+        do_test(&data);\n+    });\n+}\n+\n+#[cfg(feature = \"honggfuzz\")]\n+#[macro_use] extern crate honggfuzz;\n+#[cfg(feature = \"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|data| {\n+            do_test(data);\n+        });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"00000000\", &mut a);\n+        super::do_test(&a);\n+    }\n+}"
      },
      {
        "sha": "3e2b7a1b12a67331c05e721e2374f6eedd90c905",
        "filename": "src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_block.rs",
        "status": "added",
        "additions": 52,
        "deletions": 0,
        "changes": 52,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_block.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_block.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_block.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,52 @@\n+extern crate bitcoin;\n+\n+fn do_test(data: &[u8]) {\n+    let _: Result<bitcoin::blockdata::block::Block, _>= bitcoin::consensus::encode::deserialize(data);\n+}\n+\n+#[cfg(feature = \"afl\")]\n+#[macro_use] extern crate afl;\n+#[cfg(feature = \"afl\")]\n+fn main() {\n+    fuzz!(|data| {\n+        do_test(&data);\n+    });\n+}\n+\n+#[cfg(feature = \"honggfuzz\")]\n+#[macro_use] extern crate honggfuzz;\n+#[cfg(feature = \"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|data| {\n+            do_test(data);\n+        });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"00\", &mut a);\n+        super::do_test(&a);\n+    }\n+}"
      },
      {
        "sha": "d19563b17cf226fcce5aa3b3a1d8461477f0b4ae",
        "filename": "src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_psbt.rs",
        "status": "added",
        "additions": 61,
        "deletions": 0,
        "changes": 61,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_psbt.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_psbt.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_psbt.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,61 @@\n+extern crate bitcoin;\n+\n+fn do_test(data: &[u8]) {\n+    let psbt: Result<bitcoin::util::psbt::PartiallySignedTransaction, _> = bitcoin::consensus::encode::deserialize(data);\n+    match psbt {\n+        Err(_) => {},\n+        Ok(psbt) => {\n+            let ser = bitcoin::consensus::encode::serialize(&psbt);\n+            let deser: bitcoin::util::psbt::PartiallySignedTransaction  = bitcoin::consensus::encode::deserialize(&ser).unwrap();\n+            // Since the fuzz data could order psbt fields differently, we compare to our deser/ser instead of data\n+            assert_eq!(ser, bitcoin::consensus::encode::serialize(&deser));\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"afl\")]\n+#[macro_use] extern crate afl;\n+#[cfg(feature = \"afl\")]\n+fn main() {\n+    fuzz!(|data| {\n+        do_test(&data);\n+    });\n+}\n+\n+#[cfg(feature = \"honggfuzz\")]\n+#[macro_use] extern crate honggfuzz;\n+#[cfg(feature = \"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|data| {\n+            do_test(data);\n+        });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"00\", &mut a);\n+        super::do_test(&a);\n+    }\n+}"
      },
      {
        "sha": "e7c36de05cff88b3ab34759287e65d5c676dfed2",
        "filename": "src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_script.rs",
        "status": "added",
        "additions": 90,
        "deletions": 0,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_script.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_script.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_script.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,90 @@\n+extern crate bitcoin;\n+\n+use bitcoin::util::address::Address;\n+use bitcoin::network::constants::Network;\n+use bitcoin::blockdata::script;\n+use bitcoin::consensus::encode;\n+\n+fn do_test(data: &[u8]) {\n+    let s: Result<script::Script, _> = encode::deserialize(data);\n+    if let Ok(script) = s {\n+        let _: Vec<script::Instruction> = script.iter(false).collect();\n+        let enforce_min: Vec<script::Instruction> = script.iter(true).collect();\n+\n+        let mut b = script::Builder::new();\n+        for ins in enforce_min {\n+            match ins {\n+                script::Instruction::Error(_) => return,\n+                script::Instruction::Op(op) => { b = b.push_opcode(op); }\n+                script::Instruction::PushBytes(bytes) => {\n+                    // Any one-byte pushes, except -0, which can be interpreted as numbers, should be\n+                    // reserialized as numbers. (For -1 through 16, this will use special ops; for\n+                    // others it'll just reserialize them as pushes.)\n+                    if bytes.len() == 1 && bytes[0] != 0x80 && bytes[0] != 0x00 {\n+                        if let Ok(num) = script::read_scriptint(bytes) {\n+                            b = b.push_int(num);\n+                        } else {\n+                            b = b.push_slice(bytes);\n+                        }\n+                    } else {\n+                        b = b.push_slice(bytes);\n+                    }\n+                }\n+            }\n+        }\n+        assert_eq!(b.into_script(), script);\n+        assert_eq!(data, &encode::serialize(&script)[..]);\n+\n+        // Check if valid address and if that address roundtrips.\n+        if let Some(addr) = Address::from_script(&script, Network::Bitcoin) {\n+            assert_eq!(addr.script_pubkey(), script);\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"afl\")]\n+#[macro_use] extern crate afl;\n+#[cfg(feature = \"afl\")]\n+fn main() {\n+    fuzz!(|data| {\n+        do_test(&data);\n+    });\n+}\n+\n+#[cfg(feature = \"honggfuzz\")]\n+#[macro_use] extern crate honggfuzz;\n+#[cfg(feature = \"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|data| {\n+            do_test(data);\n+        });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"00\", &mut a);\n+        super::do_test(&a);\n+    }\n+}"
      },
      {
        "sha": "b0cd7ab5ff2a5fbe3ea1fd6ab052ae1f5456dc00",
        "filename": "src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_transaction.rs",
        "status": "added",
        "additions": 73,
        "deletions": 0,
        "changes": 73,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_transaction.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_transaction.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/fuzz_targets/deserialize_transaction.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,73 @@\n+extern crate bitcoin;\n+\n+fn do_test(data: &[u8]) {\n+    let tx_result: Result<bitcoin::blockdata::transaction::Transaction, _> = bitcoin::consensus::encode::deserialize(data);\n+    match tx_result {\n+        Err(_) => {},\n+        Ok(mut tx) => {\n+            let ser = bitcoin::consensus::encode::serialize(&tx);\n+            assert_eq!(&ser[..], data);\n+            let len = ser.len();\n+            let calculated_weight = tx.get_weight();\n+            for input in &mut tx.input {\n+                input.witness = vec![];\n+            }\n+            let no_witness_len = bitcoin::consensus::encode::serialize(&tx).len();\n+            // For 0-input transactions, `no_witness_len` will be incorrect because\n+            // we serialize as segwit even after \"stripping the witnesses\". We need\n+            // to drop two bytes (i.e. eight weight)\n+            if tx.input.is_empty() {\n+                assert_eq!(no_witness_len * 3 + len - 8, calculated_weight);\n+            } else {\n+                assert_eq!(no_witness_len * 3 + len, calculated_weight);\n+            }\n+        },\n+    }\n+}\n+\n+#[cfg(feature = \"afl\")]\n+#[macro_use] extern crate afl;\n+#[cfg(feature = \"afl\")]\n+fn main() {\n+    fuzz!(|data| {\n+        do_test(&data);\n+    });\n+}\n+\n+#[cfg(feature = \"honggfuzz\")]\n+#[macro_use] extern crate honggfuzz;\n+#[cfg(feature = \"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|data| {\n+            do_test(data);\n+        });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"000700000001000000010000\", &mut a);\n+        super::do_test(&a);\n+    }\n+}"
      },
      {
        "sha": "ed2d3fee88e93cba264df3059c49053d1df80579",
        "filename": "src/rusty/rust-bitcoin/fuzz/fuzz_targets/outpoint_string.rs",
        "status": "added",
        "additions": 88,
        "deletions": 0,
        "changes": 88,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/outpoint_string.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/fuzz_targets/outpoint_string.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/fuzz_targets/outpoint_string.rs?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,88 @@\n+\n+extern crate bitcoin;\n+\n+use bitcoin::blockdata::transaction::OutPoint;\n+use bitcoin::consensus::encode;\n+\n+use std::str::FromStr;\n+\n+fn do_test(data: &[u8]) {\n+    let lowercase: Vec<u8> = data.iter().map(|c| match *c {\n+        b'A' => b'a',\n+        b'B' => b'b',\n+        b'C' => b'c',\n+        b'D' => b'd',\n+        b'E' => b'e',\n+        b'F' => b'f',\n+        x => x\n+    }).collect();\n+    let data_str = match String::from_utf8(lowercase) {\n+        Err(_) => return,\n+        Ok(s) => s,\n+    };\n+    match OutPoint::from_str(&data_str) {\n+        Ok(op) => {\n+            assert_eq!(op.to_string().as_bytes(), data_str.as_bytes());\n+        }\n+        Err(_) => {\n+            // If we can't deserialize as a string, try consensus deserializing\n+            let res: Result<OutPoint, _> = encode::deserialize(data);\n+            if let Ok(deser) = res {\n+                let ser = encode::serialize(&deser);\n+                assert_eq!(ser, data);\n+                let string = deser.to_string();\n+                match OutPoint::from_str(&string) {\n+                    Ok(destring) => assert_eq!(destring, deser),\n+                    Err(_) => panic!()\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+#[cfg(feature = \"afl\")]\n+#[macro_use] extern crate afl;\n+#[cfg(feature = \"afl\")]\n+fn main() {\n+    fuzz!(|data| {\n+        do_test(&data);\n+    });\n+}\n+\n+#[cfg(feature = \"honggfuzz\")]\n+#[macro_use] extern crate honggfuzz;\n+#[cfg(feature = \"honggfuzz\")]\n+fn main() {\n+    loop {\n+        fuzz!(|data| {\n+            do_test(data);\n+        });\n+    }\n+}\n+\n+#[cfg(test)]\n+mod tests {\n+    fn extend_vec_from_hex(hex: &str, out: &mut Vec<u8>) {\n+        let mut b = 0;\n+        for (idx, c) in hex.as_bytes().iter().enumerate() {\n+            b <<= 4;\n+            match *c {\n+                b'A'...b'F' => b |= c - b'A' + 10,\n+                b'a'...b'f' => b |= c - b'a' + 10,\n+                b'0'...b'9' => b |= c - b'0',\n+                _ => panic!(\"Bad hex\"),\n+            }\n+            if (idx & 1) == 1 {\n+                out.push(b);\n+                b = 0;\n+            }\n+        }\n+    }\n+\n+    #[test]\n+    fn duplicate_crash() {\n+        let mut a = Vec::new();\n+        extend_vec_from_hex(\"00\", &mut a);\n+        super::do_test(&a);\n+    }\n+}"
      },
      {
        "sha": "47522b2242e194cd6eb4b17b0444621078dc574f",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/18b6e222b04bbd45df9508b64b8e47d5.00000014.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/18b6e222b04bbd45df9508b64b8e47d5.00000014.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/18b6e222b04bbd45df9508b64b8e47d5.00000014.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/18b6e222b04bbd45df9508b64b8e47d5.00000014.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+tb1218755mmmmmmlmmm9\n\\ No newline at end of file"
      },
      {
        "sha": "e737eff2df251318c1d605d2076d4bf5a2c6a732",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/2418838742eb837088ce87020b701357.0000000e.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/2418838742eb837088ce87020b701357.0000000e.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/2418838742eb837088ce87020b701357.0000000e.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/2418838742eb837088ce87020b701357.0000000e.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+tb1q1q\ufffdtb1f\ufffdqo\n\\ No newline at end of file"
      },
      {
        "sha": "e9f83e117e4f1b2ec501c48812f58dd2da0541d5",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/4c268893957d293ecb031b7a493d5517.0000000b.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/4c268893957d293ecb031b7a493d5517.0000000b.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/4c268893957d293ecb031b7a493d5517.0000000b.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/4c268893957d293ecb031b7a493d5517.0000000b.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+tb1270kt564\n\\ No newline at end of file"
      },
      {
        "sha": "ac46421140b7b021637b3b7aa34f718d054dc360",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/642cd2ab1075cc9dcbf11d4517132cff.0000000d.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/642cd2ab1075cc9dcbf11d4517132cff.0000000d.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/642cd2ab1075cc9dcbf11d4517132cff.0000000d.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/642cd2ab1075cc9dcbf11d4517132cff.0000000d.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1A[01z--546\n\\ No newline at end of file"
      },
      {
        "sha": "313377fe1bb5a0accba50f21a88eec6660907f3a",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/733c9c9c9cb000002c9c9c9cc3100000.00000005.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/733c9c9c9cb000002c9c9c9cc3100000.00000005.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/733c9c9c9cb000002c9c9c9cc3100000.00000005.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/733c9c9c9cb000002c9c9c9cc3100000.00000005.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+1111W\n\\ No newline at end of file"
      },
      {
        "sha": "1fde608ae185f73777b51827e2f1250b911522b4",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/804ca76c67dac27d3fa9842a5fbf0acb.00000012.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/804ca76c67dac27d3fa9842a5fbf0acb.00000012.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/804ca76c67dac27d3fa9842a5fbf0acb.00000012.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/804ca76c67dac27d3fa9842a5fbf0acb.00000012.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1-81003971758255\n\\ No newline at end of file"
      },
      {
        "sha": "b11bf94e40d5535d2a63ea94eb84261ad0767aeb",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/a4611c9c91300000211c9c9194400000.00000005.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/a4611c9c91300000211c9c9194400000.00000005.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/a4611c9c91300000211c9c9194400000.00000005.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/a4611c9c91300000211c9c9194400000.00000005.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+9119\ufffd\n\\ No newline at end of file"
      },
      {
        "sha": "023c84a6fcc1fee9d3055dc49e26e7f8991a7871",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/c7b1f1e233cb62b7663a33abe7722ab8.0000000e.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/c7b1f1e233cb62b7663a33abe7722ab8.0000000e.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/c7b1f1e233cb62b7663a33abe7722ab8.0000000e.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/c7b1f1e233cb62b7663a33abe7722ab8.0000000e.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+bc1{)2\u008031cc\ufffd\ufffd\n\\ No newline at end of file"
      },
      {
        "sha": "f537ffc7f6912762f590e936c098df436d304ebc",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/dddf9577343cbfd614aa48444fdc440d.0000000b.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/dddf9577343cbfd614aa48444fdc440d.0000000b.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/dddf9577343cbfd614aa48444fdc440d.0000000b.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/dddf9577343cbfd614aa48444fdc440d.0000000b.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1\u07c5\ufffd?\ufffd~\ufffd:\n\\ No newline at end of file"
      },
      {
        "sha": "71d1602ccaa4eaaf2e6933110caacc42669da956",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/ebdf1f0999769e0dd97c488f9e1629c3.0000000b.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/ebdf1f0999769e0dd97c488f9e1629c3.0000000b.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/ebdf1f0999769e0dd97c488f9e1629c3.0000000b.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/ebdf1f0999769e0dd97c488f9e1629c3.0000000b.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1A2Q\ud801\udc00:\n\\ No newline at end of file"
      },
      {
        "sha": "1eef598f73f1f439ae8511d3f7b331b290d002e9",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/fea481ecdefcdebf030efcdefcc12454.00000008.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/fea481ecdefcdebf030efcdefcc12454.00000008.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/fea481ecdefcdebf030efcdefcc12454.00000008.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/fea481ecdefcdebf030efcdefcc12454.00000008.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1C1T\ufffd\ufffd\n\\ No newline at end of file"
      },
      {
        "sha": "38eef5ea183e267a459bda4ede397ccc50b9f4a4",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000000,orig:15cad1ae8551b96348bc3115fa7ebe63.0000000e.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000000,orig:15cad1ae8551b96348bc3115fa7ebe63.0000000e.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000000,orig:15cad1ae8551b96348bc3115fa7ebe63.0000000e.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000000,orig:15cad1ae8551b96348bc3115fa7ebe63.0000000e.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC10VWWW0VWWWy\n\\ No newline at end of file"
      },
      {
        "sha": "2eb06a8464a68bb8d60bc7b12abbcae7affb620e",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000001,orig:215f74c65c586d0f6697654f73f1590f.0000001d.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000001,orig:215f74c65c586d0f6697654f73f1590f.0000001d.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000001,orig:215f74c65c586d0f6697654f73f1590f.0000001d.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000001,orig:215f74c65c586d0f6697654f73f1590f.0000001d.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1MMMMMMMMMMMMMMMMMMMMMMMMM6\n\\ No newline at end of file"
      },
      {
        "sha": "0b9b9f7de6b0e5ed6e47e863e2f1b57ffcc75d8c",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000002,orig:2cc7e6ae50991ecc4678fc57c3fec235.00000025.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000002,orig:2cc7e6ae50991ecc4678fc57c3fec235.00000025.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000002,orig:2cc7e6ae50991ecc4678fc57c3fec235.00000025.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000002,orig:2cc7e6ae50991ecc4678fc57c3fec235.00000025.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "1e3b8048d90ccd0936b1ad392d854213b61e3937",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000003,orig:2ce88960000000005938fcb000000000.00000003.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000003,orig:2ce88960000000005938fcb000000000.00000003.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000003,orig:2ce88960000000005938fcb000000000.00000003.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000003,orig:2ce88960000000005938fcb000000000.00000003.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+bc1\n\\ No newline at end of file"
      },
      {
        "sha": "50f90afa1b32f105c68244b5d925f2b5cf739daa",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000006,orig:70b17afe56c3a7b354b7c3b6c80a2bb9.0000002b.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000006,orig:70b17afe56c3a7b354b7c3b6c80a2bb9.0000002b.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000006,orig:70b17afe56c3a7b354b7c3b6c80a2bb9.0000002b.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000006,orig:70b17afe56c3a7b354b7c3b6c80a2bb9.0000002b.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+tb1118755mmmmmmmmmm9264mmmmmmm932772648\n\\ No newline at end of file"
      },
      {
        "sha": "e3f2b85d6372f226a32f9d8e1add6739d894c426",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000007,orig:728beb87e91000002957ebebb2a00000.00000005.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000007,orig:728beb87e91000002957ebebb2a00000.00000005.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000007,orig:728beb87e91000002957ebebb2a00000.00000005.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000007,orig:728beb87e91000002957ebebb2a00000.00000005.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+7t44V\n\\ No newline at end of file"
      },
      {
        "sha": "d1d06ad36a5841e8c06a90bd29707290d979cc2b",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000008,orig:2c9c9c9cb00000002c9c9c9cb0000000.00000004.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000008,orig:2c9c9c9cb00000002c9c9c9cb0000000.00000004.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000008,orig:2c9c9c9cb00000002c9c9c9cb0000000.00000004.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000008,orig:2c9c9c9cb00000002c9c9c9cb0000000.00000004.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+1111\n\\ No newline at end of file"
      },
      {
        "sha": "7570bc6c8158de029237eeef67080468f55b3b6e",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000011,orig:9c3c1fb7a5a5a5a5a60c3c7aa5a5a5a5.0000000b.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000011,orig:9c3c1fb7a5a5a5a5a60c3c7aa5a5a5a5.0000000b.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000011,orig:9c3c1fb7a5a5a5a5a60c3c7aa5a5a5a5.0000000b.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000011,orig:9c3c1fb7a5a5a5a5a60c3c7aa5a5a5a5.0000000b.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+zSSSSSSSSSS\n\\ No newline at end of file"
      },
      {
        "sha": "51b44f0726062f9e07591307edac33573a3a6333",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000013,orig:c5a6dff88d6d9cded749fcdd9d288fec.00000009.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000013,orig:c5a6dff88d6d9cded749fcdd9d288fec.00000009.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000013,orig:c5a6dff88d6d9cded749fcdd9d288fec.00000009.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000013,orig:c5a6dff88d6d9cded749fcdd9d288fec.00000009.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1A063-+\n\\ No newline at end of file"
      },
      {
        "sha": "db8baf7e36074604ff1ceb4191414003d6ed48ae",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000014,orig:c609787c4d59cd6ad2d9fe413e542b60.000018a8.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000014,orig:c609787c4d59cd6ad2d9fe413e542b60.000018a8.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000014,orig:c609787c4d59cd6ad2d9fe413e542b60.000018a8.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000014,orig:c609787c4d59cd6ad2d9fe413e542b60.000018a8.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "453c0868307e37abc762b3db27787f9833be2500",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000016,orig:cedfa000000000005f6e800000000000.00000002.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000016,orig:cedfa000000000005f6e800000000000.00000002.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000016,orig:cedfa000000000005f6e800000000000.00000002.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000016,orig:cedfa000000000005f6e800000000000.00000002.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+f\ufffd\n\\ No newline at end of file"
      },
      {
        "sha": "23e49af41fcd2e1c14e9c3288b9c0c9e4ef1532b",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000017,orig:cfe7500000000000d79f300000000000.00000002.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000017,orig:cfe7500000000000d79f300000000000.00000002.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000017,orig:cfe7500000000000d79f300000000000.00000002.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000017,orig:cfe7500000000000d79f300000000000.00000002.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+\ufffd\ufffd\n\\ No newline at end of file"
      },
      {
        "sha": "b4039d289906f6eb292b14cdc2407867fd2b7c6e",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000018,orig:e9b51c311bb9ce0d748f29409e19cbbb.0000000b.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000018,orig:e9b51c311bb9ce0d748f29409e19cbbb.0000000b.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000018,orig:e9b51c311bb9ce0d748f29409e19cbbb.0000000b.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000018,orig:e9b51c311bb9ce0d748f29409e19cbbb.0000000b.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1A2Z4Y8J9\n\\ No newline at end of file"
      },
      {
        "sha": "24de910c13bb1e60fc5ec37a1058d356b1f2fa4d",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000019,orig:7b300000000000007b30000000000000.00000001.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000019,orig:7b300000000000007b30000000000000.00000001.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000019,orig:7b300000000000007b30000000000000.00000001.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000019,orig:7b300000000000007b30000000000000.00000001.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+Y\n\\ No newline at end of file"
      },
      {
        "sha": "6ea20ec862773300af6ae9df727a8d7c99f1c242",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000019,orig:eaaab62c6d65ea2889ce9e10f05d9924.0000000f.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000019,orig:eaaab62c6d65ea2889ce9e10f05d9924.0000000f.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000019,orig:eaaab62c6d65ea2889ce9e10f05d9924.0000000f.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000019,orig:eaaab62c6d65ea2889ce9e10f05d9924.0000000f.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+tb1p25316484708\n\\ No newline at end of file"
      },
      {
        "sha": "d4b1cd947951930c987d65f4e25ca94b1d916fe9",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000021,orig:efa9a6552efcc1b41f947711ecde356c.0000000a.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000021,orig:efa9a6552efcc1b41f947711ecde356c.0000000a.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000021,orig:efa9a6552efcc1b41f947711ecde356c.0000000a.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000021,orig:efa9a6552efcc1b41f947711ecde356c.0000000a.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BCRT1C\ufffd1\ufffd\ufffd\n\\ No newline at end of file"
      },
      {
        "sha": "178f2cd6ca1b2a7b98ef111f3b48aff825a2bd1b",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000022,orig:cb1917e940dd2cde31ebfc9d50d957a3.00000009.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000022,orig:cb1917e940dd2cde31ebfc9d50d957a3.00000009.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000022,orig:cb1917e940dd2cde31ebfc9d50d957a3.00000009.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000022,orig:cb1917e940dd2cde31ebfc9d50d957a3.00000009.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC10m7tK!\n\\ No newline at end of file"
      },
      {
        "sha": "9fe6dde42800d82032738bcd42214d04a8583301",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000025,orig:46367000000000004636700000000000.00000002.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000025,orig:46367000000000004636700000000000.00000002.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000025,orig:46367000000000004636700000000000.00000002.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000025,orig:46367000000000004636700000000000.00000002.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+uu\n\\ No newline at end of file"
      },
      {
        "sha": "3b87260bbdb467126d192b6b6e81fc9fe5b89b3c",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000026,orig:2b5a40ad2cdebf606f0efc9d201a4bc0.00000007.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000026,orig:2b5a40ad2cdebf606f0efc9d201a4bc0.00000007.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000026,orig:2b5a40ad2cdebf606f0efc9d201a4bc0.00000007.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000026,orig:2b5a40ad2cdebf606f0efc9d201a4bc0.00000007.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC108\ufffd4\n\\ No newline at end of file"
      },
      {
        "sha": "2898eb86b00b5b55c2432d472e4d0215cefe66a6",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000028,orig:2cdf11c00000000071af4cb000000000.00000003.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000028,orig:2cdf11c00000000071af4cb000000000.00000003.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000028,orig:2cdf11c00000000071af4cb000000000.00000003.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000028,orig:2cdf11c00000000071af4cb000000000.00000003.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+TB1\n\\ No newline at end of file"
      },
      {
        "sha": "5447026c791d8baca286e34416ce9ac720e3b13f",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000028,orig:e3a0a0acdebf60006f0efc90a0638000.00000006.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000028,orig:e3a0a0acdebf60006f0efc90a0638000.00000006.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000028,orig:e3a0a0acdebf60006f0efc90a0638000.00000006.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000028,orig:e3a0a0acdebf60006f0efc90a0638000.00000006.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC188\ufffd\n\\ No newline at end of file"
      },
      {
        "sha": "91cde8bba5affaec38a02f75414cadbc167420f5",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000029,orig:2ce927c00000000047994cb000000000.00000003.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000029,orig:2ce927c00000000047994cb000000000.00000003.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000029,orig:2ce927c00000000047994cb000000000.00000003.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000029,orig:2ce927c00000000047994cb000000000.00000003.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+tb1\n\\ No newline at end of file"
      },
      {
        "sha": "4d7eaaf89e043d0328a93c4e05538f9e1b987547",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000029,orig:e4299c9c9c9c9c9ce4299c9c9c9c9c9c.00000009.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000029,orig:e4299c9c9c9c9c9ce4299c9c9c9c9c9c.00000009.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000029,orig:e4299c9c9c9c9c9ce4299c9c9c9c9c9c.00000009.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000029,orig:e4299c9c9c9c9c9ce4299c9c9c9c9c9c.00000009.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+111111111\n\\ No newline at end of file"
      },
      {
        "sha": "c08840a981a2f3b1eee8e6dd4b232fd12907e9ff",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000030,orig:37df2d30000000004d5f57b000000000.00000003.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000030,orig:37df2d30000000004d5f57b000000000.00000003.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000030,orig:37df2d30000000004d5f57b000000000.00000003.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000030,orig:37df2d30000000004d5f57b000000000.00000003.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+yB!\n\\ No newline at end of file"
      },
      {
        "sha": "7b467a2f2a5c440b162f6564f25c295cd4533a09",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000031,orig:41736041414141414173604141414141.00000019.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000031,orig:41736041414141414173604141414141.00000019.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000031,orig:41736041414141414173604141414141.00000019.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000031,orig:41736041414141414173604141414141.00000019.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+1111111111111111111111111\n\\ No newline at end of file"
      },
      {
        "sha": "5d6c77dcbb8c65594bb144af80d4e46fa85ee3c1",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000032,orig:583f57782266bf0cf61b913df4fa7b99.00000011.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000032,orig:583f57782266bf0cf61b913df4fa7b99.00000011.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000032,orig:583f57782266bf0cf61b913df4fa7b99.00000011.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000032,orig:583f57782266bf0cf61b913df4fa7b99.00000011.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1-7111544E0837U\n\\ No newline at end of file"
      },
      {
        "sha": "8d04c982dbf3863ca392a2db87a38e1899c784f4",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000036,orig:d7796363633d2cde4deafc9d73636363.00000009.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000036,orig:d7796363633d2cde4deafc9d73636363.00000009.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000036,orig:d7796363633d2cde4deafc9d73636363.00000009.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000036,orig:d7796363633d2cde4deafc9d73636363.00000009.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC10WWWW4\n\\ No newline at end of file"
      },
      {
        "sha": "a86b9ee04553ddca05a9a0c9411e2ac45ca4edca",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000039,orig:id:000033,src:000004,op:havoc,rep:2",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000039,orig:id:000033,src:000004,op:havoc,rep:2",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000039,orig:id:000033,src:000004,op:havoc,rep:2",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000039,orig:id:000033,src:000004,op:havoc,rep:2?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+o161\n\\ No newline at end of file"
      },
      {
        "sha": "2cf65cf5c9827f438fe2fd8249843693938b8c0a",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000040,orig:id:000034,src:000004,op:havoc,rep:2",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000040,orig:id:000034,src:000004,op:havoc,rep:2",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000040,orig:id:000034,src:000004,op:havoc,rep:2",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000040,orig:id:000034,src:000004,op:havoc,rep:2?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+1\u0018\n\\ No newline at end of file"
      },
      {
        "sha": "6a9534301279563a8c71f762b9ba9d7ece015a15",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000041,orig:id:000034,src:000004,op:havoc,rep:64",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000041,orig:id:000034,src:000004,op:havoc,rep:64",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000041,orig:id:000034,src:000004,op:havoc,rep:64",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000041,orig:id:000034,src:000004,op:havoc,rep:64?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "9d07aa0df55c353e18eea6f1b401946b5dad7bce",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000043,orig:id:000042,src:000004,op:havoc,rep:2",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000043,orig:id:000042,src:000004,op:havoc,rep:2",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000043,orig:id:000042,src:000004,op:havoc,rep:2",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000043,orig:id:000042,src:000004,op:havoc,rep:2?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+111\n\\ No newline at end of file"
      },
      {
        "sha": "47e8930a52ca0fce69fc4df4ebec785b52e1bb52",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000044,orig:id:000042,src:000004,op:havoc,rep:64",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000044,orig:id:000042,src:000004,op:havoc,rep:64",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000044,orig:id:000042,src:000004,op:havoc,rep:64",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000044,orig:id:000042,src:000004,op:havoc,rep:64?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx\n\\ No newline at end of file"
      },
      {
        "sha": "b8471521bbedba7dcad5b92d6a019030d3c018c4",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000045,orig:id:000044,src:000004,op:havoc,rep:4",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000045,orig:id:000044,src:000004,op:havoc,rep:4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000045,orig:id:000044,src:000004,op:havoc,rep:4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000045,orig:id:000044,src:000004,op:havoc,rep:4?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+11YYYYYYYYYYYY1961\n\\ No newline at end of file"
      },
      {
        "sha": "f6de2994c9043cafe5a69941b0205ee7bf084df9",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000046,orig:id:000045,src:000004,op:havoc,rep:2",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000046,orig:id:000045,src:000004,op:havoc,rep:2",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000046,orig:id:000045,src:000004,op:havoc,rep:2",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000046,orig:id:000045,src:000004,op:havoc,rep:2?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+1Y666161\n\\ No newline at end of file"
      },
      {
        "sha": "d769ca0f057c73320d41888e42166d0f0aa979a7",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000046,src:000004,op:havoc,rep:2",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000046,src:000004,op:havoc,rep:2",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000046,src:000004,op:havoc,rep:2",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000046,src:000004,op:havoc,rep:2?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+11111111111111\n\\ No newline at end of file"
      },
      {
        "sha": "db111c5bcd8bd29cee5dd62c370c9d93dcc87e7c",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000047,src:000004+000012,op:splice,rep:2",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000047,src:000004+000012,op:splice,rep:2",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000047,src:000004+000012,op:splice,rep:2",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000047,src:000004+000012,op:splice,rep:2?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1-71110837GGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGGWGGGG\n\\ No newline at end of file"
      },
      {
        "sha": "7153628ea778a52e8acb0b78701df26a8b4f19e4",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000058,sync:deserialize_address_0,src:000050",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000058,sync:deserialize_address_0,src:000050",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000058,sync:deserialize_address_0,src:000050",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000058,sync:deserialize_address_0,src:000050?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+1111111\n\\ No newline at end of file"
      },
      {
        "sha": "db218e2df8f18ec3fb8de9885f1b9bdbe5d49eae",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000059,sync:deserialize_address_0,src:000057",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000059,sync:deserialize_address_0,src:000057",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000059,sync:deserialize_address_0,src:000057",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000059,sync:deserialize_address_0,src:000057?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1-711154444444444444444444444444444E083dU\n\\ No newline at end of file"
      },
      {
        "sha": "e5c5a15962a002f256bf3b35c66ad3b7e9c8f214",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000062,sync:deserialize_address_0,src:000059",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000062,sync:deserialize_address_0,src:000059",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000062,sync:deserialize_address_0,src:000059",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000062,sync:deserialize_address_0,src:000059?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1C1;71;711-7111544E083'1-71115111111O1111144E0837U\n\\ No newline at end of file"
      },
      {
        "sha": "43db9efb341ba4d0d890a527c3b3416724a44d4f",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000062,sync:deserialize_address_master,src:000062",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000062,sync:deserialize_address_master,src:000062",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000062,sync:deserialize_address_master,src:000062",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000062,sync:deserialize_address_master,src:000062?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+11111111111111111111111111111111111111111111\n\\ No newline at end of file"
      },
      {
        "sha": "a1c2f115994f384dfd5cebf1da9394e910dc6060",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000063,sync:deserialize_address_master,src:000044",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000063,sync:deserialize_address_master,src:000044",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000063,sync:deserialize_address_master,src:000044",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000063,sync:deserialize_address_master,src:000044?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+11111161\n\\ No newline at end of file"
      },
      {
        "sha": "807f50e863855eee0fd150a09628ee7fc7610218",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000064,sync:deserialize_address_0,src:000044",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000064,sync:deserialize_address_0,src:000044",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000064,sync:deserialize_address_0,src:000044",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000064,sync:deserialize_address_0,src:000044?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1-71115(4E0831-7111544E0837U7U\n\\ No newline at end of file"
      },
      {
        "sha": "a1c58eaa019a303148fd6cfaf5e1de5e181594d4",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000064,sync:deserialize_address_0,src:000060",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000064,sync:deserialize_address_0,src:000060",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000064,sync:deserialize_address_0,src:000060",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000064,sync:deserialize_address_0,src:000060?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1C11111111111111111111111111~~~~~~~~~~~~~~~~~1111E0837U\n\\ No newline at end of file"
      },
      {
        "sha": "b43b6c790a80e917c87cf5cdac84f0b3e6bced18",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000065,sync:deserialize_address_master,src:000067",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000065,sync:deserialize_address_master,src:000067",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000065,sync:deserialize_address_master,src:000067",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000065,sync:deserialize_address_master,src:000067?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC111544E083'1-711154C1;71@711-7111544E083'1-7111544E0837U\n\\ No newline at end of file"
      },
      {
        "sha": "921a12bc647666406f781f22618b3d1777367b66",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000068,src:000004,op:flip1,pos:3",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000068,src:000004,op:flip1,pos:3",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000068,src:000004,op:flip1,pos:3",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000068,src:000004,op:flip1,pos:3?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+tb1r70kt564\n\\ No newline at end of file"
      },
      {
        "sha": "04ef632c1d033c72566fba950cad7119d7998399",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000069,src:000004,op:flip2,pos:3",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000069,src:000004,op:flip2,pos:3",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000069,src:000004,op:flip2,pos:3",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000069,src:000004,op:flip2,pos:3?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+tb1170kt564\n\\ No newline at end of file"
      },
      {
        "sha": "dbe88ee759729842726443c363645179b84c14ac",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000069,src:000050,op:havoc,rep:8",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000069,src:000050,op:havoc,rep:8",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000069,src:000050,op:havoc,rep:8",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000069,src:000050,op:havoc,rep:8?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1C1;XXXXXXXXXXXXXXXXXXXXXXXXAXXX114E544E0<544E7111544E0837U\n\\ No newline at end of file"
      },
      {
        "sha": "191d1c2a44daf11bc3d62fa74ee0694eec5bf30a",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000070,src:000050,op:havoc,rep:4",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000070,src:000050,op:havoc,rep:4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000070,src:000050,op:havoc,rep:4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000070,src:000050,op:havoc,rep:4?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1C1;71;711-7111544E083'711-711154-7117'11-71115440837U\n\\ No newline at end of file"
      },
      {
        "sha": "17b540af343df387208c331b8b51dbcd301ea902",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000070,sync:deserialize_address_0,src:000062",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000070,sync:deserialize_address_0,src:000062",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000070,sync:deserialize_address_0,src:000062",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000070,sync:deserialize_address_0,src:000062?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC11544E0837U\n\\ No newline at end of file"
      },
      {
        "sha": "780288f64ab8e62c21a1d8260016c08748d39135",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000071,src:000050,op:havoc,rep:2",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000071,src:000050,op:havoc,rep:2",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000071,src:000050,op:havoc,rep:2",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000071,src:000050,op:havoc,rep:2?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1C1;71;711-7111544E083'1-7111544E08377-7111544E0837UU\n\\ No newline at end of file"
      },
      {
        "sha": "8fdd954df9831dfd29ceec0d74829b02f3f5d8c3",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000072,src:000004,op:havoc,rep:64",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000072,src:000004,op:havoc,rep:64",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000072,src:000004,op:havoc,rep:64",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000072,src:000004,op:havoc,rep:64?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+22\n\\ No newline at end of file"
      },
      {
        "sha": "360f2710ef5f8e5a7c7bb23ee9a61f716d586f41",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000072,src:000051,op:flip2,pos:22",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000072,src:000051,op:flip2,pos:22",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000072,src:000051,op:flip2,pos:22",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000072,src:000051,op:flip2,pos:22?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1-3711LLLLLLLLLLLLLL,LLLLLLLLLLLLLLLLL1544E0837U\n\\ No newline at end of file"
      },
      {
        "sha": "7886624456b2db76632de763ff3800c4704af325",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000074,src:000004,op:havoc,rep:2",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000074,src:000004,op:havoc,rep:2",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000074,src:000004,op:havoc,rep:2",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000074,src:000004,op:havoc,rep:2?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+tb127kkkkkkkkkkkkkkkkkkkkkkkkkkkkkk0kt56\n\\ No newline at end of file"
      },
      {
        "sha": "6ff36f14479ad46667c01597fbe6761b5505bf24",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000074,sync:deserialize_address_0,src:000064",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000074,sync:deserialize_address_0,src:000064",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000074,sync:deserialize_address_0,src:000064",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000074,sync:deserialize_address_0,src:000064?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1C1;71;711-44E083'1-711154SA0837111544E083'1-7111544E0837U\n\\ No newline at end of file"
      },
      {
        "sha": "e53a470f26c9509c5bd6d341f511f5c103d49947",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000075,src:000004,op:havoc,rep:64",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000075,src:000004,op:havoc,rep:64",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000075,src:000004,op:havoc,rep:64",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000075,src:000004,op:havoc,rep:64?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+hhhhhhhhhhhhhhhhRhhhhhhhThhhhhhhhhhhhhhRhhhhhhhh\n\\ No newline at end of file"
      },
      {
        "sha": "8f1a03bae7f358b661488a3042cfe4d1c2588cc0",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000075,sync:deserialize_address_0,src:000049",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000075,sync:deserialize_address_0,src:000049",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000075,sync:deserialize_address_0,src:000049",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000075,sync:deserialize_address_0,src:000049?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1EC1-7111544E0A37+111544E0A37U\n\\ No newline at end of file"
      },
      {
        "sha": "433cfc4269a62aa15d36971bf56c779ff7ad278a",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000076,src:000061,op:havoc,rep:8",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000076,src:000061,op:havoc,rep:8",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000076,src:000061,op:havoc,rep:8",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000076,src:000061,op:havoc,rep:8?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1C1;71;.11-7111544-7*1'1-7*115C17*1'1-7*115C1CA;71;1C1;71;711-711-7111514E0837U\n\\ No newline at end of file"
      },
      {
        "sha": "a797ed62362be775ff3299246ba5530e70d52245",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000077,src:000006,op:flip1,pos:30",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000077,src:000006,op:flip1,pos:30",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000077,src:000006,op:flip1,pos:30",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000077,src:000006,op:flip1,pos:30?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+tb1118755mmmmmmmmmm9264mmmmmmm132772648\n\\ No newline at end of file"
      },
      {
        "sha": "93a18cdd923504ff13ec81ae894988cae3392482",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000077,sync:deserialize_address_0,src:000043",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000077,sync:deserialize_address_0,src:000043",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000077,sync:deserialize_address_0,src:000043",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000077,sync:deserialize_address_0,src:000043?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+BC1C1;71;711-710154C1C1;71;711-4E083'1-7111544E0837U\n\\ No newline at end of file"
      },
      {
        "sha": "537c3b8313a6baf39fbfda24a92b5ddf363ef8c5",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000080,src:000006,op:havoc,rep:2",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000080,src:000006,op:havoc,rep:2",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000080,src:000006,op:havoc,rep:2",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000080,src:000006,op:havoc,rep:2?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+tb1118755mmmnmmmmmm9264mmb1mmmmm93277264\n\\ No newline at end of file"
      },
      {
        "sha": "002172109f3244a04fa886d580f168474a8f403f",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000082,src:000010,op:havoc,rep:4",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000082,src:000010,op:havoc,rep:4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000082,src:000010,op:havoc,rep:4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000082,src:000010,op:havoc,rep:4?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000090,src:000081,op:havoc,rep:2",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000090,src:000081,op:havoc,rep:2",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000090,src:000081,op:havoc,rep:2",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_address/input/id:000090,src:000081,op:havoc,rep:2?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "9aa63b05361e5dee4f01f8c824cfc483a339f5c3",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/26c81c03b9651108489c94e7f7d9ec83.0000187a.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/26c81c03b9651108489c94e7f7d9ec83.0000187a.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/26c81c03b9651108489c94e7f7d9ec83.0000187a.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/26c81c03b9651108489c94e7f7d9ec83.0000187a.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "d4228a326124c4425311873415678d43d9bebab0",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/82b6ca2032c4fae9f860fb7f02607f0f.0000005e.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/82b6ca2032c4fae9f860fb7f02607f0f.0000005e.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/82b6ca2032c4fae9f860fb7f02607f0f.0000005e.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/82b6ca2032c4fae9f860fb7f02607f0f.0000005e.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "82b7fa5360c10cdb6a26ecf4ee5a0c32da12848e",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/e4313771686c7664845b7c29b1a259ce.00001e39.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/e4313771686c7664845b7c29b1a259ce.00001e39.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/e4313771686c7664845b7c29b1a259ce.00001e39.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/e4313771686c7664845b7c29b1a259ce.00001e39.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "bb5baad68c6cdb2f5e3829caf5016169da885982",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/ea8e157df43da4453ccdb7b706da2fcd.0000012c.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/ea8e157df43da4453ccdb7b706da2fcd.0000012c.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/ea8e157df43da4453ccdb7b706da2fcd.0000012c.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/ea8e157df43da4453ccdb7b706da2fcd.0000012c.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "9716078cfaba187176d49643b35c69025a1af3e1",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/eaa84c843e28389940ee87aef0bf42c8.0000005e.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/eaa84c843e28389940ee87aef0bf42c8.0000005e.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/eaa84c843e28389940ee87aef0bf42c8.0000005e.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/eaa84c843e28389940ee87aef0bf42c8.0000005e.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "df879cf49534a5672299e8e57970c3d2ef1be71d",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000000,orig:00000000000000000000000000000000.00000014.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000000,orig:00000000000000000000000000000000.00000014.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000000,orig:00000000000000000000000000000000.00000014.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000000,orig:00000000000000000000000000000000.00000014.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "cc777282f4d6bcf36450def0dbad3d1666144b03",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000000,orig:0000747a210d0000e395529a00000000.0000000d.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000000,orig:0000747a210d0000e395529a00000000.0000000d.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000000,orig:0000747a210d0000e395529a00000000.0000000d.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000000,orig:0000747a210d0000e395529a00000000.0000000d.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "9339aa6bcb3cf2a350e9227ae36b384ab8738749",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000002,orig:30de67eb614e23eae7a8524998830ae5.0000104e.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000002,orig:30de67eb614e23eae7a8524998830ae5.0000104e.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000002,orig:30de67eb614e23eae7a8524998830ae5.0000104e.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000002,orig:30de67eb614e23eae7a8524998830ae5.0000104e.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "f2d3ecfffc193ec668fcf4766d311292f8631a5a",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000003,orig:3e4c1ecfa88e7688176bafdc1cdef3ac.00000068.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000003,orig:3e4c1ecfa88e7688176bafdc1cdef3ac.00000068.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000003,orig:3e4c1ecfa88e7688176bafdc1cdef3ac.00000068.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000003,orig:3e4c1ecfa88e7688176bafdc1cdef3ac.00000068.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "920368ead15d6bcc36454f2881b5b9cc5d394d07",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000004,orig:46ef0efd9258e206e3f01d38fab33e5d.0000049a.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000004,orig:46ef0efd9258e206e3f01d38fab33e5d.0000049a.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000004,orig:46ef0efd9258e206e3f01d38fab33e5d.0000049a.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000004,orig:46ef0efd9258e206e3f01d38fab33e5d.0000049a.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "2a09bb15a40a1f7d1629964c4e56f263f75960d1",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000006,orig:55c3be8d8490c27b9016b8cf573000d5.00000050.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000006,orig:55c3be8d8490c27b9016b8cf573000d5.00000050.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000006,orig:55c3be8d8490c27b9016b8cf573000d5.00000050.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000006,orig:55c3be8d8490c27b9016b8cf573000d5.00000050.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "218ad0c93ff72a1e377c86e55d97cdf07083a61b",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000007,orig:58d699335b5b36233d1bdf0cedad7f63.00001175.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000007,orig:58d699335b5b36233d1bdf0cedad7f63.00001175.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000007,orig:58d699335b5b36233d1bdf0cedad7f63.00001175.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000007,orig:58d699335b5b36233d1bdf0cedad7f63.00001175.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "4ba8e76d62f0d521e394b54213928ce059fe2f36",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000007,orig:d7112b3552db4a545d8693c4b4ca38ee.00000347.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000007,orig:d7112b3552db4a545d8693c4b4ca38ee.00000347.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000007,orig:d7112b3552db4a545d8693c4b4ca38ee.00000347.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000007,orig:d7112b3552db4a545d8693c4b4ca38ee.00000347.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "58c62dc9d114d5c3e1acbf7fcce41f71e1935117",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000008,orig:59d7733b7ce0acb6d1a8c01a2a733c0f.000009c1.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000008,orig:59d7733b7ce0acb6d1a8c01a2a733c0f.000009c1.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000008,orig:59d7733b7ce0acb6d1a8c01a2a733c0f.000009c1.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000008,orig:59d7733b7ce0acb6d1a8c01a2a733c0f.000009c1.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "ffeea9522f900bbbfc59e94247924dca025ca20a",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000009,orig:5a049d1bda43f22cd02347f6759f8d49.00000171.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000009,orig:5a049d1bda43f22cd02347f6759f8d49.00000171.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000009,orig:5a049d1bda43f22cd02347f6759f8d49.00000171.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000009,orig:5a049d1bda43f22cd02347f6759f8d49.00000171.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "447993c1e84d85f7be881eae4641821f9bdef1c8",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000010,orig:799478dd7f44436e43f6a2ce9dd5d500.00000280.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000010,orig:799478dd7f44436e43f6a2ce9dd5d500.00000280.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000010,orig:799478dd7f44436e43f6a2ce9dd5d500.00000280.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000010,orig:799478dd7f44436e43f6a2ce9dd5d500.00000280.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "c97f747213d2c93d22f019701126aff63c32d903",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000012,orig:33158c5168501211b85e51eb858552d0.00000052.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000012,orig:33158c5168501211b85e51eb858552d0.00000052.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000012,orig:33158c5168501211b85e51eb858552d0.00000052.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000012,orig:33158c5168501211b85e51eb858552d0.00000052.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "0acea8076fdc03c275770e6733cc917985e73324",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000013,orig:834b231ba86ecc35458b98ab40242765.00000090.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000013,orig:834b231ba86ecc35458b98ab40242765.00000090.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000013,orig:834b231ba86ecc35458b98ab40242765.00000090.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000013,orig:834b231ba86ecc35458b98ab40242765.00000090.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "02e82c4534616f551eb68b0e74249d28c2f18006",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000013,orig:92acdfa148ead2580273b028376c833f.00001118.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000013,orig:92acdfa148ead2580273b028376c833f.00001118.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000013,orig:92acdfa148ead2580273b028376c833f.00001118.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000013,orig:92acdfa148ead2580273b028376c833f.00001118.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "6be56fcd324bc3b74375a3a5fb0200e8a429d227",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000014,orig:8a6caa161bbf8b62f1155509f47c1925.000001c9.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000014,orig:8a6caa161bbf8b62f1155509f47c1925.000001c9.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000014,orig:8a6caa161bbf8b62f1155509f47c1925.000001c9.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000014,orig:8a6caa161bbf8b62f1155509f47c1925.000001c9.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "1124ba175becdcef9e16b780242b92703f17cce3",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000014,orig:b195ff73ae6af70b8dd960d5e2497074.00000051.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000014,orig:b195ff73ae6af70b8dd960d5e2497074.00000051.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000014,orig:b195ff73ae6af70b8dd960d5e2497074.00000051.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000014,orig:b195ff73ae6af70b8dd960d5e2497074.00000051.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "8b99b76f0cea7dc586f247dec8c5a8d55e5dbe74",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000015,orig:9997f28c8f839e94f08803b89546af85.000003d5.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000015,orig:9997f28c8f839e94f08803b89546af85.000003d5.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000015,orig:9997f28c8f839e94f08803b89546af85.000003d5.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000015,orig:9997f28c8f839e94f08803b89546af85.000003d5.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "0b6600f1efb365bd5575ff604065c2e15b328347",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000016,orig:9fee7269e42f7a1cbc932c4b11ebe638.00000cb1.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000016,orig:9fee7269e42f7a1cbc932c4b11ebe638.00000cb1.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000016,orig:9fee7269e42f7a1cbc932c4b11ebe638.00000cb1.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000016,orig:9fee7269e42f7a1cbc932c4b11ebe638.00000cb1.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "5b2881be25487699d7942517640732067872c072",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000017,orig:a544d559857d49e138d25cf41c61568e.0000007c.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000017,orig:a544d559857d49e138d25cf41c61568e.0000007c.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000017,orig:a544d559857d49e138d25cf41c61568e.0000007c.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000017,orig:a544d559857d49e138d25cf41c61568e.0000007c.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "3b721680e7b9509ef7d3e4400938649aa54c6db4",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000018,orig:b01ceea7151583100c9651148b73a82d.00000483.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000018,orig:b01ceea7151583100c9651148b73a82d.00000483.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000018,orig:b01ceea7151583100c9651148b73a82d.00000483.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000018,orig:b01ceea7151583100c9651148b73a82d.00000483.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "73f3969026f37a54768bc212b181ff5dff77806c",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000018,orig:d3a15597bf83b134239874b31cc9164c.00003ffa.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000018,orig:d3a15597bf83b134239874b31cc9164c.00003ffa.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000018,orig:d3a15597bf83b134239874b31cc9164c.00003ffa.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000018,orig:d3a15597bf83b134239874b31cc9164c.00003ffa.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "7b0ed899f13e198d30078c52c83abfbb17559cf0",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000019,orig:b63ddcefe10c51a93b8b39474c2da11b.0000005e.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000019,orig:b63ddcefe10c51a93b8b39474c2da11b.0000005e.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000019,orig:b63ddcefe10c51a93b8b39474c2da11b.0000005e.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000019,orig:b63ddcefe10c51a93b8b39474c2da11b.0000005e.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "c40560b892aa5386bed85e6d06d11fe75a1e7251",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000020,orig:be9377d826f57b92ecccd35ed7653e78.000001c9.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000020,orig:be9377d826f57b92ecccd35ed7653e78.000001c9.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000020,orig:be9377d826f57b92ecccd35ed7653e78.000001c9.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000020,orig:be9377d826f57b92ecccd35ed7653e78.000001c9.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "75370b535c665a74f1262fce234b2b86ea72aa4d",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000022,orig:d26c7af7d0ff524953bcb2e8bc3c634e.0000191b.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000022,orig:d26c7af7d0ff524953bcb2e8bc3c634e.0000191b.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000022,orig:d26c7af7d0ff524953bcb2e8bc3c634e.0000191b.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000022,orig:d26c7af7d0ff524953bcb2e8bc3c634e.0000191b.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "373162cafeee2290c66112a2c793e608d7869cc5",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000024,orig:e7dbfe989e635dd6d2ffcc74e82004b9.00001cea.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000024,orig:e7dbfe989e635dd6d2ffcc74e82004b9.00001cea.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000024,orig:e7dbfe989e635dd6d2ffcc74e82004b9.00001cea.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000024,orig:e7dbfe989e635dd6d2ffcc74e82004b9.00001cea.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "0774c36b4322e4ae913d65b6ec3ff05202c687c3",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000025,orig:e7e475510d47fd1b20e16d8b69a0bd06.00000051.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000025,orig:e7e475510d47fd1b20e16d8b69a0bd06.00000051.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000025,orig:e7e475510d47fd1b20e16d8b69a0bd06.00000051.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000025,orig:e7e475510d47fd1b20e16d8b69a0bd06.00000051.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "fbfbeb7bb83bbd58bdd81b339847a3f6ffe27e08",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000027,orig:f8b26d87f49e288cd46df1ba44f91982.0000008e.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000027,orig:f8b26d87f49e288cd46df1ba44f91982.0000008e.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000027,orig:f8b26d87f49e288cd46df1ba44f91982.0000008e.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000027,orig:f8b26d87f49e288cd46df1ba44f91982.0000008e.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "67015a1fe18868137f5706da892c1af973b6990e",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000028,orig:587e6b698644e3adef93f9d0d26be075.000001bc.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000028,orig:587e6b698644e3adef93f9d0d26be075.000001bc.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000028,orig:587e6b698644e3adef93f9d0d26be075.000001bc.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000028,orig:587e6b698644e3adef93f9d0d26be075.000001bc.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "5699696e9cc68569aff278840a19c54df3754275",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000029,orig:2f7cea00ffbe06e68c4c802bc457e84b.00000051.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000029,orig:2f7cea00ffbe06e68c4c802bc457e84b.00000051.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000029,orig:2f7cea00ffbe06e68c4c802bc457e84b.00000051.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000029,orig:2f7cea00ffbe06e68c4c802bc457e84b.00000051.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "5cf9355b121fb07527fa9ef5146987415f49b080",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000030,orig:288c2c66482153a0d9aae05f1e9a69ea.0000005b.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000030,orig:288c2c66482153a0d9aae05f1e9a69ea.0000005b.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000030,orig:288c2c66482153a0d9aae05f1e9a69ea.0000005b.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000030,orig:288c2c66482153a0d9aae05f1e9a69ea.0000005b.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "df1a19d5b15afd18ff1545b76d5319f973240aa4",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000030,orig:69f287152d5409a5671ba4a0e75e9fd2.000010b0.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000030,orig:69f287152d5409a5671ba4a0e75e9fd2.000010b0.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000030,orig:69f287152d5409a5671ba4a0e75e9fd2.000010b0.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000030,orig:69f287152d5409a5671ba4a0e75e9fd2.000010b0.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "36c10bb03a309a0711b76913e9e2d73b8447171a",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000032,orig:6be09244078a2cdb4b52e2703192aa1c.00000936.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000032,orig:6be09244078a2cdb4b52e2703192aa1c.00000936.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000032,orig:6be09244078a2cdb4b52e2703192aa1c.00000936.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000032,orig:6be09244078a2cdb4b52e2703192aa1c.00000936.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "babe844e2d2ab9ac5676ff363c7b31f816825ea0",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000033,orig:898de0b89c0c21032e788e06f6b9ccc6.0000049e.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000033,orig:898de0b89c0c21032e788e06f6b9ccc6.0000049e.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000033,orig:898de0b89c0c21032e788e06f6b9ccc6.0000049e.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000033,orig:898de0b89c0c21032e788e06f6b9ccc6.0000049e.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "8b73c947dfe0a87b041cb5f7e670c5934e64648e",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000034,orig:fb4c2bb2b57f2e8f482d6b2ca2c638ab.00000146.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000034,orig:fb4c2bb2b57f2e8f482d6b2ca2c638ab.00000146.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000034,orig:fb4c2bb2b57f2e8f482d6b2ca2c638ab.00000146.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000034,orig:fb4c2bb2b57f2e8f482d6b2ca2c638ab.00000146.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "e22376871a1f16403cbbd510a05da474f8025392",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000036,orig:ee35e81370e627fcc08f5f4eca611c52.00004f36.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000036,orig:ee35e81370e627fcc08f5f4eca611c52.00004f36.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000036,orig:ee35e81370e627fcc08f5f4eca611c52.00004f36.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000036,orig:ee35e81370e627fcc08f5f4eca611c52.00004f36.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "850d806939ca70ea096dd2e748e1c53c794bd324",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000037,orig:d8c72638fcfeed2b490ad59971eba5cb.00000089.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000037,orig:d8c72638fcfeed2b490ad59971eba5cb.00000089.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000037,orig:d8c72638fcfeed2b490ad59971eba5cb.00000089.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000037,orig:d8c72638fcfeed2b490ad59971eba5cb.00000089.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "8f4003e87215b771de8b527039b996df75dd7d50",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000039,orig:dca36c2c9dfc4aac2055199abf343c9a.0000006d.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000039,orig:dca36c2c9dfc4aac2055199abf343c9a.0000006d.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000039,orig:dca36c2c9dfc4aac2055199abf343c9a.0000006d.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000039,orig:dca36c2c9dfc4aac2055199abf343c9a.0000006d.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "f2075a143295b465c439f5f1c809f87e0f85dc86",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000041,orig:4182ee40e8b9db920aa463251cc10b72.00000071.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000041,orig:4182ee40e8b9db920aa463251cc10b72.00000071.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000041,orig:4182ee40e8b9db920aa463251cc10b72.00000071.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000041,orig:4182ee40e8b9db920aa463251cc10b72.00000071.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "9ba81982a204ef667699c12ca0b5f25985ccc1ea",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000042,orig:fc696eda9366e8dd2b74ee38afc9b112.00000080.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000042,orig:fc696eda9366e8dd2b74ee38afc9b112.00000080.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000042,orig:fc696eda9366e8dd2b74ee38afc9b112.00000080.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000042,orig:fc696eda9366e8dd2b74ee38afc9b112.00000080.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "85c1db506a54408cd8c7c3660638a13c01abb10f",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000043,orig:21056c56ff512f3827c6e58a4798aef1.0000132e.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000043,orig:21056c56ff512f3827c6e58a4798aef1.0000132e.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000043,orig:21056c56ff512f3827c6e58a4798aef1.0000132e.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000043,orig:21056c56ff512f3827c6e58a4798aef1.0000132e.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "508043816d5d7e1ca2bc5c16c768cbe35404ba66",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000044,orig:3bb95a79c18a48d6fc2cae5619513e47.00000024.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000044,orig:3bb95a79c18a48d6fc2cae5619513e47.00000024.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000044,orig:3bb95a79c18a48d6fc2cae5619513e47.00000024.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000044,orig:3bb95a79c18a48d6fc2cae5619513e47.00000024.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "833397680eaf939a49e29e5b02bd150af3c903bf",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000047,orig:bbbb8044701289e467497ea8f3ace4fc.0000020a.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000047,orig:bbbb8044701289e467497ea8f3ace4fc.0000020a.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000047,orig:bbbb8044701289e467497ea8f3ace4fc.0000020a.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000047,orig:bbbb8044701289e467497ea8f3ace4fc.0000020a.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "bae158400de393a1bc18fde56738525d13efefed",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000049,orig:3f61d605dff91d3eaf012548db3e06f1.0000005a.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000049,orig:3f61d605dff91d3eaf012548db3e06f1.0000005a.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000049,orig:3f61d605dff91d3eaf012548db3e06f1.0000005a.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000049,orig:3f61d605dff91d3eaf012548db3e06f1.0000005a.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "6087bb1d7bd28b2c6579c8cd4af4f6565ffc1b26",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000051,orig:739a844f27d4b10bd9a07dbdfc6860a8.0000005e.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000051,orig:739a844f27d4b10bd9a07dbdfc6860a8.0000005e.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000051,orig:739a844f27d4b10bd9a07dbdfc6860a8.0000005e.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000051,orig:739a844f27d4b10bd9a07dbdfc6860a8.0000005e.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "a4e864ddb3c6e21c768704e1f67d98f54470feb3",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000052,orig:e4fd180890e317061b581cf656ccdcb5.0000005b.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000052,orig:e4fd180890e317061b581cf656ccdcb5.0000005b.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000052,orig:e4fd180890e317061b581cf656ccdcb5.0000005b.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000052,orig:e4fd180890e317061b581cf656ccdcb5.0000005b.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "03338d3ed5323e474daec300e449d25883a049ee",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000053,orig:e7ffc69d40729bdbf8ea9eaa0ad83f5e.00000045.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000053,orig:e7ffc69d40729bdbf8ea9eaa0ad83f5e.00000045.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000053,orig:e7ffc69d40729bdbf8ea9eaa0ad83f5e.00000045.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000053,orig:e7ffc69d40729bdbf8ea9eaa0ad83f5e.00000045.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "c8192f9a5a6438c6f6ac07c37d1f40b8b128765e",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000054,orig:eaa3d259ac214000f33500515ca91269.00000009.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000054,orig:eaa3d259ac214000f33500515ca91269.00000009.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000054,orig:eaa3d259ac214000f33500515ca91269.00000009.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000054,orig:eaa3d259ac214000f33500515ca91269.00000009.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "d85802828d9c4e80f20f3fe072f292d604ad302f",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000055,orig:25eef38783e131a71c589706915e229f.0000004c.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000055,orig:25eef38783e131a71c589706915e229f.0000004c.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000055,orig:25eef38783e131a71c589706915e229f.0000004c.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000055,orig:25eef38783e131a71c589706915e229f.0000004c.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "988cb4efc4c15892e16c2c28329e0996a8ce43b9",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000056,orig:2e488cd421b08e308e3001d40c988e60.00000007.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000056,orig:2e488cd421b08e308e3001d40c988e60.00000007.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000056,orig:2e488cd421b08e308e3001d40c988e60.00000007.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000056,orig:2e488cd421b08e308e3001d40c988e60.00000007.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "af4147a911a65a7f75cd6f19328edc244db9229d",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000059,orig:eea8d9411c998c1179d61d182d7ee35f.0000132e.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000059,orig:eea8d9411c998c1179d61d182d7ee35f.0000132e.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000059,orig:eea8d9411c998c1179d61d182d7ee35f.0000132e.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000059,orig:eea8d9411c998c1179d61d182d7ee35f.0000132e.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "367a0b303c8221bec200dd45cf79a63a2a7acc88",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000060,orig:4f40ec4f600000006fdc801fe0000000.00000004.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000060,orig:4f40ec4f600000006fdc801fe0000000.00000004.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000060,orig:4f40ec4f600000006fdc801fe0000000.00000004.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000060,orig:4f40ec4f600000006fdc801fe0000000.00000004.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+B\ufffd\ufffdz\n\\ No newline at end of file"
      },
      {
        "sha": "1380b8f7e5dbaec99e30953ad0b4fba1388e9d04",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000071,orig:id:000107,src:000105,op:flip1,pos:435",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000071,orig:id:000107,src:000105,op:flip1,pos:435",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000071,orig:id:000107,src:000105,op:flip1,pos:435",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000071,orig:id:000107,src:000105,op:flip1,pos:435?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "5916b25060d553703ef2a7e2a452a40bfa31e30a",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000073,orig:id:000112,src:000012,op:flip1,pos:1599",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000073,orig:id:000112,src:000012,op:flip1,pos:1599",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000073,orig:id:000112,src:000012,op:flip1,pos:1599",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000073,orig:id:000112,src:000012,op:flip1,pos:1599?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "a52c68845538967dcd3ab266f32f521c54e41140",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000076,orig:fd80063f8fa2254c3ea9ef2a9d29a71e.00000048.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000076,orig:fd80063f8fa2254c3ea9ef2a9d29a71e.00000048.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000076,orig:fd80063f8fa2254c3ea9ef2a9d29a71e.00000048.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000076,orig:fd80063f8fa2254c3ea9ef2a9d29a71e.00000048.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "7b04e457b91a8daf123be74151e7d356ad0fa0f4",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000076,orig:id:000115,src:000101,op:arith8,pos:1139,val:-19",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000076,orig:id:000115,src:000101,op:arith8,pos:1139,val:-19",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000076,orig:id:000115,src:000101,op:arith8,pos:1139,val:-19",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000076,orig:id:000115,src:000101,op:arith8,pos:1139,val:-19?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "cc6d95ba5ca14560deba45ef344cac22bbf54f9b",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000081,src:000003,op:havoc,rep:64",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000081,src:000003,op:havoc,rep:64",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000081,src:000003,op:havoc,rep:64",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000081,src:000003,op:havoc,rep:64?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "814767037d674ad0bc3e173f54908de91002d57e",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000082,src:000003,op:havoc,rep:8",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000082,src:000003,op:havoc,rep:8",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000082,src:000003,op:havoc,rep:8",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000082,src:000003,op:havoc,rep:8?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "fd3f95de76b68c34f23369591bd74910e8a92da2",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000083,src:000003,op:havoc,rep:32",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000083,src:000003,op:havoc,rep:32",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000083,src:000003,op:havoc,rep:32",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000083,src:000003,op:havoc,rep:32?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "81029367640e0b4dd689dc2de349630e4e194359",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000087,orig:id:000101,src:000005,op:int16,pos:97,val:+1024",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000087,orig:id:000101,src:000005,op:int16,pos:97,val:+1024",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000087,orig:id:000101,src:000005,op:int16,pos:97,val:+1024",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000087,orig:id:000101,src:000005,op:int16,pos:97,val:+1024?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "07c1df4d0c949800aa8f1cb402f87e1b84e76396",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000095,orig:tx_id:000095,src:000000+000033,op:splice,rep:128",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000095,orig:tx_id:000095,src:000000+000033,op:splice,rep:128",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000095,orig:tx_id:000095,src:000000+000033,op:splice,rep:128",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000095,orig:tx_id:000095,src:000000+000033,op:splice,rep:128?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "fc9a72bba72f9f1eb12f5f8488d8f13ae10bf7a0",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000096,orig:id:000157,src:000113,op:havoc,rep:32",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000096,orig:id:000157,src:000113,op:havoc,rep:32",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000096,orig:id:000157,src:000113,op:havoc,rep:32",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000096,orig:id:000157,src:000113,op:havoc,rep:32?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "872a5a8ae3892b368d82e5b1cc2679ecbcaa9b35",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000096,orig:tx_id:000097,src:000000+000010,op:splice,rep:64",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000096,orig:tx_id:000097,src:000000+000010,op:splice,rep:64",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000096,orig:tx_id:000097,src:000000+000010,op:splice,rep:64",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000096,orig:tx_id:000097,src:000000+000010,op:splice,rep:64?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "28082c43050a61c5e334548e6180498b85fd2493",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000097,src:000005,op:arith8,pos:3343,val:-22",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000097,src:000005,op:arith8,pos:3343,val:-22",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000097,src:000005,op:arith8,pos:3343,val:-22",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000097,src:000005,op:arith8,pos:3343,val:-22?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "5dc1e70025d5e00640de2f7cb0bf67eb6110fb6e",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000098,orig:tx_id:000166,sync:deserialize_transaction_master,src:000136",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000098,orig:tx_id:000166,sync:deserialize_transaction_master,src:000136",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000098,orig:tx_id:000166,sync:deserialize_transaction_master,src:000136",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000098,orig:tx_id:000166,sync:deserialize_transaction_master,src:000136?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "8e1b68455e28faed0662ee29f91c5dc3779de32f",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000098,src:000021,op:flip1,pos:3143",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000098,src:000021,op:flip1,pos:3143",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000098,src:000021,op:flip1,pos:3143",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000098,src:000021,op:flip1,pos:3143?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "8063b047d981e16393732daac817312b36d0ec7f",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000101,orig:tx_id:000188,sync:deserialize_transaction_master,src:000172",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000101,orig:tx_id:000188,sync:deserialize_transaction_master,src:000172",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000101,orig:tx_id:000188,sync:deserialize_transaction_master,src:000172",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000101,orig:tx_id:000188,sync:deserialize_transaction_master,src:000172?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "d98b88ca081ba83c8328317adfba0ab1ed0bd72b",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000102,orig:tx_id:000190,sync:deserialize_transaction_master,src:000171",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000102,orig:tx_id:000190,sync:deserialize_transaction_master,src:000171",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000102,orig:tx_id:000190,sync:deserialize_transaction_master,src:000171",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000102,orig:tx_id:000190,sync:deserialize_transaction_master,src:000171?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "3c9c4fcd804cf6303211dc7ecb453823cc9fed18",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000104,src:000005,op:int32,pos:3524,val:+16",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000104,src:000005,op:int32,pos:3524,val:+16",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000104,src:000005,op:int32,pos:3524,val:+16",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000104,src:000005,op:int32,pos:3524,val:+16?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "9e97236af2f46de2a53ffcece82abf8f2e3a17e5",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000105,src:000008,op:flip1,pos:1160",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000105,src:000008,op:flip1,pos:1160",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000105,src:000008,op:flip1,pos:1160",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000105,src:000008,op:flip1,pos:1160?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "7abd725e63f6703fc46e4ec185eee1b43fd3bc39",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000106,orig:tx_id:000202,src:000173,op:arith8,pos:178,val:-2",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000106,orig:tx_id:000202,src:000173,op:arith8,pos:178,val:-2",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000106,orig:tx_id:000202,src:000173,op:arith8,pos:178,val:-2",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000106,orig:tx_id:000202,src:000173,op:arith8,pos:178,val:-2?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "89c231b4084b196b7c03f8a647652825bc5e3095",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000108,orig:tx_id:000223,sync:deserialize_transaction_2,src:000214",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000108,orig:tx_id:000223,sync:deserialize_transaction_2,src:000214",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000108,orig:tx_id:000223,sync:deserialize_transaction_2,src:000214",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000108,orig:tx_id:000223,sync:deserialize_transaction_2,src:000214?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "1372e581b181aa8723b2641170648a8635775a5c",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000110,src:000002,op:havoc,rep:4",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000110,src:000002,op:havoc,rep:4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000110,src:000002,op:havoc,rep:4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000110,src:000002,op:havoc,rep:4?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "ad161e2780d0922847623a4586818653af98c044",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000111,src:000002,op:havoc,rep:32",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000111,src:000002,op:havoc,rep:32",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000111,src:000002,op:havoc,rep:32",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000111,src:000002,op:havoc,rep:32?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "067e7a40f0ec0daae183def1a8cf9ee17fef1760",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000113,src:000002,op:havoc,rep:16",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000113,src:000002,op:havoc,rep:16",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000113,src:000002,op:havoc,rep:16",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000113,src:000002,op:havoc,rep:16?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "281ae3a119e71d04ceb54dcdd9234d746442e372",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000113,sync:deserialize_block_2,src:000112",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000113,sync:deserialize_block_2,src:000112",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000113,sync:deserialize_block_2,src:000112",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000113,sync:deserialize_block_2,src:000112?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "4a4eba1162d59db096cd18ab5b9e776a28582f60",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000114,src:000005,op:flip4,pos:263",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000114,src:000005,op:flip4,pos:263",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000114,src:000005,op:flip4,pos:263",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000114,src:000005,op:flip4,pos:263?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "bde24285f18d1408f8ca3d230902336038adeb88",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000116,src:000031+000101,op:splice,rep:16",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000116,src:000031+000101,op:splice,rep:16",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000116,src:000031+000101,op:splice,rep:16",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000116,src:000031+000101,op:splice,rep:16?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "c0b0d9ba0626bd2db456524fc93a774240e17f3d",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000116,src:000059,op:flip1,pos:157",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000116,src:000059,op:flip1,pos:157",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000116,src:000059,op:flip1,pos:157",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000116,src:000059,op:flip1,pos:157?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "eecb7ee5fa78ca347d53d9973bbdce8cf84a2f9b",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000117,src:000059,op:flip4,pos:157",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000117,src:000059,op:flip4,pos:157",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000117,src:000059,op:flip4,pos:157",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000117,src:000059,op:flip4,pos:157?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "dc0f08083a4e656067217a449dfb15bef59464c8",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000118,src:000018,op:flip1,pos:134",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000118,src:000018,op:flip1,pos:134",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000118,src:000018,op:flip1,pos:134",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000118,src:000018,op:flip1,pos:134?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "e2e1946c3185fc1f081f20bccfdedd2e8da00f2d",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000119,src:000082,op:flip1,pos:443",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000119,src:000082,op:flip1,pos:443",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000119,src:000082,op:flip1,pos:443",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000119,src:000082,op:flip1,pos:443?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "4e303edb43c67274e2162a6cb0a81fd43bb059e9",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000120,src:000029,op:havoc,rep:64",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000120,src:000029,op:havoc,rep:64",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000120,src:000029,op:havoc,rep:64",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000120,src:000029,op:havoc,rep:64?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "c1cc2047e011a1f1dd6ca72037adfad8e03cd14a",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000121,src:000077,op:arith8,pos:7636,val:-18",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000121,src:000077,op:arith8,pos:7636,val:-18",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000121,src:000077,op:arith8,pos:7636,val:-18",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000121,src:000077,op:arith8,pos:7636,val:-18?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "3034e6ec22b7e96ce97e82fcd5f5986e5814d862",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000121,src:000115,op:int16,pos:24501,val:+256",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000121,src:000115,op:int16,pos:24501,val:+256",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000121,src:000115,op:int16,pos:24501,val:+256",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000121,src:000115,op:int16,pos:24501,val:+256?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "7cc1fe2d7fcb99f9371facf1460d4d0d2f4ed0ed",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000122,src:000064,op:arith8,pos:95,val:-2",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000122,src:000064,op:arith8,pos:95,val:-2",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000122,src:000064,op:arith8,pos:95,val:-2",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000122,src:000064,op:arith8,pos:95,val:-2?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "bcc4a9ad590e2ce548a4a70439ce8367cb359d89",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000124,src:000118,op:int16,pos:2599,val:+256",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000124,src:000118,op:int16,pos:2599,val:+256",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000124,src:000118,op:int16,pos:2599,val:+256",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000124,src:000118,op:int16,pos:2599,val:+256?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "4619c12019bad12ace277ce10a78480d19a7f001",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000125,src:000080,op:flip2,pos:411",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000125,src:000080,op:flip2,pos:411",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000125,src:000080,op:flip2,pos:411",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000125,src:000080,op:flip2,pos:411?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "daa1bd75d14fa64b2301f56810f7d81df74ab97a",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000126,src:000018+000077,op:splice,rep:8",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000126,src:000018+000077,op:splice,rep:8",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000126,src:000018+000077,op:splice,rep:8",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000126,src:000018+000077,op:splice,rep:8?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "f8bd6207146c4d4aaa041985914b880de3bfac2f",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000126,src:000085,op:havoc,rep:8",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000126,src:000085,op:havoc,rep:8",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000126,src:000085,op:havoc,rep:8",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000126,src:000085,op:havoc,rep:8?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "681438cd52c3fe4299c827cd5fe25be5ac9f8b45",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000128,src:000108,op:havoc,rep:32",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000128,src:000108,op:havoc,rep:32",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000128,src:000108,op:havoc,rep:32",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000128,src:000108,op:havoc,rep:32?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "d91e8a5aaa0fbc55b723d3ef6dd32d96242e042a",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000129,src:000128,op:flip1,pos:1977",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000129,src:000128,op:flip1,pos:1977",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000129,src:000128,op:flip1,pos:1977",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000129,src:000128,op:flip1,pos:1977?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "4d42c5b36e5971085201c08505b42c7155d060e6",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000132,src:000131,op:flip1,pos:7872",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000132,src:000131,op:flip1,pos:7872",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000132,src:000131,op:flip1,pos:7872",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000132,src:000131,op:flip1,pos:7872?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "cd4c3ce431710333d87d927598afdf8aca1da514",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000134,src:000005+000128,op:splice,rep:4",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000134,src:000005+000128,op:splice,rep:4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000134,src:000005+000128,op:splice,rep:4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000134,src:000005+000128,op:splice,rep:4?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "7331dea6f759536737874c5d0cb8e8d5e2c6f7ea",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000135,src:000134,op:flip8,pos:972",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000135,src:000134,op:flip8,pos:972",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000135,src:000134,op:flip8,pos:972",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000135,src:000134,op:flip8,pos:972?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "9585fcb5f3d26301be4d945cc63d1a2f429c98a6",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000136,src:000134,op:arith8,pos:972,val:-2",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000136,src:000134,op:arith8,pos:972,val:-2",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000136,src:000134,op:arith8,pos:972,val:-2",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000136,src:000134,op:arith8,pos:972,val:-2?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "0057a42ea1e192d14a6c8e06692412324f34219d",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000137,src:000035+000128,op:splice,rep:4",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000137,src:000035+000128,op:splice,rep:4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000137,src:000035+000128,op:splice,rep:4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000137,src:000035+000128,op:splice,rep:4?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "e69de29bb2d1d6434b8b29ae775ad8c2e48c5391",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000155,src:000087,op:flip2,pos:126",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000155,src:000087,op:flip2,pos:126",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000155,src:000087,op:flip2,pos:126",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000155,src:000087,op:flip2,pos:126?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "55fb2c19a475c0af00fd2954f1a738616e0adea7",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000159,src:000113,op:havoc,rep:128",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000159,src:000113,op:havoc,rep:128",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000159,src:000113,op:havoc,rep:128",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/id:000159,src:000113,op:havoc,rep:128?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "45d515004de265846cb0509f2b93d0e4a075f26f",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000008,orig:363987a6ffb736444cc2a3b45a01b0c1.000000aa.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000008,orig:363987a6ffb736444cc2a3b45a01b0c1.000000aa.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000008,orig:363987a6ffb736444cc2a3b45a01b0c1.000000aa.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000008,orig:363987a6ffb736444cc2a3b45a01b0c1.000000aa.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "55bf2297c62a7c5cdb86c4fbb2093fa07a347a76",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000009,orig:8530f6c85f51e01782b6e9d970a22f7f.000013b1.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000009,orig:8530f6c85f51e01782b6e9d970a22f7f.000013b1.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000009,orig:8530f6c85f51e01782b6e9d970a22f7f.000013b1.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000009,orig:8530f6c85f51e01782b6e9d970a22f7f.000013b1.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "ab1dbfc67ccbac5c25887bf1391a277c7ab9fc76",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000015,orig:a7114a6c122f99cbbed5448562b7a513.000000aa.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000015,orig:a7114a6c122f99cbbed5448562b7a513.000000aa.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000015,orig:a7114a6c122f99cbbed5448562b7a513.000000aa.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000015,orig:a7114a6c122f99cbbed5448562b7a513.000000aa.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "ca69ca1ccedac4cc73a3f6313cc3d97acc6ca539",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000016,orig:003baefb49000000999bfe5b80000000.00000005.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000016,orig:003baefb49000000999bfe5b80000000.00000005.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000016,orig:003baefb49000000999bfe5b80000000.00000005.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000016,orig:003baefb49000000999bfe5b80000000.00000005.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "3ef74f4dc0977234ba4226712b8dc22f11ebfbc1",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000076,src:000000,op:havoc,rep:128",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000076,src:000000,op:havoc,rep:128",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000076,src:000000,op:havoc,rep:128",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000076,src:000000,op:havoc,rep:128?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "14868932306401b4efa8f48e04c22e31c79742f6",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000077,src:000000,op:havoc,rep:64",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000077,src:000000,op:havoc,rep:64",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000077,src:000000,op:havoc,rep:64",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000077,src:000000,op:havoc,rep:64?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "9296017668ab359375a46e688cad202afca47685",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000080,src:000000,op:havoc,rep:32",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000080,src:000000,op:havoc,rep:32",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000080,src:000000,op:havoc,rep:32",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000080,src:000000,op:havoc,rep:32?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "f6493451d0a48aa66d02d90c78dc585cff1c5078",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000084,src:000000+000044,op:splice,rep:8",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000084,src:000000+000044,op:splice,rep:8",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000084,src:000000+000044,op:splice,rep:8",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000084,src:000000+000044,op:splice,rep:8?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "67510b933f9037852ce3f8ef26b08d92f42d0911",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000121,src:000000+000033,op:splice,rep:8",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000121,src:000000+000033,op:splice,rep:8",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000121,src:000000+000033,op:splice,rep:8",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000121,src:000000+000033,op:splice,rep:8?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "8470d35d3c1db90db6429e789e66c67ccf7356ad",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000176,sync:deserialize_transaction_2,src:000163",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000176,sync:deserialize_transaction_2,src:000163",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000176,sync:deserialize_transaction_2,src:000163",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000176,sync:deserialize_transaction_2,src:000163?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "3c3ae9f9b74032ff2a39e5074223705fccacbede",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000176,sync:deserialize_transaction_master,src:000128",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000176,sync:deserialize_transaction_master,src:000128",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000176,sync:deserialize_transaction_master,src:000128",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000176,sync:deserialize_transaction_master,src:000128?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "904c365fe97ec22c1ef64473c143682f92f377d5",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000202,sync:deserialize_transaction_master,src:000162",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000202,sync:deserialize_transaction_master,src:000162",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000202,sync:deserialize_transaction_master,src:000162",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_block/input/tx_id:000202,sync:deserialize_transaction_master,src:000162?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "e133fd446cd647f427b480bd02bb7591b5b7aacc",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/132dec80e89477d962a7bd0d20947063.00000077.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/132dec80e89477d962a7bd0d20947063.00000077.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/132dec80e89477d962a7bd0d20947063.00000077.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/132dec80e89477d962a7bd0d20947063.00000077.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "ca7f418c475312e161dc6df0b4a26a27faed0d29",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/24fc2c1884453115fa0b1f2a758a8696.0000034c.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/24fc2c1884453115fa0b1f2a758a8696.0000034c.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/24fc2c1884453115fa0b1f2a758a8696.0000034c.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/24fc2c1884453115fa0b1f2a758a8696.0000034c.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "852f75b999be1250e10af706e26f2fe8bb9f6b0b",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/2d32100000000000323d000000000000.00000002.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/2d32100000000000323d000000000000.00000002.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/2d32100000000000323d000000000000.00000002.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/2d32100000000000323d000000000000.00000002.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+'0\n\\ No newline at end of file"
      },
      {
        "sha": "e80229f4e639a7921a829c525c93e80c26251356",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/3096e01ac84d84540d122233010feba6.000004cf.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/3096e01ac84d84540d122233010feba6.000004cf.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/3096e01ac84d84540d122233010feba6.000004cf.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/3096e01ac84d84540d122233010feba6.000004cf.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "c2538676eaf14f6f0fc6176786b860a29464481a",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/36413cf2bc1e6cf57d77335d0f348928.00000047.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/36413cf2bc1e6cf57d77335d0f348928.00000047.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/36413cf2bc1e6cf57d77335d0f348928.00000047.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/36413cf2bc1e6cf57d77335d0f348928.00000047.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "c0648a180eae79ed78a71dcdd8fe5a0019a1d8b0",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/467ad0f85000000078708ab670000000.00000004.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/467ad0f85000000078708ab670000000.00000004.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/467ad0f85000000078708ab670000000.00000004.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/467ad0f85000000078708ab670000000.00000004.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+[8\ru\n\\ No newline at end of file"
      },
      {
        "sha": "ec747fa47ddb81e9bf2d282011ed32aa4c59f932",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/51110622200000005266211140000000.00000004.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/51110622200000005266211140000000.00000004.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/51110622200000005266211140000000.00000004.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/51110622200000005266211140000000.00000004.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+null\n\\ No newline at end of file"
      },
      {
        "sha": "e22e541d116d8bdcf23d5cf86aafd3b1331a6f7b",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/57fd8d882850000078282d8da7800000.00000005.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/57fd8d882850000078282d8da7800000.00000005.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/57fd8d882850000078282d8da7800000.00000005.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/57fd8d882850000078282d8da7800000.00000005.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+[[]]h\n\\ No newline at end of file"
      },
      {
        "sha": "e4dbc88c0596022789423d67f67fe2970bc55554",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/70e4556ab8a8c7dcc2338dfa4891f4ae.000000a6.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/70e4556ab8a8c7dcc2338dfa4891f4ae.000000a6.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/70e4556ab8a8c7dcc2338dfa4891f4ae.000000a6.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/70e4556ab8a8c7dcc2338dfa4891f4ae.000000a6.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+{\"v\ufffd\ufffd\ufffd2-2651803231792492518\u0004\u00043\ufffd\u0336\ufffd\u0012*\ufffd\ufffdNkkkkkkkkk\ufffdR\ufffd\ufffd0\ufffd\ufffd5\ufffd\ufffd \ufffd\u0010\ubc5d0\ufffdd\ufffd:P\ufffd\ufffd\u0001V\ufffdP\ufffd\ufffdp\ufffd\":9 }\ufffd\ufffd \ufffd\u0010\ubc5d0\ufffdd\ufffd:P\ufffd\ufffd\u0001V\ufffd\u0001V\ufffdP\ufffd\ufffdp\ufffd\":9 P\ufffd\ufffd\u0001V\ufffdP\ufffd\ufffdp\ufffd\":9 u\ufffd\ufffd \ufffd\u0010\ubc5d0\ufffdd\ufffd:P\ufffd\ufffd\u0001V\ufffd\u0001V\ufffdP\ufffd\ufffdp\ufffd8:9 P\n\\ No newline at end of file"
      },
      {
        "sha": "a0f1e52c5630427e002e62a7547e4d4a1a14db3f",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/74606c62f539e4d5935525e03e92a40e.00000109.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/74606c62f539e4d5935525e03e92a40e.00000109.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/74606c62f539e4d5935525e03e92a40e.00000109.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/74606c62f539e4d5935525e03e92a40e.00000109.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "47d68df6fc1d7c2f1fb4e0ab851c464b65563fee",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/77ec8eda1dccae702efb36b0adf0e18f.00000165.honggfuzz.cov",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/77ec8eda1dccae702efb36b0adf0e18f.00000165.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/77ec8eda1dccae702efb36b0adf0e18f.00000165.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/77ec8eda1dccae702efb36b0adf0e18f.00000165.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,2 @@\n+{\"v\ufffd0\ufffdd\ufffd:P\ufffd\ufffd\u0001V\ufffdP\ufffd\ufffdp\ufffd\":9 ,\"\ufffd\ufffd83622040\ufffd\ufffdNkkkkkkkkk\ufffdR\ufffd\ufffdv\ufffd\ufffd5\ufffd\ufffd \ufffd\u0010\ubc5d0\ufffdd\ufffd:P\ufffd\ufffdV\ufffdP\ufffd\ufffdp\ufffd\":9 -7858362224003565858\u0001V\ufffdP\ufffd\ufffdp\ufffd\":9 v3Z\ufffdr\ufffd\u06e6\ufffd\ufffd\ufffd(\n+\b\ufffd?\ufffd\ufffd\ufffd\u0002\ufffd*\u001d\ufffdef\ufffd9i\"\ufffd*(\ufffd\u0002\ufffdr\ufffd\u0707\ufffd]\ufffd1\ufffd\ufffdY\ufffd\":9 u\ufffd\ufffd\u0017\ufffd\u0010\ubc5d0\ufffdd\ufffd:P\ufffd\ufffd\u0001V\ufffd\u0001V\ufffdP\ufffd\ufffdp\ufffd3\ufffd\u0336FFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFFF\n\\ No newline at end of file"
      },
      {
        "sha": "375c732672042d02a2a59734fc66c3ed3e2d8003",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/7bea4e2285010eb3cf4acb9b1203841b.0000007b.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/7bea4e2285010eb3cf4acb9b1203841b.0000007b.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/7bea4e2285010eb3cf4acb9b1203841b.0000007b.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/7bea4e2285010eb3cf4acb9b1203841b.0000007b.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "dec57403953ea21c47d43a2ba08958ecc3dfa5fb",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/7cd702cb9c81e396ff5433e1b716e343.0000056e.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/7cd702cb9c81e396ff5433e1b716e343.0000056e.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/7cd702cb9c81e396ff5433e1b716e343.0000056e.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/7cd702cb9c81e396ff5433e1b716e343.0000056e.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "8b137891791fe96927ad78e64b0aad7bded08bdc",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000002,orig:0ee00000000000000ee0000000000000.00000001.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000002,orig:0ee00000000000000ee0000000000000.00000001.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000002,orig:0ee00000000000000ee0000000000000.00000001.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000002,orig:0ee00000000000000ee0000000000000.00000001.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+"
      },
      {
        "sha": "92fbbcf058d9858bc61ec618113963fe2ee8bdc1",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000003,orig:108d4836be71e10731359b612fcb840b.000010b4.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000003,orig:108d4836be71e10731359b612fcb840b.000010b4.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000003,orig:108d4836be71e10731359b612fcb840b.000010b4.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000003,orig:108d4836be71e10731359b612fcb840b.000010b4.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "d80ce6b17f8426f997ed6807a0b2109cc675dfb8",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000004,orig:123fcb7f3b8bc4bc500d63157d0d25ff.00001d58.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000004,orig:123fcb7f3b8bc4bc500d63157d0d25ff.00001d58.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000004,orig:123fcb7f3b8bc4bc500d63157d0d25ff.00001d58.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000004,orig:123fcb7f3b8bc4bc500d63157d0d25ff.00001d58.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "a3731f31e8d4f0ed8f637ae8f9ca5f3bb89ebd9d",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000005,orig:12dfa93ad99f88fc4f2053d53480c3e5.00000d84.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000005,orig:12dfa93ad99f88fc4f2053d53480c3e5.00000d84.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000005,orig:12dfa93ad99f88fc4f2053d53480c3e5.00000d84.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000005,orig:12dfa93ad99f88fc4f2053d53480c3e5.00000d84.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "0b1e19e6591be4691e6b8e357e2fcc6a08481b62",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000007,orig:1e82e6b16644739bc1095df2d0075c0b.00000097.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000007,orig:1e82e6b16644739bc1095df2d0075c0b.00000097.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000007,orig:1e82e6b16644739bc1095df2d0075c0b.00000097.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000007,orig:1e82e6b16644739bc1095df2d0075c0b.00000097.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "74badb194b5e21f260812173e480810f77d7c035",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000008,orig:1e9b9cbf5c7959604b0d1c83097d1345.00001520.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000008,orig:1e9b9cbf5c7959604b0d1c83097d1345.00001520.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000008,orig:1e9b9cbf5c7959604b0d1c83097d1345.00001520.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000008,orig:1e9b9cbf5c7959604b0d1c83097d1345.00001520.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+[\"\"7\ufffd\ufffd-5\n\\ No newline at end of file"
      },
      {
        "sha": "b6b3dc08133a5510d69630331683a92259ce2b0e",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000009,orig:20ae411d2fd000002ffd211e40800000.00000005.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000009,orig:20ae411d2fd000002ffd211e40800000.00000005.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000009,orig:20ae411d2fd000002ffd211e40800000.00000005.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000009,orig:20ae411d2fd000002ffd211e40800000.00000005.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+30928\n\\ No newline at end of file"
      },
      {
        "sha": "804f8bffe64227a14fa86fdb5135ca26cea77c01",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000012,orig:288e5e0e600000002e5e0e48a0000000.00000004.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000012,orig:288e5e0e600000002e5e0e48a0000000.00000004.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000012,orig:288e5e0e600000002e5e0e48a0000000.00000004.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000012,orig:288e5e0e600000002e5e0e48a0000000.00000004.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+2.26\n\\ No newline at end of file"
      },
      {
        "sha": "890011b0b2f81cf8eae610016fd104f2548fe2d6",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000013,orig:2a4d69685000000078792d6a70000000.00000004.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000013,orig:2a4d69685000000078792d6a70000000.00000004.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000013,orig:2a4d69685000000078792d6a70000000.00000004.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000013,orig:2a4d69685000000078792d6a70000000.00000004.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+[7,5\n\\ No newline at end of file"
      },
      {
        "sha": "bf291a94b506a994996d8f49d8942c0aa3160d6e",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000017,orig:334c35e4651b52f2061d4fe13e60a281.00000214.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000017,orig:334c35e4651b52f2061d4fe13e60a281.00000214.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000017,orig:334c35e4651b52f2061d4fe13e60a281.00000214.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000017,orig:334c35e4651b52f2061d4fe13e60a281.00000214.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "a9bcb2436ed4bbde9590617579c25f1f2b273851",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000018,orig:397e6000000000002e59500000000000.00000002.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000018,orig:397e6000000000002e59500000000000.00000002.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000018,orig:397e6000000000002e59500000000000.00000002.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000018,orig:397e6000000000002e59500000000000.00000002.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+2+\n\\ No newline at end of file"
      },
      {
        "sha": "998d1104ebfd3c127bf8578a44fb04a84dc2ea0d",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000020,orig:3cde6000000000002e5cf00000000000.00000002.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000020,orig:3cde6000000000002e5cf00000000000.00000002.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000020,orig:3cde6000000000002e5cf00000000000.00000002.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000020,orig:3cde6000000000002e5cf00000000000.00000002.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+2-\n\\ No newline at end of file"
      },
      {
        "sha": "3cf20d57b0b8258463711cedd592007b0b5cdfe8",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000021,orig:3cf00000000000003cf0000000000000.00000001.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000021,orig:3cf00000000000003cf0000000000000.00000001.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000021,orig:3cf00000000000003cf0000000000000.00000001.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000021,orig:3cf00000000000003cf0000000000000.00000001.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+-\n\\ No newline at end of file"
      },
      {
        "sha": "32f64f4d836716819dc5fa9a1e09a29b428881df",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000023,orig:47c000000000000047c0000000000000.00000001.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000023,orig:47c000000000000047c0000000000000.00000001.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000023,orig:47c000000000000047c0000000000000.00000001.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000023,orig:47c000000000000047c0000000000000.00000001.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+t\n\\ No newline at end of file"
      },
      {
        "sha": "81750b96f9d83b395f285233d54ec0c9df9ab93d",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000024,orig:4e500000000000004e50000000000000.00000001.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000024,orig:4e500000000000004e50000000000000.00000001.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000024,orig:4e500000000000004e50000000000000.00000001.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000024,orig:4e500000000000004e50000000000000.00000001.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+{\n\\ No newline at end of file"
      },
      {
        "sha": "e0a6c6668c4b093cc3bcdf79b05693c024daa46f",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000026,orig:53cfa000000000005ff3900000000000.00000002.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000026,orig:53cfa000000000005ff3900000000000.00000002.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000026,orig:53cfa000000000005ff3900000000000.00000002.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000026,orig:53cfa000000000005ff3900000000000.00000002.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+fo\n\\ No newline at end of file"
      },
      {
        "sha": "4fc953f0d74fc29de4d80506a6205ec22da8033b",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000027,orig:54c0ad00000000002d20d4e000000000.00000003.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000027,orig:54c0ad00000000002d20d4e000000000.00000003.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000027,orig:54c0ad00000000002d20d4e000000000.00000003.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000027,orig:54c0ad00000000002d20d4e000000000.00000003.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+08j\n\\ No newline at end of file"
      },
      {
        "sha": "57608ac4fe66323c4ad253be470b70585cae8ec6",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000028,orig:5631cf21cf4a9e2d44df21cf21f52d69.0000000e.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000028,orig:5631cf21cf4a9e2d44df21cf21f52d69.0000000e.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000028,orig:5631cf21cf4a9e2d44df21cf21f52d69.0000000e.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000028,orig:5631cf21cf4a9e2d44df21cf21f52d69.0000000e.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "f3e2f82b4e96b18c2e6ccafee7f8ff27d90b2f0e",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000029,orig:57f82d882850000078282d8807800000.00000005.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000029,orig:57f82d882850000078282d8807800000.00000005.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000029,orig:57f82d882850000078282d8807800000.00000005.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000029,orig:57f82d882850000078282d8807800000.00000005.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+[[][h\n\\ No newline at end of file"
      },
      {
        "sha": "57025ac5abe52bce2785e9a824aaa1ad8270de88",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000031,orig:57fddbb82850000078287bbda7800000.00000005.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000031,orig:57fddbb82850000078287bbda7800000.00000005.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000031,orig:57fddbb82850000078287bbda7800000.00000005.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000031,orig:57fddbb82850000078287bbda7800000.00000005.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+[[4]h\n\\ No newline at end of file"
      },
      {
        "sha": "e969b4b3fb90323edbfb42848679603c20227a77",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000032,orig:5d2d2d5a700000002a2d2d2d70000000.00000004.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000032,orig:5d2d2d5a700000002a2d2d2d70000000.00000004.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000032,orig:5d2d2d5a700000002a2d2d2d70000000.00000004.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000032,orig:5d2d2d5a700000002a2d2d2d70000000.00000004.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+5eee\n\\ No newline at end of file"
      },
      {
        "sha": "774af0affe62a90ae0132c8fe738e5c83af0fc7c",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000035,orig:6d59154edc9107406929538201922082.00000248.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000035,orig:6d59154edc9107406929538201922082.00000248.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000035,orig:6d59154edc9107406929538201922082.00000248.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000035,orig:6d59154edc9107406929538201922082.00000248.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "b38d997affcfbbf028943f661e4e1915af01bd3c",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000037,orig:705e4e493e4e5e0e6f5e0e4e493e4e4a.00000008.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000037,orig:705e4e493e4e5e0e6f5e0e4e493e4e4a.00000008.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000037,orig:705e4e493e4e5e0e6f5e0e4e493e4e4a.00000008.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000037,orig:705e4e493e4e5e0e6f5e0e4e493e4e4a.00000008.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+2.227225\n\\ No newline at end of file"
      },
      {
        "sha": "8c08ecf4ec0dec94edaa60471942f97af037be87",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000040,orig:761f0bedebcfac240c2affec91115bfd.00000011.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000040,orig:761f0bedebcfac240c2affec91115bfd.00000011.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000040,orig:761f0bedebcfac240c2affec91115bfd.00000011.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000040,orig:761f0bedebcfac240c2affec91115bfd.00000011.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+2.322947127462735\n\\ No newline at end of file"
      },
      {
        "sha": "48b9a17c392ba5dfd4a70fdf79554d5f96ab7c71",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000041,orig:77c36463d3da4ba27232b488be74d652.00000443.honggfuzz.cov",
        "status": "added",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000041,orig:77c36463d3da4ba27232b488be74d652.00000443.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000041,orig:77c36463d3da4ba27232b488be74d652.00000443.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000041,orig:77c36463d3da4ba27232b488be74d652.00000443.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,4 @@\n+{\"v\ufffd0\ufffdd\ufffd:P\ufffd\ufffd\u0001V\ufffdh\rPu_I\ufffdB\ufffd\ufffd\ufffd\ufffd\u007fA\u01bfX\u0014\u0019\ufffd\u0004{?a0\ufffdG\ufffdl\ufffdw#\ufffdg\ufffd:\ufffd\ufffd\ufffdN\ufffd\u0490\u0014I\u001d^\ufffd\ufffdY\ufffd\u0016\ufffdO\ufffd\ufffdn\ufffd~X\ufffd\ufffd\u0018\ufffdj\ufffdo\ufffd\u000b\ufffd\u0006P\ufffd\ufffdp\ufffd\":9 ,\"\ufffd\ufffd836220t\ufffd\ufffdQ\ufffd\n+\u0001\ufffd\u000e\ufffd\ufffd\ufffdT\u001cO'2\ufffdE\ufffdO\ufffd\ufffd\ufffd\u000e\td\ufffd\ufffd\u0014\ufffd@@w\ufffd\ufffd\u001cY\u0012\ufffdWZ$\u001f\ufffdY(1\ufffd=y\u0017\ufffd=#i\ufffdx\ufffd\ufffd*\u0010,\ufffdD\u0010\ufffd\u06a2\ufffd\ufffd\ufffdbY'E\ufffd\u010d\ufffd2\u001f}\u0005#\ufffd'\ufffd\u0013Ja\ufffd\ufffd\u0007\ufffd\ufffd\ufffdL-;r]\ufffd\ufffdq\ufffdo\ufffdk\ufffd\ufffd\ufffd\ufffd\u0016\ufffd.\u0019\ufffdb\ufffd\u0003\ufffd\b\ufffd~\ufffd\ufffd40\ufffd\ufffdNkkkkkkkkk\ufffdR\ufffd\ufffdv\ufffd\ufffd5\ufffd\ufffd \ufffd\u0010\ubc5d08673586266809954039-P\ufffd\ufffdp\ufffd\":{\"v\ufffd0\ufffdd\ufffd:P\ufffd\ufffd\u0001V\ufffdh\rPu_I\ufffdB\ufffd\ufffd\ufffd\ufffd\u007fA\u01bfX\u0014\u0019\ufffd\u0004{?a0\ufffdG\ufffdl\ufffdw#\ufffdg\ufffd:\ufffd\ufffd\ufffdN\ufffd\u0490\u0014I\u001d^\ufffd\ufffdY\ufffd\u0016\ufffdO\ufffd\ufffdn\ufffd~X\ufffd\ufffd\u0018\ufffdj\ufffdo\ufffd\u000b\ufffd\u0006P\ufffd\ufffdp\ufffd\":9 ,\"\ufffd\ufffd836220t\ufffd\ufffdQ\ufffd\n+\u0001\ufffd\u000e\ufffd\ufffd\ufffdT\u001cO'2\ufffdE\ufffdO\ufffd\ufffd\ufffd\u000e\td\ufffd\ufffd\u0014\ufffd@@w\ufffd\ufffd\u001cY\u0012\ufffdWZ$\u001f\ufffdY(1\ufffd=y\u0017\ufffd=#i\ufffdx\ufffd\ufffd*\u0010,\ufffdD\u0010\ufffd\u06a2\ufffd\ufffd\ufffdbY'E\ufffd\u010d\ufffd2\u001f}\u0005#\ufffd'\ufffd\u0013Ja\ufffd\ufffd\u0007\ufffd\ufffd\ufffdL-;r]\ufffd\ufffdq\ufffdo\ufffdk\ufffd\ufffd\ufffd\ufffd\u0016\ufffd.\u0019\ufffdb\ufffd\u0003\ufffd\b\ufffd~\ufffd\ufffd40\ufffd\ufffdNkkkkkkkkk\ufffdR\ufffd\ufffdv\ufffd\ufffd5\ufffd\ufffd \ufffd\u0010\ubc5d08673586266809954039-P\ufffd\ufffdp\ufffd\":{\"v\ufffd0\ufffdd\ufffd:P\ufffd\ufffd\u0001V\ufffdh\rPu_I\ufffdB\ufffd\ufffd\ufffd\ufffd\u007fA\u01bfX\u0014\u0019\ufffd\u0004{?a0\ufffdG\ufffdl\ufffdw#\ufffdg\ufffd:\ufffd\ufffd\ufffdN\ufffd\u0490\u0014I\u001d^\ufffd\ufffdY\ufffd\u0016\ufffdO\ufffd\ufffdn\ufffd~X\ufffd\ufffd\u0018\ufffdj\ufffdo\ufffd\u000b\ufffd\u0006P\ufffd\ufffdp\ufffd\":9 ,\"\ufffd\ufffd836220t\ufffd\ufffdQ\ufffd\n+\u0001\ufffd\u000e\ufffd\ufffd\ufffdT\u001cO'2\ufffdE\ufffdO\ufffd\ufffd\ufffd\u000e\td\ufffd\ufffd\u0014\ufffd@@w\ufffd\ufffd\u001cY\u0012\ufffdWZ$\u001f\ufffdY(1\ufffd=y\u0017\ufffd=#i\ufffdx\ufffd\ufffd*\u0010,\ufffdD\u0010\ufffd\u06a2\ufffd\ufffd\ufffdbY'E\ufffd\u010d\ufffd2\u001f}\u0005#\ufffd'\ufffd\u0013Ja\ufffd\ufffd\u0007\ufffd\ufffd\ufffdL-;r]\ufffd\ufffdq\ufffdo\ufffdk\ufffd\ufffd\ufffd\ufffd\u0014\ufffd.\u0019\ufffdb\ufffd\u0003\ufffd\b\ufffd~\ufffd\ufffd40\ufffd\ufffdNkkkkkkkkk\ufffdR\ufffd\ufffdv\ufffd\ufffd5\ufffd\ufffd \ufffd\u0010\ubc5d08673586266809954039-P\ufffd\ufffdp\ufffd\":9 }}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}}||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||||,\f\ufffd\n\\ No newline at end of file"
      },
      {
        "sha": "a64e3821af1cfcbfec573444e965c2a209bc18b0",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000042,orig:77d7557f54289c91e217b85d989facd8.00000018.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000042,orig:77d7557f54289c91e217b85d989facd8.00000018.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000042,orig:77d7557f54289c91e217b85d989facd8.00000018.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000042,orig:77d7557f54289c91e217b85d989facd8.00000018.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+0.3329481833294518658410\n\\ No newline at end of file"
      },
      {
        "sha": "8e2f0bef135ba8e52e4110b6a5b0ebf19a528ca4",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000044,orig:78500000000000007850000000000000.00000001.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000044,orig:78500000000000007850000000000000.00000001.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000044,orig:78500000000000007850000000000000.00000001.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000044,orig:78500000000000007850000000000000.00000001.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+[\n\\ No newline at end of file"
      },
      {
        "sha": "93b6be2bccada2d5d43ea4665373a3bf6f93c11a",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000047,orig:7dc55518500000007865551df0000000.00000004.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000047,orig:7dc55518500000007865551df0000000.00000004.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000047,orig:7dc55518500000007865551df0000000.00000004.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000047,orig:7dc55518500000007865551df0000000.00000004.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+[\"\"]\n\\ No newline at end of file"
      },
      {
        "sha": "635e7b69697f29c120f179deec4be5973ab85fad",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000048,orig:7eedadd9a00e3b31fcb0884b16349723.00000014.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000048,orig:7eedadd9a00e3b31fcb0884b16349723.00000014.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000048,orig:7eedadd9a00e3b31fcb0884b16349723.00000014.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000048,orig:7eedadd9a00e3b31fcb0884b16349723.00000014.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+-7010909841481319489\n\\ No newline at end of file"
      },
      {
        "sha": "e664d1b53cc37be6fb7d127a39c45a4e777e0d70",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000049,orig:8d5ec8a00000000028ae6d5000000000.00000003.honggfuzz.cov",
        "status": "added",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000049,orig:8d5ec8a00000000028ae6d5000000000.00000003.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000049,orig:8d5ec8a00000000028ae6d5000000000.00000003.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000049,orig:8d5ec8a00000000028ae6d5000000000.00000003.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1,2 @@\n+6\n+\ufffd\n\\ No newline at end of file"
      },
      {
        "sha": "e26fee6a4cb0ba68bcafafe106a8607b06f79806",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000052,orig:a3a3fd51b18fec92a2a7beeffed8cae3.00000018.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000052,orig:a3a3fd51b18fec92a2a7beeffed8cae3.00000018.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000052,orig:a3a3fd51b18fec92a2a7beeffed8cae3.00000018.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000052,orig:a3a3fd51b18fec92a2a7beeffed8cae3.00000018.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "789cd047d7993dc1a16825312fcbfb7144b524b0",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000055,orig:a9f6021f1f65e0dc27de93336aabd27c.000018d9.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000055,orig:a9f6021f1f65e0dc27de93336aabd27c.000018d9.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000055,orig:a9f6021f1f65e0dc27de93336aabd27c.000018d9.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000055,orig:a9f6021f1f65e0dc27de93336aabd27c.000018d9.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "ad41a6b0f16eabc2bc5cb628eb1a7dfbbf772631",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000056,orig:ada1751ee6257eb5e41676e7942f2cee.0000018c.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000056,orig:ada1751ee6257eb5e41676e7942f2cee.0000018c.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000056,orig:ada1751ee6257eb5e41676e7942f2cee.0000018c.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000056,orig:ada1751ee6257eb5e41676e7942f2cee.0000018c.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "74515b632f3c8e0cccd875747eeccff623b6e79a",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000057,orig:aebd22b8a4eaea84473de8f7af92b9e8.00000010.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000057,orig:aebd22b8a4eaea84473de8f7af92b9e8.00000010.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000057,orig:aebd22b8a4eaea84473de8f7af92b9e8.00000010.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000057,orig:aebd22b8a4eaea84473de8f7af92b9e8.00000010.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+2.32294718384932\n\\ No newline at end of file"
      },
      {
        "sha": "75f66321d27e5379044b7e2c59a6fc097a0723b1",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000058,orig:bb2dbbbe28500000781e1b8d4b500000.00000005.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000058,orig:bb2dbbbe28500000781e1b8d4b500000.00000005.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000058,orig:bb2dbbbe28500000781e1b8d4b500000.00000005.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000058,orig:bb2dbbbe28500000781e1b8d4b500000.00000005.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+[{}]\ufffd\n\\ No newline at end of file"
      },
      {
        "sha": "fac0d071263aae1ad0ccf8f2fd551fc63fa524dd",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000059,orig:bfff1b9d411fec33960462c7c10fff37.00000015.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000059,orig:bfff1b9d411fec33960462c7c10fff37.00000015.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000059,orig:bfff1b9d411fec33960462c7c10fff37.00000015.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000059,orig:bfff1b9d411fec33960462c7c10fff37.00000015.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+-0.89846310859469617\n\\ No newline at end of file"
      },
      {
        "sha": "c99f102bb779243d4acade1cfb4bd03dbee2c245",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000061,orig:c10ddce82b9fbc814168922cd0a8c702.00000cd9.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000061,orig:c10ddce82b9fbc814168922cd0a8c702.00000cd9.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000061,orig:c10ddce82b9fbc814168922cd0a8c702.00000cd9.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000061,orig:c10ddce82b9fbc814168922cd0a8c702.00000cd9.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+[[4]]\ufffd\ufffd5\n\\ No newline at end of file"
      },
      {
        "sha": "91b7cf5b0d1567c2d6872537d3e84f1f0dd95fb6",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000062,orig:cba6d94806f7b566cb25b3da0ef0c600.0000111f.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000062,orig:cba6d94806f7b566cb25b3da0ef0c600.0000111f.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000062,orig:cba6d94806f7b566cb25b3da0ef0c600.0000111f.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000062,orig:cba6d94806f7b566cb25b3da0ef0c600.0000111f.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "40c54f911578bcd2daefed1779436c80c82e6f4c",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000063,orig:d40f0232cbdf1d50812e29256f1fd27c.000002e7.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000063,orig:d40f0232cbdf1d50812e29256f1fd27c.000002e7.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000063,orig:d40f0232cbdf1d50812e29256f1fd27c.000002e7.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000063,orig:d40f0232cbdf1d50812e29256f1fd27c.000002e7.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "115f5a5283efd95b0ad47028cd69a31e02bb57a2",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000064,orig:d706a550b181d5068db96ee44a07c478.000000b7.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000064,orig:d706a550b181d5068db96ee44a07c478.000000b7.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000064,orig:d706a550b181d5068db96ee44a07c478.000000b7.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000064,orig:d706a550b181d5068db96ee44a07c478.000000b7.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "5b4000e1c7bdbec8247e923ab9ed9d5a72eead8d",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000065,orig:d7b9d4f86a11cd25d4fef32dc4e27948.000001d6.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000065,orig:d7b9d4f86a11cd25d4fef32dc4e27948.000001d6.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000065,orig:d7b9d4f86a11cd25d4fef32dc4e27948.000001d6.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000065,orig:d7b9d4f86a11cd25d4fef32dc4e27948.000001d6.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "a63c371b0867fdfb2f051dd4bd7379e8cac8e0d6",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000067,orig:db66e14c0e5000004e2c61361b600000.00000005.honggfuzz.cov",
        "status": "added",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000067,orig:db66e14c0e5000004e2c61361b600000.00000005.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000067,orig:db66e14c0e5000004e2c61361b600000.00000005.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000067,orig:db66e14c0e5000004e2c61361b600000.00000005.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1",
        "patch": "@@ -0,0 +1 @@\n+{\\9\u0004\ufffd\n\\ No newline at end of file"
      },
      {
        "sha": "24f5f82ee724c539863214bfd78b28b29336bb6f",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000068,orig:e177cb82e1fdef491f2140a923efd3ed.000001d6.honggfuzz.cov",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000068,orig:e177cb82e1fdef491f2140a923efd3ed.000001d6.honggfuzz.cov",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000068,orig:e177cb82e1fdef491f2140a923efd3ed.000001d6.honggfuzz.cov",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000068,orig:e177cb82e1fdef491f2140a923efd3ed.000001d6.honggfuzz.cov?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "d6ddb44505b99507c83f8a1ecd7e84e88c645b68",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000080,src:000000,op:havoc,rep:32",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000080,src:000000,op:havoc,rep:32",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000080,src:000000,op:havoc,rep:32",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000080,src:000000,op:havoc,rep:32?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "5242083770f1896668f93823adcb0edcec99b25b",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000083,src:000000,op:havoc,rep:8",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000083,src:000000,op:havoc,rep:8",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000083,src:000000,op:havoc,rep:8",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000083,src:000000,op:havoc,rep:8?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "fec3dfd2d9b95e65bd5d355038d824ee5fbe17fd",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000084,src:000000,op:havoc,rep:4",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000084,src:000000,op:havoc,rep:4",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000084,src:000000,op:havoc,rep:4",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000084,src:000000,op:havoc,rep:4?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "5eb264df2df3d2679ea317a207613b3b3c49a95e",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000086,src:000000,op:havoc,rep:16",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000086,src:000000,op:havoc,rep:16",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000086,src:000000,op:havoc,rep:16",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000086,src:000000,op:havoc,rep:16?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "14c3739293239ab4d15efa1e4ac92ba900210cb9",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000090,src:000000,op:havoc,rep:8",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000090,src:000000,op:havoc,rep:8",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000090,src:000000,op:havoc,rep:8",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000090,src:000000,op:havoc,rep:8?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      },
      {
        "sha": "b5f49a5bdc09bf59aba04971ac138e98a0721b9b",
        "filename": "src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000093,src:000000,op:havoc,rep:128",
        "status": "added",
        "additions": 0,
        "deletions": 0,
        "changes": 0,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000093,src:000000,op:havoc,rep:128",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6bbb67abdddab9ca453baa0778f06472a31435e1/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000093,src:000000,op:havoc,rep:128",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/rust-bitcoin/fuzz/hfuzz_input/deserialize_decimal/input/id:000093,src:000000,op:havoc,rep:128?ref=6bbb67abdddab9ca453baa0778f06472a31435e1"
      }
    ]
  },
  {
    "sha": "87c014d0b3f31a167f027ad1b6e17216c7118caf",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4N2MwMTRkMGIzZjMxYTE2N2YwMjdhZDFiNmUxNzIxNmM3MTE4Y2Fm",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-18T19:33:05Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "Build the new rusty deps into the rusty lib\n\nNote that we have to use LTO to work around the missing der_lax\nsymbol in rust-secp256k1.\nSee https://github.com/rust-bitcoin/rust-secp256k1/issues/168",
      "tree": {
        "sha": "101d0551c2c8a0f7c08751bf1f5eead0d56845e8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/101d0551c2c8a0f7c08751bf1f5eead0d56845e8"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/87c014d0b3f31a167f027ad1b6e17216c7118caf",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/87c014d0b3f31a167f027ad1b6e17216c7118caf",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/87c014d0b3f31a167f027ad1b6e17216c7118caf",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/87c014d0b3f31a167f027ad1b6e17216c7118caf/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6bbb67abdddab9ca453baa0778f06472a31435e1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6bbb67abdddab9ca453baa0778f06472a31435e1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6bbb67abdddab9ca453baa0778f06472a31435e1"
      }
    ],
    "stats": {
      "total": 31,
      "additions": 28,
      "deletions": 3
    },
    "files": [
      {
        "sha": "fbe969e069a8b07226f13922a9c5b7602f2f5ebe",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 24,
        "deletions": 3,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/87c014d0b3f31a167f027ad1b6e17216c7118caf/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/87c014d0b3f31a167f027ad1b6e17216c7118caf/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=87c014d0b3f31a167f027ad1b6e17216c7118caf",
        "patch": "@@ -382,14 +382,35 @@ LIBBITCOIN_RUSTY_SRCS= \\\n LIBBITCOIN_RUSTY_TEST_SRCS= \\\n   rusty/src/test_bridge.rs\n \n+rusty/liblibc.rlib: rusty/libc/src/lib.rs $(wildcard rusty/libc/src/*.rs)\n+\t$(RUSTC) --crate-name libc $< --crate-type=rlib -g -O -C overflow-checks=on -C panic=unwind --out-dir $(@D) && \\\n+\ttouch $@\n+\n+rusty/libbech32.rlib: rusty/rust-bech32/src/lib.rs $(wildcard rusty/rust-bech32/src/*.rs)\n+\t$(RUSTC) --crate-name bech32 $< --crate-type=rlib -g -O -C overflow-checks=on -C panic=unwind --out-dir $(@D) && \\\n+\ttouch $@\n+\n+rusty/libbitcoin_hashes.rlib: rusty/bitcoin_hashes/src/lib.rs $(wildcard rusty/bitcoin_hashes/src/*.rs)\n+\t$(RUSTC) --crate-name bitcoin_hashes $< --crate-type=rlib -g -O -C overflow-checks=on -C panic=unwind --cfg 'feature=\"default\"' --cfg 'feature=\"std\"' --out-dir $(@D) && \\\n+\ttouch $@\n+\n+rusty/libsecp256k1.rlib: rusty/rust-secp256k1/src/lib.rs $(wildcard rusty/rust-secp256k1/src/*.rs) $(LIBSECP256K1)\n+\t$(RUSTC) --crate-name secp256k1 $< --crate-type=rlib -g -O -C overflow-checks=on -C panic=unwind --cfg 'feature=\"std\"' --cfg 'feature=\"dont_replace_c_symbols\"' --out-dir $(@D) && \\\n+\ttouch $@\n+\n+rusty/libbitcoin.rlib: rusty/libbech32.rlib rusty/libbitcoin_hashes.rlib rusty/libsecp256k1.rlib\n+rusty/libbitcoin.rlib: rusty/rust-bitcoin/src/lib.rs $(wildcard rusty/rust-bitcoin/src/*.rs) $(wildcard rusty/rust-bitcoin/src/*/*.rs) $(wildcard rusty/rust-bitcoin/src/*/*/*.rs)\n+\t$(RUSTC) --crate-name bitcoin $< --crate-type=rlib -g -O -C overflow-checks=on -C panic=unwind --out-dir $(@D) --extern bech32=$(@D)/libbech32.rlib --extern bitcoin_hashes=$(@D)/libbitcoin_hashes.rlib --extern secp256k1=$(@D)/libsecp256k1.rlib && \\\n+\ttouch $@\n+\n # We force overflow checks on so that any integer overflows result in a panic\n # instead of, eg, attempting to alloc 4GB of memory (though we will catch such\n # an alloc and refuse it, generating a panic instead).\n # Also force panics to unwind (instead of calling abort()) as we want to catch\n # panics in the Rust threads and simply close the thread, instead of bringing\n # down the rest of Bitcoin Core.\n-$(LIBBITCOIN_RUSTY): $(LIBBITCOIN_RUSTY_SRCS)\n-\t$(RUSTC) --crate-name rusty $< --target=$(RUST_TARGET) --crate-type=staticlib --emit=link -g -O -C overflow-checks=on -C panic=unwind --out-dir $(@D)\n+$(LIBBITCOIN_RUSTY): $(LIBBITCOIN_RUSTY_SRCS) rusty/libbitcoin.rlib rusty/liblibc.rlib\n+\t$(RUSTC) --crate-name rusty $< --target=$(RUST_TARGET) --crate-type=staticlib --emit=link -g -O -C lto=on -C overflow-checks=on -C panic=unwind --out-dir $(@D) -L dependency=$(@D) --extern libc=$(@D)/liblibc.rlib --extern bitcoin_hashes=$(@D)/libbitcoin_hashes.rlib --extern bitcoin=$(@D)/libbitcoin.rlib\n \ttouch $@\n \n # crypto primitives library\n@@ -696,7 +717,7 @@ LIBBITCOIN_RUST_LIBS += $(LIBBITCOIN_RUSTY_BRIDGE)\n \n RUSTY_TEST_BIN=rusty/test_rusty\n $(RUSTY_TEST_BIN): $(LIBBITCOIN_RUSTY_SRCS) $(LIBBITCOIN_RUSTY_TEST_SRCS)\n-\t$(RUSTC) --crate-name test_rusty $< --target=$(RUST_TARGET) --emit=link --test -C debuginfo=2 -C overflow-checks=on --out-dir $(@D)\n+\t$(RUSTC) --crate-name test_rusty $< --target=$(RUST_TARGET) --emit=link -C lto=on --test -C debuginfo=2 -C overflow-checks=on --out-dir $(@D) -L dependency=$(@D) --extern libc=$(@D)/liblibc.rlib --extern bitcoin_hashes=$(@D)/libbitcoin_hashes.rlib --extern bitcoin=$(@D)/libbitcoin.rlib\n \n ## FIXME: always build RUSTY_TEST_BIN the same as we do test_bitcoin\n RUSTY_CHECK=rusty-check"
      },
      {
        "sha": "db55e0d02ef7ae0d3b8dfb8242bc578b08b8bef6",
        "filename": "src/rusty/src/lib.rs",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/87c014d0b3f31a167f027ad1b6e17216c7118caf/src/rusty/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/87c014d0b3f31a167f027ad1b6e17216c7118caf/src/rusty/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/lib.rs?ref=87c014d0b3f31a167f027ad1b6e17216c7118caf",
        "patch": "@@ -4,6 +4,10 @@\n // warnings. Thus, we should disable such useless lints below.\n #![allow(deprecated)]\n \n+extern crate bitcoin;\n+extern crate bitcoin_hashes;\n+extern crate libc;\n+\n #[cfg(not(test))] mod bridge;\n #[cfg(test)] pub mod test_bridge;\n #[cfg(test)] pub use test_bridge as bridge;"
      }
    ]
  },
  {
    "sha": "640deb2332a668ebac69a3f072b784f526fab4ea",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NDBkZWIyMzMyYTY2OGViYWM2OWEzZjA3MmI3ODRmNTI2ZmFiNGVh",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-09-24T06:34:48Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "Add additional FFIs from rust to support a full-fledged P2P client",
      "tree": {
        "sha": "4330d55b6ed2bb05271026414ca6585e8afc3dbc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/4330d55b6ed2bb05271026414ca6585e8afc3dbc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/640deb2332a668ebac69a3f072b784f526fab4ea",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/640deb2332a668ebac69a3f072b784f526fab4ea",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/640deb2332a668ebac69a3f072b784f526fab4ea",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/640deb2332a668ebac69a3f072b784f526fab4ea/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "87c014d0b3f31a167f027ad1b6e17216c7118caf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/87c014d0b3f31a167f027ad1b6e17216c7118caf",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/87c014d0b3f31a167f027ad1b6e17216c7118caf"
      }
    ],
    "stats": {
      "total": 393,
      "additions": 390,
      "deletions": 3
    },
    "files": [
      {
        "sha": "2a8cbef40eddeceaf3a8bd5ec255b3e391e4f562",
        "filename": "src/logging.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/640deb2332a668ebac69a3f072b784f526fab4ea/src/logging.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/640deb2332a668ebac69a3f072b784f526fab4ea/src/logging.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.cpp?ref=640deb2332a668ebac69a3f072b784f526fab4ea",
        "patch": "@@ -150,6 +150,7 @@ const CLogCategoryDesc LogCategories[] =\n     {BCLog::COINDB, \"coindb\"},\n     {BCLog::QT, \"qt\"},\n     {BCLog::LEVELDB, \"leveldb\"},\n+    {BCLog::RUST, \"rust\"},\n     {BCLog::ALL, \"1\"},\n     {BCLog::ALL, \"all\"},\n };"
      },
      {
        "sha": "1030d72b485fba3beb09d82d72a977006a31a355",
        "filename": "src/logging.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/640deb2332a668ebac69a3f072b784f526fab4ea/src/logging.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/640deb2332a668ebac69a3f072b784f526fab4ea/src/logging.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/logging.h?ref=640deb2332a668ebac69a3f072b784f526fab4ea",
        "patch": "@@ -54,6 +54,7 @@ namespace BCLog {\n         COINDB      = (1 << 18),\n         QT          = (1 << 19),\n         LEVELDB     = (1 << 20),\n+        RUST        = (1 << 21),\n         ALL         = ~(uint32_t)0,\n     };\n "
      },
      {
        "sha": "e412155ec585f12c774e71c4433e146f6abbb871",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/640deb2332a668ebac69a3f072b784f526fab4ea/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/640deb2332a668ebac69a3f072b784f526fab4ea/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=640deb2332a668ebac69a3f072b784f526fab4ea",
        "patch": "@@ -1008,7 +1008,7 @@ static bool MaybePunishNodeForTx(NodeId nodeid, const TxValidationState& state,\n // active chain if they are no more than a month older (both in time, and in\n // best equivalent proof of work) than the best header chain we know about and\n // we fully-validated them at some point.\n-static bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n+bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main)\n {\n     AssertLockHeld(cs_main);\n     if (::ChainActive().Contains(pindex)) return true;"
      },
      {
        "sha": "1449ede95e8d2b3ec44595080ff4332f67ccc49c",
        "filename": "src/net_processing.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/640deb2332a668ebac69a3f072b784f526fab4ea/src/net_processing.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/640deb2332a668ebac69a3f072b784f526fab4ea/src/net_processing.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.h?ref=640deb2332a668ebac69a3f072b784f526fab4ea",
        "patch": "@@ -89,4 +89,7 @@ bool GetNodeStateStats(NodeId nodeid, CNodeStateStats &stats);\n /** Relay transaction to every node */\n void RelayTransaction(const uint256&, const CConnman& connman);\n \n+/** Check if we're allowed to leak that we know that this block exists */\n+bool BlockRequestAllowed(const CBlockIndex* pindex, const Consensus::Params& consensusParams) EXCLUSIVE_LOCKS_REQUIRED(cs_main);\n+\n #endif // BITCOIN_NET_PROCESSING_H"
      },
      {
        "sha": "93715700b245ff237bc564b582a0f436e42e3e5a",
        "filename": "src/rusty/src/bridge.rs",
        "status": "modified",
        "additions": 220,
        "deletions": 2,
        "changes": 222,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/640deb2332a668ebac69a3f072b784f526fab4ea/src/rusty/src/bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/640deb2332a668ebac69a3f072b784f526fab4ea/src/rusty/src/bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/bridge.rs?ref=640deb2332a668ebac69a3f072b784f526fab4ea",
        "patch": "@@ -1,4 +1,39 @@\n-use std::ffi::c_void;\n+use std::ffi::{c_void, CString};\n+use std::ptr;\n+use std::io::Cursor;\n+\n+use bitcoin::blockdata::block::BlockHeader;\n+use bitcoin::consensus::Encodable;\n+use bitcoin::util::uint::Uint256;\n+\n+#[inline]\n+pub fn slice_to_u64_le(slice: &[u8]) -> u64 {\n+    assert_eq!(slice.len(), 8);\n+    (slice[0] as u64) << 0*8 |\n+    (slice[1] as u64) << 1*8 |\n+    (slice[2] as u64) << 2*8 |\n+    (slice[3] as u64) << 3*8 |\n+    (slice[4] as u64) << 4*8 |\n+    (slice[5] as u64) << 5*8 |\n+    (slice[6] as u64) << 6*8 |\n+    (slice[7] as u64) << 7*8\n+}\n+\n+#[repr(C)]\n+struct ThirtyTwoBytes {\n+    pub val: [u8; 32],\n+}\n+impl ThirtyTwoBytes {\n+    pub fn to_uint_le(&self) -> Uint256 {\n+        Uint256([\n+            slice_to_u64_le(&self.val[0*8..1*8]),\n+            slice_to_u64_le(&self.val[1*8..2*8]),\n+            slice_to_u64_le(&self.val[2*8..3*8]),\n+            slice_to_u64_le(&self.val[3*8..4*8])\n+        ])\n+    }\n+}\n+\n extern \"C\" {\n     pub fn rusty_IsInitialBlockDownload() -> bool;\n     pub fn rusty_ShutdownRequested() -> bool;\n@@ -15,15 +50,55 @@ extern \"C\" {\n     /// Guaranteed to never be NULL (but may be genesis)\n     fn rusty_GetChainTip() -> *const c_void;\n \n+    /// Gets a CBlockIndex* pointer (casted to a c_void) representing the current best\n+    /// (not known to be invalid) header.\n+    /// Guaranteed to never be NULL (but may be genesis)\n+    fn rusty_GetBestHeader() -> *const c_void;\n+\n     /// Gets a CBlockIndex* pointer (casted to a c_void) representing the genesis block.\n     /// Guaranteed to never be NULL\n     fn rusty_GetGenesisIndex() -> *const c_void;\n \n+    /// Finds a CBlockIndex* for a given block hash, or NULL if none is found\n+    fn rusty_HashToIndex(hash: *const u8) -> *const c_void;\n+\n     /// Gets the height of a given CBlockIndex* pointer\n     fn rusty_IndexToHeight(index: *const c_void) -> i32;\n \n     /// Gets the hash of a given CBlockIndex* pointer\n     fn rusty_IndexToHash(index: *const c_void) -> *const u8;\n+\n+    /// Gets the immediate ancestor of the given index\n+    fn rusty_IndexToPrev(index: *const c_void) -> *const c_void;\n+\n+    /// Gets the ancestor of the given index at the given height\n+    fn rusty_IndexToAncestor(index: *const c_void, height: i32) -> *const c_void;\n+\n+    /// Gets the total (estimated) work that went into creating index, as a little endian u256\n+    fn rusty_IndexToWork(index: *const c_void) -> ThirtyTwoBytes;\n+\n+    /// Checks whether we currently have a copy of the block this index points to on disk.\n+    fn rusty_IndexToHaveData(index: *const c_void) -> bool;\n+\n+    /// Checks whether the block the given index points to is not known to be invalid.\n+    fn rusty_IndexToNotInvalid(index: *const c_void, invalid_parent_ok: bool) -> bool;\n+\n+    /// Gets nMinimumChainWork\n+    fn rusty_MinimumChainWork() -> ThirtyTwoBytes;\n+\n+    /// Serializes the header pointed to by the CBlockIndex* into eighty_bytes_dest.\n+    fn rusty_SerializeIndex(index: *const c_void, eighty_bytes_dest: *mut u8);\n+\n+    /// Given a CBlockIndex* pointer, gets a pointer/length pair for the serialized block,\n+    /// returning an opaque resource pointer, which must be deallocated (invalidating the\n+    /// returned serialized data pointer) via rusty_FreeBlockData().\n+    fn rusty_GetBlockData(index: *const c_void, resdata: *mut *const u8, reslen: *mut u64) -> *const c_void;\n+\n+    /// Frees the data allocated by rusty_GetBlockData().\n+    fn rusty_FreeBlockData(dataresource: *const c_void);\n+\n+    /// Returns true if we're allowed to expose knowledge of the given CBlockIndex* to peers.\n+    fn rusty_BlockRequestAllowed(pindexvoid: *const c_void) -> bool;\n }\n \n /// Connects the given array of (sorted, in chain order) headers (in serialized, 80-byte form).\n@@ -35,6 +110,18 @@ pub fn connect_headers_flat_bytes(headers: &[u8]) -> Option<BlockIndex> {\n     if index.is_null() { None } else { Some(BlockIndex { index }) }\n }\n \n+/// Connects the given array of (sorted, in chain order) headers. Note that this is slightly less\n+/// effecient than the connect_headers_flat_bytes version as the headers are reserialized before\n+/// handing them to C++.\n+/// Returns the last header which was connected, if any.\n+pub fn connect_headers(headers: &[BlockHeader]) -> Option<BlockIndex> {\n+    let mut encoder = Cursor::new(Vec::with_capacity(headers.len() * 80));\n+    for header in headers {\n+        header.consensus_encode(&mut encoder).unwrap();\n+    }\n+    connect_headers_flat_bytes(&encoder.into_inner())\n+}\n+\n /// Processes a new block, in serialized form.\n /// blockindex_requested_by_state should be set *only* if the given BlockIndex was provided by\n /// BlockProviderState::get_next_block_to_download(), and may be set to None always.\n@@ -57,12 +144,61 @@ impl BlockIndex {\n         }\n     }\n \n+    pub fn best_header() -> Self {\n+        Self {\n+            index: unsafe { rusty_GetBestHeader() },\n+        }\n+    }\n+\n+    /// Gets the a block index with the given hash. Will *not* return old, stale blocks for which\n+    /// we shouldn't reveal knowledge of a block.\n+    /// best_tip optimizes this check somewhat, as it can otherwise be expensive (read: take\n+    /// cs_main).\n+    pub fn get_from_hash(hash: &[u8; 32], best_tip: Option<BlockIndex>) -> Option<Self> {\n+        let index = unsafe { rusty_HashToIndex(hash.as_ptr()) };\n+        if index.is_null() {\n+            None\n+        } else {\n+            let res = Self { index };\n+            if let Some(tip) = best_tip {\n+                if tip.get_ancestor(res.height()) == Some(res) {\n+                    return Some(res);\n+                }\n+            }\n+            if res.is_knowledge_public() {\n+                Some(Self { index })\n+            } else { None }\n+        }\n+    }\n+\n     pub fn genesis() -> Self {\n         Self {\n             index: unsafe { rusty_GetGenesisIndex() },\n         }\n     }\n \n+    /// Gets the ancestor immediately prior to this block.\n+    /// Returns Some for any block except genesis\n+    pub fn get_prev(&self) -> Option<Self> {\n+        let index = unsafe { rusty_IndexToPrev(self.index) };\n+        if index.is_null() {\n+            None\n+        } else {\n+            Some(Self { index })\n+        }\n+    }\n+\n+    /// Gets the ancestor 1008 blocks prior to this one, if any\n+    pub fn get_ancestor(&self, height: i32) -> Option<Self> {\n+        if height < 0 { return None; }\n+        let index = unsafe { rusty_IndexToAncestor(self.index, height) };\n+        if index.is_null() {\n+            None\n+        } else {\n+            Some(Self { index })\n+        }\n+    }\n+\n     pub fn height(&self) -> i32 {\n         unsafe { rusty_IndexToHeight(self.index) }\n     }\n@@ -86,6 +222,63 @@ impl BlockIndex {\n         }\n         res\n     }\n+\n+    /// Gets the total number of expected double-SHA256 operations required to build a chain from\n+    /// genesis to this block.\n+    pub fn total_work(&self) -> Uint256 {\n+        unsafe { rusty_IndexToWork(self.index) }.to_uint_le()\n+    }\n+\n+    /// Returns true if we have data for this block\n+    pub fn have_block(&self) -> bool {\n+        unsafe { rusty_IndexToHaveData(self.index) }\n+    }\n+\n+    /// Returns true if this block is not known to be invalid.\n+    /// Note that this is distinct from being valid, as the block may not have been verified yet.\n+    /// This *may* include blocks who's parent is invalid (and thus cannot be considered \"valid\"),\n+    /// but this is not guaranteed. If you want a guarantee that a block has no invalid parents,\n+    /// set the boolean \"invalid_parent_ok\" arg to false and the C++ side will walk the tree up\n+    /// until it finds a valid parent (or genesis).\n+    pub fn not_invalid(&self, invalid_parent_ok: bool) -> bool {\n+        unsafe { rusty_IndexToNotInvalid(self.index, invalid_parent_ok) }\n+    }\n+\n+    /// Gets the full, serialized, header\n+    pub fn header_bytes(&self) -> [u8; 80] {\n+        let mut ser = [0u8; 80];\n+        unsafe { rusty_SerializeIndex(self.index, (&mut ser).as_mut_ptr()); }\n+        ser\n+    }\n+\n+    /// Gets the full, serialized, block, in witness form\n+    pub fn block_bytes(&self) -> Vec<u8> {\n+        let mut len: u64 = 0;\n+        let mut data: *const u8 = ptr::null();\n+        let resource = unsafe { rusty_GetBlockData(self.index, &mut data, &mut len) };\n+        assert!(!data.is_null());\n+        let mut res = Vec::new();\n+        res.resize(len as usize, 0);\n+        unsafe { ptr::copy_nonoverlapping(data, res.as_mut_ptr(), len as usize); }\n+        unsafe { rusty_FreeBlockData(resource) };\n+        res\n+    }\n+\n+    /// Returns true if we're allowed to leak to our peers the fact that we know about this header.\n+    /// In general, once a header is old, if its not on the best chain, we want to avoid letting\n+    /// anyone know we heard about it, to prevent long-term node fingerprinting attacks.\n+    /// It shouldn't practically be possible to get a !is_knowledge_public BlockIndex via the\n+    /// current API, modulo if our best header forks off from our best chain long ago, and you walk\n+    /// backwards from our best header.\n+    pub fn is_knowledge_public(&self) -> bool {\n+        unsafe { rusty_BlockRequestAllowed(self.index) }\n+    }\n+}\n+\n+/// Gets the minimum amount of total work (ie BlockIndex::total_work()) that a chain should have\n+/// before any blocks along that chain should be stored.\n+pub fn get_min_chainwork() -> Uint256 {\n+    unsafe { rusty_MinimumChainWork() }.to_uint_le()\n }\n \n extern \"C\" {\n@@ -104,9 +297,18 @@ extern \"C\" {\n     fn rusty_ProviderStateGetNextDownloads(providerindexvoid: *mut c_void, has_witness: bool) -> *const c_void;\n }\n \n+/// Tracks a generic block provider's current best tip and allows querying for which blocks to\n+/// download given a best tip, handling reorgs appropriately. Any blocks which are downloaded from\n+/// the provider based on a get_next_block_to_download() call should be fed to connect_bock with\n+/// the blockindex_requested_by_state parameter set to the returned BlockIndex (or a clone()\n+/// thereof).\n+///\n+/// Note that the most-recently-set current best is tracked independently from the C++ logic,\n+/// making it at least slightly more robust against failure in the C++ code.\n pub struct BlockProviderState {\n     // TODO: We should be smarter than to keep a copy of the current best pointer twice, but\n-    // crossing the FFI boundary just to look it up again sucks.\n+    // crossing the FFI boundary just to look it up again sucks (and we want to be a bit more\n+    // robust).\n     current_best: BlockIndex,\n     state: *mut c_void,\n }\n@@ -145,3 +347,19 @@ impl Drop for BlockProviderState {\n         unsafe { rusty_ProviderStateFree(self.state) };\n     }\n }\n+\n+extern \"C\" {\n+    // General utilities. Wrapped in safe wrappers below.\n+\n+    /// Log some string\n+    fn rusty_LogLine(string: *const u8, debug: bool);\n+}\n+\n+pub fn log_line(line: &str, debug: bool) {\n+    let cstr = match CString::new(line) {\n+        Ok(cstr) => cstr,\n+        Err(_) => CString::new(\"Attempted to log an str with nul bytes in it?!\").unwrap(),\n+    };\n+    let ptr = cstr.as_bytes_with_nul();\n+    unsafe { rusty_LogLine(ptr.as_ptr(), debug); }\n+}"
      },
      {
        "sha": "1a8824c3c252c02383cb8c511c135af33e898313",
        "filename": "src/rusty/src/cpp_bridge.cpp",
        "status": "modified",
        "additions": 109,
        "deletions": 0,
        "changes": 109,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/640deb2332a668ebac69a3f072b784f526fab4ea/src/rusty/src/cpp_bridge.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/640deb2332a668ebac69a3f072b784f526fab4ea/src/rusty/src/cpp_bridge.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/cpp_bridge.cpp?ref=640deb2332a668ebac69a3f072b784f526fab4ea",
        "patch": "@@ -1,8 +1,10 @@\n #include <chainparams.h>\n+#include <net_processing.h>\n #include <validation.h>\n #include <shutdown.h>\n #include <serialize.h>\n #include <consensus/validation.h>\n+#include <logging.h>\n \n /** A class that deserializes a single thing one time. */\n class InputStream\n@@ -92,13 +94,26 @@ const void* rusty_GetChainTip() {\n     return tip;\n }\n \n+const void* rusty_GetBestHeader() {\n+    LOCK(cs_main);\n+    assert(pindexBestHeader != nullptr);\n+    return pindexBestHeader;\n+}\n+\n const void* rusty_GetGenesisIndex() {\n     LOCK(cs_main);\n     const CBlockIndex* genesis = ::ChainActive().Genesis();\n     assert(genesis != nullptr);\n     return genesis;\n }\n \n+const void* rusty_HashToIndex(const uint8_t* hash_ptr) {\n+    uint256 hash;\n+    memcpy(hash.begin(), hash_ptr, 32);\n+    LOCK(cs_main);\n+    return LookupBlockIndex(hash);\n+}\n+\n int32_t rusty_IndexToHeight(const void* pindexvoid) {\n     const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n     assert(pindex != nullptr);\n@@ -111,6 +126,92 @@ const uint8_t* rusty_IndexToHash(const void* pindexvoid) {\n     return pindex->phashBlock->begin();\n }\n \n+const void* rusty_IndexToPrev(const void* pindexvoid) {\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    return pindex->pprev;\n+}\n+\n+const void* rusty_IndexToAncestor(const void* pindexvoid, int32_t height) {\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    if (height < 0 || height > pindex->nHeight) {\n+        return nullptr;\n+    }\n+    if (height == pindex->nHeight) { return pindex; }\n+    return pindex->GetAncestor(height);\n+}\n+\n+// Create a dummy enum to return a 32 byte array, ensuring changes in uint256 don't break things.\n+// The compiler should optimize this away for us.\n+struct ThirtyTwoBytes {\n+    uint8_t val[32];\n+};\n+ThirtyTwoBytes rusty_IndexToWork(const void* pindexvoid) {\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    ThirtyTwoBytes ret;\n+    uint256 work = ArithToUint256(pindex->nChainWork);\n+    memcpy(ret.val, work.begin(), 32);\n+    return ret;\n+}\n+\n+ThirtyTwoBytes rusty_MinimumChainWork() {\n+    ThirtyTwoBytes ret;\n+    uint256 work = ArithToUint256(nMinimumChainWork);\n+    memcpy(ret.val, work.begin(), 32);\n+    return ret;\n+}\n+\n+bool rusty_IndexToHaveData(const void* pindexvoid) {\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    LOCK(cs_main);\n+    return (pindex->nStatus & BLOCK_HAVE_DATA) != 0;\n+}\n+\n+bool rusty_IndexToNotInvalid(const void* pindexvoid, bool invalid_parent_ok) {\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    LOCK(cs_main);\n+    if (pindex->nStatus & BLOCK_FAILED_MASK) { return false; }\n+    if (pindex->IsValid(BLOCK_VALID_SCRIPTS)) { return true; }\n+    if (invalid_parent_ok) { return true; }\n+    while (pindex->pprev && !pindex->pprev->IsValid(BLOCK_VALID_SCRIPTS)) {\n+        pindex = pindex->pprev;\n+        if (pindex->nStatus & BLOCK_FAILED_MASK) { return false; }\n+    }\n+    return true;\n+}\n+\n+void rusty_SerializeIndex(const void* pindexvoid, unsigned char* eighty_bytes_dest) {\n+    //TODO: Could optimize this a bit\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    std::vector<unsigned char> ser;\n+    ser.reserve(80);\n+    CVectorWriter(SER_NETWORK, PROTOCOL_VERSION, ser, 0) << pindex->GetBlockHeader();\n+    assert(ser.size() == 80);\n+    memcpy(eighty_bytes_dest, ser.data(), 80);\n+}\n+\n+void* rusty_GetBlockData(const void* pindexvoid, const unsigned char **data, uint64_t *datalen) {\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    std::vector<uint8_t> *res = new std::vector<uint8_t>();\n+    if (!ReadRawBlockFromDisk(*res, pindex, Params().MessageStart())) {\n+        delete res;\n+        return nullptr;\n+    }\n+    *data = res->data();\n+    *datalen = res->size();\n+    return (void*)res;\n+}\n+\n+void rusty_FreeBlockData(const void* vectorvoid) {\n+    std::vector<uint8_t> *vec = (std::vector<uint8_t>*) vectorvoid;\n+    delete vec;\n+}\n+\n+bool rusty_BlockRequestAllowed(const void* pindexvoid) {\n+    LOCK(cs_main);\n+    const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n+    return BlockRequestAllowed(pindex, Params().GetConsensus());\n+}\n+\n void* rusty_ProviderStateInit(const void* pindexvoid) {\n     const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n     BlockProviderState* state = new BlockProviderState;\n@@ -137,4 +238,12 @@ const void* rusty_ProviderStateGetNextDownloads(void* providerindexvoid, bool ha\n     return blocks.empty() ? nullptr : blocks[0];\n }\n \n+void rusty_LogLine(const unsigned char* str, bool debug) {\n+    if (debug) {\n+        LogPrint(BCLog::RUST, \"%s\\n\", str);\n+    } else {\n+        LogPrintf(\"%s\\n\", str);\n+    }\n+}\n+\n }"
      },
      {
        "sha": "71edcbf9751c23b271e82ee7671dab76cf639dc4",
        "filename": "src/rusty/src/test_bridge.rs",
        "status": "modified",
        "additions": 55,
        "deletions": 0,
        "changes": 55,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/640deb2332a668ebac69a3f072b784f526fab4ea/src/rusty/src/test_bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/640deb2332a668ebac69a3f072b784f526fab4ea/src/rusty/src/test_bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/test_bridge.rs?ref=640deb2332a668ebac69a3f072b784f526fab4ea",
        "patch": "@@ -1,5 +1,8 @@\n ///! \"bridge\" to C++ code without any backing C++ code. Used for shimming in dummies for testing.\n \n+use bitcoin::blockdata::block::BlockHeader;\n+use bitcoin::util::uint::Uint256;\n+\n #[no_mangle]\n pub unsafe extern \"C\" fn rusty_IsInitialBlockDownload() -> bool { unimplemented!(); }\n \n@@ -10,6 +13,10 @@ pub fn connect_headers_flat_bytes(_headers: &[u8]) -> Option<BlockIndex> {\n     unimplemented!();\n }\n \n+pub fn connect_headers(_headers: &[BlockHeader]) -> Option<BlockIndex> {\n+    unimplemented!();\n+}\n+\n pub fn connect_block(_blockdata: &[u8], _blockindex_requested_by_state: Option<BlockIndex>) {\n     unimplemented!();\n }\n@@ -22,10 +29,26 @@ impl BlockIndex {\n         unimplemented!();\n     }\n \n+    pub fn best_header() -> Self {\n+        unimplemented!();\n+    }\n+\n+    pub fn get_from_hash(_hash: &[u8; 32], _best_tip: Option<Self>) -> Option<Self> {\n+        unimplemented!();\n+    }\n+\n     pub fn genesis() -> Self {\n         unimplemented!();\n     }\n \n+    pub fn get_prev(&self) -> Option<Self> {\n+        unimplemented!();\n+    }\n+\n+    pub fn get_ancestor(&self, _height: i32) -> Option<Self> {\n+        unimplemented!();\n+    }\n+\n     pub fn height(&self) -> i32 {\n         unimplemented!();\n     }\n@@ -37,6 +60,34 @@ impl BlockIndex {\n     pub fn hash_hex(&self) -> String {\n         unimplemented!();\n     }\n+\n+    pub fn total_work(&self) -> Uint256 {\n+        unimplemented!();\n+    }\n+\n+    pub fn have_block(&self) -> bool {\n+        unimplemented!();\n+    }\n+\n+    pub fn not_invalid(&self, _invalid_parent_ok: bool) -> bool {\n+        unimplemented!();\n+    }\n+\n+    pub fn header_bytes(&self) -> [u8; 80] {\n+        unimplemented!();\n+    }\n+\n+    pub fn block_bytes(&self) -> Vec<u8> {\n+        unimplemented!();\n+    }\n+\n+    pub fn is_knowledge_public(&self) -> bool {\n+        unimplemented!();\n+    }\n+}\n+\n+pub fn get_min_chainwork() -> Uint256 {\n+    unimplemented!();\n }\n \n pub struct BlockProviderState { }\n@@ -58,3 +109,7 @@ impl BlockProviderState {\n         unimplemented!();\n     }\n }\n+\n+pub fn log_line(_line: &str, _debug: bool) {\n+    unimplemented!();\n+}"
      }
    ]
  },
  {
    "sha": "3f0598325ed55a4fc1aee4eb51404f6973906f38",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozZjA1OTgzMjVlZDU1YTRmYzFhZWU0ZWI1MTQwNGY2OTczOTA2ZjM4",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-28T21:32:32Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "Add a FastRandomContext wrapper in the Rust FFI bridge",
      "tree": {
        "sha": "994ff5ae3ca4c49daddf9642c12e070ca37f6caf",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/994ff5ae3ca4c49daddf9642c12e070ca37f6caf"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/3f0598325ed55a4fc1aee4eb51404f6973906f38",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3f0598325ed55a4fc1aee4eb51404f6973906f38",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/3f0598325ed55a4fc1aee4eb51404f6973906f38",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3f0598325ed55a4fc1aee4eb51404f6973906f38/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "640deb2332a668ebac69a3f072b784f526fab4ea",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/640deb2332a668ebac69a3f072b784f526fab4ea",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/640deb2332a668ebac69a3f072b784f526fab4ea"
      }
    ],
    "stats": {
      "total": 77,
      "additions": 77,
      "deletions": 0
    },
    "files": [
      {
        "sha": "6a6a34655f163e09762c8561337f1bc47d167702",
        "filename": "src/rusty/src/bridge.rs",
        "status": "modified",
        "additions": 43,
        "deletions": 0,
        "changes": 43,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3f0598325ed55a4fc1aee4eb51404f6973906f38/src/rusty/src/bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3f0598325ed55a4fc1aee4eb51404f6973906f38/src/rusty/src/bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/bridge.rs?ref=3f0598325ed55a4fc1aee4eb51404f6973906f38",
        "patch": "@@ -363,3 +363,46 @@ pub fn log_line(line: &str, debug: bool) {\n     let ptr = cstr.as_bytes_with_nul();\n     unsafe { rusty_LogLine(ptr.as_ptr(), debug); }\n }\n+\n+extern \"C\" {\n+    // Utilities to wrap the C++ FastRandomContext (essentially a ChaCha stream)\n+\n+    /// Creates and returns a FastRandomContext*. Should be called after we're up so that\n+    /// it had reandom data to pull from.\n+    fn rusty_InitRandContext() -> *mut c_void;\n+\n+    /// Frees a FastRandomContext* generated with rusty_InitRandContext().\n+    fn rusty_FreeRandContext(rand_context: *mut c_void);\n+\n+    /// Gets a u64 out of a Random Context generated with rusty_InitRandContext()\n+    fn rusty_GetRandU64(rand_context: *mut c_void) -> u64;\n+\n+    /// Gets a u64 less than the given max out of a Random Context generated with rusty_InitRandContext()\n+    fn rusty_GetRandRange(rand_context: *mut c_void, range: u64) -> u64;\n+}\n+\n+pub struct RandomContext {\n+    index: *mut c_void,\n+}\n+impl RandomContext {\n+    pub fn new() -> Self {\n+        let index = unsafe { rusty_InitRandContext() };\n+        assert!(!index.is_null());\n+        Self { index }\n+    }\n+\n+    pub fn get_rand_u64(&mut self) -> u64 {\n+        unsafe { rusty_GetRandU64(self.index) }\n+    }\n+\n+    /// Gets a random number in the range [0..range)\n+    pub fn randrange(&mut self, range: u64) -> u64 {\n+        assert!(range > 0);\n+        unsafe { rusty_GetRandRange(self.index, range) }\n+    }\n+}\n+impl Drop for RandomContext {\n+    fn drop(&mut self) {\n+        unsafe { rusty_FreeRandContext(self.index) }\n+    }\n+}"
      },
      {
        "sha": "726f950457a38f9a38af3dff54d92affd0019f24",
        "filename": "src/rusty/src/cpp_bridge.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 0,
        "changes": 19,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3f0598325ed55a4fc1aee4eb51404f6973906f38/src/rusty/src/cpp_bridge.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3f0598325ed55a4fc1aee4eb51404f6973906f38/src/rusty/src/cpp_bridge.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/cpp_bridge.cpp?ref=3f0598325ed55a4fc1aee4eb51404f6973906f38",
        "patch": "@@ -238,6 +238,25 @@ const void* rusty_ProviderStateGetNextDownloads(void* providerindexvoid, bool ha\n     return blocks.empty() ? nullptr : blocks[0];\n }\n \n+void* rusty_InitRandContext() {\n+    return (void*) new FastRandomContext();\n+}\n+\n+void rusty_FreeRandContext(void* contextvoid) {\n+    FastRandomContext* ctx = (FastRandomContext*) contextvoid;\n+    delete ctx;\n+}\n+\n+uint64_t rusty_GetRandU64(void* contextvoid) {\n+    FastRandomContext* ctx = (FastRandomContext*) contextvoid;\n+    return ctx->rand64();\n+}\n+\n+uint64_t rusty_GetRandRange(void* contextvoid, uint64_t range) {\n+    FastRandomContext* ctx = (FastRandomContext*) contextvoid;\n+    return ctx->randrange(range);\n+}\n+\n void rusty_LogLine(const unsigned char* str, bool debug) {\n     if (debug) {\n         LogPrint(BCLog::RUST, \"%s\\n\", str);"
      },
      {
        "sha": "ae0ca2caea7fce3cf92a359e4f133f359cb3c780",
        "filename": "src/rusty/src/test_bridge.rs",
        "status": "modified",
        "additions": 15,
        "deletions": 0,
        "changes": 15,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/3f0598325ed55a4fc1aee4eb51404f6973906f38/src/rusty/src/test_bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/3f0598325ed55a4fc1aee4eb51404f6973906f38/src/rusty/src/test_bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/test_bridge.rs?ref=3f0598325ed55a4fc1aee4eb51404f6973906f38",
        "patch": "@@ -113,3 +113,18 @@ impl BlockProviderState {\n pub fn log_line(_line: &str, _debug: bool) {\n     unimplemented!();\n }\n+\n+pub struct RandomContext { }\n+impl RandomContext {\n+    pub fn new() -> Self {\n+        unimplemented!();\n+    }\n+\n+    pub fn get_rand_u64(&mut self) -> u64 {\n+        unimplemented!();\n+    }\n+\n+    pub fn randrange(&mut self, _range: u64) -> u64 {\n+        unimplemented!();\n+    }\n+}"
      }
    ]
  },
  {
    "sha": "af2ea1e18d416bd7b8f19b9d3ccad68154075376",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphZjJlYTFlMThkNDE2YmQ3YjhmMTliOWQzY2NhZDY4MTU0MDc1Mzc2",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-10-28T21:09:11Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:22Z"
      },
      "message": "Add FFIs to Rust Bridge to check outbound connection nonces",
      "tree": {
        "sha": "bd5d4fefd1620186b3889bee10c8f52f11a60bc4",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/bd5d4fefd1620186b3889bee10c8f52f11a60bc4"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/af2ea1e18d416bd7b8f19b9d3ccad68154075376",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af2ea1e18d416bd7b8f19b9d3ccad68154075376",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/af2ea1e18d416bd7b8f19b9d3ccad68154075376",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af2ea1e18d416bd7b8f19b9d3ccad68154075376/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3f0598325ed55a4fc1aee4eb51404f6973906f38",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3f0598325ed55a4fc1aee4eb51404f6973906f38",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3f0598325ed55a4fc1aee4eb51404f6973906f38"
      }
    ],
    "stats": {
      "total": 124,
      "additions": 124,
      "deletions": 0
    },
    "files": [
      {
        "sha": "eb20487d7cfbafc3f134604a307f981df1d1d02c",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af2ea1e18d416bd7b8f19b9d3ccad68154075376/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af2ea1e18d416bd7b8f19b9d3ccad68154075376/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=af2ea1e18d416bd7b8f19b9d3ccad68154075376",
        "patch": "@@ -326,8 +326,26 @@ CNode* CConnman::FindNode(const CService& addr)\n     return nullptr;\n }\n \n+void CConnman::AddOutboundNonce(uint64_t nonce)\n+{\n+    LOCK(m_cs_other_nonces);\n+    m_other_nonces.insert(nonce);\n+}\n+\n+void CConnman::DropOutboundNonce(uint64_t nonce)\n+{\n+    LOCK(m_cs_other_nonces);\n+    m_other_nonces.erase(nonce);\n+}\n+\n bool CConnman::CheckIncomingNonce(uint64_t nonce)\n {\n+    {\n+        LOCK(m_cs_other_nonces);\n+        for (uint64_t other_nonce : m_other_nonces) {\n+            if (nonce == other_nonce) { return false; }\n+        }\n+    }\n     LOCK(cs_vNodes);\n     for (const CNode* pnode : vNodes) {\n         if (!pnode->fSuccessfullyConnected && !pnode->fInbound && pnode->GetLocalNonce() == nonce)"
      },
      {
        "sha": "ef25c6e873fe5df9c63fe62fa2ac1360087d3055",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af2ea1e18d416bd7b8f19b9d3ccad68154075376/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af2ea1e18d416bd7b8f19b9d3ccad68154075376/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=af2ea1e18d416bd7b8f19b9d3ccad68154075376",
        "patch": "@@ -30,6 +30,7 @@\n #include <thread>\n #include <memory>\n #include <condition_variable>\n+#include <unordered_set>\n \n #ifndef WIN32\n #include <arpa/inet.h>\n@@ -330,6 +331,20 @@ class CConnman\n     */\n     int64_t PoissonNextSendInbound(int64_t now, int average_interval_seconds);\n \n+    /** Adds a nonce which is being used for an outbound connection to the set\n+     *  of nonces which we check against when we receive a version message.\n+     *  This allows any parallel P2P connection logic to ensure we don't connect\n+     *  back to ourselves.\n+     */\n+    void AddOutboundNonce(uint64_t nonce);\n+\n+    /** Drops a nonce which was used for an outbound connection from the set of\n+     *  nonces which we check against when we receive a version message.\n+     *  This MUST be called after completing the version/verack handshake for\n+     *  any peer for which AddOutboundNonce was called.\n+     */\n+    void DropOutboundNonce(uint64_t nonce);\n+\n private:\n     struct ListenSocket {\n     public:\n@@ -419,6 +434,9 @@ class CConnman\n     std::atomic<NodeId> nLastNodeId{0};\n     unsigned int nPrevNodeCount{0};\n \n+    mutable CCriticalSection m_cs_other_nonces;\n+    std::unordered_set<uint64_t> m_other_nonces GUARDED_BY(m_cs_other_nonces);\n+\n     /**\n      * Services this instance offers.\n      *"
      },
      {
        "sha": "726be0cc86fe5963394e02bcce7b293edfadecb7",
        "filename": "src/rusty/src/bridge.rs",
        "status": "modified",
        "additions": 44,
        "deletions": 0,
        "changes": 44,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af2ea1e18d416bd7b8f19b9d3ccad68154075376/src/rusty/src/bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af2ea1e18d416bd7b8f19b9d3ccad68154075376/src/rusty/src/bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/bridge.rs?ref=af2ea1e18d416bd7b8f19b9d3ccad68154075376",
        "patch": "@@ -406,3 +406,47 @@ impl Drop for RandomContext {\n         unsafe { rusty_FreeRandContext(self.index) }\n     }\n }\n+\n+extern \"C\" {\n+    // P2P-specific utilities.\n+\n+    /// Begins tracking the given nonce to reject any incoming connections with the same\n+    /// in their VERSION message, preventing us from connecting to ourselves.\n+    /// nonce must be random, and you MUST call rusty_DropOutboundP2PNonce afterwards.\n+    fn rusty_AddOutboundP2PNonce(connman: *mut c_void, nonce: u64);\n+\n+    /// Stops tracking the given connection nonce, provided to rusty_AddOutboundP2PNonce.\n+    fn rusty_DropOutboundP2PNonce(connman: *mut c_void, nonce: u64);\n+\n+    /// Returns false if the given nonce has been used on any of our outbound connections\n+    /// (including those made by the C++ P2P client and those added via\n+    /// rusty_AddOutboundP2PNonce).\n+    fn rusty_CheckInboundP2PNonce(connman: *mut c_void, nonce: u64) -> bool;\n+}\n+\n+#[derive(Copy, Clone)]\n+pub struct Connman(pub *mut c_void);\n+// As long as we exit when required to, sending around pointers to Connman is fine:\n+unsafe impl Send for Connman {}\n+\n+pub struct OutboundP2PNonce {\n+    connman: Connman,\n+    nonce: u64,\n+}\n+impl OutboundP2PNonce {\n+    pub fn new(connman: Connman, rand_ctx: &mut RandomContext) -> Self {\n+        let nonce = rand_ctx.get_rand_u64();\n+        unsafe { rusty_AddOutboundP2PNonce(connman.0, nonce) }\n+        Self { connman, nonce }\n+    }\n+    pub fn nonce(&self) -> u64 { self.nonce }\n+}\n+impl Drop for OutboundP2PNonce  {\n+    fn drop(&mut self) {\n+        unsafe { rusty_DropOutboundP2PNonce(self.connman.0, self.nonce) }\n+    }\n+}\n+\n+pub fn should_disconnect_by_inbound_nonce(connman: Connman, nonce: u64) -> bool {\n+    ! unsafe { rusty_CheckInboundP2PNonce(connman.0, nonce) }\n+}"
      },
      {
        "sha": "3b7f17989d34dac47f2fd7a19dd2be7354e0492f",
        "filename": "src/rusty/src/cpp_bridge.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af2ea1e18d416bd7b8f19b9d3ccad68154075376/src/rusty/src/cpp_bridge.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af2ea1e18d416bd7b8f19b9d3ccad68154075376/src/rusty/src/cpp_bridge.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/cpp_bridge.cpp?ref=af2ea1e18d416bd7b8f19b9d3ccad68154075376",
        "patch": "@@ -1,4 +1,5 @@\n #include <chainparams.h>\n+#include <net.h>\n #include <net_processing.h>\n #include <validation.h>\n #include <shutdown.h>\n@@ -265,4 +266,26 @@ void rusty_LogLine(const unsigned char* str, bool debug) {\n     }\n }\n \n+void rusty_AddOutboundP2PNonce(void* pconnmanvoid, uint64_t nonce) {\n+    CConnman* g_rusty_connman = (CConnman*) pconnmanvoid;\n+    if (g_rusty_connman) {\n+        g_rusty_connman->AddOutboundNonce(nonce);\n+    }\n+}\n+\n+void rusty_DropOutboundP2PNonce(void* pconnmanvoid, uint64_t nonce) {\n+    CConnman* g_rusty_connman = (CConnman*) pconnmanvoid;\n+    if (g_rusty_connman) {\n+        g_rusty_connman->DropOutboundNonce(nonce);\n+    }\n+}\n+\n+bool rusty_CheckInboundP2PNonce(void* pconnmanvoid, uint64_t nonce) {\n+    CConnman* g_rusty_connman = (CConnman*) pconnmanvoid;\n+    if (g_rusty_connman) {\n+        return g_rusty_connman->CheckIncomingNonce(nonce);\n+    }\n+    return false;\n+}\n+\n }"
      },
      {
        "sha": "2db6ce6305f4c01bcd3e7c543d4d9c4e9c02d6a1",
        "filename": "src/rusty/src/test_bridge.rs",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/af2ea1e18d416bd7b8f19b9d3ccad68154075376/src/rusty/src/test_bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/af2ea1e18d416bd7b8f19b9d3ccad68154075376/src/rusty/src/test_bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/test_bridge.rs?ref=af2ea1e18d416bd7b8f19b9d3ccad68154075376",
        "patch": "@@ -1,5 +1,7 @@\n ///! \"bridge\" to C++ code without any backing C++ code. Used for shimming in dummies for testing.\n \n+use std::ffi::c_void;\n+\n use bitcoin::blockdata::block::BlockHeader;\n use bitcoin::util::uint::Uint256;\n \n@@ -128,3 +130,22 @@ impl RandomContext {\n         unimplemented!();\n     }\n }\n+\n+#[derive(Copy, Clone)]\n+pub struct Connman(pub *mut c_void);\n+// As long as we exit when required to, sending around pointers to Connman is fine:\n+unsafe impl Send for Connman {}\n+\n+pub struct OutboundP2PNonce { }\n+impl OutboundP2PNonce {\n+    pub fn new(_connman: Connman, _rand_ctx: &mut RandomContext) -> Self {\n+        unimplemented!();\n+    }\n+    pub fn nonce(&self) -> u64 {\n+        unimplemented!();\n+    }\n+}\n+\n+pub fn should_disconnect_by_inbound_nonce(_connman: Connman, _nonce: u64) -> bool {\n+    unimplemented!();\n+}"
      }
    ]
  },
  {
    "sha": "d0be12500624d641d1aa7a7db8373081879203d6",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpkMGJlMTI1MDA2MjRkNjQxZDFhYTdhN2RiODM3MzA4MTg3OTIwM2Q2",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-09-30T21:07:33Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:30Z"
      },
      "message": "Add P2P Client",
      "tree": {
        "sha": "ac570941ab11a0fe127050bc8684c1a401f4b868",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ac570941ab11a0fe127050bc8684c1a401f4b868"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/d0be12500624d641d1aa7a7db8373081879203d6",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0be12500624d641d1aa7a7db8373081879203d6",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/d0be12500624d641d1aa7a7db8373081879203d6",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0be12500624d641d1aa7a7db8373081879203d6/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "af2ea1e18d416bd7b8f19b9d3ccad68154075376",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/af2ea1e18d416bd7b8f19b9d3ccad68154075376",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/af2ea1e18d416bd7b8f19b9d3ccad68154075376"
      }
    ],
    "stats": {
      "total": 1407,
      "additions": 1406,
      "deletions": 1
    },
    "files": [
      {
        "sha": "7864361155bf049c02dfb9a64ad4896c468240a9",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0be12500624d641d1aa7a7db8373081879203d6/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0be12500624d641d1aa7a7db8373081879203d6/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=d0be12500624d641d1aa7a7db8373081879203d6",
        "patch": "@@ -377,7 +377,9 @@ LIBBITCOIN_RUSTY_SRCS= \\\n   rusty/src/lib.rs \\\n   rusty/src/bridge.rs \\\n   rusty/src/dns_headers.rs \\\n-  rusty/src/rest_downloader.rs\n+  rusty/src/rest_downloader.rs \\\n+  rusty/src/p2p_addrs.rs rusty/src/p2p_client.rs \\\n+  rusty/src/p2p_socket_handler.rs\n \n LIBBITCOIN_RUSTY_TEST_SRCS= \\\n   rusty/src/test_bridge.rs"
      },
      {
        "sha": "f54473cbe753c117fc32f4ba238567d755c285a9",
        "filename": "src/clientversion.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0be12500624d641d1aa7a7db8373081879203d6/src/clientversion.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0be12500624d641d1aa7a7db8373081879203d6/src/clientversion.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.cpp?ref=d0be12500624d641d1aa7a7db8373081879203d6",
        "patch": "@@ -14,6 +14,12 @@\n  */\n const std::string CLIENT_NAME(\"Satoshi\");\n \n+/**\n+ * Name of client reported in the 'version' message when connected to the\n+ * in-Rust P2P client.\n+ */\n+const std::string RUSTY_CLIENT_NAME(\"RustySatoshi\");\n+\n /**\n  * Client version number\n  */"
      },
      {
        "sha": "0b23eba265590ef653b72540e2130eb90829b762",
        "filename": "src/clientversion.h",
        "status": "modified",
        "additions": 1,
        "deletions": 0,
        "changes": 1,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0be12500624d641d1aa7a7db8373081879203d6/src/clientversion.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0be12500624d641d1aa7a7db8373081879203d6/src/clientversion.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.h?ref=d0be12500624d641d1aa7a7db8373081879203d6",
        "patch": "@@ -42,6 +42,7 @@ static const int CLIENT_VERSION =\n                          +       1 * CLIENT_VERSION_BUILD;\n \n extern const std::string CLIENT_NAME;\n+extern const std::string RUSTY_CLIENT_NAME;\n extern const std::string CLIENT_BUILD;\n \n "
      },
      {
        "sha": "a4b38276ccba14214ac1263a5ddfe8c0fd3dc82a",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 18,
        "deletions": 0,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0be12500624d641d1aa7a7db8373081879203d6/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0be12500624d641d1aa7a7db8373081879203d6/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=d0be12500624d641d1aa7a7db8373081879203d6",
        "patch": "@@ -190,6 +190,7 @@ void Shutdown(NodeContext& node)\n #if ENABLE_RUSTY\n     rust_block_fetch::stop_fetch_dns_headers();\n     rust_block_fetch::stop_fetch_rest_blocks();\n+    rust_block_fetch::stop_p2p_client();\n #endif\n \n     StopHTTPRPC();\n@@ -409,6 +410,8 @@ void SetupServerArgs()\n #if ENABLE_RUSTY\n     gArgs.AddArg(\"-blockfetchrest=<uri>\", \"A REST endpoint from which to fetch blocks. Acts as a redundant backup for P2P connectivity. eg http://cloudflare.deanonymizingseed.com/rest/\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-headersfetchdns=<domain>\", \"A domain name from which to fetch headers. eg bitcoinheaders.net\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-parallelp2p\", strprintf(\"Whether to run a parallel P2P client to provide redundancy in block fetch implementation (default: %u).\", rust_block_fetch::DEFAULT_P2P), ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-parallelp2pport=<port>\", strprintf(\"Listen for connections on <port> with the parallel P2P client (default: %u, testnet: %u, regtest: %u). 0 indicates no listening, only outbound connections are made.\", defaultChainParams->GetDefaultPort() + 1, testnetChainParams->GetDefaultPort() + 1, regtestChainParams->GetDefaultPort() + 1), ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n #endif\n     gArgs.AddArg(\"-addnode=<ip>\", \"Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC command help for more info). This option can be specified multiple times to add multiple nodes.\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-banscore=<n>\", strprintf(\"Threshold for disconnecting misbehaving peers (default: %u)\", DEFAULT_BANSCORE_THRESHOLD), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n@@ -1345,6 +1348,13 @@ bool AppInitMain(NodeContext& node)\n         return InitError(strprintf(_(\"Total length of network version string (%i) exceeds maximum length (%i). Reduce the number or size of uacomments.\").translated,\n             strSubVersion.size(), MAX_SUBVERSION_LENGTH));\n     }\n+#ifdef ENABLE_RUSTY\n+    std::string rusty_sub_ver = FormatSubVersion(RUSTY_CLIENT_NAME, CLIENT_VERSION, uacomments);\n+    if (gArgs.GetBoolArg(\"-parallelp2p\", rust_block_fetch::DEFAULT_P2P) && rusty_sub_ver.size() > MAX_SUBVERSION_LENGTH) {\n+        return InitError(strprintf(_(\"Total length of network version string (%i) exceeds maximum length (%i). Reduce the number or size of uacomments.\").translated,\n+            rusty_sub_ver.size(), MAX_SUBVERSION_LENGTH));\n+    }\n+#endif\n \n     if (gArgs.IsArgSet(\"-onlynet\")) {\n         std::set<enum Network> nets;\n@@ -1844,6 +1854,14 @@ bool AppInitMain(NodeContext& node)\n     for (const std::string& uri : gArgs.GetArgs(\"-blockfetchrest\")) {\n         rust_block_fetch::init_fetch_rest_blocks(uri.c_str());\n     }\n+    if (gArgs.GetBoolArg(\"-parallelp2p\", rust_block_fetch::DEFAULT_P2P)) {\n+        std::vector<const char*> dnsseeds;\n+        for (const std::string& seed : Params().DNSSeeds()) {\n+            dnsseeds.push_back(seed.c_str());\n+        }\n+        unsigned short bind_port = (unsigned short)(gArgs.GetArg(\"-parallelp2pport\", Params().GetDefaultPort() + 1));\n+        rust_block_fetch::init_p2p_client(node.connman.get(), GetDataDir().c_str(), rusty_sub_ver.c_str(), bind_port, dnsseeds.data(), dnsseeds.size());\n+    }\n #endif\n \n     return true;"
      },
      {
        "sha": "455c8c38d26d5fffd3916f76a3fe02cc00ad6419",
        "filename": "src/rusty/src/lib.rs",
        "status": "modified",
        "additions": 14,
        "deletions": 0,
        "changes": 14,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0be12500624d641d1aa7a7db8373081879203d6/src/rusty/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0be12500624d641d1aa7a7db8373081879203d6/src/rusty/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/lib.rs?ref=d0be12500624d641d1aa7a7db8373081879203d6",
        "patch": "@@ -16,6 +16,20 @@ use bridge::*;\n mod dns_headers;\n mod rest_downloader;\n \n+// Our P2P socket handler currently only supports poll(), so we stub out all the P2P client for\n+// Windows with dumy init/stop functions.\n+#[cfg(target_family = \"unix\")] mod p2p_addrs;\n+#[cfg(target_family = \"unix\")] mod p2p_client;\n+#[cfg(target_family = \"unix\")] mod p2p_socket_handler;\n+\n+#[cfg(target_family = \"windows\")]\n+mod dummy_p2p {\n+    #[no_mangle]\n+    pub extern \"C\" fn init_p2p_client(_connman_ptr: *mut c_void, _datadir_path: *const c_char, _subver_c: *const c_char, _bind_port: u16, _dnsseed_names: *const *const c_char, _dnsseed_count: usize) { }\n+    #[no_mangle]\n+    pub extern \"C\" fn stop_p2p_client() { }\n+}\n+\n use std::alloc::{GlobalAlloc, Layout, System};\n use std::ptr;\n use std::sync::atomic::{AtomicUsize, Ordering};"
      },
      {
        "sha": "1f0b68a7974e73b05a80923ca59ef3ad6b03af94",
        "filename": "src/rusty/src/p2p_addrs.rs",
        "status": "added",
        "additions": 194,
        "deletions": 0,
        "changes": 194,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0be12500624d641d1aa7a7db8373081879203d6/src/rusty/src/p2p_addrs.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0be12500624d641d1aa7a7db8373081879203d6/src/rusty/src/p2p_addrs.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/p2p_addrs.rs?ref=d0be12500624d641d1aa7a7db8373081879203d6",
        "patch": "@@ -0,0 +1,194 @@\n+use std::collections::HashSet;\n+use std::net::{SocketAddr, SocketAddrV4, SocketAddrV6, ToSocketAddrs, Ipv4Addr, Ipv6Addr};\n+use std::{fs, io};\n+use std::io::Seek;\n+\n+use bitcoin::network::address::Address as BitcoinAddr;\n+\n+use bridge::*;\n+\n+/// An address which can be used to connect to a remote peer\n+#[derive(Clone, PartialEq, Eq, Debug, Hash)]\n+pub enum NetAddress {\n+    /// An IPv4 address/port on which the peer is listening.\n+    IPv4(SocketAddrV4),\n+    /// An IPv6 address/port on which the peer is listening.\n+    IPv6(SocketAddrV6),\n+    /// An old-style Tor onion address/port on which the peer is listening.\n+    OnionV2 {\n+        /// The bytes (usually encoded in base32 with \".onion\" appended)\n+        addr: [u8; 10],\n+        /// The port on which the node is listening\n+        port: u16,\n+    },\n+    /// A new-style Tor onion address/port on which the peer is listening.\n+    /// To create the human-readable \"hostname\", concatenate ed25519_pubkey, checksum, and version,\n+    /// wrap as base32 and append \".onion\".\n+    OnionV3 {\n+        /// The ed25519 long-term public key of the peer\n+        ed25519_pubkey: [u8; 32],\n+        /// The checksum of the pubkey and version, as included in the onion address\n+        checksum: u16,\n+        /// The version byte, as defined by the Tor Onion v3 spec.\n+        version: u8,\n+        /// The port on which the node is listening\n+        port: u16,\n+    },\n+}\n+\n+impl NetAddress {\n+    pub fn write<W : io::Write>(&self, write: &mut W) -> Result<(), io::Error> {\n+        match self {\n+            NetAddress::IPv4(sockaddr) => {\n+                write.write_all(&[0, 8])?;\n+                write.write_all(&sockaddr.ip().octets())?;\n+                write.write_all(&[(sockaddr.port() >> 8) as u8, sockaddr.port() as u8])?;\n+            },\n+            NetAddress::IPv6(sockaddr) => {\n+                write.write_all(&[1, 20])?;\n+                write.write_all(&sockaddr.ip().octets())?;\n+                write.write_all(&[(sockaddr.port() >> 8) as u8, sockaddr.port() as u8])?;\n+            },\n+            NetAddress::OnionV2 { addr, port } => {\n+                write.write_all(&[2, 14])?;\n+                write.write_all(addr)?;\n+                write.write_all(&[(*port >> 8) as u8, *port as u8])?;\n+            },\n+            NetAddress::OnionV3 { ed25519_pubkey, checksum, version, port } => {\n+                write.write_all(&[3, 39])?;\n+                write.write_all(ed25519_pubkey)?;\n+                write.write_all(&[(*checksum >> 8) as u8, *checksum as u8])?;\n+                write.write_all(&[*version])?;\n+                write.write_all(&[(*port >> 8) as u8, *port as u8])?;\n+            },\n+        }\n+        Ok(())\n+    }\n+\n+    pub fn new(addr: SocketAddr) -> NetAddress {\n+        match addr {\n+            SocketAddr::V4(sa) => NetAddress::IPv4(sa),\n+            SocketAddr::V6(sa) if sa.ip().octets()[..6] == [0xFD,0x87,0xD8,0x7E,0xEB,0x43][..] => {\n+                let mut addr = [0; 10];\n+                addr.copy_from_slice(&sa.ip().octets()[6..]);\n+                NetAddress::OnionV2 {\n+                    addr,\n+                    port: sa.port(),\n+                }\n+            },\n+            SocketAddr::V6(sa) => if let Some(v4ip) = sa.ip().to_ipv4() {\n+                    NetAddress::IPv4(SocketAddrV4::new(v4ip, sa.port()))\n+                } else {\n+                    NetAddress::IPv6(sa)\n+                },\n+        }\n+    }\n+}\n+\n+struct AddrStream<'a, R : io::Read> (Option<&'a mut R>);\n+impl<'a, R : io::Read> AddrStream<'a, R> {\n+    pub fn new(read: &'a mut R) -> AddrStream<'a, R> {\n+        let mut ver_info = [0u8; 2]; // (min ver, max ver)\n+        if let Ok(_) = read.read_exact(&mut ver_info) {\n+            if ver_info[0] <= 1 {\n+                Self(Some(read))\n+            } else { Self(None) }\n+        } else { Self(None) }\n+    }\n+}\n+impl<'a, R : io::Read> Iterator for AddrStream<'a, R> {\n+    type Item = NetAddress;\n+    fn next(&mut self) -> Option<NetAddress> {\n+        'bad_file: loop {\n+            match &mut self.0 {\n+                &mut None => return None,\n+                &mut Some(ref mut r) => {\n+                    let mut addr = [0; 255];\n+                    // Min length is 8 (type, len, ipv4, port)\n+                    if let Ok(_) = r.read_exact(&mut addr[0..2]) {\n+                        let len = addr[1] as usize;\n+                        if len < 8 { break 'bad_file; }\n+                        else if let Ok(_) = r.read_exact(&mut addr[2..len]) {\n+                            match addr[0] {\n+                                0 if addr[1] == 8 => {\n+                                    return Some(NetAddress::IPv4(SocketAddrV4::new(\n+                                                Ipv4Addr::new(addr[2], addr[3], addr[4], addr[5]),\n+                                                 ((addr[6] as u16) << 8) | addr[7] as u16)));\n+                                },\n+                                1 if addr[1] == 20 => {\n+                                    return Some(NetAddress::IPv6(SocketAddrV6::new(\n+                                                 Ipv6Addr::new(((addr[ 2] as u16) << 8) | addr[ 3] as u16,\n+                                                               ((addr[ 4] as u16) << 8) | addr[ 5] as u16,\n+                                                               ((addr[ 6] as u16) << 8) | addr[ 7] as u16,\n+                                                               ((addr[ 8] as u16) << 8) | addr[ 9] as u16,\n+                                                               ((addr[10] as u16) << 8) | addr[11] as u16,\n+                                                               ((addr[12] as u16) << 8) | addr[13] as u16,\n+                                                               ((addr[14] as u16) << 8) | addr[15] as u16,\n+                                                               ((addr[16] as u16) << 8) | addr[17] as u16),\n+                                                 ((addr[18] as u16) << 8) | addr[19] as u16, 0, 0)));\n+                                },\n+                                2 if addr[1] == 14 => {\n+                                    let mut onion_bytes = [0; 10];\n+                                    onion_bytes.copy_from_slice(&mut addr[2..12]);\n+                                    return Some(NetAddress::OnionV2 {\n+                                        addr: onion_bytes,\n+                                        port: ((addr[12] as u16) << 8) | addr[13] as u16,\n+                                    });\n+                                },\n+                                3 if addr[1] == 2 + 32 + 2 + 1 + 2 => {\n+                                    let mut ed25519_pubkey = [0; 32];\n+                                    ed25519_pubkey.copy_from_slice(&mut addr[2..34]);\n+                                    return Some(NetAddress::OnionV3 {\n+                                        ed25519_pubkey,\n+                                        checksum: ((addr[34] as u16) << 8) | addr[35] as u16,\n+                                        version: addr[36],\n+                                        port: ((addr[37] as u16) << 8) | addr[38] as u16,\n+                                    });\n+                                },\n+                                _ => { },\n+                            }\n+                        } else { break 'bad_file; }\n+                    } else { break 'bad_file; }\n+                },\n+            };\n+        }\n+        self.0 = None;\n+        None\n+    }\n+}\n+\n+pub struct AddrTracker {\n+    addr_set: HashSet<NetAddress>,\n+}\n+impl AddrTracker {\n+    pub fn new(addr_path: String, dnsseeds: Vec<String>) -> Self {\n+        // First read up to 1000 addrs off disk, and if we don't have 500, pull up to 25/seed\n+        // from the dnsseeds, then write them back to disk.\n+        let mut addr_f = fs::OpenOptions::new().read(true).write(true).create(true).open(addr_path).expect(\"Failed to open addr database\");\n+        let mut addr_set: HashSet<_> = AddrStream::new(&mut addr_f).take(1000).collect();\n+        if addr_set.len() < 500 {\n+            for dnsseed in dnsseeds {\n+                if let Ok(addrs) = dnsseed.to_socket_addrs() {\n+                    for addr in addrs.take(25) {\n+                        addr_set.insert(NetAddress::new(addr));\n+                    }\n+                }\n+            }\n+            addr_f.seek(io::SeekFrom::Start(0)).unwrap();\n+            for addr in addr_set.iter() {\n+                addr.write(&mut addr_f).expect(\"Failed to write new addresses\");\n+            }\n+        }\n+        Self { addr_set }\n+    }\n+\n+    pub fn get_rand_addr(&self, rand_ctx: &mut RandomContext) -> Option<NetAddress> {\n+        if self.addr_set.is_empty() {\n+            None\n+        } else {\n+            self.addr_set.iter().skip(rand_ctx.randrange(self.addr_set.len() as u64) as usize).next().cloned()\n+        }\n+    }\n+\n+    pub fn addrs_recvd(&mut self, _from: &NetAddress, _outbound: bool, _addrs: &Vec<(u32, BitcoinAddr)>) {}\n+}"
      },
      {
        "sha": "86c27b40b988bdbec24f24754f5ac2b1edb518a8",
        "filename": "src/rusty/src/p2p_client.rs",
        "status": "added",
        "additions": 645,
        "deletions": 0,
        "changes": 645,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0be12500624d641d1aa7a7db8373081879203d6/src/rusty/src/p2p_client.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0be12500624d641d1aa7a7db8373081879203d6/src/rusty/src/p2p_client.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/p2p_client.rs?ref=d0be12500624d641d1aa7a7db8373081879203d6",
        "patch": "@@ -0,0 +1,645 @@\n+use std::collections::LinkedList;\n+use std::panic::catch_unwind;\n+use std::sync::{Arc, Condvar, Mutex};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::time::{Duration, Instant, SystemTime};\n+\n+use std::ffi::{CStr, c_void};\n+use std::os::raw::c_char;\n+\n+use crate::bridge::*;\n+use crate::await_ibd_complete_or_stalled;\n+use crate::p2p_addrs::*;\n+use crate::p2p_socket_handler::*;\n+\n+use bitcoin::BitcoinHash;\n+use bitcoin::blockdata::block::BlockHeader;\n+use bitcoin::consensus::Decodable;\n+use bitcoin::consensus::encode::deserialize;\n+use bitcoin::network::address;\n+use bitcoin::network::message::NetworkMessage;\n+use bitcoin::network::message_network::VersionMessage;\n+use bitcoin::network::message_blockdata::{GetHeadersMessage, Inventory, InvType};\n+\n+use bitcoin_hashes::Hash as HashTrait;\n+use bitcoin_hashes::sha256d::Hash;\n+\n+///! A (relatively) simple P2P blocks-only implementation. The goal here is explicitly *not* to be\n+///! efficient (modulo a few obvious fixes), but instead to be simple, and thus robust and easy to\n+///! understand. That said, we can't, in the common case, blow up bandwidth usage. An easy cheat,\n+///! however, to avoid it, is to simply wait some number of seconds (BLOCK_REQ_DELAY, below) before\n+///! downloading any blocks once we've decided they should be requested. This gives the,\n+///! potentially more effecient, C++ client a chance to fetch the block before we do it.\n+///! Additionally, we wait until the C++ client has gotten us out of IBD (or it seems to have\n+///! stalled and isn't making progress) before we do anything at all. Further, we, with the\n+///! exception of any common state held in the C++ codebase, don't keep any per-peer state.\n+\n+static THREAD_COUNT: AtomicUsize = AtomicUsize::new(0);\n+\n+/// If a headers message contains this many headers, it means we should ask for more headers\n+/// starting from the last one in the message. This is only an optimization as we'll still\n+/// regularly poll all our peers with getheaders messages.\n+const HEADERS_LEN_CONTINUE: usize = 2000;\n+const PROTOCOL_VERSION: u32 = 70015;\n+\n+/// Check for new blocks to download regularly at this interval, and also delay requesting blocks\n+/// for this amount of time after we decide we should, in the hopes someone else fetches it in a\n+/// more efficient manner.\n+const BLOCK_REQ_DELAY: Duration = Duration::from_secs(29);\n+\n+/// Interval at which we poll our peers for their latest header.\n+const HEADER_POLL_INTERVAL: Duration = Duration::from_secs(31);\n+\n+/// Interval at which we send regular pings to peers (and at which point they must have responded\n+/// to the previous ping with a pong).\n+const PING_INTERVAL: Duration = Duration::from_secs(23);\n+\n+/// state that gets wrapped in an Arc to pass incoming and outgoing messages into/out of the socket\n+/// handling thread.\n+struct PeerState {\n+    queues: Arc<MessageQueues>,\n+    remote_addr: NetAddress,\n+    is_outbound: bool,\n+    /// The random nonce we send in our version message to detect connecting-back-to-ourselves.\n+    /// Only set for outbound peers and only kept around until version handshake completes.\n+    outbound_nonce: Option<OutboundP2PNonce>,\n+    recvd_ver: bool,\n+    recvd_verack: bool,\n+    recvd_sendheaders: bool,\n+    /// We use the C++ block-fetching logic to get its reorg-robustness. However, we *also* try to\n+    /// be at least partially robust against bugs therein, if only for non-reorg paths.\n+    block_state: BlockProviderState,\n+    /// The next time we should poll this peer for their current header tip\n+    next_header_poll: Instant,\n+    /// The next block we (may) request if we still don't have it at next_block_request_time.\n+    next_block_request: Option<BlockIndex>,\n+    /// We wait a bit after we hear about a block before requesting it, in the hopes that the C++\n+    /// code is a bit more effecient than we are, but if we reach this time, we go ahead with it.\n+    next_block_request_time: Instant,\n+    last_ping_nonce: Option<u64>,\n+    /// The next time we should send a ping. If last_ping_nonce is not-None by the time we get\n+    /// there, we should disconnect the peer.\n+    next_ping_time: Instant,\n+}\n+\n+/// Finds the fork point between a and b and the block that is (up to) 2000 blocks\n+/// after the fork point, headed towards a.\n+fn find_fork_point_plus_2k(mut a: BlockIndex, mut b: BlockIndex) -> (BlockIndex, BlockIndex) {\n+    let mut a2k = a;\n+    let mut a2k_height = a2k.height();\n+    let mut a_height = a2k_height;\n+    let initial_b_height = b.height();\n+    if a_height > initial_b_height {\n+        if a_height > initial_b_height + 2000 {\n+            a2k = a.get_ancestor(initial_b_height + 2000).expect(\"prev() has to at least get us back to genesis\");\n+        }\n+        a = a2k.get_ancestor(initial_b_height).expect(\"prev() has to at least get us back to genesis\");\n+        a_height = a.height();\n+    }\n+    if initial_b_height > a_height {\n+        b = b.get_ancestor(a_height).expect(\"prev() has to at least get us back to genesis\");\n+    }\n+    assert_eq!(a.height(), b.height());\n+    while a != b {\n+        a = a.get_prev().expect(\"prev() has to at least get us back to genesis\");\n+        b = b.get_prev().expect(\"prev() has to at least get us back to genesis\");\n+        a_height -= 1;\n+        if a2k_height > a_height + 2000 {\n+            a2k = a2k.get_prev().expect(\"prev() has to at least get us back to genesis\");\n+            a2k_height -= 1;\n+        }\n+    }\n+    (a, a2k)\n+}\n+\n+fn generate_locator_response<T: Clone, Conv: Fn(BlockIndex) -> T, Dummy: Fn() -> T>(our_best: BlockIndex, locators: &Vec<Hash>, stop_hash: &Hash, c: Conv, d: Dummy) -> Vec<T> {\n+    let mut res = Vec::new();\n+    if locators.is_empty() {\n+        if let Some(index) = BlockIndex::get_from_hash(&stop_hash.into_inner(), Some(our_best)) {\n+            res.push(c(index));\n+        }\n+    } else {\n+        let mut range = None;\n+        for h in locators {\n+            if let Some(index) = BlockIndex::get_from_hash(&h.into_inner(), Some(our_best)) {\n+                if index == our_best {\n+                    // They asked for anything newer than our tip, don't send them anything!\n+                    break;\n+                }\n+                let (fork, fork2k) = find_fork_point_plus_2k(our_best, index);\n+                range = Some((fork, fork2k));\n+                break;\n+            }\n+        }\n+        if range.is_none() {\n+            range = Some((BlockIndex::genesis(),\n+                         our_best.get_ancestor(std::cmp::min(2000, our_best.height())).expect(\"prev() has to at least get us back to genesis\")));\n+        }\n+        if let Some((fork_point, mut stop_index)) = range {\n+            res.resize(2000, d());\n+            let mut idx: isize = 1999;\n+            while stop_index != fork_point {\n+                if stop_hash.into_inner() != [0; 32] && stop_hash.into_inner() == stop_index.hash() {\n+                    break;\n+                }\n+                res[idx as usize] = c(stop_index);\n+                idx -= 1;\n+                stop_index = stop_index.get_prev().expect(\"prev() has to at least get us back to genesis\");\n+                if idx == -1 {\n+                    assert!(fork_point == stop_index);\n+                }\n+            }\n+            if idx >= 0 {\n+                res.drain(0..(idx as usize) + 1);\n+            }\n+        }\n+    }\n+    res\n+}\n+\n+/// Finds the first ancestor from candidate_tip going back to the fork block from our_tip that\n+/// doesn't have data. This is gratuitously expensive, so we should prefer to avoid it, in general.\n+fn find_missing_data_fork_point(mut our_tip: BlockIndex, mut candidate_tip: BlockIndex) -> Option<BlockIndex> {\n+    let mut tip_walk_height = our_tip.height();\n+    let mut candidate_height = candidate_tip.height();\n+    // Walk back candidate_tip until it doesn't have_data(), but return None if we hit a common\n+    // ancestor with our_tip (instead of walking back further).\n+    while !candidate_tip.have_block() {\n+        if candidate_height < 1 {\n+            // Why would we download genesis?\n+            return None;\n+        }\n+        if candidate_height - 1 < tip_walk_height {\n+            our_tip = our_tip.get_prev().expect(\"prev() can't return nothing if height > 0\");\n+            tip_walk_height -= 1;\n+        }\n+        let prev = candidate_tip.get_prev().expect(\"prev() can't return nothing if height > 0\");\n+        if prev == our_tip {\n+            // We got to the fork point and every block is missing data, just request the block\n+            // immediately after the fork point.\n+            break;\n+        }\n+        candidate_height -= 1;\n+        candidate_tip = prev;\n+    }\n+    Some(candidate_tip)\n+}\n+\n+/// Returns true if the block pointed to by the given index is a pretty good candidate for being on\n+/// the best chain. Checks for some basics like the candidate tip not being obviously-bogus,\n+/// not known-to-be-invalid, and having more work than our tip.\n+/// Does *not* check whether we already have the data for this block\n+/// Takes a hint of a best chain that this may be building towards (which may be == block)\n+fn is_probably_on_best_chain(our_tip: BlockIndex, block: BlockIndex, candidate_chain_tip: BlockIndex) -> bool {\n+    let min_chainwork = get_min_chainwork();\n+    let tip_work = our_tip.total_work();\n+\n+    let block_work = block.total_work();\n+    if block_work >= min_chainwork && block_work > tip_work && block.not_invalid(false) {\n+        return true;\n+    }\n+    if block == candidate_chain_tip { return false; }\n+\n+    let candidate_work = candidate_chain_tip.total_work();\n+    candidate_work >= min_chainwork && candidate_work > tip_work &&\n+    candidate_chain_tip.get_ancestor(block.height()) == Some(block) &&\n+    candidate_chain_tip.not_invalid(false)\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_p2p_client(connman_ptr: *mut c_void, datadir_path: *const c_char, subver_c: *const c_char, bind_port: u16, dnsseed_names: *const *const c_char, dnsseed_count: usize) {\n+    let addr_path: String = match unsafe { CStr::from_ptr(datadir_path) }.to_str() {\n+        Ok(d) => d.to_string() + \"/rust_p2p_addrs.dat\",\n+        Err(_) => return,\n+    };\n+    let subver: String = match unsafe { CStr::from_ptr(subver_c) }.to_str() {\n+        Ok(d) => d.to_string(),\n+        Err(_) => return,\n+    };\n+    let mut dnsseeds: Vec<String> = Vec::with_capacity(dnsseed_count);\n+    for i in 0..dnsseed_count {\n+        dnsseeds.push(match unsafe { CStr::from_ptr(*dnsseed_names.offset(i as isize)) }.to_str() {\n+            Ok(d) => d.to_string(),\n+            Err(_) => return,\n+        });\n+    }\n+    let connman = Connman(connman_ptr);\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        THREAD_COUNT.fetch_add(1, Ordering::AcqRel);\n+        let _ = catch_unwind(move || {\n+            let mut addr_tracker = AddrTracker::new(addr_path, dnsseeds);\n+\n+            await_ibd_complete_or_stalled();\n+\n+            let mut rand_ctx = RandomContext::new();\n+\n+            let sleep_condvar = Arc::new(Condvar::new());\n+            let sleep_mutex = Arc::new(Mutex::new(()));\n+\n+            let pending_outbounds = Arc::new(Mutex::new(Vec::new()));\n+            let pending_inbounds = Arc::new(Mutex::new(Vec::new()));\n+\n+            let mut peers: Vec<PeerState> = Vec::new();\n+            let waker = spawn_socket_handler(&THREAD_COUNT, bind_port, Arc::clone(&sleep_condvar), Arc::clone(&sleep_mutex), Arc::clone(&pending_outbounds), Arc::clone(&pending_inbounds));\n+\n+            let mut prev_tip = BlockIndex::tip();\n+            let mut last_tip_update = Instant::now();\n+            let mut last_header_tip_update = Instant::now();\n+            let mut prev_header_tip = BlockIndex::best_header();\n+            'aggressiveness_check: while unsafe { !rusty_ShutdownRequested() } {\n+                {\n+                    let sleep_lock = sleep_mutex.lock().unwrap();\n+                    let mut skip_sleep = false;\n+                    for peer in peers.iter() {\n+                        if !peer.queues.inbound.lock().unwrap().is_empty() {\n+                            skip_sleep = true;\n+                            break;\n+                        }\n+                    }\n+                    if !skip_sleep {\n+                        // We're ok with spurious wakes making us run the main loop again, its not\n+                        // too expensive and its worth checking again if there's any work to do.\n+                        let _ = sleep_condvar.wait_timeout(sleep_lock, Duration::from_millis(100)).unwrap();\n+                    }\n+                }\n+\n+                // If we haven't made progress, and our tip doesn't match our best header,\n+                // aggressively connect to new peers to find the block data.\n+                let new_tip = BlockIndex::tip();\n+                let new_header_tip = BlockIndex::best_header();\n+                if prev_tip == new_tip && new_tip != new_header_tip &&\n+                        Instant::now() - last_header_tip_update > Duration::from_secs(60) &&\n+                        Instant::now() - last_tip_update > Duration::from_secs(60) {\n+                    log_line(\"Progress not being made, seeking better peers!\", false);\n+                    if let Some(addr) = addr_tracker.get_rand_addr(&mut rand_ctx) {\n+                        let queues = Arc::new(MessageQueues {\n+                            inbound: Mutex::new(LinkedList::new()),\n+                            outbound: Mutex::new(LinkedList::new()),\n+                        });\n+                        let outbound_nonce = OutboundP2PNonce::new(connman, &mut rand_ctx);\n+                        queues.outbound.lock().unwrap().push_back(NetMsg::Msg(NetworkMessage::Version(VersionMessage {\n+                            version: PROTOCOL_VERSION,\n+                            services: (1 << 3) | (1 << 10), // We don't bother to track pruning status\n+                            timestamp: SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap().as_secs() as i64,\n+                            receiver: address::Address {\n+                                services: 0,\n+                                address: [0; 8], //TODO?\n+                                port: 0, //TODO?\n+                            },\n+                            sender: address::Address {\n+                                services: 0,\n+                                address: [0; 8],\n+                                port: 0,\n+                            },\n+                            nonce: outbound_nonce.nonce(),\n+                            user_agent: subver.clone(),\n+                            start_height: new_tip.height(),\n+                            relay: false, // Blocks only\n+                        })));\n+                        pending_outbounds.lock().unwrap().push((Arc::clone(&queues), addr.clone()));\n+                        peers.push(PeerState {\n+                            queues,\n+                            remote_addr: addr,\n+                            is_outbound: true,\n+                            outbound_nonce: Some(outbound_nonce),\n+                            recvd_ver: false,\n+                            recvd_verack: false,\n+                            recvd_sendheaders: false,\n+                            block_state: BlockProviderState::new_with_current_best(BlockIndex::genesis()),\n+                            next_header_poll: Instant::now() + HEADER_POLL_INTERVAL,\n+                            next_block_request: None,\n+                            next_block_request_time: Instant::now() + BLOCK_REQ_DELAY,\n+                            last_ping_nonce: None,\n+                            next_ping_time: Instant::now() + PING_INTERVAL,\n+                        });\n+                    }\n+                }\n+                if new_header_tip != prev_header_tip {\n+                    prev_header_tip = new_header_tip;\n+                    last_header_tip_update = Instant::now();\n+                }\n+                if new_tip != prev_tip {\n+                    prev_tip = new_tip;\n+                    last_tip_update = Instant::now();\n+                }\n+\n+                {\n+                    let mut inbounds = pending_inbounds.lock().unwrap();\n+                    for (queues, addr) in inbounds.drain(..) {\n+                        peers.push(PeerState {\n+                            queues,\n+                            remote_addr: addr,\n+                            is_outbound: false,\n+                            outbound_nonce: None,\n+                            recvd_ver: false,\n+                            recvd_verack: false,\n+                            recvd_sendheaders: false,\n+                            block_state: BlockProviderState::new_with_current_best(BlockIndex::genesis()),\n+                            next_header_poll: Instant::now() + HEADER_POLL_INTERVAL,\n+                            next_block_request: None,\n+                            next_block_request_time: Instant::now() + BLOCK_REQ_DELAY,\n+                            last_ping_nonce: None,\n+                            next_ping_time: Instant::now() + PING_INTERVAL,\n+                        });\n+                    }\n+                }\n+\n+                // Process new inbound messages\n+                let mut i = 0;\n+                'peer_iter: while i != peers.len() {\n+                    let mut drop_peer = false;\n+                    {\n+                        let peer = &mut peers[i];\n+\n+                        macro_rules! write_msg { ($msg: expr) => { {\n+                            peer.queues.outbound.lock().unwrap().push_back($msg);\n+                            waker.wake();\n+                        } } }\n+\n+                        // Request headers, starting at $from_target and continuing for up to 2000\n+                        // blocks.\n+                        macro_rules! request_headers { ($from_target: expr) => { {\n+                            let mut locator_hashes = vec![Hash::from_inner($from_target.hash())];\n+                            if let Some(ancestor) = $from_target.get_ancestor($from_target.height() - 1008) {\n+                                locator_hashes.push(Hash::from_inner(ancestor.hash()));\n+                            }\n+                            write_msg!(NetMsg::Msg(NetworkMessage::GetHeaders(GetHeadersMessage {\n+                                version: PROTOCOL_VERSION,\n+                                locator_hashes,\n+                                stop_hash: Hash::from_inner([0; 32]),\n+                            })));\n+                        } } }\n+\n+                        while let Some(msg) = {\n+                            // If, eg, we're sending blocks, we have to wait for them to receive them\n+                            // before we want to go push another one into the send buffer...\n+                            if peer.queues.outbound.lock().unwrap().len() >= MAX_QUEUE_LEN {\n+                                None\n+                            } else {\n+                                peer.queues.inbound.lock().unwrap().pop_front()\n+                            }\n+                        } {\n+                            match msg {\n+                                NetMsg::EOF => { drop_peer = true; break; },\n+                                NetMsg::Msg(NetworkMessage::Version(ver)) => {\n+                                    if peer.recvd_ver { drop_peer = true; break; }\n+                                    // Check that we've connected to a full node that supports SegWit\n+                                    if ver.services & ((1 << 10) | (1 << 0)) == 0 || ver.services & (1 << 3) == 0 {\n+                                        drop_peer = true;\n+                                        break;\n+                                    }\n+                                    if !peer.is_outbound {\n+                                        if should_disconnect_by_inbound_nonce(connman, ver.nonce) {\n+                                            drop_peer = true;\n+                                            break;\n+                                        }\n+                                        write_msg!(NetMsg::Msg(NetworkMessage::Version(VersionMessage {\n+                                            version: PROTOCOL_VERSION,\n+                                            services: (1 << 3) | (1 << 10), // We don't bother to track pruning status\n+                                            timestamp: SystemTime::now().duration_since(SystemTime::UNIX_EPOCH).unwrap().as_secs() as i64,\n+                                            receiver: address::Address {\n+                                                services: 0,\n+                                                address: [0; 8], //TODO?\n+                                                port: 0, //TODO?\n+                                            },\n+                                            sender: address::Address {\n+                                                services: 0,\n+                                                address: [0; 8], //TODO?\n+                                                port: 0, //TODO?\n+                                            },\n+                                            nonce: 0,\n+                                            user_agent: subver.clone(),\n+                                            start_height: new_tip.height(),\n+                                            relay: false, // Blocks only\n+                                        })));\n+                                    }\n+                                    write_msg!(NetMsg::Msg(NetworkMessage::Verack));\n+                                    peer.recvd_ver = true;\n+                                },\n+                                NetMsg::Msg(NetworkMessage::Verack) => {\n+                                    if peer.recvd_verack { drop_peer = true; break; }\n+                                    peer.outbound_nonce = None;\n+                                    peer.recvd_verack = true;\n+                                    write_msg!(NetMsg::Msg(NetworkMessage::GetAddr));\n+                                },\n+                                _ if !peer.recvd_ver || !peer.recvd_verack => { drop_peer = true; break; },\n+                                NetMsg::Msg(NetworkMessage::SendHeaders) => {\n+                                    peer.recvd_sendheaders = true;\n+                                },\n+                                NetMsg::Msg(NetworkMessage::GetAddr) => {\n+                                    // We refuse to respond to getaddr messages to protect our own\n+                                    // privacy.\n+                                },\n+                                NetMsg::Msg(NetworkMessage::Addr(addrs)) => {\n+                                    addr_tracker.addrs_recvd(&peer.remote_addr, peer.is_outbound, &addrs);\n+                                },\n+                                NetMsg::Msg(NetworkMessage::GetBlocks(getblocks)) => {\n+                                    let resp = generate_locator_response(new_tip, &getblocks.locator_hashes, &getblocks.stop_hash,\n+                                                                         |index| Inventory { inv_type: InvType::WitnessBlock, hash: Hash::from_inner(index.hash()) },\n+                                                                         || Inventory { inv_type: InvType::WitnessBlock, hash: Default::default() });\n+                                    write_msg!(NetMsg::Msg(NetworkMessage::Inv(resp)));\n+                                },\n+                                NetMsg::Msg(NetworkMessage::GetHeaders(getheaders)) => {\n+                                    let resp = generate_locator_response(new_tip, &getheaders.locator_hashes, &getheaders.stop_hash,\n+                                                                         |index| deserialize::<BlockHeader>(&index.header_bytes()).expect(\"Headers are valid\"),\n+                                                                         || BlockHeader { version: 0, prev_blockhash: Default::default(), merkle_root: Default::default(), time: 0, bits: 0, nonce: 0 });\n+                                    write_msg!(NetMsg::Msg(NetworkMessage::Headers(resp)));\n+                                },\n+                                NetMsg::Msg(NetworkMessage::GetData(mut invs)) => {\n+                                    let mut cut_idx = invs.len();\n+                                    for (idx, inv) in invs.iter().enumerate() {\n+                                        if inv.inv_type == InvType::WitnessBlock {\n+                                            if let Some(index) = BlockIndex::get_from_hash(&inv.hash.into_inner(), Some(new_tip)) {\n+                                                write_msg!(NetMsg::SerializedBlock(index.block_bytes()));\n+                                                cut_idx = idx;\n+                                                break;\n+                                            }\n+                                        }\n+                                    }\n+                                    if cut_idx != invs.len() {\n+                                        // Push the remaining blocks requested back into the message\n+                                        // stack for processing - we'll check if there's buffer space\n+                                        // when we go around again.\n+                                        let new_invs = invs.split_off(cut_idx + 1);\n+                                        peer.queues.inbound.lock().unwrap().push_front(NetMsg::Msg(NetworkMessage::GetData(new_invs)));\n+                                    }\n+                                },\n+                                NetMsg::Msg(NetworkMessage::Inv(invs)) => {\n+                                    for inv in invs.iter() {\n+                                        if inv.inv_type == InvType::WitnessBlock || inv.inv_type == InvType::Block {\n+                                            if let Some(index) = BlockIndex::get_from_hash(&inv.hash.into_inner(), Some(new_tip)) {\n+                                                peer.block_state.set_current_best(index);\n+                                            } else {\n+                                                // Request the header itself, using a null locator. If\n+                                                // we are somehow missing a block in between, thats ok,\n+                                                // we'll fall back to the header-fetch polling soon.\n+                                                write_msg!(NetMsg::Msg(NetworkMessage::GetHeaders(GetHeadersMessage {\n+                                                    version: PROTOCOL_VERSION,\n+                                                    locator_hashes: Vec::new(),\n+                                                    stop_hash: inv.hash,\n+                                                })));\n+                                            }\n+                                        }\n+                                    }\n+                                },\n+                                NetMsg::Msg(NetworkMessage::Headers(ref headers)) if !headers.is_empty() => {\n+                                    if let Some(best_connected) = connect_headers(&headers) {\n+                                        if headers.len() == HEADERS_LEN_CONTINUE {\n+                                            if best_connected.total_work() > peer.block_state.get_current_best().total_work() {\n+                                                // We've succeeded at fetching some new headers from\n+                                                // this peer, and should request more. If we hit a\n+                                                // regular header poll we'll probably end up just\n+                                                // sending roughly the same request again...instead,\n+                                                // delay fetching and give them the chance to get us up\n+                                                // to sync with them via this response-request flow.\n+                                                request_headers!(best_connected);\n+                                                peer.next_header_poll = Instant::now() + HEADER_POLL_INTERVAL;\n+                                            }\n+                                        }\n+                                        // Always blindly assume the last header we receive is the\n+                                        // peer's current best. This should be fine as long as we never\n+                                        // request headers when we don't believe the requested header\n+                                        // is their best block.\n+                                        // One important violation to keep in mind is that we may send\n+                                        // a headers request without enough locator hashes for them to\n+                                        // find our chain, resulting in them responding with headers\n+                                        // starting with genesis. To avoid this happening needlessly\n+                                        // when they reorg a block or two, we always try to send a\n+                                        // locator with a second block a week back.\n+                                        // While this should not result in a lack of robustness, it may\n+                                        // result in us redownloading the header chain from them.\n+                                        peer.block_state.set_current_best(best_connected);\n+                                    } else {\n+                                        // The peer sent us a non-empty headers message, indicating\n+                                        // they're trying to speak to us, I know it! I just don't know\n+                                        // what they're saying...we'll request again within 30 seconds.\n+                                        // Note that we don't want to make a request again here as it's\n+                                        // likely they're just sending is a block at their tip which we\n+                                        // haven't sync'ed to yet, and we'll end up making redundant\n+                                        // requests.\n+                                    }\n+                                },\n+                                NetMsg::SerializedBlock(blockdata) => {\n+                                    // If the block is a descendant of their best header, their best\n+                                    // header is not known to be invalid, their best header has more\n+                                    // work than ours, and their best header meets min chain work,\n+                                    // force processing (aka storing) the block.\n+                                    // Otherwise, just process normally.\n+                                    if let Ok(header) = BlockHeader::consensus_decode(&blockdata[..]) {\n+                                        if let Some(index) = BlockIndex::get_from_hash(&header.bitcoin_hash().into_inner(), Some(new_tip)) {\n+                                            if is_probably_on_best_chain(new_tip, index, peer.block_state.get_current_best()) {\n+                                                connect_block(&blockdata, Some(index));\n+                                            } else {\n+                                                connect_block(&blockdata, None);\n+                                            }\n+                                        } else {\n+                                            // Don't have the header connected anywhere. This block is\n+                                            // almost certainly useless and we probably didn't request\n+                                            // it, but hand it off to C++ just in case.\n+                                            connect_block(&blockdata, None);\n+                                        }\n+                                    } else {\n+                                        // If we couldn't even decode the header, just disconnect them.\n+                                        drop_peer = true; break;\n+                                    }\n+                                },\n+                                NetMsg::Msg(NetworkMessage::Ping(nonce)) => {\n+                                    write_msg!(NetMsg::Msg(NetworkMessage::Pong(nonce)));\n+                                },\n+                                NetMsg::Msg(NetworkMessage::Pong(nonce)) => {\n+                                    if Some(nonce) == peer.last_ping_nonce {\n+                                        peer.last_ping_nonce = None;\n+                                    }\n+                                },\n+                                _ => {},\n+                            }\n+                        }\n+\n+                        // Poll for their latest header once every 30 seconds by sending a GetHeaders.\n+                        if !drop_peer && peer.next_header_poll < Instant::now() {\n+                            // If we haven't yet received their version/verack within 30 seconds after\n+                            // connecting, just drop the peer...\n+                            if !peer.recvd_ver || !peer.recvd_verack {\n+                                drop_peer = true;\n+                            } else {\n+                                // Always request one-header-ago so that we get a eader in response and\n+                                // update the best header we know they have.\n+                                request_headers!(new_header_tip.get_prev().unwrap_or(new_header_tip));\n+                                peer.next_header_poll = Instant::now() + HEADER_POLL_INTERVAL;\n+                            }\n+                        }\n+\n+                        // Regularly poll the BlockProviderState for a block to download and download\n+                        // any blocks that we've been waiting on for a while.\n+                        if !drop_peer && peer.next_block_request_time < Instant::now() {\n+                            let their_best = peer.block_state.get_current_best();\n+                            let cpp_requested = peer.block_state.get_next_block_to_download(true);\n+\n+                            if let Some(index) = peer.next_block_request {\n+                                // If we wanted to download the block in the past, and we still don't\n+                                // have data for it, and it has same or more work than our current tip,\n+                                // or builds towards a potential future tip, go ahead and download it.\n+                                if cpp_requested == Some(index) ||\n+                                   (index != new_tip && !index.have_block() && is_probably_on_best_chain(new_tip, index, their_best)) {\n+                                    write_msg!(NetMsg::Msg(NetworkMessage::GetData(vec![Inventory {\n+                                        inv_type: InvType::WitnessBlock,\n+                                        hash: Hash::from_inner(index.hash()),\n+                                    }])));\n+                                }\n+                                peer.next_block_request = None;\n+                            }\n+\n+                            let mut may_request = true;\n+                            if let Some(index) = cpp_requested {\n+                                // We go a new potential request block from the C++ block requester.\n+                                // Great! But lets assume its returning garbage on each call, and make\n+                                // sure the block it wants us to request meets our fetch requirements.\n+                                if is_probably_on_best_chain(new_tip, index, their_best) {\n+                                    peer.next_block_request = Some(index);\n+                                    may_request = false;\n+                                }\n+                            }\n+                            if may_request && is_probably_on_best_chain(new_tip, their_best, their_best) {\n+                                // If the standard block requester didn't find anything we wanted to\n+                                // do, and their chain meets the requirements for fetching,\n+                                // (gratuitously inefficiently) find the fork point that hasn't been\n+                                // downloaded and start fetching.\n+                                peer.next_block_request = find_missing_data_fork_point(new_tip, their_best);\n+                            }\n+                            peer.next_block_request_time = Instant::now() + BLOCK_REQ_DELAY;\n+                        }\n+\n+                        if !drop_peer && peer.next_ping_time < Instant::now() {\n+                            if peer.last_ping_nonce.is_some() {\n+                                drop_peer = true;\n+                            } else {\n+                                let nonce = rand_ctx.get_rand_u64();\n+                                peer.last_ping_nonce = Some(nonce);\n+                                peer.next_ping_time = Instant::now() + PING_INTERVAL;\n+                                write_msg!(NetMsg::Msg(NetworkMessage::Ping(nonce)));\n+                            }\n+                        }\n+                    }\n+\n+                    if drop_peer {\n+                        peers[i].queues.outbound.lock().unwrap().push_back(NetMsg::EOF);\n+                        waker.wake();\n+                        peers.remove(i);\n+                    } else {\n+                        i += 1;\n+                    }\n+                }\n+            }\n+        });\n+        THREAD_COUNT.fetch_sub(1, Ordering::AcqRel);\n+    });\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn stop_p2p_client() {\n+    while THREAD_COUNT.load(Ordering::Acquire) != 0 {\n+        std::thread::sleep(Duration::from_millis(10));\n+    }\n+}"
      },
      {
        "sha": "dbae9f0e75634e102a8f46038ac8e378d622b85e",
        "filename": "src/rusty/src/p2p_socket_handler.rs",
        "status": "added",
        "additions": 521,
        "deletions": 0,
        "changes": 521,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0be12500624d641d1aa7a7db8373081879203d6/src/rusty/src/p2p_socket_handler.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0be12500624d641d1aa7a7db8373081879203d6/src/rusty/src/p2p_socket_handler.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/p2p_socket_handler.rs?ref=d0be12500624d641d1aa7a7db8373081879203d6",
        "patch": "@@ -0,0 +1,521 @@\n+use std::collections::LinkedList;\n+use std::convert::TryInto;\n+use std::panic::{AssertUnwindSafe, catch_unwind};\n+use std::sync::{Arc, Condvar, Mutex};\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use std::net::{SocketAddr, SocketAddrV6, Ipv6Addr};\n+use std::net::{TcpStream, TcpListener};\n+use std::io::{Cursor, Read, Write};\n+use std::os::raw::c_int;\n+use std::os::unix::io::AsRawFd;\n+\n+use crate::bridge::*;\n+use crate::p2p_addrs::*;\n+\n+use bitcoin::consensus::{Decodable, Encodable};\n+use bitcoin::consensus::encode::CheckedData;\n+use bitcoin::network::message::{CommandString, RawNetworkMessage, NetworkMessage};\n+\n+#[inline]\n+pub fn slice_to_u32_le(slice: &[u8]) -> u32 {\n+    assert_eq!(slice.len(), 4);\n+    (slice[0] as u32) << 0*8 |\n+    (slice[1] as u32) << 1*8 |\n+    (slice[2] as u32) << 2*8 |\n+    (slice[3] as u32) << 3*8\n+}\n+\n+pub enum NetMsg {\n+    Msg(NetworkMessage),\n+    /// Since we just hand blocks over the wall to C++ for deserialization anyway, we don't bother\n+    /// to deserialize-reserialize-deserialize blocks and just put them, in full form, in a Vec.\n+    SerializedBlock(Vec<u8>),\n+    /// Indicates either the socket should be closed (if sent outbound) or that the socket has been\n+    /// closed (if received inbound)\n+    EOF,\n+}\n+\n+/// state that gets wrapped in an Arc to pass incoming and outgoing messages into/out of the socket\n+/// handling thread.\n+pub struct MessageQueues {\n+    pub inbound: Mutex<LinkedList<NetMsg>>,\n+    pub outbound: Mutex<LinkedList<NetMsg>>,\n+}\n+\n+const MSG_HDR_LEN: usize = 4 + 12 + 4 + 4;\n+/// Max number of messages to hold in the message queue, minus one\n+pub const MAX_QUEUE_LEN: usize = 2;\n+\n+#[cfg(target_family = \"unix\")]\n+mod poll {\n+    use super::*;\n+    use libc::{c_void, poll, pollfd, POLLIN, POLLOUT, pipe2, O_NONBLOCK, read};\n+\n+    /// Reference to a way to wake up the socket handling thread to write data.\n+    /// Currently implemented as a pipe write fd.\n+    pub struct Waker(c_int);\n+    impl Waker {\n+        pub fn wake(&self) {\n+            let data = [0u8; 1];\n+            unsafe { libc::write(self.0, data.as_ptr() as *const libc::c_void, 1) };\n+        }\n+    }\n+\n+    /// socket-handler-thread-specific data about a given peer (buffers and the socket itself).\n+    pub struct SocketData {\n+        pub sock: TcpStream,\n+        pub read_len: usize,\n+        pub read_buff: Vec<u8>,\n+        pub write_pos: usize,\n+        pub write_buff: Vec<u8>,\n+        pub queues: Arc<MessageQueues>,\n+    }\n+\n+    pub struct Sock<'a> {\n+        pfd: &'a mut pollfd,\n+        sock_data: &'a mut Option<SocketData>,\n+    }\n+    impl<'a> Sock<'a> {\n+        /// Only valid if using an iterator retruend from poll()!\n+        pub fn is_readable(&self) -> bool {\n+            self.pfd.revents & POLLIN == POLLIN\n+        }\n+        /// Only valid if using an iterator retruend from poll()!\n+        pub fn is_writable(&self) -> bool {\n+            self.pfd.revents & POLLOUT == POLLOUT\n+        }\n+        /// Always Some() unless drop_sock has been called on this Sock\n+        pub fn state<'b>(&'b mut self) -> Option<&'b mut SocketData> {\n+            self.sock_data.as_mut()\n+        }\n+        pub fn drop_sock(&mut self) {\n+            self.sock_data.as_ref().unwrap().queues.inbound.lock().unwrap().push_back(NetMsg::EOF);\n+            self.pfd.fd = -1;\n+            self.pfd.events = 0;\n+            *self.sock_data = None;\n+        }\n+        pub fn pause_read(&mut self) {\n+            self.pfd.events &= !POLLIN;\n+        }\n+        pub fn resume_read(&mut self) {\n+            self.pfd.events |= POLLIN;\n+        }\n+        /// Pause writing for now, note that if any outbound messages appear in queues, we\n+        /// automatically un-pause writing.\n+        pub fn pause_write(&mut self) {\n+            self.pfd.events &= !POLLOUT;\n+        }\n+    }\n+\n+    pub struct SockIter<'a>(std::iter::Zip<std::slice::IterMut<'a, pollfd>, std::slice::IterMut<'a, Option<SocketData>>>);\n+    impl<'a> Iterator for SockIter<'a> {\n+        type Item = Sock<'a>;\n+        fn next(&mut self) -> Option<Sock<'a>> {\n+            while let Some((pfd, sock_data)) = self.0.next() {\n+                if sock_data.is_some() {\n+                    return Some(Sock {\n+                        pfd,\n+                        sock_data,\n+                    });\n+                }\n+            }\n+            None\n+        }\n+    }\n+\n+    pub struct Sockets {\n+        /// File descriptors we are watching - first is always the wake pipe listen end.\n+        /// Second is \"reserved\" for a listen socket.\n+        /// Thereafter, each fds entry corresponds with a sock_data entry (which may be None,\n+        /// resulting in a fd of -1).\n+        fds: Vec<pollfd>,\n+        sock_data: Vec<Option<SocketData>>,\n+    }\n+    impl Sockets {\n+        pub fn new(listener: &Option<TcpListener>) -> (Self, Waker) {\n+            let mut wakefds: [c_int; 2] = [0; 2];\n+            assert_eq!(unsafe { pipe2(wakefds.as_mut_ptr(), O_NONBLOCK) }, 0);\n+            let waker = Waker(wakefds[1]);\n+            let fds = vec![pollfd {\n+                fd: wakefds[0],\n+                events: POLLIN,\n+                revents: 0,\n+            }, match listener {\n+                Some(sock) => {\n+                    sock.set_nonblocking(true).unwrap();\n+                    pollfd {\n+                        fd: sock.as_raw_fd(),\n+                        events: POLLIN,\n+                        revents: 0,\n+                    }\n+                },\n+                None => {\n+                    pollfd {\n+                        fd: -1,\n+                        events: 0,\n+                        revents: 0,\n+                    }\n+                },\n+            }];\n+            (Self {\n+                fds,\n+                sock_data: Vec::new(),\n+            }, waker)\n+        }\n+\n+        pub fn register_sockdata(&mut self, data: SocketData) {\n+            data.sock.set_nonblocking(true).unwrap();\n+            let pfd = pollfd {\n+                fd: data.sock.as_raw_fd(),\n+                events: POLLIN | POLLOUT,\n+                revents: 0,\n+            };\n+            for (idx, data_iter) in self.sock_data.iter_mut().enumerate() {\n+                if data_iter.is_none() {\n+                    *data_iter = Some(data);\n+                    self.fds[idx + 2] = pfd;\n+                    return;\n+                }\n+            }\n+            self.sock_data.push(Some(data));\n+            self.fds.push(pfd);\n+        }\n+\n+        /// Waits for socket events.\n+        /// Returns (a bool indicating there are incoming sockets available, iterator over\n+        /// existing-socket events).\n+        pub fn poll<'a>(&'a mut self, timeout_ms: c_int) -> (bool, SockIter<'a>) {\n+            // Check if any peers need their writing re-enabled, trying to avoid locking a bit\n+            // by only checking those with writing already paused.\n+            for mut sock in self.sock_iter() {\n+                if sock.pfd.events & POLLOUT == 0 {\n+                    if !sock.state().unwrap().queues.outbound.lock().unwrap().is_empty() {\n+                        sock.pfd.events |= POLLOUT;\n+                    }\n+                }\n+            }\n+            unsafe { poll(self.fds.as_mut_ptr(), self.fds.len().try_into().unwrap(), timeout_ms) };\n+            if self.fds[0].revents != 0 {\n+                // Always drain the read side of our wakeup pipe:\n+                let mut readbuff = [0u8; 8192];\n+                assert!(unsafe { read(self.fds[0].fd, readbuff.as_mut_ptr() as *mut c_void, 8192) } > 0);\n+            }\n+            (self.fds[1].revents & POLLIN == POLLIN, self.sock_iter())\n+        }\n+\n+        pub fn sock_iter<'a>(&'a mut self) -> SockIter<'a> {\n+            let mut fds_iter = self.fds.iter_mut();\n+            fds_iter.next();\n+            fds_iter.next();\n+            SockIter(fds_iter.zip(self.sock_data.iter_mut()))\n+        }\n+    }\n+}\n+pub use self::poll::Waker;\n+use self::poll::*;\n+\n+enum ReadResult {\n+    /// We maybe read some stuff, we should keep trying to read some stuff.\n+    Good,\n+    /// We should disconnect (or already have, and should clean up resources)\n+    Disconnect,\n+    /// We've read lots of stuff, we should process it before reading more\n+    PauseRead,\n+}\n+\n+/// Reads from the given socket, deserializing messages into the inbound queue, and potentially\n+/// pausing read if the queue grows too large.\n+fn sock_read(sock_state: &mut SocketData, msg_wake_condvar: &Condvar, msg_wake_mutex: &Mutex<()>) -> ReadResult {\n+    loop { // Read until we have too many pending messages or we get Err(WouldBlock)\n+        if sock_state.read_len == 0 {\n+            // We've paused reading, and probably shouldn't have gotten here, but we may have hit\n+            // some kind of spurious wake, so just return false and move on.\n+            return ReadResult::PauseRead;\n+        }\n+        // We should never be asked to read if we already have a buffer of the next-read size:\n+        assert!(sock_state.read_buff.len() < sock_state.read_len);\n+        let read_pos = sock_state.read_buff.len();\n+        sock_state.read_buff.resize(sock_state.read_len, 0u8);\n+        match sock_state.sock.read(&mut sock_state.read_buff[read_pos..]) {\n+            Ok(0) => {\n+                // EOF - we've been disconnected\n+                return ReadResult::Disconnect;\n+            },\n+            Ok(read_len) => {\n+                assert!(read_pos + read_len <= sock_state.read_buff.len());\n+                if read_pos + read_len == sock_state.read_buff.len() {\n+                    macro_rules! process_msg { () => { {\n+                        macro_rules! push_msg { ($msg: expr) => { {\n+                            if {\n+                                // Push the new message onto the queue, passing whether to\n+                                // pause read into the if without holding the lock.\n+                                let mut inbounds = sock_state.queues.inbound.lock().unwrap();\n+                                inbounds.push_back($msg);\n+                                inbounds.len() >= MAX_QUEUE_LEN\n+                            } || sock_state.queues.outbound.lock().unwrap().len() >= MAX_QUEUE_LEN {\n+                                // Drop the buffer and pause reading...\n+                                sock_state.read_buff.clear();\n+                                sock_state.read_buff.shrink_to_fit();\n+                                sock_state.read_len = 0;\n+                                return ReadResult::PauseRead;\n+                            } else {\n+                                // Re-capacity the buffer to 8KB and resize to 0\n+                                sock_state.read_buff.resize(8 * 1024, 0u8);\n+                                sock_state.read_buff.shrink_to_fit();\n+                                sock_state.read_buff.clear();\n+                                sock_state.read_len = MSG_HDR_LEN;\n+                            }\n+                            {\n+                                // All we need to do is ensure that the message-handling thread\n+                                // will check for available messages after we've pushed a message\n+                                // or go to sleep before we call notify_one(), below. If we just\n+                                // lock the msg_wake_mutex here, we ensure that either it has\n+                                // slept, or it has yet to check for available messages when we\n+                                // exit this block. Thus, we should be good!\n+                                //\n+                                // Note that we very much deliberately do not take this lock at the\n+                                // same time as any of the queue locks, thus leaving any lock\n+                                // ordering guarantees up to the message-handling thread.\n+                                let _ = msg_wake_mutex.lock().unwrap();\n+                            }\n+                            msg_wake_condvar.notify_one();\n+                        } } }\n+\n+                        match u32::consensus_decode(&sock_state.read_buff[..]) {\n+                            Ok(res) if res == bitcoin::Network::Bitcoin.magic() => {},\n+                            _ => return ReadResult::Disconnect,\n+                        }\n+                        // First deserialize the command. If it is a block, don't deserialize to a\n+                        // Rust-Bitcoin block (only to reserialize it and hand it to C++), but instead\n+                        // just check the checksum and hand it over the wall. Otherwise, call Rust-Bitcoin's\n+                        // deserialize routine for general network messages.\n+                        match CommandString::consensus_decode(&sock_state.read_buff[4..]) {\n+                            Ok(CommandString(ref cmd)) if cmd == \"block\" => {\n+                                match CheckedData::consensus_decode(&sock_state.read_buff[4 + 12..]) {\n+                                    Ok(res) => push_msg!(NetMsg::SerializedBlock(res.0)),\n+                                    Err(_) => return ReadResult::Disconnect,\n+                                }\n+                            },\n+                            Ok(_) => match RawNetworkMessage::consensus_decode(&sock_state.read_buff[..]) {\n+                                Ok(res) => push_msg!(NetMsg::Msg(res.payload)),\n+                                Err(bitcoin::consensus::encode::Error::UnrecognizedNetworkCommand(_)) => {\n+                                    // Re-capacity the buffer to 8KB and resize to 0\n+                                    sock_state.read_buff.resize(8 * 1024, 0u8);\n+                                    sock_state.read_buff.shrink_to_fit();\n+                                    sock_state.read_buff.clear();\n+                                    sock_state.read_len = MSG_HDR_LEN;\n+                                },\n+                                Err(_) => return ReadResult::Disconnect,\n+                            },\n+                            Err(_) => return ReadResult::Disconnect,\n+                        }\n+                    } } }\n+\n+                    // If we're currently reading the header, deserialize the payload length then continue\n+                    // the read loop. If the payload happens to be zero-length, process the message too.\n+                    if sock_state.read_len == MSG_HDR_LEN {\n+                        let payload_len = slice_to_u32_le(&sock_state.read_buff[4 + 12..4 + 12 + 4]);\n+                        if payload_len as usize > bitcoin::consensus::encode::MAX_VEC_SIZE {\n+                            return ReadResult::Disconnect;\n+                        }\n+                        if payload_len == 0 {\n+                            process_msg!();\n+                        } else {\n+                            sock_state.read_len = MSG_HDR_LEN + payload_len as usize;\n+                        }\n+                    } else {\n+                        process_msg!();\n+                    }\n+                } else {\n+                    // Drop the size of the read_buff to how much we've\n+                    // read. Shouldn't ever result in a realloc (nor\n+                    // should reading later, since capacity doesn't\n+                    // change).\n+                    sock_state.read_buff.resize(read_pos + read_len, 0u8);\n+                }\n+            },\n+            Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {\n+                sock_state.read_buff.resize(read_pos, 0u8);\n+                return ReadResult::Good;\n+            },\n+            Err(_) => return ReadResult::Disconnect,\n+        }\n+    }\n+}\n+\n+enum WriteResult {\n+    /// We maybe wrote some stuff, we should keep trying to write some stuff.\n+    Good,\n+    /// We should disconnect (or already have, and should clean up resources)\n+    Disconnect,\n+    /// We've written all the stuff.\n+    DoneWriting,\n+}\n+\n+/// Writes to the given socket, taking messages from the outbound queue as necessary.\n+/// Does *not* automatically unpause read if we've sufficiently drained the outbound queue.\n+fn sock_write(sock_state: &mut SocketData) -> WriteResult {\n+    loop { // Write until we get Err(WouldBlock)\n+        if sock_state.write_pos >= sock_state.write_buff.len() { // ie incl sock_state.write_buff.is_empty()\n+            let next_out_msg = sock_state.queues.outbound.lock().unwrap().pop_front();\n+            if let Some(write_msg) = next_out_msg {\n+                match write_msg {\n+                    NetMsg::Msg(msg) => {\n+                        let mut write_buff = Vec::new();\n+                        std::mem::swap(&mut write_buff, &mut sock_state.write_buff);\n+                        let mut cursor = Cursor::new(write_buff);\n+                        RawNetworkMessage {\n+                            magic: bitcoin::Network::Bitcoin.magic(),\n+                            payload: msg,\n+                        }.consensus_encode(&mut cursor).expect(\"Should only get I/O errors, which Cursor won't generate\");\n+                        std::mem::swap(&mut cursor.into_inner(), &mut sock_state.write_buff);\n+                        sock_state.write_pos = 0;\n+                    },\n+                    NetMsg::SerializedBlock(block) => {\n+                        let mut write_buff = Vec::new();\n+                        std::mem::swap(&mut write_buff, &mut sock_state.write_buff);\n+                        let mut cursor = Cursor::new(write_buff);\n+                        bitcoin::Network::Bitcoin.magic().consensus_encode(&mut cursor).unwrap();\n+                        CommandString(\"block\".to_string()).consensus_encode(&mut cursor).unwrap();\n+                        CheckedData(block).consensus_encode(&mut cursor).unwrap();\n+                        std::mem::swap(&mut cursor.into_inner(), &mut sock_state.write_buff);\n+                        sock_state.write_pos = 0;\n+                    },\n+                    NetMsg::EOF => { return WriteResult::Disconnect; },\n+                }\n+            } else {return WriteResult::DoneWriting; }\n+        }\n+        match sock_state.sock.write(&mut sock_state.write_buff[sock_state.write_pos..]) {\n+            Ok(0) => { panic!(); }, //XXX: No, but need to figure out if this means EOF or WouldBlock!\n+            Ok(writelen) => {\n+                assert!(writelen <= sock_state.write_buff.len() - sock_state.write_pos);\n+                sock_state.write_pos += writelen;\n+                if sock_state.write_pos == sock_state.write_buff.len() {\n+                    // Re-capacity the buffer to 8KB and resize to 0\n+                    sock_state.write_buff.resize(8 * 1024, 0u8);\n+                    sock_state.write_buff.shrink_to_fit();\n+                    sock_state.write_buff.clear();\n+                }\n+            },\n+            Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => return WriteResult::Good,\n+            Err(_) => return WriteResult::Disconnect,\n+        }\n+    }\n+}\n+\n+pub fn spawn_socket_handler(thread_count_tracker: &'static AtomicUsize, bind_port: u16, msg_wake_arg: Arc<Condvar>, msg_wake_mutex: Arc<Mutex<()>>, pending_outbounds: Arc<Mutex<Vec<(Arc<MessageQueues>, NetAddress)>>>, pending_inbounds: Arc<Mutex<Vec<(Arc<MessageQueues>, NetAddress)>>>) -> Waker {\n+    let listener = if bind_port != 0 {\n+        if let Ok(listener) = TcpListener::bind(SocketAddr::V6(SocketAddrV6::new(Ipv6Addr::new(0,0,0,0,0,0,0,0), bind_port, 0, 0))) {\n+            Some(listener)\n+        } else { None }\n+    } else { None };\n+    let (mut poll, waker) = Sockets::new(&listener);\n+\n+    std::thread::spawn(move || {\n+        // Always catch panics so that even if we have some bug in our parser we don't take the\n+        // rest of Bitcoin Core down with us:\n+        thread_count_tracker.fetch_add(1, Ordering::AcqRel);\n+        //XXX: WTF DOES THIS MEAN:\n+        let msg_wake_condvar = AssertUnwindSafe(msg_wake_arg);\n+        let _ = catch_unwind(move || {\n+            while unsafe { !rusty_ShutdownRequested() } {\n+                macro_rules! register_sock {\n+                    ($queues: expr, $sock: expr) => { {\n+                        poll.register_sockdata(SocketData {\n+                            sock: $sock,\n+                            queues: $queues,\n+                            read_len: MSG_HDR_LEN,\n+                            read_buff: Vec::new(),\n+                            write_pos: 0,\n+                            write_buff: Vec::new(),\n+                        });\n+                    } }\n+                }\n+\n+                if {\n+                    let (inbounds, iter) = poll.poll(100);\n+                    for mut event in iter {\n+                        if event.is_readable() {\n+                            match sock_read(event.state().unwrap(), &msg_wake_condvar, &msg_wake_mutex) {\n+                                ReadResult::Disconnect => {\n+                                    event.drop_sock();\n+                                    continue;\n+                                },\n+                                ReadResult::PauseRead => {\n+                                    event.pause_read()\n+                                },\n+                                ReadResult::Good => {},\n+                            }\n+                        }\n+\n+                        if event.is_writable() {\n+                            match sock_write(event.state().unwrap()) {\n+                                WriteResult::Disconnect => {\n+                                    event.drop_sock();\n+                                    continue;\n+                                },\n+                                WriteResult::DoneWriting => {\n+                                    event.pause_write()\n+                                },\n+                                WriteResult::Good => {},\n+                            }\n+                        }\n+                    }\n+                    inbounds\n+                } {\n+                    match listener.as_ref().unwrap().accept() {\n+                        Ok((sock, addr)) => {\n+                            let queues = Arc::new(MessageQueues {\n+                                inbound: Mutex::new(LinkedList::new()),\n+                                outbound: Mutex::new(LinkedList::new()),\n+                            });\n+                            pending_inbounds.lock().unwrap().push((Arc::clone(&queues), NetAddress::new(addr)));\n+                            register_sock!(queues, sock);\n+                        },\n+                        Err(ref e) if e.kind() == std::io::ErrorKind::WouldBlock => {},\n+                        Err(_) => { panic!(\"How did we lose a listening sock?!\"); },\n+                    }\n+                }\n+\n+                for mut sock in poll.sock_iter() {\n+                    match {\n+                        let sock_state = sock.state().unwrap();\n+                        // If we paused reading for this peer (read_len == 0) and the inbound+outbound\n+                        // message queues have room again, unpause reading.\n+                        if sock_state.read_len == 0 && sock_state.queues.inbound.lock().unwrap().len() < MAX_QUEUE_LEN &&\n+                            sock_state.queues.outbound.lock().unwrap().len() < MAX_QUEUE_LEN {\n+                            sock_state.read_len = MSG_HDR_LEN;\n+                            sock_read(sock_state, &msg_wake_condvar, &msg_wake_mutex)\n+                        } else { ReadResult::Good }\n+                    } {\n+                        ReadResult::Disconnect => {\n+                            sock.drop_sock();\n+                            continue;\n+                        },\n+                        ReadResult::PauseRead => {\n+                            sock.pause_read()\n+                        },\n+                        ReadResult::Good => {\n+                            sock.resume_read()\n+                        },\n+                    }\n+                }\n+\n+                // Check if we've been asked to open new connections...\n+                let mut outbounds = pending_outbounds.lock().unwrap();\n+                'connect_loop: for (queues, addr) in outbounds.drain(..) {\n+                    match match addr {\n+                        NetAddress::IPv4(a) => TcpStream::connect(SocketAddr::V4(a)).ok(),\n+                        NetAddress::IPv6(a) => TcpStream::connect(SocketAddr::V6(a)).ok(),\n+                        _ => None,\n+                    } {\n+                        Some(sock) => { register_sock!(queues, sock); },\n+                        None => {},\n+                    }\n+                }\n+            }\n+        });\n+        thread_count_tracker.fetch_sub(1, Ordering::AcqRel);\n+    });\n+    waker\n+}"
      },
      {
        "sha": "e1fbdda60e4ed9c04bab75cbf303d83155d274a9",
        "filename": "src/rusty/src/rust_bridge.h",
        "status": "modified",
        "additions": 4,
        "deletions": 0,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/d0be12500624d641d1aa7a7db8373081879203d6/src/rusty/src/rust_bridge.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/d0be12500624d641d1aa7a7db8373081879203d6/src/rusty/src/rust_bridge.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/rust_bridge.h?ref=d0be12500624d641d1aa7a7db8373081879203d6",
        "patch": "@@ -19,6 +19,10 @@ bool init_fetch_dns_headers(const char *domain);\n bool stop_fetch_dns_headers();\n bool init_fetch_rest_blocks(const char *uri);\n bool stop_fetch_rest_blocks();\n+bool init_p2p_client(void* pconnman, const char *datadir, const char *subver, uint16_t bind_port, const char **dnsseed_names, size_t dnsseed_count);\n+bool stop_p2p_client();\n+\n+static const bool DEFAULT_P2P = true;\n \n } // extern \"C\"\n "
      }
    ]
  },
  {
    "sha": "33287e2a3f516e38d70537436c680c4b43be3587",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzozMzI4N2UyYTNmNTE2ZTM4ZDcwNTM3NDM2YzY4MGM0YjQzYmUzNTg3",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-03T04:20:26Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2019-11-05T04:54:30Z"
      },
      "message": "Add headers tree in test bridge and test locator response generation",
      "tree": {
        "sha": "e32c7cf56058c8d8791c26060dc5aa5d7bfc2418",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/e32c7cf56058c8d8791c26060dc5aa5d7bfc2418"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/33287e2a3f516e38d70537436c680c4b43be3587",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/33287e2a3f516e38d70537436c680c4b43be3587",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/33287e2a3f516e38d70537436c680c4b43be3587",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/33287e2a3f516e38d70537436c680c4b43be3587/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "d0be12500624d641d1aa7a7db8373081879203d6",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/d0be12500624d641d1aa7a7db8373081879203d6",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/d0be12500624d641d1aa7a7db8373081879203d6"
      }
    ],
    "stats": {
      "total": 178,
      "additions": 167,
      "deletions": 11
    },
    "files": [
      {
        "sha": "8b06648da1424a279450fdb70277256bbdc5df83",
        "filename": "src/rusty/src/p2p_client.rs",
        "status": "modified",
        "additions": 68,
        "deletions": 0,
        "changes": 68,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/33287e2a3f516e38d70537436c680c4b43be3587/src/rusty/src/p2p_client.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/33287e2a3f516e38d70537436c680c4b43be3587/src/rusty/src/p2p_client.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/p2p_client.rs?ref=33287e2a3f516e38d70537436c680c4b43be3587",
        "patch": "@@ -157,6 +157,74 @@ fn generate_locator_response<T: Clone, Conv: Fn(BlockIndex) -> T, Dummy: Fn() ->\n     res\n }\n \n+#[cfg(test)]\n+#[test]\n+fn test_locator_lookup() {\n+    // Build a block tree that we can look up against\n+    // G -> 2k blocks -> 2001 A -> 2k blocks -> 4002 C -> 2k blocks -> 6003 E\n+    //               \\-> 2001 B             \\-> 4002 D\n+    let mut block = BlockIndex::genesis();\n+    let mut best_chain = Vec::new();\n+    best_chain.push(block);\n+    for _ in 0..2000 {\n+        block = build_on(block);\n+        best_chain.push(block);\n+    }\n+    let b = build_on(block);\n+    block = build_on(block);\n+    best_chain.push(block);\n+    let a = block;\n+    assert_eq!(a.height(), 2001);\n+    for _ in 0..2000 {\n+        block = build_on(block);\n+        best_chain.push(block);\n+    }\n+    let d = build_on(block);\n+    block = build_on(block);\n+    best_chain.push(block);\n+    let c = block;\n+    assert_eq!(c.height(), 4002);\n+    for _ in 0..2000 {\n+        block = build_on(block);\n+        best_chain.push(block);\n+    }\n+    let e = build_on(block);\n+    best_chain.push(e);\n+    assert_eq!(e.height(), 6003);\n+    set_bests(e, e);\n+\n+    // Basic test just asking for D and getting the main fork back\n+    let d_to_e_minus_two = generate_locator_response(e, &vec![Hash::from_inner(d.hash())], &Hash::from_inner([0; 32]),\n+            |index| index, || BlockIndex::genesis());\n+    assert_eq!(d_to_e_minus_two.len(), 2000);\n+    assert_eq!(d_to_e_minus_two[0], c);\n+    assert_eq!(d_to_e_minus_two[..], best_chain[4002..6002]);\n+\n+    // Basic test just asking for E minus a few gets to E\n+    let near_tip_index = e.get_prev().unwrap().get_prev().unwrap().get_prev().unwrap();\n+    let near_to_e = generate_locator_response(e,\n+            &vec![Hash::from_inner(near_tip_index.get_prev().unwrap().hash())], &Hash::from_inner([0; 32]),\n+            |index| index, || BlockIndex::genesis());\n+    assert_eq!(near_to_e.len(), 4);\n+    assert_eq!(near_to_e[0], near_tip_index);\n+    assert_eq!(near_to_e[3], e);\n+    assert_eq!(near_to_e[..], best_chain[6000..]);\n+\n+    // Asking for just one header...gets just one header\n+    assert_eq!(generate_locator_response(e, &Vec::new(), &Hash::from_inner(a.hash()),\n+            |index| index, || BlockIndex::genesis()), vec![a]);\n+\n+    // Asking for something not on the best chain should get no response...\n+    assert_eq!(generate_locator_response(e, &Vec::new(), &Hash::from_inner(b.hash()),\n+            |index| index, || BlockIndex::genesis()), Vec::new());\n+\n+    // Asking for something that forks off the main chain long ago should be treated as genesis...\n+    let from_genesis = generate_locator_response(e, &vec![Hash::from_inner(b.hash())], &Hash::from_inner([0; 32]),\n+            |index| index, || BlockIndex::genesis());\n+    assert_eq!(from_genesis.len(), 2000);\n+    assert_eq!(from_genesis[..], best_chain[1..2001]);\n+}\n+\n /// Finds the first ancestor from candidate_tip going back to the fork block from our_tip that\n /// doesn't have data. This is gratuitously expensive, so we should prefer to avoid it, in general.\n fn find_missing_data_fork_point(mut our_tip: BlockIndex, mut candidate_tip: BlockIndex) -> Option<BlockIndex> {"
      },
      {
        "sha": "6f4aff1d14a8fac06348ffb6abe2aa59c8faad83",
        "filename": "src/rusty/src/test_bridge.rs",
        "status": "modified",
        "additions": 99,
        "deletions": 11,
        "changes": 110,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/33287e2a3f516e38d70537436c680c4b43be3587/src/rusty/src/test_bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/33287e2a3f516e38d70537436c680c4b43be3587/src/rusty/src/test_bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/test_bridge.rs?ref=33287e2a3f516e38d70537436c680c4b43be3587",
        "patch": "@@ -1,6 +1,9 @@\n ///! \"bridge\" to C++ code without any backing C++ code. Used for shimming in dummies for testing.\n \n+use std::collections::HashMap;\n use std::ffi::c_void;\n+use std::sync::atomic::{AtomicPtr, Ordering};\n+use std::sync::Mutex;\n \n use bitcoin::blockdata::block::BlockHeader;\n use bitcoin::util::uint::Uint256;\n@@ -23,8 +26,75 @@ pub fn connect_block(_blockdata: &[u8], _blockindex_requested_by_state: Option<B\n     unimplemented!();\n }\n \n-#[derive(PartialEq, Clone, Copy)]\n-pub struct BlockIndex { }\n+struct BlockTree {\n+    blocks: HashMap<[u8; 32], BlockIndex>,\n+    best_block: [u8; 32],\n+    best_header: [u8; 32],\n+}\n+static BLOCKS: AtomicPtr<Mutex<BlockTree>> = AtomicPtr::new(std::ptr::null_mut());\n+\n+fn check_blocks_avail() -> &'static Mutex<BlockTree> {\n+    if BLOCKS.load(Ordering::Relaxed).is_null() {\n+        let mut new = BlockTree {\n+            blocks: HashMap::new(),\n+            best_block: [1; 32],\n+            best_header: [1; 32],\n+        };\n+        new.blocks.insert([1; 32], BlockIndex {\n+            height: 0,\n+            hash: [1; 32],\n+            prev: [0; 32],\n+        });\n+        let mut mutex = Box::new(Mutex::new(new));\n+        let new_ptr = &mut *mutex as *mut Mutex<BlockTree>;\n+        if let Ok(_) = BLOCKS.compare_exchange(std::ptr::null_mut(), new_ptr, Ordering::AcqRel, Ordering::Acquire) {\n+            assert!(std::ptr::eq(Box::leak(mutex), new_ptr));\n+        }\n+    }\n+    unsafe { &*BLOCKS.load(Ordering::Relaxed) }\n+}\n+\n+/// Extend the block tree by one on top of index\n+pub fn build_on(index: BlockIndex) -> BlockIndex {\n+    let mut blocks = check_blocks_avail().lock().unwrap();\n+    let newblock = BlockIndex {\n+        height: index.height + 1,\n+        hash: [\n+            ((blocks.blocks.len() as u64) >> 7*8) as u8,\n+            ((blocks.blocks.len() as u64) >> 6*8) as u8,\n+            ((blocks.blocks.len() as u64) >> 5*8) as u8,\n+            ((blocks.blocks.len() as u64) >> 4*8) as u8,\n+            ((blocks.blocks.len() as u64) >> 3*8) as u8,\n+            ((blocks.blocks.len() as u64) >> 2*8) as u8,\n+            ((blocks.blocks.len() as u64) >> 1*8) as u8,\n+            ((blocks.blocks.len() as u64) >> 0*8) as u8,\n+            (((index.height + 1) as u64) >> 7*8) as u8,\n+            (((index.height + 1) as u64) >> 6*8) as u8,\n+            (((index.height + 1) as u64) >> 5*8) as u8,\n+            (((index.height + 1) as u64) >> 4*8) as u8,\n+            (((index.height + 1) as u64) >> 3*8) as u8,\n+            (((index.height + 1) as u64) >> 2*8) as u8,\n+            (((index.height + 1) as u64) >> 1*8) as u8,\n+            (((index.height + 1) as u64) >> 0*8) as u8,\n+            0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n+        prev: index.hash,\n+    };\n+    blocks.blocks.insert(newblock.hash, newblock);\n+    newblock\n+}\n+\n+pub fn set_bests(best_header: BlockIndex, best_block: BlockIndex) {\n+    let mut blocks = check_blocks_avail().lock().unwrap();\n+    blocks.best_block = best_block.hash;\n+    blocks.best_header = best_header.hash;\n+}\n+\n+#[derive(Debug, PartialEq, Clone, Copy)]\n+pub struct BlockIndex {\n+    height: i32,\n+    hash: [u8; 32],\n+    prev: [u8; 32],\n+}\n \n impl BlockIndex {\n     pub fn tip() -> Self {\n@@ -35,28 +105,41 @@ impl BlockIndex {\n         unimplemented!();\n     }\n \n-    pub fn get_from_hash(_hash: &[u8; 32], _best_tip: Option<Self>) -> Option<Self> {\n-        unimplemented!();\n+    pub fn get_from_hash(hash: &[u8; 32], _best_tip: Option<Self>) -> Option<Self> {\n+        let res = check_blocks_avail().lock().unwrap().blocks.get(hash).cloned();\n+        if let Some(index) = res {\n+            if index.is_knowledge_public() { return res; }\n+        }\n+        None\n     }\n \n     pub fn genesis() -> Self {\n-        unimplemented!();\n+        let blocks = check_blocks_avail().lock().unwrap();\n+        blocks.blocks.get(&[1; 32]).unwrap().clone()\n     }\n \n     pub fn get_prev(&self) -> Option<Self> {\n-        unimplemented!();\n+        if self.height == 0 { return None; }\n+        let blocks = check_blocks_avail().lock().unwrap();\n+        Some(blocks.blocks.get(&self.prev).unwrap().clone())\n     }\n \n-    pub fn get_ancestor(&self, _height: i32) -> Option<Self> {\n-        unimplemented!();\n+    pub fn get_ancestor(&self, height: i32) -> Option<Self> {\n+        if height > self.height || height < 0 { return None; }\n+        let blocks = check_blocks_avail().lock().unwrap();\n+        let mut res = *self;\n+        while res.height != height {\n+            res = blocks.blocks.get(&res.prev).unwrap().clone();\n+        }\n+        Some(res)\n     }\n \n     pub fn height(&self) -> i32 {\n-        unimplemented!();\n+        self.height\n     }\n \n     pub fn hash(&self) -> [u8; 32] {\n-        unimplemented!();\n+        self.hash\n     }\n \n     pub fn hash_hex(&self) -> String {\n@@ -83,8 +166,13 @@ impl BlockIndex {\n         unimplemented!();\n     }\n \n+    /// Hacky version of the real logic - just reject anything on a fork older than 2500 blocks\n     pub fn is_knowledge_public(&self) -> bool {\n-        unimplemented!();\n+        let tip = {\n+            let blocks = check_blocks_avail().lock().unwrap();\n+            blocks.blocks.get(&blocks.best_block).unwrap().clone()\n+        };\n+        self.height > tip.height - 2500 || tip.get_ancestor(self.height).unwrap() == *self\n     }\n }\n "
      }
    ]
  },
  {
    "sha": "6693089385aa51c1c2769e21ad738aff3252b5f0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2NjkzMDg5Mzg1YWE1MWMxYzI3NjllMjFhZDczOGFmZjMyNTJiNWYw",
    "commit": {
      "author": {
        "name": "Igor Cota",
        "email": "igor@codexapertus.com",
        "date": "2019-11-19T13:46:49Z"
      },
      "committer": {
        "name": "Igor Cota",
        "email": "igor@codexapertus.com",
        "date": "2020-02-19T14:32:32Z"
      },
      "message": "Add CoreLightning\n\nCoreLightning is a rusty interface to Lightning Network\nIt uses the rust-lightning library",
      "tree": {
        "sha": "b7198c422d0865f6ed1fd93e30c0b715ea31c89e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b7198c422d0865f6ed1fd93e30c0b715ea31c89e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/6693089385aa51c1c2769e21ad738aff3252b5f0",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6693089385aa51c1c2769e21ad738aff3252b5f0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/6693089385aa51c1c2769e21ad738aff3252b5f0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6693089385aa51c1c2769e21ad738aff3252b5f0/comments",
    "author": {
      "login": "icota",
      "id": 762502,
      "node_id": "MDQ6VXNlcjc2MjUwMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/762502?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/icota",
      "html_url": "https://github.com/icota",
      "followers_url": "https://api.github.com/users/icota/followers",
      "following_url": "https://api.github.com/users/icota/following{/other_user}",
      "gists_url": "https://api.github.com/users/icota/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/icota/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/icota/subscriptions",
      "organizations_url": "https://api.github.com/users/icota/orgs",
      "repos_url": "https://api.github.com/users/icota/repos",
      "events_url": "https://api.github.com/users/icota/events{/privacy}",
      "received_events_url": "https://api.github.com/users/icota/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "icota",
      "id": 762502,
      "node_id": "MDQ6VXNlcjc2MjUwMg==",
      "avatar_url": "https://avatars.githubusercontent.com/u/762502?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/icota",
      "html_url": "https://github.com/icota",
      "followers_url": "https://api.github.com/users/icota/followers",
      "following_url": "https://api.github.com/users/icota/following{/other_user}",
      "gists_url": "https://api.github.com/users/icota/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/icota/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/icota/subscriptions",
      "organizations_url": "https://api.github.com/users/icota/orgs",
      "repos_url": "https://api.github.com/users/icota/repos",
      "events_url": "https://api.github.com/users/icota/events{/privacy}",
      "received_events_url": "https://api.github.com/users/icota/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "33287e2a3f516e38d70537436c680c4b43be3587",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/33287e2a3f516e38d70537436c680c4b43be3587",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/33287e2a3f516e38d70537436c680c4b43be3587"
      }
    ],
    "stats": {
      "total": 1779,
      "additions": 1747,
      "deletions": 32
    },
    "files": [
      {
        "sha": "58744c65a6e3c4a0426cfab8a1d0c281db50050d",
        "filename": "configure.ac",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6693089385aa51c1c2769e21ad738aff3252b5f0/configure.ac",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6693089385aa51c1c2769e21ad738aff3252b5f0/configure.ac",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/configure.ac?ref=6693089385aa51c1c2769e21ad738aff3252b5f0",
        "patch": "@@ -1660,7 +1660,7 @@ if test x$need_bundled_univalue = xyes; then\n   AC_CONFIG_SUBDIRS([src/univalue])\n fi\n \n-ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-recovery --disable-jni\"\n+ac_configure_args=\"${ac_configure_args} --disable-shared --with-pic --enable-benchmark=no --with-bignum=no --enable-module-ecdh --enable-experimental --enable-module-recovery --disable-jni\"\n AC_CONFIG_SUBDIRS([src/secp256k1])\n \n AC_OUTPUT"
      },
      {
        "sha": "8d71c95f75dc7e544e53dfa540f6a5f33b4c1384",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 25,
        "deletions": 4,
        "changes": 29,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6693089385aa51c1c2769e21ad738aff3252b5f0/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6693089385aa51c1c2769e21ad738aff3252b5f0/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=6693089385aa51c1c2769e21ad738aff3252b5f0",
        "patch": "@@ -312,6 +312,7 @@ libbitcoin_server_a_SOURCES = \\\n   rpc/net.cpp \\\n   rpc/rawtransaction.cpp \\\n   rpc/server.cpp \\\n+  rpc/lightning.cpp \\\n   script/sigcache.cpp \\\n   shutdown.cpp \\\n   timedata.cpp \\\n@@ -379,7 +380,8 @@ LIBBITCOIN_RUSTY_SRCS= \\\n   rusty/src/dns_headers.rs \\\n   rusty/src/rest_downloader.rs \\\n   rusty/src/p2p_addrs.rs rusty/src/p2p_client.rs \\\n-  rusty/src/p2p_socket_handler.rs\n+  rusty/src/p2p_socket_handler.rs \\\n+  rusty/src/core_lightning/mod.rs\n \n LIBBITCOIN_RUSTY_TEST_SRCS= \\\n   rusty/src/test_bridge.rs\n@@ -397,22 +399,41 @@ rusty/libbitcoin_hashes.rlib: rusty/bitcoin_hashes/src/lib.rs $(wildcard rusty/b\n \ttouch $@\n \n rusty/libsecp256k1.rlib: rusty/rust-secp256k1/src/lib.rs $(wildcard rusty/rust-secp256k1/src/*.rs) $(LIBSECP256K1)\n-\t$(RUSTC) --crate-name secp256k1 $< --crate-type=rlib -g -O -C overflow-checks=on -C panic=unwind --cfg 'feature=\"std\"' --cfg 'feature=\"dont_replace_c_symbols\"' --out-dir $(@D) && \\\n+\t$(RUSTC) --crate-name secp256k1 $< --crate-type=rlib -g -O -C overflow-checks=on -C panic=unwind --cfg 'feature=\"std\"' --cfg 'feature=\"recovery\"' --cfg 'feature=\"dont_replace_c_symbols\"' --out-dir $(@D) && \\\n \ttouch $@\n \n rusty/libbitcoin.rlib: rusty/libbech32.rlib rusty/libbitcoin_hashes.rlib rusty/libsecp256k1.rlib\n rusty/libbitcoin.rlib: rusty/rust-bitcoin/src/lib.rs $(wildcard rusty/rust-bitcoin/src/*.rs) $(wildcard rusty/rust-bitcoin/src/*/*.rs) $(wildcard rusty/rust-bitcoin/src/*/*/*.rs)\n \t$(RUSTC) --crate-name bitcoin $< --crate-type=rlib -g -O -C overflow-checks=on -C panic=unwind --out-dir $(@D) --extern bech32=$(@D)/libbech32.rlib --extern bitcoin_hashes=$(@D)/libbitcoin_hashes.rlib --extern secp256k1=$(@D)/libsecp256k1.rlib && \\\n \ttouch $@\n \n+rusty/liblightning.rlib: rusty/libbitcoin.rlib\n+rusty/liblightning.rlib: rusty/rust-lightning/lightning/src/lib.rs $(wildcard rusty/rust-lightning/lightning/src/*.rs) $(wildcard rusty/rust-lightning/lightning/src/*/*.rs) $(wildcard rusty/rust-lightning/src/*/*/*.rs)\n+\t$(RUSTC) --crate-name lightning $< --crate-type=rlib -g -O -C overflow-checks=on -C panic=unwind --out-dir $(@D) -L rusty && \\\n+\ttouch $@\n+\n+rusty/libbitcoin-bech32.rlib: rusty/libbech32.rlib\n+rusty/libbitcoin-bech32.rlib: rusty/rust-bech32-bitcoin/src/lib.rs\n+\t$(RUSTC) --crate-name bitcoin_bech32 $< --crate-type=rlib -g -O -C overflow-checks=on -C panic=unwind --out-dir $(@D) -L rusty && \\\n+\ttouch $@\n+\n+rusty/liblightninginvoice.rlib: rusty/libnum-traits.rlib rusty/libsecp256k1.rlib\n+rusty/liblightninginvoice.rlib: rusty/rust-lightning-invoice/src/lib.rs\n+\t$(RUSTC) --crate-name lightning_invoice $< --crate-type=rlib -g -O -C overflow-checks=on -C panic=unwind --out-dir $(@D) -L rusty && \\\n+\ttouch $@\n+\n+rusty/libnum-traits.rlib: rusty/num-traits/src/lib.rs\n+\t$(RUSTC) --crate-name num_traits $< --crate-type=rlib -g -O -C overflow-checks=on -C panic=unwind --out-dir $(@D) -L rusty && \\\n+\ttouch $@\n+\n # We force overflow checks on so that any integer overflows result in a panic\n # instead of, eg, attempting to alloc 4GB of memory (though we will catch such\n # an alloc and refuse it, generating a panic instead).\n # Also force panics to unwind (instead of calling abort()) as we want to catch\n # panics in the Rust threads and simply close the thread, instead of bringing\n # down the rest of Bitcoin Core.\n-$(LIBBITCOIN_RUSTY): $(LIBBITCOIN_RUSTY_SRCS) rusty/libbitcoin.rlib rusty/liblibc.rlib\n-\t$(RUSTC) --crate-name rusty $< --target=$(RUST_TARGET) --crate-type=staticlib --emit=link -g -O -C lto=on -C overflow-checks=on -C panic=unwind --out-dir $(@D) -L dependency=$(@D) --extern libc=$(@D)/liblibc.rlib --extern bitcoin_hashes=$(@D)/libbitcoin_hashes.rlib --extern bitcoin=$(@D)/libbitcoin.rlib\n+$(LIBBITCOIN_RUSTY): $(LIBBITCOIN_RUSTY_SRCS) rusty/libbitcoin.rlib rusty/liblibc.rlib rusty/liblightning.rlib rusty/libbitcoin-bech32.rlib rusty/liblightninginvoice.rlib\n+\t$(RUSTC) --crate-name rusty $< --target=$(RUST_TARGET) --crate-type=staticlib --emit=link -g -C lto=on -C overflow-checks=on -C panic=unwind --out-dir $(@D) -L $(@D) --extern libc=$(@D)/liblibc.rlib\n \ttouch $@\n \n # crypto primitives library"
      },
      {
        "sha": "d1148aa1d226dc07966a137703700e62925d5846",
        "filename": "src/clientversion.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 0,
        "changes": 6,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6693089385aa51c1c2769e21ad738aff3252b5f0/src/clientversion.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6693089385aa51c1c2769e21ad738aff3252b5f0/src/clientversion.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/clientversion.cpp?ref=6693089385aa51c1c2769e21ad738aff3252b5f0",
        "patch": "@@ -20,6 +20,12 @@ const std::string CLIENT_NAME(\"Satoshi\");\n  */\n const std::string RUSTY_CLIENT_NAME(\"RustySatoshi\");\n \n+/**\n+ * Name of client reported when connected to the\n+ * in-Rust Lightning client.\n+ */\n+const std::string RUSTY_LIGHTNING_CLIENT_NAME(\"CoreLightning\");\n+\n /**\n  * Client version number\n  */"
      },
      {
        "sha": "fc53bac98035eddbcd66a4a2f4151c27c1471283",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 21,
        "deletions": 0,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6693089385aa51c1c2769e21ad738aff3252b5f0/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6693089385aa51c1c2769e21ad738aff3252b5f0/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=6693089385aa51c1c2769e21ad738aff3252b5f0",
        "patch": "@@ -412,6 +412,8 @@ void SetupServerArgs()\n     gArgs.AddArg(\"-headersfetchdns=<domain>\", \"A domain name from which to fetch headers. eg bitcoinheaders.net\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-parallelp2p\", strprintf(\"Whether to run a parallel P2P client to provide redundancy in block fetch implementation (default: %u).\", rust_block_fetch::DEFAULT_P2P), ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-parallelp2pport=<port>\", strprintf(\"Listen for connections on <port> with the parallel P2P client (default: %u, testnet: %u, regtest: %u). 0 indicates no listening, only outbound connections are made.\", defaultChainParams->GetDefaultPort() + 1, testnetChainParams->GetDefaultPort() + 1, regtestChainParams->GetDefaultPort() + 1), ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-lightning\", strprintf(\"Whether to run a Lightning client (default: %u).\", rust_block_fetch::DEFAULT_P2P), ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n+    gArgs.AddArg(\"-lightningport=<port>\", strprintf(\"Listen for connections on <port> with the Lightning client (default: %u). 0 indicates no listening, only outbound connections are made.\", lightning::DEFAULT_LIGHTNING_PORT), ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n #endif\n     gArgs.AddArg(\"-addnode=<ip>\", \"Add a node to connect to and attempt to keep the connection open (see the `addnode` RPC command help for more info). This option can be specified multiple times to add multiple nodes.\", ArgsManager::ALLOW_ANY | ArgsManager::NETWORK_ONLY, OptionsCategory::CONNECTION);\n     gArgs.AddArg(\"-banscore=<n>\", strprintf(\"Threshold for disconnecting misbehaving peers (default: %u)\", DEFAULT_BANSCORE_THRESHOLD), ArgsManager::ALLOW_ANY, OptionsCategory::CONNECTION);\n@@ -1221,6 +1223,15 @@ bool AppInitLockDataDirectory()\n     return true;\n }\n \n+void* lightning_node = nullptr;\n+\n+static void LightningBlockNotifyCallback(bool initialSync, const CBlockIndex *pBlockIndex) {\n+    if (initialSync || !pBlockIndex || !lightning_node)\n+        return;\n+\n+    lightning::notify_block(lightning_node);\n+}\n+\n bool AppInitMain(NodeContext& node)\n {\n     const CChainParams& chainparams = Params();\n@@ -1862,6 +1873,16 @@ bool AppInitMain(NodeContext& node)\n         unsigned short bind_port = (unsigned short)(gArgs.GetArg(\"-parallelp2pport\", Params().GetDefaultPort() + 1));\n         rust_block_fetch::init_p2p_client(node.connman.get(), GetDataDir().c_str(), rusty_sub_ver.c_str(), bind_port, dnsseeds.data(), dnsseeds.size());\n     }\n+    if (gArgs.GetBoolArg(\"-lightning\", lightning::DEFAULT_LIGHTNING)) {\n+        unsigned short bind_port = (unsigned short)(gArgs.GetArg(\"-lightningport\", lightning::DEFAULT_LIGHTNING_PORT));\n+        lightning_node = lightning::init_node(GetDataDir().c_str());\n+        if (bind_port) {\n+            // TODO: this is supposed to return\n+            //lightning::listen_incoming(lightning_node, bind_port);\n+        }\n+        uiInterface.NotifyBlockTip_connect(LightningBlockNotifyCallback);\n+\n+    }\n #endif\n \n     return true;"
      },
      {
        "sha": "e67ed76eeda97bf669ac5ca28b30e89a0129e8ad",
        "filename": "src/rpc/lightning.cpp",
        "status": "added",
        "additions": 199,
        "deletions": 0,
        "changes": 199,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rpc/lightning.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rpc/lightning.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/lightning.cpp?ref=6693089385aa51c1c2769e21ad738aff3252b5f0",
        "patch": "@@ -0,0 +1,199 @@\n+// Copyright (c) 2009-2019 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <rpc/server.h>\n+\n+#include <rusty/src/rust_bridge.h>\n+\n+#include <rpc/util.h>\n+#include <util/strencodings.h>\n+\n+#include <univalue.h>\n+\n+//! Pointer to Lightning node that needs to be declared as a global to be accessible\n+//! RPC methods. Due to limitations of the RPC framework, there's currently no\n+//! direct way to pass in state to RPC methods without globals.\n+extern void* lightning_node;\n+\n+static UniValue lnconnect(const JSONRPCRequest& request)\n+{\n+    RPCHelpMan{\"lnconnect\",\n+               \"\\nConnect to a Lightning Network node.\\n\",\n+               {{\"node\", RPCArg::Type::STR, RPCArg::Optional::NO, \"Node to connect to in pubkey@host:port format.\"},},\n+               RPCResult{\n+                       \"n          (numeric) FIX\\n\"\n+               },\n+               RPCExamples{\n+                       HelpExampleCli(\"lnconnect\", \"pubkey@host:port\")\n+                       + HelpExampleRpc(\"lnconnect\", \"pubkey@host:port\")\n+               },\n+    }.Check(request);\n+\n+    std::string strNode = request.params[0].get_str();\n+\n+    return lightning::connect_peer(lightning_node, strNode.c_str());\n+}\n+\n+static UniValue lngetpeers(const JSONRPCRequest& request)\n+{\n+    RPCHelpMan{\"lngetpeers\",\n+               \"\\nList all connected Lightning Network nodes.\\n\",\n+               {},\n+               RPCResult{\n+                       \"n          (numeric) FIXME\\n\"\n+               },\n+               RPCExamples{\n+                       HelpExampleCli(\"lngetpeers\", \"\")\n+                       + HelpExampleRpc(\"lngetpeers\", \"\")\n+               },\n+    }.Check(request);\n+\n+    auto peers = lightning::get_peers(lightning_node);\n+    std::vector<lightning::Peer> vpeers(peers.ptr, peers.ptr + peers.len);\n+\n+    UniValue ret(UniValue::VARR);\n+\n+    for (auto peer : vpeers) {\n+        UniValue obj(UniValue::VOBJ);\n+        obj.pushKV(\"id\", peer.id);\n+        ret.push_back(obj);\n+    };\n+\n+    return ret;\n+}\n+\n+static UniValue lnfundchannel(const JSONRPCRequest& request)\n+{\n+    RPCHelpMan{\"lnfundchannel\",\n+               \"\\nFund a Lightning Network channel.\\n\",\n+               {{\"node_id\", RPCArg::Type::STR, RPCArg::Optional::NO, \"Node to open a channel with.\"},\n+                {\"amount\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"Amount.\"},},\n+               RPCResults{},\n+               RPCExamples{\n+                       HelpExampleCli(\"lnfundchannel\", \"pubkey amount\")\n+                       + HelpExampleRpc(\"lnfundchannel\", \"pubkey amount\")\n+               },\n+    }.Check(request);\n+\n+    std::string strNode = request.params[0].get_str();\n+\n+    CAmount nAmount = AmountFromValue(request.params[1]);\n+    if (nAmount <= 0)\n+        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount\");\n+\n+    lightning::fund_channel(lightning_node, strNode.c_str(), nAmount);\n+    return NullUniValue;\n+}\n+\n+static UniValue lngetchannels(const JSONRPCRequest& request)\n+{\n+    RPCHelpMan{\"lngetchannels\",\n+               \"\\nList all Lightning Network channels.\\n\",\n+               {},\n+               RPCResult{\n+                       \"n          (numeric) FIXME\\n\"\n+               },\n+               RPCExamples{\n+                       HelpExampleCli(\"lngetchannels\", \"\")\n+                       + HelpExampleRpc(\"lngetchannels\", \"\")\n+               },\n+    }.Check(request);\n+\n+\n+    auto channels = lightning::get_channels(lightning_node);\n+    std::vector<lightning::Channel> vchannels(channels.ptr, channels.ptr + channels.len);\n+\n+    UniValue ret(UniValue::VARR);\n+\n+    for (auto channel : vchannels) {\n+        UniValue obj(UniValue::VOBJ);\n+        obj.pushKV(\"id\", channel.id);\n+        obj.pushKV(\"shortid\", channel.short_id);\n+        obj.pushKV(\"capacity\", channel.capacity);\n+        obj.pushKV(\"status\", channel.short_id ? \"confirmed\" : \"unconfirmed\");\n+        ret.push_back(obj);\n+    };\n+\n+    return ret;\n+}\n+\n+static UniValue lnpayinvoice(const JSONRPCRequest& request)\n+{\n+    RPCHelpMan{\"lnpayinvoice\",\n+               \"\\nPay a Lightning Network invoice.\\n\",\n+               {{\"invoice\", RPCArg::Type::STR, RPCArg::Optional::NO, \"BOLT-11 encoded invoice string\"},},\n+               RPCResults{},\n+               RPCExamples{\n+                       HelpExampleCli(\"lnpayinvoice\", \"invoice\")\n+                       + HelpExampleRpc(\"lnpayinvoice\", \"invoice\")\n+               },\n+    }.Check(request);\n+\n+    std::string bolt11 = request.params[0].get_str();\n+\n+    lightning::pay_invoice(lightning_node, bolt11.c_str());\n+    return NullUniValue;\n+}\n+\n+static UniValue lncreateinvoice(const JSONRPCRequest& request)\n+{\n+    RPCHelpMan{\"lncreateinvoice\",\n+               \"\\nFund a Lightning Network channel.\\n\",\n+               {{\"description\", RPCArg::Type::STR, RPCArg::Optional::NO, \"Invoice description.\"},\n+                {\"amount\", RPCArg::Type::AMOUNT, RPCArg::Optional::NO, \"Amount.\"},},\n+               RPCResult{\n+                       \"s          (string) BOLT-11 encoded invoice\\n\"\n+               },\n+               RPCExamples{\n+                       HelpExampleCli(\"lncreateinvoice\", \"description amount\")\n+                       + HelpExampleRpc(\"lncreateinvoice\", \"description amount\")\n+               },\n+    }.Check(request);\n+\n+    std::string description = request.params[0].get_str();\n+\n+    CAmount nAmount = AmountFromValue(request.params[1]);\n+    if (nAmount <= 0)\n+        throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount\");\n+\n+    return lightning::create_invoice(lightning_node, description.c_str(), nAmount);\n+}\n+\n+static UniValue lnclosechannel(const JSONRPCRequest& request)\n+{\n+    RPCHelpMan{\"lnclosechannel\",\n+               \"\\nClose a Lightning Network channel.\\n\",\n+               {{\"channel_id\", RPCArg::Type::STR, RPCArg::Optional::NO, \"Channel ID.\"},},\n+               RPCResults{},\n+               RPCExamples{\n+                       HelpExampleCli(\"lnclosechannel\", \"channel_id\")\n+                       + HelpExampleRpc(\"lnclosechannel\", \"channel_id\")\n+               },\n+    }.Check(request);\n+\n+    std::string strChannelId = request.params[0].get_str();\n+\n+    lightning::close_channel(lightning_node, strChannelId.c_str());\n+    return NullUniValue;\n+}\n+\n+// clang-format off\n+static const CRPCCommand commands[] =\n+        { //  category              name                      actor (function)         argNames\n+                //  --------------------- ------------------------  -----------------------  ----------\n+                { \"lightning\",            \"lnconnect\",                &lnconnect,                {\"node\"} },\n+                { \"lightning\",            \"lngetpeers\",               &lngetpeers,               {} },\n+                { \"lightning\",            \"lnfundchannel\",            &lnfundchannel,            {\"node_id\", \"amount\"} },\n+                { \"lightning\",            \"lngetchannels\",            &lngetchannels,            {} },\n+                { \"lightning\",            \"lnpayinvoice\",             &lnpayinvoice,             {\"invoice\"} },\n+                { \"lightning\",            \"lncreateinvoice\",          &lncreateinvoice,          {\"description\", \"amount\"} },\n+                { \"lightning\",            \"lnclosechannel\",           &lnclosechannel,           {\"channel_id\"} },\n+        };\n+// clang-format on\n+\n+void RegisterLightningRPCCommands(CRPCTable &t)\n+{\n+    for (unsigned int vcidx = 0; vcidx < ARRAYLEN(commands); vcidx++)\n+        t.appendCommand(commands[vcidx].name, &commands[vcidx]);\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "f44d568a4e49ba682d38ef9da763d0e53410b7e2",
        "filename": "src/rpc/register.h",
        "status": "modified",
        "additions": 3,
        "deletions": 0,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rpc/register.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rpc/register.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rpc/register.h?ref=6693089385aa51c1c2769e21ad738aff3252b5f0",
        "patch": "@@ -19,6 +19,8 @@ void RegisterMiscRPCCommands(CRPCTable &tableRPC);\n void RegisterMiningRPCCommands(CRPCTable &tableRPC);\n /** Register raw transaction RPC commands */\n void RegisterRawTransactionRPCCommands(CRPCTable &tableRPC);\n+/** Register Lightning Network RPC commands */\n+void RegisterLightningRPCCommands(CRPCTable &tableRPC);\n \n static inline void RegisterAllCoreRPCCommands(CRPCTable &t)\n {\n@@ -27,6 +29,7 @@ static inline void RegisterAllCoreRPCCommands(CRPCTable &t)\n     RegisterMiscRPCCommands(t);\n     RegisterMiningRPCCommands(t);\n     RegisterRawTransactionRPCCommands(t);\n+    RegisterLightningRPCCommands(t);\n }\n \n #endif // BITCOIN_RPC_REGISTER_H"
      },
      {
        "sha": "512066be413cae191da0922071d176a26aefdbbf",
        "filename": "src/rusty/src/bridge.rs",
        "status": "modified",
        "additions": 71,
        "deletions": 1,
        "changes": 72,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/bridge.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/bridge.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/bridge.rs?ref=6693089385aa51c1c2769e21ad738aff3252b5f0",
        "patch": "@@ -1,10 +1,11 @@\n-use std::ffi::{c_void, CString};\n+use std::ffi::{c_void, CString, CStr};\n use std::ptr;\n use std::io::Cursor;\n \n use bitcoin::blockdata::block::BlockHeader;\n use bitcoin::consensus::Encodable;\n use bitcoin::util::uint::Uint256;\n+use std::os::raw::{c_char, c_uint};\n \n #[inline]\n pub fn slice_to_u64_le(slice: &[u8]) -> u64 {\n@@ -89,6 +90,8 @@ extern \"C\" {\n     /// Serializes the header pointed to by the CBlockIndex* into eighty_bytes_dest.\n     fn rusty_SerializeIndex(index: *const c_void, eighty_bytes_dest: *mut u8);\n \n+    fn rusty_GetNetworkIDString() -> *const c_char;\n+\n     /// Given a CBlockIndex* pointer, gets a pointer/length pair for the serialized block,\n     /// returning an opaque resource pointer, which must be deallocated (invalidating the\n     /// returned serialized data pointer) via rusty_FreeBlockData().\n@@ -99,6 +102,16 @@ extern \"C\" {\n \n     /// Returns true if we're allowed to expose knowledge of the given CBlockIndex* to peers.\n     fn rusty_BlockRequestAllowed(pindexvoid: *const c_void) -> bool;\n+\n+    fn rusty_GetBlockCount() -> u64;\n+\n+    fn rusty_GetSignedTx(script: *const u8, scriptlen: c_uint, value: u64, resdata: *mut *const u8, reslen: *mut u64) -> *const c_void;\n+\n+    fn rusty_BroadcastTx(tx: *const u8, txlen: c_uint) -> bool;\n+\n+    fn rusty_EstimateFee(conftarget: u64, conservative: bool) -> usize;\n+\n+    fn rusty_ImportKey(key: *const u8) -> bool;\n }\n \n /// Connects the given array of (sorted, in chain order) headers (in serialized, 80-byte form).\n@@ -132,6 +145,44 @@ pub fn connect_block(blockdata: &[u8], blockindex_requested_by_state: Option<Blo\n     }\n }\n \n+pub fn get_block_count() -> u64 {\n+    unsafe {\n+        rusty_GetBlockCount()\n+    }\n+}\n+\n+pub fn get_signed_tx(script: Vec<u8>, value: u64) -> Vec<u8> {\n+    let mut len: u64 = 0;\n+    let mut data: *const u8 = ptr::null();\n+    let resource = unsafe { rusty_GetSignedTx(script.as_ptr(), script.len() as u32, value, &mut data, &mut len) };\n+    // TODO: propagate errors down to RPC\n+    assert!(!data.is_null());\n+    let mut res = Vec::new();\n+    res.resize(len as usize, 0);\n+    unsafe { ptr::copy_nonoverlapping(data, res.as_mut_ptr(), len as usize); }\n+    // TODO: make this generic\n+    unsafe { rusty_FreeBlockData(resource) };\n+    res\n+}\n+\n+pub fn broadcast_tx(tx: Vec<u8>) -> bool {\n+    unsafe {\n+        rusty_BroadcastTx(tx.as_ptr(), tx.len() as u32)\n+    }\n+}\n+\n+pub fn estimate_fee(conftarget: u64, conservative: bool) -> usize {\n+    unsafe {\n+        rusty_EstimateFee(conftarget, conservative)\n+    }\n+}\n+\n+pub fn import_key(key: Vec<u8>) -> bool {\n+    unsafe {\n+        rusty_ImportKey(key.as_ptr())\n+    }\n+}\n+\n #[derive(PartialEq, Clone, Copy)]\n pub struct BlockIndex {\n     index: *const c_void,\n@@ -251,6 +302,12 @@ impl BlockIndex {\n         ser\n     }\n \n+    pub fn network_id() -> String {\n+        unsafe {\n+            CStr::from_ptr(rusty_GetNetworkIDString()).to_string_lossy().into_owned()\n+        }\n+    }\n+\n     /// Gets the full, serialized, block, in witness form\n     pub fn block_bytes(&self) -> Vec<u8> {\n         let mut len: u64 = 0;\n@@ -379,6 +436,9 @@ extern \"C\" {\n \n     /// Gets a u64 less than the given max out of a Random Context generated with rusty_InitRandContext()\n     fn rusty_GetRandRange(rand_context: *mut c_void, range: u64) -> u64;\n+\n+    /// Gets len random bytes out of a Random Context generated with rusty_InitRandContext()\n+    fn rusty_GetRandThirtyTwoBytes(rand_context: *mut c_void) -> ThirtyTwoBytes;\n }\n \n pub struct RandomContext {\n@@ -400,6 +460,10 @@ impl RandomContext {\n         assert!(range > 0);\n         unsafe { rusty_GetRandRange(self.index, range) }\n     }\n+\n+    pub fn randthirtytwobytes(&mut self) -> Uint256 {\n+        unsafe { rusty_GetRandThirtyTwoBytes(self.index) }.to_uint_le()\n+    }\n }\n impl Drop for RandomContext {\n     fn drop(&mut self) {\n@@ -424,6 +488,12 @@ extern \"C\" {\n     fn rusty_CheckInboundP2PNonce(connman: *mut c_void, nonce: u64) -> bool;\n }\n \n+#[derive(Copy, Clone)]\n+pub struct NodeContext(pub *mut c_void);\n+unsafe impl Send for NodeContext {}\n+unsafe impl Sync for NodeContext {}\n+\n+\n #[derive(Copy, Clone)]\n pub struct Connman(pub *mut c_void);\n // As long as we exit when required to, sending around pointers to Connman is fine:"
      },
      {
        "sha": "ea8b04d283ac52d042c6b84b7ff3dc647c37569e",
        "filename": "src/rusty/src/core_lightning/chain_interface.rs",
        "status": "added",
        "additions": 265,
        "deletions": 0,
        "changes": 265,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/core_lightning/chain_interface.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/core_lightning/chain_interface.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/core_lightning/chain_interface.rs?ref=6693089385aa51c1c2769e21ad738aff3252b5f0",
        "patch": "@@ -0,0 +1,265 @@\n+use std::sync::atomic::{AtomicUsize, Ordering};\n+use bridge::{estimate_fee, broadcast_tx};\n+use std::sync::{Arc, Mutex};\n+use lightning::chain::chaininterface;\n+use std::{cmp, fs};\n+use std::collections::HashMap;\n+use lightning::util::logger::Logger;\n+use bitcoin::{Network, Block, Transaction};\n+use bitcoin::consensus::encode;\n+use lightning::chain::chaininterface::ChainError;\n+use lightning::ln::channelmonitor;\n+use lightning::chain;\n+use bitcoin_hashes::hex::FromHex;\n+use std::io::Cursor;\n+use core_lightning::LogPrinter;\n+use lightning::ln::channelmonitor::ManyChannelMonitor;\n+use bitcoin::hashes::hex::ToHex;\n+use lightning::util::ser::ReadableArgs;\n+\n+pub struct FeeEstimator {\n+    background_est: AtomicUsize,\n+    normal_est: AtomicUsize,\n+    high_prio_est: AtomicUsize,\n+}\n+\n+impl FeeEstimator {\n+    pub fn new() -> Self {\n+        FeeEstimator {\n+            background_est: AtomicUsize::new(0),\n+            normal_est: AtomicUsize::new(0),\n+            high_prio_est: AtomicUsize::new(0),\n+        }\n+    }\n+    pub fn update_values(&self) {\n+        self.high_prio_est\n+            .store(estimate_fee(6, true) / 250 + 3, Ordering::Release);\n+        self.normal_est\n+            .store(estimate_fee(18, false) / 250 + 3, Ordering::Release);\n+        self.background_est\n+            .store(estimate_fee(144, false) / 250 + 3, Ordering::Release);\n+    }\n+}\n+\n+impl chaininterface::FeeEstimator for FeeEstimator {\n+    fn get_est_sat_per_1000_weight(&self, conf_target: chaininterface::ConfirmationTarget) -> u64 {\n+        cmp::max(\n+            match conf_target {\n+                chaininterface::ConfirmationTarget::Background => {\n+                    self.background_est.load(Ordering::Acquire) as u64\n+                }\n+                chaininterface::ConfirmationTarget::Normal => {\n+                    self.normal_est.load(Ordering::Acquire) as u64\n+                }\n+                chaininterface::ConfirmationTarget::HighPriority => {\n+                    self.high_prio_est.load(Ordering::Acquire) as u64\n+                }\n+            },\n+            253,\n+        )\n+    }\n+}\n+\n+pub struct ChainInterface {\n+    util: chaininterface::ChainWatchInterfaceUtil,\n+    txn_to_broadcast:\n+    Mutex<HashMap<bitcoin_hashes::sha256d::Hash, bitcoin::blockdata::transaction::Transaction>>,\n+}\n+\n+impl ChainInterface {\n+    pub fn new(network: Network, logger: Arc<Logger>) -> Self {\n+        ChainInterface {\n+            util: chaininterface::ChainWatchInterfaceUtil::new(network, logger),\n+            txn_to_broadcast: Mutex::new(HashMap::new()),\n+        }\n+    }\n+\n+    fn rebroadcast_txn(&self) {\n+        let txn = self.txn_to_broadcast.lock().unwrap();\n+        for (_, tx) in txn.iter() {\n+            let raw_tx = &encode::serialize(tx);\n+            broadcast_tx(raw_tx.clone());\n+        }\n+    }\n+}\n+\n+impl chaininterface::BroadcasterInterface for ChainInterface {\n+    fn broadcast_transaction(&self, tx: &bitcoin::blockdata::transaction::Transaction) {\n+        self.txn_to_broadcast\n+            .lock()\n+            .unwrap()\n+            .insert(tx.txid(), tx.clone());\n+        let raw_tx = &encode::serialize(tx);\n+        broadcast_tx(raw_tx.clone());\n+    }\n+}\n+\n+impl chaininterface::ChainWatchInterface for ChainInterface {\n+    fn install_watch_tx(\n+        &self,\n+        txid: &bitcoin_hashes::sha256d::Hash,\n+        script: &bitcoin::blockdata::script::Script,\n+    ) {\n+        self.util.install_watch_tx(txid, script);\n+    }\n+\n+    fn install_watch_outpoint(\n+        &self,\n+        outpoint: (bitcoin_hashes::sha256d::Hash, u32),\n+        script_pubkey: &bitcoin::blockdata::script::Script,\n+    ) {\n+        self.util.install_watch_outpoint(outpoint, script_pubkey);\n+    }\n+\n+    fn watch_all_txn(&self) {\n+        self.util.watch_all_txn();\n+    }\n+\n+    fn get_chain_utxo(\n+        &self,\n+        genesis_hash: bitcoin_hashes::sha256d::Hash,\n+        unspent_tx_output_identifier: u64,\n+    ) -> Result<(bitcoin::blockdata::script::Script, u64), ChainError> {\n+        self.util\n+            .get_chain_utxo(genesis_hash, unspent_tx_output_identifier)\n+    }\n+\n+    fn filter_block<'a>(&self, block: &'a Block) -> (Vec<&'a Transaction>, Vec<u32>) {\n+        self.util.filter_block(block)\n+    }\n+\n+    fn reentered(&self) -> usize {\n+        self.util.reentered()\n+    }\n+}\n+\n+pub(crate) struct ChannelMonitor {\n+    pub(crate) monitor: Arc<channelmonitor::SimpleManyChannelMonitor<chain::transaction::OutPoint>>,\n+    pub(crate) file_prefix: String,\n+}\n+\n+impl ChannelMonitor {\n+    pub(crate) fn load_from_disk(\n+        file_prefix: &String,\n+    ) -> Vec<(chain::transaction::OutPoint, channelmonitor::ChannelMonitor)> {\n+        let mut res = Vec::new();\n+        for file_option in fs::read_dir(file_prefix).unwrap() {\n+            let mut loaded = false;\n+            let file = file_option.unwrap();\n+            if let Some(filename) = file.file_name().to_str() {\n+                if filename.is_ascii() && filename.len() > 65 {\n+                    if let Ok(txid) =\n+                    bitcoin_hashes::sha256d::Hash::from_hex(filename.split_at(64).0)\n+                    {\n+                        if let Ok(index) =\n+                        filename.split_at(65).1.split('.').next().unwrap().parse()\n+                        {\n+                            if let Ok(contents) = fs::read(&file.path()) {\n+                                if let Ok((last_block_hash, loaded_monitor)) = <(\n+                                    bitcoin_hashes::sha256d::Hash,\n+                                    channelmonitor::ChannelMonitor,\n+                                )>::read(\n+                                    &mut Cursor::new(&contents),\n+                                    Arc::new(LogPrinter {}),\n+                                ) {\n+                                    // TODO: Rescan from last_block_hash\n+                                    res.push((\n+                                        chain::transaction::OutPoint { txid, index },\n+                                        loaded_monitor,\n+                                    ));\n+                                    loaded = true;\n+                                }\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            if !loaded {\n+                println!(\"WARNING: Failed to read one of the channel monitor storage files! Check perms!\");\n+            }\n+        }\n+        res\n+    }\n+\n+    pub(crate) fn load_from_vec(\n+        &self,\n+        mut monitors: Vec<(chain::transaction::OutPoint, channelmonitor::ChannelMonitor)>,\n+    ) {\n+        for (outpoint, monitor) in monitors.drain(..) {\n+            if let Err(_) = self.monitor.add_update_monitor(outpoint, monitor) {\n+                panic!(\"Failed to load monitor that deserialized\");\n+            }\n+        }\n+    }\n+}\n+\n+impl channelmonitor::ManyChannelMonitor for ChannelMonitor {\n+    fn add_update_monitor(\n+        &self,\n+        funding_txo: chain::transaction::OutPoint,\n+        monitor: channelmonitor::ChannelMonitor,\n+    ) -> Result<(), channelmonitor::ChannelMonitorUpdateErr> {\n+        macro_rules! try_fs {\n+            ($res: expr) => {\n+                match $res {\n+                    Ok(res) => res,\n+                    Err(_) => return Err(channelmonitor::ChannelMonitorUpdateErr::PermanentFailure),\n+                }\n+            };\n+        }\n+        // Do a crazy dance with lots of fsync()s to be overly cautious here...\n+        // We never want to end up in a state where we've lost the old data, or end up using the\n+        // old data on power loss after we've returned\n+        // Note that this actually *isn't* enough (at least on Linux)! We need to fsync an fd with\n+        // the containing dir, but Rust doesn't let us do that directly, sadly. TODO: Fix this with\n+        // the libc crate!\n+        let filename = format!(\n+            \"{}/{}_{}\",\n+            self.file_prefix,\n+            funding_txo.txid.to_hex(),\n+            funding_txo.index\n+        );\n+        let tmp_filename = filename.clone() + \".tmp\";\n+\n+        {\n+            let mut f = try_fs!(fs::File::create(&tmp_filename));\n+            try_fs!(monitor.write_for_disk(&mut f));\n+            try_fs!(f.sync_all());\n+        }\n+        // We don't need to create a backup if didn't already have the file, but in any other case\n+        // try to create the backup and expect failure on fs::copy() if eg there's a perms issue.\n+        let need_bk = match fs::metadata(&filename) {\n+            Ok(data) => {\n+                if !data.is_file() {\n+                    return Err(channelmonitor::ChannelMonitorUpdateErr::PermanentFailure);\n+                }\n+                true\n+            }\n+            Err(e) => match e.kind() {\n+                std::io::ErrorKind::NotFound => false,\n+                _ => true,\n+            },\n+        };\n+        let bk_filename = filename.clone() + \".bk\";\n+        if need_bk {\n+            try_fs!(fs::copy(&filename, &bk_filename));\n+            {\n+                let f = try_fs!(fs::File::open(&bk_filename));\n+                try_fs!(f.sync_all());\n+            }\n+        }\n+        try_fs!(fs::rename(&tmp_filename, &filename));\n+        {\n+            let f = try_fs!(fs::File::open(&filename));\n+            try_fs!(f.sync_all());\n+        }\n+        if need_bk {\n+            try_fs!(fs::remove_file(&bk_filename));\n+        }\n+        self.monitor.add_update_monitor(funding_txo, monitor)\n+    }\n+\n+    fn fetch_pending_htlc_updated(&self) -> Vec<channelmonitor::HTLCUpdate> {\n+        self.monitor.fetch_pending_htlc_updated()\n+    }\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "259b330ecb9700c5f10fb8257f3674d0e3f5ec6e",
        "filename": "src/rusty/src/core_lightning/event_handler.rs",
        "status": "added",
        "additions": 176,
        "deletions": 0,
        "changes": 176,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/core_lightning/event_handler.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/core_lightning/event_handler.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/core_lightning/event_handler.rs?ref=6693089385aa51c1c2769e21ad738aff3252b5f0",
        "patch": "@@ -0,0 +1,176 @@\n+use bitcoin::network::constants;\n+use std::sync::{Arc, Mutex};\n+use std::collections::HashMap;\n+use lightning::ln::router::Router;\n+use lightning::chain::chaininterface::BlockNotifier;\n+use lightning::chain;\n+use lightning::ln::{channelmonitor, channelmanager, peer_handler};\n+use core_lightning::{socket, CHANNEL_MANAGER_FILE};\n+use lightning::chain::keysinterface::{InMemoryChannelKeys, SpendableOutputDescriptor};\n+use bitcoin::blockdata;\n+use lightning::ln::channelmanager::{PaymentHash, PaymentPreimage};\n+use lightning::ln::peer_handler::PeerManager;\n+use lightning::util::events::{EventsProvider, Event};\n+use bridge::get_signed_tx;\n+use bitcoin::consensus::encode;\n+use core_lightning::utils::hex_str;\n+use std::fs;\n+use lightning::util::ser::Writeable;\n+use core_lightning::socket::SocketDescriptor;\n+\n+pub struct EventHandler {\n+    pub(crate) network: constants::Network,\n+    pub(crate) file_prefix: String,\n+    pub(crate) peer_manager: Arc<peer_handler::PeerManager<socket::SocketDescriptor>>,\n+    pub(crate) channel_manager: Arc<channelmanager::ChannelManager<InMemoryChannelKeys>>,\n+    monitor: Arc<channelmonitor::SimpleManyChannelMonitor<chain::transaction::OutPoint>>,\n+    broadcaster: Arc<chain::chaininterface::BroadcasterInterface>,\n+    pub(crate) block_notifier: Arc<BlockNotifier>,\n+    pub(crate) router: Arc<Router>,\n+    txn_to_broadcast:\n+    Mutex<HashMap<chain::transaction::OutPoint, blockdata::transaction::Transaction>>,\n+    payment_preimages: Arc<Mutex<HashMap<PaymentHash, PaymentPreimage>>>,\n+}\n+\n+impl EventHandler {\n+    pub(crate) fn new(\n+        network: constants::Network,\n+        file_prefix: String,\n+        peer_manager: Arc<peer_handler::PeerManager<socket::SocketDescriptor>>,\n+        monitor: Arc<channelmonitor::SimpleManyChannelMonitor<chain::transaction::OutPoint>>,\n+        channel_manager: Arc<channelmanager::ChannelManager<InMemoryChannelKeys>>,\n+        broadcaster: Arc<chain::chaininterface::BroadcasterInterface>,\n+        block_notifier: Arc<BlockNotifier>,\n+        router: Arc<Router>,\n+        payment_preimages: Arc<Mutex<HashMap<PaymentHash, PaymentPreimage>>>,\n+    ) -> EventHandler {\n+        Self {\n+            network,\n+            file_prefix,\n+            peer_manager,\n+            channel_manager,\n+            monitor,\n+            broadcaster,\n+            block_notifier,\n+            router,\n+            txn_to_broadcast: Mutex::new(HashMap::new()),\n+            payment_preimages,\n+        }\n+    }\n+\n+    pub fn clone_peer_manager(&self) -> Arc<PeerManager<SocketDescriptor>> {\n+        self.peer_manager.clone()\n+    }\n+\n+    pub fn process_events(&self) {\n+        self.peer_manager.process_events();\n+        let mut events = self.channel_manager.get_and_clear_pending_events();\n+        events.append(&mut self.monitor.get_and_clear_pending_events());\n+\n+        let save_state = events.is_empty();\n+\n+        for event in events {\n+            match event {\n+                Event::FundingGenerationReady {\n+                    temporary_channel_id,\n+                    channel_value_satoshis,\n+                    output_script,\n+                    ..\n+                } => {\n+                    let us = self.clone();\n+\n+                    let addr = bitcoin_bech32::WitnessProgram::from_scriptpubkey(&output_script[..], match us.network {\n+                        constants::Network::Bitcoin => bitcoin_bech32::constants::Network::Bitcoin,\n+                        constants::Network::Testnet => bitcoin_bech32::constants::Network::Testnet,\n+                        constants::Network::Regtest => bitcoin_bech32::constants::Network::Regtest,\n+                    }).expect(\"LN funding tx should always be to a SegWit output\").to_address();\n+\n+                    let signed_tx = get_signed_tx(addr.into_bytes(), channel_value_satoshis);\n+\n+                    let tx: blockdata::transaction::Transaction =\n+                        encode::deserialize(signed_tx.as_slice()).unwrap();\n+\n+                    let outpoint = chain::transaction::OutPoint {\n+                        txid: tx.txid(),\n+                        index: 1,\n+                    };\n+\n+                    us.channel_manager\n+                        .funding_transaction_generated(&temporary_channel_id, outpoint);\n+                    us.txn_to_broadcast.lock().unwrap().insert(outpoint, tx);\n+                    println!(\"Generated funding tx!\");\n+                }\n+                Event::FundingBroadcastSafe { funding_txo, .. } => {\n+                    let mut txn = self.txn_to_broadcast.lock().unwrap();\n+                    let tx = txn.remove(&funding_txo).unwrap();\n+                    self.broadcaster.broadcast_transaction(&tx);\n+                    println!(\"Broadcast funding tx {}!\", tx.txid());\n+                }\n+                Event::PaymentReceived { payment_hash, amt } => {\n+                    let images = self.payment_preimages.lock().unwrap();\n+                    if let Some(payment_preimage) = images.get(&payment_hash) {\n+                        if self\n+                            .channel_manager\n+                            .claim_funds(payment_preimage.clone(), 10000)\n+                        {\n+                            println!(\"Moneymoney! {} id {}\", amt, hex_str(&payment_hash.0));\n+                        } else {\n+                            println!(\"Failed to claim money we were told we had?\");\n+                        }\n+                    } else {\n+                        self.channel_manager.fail_htlc_backwards(&payment_hash);\n+                        println!(\"Received payment but we didn't know the preimage :(\");\n+                    }\n+                }\n+                Event::PaymentSent { payment_preimage } => {\n+                    println!(\"Less money :(, proof: {}\", hex_str(&payment_preimage.0));\n+                }\n+                Event::PaymentFailed {\n+                    payment_hash,\n+                    rejected_by_dest,\n+                } => {\n+                    println!(\n+                        \"{} failed id {}!\",\n+                        if rejected_by_dest { \"Send\" } else { \"Route\" },\n+                        hex_str(&payment_hash.0)\n+                    );\n+                }\n+                Event::PendingHTLCsForwardable { time_forwardable } => {\n+                    let us = self.clone();\n+                    us.channel_manager.process_pending_htlc_forwards();\n+                }\n+                Event::SpendableOutputs { mut outputs } => {\n+                    for output in outputs.drain(..) {\n+                        match output {\n+                            SpendableOutputDescriptor::StaticOutput { outpoint, .. } => {\n+                                println!(\"Got on-chain output Bitcoin Core should know how to claim at {}:{}\", hex_str(&outpoint.txid[..]), outpoint.vout);\n+                            }\n+                            SpendableOutputDescriptor::DynamicOutputP2WSH { .. } => {\n+                                println!(\"Got on-chain output we should claim...\");\n+                                //TODO: Send back to Bitcoin Core!\n+                            }\n+                            SpendableOutputDescriptor::DynamicOutputP2WPKH { .. } => {\n+                                println!(\"Got on-chain output we should claim...\");\n+                                //TODO: Send back to Bitcoin Core!\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+        }\n+\n+        if save_state {\n+            self.save_channel_manager_state();\n+        }\n+    }\n+\n+    fn save_channel_manager_state(&self) {\n+        let filename = format!(\"{}/{}\", self.file_prefix, CHANNEL_MANAGER_FILE);\n+        let tmp_filename = filename.clone() + \".tmp\";\n+        {\n+            let mut f = fs::File::create(&tmp_filename).unwrap();\n+            self.channel_manager.write(&mut f).unwrap();\n+        }\n+        fs::rename(&tmp_filename, &filename).unwrap();\n+    }\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "935fff5438beec87acb4a78099381f4d2396c655",
        "filename": "src/rusty/src/core_lightning/mod.rs",
        "status": "added",
        "additions": 600,
        "deletions": 0,
        "changes": 600,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/core_lightning/mod.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/core_lightning/mod.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/core_lightning/mod.rs?ref=6693089385aa51c1c2769e21ad738aff3252b5f0",
        "patch": "@@ -0,0 +1,600 @@\n+use bitcoin::secp256k1::key::PublicKey;\n+use bitcoin::secp256k1::Secp256k1;\n+\n+use bitcoin::network::constants;\n+use std::ffi::CStr;\n+use std::os::raw::{c_char, c_ulong};\n+use std::ffi::CString;\n+use std::sync::{Arc, Mutex};\n+\n+use crate::bridge::*;\n+use bitcoin::consensus::{encode, serialize};\n+use bitcoin::util::bip32;\n+use bitcoin::Block;\n+use lightning::chain::chaininterface;\n+use lightning::chain::chaininterface::BlockNotifier;\n+use lightning::chain::keysinterface::{\n+    InMemoryChannelKeys, KeysInterface, KeysManager,\n+};\n+use lightning::util::logger::{Logger, Record, Level};\n+use std::collections::HashMap;\n+use std::io::{Write, Read};\n+use std::time::{Duration, SystemTime, UNIX_EPOCH};\n+use std::{fs, thread, time};\n+\n+use lightning::ln::peer_handler::PeerManager;\n+use lightning::ln::{channelmanager, channelmonitor, peer_handler, router};\n+use lightning::util::config;\n+use lightning::util::ser::{ReadableArgs, Writeable};\n+\n+use lightning::ln::channelmanager::{PaymentHash, PaymentPreimage};\n+use self::socket::SocketDescriptor;\n+use std::mem::transmute;\n+use std::net::{Ipv4Addr, SocketAddr, SocketAddrV4, TcpListener};\n+use std::str::FromStr;\n+use std::borrow::Borrow;\n+use std::fs::OpenOptions;\n+use bitcoin::hashes::Hash;\n+\n+mod socket;\n+mod utils;\n+mod chain_interface;\n+mod event_handler;\n+use core_lightning::chain_interface::*;\n+use core_lightning::utils::*;\n+use core_lightning::event_handler::EventHandler;\n+\n+const FEE_PROPORTIONAL_MILLIONTHS: u32 = 10;\n+const ANNOUNCE_CHANNELS: bool = false;\n+\n+const SUBDIR: &str = \"/lightning\";\n+const MONITORS_SUBDIR: &str = \"/monitors\";\n+const SEED_KEY_FILE: &str = \"seed.key\";\n+const CHANNEL_MANAGER_FILE: &str = \"manager.dat\";\n+const PEERS_FILE: &str = \"peers.dat\";\n+\n+#[repr(C)]\n+pub struct PeerList {\n+    ptr: *mut Peer,\n+    len: usize,\n+}\n+\n+#[repr(C)]\n+pub struct Peer {\n+    id: CString,\n+}\n+\n+#[repr(C)]\n+pub struct ChannelList {\n+    ptr: *mut Channel,\n+    len: usize,\n+}\n+\n+#[repr(C)]\n+pub struct Channel {\n+    short_id: u64,\n+    capacity: u64,\n+    id: CString,\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn init_node(datadir: *const c_char) -> *mut Node {\n+    let data_path: String = match unsafe { CStr::from_ptr(datadir) }.to_str() {\n+        Ok(d) => d.to_string() + SUBDIR,\n+        Err(_) => panic!(),\n+    };\n+\n+    let lightning_node = Node::new(data_path);\n+    let lightning_ptr = unsafe { transmute(Box::new(lightning_node)) };\n+    lightning_ptr\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn listen_incoming(ptr: *mut Node, bind_port: u16) -> bool {\n+    let node = unsafe { &mut *ptr };\n+    node.listen_incoming(bind_port)\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn connect_peer(ptr: *mut Node, addr: *const c_char) -> bool {\n+    let node = unsafe { &mut *ptr };\n+    let addr_string: String = match unsafe { CStr::from_ptr(addr) }.to_str() {\n+        Ok(d) => d.to_string(),\n+        Err(_) => return false,\n+    };\n+    node.connect_peer(addr_string)\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn get_peers(ptr: *mut Node) -> PeerList {\n+    let node = unsafe { &mut *ptr };\n+    let boxed_slice = node.get_peers().into_boxed_slice();\n+    let len = boxed_slice.len();\n+    let fat_ptr: *mut [Peer] = Box::into_raw(boxed_slice);\n+    let slim_ptr: *mut Peer = fat_ptr as _;\n+    PeerList { ptr: slim_ptr, len }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn fund_channel(ptr: *mut Node, node_id: *const c_char, amount: c_ulong) -> bool {\n+    let node = unsafe { &mut *ptr };\n+    let pk = unsafe { CStr::from_ptr(node_id) }.to_str().unwrap();\n+    node.fund_channel(pk.parse().unwrap(), amount)\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn get_channels(ptr: *mut Node) -> ChannelList {\n+    let node = unsafe { &mut *ptr };\n+    let boxed_slice = node.get_channels().into_boxed_slice();\n+    let len = boxed_slice.len();\n+    let fat_ptr: *mut [Channel] = Box::into_raw(boxed_slice);\n+    let slim_ptr: *mut Channel = fat_ptr as _;\n+    ChannelList { ptr: slim_ptr, len }\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn pay_invoice(ptr: *mut Node, invoice: *const c_char) -> CString {\n+    let node = unsafe { &mut *ptr };\n+    let invoice_str = unsafe { CStr::from_ptr(invoice) }.to_str().unwrap();\n+    CString::new(node.pay_invoice(invoice_str)).unwrap()\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn create_invoice(\n+    ptr: *mut Node,\n+    desc: *const c_char,\n+    amount: c_ulong,\n+) -> CString {\n+    let node = unsafe { &mut *ptr };\n+    CString::new(node.create_invoice(desc, amount)).unwrap()\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn close_channel(ptr: *mut Node, channel_id: *const c_char) -> CString {\n+    let node = unsafe { &mut *ptr };\n+    let id = unsafe { CStr::from_ptr(channel_id) }.to_str().unwrap();\n+    CString::new(node.close_channel(id)).unwrap()\n+}\n+\n+#[no_mangle]\n+pub extern \"C\" fn notify_block(ptr: *mut Node) {\n+    let node = unsafe { &mut *ptr };\n+    node.notify_block()\n+}\n+\n+pub struct Node {\n+    handler: Arc<EventHandler>,\n+    peers: Vec<String>,\n+    fee_estimator: Arc<FeeEstimator>,\n+}\n+\n+impl Node {\n+    pub fn new(data_path: String) -> Node {\n+        fs::create_dir_all(data_path.clone()).expect(\"Couldn't create lightning data directory\");\n+\n+        let network = match BlockIndex::network_id().as_ref() {\n+            \"main\" => constants::Network::Bitcoin,\n+            \"test\" => constants::Network::Testnet,\n+            \"regtest\" => constants::Network::Regtest,\n+            _ => panic!(\"Unknown network\"),\n+        };\n+\n+        let node_seed = if let Ok(seed) = fs::read(format!(\"{}/{}\", data_path.clone(), SEED_KEY_FILE)) {\n+            assert_eq!(seed.len(), 32);\n+            let mut key = [0; 32];\n+            key.copy_from_slice(&seed);\n+            key\n+        } else {\n+            let mut rand_ctx = RandomContext::new();\n+            let seed = rand_ctx.randthirtytwobytes();\n+            let mut key = [0; 32];\n+            key.copy_from_slice(serialize(&seed).as_slice());\n+            let mut f = fs::File::create(format!(\"{}/{}\", data_path.clone(), SEED_KEY_FILE)).unwrap();\n+            f.write_all(&key).expect(\"Failed to write seed to disk\");\n+            f.sync_all().expect(\"Failed to sync seed to disk\");\n+            key\n+        };\n+\n+        let logger = Arc::new(LogPrinter {});\n+\n+        let starting_time = SystemTime::now();\n+        let since_the_epoch = starting_time\n+            .duration_since(UNIX_EPOCH)\n+            .expect(\"Time went backwards\");\n+\n+        let keys = Arc::new(KeysManager::new(\n+            &node_seed,\n+            network,\n+            logger.clone(),\n+            since_the_epoch.as_secs(),\n+            since_the_epoch.subsec_micros(),\n+        ));\n+\n+        let secp_ctx = Secp256k1::new();\n+\n+        let (import_key_1, import_key_2) =\n+            bip32::ExtendedPrivKey::new_master(network, &node_seed)\n+                .map(|extpriv| {\n+                    (\n+                        extpriv\n+                            .ckd_priv(&secp_ctx, bip32::ChildNumber::from_hardened_idx(1).unwrap())\n+                            .unwrap()\n+                            .private_key\n+                            .key,\n+                        extpriv\n+                            .ckd_priv(&secp_ctx, bip32::ChildNumber::from_hardened_idx(2).unwrap())\n+                            .unwrap()\n+                            .private_key\n+                            .key,\n+                    )\n+                })\n+                .unwrap();\n+\n+        if !import_key(import_key_1.encode()) || !import_key(import_key_2.encode()) {\n+            panic!(\"Couldn't import private keys\")\n+        }\n+\n+        let chain_monitor = Arc::new(ChainInterface::new(network, logger.clone()));\n+\n+        let fee_estimator = Arc::new(FeeEstimator::new());\n+\n+        let monitors_dir = data_path.clone() + MONITORS_SUBDIR;\n+\n+        fs::create_dir_all(monitors_dir.clone()).expect(\"Couldn't create monitors subdir\");\n+\n+        let mut monitors_loaded =\n+            ChannelMonitor::load_from_disk(&monitors_dir);\n+\n+        let channel_monitor = Arc::new(ChannelMonitor {\n+            monitor: channelmonitor::SimpleManyChannelMonitor::new(\n+                chain_monitor.clone(),\n+                chain_monitor.clone(),\n+                logger.clone(),\n+                fee_estimator.clone(),\n+            ),\n+            file_prefix: monitors_dir.clone(),\n+        });\n+\n+        let mut config = config::UserConfig::default();\n+        config.channel_options.fee_proportional_millionths = FEE_PROPORTIONAL_MILLIONTHS;\n+        config.channel_options.announced_channel = ANNOUNCE_CHANNELS;\n+\n+        let channel_manager = if let Ok(mut f) = fs::File::open(format!(\"{}/{}\", data_path.clone(), CHANNEL_MANAGER_FILE))\n+        {\n+            let (last_block_hash, manager) = {\n+                let mut monitors_refs = HashMap::new();\n+                for (outpoint, monitor) in monitors_loaded.iter_mut() {\n+                    monitors_refs.insert(*outpoint, monitor);\n+                }\n+                <(\n+                    bitcoin_hashes::sha256d::Hash,\n+                    channelmanager::ChannelManager<InMemoryChannelKeys>,\n+                )>::read(\n+                    &mut f,\n+                    channelmanager::ChannelManagerReadArgs {\n+                        keys_manager: keys.clone(),\n+                        fee_estimator: fee_estimator.clone(),\n+                        monitor: channel_monitor.clone(),\n+                        tx_broadcaster: chain_monitor.clone(),\n+                        logger: logger.clone(),\n+                        default_config: config,\n+                        channel_monitors: &mut monitors_refs,\n+                    },\n+                )\n+                .expect(\"Failed to deserialize channel manager\")\n+            };\n+            channel_monitor.load_from_vec(monitors_loaded);\n+            //TODO: Rescan\n+            let manager = Arc::new(manager);\n+            manager\n+        } else {\n+            if !monitors_loaded.is_empty() {\n+                panic!(\"Found some channel monitors but no channel state!\");\n+            }\n+            channelmanager::ChannelManager::new(\n+                network,\n+                fee_estimator.clone(),\n+                channel_monitor.clone(),\n+                chain_monitor.clone(),\n+                logger.clone(),\n+                keys.clone(),\n+                config,\n+                get_block_count() as usize,\n+            )\n+            .unwrap()\n+        };\n+\n+        let router = Arc::new(router::Router::new(\n+            PublicKey::from_secret_key(&secp_ctx, &keys.get_node_secret()),\n+            chain_monitor.clone(),\n+            logger.clone(),\n+        ));\n+\n+        let mut rand_ctx = RandomContext::new();\n+        let rand256 = rand_ctx.randthirtytwobytes();\n+        let mut rand = [0; 32];\n+        rand.copy_from_slice(serialize(&rand256).as_slice());\n+\n+        let peer_manager: Arc<PeerManager<socket::SocketDescriptor>> =\n+            Arc::new(peer_handler::PeerManager::new(\n+                peer_handler::MessageHandler {\n+                    chan_handler: channel_manager.clone(),\n+                    route_handler: router.clone(),\n+                },\n+                keys.get_node_secret(),\n+                &rand,\n+                logger.clone(),\n+            ));\n+\n+        let payment_preimages: Arc<Mutex<HashMap<PaymentHash, PaymentPreimage>>> =\n+            Arc::new(Mutex::new(HashMap::new()));\n+\n+        let block_notifier = Arc::new(BlockNotifier::new(chain_monitor.clone()));\n+\n+        let channel_manager_listener: Arc<chaininterface::ChainListener> = channel_manager.clone();\n+        block_notifier.register_listener(Arc::downgrade(&channel_manager_listener));\n+\n+        let event_handler = Arc::new(EventHandler::new(\n+            network,\n+            data_path,\n+            peer_manager.clone(),\n+            channel_monitor.monitor.clone(),\n+            channel_manager.clone(),\n+            chain_monitor.clone(),\n+            block_notifier.clone(),\n+            router.clone(),\n+            payment_preimages.clone(),\n+        ));\n+\n+        let event_handler_clone = event_handler.clone();\n+\n+        thread::spawn(move || {\n+            loop {\n+                thread::sleep(time::Duration::from_millis(500));\n+                event_handler_clone.process_events();\n+            }\n+        });\n+\n+        let mut res = Node {\n+            handler: event_handler,\n+            peers: Vec::new(),\n+            fee_estimator: fee_estimator.clone(),\n+        };\n+\n+        res.reconnect_peers();\n+        res\n+    }\n+\n+    pub fn listen_incoming(&self, bind_port: u16) -> bool {\n+        let listener = TcpListener::bind(SocketAddr::V4(SocketAddrV4::new(\n+            Ipv4Addr::new(0, 0, 0, 0),\n+            bind_port,\n+        )))\n+        .unwrap();\n+        listener.set_nonblocking(true).expect(\"Cannot set non-blocking\");\n+\n+        print!(\"Listening on port {}...\\n\", bind_port);\n+\n+        for stream in listener.incoming() {\n+            match stream {\n+                Ok(_) => {\n+                    print!(\"Incoming connection on {}...\\n\", bind_port);\n+                }\n+                Err(e) => panic!(\"encountered IO error: {}\", e),\n+            }\n+        }\n+\n+        true\n+    }\n+\n+    fn save_peer(&self, addr: String) {\n+        if self.peers.contains(&addr) {\n+            return\n+        }\n+\n+        let peer_file_path = format!(\"{}/{}\", self.handler.file_prefix, PEERS_FILE);\n+        if let Ok(mut f) = OpenOptions::new().append(true).open(peer_file_path.as_str()) {\n+            write!(f, \"{}\\n\", addr).unwrap();\n+        } else {\n+            let mut f = fs::File::create(peer_file_path.as_str()).unwrap();\n+            write!(f, \"{}\\n\", addr).unwrap();\n+            f.sync_all().expect(\"Failed to sync peers to disk\");\n+        }\n+    }\n+\n+    fn reconnect_peers(&mut self) {\n+        let peer_file_path = format!(\"{}/{}\", self.handler.file_prefix, PEERS_FILE);\n+        if let Ok(mut f) = fs::File::open(peer_file_path.as_str()) {\n+            let mut data = String::new();\n+            if f.read_to_string(&mut data).is_ok() {\n+                let file_peers = data.split(\"\\n\");\n+                for peer in file_peers {\n+                    if peer.len() > 33 {\n+                        self.peers.push(peer.to_string());\n+                        self.connect_peer(peer.to_string());\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    pub fn connect_peer(&self, addr: String) -> bool {\n+        match hex_to_compressed_pubkey(&addr) {\n+            Some(pk) => {\n+                if addr.as_bytes()[33 * 2] == '@' as u8 {\n+                    let parse_res: Result<std::net::SocketAddr, _> =\n+                        addr.split_at(33 * 2 + 1).1.parse();\n+                    if let Ok(sock_addr) = parse_res {\n+                        print!(\"Attempting to connect to {}...\", sock_addr);\n+                        match std::net::TcpStream::connect_timeout(&sock_addr, Duration::from_secs(10)) {\n+                            Ok(stream) => {\n+                                stream\n+                                    .set_nonblocking(false)\n+                                    .expect(\"set_nonblocking call failed\");\n+                                println!(\"connected, initiating handshake!\");\n+                                let mut descriptor = SocketDescriptor::new(\n+                                    self.handler.clone(),\n+                                    stream,\n+                                );\n+                                descriptor.setup_outbound(pk);\n+                                self.save_peer(addr);\n+                                true\n+                            }\n+                            Err(e) => {\n+                                println!(\"connection failed {:?}!\", e);\n+                                false\n+                            }\n+                        }\n+                    } else {\n+                        println!(\"Couldn't parse host:port into a socket address\");\n+                        false\n+                    }\n+                } else {\n+                    println!(\"Invalid line, should be c pubkey@host:port\");\n+                    false\n+                }\n+            }\n+            None => {\n+                println!(\"Bad PubKey for remote node\");\n+                false\n+            }\n+        };\n+        false\n+    }\n+\n+    pub fn get_peers(&self) -> Vec<Peer> {\n+        let mut peers: Vec<Peer> = Vec::new();\n+\n+        for node_id in self.handler.peer_manager.get_peer_node_ids() {\n+            let hex = CString::new(hex_str(&node_id.serialize())).unwrap();\n+            peers.push(Peer{id: hex.clone()});\n+        }\n+\n+        peers\n+    }\n+\n+    pub fn fund_channel(&self, node_id: String, amount: u64) -> bool {\n+        let pk = hex_to_compressed_pubkey(node_id.as_str());\n+\n+        match self\n+            .handler\n+            .channel_manager\n+            .create_channel(pk.unwrap(), amount, 0, 0)\n+        {\n+            Ok(_) => {\n+                self.handler.process_events();\n+                true\n+            }\n+            Err(e) => {\n+                println!(\"Failed to open channel: {:?}!\", e);\n+                false\n+            }\n+        }\n+    }\n+\n+    pub fn get_channels(&self) -> Vec<Channel> {\n+        let mut channels: Vec<Channel> = Vec::new();\n+        for chan_info in self.handler.channel_manager.list_channels() {\n+            let id = CString::new(hex_str(&chan_info.channel_id[..])).unwrap();\n+            if let Some(short_id) = chan_info.short_channel_id {\n+                channels.push(Channel{id, short_id, capacity: chan_info.channel_value_satoshis});\n+            } else {\n+                channels.push(Channel{id, short_id: 0, capacity: chan_info.channel_value_satoshis});\n+            }\n+        }\n+\n+        channels\n+    }\n+\n+    pub fn pay_invoice(&self, bolt11: &str) -> &str {\n+        match lightning_invoice::Invoice::from_str(bolt11) {\n+            Ok(invoice) => {\n+                if match invoice.currency() {\n+                    lightning_invoice::Currency::Bitcoin => constants::Network::Bitcoin,\n+                    lightning_invoice::Currency::BitcoinTestnet => constants::Network::Testnet,\n+                    lightning_invoice::Currency::Regtest => constants::Network::Regtest,\n+                } != self.handler.network {\n+                    \"Wrong network on invoice\"\n+                } else {\n+                    let mut route_hint = Vec::with_capacity(invoice.routes().len());\n+                    for route in invoice.routes() {\n+                            route_hint.push(router::RouteHint {\n+                                src_node_id: route[0].pubkey,\n+                                short_channel_id: slice_to_be64(&route[0].short_channel_id),\n+                                fee_base_msat: route[0].fee_base_msat,\n+                                fee_proportional_millionths: route[0].fee_proportional_millionths,\n+                                cltv_expiry_delta: route[0].cltv_expiry_delta,\n+                                htlc_minimum_msat: 0,\n+                            });\n+                    }\n+\n+                    let final_cltv = invoice.min_final_cltv_expiry().unwrap();\n+\n+                    match self.handler.router.get_route(invoice.recover_payee_pub_key().borrow(), Some(&self.handler.channel_manager.list_usable_channels()), &route_hint, invoice.amount_pico_btc().unwrap() / 10, *final_cltv as u32) {\n+                        Ok(route) => {\n+                            match self.handler.channel_manager.send_payment(route, PaymentHash(invoice.payment_hash().into_inner())) {\n+                                Ok(()) => {\n+                                    \"Sending payment\"\n+                                },\n+                                Err(_) => {\n+                                    \"Payment failed\"\n+                                }\n+                            }\n+                        },\n+                        Err(e) => {\n+                            e.err\n+                        }\n+                    }\n+                }\n+            },\n+            Err(_) => {\n+                \"Bad invoice\"\n+            },\n+        }\n+    }\n+\n+    pub fn create_invoice(&self, _desc: *const c_char, _amount: c_ulong) -> &str {\n+        \"not implemented\"\n+    }\n+\n+    pub fn close_channel(&self, chan_id: &str) -> &str {\n+        if chan_id.len() == 64  {\n+            if let Some(chan_id_vec) = hex_to_vec(chan_id) {\n+                let mut channel_id = [0; 32];\n+                channel_id.copy_from_slice(&chan_id_vec);\n+                match self.handler.channel_manager.close_channel(&channel_id) {\n+                    Ok(()) => {\n+                        \"Closing channel!\"\n+                    },\n+                    Err(_) => \"Failed to close channel.\"\n+                }\n+            } else { \"Bad channel_id\" }\n+        } else { \"channel_id too short\" }\n+    }\n+\n+    pub fn notify_block(&self) {\n+        self.fee_estimator.update_values();\n+        let chain_tip = BlockIndex::tip();\n+        let block: Block = encode::deserialize(chain_tip.block_bytes().as_ref()).expect(\"Couldn't deserialize tip data\");\n+        self.handler.block_notifier.block_connected(block.borrow(), chain_tip.height() as u32);\n+    }\n+}\n+\n+struct LogPrinter {}\n+\n+impl Logger for LogPrinter {\n+    fn log(&self, record: &Record) {\n+        log_line(\n+            format!(\n+                \"CoreLightning: {:<5} [{} : {}, {}] {}\",\n+                record.level.to_string(),\n+                record.module_path,\n+                record.file,\n+                record.line,\n+                record.args\n+            )\n+                .as_str(),\n+            false, //record.level == Level::Trace,\n+        );\n+    }\n+}"
      },
      {
        "sha": "da855b36461f03aa723fc7c49f38b0769bb16e84",
        "filename": "src/rusty/src/core_lightning/socket.rs",
        "status": "added",
        "additions": 136,
        "deletions": 0,
        "changes": 136,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/core_lightning/socket.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/core_lightning/socket.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/core_lightning/socket.rs?ref=6693089385aa51c1c2769e21ad738aff3252b5f0",
        "patch": "@@ -0,0 +1,136 @@\n+use bitcoin::secp256k1::PublicKey;\n+use lightning::ln::peer_handler;\n+use lightning::ln::peer_handler::SocketDescriptor as LnSocketTrait;\n+use std::io::{Read, Write};\n+use std::net::TcpStream;\n+use std::sync::atomic::AtomicU64;\n+use std::sync::atomic::Ordering;\n+use std::sync::Arc;\n+use std::{hash, thread};\n+use core_lightning::event_handler::EventHandler;\n+\n+static ID_COUNTER: AtomicU64 = AtomicU64::new(0);\n+\n+pub struct SocketDescriptor {\n+    event_notify: Arc<EventHandler>,\n+    pending_read: Vec<u8>,\n+    read_paused: bool,\n+    need_disconnect: bool,\n+    id: u64,\n+    stream: TcpStream,\n+    read_scheduled: bool,\n+}\n+\n+impl SocketDescriptor {\n+    pub(crate) fn new(\n+        event_notify: Arc<EventHandler>,\n+        stream: TcpStream,\n+    ) -> Self {\n+        Self {\n+            id: ID_COUNTER.fetch_add(1, Ordering::AcqRel),\n+            event_notify,\n+            pending_read: Vec::new(),\n+            read_paused: false,\n+            need_disconnect: true,\n+            stream,\n+            read_scheduled: true,\n+        }\n+    }\n+\n+    pub fn constant_read(&mut self) {\n+        let mut input_stream = self.stream.try_clone().unwrap();\n+        let peer_manager_clone = self.event_notify.clone_peer_manager();\n+        let mut us = self.clone();\n+\n+        thread::spawn(move || {\n+            let mut client_buffer = [0u8; 1024];\n+\n+            loop {\n+                match input_stream.read(&mut client_buffer) {\n+                    Ok(n) => {\n+                        if n > 0 {\n+                            println!(\"Read {}!\", n);\n+                            match peer_manager_clone\n+                                .read_event(&mut us, client_buffer[..n].to_vec())\n+                            {\n+                                Ok(pause_read) => {\n+                                    if pause_read {\n+                                        us.read_paused = true;\n+                                    }\n+                                }\n+                                Err(e) => {\n+                                    us.need_disconnect = false;\n+                                }\n+                            }\n+\n+                            us.event_notify.process_events();\n+                        }\n+                    }\n+                    Err(error) => {\n+                        println!(\"{}\", error.to_string());\n+                    }\n+                }\n+            }\n+        });\n+    }\n+\n+    pub fn setup_outbound(&mut self, their_node_id: PublicKey) {\n+        if let Ok(initial_send) = self\n+            .event_notify.clone_peer_manager().new_outbound_connection(their_node_id, self.clone())\n+        {\n+            if self.send_data(&initial_send, true) == initial_send.len() {\n+                self.constant_read();\n+            }\n+        }\n+    }\n+}\n+\n+impl peer_handler::SocketDescriptor for SocketDescriptor {\n+    fn send_data(&mut self, data: &[u8], resume_read: bool) -> usize {\n+        println!(\n+            \"Writing to: {}\",\n+            // TODO: peer can be disconnected\n+            self.stream.peer_addr().unwrap().ip().to_string()\n+        );\n+\n+        let bytes_written = self.stream.write(data).unwrap();\n+\n+        println!(\"Written {}\", bytes_written);\n+\n+        if resume_read {\n+            self.read_scheduled = true;\n+        }\n+\n+        bytes_written\n+    }\n+\n+    fn disconnect_socket(&mut self) {\n+        self.need_disconnect = true;\n+        self.read_paused = true;\n+    }\n+}\n+impl Eq for SocketDescriptor {}\n+impl PartialEq for SocketDescriptor {\n+    fn eq(&self, o: &Self) -> bool {\n+        self.id == o.id\n+    }\n+}\n+impl hash::Hash for SocketDescriptor {\n+    fn hash<H: std::hash::Hasher>(&self, state: &mut H) {\n+        self.id.hash(state);\n+    }\n+}\n+\n+impl Clone for SocketDescriptor {\n+    fn clone(&self) -> SocketDescriptor {\n+        SocketDescriptor {\n+            event_notify: self.event_notify.clone(),\n+            pending_read: self.pending_read.clone(),\n+            read_paused: self.read_paused,\n+            need_disconnect: self.need_disconnect,\n+            id: self.id,\n+            stream: self.stream.try_clone().unwrap(),\n+            read_scheduled: self.read_scheduled,\n+        }\n+    }\n+}"
      },
      {
        "sha": "14374558602c40439188753a65f97bf78df24449",
        "filename": "src/rusty/src/core_lightning/utils.rs",
        "status": "added",
        "additions": 54,
        "deletions": 0,
        "changes": 54,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/core_lightning/utils.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/core_lightning/utils.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/core_lightning/utils.rs?ref=6693089385aa51c1c2769e21ad738aff3252b5f0",
        "patch": "@@ -0,0 +1,54 @@\n+use bitcoin::secp256k1::PublicKey;\n+\n+pub fn hex_to_vec(hex: &str) -> Option<Vec<u8>> {\n+    let mut out = Vec::with_capacity(hex.len() / 2);\n+\n+    let mut b = 0;\n+    for (idx, c) in hex.as_bytes().iter().enumerate() {\n+        b <<= 4;\n+        match *c {\n+            b'A'...b'F' => b |= c - b'A' + 10,\n+            b'a'...b'f' => b |= c - b'a' + 10,\n+            b'0'...b'9' => b |= c - b'0',\n+            _ => return None,\n+        }\n+        if (idx & 1) == 1 {\n+            out.push(b);\n+            b = 0;\n+        }\n+    }\n+\n+    Some(out)\n+}\n+\n+pub fn hex_to_compressed_pubkey(hex: &str) -> Option<PublicKey> {\n+    let data = match hex_to_vec(&hex[0..33 * 2]) {\n+        Some(bytes) => bytes,\n+        None => return None,\n+    };\n+    match PublicKey::from_slice(&data) {\n+        Ok(pk) => Some(pk),\n+        Err(_) => None,\n+    }\n+}\n+\n+#[inline]\n+pub fn hex_str(value: &[u8]) -> String {\n+    let mut res = String::with_capacity(64);\n+    for v in value {\n+        res += &format!(\"{:02x}\", v);\n+    }\n+    res\n+}\n+\n+#[inline]\n+pub fn slice_to_be64(v: &[u8]) -> u64 {\n+    ((v[0] as u64) << 8*7) |\n+        ((v[1] as u64) << 8*6) |\n+        ((v[2] as u64) << 8*5) |\n+        ((v[3] as u64) << 8*4) |\n+        ((v[4] as u64) << 8*3) |\n+        ((v[5] as u64) << 8*2) |\n+        ((v[6] as u64) << 8*1) |\n+        ((v[7] as u64) << 8*0)\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "6dcea551e2858aadb291f037429ea5903596dd2b",
        "filename": "src/rusty/src/cpp_bridge.cpp",
        "status": "modified",
        "additions": 114,
        "deletions": 0,
        "changes": 114,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/cpp_bridge.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/cpp_bridge.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/cpp_bridge.cpp?ref=6693089385aa51c1c2769e21ad738aff3252b5f0",
        "patch": "@@ -6,6 +6,12 @@\n #include <serialize.h>\n #include <consensus/validation.h>\n #include <logging.h>\n+#include <script/standard.h>\n+#include <wallet/wallet.h>\n+#include <wallet/coincontrol.h>\n+#include <core_io.h>\n+#include <node/transaction.h>\n+#include <key_io.h>\n \n /** A class that deserializes a single thing one time. */\n class InputStream\n@@ -190,6 +196,11 @@ void rusty_SerializeIndex(const void* pindexvoid, unsigned char* eighty_bytes_de\n     memcpy(eighty_bytes_dest, ser.data(), 80);\n }\n \n+const char* rusty_GetNetworkIDString() {\n+    auto network = Params().NetworkIDString().c_str();\n+    return network;\n+}\n+\n void* rusty_GetBlockData(const void* pindexvoid, const unsigned char **data, uint64_t *datalen) {\n     const CBlockIndex *pindex = (const CBlockIndex*) pindexvoid;\n     std::vector<uint8_t> *res = new std::vector<uint8_t>();\n@@ -258,6 +269,109 @@ uint64_t rusty_GetRandRange(void* contextvoid, uint64_t range) {\n     return ctx->randrange(range);\n }\n \n+ThirtyTwoBytes rusty_GetRandThirtyTwoBytes(void* contextvoid) {\n+    FastRandomContext* ctx = (FastRandomContext*) contextvoid;\n+    ThirtyTwoBytes ret;\n+    uint256 work = ctx->rand256();\n+    memcpy(ret.val, work.begin(), 32);\n+    return ret;\n+}\n+\n+const uint64_t rusty_GetBlockCount() {\n+    LOCK(cs_main);\n+    return ::ChainActive().Height();\n+};\n+\n+void* rusty_GetSignedTx(unsigned char* script, unsigned int scriptlen, uint64_t amount, const unsigned char **data, uint64_t *datalen) {\n+    CMutableTransaction mtx = CMutableTransaction();\n+\n+    std::vector<unsigned char> scriptvec(script, script + scriptlen);\n+    std::string s(scriptvec.begin(), scriptvec.end());\n+\n+    CScript scriptPubKey = GetScriptForDestination(DecodeDestination(s));\n+\n+    CTxOut out(amount, scriptPubKey);\n+\n+    mtx.vout.push_back(out);\n+\n+    std::vector<std::shared_ptr<CWallet>> wallets = GetWallets();\n+    std::shared_ptr<CWallet> pwallet = wallets[0];\n+\n+    CAmount fee;\n+    int change_position = 0;\n+\n+    std::string strFailReason;\n+    bool lockUnspents = false;\n+    std::set<int> setSubtractFeeFromOutputs;\n+    CCoinControl coinControl;\n+\n+    bool success = pwallet->FundTransaction(mtx, fee, change_position, strFailReason, lockUnspents, setSubtractFeeFromOutputs, coinControl);\n+\n+    if (!success) {\n+        return nullptr;\n+    }\n+\n+    auto locked_chain = pwallet->chain().lock();\n+    LOCK(pwallet->cs_wallet);\n+\n+    pwallet->SignTransaction(mtx);\n+\n+    CDataStream ssTx(SER_NETWORK, PROTOCOL_VERSION);\n+    ssTx << mtx;\n+\n+    std::string result_str = HexStr(ssTx.str());\n+\n+    std::vector<uint8_t> *res = new std::vector<uint8_t>(ssTx.begin(), ssTx.end());\n+\n+    *data = res->data();\n+    *datalen = res->size();\n+    return (void*)res;\n+}\n+\n+bool rusty_BroadcastTx(const unsigned char* tx, unsigned int txlen) {\n+    CMutableTransaction mtx;\n+\n+    std::vector<unsigned char> tx_data(tx, tx + txlen);\n+    CDataStream ssData(tx_data, SER_NETWORK, PROTOCOL_VERSION);\n+\n+    try {\n+        ssData >> mtx;\n+    } catch (const std::exception&) {\n+        // Fall through.\n+    }\n+\n+    std::string result_str = HexStr(ssData.str());\n+\n+    std::vector<std::shared_ptr<CWallet>> wallets = GetWallets();\n+    std::shared_ptr<CWallet> pwallet = wallets[0];\n+    std::string strFailReason;\n+\n+    std::shared_ptr<const CTransaction> tx_ptr = std::make_shared<const CTransaction>(CTransaction(mtx));\n+\n+    bool ret = pwallet->chain().broadcastTransaction(tx_ptr, strFailReason, pwallet->m_default_max_tx_fee, true);\n+    return ret;\n+}\n+\n+size_t rusty_EstimateFee(unsigned int conftarget, bool conservative) {\n+    FeeCalculation feeCalc;\n+    CFeeRate feeRate = ::feeEstimator.estimateSmartFee(conftarget, &feeCalc, conservative);\n+    return feeRate.GetFeePerK();\n+}\n+\n+bool rusty_ImportKey(const unsigned char* key) {\n+    std::vector<unsigned char> keyvec(key, key + 32);\n+\n+    CKey privkey = CKey();\n+    privkey.Set(keyvec.begin(), keyvec.end(), true);\n+\n+    CPubKey pubkey = privkey.GetPubKey();\n+    std::vector<std::shared_ptr<CWallet>> wallets = GetWallets();\n+    std::shared_ptr<CWallet> pwallet = wallets[0];\n+\n+    LOCK(pwallet->cs_wallet);\n+    return pwallet->ImportPrivKeys({{pubkey.GetID(), privkey}}, 1);\n+}\n+\n void rusty_LogLine(const unsigned char* str, bool debug) {\n     if (debug) {\n         LogPrint(BCLog::RUST, \"%s\\n\", str);"
      },
      {
        "sha": "b108f27811c1c38084665cdcaf372b043330d67b",
        "filename": "src/rusty/src/lib.rs",
        "status": "modified",
        "additions": 32,
        "deletions": 25,
        "changes": 57,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/lib.rs",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/lib.rs",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/lib.rs?ref=6693089385aa51c1c2769e21ad738aff3252b5f0",
        "patch": "@@ -3,18 +3,25 @@\n // as distributed by their linux distribution, so in generally cannot \"fix\" the\n // warnings. Thus, we should disable such useless lints below.\n #![allow(deprecated)]\n+#![feature(try_from)]\n+#![feature(integer_atomics)]\n \n extern crate bitcoin;\n extern crate bitcoin_hashes;\n extern crate libc;\n+extern crate lightning;\n+extern crate lightning_invoice;\n+extern crate bitcoin_bech32;\n+extern crate core;\n \n #[cfg(not(test))] mod bridge;\n #[cfg(test)] pub mod test_bridge;\n-#[cfg(test)] pub use test_bridge as bridge;\n+//#[cfg(test)] pub use test_bridge as bridge;\n use bridge::*;\n \n mod dns_headers;\n mod rest_downloader;\n+mod core_lightning;\n \n // Our P2P socket handler currently only supports poll(), so we stub out all the P2P client for\n // Windows with dumy init/stop functions.\n@@ -46,30 +53,30 @@ use std::time::{Duration, Instant};\n // returns Results instead of raw pointers, or redefining the GlobalAlloc API to allow\n // panic!()s inside of alloc calls), we should switch to those, however these APIs are\n // currently unstable.\n-const TOTAL_MEM_LIMIT_BYTES: usize = 128 * 1024 * 1024;\n-static TOTAL_MEM_ALLOCD: AtomicUsize = AtomicUsize::new(0);\n-struct MemoryLimitingAllocator;\n-unsafe impl GlobalAlloc for MemoryLimitingAllocator {\n-    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n-        let len = layout.size();\n-        if len > TOTAL_MEM_LIMIT_BYTES {\n-            return ptr::null_mut();\n-        }\n-        if TOTAL_MEM_ALLOCD.fetch_add(len, Ordering::AcqRel) + len > TOTAL_MEM_LIMIT_BYTES {\n-            TOTAL_MEM_ALLOCD.fetch_sub(len, Ordering::AcqRel);\n-            return ptr::null_mut();\n-        }\n-        System.alloc(layout)\n-    }\n-\n-    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n-        System.dealloc(ptr, layout);\n-        TOTAL_MEM_ALLOCD.fetch_sub(layout.size(), Ordering::AcqRel);\n-    }\n-}\n-\n-#[global_allocator]\n-static ALLOC: MemoryLimitingAllocator = MemoryLimitingAllocator;\n+//const TOTAL_MEM_LIMIT_BYTES: usize = 128 * 1024 * 1024;\n+//static TOTAL_MEM_ALLOCD: AtomicUsize = AtomicUsize::new(0);\n+//struct MemoryLimitingAllocator;\n+//unsafe impl GlobalAlloc for MemoryLimitingAllocator {\n+//    unsafe fn alloc(&self, layout: Layout) -> *mut u8 {\n+//        let len = layout.size();\n+//        if len > TOTAL_MEM_LIMIT_BYTES {\n+//            return ptr::null_mut();\n+//        }\n+//        if TOTAL_MEM_ALLOCD.fetch_add(len, Ordering::AcqRel) + len > TOTAL_MEM_LIMIT_BYTES {\n+//            TOTAL_MEM_ALLOCD.fetch_sub(len, Ordering::AcqRel);\n+//            return ptr::null_mut();\n+//        }\n+//        System.alloc(layout)\n+//    }\n+//\n+//    unsafe fn dealloc(&self, ptr: *mut u8, layout: Layout) {\n+//        System.dealloc(ptr, layout);\n+//        TOTAL_MEM_ALLOCD.fetch_sub(layout.size(), Ordering::AcqRel);\n+//    }\n+//}\n+//\n+//#[global_allocator]\n+//static ALLOC: MemoryLimitingAllocator = MemoryLimitingAllocator;\n \n /// Waits for IBD to complete, to get stuck, or shutdown to be initiated. This should be called\n /// prior to any background block fetchers initiating connections."
      },
      {
        "sha": "664f0bdf9617f6216ccf30f0e674d116d4f8e36b",
        "filename": "src/rusty/src/rust_bridge.h",
        "status": "modified",
        "additions": 44,
        "deletions": 1,
        "changes": 45,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/rust_bridge.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/6693089385aa51c1c2769e21ad738aff3252b5f0/src/rusty/src/rust_bridge.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/rusty/src/rust_bridge.h?ref=6693089385aa51c1c2769e21ad738aff3252b5f0",
        "patch": "@@ -10,6 +10,7 @@\n #include <cstdint>\n #include <cstdlib>\n #include <new>\n+#include <chain.h>\n \n namespace rust_block_fetch {\n \n@@ -23,9 +24,51 @@ bool init_p2p_client(void* pconnman, const char *datadir, const char *subver, ui\n bool stop_p2p_client();\n \n static const bool DEFAULT_P2P = true;\n-\n } // extern \"C\"\n \n } // namespace rust_block_fetch\n \n+namespace lightning {\n+\n+extern \"C\" {\n+\n+struct Peer {\n+    const char* id;\n+};\n+\n+struct PeerList {\n+    Peer* ptr;\n+    size_t len;\n+};\n+\n+struct Channel {\n+    uint64_t short_id;\n+    uint64_t capacity;\n+    const char* id;\n+};\n+\n+struct ChannelList {\n+    Channel* ptr;\n+    size_t len;\n+};\n+\n+static const bool DEFAULT_LIGHTNING = true;\n+static const int DEFAULT_LIGHTNING_PORT = 9735;\n+\n+void* init_node(const char *datadir);\n+bool listen_incoming(void* node_ptr, uint16_t bind_port);\n+bool connect_peer(void* node_ptr, const char *addr);\n+PeerList get_peers(void* node_ptr);\n+bool fund_channel(void* node_ptr, const char *node_id, uint32_t amount);\n+ChannelList get_channels(void* node_ptr);\n+const char* pay_invoice(void* node_ptr, const char *invoice);\n+const char* create_invoice(void* node_ptr, const char *invoice, uint32_t amount);\n+bool close_channel(void* node_ptr, const char *channel_id);\n+void notify_block(void* node_ptr);\n+\n+} // extern \"C\"\n+\n+} // namespace lightning\n+\n+\n #endif // BITCOIN_RUSTY_SRC_RUST_BRIDGE_H"
      }
    ]
  }
]