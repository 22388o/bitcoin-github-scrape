[
  {
    "sha": "26a965c33e45f77ce376a51c817f2d1bb414e078",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyNmE5NjVjMzNlNDVmNzdjZTM3NmE1MWM4MTdmMmQxYmI0MTRlMDc4",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-05-11T17:52:49Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-05-14T17:32:27Z"
      },
      "message": "Remove unused fScriptChecks parameter from CheckInputs\n\nfScriptChecks = false just short-circuits the entire function, so\npassing it in is entirely useless.",
      "tree": {
        "sha": "8c879c1fa575946db89794fd64ef554a15b32a27",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/8c879c1fa575946db89794fd64ef554a15b32a27"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/26a965c33e45f77ce376a51c817f2d1bb414e078",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26a965c33e45f77ce376a51c817f2d1bb414e078",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/26a965c33e45f77ce376a51c817f2d1bb414e078",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26a965c33e45f77ce376a51c817f2d1bb414e078/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "81d0d565ab5551110ef465484b061922452aabe9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/81d0d565ab5551110ef465484b061922452aabe9",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/81d0d565ab5551110ef465484b061922452aabe9"
      }
    ],
    "stats": {
      "total": 157,
      "additions": 73,
      "deletions": 84
    },
    "files": [
      {
        "sha": "70e2f4fb385b0e81c638788fcbce4ecbea24b097",
        "filename": "src/test/txvalidationcache_tests.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 10,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26a965c33e45f77ce376a51c817f2d1bb414e078/src/test/txvalidationcache_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26a965c33e45f77ce376a51c817f2d1bb414e078/src/test/txvalidationcache_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txvalidationcache_tests.cpp?ref=26a965c33e45f77ce376a51c817f2d1bb414e078",
        "patch": "@@ -19,7 +19,7 @@\n \n #include <boost/test/unit_test.hpp>\n \n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks);\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks);\n \n BOOST_AUTO_TEST_SUITE(tx_validationcache_tests)\n \n@@ -119,7 +119,7 @@ static void ValidateCheckInputsForAllFlags(CMutableTransaction &tx, uint32_t fai\n             // WITNESS requires P2SH\n             test_flags |= SCRIPT_VERIFY_P2SH;\n         }\n-        bool ret = CheckInputs(tx, state, pcoinsTip.get(), true, test_flags, true, add_to_cache, txdata, nullptr);\n+        bool ret = CheckInputs(tx, state, pcoinsTip.get(), test_flags, true, add_to_cache, txdata, nullptr);\n         // CheckInputs should succeed iff test_flags doesn't intersect with\n         // failing_flags\n         bool expected_return_value = !(test_flags & failing_flags);\n@@ -129,13 +129,13 @@ static void ValidateCheckInputsForAllFlags(CMutableTransaction &tx, uint32_t fai\n         if (ret && add_to_cache) {\n             // Check that we get a cache hit if the tx was valid\n             std::vector<CScriptCheck> scriptchecks;\n-            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), test_flags, true, add_to_cache, txdata, &scriptchecks));\n             BOOST_CHECK(scriptchecks.empty());\n         } else {\n             // Check that we get script executions to check, if the transaction\n             // was invalid, or we didn't add to cache.\n             std::vector<CScriptCheck> scriptchecks;\n-            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, test_flags, true, add_to_cache, txdata, &scriptchecks));\n+            BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), test_flags, true, add_to_cache, txdata, &scriptchecks));\n             BOOST_CHECK_EQUAL(scriptchecks.size(), tx.vin.size());\n         }\n     }\n@@ -198,13 +198,13 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         CValidationState state;\n         PrecomputedTransactionData ptd_spend_tx(spend_tx);\n \n-        BOOST_CHECK(!CheckInputs(spend_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n+        BOOST_CHECK(!CheckInputs(spend_tx, state, pcoinsTip.get(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, nullptr));\n \n         // If we call again asking for scriptchecks (as happens in\n         // ConnectBlock), we should add a script check object for this -- we're\n         // not caching invalidity (if that changes, delete this test case).\n         std::vector<CScriptCheck> scriptchecks;\n-        BOOST_CHECK(CheckInputs(spend_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n+        BOOST_CHECK(CheckInputs(spend_tx, state, pcoinsTip.get(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_DERSIG, true, true, ptd_spend_tx, &scriptchecks));\n         BOOST_CHECK_EQUAL(scriptchecks.size(), 1U);\n \n         // Test that CheckInputs returns true iff DERSIG-enforcing flags are\n@@ -267,7 +267,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         invalid_with_cltv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n         CValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_cltv_tx);\n-        BOOST_CHECK(CheckInputs(invalid_with_cltv_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n+        BOOST_CHECK(CheckInputs(invalid_with_cltv_tx, state, pcoinsTip.get(), SCRIPT_VERIFY_CHECKLOCKTIMEVERIFY, true, true, txdata, nullptr));\n     }\n \n     // TEST CHECKSEQUENCEVERIFY\n@@ -295,7 +295,7 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         invalid_with_csv_tx.vin[0].scriptSig = CScript() << vchSig << 100;\n         CValidationState state;\n         PrecomputedTransactionData txdata(invalid_with_csv_tx);\n-        BOOST_CHECK(CheckInputs(invalid_with_csv_tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n+        BOOST_CHECK(CheckInputs(invalid_with_csv_tx, state, pcoinsTip.get(), SCRIPT_VERIFY_CHECKSEQUENCEVERIFY, true, true, txdata, nullptr));\n     }\n \n     // TODO: add tests for remaining script flags\n@@ -357,12 +357,12 @@ BOOST_FIXTURE_TEST_CASE(checkinputs_test, TestChain100Setup)\n         CValidationState state;\n         PrecomputedTransactionData txdata(tx);\n         // This transaction is now invalid under segwit, because of the second input.\n-        BOOST_CHECK(!CheckInputs(tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n+        BOOST_CHECK(!CheckInputs(tx, state, pcoinsTip.get(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, nullptr));\n \n         std::vector<CScriptCheck> scriptchecks;\n         // Make sure this transaction was not cached (ie because the first\n         // input was valid)\n-        BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), true, SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n+        BOOST_CHECK(CheckInputs(tx, state, pcoinsTip.get(), SCRIPT_VERIFY_P2SH | SCRIPT_VERIFY_WITNESS, true, true, txdata, &scriptchecks));\n         // Should get 2 script checks back -- caching is on a whole-transaction basis.\n         BOOST_CHECK_EQUAL(scriptchecks.size(), 2U);\n     }"
      },
      {
        "sha": "4742a6ac0f642a40ea6c65bd616a32352dd2d307",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 63,
        "deletions": 74,
        "changes": 137,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/26a965c33e45f77ce376a51c817f2d1bb414e078/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/26a965c33e45f77ce376a51c817f2d1bb414e078/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=26a965c33e45f77ce376a51c817f2d1bb414e078",
        "patch": "@@ -303,7 +303,7 @@ enum class FlushStateMode {\n static bool FlushStateToDisk(const CChainParams& chainParams, CValidationState &state, FlushStateMode mode, int nManualPruneHeight=0);\n static void FindFilesToPruneManual(std::set<int>& setFilesToPrune, int nManualPruneHeight);\n static void FindFilesToPrune(std::set<int>& setFilesToPrune, uint64_t nPruneAfterHeight);\n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = nullptr);\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks = nullptr);\n static FILE* OpenUndoFile(const CDiskBlockPos &pos, bool fReadOnly = false);\n \n bool CheckFinalTx(const CTransaction &tx, int flags)\n@@ -549,7 +549,7 @@ static bool CheckInputsFromMempoolAndCache(const CTransaction& tx, CValidationSt\n         }\n     }\n \n-    return CheckInputs(tx, state, view, true, flags, cacheSigStore, true, txdata);\n+    return CheckInputs(tx, state, view, flags, cacheSigStore, true, txdata);\n }\n \n static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool& pool, CValidationState& state, const CTransactionRef& ptx,\n@@ -899,13 +899,13 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n         PrecomputedTransactionData txdata(tx);\n-        if (!CheckInputs(tx, state, view, true, scriptVerifyFlags, true, false, txdata)) {\n+        if (!CheckInputs(tx, state, view, scriptVerifyFlags, true, false, txdata)) {\n             // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n             // need to turn both off, and compare against just turning off CLEANSTACK\n             // to see if the failure is specifically due to witness validation.\n             CValidationState stateDummy; // Want reported failures to be from first CheckInputs\n-            if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n-                !CheckInputs(tx, stateDummy, view, true, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n+            if (!tx.HasWitness() && CheckInputs(tx, stateDummy, view, scriptVerifyFlags & ~(SCRIPT_VERIFY_WITNESS | SCRIPT_VERIFY_CLEANSTACK), true, false, txdata) &&\n+                !CheckInputs(tx, stateDummy, view, scriptVerifyFlags & ~SCRIPT_VERIFY_CLEANSTACK, true, false, txdata)) {\n                 // Only the witness is missing, so the transaction itself may be fine.\n                 state.SetCorruptionPossible();\n             }\n@@ -936,7 +936,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n                 return error(\"%s: BUG! PLEASE REPORT THIS! ConnectInputs failed against latest-block but not STANDARD flags %s, %s\",\n                     __func__, hash.ToString(), FormatStateMessage(state));\n             } else {\n-                if (!CheckInputs(tx, state, view, true, MANDATORY_SCRIPT_VERIFY_FLAGS, true, false, txdata)) {\n+                if (!CheckInputs(tx, state, view, MANDATORY_SCRIPT_VERIFY_FLAGS, true, false, txdata)) {\n                     return error(\"%s: ConnectInputs failed against MANDATORY but not STANDARD flags due to promiscuous mempool %s, %s\",\n                         __func__, hash.ToString(), FormatStateMessage(state));\n                 } else {\n@@ -1343,83 +1343,72 @@ void InitScriptExecutionCache() {\n  *\n  * Non-static (and re-declared) in src/test/txvalidationcache_tests.cpp\n  */\n-bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, bool fScriptChecks, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n+bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsViewCache &inputs, unsigned int flags, bool cacheSigStore, bool cacheFullScriptStore, PrecomputedTransactionData& txdata, std::vector<CScriptCheck> *pvChecks)\n {\n     if (!tx.IsCoinBase())\n     {\n         if (pvChecks)\n             pvChecks->reserve(tx.vin.size());\n \n-        // The first loop above does all the inexpensive checks.\n-        // Only if ALL inputs pass do we perform expensive ECDSA signature checks.\n-        // Helps prevent CPU exhaustion attacks.\n-\n-        // Skip script verification when connecting blocks under the\n-        // assumevalid block. Assuming the assumevalid block is valid this\n-        // is safe because block merkle hashes are still computed and checked,\n-        // Of course, if an assumed valid block is invalid due to false scriptSigs\n-        // this optimization would allow an invalid chain to be accepted.\n-        if (fScriptChecks) {\n-            // First check if script executions have been cached with the same\n-            // flags. Note that this assumes that the inputs provided are\n-            // correct (ie that the transaction hash which is in tx's prevouts\n-            // properly commits to the scriptPubKey in the inputs view of that\n-            // transaction).\n-            uint256 hashCacheEntry;\n-            // We only use the first 19 bytes of nonce to avoid a second SHA\n-            // round - giving us 19 + 32 + 4 = 55 bytes (+ 8 + 1 = 64)\n-            static_assert(55 - sizeof(flags) - 32 >= 128/8, \"Want at least 128 bits of nonce for script execution cache\");\n-            CSHA256().Write(scriptExecutionCacheNonce.begin(), 55 - sizeof(flags) - 32).Write(tx.GetWitnessHash().begin(), 32).Write((unsigned char*)&flags, sizeof(flags)).Finalize(hashCacheEntry.begin());\n-            AssertLockHeld(cs_main); //TODO: Remove this requirement by making CuckooCache not require external locks\n-            if (scriptExecutionCache.contains(hashCacheEntry, !cacheFullScriptStore)) {\n-                return true;\n-            }\n+        // First check if script executions have been cached with the same\n+        // flags. Note that this assumes that the inputs provided are\n+        // correct (ie that the transaction hash which is in tx's prevouts\n+        // properly commits to the scriptPubKey in the inputs view of that\n+        // transaction).\n+        uint256 hashCacheEntry;\n+        // We only use the first 19 bytes of nonce to avoid a second SHA\n+        // round - giving us 19 + 32 + 4 = 55 bytes (+ 8 + 1 = 64)\n+        static_assert(55 - sizeof(flags) - 32 >= 128/8, \"Want at least 128 bits of nonce for script execution cache\");\n+        CSHA256().Write(scriptExecutionCacheNonce.begin(), 55 - sizeof(flags) - 32).Write(tx.GetWitnessHash().begin(), 32).Write((unsigned char*)&flags, sizeof(flags)).Finalize(hashCacheEntry.begin());\n+        AssertLockHeld(cs_main); //TODO: Remove this requirement by making CuckooCache not require external locks\n+        if (scriptExecutionCache.contains(hashCacheEntry, !cacheFullScriptStore)) {\n+            return true;\n+        }\n \n-            for (unsigned int i = 0; i < tx.vin.size(); i++) {\n-                const COutPoint &prevout = tx.vin[i].prevout;\n-                const Coin& coin = inputs.AccessCoin(prevout);\n-                assert(!coin.IsSpent());\n-\n-                // We very carefully only pass in things to CScriptCheck which\n-                // are clearly committed to by tx' witness hash. This provides\n-                // a sanity check that our caching is not introducing consensus\n-                // failures through additional data in, eg, the coins being\n-                // spent being checked as a part of CScriptCheck.\n-\n-                // Verify signature\n-                CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &txdata);\n-                if (pvChecks) {\n-                    pvChecks->push_back(CScriptCheck());\n-                    check.swap(pvChecks->back());\n-                } else if (!check()) {\n-                    if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n-                        // Check whether the failure was caused by a\n-                        // non-mandatory script verification check, such as\n-                        // non-standard DER encodings or non-null dummy\n-                        // arguments; if so, don't trigger DoS protection to\n-                        // avoid splitting the network between upgraded and\n-                        // non-upgraded nodes.\n-                        CScriptCheck check2(coin.out, tx, i,\n-                                flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n-                        if (check2())\n-                            return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n-                    }\n-                    // Failures of other flags indicate a transaction that is\n-                    // invalid in new blocks, e.g. an invalid P2SH. We DoS ban\n-                    // such nodes as they are not following the protocol. That\n-                    // said during an upgrade careful thought should be taken\n-                    // as to the correct behavior - we may want to continue\n-                    // peering with non-upgraded nodes even after soft-fork\n-                    // super-majority signaling has occurred.\n-                    return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n+        for (unsigned int i = 0; i < tx.vin.size(); i++) {\n+            const COutPoint &prevout = tx.vin[i].prevout;\n+            const Coin& coin = inputs.AccessCoin(prevout);\n+            assert(!coin.IsSpent());\n+\n+            // We very carefully only pass in things to CScriptCheck which\n+            // are clearly committed to by tx' witness hash. This provides\n+            // a sanity check that our caching is not introducing consensus\n+            // failures through additional data in, eg, the coins being\n+            // spent being checked as a part of CScriptCheck.\n+\n+            // Verify signature\n+            CScriptCheck check(coin.out, tx, i, flags, cacheSigStore, &txdata);\n+            if (pvChecks) {\n+                pvChecks->push_back(CScriptCheck());\n+                check.swap(pvChecks->back());\n+            } else if (!check()) {\n+                if (flags & STANDARD_NOT_MANDATORY_VERIFY_FLAGS) {\n+                    // Check whether the failure was caused by a\n+                    // non-mandatory script verification check, such as\n+                    // non-standard DER encodings or non-null dummy\n+                    // arguments; if so, don't trigger DoS protection to\n+                    // avoid splitting the network between upgraded and\n+                    // non-upgraded nodes.\n+                    CScriptCheck check2(coin.out, tx, i,\n+                            flags & ~STANDARD_NOT_MANDATORY_VERIFY_FLAGS, cacheSigStore, &txdata);\n+                    if (check2())\n+                        return state.Invalid(false, REJECT_NONSTANDARD, strprintf(\"non-mandatory-script-verify-flag (%s)\", ScriptErrorString(check.GetScriptError())));\n                 }\n+                // Failures of other flags indicate a transaction that is\n+                // invalid in new blocks, e.g. an invalid P2SH. We DoS ban\n+                // such nodes as they are not following the protocol. That\n+                // said during an upgrade careful thought should be taken\n+                // as to the correct behavior - we may want to continue\n+                // peering with non-upgraded nodes even after soft-fork\n+                // super-majority signaling has occurred.\n+                return state.DoS(100,false, REJECT_INVALID, strprintf(\"mandatory-script-verify-flag-failed (%s)\", ScriptErrorString(check.GetScriptError())));\n             }\n+        }\n \n-            if (cacheFullScriptStore && !pvChecks) {\n-                // We executed all of the provided scripts, and were told to\n-                // cache the result. Do so now.\n-                scriptExecutionCache.insert(hashCacheEntry);\n-            }\n+        if (cacheFullScriptStore && !pvChecks) {\n+            // We executed all of the provided scripts, and were told to\n+            // cache the result. Do so now.\n+            scriptExecutionCache.insert(hashCacheEntry);\n         }\n     }\n \n@@ -2001,7 +1990,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n         {\n             std::vector<CScriptCheck> vChecks;\n             bool fCacheResults = fJustCheck; /* Don't cache results if we're actually connecting blocks (still consult the cache, though) */\n-            if (!CheckInputs(tx, state, view, fScriptChecks, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : nullptr))\n+            if (fScriptChecks && !CheckInputs(tx, state, view, flags, fCacheResults, fCacheResults, txdata[i], nScriptCheckThreads ? &vChecks : nullptr))\n                 return error(\"ConnectBlock(): CheckInputs on %s failed with %s\",\n                     tx.GetHash().ToString(), FormatStateMessage(state));\n             control.Add(vChecks);"
      }
    ]
  },
  {
    "sha": "feda9b37ded38e49f37ce37377836d7b493c60e8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmZWRhOWIzN2RlZDM4ZTQ5ZjM3Y2UzNzM3NzgzNmQ3YjQ5M2M2MGU4",
    "commit": {
      "author": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-05-14T17:44:55Z"
      },
      "committer": {
        "name": "Matt Corallo",
        "email": "git@bluematt.me",
        "date": "2018-05-14T17:44:55Z"
      },
      "message": "Skip PrecomputedTransactionData hashing for cache hits.",
      "tree": {
        "sha": "42c33aa818d1b4d5264fb8e13ab04310c5678e33",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/42c33aa818d1b4d5264fb8e13ab04310c5678e33"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/feda9b37ded38e49f37ce37377836d7b493c60e8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/feda9b37ded38e49f37ce37377836d7b493c60e8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/feda9b37ded38e49f37ce37377836d7b493c60e8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/feda9b37ded38e49f37ce37377836d7b493c60e8/comments",
    "author": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "TheBlueMatt",
      "id": 649246,
      "node_id": "MDQ6VXNlcjY0OTI0Ng==",
      "avatar_url": "https://avatars.githubusercontent.com/u/649246?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/TheBlueMatt",
      "html_url": "https://github.com/TheBlueMatt",
      "followers_url": "https://api.github.com/users/TheBlueMatt/followers",
      "following_url": "https://api.github.com/users/TheBlueMatt/following{/other_user}",
      "gists_url": "https://api.github.com/users/TheBlueMatt/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/TheBlueMatt/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/TheBlueMatt/subscriptions",
      "organizations_url": "https://api.github.com/users/TheBlueMatt/orgs",
      "repos_url": "https://api.github.com/users/TheBlueMatt/repos",
      "events_url": "https://api.github.com/users/TheBlueMatt/events{/privacy}",
      "received_events_url": "https://api.github.com/users/TheBlueMatt/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "26a965c33e45f77ce376a51c817f2d1bb414e078",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/26a965c33e45f77ce376a51c817f2d1bb414e078",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/26a965c33e45f77ce376a51c817f2d1bb414e078"
      }
    ],
    "stats": {
      "total": 17,
      "additions": 10,
      "deletions": 7
    },
    "files": [
      {
        "sha": "e4902c8c9bc86fe1fd188c491d60738468b0a86f",
        "filename": "src/script/interpreter.cpp",
        "status": "modified",
        "additions": 2,
        "deletions": 2,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/feda9b37ded38e49f37ce37377836d7b493c60e8/src/script/interpreter.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/feda9b37ded38e49f37ce37377836d7b493c60e8/src/script/interpreter.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.cpp?ref=feda9b37ded38e49f37ce37377836d7b493c60e8",
        "patch": "@@ -1195,10 +1195,10 @@ uint256 GetOutputsHash(const CTransaction& txTo) {\n \n } // namespace\n \n-PrecomputedTransactionData::PrecomputedTransactionData(const CTransaction& txTo)\n+void PrecomputedTransactionData::ComputeHashes(const CTransaction& txTo)\n {\n     // Cache is calculated only for transactions with witness\n-    if (txTo.HasWitness()) {\n+    if (!ready && txTo.HasWitness()) {\n         hashPrevouts = GetPrevoutHash(txTo);\n         hashSequence = GetSequenceHash(txTo);\n         hashOutputs = GetOutputsHash(txTo);"
      },
      {
        "sha": "a35b5f1f2d68a44be342d58df45ea1131d37a93c",
        "filename": "src/script/interpreter.h",
        "status": "modified",
        "additions": 4,
        "deletions": 1,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/feda9b37ded38e49f37ce37377836d7b493c60e8/src/script/interpreter.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/feda9b37ded38e49f37ce37377836d7b493c60e8/src/script/interpreter.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/script/interpreter.h?ref=feda9b37ded38e49f37ce37377836d7b493c60e8",
        "patch": "@@ -120,7 +120,10 @@ struct PrecomputedTransactionData\n     uint256 hashPrevouts, hashSequence, hashOutputs;\n     bool ready = false;\n \n-    explicit PrecomputedTransactionData(const CTransaction& tx);\n+    explicit PrecomputedTransactionData(const CTransaction& tx) { ComputeHashes(tx); }\n+    PrecomputedTransactionData() {}\n+\n+    void ComputeHashes(const CTransaction& tx);\n };\n \n enum class SigVersion"
      },
      {
        "sha": "c0f8a9f8685387b163ffdb5fc222b74962cccc1a",
        "filename": "src/validation.cpp",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/feda9b37ded38e49f37ce37377836d7b493c60e8/src/validation.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/feda9b37ded38e49f37ce37377836d7b493c60e8/src/validation.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/validation.cpp?ref=feda9b37ded38e49f37ce37377836d7b493c60e8",
        "patch": "@@ -898,7 +898,7 @@ static bool AcceptToMemoryPoolWorker(const CChainParams& chainparams, CTxMemPool\n \n         // Check against previous transactions\n         // This is done last to help prevent CPU exhaustion denial-of-service attacks.\n-        PrecomputedTransactionData txdata(tx);\n+        PrecomputedTransactionData txdata;\n         if (!CheckInputs(tx, state, view, scriptVerifyFlags, true, false, txdata)) {\n             // SCRIPT_VERIFY_CLEANSTACK requires SCRIPT_VERIFY_WITNESS, so we\n             // need to turn both off, and compare against just turning off CLEANSTACK\n@@ -1365,6 +1365,8 @@ bool CheckInputs(const CTransaction& tx, CValidationState &state, const CCoinsVi\n             return true;\n         }\n \n+        txdata.ComputeHashes(tx);\n+\n         for (unsigned int i = 0; i < tx.vin.size(); i++) {\n             const COutPoint &prevout = tx.vin[i].prevout;\n             const Coin& coin = inputs.AccessCoin(prevout);\n@@ -1942,8 +1944,7 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n     int nInputs = 0;\n     int64_t nSigOpsCost = 0;\n     blockundo.vtxundo.reserve(block.vtx.size() - 1);\n-    std::vector<PrecomputedTransactionData> txdata;\n-    txdata.reserve(block.vtx.size()); // Required so that pointers to individual PrecomputedTransactionData don't get invalidated\n+    std::vector<PrecomputedTransactionData> txdata(block.vtx.size());\n     for (unsigned int i = 0; i < block.vtx.size(); i++)\n     {\n         const CTransaction &tx = *(block.vtx[i]);\n@@ -1985,7 +1986,6 @@ bool CChainState::ConnectBlock(const CBlock& block, CValidationState& state, CBl\n             return state.DoS(100, error(\"ConnectBlock(): too many sigops\"),\n                              REJECT_INVALID, \"bad-blk-sigops\");\n \n-        txdata.emplace_back(tx);\n         if (!tx.IsCoinBase())\n         {\n             std::vector<CScriptCheck> vChecks;"
      }
    ]
  }
]