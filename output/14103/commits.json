[
  {
    "sha": "0e534d4dcae91ecf7ebd7a667227f7c26b4d5755",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZTUzNGQ0ZGNhZTkxZWNmN2ViZDdhNjY3MjI3ZjdjMjZiNGQ1NzU1",
    "commit": {
      "author": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2018-08-08T19:12:14Z"
      },
      "committer": {
        "name": "practicalswift",
        "email": "practicalswift@users.noreply.github.com",
        "date": "2018-08-08T20:14:45Z"
      },
      "message": "Fix incorrect Doxygen comments",
      "tree": {
        "sha": "7d21739df2eb4d694e53cd36498d227129a4b6bc",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/7d21739df2eb4d694e53cd36498d227129a4b6bc"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0e534d4dcae91ecf7ebd7a667227f7c26b4d5755",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e534d4dcae91ecf7ebd7a667227f7c26b4d5755",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0e534d4dcae91ecf7ebd7a667227f7c26b4d5755",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0e534d4dcae91ecf7ebd7a667227f7c26b4d5755/comments",
    "author": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "practicalswift",
      "id": 7826565,
      "node_id": "MDQ6VXNlcjc4MjY1NjU=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7826565?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/practicalswift",
      "html_url": "https://github.com/practicalswift",
      "followers_url": "https://api.github.com/users/practicalswift/followers",
      "following_url": "https://api.github.com/users/practicalswift/following{/other_user}",
      "gists_url": "https://api.github.com/users/practicalswift/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/practicalswift/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/practicalswift/subscriptions",
      "organizations_url": "https://api.github.com/users/practicalswift/orgs",
      "repos_url": "https://api.github.com/users/practicalswift/repos",
      "events_url": "https://api.github.com/users/practicalswift/events{/privacy}",
      "received_events_url": "https://api.github.com/users/practicalswift/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9d86aad287f07e20066138b9f909758ad7a2e098",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9d86aad287f07e20066138b9f909758ad7a2e098",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9d86aad287f07e20066138b9f909758ad7a2e098"
      }
    ],
    "stats": {
      "total": 96,
      "additions": 47,
      "deletions": 49
    },
    "files": [
      {
        "sha": "717eabd74becae5eec928b08c128e04b9fb62002",
        "filename": "src/policy/fees.h",
        "status": "modified",
        "additions": 44,
        "deletions": 46,
        "changes": 90,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e534d4dcae91ecf7ebd7a667227f7c26b4d5755/src/policy/fees.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e534d4dcae91ecf7ebd7a667227f7c26b4d5755/src/policy/fees.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/policy/fees.h?ref=0e534d4dcae91ecf7ebd7a667227f7c26b4d5755",
        "patch": "@@ -22,51 +22,6 @@ class CTxMemPoolEntry;\n class CTxMemPool;\n class TxConfirmStats;\n \n-/** \\class CBlockPolicyEstimator\n- * The BlockPolicyEstimator is used for estimating the feerate needed\n- * for a transaction to be included in a block within a certain number of\n- * blocks.\n- *\n- * At a high level the algorithm works by grouping transactions into buckets\n- * based on having similar feerates and then tracking how long it\n- * takes transactions in the various buckets to be mined.  It operates under\n- * the assumption that in general transactions of higher feerate will be\n- * included in blocks before transactions of lower feerate.   So for\n- * example if you wanted to know what feerate you should put on a transaction to\n- * be included in a block within the next 5 blocks, you would start by looking\n- * at the bucket with the highest feerate transactions and verifying that a\n- * sufficiently high percentage of them were confirmed within 5 blocks and\n- * then you would look at the next highest feerate bucket, and so on, stopping at\n- * the last bucket to pass the test.   The average feerate of transactions in this\n- * bucket will give you an indication of the lowest feerate you can put on a\n- * transaction and still have a sufficiently high chance of being confirmed\n- * within your desired 5 blocks.\n- *\n- * Here is a brief description of the implementation:\n- * When a transaction enters the mempool, we track the height of the block chain\n- * at entry.  All further calculations are conducted only on this set of \"seen\"\n- * transactions. Whenever a block comes in, we count the number of transactions\n- * in each bucket and the total amount of feerate paid in each bucket. Then we\n- * calculate how many blocks Y it took each transaction to be mined.  We convert\n- * from a number of blocks to a number of periods Y' each encompassing \"scale\"\n- * blocks.  This is tracked in 3 different data sets each up to a maximum\n- * number of periods. Within each data set we have an array of counters in each\n- * feerate bucket and we increment all the counters from Y' up to max periods\n- * representing that a tx was successfully confirmed in less than or equal to\n- * that many periods. We want to save a history of this information, so at any\n- * time we have a counter of the total number of transactions that happened in a\n- * given feerate bucket and the total number that were confirmed in each of the\n- * periods or less for any bucket.  We save this history by keeping an\n- * exponentially decaying moving average of each one of these stats.  This is\n- * done for a different decay in each of the 3 data sets to keep relevant data\n- * from different time horizons.  Furthermore we also keep track of the number\n- * unmined (in mempool or left mempool without being included in a block)\n- * transactions in each bucket and for how many blocks they have been\n- * outstanding and use both of these numbers to increase the number of transactions\n- * we've seen in that feerate bucket when calculating an estimate for any number\n- * of confirmations below the number of blocks they've been outstanding.\n- */\n-\n /* Identifier for each of the 3 different TxConfirmStats which will track\n  * history over different time horizons. */\n enum class FeeEstimateHorizon {\n@@ -130,7 +85,50 @@ struct FeeCalculation\n     int returnedTarget = 0;\n };\n \n-/**\n+/** \\class CBlockPolicyEstimator\n+ * The BlockPolicyEstimator is used for estimating the feerate needed\n+ * for a transaction to be included in a block within a certain number of\n+ * blocks.\n+ *\n+ * At a high level the algorithm works by grouping transactions into buckets\n+ * based on having similar feerates and then tracking how long it\n+ * takes transactions in the various buckets to be mined.  It operates under\n+ * the assumption that in general transactions of higher feerate will be\n+ * included in blocks before transactions of lower feerate.   So for\n+ * example if you wanted to know what feerate you should put on a transaction to\n+ * be included in a block within the next 5 blocks, you would start by looking\n+ * at the bucket with the highest feerate transactions and verifying that a\n+ * sufficiently high percentage of them were confirmed within 5 blocks and\n+ * then you would look at the next highest feerate bucket, and so on, stopping at\n+ * the last bucket to pass the test.   The average feerate of transactions in this\n+ * bucket will give you an indication of the lowest feerate you can put on a\n+ * transaction and still have a sufficiently high chance of being confirmed\n+ * within your desired 5 blocks.\n+ *\n+ * Here is a brief description of the implementation:\n+ * When a transaction enters the mempool, we track the height of the block chain\n+ * at entry.  All further calculations are conducted only on this set of \"seen\"\n+ * transactions. Whenever a block comes in, we count the number of transactions\n+ * in each bucket and the total amount of feerate paid in each bucket. Then we\n+ * calculate how many blocks Y it took each transaction to be mined.  We convert\n+ * from a number of blocks to a number of periods Y' each encompassing \"scale\"\n+ * blocks.  This is tracked in 3 different data sets each up to a maximum\n+ * number of periods. Within each data set we have an array of counters in each\n+ * feerate bucket and we increment all the counters from Y' up to max periods\n+ * representing that a tx was successfully confirmed in less than or equal to\n+ * that many periods. We want to save a history of this information, so at any\n+ * time we have a counter of the total number of transactions that happened in a\n+ * given feerate bucket and the total number that were confirmed in each of the\n+ * periods or less for any bucket.  We save this history by keeping an\n+ * exponentially decaying moving average of each one of these stats.  This is\n+ * done for a different decay in each of the 3 data sets to keep relevant data\n+ * from different time horizons.  Furthermore we also keep track of the number\n+ * unmined (in mempool or left mempool without being included in a block)\n+ * transactions in each bucket and for how many blocks they have been\n+ * outstanding and use both of these numbers to increase the number of transactions\n+ * we've seen in that feerate bucket when calculating an estimate for any number\n+ * of confirmations below the number of blocks they've been outstanding.\n+ *\n  *  We want to be able to estimate feerates that are needed on tx's to be included in\n  * a certain number of blocks.  Every time a block is added to the best chain, this class records\n  * stats on the transactions included in that block"
      },
      {
        "sha": "34f80210c43486cb1e2a0e9c1b238ca6d7bd45a1",
        "filename": "src/qt/bitcoingui.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e534d4dcae91ecf7ebd7a667227f7c26b4d5755/src/qt/bitcoingui.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e534d4dcae91ecf7ebd7a667227f7c26b4d5755/src/qt/bitcoingui.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/bitcoingui.h?ref=0e534d4dcae91ecf7ebd7a667227f7c26b4d5755",
        "patch": "@@ -202,7 +202,7 @@ public Q_SLOTS:\n     void setEncryptionStatus(int status);\n \n     /** Set the hd-enabled status as shown in the UI.\n-     @param[in] status            current hd enabled status\n+     @param[in] hdEnabled         current hd enabled status\n      @see WalletModel::EncryptionStatus\n      */\n     void setHDStatus(int hdEnabled);"
      },
      {
        "sha": "e3fd24b9c7f3dd12df53b9dfecfe52563cbe46b2",
        "filename": "src/qt/rpcconsole.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e534d4dcae91ecf7ebd7a667227f7c26b4d5755/src/qt/rpcconsole.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e534d4dcae91ecf7ebd7a667227f7c26b4d5755/src/qt/rpcconsole.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/qt/rpcconsole.cpp?ref=0e534d4dcae91ecf7ebd7a667227f7c26b4d5755",
        "patch": "@@ -144,7 +144,7 @@ class QtRPCTimerInterface: public RPCTimerInterface\n  *   - Within single quotes, no escaping is possible and no special interpretation takes place\n  *\n  * @param[in]    node    optional node to execute command on\n- * @param[out]   result      stringified Result from the executed command(chain)\n+ * @param[out]   strResult   stringified result from the executed command(chain)\n  * @param[in]    strCommand  Command line to split\n  * @param[in]    fExecute    set true if you want the command to be executed\n  * @param[out]   pstrFilteredOut  Command line, filtered to remove any sensitive data"
      },
      {
        "sha": "ac87cbd2fd02eae19fd87d4f2d077953c9600b46",
        "filename": "src/wallet/wallet.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0e534d4dcae91ecf7ebd7a667227f7c26b4d5755/src/wallet/wallet.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0e534d4dcae91ecf7ebd7a667227f7c26b4d5755/src/wallet/wallet.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.h?ref=0e534d4dcae91ecf7ebd7a667227f7c26b4d5755",
        "patch": "@@ -989,7 +989,7 @@ class CWallet final : public CCryptoKeyStore, public CValidationInterface\n     unsigned int m_confirm_target{DEFAULT_TX_CONFIRM_TARGET};\n     bool m_spend_zero_conf_change{DEFAULT_SPEND_ZEROCONF_CHANGE};\n     bool m_signal_rbf{DEFAULT_WALLET_RBF};\n-    bool m_allow_fallback_fee{true}; //<! will be defined via chainparams\n+    bool m_allow_fallback_fee{true}; //!< will be defined via chainparams\n     CFeeRate m_min_fee{DEFAULT_TRANSACTION_MINFEE}; //!< Override with -mintxfee\n     /**\n      * If fee estimation does not have enough data to provide estimates, use this fee instead."
      }
    ]
  }
]