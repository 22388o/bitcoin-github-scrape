[
  {
    "sha": "42cb388167ef78f47a3a440eb651b6938c10f508",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MmNiMzg4MTY3ZWY3OGY0N2EzYTQ0MGViNjUxYjY5MzhjMTBmNTA4",
    "commit": {
      "author": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2015-09-07T22:22:23Z"
      },
      "committer": {
        "name": "James O'Beirne",
        "email": "james.obeirne@gmail.com",
        "date": "2015-10-06T14:46:10Z"
      },
      "message": "Add chainstate obfuscation to avoid spurious antivirus detection\n\nAdds an `obfuscate` parameter to `CLevelDBWrapper` and makes use of it\nfor all new chainstate stores built via `CCoinsViewDB`. Also adds an\n`Xor` method to `CDataStream`.\n\nThanks to @sipa @laanwj @pstratem @dexX7 @KyrosKrane @gmaxwell.",
      "tree": {
        "sha": "5030db533bf8e2c8231b9df00865528a6f6b5706",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/5030db533bf8e2c8231b9df00865528a6f6b5706"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/42cb388167ef78f47a3a440eb651b6938c10f508",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/42cb388167ef78f47a3a440eb651b6938c10f508",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/42cb388167ef78f47a3a440eb651b6938c10f508",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/42cb388167ef78f47a3a440eb651b6938c10f508/comments",
    "author": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jamesob",
      "id": 73197,
      "node_id": "MDQ6VXNlcjczMTk3",
      "avatar_url": "https://avatars.githubusercontent.com/u/73197?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jamesob",
      "html_url": "https://github.com/jamesob",
      "followers_url": "https://api.github.com/users/jamesob/followers",
      "following_url": "https://api.github.com/users/jamesob/following{/other_user}",
      "gists_url": "https://api.github.com/users/jamesob/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jamesob/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jamesob/subscriptions",
      "organizations_url": "https://api.github.com/users/jamesob/orgs",
      "repos_url": "https://api.github.com/users/jamesob/repos",
      "events_url": "https://api.github.com/users/jamesob/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jamesob/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "3932ff50c563df19c14e9987f2297d9f99a299ac",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/3932ff50c563df19c14e9987f2297d9f99a299ac",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/3932ff50c563df19c14e9987f2297d9f99a299ac"
      }
    ],
    "stats": {
      "total": 360,
      "additions": 338,
      "deletions": 22
    },
    "files": [
      {
        "sha": "7107235a8ae095e11b8d8ca71a3708c7bd18a6dc",
        "filename": "src/Makefile.test.include",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/42cb388167ef78f47a3a440eb651b6938c10f508/src/Makefile.test.include",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/42cb388167ef78f47a3a440eb651b6938c10f508/src/Makefile.test.include",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.test.include?ref=42cb388167ef78f47a3a440eb651b6938c10f508",
        "patch": "@@ -53,6 +53,7 @@ BITCOIN_TESTS =\\\n   test/hash_tests.cpp \\\n   test/key_tests.cpp \\\n   test/limitedmap_tests.cpp \\\n+  test/leveldbwrapper_tests.cpp \\\n   test/main_tests.cpp \\\n   test/mempool_tests.cpp \\\n   test/miner_tests.cpp \\\n@@ -72,6 +73,7 @@ BITCOIN_TESTS =\\\n   test/sighash_tests.cpp \\\n   test/sigopcount_tests.cpp \\\n   test/skiplist_tests.cpp \\\n+  test/streams_tests.cpp \\\n   test/test_bitcoin.cpp \\\n   test/test_bitcoin.h \\\n   test/timedata_tests.cpp \\"
      },
      {
        "sha": "ce96b5c8aa632d8300841c9967e7590bf30f7882",
        "filename": "src/leveldbwrapper.cpp",
        "status": "modified",
        "additions": 59,
        "deletions": 1,
        "changes": 60,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/42cb388167ef78f47a3a440eb651b6938c10f508/src/leveldbwrapper.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/42cb388167ef78f47a3a440eb651b6938c10f508/src/leveldbwrapper.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldbwrapper.cpp?ref=42cb388167ef78f47a3a440eb651b6938c10f508",
        "patch": "@@ -5,13 +5,15 @@\n #include \"leveldbwrapper.h\"\n \n #include \"util.h\"\n+#include \"random.h\"\n \n #include <boost/filesystem.hpp>\n \n #include <leveldb/cache.h>\n #include <leveldb/env.h>\n #include <leveldb/filter_policy.h>\n #include <memenv.h>\n+#include <stdint.h>\n \n void HandleError(const leveldb::Status& status) throw(leveldb_error)\n {\n@@ -43,7 +45,7 @@ static leveldb::Options GetOptions(size_t nCacheSize)\n     return options;\n }\n \n-CLevelDBWrapper::CLevelDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory, bool fWipe)\n+CLevelDBWrapper::CLevelDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory, bool fWipe, bool obfuscate)\n {\n     penv = NULL;\n     readoptions.verify_checksums = true;\n@@ -67,6 +69,25 @@ CLevelDBWrapper::CLevelDBWrapper(const boost::filesystem::path& path, size_t nCa\n     leveldb::Status status = leveldb::DB::Open(options, path.string(), &pdb);\n     HandleError(status);\n     LogPrintf(\"Opened LevelDB successfully\\n\");\n+\n+    // The base-case obfuscation key, which is a noop.\n+    obfuscate_key = std::vector<unsigned char>(OBFUSCATE_KEY_NUM_BYTES, '\\000');\n+\n+    bool key_exists = Read(OBFUSCATE_KEY_KEY, obfuscate_key);\n+\n+    if (!key_exists && obfuscate && IsEmpty()) {\n+        // Initialize non-degenerate obfuscation if it won't upset \n+        // existing, non-obfuscated data.\n+        std::vector<unsigned char> new_key = CreateObfuscateKey();\n+\n+        // Write `new_key` so we don't obfuscate the key with itself\n+        Write(OBFUSCATE_KEY_KEY, new_key);\n+        obfuscate_key = new_key;\n+\n+        LogPrintf(\"Wrote new obfuscate key for %s: %s\\n\", path.string(), GetObfuscateKeyHex());\n+    }\n+\n+    LogPrintf(\"Using obfuscation key for %s: %s\\n\", path.string(), GetObfuscateKeyHex());\n }\n \n CLevelDBWrapper::~CLevelDBWrapper()\n@@ -87,3 +108,40 @@ bool CLevelDBWrapper::WriteBatch(CLevelDBBatch& batch, bool fSync) throw(leveldb\n     HandleError(status);\n     return true;\n }\n+\n+// Prefixed with null character to avoid collisions with other keys\n+//\n+// We must use a string constructor which specifies length so that we copy\n+// past the null-terminator.\n+const std::string CLevelDBWrapper::OBFUSCATE_KEY_KEY(\"\\000obfuscate_key\", 14);\n+\n+const unsigned int CLevelDBWrapper::OBFUSCATE_KEY_NUM_BYTES = 8;\n+\n+/**\n+ * Returns a string (consisting of 8 random bytes) suitable for use as an \n+ * obfuscating XOR key. \n+ */\n+std::vector<unsigned char> CLevelDBWrapper::CreateObfuscateKey() const \n+{\n+    unsigned char buff[OBFUSCATE_KEY_NUM_BYTES];\n+    GetRandBytes(buff, OBFUSCATE_KEY_NUM_BYTES);\n+    return std::vector<unsigned char>(&buff[0], &buff[OBFUSCATE_KEY_NUM_BYTES]);\n+\n+}\n+\n+bool CLevelDBWrapper::IsEmpty()\n+{\n+    boost::scoped_ptr<leveldb::Iterator> it(NewIterator());\n+    it->SeekToFirst();\n+    return !(it->Valid());\n+}\n+\n+const std::vector<unsigned char>& CLevelDBWrapper::GetObfuscateKey() const \n+{ \n+    return obfuscate_key; \n+}\n+\n+std::string CLevelDBWrapper::GetObfuscateKeyHex() const\n+{ \n+    return HexStr(obfuscate_key); \n+}"
      },
      {
        "sha": "f5c463830cbddb5fb0898bfa839e81b1a5d774c2",
        "filename": "src/leveldbwrapper.h",
        "status": "modified",
        "additions": 49,
        "deletions": 4,
        "changes": 53,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/42cb388167ef78f47a3a440eb651b6938c10f508/src/leveldbwrapper.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/42cb388167ef78f47a3a440eb651b6938c10f508/src/leveldbwrapper.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/leveldbwrapper.h?ref=42cb388167ef78f47a3a440eb651b6938c10f508",
        "patch": "@@ -9,6 +9,7 @@\n #include \"serialize.h\"\n #include \"streams.h\"\n #include \"util.h\"\n+#include \"utilstrencodings.h\"\n #include \"version.h\"\n \n #include <boost/filesystem/path.hpp>\n@@ -31,8 +32,14 @@ class CLevelDBBatch\n \n private:\n     leveldb::WriteBatch batch;\n+    const std::vector<unsigned char> obfuscate_key;\n \n public:\n+    /**\n+     * @param[in] obfuscate_key    If passed, XOR data with this key.\n+     */\n+    CLevelDBBatch(const std::vector<unsigned char>& obfuscate_key) : obfuscate_key(obfuscate_key) { };\n+\n     template <typename K, typename V>\n     void Write(const K& key, const V& value)\n     {\n@@ -44,6 +51,7 @@ class CLevelDBBatch\n         CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n         ssValue.reserve(ssValue.GetSerializeSize(value));\n         ssValue << value;\n+        ssValue.Xor(obfuscate_key);\n         leveldb::Slice slValue(&ssValue[0], ssValue.size());\n \n         batch.Put(slKey, slValue);\n@@ -85,8 +93,27 @@ class CLevelDBWrapper\n     //! the database itself\n     leveldb::DB* pdb;\n \n+    //! a key used for optional XOR-obfuscation of the database\n+    std::vector<unsigned char> obfuscate_key;\n+\n+    //! the key under which the obfuscation key is stored\n+    static const std::string OBFUSCATE_KEY_KEY;\n+    \n+    //! the length of the obfuscate key in number of bytes\n+    static const unsigned int OBFUSCATE_KEY_NUM_BYTES;\n+    \n+    std::vector<unsigned char> CreateObfuscateKey() const;\n+\n public:\n-    CLevelDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory = false, bool fWipe = false);\n+    /**\n+     * @param[in] path        Location in the filesystem where leveldb data will be stored.\n+     * @param[in] nCacheSize  Configures various leveldb cache settings.\n+     * @param[in] fMemory     If true, use leveldb's memory environment.\n+     * @param[in] fWipe       If true, remove all existing data.\n+     * @param[in] obfuscate   If true, store data obfuscated via simple XOR. If false, XOR\n+     *                        with a zero'd byte array.\n+     */\n+    CLevelDBWrapper(const boost::filesystem::path& path, size_t nCacheSize, bool fMemory = false, bool fWipe = false, bool obfuscate = false);\n     ~CLevelDBWrapper();\n \n     template <typename K, typename V>\n@@ -107,6 +134,7 @@ class CLevelDBWrapper\n         }\n         try {\n             CDataStream ssValue(strValue.data(), strValue.data() + strValue.size(), SER_DISK, CLIENT_VERSION);\n+            ssValue.Xor(obfuscate_key);\n             ssValue >> value;\n         } catch (const std::exception&) {\n             return false;\n@@ -117,7 +145,7 @@ class CLevelDBWrapper\n     template <typename K, typename V>\n     bool Write(const K& key, const V& value, bool fSync = false) throw(leveldb_error)\n     {\n-        CLevelDBBatch batch;\n+        CLevelDBBatch batch(obfuscate_key);\n         batch.Write(key, value);\n         return WriteBatch(batch, fSync);\n     }\n@@ -144,7 +172,7 @@ class CLevelDBWrapper\n     template <typename K>\n     bool Erase(const K& key, bool fSync = false) throw(leveldb_error)\n     {\n-        CLevelDBBatch batch;\n+        CLevelDBBatch batch(obfuscate_key);\n         batch.Erase(key);\n         return WriteBatch(batch, fSync);\n     }\n@@ -159,7 +187,7 @@ class CLevelDBWrapper\n \n     bool Sync() throw(leveldb_error)\n     {\n-        CLevelDBBatch batch;\n+        CLevelDBBatch batch(obfuscate_key);\n         return WriteBatch(batch, true);\n     }\n \n@@ -168,6 +196,23 @@ class CLevelDBWrapper\n     {\n         return pdb->NewIterator(iteroptions);\n     }\n+\n+    /**\n+     * Return true if the database managed by this class contains no entries.\n+     */\n+    bool IsEmpty();\n+\n+    /**\n+     * Accessor for obfuscate_key.\n+     */\n+    const std::vector<unsigned char>& GetObfuscateKey() const;\n+\n+    /**\n+     * Return the obfuscate_key as a hex-formatted string.\n+     */\n+    std::string GetObfuscateKeyHex() const;\n+\n };\n \n #endif // BITCOIN_LEVELDBWRAPPER_H\n+"
      },
      {
        "sha": "8610e4d18e612b71a7ae1501153f356275dd8864",
        "filename": "src/streams.h",
        "status": "modified",
        "additions": 23,
        "deletions": 0,
        "changes": 23,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/42cb388167ef78f47a3a440eb651b6938c10f508/src/streams.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/42cb388167ef78f47a3a440eb651b6938c10f508/src/streams.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/streams.h?ref=42cb388167ef78f47a3a440eb651b6938c10f508",
        "patch": "@@ -296,6 +296,29 @@ class CDataStream\n         data.insert(data.end(), begin(), end());\n         clear();\n     }\n+\n+    /**\n+     * XOR the contents of this stream with a certain key.\n+     *\n+     * @param[in] key    The key used to XOR the data in this stream.\n+     */\n+    void Xor(const std::vector<unsigned char>& key)\n+    {\n+        if (key.size() == 0) {\n+            return;\n+        }\n+\n+        for (size_type i = 0, j = 0; i != size(); i++) {\n+            vch[i] ^= key[j++];\n+\n+            // This potentially acts on very many bytes of data, so it's\n+            // important that we calculate `j`, i.e. the `key` index in this\n+            // way instead of doing a %, which would effectively be a division\n+            // for each byte Xor'd -- much slower than need be.\n+            if (j == key.size())\n+                j = 0;\n+        }\n+    }\n };\n \n "
      },
      {
        "sha": "db04f3ea481216e01d9d593bfa3dcf02325973b2",
        "filename": "src/test/leveldbwrapper_tests.cpp",
        "status": "added",
        "additions": 128,
        "deletions": 0,
        "changes": 128,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/42cb388167ef78f47a3a440eb651b6938c10f508/src/test/leveldbwrapper_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/42cb388167ef78f47a3a440eb651b6938c10f508/src/test/leveldbwrapper_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/leveldbwrapper_tests.cpp?ref=42cb388167ef78f47a3a440eb651b6938c10f508",
        "patch": "@@ -0,0 +1,128 @@\n+// Copyright (c) 2012-2013 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"leveldbwrapper.h\"\n+#include \"uint256.h\"\n+#include \"random.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/assign/std/vector.hpp> // for 'operator+=()'\n+#include <boost/assert.hpp>\n+#include <boost/test/unit_test.hpp>\n+                    \n+using namespace std;\n+using namespace boost::assign; // bring 'operator+=()' into scope\n+using namespace boost::filesystem;\n+         \n+// Test if a string consists entirely of null characters\n+bool is_null_key(const vector<unsigned char>& key) {\n+    bool isnull = true;\n+\n+    for (unsigned int i = 0; i < key.size(); i++)\n+        isnull &= (key[i] == '\\x00');\n+\n+    return isnull;\n+}\n+ \n+BOOST_FIXTURE_TEST_SUITE(leveldbwrapper_tests, BasicTestingSetup)\n+                       \n+BOOST_AUTO_TEST_CASE(leveldbwrapper)\n+{\n+    // Perform tests both obfuscated and non-obfuscated.\n+    for (int i = 0; i < 2; i++) {\n+        bool obfuscate = (bool)i;\n+        path ph = temp_directory_path() / unique_path();\n+        CLevelDBWrapper dbw(ph, (1 << 20), true, false, obfuscate);\n+        char key = 'k';\n+        uint256 in = GetRandHash();\n+        uint256 res;\n+\n+        // Ensure that we're doing real obfuscation when obfuscate=true\n+        BOOST_CHECK(obfuscate != is_null_key(dbw.GetObfuscateKey()));\n+\n+        BOOST_CHECK(dbw.Write(key, in));\n+        BOOST_CHECK(dbw.Read(key, res));\n+        BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n+    }\n+}\n+                       \n+// Test that we do not obfuscation if there is existing data.\n+BOOST_AUTO_TEST_CASE(existing_data_no_obfuscate)\n+{\n+    // We're going to share this path between two wrappers\n+    path ph = temp_directory_path() / unique_path();\n+    create_directories(ph);\n+\n+    // Set up a non-obfuscated wrapper to write some initial data.\n+    CLevelDBWrapper* dbw = new CLevelDBWrapper(ph, (1 << 10), false, false, false);\n+    char key = 'k';\n+    uint256 in = GetRandHash();\n+    uint256 res;\n+\n+    BOOST_CHECK(dbw->Write(key, in));\n+    BOOST_CHECK(dbw->Read(key, res));\n+    BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n+\n+    // Call the destructor to free leveldb LOCK\n+    delete dbw;\n+\n+    // Now, set up another wrapper that wants to obfuscate the same directory\n+    CLevelDBWrapper odbw(ph, (1 << 10), false, false, true);\n+\n+    // Check that the key/val we wrote with unobfuscated wrapper exists and \n+    // is readable.\n+    uint256 res2;\n+    BOOST_CHECK(odbw.Read(key, res2));\n+    BOOST_CHECK_EQUAL(res2.ToString(), in.ToString());\n+\n+    BOOST_CHECK(!odbw.IsEmpty()); // There should be existing data\n+    BOOST_CHECK(is_null_key(odbw.GetObfuscateKey())); // The key should be an empty string\n+\n+    uint256 in2 = GetRandHash();\n+    uint256 res3;\n+ \n+    // Check that we can write successfully\n+    BOOST_CHECK(odbw.Write(key, in2));\n+    BOOST_CHECK(odbw.Read(key, res3));\n+    BOOST_CHECK_EQUAL(res3.ToString(), in2.ToString());\n+}\n+                        \n+// Ensure that we start obfuscating during a reindex.\n+BOOST_AUTO_TEST_CASE(existing_data_reindex)\n+{\n+    // We're going to share this path between two wrappers\n+    path ph = temp_directory_path() / unique_path();\n+    create_directories(ph);\n+\n+    // Set up a non-obfuscated wrapper to write some initial data.\n+    CLevelDBWrapper* dbw = new CLevelDBWrapper(ph, (1 << 10), false, false, false);\n+    char key = 'k';\n+    uint256 in = GetRandHash();\n+    uint256 res;\n+\n+    BOOST_CHECK(dbw->Write(key, in));\n+    BOOST_CHECK(dbw->Read(key, res));\n+    BOOST_CHECK_EQUAL(res.ToString(), in.ToString());\n+\n+    // Call the destructor to free leveldb LOCK\n+    delete dbw;\n+\n+    // Simulate a -reindex by wiping the existing data store\n+    CLevelDBWrapper odbw(ph, (1 << 10), false, true, true);\n+\n+    // Check that the key/val we wrote with unobfuscated wrapper doesn't exist\n+    uint256 res2;\n+    BOOST_CHECK(!odbw.Read(key, res2));\n+    BOOST_CHECK(!is_null_key(odbw.GetObfuscateKey()));\n+\n+    uint256 in2 = GetRandHash();\n+    uint256 res3;\n+ \n+    // Check that we can write successfully\n+    BOOST_CHECK(odbw.Write(key, in2));\n+    BOOST_CHECK(odbw.Read(key, res3));\n+    BOOST_CHECK_EQUAL(res3.ToString(), in2.ToString());\n+}\n+ \n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "0ed8f363d7893d13c4e61b4df1711ab7e36addcb",
        "filename": "src/test/streams_tests.cpp",
        "status": "added",
        "additions": 67,
        "deletions": 0,
        "changes": 67,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/42cb388167ef78f47a3a440eb651b6938c10f508/src/test/streams_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/42cb388167ef78f47a3a440eb651b6938c10f508/src/test/streams_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/streams_tests.cpp?ref=42cb388167ef78f47a3a440eb651b6938c10f508",
        "patch": "@@ -0,0 +1,67 @@\n+// Copyright (c) 2012-2013 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include \"streams.h\"\n+#include \"support/allocators/zeroafterfree.h\"\n+#include \"test/test_bitcoin.h\"\n+\n+#include <boost/assign/std/vector.hpp> // for 'operator+=()'\n+#include <boost/assert.hpp>\n+#include <boost/test/unit_test.hpp>\n+                    \n+using namespace std;\n+using namespace boost::assign; // bring 'operator+=()' into scope\n+\n+BOOST_FIXTURE_TEST_SUITE(streams_tests, BasicTestingSetup)\n+\n+BOOST_AUTO_TEST_CASE(streams_serializedata_xor)\n+{\n+    std::vector<char> in;\n+    std::vector<char> expected_xor;\n+    std::vector<unsigned char> key;\n+    CDataStream ds(in, 0, 0);\n+\n+    // Degenerate case\n+    \n+    key += '\\x00','\\x00';\n+    ds.Xor(key);\n+    BOOST_CHECK_EQUAL(\n+            std::string(expected_xor.begin(), expected_xor.end()), \n+            std::string(ds.begin(), ds.end()));\n+\n+    in += '\\x0f','\\xf0';\n+    expected_xor += '\\xf0','\\x0f';\n+    \n+    // Single character key\n+\n+    ds.clear();\n+    ds.insert(ds.begin(), in.begin(), in.end());\n+    key.clear();\n+\n+    key += '\\xff';\n+    ds.Xor(key);\n+    BOOST_CHECK_EQUAL(\n+            std::string(expected_xor.begin(), expected_xor.end()), \n+            std::string(ds.begin(), ds.end())); \n+    \n+    // Multi character key\n+\n+    in.clear();\n+    expected_xor.clear();\n+    in += '\\xf0','\\x0f';\n+    expected_xor += '\\x0f','\\x00';\n+                        \n+    ds.clear();\n+    ds.insert(ds.begin(), in.begin(), in.end());\n+\n+    key.clear();\n+    key += '\\xff','\\x0f';\n+\n+    ds.Xor(key);\n+    BOOST_CHECK_EQUAL(\n+            std::string(expected_xor.begin(), expected_xor.end()), \n+            std::string(ds.begin(), ds.end()));  \n+}         \n+\n+BOOST_AUTO_TEST_SUITE_END()"
      },
      {
        "sha": "9738dea03d79f2b4b349111c413f1b3834b64f48",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 10,
        "deletions": 17,
        "changes": 27,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/42cb388167ef78f47a3a440eb651b6938c10f508/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/42cb388167ef78f47a3a440eb651b6938c10f508/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=42cb388167ef78f47a3a440eb651b6938c10f508",
        "patch": "@@ -29,18 +29,8 @@ static const char DB_REINDEX_FLAG = 'R';\n static const char DB_LAST_BLOCK = 'l';\n \n \n-void static BatchWriteCoins(CLevelDBBatch &batch, const uint256 &hash, const CCoins &coins) {\n-    if (coins.IsPruned())\n-        batch.Erase(make_pair(DB_COINS, hash));\n-    else\n-        batch.Write(make_pair(DB_COINS, hash), coins);\n-}\n-\n-void static BatchWriteHashBestChain(CLevelDBBatch &batch, const uint256 &hash) {\n-    batch.Write(DB_BEST_BLOCK, hash);\n-}\n-\n-CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe) {\n+CCoinsViewDB::CCoinsViewDB(size_t nCacheSize, bool fMemory, bool fWipe) : db(GetDataDir() / \"chainstate\", nCacheSize, fMemory, fWipe, true) \n+{\n }\n \n bool CCoinsViewDB::GetCoins(const uint256 &txid, CCoins &coins) const {\n@@ -59,20 +49,23 @@ uint256 CCoinsViewDB::GetBestBlock() const {\n }\n \n bool CCoinsViewDB::BatchWrite(CCoinsMap &mapCoins, const uint256 &hashBlock) {\n-    CLevelDBBatch batch;\n+    CLevelDBBatch batch(db.GetObfuscateKey());\n     size_t count = 0;\n     size_t changed = 0;\n     for (CCoinsMap::iterator it = mapCoins.begin(); it != mapCoins.end();) {\n         if (it->second.flags & CCoinsCacheEntry::DIRTY) {\n-            BatchWriteCoins(batch, it->first, it->second.coins);\n+            if (it->second.coins.IsPruned())\n+                batch.Erase(make_pair(DB_COINS, it->first));\n+            else\n+                batch.Write(make_pair(DB_COINS, it->first), it->second.coins);\n             changed++;\n         }\n         count++;\n         CCoinsMap::iterator itOld = it++;\n         mapCoins.erase(itOld);\n     }\n     if (!hashBlock.IsNull())\n-        BatchWriteHashBestChain(batch, hashBlock);\n+        batch.Write(DB_BEST_BLOCK, hashBlock);\n \n     LogPrint(\"coindb\", \"Committing %u changed transactions (out of %u) to coin database...\\n\", (unsigned int)changed, (unsigned int)count);\n     return db.WriteBatch(batch);\n@@ -158,7 +151,7 @@ bool CCoinsViewDB::GetStats(CCoinsStats &stats) const {\n }\n \n bool CBlockTreeDB::WriteBatchSync(const std::vector<std::pair<int, const CBlockFileInfo*> >& fileInfo, int nLastFile, const std::vector<const CBlockIndex*>& blockinfo) {\n-    CLevelDBBatch batch;\n+    CLevelDBBatch batch(GetObfuscateKey());\n     for (std::vector<std::pair<int, const CBlockFileInfo*> >::const_iterator it=fileInfo.begin(); it != fileInfo.end(); it++) {\n         batch.Write(make_pair(DB_BLOCK_FILES, it->first), *it->second);\n     }\n@@ -174,7 +167,7 @@ bool CBlockTreeDB::ReadTxIndex(const uint256 &txid, CDiskTxPos &pos) {\n }\n \n bool CBlockTreeDB::WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> >&vect) {\n-    CLevelDBBatch batch;\n+    CLevelDBBatch batch(GetObfuscateKey());\n     for (std::vector<std::pair<uint256,CDiskTxPos> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n         batch.Write(make_pair(DB_TXINDEX, it->first), it->second);\n     return WriteBatch(batch);"
      }
    ]
  }
]