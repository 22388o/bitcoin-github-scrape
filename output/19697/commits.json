[
  {
    "sha": "42ec5585424ceb91bed07826dde15697c020661a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MmVjNTU4NTQyNGNlYjkxYmVkMDc4MjZkZGUxNTY5N2MwMjA2NjFh",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-08-11T07:42:26Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-08-27T07:51:56Z"
      },
      "message": "Justify the choice of ADDR cache lifetime",
      "tree": {
        "sha": "aed17b3baae37d6a5c04233e29d2c886b2b9b9a9",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/aed17b3baae37d6a5c04233e29d2c886b2b9b9a9"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/42ec5585424ceb91bed07826dde15697c020661a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/42ec5585424ceb91bed07826dde15697c020661a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/42ec5585424ceb91bed07826dde15697c020661a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/42ec5585424ceb91bed07826dde15697c020661a/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "28f4e53e168fe09b3ed9b811f12e1f990a304264",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/28f4e53e168fe09b3ed9b811f12e1f990a304264",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/28f4e53e168fe09b3ed9b811f12e1f990a304264"
      }
    ],
    "stats": {
      "total": 25,
      "additions": 25,
      "deletions": 0
    },
    "files": [
      {
        "sha": "7841965f601e9802b8423da91345551dc76b0851",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 25,
        "deletions": 0,
        "changes": 25,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/42ec5585424ceb91bed07826dde15697c020661a/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/42ec5585424ceb91bed07826dde15697c020661a/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=42ec5585424ceb91bed07826dde15697c020661a",
        "patch": "@@ -2545,6 +2545,31 @@ std::vector<CAddress> CConnman::GetAddresses(Network requestor_network, size_t m\n     if (m_addr_response_caches.find(requestor_network) == m_addr_response_caches.end() ||\n         m_addr_response_caches[requestor_network].m_update_addr_response < current_time) {\n         m_addr_response_caches[requestor_network].m_addrs_response_cache = GetAddresses(max_addresses, max_pct);\n+\n+        // Choosing a proper cache lifetime is a trade-off between the privacy leak minimization\n+        // and the usefulness of ADDR responses to honest users.\n+        //\n+        // Longer cache lifetime makes it more difficult for an attacker to scrape\n+        // enough AddrMan data to maliciously infer something useful.\n+        // By the time an attacker scraped enough AddrMan records, most of\n+        // the records should be old enough to not leak topology info by\n+        // e.g. analyzing real-time changes in timestamps.\n+        //\n+        // It takes only several hundred requests to scrape everything from an AddrMan containing 100,000 nodes,\n+        // so ~24 hours of cache lifetime indeed makes the data less inferable by the time\n+        // most of it could be scraped (considering that timestamps are updated via\n+        // ADDR self-announcements and when nodes communicate).\n+        // We also should be robust to those attacks which may not require scraping *full* victim's AddrMan\n+        // (because even several timestamps of the same handful of nodes may leak privacy).\n+        //\n+        // On the other hand, longer cache lifetime makes ADDR responses\n+        // outdated and less useful for an honest requestor, e.g. if most nodes\n+        // in the ADDR response are no longer active.\n+        //\n+        // However, the churn in the network is known to be rather low. Since we consider\n+        // nodes to be \"terrible\" (see IsTerrible()) if the timestamps are older than 30 days,\n+        // max. 24 hours of \"penalty\" due to cache shouldn't make any meaningful difference\n+        // in terms of the freshness of the response.\n         m_addr_response_caches[requestor_network].m_update_addr_response = current_time + std::chrono::hours(21) + GetRandMillis(std::chrono::hours(6));\n     }\n     return m_addr_response_caches[requestor_network].m_addrs_response_cache;"
      }
    ]
  },
  {
    "sha": "81b00f87800f40cb14f2131ff27668bd2bb9e551",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4MWIwMGY4NzgwMGY0MGNiMTRmMjEzMWZmMjc2NjhiZDJiYjllNTUx",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-08-11T09:41:26Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-08-27T07:51:56Z"
      },
      "message": "Add indexing ADDR cache by local socket addr",
      "tree": {
        "sha": "fc6b630ff1121934b0859ec8e67eefbb8d850245",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/fc6b630ff1121934b0859ec8e67eefbb8d850245"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/81b00f87800f40cb14f2131ff27668bd2bb9e551",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/81b00f87800f40cb14f2131ff27668bd2bb9e551",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/81b00f87800f40cb14f2131ff27668bd2bb9e551",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/81b00f87800f40cb14f2131ff27668bd2bb9e551/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "42ec5585424ceb91bed07826dde15697c020661a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/42ec5585424ceb91bed07826dde15697c020661a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/42ec5585424ceb91bed07826dde15697c020661a"
      }
    ],
    "stats": {
      "total": 34,
      "additions": 23,
      "deletions": 11
    },
    "files": [
      {
        "sha": "e43b4806123c4893705e4cb737e97b32c8990976",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 6,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/81b00f87800f40cb14f2131ff27668bd2bb9e551/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/81b00f87800f40cb14f2131ff27668bd2bb9e551/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=81b00f87800f40cb14f2131ff27668bd2bb9e551",
        "patch": "@@ -94,6 +94,7 @@ const std::string NET_MESSAGE_COMMAND_OTHER = \"*other*\";\n \n static const uint64_t RANDOMIZER_ID_NETGROUP = 0x6c0edd8036ef4036ULL; // SHA256(\"netgroup\")[0:8]\n static const uint64_t RANDOMIZER_ID_LOCALHOSTNONCE = 0xd93e69e2bbfa5735ULL; // SHA256(\"localhostnonce\")[0:8]\n+static const uint64_t RANDOMIZER_ID_ADDRCACHE = 0x1cf2e4ddd306dda9ULL; // SHA256(\"addrcache\")[0:8]\n //\n // Global state variables\n //\n@@ -2539,12 +2540,19 @@ std::vector<CAddress> CConnman::GetAddresses(size_t max_addresses, size_t max_pc\n     return addresses;\n }\n \n-std::vector<CAddress> CConnman::GetAddresses(Network requestor_network, size_t max_addresses, size_t max_pct)\n+std::vector<CAddress> CConnman::GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct)\n {\n+    SOCKET socket;\n+    WITH_LOCK(requestor.cs_hSocket, socket = requestor.hSocket);\n+    auto local_socket_bytes = GetBindAddress(socket).GetAddrBytes();\n+    uint64_t cache_id = GetDeterministicRandomizer(RANDOMIZER_ID_ADDRCACHE)\n+        .Write(requestor.addr.GetNetwork())\n+        .Write(local_socket_bytes.data(), local_socket_bytes.size())\n+        .Finalize();\n     const auto current_time = GetTime<std::chrono::microseconds>();\n-    if (m_addr_response_caches.find(requestor_network) == m_addr_response_caches.end() ||\n-        m_addr_response_caches[requestor_network].m_update_addr_response < current_time) {\n-        m_addr_response_caches[requestor_network].m_addrs_response_cache = GetAddresses(max_addresses, max_pct);\n+    if (m_addr_response_caches.find(cache_id) == m_addr_response_caches.end() ||\n+        m_addr_response_caches[cache_id].m_update_addr_response < current_time) {\n+        m_addr_response_caches[cache_id].m_addrs_response_cache = GetAddresses(max_addresses, max_pct);\n \n         // Choosing a proper cache lifetime is a trade-off between the privacy leak minimization\n         // and the usefulness of ADDR responses to honest users.\n@@ -2570,9 +2578,9 @@ std::vector<CAddress> CConnman::GetAddresses(Network requestor_network, size_t m\n         // nodes to be \"terrible\" (see IsTerrible()) if the timestamps are older than 30 days,\n         // max. 24 hours of \"penalty\" due to cache shouldn't make any meaningful difference\n         // in terms of the freshness of the response.\n-        m_addr_response_caches[requestor_network].m_update_addr_response = current_time + std::chrono::hours(21) + GetRandMillis(std::chrono::hours(6));\n+        m_addr_response_caches[cache_id].m_update_addr_response = current_time + std::chrono::hours(21) + GetRandMillis(std::chrono::hours(6));\n     }\n-    return m_addr_response_caches[requestor_network].m_addrs_response_cache;\n+    return m_addr_response_caches[cache_id].m_addrs_response_cache;\n }\n \n bool CConnman::AddNode(const std::string& strNode)"
      },
      {
        "sha": "c9ab579eb24b89923363abd54fd79de74a080fdb",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 8,
        "deletions": 4,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/81b00f87800f40cb14f2131ff27668bd2bb9e551/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/81b00f87800f40cb14f2131ff27668bd2bb9e551/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=81b00f87800f40cb14f2131ff27668bd2bb9e551",
        "patch": "@@ -269,7 +269,7 @@ class CConnman\n      * A non-malicious call (from RPC or a peer with addr permission) should\n      * call the function without a parameter to avoid using the cache.\n      */\n-    std::vector<CAddress> GetAddresses(Network requestor_network, size_t max_addresses, size_t max_pct);\n+    std::vector<CAddress> GetAddresses(CNode& requestor, size_t max_addresses, size_t max_pct);\n \n     // This allows temporarily exceeding m_max_outbound_full_relay, with the goal of finding\n     // a peer that is better than all our current peers.\n@@ -447,15 +447,19 @@ class CConnman\n \n     /**\n      * Addr responses stored in different caches\n-     * per network prevent cross-network node identification.\n+     * per (network, local socket) prevent cross-network node identification.\n      * If a node for example is multi-homed under Tor and IPv6,\n      * a single cache (or no cache at all) would let an attacker\n      * to easily detect that it is the same node by comparing responses.\n+     * Indexing by local socket prevents leakage when a node has multiple\n+     * listening addresses on the same network.\n+     *\n      * The used memory equals to 1000 CAddress records (or around 32 bytes) per\n      * distinct Network (up to 5) we have/had an inbound peer from,\n-     * resulting in at most ~160 KB.\n+     * resulting in at most ~160 KB. Every separate local socket may\n+     * add up to ~160 KB extra.\n      */\n-    std::map<Network, CachedAddrResponse> m_addr_response_caches;\n+    std::map<uint64_t, CachedAddrResponse> m_addr_response_caches;\n \n     /**\n      * Services this instance offers."
      },
      {
        "sha": "bf359a0d686bcc61f18fc97ae07b39382d37ccb6",
        "filename": "src/net_processing.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/81b00f87800f40cb14f2131ff27668bd2bb9e551/src/net_processing.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/81b00f87800f40cb14f2131ff27668bd2bb9e551/src/net_processing.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net_processing.cpp?ref=81b00f87800f40cb14f2131ff27668bd2bb9e551",
        "patch": "@@ -3516,7 +3516,7 @@ void PeerLogicValidation::ProcessMessage(CNode& pfrom, const std::string& msg_ty\n         if (pfrom.HasPermission(PF_ADDR)) {\n             vAddr = m_connman.GetAddresses(MAX_ADDR_TO_SEND, MAX_PCT_ADDR_TO_SEND);\n         } else {\n-            vAddr = m_connman.GetAddresses(pfrom.addr.GetNetwork(), MAX_ADDR_TO_SEND, MAX_PCT_ADDR_TO_SEND);\n+            vAddr = m_connman.GetAddresses(pfrom, MAX_ADDR_TO_SEND, MAX_PCT_ADDR_TO_SEND);\n         }\n         FastRandomContext insecure_rand;\n         for (const CAddress &addr : vAddr) {"
      }
    ]
  },
  {
    "sha": "83ad65f31b5c9441ae1618614082e584854a14e1",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4M2FkNjVmMzFiNWM5NDQxYWUxNjE4NjE0MDgyZTU4NDg1NGExNGUx",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-08-11T10:39:56Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-09-02T07:33:17Z"
      },
      "message": "Address nits in ADDR caching",
      "tree": {
        "sha": "84a31614121e669ba64148876c0d4dd5aade0312",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/84a31614121e669ba64148876c0d4dd5aade0312"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/83ad65f31b5c9441ae1618614082e584854a14e1",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/83ad65f31b5c9441ae1618614082e584854a14e1",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/83ad65f31b5c9441ae1618614082e584854a14e1",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/83ad65f31b5c9441ae1618614082e584854a14e1/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "81b00f87800f40cb14f2131ff27668bd2bb9e551",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/81b00f87800f40cb14f2131ff27668bd2bb9e551",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/81b00f87800f40cb14f2131ff27668bd2bb9e551"
      }
    ],
    "stats": {
      "total": 20,
      "additions": 10,
      "deletions": 10
    },
    "files": [
      {
        "sha": "8ac45dbcb598d31321c5f5258b35f41c1b3f75e5",
        "filename": "src/net.cpp",
        "status": "modified",
        "additions": 6,
        "deletions": 6,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/83ad65f31b5c9441ae1618614082e584854a14e1/src/net.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/83ad65f31b5c9441ae1618614082e584854a14e1/src/net.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.cpp?ref=83ad65f31b5c9441ae1618614082e584854a14e1",
        "patch": "@@ -2550,10 +2550,10 @@ std::vector<CAddress> CConnman::GetAddresses(CNode& requestor, size_t max_addres\n         .Write(local_socket_bytes.data(), local_socket_bytes.size())\n         .Finalize();\n     const auto current_time = GetTime<std::chrono::microseconds>();\n-    if (m_addr_response_caches.find(cache_id) == m_addr_response_caches.end() ||\n-        m_addr_response_caches[cache_id].m_update_addr_response < current_time) {\n-        m_addr_response_caches[cache_id].m_addrs_response_cache = GetAddresses(max_addresses, max_pct);\n-\n+    auto r = m_addr_response_caches.emplace(cache_id, CachedAddrResponse{});\n+    CachedAddrResponse& cache_entry = r.first->second;\n+    if (cache_entry.m_cache_entry_expiration < current_time) { // If emplace() added new one it has expiration 0.\n+        cache_entry.m_addrs_response_cache = GetAddresses(max_addresses, max_pct);\n         // Choosing a proper cache lifetime is a trade-off between the privacy leak minimization\n         // and the usefulness of ADDR responses to honest users.\n         //\n@@ -2578,9 +2578,9 @@ std::vector<CAddress> CConnman::GetAddresses(CNode& requestor, size_t max_addres\n         // nodes to be \"terrible\" (see IsTerrible()) if the timestamps are older than 30 days,\n         // max. 24 hours of \"penalty\" due to cache shouldn't make any meaningful difference\n         // in terms of the freshness of the response.\n-        m_addr_response_caches[cache_id].m_update_addr_response = current_time + std::chrono::hours(21) + GetRandMillis(std::chrono::hours(6));\n+        cache_entry.m_cache_entry_expiration = current_time + std::chrono::hours(21) + GetRandMillis(std::chrono::hours(6));\n     }\n-    return m_addr_response_caches[cache_id].m_addrs_response_cache;\n+    return cache_entry.m_addrs_response_cache;\n }\n \n bool CConnman::AddNode(const std::string& strNode)"
      },
      {
        "sha": "21faea591ac55022f011fadfab9394e46fdc5cbb",
        "filename": "src/net.h",
        "status": "modified",
        "additions": 4,
        "deletions": 4,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/83ad65f31b5c9441ae1618614082e584854a14e1/src/net.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/83ad65f31b5c9441ae1618614082e584854a14e1/src/net.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/net.h?ref=83ad65f31b5c9441ae1618614082e584854a14e1",
        "patch": "@@ -442,7 +442,7 @@ class CConnman\n      */\n     struct CachedAddrResponse {\n         std::vector<CAddress> m_addrs_response_cache;\n-        std::chrono::microseconds m_update_addr_response{0};\n+        std::chrono::microseconds m_cache_entry_expiration{0};\n     };\n \n     /**\n@@ -454,10 +454,10 @@ class CConnman\n      * Indexing by local socket prevents leakage when a node has multiple\n      * listening addresses on the same network.\n      *\n-     * The used memory equals to 1000 CAddress records (or around 32 bytes) per\n+     * The used memory equals to 1000 CAddress records (or around 40 bytes) per\n      * distinct Network (up to 5) we have/had an inbound peer from,\n-     * resulting in at most ~160 KB. Every separate local socket may\n-     * add up to ~160 KB extra.\n+     * resulting in at most ~196 KB. Every separate local socket may\n+     * add up to ~196 KB extra.\n      */\n     std::map<uint64_t, CachedAddrResponse> m_addr_response_caches;\n "
      }
    ]
  },
  {
    "sha": "0d04784af151de249bbbcbad51e6e8ad9af8f5a3",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzowZDA0Nzg0YWYxNTFkZTI0OWJiYmNiYWQ1MWU2ZThhZDlhZjhmNWEz",
    "commit": {
      "author": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-08-23T14:31:45Z"
      },
      "committer": {
        "name": "Gleb Naumenko",
        "email": "naumenko.gs@gmail.com",
        "date": "2020-09-02T07:33:18Z"
      },
      "message": "Refactor the functional test",
      "tree": {
        "sha": "27ee48cb36cb29b2d90d4321864ee14cd6843c5a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/27ee48cb36cb29b2d90d4321864ee14cd6843c5a"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/0d04784af151de249bbbcbad51e6e8ad9af8f5a3",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d04784af151de249bbbcbad51e6e8ad9af8f5a3",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/0d04784af151de249bbbcbad51e6e8ad9af8f5a3",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0d04784af151de249bbbcbad51e6e8ad9af8f5a3/comments",
    "author": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "naumenkogs",
      "id": 7975071,
      "node_id": "MDQ6VXNlcjc5NzUwNzE=",
      "avatar_url": "https://avatars.githubusercontent.com/u/7975071?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/naumenkogs",
      "html_url": "https://github.com/naumenkogs",
      "followers_url": "https://api.github.com/users/naumenkogs/followers",
      "following_url": "https://api.github.com/users/naumenkogs/following{/other_user}",
      "gists_url": "https://api.github.com/users/naumenkogs/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/naumenkogs/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/naumenkogs/subscriptions",
      "organizations_url": "https://api.github.com/users/naumenkogs/orgs",
      "repos_url": "https://api.github.com/users/naumenkogs/repos",
      "events_url": "https://api.github.com/users/naumenkogs/events{/privacy}",
      "received_events_url": "https://api.github.com/users/naumenkogs/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "83ad65f31b5c9441ae1618614082e584854a14e1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/83ad65f31b5c9441ae1618614082e584854a14e1",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/83ad65f31b5c9441ae1618614082e584854a14e1"
      }
    ],
    "stats": {
      "total": 47,
      "additions": 14,
      "deletions": 33
    },
    "files": [
      {
        "sha": "2b75ad517547d67d620d90ce1c26ebea6b7e3599",
        "filename": "test/functional/p2p_getaddr_caching.py",
        "status": "modified",
        "additions": 14,
        "deletions": 33,
        "changes": 47,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/0d04784af151de249bbbcbad51e6e8ad9af8f5a3/test/functional/p2p_getaddr_caching.py",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/0d04784af151de249bbbcbad51e6e8ad9af8f5a3/test/functional/p2p_getaddr_caching.py",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/test/functional/p2p_getaddr_caching.py?ref=0d04784af151de249bbbcbad51e6e8ad9af8f5a3",
        "patch": "@@ -5,13 +5,8 @@\n \"\"\"Test addr response caching\"\"\"\n \n import time\n-from test_framework.messages import (\n-    CAddress,\n-    NODE_NETWORK,\n-    NODE_WITNESS,\n-    msg_addr,\n-    msg_getaddr,\n-)\n+\n+from test_framework.messages import msg_getaddr\n from test_framework.p2p import (\n     P2PInterface,\n     p2p_lock\n@@ -21,21 +16,9 @@\n     assert_equal,\n )\n \n+# As defined in net_processing.\n MAX_ADDR_TO_SEND = 1000\n-\n-def gen_addrs(n):\n-    addrs = []\n-    for i in range(n):\n-        addr = CAddress()\n-        addr.time = int(time.time())\n-        addr.nServices = NODE_NETWORK | NODE_WITNESS\n-        # Use first octets to occupy different AddrMan buckets\n-        first_octet = i >> 8\n-        second_octet = i % 256\n-        addr.ip = \"{}.{}.1.1\".format(first_octet, second_octet)\n-        addr.port = 8333\n-        addrs.append(addr)\n-    return addrs\n+MAX_PCT_ADDR_TO_SEND = 23\n \n class AddrReceiver(P2PInterface):\n \n@@ -62,18 +45,16 @@ def set_test_params(self):\n         self.num_nodes = 1\n \n     def run_test(self):\n-        self.log.info('Create connection that sends and requests addr messages')\n-        addr_source = self.nodes[0].add_p2p_connection(P2PInterface())\n-\n-        msg_send_addrs = msg_addr()\n         self.log.info('Fill peer AddrMan with a lot of records')\n-        # Since these addrs are sent from the same source, not all of them will be stored,\n-        # because we allocate a limited number of AddrMan buckets per addr source.\n-        total_addrs = 10000\n-        addrs = gen_addrs(total_addrs)\n-        for i in range(int(total_addrs/MAX_ADDR_TO_SEND)):\n-            msg_send_addrs.addrs = addrs[i * MAX_ADDR_TO_SEND:(i + 1) * MAX_ADDR_TO_SEND]\n-            addr_source.send_and_ping(msg_send_addrs)\n+        for i in range(10000):\n+            first_octet = i >> 8\n+            second_octet = i % 256\n+            a = \"{}.{}.1.1\".format(first_octet, second_octet)\n+            self.nodes[0].addpeeraddress(a, 8333)\n+\n+        # Need to make sure we hit MAX_ADDR_TO_SEND records in the addr response later because\n+        # only a fraction of all known addresses can be cached and returned.\n+        assert(len(self.nodes[0].getnodeaddresses(0)) > int(MAX_ADDR_TO_SEND / (MAX_PCT_ADDR_TO_SEND / 100)))\n \n         responses = []\n         self.log.info('Send many addr requests within short time to receive same response')\n@@ -89,7 +70,7 @@ def run_test(self):\n             responses.append(addr_receiver.get_received_addrs())\n         for response in responses[1:]:\n             assert_equal(response, responses[0])\n-        assert(len(response) < MAX_ADDR_TO_SEND)\n+        assert(len(response) == MAX_ADDR_TO_SEND)\n \n         cur_mock_time += 3 * 24 * 60 * 60\n         self.nodes[0].setmocktime(cur_mock_time)"
      }
    ]
  }
]