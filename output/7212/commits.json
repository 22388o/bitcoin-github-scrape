[
  {
    "sha": "40c87b6e6961e61d1cccdd248534e99f7a421564",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo0MGM4N2I2ZTY5NjFlNjFkMWNjY2RkMjQ4NTM0ZTk5ZjdhNDIxNTY0",
    "commit": {
      "author": {
        "name": "Ethan Heilman",
        "email": "Ethan.R.Heilman@gmail.com",
        "date": "2015-12-13T03:34:08Z"
      },
      "committer": {
        "name": "EthanHeilman",
        "email": "ethan.r.heilman@gmail.com",
        "date": "2016-01-27T15:50:58Z"
      },
      "message": "Increase test coverage for addrman and addrinfo\n\nAdds several unittests for CAddrMan and CAddrInfo.\nIncreases the accuracy of addrman tests.\nRemoves non-determinism in tests by overriding the random number generator.\nExtracts testing code from addrman class to test class.",
      "tree": {
        "sha": "2923a3410b96ab4c21359b4b639540005e1ef979",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/2923a3410b96ab4c21359b4b639540005e1ef979"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/40c87b6e6961e61d1cccdd248534e99f7a421564",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40c87b6e6961e61d1cccdd248534e99f7a421564",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/40c87b6e6961e61d1cccdd248534e99f7a421564",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/40c87b6e6961e61d1cccdd248534e99f7a421564/comments",
    "author": {
      "login": "EthanHeilman",
      "id": 274814,
      "node_id": "MDQ6VXNlcjI3NDgxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/274814?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/EthanHeilman",
      "html_url": "https://github.com/EthanHeilman",
      "followers_url": "https://api.github.com/users/EthanHeilman/followers",
      "following_url": "https://api.github.com/users/EthanHeilman/following{/other_user}",
      "gists_url": "https://api.github.com/users/EthanHeilman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/EthanHeilman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/EthanHeilman/subscriptions",
      "organizations_url": "https://api.github.com/users/EthanHeilman/orgs",
      "repos_url": "https://api.github.com/users/EthanHeilman/repos",
      "events_url": "https://api.github.com/users/EthanHeilman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/EthanHeilman/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "EthanHeilman",
      "id": 274814,
      "node_id": "MDQ6VXNlcjI3NDgxNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/274814?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/EthanHeilman",
      "html_url": "https://github.com/EthanHeilman",
      "followers_url": "https://api.github.com/users/EthanHeilman/followers",
      "following_url": "https://api.github.com/users/EthanHeilman/following{/other_user}",
      "gists_url": "https://api.github.com/users/EthanHeilman/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/EthanHeilman/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/EthanHeilman/subscriptions",
      "organizations_url": "https://api.github.com/users/EthanHeilman/orgs",
      "repos_url": "https://api.github.com/users/EthanHeilman/repos",
      "events_url": "https://api.github.com/users/EthanHeilman/events{/privacy}",
      "received_events_url": "https://api.github.com/users/EthanHeilman/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "473ad1bb026986db2569fff278d8957363f758f8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/473ad1bb026986db2569fff278d8957363f758f8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/473ad1bb026986db2569fff278d8957363f758f8"
      }
    ],
    "stats": {
      "total": 440,
      "additions": 391,
      "deletions": 49
    },
    "files": [
      {
        "sha": "2dea0b844c9e4e3438b191fbb1845fe440a2c8c3",
        "filename": "src/addrman.cpp",
        "status": "modified",
        "additions": 14,
        "deletions": 10,
        "changes": 24,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40c87b6e6961e61d1cccdd248534e99f7a421564/src/addrman.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40c87b6e6961e61d1cccdd248534e99f7a421564/src/addrman.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.cpp?ref=40c87b6e6961e61d1cccdd248534e99f7a421564",
        "patch": "@@ -220,7 +220,7 @@ void CAddrMan::Good_(const CService& addr, int64_t nTime)\n         return;\n \n     // find a bucket it is in now\n-    int nRnd = GetRandInt(ADDRMAN_NEW_BUCKET_COUNT);\n+    int nRnd = RandomInt(ADDRMAN_NEW_BUCKET_COUNT);\n     int nUBucket = -1;\n     for (unsigned int n = 0; n < ADDRMAN_NEW_BUCKET_COUNT; n++) {\n         int nB = (n + nRnd) % ADDRMAN_NEW_BUCKET_COUNT;\n@@ -277,7 +277,7 @@ bool CAddrMan::Add_(const CAddress& addr, const CNetAddr& source, int64_t nTimeP\n         int nFactor = 1;\n         for (int n = 0; n < pinfo->nRefCount; n++)\n             nFactor *= 2;\n-        if (nFactor > 1 && (GetRandInt(nFactor) != 0))\n+        if (nFactor > 1 && (RandomInt(nFactor) != 0))\n             return false;\n     } else {\n         pinfo = Create(addr, source, &nId);\n@@ -339,37 +339,37 @@ CAddrInfo CAddrMan::Select_(bool newOnly)\n \n     // Use a 50% chance for choosing between tried and new table entries.\n     if (!newOnly &&\n-       (nTried > 0 && (nNew == 0 || GetRandInt(2) == 0))) { \n+       (nTried > 0 && (nNew == 0 || RandomInt(2) == 0))) { \n         // use a tried node\n         double fChanceFactor = 1.0;\n         while (1) {\n-            int nKBucket = GetRandInt(ADDRMAN_TRIED_BUCKET_COUNT);\n-            int nKBucketPos = GetRandInt(ADDRMAN_BUCKET_SIZE);\n+            int nKBucket = RandomInt(ADDRMAN_TRIED_BUCKET_COUNT);\n+            int nKBucketPos = RandomInt(ADDRMAN_BUCKET_SIZE);\n             while (vvTried[nKBucket][nKBucketPos] == -1) {\n                 nKBucket = (nKBucket + insecure_rand()) % ADDRMAN_TRIED_BUCKET_COUNT;\n                 nKBucketPos = (nKBucketPos + insecure_rand()) % ADDRMAN_BUCKET_SIZE;\n             }\n             int nId = vvTried[nKBucket][nKBucketPos];\n             assert(mapInfo.count(nId) == 1);\n             CAddrInfo& info = mapInfo[nId];\n-            if (GetRandInt(1 << 30) < fChanceFactor * info.GetChance() * (1 << 30))\n+            if (RandomInt(1 << 30) < fChanceFactor * info.GetChance() * (1 << 30))\n                 return info;\n             fChanceFactor *= 1.2;\n         }\n     } else {\n         // use a new node\n         double fChanceFactor = 1.0;\n         while (1) {\n-            int nUBucket = GetRandInt(ADDRMAN_NEW_BUCKET_COUNT);\n-            int nUBucketPos = GetRandInt(ADDRMAN_BUCKET_SIZE);\n+            int nUBucket = RandomInt(ADDRMAN_NEW_BUCKET_COUNT);\n+            int nUBucketPos = RandomInt(ADDRMAN_BUCKET_SIZE);\n             while (vvNew[nUBucket][nUBucketPos] == -1) {\n                 nUBucket = (nUBucket + insecure_rand()) % ADDRMAN_NEW_BUCKET_COUNT;\n                 nUBucketPos = (nUBucketPos + insecure_rand()) % ADDRMAN_BUCKET_SIZE;\n             }\n             int nId = vvNew[nUBucket][nUBucketPos];\n             assert(mapInfo.count(nId) == 1);\n             CAddrInfo& info = mapInfo[nId];\n-            if (GetRandInt(1 << 30) < fChanceFactor * info.GetChance() * (1 << 30))\n+            if (RandomInt(1 << 30) < fChanceFactor * info.GetChance() * (1 << 30))\n                 return info;\n             fChanceFactor *= 1.2;\n         }\n@@ -465,7 +465,7 @@ void CAddrMan::GetAddr_(std::vector<CAddress>& vAddr)\n         if (vAddr.size() >= nNodes)\n             break;\n \n-        int nRndPos = GetRandInt(vRandom.size() - n) + n;\n+        int nRndPos = RandomInt(vRandom.size() - n) + n;\n         SwapRandom(n, nRndPos);\n         assert(mapInfo.count(vRandom[n]) == 1);\n \n@@ -494,3 +494,7 @@ void CAddrMan::Connected_(const CService& addr, int64_t nTime)\n     if (nTime - info.nTime > nUpdateInterval)\n         info.nTime = nTime;\n }\n+\n+int CAddrMan::RandomInt(int nMax){\n+    return GetRandInt(nMax);\n+}\n\\ No newline at end of file"
      },
      {
        "sha": "26a6dae473e7742d1d357c2d2441e5aacfcb4852",
        "filename": "src/addrman.h",
        "status": "modified",
        "additions": 5,
        "deletions": 8,
        "changes": 13,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40c87b6e6961e61d1cccdd248534e99f7a421564/src/addrman.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40c87b6e6961e61d1cccdd248534e99f7a421564/src/addrman.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/addrman.h?ref=40c87b6e6961e61d1cccdd248534e99f7a421564",
        "patch": "@@ -175,9 +175,6 @@ class CAddrMan\n     //! critical section to protect the inner data structures\n     mutable CCriticalSection cs;\n \n-    //! secret key to randomize bucket select with\n-    uint256 nKey;\n-\n     //! last used nId\n     int nIdCount;\n \n@@ -203,6 +200,8 @@ class CAddrMan\n     int vvNew[ADDRMAN_NEW_BUCKET_COUNT][ADDRMAN_BUCKET_SIZE];\n \n protected:\n+    //! secret key to randomize bucket select with\n+    uint256 nKey;\n \n     //! Find an entry.\n     CAddrInfo* Find(const CNetAddr& addr, int *pnId = NULL);\n@@ -235,6 +234,9 @@ class CAddrMan\n     //! Select an address to connect to, if newOnly is set to true, only the new table is selected from.\n     CAddrInfo Select_(bool newOnly);\n \n+    //! Wraps GetRandInt to allow tests to override RandomInt and make it determinismistic.\n+    virtual int RandomInt(int nMax);\n+\n #ifdef DEBUG_ADDRMAN\n     //! Perform consistency check. Returns an error code or zero.\n     int Check_();\n@@ -569,11 +571,6 @@ class CAddrMan\n             Check();\n         }\n     }\n-    \n-    //! Ensure that bucket placement is always the same for testing purposes.\n-    void MakeDeterministic(){\n-        nKey.SetNull(); //Do not use outside of tests.\n-    }\n \n };\n "
      },
      {
        "sha": "767b653e47734911bf6d47144c855011b48ded0a",
        "filename": "src/test/addrman_tests.cpp",
        "status": "modified",
        "additions": 372,
        "deletions": 31,
        "changes": 403,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/40c87b6e6961e61d1cccdd248534e99f7a421564/src/test/addrman_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/40c87b6e6961e61d1cccdd248534e99f7a421564/src/test/addrman_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/addrman_tests.cpp?ref=40c87b6e6961e61d1cccdd248534e99f7a421564",
        "patch": "@@ -6,11 +6,49 @@\n #include <string>\n #include <boost/test/unit_test.hpp>\n \n+#include \"hash.h\"\n #include \"random.h\"\n \n using namespace std;\n \n-class CAddrManTest : public CAddrMan{};\n+class CAddrManTest : public CAddrMan\n+{\n+    uint64_t state;\n+\n+public:\n+    CAddrManTest()\n+    {\n+        state = 1;\n+    }\n+\n+    //! Ensure that bucket placement is always the same for testing purposes.\n+    void MakeDeterministic()\n+    {\n+        nKey.SetNull();\n+        seed_insecure_rand(true);\n+    }\n+\n+    int RandomInt(int nMax)\n+    {\n+        state = (CHashWriter(SER_GETHASH, 0) << state).GetHash().GetCheapHash();\n+        return (unsigned int)(state % nMax);\n+    }\n+\n+    CAddrInfo* Find(const CNetAddr& addr, int* pnId = NULL)\n+    {\n+        return CAddrMan::Find(addr, pnId);\n+    }\n+\n+    CAddrInfo* Create(const CAddress& addr, const CNetAddr& addrSource, int* pnId = NULL)\n+    {\n+        return CAddrMan::Create(addr, addrSource, pnId);\n+    }\n+\n+    void Delete(int nId)\n+    {\n+        CAddrMan::Delete(nId);\n+    }\n+};\n \n BOOST_FIXTURE_TEST_SUITE(addrman_tests, BasicTestingSetup)\n \n@@ -21,34 +59,34 @@ BOOST_AUTO_TEST_CASE(addrman_simple)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CNetAddr source = CNetAddr(\"252.2.2.2:8333\");\n+    CNetAddr source = CNetAddr(\"252.2.2.2\");\n \n     // Test 1: Does Addrman respond correctly when empty.\n     BOOST_CHECK(addrman.size() == 0);\n     CAddrInfo addr_null = addrman.Select();\n     BOOST_CHECK(addr_null.ToString() == \"[::]:0\");\n \n     // Test 2: Does Addrman::Add work as expected.\n-    CService addr1 = CService(\"250.1.1.1:8333\");\n+    CService addr1 = CService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1), source);\n     BOOST_CHECK(addrman.size() == 1);\n     CAddrInfo addr_ret1 = addrman.Select();\n     BOOST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n \n-    // Test 3: Does IP address deduplication work correctly. \n+    // Test 3: Does IP address deduplication work correctly.\n     //  Expected dup IP should not be added.\n-    CService addr1_dup = CService(\"250.1.1.1:8333\");\n+    CService addr1_dup = CService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1_dup), source);\n     BOOST_CHECK(addrman.size() == 1);\n \n \n     // Test 5: New table has one addr and we add a diff addr we should\n     //  have two addrs.\n-    CService addr2 = CService(\"250.1.1.2:8333\");\n+    CService addr2 = CService(\"250.1.1.2\", 8333);\n     addrman.Add(CAddress(addr2), source);\n     BOOST_CHECK(addrman.size() == 2);\n \n-    // Test 6: AddrMan::Clear() should empty the new table. \n+    // Test 6: AddrMan::Clear() should empty the new table.\n     addrman.Clear();\n     BOOST_CHECK(addrman.size() == 0);\n     CAddrInfo addr_null2 = addrman.Select();\n@@ -62,16 +100,16 @@ BOOST_AUTO_TEST_CASE(addrman_ports)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CNetAddr source = CNetAddr(\"252.2.2.2:8333\");\n+    CNetAddr source = CNetAddr(\"252.2.2.2\");\n \n     BOOST_CHECK(addrman.size() == 0);\n \n     // Test 7; Addr with same IP but diff port does not replace existing addr.\n-    CService addr1 = CService(\"250.1.1.1:8333\");\n+    CService addr1 = CService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1), source);\n     BOOST_CHECK(addrman.size() == 1);\n \n-    CService addr1_port = CService(\"250.1.1.1:8334\");\n+    CService addr1_port = CService(\"250.1.1.1\", 8334);\n     addrman.Add(CAddress(addr1_port), source);\n     BOOST_CHECK(addrman.size() == 1);\n     CAddrInfo addr_ret2 = addrman.Select();\n@@ -94,18 +132,17 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CNetAddr source = CNetAddr(\"252.2.2.2:8333\");\n+    CNetAddr source = CNetAddr(\"252.2.2.2\");\n \n     // Test 9: Select from new with 1 addr in new.\n-    CService addr1 = CService(\"250.1.1.1:8333\");\n+    CService addr1 = CService(\"250.1.1.1\", 8333);\n     addrman.Add(CAddress(addr1), source);\n     BOOST_CHECK(addrman.size() == 1);\n \n     bool newOnly = true;\n     CAddrInfo addr_ret1 = addrman.Select(newOnly);\n     BOOST_CHECK(addr_ret1.ToString() == \"250.1.1.1:8333\");\n \n-\n     // Test 10: move addr to tried, select from new expected nothing returned.\n     addrman.Good(CAddress(addr1));\n     BOOST_CHECK(addrman.size() == 1);\n@@ -114,6 +151,39 @@ BOOST_AUTO_TEST_CASE(addrman_select)\n \n     CAddrInfo addr_ret3 = addrman.Select();\n     BOOST_CHECK(addr_ret3.ToString() == \"250.1.1.1:8333\");\n+\n+    BOOST_CHECK(addrman.size() == 1);\n+\n+\n+    // Add three addresses to new table.\n+    CService addr2 = CService(\"250.3.1.1\", 8333);\n+    CService addr3 = CService(\"250.3.2.2\", 9999);\n+    CService addr4 = CService(\"250.3.3.3\", 9999);\n+\n+    addrman.Add(CAddress(addr2), CService(\"250.3.1.1\", 8333));\n+    addrman.Add(CAddress(addr3), CService(\"250.3.1.1\", 8333));\n+    addrman.Add(CAddress(addr4), CService(\"250.4.1.1\", 8333));\n+\n+    // Add three addresses to tried table.\n+    CService addr5 = CService(\"250.4.4.4\", 8333);\n+    CService addr6 = CService(\"250.4.5.5\", 7777);\n+    CService addr7 = CService(\"250.4.6.6\", 8333);\n+\n+    addrman.Add(CAddress(addr5), CService(\"250.3.1.1\", 8333));\n+    addrman.Good(CAddress(addr5));\n+    addrman.Add(CAddress(addr6), CService(\"250.3.1.1\", 8333));\n+    addrman.Good(CAddress(addr6));\n+    addrman.Add(CAddress(addr7), CService(\"250.1.1.3\", 8333));\n+    addrman.Good(CAddress(addr7));\n+\n+    // Test 11: 6 addrs + 1 addr from last test = 7.\n+    BOOST_CHECK(addrman.size() == 7);\n+\n+    // Test 12: Select pulls from new and tried regardless of port number.\n+    BOOST_CHECK(addrman.Select().ToString() == \"250.4.6.6:8333\");\n+    BOOST_CHECK(addrman.Select().ToString() == \"250.3.2.2:9999\");\n+    BOOST_CHECK(addrman.Select().ToString() == \"250.3.3.3:9999\");\n+    BOOST_CHECK(addrman.Select().ToString() == \"250.4.4.4:8333\");\n }\n \n BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n@@ -123,26 +193,26 @@ BOOST_AUTO_TEST_CASE(addrman_new_collisions)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CNetAddr source = CNetAddr(\"252.2.2.2:8333\");\n+    CNetAddr source = CNetAddr(\"252.2.2.2\");\n \n     BOOST_CHECK(addrman.size() == 0);\n \n-    for (unsigned int i = 1; i < 4; i++){\n-        CService addr = CService(\"250.1.1.\"+boost::to_string(i));\n+    for (unsigned int i = 1; i < 18; i++) {\n+        CService addr = CService(\"250.1.1.\" + boost::to_string(i));\n         addrman.Add(CAddress(addr), source);\n \n-        //Test 11: No collision in new table yet.\n+        //Test 13: No collision in new table yet.\n         BOOST_CHECK(addrman.size() == i);\n     }\n \n-    //Test 12: new table collision!\n-    CService addr1 = CService(\"250.1.1.4\");\n+    //Test 14: new table collision!\n+    CService addr1 = CService(\"250.1.1.18\");\n     addrman.Add(CAddress(addr1), source);\n-    BOOST_CHECK(addrman.size() == 3);\n+    BOOST_CHECK(addrman.size() == 17);\n \n-    CService addr2 = CService(\"250.1.1.5\");\n+    CService addr2 = CService(\"250.1.1.19\");\n     addrman.Add(CAddress(addr2), source);\n-    BOOST_CHECK(addrman.size() == 4);\n+    BOOST_CHECK(addrman.size() == 18);\n }\n \n BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n@@ -152,29 +222,300 @@ BOOST_AUTO_TEST_CASE(addrman_tried_collisions)\n     // Set addrman addr placement to be deterministic.\n     addrman.MakeDeterministic();\n \n-    CNetAddr source = CNetAddr(\"252.2.2.2:8333\");\n+    CNetAddr source = CNetAddr(\"252.2.2.2\");\n \n     BOOST_CHECK(addrman.size() == 0);\n \n-    for (unsigned int i = 1; i < 75; i++){\n-        CService addr = CService(\"250.1.1.\"+boost::to_string(i));\n+    for (unsigned int i = 1; i < 80; i++) {\n+        CService addr = CService(\"250.1.1.\" + boost::to_string(i));\n         addrman.Add(CAddress(addr), source);\n         addrman.Good(CAddress(addr));\n \n-        //Test 13: No collision in tried table yet.\n+        //Test 15: No collision in tried table yet.\n         BOOST_TEST_MESSAGE(addrman.size());\n         BOOST_CHECK(addrman.size() == i);\n     }\n \n-    //Test 14: tried table collision!\n-    CService addr1 = CService(\"250.1.1.76\");\n+    //Test 16: tried table collision!\n+    CService addr1 = CService(\"250.1.1.80\");\n     addrman.Add(CAddress(addr1), source);\n-    BOOST_CHECK(addrman.size() == 74);\n+    BOOST_CHECK(addrman.size() == 79);\n \n-    CService addr2 = CService(\"250.1.1.77\");\n+    CService addr2 = CService(\"250.1.1.81\");\n     addrman.Add(CAddress(addr2), source);\n-    BOOST_CHECK(addrman.size() == 75);\n+    BOOST_CHECK(addrman.size() == 80);\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_find)\n+{\n+    CAddrManTest addrman;\n+\n+    // Set addrman addr placement to be deterministic.\n+    addrman.MakeDeterministic();\n+\n+    BOOST_CHECK(addrman.size() == 0);\n+\n+    CAddress addr1 = CAddress(CService(\"250.1.2.1\", 8333));\n+    CAddress addr2 = CAddress(CService(\"250.1.2.1\", 9999));\n+    CAddress addr3 = CAddress(CService(\"251.255.2.1\", 8333));\n+\n+    CNetAddr source1 = CNetAddr(\"250.1.2.1\");\n+    CNetAddr source2 = CNetAddr(\"250.1.2.2\");\n+\n+    addrman.Add(addr1, source1);\n+    addrman.Add(addr2, source2);\n+    addrman.Add(addr3, source1);\n+\n+    // Test 17: ensure Find returns an IP matching what we searched on.\n+    CAddrInfo* info1 = addrman.Find(addr1);\n+    BOOST_CHECK(info1);\n+    if (info1)\n+        BOOST_CHECK(info1->ToString() == \"250.1.2.1:8333\");\n+\n+    // Test 18; Find does not discriminate by port number.\n+    CAddrInfo* info2 = addrman.Find(addr2);\n+    BOOST_CHECK(info2);\n+    if (info2)\n+        BOOST_CHECK(info2->ToString() == info1->ToString());\n+\n+    // Test 19: Find returns another IP matching what we searched on.\n+    CAddrInfo* info3 = addrman.Find(addr3);\n+    BOOST_CHECK(info3);\n+    if (info3)\n+        BOOST_CHECK(info3->ToString() == \"251.255.2.1:8333\");\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_create)\n+{\n+    CAddrManTest addrman;\n+\n+    // Set addrman addr placement to be deterministic.\n+    addrman.MakeDeterministic();\n+\n+    BOOST_CHECK(addrman.size() == 0);\n+\n+    CAddress addr1 = CAddress(CService(\"250.1.2.1\", 8333));\n+    CNetAddr source1 = CNetAddr(\"250.1.2.1\");\n+\n+    int nId;\n+    CAddrInfo* pinfo = addrman.Create(addr1, source1, &nId);\n+\n+    // Test 20: The result should be the same as the input addr.\n+    BOOST_CHECK(pinfo->ToString() == \"250.1.2.1:8333\");\n+\n+    CAddrInfo* info2 = addrman.Find(addr1);\n+    BOOST_CHECK(info2->ToString() == \"250.1.2.1:8333\");\n+}\n+\n+\n+BOOST_AUTO_TEST_CASE(addrman_delete)\n+{\n+    CAddrManTest addrman;\n+\n+    // Set addrman addr placement to be deterministic.\n+    addrman.MakeDeterministic();\n+\n+    BOOST_CHECK(addrman.size() == 0);\n+\n+    CAddress addr1 = CAddress(CService(\"250.1.2.1\", 8333));\n+    CNetAddr source1 = CNetAddr(\"250.1.2.1\");\n+\n+    int nId;\n+    addrman.Create(addr1, source1, &nId);\n+\n+    // Test 21: Delete should actually delete the addr.\n+    BOOST_CHECK(addrman.size() == 1);\n+    addrman.Delete(nId);\n+    BOOST_CHECK(addrman.size() == 0);\n+    CAddrInfo* info2 = addrman.Find(addr1);\n+    BOOST_CHECK(info2 == NULL);\n+}\n+\n+BOOST_AUTO_TEST_CASE(addrman_getaddr)\n+{\n+    CAddrManTest addrman;\n+\n+    // Set addrman addr placement to be deterministic.\n+    addrman.MakeDeterministic();\n+\n+    // Test 22: Sanity check, GetAddr should never return anything if addrman\n+    //  is empty.\n+    BOOST_CHECK(addrman.size() == 0);\n+    vector<CAddress> vAddr1 = addrman.GetAddr();\n+    BOOST_CHECK(vAddr1.size() == 0);\n+\n+    CAddress addr1 = CAddress(CService(\"250.250.2.1\", 8333));\n+    addr1.nTime = GetAdjustedTime(); // Set time so isTerrible = false\n+    CAddress addr2 = CAddress(CService(\"250.251.2.2\", 9999));\n+    addr2.nTime = GetAdjustedTime();\n+    CAddress addr3 = CAddress(CService(\"251.252.2.3\", 8333));\n+    addr3.nTime = GetAdjustedTime();\n+    CAddress addr4 = CAddress(CService(\"252.253.3.4\", 8333));\n+    addr4.nTime = GetAdjustedTime();\n+    CAddress addr5 = CAddress(CService(\"252.254.4.5\", 8333));\n+    addr5.nTime = GetAdjustedTime();\n+    CNetAddr source1 = CNetAddr(\"250.1.2.1\");\n+    CNetAddr source2 = CNetAddr(\"250.2.3.3\");\n+\n+    // Test 23: Ensure GetAddr works with new addresses.\n+    addrman.Add(addr1, source1);\n+    addrman.Add(addr2, source2);\n+    addrman.Add(addr3, source1);\n+    addrman.Add(addr4, source2);\n+    addrman.Add(addr5, source1);\n+\n+    // GetAddr returns 23% of addresses, 23% of 5 is 1 rounded down.\n+    BOOST_CHECK(addrman.GetAddr().size() == 1); \n+\n+    // Test 24: Ensure GetAddr works with new and tried addresses.\n+    addrman.Good(CAddress(addr1));\n+    addrman.Good(CAddress(addr2));\n+    BOOST_CHECK(addrman.GetAddr().size() == 1);\n+\n+    // Test 25: Ensure GetAddr still returns 23% when addrman has many addrs.\n+    for (unsigned int i = 1; i < (8 * 256); i++) {\n+        int octet1 = i % 256;\n+        int octet2 = (i / 256) % 256;\n+        int octet3 = (i / (256 * 2)) % 256;\n+        string strAddr = boost::to_string(octet1) + \".\" + boost::to_string(octet2) + \".\" + boost::to_string(octet3) + \".23\";\n+        CAddress addr = CAddress(CService(strAddr));\n+        \n+        // Ensure that for all addrs in addrman, isTerrible == false.\n+        addr.nTime = GetAdjustedTime();\n+        addrman.Add(addr, CNetAddr(strAddr));\n+        if (i % 8 == 0)\n+            addrman.Good(addr);\n+    }\n+    vector<CAddress> vAddr = addrman.GetAddr();\n+\n+    size_t percent23 = (addrman.size() * 23) / 100;\n+    BOOST_CHECK(vAddr.size() == percent23);\n+    BOOST_CHECK(vAddr.size() == 461);\n+    // (Addrman.size() < number of addresses added) due to address collisons.\n+    BOOST_CHECK(addrman.size() == 2007);\n }\n \n \n+BOOST_AUTO_TEST_CASE(caddrinfo_get_tried_bucket)\n+{\n+    CAddrManTest addrman;\n+\n+    // Set addrman addr placement to be deterministic.\n+    addrman.MakeDeterministic();\n+\n+    CAddress addr1 = CAddress(CService(\"250.1.1.1\", 8333));\n+    CAddress addr2 = CAddress(CService(\"250.1.1.1\", 9999));\n+\n+    CNetAddr source1 = CNetAddr(\"250.1.1.1\");\n+\n+\n+    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+\n+    uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n+    uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n+\n+\n+    BOOST_CHECK(info1.GetTriedBucket(nKey1) == 40);\n+\n+    // Test 26: Make sure key actually randomizes bucket placement. A fail on\n+    //  this test could be a security issue.\n+    BOOST_CHECK(info1.GetTriedBucket(nKey1) != info1.GetTriedBucket(nKey2));\n+\n+    // Test 27: Two addresses with same IP but different ports can map to\n+    //  different buckets because they have different keys.\n+    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+\n+    BOOST_CHECK(info1.GetKey() != info2.GetKey());\n+    BOOST_CHECK(info1.GetTriedBucket(nKey1) != info2.GetTriedBucket(nKey1));\n+\n+    set<int> buckets;\n+    for (int i = 0; i < 255; i++) {\n+        CAddrInfo infoi = CAddrInfo(\n+            CAddress(CService(\"250.1.1.\" + boost::to_string(i))),\n+            CNetAddr(\"250.1.1.\" + boost::to_string(i)));\n+        int bucket = infoi.GetTriedBucket(nKey1);\n+        buckets.insert(bucket);\n+    }\n+    // Test 28: IP addresses in the same group (\\16 prefix for IPv4) should\n+    //  never get more than 8 buckets\n+    BOOST_CHECK(buckets.size() == 8);\n+\n+    buckets.clear();\n+    for (int j = 0; j < 255; j++) {\n+        CAddrInfo infoj = CAddrInfo(\n+            CAddress(CService(\"250.\" + boost::to_string(j) + \".1.1\")),\n+            CNetAddr(\"250.\" + boost::to_string(j) + \".1.1\"));\n+        int bucket = infoj.GetTriedBucket(nKey1);\n+        buckets.insert(bucket);\n+    }\n+    // Test 29: IP addresses in the different groups should map to more than\n+    //  8 buckets.\n+    BOOST_CHECK(buckets.size() == 160);\n+}\n+\n+BOOST_AUTO_TEST_CASE(caddrinfo_get_new_bucket)\n+{\n+    CAddrManTest addrman;\n+\n+    // Set addrman addr placement to be deterministic.\n+    addrman.MakeDeterministic();\n+\n+    CAddress addr1 = CAddress(CService(\"250.1.2.1\", 8333));\n+    CAddress addr2 = CAddress(CService(\"250.1.2.1\", 9999));\n+\n+    CNetAddr source1 = CNetAddr(\"250.1.2.1\");\n+\n+    CAddrInfo info1 = CAddrInfo(addr1, source1);\n+\n+    uint256 nKey1 = (uint256)(CHashWriter(SER_GETHASH, 0) << 1).GetHash();\n+    uint256 nKey2 = (uint256)(CHashWriter(SER_GETHASH, 0) << 2).GetHash();\n+\n+    BOOST_CHECK(info1.GetNewBucket(nKey1) == 786);\n+\n+    // Test 30: Make sure key actually randomizes bucket placement. A fail on\n+    //  this test could be a security issue.\n+    BOOST_CHECK(info1.GetNewBucket(nKey1) != info1.GetNewBucket(nKey2));\n+\n+    // Test 31: Ports should not effect bucket placement in the addr\n+    CAddrInfo info2 = CAddrInfo(addr2, source1);\n+    BOOST_CHECK(info1.GetKey() != info2.GetKey());\n+    BOOST_CHECK(info1.GetNewBucket(nKey1) == info2.GetNewBucket(nKey1));\n+\n+    set<int> buckets;\n+    for (int i = 0; i < 255; i++) {\n+        CAddrInfo infoi = CAddrInfo(\n+            CAddress(CService(\"250.1.1.\" + boost::to_string(i))),\n+            CNetAddr(\"250.1.1.\" + boost::to_string(i)));\n+        int bucket = infoi.GetNewBucket(nKey1);\n+        buckets.insert(bucket);\n+    }\n+    // Test 32: IP addresses in the same group (\\16 prefix for IPv4) should\n+    //  always map to the same bucket.\n+    BOOST_CHECK(buckets.size() == 1);\n+\n+    buckets.clear();\n+    for (int j = 0; j < 4 * 255; j++) {\n+        CAddrInfo infoj = CAddrInfo(CAddress(\n+                                        CService(\n+                                            boost::to_string(250 + (j / 255)) + \".\" + boost::to_string(j % 256) + \".1.1\")),\n+            CNetAddr(\"251.4.1.1\"));\n+        int bucket = infoj.GetNewBucket(nKey1);\n+        buckets.insert(bucket);\n+    }\n+    // Test 33: IP addresses in the same source groups should map to no more\n+    //  than 64 buckets.\n+    BOOST_CHECK(buckets.size() <= 64);\n+\n+    buckets.clear();\n+    for (int p = 0; p < 255; p++) {\n+        CAddrInfo infoj = CAddrInfo(\n+            CAddress(CService(\"250.1.1.1\")),\n+            CNetAddr(\"250.\" + boost::to_string(p) + \".1.1\"));\n+        int bucket = infoj.GetNewBucket(nKey1);\n+        buckets.insert(bucket);\n+    }\n+    // Test 34: IP addresses in the different source groups should map to more\n+    //  than 64 buckets.\n+    BOOST_CHECK(buckets.size() > 64);\n+}\n BOOST_AUTO_TEST_SUITE_END()\n\\ No newline at end of file"
      }
    ]
  }
]