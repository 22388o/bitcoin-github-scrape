[
  {
    "sha": "9b0ec1a7f9ffae816fd5ca32ff7e7559640b6f6d",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo5YjBlYzFhN2Y5ZmZhZTgxNmZkNWNhMzJmZjdlNzU1OTY0MGI2ZjZk",
    "commit": {
      "author": {
        "name": "Jim Posen",
        "email": "jim.posen@gmail.com",
        "date": "2018-05-16T00:52:09Z"
      },
      "committer": {
        "name": "Jim Posen",
        "email": "jim.posen@gmail.com",
        "date": "2018-06-05T02:22:20Z"
      },
      "message": "db: Remove obsolete methods from CBlockTreeDB.",
      "tree": {
        "sha": "0de6ce97a2f073afd51dc86b7765da03ca86f1c1",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/0de6ce97a2f073afd51dc86b7765da03ca86f1c1"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/9b0ec1a7f9ffae816fd5ca32ff7e7559640b6f6d",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b0ec1a7f9ffae816fd5ca32ff7e7559640b6f6d",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/9b0ec1a7f9ffae816fd5ca32ff7e7559640b6f6d",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b0ec1a7f9ffae816fd5ca32ff7e7559640b6f6d/comments",
    "author": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "0de7cc848e07d942e09bb3bb60189985e53d2bb5",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/0de7cc848e07d942e09bb3bb60189985e53d2bb5",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/0de7cc848e07d942e09bb3bb60189985e53d2bb5"
      }
    ],
    "stats": {
      "total": 13,
      "additions": 0,
      "deletions": 13
    },
    "files": [
      {
        "sha": "90d937d4c0ea6bde595462095a3c95fd77b68187",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 11,
        "changes": 11,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b0ec1a7f9ffae816fd5ca32ff7e7559640b6f6d/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b0ec1a7f9ffae816fd5ca32ff7e7559640b6f6d/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=9b0ec1a7f9ffae816fd5ca32ff7e7559640b6f6d",
        "patch": "@@ -237,17 +237,6 @@ bool CBlockTreeDB::WriteBatchSync(const std::vector<std::pair<int, const CBlockF\n     return WriteBatch(batch, true);\n }\n \n-bool CBlockTreeDB::ReadTxIndex(const uint256 &txid, CDiskTxPos &pos) {\n-    return Read(std::make_pair(DB_TXINDEX, txid), pos);\n-}\n-\n-bool CBlockTreeDB::WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> >&vect) {\n-    CDBBatch batch(*this);\n-    for (std::vector<std::pair<uint256,CDiskTxPos> >::const_iterator it=vect.begin(); it!=vect.end(); it++)\n-        batch.Write(std::make_pair(DB_TXINDEX, it->first), it->second);\n-    return WriteBatch(batch);\n-}\n-\n bool CBlockTreeDB::WriteFlag(const std::string &name, bool fValue) {\n     return Write(std::make_pair(DB_FLAG, name), fValue ? '1' : '0');\n }"
      },
      {
        "sha": "3c509373f46cd7bf832416b00986a67822831377",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/9b0ec1a7f9ffae816fd5ca32ff7e7559640b6f6d/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/9b0ec1a7f9ffae816fd5ca32ff7e7559640b6f6d/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=9b0ec1a7f9ffae816fd5ca32ff7e7559640b6f6d",
        "patch": "@@ -118,8 +118,6 @@ class CBlockTreeDB : public CDBWrapper\n     bool ReadLastBlockFile(int &nFile);\n     bool WriteReindexing(bool fReindexing);\n     bool ReadReindexing(bool &fReindexing);\n-    bool ReadTxIndex(const uint256 &txid, CDiskTxPos &pos);\n-    bool WriteTxIndex(const std::vector<std::pair<uint256, CDiskTxPos> > &vect);\n     bool WriteFlag(const std::string &name, bool fValue);\n     bool ReadFlag(const std::string &name, bool &fValue);\n     bool LoadBlockIndexGuts(const Consensus::Params& consensusParams, std::function<CBlockIndex*(const uint256&)> insertBlockIndex);"
      }
    ]
  },
  {
    "sha": "e5af5fc6fb4658599b940d1d50853129b31b8766",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplNWFmNWZjNmZiNDY1ODU5OWI5NDBkMWQ1MDg1MzEyOWIzMWI4NzY2",
    "commit": {
      "author": {
        "name": "Jim Posen",
        "email": "jim.posen@gmail.com",
        "date": "2018-05-15T21:57:22Z"
      },
      "committer": {
        "name": "Jim Posen",
        "email": "jim.posen@gmail.com",
        "date": "2018-06-05T02:22:21Z"
      },
      "message": "db: Make reusable base class for index databases.",
      "tree": {
        "sha": "49a664e962fe76d77e22364750cf6ca3dd0d74db",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/49a664e962fe76d77e22364750cf6ca3dd0d74db"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/e5af5fc6fb4658599b940d1d50853129b31b8766",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e5af5fc6fb4658599b940d1d50853129b31b8766",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/e5af5fc6fb4658599b940d1d50853129b31b8766",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e5af5fc6fb4658599b940d1d50853129b31b8766/comments",
    "author": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "9b0ec1a7f9ffae816fd5ca32ff7e7559640b6f6d",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/9b0ec1a7f9ffae816fd5ca32ff7e7559640b6f6d",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/9b0ec1a7f9ffae816fd5ca32ff7e7559640b6f6d"
      }
    ],
    "stats": {
      "total": 31,
      "additions": 21,
      "deletions": 10
    },
    "files": [
      {
        "sha": "624b23962a0441f74c71193b27331ab1121fa4f2",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 7,
        "deletions": 3,
        "changes": 10,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e5af5fc6fb4658599b940d1d50853129b31b8766/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e5af5fc6fb4658599b940d1d50853129b31b8766/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=e5af5fc6fb4658599b940d1d50853129b31b8766",
        "patch": "@@ -415,8 +415,12 @@ bool CCoinsViewDB::Upgrade() {\n     return !ShutdownRequested();\n }\n \n+BaseIndexDB::BaseIndexDB(const fs::path& path, size_t n_cache_size, bool f_memory, bool f_wipe, bool f_obfuscate) :\n+    CDBWrapper(path, n_cache_size, f_memory, f_wipe, f_obfuscate)\n+{}\n+\n TxIndexDB::TxIndexDB(size_t n_cache_size, bool f_memory, bool f_wipe) :\n-    CDBWrapper(GetDataDir() / \"indexes\" / \"txindex\", n_cache_size, f_memory, f_wipe)\n+    BaseIndexDB(GetDataDir() / \"indexes\" / \"txindex\", n_cache_size, f_memory, f_wipe)\n {}\n \n bool TxIndexDB::ReadTxPos(const uint256 &txid, CDiskTxPos& pos) const\n@@ -433,7 +437,7 @@ bool TxIndexDB::WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_po\n     return WriteBatch(batch);\n }\n \n-bool TxIndexDB::ReadBestBlock(CBlockLocator& locator) const\n+bool BaseIndexDB::ReadBestBlock(CBlockLocator& locator) const\n {\n     bool success = Read(DB_BEST_BLOCK, locator);\n     if (!success) {\n@@ -442,7 +446,7 @@ bool TxIndexDB::ReadBestBlock(CBlockLocator& locator) const\n     return success;\n }\n \n-bool TxIndexDB::WriteBestBlock(const CBlockLocator& locator)\n+bool BaseIndexDB::WriteBestBlock(const CBlockLocator& locator)\n {\n     return Write(DB_BEST_BLOCK, locator);\n }"
      },
      {
        "sha": "f9d9e4246cae256fbec8201d092b1c10fe885de3",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 14,
        "deletions": 7,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/e5af5fc6fb4658599b940d1d50853129b31b8766/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/e5af5fc6fb4658599b940d1d50853129b31b8766/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=e5af5fc6fb4658599b940d1d50853129b31b8766",
        "patch": "@@ -123,6 +123,19 @@ class CBlockTreeDB : public CDBWrapper\n     bool LoadBlockIndexGuts(const Consensus::Params& consensusParams, std::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n };\n \n+class BaseIndexDB : public CDBWrapper\n+{\n+public:\n+    BaseIndexDB(const fs::path& path, size_t n_cache_size,\n+                bool f_memory = false, bool f_wipe = false, bool f_obfuscate = false);\n+\n+    /// Read block locator of the chain that the index is in sync with.\n+    bool ReadBestBlock(CBlockLocator& locator) const;\n+\n+    /// Write block locator of the chain that the index is in sync with.\n+    bool WriteBestBlock(const CBlockLocator& locator);\n+};\n+\n /**\n  * Access to the txindex database (indexes/txindex/)\n  *\n@@ -132,7 +145,7 @@ class CBlockTreeDB : public CDBWrapper\n  * and block index entries may not be flushed to disk until after this database\n  * is updated.\n  */\n-class TxIndexDB : public CDBWrapper\n+class TxIndexDB : public BaseIndexDB\n {\n public:\n     explicit TxIndexDB(size_t n_cache_size, bool f_memory = false, bool f_wipe = false);\n@@ -144,12 +157,6 @@ class TxIndexDB : public CDBWrapper\n     /// Write a batch of transaction positions to the DB.\n     bool WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_pos);\n \n-    /// Read block locator of the chain that the txindex is in sync with.\n-    bool ReadBestBlock(CBlockLocator& locator) const;\n-\n-    /// Write block locator of the chain that the txindex is in sync with.\n-    bool WriteBestBlock(const CBlockLocator& locator);\n-\n     /// Migrate txindex data from the block tree DB, where it may be for older nodes that have not\n     /// been upgraded yet to the new database.\n     bool MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator& best_locator);"
      }
    ]
  },
  {
    "sha": "61a1226d87d80234b2be123c5cad07534c318cfb",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo2MWExMjI2ZDg3ZDgwMjM0YjJiZTEyM2M1Y2FkMDc1MzRjMzE4Y2Zi",
    "commit": {
      "author": {
        "name": "Jim Posen",
        "email": "jim.posen@gmail.com",
        "date": "2018-05-15T21:47:37Z"
      },
      "committer": {
        "name": "Jim Posen",
        "email": "jim.posen@gmail.com",
        "date": "2018-06-05T02:22:23Z"
      },
      "message": "index: Extract logic from TxIndex into reusable base class.",
      "tree": {
        "sha": "ff6c3c24c4216afdebbf53432699173d30b22e77",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/ff6c3c24c4216afdebbf53432699173d30b22e77"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/61a1226d87d80234b2be123c5cad07534c318cfb",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61a1226d87d80234b2be123c5cad07534c318cfb",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/61a1226d87d80234b2be123c5cad07534c318cfb",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61a1226d87d80234b2be123c5cad07534c318cfb/comments",
    "author": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "e5af5fc6fb4658599b940d1d50853129b31b8766",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/e5af5fc6fb4658599b940d1d50853129b31b8766",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/e5af5fc6fb4658599b940d1d50853129b31b8766"
      }
    ],
    "stats": {
      "total": 133,
      "additions": 80,
      "deletions": 53
    },
    "files": [
      {
        "sha": "90de0fde971d5668d7013105dae85b7d84e81121",
        "filename": "src/index/txindex.cpp",
        "status": "modified",
        "additions": 23,
        "deletions": 17,
        "changes": 40,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61a1226d87d80234b2be123c5cad07534c318cfb/src/index/txindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61a1226d87d80234b2be123c5cad07534c318cfb/src/index/txindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.cpp?ref=61a1226d87d80234b2be123c5cad07534c318cfb",
        "patch": "@@ -28,11 +28,9 @@ static void FatalError(const char* fmt, const Args&... args)\n     StartShutdown();\n }\n \n-TxIndex::TxIndex(std::unique_ptr<TxIndexDB> db) :\n-    m_db(std::move(db)), m_synced(false), m_best_block_index(nullptr)\n-{}\n+TxIndex::TxIndex(std::unique_ptr<TxIndexDB> db) : m_db(std::move(db)) {}\n \n-TxIndex::~TxIndex()\n+BaseIndex::~BaseIndex()\n {\n     Interrupt();\n     Stop();\n@@ -49,11 +47,17 @@ bool TxIndex::Init()\n         return false;\n     }\n \n+    return BaseIndex::Init();\n+}\n+\n+bool BaseIndex::Init()\n+{\n     CBlockLocator locator;\n-    if (!m_db->ReadBestBlock(locator)) {\n+    if (!GetDB().ReadBestBlock(locator)) {\n         locator.SetNull();\n     }\n \n+    LOCK(cs_main);\n     m_best_block_index = FindForkInGlobalIndex(chainActive, locator);\n     m_synced = m_best_block_index.load() == chainActive.Tip();\n     return true;\n@@ -75,7 +79,7 @@ static const CBlockIndex* NextSyncBlock(const CBlockIndex* pindex_prev)\n     return chainActive.Next(chainActive.FindFork(pindex_prev));\n }\n \n-void TxIndex::ThreadSync()\n+void BaseIndex::ThreadSync()\n {\n     const CBlockIndex* pindex = m_best_block_index.load();\n     if (!m_synced) {\n@@ -145,17 +149,19 @@ bool TxIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n     return m_db->WriteTxs(vPos);\n }\n \n-bool TxIndex::WriteBestBlock(const CBlockIndex* block_index)\n+BaseIndexDB& TxIndex::GetDB() const { return *m_db; }\n+\n+bool BaseIndex::WriteBestBlock(const CBlockIndex* block_index)\n {\n     LOCK(cs_main);\n-    if (!m_db->WriteBestBlock(chainActive.GetLocator(block_index))) {\n+    if (!GetDB().WriteBestBlock(chainActive.GetLocator(block_index))) {\n         return error(\"%s: Failed to write locator to disk\", __func__);\n     }\n     return true;\n }\n \n-void TxIndex::BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex,\n-                    const std::vector<CTransactionRef>& txn_conflicted)\n+void BaseIndex::BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex,\n+                               const std::vector<CTransactionRef>& txn_conflicted)\n {\n     if (!m_synced) {\n         return;\n@@ -192,7 +198,7 @@ void TxIndex::BlockConnected(const std::shared_ptr<const CBlock>& block, const C\n     }\n }\n \n-void TxIndex::ChainStateFlushed(const CBlockLocator& locator)\n+void BaseIndex::ChainStateFlushed(const CBlockLocator& locator)\n {\n     if (!m_synced) {\n         return;\n@@ -225,12 +231,12 @@ void TxIndex::ChainStateFlushed(const CBlockLocator& locator)\n         return;\n     }\n \n-    if (!m_db->WriteBestBlock(locator)) {\n+    if (!GetDB().WriteBestBlock(locator)) {\n         error(\"%s: Failed to write locator to disk\", __func__);\n     }\n }\n \n-bool TxIndex::BlockUntilSyncedToCurrentChain()\n+bool BaseIndex::BlockUntilSyncedToCurrentChain()\n {\n     AssertLockNotHeld(cs_main);\n \n@@ -282,12 +288,12 @@ bool TxIndex::FindTx(const uint256& tx_hash, uint256& block_hash, CTransactionRe\n     return true;\n }\n \n-void TxIndex::Interrupt()\n+void BaseIndex::Interrupt()\n {\n     m_interrupt();\n }\n \n-void TxIndex::Start()\n+void BaseIndex::Start()\n {\n     // Need to register this ValidationInterface before running Init(), so that\n     // callbacks are not missed if Init sets m_synced to true.\n@@ -298,10 +304,10 @@ void TxIndex::Start()\n     }\n \n     m_thread_sync = std::thread(&TraceThread<std::function<void()>>, \"txindex\",\n-                                std::bind(&TxIndex::ThreadSync, this));\n+                                std::bind(&BaseIndex::ThreadSync, this));\n }\n \n-void TxIndex::Stop()\n+void BaseIndex::Stop()\n {\n     UnregisterValidationInterface(this);\n "
      },
      {
        "sha": "f38d845998d504e5f4c09c3176859f0fc6d910f0",
        "filename": "src/index/txindex.h",
        "status": "modified",
        "additions": 57,
        "deletions": 36,
        "changes": 93,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/61a1226d87d80234b2be123c5cad07534c318cfb/src/index/txindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/61a1226d87d80234b2be123c5cad07534c318cfb/src/index/txindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.h?ref=61a1226d87d80234b2be123c5cad07534c318cfb",
        "patch": "@@ -15,39 +15,31 @@\n class CBlockIndex;\n \n /**\n- * TxIndex is used to look up transactions included in the blockchain by hash.\n- * The index is written to a LevelDB database and records the filesystem\n- * location of each transaction by transaction hash.\n+ * Base class for indices of blockchain data. This implements\n+ * CValidationInterface and ensures blocks are indexed sequentially according\n+ * to their position in the active chain.\n  */\n-class TxIndex final : public CValidationInterface\n+class BaseIndex : public CValidationInterface\n {\n private:\n-    const std::unique_ptr<TxIndexDB> m_db;\n-\n     /// Whether the index is in sync with the main chain. The flag is flipped\n     /// from false to true once, after which point this starts processing\n     /// ValidationInterface notifications to stay in sync.\n-    std::atomic<bool> m_synced;\n+    std::atomic<bool> m_synced{false};\n \n-    /// The last block in the chain that the TxIndex is in sync with.\n-    std::atomic<const CBlockIndex*> m_best_block_index;\n+    /// The last block in the chain that the index is in sync with.\n+    std::atomic<const CBlockIndex*> m_best_block_index{nullptr};\n \n     std::thread m_thread_sync;\n     CThreadInterrupt m_interrupt;\n \n-    /// Initialize internal state from the database and block index.\n-    bool Init();\n-\n-    /// Sync the tx index with the block index starting from the current best\n-    /// block. Intended to be run in its own thread, m_thread_sync, and can be\n-    /// interrupted with m_interrupt. Once the txindex gets in sync, the\n-    /// m_synced flag is set and the BlockConnected ValidationInterface callback\n-    /// takes over and the sync thread exits.\n+    /// Sync the index with the block index starting from the current best block.\n+    /// Intended to be run in its own thread, m_thread_sync, and can be\n+    /// interrupted with m_interrupt. Once the index gets in sync, the m_synced\n+    /// flag is set and the BlockConnected ValidationInterface callback takes\n+    /// over and the sync thread exits.\n     void ThreadSync();\n \n-    /// Write update index entries for a newly connected block.\n-    bool WriteBlock(const CBlock& block, const CBlockIndex* pindex);\n-\n     /// Write the current chain block locator to the DB.\n     bool WriteBestBlock(const CBlockIndex* block_index);\n \n@@ -57,27 +49,25 @@ class TxIndex final : public CValidationInterface\n \n     void ChainStateFlushed(const CBlockLocator& locator) override;\n \n-public:\n-    /// Constructs the TxIndex, which becomes available to be queried.\n-    explicit TxIndex(std::unique_ptr<TxIndexDB> db);\n+    /// Initialize internal state from the database and block index.\n+    virtual bool Init();\n \n+    /// Write update index entries for a newly connected block.\n+    virtual bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) { return true; }\n+\n+    virtual BaseIndexDB& GetDB() const = 0;\n+\n+public:\n     /// Destructor interrupts sync thread if running and blocks until it exits.\n-    ~TxIndex();\n+    virtual ~BaseIndex();\n \n-    /// Blocks the current thread until the transaction index is caught up to\n-    /// the current state of the block chain. This only blocks if the index has gotten in sync once\n-    /// and only needs to process blocks in the ValidationInterface queue. If the index is catching\n-    /// up from far behind, this method does not block and immediately returns false.\n+    /// Blocks the current thread until the index is caught up to the current\n+    /// state of the block chain. This only blocks if the index has gotten in\n+    /// sync once and only needs to process blocks in the ValidationInterface\n+    /// queue. If the index is catching up from far behind, this method does\n+    /// not block and immediately returns false.\n     bool BlockUntilSyncedToCurrentChain();\n \n-    /// Look up a transaction by hash.\n-    ///\n-    /// @param[in]   tx_hash  The hash of the transaction to be returned.\n-    /// @param[out]  block_hash  The hash of the block the transaction is found in.\n-    /// @param[out]  tx  The transaction itself.\n-    /// @return  true if transaction is found, false otherwise\n-    bool FindTx(const uint256& tx_hash, uint256& block_hash, CTransactionRef& tx) const;\n-\n     void Interrupt();\n \n     /// Start initializes the sync state and registers the instance as a\n@@ -88,6 +78,37 @@ class TxIndex final : public CValidationInterface\n     void Stop();\n };\n \n+/**\n+ * TxIndex is used to look up transactions included in the blockchain by hash.\n+ * The index is written to a LevelDB database and records the filesystem\n+ * location of each transaction by transaction hash.\n+ */\n+class TxIndex final : public BaseIndex\n+{\n+private:\n+    const std::unique_ptr<TxIndexDB> m_db;\n+\n+protected:\n+    /// Override base class init to migrate from old database.\n+    bool Init() override;\n+\n+    bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) override;\n+\n+    BaseIndexDB& GetDB() const override;\n+\n+public:\n+    /// Constructs the index, which becomes available to be queried.\n+    explicit TxIndex(std::unique_ptr<TxIndexDB> db);\n+\n+    /// Look up a transaction by hash.\n+    ///\n+    /// @param[in]   tx_hash  The hash of the transaction to be returned.\n+    /// @param[out]  block_hash  The hash of the block the transaction is found in.\n+    /// @param[out]  tx  The transaction itself.\n+    /// @return  true if transaction is found, false otherwise\n+    bool FindTx(const uint256& tx_hash, uint256& block_hash, CTransactionRef& tx) const;\n+};\n+\n /// The global transaction index, used in GetTransaction. May be null.\n extern std::unique_ptr<TxIndex> g_txindex;\n "
      }
    ]
  },
  {
    "sha": "f376a4924109af2496b5fd16a787299eb039f1c8",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzpmMzc2YTQ5MjQxMDlhZjI0OTZiNWZkMTZhNzg3Mjk5ZWIwMzlmMWM4",
    "commit": {
      "author": {
        "name": "Jim Posen",
        "email": "jim.posen@gmail.com",
        "date": "2018-05-15T22:45:20Z"
      },
      "committer": {
        "name": "Jim Posen",
        "email": "jim.posen@gmail.com",
        "date": "2018-06-05T02:22:24Z"
      },
      "message": "index: Generalize logged statements in BaseIndex.",
      "tree": {
        "sha": "925e460c230e5c061b21e1782e5ec56944cca29e",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/925e460c230e5c061b21e1782e5ec56944cca29e"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/f376a4924109af2496b5fd16a787299eb039f1c8",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f376a4924109af2496b5fd16a787299eb039f1c8",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/f376a4924109af2496b5fd16a787299eb039f1c8",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f376a4924109af2496b5fd16a787299eb039f1c8/comments",
    "author": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "61a1226d87d80234b2be123c5cad07534c318cfb",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/61a1226d87d80234b2be123c5cad07534c318cfb",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/61a1226d87d80234b2be123c5cad07534c318cfb"
      }
    ],
    "stats": {
      "total": 26,
      "additions": 16,
      "deletions": 10
    },
    "files": [
      {
        "sha": "4434ce3f21648eff3613e7056904174b82c0efaf",
        "filename": "src/index/txindex.cpp",
        "status": "modified",
        "additions": 11,
        "deletions": 10,
        "changes": 21,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f376a4924109af2496b5fd16a787299eb039f1c8/src/index/txindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f376a4924109af2496b5fd16a787299eb039f1c8/src/index/txindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.cpp?ref=f376a4924109af2496b5fd16a787299eb039f1c8",
        "patch": "@@ -107,7 +107,8 @@ void BaseIndex::ThreadSync()\n \n             int64_t current_time = GetTime();\n             if (last_log_time + SYNC_LOG_INTERVAL < current_time) {\n-                LogPrintf(\"Syncing txindex with block chain from height %d\\n\", pindex->nHeight);\n+                LogPrintf(\"Syncing %s with block chain from height %d\\n\",\n+                          GetName(), pindex->nHeight);\n                 last_log_time = current_time;\n             }\n \n@@ -123,17 +124,17 @@ void BaseIndex::ThreadSync()\n                 return;\n             }\n             if (!WriteBlock(block, pindex)) {\n-                FatalError(\"%s: Failed to write block %s to tx index database\",\n+                FatalError(\"%s: Failed to write block %s to index database\",\n                            __func__, pindex->GetBlockHash().ToString());\n                 return;\n             }\n         }\n     }\n \n     if (pindex) {\n-        LogPrintf(\"txindex is enabled at height %d\\n\", pindex->nHeight);\n+        LogPrintf(\"%s is enabled at height %d\\n\", GetName(), pindex->nHeight);\n     } else {\n-        LogPrintf(\"txindex is enabled\\n\");\n+        LogPrintf(\"%s is enabled\\n\", GetName());\n     }\n }\n \n@@ -182,7 +183,7 @@ void BaseIndex::BlockConnected(const std::shared_ptr<const CBlock>& block, const\n         // new chain tip. In this unlikely event, log a warning and let the queue clear.\n         if (best_block_index->GetAncestor(pindex->nHeight - 1) != pindex->pprev) {\n             LogPrintf(\"%s: WARNING: Block %s does not connect to an ancestor of \" /* Continued */\n-                      \"known best chain (tip=%s); not updating txindex\\n\",\n+                      \"known best chain (tip=%s); not updating index\\n\",\n                       __func__, pindex->GetBlockHash().ToString(),\n                       best_block_index->GetBlockHash().ToString());\n             return;\n@@ -192,7 +193,7 @@ void BaseIndex::BlockConnected(const std::shared_ptr<const CBlock>& block, const\n     if (WriteBlock(*block, pindex)) {\n         m_best_block_index = pindex;\n     } else {\n-        FatalError(\"%s: Failed to write block %s to txindex\",\n+        FatalError(\"%s: Failed to write block %s to index\",\n                    __func__, pindex->GetBlockHash().ToString());\n         return;\n     }\n@@ -225,7 +226,7 @@ void BaseIndex::ChainStateFlushed(const CBlockLocator& locator)\n     const CBlockIndex* best_block_index = m_best_block_index.load();\n     if (best_block_index->GetAncestor(locator_tip_index->nHeight) != locator_tip_index) {\n         LogPrintf(\"%s: WARNING: Locator contains block (hash=%s) not on known best \" /* Continued */\n-                  \"chain (tip=%s); not writing txindex locator\\n\",\n+                  \"chain (tip=%s); not writing index locator\\n\",\n                   __func__, locator_tip_hash.ToString(),\n                   best_block_index->GetBlockHash().ToString());\n         return;\n@@ -255,7 +256,7 @@ bool BaseIndex::BlockUntilSyncedToCurrentChain()\n         }\n     }\n \n-    LogPrintf(\"%s: txindex is catching up on block notifications\\n\", __func__);\n+    LogPrintf(\"%s: %s is catching up on block notifications\\n\", __func__, GetName());\n     SyncWithValidationInterfaceQueue();\n     return true;\n }\n@@ -299,11 +300,11 @@ void BaseIndex::Start()\n     // callbacks are not missed if Init sets m_synced to true.\n     RegisterValidationInterface(this);\n     if (!Init()) {\n-        FatalError(\"%s: txindex failed to initialize\", __func__);\n+        FatalError(\"%s: %s failed to initialize\", __func__, GetName());\n         return;\n     }\n \n-    m_thread_sync = std::thread(&TraceThread<std::function<void()>>, \"txindex\",\n+    m_thread_sync = std::thread(&TraceThread<std::function<void()>>, GetName(),\n                                 std::bind(&BaseIndex::ThreadSync, this));\n }\n "
      },
      {
        "sha": "29626332ab939711b324f91d0aa94c4302820bed",
        "filename": "src/index/txindex.h",
        "status": "modified",
        "additions": 5,
        "deletions": 0,
        "changes": 5,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/f376a4924109af2496b5fd16a787299eb039f1c8/src/index/txindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/f376a4924109af2496b5fd16a787299eb039f1c8/src/index/txindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.h?ref=f376a4924109af2496b5fd16a787299eb039f1c8",
        "patch": "@@ -57,6 +57,9 @@ class BaseIndex : public CValidationInterface\n \n     virtual BaseIndexDB& GetDB() const = 0;\n \n+    /// Get the name of the index for display in logs.\n+    virtual const char* GetName() const = 0;\n+\n public:\n     /// Destructor interrupts sync thread if running and blocks until it exits.\n     virtual ~BaseIndex();\n@@ -96,6 +99,8 @@ class TxIndex final : public BaseIndex\n \n     BaseIndexDB& GetDB() const override;\n \n+    const char* GetName() const override { return \"txindex\"; }\n+\n public:\n     /// Constructs the index, which becomes available to be queried.\n     explicit TxIndex(std::unique_ptr<TxIndexDB> db);"
      }
    ]
  },
  {
    "sha": "2318affd27de436ddf9d866a4b82eed8ea2e738b",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzoyMzE4YWZmZDI3ZGU0MzZkZGY5ZDg2NmE0YjgyZWVkOGVhMmU3Mzhi",
    "commit": {
      "author": {
        "name": "Jim Posen",
        "email": "jim.posen@gmail.com",
        "date": "2018-05-15T22:57:48Z"
      },
      "committer": {
        "name": "Jim Posen",
        "email": "jim.posen@gmail.com",
        "date": "2018-06-05T02:22:26Z"
      },
      "message": "MOVEONLY: Move BaseIndex to its own file.",
      "tree": {
        "sha": "014e8cc6347c5668c002961fefef7ed01243f5cd",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/014e8cc6347c5668c002961fefef7ed01243f5cd"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/2318affd27de436ddf9d866a4b82eed8ea2e738b",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2318affd27de436ddf9d866a4b82eed8ea2e738b",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/2318affd27de436ddf9d866a4b82eed8ea2e738b",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2318affd27de436ddf9d866a4b82eed8ea2e738b/comments",
    "author": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "f376a4924109af2496b5fd16a787299eb039f1c8",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/f376a4924109af2496b5fd16a787299eb039f1c8",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/f376a4924109af2496b5fd16a787299eb039f1c8"
      }
    ],
    "stats": {
      "total": 671,
      "additions": 345,
      "deletions": 326
    },
    "files": [
      {
        "sha": "9462c407a1381b6eaddb1f47c11bb1fb49371031",
        "filename": "src/Makefile.am",
        "status": "modified",
        "additions": 2,
        "deletions": 0,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2318affd27de436ddf9d866a4b82eed8ea2e738b/src/Makefile.am",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2318affd27de436ddf9d866a4b82eed8ea2e738b/src/Makefile.am",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/Makefile.am?ref=2318affd27de436ddf9d866a4b82eed8ea2e738b",
        "patch": "@@ -107,6 +107,7 @@ BITCOIN_CORE_H = \\\n   fs.h \\\n   httprpc.h \\\n   httpserver.h \\\n+  index/base.h \\\n   index/txindex.h \\\n   indirectmap.h \\\n   init.h \\\n@@ -208,6 +209,7 @@ libbitcoin_server_a_SOURCES = \\\n   consensus/tx_verify.cpp \\\n   httprpc.cpp \\\n   httpserver.cpp \\\n+  index/base.cpp \\\n   index/txindex.cpp \\\n   init.cpp \\\n   dbwrapper.cpp \\"
      },
      {
        "sha": "f381681a640be380b75735866645823e8281283f",
        "filename": "src/index/base.cpp",
        "status": "added",
        "additions": 258,
        "deletions": 0,
        "changes": 258,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2318affd27de436ddf9d866a4b82eed8ea2e738b/src/index/base.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2318affd27de436ddf9d866a4b82eed8ea2e738b/src/index/base.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.cpp?ref=2318affd27de436ddf9d866a4b82eed8ea2e738b",
        "patch": "@@ -0,0 +1,258 @@\n+// Copyright (c) 2017-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#include <chainparams.h>\n+#include <index/base.h>\n+#include <init.h>\n+#include <tinyformat.h>\n+#include <ui_interface.h>\n+#include <util.h>\n+#include <validation.h>\n+#include <warnings.h>\n+\n+constexpr int64_t SYNC_LOG_INTERVAL = 30; // seconds\n+constexpr int64_t SYNC_LOCATOR_WRITE_INTERVAL = 30; // seconds\n+\n+template<typename... Args>\n+static void FatalError(const char* fmt, const Args&... args)\n+{\n+    std::string strMessage = tfm::format(fmt, args...);\n+    SetMiscWarning(strMessage);\n+    LogPrintf(\"*** %s\\n\", strMessage);\n+    uiInterface.ThreadSafeMessageBox(\n+        \"Error: A fatal internal error occurred, see debug.log for details\",\n+        \"\", CClientUIInterface::MSG_ERROR);\n+    StartShutdown();\n+}\n+\n+BaseIndex::~BaseIndex()\n+{\n+    Interrupt();\n+    Stop();\n+}\n+\n+bool BaseIndex::Init()\n+{\n+    CBlockLocator locator;\n+    if (!GetDB().ReadBestBlock(locator)) {\n+        locator.SetNull();\n+    }\n+\n+    LOCK(cs_main);\n+    m_best_block_index = FindForkInGlobalIndex(chainActive, locator);\n+    m_synced = m_best_block_index.load() == chainActive.Tip();\n+    return true;\n+}\n+\n+static const CBlockIndex* NextSyncBlock(const CBlockIndex* pindex_prev)\n+{\n+    AssertLockHeld(cs_main);\n+\n+    if (!pindex_prev) {\n+        return chainActive.Genesis();\n+    }\n+\n+    const CBlockIndex* pindex = chainActive.Next(pindex_prev);\n+    if (pindex) {\n+        return pindex;\n+    }\n+\n+    return chainActive.Next(chainActive.FindFork(pindex_prev));\n+}\n+\n+void BaseIndex::ThreadSync()\n+{\n+    const CBlockIndex* pindex = m_best_block_index.load();\n+    if (!m_synced) {\n+        auto& consensus_params = Params().GetConsensus();\n+\n+        int64_t last_log_time = 0;\n+        int64_t last_locator_write_time = 0;\n+        while (true) {\n+            if (m_interrupt) {\n+                WriteBestBlock(pindex);\n+                return;\n+            }\n+\n+            {\n+                LOCK(cs_main);\n+                const CBlockIndex* pindex_next = NextSyncBlock(pindex);\n+                if (!pindex_next) {\n+                    WriteBestBlock(pindex);\n+                    m_best_block_index = pindex;\n+                    m_synced = true;\n+                    break;\n+                }\n+                pindex = pindex_next;\n+            }\n+\n+            int64_t current_time = GetTime();\n+            if (last_log_time + SYNC_LOG_INTERVAL < current_time) {\n+                LogPrintf(\"Syncing %s with block chain from height %d\\n\",\n+                          GetName(), pindex->nHeight);\n+                last_log_time = current_time;\n+            }\n+\n+            if (last_locator_write_time + SYNC_LOCATOR_WRITE_INTERVAL < current_time) {\n+                WriteBestBlock(pindex);\n+                last_locator_write_time = current_time;\n+            }\n+\n+            CBlock block;\n+            if (!ReadBlockFromDisk(block, pindex, consensus_params)) {\n+                FatalError(\"%s: Failed to read block %s from disk\",\n+                           __func__, pindex->GetBlockHash().ToString());\n+                return;\n+            }\n+            if (!WriteBlock(block, pindex)) {\n+                FatalError(\"%s: Failed to write block %s to index database\",\n+                           __func__, pindex->GetBlockHash().ToString());\n+                return;\n+            }\n+        }\n+    }\n+\n+    if (pindex) {\n+        LogPrintf(\"%s is enabled at height %d\\n\", GetName(), pindex->nHeight);\n+    } else {\n+        LogPrintf(\"%s is enabled\\n\", GetName());\n+    }\n+}\n+\n+bool BaseIndex::WriteBestBlock(const CBlockIndex* block_index)\n+{\n+    LOCK(cs_main);\n+    if (!GetDB().WriteBestBlock(chainActive.GetLocator(block_index))) {\n+        return error(\"%s: Failed to write locator to disk\", __func__);\n+    }\n+    return true;\n+}\n+\n+void BaseIndex::BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex,\n+                               const std::vector<CTransactionRef>& txn_conflicted)\n+{\n+    if (!m_synced) {\n+        return;\n+    }\n+\n+    const CBlockIndex* best_block_index = m_best_block_index.load();\n+    if (!best_block_index) {\n+        if (pindex->nHeight != 0) {\n+            FatalError(\"%s: First block connected is not the genesis block (height=%d)\",\n+                       __func__, pindex->nHeight);\n+            return;\n+        }\n+    } else {\n+        // Ensure block connects to an ancestor of the current best block. This should be the case\n+        // most of the time, but may not be immediately after the sync thread catches up and sets\n+        // m_synced. Consider the case where there is a reorg and the blocks on the stale branch are\n+        // in the ValidationInterface queue backlog even after the sync thread has caught up to the\n+        // new chain tip. In this unlikely event, log a warning and let the queue clear.\n+        if (best_block_index->GetAncestor(pindex->nHeight - 1) != pindex->pprev) {\n+            LogPrintf(\"%s: WARNING: Block %s does not connect to an ancestor of \" /* Continued */\n+                      \"known best chain (tip=%s); not updating index\\n\",\n+                      __func__, pindex->GetBlockHash().ToString(),\n+                      best_block_index->GetBlockHash().ToString());\n+            return;\n+        }\n+    }\n+\n+    if (WriteBlock(*block, pindex)) {\n+        m_best_block_index = pindex;\n+    } else {\n+        FatalError(\"%s: Failed to write block %s to index\",\n+                   __func__, pindex->GetBlockHash().ToString());\n+        return;\n+    }\n+}\n+\n+void BaseIndex::ChainStateFlushed(const CBlockLocator& locator)\n+{\n+    if (!m_synced) {\n+        return;\n+    }\n+\n+    const uint256& locator_tip_hash = locator.vHave.front();\n+    const CBlockIndex* locator_tip_index;\n+    {\n+        LOCK(cs_main);\n+        locator_tip_index = LookupBlockIndex(locator_tip_hash);\n+    }\n+\n+    if (!locator_tip_index) {\n+        FatalError(\"%s: First block (hash=%s) in locator was not found\",\n+                   __func__, locator_tip_hash.ToString());\n+        return;\n+    }\n+\n+    // This checks that ChainStateFlushed callbacks are received after BlockConnected. The check may fail\n+    // immediately after the sync thread catches up and sets m_synced. Consider the case where\n+    // there is a reorg and the blocks on the stale branch are in the ValidationInterface queue\n+    // backlog even after the sync thread has caught up to the new chain tip. In this unlikely\n+    // event, log a warning and let the queue clear.\n+    const CBlockIndex* best_block_index = m_best_block_index.load();\n+    if (best_block_index->GetAncestor(locator_tip_index->nHeight) != locator_tip_index) {\n+        LogPrintf(\"%s: WARNING: Locator contains block (hash=%s) not on known best \" /* Continued */\n+                  \"chain (tip=%s); not writing index locator\\n\",\n+                  __func__, locator_tip_hash.ToString(),\n+                  best_block_index->GetBlockHash().ToString());\n+        return;\n+    }\n+\n+    if (!GetDB().WriteBestBlock(locator)) {\n+        error(\"%s: Failed to write locator to disk\", __func__);\n+    }\n+}\n+\n+bool BaseIndex::BlockUntilSyncedToCurrentChain()\n+{\n+    AssertLockNotHeld(cs_main);\n+\n+    if (!m_synced) {\n+        return false;\n+    }\n+\n+    {\n+        // Skip the queue-draining stuff if we know we're caught up with\n+        // chainActive.Tip().\n+        LOCK(cs_main);\n+        const CBlockIndex* chain_tip = chainActive.Tip();\n+        const CBlockIndex* best_block_index = m_best_block_index.load();\n+        if (best_block_index->GetAncestor(chain_tip->nHeight) == chain_tip) {\n+            return true;\n+        }\n+    }\n+\n+    LogPrintf(\"%s: %s is catching up on block notifications\\n\", __func__, GetName());\n+    SyncWithValidationInterfaceQueue();\n+    return true;\n+}\n+\n+void BaseIndex::Interrupt()\n+{\n+    m_interrupt();\n+}\n+\n+void BaseIndex::Start()\n+{\n+    // Need to register this ValidationInterface before running Init(), so that\n+    // callbacks are not missed if Init sets m_synced to true.\n+    RegisterValidationInterface(this);\n+    if (!Init()) {\n+        FatalError(\"%s: %s failed to initialize\", __func__, GetName());\n+        return;\n+    }\n+\n+    m_thread_sync = std::thread(&TraceThread<std::function<void()>>, GetName(),\n+                                std::bind(&BaseIndex::ThreadSync, this));\n+}\n+\n+void BaseIndex::Stop()\n+{\n+    UnregisterValidationInterface(this);\n+\n+    if (m_thread_sync.joinable()) {\n+        m_thread_sync.join();\n+    }\n+}"
      },
      {
        "sha": "68efaaaf265b2505358961a8c9942768339dfcfc",
        "filename": "src/index/base.h",
        "status": "added",
        "additions": 84,
        "deletions": 0,
        "changes": 84,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2318affd27de436ddf9d866a4b82eed8ea2e738b/src/index/base.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2318affd27de436ddf9d866a4b82eed8ea2e738b/src/index/base.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.h?ref=2318affd27de436ddf9d866a4b82eed8ea2e738b",
        "patch": "@@ -0,0 +1,84 @@\n+// Copyright (c) 2017-2018 The Bitcoin Core developers\n+// Distributed under the MIT software license, see the accompanying\n+// file COPYING or http://www.opensource.org/licenses/mit-license.php.\n+\n+#ifndef BITCOIN_INDEX_BASE_H\n+#define BITCOIN_INDEX_BASE_H\n+\n+#include <primitives/block.h>\n+#include <primitives/transaction.h>\n+#include <threadinterrupt.h>\n+#include <txdb.h>\n+#include <uint256.h>\n+#include <validationinterface.h>\n+\n+class CBlockIndex;\n+\n+/**\n+ * Base class for indices of blockchain data. This implements\n+ * CValidationInterface and ensures blocks are indexed sequentially according\n+ * to their position in the active chain.\n+ */\n+class BaseIndex : public CValidationInterface\n+{\n+private:\n+    /// Whether the index is in sync with the main chain. The flag is flipped\n+    /// from false to true once, after which point this starts processing\n+    /// ValidationInterface notifications to stay in sync.\n+    std::atomic<bool> m_synced{false};\n+\n+    /// The last block in the chain that the index is in sync with.\n+    std::atomic<const CBlockIndex*> m_best_block_index{nullptr};\n+\n+    std::thread m_thread_sync;\n+    CThreadInterrupt m_interrupt;\n+\n+    /// Sync the index with the block index starting from the current best block.\n+    /// Intended to be run in its own thread, m_thread_sync, and can be\n+    /// interrupted with m_interrupt. Once the index gets in sync, the m_synced\n+    /// flag is set and the BlockConnected ValidationInterface callback takes\n+    /// over and the sync thread exits.\n+    void ThreadSync();\n+\n+    /// Write the current chain block locator to the DB.\n+    bool WriteBestBlock(const CBlockIndex* block_index);\n+\n+protected:\n+    void BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex,\n+                        const std::vector<CTransactionRef>& txn_conflicted) override;\n+\n+    void ChainStateFlushed(const CBlockLocator& locator) override;\n+\n+    /// Initialize internal state from the database and block index.\n+    virtual bool Init();\n+\n+    /// Write update index entries for a newly connected block.\n+    virtual bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) { return true; }\n+\n+    virtual BaseIndexDB& GetDB() const = 0;\n+\n+    /// Get the name of the index for display in logs.\n+    virtual const char* GetName() const = 0;\n+\n+public:\n+    /// Destructor interrupts sync thread if running and blocks until it exits.\n+    virtual ~BaseIndex();\n+\n+    /// Blocks the current thread until the index is caught up to the current\n+    /// state of the block chain. This only blocks if the index has gotten in\n+    /// sync once and only needs to process blocks in the ValidationInterface\n+    /// queue. If the index is catching up from far behind, this method does\n+    /// not block and immediately returns false.\n+    bool BlockUntilSyncedToCurrentChain();\n+\n+    void Interrupt();\n+\n+    /// Start initializes the sync state and registers the instance as a\n+    /// ValidationInterface so that it stays in sync with blockchain updates.\n+    void Start();\n+\n+    /// Stops the instance from staying in sync with blockchain updates.\n+    void Stop();\n+};\n+\n+#endif // BITCOIN_INDEX_BASE_H"
      },
      {
        "sha": "7d3d2fed523c9ac9b64942df9a4286b41a90b2b7",
        "filename": "src/index/txindex.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 251,
        "changes": 251,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2318affd27de436ddf9d866a4b82eed8ea2e738b/src/index/txindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2318affd27de436ddf9d866a4b82eed8ea2e738b/src/index/txindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.cpp?ref=2318affd27de436ddf9d866a4b82eed8ea2e738b",
        "patch": "@@ -2,40 +2,14 @@\n // Distributed under the MIT software license, see the accompanying\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n-#include <chainparams.h>\n #include <index/txindex.h>\n-#include <init.h>\n-#include <tinyformat.h>\n-#include <ui_interface.h>\n #include <util.h>\n #include <validation.h>\n-#include <warnings.h>\n-\n-constexpr int64_t SYNC_LOG_INTERVAL = 30; // seconds\n-constexpr int64_t SYNC_LOCATOR_WRITE_INTERVAL = 30; // seconds\n \n std::unique_ptr<TxIndex> g_txindex;\n \n-template<typename... Args>\n-static void FatalError(const char* fmt, const Args&... args)\n-{\n-    std::string strMessage = tfm::format(fmt, args...);\n-    SetMiscWarning(strMessage);\n-    LogPrintf(\"*** %s\\n\", strMessage);\n-    uiInterface.ThreadSafeMessageBox(\n-        \"Error: A fatal internal error occurred, see debug.log for details\",\n-        \"\", CClientUIInterface::MSG_ERROR);\n-    StartShutdown();\n-}\n-\n TxIndex::TxIndex(std::unique_ptr<TxIndexDB> db) : m_db(std::move(db)) {}\n \n-BaseIndex::~BaseIndex()\n-{\n-    Interrupt();\n-    Stop();\n-}\n-\n bool TxIndex::Init()\n {\n     LOCK(cs_main);\n@@ -50,94 +24,6 @@ bool TxIndex::Init()\n     return BaseIndex::Init();\n }\n \n-bool BaseIndex::Init()\n-{\n-    CBlockLocator locator;\n-    if (!GetDB().ReadBestBlock(locator)) {\n-        locator.SetNull();\n-    }\n-\n-    LOCK(cs_main);\n-    m_best_block_index = FindForkInGlobalIndex(chainActive, locator);\n-    m_synced = m_best_block_index.load() == chainActive.Tip();\n-    return true;\n-}\n-\n-static const CBlockIndex* NextSyncBlock(const CBlockIndex* pindex_prev)\n-{\n-    AssertLockHeld(cs_main);\n-\n-    if (!pindex_prev) {\n-        return chainActive.Genesis();\n-    }\n-\n-    const CBlockIndex* pindex = chainActive.Next(pindex_prev);\n-    if (pindex) {\n-        return pindex;\n-    }\n-\n-    return chainActive.Next(chainActive.FindFork(pindex_prev));\n-}\n-\n-void BaseIndex::ThreadSync()\n-{\n-    const CBlockIndex* pindex = m_best_block_index.load();\n-    if (!m_synced) {\n-        auto& consensus_params = Params().GetConsensus();\n-\n-        int64_t last_log_time = 0;\n-        int64_t last_locator_write_time = 0;\n-        while (true) {\n-            if (m_interrupt) {\n-                WriteBestBlock(pindex);\n-                return;\n-            }\n-\n-            {\n-                LOCK(cs_main);\n-                const CBlockIndex* pindex_next = NextSyncBlock(pindex);\n-                if (!pindex_next) {\n-                    WriteBestBlock(pindex);\n-                    m_best_block_index = pindex;\n-                    m_synced = true;\n-                    break;\n-                }\n-                pindex = pindex_next;\n-            }\n-\n-            int64_t current_time = GetTime();\n-            if (last_log_time + SYNC_LOG_INTERVAL < current_time) {\n-                LogPrintf(\"Syncing %s with block chain from height %d\\n\",\n-                          GetName(), pindex->nHeight);\n-                last_log_time = current_time;\n-            }\n-\n-            if (last_locator_write_time + SYNC_LOCATOR_WRITE_INTERVAL < current_time) {\n-                WriteBestBlock(pindex);\n-                last_locator_write_time = current_time;\n-            }\n-\n-            CBlock block;\n-            if (!ReadBlockFromDisk(block, pindex, consensus_params)) {\n-                FatalError(\"%s: Failed to read block %s from disk\",\n-                           __func__, pindex->GetBlockHash().ToString());\n-                return;\n-            }\n-            if (!WriteBlock(block, pindex)) {\n-                FatalError(\"%s: Failed to write block %s to index database\",\n-                           __func__, pindex->GetBlockHash().ToString());\n-                return;\n-            }\n-        }\n-    }\n-\n-    if (pindex) {\n-        LogPrintf(\"%s is enabled at height %d\\n\", GetName(), pindex->nHeight);\n-    } else {\n-        LogPrintf(\"%s is enabled\\n\", GetName());\n-    }\n-}\n-\n bool TxIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n {\n     CDiskTxPos pos(pindex->GetBlockPos(), GetSizeOfCompactSize(block.vtx.size()));\n@@ -152,115 +38,6 @@ bool TxIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n \n BaseIndexDB& TxIndex::GetDB() const { return *m_db; }\n \n-bool BaseIndex::WriteBestBlock(const CBlockIndex* block_index)\n-{\n-    LOCK(cs_main);\n-    if (!GetDB().WriteBestBlock(chainActive.GetLocator(block_index))) {\n-        return error(\"%s: Failed to write locator to disk\", __func__);\n-    }\n-    return true;\n-}\n-\n-void BaseIndex::BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex,\n-                               const std::vector<CTransactionRef>& txn_conflicted)\n-{\n-    if (!m_synced) {\n-        return;\n-    }\n-\n-    const CBlockIndex* best_block_index = m_best_block_index.load();\n-    if (!best_block_index) {\n-        if (pindex->nHeight != 0) {\n-            FatalError(\"%s: First block connected is not the genesis block (height=%d)\",\n-                       __func__, pindex->nHeight);\n-            return;\n-        }\n-    } else {\n-        // Ensure block connects to an ancestor of the current best block. This should be the case\n-        // most of the time, but may not be immediately after the sync thread catches up and sets\n-        // m_synced. Consider the case where there is a reorg and the blocks on the stale branch are\n-        // in the ValidationInterface queue backlog even after the sync thread has caught up to the\n-        // new chain tip. In this unlikely event, log a warning and let the queue clear.\n-        if (best_block_index->GetAncestor(pindex->nHeight - 1) != pindex->pprev) {\n-            LogPrintf(\"%s: WARNING: Block %s does not connect to an ancestor of \" /* Continued */\n-                      \"known best chain (tip=%s); not updating index\\n\",\n-                      __func__, pindex->GetBlockHash().ToString(),\n-                      best_block_index->GetBlockHash().ToString());\n-            return;\n-        }\n-    }\n-\n-    if (WriteBlock(*block, pindex)) {\n-        m_best_block_index = pindex;\n-    } else {\n-        FatalError(\"%s: Failed to write block %s to index\",\n-                   __func__, pindex->GetBlockHash().ToString());\n-        return;\n-    }\n-}\n-\n-void BaseIndex::ChainStateFlushed(const CBlockLocator& locator)\n-{\n-    if (!m_synced) {\n-        return;\n-    }\n-\n-    const uint256& locator_tip_hash = locator.vHave.front();\n-    const CBlockIndex* locator_tip_index;\n-    {\n-        LOCK(cs_main);\n-        locator_tip_index = LookupBlockIndex(locator_tip_hash);\n-    }\n-\n-    if (!locator_tip_index) {\n-        FatalError(\"%s: First block (hash=%s) in locator was not found\",\n-                   __func__, locator_tip_hash.ToString());\n-        return;\n-    }\n-\n-    // This checks that ChainStateFlushed callbacks are received after BlockConnected. The check may fail\n-    // immediately after the sync thread catches up and sets m_synced. Consider the case where\n-    // there is a reorg and the blocks on the stale branch are in the ValidationInterface queue\n-    // backlog even after the sync thread has caught up to the new chain tip. In this unlikely\n-    // event, log a warning and let the queue clear.\n-    const CBlockIndex* best_block_index = m_best_block_index.load();\n-    if (best_block_index->GetAncestor(locator_tip_index->nHeight) != locator_tip_index) {\n-        LogPrintf(\"%s: WARNING: Locator contains block (hash=%s) not on known best \" /* Continued */\n-                  \"chain (tip=%s); not writing index locator\\n\",\n-                  __func__, locator_tip_hash.ToString(),\n-                  best_block_index->GetBlockHash().ToString());\n-        return;\n-    }\n-\n-    if (!GetDB().WriteBestBlock(locator)) {\n-        error(\"%s: Failed to write locator to disk\", __func__);\n-    }\n-}\n-\n-bool BaseIndex::BlockUntilSyncedToCurrentChain()\n-{\n-    AssertLockNotHeld(cs_main);\n-\n-    if (!m_synced) {\n-        return false;\n-    }\n-\n-    {\n-        // Skip the queue-draining stuff if we know we're caught up with\n-        // chainActive.Tip().\n-        LOCK(cs_main);\n-        const CBlockIndex* chain_tip = chainActive.Tip();\n-        const CBlockIndex* best_block_index = m_best_block_index.load();\n-        if (best_block_index->GetAncestor(chain_tip->nHeight) == chain_tip) {\n-            return true;\n-        }\n-    }\n-\n-    LogPrintf(\"%s: %s is catching up on block notifications\\n\", __func__, GetName());\n-    SyncWithValidationInterfaceQueue();\n-    return true;\n-}\n-\n bool TxIndex::FindTx(const uint256& tx_hash, uint256& block_hash, CTransactionRef& tx) const\n {\n     CDiskTxPos postx;\n@@ -288,31 +65,3 @@ bool TxIndex::FindTx(const uint256& tx_hash, uint256& block_hash, CTransactionRe\n     block_hash = header.GetHash();\n     return true;\n }\n-\n-void BaseIndex::Interrupt()\n-{\n-    m_interrupt();\n-}\n-\n-void BaseIndex::Start()\n-{\n-    // Need to register this ValidationInterface before running Init(), so that\n-    // callbacks are not missed if Init sets m_synced to true.\n-    RegisterValidationInterface(this);\n-    if (!Init()) {\n-        FatalError(\"%s: %s failed to initialize\", __func__, GetName());\n-        return;\n-    }\n-\n-    m_thread_sync = std::thread(&TraceThread<std::function<void()>>, GetName(),\n-                                std::bind(&BaseIndex::ThreadSync, this));\n-}\n-\n-void BaseIndex::Stop()\n-{\n-    UnregisterValidationInterface(this);\n-\n-    if (m_thread_sync.joinable()) {\n-        m_thread_sync.join();\n-    }\n-}"
      },
      {
        "sha": "fb92ad98dcb0996ea7777484f01625277506a3c2",
        "filename": "src/index/txindex.h",
        "status": "modified",
        "additions": 1,
        "deletions": 75,
        "changes": 76,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/2318affd27de436ddf9d866a4b82eed8ea2e738b/src/index/txindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/2318affd27de436ddf9d866a4b82eed8ea2e738b/src/index/txindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.h?ref=2318affd27de436ddf9d866a4b82eed8ea2e738b",
        "patch": "@@ -5,81 +5,7 @@\n #ifndef BITCOIN_INDEX_TXINDEX_H\n #define BITCOIN_INDEX_TXINDEX_H\n \n-#include <primitives/block.h>\n-#include <primitives/transaction.h>\n-#include <threadinterrupt.h>\n-#include <txdb.h>\n-#include <uint256.h>\n-#include <validationinterface.h>\n-\n-class CBlockIndex;\n-\n-/**\n- * Base class for indices of blockchain data. This implements\n- * CValidationInterface and ensures blocks are indexed sequentially according\n- * to their position in the active chain.\n- */\n-class BaseIndex : public CValidationInterface\n-{\n-private:\n-    /// Whether the index is in sync with the main chain. The flag is flipped\n-    /// from false to true once, after which point this starts processing\n-    /// ValidationInterface notifications to stay in sync.\n-    std::atomic<bool> m_synced{false};\n-\n-    /// The last block in the chain that the index is in sync with.\n-    std::atomic<const CBlockIndex*> m_best_block_index{nullptr};\n-\n-    std::thread m_thread_sync;\n-    CThreadInterrupt m_interrupt;\n-\n-    /// Sync the index with the block index starting from the current best block.\n-    /// Intended to be run in its own thread, m_thread_sync, and can be\n-    /// interrupted with m_interrupt. Once the index gets in sync, the m_synced\n-    /// flag is set and the BlockConnected ValidationInterface callback takes\n-    /// over and the sync thread exits.\n-    void ThreadSync();\n-\n-    /// Write the current chain block locator to the DB.\n-    bool WriteBestBlock(const CBlockIndex* block_index);\n-\n-protected:\n-    void BlockConnected(const std::shared_ptr<const CBlock>& block, const CBlockIndex* pindex,\n-                        const std::vector<CTransactionRef>& txn_conflicted) override;\n-\n-    void ChainStateFlushed(const CBlockLocator& locator) override;\n-\n-    /// Initialize internal state from the database and block index.\n-    virtual bool Init();\n-\n-    /// Write update index entries for a newly connected block.\n-    virtual bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) { return true; }\n-\n-    virtual BaseIndexDB& GetDB() const = 0;\n-\n-    /// Get the name of the index for display in logs.\n-    virtual const char* GetName() const = 0;\n-\n-public:\n-    /// Destructor interrupts sync thread if running and blocks until it exits.\n-    virtual ~BaseIndex();\n-\n-    /// Blocks the current thread until the index is caught up to the current\n-    /// state of the block chain. This only blocks if the index has gotten in\n-    /// sync once and only needs to process blocks in the ValidationInterface\n-    /// queue. If the index is catching up from far behind, this method does\n-    /// not block and immediately returns false.\n-    bool BlockUntilSyncedToCurrentChain();\n-\n-    void Interrupt();\n-\n-    /// Start initializes the sync state and registers the instance as a\n-    /// ValidationInterface so that it stays in sync with blockchain updates.\n-    void Start();\n-\n-    /// Stops the instance from staying in sync with blockchain updates.\n-    void Stop();\n-};\n+#include <index/base.h>\n \n /**\n  * TxIndex is used to look up transactions included in the blockchain by hash."
      }
    ]
  },
  {
    "sha": "89eddcd365e9a2218648f5cc5b9f22b28023f50a",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4OWVkZGNkMzY1ZTlhMjIxODY0OGY1Y2M1YjlmMjJiMjgwMjNmNTBh",
    "commit": {
      "author": {
        "name": "Jim Posen",
        "email": "jim.posen@gmail.com",
        "date": "2018-05-16T00:26:49Z"
      },
      "committer": {
        "name": "Jim Posen",
        "email": "jim.posen@gmail.com",
        "date": "2018-06-05T02:22:28Z"
      },
      "message": "index: Remove TxIndexDB from public interface of TxIndex.",
      "tree": {
        "sha": "6aeaaec4323b1a6c846fc79e539bba4579f4d203",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/6aeaaec4323b1a6c846fc79e539bba4579f4d203"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/89eddcd365e9a2218648f5cc5b9f22b28023f50a",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89eddcd365e9a2218648f5cc5b9f22b28023f50a",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/89eddcd365e9a2218648f5cc5b9f22b28023f50a",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89eddcd365e9a2218648f5cc5b9f22b28023f50a/comments",
    "author": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "2318affd27de436ddf9d866a4b82eed8ea2e738b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/2318affd27de436ddf9d866a4b82eed8ea2e738b",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/2318affd27de436ddf9d866a4b82eed8ea2e738b"
      }
    ],
    "stats": {
      "total": 11,
      "additions": 6,
      "deletions": 5
    },
    "files": [
      {
        "sha": "328039977fcffb97b729d14e0f88d536779c8cd5",
        "filename": "src/index/txindex.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 1,
        "changes": 4,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/89eddcd365e9a2218648f5cc5b9f22b28023f50a/src/index/txindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/89eddcd365e9a2218648f5cc5b9f22b28023f50a/src/index/txindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.cpp?ref=89eddcd365e9a2218648f5cc5b9f22b28023f50a",
        "patch": "@@ -8,7 +8,9 @@\n \n std::unique_ptr<TxIndex> g_txindex;\n \n-TxIndex::TxIndex(std::unique_ptr<TxIndexDB> db) : m_db(std::move(db)) {}\n+TxIndex::TxIndex(size_t n_cache_size, bool f_memory, bool f_wipe)\n+    : m_db(MakeUnique<TxIndex::DB>(n_cache_size, f_memory, f_wipe))\n+{}\n \n bool TxIndex::Init()\n {"
      },
      {
        "sha": "2a0c70e9d1489c89b38777afd1f96c2664781c6c",
        "filename": "src/index/txindex.h",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/89eddcd365e9a2218648f5cc5b9f22b28023f50a/src/index/txindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/89eddcd365e9a2218648f5cc5b9f22b28023f50a/src/index/txindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.h?ref=89eddcd365e9a2218648f5cc5b9f22b28023f50a",
        "patch": "@@ -29,7 +29,7 @@ class TxIndex final : public BaseIndex\n \n public:\n     /// Constructs the index, which becomes available to be queried.\n-    explicit TxIndex(std::unique_ptr<TxIndexDB> db);\n+    explicit TxIndex(size_t n_cache_size, bool f_memory = false, bool f_wipe = false);\n \n     /// Look up a transaction by hash.\n     ///"
      },
      {
        "sha": "9246f6e71cdb9b1ca5e8964df7fc6c5b46fc5d6a",
        "filename": "src/init.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 2,
        "changes": 3,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/89eddcd365e9a2218648f5cc5b9f22b28023f50a/src/init.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/89eddcd365e9a2218648f5cc5b9f22b28023f50a/src/init.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/init.cpp?ref=89eddcd365e9a2218648f5cc5b9f22b28023f50a",
        "patch": "@@ -1606,8 +1606,7 @@ bool AppInitMain()\n \n     // ********************************************************* Step 8: start indexers\n     if (gArgs.GetBoolArg(\"-txindex\", DEFAULT_TXINDEX)) {\n-        auto txindex_db = MakeUnique<TxIndexDB>(nTxIndexCache, false, fReindex);\n-        g_txindex = MakeUnique<TxIndex>(std::move(txindex_db));\n+        g_txindex = MakeUnique<TxIndex>(nTxIndexCache, false, fReindex);\n         g_txindex->Start();\n     }\n "
      },
      {
        "sha": "be7ee2428b2725a80957f49375e93f05ba64bd4d",
        "filename": "src/test/txindex_tests.cpp",
        "status": "modified",
        "additions": 1,
        "deletions": 1,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/89eddcd365e9a2218648f5cc5b9f22b28023f50a/src/test/txindex_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/89eddcd365e9a2218648f5cc5b9f22b28023f50a/src/test/txindex_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/test/txindex_tests.cpp?ref=89eddcd365e9a2218648f5cc5b9f22b28023f50a",
        "patch": "@@ -15,7 +15,7 @@ BOOST_AUTO_TEST_SUITE(txindex_tests)\n \n BOOST_FIXTURE_TEST_CASE(txindex_initial_sync, TestChain100Setup)\n {\n-    TxIndex txindex(MakeUnique<TxIndexDB>(1 << 20, true));\n+    TxIndex txindex(1 << 20, true);\n \n     CTransactionRef tx_disk;\n     uint256 block_hash;"
      }
    ]
  },
  {
    "sha": "ec3073a274bf7affe1b8c87a10f75d126f5ac027",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzplYzMwNzNhMjc0YmY3YWZmZTFiOGM4N2ExMGY3NWQxMjZmNWFjMDI3",
    "commit": {
      "author": {
        "name": "Jim Posen",
        "email": "jim.posen@gmail.com",
        "date": "2018-05-16T00:20:17Z"
      },
      "committer": {
        "name": "Jim Posen",
        "email": "jim.posen@gmail.com",
        "date": "2018-06-05T02:22:30Z"
      },
      "message": "index: Move index DBs into index/ directory.",
      "tree": {
        "sha": "9f56192c49d79d2c23a5618b8b663926bc1b9fb2",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/9f56192c49d79d2c23a5618b8b663926bc1b9fb2"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/ec3073a274bf7affe1b8c87a10f75d126f5ac027",
      "comment_count": 0,
      "verification": {
        "verified": false,
        "reason": "unsigned",
        "signature": null,
        "payload": null
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec3073a274bf7affe1b8c87a10f75d126f5ac027",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/ec3073a274bf7affe1b8c87a10f75d126f5ac027",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/ec3073a274bf7affe1b8c87a10f75d126f5ac027/comments",
    "author": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "jimpo",
      "id": 881253,
      "node_id": "MDQ6VXNlcjg4MTI1Mw==",
      "avatar_url": "https://avatars.githubusercontent.com/u/881253?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/jimpo",
      "html_url": "https://github.com/jimpo",
      "followers_url": "https://api.github.com/users/jimpo/followers",
      "following_url": "https://api.github.com/users/jimpo/following{/other_user}",
      "gists_url": "https://api.github.com/users/jimpo/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/jimpo/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/jimpo/subscriptions",
      "organizations_url": "https://api.github.com/users/jimpo/orgs",
      "repos_url": "https://api.github.com/users/jimpo/repos",
      "events_url": "https://api.github.com/users/jimpo/events{/privacy}",
      "received_events_url": "https://api.github.com/users/jimpo/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "89eddcd365e9a2218648f5cc5b9f22b28023f50a",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/89eddcd365e9a2218648f5cc5b9f22b28023f50a",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/89eddcd365e9a2218648f5cc5b9f22b28023f50a"
      }
    ],
    "stats": {
      "total": 509,
      "additions": 264,
      "deletions": 245
    },
    "files": [
      {
        "sha": "738166dc94aafca2642736259cab32496c3cec2d",
        "filename": "src/index/base.cpp",
        "status": "modified",
        "additions": 20,
        "deletions": 0,
        "changes": 20,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec3073a274bf7affe1b8c87a10f75d126f5ac027/src/index/base.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec3073a274bf7affe1b8c87a10f75d126f5ac027/src/index/base.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.cpp?ref=ec3073a274bf7affe1b8c87a10f75d126f5ac027",
        "patch": "@@ -11,6 +11,8 @@\n #include <validation.h>\n #include <warnings.h>\n \n+constexpr char DB_BEST_BLOCK = 'B';\n+\n constexpr int64_t SYNC_LOG_INTERVAL = 30; // seconds\n constexpr int64_t SYNC_LOCATOR_WRITE_INTERVAL = 30; // seconds\n \n@@ -26,6 +28,24 @@ static void FatalError(const char* fmt, const Args&... args)\n     StartShutdown();\n }\n \n+BaseIndex::DB::DB(const fs::path& path, size_t n_cache_size, bool f_memory, bool f_wipe, bool f_obfuscate) :\n+    CDBWrapper(path, n_cache_size, f_memory, f_wipe, f_obfuscate)\n+{}\n+\n+bool BaseIndex::DB::ReadBestBlock(CBlockLocator& locator) const\n+{\n+    bool success = Read(DB_BEST_BLOCK, locator);\n+    if (!success) {\n+        locator.SetNull();\n+    }\n+    return success;\n+}\n+\n+bool BaseIndex::DB::WriteBestBlock(const CBlockLocator& locator)\n+{\n+    return Write(DB_BEST_BLOCK, locator);\n+}\n+\n BaseIndex::~BaseIndex()\n {\n     Interrupt();"
      },
      {
        "sha": "04ee6e6cc2dac672c342e40a0332932fb99b25dd",
        "filename": "src/index/base.h",
        "status": "modified",
        "additions": 16,
        "deletions": 2,
        "changes": 18,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec3073a274bf7affe1b8c87a10f75d126f5ac027/src/index/base.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec3073a274bf7affe1b8c87a10f75d126f5ac027/src/index/base.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/base.h?ref=ec3073a274bf7affe1b8c87a10f75d126f5ac027",
        "patch": "@@ -5,10 +5,10 @@\n #ifndef BITCOIN_INDEX_BASE_H\n #define BITCOIN_INDEX_BASE_H\n \n+#include <dbwrapper.h>\n #include <primitives/block.h>\n #include <primitives/transaction.h>\n #include <threadinterrupt.h>\n-#include <txdb.h>\n #include <uint256.h>\n #include <validationinterface.h>\n \n@@ -21,6 +21,20 @@ class CBlockIndex;\n  */\n class BaseIndex : public CValidationInterface\n {\n+protected:\n+    class DB : public CDBWrapper\n+    {\n+    public:\n+        DB(const fs::path& path, size_t n_cache_size,\n+           bool f_memory = false, bool f_wipe = false, bool f_obfuscate = false);\n+\n+        /// Read block locator of the chain that the txindex is in sync with.\n+        bool ReadBestBlock(CBlockLocator& locator) const;\n+\n+        /// Write block locator of the chain that the txindex is in sync with.\n+        bool WriteBestBlock(const CBlockLocator& locator);\n+    };\n+\n private:\n     /// Whether the index is in sync with the main chain. The flag is flipped\n     /// from false to true once, after which point this starts processing\n@@ -55,7 +69,7 @@ class BaseIndex : public CValidationInterface\n     /// Write update index entries for a newly connected block.\n     virtual bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) { return true; }\n \n-    virtual BaseIndexDB& GetDB() const = 0;\n+    virtual DB& GetDB() const = 0;\n \n     /// Get the name of the index for display in logs.\n     virtual const char* GetName() const = 0;"
      },
      {
        "sha": "e106b9b42095ab33f035d4ba199da9fbcb25a9f0",
        "filename": "src/index/txindex.cpp",
        "status": "modified",
        "additions": 218,
        "deletions": 1,
        "changes": 219,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec3073a274bf7affe1b8c87a10f75d126f5ac027/src/index/txindex.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec3073a274bf7affe1b8c87a10f75d126f5ac027/src/index/txindex.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.cpp?ref=ec3073a274bf7affe1b8c87a10f75d126f5ac027",
        "patch": "@@ -3,15 +3,232 @@\n // file COPYING or http://www.opensource.org/licenses/mit-license.php.\n \n #include <index/txindex.h>\n+#include <init.h>\n+#include <ui_interface.h>\n #include <util.h>\n #include <validation.h>\n \n+#include <boost/thread.hpp>\n+\n+constexpr char DB_BEST_BLOCK = 'B';\n+constexpr char DB_TXINDEX = 't';\n+constexpr char DB_TXINDEX_BLOCK = 'T';\n+\n std::unique_ptr<TxIndex> g_txindex;\n \n+struct CDiskTxPos : public CDiskBlockPos\n+{\n+    unsigned int nTxOffset; // after header\n+\n+    ADD_SERIALIZE_METHODS;\n+\n+    template <typename Stream, typename Operation>\n+    inline void SerializationOp(Stream& s, Operation ser_action) {\n+        READWRITEAS(CDiskBlockPos, *this);\n+        READWRITE(VARINT(nTxOffset));\n+    }\n+\n+    CDiskTxPos(const CDiskBlockPos &blockIn, unsigned int nTxOffsetIn) : CDiskBlockPos(blockIn.nFile, blockIn.nPos), nTxOffset(nTxOffsetIn) {\n+    }\n+\n+    CDiskTxPos() {\n+        SetNull();\n+    }\n+\n+    void SetNull() {\n+        CDiskBlockPos::SetNull();\n+        nTxOffset = 0;\n+    }\n+};\n+\n+/**\n+ * Access to the txindex database (indexes/txindex/)\n+ *\n+ * The database stores a block locator of the chain the database is synced to\n+ * so that the TxIndex can efficiently determine the point it last stopped at.\n+ * A locator is used instead of a simple hash of the chain tip because blocks\n+ * and block index entries may not be flushed to disk until after this database\n+ * is updated.\n+ */\n+class TxIndex::DB : public BaseIndex::DB\n+{\n+public:\n+    explicit DB(size_t n_cache_size, bool f_memory = false, bool f_wipe = false);\n+\n+    /// Read the disk location of the transaction data with the given hash. Returns false if the\n+    /// transaction hash is not indexed.\n+    bool ReadTxPos(const uint256& txid, CDiskTxPos& pos) const;\n+\n+    /// Write a batch of transaction positions to the DB.\n+    bool WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_pos);\n+\n+    /// Migrate txindex data from the block tree DB, where it may be for older nodes that have not\n+    /// been upgraded yet to the new database.\n+    bool MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator& best_locator);\n+};\n+\n+TxIndex::DB::DB(size_t n_cache_size, bool f_memory, bool f_wipe) :\n+    BaseIndex::DB(GetDataDir() / \"indexes\" / \"txindex\", n_cache_size, f_memory, f_wipe)\n+{}\n+\n+bool TxIndex::DB::ReadTxPos(const uint256 &txid, CDiskTxPos& pos) const\n+{\n+    return Read(std::make_pair(DB_TXINDEX, txid), pos);\n+}\n+\n+bool TxIndex::DB::WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_pos)\n+{\n+    CDBBatch batch(*this);\n+    for (const auto& tuple : v_pos) {\n+        batch.Write(std::make_pair(DB_TXINDEX, tuple.first), tuple.second);\n+    }\n+    return WriteBatch(batch);\n+}\n+\n+/*\n+ * Safely persist a transfer of data from the old txindex database to the new one, and compact the\n+ * range of keys updated. This is used internally by MigrateData.\n+ */\n+static void WriteTxIndexMigrationBatches(CDBWrapper& newdb, CDBWrapper& olddb,\n+                                         CDBBatch& batch_newdb, CDBBatch& batch_olddb,\n+                                         const std::pair<unsigned char, uint256>& begin_key,\n+                                         const std::pair<unsigned char, uint256>& end_key)\n+{\n+    // Sync new DB changes to disk before deleting from old DB.\n+    newdb.WriteBatch(batch_newdb, /*fSync=*/ true);\n+    olddb.WriteBatch(batch_olddb);\n+    olddb.CompactRange(begin_key, end_key);\n+\n+    batch_newdb.Clear();\n+    batch_olddb.Clear();\n+}\n+\n+bool TxIndex::DB::MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator& best_locator)\n+{\n+    // The prior implementation of txindex was always in sync with block index\n+    // and presence was indicated with a boolean DB flag. If the flag is set,\n+    // this means the txindex from a previous version is valid and in sync with\n+    // the chain tip. The first step of the migration is to unset the flag and\n+    // write the chain hash to a separate key, DB_TXINDEX_BLOCK. After that, the\n+    // index entries are copied over in batches to the new database. Finally,\n+    // DB_TXINDEX_BLOCK is erased from the old database and the block hash is\n+    // written to the new database.\n+    //\n+    // Unsetting the boolean flag ensures that if the node is downgraded to a\n+    // previous version, it will not see a corrupted, partially migrated index\n+    // -- it will see that the txindex is disabled. When the node is upgraded\n+    // again, the migration will pick up where it left off and sync to the block\n+    // with hash DB_TXINDEX_BLOCK.\n+    bool f_legacy_flag = false;\n+    block_tree_db.ReadFlag(\"txindex\", f_legacy_flag);\n+    if (f_legacy_flag) {\n+        if (!block_tree_db.Write(DB_TXINDEX_BLOCK, best_locator)) {\n+            return error(\"%s: cannot write block indicator\", __func__);\n+        }\n+        if (!block_tree_db.WriteFlag(\"txindex\", false)) {\n+            return error(\"%s: cannot write block index db flag\", __func__);\n+        }\n+    }\n+\n+    CBlockLocator locator;\n+    if (!block_tree_db.Read(DB_TXINDEX_BLOCK, locator)) {\n+        return true;\n+    }\n+\n+    int64_t count = 0;\n+    LogPrintf(\"Upgrading txindex database... [0%%]\\n\");\n+    uiInterface.ShowProgress(_(\"Upgrading txindex database\"), 0, true);\n+    int report_done = 0;\n+    const size_t batch_size = 1 << 24; // 16 MiB\n+\n+    CDBBatch batch_newdb(*this);\n+    CDBBatch batch_olddb(block_tree_db);\n+\n+    std::pair<unsigned char, uint256> key;\n+    std::pair<unsigned char, uint256> begin_key{DB_TXINDEX, uint256()};\n+    std::pair<unsigned char, uint256> prev_key = begin_key;\n+\n+    bool interrupted = false;\n+    std::unique_ptr<CDBIterator> cursor(block_tree_db.NewIterator());\n+    for (cursor->Seek(begin_key); cursor->Valid(); cursor->Next()) {\n+        boost::this_thread::interruption_point();\n+        if (ShutdownRequested()) {\n+            interrupted = true;\n+            break;\n+        }\n+\n+        if (!cursor->GetKey(key)) {\n+            return error(\"%s: cannot get key from valid cursor\", __func__);\n+        }\n+        if (key.first != DB_TXINDEX) {\n+            break;\n+        }\n+\n+        // Log progress every 10%.\n+        if (++count % 256 == 0) {\n+            // Since txids are uniformly random and traversed in increasing order, the high 16 bits\n+            // of the hash can be used to estimate the current progress.\n+            const uint256& txid = key.second;\n+            uint32_t high_nibble =\n+                (static_cast<uint32_t>(*(txid.begin() + 0)) << 8) +\n+                (static_cast<uint32_t>(*(txid.begin() + 1)) << 0);\n+            int percentage_done = (int)(high_nibble * 100.0 / 65536.0 + 0.5);\n+\n+            uiInterface.ShowProgress(_(\"Upgrading txindex database\"), percentage_done, true);\n+            if (report_done < percentage_done/10) {\n+                LogPrintf(\"Upgrading txindex database... [%d%%]\\n\", percentage_done);\n+                report_done = percentage_done/10;\n+            }\n+        }\n+\n+        CDiskTxPos value;\n+        if (!cursor->GetValue(value)) {\n+            return error(\"%s: cannot parse txindex record\", __func__);\n+        }\n+        batch_newdb.Write(key, value);\n+        batch_olddb.Erase(key);\n+\n+        if (batch_newdb.SizeEstimate() > batch_size || batch_olddb.SizeEstimate() > batch_size) {\n+            // NOTE: it's OK to delete the key pointed at by the current DB cursor while iterating\n+            // because LevelDB iterators are guaranteed to provide a consistent view of the\n+            // underlying data, like a lightweight snapshot.\n+            WriteTxIndexMigrationBatches(*this, block_tree_db,\n+                                         batch_newdb, batch_olddb,\n+                                         prev_key, key);\n+            prev_key = key;\n+        }\n+    }\n+\n+    // If these final DB batches complete the migration, write the best block\n+    // hash marker to the new database and delete from the old one. This signals\n+    // that the former is fully caught up to that point in the blockchain and\n+    // that all txindex entries have been removed from the latter.\n+    if (!interrupted) {\n+        batch_olddb.Erase(DB_TXINDEX_BLOCK);\n+        batch_newdb.Write(DB_BEST_BLOCK, locator);\n+    }\n+\n+    WriteTxIndexMigrationBatches(*this, block_tree_db,\n+                                 batch_newdb, batch_olddb,\n+                                 begin_key, key);\n+\n+    if (interrupted) {\n+        LogPrintf(\"[CANCELLED].\\n\");\n+        return false;\n+    }\n+\n+    uiInterface.ShowProgress(\"\", 100, false);\n+\n+    LogPrintf(\"[DONE].\\n\");\n+    return true;\n+}\n+\n TxIndex::TxIndex(size_t n_cache_size, bool f_memory, bool f_wipe)\n     : m_db(MakeUnique<TxIndex::DB>(n_cache_size, f_memory, f_wipe))\n {}\n \n+TxIndex::~TxIndex() {}\n+\n bool TxIndex::Init()\n {\n     LOCK(cs_main);\n@@ -38,7 +255,7 @@ bool TxIndex::WriteBlock(const CBlock& block, const CBlockIndex* pindex)\n     return m_db->WriteTxs(vPos);\n }\n \n-BaseIndexDB& TxIndex::GetDB() const { return *m_db; }\n+BaseIndex::DB& TxIndex::GetDB() const { return *m_db; }\n \n bool TxIndex::FindTx(const uint256& tx_hash, uint256& block_hash, CTransactionRef& tx) const\n {"
      },
      {
        "sha": "8202c3c951f1229ae2d5242372273323e4e8c3c5",
        "filename": "src/index/txindex.h",
        "status": "modified",
        "additions": 10,
        "deletions": 2,
        "changes": 12,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec3073a274bf7affe1b8c87a10f75d126f5ac027/src/index/txindex.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec3073a274bf7affe1b8c87a10f75d126f5ac027/src/index/txindex.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/index/txindex.h?ref=ec3073a274bf7affe1b8c87a10f75d126f5ac027",
        "patch": "@@ -5,7 +5,9 @@\n #ifndef BITCOIN_INDEX_TXINDEX_H\n #define BITCOIN_INDEX_TXINDEX_H\n \n+#include <chain.h>\n #include <index/base.h>\n+#include <txdb.h>\n \n /**\n  * TxIndex is used to look up transactions included in the blockchain by hash.\n@@ -14,23 +16,29 @@\n  */\n class TxIndex final : public BaseIndex\n {\n+protected:\n+    class DB;\n+\n private:\n-    const std::unique_ptr<TxIndexDB> m_db;\n+    const std::unique_ptr<DB> m_db;\n \n protected:\n     /// Override base class init to migrate from old database.\n     bool Init() override;\n \n     bool WriteBlock(const CBlock& block, const CBlockIndex* pindex) override;\n \n-    BaseIndexDB& GetDB() const override;\n+    BaseIndex::DB& GetDB() const override;\n \n     const char* GetName() const override { return \"txindex\"; }\n \n public:\n     /// Constructs the index, which becomes available to be queried.\n     explicit TxIndex(size_t n_cache_size, bool f_memory = false, bool f_wipe = false);\n \n+    // Destructor is declared because this class contains a unique_ptr to an incomplete type.\n+    virtual ~TxIndex() override;\n+\n     /// Look up a transaction by hash.\n     ///\n     /// @param[in]   tx_hash  The hash of the transaction to be returned."
      },
      {
        "sha": "b1d5879c83329502d680399cbf4f2b4ae51633f5",
        "filename": "src/txdb.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 176,
        "changes": 176,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec3073a274bf7affe1b8c87a10f75d126f5ac027/src/txdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec3073a274bf7affe1b8c87a10f75d126f5ac027/src/txdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.cpp?ref=ec3073a274bf7affe1b8c87a10f75d126f5ac027",
        "patch": "@@ -21,8 +21,6 @@\n static const char DB_COIN = 'C';\n static const char DB_COINS = 'c';\n static const char DB_BLOCK_FILES = 'f';\n-static const char DB_TXINDEX = 't';\n-static const char DB_TXINDEX_BLOCK = 'T';\n static const char DB_BLOCK_INDEX = 'b';\n \n static const char DB_BEST_BLOCK = 'B';\n@@ -414,177 +412,3 @@ bool CCoinsViewDB::Upgrade() {\n     LogPrintf(\"[%s].\\n\", ShutdownRequested() ? \"CANCELLED\" : \"DONE\");\n     return !ShutdownRequested();\n }\n-\n-BaseIndexDB::BaseIndexDB(const fs::path& path, size_t n_cache_size, bool f_memory, bool f_wipe, bool f_obfuscate) :\n-    CDBWrapper(path, n_cache_size, f_memory, f_wipe, f_obfuscate)\n-{}\n-\n-TxIndexDB::TxIndexDB(size_t n_cache_size, bool f_memory, bool f_wipe) :\n-    BaseIndexDB(GetDataDir() / \"indexes\" / \"txindex\", n_cache_size, f_memory, f_wipe)\n-{}\n-\n-bool TxIndexDB::ReadTxPos(const uint256 &txid, CDiskTxPos& pos) const\n-{\n-    return Read(std::make_pair(DB_TXINDEX, txid), pos);\n-}\n-\n-bool TxIndexDB::WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_pos)\n-{\n-    CDBBatch batch(*this);\n-    for (const auto& tuple : v_pos) {\n-        batch.Write(std::make_pair(DB_TXINDEX, tuple.first), tuple.second);\n-    }\n-    return WriteBatch(batch);\n-}\n-\n-bool BaseIndexDB::ReadBestBlock(CBlockLocator& locator) const\n-{\n-    bool success = Read(DB_BEST_BLOCK, locator);\n-    if (!success) {\n-        locator.SetNull();\n-    }\n-    return success;\n-}\n-\n-bool BaseIndexDB::WriteBestBlock(const CBlockLocator& locator)\n-{\n-    return Write(DB_BEST_BLOCK, locator);\n-}\n-\n-/*\n- * Safely persist a transfer of data from the old txindex database to the new one, and compact the\n- * range of keys updated. This is used internally by MigrateData.\n- */\n-static void WriteTxIndexMigrationBatches(TxIndexDB& newdb, CBlockTreeDB& olddb,\n-                                         CDBBatch& batch_newdb, CDBBatch& batch_olddb,\n-                                         const std::pair<unsigned char, uint256>& begin_key,\n-                                         const std::pair<unsigned char, uint256>& end_key)\n-{\n-    // Sync new DB changes to disk before deleting from old DB.\n-    newdb.WriteBatch(batch_newdb, /*fSync=*/ true);\n-    olddb.WriteBatch(batch_olddb);\n-    olddb.CompactRange(begin_key, end_key);\n-\n-    batch_newdb.Clear();\n-    batch_olddb.Clear();\n-}\n-\n-bool TxIndexDB::MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator& best_locator)\n-{\n-    // The prior implementation of txindex was always in sync with block index\n-    // and presence was indicated with a boolean DB flag. If the flag is set,\n-    // this means the txindex from a previous version is valid and in sync with\n-    // the chain tip. The first step of the migration is to unset the flag and\n-    // write the chain hash to a separate key, DB_TXINDEX_BLOCK. After that, the\n-    // index entries are copied over in batches to the new database. Finally,\n-    // DB_TXINDEX_BLOCK is erased from the old database and the block hash is\n-    // written to the new database.\n-    //\n-    // Unsetting the boolean flag ensures that if the node is downgraded to a\n-    // previous version, it will not see a corrupted, partially migrated index\n-    // -- it will see that the txindex is disabled. When the node is upgraded\n-    // again, the migration will pick up where it left off and sync to the block\n-    // with hash DB_TXINDEX_BLOCK.\n-    bool f_legacy_flag = false;\n-    block_tree_db.ReadFlag(\"txindex\", f_legacy_flag);\n-    if (f_legacy_flag) {\n-        if (!block_tree_db.Write(DB_TXINDEX_BLOCK, best_locator)) {\n-            return error(\"%s: cannot write block indicator\", __func__);\n-        }\n-        if (!block_tree_db.WriteFlag(\"txindex\", false)) {\n-            return error(\"%s: cannot write block index db flag\", __func__);\n-        }\n-    }\n-\n-    CBlockLocator locator;\n-    if (!block_tree_db.Read(DB_TXINDEX_BLOCK, locator)) {\n-        return true;\n-    }\n-\n-    int64_t count = 0;\n-    LogPrintf(\"Upgrading txindex database... [0%%]\\n\");\n-    uiInterface.ShowProgress(_(\"Upgrading txindex database\"), 0, true);\n-    int report_done = 0;\n-    const size_t batch_size = 1 << 24; // 16 MiB\n-\n-    CDBBatch batch_newdb(*this);\n-    CDBBatch batch_olddb(block_tree_db);\n-\n-    std::pair<unsigned char, uint256> key;\n-    std::pair<unsigned char, uint256> begin_key{DB_TXINDEX, uint256()};\n-    std::pair<unsigned char, uint256> prev_key = begin_key;\n-\n-    bool interrupted = false;\n-    std::unique_ptr<CDBIterator> cursor(block_tree_db.NewIterator());\n-    for (cursor->Seek(begin_key); cursor->Valid(); cursor->Next()) {\n-        boost::this_thread::interruption_point();\n-        if (ShutdownRequested()) {\n-            interrupted = true;\n-            break;\n-        }\n-\n-        if (!cursor->GetKey(key)) {\n-            return error(\"%s: cannot get key from valid cursor\", __func__);\n-        }\n-        if (key.first != DB_TXINDEX) {\n-            break;\n-        }\n-\n-        // Log progress every 10%.\n-        if (++count % 256 == 0) {\n-            // Since txids are uniformly random and traversed in increasing order, the high 16 bits\n-            // of the hash can be used to estimate the current progress.\n-            const uint256& txid = key.second;\n-            uint32_t high_nibble =\n-                (static_cast<uint32_t>(*(txid.begin() + 0)) << 8) +\n-                (static_cast<uint32_t>(*(txid.begin() + 1)) << 0);\n-            int percentage_done = (int)(high_nibble * 100.0 / 65536.0 + 0.5);\n-\n-            uiInterface.ShowProgress(_(\"Upgrading txindex database\"), percentage_done, true);\n-            if (report_done < percentage_done/10) {\n-                LogPrintf(\"Upgrading txindex database... [%d%%]\\n\", percentage_done);\n-                report_done = percentage_done/10;\n-            }\n-        }\n-\n-        CDiskTxPos value;\n-        if (!cursor->GetValue(value)) {\n-            return error(\"%s: cannot parse txindex record\", __func__);\n-        }\n-        batch_newdb.Write(key, value);\n-        batch_olddb.Erase(key);\n-\n-        if (batch_newdb.SizeEstimate() > batch_size || batch_olddb.SizeEstimate() > batch_size) {\n-            // NOTE: it's OK to delete the key pointed at by the current DB cursor while iterating\n-            // because LevelDB iterators are guaranteed to provide a consistent view of the\n-            // underlying data, like a lightweight snapshot.\n-            WriteTxIndexMigrationBatches(*this, block_tree_db,\n-                                         batch_newdb, batch_olddb,\n-                                         prev_key, key);\n-            prev_key = key;\n-        }\n-    }\n-\n-    // If these final DB batches complete the migration, write the best block\n-    // hash marker to the new database and delete from the old one. This signals\n-    // that the former is fully caught up to that point in the blockchain and\n-    // that all txindex entries have been removed from the latter.\n-    if (!interrupted) {\n-        batch_olddb.Erase(DB_TXINDEX_BLOCK);\n-        batch_newdb.Write(DB_BEST_BLOCK, locator);\n-    }\n-\n-    WriteTxIndexMigrationBatches(*this, block_tree_db,\n-                                 batch_newdb, batch_olddb,\n-                                 begin_key, key);\n-\n-    if (interrupted) {\n-        LogPrintf(\"[CANCELLED].\\n\");\n-        return false;\n-    }\n-\n-    uiInterface.ShowProgress(\"\", 100, false);\n-\n-    LogPrintf(\"[DONE].\\n\");\n-    return true;\n-}"
      },
      {
        "sha": "100adb428dac9f035bbc8116002757152fe73fdb",
        "filename": "src/txdb.h",
        "status": "modified",
        "additions": 0,
        "deletions": 64,
        "changes": 64,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/ec3073a274bf7affe1b8c87a10f75d126f5ac027/src/txdb.h",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/ec3073a274bf7affe1b8c87a10f75d126f5ac027/src/txdb.h",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/txdb.h?ref=ec3073a274bf7affe1b8c87a10f75d126f5ac027",
        "patch": "@@ -40,31 +40,6 @@ static const int64_t nMaxTxIndexCache = 1024;\n //! Max memory allocated to coin DB specific cache (MiB)\n static const int64_t nMaxCoinsDBCache = 8;\n \n-struct CDiskTxPos : public CDiskBlockPos\n-{\n-    unsigned int nTxOffset; // after header\n-\n-    ADD_SERIALIZE_METHODS;\n-\n-    template <typename Stream, typename Operation>\n-    inline void SerializationOp(Stream& s, Operation ser_action) {\n-        READWRITEAS(CDiskBlockPos, *this);\n-        READWRITE(VARINT(nTxOffset));\n-    }\n-\n-    CDiskTxPos(const CDiskBlockPos &blockIn, unsigned int nTxOffsetIn) : CDiskBlockPos(blockIn.nFile, blockIn.nPos), nTxOffset(nTxOffsetIn) {\n-    }\n-\n-    CDiskTxPos() {\n-        SetNull();\n-    }\n-\n-    void SetNull() {\n-        CDiskBlockPos::SetNull();\n-        nTxOffset = 0;\n-    }\n-};\n-\n /** CCoinsView backed by the coin database (chainstate/) */\n class CCoinsViewDB final : public CCoinsView\n {\n@@ -123,43 +98,4 @@ class CBlockTreeDB : public CDBWrapper\n     bool LoadBlockIndexGuts(const Consensus::Params& consensusParams, std::function<CBlockIndex*(const uint256&)> insertBlockIndex);\n };\n \n-class BaseIndexDB : public CDBWrapper\n-{\n-public:\n-    BaseIndexDB(const fs::path& path, size_t n_cache_size,\n-                bool f_memory = false, bool f_wipe = false, bool f_obfuscate = false);\n-\n-    /// Read block locator of the chain that the index is in sync with.\n-    bool ReadBestBlock(CBlockLocator& locator) const;\n-\n-    /// Write block locator of the chain that the index is in sync with.\n-    bool WriteBestBlock(const CBlockLocator& locator);\n-};\n-\n-/**\n- * Access to the txindex database (indexes/txindex/)\n- *\n- * The database stores a block locator of the chain the database is synced to\n- * so that the TxIndex can efficiently determine the point it last stopped at.\n- * A locator is used instead of a simple hash of the chain tip because blocks\n- * and block index entries may not be flushed to disk until after this database\n- * is updated.\n- */\n-class TxIndexDB : public BaseIndexDB\n-{\n-public:\n-    explicit TxIndexDB(size_t n_cache_size, bool f_memory = false, bool f_wipe = false);\n-\n-    /// Read the disk location of the transaction data with the given hash. Returns false if the\n-    /// transaction hash is not indexed.\n-    bool ReadTxPos(const uint256& txid, CDiskTxPos& pos) const;\n-\n-    /// Write a batch of transaction positions to the DB.\n-    bool WriteTxs(const std::vector<std::pair<uint256, CDiskTxPos>>& v_pos);\n-\n-    /// Migrate txindex data from the block tree DB, where it may be for older nodes that have not\n-    /// been upgraded yet to the new database.\n-    bool MigrateData(CBlockTreeDB& block_tree_db, const CBlockLocator& best_locator);\n-};\n-\n #endif // BITCOIN_TXDB_H"
      }
    ]
  }
]