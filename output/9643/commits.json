[
  {
    "sha": "8a5228197cec2e65f53bffe269c08ce94c440048",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzo4YTUyMjgxOTdjZWMyZTY1ZjUzYmZmZTI2OWMwOGNlOTRjNDQwMDQ4",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-01-27T01:33:45Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-03-08T16:46:59Z"
      },
      "message": "Refactor: Remove using namespace <xxx> from wallet/",
      "tree": {
        "sha": "42ba6c3ed35b1d3df3c8eb917e906abe9d46965b",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/42ba6c3ed35b1d3df3c8eb917e906abe9d46965b"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/8a5228197cec2e65f53bffe269c08ce94c440048",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCAAGBQJYwDWGAAoJEFevdi2zNTMilqoP/jtNI0VhpjKrWdSLAniXkaBW\nZAm2kCMfw7YsoTgJces0L7+R7fM9ZlX+Yj5tBxhF5WVsqMqVtQ1NAa6aqCS+lw0v\n93dLjKlxVVU+BACNkvuIQc43KqeVMIgXMUtKzU0Hc4oLwZUVJtY0Fjj2vdSPneFZ\nsiGCyywlRCLE+smgVN5bekArNnH1pJj5LlAz9gSixAymJ3irqJ9m9P+fiDoKzS+v\nmR6CJ4FSShLNkJ4IfT5qYNGOklLQ0R5nebMklJm+sH4fiR2Qz9Ou86nUgfM+7oVj\nWEet1BIedq15YgTsD4JW3dAdHABVChDgaimWl1fXAjNWV7MOLicwAiq6meSG8mmK\nZFfkI5Z0yWDsM1T20RL2U6w9AB02XVkro98Vy1dQVnlhF3eljZiepkzP12M6YLZ1\nY3V3R76+X58jppOfuaNYhUUF1xjmp+04Bd30q2ITPwiYAE3W01RjZfpEzkbpKyuc\n1YDrKtFasuEzeqL53HXd8Gr9u2Dl9XjbFjKbbjRyhbKgdXw+Lod9VsJDYKmSCd6P\nKQXb9hHw4QsnkGAEuj6dJcxoo24al+VHaZjg36YBoV+3YNvOsDE0AzFA27kPlFJJ\nHRA1xj23RIVCNwMMiNI8uZDiBUNkL/OSyQgngNbG7XrLxJH4A930Xni6Xukcl/zp\niioCGyEN0mo/13XL812x\n=KH1k\n-----END PGP SIGNATURE-----",
        "payload": "tree 42ba6c3ed35b1d3df3c8eb917e906abe9d46965b\nparent 6996e066b538f03b8aa1f617dbb959b57ff6e727\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1485480825 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1488991619 -0800\n\nRefactor: Remove using namespace <xxx> from wallet/\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8a5228197cec2e65f53bffe269c08ce94c440048",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/8a5228197cec2e65f53bffe269c08ce94c440048",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8a5228197cec2e65f53bffe269c08ce94c440048/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "6996e066b538f03b8aa1f617dbb959b57ff6e727",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/6996e066b538f03b8aa1f617dbb959b57ff6e727",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/6996e066b538f03b8aa1f617dbb959b57ff6e727"
      }
    ],
    "stats": {
      "total": 619,
      "additions": 303,
      "deletions": 316
    },
    "files": [
      {
        "sha": "80c42bd91b4c93550c39f8d9529077e041fef254",
        "filename": "src/wallet/db.cpp",
        "status": "modified",
        "additions": 17,
        "deletions": 20,
        "changes": 37,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8a5228197cec2e65f53bffe269c08ce94c440048/src/wallet/db.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8a5228197cec2e65f53bffe269c08ce94c440048/src/wallet/db.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/db.cpp?ref=8a5228197cec2e65f53bffe269c08ce94c440048",
        "patch": "@@ -22,9 +22,6 @@\n #include <boost/thread.hpp>\n #include <boost/version.hpp>\n \n-using namespace std;\n-\n-\n //\n // CDB\n //\n@@ -117,7 +114,7 @@ bool CDBEnv::Open(const boost::filesystem::path& pathIn)\n void CDBEnv::MakeMock()\n {\n     if (fDbEnvInit)\n-        throw runtime_error(\"CDBEnv::MakeMock: Already initialized\");\n+        throw std::runtime_error(\"CDBEnv::MakeMock: Already initialized\");\n \n     boost::this_thread::interruption_point();\n \n@@ -140,7 +137,7 @@ void CDBEnv::MakeMock()\n                              DB_PRIVATE,\n                          S_IRUSR | S_IWUSR);\n     if (ret > 0)\n-        throw runtime_error(strprintf(\"CDBEnv::MakeMock: Error %d opening database environment.\", ret));\n+        throw std::runtime_error(strprintf(\"CDBEnv::MakeMock: Error %d opening database environment.\", ret));\n \n     fDbEnvInit = true;\n     fMockDb = true;\n@@ -214,7 +211,7 @@ bool CDB::Recover(const std::string& filename, void *callbackDataIn, bool (*reco\n         {\n             CDataStream ssKey(row.first, SER_DISK, CLIENT_VERSION);\n             CDataStream ssValue(row.second, SER_DISK, CLIENT_VERSION);\n-            string strType, strErr;\n+            std::string strType, strErr;\n             if (!(*recoverKVcallback)(callbackDataIn, ssKey, ssValue))\n                 continue;\n         }\n@@ -301,7 +298,7 @@ bool CDBEnv::Salvage(const std::string& strFile, bool fAggressive, std::vector<C\n     if (fAggressive)\n         flags |= DB_AGGRESSIVE;\n \n-    stringstream strDump;\n+    std::stringstream strDump;\n \n     Db db(dbenv, 0);\n     int result = db.verify(strFile.c_str(), NULL, &strDump, flags);\n@@ -325,7 +322,7 @@ bool CDBEnv::Salvage(const std::string& strFile, bool fAggressive, std::vector<C\n     //  ... repeated\n     // DATA=END\n \n-    string strLine;\n+    std::string strLine;\n     while (!strDump.eof() && strLine != HEADER_END)\n         getline(strDump, strLine); // Skip past header\n \n@@ -378,7 +375,7 @@ CDB::CDB(const std::string& strFilename, const char* pszMode, bool fFlushOnClose\n     {\n         LOCK(bitdb.cs_db);\n         if (!bitdb.Open(GetDataDir()))\n-            throw runtime_error(\"CDB: Failed to open database environment.\");\n+            throw std::runtime_error(\"CDB: Failed to open database environment.\");\n \n         strFile = strFilename;\n         ++bitdb.mapFileUseCount[strFile];\n@@ -391,7 +388,7 @@ CDB::CDB(const std::string& strFilename, const char* pszMode, bool fFlushOnClose\n                 DbMpoolFile* mpf = pdb->get_mpf();\n                 ret = mpf->set_flags(DB_MPOOL_NOFILE, 1);\n                 if (ret != 0)\n-                    throw runtime_error(strprintf(\"CDB: Failed to configure for no temp file backing for database %s\", strFile));\n+                    throw std::runtime_error(strprintf(\"CDB: Failed to configure for no temp file backing for database %s\", strFile));\n             }\n \n             ret = pdb->open(NULL,                               // Txn pointer\n@@ -406,10 +403,10 @@ CDB::CDB(const std::string& strFilename, const char* pszMode, bool fFlushOnClose\n                 pdb = NULL;\n                 --bitdb.mapFileUseCount[strFile];\n                 strFile = \"\";\n-                throw runtime_error(strprintf(\"CDB: Error %d, can't open database %s\", ret, strFilename));\n+                throw std::runtime_error(strprintf(\"CDB: Error %d, can't open database %s\", ret, strFilename));\n             }\n \n-            if (fCreate && !Exists(string(\"version\"))) {\n+            if (fCreate && !Exists(std::string(\"version\"))) {\n                 bool fTmp = fReadOnly;\n                 fReadOnly = false;\n                 WriteVersion(CLIENT_VERSION);\n@@ -452,7 +449,7 @@ void CDB::Close()\n     }\n }\n \n-void CDBEnv::CloseDb(const string& strFile)\n+void CDBEnv::CloseDb(const std::string& strFile)\n {\n     {\n         LOCK(cs_db);\n@@ -466,7 +463,7 @@ void CDBEnv::CloseDb(const string& strFile)\n     }\n }\n \n-bool CDBEnv::RemoveDb(const string& strFile)\n+bool CDBEnv::RemoveDb(const std::string& strFile)\n {\n     this->CloseDb(strFile);\n \n@@ -475,7 +472,7 @@ bool CDBEnv::RemoveDb(const string& strFile)\n     return (rc == 0);\n }\n \n-bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n+bool CDB::Rewrite(const std::string& strFile, const char* pszSkip)\n {\n     while (true) {\n         {\n@@ -488,7 +485,7 @@ bool CDB::Rewrite(const string& strFile, const char* pszSkip)\n \n                 bool fSuccess = true;\n                 LogPrintf(\"CDB::Rewrite: Rewriting %s...\\n\", strFile);\n-                string strFileRes = strFile + \".rewrite\";\n+                std::string strFileRes = strFile + \".rewrite\";\n                 { // surround usage of db with extra {}\n                     CDB db(strFile.c_str(), \"r\");\n                     Db* pdbCopy = new Db(bitdb.dbenv, 0);\n@@ -568,9 +565,9 @@ void CDBEnv::Flush(bool fShutdown)\n         return;\n     {\n         LOCK(cs_db);\n-        map<string, int>::iterator mi = mapFileUseCount.begin();\n+        std::map<std::string, int>::iterator mi = mapFileUseCount.begin();\n         while (mi != mapFileUseCount.end()) {\n-            string strFile = (*mi).first;\n+            std::string strFile = (*mi).first;\n             int nRefCount = (*mi).second;\n             LogPrint(\"db\", \"CDBEnv::Flush: Flushing %s (refcount = %d)...\\n\", strFile, nRefCount);\n             if (nRefCount == 0) {\n@@ -607,7 +604,7 @@ bool CDB::PeriodicFlush(std::string strFile)\n     {\n         // Don't do this if any databases are in use\n         int nRefCount = 0;\n-        map<string, int>::iterator mi = bitdb.mapFileUseCount.begin();\n+        std::map<std::string, int>::iterator mi = bitdb.mapFileUseCount.begin();\n         while (mi != bitdb.mapFileUseCount.end())\n         {\n             nRefCount += (*mi).second;\n@@ -617,7 +614,7 @@ bool CDB::PeriodicFlush(std::string strFile)\n         if (nRefCount == 0)\n         {\n             boost::this_thread::interruption_point();\n-            map<string, int>::iterator mi = bitdb.mapFileUseCount.find(strFile);\n+            std::map<std::string, int>::iterator mi = bitdb.mapFileUseCount.find(strFile);\n             if (mi != bitdb.mapFileUseCount.end())\n             {\n                 LogPrint(\"db\", \"Flushing %s\\n\", strFile);"
      },
      {
        "sha": "5006dbc477dfcb0c1b1d7dca41231d10cdb2691a",
        "filename": "src/wallet/rpcdump.cpp",
        "status": "modified",
        "additions": 30,
        "deletions": 32,
        "changes": 62,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8a5228197cec2e65f53bffe269c08ce94c440048/src/wallet/rpcdump.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8a5228197cec2e65f53bffe269c08ce94c440048/src/wallet/rpcdump.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcdump.cpp?ref=8a5228197cec2e65f53bffe269c08ce94c440048",
        "patch": "@@ -29,8 +29,6 @@\n #include <boost/assign/list_of.hpp>\n #include <boost/foreach.hpp>\n \n-using namespace std;\n-\n std::string static EncodeDumpTime(int64_t nTime) {\n     return DateTimeStrFormat(\"%Y-%m-%dT%H:%M:%SZ\", nTime);\n }\n@@ -82,7 +80,7 @@ UniValue importprivkey(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"importprivkey \\\"bitcoinprivkey\\\" ( \\\"label\\\" ) ( rescan )\\n\"\n             \"\\nAdds a private key (as returned by dumpprivkey) to your wallet.\\n\"\n             \"\\nArguments:\\n\"\n@@ -106,8 +104,8 @@ UniValue importprivkey(const JSONRPCRequest& request)\n \n     EnsureWalletIsUnlocked(pwallet);\n \n-    string strSecret = request.params[0].get_str();\n-    string strLabel = \"\";\n+    std::string strSecret = request.params[0].get_str();\n+    std::string strLabel = \"\";\n     if (request.params.size() > 1)\n         strLabel = request.params[1].get_str();\n \n@@ -156,8 +154,8 @@ UniValue importprivkey(const JSONRPCRequest& request)\n     return NullUniValue;\n }\n \n-void ImportAddress(CWallet*, const CBitcoinAddress& address, const string& strLabel);\n-void ImportScript(CWallet * const pwallet, const CScript& script, const string& strLabel, bool isRedeemScript)\n+void ImportAddress(CWallet*, const CBitcoinAddress& address, const std::string& strLabel);\n+void ImportScript(CWallet* const pwallet, const CScript& script, const std::string& strLabel, bool isRedeemScript)\n {\n     if (!isRedeemScript && ::IsMine(*pwallet, script) == ISMINE_SPENDABLE) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"The wallet already contains the private key for this address or script\");\n@@ -182,7 +180,7 @@ void ImportScript(CWallet * const pwallet, const CScript& script, const string&\n     }\n }\n \n-void ImportAddress(CWallet * const pwallet, const CBitcoinAddress& address, const string& strLabel)\n+void ImportAddress(CWallet* const pwallet, const CBitcoinAddress& address, const std::string& strLabel)\n {\n     CScript script = GetScriptForDestination(address.Get());\n     ImportScript(pwallet, script, strLabel, false);\n@@ -199,7 +197,7 @@ UniValue importaddress(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"importaddress \\\"address\\\" ( \\\"label\\\" rescan p2sh )\\n\"\n             \"\\nAdds a script (in hex) or address that can be watched as if it were in your wallet but cannot be used to spend.\\n\"\n             \"\\nArguments:\\n\"\n@@ -221,7 +219,7 @@ UniValue importaddress(const JSONRPCRequest& request)\n         );\n \n \n-    string strLabel = \"\";\n+    std::string strLabel = \"\";\n     if (request.params.size() > 1)\n         strLabel = request.params[1].get_str();\n \n@@ -269,7 +267,7 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() != 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"importprunedfunds\\n\"\n             \"\\nImports funds without rescan. Corresponding address or script must previously be included in wallet. Aimed towards pruned wallets. The end-user is responsible to import additional transactions that subsequently spend the imported outputs or rescan after the point in the blockchain the transaction is included.\\n\"\n             \"\\nArguments:\\n\"\n@@ -288,8 +286,8 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n     ssMB >> merkleBlock;\n \n     //Search partial merkle tree in proof for our transaction and index in valid block\n-    vector<uint256> vMatch;\n-    vector<unsigned int> vIndex;\n+    std::vector<uint256> vMatch;\n+    std::vector<unsigned int> vIndex;\n     unsigned int txnIndex = 0;\n     if (merkleBlock.txn.ExtractMatches(vMatch, vIndex) == merkleBlock.header.hashMerkleRoot) {\n \n@@ -298,7 +296,7 @@ UniValue importprunedfunds(const JSONRPCRequest& request)\n         if (!mapBlockIndex.count(merkleBlock.header.GetHash()) || !chainActive.Contains(mapBlockIndex[merkleBlock.header.GetHash()]))\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Block not found in chain\");\n \n-        vector<uint256>::const_iterator it;\n+        std::vector<uint256>::const_iterator it;\n         if ((it = std::find(vMatch.begin(), vMatch.end(), hashTx))==vMatch.end()) {\n             throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Transaction given doesn't exist in proof\");\n         }\n@@ -330,7 +328,7 @@ UniValue removeprunedfunds(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"removeprunedfunds \\\"txid\\\"\\n\"\n             \"\\nDeletes the specified transaction from the wallet. Meant for use with pruned wallets and as a companion to importprunedfunds. This will effect wallet balances.\\n\"\n             \"\\nArguments:\\n\"\n@@ -345,9 +343,9 @@ UniValue removeprunedfunds(const JSONRPCRequest& request)\n \n     uint256 hash;\n     hash.SetHex(request.params[0].get_str());\n-    vector<uint256> vHash;\n+    std::vector<uint256> vHash;\n     vHash.push_back(hash);\n-    vector<uint256> vHashOut;\n+    std::vector<uint256> vHashOut;\n \n     if (pwallet->ZapSelectTx(vHash, vHashOut) != DB_LOAD_OK) {\n         throw JSONRPCError(RPC_INTERNAL_ERROR, \"Could not properly delete the transaction.\");\n@@ -368,7 +366,7 @@ UniValue importpubkey(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 4)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"importpubkey \\\"pubkey\\\" ( \\\"label\\\" rescan )\\n\"\n             \"\\nAdds a public key (in hex) that can be watched as if it were in your wallet but cannot be used to spend.\\n\"\n             \"\\nArguments:\\n\"\n@@ -386,7 +384,7 @@ UniValue importpubkey(const JSONRPCRequest& request)\n         );\n \n \n-    string strLabel = \"\";\n+    std::string strLabel = \"\";\n     if (request.params.size() > 1)\n         strLabel = request.params[1].get_str();\n \n@@ -428,7 +426,7 @@ UniValue importwallet(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"importwallet \\\"filename\\\"\\n\"\n             \"\\nImports keys from a wallet dump file (see dumpwallet).\\n\"\n             \"\\nArguments:\\n\"\n@@ -449,7 +447,7 @@ UniValue importwallet(const JSONRPCRequest& request)\n \n     EnsureWalletIsUnlocked(pwallet);\n \n-    ifstream file;\n+    std::ifstream file;\n     file.open(request.params[0].get_str().c_str(), std::ios::in | std::ios::ate);\n     if (!file.is_open())\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n@@ -536,7 +534,7 @@ UniValue dumpprivkey(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"dumpprivkey \\\"address\\\"\\n\"\n             \"\\nReveals the private key corresponding to 'address'.\\n\"\n             \"Then the importprivkey can be used with this output\\n\"\n@@ -554,7 +552,7 @@ UniValue dumpprivkey(const JSONRPCRequest& request)\n \n     EnsureWalletIsUnlocked(pwallet);\n \n-    string strAddress = request.params[0].get_str();\n+    std::string strAddress = request.params[0].get_str();\n     CBitcoinAddress address;\n     if (!address.SetString(strAddress))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n@@ -577,7 +575,7 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"dumpwallet \\\"filename\\\"\\n\"\n             \"\\nDumps all wallet keys in a human-readable format.\\n\"\n             \"\\nArguments:\\n\"\n@@ -591,7 +589,7 @@ UniValue dumpwallet(const JSONRPCRequest& request)\n \n     EnsureWalletIsUnlocked(pwallet);\n \n-    ofstream file;\n+    std::ofstream file;\n     file.open(request.params[0].get_str().c_str());\n     if (!file.is_open())\n         throw JSONRPCError(RPC_INVALID_PARAMETER, \"Cannot open wallet dump file\");\n@@ -675,16 +673,16 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n         }\n \n         // Optional fields.\n-        const string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n+        const std::string& strRedeemScript = data.exists(\"redeemscript\") ? data[\"redeemscript\"].get_str() : \"\";\n         const UniValue& pubKeys = data.exists(\"pubkeys\") ? data[\"pubkeys\"].get_array() : UniValue();\n         const UniValue& keys = data.exists(\"keys\") ? data[\"keys\"].get_array() : UniValue();\n         const bool& internal = data.exists(\"internal\") ? data[\"internal\"].get_bool() : false;\n         const bool& watchOnly = data.exists(\"watchonly\") ? data[\"watchonly\"].get_bool() : false;\n-        const string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n+        const std::string& label = data.exists(\"label\") && !internal ? data[\"label\"].get_str() : \"\";\n \n         bool isScript = scriptPubKey.getType() == UniValue::VSTR;\n         bool isP2SH = strRedeemScript.length() > 0;\n-        const string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n+        const std::string& output = isScript ? scriptPubKey.get_str() : scriptPubKey[\"address\"].get_str();\n \n         // Parse the output.\n         CScript script;\n@@ -774,7 +772,7 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n             // Import private keys.\n             if (keys.size()) {\n                 for (size_t i = 0; i < keys.size(); i++) {\n-                    const string& privkey = keys[i].get_str();\n+                    const std::string& privkey = keys[i].get_str();\n \n                     CBitcoinSecret vchSecret;\n                     bool fGood = vchSecret.SetString(privkey);\n@@ -814,7 +812,7 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n         } else {\n             // Import public keys.\n             if (pubKeys.size() && keys.size() == 0) {\n-                const string& strPubKey = pubKeys[0].get_str();\n+                const std::string& strPubKey = pubKeys[0].get_str();\n \n                 if (!IsHex(strPubKey)) {\n                     throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Pubkey must be a hex string\");\n@@ -882,7 +880,7 @@ UniValue ProcessImport(CWallet * const pwallet, const UniValue& data, const int6\n \n             // Import private keys.\n             if (keys.size()) {\n-                const string& strPrivkey = keys[0].get_str();\n+                const std::string& strPrivkey = keys[0].get_str();\n \n                 // Checks.\n                 CBitcoinSecret vchSecret;\n@@ -1001,7 +999,7 @@ UniValue importmulti(const JSONRPCRequest& mainRequest)\n \n     // clang-format off\n     if (mainRequest.fHelp || mainRequest.params.size() < 1 || mainRequest.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"importmulti \\\"requests\\\" \\\"options\\\"\\n\\n\"\n             \"Import addresses/scripts (with private or public keys, redeem script (P2SH)), rescanning all addresses in one-shot-only (rescan can be disabled via options).\\n\\n\"\n             \"Arguments:\\n\""
      },
      {
        "sha": "f38b639becca2e0ad53a8db2119cd915fd851aac",
        "filename": "src/wallet/rpcwallet.cpp",
        "status": "modified",
        "additions": 119,
        "deletions": 121,
        "changes": 240,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8a5228197cec2e65f53bffe269c08ce94c440048/src/wallet/rpcwallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8a5228197cec2e65f53bffe269c08ce94c440048/src/wallet/rpcwallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/rpcwallet.cpp?ref=8a5228197cec2e65f53bffe269c08ce94c440048",
        "patch": "@@ -27,8 +27,6 @@\n \n #include <univalue.h>\n \n-using namespace std;\n-\n CWallet *GetWalletForJSONRPCRequest(const JSONRPCRequest& request)\n {\n     return pwalletMain;\n@@ -94,13 +92,13 @@ void WalletTxToJSON(const CWalletTx& wtx, UniValue& entry)\n     }\n     entry.push_back(Pair(\"bip125-replaceable\", rbfStatus));\n \n-    BOOST_FOREACH(const PAIRTYPE(string,string)& item, wtx.mapValue)\n+    BOOST_FOREACH(const PAIRTYPE(std::string, std::string)& item, wtx.mapValue)\n         entry.push_back(Pair(item.first, item.second));\n }\n \n-string AccountFromValue(const UniValue& value)\n+std::string AccountFromValue(const UniValue& value)\n {\n-    string strAccount = value.get_str();\n+    std::string strAccount = value.get_str();\n     if (strAccount == \"*\")\n         throw JSONRPCError(RPC_WALLET_INVALID_ACCOUNT_NAME, \"Invalid account name\");\n     return strAccount;\n@@ -114,7 +112,7 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getnewaddress ( \\\"account\\\" )\\n\"\n             \"\\nReturns a new Bitcoin address for receiving payments.\\n\"\n             \"If 'account' is specified (DEPRECATED), it is added to the address book \\n\"\n@@ -131,7 +129,7 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n     LOCK2(cs_main, pwallet->cs_wallet);\n \n     // Parse the account first so we don't generate a key if there's an error\n-    string strAccount;\n+    std::string strAccount;\n     if (request.params.size() > 0)\n         strAccount = AccountFromValue(request.params[0]);\n \n@@ -152,7 +150,7 @@ UniValue getnewaddress(const JSONRPCRequest& request)\n }\n \n \n-CBitcoinAddress GetAccountAddress(CWallet * const pwallet, string strAccount, bool bForceNew=false)\n+CBitcoinAddress GetAccountAddress(CWallet* const pwallet, std::string strAccount, bool bForceNew=false)\n {\n     CPubKey pubKey;\n     if (!pwallet->GetAccountPubkey(pubKey, strAccount, bForceNew)) {\n@@ -170,7 +168,7 @@ UniValue getaccountaddress(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getaccountaddress \\\"account\\\"\\n\"\n             \"\\nDEPRECATED. Returns the current Bitcoin address for receiving payments to this account.\\n\"\n             \"\\nArguments:\\n\"\n@@ -187,7 +185,7 @@ UniValue getaccountaddress(const JSONRPCRequest& request)\n     LOCK2(cs_main, pwallet->cs_wallet);\n \n     // Parse the account first so we don't generate a key if there's an error\n-    string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = AccountFromValue(request.params[0]);\n \n     UniValue ret(UniValue::VSTR);\n \n@@ -204,7 +202,7 @@ UniValue getrawchangeaddress(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getrawchangeaddress\\n\"\n             \"\\nReturns a new Bitcoin address, for receiving change.\\n\"\n             \"This is for use with raw transactions, NOT normal use.\\n\"\n@@ -242,7 +240,7 @@ UniValue setaccount(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"setaccount \\\"address\\\" \\\"account\\\"\\n\"\n             \"\\nDEPRECATED. Sets the account associated with the given address.\\n\"\n             \"\\nArguments:\\n\"\n@@ -259,15 +257,15 @@ UniValue setaccount(const JSONRPCRequest& request)\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n \n-    string strAccount;\n+    std::string strAccount;\n     if (request.params.size() > 1)\n         strAccount = AccountFromValue(request.params[1]);\n \n     // Only add the account if the address is yours.\n     if (IsMine(*pwallet, address.Get())) {\n         // Detect when changing the account of an address that is the 'unused current key' of another account:\n         if (pwallet->mapAddressBook.count(address.Get())) {\n-            string strOldAccount = pwallet->mapAddressBook[address.Get()].name;\n+            std::string strOldAccount = pwallet->mapAddressBook[address.Get()].name;\n             if (address == GetAccountAddress(pwallet, strOldAccount)) {\n                 GetAccountAddress(pwallet, strOldAccount, true);\n             }\n@@ -289,7 +287,7 @@ UniValue getaccount(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getaccount \\\"address\\\"\\n\"\n             \"\\nDEPRECATED. Returns the account associated with the given address.\\n\"\n             \"\\nArguments:\\n\"\n@@ -307,8 +305,8 @@ UniValue getaccount(const JSONRPCRequest& request)\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n \n-    string strAccount;\n-    map<CTxDestination, CAddressBookData>::iterator mi = pwallet->mapAddressBook.find(address.Get());\n+    std::string strAccount;\n+    std::map<CTxDestination, CAddressBookData>::iterator mi = pwallet->mapAddressBook.find(address.Get());\n     if (mi != pwallet->mapAddressBook.end() && !(*mi).second.name.empty()) {\n         strAccount = (*mi).second.name;\n     }\n@@ -324,7 +322,7 @@ UniValue getaddressesbyaccount(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getaddressesbyaccount \\\"account\\\"\\n\"\n             \"\\nDEPRECATED. Returns the list of addresses for the given account.\\n\"\n             \"\\nArguments:\\n\"\n@@ -341,13 +339,13 @@ UniValue getaddressesbyaccount(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = AccountFromValue(request.params[0]);\n \n     // Find all addresses that have the given account\n     UniValue ret(UniValue::VARR);\n     for (const std::pair<CBitcoinAddress, CAddressBookData>& item : pwallet->mapAddressBook) {\n         const CBitcoinAddress& address = item.first;\n-        const string& strName = item.second.name;\n+        const std::string& strName = item.second.name;\n         if (strName == strAccount)\n             ret.push_back(address.ToString());\n     }\n@@ -376,7 +374,7 @@ static void SendMoney(CWallet * const pwallet, const CTxDestination &address, CA\n     CReserveKey reservekey(pwallet);\n     CAmount nFeeRequired;\n     std::string strError;\n-    vector<CRecipient> vecSend;\n+    std::vector<CRecipient> vecSend;\n     int nChangePosRet = -1;\n     CRecipient recipient = {scriptPubKey, nValue, fSubtractFeeFromAmount};\n     vecSend.push_back(recipient);\n@@ -400,7 +398,7 @@ UniValue sendtoaddress(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 5)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"sendtoaddress \\\"address\\\" amount ( \\\"comment\\\" \\\"comment_to\\\" subtractfeefromamount )\\n\"\n             \"\\nSend an amount to a given address.\\n\"\n             + HelpRequiringPassphrase(pwallet) +\n@@ -460,7 +458,7 @@ UniValue listaddressgroupings(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listaddressgroupings\\n\"\n             \"\\nLists groups of addresses which have had their common ownership\\n\"\n             \"made public by common use as inputs or as the resulting change\\n\"\n@@ -485,8 +483,8 @@ UniValue listaddressgroupings(const JSONRPCRequest& request)\n     LOCK2(cs_main, pwallet->cs_wallet);\n \n     UniValue jsonGroupings(UniValue::VARR);\n-    map<CTxDestination, CAmount> balances = pwallet->GetAddressBalances();\n-    for (set<CTxDestination> grouping : pwallet->GetAddressGroupings()) {\n+    std::map<CTxDestination, CAmount> balances = pwallet->GetAddressBalances();\n+    for (std::set<CTxDestination> grouping : pwallet->GetAddressGroupings()) {\n         UniValue jsonGrouping(UniValue::VARR);\n         BOOST_FOREACH(CTxDestination address, grouping)\n         {\n@@ -513,7 +511,7 @@ UniValue signmessage(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() != 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"signmessage \\\"address\\\" \\\"message\\\"\\n\"\n             \"\\nSign a message with the private key of an address\"\n             + HelpRequiringPassphrase(pwallet) + \"\\n\"\n@@ -537,8 +535,8 @@ UniValue signmessage(const JSONRPCRequest& request)\n \n     EnsureWalletIsUnlocked(pwallet);\n \n-    string strAddress = request.params[0].get_str();\n-    string strMessage = request.params[1].get_str();\n+    std::string strAddress = request.params[0].get_str();\n+    std::string strMessage = request.params[1].get_str();\n \n     CBitcoinAddress addr(strAddress);\n     if (!addr.IsValid())\n@@ -557,7 +555,7 @@ UniValue signmessage(const JSONRPCRequest& request)\n     ss << strMessageMagic;\n     ss << strMessage;\n \n-    vector<unsigned char> vchSig;\n+    std::vector<unsigned char> vchSig;\n     if (!key.SignCompact(ss.GetHash(), vchSig))\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Sign failed\");\n \n@@ -572,7 +570,7 @@ UniValue getreceivedbyaddress(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getreceivedbyaddress \\\"address\\\" ( minconf )\\n\"\n             \"\\nReturns the total amount received by the given address in transactions with at least minconf confirmations.\\n\"\n             \"\\nArguments:\\n\"\n@@ -632,7 +630,7 @@ UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getreceivedbyaccount \\\"account\\\" ( minconf )\\n\"\n             \"\\nDEPRECATED. Returns the total amount received by addresses with <account> in transactions with at least [minconf] confirmations.\\n\"\n             \"\\nArguments:\\n\"\n@@ -659,8 +657,8 @@ UniValue getreceivedbyaccount(const JSONRPCRequest& request)\n         nMinDepth = request.params[1].get_int();\n \n     // Get the set of pub keys assigned to account\n-    string strAccount = AccountFromValue(request.params[0]);\n-    set<CTxDestination> setAddress = pwallet->GetAccountAddresses(strAccount);\n+    std::string strAccount = AccountFromValue(request.params[0]);\n+    std::set<CTxDestination> setAddress = pwallet->GetAccountAddresses(strAccount);\n \n     // Tally\n     CAmount nAmount = 0;\n@@ -691,7 +689,7 @@ UniValue getbalance(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() > 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getbalance ( \\\"account\\\" minconf include_watchonly )\\n\"\n             \"\\nIf account is not specified, returns the server's total available balance.\\n\"\n             \"If account is specified (DEPRECATED), returns the balance in the account.\\n\"\n@@ -750,9 +748,9 @@ UniValue getbalance(const JSONRPCRequest& request)\n                 continue;\n \n             CAmount allFee;\n-            string strSentAccount;\n-            list<COutputEntry> listReceived;\n-            list<COutputEntry> listSent;\n+            std::string strSentAccount;\n+            std::list<COutputEntry> listReceived;\n+            std::list<COutputEntry> listSent;\n             wtx.GetAmounts(listReceived, listSent, allFee, strSentAccount, filter);\n             if (wtx.GetDepthInMainChain() >= nMinDepth)\n             {\n@@ -766,7 +764,7 @@ UniValue getbalance(const JSONRPCRequest& request)\n         return  ValueFromAmount(nBalance);\n     }\n \n-    string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = AccountFromValue(request.params[0]);\n \n     CAmount nBalance = pwallet->GetAccountBalance(strAccount, nMinDepth, filter);\n \n@@ -781,7 +779,7 @@ UniValue getunconfirmedbalance(const JSONRPCRequest &request)\n     }\n \n     if (request.fHelp || request.params.size() > 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n                 \"getunconfirmedbalance\\n\"\n                 \"Returns the server's total unconfirmed balance\\n\");\n \n@@ -799,7 +797,7 @@ UniValue movecmd(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 3 || request.params.size() > 5)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"move \\\"fromaccount\\\" \\\"toaccount\\\" amount ( minconf \\\"comment\\\" )\\n\"\n             \"\\nDEPRECATED. Move a specified amount from one account in your wallet to another.\\n\"\n             \"\\nArguments:\\n\"\n@@ -821,15 +819,15 @@ UniValue movecmd(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    string strFrom = AccountFromValue(request.params[0]);\n-    string strTo = AccountFromValue(request.params[1]);\n+    std::string strFrom = AccountFromValue(request.params[0]);\n+    std::string strTo = AccountFromValue(request.params[1]);\n     CAmount nAmount = AmountFromValue(request.params[2]);\n     if (nAmount <= 0)\n         throw JSONRPCError(RPC_TYPE_ERROR, \"Invalid amount for send\");\n     if (request.params.size() > 3)\n         // unused parameter, used to be nMinDepth, keep type-checking it though\n         (void)request.params[3].get_int();\n-    string strComment;\n+    std::string strComment;\n     if (request.params.size() > 4)\n         strComment = request.params[4].get_str();\n \n@@ -849,7 +847,7 @@ UniValue sendfrom(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 3 || request.params.size() > 6)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"sendfrom \\\"fromaccount\\\" \\\"toaddress\\\" amount ( minconf \\\"comment\\\" \\\"comment_to\\\" )\\n\"\n             \"\\nDEPRECATED (use sendtoaddress). Sent an amount from an account to a bitcoin address.\"\n             + HelpRequiringPassphrase(pwallet) + \"\\n\"\n@@ -879,7 +877,7 @@ UniValue sendfrom(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = AccountFromValue(request.params[0]);\n     CBitcoinAddress address(request.params[1].get_str());\n     if (!address.IsValid())\n         throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, \"Invalid Bitcoin address\");\n@@ -918,7 +916,7 @@ UniValue sendmany(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 5)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"sendmany \\\"fromaccount\\\" {\\\"address\\\":amount,...} ( minconf \\\"comment\\\" [\\\"address\\\",...] )\\n\"\n             \"\\nSend multiple times. Amounts are double-precision floating point numbers.\"\n             + HelpRequiringPassphrase(pwallet) + \"\\n\"\n@@ -959,7 +957,7 @@ UniValue sendmany(const JSONRPCRequest& request)\n         throw JSONRPCError(RPC_CLIENT_P2P_DISABLED, \"Error: Peer-to-peer functionality missing or disabled\");\n     }\n \n-    string strAccount = AccountFromValue(request.params[0]);\n+    std::string strAccount = AccountFromValue(request.params[0]);\n     UniValue sendTo = request.params[1].get_obj();\n     int nMinDepth = 1;\n     if (request.params.size() > 2)\n@@ -974,19 +972,19 @@ UniValue sendmany(const JSONRPCRequest& request)\n     if (request.params.size() > 4)\n         subtractFeeFromAmount = request.params[4].get_array();\n \n-    set<CBitcoinAddress> setAddress;\n-    vector<CRecipient> vecSend;\n+    std::set<CBitcoinAddress> setAddress;\n+    std::vector<CRecipient> vecSend;\n \n     CAmount totalAmount = 0;\n-    vector<string> keys = sendTo.getKeys();\n-    BOOST_FOREACH(const string& name_, keys)\n+    std::vector<std::string> keys = sendTo.getKeys();\n+    BOOST_FOREACH(const std::string& name_, keys)\n     {\n         CBitcoinAddress address(name_);\n         if (!address.IsValid())\n-            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Bitcoin address: \")+name_);\n+            throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(\"Invalid Bitcoin address: \")+name_);\n \n         if (setAddress.count(address))\n-            throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \")+name_);\n+            throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated address: \")+name_);\n         setAddress.insert(address);\n \n         CScript scriptPubKey = GetScriptForDestination(address.Get());\n@@ -1017,7 +1015,7 @@ UniValue sendmany(const JSONRPCRequest& request)\n     CReserveKey keyChange(pwallet);\n     CAmount nFeeRequired = 0;\n     int nChangePosRet = -1;\n-    string strFailReason;\n+    std::string strFailReason;\n     bool fCreated = pwallet->CreateTransaction(vecSend, wtx, keyChange, nFeeRequired, nChangePosRet, strFailReason);\n     if (!fCreated)\n         throw JSONRPCError(RPC_WALLET_INSUFFICIENT_FUNDS, strFailReason);\n@@ -1042,7 +1040,7 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() < 2 || request.params.size() > 3)\n     {\n-        string msg = \"addmultisigaddress nrequired [\\\"key\\\",...] ( \\\"account\\\" )\\n\"\n+        std::string msg = \"addmultisigaddress nrequired [\\\"key\\\",...] ( \\\"account\\\" )\\n\"\n             \"\\nAdd a nrequired-to-sign multisignature address to the wallet.\\n\"\n             \"Each key is a Bitcoin address or hex-encoded public key.\\n\"\n             \"If 'account' is specified (DEPRECATED), assign address to that account.\\n\"\n@@ -1065,12 +1063,12 @@ UniValue addmultisigaddress(const JSONRPCRequest& request)\n             \"\\nAs json rpc call\\n\"\n             + HelpExampleRpc(\"addmultisigaddress\", \"2, \\\"[\\\\\\\"16sSauSf5pF2UkUwvKGq4qjNRzBZYqgEL5\\\\\\\",\\\\\\\"171sgjn4YtPu27adkKGrdDwzRTxnRkBfKV\\\\\\\"]\\\"\")\n         ;\n-        throw runtime_error(msg);\n+        throw std::runtime_error(msg);\n     }\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    string strAccount;\n+    std::string strAccount;\n     if (request.params.size() > 2)\n         strAccount = AccountFromValue(request.params[2]);\n \n@@ -1140,7 +1138,7 @@ UniValue addwitnessaddress(const JSONRPCRequest& request)\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 1)\n     {\n-        string msg = \"addwitnessaddress \\\"address\\\"\\n\"\n+        std::string msg = \"addwitnessaddress \\\"address\\\"\\n\"\n             \"\\nAdd a witness address for a script (with pubkey or redeemscript known).\\n\"\n             \"It returns the witness script.\\n\"\n \n@@ -1151,7 +1149,7 @@ UniValue addwitnessaddress(const JSONRPCRequest& request)\n             \"\\\"witnessaddress\\\",  (string) The value of the new address (P2SH of witness script).\\n\"\n             \"}\\n\"\n         ;\n-        throw runtime_error(msg);\n+        throw std::runtime_error(msg);\n     }\n \n     {\n@@ -1181,7 +1179,7 @@ struct tallyitem\n {\n     CAmount nAmount;\n     int nConf;\n-    vector<uint256> txids;\n+    std::vector<uint256> txids;\n     bool fIsWatchonly;\n     tallyitem()\n     {\n@@ -1209,7 +1207,7 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n             filter = filter | ISMINE_WATCH_ONLY;\n \n     // Tally\n-    map<CBitcoinAddress, tallyitem> mapTally;\n+    std::map<CBitcoinAddress, tallyitem> mapTally;\n     for (const std::pair<uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n         const CWalletTx& wtx = pairWtx.second;\n \n@@ -1232,7 +1230,7 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n \n             tallyitem& item = mapTally[address];\n             item.nAmount += txout.nValue;\n-            item.nConf = min(item.nConf, nDepth);\n+            item.nConf = std::min(item.nConf, nDepth);\n             item.txids.push_back(wtx.GetHash());\n             if (mine & ISMINE_WATCH_ONLY)\n                 item.fIsWatchonly = true;\n@@ -1241,11 +1239,11 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n \n     // Reply\n     UniValue ret(UniValue::VARR);\n-    map<string, tallyitem> mapAccountTally;\n+    std::map<std::string, tallyitem> mapAccountTally;\n     for (const std::pair<CBitcoinAddress, CAddressBookData>& item : pwallet->mapAddressBook) {\n         const CBitcoinAddress& address = item.first;\n-        const string& strAccount = item.second.name;\n-        map<CBitcoinAddress, tallyitem>::iterator it = mapTally.find(address);\n+        const std::string& strAccount = item.second.name;\n+        std::map<CBitcoinAddress, tallyitem>::iterator it = mapTally.find(address);\n         if (it == mapTally.end() && !fIncludeEmpty)\n             continue;\n \n@@ -1263,7 +1261,7 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n         {\n             tallyitem& _item = mapAccountTally[strAccount];\n             _item.nAmount += nAmount;\n-            _item.nConf = min(_item.nConf, nConf);\n+            _item.nConf = std::min(_item.nConf, nConf);\n             _item.fIsWatchonly = fIsWatchonly;\n         }\n         else\n@@ -1292,7 +1290,7 @@ UniValue ListReceived(CWallet * const pwallet, const UniValue& params, bool fByA\n \n     if (fByAccounts)\n     {\n-        for (map<string, tallyitem>::iterator it = mapAccountTally.begin(); it != mapAccountTally.end(); ++it)\n+        for (std::map<std::string, tallyitem>::iterator it = mapAccountTally.begin(); it != mapAccountTally.end(); ++it)\n         {\n             CAmount nAmount = (*it).second.nAmount;\n             int nConf = (*it).second.nConf;\n@@ -1317,7 +1315,7 @@ UniValue listreceivedbyaddress(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() > 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listreceivedbyaddress ( minconf include_empty include_watchonly)\\n\"\n             \"\\nList balances by receiving address.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1361,7 +1359,7 @@ UniValue listreceivedbyaccount(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() > 3)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listreceivedbyaccount ( minconf include_empty include_watchonly)\\n\"\n             \"\\nDEPRECATED. List balances by account.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1399,16 +1397,16 @@ static void MaybePushAddress(UniValue & entry, const CTxDestination &dest)\n         entry.push_back(Pair(\"address\", addr.ToString()));\n }\n \n-void ListTransactions(CWallet * const pwallet, const CWalletTx& wtx, const string& strAccount, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter)\n+void ListTransactions(CWallet* const pwallet, const CWalletTx& wtx, const std::string& strAccount, int nMinDepth, bool fLong, UniValue& ret, const isminefilter& filter)\n {\n     CAmount nFee;\n-    string strSentAccount;\n-    list<COutputEntry> listReceived;\n-    list<COutputEntry> listSent;\n+    std::string strSentAccount;\n+    std::list<COutputEntry> listReceived;\n+    std::list<COutputEntry> listSent;\n \n     wtx.GetAmounts(listReceived, listSent, nFee, strSentAccount, filter);\n \n-    bool fAllAccounts = (strAccount == string(\"*\"));\n+    bool fAllAccounts = (strAccount == std::string(\"*\"));\n     bool involvesWatchonly = wtx.IsFromMe(ISMINE_WATCH_ONLY);\n \n     // Sent\n@@ -1441,7 +1439,7 @@ void ListTransactions(CWallet * const pwallet, const CWalletTx& wtx, const strin\n     {\n         BOOST_FOREACH(const COutputEntry& r, listReceived)\n         {\n-            string account;\n+            std::string account;\n             if (pwallet->mapAddressBook.count(r.destination)) {\n                 account = pwallet->mapAddressBook[r.destination].name;\n             }\n@@ -1479,9 +1477,9 @@ void ListTransactions(CWallet * const pwallet, const CWalletTx& wtx, const strin\n     }\n }\n \n-void AcentryToJSON(const CAccountingEntry& acentry, const string& strAccount, UniValue& ret)\n+void AcentryToJSON(const CAccountingEntry& acentry, const std::string& strAccount, UniValue& ret)\n {\n-    bool fAllAccounts = (strAccount == string(\"*\"));\n+    bool fAllAccounts = (strAccount == std::string(\"*\"));\n \n     if (fAllAccounts || acentry.strAccount == strAccount)\n     {\n@@ -1504,7 +1502,7 @@ UniValue listtransactions(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() > 4)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listtransactions ( \\\"account\\\" count skip include_watchonly)\\n\"\n             \"\\nReturns up to 'count' most recent transactions skipping the first 'from' transactions for account 'account'.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1565,7 +1563,7 @@ UniValue listtransactions(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    string strAccount = \"*\";\n+    std::string strAccount = \"*\";\n     if (request.params.size() > 0)\n         strAccount = request.params[0].get_str();\n     int nCount = 10;\n@@ -1607,11 +1605,11 @@ UniValue listtransactions(const JSONRPCRequest& request)\n     if ((nFrom + nCount) > (int)ret.size())\n         nCount = ret.size() - nFrom;\n \n-    vector<UniValue> arrTmp = ret.getValues();\n+    std::vector<UniValue> arrTmp = ret.getValues();\n \n-    vector<UniValue>::iterator first = arrTmp.begin();\n+    std::vector<UniValue>::iterator first = arrTmp.begin();\n     std::advance(first, nFrom);\n-    vector<UniValue>::iterator last = arrTmp.begin();\n+    std::vector<UniValue>::iterator last = arrTmp.begin();\n     std::advance(last, nFrom+nCount);\n \n     if (last != arrTmp.end()) arrTmp.erase(last, arrTmp.end());\n@@ -1634,7 +1632,7 @@ UniValue listaccounts(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listaccounts ( minconf include_watchonly)\\n\"\n             \"\\nDEPRECATED. Returns Object that has account names as keys, account balances as values.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1666,7 +1664,7 @@ UniValue listaccounts(const JSONRPCRequest& request)\n         if(request.params[1].get_bool())\n             includeWatchonly = includeWatchonly | ISMINE_WATCH_ONLY;\n \n-    map<string, CAmount> mapAccountBalances;\n+    std::map<std::string, CAmount> mapAccountBalances;\n     for (const std::pair<CTxDestination, CAddressBookData>& entry : pwallet->mapAddressBook) {\n         if (IsMine(*pwallet, entry.first) & includeWatchonly) {  // This address belongs to me\n             mapAccountBalances[entry.second.name] = 0;\n@@ -1676,9 +1674,9 @@ UniValue listaccounts(const JSONRPCRequest& request)\n     for (const std::pair<uint256, CWalletTx>& pairWtx : pwallet->mapWallet) {\n         const CWalletTx& wtx = pairWtx.second;\n         CAmount nFee;\n-        string strSentAccount;\n-        list<COutputEntry> listReceived;\n-        list<COutputEntry> listSent;\n+        std::string strSentAccount;\n+        std::list<COutputEntry> listReceived;\n+        std::list<COutputEntry> listSent;\n         int nDepth = wtx.GetDepthInMainChain();\n         if (wtx.GetBlocksToMaturity() > 0 || nDepth < 0)\n             continue;\n@@ -1697,12 +1695,12 @@ UniValue listaccounts(const JSONRPCRequest& request)\n         }\n     }\n \n-    const list<CAccountingEntry> & acentries = pwallet->laccentries;\n+    const std::list<CAccountingEntry>& acentries = pwallet->laccentries;\n     BOOST_FOREACH(const CAccountingEntry& entry, acentries)\n         mapAccountBalances[entry.strAccount] += entry.nCreditDebit;\n \n     UniValue ret(UniValue::VOBJ);\n-    BOOST_FOREACH(const PAIRTYPE(string, CAmount)& accountBalance, mapAccountBalances) {\n+    BOOST_FOREACH(const PAIRTYPE(std::string, CAmount)& accountBalance, mapAccountBalances) {\n         ret.push_back(Pair(accountBalance.first, ValueFromAmount(accountBalance.second)));\n     }\n     return ret;\n@@ -1716,7 +1714,7 @@ UniValue listsinceblock(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listsinceblock ( \\\"blockhash\\\" target_confirmations include_watchonly)\\n\"\n             \"\\nGet all transactions in blocks since block [blockhash], or all transactions if omitted\\n\"\n             \"\\nArguments:\\n\"\n@@ -1823,7 +1821,7 @@ UniValue gettransaction(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"gettransaction \\\"txid\\\" ( include_watchonly )\\n\"\n             \"\\nGet detailed information about in-wallet transaction <txid>\\n\"\n             \"\\nArguments:\\n\"\n@@ -1898,7 +1896,7 @@ UniValue gettransaction(const JSONRPCRequest& request)\n     ListTransactions(pwallet, wtx, \"*\", 0, false, details, filter);\n     entry.push_back(Pair(\"details\", details));\n \n-    string strHex = EncodeHexTx(static_cast<CTransaction>(wtx), RPCSerializationFlags());\n+    std::string strHex = EncodeHexTx(static_cast<CTransaction>(wtx), RPCSerializationFlags());\n     entry.push_back(Pair(\"hex\", strHex));\n \n     return entry;\n@@ -1912,7 +1910,7 @@ UniValue abandontransaction(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"abandontransaction \\\"txid\\\"\\n\"\n             \"\\nMark in-wallet transaction <txid> as abandoned\\n\"\n             \"This will mark this transaction and all its in-wallet descendants as abandoned which will allow\\n\"\n@@ -1951,7 +1949,7 @@ UniValue backupwallet(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() != 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"backupwallet \\\"destination\\\"\\n\"\n             \"\\nSafely copies current wallet file to destination, which can be a directory or a path with filename.\\n\"\n             \"\\nArguments:\\n\"\n@@ -1963,7 +1961,7 @@ UniValue backupwallet(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    string strDest = request.params[0].get_str();\n+    std::string strDest = request.params[0].get_str();\n     if (!pwallet->BackupWallet(strDest)) {\n         throw JSONRPCError(RPC_WALLET_ERROR, \"Error: Wallet backup failed!\");\n     }\n@@ -1980,7 +1978,7 @@ UniValue keypoolrefill(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"keypoolrefill ( newsize )\\n\"\n             \"\\nFills the keypool.\"\n             + HelpRequiringPassphrase(pwallet) + \"\\n\"\n@@ -2027,7 +2025,7 @@ UniValue walletpassphrase(const JSONRPCRequest& request)\n     }\n \n     if (pwallet->IsCrypted() && (request.fHelp || request.params.size() != 2)) {\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"walletpassphrase \\\"passphrase\\\" timeout\\n\"\n             \"\\nStores the wallet decryption key in memory for 'timeout' seconds.\\n\"\n             \"This is needed prior to performing transactions related to private keys such as sending bitcoins\\n\"\n@@ -2069,7 +2067,7 @@ UniValue walletpassphrase(const JSONRPCRequest& request)\n         }\n     }\n     else\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"walletpassphrase <passphrase> <timeout>\\n\"\n             \"Stores the wallet decryption key in memory for <timeout> seconds.\");\n \n@@ -2091,7 +2089,7 @@ UniValue walletpassphrasechange(const JSONRPCRequest& request)\n     }\n \n     if (pwallet->IsCrypted() && (request.fHelp || request.params.size() != 2)) {\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"walletpassphrasechange \\\"oldpassphrase\\\" \\\"newpassphrase\\\"\\n\"\n             \"\\nChanges the wallet passphrase from 'oldpassphrase' to 'newpassphrase'.\\n\"\n             \"\\nArguments:\\n\"\n@@ -2122,7 +2120,7 @@ UniValue walletpassphrasechange(const JSONRPCRequest& request)\n     strNewWalletPass = request.params[1].get_str().c_str();\n \n     if (strOldWalletPass.length() < 1 || strNewWalletPass.length() < 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"walletpassphrasechange <oldpassphrase> <newpassphrase>\\n\"\n             \"Changes the wallet passphrase from <oldpassphrase> to <newpassphrase>.\");\n \n@@ -2142,7 +2140,7 @@ UniValue walletlock(const JSONRPCRequest& request)\n     }\n \n     if (pwallet->IsCrypted() && (request.fHelp || request.params.size() != 0)) {\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"walletlock\\n\"\n             \"\\nRemoves the wallet encryption key from memory, locking the wallet.\\n\"\n             \"After calling this method, you will need to call walletpassphrase again\\n\"\n@@ -2182,7 +2180,7 @@ UniValue encryptwallet(const JSONRPCRequest& request)\n     }\n \n     if (!pwallet->IsCrypted() && (request.fHelp || request.params.size() != 1)) {\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"encryptwallet \\\"passphrase\\\"\\n\"\n             \"\\nEncrypts the wallet with 'passphrase'. This is for first time encryption.\\n\"\n             \"After this, any calls that interact with private keys such as sending or signing \\n\"\n@@ -2221,7 +2219,7 @@ UniValue encryptwallet(const JSONRPCRequest& request)\n     strWalletPass = request.params[0].get_str().c_str();\n \n     if (strWalletPass.length() < 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"encryptwallet <passphrase>\\n\"\n             \"Encrypts the wallet with <passphrase>.\");\n \n@@ -2244,7 +2242,7 @@ UniValue lockunspent(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"lockunspent unlock ([{\\\"txid\\\":\\\"txid\\\",\\\"vout\\\":n},...])\\n\"\n             \"\\nUpdates list of temporarily unspendable outputs.\\n\"\n             \"Temporarily lock (unlock=false) or unlock (unlock=true) specified transaction outputs.\\n\"\n@@ -2308,7 +2306,7 @@ UniValue lockunspent(const JSONRPCRequest& request)\n                 {\"vout\", UniValueType(UniValue::VNUM)},\n             });\n \n-        string txid = find_value(o, \"txid\").get_str();\n+        std::string txid = find_value(o, \"txid\").get_str();\n         if (!IsHex(txid))\n             throw JSONRPCError(RPC_INVALID_PARAMETER, \"Invalid parameter, expected hex txid\");\n \n@@ -2335,7 +2333,7 @@ UniValue listlockunspent(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() > 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listlockunspent\\n\"\n             \"\\nReturns list of temporarily unspendable outputs.\\n\"\n             \"See the lockunspent call to lock and unlock transactions for spending.\\n\"\n@@ -2362,7 +2360,7 @@ UniValue listlockunspent(const JSONRPCRequest& request)\n \n     LOCK2(cs_main, pwallet->cs_wallet);\n \n-    vector<COutPoint> vOutpts;\n+    std::vector<COutPoint> vOutpts;\n     pwallet->ListLockedCoins(vOutpts);\n \n     UniValue ret(UniValue::VARR);\n@@ -2386,7 +2384,7 @@ UniValue settxfee(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 1)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"settxfee amount\\n\"\n             \"\\nSet the transaction fee per kB. Overwrites the paytxfee parameter.\\n\"\n             \"\\nArguments:\\n\"\n@@ -2415,7 +2413,7 @@ UniValue getwalletinfo(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"getwalletinfo\\n\"\n             \"Returns an object containing various wallet state info.\\n\"\n             \"\\nResult:\\n\"\n@@ -2464,7 +2462,7 @@ UniValue resendwallettransactions(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() != 0)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"resendwallettransactions\\n\"\n             \"Immediately re-broadcast unconfirmed wallet transactions to all peers.\\n\"\n             \"Intended only for testing; the wallet code periodically re-broadcasts\\n\"\n@@ -2494,7 +2492,7 @@ UniValue listunspent(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() > 4)\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"listunspent ( minconf maxconf  [\\\"addresses\\\",...] [include_unsafe] )\\n\"\n             \"\\nReturns array of unspent transaction outputs\\n\"\n             \"with between minconf and maxconf (inclusive) confirmations.\\n\"\n@@ -2546,17 +2544,17 @@ UniValue listunspent(const JSONRPCRequest& request)\n         nMaxDepth = request.params[1].get_int();\n     }\n \n-    set<CBitcoinAddress> setAddress;\n+    std::set<CBitcoinAddress> setAddress;\n     if (request.params.size() > 2 && !request.params[2].isNull()) {\n         RPCTypeCheckArgument(request.params[2], UniValue::VARR);\n         UniValue inputs = request.params[2].get_array();\n         for (unsigned int idx = 0; idx < inputs.size(); idx++) {\n             const UniValue& input = inputs[idx];\n             CBitcoinAddress address(input.get_str());\n             if (!address.IsValid())\n-                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, string(\"Invalid Bitcoin address: \")+input.get_str());\n+                throw JSONRPCError(RPC_INVALID_ADDRESS_OR_KEY, std::string(\"Invalid Bitcoin address: \")+input.get_str());\n             if (setAddress.count(address))\n-                throw JSONRPCError(RPC_INVALID_PARAMETER, string(\"Invalid parameter, duplicated address: \")+input.get_str());\n+                throw JSONRPCError(RPC_INVALID_PARAMETER, std::string(\"Invalid parameter, duplicated address: \")+input.get_str());\n            setAddress.insert(address);\n         }\n     }\n@@ -2568,7 +2566,7 @@ UniValue listunspent(const JSONRPCRequest& request)\n     }\n \n     UniValue results(UniValue::VARR);\n-    vector<COutput> vecOutputs;\n+    std::vector<COutput> vecOutputs;\n     assert(pwallet != NULL);\n     LOCK2(cs_main, pwallet->cs_wallet);\n     pwallet->AvailableCoins(vecOutputs, !include_unsafe, NULL, true);\n@@ -2622,7 +2620,7 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     }\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2)\n-        throw runtime_error(\n+        throw std::runtime_error(\n                             \"fundrawtransaction \\\"hexstring\\\" ( options )\\n\"\n                             \"\\nAdd inputs to a transaction until it has enough in value to meet its out value.\\n\"\n                             \"This will not modify existing inputs, and will add at most one change output to the outputs.\\n\"\n@@ -2679,7 +2677,7 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     CFeeRate feeRate = CFeeRate(0);\n     bool overrideEstimatedFeerate = false;\n     UniValue subtractFeeFromOutputs;\n-    set<int> setSubtractFeeFromOutputs;\n+    std::set<int> setSubtractFeeFromOutputs;\n \n     if (request.params.size() > 1) {\n       if (request.params[1].type() == UniValue::VBOOL) {\n@@ -2758,7 +2756,7 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n     }\n \n     CAmount nFeeOut;\n-    string strFailReason;\n+    std::string strFailReason;\n \n     if (!pwallet->FundTransaction(tx, nFeeOut, overrideEstimatedFeerate, feeRate, changePosition, strFailReason, includeWatching, lockUnspents, setSubtractFeeFromOutputs, reserveChangeKey, changeAddress)) {\n         throw JSONRPCError(RPC_INTERNAL_ERROR, strFailReason);\n@@ -2782,14 +2780,14 @@ UniValue fundrawtransaction(const JSONRPCRequest& request)\n int64_t CalculateMaximumSignedTxSize(const CTransaction &tx, CWallet &wallet)\n {\n     CMutableTransaction txNew(tx);\n-    std::vector<pair<CWalletTx *, unsigned int>> vCoins;\n+    std::vector<std::pair<CWalletTx*, unsigned int>> vCoins;\n     // Look up the inputs.  We should have already checked that this transaction\n     // IsAllFromMe(ISMINE_SPENDABLE), so every input should already be in our\n     // wallet, with a valid index into the vout array.\n     for (auto& input : tx.vin) {\n         const auto mi = wallet.mapWallet.find(input.prevout.hash);\n         assert(mi != wallet.mapWallet.end() && input.prevout.n < mi->second.tx->vout.size());\n-        vCoins.emplace_back(make_pair(&(mi->second), input.prevout.n));\n+        vCoins.emplace_back(std::make_pair(&(mi->second), input.prevout.n));\n     }\n     if (!wallet.DummySignTx(txNew, vCoins)) {\n         // This should never happen, because IsAllFromMe(ISMINE_SPENDABLE)\n@@ -2807,7 +2805,7 @@ UniValue bumpfee(const JSONRPCRequest& request)\n         return NullUniValue;\n \n     if (request.fHelp || request.params.size() < 1 || request.params.size() > 2) {\n-        throw runtime_error(\n+        throw std::runtime_error(\n             \"bumpfee \\\"txid\\\" ( options ) \\n\"\n             \"\\nBumps the fee of an opt-in-RBF transaction T, replacing it with a new transaction B.\\n\"\n             \"An opt-in RBF transaction with the given txid must be in the wallet.\\n\""
      },
      {
        "sha": "c94491ca21f20dfdc7f41e699fb3014724e9a7b9",
        "filename": "src/wallet/test/wallet_tests.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8a5228197cec2e65f53bffe269c08ce94c440048/src/wallet/test/wallet_tests.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8a5228197cec2e65f53bffe269c08ce94c440048/src/wallet/test/wallet_tests.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/test/wallet_tests.cpp?ref=8a5228197cec2e65f53bffe269c08ce94c440048",
        "patch": "@@ -27,16 +27,14 @@ extern UniValue importmulti(const JSONRPCRequest& request);\n // we repeat those tests this many times and only complain if all iterations of the test fail\n #define RANDOM_REPEATS 5\n \n-using namespace std;\n-\n std::vector<std::unique_ptr<CWalletTx>> wtxn;\n \n-typedef set<pair<const CWalletTx*,unsigned int> > CoinSet;\n+typedef std::set<std::pair<const CWalletTx*,unsigned int> > CoinSet;\n \n BOOST_FIXTURE_TEST_SUITE(wallet_tests, WalletTestingSetup)\n \n static const CWallet testWallet;\n-static vector<COutput> vCoins;\n+static std::vector<COutput> vCoins;\n \n static void add_coin(const CAmount& nValue, int nAge = 6*24, bool fIsFromMe = false, int nInput=0)\n {\n@@ -69,7 +67,7 @@ static void empty_wallet(void)\n \n static bool equal_sets(CoinSet a, CoinSet b)\n {\n-    pair<CoinSet::iterator, CoinSet::iterator> ret = mismatch(a.begin(), a.end(), b.begin());\n+    std::pair<CoinSet::iterator, CoinSet::iterator> ret = mismatch(a.begin(), a.end(), b.begin());\n     return ret.first == a.end() && ret.second == b.end();\n }\n "
      },
      {
        "sha": "07b34ae10effa9cda47bea35b3d6449900f96219",
        "filename": "src/wallet/wallet.cpp",
        "status": "modified",
        "additions": 98,
        "deletions": 100,
        "changes": 198,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8a5228197cec2e65f53bffe269c08ce94c440048/src/wallet/wallet.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8a5228197cec2e65f53bffe269c08ce94c440048/src/wallet/wallet.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/wallet.cpp?ref=8a5228197cec2e65f53bffe269c08ce94c440048",
        "patch": "@@ -33,8 +33,6 @@\n #include <boost/filesystem.hpp>\n #include <boost/thread.hpp>\n \n-using namespace std;\n-\n CWallet* pwalletMain = NULL;\n /** Transaction fee set by the user */\n CFeeRate payTxFee(DEFAULT_TRANSACTION_FEE);\n@@ -66,8 +64,8 @@ const uint256 CMerkleTx::ABANDON_HASH(uint256S(\"00000000000000000000000000000000\n \n struct CompareValueOnly\n {\n-    bool operator()(const pair<CAmount, pair<const CWalletTx*, unsigned int> >& t1,\n-                    const pair<CAmount, pair<const CWalletTx*, unsigned int> >& t2) const\n+    bool operator()(const std::pair<CAmount, std::pair<const CWalletTx*, unsigned int> >& t1,\n+                    const std::pair<CAmount, std::pair<const CWalletTx*, unsigned int> >& t2) const\n     {\n         return t1.first < t2.first;\n     }\n@@ -186,7 +184,7 @@ bool CWallet::AddKeyPubKey(const CKey& secret, const CPubKey &pubkey)\n }\n \n bool CWallet::AddCryptedKey(const CPubKey &vchPubKey,\n-                            const vector<unsigned char> &vchCryptedSecret)\n+                            const std::vector<unsigned char> &vchCryptedSecret)\n {\n     if (!CCryptoKeyStore::AddCryptedKey(vchPubKey, vchCryptedSecret))\n         return false;\n@@ -404,9 +402,9 @@ bool CWallet::SetMaxVersion(int nVersion)\n     return true;\n }\n \n-set<uint256> CWallet::GetConflicts(const uint256& txid) const\n+std::set<uint256> CWallet::GetConflicts(const uint256& txid) const\n {\n-    set<uint256> result;\n+    std::set<uint256> result;\n     AssertLockHeld(cs_wallet);\n \n     std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(txid);\n@@ -471,7 +469,7 @@ bool CWallet::Verify()\n     return true;\n }\n \n-void CWallet::SyncMetaData(pair<TxSpends::iterator, TxSpends::iterator> range)\n+void CWallet::SyncMetaData(std::pair<TxSpends::iterator, TxSpends::iterator> range)\n {\n     // We want all the wallet transactions in range to have the same metadata as\n     // the oldest (smallest nOrderPos).\n@@ -515,7 +513,7 @@ void CWallet::SyncMetaData(pair<TxSpends::iterator, TxSpends::iterator> range)\n bool CWallet::IsSpent(const uint256& hash, unsigned int n) const\n {\n     const COutPoint outpoint(hash, n);\n-    pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n+    std::pair<TxSpends::const_iterator, TxSpends::const_iterator> range;\n     range = mapTxSpends.equal_range(outpoint);\n \n     for (TxSpends::const_iterator it = range.first; it != range.second; ++it)\n@@ -533,9 +531,9 @@ bool CWallet::IsSpent(const uint256& hash, unsigned int n) const\n \n void CWallet::AddToSpends(const COutPoint& outpoint, const uint256& wtxid)\n {\n-    mapTxSpends.insert(make_pair(outpoint, wtxid));\n+    mapTxSpends.insert(std::make_pair(outpoint, wtxid));\n \n-    pair<TxSpends::iterator, TxSpends::iterator> range;\n+    std::pair<TxSpends::iterator, TxSpends::iterator> range;\n     range = mapTxSpends.equal_range(outpoint);\n     SyncMetaData(range);\n }\n@@ -661,20 +659,20 @@ DBErrors CWallet::ReorderTransactions()\n     // Probably a bad idea to change the output of this\n \n     // First: get all CWalletTx and CAccountingEntry into a sorted-by-time multimap.\n-    typedef pair<CWalletTx*, CAccountingEntry*> TxPair;\n-    typedef multimap<int64_t, TxPair > TxItems;\n+    typedef std::pair<CWalletTx*, CAccountingEntry*> TxPair;\n+    typedef std::multimap<int64_t, TxPair > TxItems;\n     TxItems txByTime;\n \n-    for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+    for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n     {\n         CWalletTx* wtx = &((*it).second);\n-        txByTime.insert(make_pair(wtx->nTimeReceived, TxPair(wtx, (CAccountingEntry*)0)));\n+        txByTime.insert(std::make_pair(wtx->nTimeReceived, TxPair(wtx, (CAccountingEntry*)0)));\n     }\n-    list<CAccountingEntry> acentries;\n+    std::list<CAccountingEntry> acentries;\n     walletdb.ListAccountCreditDebit(\"\", acentries);\n     BOOST_FOREACH(CAccountingEntry& entry, acentries)\n     {\n-        txByTime.insert(make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n+        txByTime.insert(std::make_pair(entry.nTime, TxPair((CWalletTx*)0, &entry)));\n     }\n \n     nOrderPosNext = 0;\n@@ -788,7 +786,7 @@ bool CWallet::GetAccountPubkey(CPubKey &pubKey, std::string strAccount, bool bFo\n         else {\n             // Check if the current key has been used\n             CScript scriptPubKey = GetScriptForDestination(account.vchPubKey.GetID());\n-            for (map<uint256, CWalletTx>::iterator it = mapWallet.begin();\n+            for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin();\n                  it != mapWallet.end() && account.vchPubKey.IsValid();\n                  ++it)\n                 BOOST_FOREACH(const CTxOut& txout, (*it).second.tx->vout)\n@@ -860,15 +858,15 @@ bool CWallet::AddToWallet(const CWalletTx& wtxIn, bool fFlushOnClose)\n     uint256 hash = wtxIn.GetHash();\n \n     // Inserts only if not already there, returns tx inserted or tx found\n-    pair<map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(make_pair(hash, wtxIn));\n+    std::pair<std::map<uint256, CWalletTx>::iterator, bool> ret = mapWallet.insert(std::make_pair(hash, wtxIn));\n     CWalletTx& wtx = (*ret.first).second;\n     wtx.BindWallet(this);\n     bool fInsertedNew = ret.second;\n     if (fInsertedNew)\n     {\n         wtx.nTimeReceived = GetAdjustedTime();\n         wtx.nOrderPos = IncOrderPosNext(&walletdb);\n-        wtxOrdered.insert(make_pair(wtx.nOrderPos, TxPair(&wtx, (CAccountingEntry*)0)));\n+        wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, (CAccountingEntry*)0)));\n         wtx.nTimeSmart = ComputeTimeSmart(wtx);\n         AddToSpends(hash);\n     }\n@@ -933,7 +931,7 @@ bool CWallet::LoadToWallet(const CWalletTx& wtxIn)\n     mapWallet[hash] = wtxIn;\n     CWalletTx& wtx = mapWallet[hash];\n     wtx.BindWallet(this);\n-    wtxOrdered.insert(make_pair(wtx.nOrderPos, TxPair(&wtx, (CAccountingEntry*)0)));\n+    wtxOrdered.insert(std::make_pair(wtx.nOrderPos, TxPair(&wtx, (CAccountingEntry*)0)));\n     AddToSpends(hash);\n     BOOST_FOREACH(const CTxIn& txin, wtx.tx->vin) {\n         if (mapWallet.count(txin.prevout.hash)) {\n@@ -1132,7 +1130,7 @@ isminetype CWallet::IsMine(const CTxIn &txin) const\n {\n     {\n         LOCK(cs_wallet);\n-        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n+        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n         if (mi != mapWallet.end())\n         {\n             const CWalletTx& prev = (*mi).second;\n@@ -1149,7 +1147,7 @@ CAmount CWallet::GetDebit(const CTxIn &txin, const isminefilter& filter) const\n {\n     {\n         LOCK(cs_wallet);\n-        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n+        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(txin.prevout.hash);\n         if (mi != mapWallet.end())\n         {\n             const CWalletTx& prev = (*mi).second;\n@@ -1323,7 +1321,7 @@ bool CWallet::SetHDChain(const CHDChain& chain, bool memonly)\n {\n     LOCK(cs_wallet);\n     if (!memonly && !CWalletDB(strWalletFile).WriteHDChain(chain))\n-        throw runtime_error(std::string(__func__) + \": writing chain failed\");\n+        throw std::runtime_error(std::string(__func__) + \": writing chain failed\");\n \n     hdChain = chain;\n     return true;\n@@ -1351,23 +1349,23 @@ int CWalletTx::GetRequestCount() const\n             // Generated block\n             if (!hashUnset())\n             {\n-                map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n+                std::map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(hashBlock);\n                 if (mi != pwallet->mapRequestCount.end())\n                     nRequests = (*mi).second;\n             }\n         }\n         else\n         {\n             // Did anyone request this transaction?\n-            map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(GetHash());\n+            std::map<uint256, int>::const_iterator mi = pwallet->mapRequestCount.find(GetHash());\n             if (mi != pwallet->mapRequestCount.end())\n             {\n                 nRequests = (*mi).second;\n \n                 // How about the block it's in?\n                 if (nRequests == 0 && !hashUnset())\n                 {\n-                    map<uint256, int>::const_iterator _mi = pwallet->mapRequestCount.find(hashBlock);\n+                    std::map<uint256, int>::const_iterator _mi = pwallet->mapRequestCount.find(hashBlock);\n                     if (_mi != pwallet->mapRequestCount.end())\n                         nRequests = (*_mi).second;\n                     else\n@@ -1379,8 +1377,8 @@ int CWalletTx::GetRequestCount() const\n     return nRequests;\n }\n \n-void CWalletTx::GetAmounts(list<COutputEntry>& listReceived,\n-                           list<COutputEntry>& listSent, CAmount& nFee, string& strSentAccount, const isminefilter& filter) const\n+void CWalletTx::GetAmounts(std::list<COutputEntry>& listReceived,\n+                           std::list<COutputEntry>& listSent, CAmount& nFee, std::string& strSentAccount, const isminefilter& filter) const\n {\n     nFee = 0;\n     listReceived.clear();\n@@ -1435,15 +1433,15 @@ void CWalletTx::GetAmounts(list<COutputEntry>& listReceived,\n \n }\n \n-void CWalletTx::GetAccountAmounts(const string& strAccount, CAmount& nReceived,\n+void CWalletTx::GetAccountAmounts(const std::string& strAccount, CAmount& nReceived,\n                                   CAmount& nSent, CAmount& nFee, const isminefilter& filter) const\n {\n     nReceived = nSent = nFee = 0;\n \n     CAmount allFee;\n-    string strSentAccount;\n-    list<COutputEntry> listReceived;\n-    list<COutputEntry> listSent;\n+    std::string strSentAccount;\n+    std::list<COutputEntry> listReceived;\n+    std::list<COutputEntry> listSent;\n     GetAmounts(listReceived, listSent, allFee, strSentAccount, filter);\n \n     if (strAccount == strSentAccount)\n@@ -1458,7 +1456,7 @@ void CWalletTx::GetAccountAmounts(const string& strAccount, CAmount& nReceived,\n         {\n             if (pwallet->mapAddressBook.count(r.destination))\n             {\n-                map<CTxDestination, CAddressBookData>::const_iterator mi = pwallet->mapAddressBook.find(r.destination);\n+                std::map<CTxDestination, CAddressBookData>::const_iterator mi = pwallet->mapAddressBook.find(r.destination);\n                 if (mi != pwallet->mapAddressBook.end() && (*mi).second.name == strAccount)\n                     nReceived += r.amount;\n             }\n@@ -1579,9 +1577,9 @@ bool CWalletTx::RelayWalletTransaction(CConnman* connman)\n     return false;\n }\n \n-set<uint256> CWalletTx::GetConflicts() const\n+std::set<uint256> CWalletTx::GetConflicts() const\n {\n-    set<uint256> result;\n+    std::set<uint256> result;\n     if (pwallet != NULL)\n     {\n         uint256 myHash = GetHash();\n@@ -1806,14 +1804,14 @@ std::vector<uint256> CWallet::ResendWalletTransactionsBefore(int64_t nTime, CCon\n \n     LOCK(cs_wallet);\n     // Sort them in chronological order\n-    multimap<unsigned int, CWalletTx*> mapSorted;\n+    std::multimap<unsigned int, CWalletTx*> mapSorted;\n     BOOST_FOREACH(PAIRTYPE(const uint256, CWalletTx)& item, mapWallet)\n     {\n         CWalletTx& wtx = item.second;\n         // Don't rebroadcast if newer than nTime:\n         if (wtx.nTimeReceived > nTime)\n             continue;\n-        mapSorted.insert(make_pair(wtx.nTimeReceived, &wtx));\n+        mapSorted.insert(std::make_pair(wtx.nTimeReceived, &wtx));\n     }\n     BOOST_FOREACH(PAIRTYPE(const unsigned int, CWalletTx*)& item, mapSorted)\n     {\n@@ -1863,7 +1861,7 @@ CAmount CWallet::GetBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n             if (pcoin->IsTrusted())\n@@ -1879,7 +1877,7 @@ CAmount CWallet::GetUnconfirmedBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n             if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && pcoin->InMempool())\n@@ -1894,7 +1892,7 @@ CAmount CWallet::GetImmatureBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n             nTotal += pcoin->GetImmatureCredit();\n@@ -1908,7 +1906,7 @@ CAmount CWallet::GetWatchOnlyBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n             if (pcoin->IsTrusted())\n@@ -1924,7 +1922,7 @@ CAmount CWallet::GetUnconfirmedWatchOnlyBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n             if (!pcoin->IsTrusted() && pcoin->GetDepthInMainChain() == 0 && pcoin->InMempool())\n@@ -1939,7 +1937,7 @@ CAmount CWallet::GetImmatureWatchOnlyBalance() const\n     CAmount nTotal = 0;\n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const CWalletTx* pcoin = &(*it).second;\n             nTotal += pcoin->GetImmatureWatchOnlyCredit();\n@@ -1948,13 +1946,13 @@ CAmount CWallet::GetImmatureWatchOnlyBalance() const\n     return nTotal;\n }\n \n-void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl, bool fIncludeZeroValue) const\n+void CWallet::AvailableCoins(std::vector<COutput>& vCoins, bool fOnlyConfirmed, const CCoinControl *coinControl, bool fIncludeZeroValue) const\n {\n     vCoins.clear();\n \n     {\n         LOCK2(cs_main, cs_wallet);\n-        for (map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+        for (std::map<uint256, CWalletTx>::const_iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n         {\n             const uint256& wtxid = it->first;\n             const CWalletTx* pcoin = &(*it).second;\n@@ -2022,10 +2020,10 @@ void CWallet::AvailableCoins(vector<COutput>& vCoins, bool fOnlyConfirmed, const\n     }\n }\n \n-static void ApproximateBestSubset(vector<pair<CAmount, pair<const CWalletTx*,unsigned int> > >vValue, const CAmount& nTotalLower, const CAmount& nTargetValue,\n-                                  vector<char>& vfBest, CAmount& nBest, int iterations = 1000)\n+static void ApproximateBestSubset(std::vector<std::pair<CAmount, std::pair<const CWalletTx*,unsigned int> > >vValue, const CAmount& nTotalLower, const CAmount& nTargetValue,\n+                                  std::vector<char>& vfBest, CAmount& nBest, int iterations = 1000)\n {\n-    vector<char> vfIncluded;\n+    std::vector<char> vfIncluded;\n \n     vfBest.assign(vValue.size(), true);\n     nBest = nTotalLower;\n@@ -2068,17 +2066,17 @@ static void ApproximateBestSubset(vector<pair<CAmount, pair<const CWalletTx*,uns\n     }\n }\n \n-bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMine, const int nConfTheirs, const uint64_t nMaxAncestors, vector<COutput> vCoins,\n-                                 set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet) const\n+bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMine, const int nConfTheirs, const uint64_t nMaxAncestors, std::vector<COutput> vCoins,\n+                                 std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet) const\n {\n     setCoinsRet.clear();\n     nValueRet = 0;\n \n     // List of values less than target\n-    pair<CAmount, pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n+    std::pair<CAmount, std::pair<const CWalletTx*,unsigned int> > coinLowestLarger;\n     coinLowestLarger.first = std::numeric_limits<CAmount>::max();\n     coinLowestLarger.second.first = NULL;\n-    vector<pair<CAmount, pair<const CWalletTx*,unsigned int> > > vValue;\n+    std::vector<std::pair<CAmount, std::pair<const CWalletTx*,unsigned int> > > vValue;\n     CAmount nTotalLower = 0;\n \n     random_shuffle(vCoins.begin(), vCoins.end(), GetRandInt);\n@@ -2099,7 +2097,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMin\n         int i = output.i;\n         CAmount n = pcoin->tx->vout[i].nValue;\n \n-        pair<CAmount,pair<const CWalletTx*,unsigned int> > coin = make_pair(n,make_pair(pcoin, i));\n+        std::pair<CAmount,std::pair<const CWalletTx*,unsigned int> > coin = std::make_pair(n,std::make_pair(pcoin, i));\n \n         if (n == nTargetValue)\n         {\n@@ -2140,7 +2138,7 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMin\n     // Solve subset sum by stochastic approximation\n     std::sort(vValue.begin(), vValue.end(), CompareValueOnly());\n     std::reverse(vValue.begin(), vValue.end());\n-    vector<char> vfBest;\n+    std::vector<char> vfBest;\n     CAmount nBest;\n \n     ApproximateBestSubset(vValue, nTotalLower, nTargetValue, vfBest, nBest);\n@@ -2173,9 +2171,9 @@ bool CWallet::SelectCoinsMinConf(const CAmount& nTargetValue, const int nConfMin\n     return true;\n }\n \n-bool CWallet::SelectCoins(const vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, set<pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl* coinControl) const\n+bool CWallet::SelectCoins(const std::vector<COutput>& vAvailableCoins, const CAmount& nTargetValue, std::set<std::pair<const CWalletTx*,unsigned int> >& setCoinsRet, CAmount& nValueRet, const CCoinControl* coinControl) const\n {\n-    vector<COutput> vCoins(vAvailableCoins);\n+    std::vector<COutput> vCoins(vAvailableCoins);\n \n     // coin control -> return all selected outputs (we want all selected to go into the transaction for sure)\n     if (coinControl && coinControl->HasSelected() && !coinControl->fAllowOtherInputs)\n@@ -2185,37 +2183,37 @@ bool CWallet::SelectCoins(const vector<COutput>& vAvailableCoins, const CAmount&\n             if (!out.fSpendable)\n                  continue;\n             nValueRet += out.tx->tx->vout[out.i].nValue;\n-            setCoinsRet.insert(make_pair(out.tx, out.i));\n+            setCoinsRet.insert(std::make_pair(out.tx, out.i));\n         }\n         return (nValueRet >= nTargetValue);\n     }\n \n     // calculate value from preset inputs and store them\n-    set<pair<const CWalletTx*, uint32_t> > setPresetCoins;\n+    std::set<std::pair<const CWalletTx*, uint32_t> > setPresetCoins;\n     CAmount nValueFromPresetInputs = 0;\n \n     std::vector<COutPoint> vPresetInputs;\n     if (coinControl)\n         coinControl->ListSelected(vPresetInputs);\n     BOOST_FOREACH(const COutPoint& outpoint, vPresetInputs)\n     {\n-        map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n+        std::map<uint256, CWalletTx>::const_iterator it = mapWallet.find(outpoint.hash);\n         if (it != mapWallet.end())\n         {\n             const CWalletTx* pcoin = &it->second;\n             // Clearly invalid input, fail\n             if (pcoin->tx->vout.size() <= outpoint.n)\n                 return false;\n             nValueFromPresetInputs += pcoin->tx->vout[outpoint.n].nValue;\n-            setPresetCoins.insert(make_pair(pcoin, outpoint.n));\n+            setPresetCoins.insert(std::make_pair(pcoin, outpoint.n));\n         } else\n             return false; // TODO: Allow non-wallet inputs\n     }\n \n     // remove preset inputs from vCoins\n-    for (vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coinControl && coinControl->HasSelected();)\n+    for (std::vector<COutput>::iterator it = vCoins.begin(); it != vCoins.end() && coinControl && coinControl->HasSelected();)\n     {\n-        if (setPresetCoins.count(make_pair(it->tx, it->i)))\n+        if (setPresetCoins.count(std::make_pair(it->tx, it->i)))\n             it = vCoins.erase(it);\n         else\n             ++it;\n@@ -2244,7 +2242,7 @@ bool CWallet::SelectCoins(const vector<COutput>& vAvailableCoins, const CAmount&\n \n bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, bool overrideEstimatedFeeRate, const CFeeRate& specificFeeRate, int& nChangePosInOut, std::string& strFailReason, bool includeWatching, bool lockUnspents, const std::set<int>& setSubtractFeeFromOutputs, bool keepReserveKey, const CTxDestination& destChange)\n {\n-    vector<CRecipient> vecSend;\n+    std::vector<CRecipient> vecSend;\n \n     // Turn the txout set into a CRecipient vector\n     for (size_t idx = 0; idx < tx.vout.size(); idx++)\n@@ -2298,7 +2296,7 @@ bool CWallet::FundTransaction(CMutableTransaction& tx, CAmount& nFeeRet, bool ov\n     return true;\n }\n \n-bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet,\n+bool CWallet::CreateTransaction(const std::vector<CRecipient>& vecSend, CWalletTx& wtxNew, CReserveKey& reservekey, CAmount& nFeeRet,\n                                 int& nChangePosInOut, std::string& strFailReason, const CCoinControl* coinControl, bool sign)\n {\n     CAmount nValue = 0;\n@@ -2359,7 +2357,7 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n     assert(txNew.nLockTime < LOCKTIME_THRESHOLD);\n \n     {\n-        set<pair<const CWalletTx*,unsigned int> > setCoins;\n+        std::set<std::pair<const CWalletTx*,unsigned int> > setCoins;\n         LOCK2(cs_main, cs_wallet);\n         {\n             std::vector<COutput> vAvailableCoins;\n@@ -2499,7 +2497,7 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n                             return false;\n                         }\n \n-                        vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n+                        std::vector<CTxOut>::iterator position = txNew.vout.begin()+nChangePosInOut;\n                         txNew.vout.insert(position, newTxOut);\n                     }\n                 }\n@@ -2569,7 +2567,7 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n                     // to be addressed so we avoid creating too small an output.\n                     if (nFeeRet > nFeeNeeded && nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n                         CAmount extraFeePaid = nFeeRet - nFeeNeeded;\n-                        vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n+                        std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n                         change_position->nValue += extraFeePaid;\n                         nFeeRet -= extraFeePaid;\n                     }\n@@ -2579,7 +2577,7 @@ bool CWallet::CreateTransaction(const vector<CRecipient>& vecSend, CWalletTx& wt\n                 // Try to reduce change to include necessary fee\n                 if (nChangePosInOut != -1 && nSubtractFeeFromAmount == 0) {\n                     CAmount additionalFeeNeeded = nFeeNeeded - nFeeRet;\n-                    vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n+                    std::vector<CTxOut>::iterator change_position = txNew.vout.begin()+nChangePosInOut;\n                     // Only reduce change if remaining amount is still a large enough output.\n                     if (change_position->nValue >= MIN_FINAL_CHANGE + additionalFeeNeeded) {\n                         change_position->nValue -= additionalFeeNeeded;\n@@ -2705,7 +2703,7 @@ bool CWallet::AddAccountingEntry(const CAccountingEntry& acentry, CWalletDB *pwa\n \n     laccentries.push_back(acentry);\n     CAccountingEntry & entry = laccentries.back();\n-    wtxOrdered.insert(make_pair(entry.nOrderPos, TxPair((CWalletTx*)0, &entry)));\n+    wtxOrdered.insert(std::make_pair(entry.nOrderPos, TxPair((CWalletTx*)0, &entry)));\n \n     return true;\n }\n@@ -2770,7 +2768,7 @@ DBErrors CWallet::LoadWallet(bool& fFirstRunRet)\n     return DB_LOAD_OK;\n }\n \n-DBErrors CWallet::ZapSelectTx(vector<uint256>& vHashIn, vector<uint256>& vHashOut)\n+DBErrors CWallet::ZapSelectTx(std::vector<uint256>& vHashIn, std::vector<uint256>& vHashOut)\n {\n     if (!fFileBacked)\n         return DB_LOAD_OK;\n@@ -2825,7 +2823,7 @@ DBErrors CWallet::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n }\n \n \n-bool CWallet::SetAddressBook(const CTxDestination& address, const string& strName, const string& strPurpose)\n+bool CWallet::SetAddressBook(const CTxDestination& address, const std::string& strName, const std::string& strPurpose)\n {\n     bool fUpdated = false;\n     {\n@@ -2854,7 +2852,7 @@ bool CWallet::DelAddressBook(const CTxDestination& address)\n         {\n             // Delete destdata tuples associated with address\n             std::string strAddress = CBitcoinAddress(address).ToString();\n-            BOOST_FOREACH(const PAIRTYPE(string, string) &item, mapAddressBook[address].destdata)\n+            BOOST_FOREACH(const PAIRTYPE(std::string, std::string) &item, mapAddressBook[address].destdata)\n             {\n                 CWalletDB(strWalletFile).EraseDestData(strAddress, item.first);\n             }\n@@ -2897,7 +2895,7 @@ bool CWallet::NewKeyPool()\n         if (IsLocked())\n             return false;\n \n-        int64_t nKeys = max(GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE), (int64_t)0);\n+        int64_t nKeys = std::max(GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE), (int64_t)0);\n         for (int i = 0; i < nKeys; i++)\n         {\n             int64_t nIndex = i+1;\n@@ -2924,15 +2922,15 @@ bool CWallet::TopUpKeyPool(unsigned int kpSize)\n         if (kpSize > 0)\n             nTargetSize = kpSize;\n         else\n-            nTargetSize = max(GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE), (int64_t) 0);\n+            nTargetSize = std::max(GetArg(\"-keypool\", DEFAULT_KEYPOOL_SIZE), (int64_t) 0);\n \n         while (setKeyPool.size() < (nTargetSize + 1))\n         {\n             int64_t nEnd = 1;\n             if (!setKeyPool.empty())\n                 nEnd = *(--setKeyPool.end()) + 1;\n             if (!walletdb.WritePool(nEnd, CKeyPool(GenerateNewKey())))\n-                throw runtime_error(std::string(__func__) + \": writing generated key failed\");\n+                throw std::runtime_error(std::string(__func__) + \": writing generated key failed\");\n             setKeyPool.insert(nEnd);\n             LogPrintf(\"keypool added key %d, size=%u\\n\", nEnd, setKeyPool.size());\n         }\n@@ -2959,9 +2957,9 @@ void CWallet::ReserveKeyFromKeyPool(int64_t& nIndex, CKeyPool& keypool)\n         nIndex = *(setKeyPool.begin());\n         setKeyPool.erase(setKeyPool.begin());\n         if (!walletdb.ReadPool(nIndex, keypool))\n-            throw runtime_error(std::string(__func__) + \": read failed\");\n+            throw std::runtime_error(std::string(__func__) + \": read failed\");\n         if (!HaveKey(keypool.vchPubKey.GetID()))\n-            throw runtime_error(std::string(__func__) + \": unknown key in key pool\");\n+            throw std::runtime_error(std::string(__func__) + \": unknown key in key pool\");\n         assert(keypool.vchPubKey.IsValid());\n         LogPrintf(\"keypool reserve %d\\n\", nIndex);\n     }\n@@ -3020,14 +3018,14 @@ int64_t CWallet::GetOldestKeyPoolTime()\n     CWalletDB walletdb(strWalletFile);\n     int64_t nIndex = *(setKeyPool.begin());\n     if (!walletdb.ReadPool(nIndex, keypool))\n-        throw runtime_error(std::string(__func__) + \": read oldest key in keypool failed\");\n+        throw std::runtime_error(std::string(__func__) + \": read oldest key in keypool failed\");\n     assert(keypool.vchPubKey.IsValid());\n     return keypool.nTime;\n }\n \n std::map<CTxDestination, CAmount> CWallet::GetAddressBalances()\n {\n-    map<CTxDestination, CAmount> balances;\n+    std::map<CTxDestination, CAmount> balances;\n \n     {\n         LOCK(cs_wallet);\n@@ -3065,11 +3063,11 @@ std::map<CTxDestination, CAmount> CWallet::GetAddressBalances()\n     return balances;\n }\n \n-set< set<CTxDestination> > CWallet::GetAddressGroupings()\n+std::set< std::set<CTxDestination> > CWallet::GetAddressGroupings()\n {\n     AssertLockHeld(cs_wallet); // mapWallet\n-    set< set<CTxDestination> > groupings;\n-    set<CTxDestination> grouping;\n+    std::set< std::set<CTxDestination> > groupings;\n+    std::set<CTxDestination> grouping;\n \n     BOOST_FOREACH(PAIRTYPE(uint256, CWalletTx) walletEntry, mapWallet)\n     {\n@@ -3122,20 +3120,20 @@ set< set<CTxDestination> > CWallet::GetAddressGroupings()\n             }\n     }\n \n-    set< set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n-    map< CTxDestination, set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n-    BOOST_FOREACH(set<CTxDestination> _grouping, groupings)\n+    std::set< std::set<CTxDestination>* > uniqueGroupings; // a set of pointers to groups of addresses\n+    std::map< CTxDestination, std::set<CTxDestination>* > setmap;  // map addresses to the unique group containing it\n+    BOOST_FOREACH(std::set<CTxDestination> _grouping, groupings)\n     {\n         // make a set of all the groups hit by this new group\n-        set< set<CTxDestination>* > hits;\n-        map< CTxDestination, set<CTxDestination>* >::iterator it;\n+        std::set< std::set<CTxDestination>* > hits;\n+        std::map< CTxDestination, std::set<CTxDestination>* >::iterator it;\n         BOOST_FOREACH(CTxDestination address, _grouping)\n             if ((it = setmap.find(address)) != setmap.end())\n                 hits.insert((*it).second);\n \n         // merge all hit groups into a new single group and delete old groups\n-        set<CTxDestination>* merged = new set<CTxDestination>(_grouping);\n-        BOOST_FOREACH(set<CTxDestination>* hit, hits)\n+        std::set<CTxDestination>* merged = new std::set<CTxDestination>(_grouping);\n+        BOOST_FOREACH(std::set<CTxDestination>* hit, hits)\n         {\n             merged->insert(hit->begin(), hit->end());\n             uniqueGroupings.erase(hit);\n@@ -3148,8 +3146,8 @@ set< set<CTxDestination> > CWallet::GetAddressGroupings()\n             setmap[element] = merged;\n     }\n \n-    set< set<CTxDestination> > ret;\n-    BOOST_FOREACH(set<CTxDestination>* uniqueGrouping, uniqueGroupings)\n+    std::set< std::set<CTxDestination> > ret;\n+    BOOST_FOREACH(std::set<CTxDestination>* uniqueGrouping, uniqueGroupings)\n     {\n         ret.insert(*uniqueGrouping);\n         delete uniqueGrouping;\n@@ -3169,7 +3167,7 @@ CAmount CWallet::GetAccountBalance(CWalletDB& walletdb, const std::string& strAc\n     CAmount nBalance = 0;\n \n     // Tally wallet transactions\n-    for (map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n+    for (std::map<uint256, CWalletTx>::iterator it = mapWallet.begin(); it != mapWallet.end(); ++it)\n     {\n         const CWalletTx& wtx = (*it).second;\n         if (!CheckFinalTx(wtx) || wtx.GetBlocksToMaturity() > 0 || wtx.GetDepthInMainChain() < 0)\n@@ -3192,11 +3190,11 @@ CAmount CWallet::GetAccountBalance(CWalletDB& walletdb, const std::string& strAc\n std::set<CTxDestination> CWallet::GetAccountAddresses(const std::string& strAccount) const\n {\n     LOCK(cs_wallet);\n-    set<CTxDestination> result;\n+    std::set<CTxDestination> result;\n     BOOST_FOREACH(const PAIRTYPE(CTxDestination, CAddressBookData)& item, mapAddressBook)\n     {\n         const CTxDestination& address = item.first;\n-        const string& strName = item.second.name;\n+        const std::string& strName = item.second.name;\n         if (strName == strAccount)\n             result.insert(address);\n     }\n@@ -3236,7 +3234,7 @@ void CReserveKey::ReturnKey()\n     vchPubKey = CPubKey();\n }\n \n-void CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const\n+void CWallet::GetAllReserveKeys(std::set<CKeyID>& setAddress) const\n {\n     setAddress.clear();\n \n@@ -3247,11 +3245,11 @@ void CWallet::GetAllReserveKeys(set<CKeyID>& setAddress) const\n     {\n         CKeyPool keypool;\n         if (!walletdb.ReadPool(id, keypool))\n-            throw runtime_error(std::string(__func__) + \": read failed\");\n+            throw std::runtime_error(std::string(__func__) + \": read failed\");\n         assert(keypool.vchPubKey.IsValid());\n         CKeyID keyID = keypool.vchPubKey.GetID();\n         if (!HaveKey(keyID))\n-            throw runtime_error(std::string(__func__) + \": unknown key in key pool\");\n+            throw std::runtime_error(std::string(__func__) + \": unknown key in key pool\");\n         setAddress.insert(keyID);\n     }\n }\n@@ -3261,7 +3259,7 @@ void CWallet::UpdatedTransaction(const uint256 &hashTx)\n     {\n         LOCK(cs_wallet);\n         // Only notify UI if this transaction is in this wallet\n-        map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashTx);\n+        std::map<uint256, CWalletTx>::const_iterator mi = mapWallet.find(hashTx);\n         if (mi != mapWallet.end())\n             NotifyTransactionChanged(this, hashTx, CT_UPDATED);\n     }\n@@ -3932,7 +3930,7 @@ int CMerkleTx::GetBlocksToMaturity() const\n {\n     if (!IsCoinBase())\n         return 0;\n-    return max(0, (COINBASE_MATURITY+1) - GetDepthInMainChain());\n+    return std::max(0, (COINBASE_MATURITY+1) - GetDepthInMainChain());\n }\n \n "
      },
      {
        "sha": "d017965385b20741bfe7d0dfb61abc0b4c796cc5",
        "filename": "src/wallet/walletdb.cpp",
        "status": "modified",
        "additions": 36,
        "deletions": 38,
        "changes": 74,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/8a5228197cec2e65f53bffe269c08ce94c440048/src/wallet/walletdb.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/8a5228197cec2e65f53bffe269c08ce94c440048/src/wallet/walletdb.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/wallet/walletdb.cpp?ref=8a5228197cec2e65f53bffe269c08ce94c440048",
        "patch": "@@ -22,8 +22,6 @@\n #include <boost/foreach.hpp>\n #include <boost/thread.hpp>\n \n-using namespace std;\n-\n static uint64_t nAccountingEntryNumber = 0;\n \n static std::atomic<unsigned int> nWalletDBUpdateCounter;\n@@ -32,30 +30,30 @@ static std::atomic<unsigned int> nWalletDBUpdateCounter;\n // CWalletDB\n //\n \n-bool CWalletDB::WriteName(const string& strAddress, const string& strName)\n+bool CWalletDB::WriteName(const std::string& strAddress, const std::string& strName)\n {\n     nWalletDBUpdateCounter++;\n-    return Write(make_pair(string(\"name\"), strAddress), strName);\n+    return Write(make_pair(std::string(\"name\"), strAddress), strName);\n }\n \n-bool CWalletDB::EraseName(const string& strAddress)\n+bool CWalletDB::EraseName(const std::string& strAddress)\n {\n     // This should only be used for sending addresses, never for receiving addresses,\n     // receiving addresses must always have an address book entry if they're not change return.\n     nWalletDBUpdateCounter++;\n-    return Erase(make_pair(string(\"name\"), strAddress));\n+    return Erase(make_pair(std::string(\"name\"), strAddress));\n }\n \n-bool CWalletDB::WritePurpose(const string& strAddress, const string& strPurpose)\n+bool CWalletDB::WritePurpose(const std::string& strAddress, const std::string& strPurpose)\n {\n     nWalletDBUpdateCounter++;\n-    return Write(make_pair(string(\"purpose\"), strAddress), strPurpose);\n+    return Write(make_pair(std::string(\"purpose\"), strAddress), strPurpose);\n }\n \n-bool CWalletDB::ErasePurpose(const string& strPurpose)\n+bool CWalletDB::ErasePurpose(const std::string& strPurpose)\n {\n     nWalletDBUpdateCounter++;\n-    return Erase(make_pair(string(\"purpose\"), strPurpose));\n+    return Erase(make_pair(std::string(\"purpose\"), strPurpose));\n }\n \n bool CWalletDB::WriteTx(const CWalletTx& wtx)\n@@ -183,15 +181,15 @@ bool CWalletDB::WriteMinVersion(int nVersion)\n     return Write(std::string(\"minversion\"), nVersion);\n }\n \n-bool CWalletDB::ReadAccount(const string& strAccount, CAccount& account)\n+bool CWalletDB::ReadAccount(const std::string& strAccount, CAccount& account)\n {\n     account.SetNull();\n-    return Read(make_pair(string(\"acc\"), strAccount), account);\n+    return Read(make_pair(std::string(\"acc\"), strAccount), account);\n }\n \n-bool CWalletDB::WriteAccount(const string& strAccount, const CAccount& account)\n+bool CWalletDB::WriteAccount(const std::string& strAccount, const CAccount& account)\n {\n-    return Write(make_pair(string(\"acc\"), strAccount), account);\n+    return Write(make_pair(std::string(\"acc\"), strAccount), account);\n }\n \n bool CWalletDB::WriteAccountingEntry(const uint64_t nAccEntryNum, const CAccountingEntry& acentry)\n@@ -204,9 +202,9 @@ bool CWalletDB::WriteAccountingEntry_Backend(const CAccountingEntry& acentry)\n     return WriteAccountingEntry(++nAccountingEntryNumber, acentry);\n }\n \n-CAmount CWalletDB::GetAccountCreditDebit(const string& strAccount)\n+CAmount CWalletDB::GetAccountCreditDebit(const std::string& strAccount)\n {\n-    list<CAccountingEntry> entries;\n+    std::list<CAccountingEntry> entries;\n     ListAccountCreditDebit(strAccount, entries);\n \n     CAmount nCreditDebit = 0;\n@@ -216,20 +214,20 @@ CAmount CWalletDB::GetAccountCreditDebit(const string& strAccount)\n     return nCreditDebit;\n }\n \n-void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountingEntry>& entries)\n+void CWalletDB::ListAccountCreditDebit(const std::string& strAccount, std::list<CAccountingEntry>& entries)\n {\n     bool fAllAccounts = (strAccount == \"*\");\n \n     Dbc* pcursor = GetCursor();\n     if (!pcursor)\n-        throw runtime_error(std::string(__func__) + \": cannot create DB cursor\");\n+        throw std::runtime_error(std::string(__func__) + \": cannot create DB cursor\");\n     bool setRange = true;\n     while (true)\n     {\n         // Read next record\n         CDataStream ssKey(SER_DISK, CLIENT_VERSION);\n         if (setRange)\n-            ssKey << std::make_pair(std::string(\"acentry\"), std::make_pair((fAllAccounts ? string(\"\") : strAccount), uint64_t(0)));\n+            ssKey << std::make_pair(std::string(\"acentry\"), std::make_pair((fAllAccounts ? std::string(\"\") : strAccount), uint64_t(0)));\n         CDataStream ssValue(SER_DISK, CLIENT_VERSION);\n         int ret = ReadAtCursor(pcursor, ssKey, ssValue, setRange);\n         setRange = false;\n@@ -238,11 +236,11 @@ void CWalletDB::ListAccountCreditDebit(const string& strAccount, list<CAccountin\n         else if (ret != 0)\n         {\n             pcursor->close();\n-            throw runtime_error(std::string(__func__) + \": error scanning DB\");\n+            throw std::runtime_error(std::string(__func__) + \": error scanning DB\");\n         }\n \n         // Unserialize\n-        string strType;\n+        std::string strType;\n         ssKey >> strType;\n         if (strType != \"acentry\")\n             break;\n@@ -268,7 +266,7 @@ class CWalletScanState {\n     bool fIsEncrypted;\n     bool fAnyUnordered;\n     int nFileVersion;\n-    vector<uint256> vWalletUpgrade;\n+    std::vector<uint256> vWalletUpgrade;\n \n     CWalletScanState() {\n         nKeys = nCKeys = nWatchKeys = nKeyMeta = 0;\n@@ -280,7 +278,7 @@ class CWalletScanState {\n \n bool\n ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n-             CWalletScanState &wss, string& strType, string& strErr)\n+             CWalletScanState &wss, std::string& strType, std::string& strErr)\n {\n     try {\n         // Unserialize\n@@ -289,13 +287,13 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         ssKey >> strType;\n         if (strType == \"name\")\n         {\n-            string strAddress;\n+            std::string strAddress;\n             ssKey >> strAddress;\n             ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()].name;\n         }\n         else if (strType == \"purpose\")\n         {\n-            string strAddress;\n+            std::string strAddress;\n             ssKey >> strAddress;\n             ssValue >> pwallet->mapAddressBook[CBitcoinAddress(strAddress).Get()].purpose;\n         }\n@@ -336,7 +334,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n         }\n         else if (strType == \"acentry\")\n         {\n-            string strAccount;\n+            std::string strAccount;\n             ssKey >> strAccount;\n             uint64_t nNumber;\n             ssKey >> nNumber;\n@@ -449,7 +447,7 @@ ReadKeyValue(CWallet* pwallet, CDataStream& ssKey, CDataStream& ssValue,\n                 strErr = \"Error reading wallet database: CPubKey corrupt\";\n                 return false;\n             }\n-            vector<unsigned char> vchPrivKey;\n+            std::vector<unsigned char> vchPrivKey;\n             ssValue >> vchPrivKey;\n             wss.nCKeys++;\n \n@@ -562,7 +560,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n     LOCK(pwallet->cs_wallet);\n     try {\n         int nMinVersion = 0;\n-        if (Read((string)\"minversion\", nMinVersion))\n+        if (Read((std::string)\"minversion\", nMinVersion))\n         {\n             if (nMinVersion > CLIENT_VERSION)\n                 return DB_TOO_NEW;\n@@ -592,7 +590,7 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n             }\n \n             // Try to be tolerant of single corrupt records:\n-            string strType, strErr;\n+            std::string strType, strErr;\n             if (!ReadKeyValue(pwallet, ssKey, ssValue, wss, strType, strErr))\n             {\n                 // losing keys is considered a catastrophic error, anything else\n@@ -659,14 +657,14 @@ DBErrors CWalletDB::LoadWallet(CWallet* pwallet)\n     return result;\n }\n \n-DBErrors CWalletDB::FindWalletTx(vector<uint256>& vTxHash, vector<CWalletTx>& vWtx)\n+DBErrors CWalletDB::FindWalletTx(std::vector<uint256>& vTxHash, std::vector<CWalletTx>& vWtx)\n {\n     bool fNoncriticalErrors = false;\n     DBErrors result = DB_LOAD_OK;\n \n     try {\n         int nMinVersion = 0;\n-        if (Read((string)\"minversion\", nMinVersion))\n+        if (Read((std::string)\"minversion\", nMinVersion))\n         {\n             if (nMinVersion > CLIENT_VERSION)\n                 return DB_TOO_NEW;\n@@ -694,7 +692,7 @@ DBErrors CWalletDB::FindWalletTx(vector<uint256>& vTxHash, vector<CWalletTx>& vW\n                 return DB_CORRUPT;\n             }\n \n-            string strType;\n+            std::string strType;\n             ssKey >> strType;\n             if (strType == \"tx\") {\n                 uint256 hash;\n@@ -722,11 +720,11 @@ DBErrors CWalletDB::FindWalletTx(vector<uint256>& vTxHash, vector<CWalletTx>& vW\n     return result;\n }\n \n-DBErrors CWalletDB::ZapSelectTx(vector<uint256>& vTxHashIn, vector<uint256>& vTxHashOut)\n+DBErrors CWalletDB::ZapSelectTx(std::vector<uint256>& vTxHashIn, std::vector<uint256>& vTxHashOut)\n {\n     // build list of wallet TXs and hashes\n-    vector<uint256> vTxHash;\n-    vector<CWalletTx> vWtx;\n+    std::vector<uint256> vTxHash;\n+    std::vector<CWalletTx> vWtx;\n     DBErrors err = FindWalletTx(vTxHash, vWtx);\n     if (err != DB_LOAD_OK) {\n         return err;\n@@ -737,7 +735,7 @@ DBErrors CWalletDB::ZapSelectTx(vector<uint256>& vTxHashIn, vector<uint256>& vTx\n \n     // erase each matching wallet TX\n     bool delerror = false;\n-    vector<uint256>::iterator it = vTxHashIn.begin();\n+    std::vector<uint256>::iterator it = vTxHashIn.begin();\n     BOOST_FOREACH (uint256 hash, vTxHash) {\n         while (it < vTxHashIn.end() && (*it) < hash) {\n             it++;\n@@ -760,10 +758,10 @@ DBErrors CWalletDB::ZapSelectTx(vector<uint256>& vTxHashIn, vector<uint256>& vTx\n     return DB_LOAD_OK;\n }\n \n-DBErrors CWalletDB::ZapWalletTx(vector<CWalletTx>& vWtx)\n+DBErrors CWalletDB::ZapWalletTx(std::vector<CWalletTx>& vWtx)\n {\n     // build list of wallet TXs\n-    vector<uint256> vTxHash;\n+    std::vector<uint256> vTxHash;\n     DBErrors err = FindWalletTx(vTxHash, vWtx);\n     if (err != DB_LOAD_OK)\n         return err;"
      }
    ]
  },
  {
    "sha": "a57845c20e96825f1256e6b7f46d67d205c859e0",
    "node_id": "MDY6Q29tbWl0MTE4MTkyNzphNTc4NDVjMjBlOTY4MjVmMTI1NmU2YjdmNDZkNjdkMjA1Yzg1OWUw",
    "commit": {
      "author": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-01-27T01:34:06Z"
      },
      "committer": {
        "name": "Karl-Johan Alm",
        "email": "karljohan-alm@garage.co.jp",
        "date": "2017-03-08T16:47:02Z"
      },
      "message": "Refactor: Remove using namespace <xxx> from util*",
      "tree": {
        "sha": "b23c938430cfc2734831903ed0e00c3ab67b5746",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/git/trees/b23c938430cfc2734831903ed0e00c3ab67b5746"
      },
      "url": "https://api.github.com/repos/bitcoin/bitcoin/git/commits/a57845c20e96825f1256e6b7f46d67d205c859e0",
      "comment_count": 0,
      "verification": {
        "verified": true,
        "reason": "valid",
        "signature": "-----BEGIN PGP SIGNATURE-----\n\niQIcBAABCAAGBQJYwDWHAAoJEFevdi2zNTMiW5MP/iPfaW1HeCCu6bE4nCETloxM\ndqgqaDm6AUDvFku65FNl00iGOMlb1iK1ZY9KIjKv+QSzlx1IgyZTA0kcY3tpDngs\nCpje/gb9jX3Ca65HGxW8zDooQJWnsrC4V0Z7NOFjv/sHGmJClNiR+dSjj/X4JUff\n5c+fkAnzQ0+Te27VuFH5QThqlPhtsz/MhQfP7WZjXXPpP16W5nf6QmDXZsa1lqFl\nwIaL1mTDmu1JU60s3NNn1GfeS3aQOWF8++xKrYdSz4rOuW77Y5/I0phT7pcKKhDV\nk2N6touJBOaonQJHHdVRnHEJGVKTyIvxyN1Zh5xpBLBDZXI1zdJaa77OIw87T9a7\nidT61MguVHnEbp7Jnv9bmJWj3SYceg32agdWd1ETT82d6kLe8q346WTEULJIex8K\nI+BcC5xtYRzmdsfX0yG0uUpqkjc07KMYyCvHBsbB6rUVTpWYSRWZZC0T+HTZ/bIu\nDhwUqIyM3TFJCEVXd7KY8eWExCHig2oP/SIjRO9Ahp2r1d0pU/uYFSY6ricS1sLY\nL99PycXaj+Rf/rbYoeoAd7+Cz//ywLqkB7doBxd2/hsk7w+oAtbD5R5xe+qQrxTT\nkoWQEPw8sxBxgoOom5rDjD+ZsdMzwbXzuVNnASmTAPCJt9frttkUujnzhBN4HHgP\n/VEorMrVMje2/t/xOjmi\n=fK7I\n-----END PGP SIGNATURE-----",
        "payload": "tree b23c938430cfc2734831903ed0e00c3ab67b5746\nparent 8a5228197cec2e65f53bffe269c08ce94c440048\nauthor Karl-Johan Alm <karljohan-alm@garage.co.jp> 1485480846 +0900\ncommitter Karl-Johan Alm <karljohan-alm@garage.co.jp> 1488991622 -0800\n\nRefactor: Remove using namespace <xxx> from util*\n"
      }
    },
    "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a57845c20e96825f1256e6b7f46d67d205c859e0",
    "html_url": "https://github.com/bitcoin/bitcoin/commit/a57845c20e96825f1256e6b7f46d67d205c859e0",
    "comments_url": "https://api.github.com/repos/bitcoin/bitcoin/commits/a57845c20e96825f1256e6b7f46d67d205c859e0/comments",
    "author": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "committer": {
      "login": "kallewoof",
      "id": 250224,
      "node_id": "MDQ6VXNlcjI1MDIyNA==",
      "avatar_url": "https://avatars.githubusercontent.com/u/250224?v=4",
      "gravatar_id": "",
      "url": "https://api.github.com/users/kallewoof",
      "html_url": "https://github.com/kallewoof",
      "followers_url": "https://api.github.com/users/kallewoof/followers",
      "following_url": "https://api.github.com/users/kallewoof/following{/other_user}",
      "gists_url": "https://api.github.com/users/kallewoof/gists{/gist_id}",
      "starred_url": "https://api.github.com/users/kallewoof/starred{/owner}{/repo}",
      "subscriptions_url": "https://api.github.com/users/kallewoof/subscriptions",
      "organizations_url": "https://api.github.com/users/kallewoof/orgs",
      "repos_url": "https://api.github.com/users/kallewoof/repos",
      "events_url": "https://api.github.com/users/kallewoof/events{/privacy}",
      "received_events_url": "https://api.github.com/users/kallewoof/received_events",
      "type": "User",
      "site_admin": false
    },
    "parents": [
      {
        "sha": "8a5228197cec2e65f53bffe269c08ce94c440048",
        "url": "https://api.github.com/repos/bitcoin/bitcoin/commits/8a5228197cec2e65f53bffe269c08ce94c440048",
        "html_url": "https://github.com/bitcoin/bitcoin/commit/8a5228197cec2e65f53bffe269c08ce94c440048"
      }
    ],
    "stats": {
      "total": 98,
      "additions": 46,
      "deletions": 52
    },
    "files": [
      {
        "sha": "30c530cb41dbd56d0d6828406bf0599dcc1546f3",
        "filename": "src/util.cpp",
        "status": "modified",
        "additions": 19,
        "deletions": 19,
        "changes": 38,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a57845c20e96825f1256e6b7f46d67d205c859e0/src/util.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a57845c20e96825f1256e6b7f46d67d205c859e0/src/util.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/util.cpp?ref=a57845c20e96825f1256e6b7f46d67d205c859e0",
        "patch": "@@ -97,15 +97,15 @@ namespace boost {\n \n } // namespace boost\n \n-using namespace std;\n+\n \n const char * const BITCOIN_CONF_FILENAME = \"bitcoin.conf\";\n const char * const BITCOIN_PID_FILENAME = \"bitcoind.pid\";\n \n CCriticalSection cs_args;\n-map<string, string> mapArgs;\n-static map<string, vector<string> > _mapMultiArgs;\n-const map<string, vector<string> >& mapMultiArgs = _mapMultiArgs;\n+std::map<std::string, std::string> mapArgs;\n+static std::map<std::string, std::vector<std::string> > _mapMultiArgs;\n+const std::map<std::string, std::vector<std::string> >& mapMultiArgs = _mapMultiArgs;\n bool fDebug = false;\n bool fPrintToConsole = false;\n bool fPrintToDebugLog = true;\n@@ -191,7 +191,7 @@ static boost::once_flag debugPrintInitFlag = BOOST_ONCE_INIT;\n  */\n static FILE* fileout = NULL;\n static boost::mutex* mutexDebugLog = NULL;\n-static list<string> *vMsgsBeforeOpenLog;\n+static std::list<std::string>* vMsgsBeforeOpenLog;\n \n static int FileWriteStr(const std::string &str, FILE *fp)\n {\n@@ -202,7 +202,7 @@ static void DebugPrintInit()\n {\n     assert(mutexDebugLog == NULL);\n     mutexDebugLog = new boost::mutex();\n-    vMsgsBeforeOpenLog = new list<string>;\n+    vMsgsBeforeOpenLog = new std::list<std::string>;\n }\n \n void OpenDebugLog()\n@@ -238,22 +238,22 @@ bool LogAcceptCategory(const char* category)\n         // This helps prevent issues debugging global destructors,\n         // where mapMultiArgs might be deleted before another\n         // global destructor calls LogPrint()\n-        static boost::thread_specific_ptr<set<string> > ptrCategory;\n+        static boost::thread_specific_ptr<std::set<std::string> > ptrCategory;\n         if (ptrCategory.get() == NULL)\n         {\n             if (mapMultiArgs.count(\"-debug\")) {\n-                const vector<string>& categories = mapMultiArgs.at(\"-debug\");\n-                ptrCategory.reset(new set<string>(categories.begin(), categories.end()));\n+                const std::vector<std::string>& categories = mapMultiArgs.at(\"-debug\");\n+                ptrCategory.reset(new std::set<std::string>(categories.begin(), categories.end()));\n                 // thread_specific_ptr automatically deletes the set when the thread ends.\n             } else\n-                ptrCategory.reset(new set<string>());\n+                ptrCategory.reset(new std::set<std::string>());\n         }\n-        const set<string>& setCategories = *ptrCategory.get();\n+        const std::set<std::string>& setCategories = *ptrCategory.get();\n \n         // if not debugging everything and not debugging specific category, LogPrint does nothing.\n-        if (setCategories.count(string(\"\")) == 0 &&\n-            setCategories.count(string(\"1\")) == 0 &&\n-            setCategories.count(string(category)) == 0)\n+        if (setCategories.count(std::string(\"\")) == 0 &&\n+            setCategories.count(std::string(\"1\")) == 0 &&\n+            setCategories.count(std::string(category)) == 0)\n             return false;\n     }\n     return true;\n@@ -266,7 +266,7 @@ bool LogAcceptCategory(const char* category)\n  */\n static std::string LogTimestampStr(const std::string &str, std::atomic_bool *fStartedNewLine)\n {\n-    string strStamped;\n+    std::string strStamped;\n \n     if (!fLogTimestamps)\n         return str;\n@@ -293,7 +293,7 @@ int LogPrintStr(const std::string &str)\n     int ret = 0; // Returns total number of characters written\n     static std::atomic_bool fStartedNewLine(true);\n \n-    string strTimestamped = LogTimestampStr(str, &fStartedNewLine);\n+    std::string strTimestamped = LogTimestampStr(str, &fStartedNewLine);\n \n     if (fPrintToConsole)\n     {\n@@ -561,14 +561,14 @@ void ReadConfigFile(const std::string& confPath)\n \n     {\n         LOCK(cs_args);\n-        set<string> setOptions;\n+        std::set<std::string> setOptions;\n         setOptions.insert(\"*\");\n \n         for (boost::program_options::detail::config_file_iterator it(streamConfig, setOptions), end; it != end; ++it)\n         {\n             // Don't overwrite existing settings so command line settings override bitcoin.conf\n-            string strKey = string(\"-\") + it->string_key;\n-            string strValue = it->value[0];\n+            std::string strKey = std::string(\"-\") + it->string_key;\n+            std::string strValue = it->value[0];\n             InterpretNegativeSetting(strKey, strValue);\n             if (mapArgs.count(strKey) == 0)\n                 mapArgs[strKey] = strValue;"
      },
      {
        "sha": "6e6e33184ed5a1344d7fd3b4a0aaf402a2972edb",
        "filename": "src/utilmoneystr.cpp",
        "status": "modified",
        "additions": 3,
        "deletions": 5,
        "changes": 8,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a57845c20e96825f1256e6b7f46d67d205c859e0/src/utilmoneystr.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a57845c20e96825f1256e6b7f46d67d205c859e0/src/utilmoneystr.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilmoneystr.cpp?ref=a57845c20e96825f1256e6b7f46d67d205c859e0",
        "patch": "@@ -9,16 +9,14 @@\n #include \"tinyformat.h\"\n #include \"utilstrencodings.h\"\n \n-using namespace std;\n-\n std::string FormatMoney(const CAmount& n)\n {\n     // Note: not using straight sprintf here because we do NOT want\n     // localized number formatting.\n     int64_t n_abs = (n > 0 ? n : -n);\n     int64_t quotient = n_abs/COIN;\n     int64_t remainder = n_abs%COIN;\n-    string str = strprintf(\"%d.%08d\", quotient, remainder);\n+    std::string str = strprintf(\"%d.%08d\", quotient, remainder);\n \n     // Right-trim excess zeros before the decimal point:\n     int nTrim = 0;\n@@ -33,14 +31,14 @@ std::string FormatMoney(const CAmount& n)\n }\n \n \n-bool ParseMoney(const string& str, CAmount& nRet)\n+bool ParseMoney(const std::string& str, CAmount& nRet)\n {\n     return ParseMoney(str.c_str(), nRet);\n }\n \n bool ParseMoney(const char* pszIn, CAmount& nRet)\n {\n-    string strWhole;\n+    std::string strWhole;\n     int64_t nUnits = 0;\n     const char* p = pszIn;\n     while (isspace(*p))"
      },
      {
        "sha": "74bf66fbf609ced32a920c12c3f1671c4342bb99",
        "filename": "src/utilstrencodings.cpp",
        "status": "modified",
        "additions": 24,
        "deletions": 26,
        "changes": 50,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a57845c20e96825f1256e6b7f46d67d205c859e0/src/utilstrencodings.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a57845c20e96825f1256e6b7f46d67d205c859e0/src/utilstrencodings.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utilstrencodings.cpp?ref=a57845c20e96825f1256e6b7f46d67d205c859e0",
        "patch": "@@ -12,20 +12,18 @@\n #include <errno.h>\n #include <limits>\n \n-using namespace std;\n+static const std::string CHARS_ALPHA_NUM = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n \n-static const string CHARS_ALPHA_NUM = \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789\";\n-\n-static const string SAFE_CHARS[] =\n+static const std::string SAFE_CHARS[] =\n {\n     CHARS_ALPHA_NUM + \" .,;-_/:?@()\", // SAFE_CHARS_DEFAULT\n     CHARS_ALPHA_NUM + \" .,;-_?@\", // SAFE_CHARS_UA_COMMENT\n     CHARS_ALPHA_NUM + \".-_\", // SAFE_CHARS_FILENAME\n };\n \n-string SanitizeString(const string& str, int rule)\n+std::string SanitizeString(const std::string& str, int rule)\n {\n-    string strResult;\n+    std::string strResult;\n     for (std::string::size_type i = 0; i < str.size(); i++)\n     {\n         if (SAFE_CHARS[rule].find(str[i]) != std::string::npos)\n@@ -57,7 +55,7 @@ signed char HexDigit(char c)\n     return p_util_hexdigit[(unsigned char)c];\n }\n \n-bool IsHex(const string& str)\n+bool IsHex(const std::string& str)\n {\n     for(std::string::const_iterator it(str.begin()); it != str.end(); ++it)\n     {\n@@ -67,10 +65,10 @@ bool IsHex(const string& str)\n     return (str.size() > 0) && (str.size()%2 == 0);\n }\n \n-vector<unsigned char> ParseHex(const char* psz)\n+std::vector<unsigned char> ParseHex(const char* psz)\n {\n     // convert hex dump to vector\n-    vector<unsigned char> vch;\n+    std::vector<unsigned char> vch;\n     while (true)\n     {\n         while (isspace(*psz))\n@@ -88,16 +86,16 @@ vector<unsigned char> ParseHex(const char* psz)\n     return vch;\n }\n \n-vector<unsigned char> ParseHex(const string& str)\n+std::vector<unsigned char> ParseHex(const std::string& str)\n {\n     return ParseHex(str.c_str());\n }\n \n-string EncodeBase64(const unsigned char* pch, size_t len)\n+std::string EncodeBase64(const unsigned char* pch, size_t len)\n {\n     static const char *pbase64 = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/\";\n \n-    string strRet=\"\";\n+    std::string strRet = \"\";\n     strRet.reserve((len+2)/3*4);\n \n     int mode=0, left=0;\n@@ -139,12 +137,12 @@ string EncodeBase64(const unsigned char* pch, size_t len)\n     return strRet;\n }\n \n-string EncodeBase64(const string& str)\n+std::string EncodeBase64(const std::string& str)\n {\n     return EncodeBase64((const unsigned char*)str.c_str(), str.size());\n }\n \n-vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid)\n+std::vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid)\n {\n     static const int decode64_table[256] =\n     {\n@@ -166,7 +164,7 @@ vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid)\n     if (pfInvalid)\n         *pfInvalid = false;\n \n-    vector<unsigned char> vchRet;\n+    std::vector<unsigned char> vchRet;\n     vchRet.reserve(strlen(p)*3/4);\n \n     int mode = 0;\n@@ -227,17 +225,17 @@ vector<unsigned char> DecodeBase64(const char* p, bool* pfInvalid)\n     return vchRet;\n }\n \n-string DecodeBase64(const string& str)\n+std::string DecodeBase64(const std::string& str)\n {\n-    vector<unsigned char> vchRet = DecodeBase64(str.c_str());\n-    return (vchRet.size() == 0) ? string() : string((const char*)&vchRet[0], vchRet.size());\n+    std::vector<unsigned char> vchRet = DecodeBase64(str.c_str());\n+    return (vchRet.size() == 0) ? std::string() : std::string((const char*)&vchRet[0], vchRet.size());\n }\n \n-string EncodeBase32(const unsigned char* pch, size_t len)\n+std::string EncodeBase32(const unsigned char* pch, size_t len)\n {\n     static const char *pbase32 = \"abcdefghijklmnopqrstuvwxyz234567\";\n \n-    string strRet=\"\";\n+    std::string strRet=\"\";\n     strRet.reserve((len+4)/5*8);\n \n     int mode=0, left=0;\n@@ -292,12 +290,12 @@ string EncodeBase32(const unsigned char* pch, size_t len)\n     return strRet;\n }\n \n-string EncodeBase32(const string& str)\n+std::string EncodeBase32(const std::string& str)\n {\n     return EncodeBase32((const unsigned char*)str.c_str(), str.size());\n }\n \n-vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid)\n+std::vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid)\n {\n     static const int decode32_table[256] =\n     {\n@@ -319,7 +317,7 @@ vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid)\n     if (pfInvalid)\n         *pfInvalid = false;\n \n-    vector<unsigned char> vchRet;\n+    std::vector<unsigned char> vchRet;\n     vchRet.reserve((strlen(p))*5/8);\n \n     int mode = 0;\n@@ -414,10 +412,10 @@ vector<unsigned char> DecodeBase32(const char* p, bool* pfInvalid)\n     return vchRet;\n }\n \n-string DecodeBase32(const string& str)\n+std::string DecodeBase32(const std::string& str)\n {\n-    vector<unsigned char> vchRet = DecodeBase32(str.c_str());\n-    return (vchRet.size() == 0) ? string() : string((const char*)&vchRet[0], vchRet.size());\n+    std::vector<unsigned char> vchRet = DecodeBase32(str.c_str());\n+    return (vchRet.size() == 0) ? std::string() : std::string((const char*)&vchRet[0], vchRet.size());\n }\n \n static bool ParsePrechecks(const std::string& str)"
      },
      {
        "sha": "a9936a645aa59f26bab10be5314628607adc0b4a",
        "filename": "src/utiltime.cpp",
        "status": "modified",
        "additions": 0,
        "deletions": 2,
        "changes": 2,
        "blob_url": "https://github.com/bitcoin/bitcoin/blob/a57845c20e96825f1256e6b7f46d67d205c859e0/src/utiltime.cpp",
        "raw_url": "https://github.com/bitcoin/bitcoin/raw/a57845c20e96825f1256e6b7f46d67d205c859e0/src/utiltime.cpp",
        "contents_url": "https://api.github.com/repos/bitcoin/bitcoin/contents/src/utiltime.cpp?ref=a57845c20e96825f1256e6b7f46d67d205c859e0",
        "patch": "@@ -12,8 +12,6 @@\n #include <boost/date_time/posix_time/posix_time.hpp>\n #include <boost/thread.hpp>\n \n-using namespace std;\n-\n static int64_t nMockTime = 0; //!< For unit testing\n \n int64_t GetTime()"
      }
    ]
  }
]